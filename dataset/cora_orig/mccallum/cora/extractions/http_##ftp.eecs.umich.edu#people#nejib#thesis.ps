URL: http://ftp.eecs.umich.edu/people/nejib/thesis.ps
Refering-URL: http://ftp.eecs.umich.edu/people/nejib/
Root-URL: http://www.eecs.umich.edu
Title: MODELING AND ON-LINE CONTROL OF SOFTWARE/HARDWARE SYSTEMS  
Author: by Nejib Hadj-Alouane 
Degree: A dissertation submitted in partial fulfillment of the requirements for the degree of Doctor of Philosophy  Doctoral Committee: Associate Professor Stephane Lafortune, Chairman Professor Andreas Blass Associate Professor Feng Lin Assistant Professor Stuart Sechrest  
Date: 1994  
Affiliation: (Computer Information and Control Engineering) in The University of Michigan  
Abstract-found: 0
Intro-found: 1
Reference: <institution> 177 178 BIBLIOGRAPHY </institution>
Reference: [1] <author> Michael A. Arbib. </author> <title> Theories of Abstract Automata. </title> <publisher> Prentice-Hall, Inc. </publisher>
Reference-contexts: In what follows, we review the few articles we have encountered that present, more or less, a formal approach to assembly. Two fundamental ways of interconnecting (or assembling) systems are the series 59 and parallel interconnections [86]. In <ref> [1] </ref>, such interconnections are illustrated for finite state machines (FSM) with output; the state space of the interconnection is the Cartesian product of the state spaces of the constituents; and, in the case of the series interconnection, the output of one machine feeds into the input of the other.
Reference: [2] <author> E. Astesiano and G. Reggio. </author> <title> Direct semantics of concurrent languages in the smolcs approach. </title> <journal> The IBM Journal of Research and Development, </journal> <volume> 31(5), </volume> <month> September </month> <year> 1987. </year>
Reference-contexts: To cope with this problem, nonstandard denotational semantics (as opposed to the standard one outlined above) is used. In this approach, the denotations are processes (see for example [66]) that model interleaving 3 ; for example, <ref> [2] </ref> uses this approach to define the semantics of a subset of Ada. 2.3.2 Operational Semantics The operational approach describes the semantics of a programming language by defining an abstract state machine, essentially an interpreter; the state of this machine records the essential information regarding the progress of a given program
Reference: [3] <author> E. Astesiano and G. Reggio. </author> <title> The smolcs approach to the formal semantics of programming languages. </title> <editor> In G. Goos and J. Hartmanis, editors, </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> volume 275. </volume> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: A good informal introduction to denotational semantics is given in <ref> [3, 28, 40] </ref>; for an elaborate and rigorous discussion, especially of the underlying mathematics, consult [94]. Consider a simple language, such as the one defined in [94, pages 12-14], consisting of two kinds of constructs: commands and expressions.
Reference: [4] <author> S. Balemi, G.J. Hoffmann, P. Gyugyi, H. Wong-Toi, </author> <title> and G.F. Franklin. Supervisory control of a rapid thermal multiprocessor. </title> <journal> Joint issue Automatica and IEEE Trans. </journal> <volume> Autom. </volume> <booktitle> Control on Meeting the Challenge of Computer Science in the Industrial Applications of Control, </booktitle> <year> 1993. </year>
Reference-contexts: is certainly a complex, time consuming and error prone operation. 5 For the purpose of control we adopt event-based models and the widely accepted supervisory control strategy (based on these models) initiated by Ramadge and Won-ham [78, 99] which has been successfully applied to manufacturing and other software/hardware systems (see <ref> [4, 10, 47] </ref>)). Event-based models (reviewed in Chapter II) capture the system dynamics as event sequences.
Reference: [5] <editor> Avron Barr and Edward A. Feigenbaum, editors. </editor> <booktitle> The Handbook of Artificial Intelligence, </booktitle> <volume> volume 1. </volume> <publisher> William Kaufmann, Inc., </publisher> <year> 1981. </year>
Reference-contexts: For an introduction to first-order logic see [32]; a more elaborate discussion of logic can be found in [16]. Rules are a construct of Artificial Intelligence typically used in conjunction with expert systems (see <ref> [5, 82] </ref>). Each model uses a first-order many-sorted [32] language to describe all the snapshots configurations- of a software/hardware system. This language is divided into two categories of symbols: the static and the dynamic symbols. The static symbols 24 are used to model the non-changing, static aspects of the system. <p> Following the second way, hopefully, requires less work than the first way and reduces the possibility of error since the models of the constituents are usually proven before being used. Moreover, the second way has the 3 We have in mind the kind of Ada <ref> [5] </ref> private declarations here. 39 potential of being automated, at least to some extent. Here, we follow the second way and develop a method for assembling models of software/hardware components, which we present in this section.
Reference: [6] <author> N. Ben Hadj-Alouane, J. K. Chaar, and A. W. Naylor. </author> <title> The Design and Implementation of the Control and Integaration Software of a Flexible Manufacturing System. </title> <booktitle> In The First International Conference on Systems Integration, </booktitle> <month> April 23-26 </month> <year> 1990. </year>
Reference-contexts: The total picture can get very complicated and is simply beyond the grasp of a human mind. In prior work (see <ref> [6, 7] </ref>), we have developed a methodology for designing computer-integrated manufacturing control software (which also applies to other embedded systems) that addresses the above hurdles. It is based on the following guidelines, among others: 1.
Reference: [7] <author> N. Ben Hadj-Alouane, J. K. Chaar, and A. W. Naylor. </author> <title> Developing Control and Integaration Software of a Flexible Manufacturing Systems. </title> <journal> Journal of Systems Integration, </journal> <volume> (1), </volume> <year> 1991. </year>
Reference-contexts: The total picture can get very complicated and is simply beyond the grasp of a human mind. In prior work (see <ref> [6, 7] </ref>), we have developed a methodology for designing computer-integrated manufacturing control software (which also applies to other embedded systems) that addresses the above hurdles. It is based on the following guidelines, among others: 1. <p> This thesis expands on the above concepts by contributing to the software specification process and the development of generic control algorithms. 1.2 The Objective and Contributions of this Thesis The formalism of [71], originally developed for modeling manufacturing systems, has been shown suitable for specifying software/hardware components (see <ref> [7, 73] </ref>); and we intend to use it here for that purpose. There are three main reasons behind this decision; first, the formalism is able to capture true parallelism and time. Second, it can be applied uniformly to model the blending of software and hardware in software/hardware components. <p> In fact, off-line synthesis poses additional difficulties in the case of flexible manufacturing systems where the system model is constantly changing (time varying) as a result of changes in the process plans (in fact in <ref> [7] </ref> we advocate that the factory/cell and the process plans should be modeled separately and combined as needed, to enhance the reuse of these models). In the second part of this thesis we develop an on-line approach to supervisory control synthesis which avoids the above pitfalls. <p> From the specification side we have developed a method for assembling rule-based models of software/hardware components, with the aim of simplifying the specification task and reducing the specification effort. Rule-based models have proven to be powerful specification tools for software/hardware systems (see [73] and <ref> [7] </ref>). This is chiefly due to their capability to capture true parallelism and time, in addition to their grounding in first-order logic.
Reference: [8] <author> Grady Booch. </author> <title> Software Engineering With Ada. </title> <publisher> The Benjamin/Cummings Publishing Company, Inc., </publisher> <address> second edition, </address> <year> 1987. </year>
Reference-contexts: This fraction is rapidly increasing as manufacturing systems get more automated; it is expected to reach close to two thirds in the near future [83]. Similar statistics have also been reported about other kinds of embedded software <ref> [8, 15] </ref>.
Reference: [9] <author> B.A. Brandin and W.M. Wonham. </author> <title> Supervisory control of timed discrete-event systems. </title> <journal> IEEE Trans. Automatic Control, </journal> <volume> 39(2) </volume> <pages> 329-342, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: The first involves extending the VLP-S algorithm to handle timed models. Currently there are several approaches dealing with timed models from a control perspective. The approach of <ref> [9] </ref> blends easily with our on-line scheme (an application of this approach to manufacturing systems can be found in [11]). Under this approach, events take time to execute; more specifically, each event is associated with a time interval, and when enabled the event will occur somewhere in that interval. <p> These events capture the fact that a hard deadline is reached on a particular event and that the execution of the event must be somehow "forced". A new version of controllability which accounts for the effect of forcing is developed in <ref> [9] </ref>, and the existence of supervisors is characterized in terms of this new condition. Supervisor synthesis in [9], however, is approached in an off-line fashion. <p> A new version of controllability which accounts for the effect of forcing is developed in <ref> [9] </ref>, and the existence of supervisors is characterized in terms of this new condition. Supervisor synthesis in [9], however, is approached in an off-line fashion. In the case of timed models, there is an added problem to the typical problems associated with off-line synthesis: In the process of untiming the original model, an exponential state explosion occurs.
Reference: [10] <author> B.A. Brandin, W.M. Wonham, and B. Benhabib. </author> <title> Discrete event system supervisory control applied to the management of manufacturing workcells. </title> <editor> In V.C. Venkatesh and J.A. McGeough, editors, </editor> <booktitle> Proc. of 7th International Conference on Computer-Aided Production Engineering, </booktitle> <pages> pages 527-536, </pages> <address> Cookeville, TN, USA, </address> <month> August </month> <year> 1991. </year> <note> Elsevier. 179 </note>
Reference-contexts: is certainly a complex, time consuming and error prone operation. 5 For the purpose of control we adopt event-based models and the widely accepted supervisory control strategy (based on these models) initiated by Ramadge and Won-ham [78, 99] which has been successfully applied to manufacturing and other software/hardware systems (see <ref> [4, 10, 47] </ref>)). Event-based models (reviewed in Chapter II) capture the system dynamics as event sequences.
Reference: [11] <author> B.A. Brandin, W.M. Wonham, and B. Benhabib. </author> <title> Manufacturing cell supervisory control a timed discrete event system approach. </title> <booktitle> In Proc. of the 1992 IEEE Conf. on Robotics and Automation, </booktitle> <address> Nice, France, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: The first involves extending the VLP-S algorithm to handle timed models. Currently there are several approaches dealing with timed models from a control perspective. The approach of [9] blends easily with our on-line scheme (an application of this approach to manufacturing systems can be found in <ref> [11] </ref>). Under this approach, events take time to execute; more specifically, each event is associated with a time interval, and when enabled the event will occur somewhere in that interval.
Reference: [12] <author> R. D. Brandt, V. Garg, R. Kumar, F. Lin, S. I. Marcus, and W. M. Won-ham. </author> <title> Formulas for calculating supremal controllable and normal sublanguages. </title> <journal> Systems and Control Letters, </journal> <volume> 15(2) </volume> <pages> 111-117, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: (K) , s 2 K): As it turns out, the supremal controllable and normal sublanguage of the legal language K, denoted by supCN (K), also exists and is often offered as a solution to partial observation supervision problems; see e.g., [26, 63] (the computation of supCN (K) is addressed in <ref> [12, 18, 65] </ref>). In this thesis, we improve on this situation by specifying the appropriate parameters that force our algorithms to synthesize 66 partial observation supervisors that include the supremal controllable and normal sublanguage as part of the generated behavior.
Reference: [13] <author> Giorgio Bruno and Paolo Biglia. </author> <title> Performance evaluation and validation of tool handling in flexible manufacturing systems. </title> <booktitle> In 1985 International Workshop on Timed Petri Nets, </booktitle> <pages> pages 64-71, </pages> <month> July 1-3. </month>
Reference-contexts: The main advantage of Petri Nets over the rule-based formalism of [71] (and some of the event-based models discussed in the previous subsection) is their intuitive graphical representation [36]. This advantage quickly becomes a drawback when Petri Nets are used to model real computer-integrated manufacturing systems <ref> [13] </ref>. The large amount of detail that needs to be captured often results in big and unmanageable Petri Net graphs. To overcome this problem, several modifications and additions have been introduced. Colored Petri Nets (see for example, [33], [39], [97], [13] and [50]) provide a compact graphical representation of ordinary Petri <p> Petri Nets are used to model real computer-integrated manufacturing systems <ref> [13] </ref>. The large amount of detail that needs to be captured often results in big and unmanageable Petri Net graphs. To overcome this problem, several modifications and additions have been introduced. Colored Petri Nets (see for example, [33], [39], [97], [13] and [50]) provide a compact graphical representation of ordinary Petri Nets. In a colored Petri Net, analogous events are merged into a single transition and the colors associated with the tokens are used to distinguish among the various instances of the transition. <p> Other kinds of Petri Nets have been proposed to overcome other problems. See [81] for timed PNS, <ref> [37, 13] </ref> for stochastic PNS, [90, 103] for augmented PNS, [27, 95] for GRAFCETS and [14] for PROT Nets. Timed Petri Nets associate a time constant with each transition (the time it takes the action represented by the transition to execute).
Reference: [14] <author> Giorgio Bruno and Giuseppe Marchetto. </author> <title> Process-translatable petri nets for the rapid prototyping of process control systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> February </month> <year> 1986. </year>
Reference-contexts: Other kinds of Petri Nets have been proposed to overcome other problems. See [81] for timed PNS, [37, 13] for stochastic PNS, [90, 103] for augmented PNS, [27, 95] for GRAFCETS and <ref> [14] </ref> for PROT Nets. Timed Petri Nets associate a time constant with each transition (the time it takes the action represented by the transition to execute).
Reference: [15] <author> Jean Paul Calvez. </author> <title> Embedded real-time systems. </title> <address> Chichester, New York : J. </address> <publisher> Wiley, </publisher> <year> 1993. </year>
Reference-contexts: This fraction is rapidly increasing as manufacturing systems get more automated; it is expected to reach close to two thirds in the near future [83]. Similar statistics have also been reported about other kinds of embedded software <ref> [8, 15] </ref>.
Reference: [16] <author> C. C. Chang and H. J. Keisler. </author> <title> Model Theory. </title> <publisher> North-Holland Publishing Company. </publisher>
Reference-contexts: For an introduction to first-order logic see [32]; a more elaborate discussion of logic can be found in <ref> [16] </ref>. Rules are a construct of Artificial Intelligence typically used in conjunction with expert systems (see [5, 82]). Each model uses a first-order many-sorted [32] language to describe all the snapshots configurations- of a software/hardware system.
Reference: [17] <author> E. Chen and S. Lafortune. </author> <title> Dealing with blocking in supervisory control of discrete event systems. </title> <journal> IEEE Trans. Automatic Control, </journal> <volume> 36(6) </volume> <pages> 724-735, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: The most important part of this research, however, needs to address the question of a satisficing solution for the purpose of relieving this tremendous computational burden; here techniques similar to the ones studied in <ref> [17] </ref>, where blocking is not strictly avoided, coupled with limited lookahead, need to be investigated.
Reference: [18] <author> H. Cho and S. I. Marcus. </author> <title> On supremal languages of classes of sublanguages that arise in supervisor synthesis problems with partial observation. </title> <journal> Math. Control Signals Systems, </journal> <volume> 2 </volume> <pages> 47-69, </pages> <year> 1989. </year>
Reference-contexts: (K) , s 2 K): As it turns out, the supremal controllable and normal sublanguage of the legal language K, denoted by supCN (K), also exists and is often offered as a solution to partial observation supervision problems; see e.g., [26, 63] (the computation of supCN (K) is addressed in <ref> [12, 18, 65] </ref>). In this thesis, we improve on this situation by specifying the appropriate parameters that force our algorithms to synthesize 66 partial observation supervisors that include the supremal controllable and normal sublanguage as part of the generated behavior.
Reference: [19] <author> H. Cho and S. I. Marcus. </author> <title> Supremal and maximal sublanguages arising in supervisor synthesis problems with partial observations. </title> <journal> Math. Systems Theory, </journal> <volume> 22 </volume> <pages> 177-211, </pages> <year> 1989. </year>
Reference-contexts: VLP-PO is best viewed as an extension of the VLP-S algorithm of Chpater V to the case of partially-observed systems, but for the special case of prefix-closed legal languages. Properties (ii)-(vi) of VLP-PO, listed above, are in contrast with the properties of the algorithms proposed in [45]. In <ref> [19] </ref> an off-line method for generating a maximal observable and controllable sublanguage of the legal language for prefix-closed languages is presented.
Reference: [20] <author> S. L. Chung. </author> <title> Control of Discrete Event Systems Using Limited Lookahead Policies. </title> <type> PhD thesis, </type> <institution> Department of Electrical Engineering and Computer Science, University of Michigan, </institution> <address> Ann Arbor, MI, </address> <month> July </month> <year> 1992. </year>
Reference-contexts: A key advantage of this control scheme is the decoupling of the open loop behavior of the system (or model) from its behavior under feedback control <ref> [20] </ref>; this is one of the properties that must be satisfied by a generic and flexible controller (most manufacturing systems models capture the closed loop dynamics of the system thereby restricting the system to operate under one kind of "specification").
Reference: [21] <author> S. L. Chung, S. Lafortune, and F. Lin. </author> <title> Addendum to "Limited lookahead policies in supervisory control of discrete event systems": Proofs of technical results. </title> <type> Technical Report CGR-92-6, </type> <institution> College of Engineering Control Group Reports, University of Michigan, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: Observe that, soe 2 K " ) s 2 K " ^ K " =soe 6= ; ) s 2 K " ^ (K=soe) "=soe 6= ; [when soe 2 K " , K " =soe = (K=soe) "=soe , by Theorem A.1 of <ref> [21] </ref>]. Consider (K=soe) "=soe . It is nonempty; moreover, by definition, it is controllable w.r.t. L (G)=soe and it is a subset of K=soe. But, K=soe = K=ffi (x 0 ; soe) and L (G)=soe = L (G)=ffi (x 0 ; soe).
Reference: [22] <author> S. L. Chung, S. Lafortune, and F. Lin. </author> <title> Limited lookahead policies in supervisory control of discrete event systems. </title> <journal> IEEE Trans. Automatic Control, </journal> <volume> 37(12) </volume> <pages> 1921-1935, </pages> <month> December </month> <year> 1992. </year> <month> 180 </month>
Reference-contexts: Moreover, if the system and specification have a special structure, the distributed algorithm computes the exact same policies as its sequential counterpart (i.e., maximals are generated and all other properties of sequential policies apply). We also incorporated the so-called limited lookahead policies (LLPs) first presented in <ref> [22] </ref> and further studied in [23, 25, 24], as part of our on-line supervisory control scheme. When limited lookahead is used in on-line supervisory control, the current control action is determined based on only part of the future behavior of the system (say, N steps ahead). <p> In this thesis, we improve on this situation by specifying the appropriate parameters that force our algorithms to synthesize 66 partial observation supervisors that include the supremal controllable and normal sublanguage as part of the generated behavior. Limited lookahead supervisory control policies, or LLPs, were introduced in <ref> [22] </ref> and further elaborated in [23, 25, 24]. <p> Third, a dynamic programming technique is applied to the N -level tree to determine the control action at s. In <ref> [22] </ref> it is proved that (1) the conservative policy always results in legal behavior, but may produce a "starting error" (2) the optimistic policy performs better than the conservative one, but may incur illegal behavior (a "run-time error"), and (3) upper bounds on N were derived to guarantee optimality, or validity <p> Under the general framework adopted in this thesis, we propose to synthesize control policies for SSCP on-line, and by computing each control action as needed, following the execution of each system event. Moreover, we propose to incorporate the so-called limited lookahead scheme which was first presented in <ref> [22] </ref> and further studied in [25, 23, 24], as part of this on-line synthesis method. When limited looka 70 71 head is used in supervisory control, the current control action is determined on-line based on only part of the future behavior of the system (say, N steps ahead). <p> This algorithm, abbreviated VLP-S, assumes that no bound (N ) is imposed on the available system behavior (i.e., no limited lookahead is being used). * In Section 5.3.2, we prove that (1) VLP-S is always correct (or valid in the terminology of <ref> [22] </ref>) in the sense that it achieves, on-line, the optimal off-line solution of SSCP and (2) in the worst case, the computational complexity of VLP-S is quadratic in the size of the state space of the system. <p> We take the same approach as <ref> [22] </ref> (which assumes no knowledge of the state); i.e., we compute the control action at s based on the above information and on one of two attitudes, conservative or optimistic. In this regard, we address three issues. First, we illustrate how VLP-S can be modified to accommodate the above situation. <p> In this regard, we address three issues. First, we illustrate how VLP-S can be modified to accommodate the above situation. Second, we briefly discuss the performance of the resulting control policies and formulate a sufficient bound on N that guarantees their optimality. This bound improves the ones given in <ref> [22] </ref>, since it is always finite in the case of finite state machines. Finally, we give practical suggestions 98 s" x that can improve the efficiency of an implementation of the algorithm, both in terms of the computational effort and in terms of the "quality" of the resulting behavior. <p> If a conservative policy is adopted, states 3, 9 and 10 are assigned the cost 1. Running the remaining steps of the algorithm results in all the expanded states being assigned the cost 1. Since the initial state 1 has cost 1, a so-called starting error (SE) results <ref> [22] </ref> (i.e., there is no control action, including the empty string, that based on the given information can guarantee the legality of the behavior of the system). If an optimistic policy is adopted, states 3, 9 and 10 are assigned cost 0. <p> The resulting control action consists of enabling all events from state 1. Notice that if the system executes C 1 or 100 C 2 next, there is the possibility of the system eventually moving to state 5 where a so-called runtime error (RTE) is sure to result <ref> [22] </ref> (i.e., blocking cannot be avoided in this case). Notice that in the case of the conservative policy, choosing N 3 eliminates the starting error. <p> The results concerning the performance of the limited lookahead policies that were presented in <ref> [22] </ref> are all applicable in the case of the above VLP-S algorithm. Obviously, the proofs given in [22] are not applicable here. Nevertheless, for the purpose of brevity, we simply enumerate these results and refrain from proving them. <p> The results concerning the performance of the limited lookahead policies that were presented in <ref> [22] </ref> are all applicable in the case of the above VLP-S algorithm. Obviously, the proofs given in [22] are not applicable here. Nevertheless, for the purpose of brevity, we simply enumerate these results and refrain from proving them. We note, however, that the new proofs closely follow the old proofs while using arguments and results similar to the ones used in the proof of Lemma 6. <p> It is important to note that the control policies resulting from the VLP-S algorithm outlined above perform at least as well as the polices given in <ref> [22] </ref>. <p> following two propositions hold. * L (G; fl N optm;new ) L (G; fl N optm;old ) * L (G; fl N cons;old ) L (G; fl N cons;new ) The label "new" refers to the policies resulting from the above VLP-S algorithm while "old" refers to the policies of <ref> [22] </ref>. The above two propositions hold for the same reasons, given above, to justify the necessity of a breadth-first expansion. <p> The desired bound is then given as, N B = max jw (x; s)j: 102 If G is finite state then N B is well-defined; this is not necessarily the case for the bounds given in <ref> [22] </ref>, however (since states are not used in the algorithms of [22], for example a regular language involving a loop of uncontrollable events could incur an infinite bound). <p> The desired bound is then given as, N B = max jw (x; s)j: 102 If G is finite state then N B is well-defined; this is not necessarily the case for the bounds given in <ref> [22] </ref>, however (since states are not used in the algorithms of [22], for example a regular language involving a loop of uncontrollable events could incur an infinite bound). Obviously, there are infinite state systems for which the above bound is finite; however, such finiteness must be proved for each individual system. <p> In such a situation a starting error SE- is said to occur <ref> [22] </ref> (the system cannot be safely started, or it will generate an erroneous behavior no matter how it is started). The notion of an SE is formalized below. <p> We then use basically the same VLP-PO algorithm given in Section 6.2.1 with the following modification: The legality of pending states on the boundary (N th level states) depends on the attitude adopted (see <ref> [22] </ref> and Chapter V). <p> Corollary 20 If K " 6= ;, then L (G; fl N p;cons ) K. With limited lookahead under complete observation, we find that the language resulting from the conservative policy increases monotonically as the window size N increases (see <ref> [22] </ref> and Chapter V). This is not the case for limited lookahead under partial observation, as demonstrated by the following example. Example 10 Let = uo = c = fff; fig, L (G) = (ff + fi)(fffffffi + fiff) and K = (ff + fi)(fffffffi + fi).
Reference: [23] <author> S. L. Chung, S. Lafortune, and F. Lin. </author> <title> Recursive computation of limited looka-head supervisory controls for discrete event systems. Journal of Discrete Event Dynamic Systems: </title> <journal> Theory and Applications, </journal> <volume> 3(1) </volume> <pages> 71-100, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: We also incorporated the so-called limited lookahead policies (LLPs) first presented in [22] and further studied in <ref> [23, 25, 24] </ref>, as part of our on-line supervisory control scheme. When limited lookahead is used in on-line supervisory control, the current control action is determined based on only part of the future behavior of the system (say, N steps ahead). <p> Limited lookahead supervisory control policies, or LLPs, were introduced in [22] and further elaborated in <ref> [23, 25, 24] </ref>. In this scheme, it is assumed that during the system operation, only the possible future event traces of length less than or equal to N , for a given fixed N , are available; the legality/illegality of these traces is also assumed to be known. <p> Moreover, we propose to incorporate the so-called limited lookahead scheme which was first presented in [22] and further studied in <ref> [25, 23, 24] </ref>, as part of this on-line synthesis method. When limited looka 70 71 head is used in supervisory control, the current control action is determined on-line based on only part of the future behavior of the system (say, N steps ahead).
Reference: [24] <author> S. L. Chung, S. Lafortune, and F. Lin. </author> <title> Supervisory control with variable looka-head policies: Illustrative example. </title> <editor> In S. Balemi, P. Kozak, and R. Smedinga, editors, </editor> <booktitle> Discrete Event Systems: Modeling and Control Proceedings of a Joint Workshop on Discrete Event Systems, </booktitle> <pages> pages 207-214. </pages> <publisher> Birkhauser Basel Verlag, </publisher> <year> 1993. </year>
Reference-contexts: We also incorporated the so-called limited lookahead policies (LLPs) first presented in [22] and further studied in <ref> [23, 25, 24] </ref>, as part of our on-line supervisory control scheme. When limited lookahead is used in on-line supervisory control, the current control action is determined based on only part of the future behavior of the system (say, N steps ahead). <p> Limited lookahead supervisory control policies, or LLPs, were introduced in [22] and further elaborated in <ref> [23, 25, 24] </ref>. In this scheme, it is assumed that during the system operation, only the possible future event traces of length less than or equal to N , for a given fixed N , are available; the legality/illegality of these traces is also assumed to be known. <p> Moreover, we propose to incorporate the so-called limited lookahead scheme which was first presented in [22] and further studied in <ref> [25, 23, 24] </ref>, as part of this on-line synthesis method. When limited looka 70 71 head is used in supervisory control, the current control action is determined on-line based on only part of the future behavior of the system (say, N steps ahead).
Reference: [25] <author> S. L. Chung, S. Lafortune, and F. Lin. </author> <title> Supervisory control using variable lookahead policies. Journal of Discrete Event Dynamic Systems: </title> <booktitle> Theory and Applications, </booktitle> <year> 1994. </year>
Reference-contexts: We also incorporated the so-called limited lookahead policies (LLPs) first presented in [22] and further studied in <ref> [23, 25, 24] </ref>, as part of our on-line supervisory control scheme. When limited lookahead is used in on-line supervisory control, the current control action is determined based on only part of the future behavior of the system (say, N steps ahead). <p> Limited lookahead supervisory control policies, or LLPs, were introduced in [22] and further elaborated in <ref> [23, 25, 24] </ref>. In this scheme, it is assumed that during the system operation, only the possible future event traces of length less than or equal to N , for a given fixed N , are available; the legality/illegality of these traces is also assumed to be known. <p> Moreover, we propose to incorporate the so-called limited lookahead scheme which was first presented in [22] and further studied in <ref> [25, 23, 24] </ref>, as part of this on-line synthesis method. When limited looka 70 71 head is used in supervisory control, the current control action is determined on-line based on only part of the future behavior of the system (say, N steps ahead). <p> Both of these results are improvements upon the properties of the related VLP algorithm with no state information presented in <ref> [25] </ref>.
Reference: [26] <author> R. Cieslak, C. Desclaux, A. Fawaz, and P. Varaiya. </author> <title> Supervisory control of discrete-event processes with partial observations. </title> <journal> IEEE Trans. Automatic Control, </journal> <volume> 33(3) </volume> <pages> 249-260, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: However, most work in the area of supervisor synthesis has focused on off-line supervisor synthesis methods which suffer from problems related to computational complexity and state-space explosion <ref> [26, 63, 79, 78, 96, 99] </ref>. <p> In [63], a new constraint is added the SSCP: The set is also partitioned into the subset of observable events, o , and the subset of unobservable events, uo . Variation on this constraint are also considered in <ref> [26] </ref>. The projection, P : fl ! fl o defined by, 8 &gt; &gt; &gt; &gt; &gt; &gt; &gt; : P (s) if oe 2 uo ; characterizes the behavior observed by the supervisor, namely P (L (G)). <p> is normal if, (8s 2 L (G))(P (s) 2 P (K) , s 2 K): As it turns out, the supremal controllable and normal sublanguage of the legal language K, denoted by supCN (K), also exists and is often offered as a solution to partial observation supervision problems; see e.g., <ref> [26, 63] </ref> (the computation of supCN (K) is addressed in [12, 18, 65]). In this thesis, we improve on this situation by specifying the appropriate parameters that force our algorithms to synthesize 66 partial observation supervisors that include the supremal controllable and normal sublanguage as part of the generated behavior. <p> We restrict ourselves to situation where the system language and the legal language are not be prefix-closed. This problem was first studied in <ref> [26, 63, 78] </ref> where it is determined that, unlike in the full observation case, a supremal controllable and observable sublanguage of the given legal language may not always exist; instead there may be several maximal controllable and observable sublanguages of the legal language (a good survey of these results appears in <p> Section 7.6 discusses the two special cases of modular control and of control under complete event observations. 7.2 Observations on On-line Decentralized Supervisory Con trol Decentralized formulations of supervisory control problems have been addressed in <ref> [26, 60, 62, 85] </ref>. The general formulation (see [85]) involves two or more "local" supervisors, each having its local subsets of observable and controllable events (in [60] certain restrictions are imposed on the observable and controllable subsets; these restrictions help with the important issue of synthesis).
Reference: [27] <institution> Le Groupe de Travail Systemes Logiques de L'AFCET. Pour une representation normalise du cahier de charge d'un automatisme logique. Automatique et Informatique, </institution> <month> (61-62), November-December </month> <year> 1977. </year>
Reference-contexts: Hence, the state of an event graph model is often augmented with a set of variables (that keep track of details of the system state) and each of its arcs is associated with a constant time delay, a condition and an action. Event graphs closely resemble GRAFCETS <ref> [27] </ref>, reviewed later. Finitely recursive processes (intimately related to the work of [46]) have also been used to model manufacturing systems in see [48]. <p> Other kinds of Petri Nets have been proposed to overcome other problems. See [81] for timed PNS, [37, 13] for stochastic PNS, [90, 103] for augmented PNS, <ref> [27, 95] </ref> for GRAFCETS and [14] for PROT Nets. Timed Petri Nets associate a time constant with each transition (the time it takes the action represented by the transition to execute).
Reference: [28] <author> James E. Donahue. </author> <title> Complementary definitions of programming language semantics. </title> <editor> In G. Goos and J. Hartmanis, editors, </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> volume 42. </volume> <publisher> Springer-Verlag, </publisher> <year> 1976. </year>
Reference-contexts: A good informal introduction to denotational semantics is given in <ref> [3, 28, 40] </ref>; for an elaborate and rigorous discussion, especially of the underlying mathematics, consult [94]. Consider a simple language, such as the one defined in [94, pages 12-14], consisting of two kinds of constructs: commands and expressions.
Reference: [29] <author> H. Ehrig E. K. Blum and F. Parisis-Presicce. </author> <title> Algebraic specification of modules and their basic interconnections. </title> <journal> Journal of Computer and System Sciences, </journal> <year> 1987. </year>
Reference-contexts: Algebraic specifications of abstract data types [30] and modules <ref> [29] </ref> do not rely on an underlying language; however, they do not handle (as they have been used) parallelism and real-time. <p> to have a counter part in sort j, and vice-versa; otherwise, the two sorts i and j can simply be collapsed into one sort and the use of many-sorted equality can be avoided, a common practice used by the algebraic techniques for specifying data types and modules (see [30] and <ref> [29] </ref>). The advantage of our approach over the algebraic specification techniques is that it can be used to assemble models that are arbitrarily structured.
Reference: [30] <author> H. Ehrig and B. Mahr. </author> <title> Fundamentals of Algebraic Specification1. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Algebraic specifications of abstract data types <ref> [30] </ref> and modules [29] do not rely on an underlying language; however, they do not handle (as they have been used) parallelism and real-time. <p> sort i to have a counter part in sort j, and vice-versa; otherwise, the two sorts i and j can simply be collapsed into one sort and the use of many-sorted equality can be avoided, a common practice used by the algebraic techniques for specifying data types and modules (see <ref> [30] </ref> and [29]). The advantage of our approach over the algebraic specification techniques is that it can be used to assemble models that are arbitrarily structured.
Reference: [31] <author> S. E. Elmaghraby. </author> <title> Activity Networks: Project Planning and Control by Network Models. </title> <publisher> John Wiley and Sons, </publisher> <year> 1977. </year>
Reference-contexts: Activity and 12 PERT networks (see for example <ref> [31] </ref>, [67] and [70]) are also used to model manufacturing systems for the purpose of performance evaluation. The critical path method (CPM) is the simplest technique used in analyzing these networks (it allows to determine critical jobs, resources and so forth).
Reference: [32] <author> Herbert B. Enderton. </author> <title> A Mathematical Introduction to Logic. </title> <publisher> Academic Press, Inc., </publisher> <year> 1972. </year>
Reference-contexts: For an introduction to first-order logic see <ref> [32] </ref>; a more elaborate discussion of logic can be found in [16]. Rules are a construct of Artificial Intelligence typically used in conjunction with expert systems (see [5, 82]). Each model uses a first-order many-sorted [32] language to describe all the snapshots configurations- of a software/hardware system. <p> For an introduction to first-order logic see <ref> [32] </ref>; a more elaborate discussion of logic can be found in [16]. Rules are a construct of Artificial Intelligence typically used in conjunction with expert systems (see [5, 82]). Each model uses a first-order many-sorted [32] language to describe all the snapshots configurations- of a software/hardware system. This language is divided into two categories of symbols: the static and the dynamic symbols. The static symbols 24 are used to model the non-changing, static aspects of the system. <p> Also, if the time expression that appears at the right side of a change such as the ones resulting from system failures. 6 A sentence is a formula with no free variable <ref> [32] </ref>. 26 equals t, the change is said to be instantaneous; if all the changes of a rule-based model are instantaneous, the model does not capture time, and for convenience, the time variable t that appears at the right and left sides of the changes can be removed (generally speaking, the <p> The usage of existential quantifier in the above change is very simple and what and how information is passed to the right side is clear. Unfortunately, this is not always the case, things can get much more complicated. To avoid ambiguity, we Skolemize <ref> [32, page 274] </ref> the left and right sides. A constant P s , not in the language, is used in place of the variable y, both at the left and right sides of the change, and the existential quantifier is removed 8 .
Reference: [33] <author> Frank DiCesare Era Kasturia and Alan Desrochers. </author> <title> Real time control of multilevel manufacturing systems using colored petri nets. </title> <booktitle> In Proceedings 1988 IEEE International conference on Robotics and Automation, </booktitle> <pages> pages 1114-1119, </pages> <month> April 24-29. </month>
Reference-contexts: The large amount of detail that needs to be captured often results in big and unmanageable Petri Net graphs. To overcome this problem, several modifications and additions have been introduced. Colored Petri Nets (see for example, <ref> [33] </ref>, [39], [97], [13] and [50]) provide a compact graphical representation of ordinary Petri Nets. In a colored Petri Net, analogous events are merged into a single transition and the colors associated with the tokens are used to distinguish among the various instances of the transition. <p> Hierarchical Petri Nets have also been proposed as a solution to the size problem (see for example <ref> [35, 39, 33, 102] </ref>).
Reference: [34] <author> B. Carriere et al. </author> <title> A c.a.d. system for a process control based upon a standard. </title> <editor> In R. E. A. Mason, editor, </editor> <booktitle> Information Processing 83, </booktitle> <pages> pages 507-512. </pages> <publisher> Elsevier Science Publishers B. V. (North-Holland), </publisher> <year> 1983. </year> <month> 181 </month>
Reference-contexts: Finally, it should be pointed out that, in a way similar to hierarchical Petri Nets, GRAFCETs adhere to a hierarchical representation of systems <ref> [34] </ref>. PROT Nets also associate conditions and actions with Petri Net transitions. However, the actions are associated with the outgoing arcs of transitions instead of their output places.
Reference: [35] <author> D. Crockett et al. </author> <title> Implementation of a petri net controller for a machining workstation. </title> <booktitle> In Proceedings 1987 IEEE International conference on Robotics and Automation, </booktitle> <pages> pages 1861-1867, </pages> <address> March 31-April 3. </address>
Reference-contexts: Hierarchical Petri Nets have also been proposed as a solution to the size problem (see for example <ref> [35, 39, 33, 102] </ref>). <p> Hierarchical Petri Nets have also been proposed as a solution to the size problem (see for example [35, 39, 33, 102]). In <ref> [35] </ref>, a hierarchy of Petri Nets is used to capture a manufacturing system, at different levels of detail; Petri Nets at the top levels of this hierarchy (all the levels above the bottom level) have places that are themselves Petri Nets, and are called macro places [35]. <p> In <ref> [35] </ref>, a hierarchy of Petri Nets is used to capture a manufacturing system, at different levels of detail; Petri Nets at the top levels of this hierarchy (all the levels above the bottom level) have places that are themselves Petri Nets, and are called macro places [35]. Other kinds of Petri Nets have been proposed to overcome other problems. See [81] for timed PNS, [37, 13] for stochastic PNS, [90, 103] for augmented PNS, [27, 95] for GRAFCETS and [14] for PROT Nets.
Reference: [36] <author> Z. N. Cai et al. </author> <title> Petri nets for robot lattices. </title> <booktitle> In Proceedings 1987 IEEE International conference on Robotics and Automation, </booktitle> <pages> pages 999-1004, </pages> <address> March 31-April 3. </address>
Reference-contexts: The main advantage of Petri Nets over the rule-based formalism of [71] (and some of the event-based models discussed in the previous subsection) is their intuitive graphical representation <ref> [36] </ref>. This advantage quickly becomes a drawback when Petri Nets are used to model real computer-integrated manufacturing systems [13]. The large amount of detail that needs to be captured often results in big and unmanageable Petri Net graphs. To overcome this problem, several modifications and additions have been introduced.
Reference: [37] <author> G. Franceschinis G. Balbo, G. Ghiola and G. Molinar Roet. </author> <title> Generalized stochastic petri nets for the performance evaluation of fms. </title> <booktitle> In Proceedings 1987 IEEE International conference on Robotics and Automation, </booktitle> <pages> pages 1013-1018, </pages> <address> March 31-April 3. </address>
Reference-contexts: Other kinds of Petri Nets have been proposed to overcome other problems. See [81] for timed PNS, <ref> [37, 13] </ref> for stochastic PNS, [90, 103] for augmented PNS, [27, 95] for GRAFCETS and [14] for PROT Nets. Timed Petri Nets associate a time constant with each transition (the time it takes the action represented by the transition to execute).
Reference: [38] <author> V. K. Garg. </author> <title> Parallel and distributed algorithms for supervisory control of discrete event systems. </title> <booktitle> In Proc. 32th IEEE Conf. on Decision and Control, </booktitle> <pages> pages 2236-2241, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: The maximum number of messages exchanged between the agents of DI-VLP-PO (at each control action computation) is of the same order as j c j 2 (see sections 7.3 and 7.5 for exact expressions). In <ref> [38] </ref>, parallel implementations of existing sequential supervisory control synthesis algorithms are given. However, this work is different from ours because no particular structure of the system or legal language is assumed and the emphasis is on fine grain parallelization.
Reference: [39] <author> J. C. Gentina and D. Corbeel. </author> <title> Coloured adaptive structured petri net: A tool for the automatic synthesis of hierarchical control of flexible manufacturing systems (f.m.s.). </title> <booktitle> In Proceedings 1987 IEEE International conference on Robotics and Automation, </booktitle> <pages> pages 1166-1173, </pages> <address> March 31-April 3. </address>
Reference-contexts: The large amount of detail that needs to be captured often results in big and unmanageable Petri Net graphs. To overcome this problem, several modifications and additions have been introduced. Colored Petri Nets (see for example, [33], <ref> [39] </ref>, [97], [13] and [50]) provide a compact graphical representation of ordinary Petri Nets. In a colored Petri Net, analogous events are merged into a single transition and the colors associated with the tokens are used to distinguish among the various instances of the transition. <p> Hierarchical Petri Nets have also been proposed as a solution to the size problem (see for example <ref> [35, 39, 33, 102] </ref>).
Reference: [40] <author> Michael J. C. Gordon. </author> <title> The Denotational Description of Programming Languages. </title> <address> Spriger-Verlag, New York, </address> <year> 1979. </year>
Reference-contexts: A good informal introduction to denotational semantics is given in <ref> [3, 28, 40] </ref>; for an elaborate and rigorous discussion, especially of the underlying mathematics, consult [94]. Consider a simple language, such as the one defined in [94, pages 12-14], consisting of two kinds of constructs: commands and expressions.
Reference: [41] <author> Grady Booch. </author> <title> Software Components With Ada. </title> <publisher> The Benjamin/Cummings Publishing Company, Inc., </publisher> <year> 1987. </year>
Reference-contexts: In prior work (see [6, 7]), we have developed a methodology for designing computer-integrated manufacturing control software (which also applies to other embedded systems) that addresses the above hurdles. It is based on the following guidelines, among others: 1. We recognize as many others have (see for example <ref> [41] </ref>) that the careful use of modularity is the key to software reusability and flexibility. More specifically, we advocate that computer-integrated manufacturing systems should be con structed as assemblages of reusable so-called software/hardware components. 2. <p> The last section reviews the important assembly methods that we have encountered in the literature. 3.1 Software/Hardware Components and their Assemblies A software component as opposed to a software/hardware component is an object-oriented construct characterized by a public interface and a body <ref> [41] </ref>. The interface specifies the set of the services provided by the object, or class of objects, encapsulated by the component; the body, sometimes called internals, implements these services.
Reference: [42] <author> Jean Pierre Quadrat Guy Cohen, Didier Dubois and Michel Viot. </author> <title> A linear-system-theoretic view of discrete-event processes and it use for performance evaluation in manufacturing. </title> <journal> IEEE Transactions on Automatic Control, </journal> <month> March </month> <year> 1985. </year>
Reference-contexts: The critical path method (CPM) is the simplest technique used in analyzing these networks (it allows to determine critical jobs, resources and so forth). Other, more sophisticated techniques <ref> [42] </ref> transform activity networks into a set of algebraic equations (in a special algebra, called minimax algebra) and use linear methods to measure other performance parameters, such as the time it takes a system to reach a steady state. 2.2.2 Event-Based Models Event-based models view the behavior of a software/hardware system <p> Timed Petri Nets associate a time constant with each transition (the time it takes the action represented by the transition to execute). A special kind of timed Petri Nets (decision free Petri Nets [54]) can be interpreted as resource-activity graphs; the theory of minimax algebras <ref> [42] </ref> can then be used to measure their performance. Stochastic Petri Nets associate random firing times with their transitions.
Reference: [43] <author> N. Ben Hadj-Alouane, S. Lafortune, and F. Lin. </author> <title> Control of partially observed discrete event systems with maximal variable lookahead policies. </title> <booktitle> In Proceedings of the Thirty-first Annual Allerton Conference on Communication, Control, and Computing, </booktitle> <pages> pages 898-907, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: The following example shows, however, that not all maximal controllable and observable sublanguages can be generated using VLP-PO policies. (This example contradicts the claim incorrectly made in Theorem 7 of <ref> [43] </ref>.) Example 8 Consider the finite state machine in Figure 6.4. <p> By normality, wroe 2 supCN (K). This again contradicts the fact that supCN (K) K " . Both of the above cases lead to a contradiction, and therefore supCN (K) L (G; fl p ). In <ref> [43] </ref> a different method, based on a dynamically computed ordering scheme, is presented to generate maximal observable and controllable sublanguages that contain supCN (K) using VLP-PO.
Reference: [44] <author> Alireza Haji-Valizadeh and Kenneth Loparo. </author> <title> Decentralized supervisory predicate control of discrete event dynamical systems. </title> <booktitle> In Proc. of 32th Conf. Decision and Control, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: Hence, applying the recently developed algorithms for on-line supervisory control under partial observation (in [45] and Chapter VI) to decentralized control, with the hope of achieving similar gains in complexity and performance, is an appealing area of investigation. In [53] and <ref> [44] </ref> two methods for decentralized on-line control are given. <p> The global control action disables an event if it is disabled by at least one local supervisor. In the method of <ref> [44] </ref> each local supervisor also computes the policy of [45]; however, the global control policy enables an event if it is enabled by at least one supervisor (the supervisor who has the best estimation of the current state wins). <p> It follows from these observations that the behavior generated by the control method of <ref> [44] </ref> always contains the behavior generated by the method of [53]. 142 Variants of the above decentralized schemes can be obtained by keeping the same rule for deriving the global control action and using other methods for computing the local control actions. <p> The following example shows that the method of <ref> [44] </ref> does not always generate a maximal controllable and co-observable sublanguage; moreover, when the supremal controllable (with respect to the union of the local controllable event subsets) and normal (with respect to the union of the local observable event subsets) sublanguage is co-observable (and hence can be achieved via the off-line <p> supremal controllable (with respect to the union of the local controllable event subsets) and normal (with respect to the union of the local observable event subsets) sublanguage is co-observable (and hence can be achieved via the off-line synthesis of a decentralized controller using the results of [85]), the method of <ref> [44] </ref> does not always generate it. Example 11 Consider the system G and legal language K depicted in Fig 7.1. Supervisor 1 observes only the event ff and Supervisor 2 observes only fi. All events are controllable to both supervisors. <p> that the two methods may not necessarily produce comparable behavior in contrast to what is stated above 143 and co-observable sublanguage of K (the first control actions of the two decentralized supervisors enable everything, and following any observation is disabled) and contains the above language generated by the method of <ref> [44] </ref>. Also, the set f; ff; fig is the supremal controllable and normal sublanguage of K (with respect to o = fff; fig and c = fff; fi; g) and it is co-observable, but it is not a subset of the behavior generated by the method of [44]. <p> the method of <ref> [44] </ref>. Also, the set f; ff; fig is the supremal controllable and normal sublanguage of K (with respect to o = fff; fig and c = fff; fi; g) and it is co-observable, but it is not a subset of the behavior generated by the method of [44]. It can be verified that the observations of the above example extend to the VLP-PO variants discussed above. The local supervisors in the above schemes do not communicate on-line; a static rule for determining the global control actions is used.
Reference: [45] <author> M. Heymann and F. Lin. </author> <title> On-line control of partially observed discrete event systems. Discrete Event Dynamic Systems: </title> <journal> Theory and Applications, </journal> <volume> 4(3) </volume> <pages> 221-236, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: synthesis techniques for the above problem generally require building an observer for the system model, a step which is, in the worst case, of exponential complexity in the cardinality of the system state space [96]. 104 105 In the spirit of our results in Chapter V and recent work in <ref> [45] </ref> we propose a new algorithm for the on-line synthesis of control policies for partially observed discrete event systems. This algorithm, acronymed VLP-PO (for variable lookahead policies under partial observation), is based on a forward search over the system model. <p> VLP-PO is best viewed as an extension of the VLP-S algorithm of Chpater V to the case of partially-observed systems, but for the special case of prefix-closed legal languages. Properties (ii)-(vi) of VLP-PO, listed above, are in contrast with the properties of the algorithms proposed in <ref> [45] </ref>. In [19] an off-line method for generating a maximal observable and controllable sublanguage of the legal language for prefix-closed languages is presented. <p> Since it is well know that in the case of SSCP with partial observation the supremal controllable and observable sublanguage of the given legal language does not always exist, many strategies for determining a valid next control action must exist (there is no "optimal" next control action). In <ref> [45] </ref> such a strategy is presented 1 . Its starting point is a precomputed full observation optimal control policy 2 for the SSCP problem at hand. <p> if necessary. 110 1 x a a Legal state Illegal state m muba disabled at a given state if and only if it leads to a bad (infinite cost) state; it is easy to see how the extended unobservable reach of S resulting from the above described control action of <ref> [45] </ref> consists entirely of good (zero cost) states. The above strategy though simple, is in a "local sense" too restrictive. <p> Disabling the unobservable fi, for example, automatically excludes the state x 2 (reachable only via fffffiu from x 1 in S) from the unobservable reach generated by the next control action. However, the 111 strategy of <ref> [45] </ref> would still examine x 2 and as a result the event ff is disabled (ff is not in fl (x 2 ) since ffi (x 2 ; ff) is an illegal state). <p> For each new control action, a suitable ordering of controllable events is first computed based on the control action given by the strategy of <ref> [45] </ref> described in Section 5.3.1 (the events enabled by this control action are placed first in the ordering); this ordering is then used to call VLP-PO in the usual way to compute the real control action. <p> It can be easily show (though we do not pursue it for brevity purposes) that L (G; fl p ) obtained in this way includes L (G; fl ), where fl is the first policy of <ref> [45] </ref> (two policies are described in that paper, and the second one subsumes the first) 3 . In [45] it is shown that L (G; fl ) contains supCN (K). <p> show (though we do not pursue it for brevity purposes) that L (G; fl p ) obtained in this way includes L (G; fl ), where fl is the first policy of <ref> [45] </ref> (two policies are described in that paper, and the second one subsumes the first) 3 . In [45] it is shown that L (G; fl ) contains supCN (K). <p> However, the following example shows that VLP-PO cannot be used to compute a maximal controllable and observable sublanguage containing L (G; ), where is the second policy presented in <ref> [45] </ref>. Example 9 Consider the finite state machine in Figure 6.6. Assume that all the events are controllable and that o is the only observable event. <p> Hence, ff must be disabled in the second control action. The resulting language generated by the only possible VLP-PO policy is fo; ffofig. The first control action of the second policy of <ref> [45] </ref>, (computed as described in Section 6.2.1), enables only the event o. The NS that it uses to compute its second control action, after observing o, is enclosed by the right-most dotted rectangle; as a result, the second control action enables all events. <p> It is interesting to note here that supCN (K) = ;; hence for all practical purposes, the problem cannot be solved with existing off-line methods. Also the first and only control action of the second policy of <ref> [45] </ref> disables all the controllable events; thereby denying access to the resources to both users forever. <p> y 4 y 3 State Control Action y 0 fUse i A ; Use i y 1 fUse i A ; Use i y 2 fUse i A ; Use i y 3 fUse i A g y 4 fUse i A g Table 6.2: Policy for Blocking Solution of <ref> [45] </ref> also generates the path of Figure 6.11 and as before supCN (K) = ;. Though our method always generates a maximal observable and controllable sublanguage, not all maximals are good and useful. <p> As in partial observation supervisory control, the methods for (off-line) synthesis of decentralized supervisors are very limited: Even restrictive solutions (to specially structured problems) have exponential complexities (see [85] on strongly decomposable sublanguages). Hence, applying the recently developed algorithms for on-line supervisory control under partial observation (in <ref> [45] </ref> and Chapter VI) to decentralized control, with the hope of achieving similar gains in complexity and performance, is an appealing area of investigation. In [53] and [44] two methods for decentralized on-line control are given. <p> In [53] and [44] two methods for decentralized on-line control are given. In the method of [53] each local supervisor computes (online) the first partial observation policy given in <ref> [45] </ref>: the local control action is the intersection of the full observation policy control actions of all the traces generated by the system that project as the current local observation. The global control action disables an event if it is disabled by at least one local supervisor. <p> The global control action disables an event if it is disabled by at least one local supervisor. In the method of [44] each local supervisor also computes the policy of <ref> [45] </ref>; however, the global control policy enables an event if it is enabled by at least one supervisor (the supervisor who has the best estimation of the current state wins). <p> We feel that distributed/parallel approaches to supervisory control under partial observation are the natural alternative in the cases where communication is possible; applying the sequential on-line approaches to supervisory control under partial observation (see <ref> [45] </ref> and Chapter VI) to large-scale systems may be impractical due to the size of the state space. 7.3 On-line Parallel/Distributed Supervisory Control In this section we consider a special case of the general problem described in the introduction of this chapter and develop a distributed supervisory control algorithm for it;
Reference: [46] <author> C. A. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> Prentice-Hall International, </booktitle> <address> UK, </address> <publisher> LTD., </publisher> <year> 1985. </year> <month> 182 </month>
Reference-contexts: However, when these models are used for solving control problems, the usual approach consists of introducing new events to name each set of parallel events <ref> [46] </ref>. We follow this approach to transform rule-based models to event-based models. 13 vertex for each possible system event and a directed arc joining an event to each one of its possible successors. <p> Event graphs closely resemble GRAFCETS [27], reviewed later. Finitely recursive processes (intimately related to the work of <ref> [46] </ref>) have also been used to model manufacturing systems in see [48]. The approach starts by defining a set of primitive processes (by explicitly listing their trace sets) and a set of operations on processes (three operations are defined: deterministic choice, synchronous and sequential composition). <p> However, our assembly approach has some similarity with the approach considered in [93] and [52], for interconnecting Petri Nets; two Petri Nets are interconnected by identifying some of their places together. Communicating Sequential Processes (CSP) <ref> [46] </ref> and Communicating Systems (CS) [66] are two similar approaches for modeling discrete-event systems as processes. A process is viewed, as we explained in Chapter II, as a set of possible trajectories of events traces.
Reference: [47] <author> G. Hoffmann, C. Schaper, and G. Franklin. </author> <title> Discrete event controller for a rapid thermal multiprocessor. </title> <booktitle> In Proc. of 1991 American Control Conference, </booktitle> <address> Boston, MA, USA, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: is certainly a complex, time consuming and error prone operation. 5 For the purpose of control we adopt event-based models and the widely accepted supervisory control strategy (based on these models) initiated by Ramadge and Won-ham [78, 99] which has been successfully applied to manufacturing and other software/hardware systems (see <ref> [4, 10, 47] </ref>)). Event-based models (reviewed in Chapter II) capture the system dynamics as event sequences.
Reference: [48] <author> K. Inan and P. Varaiya. </author> <title> Finitely recursive process models for discrete event systems. </title> <journal> IEEE Trans. Automatic Control, </journal> <volume> 33(7) </volume> <pages> 626-639, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: If denotes the set of all possible events in a system, then the behavior of the system is given by a subset L ae fl . L is the set of all the finite sequences of events traces- <ref> [48, 80] </ref> that the system can generate 1 . One way to describe the system consists of listing all the traces in L. This, however, is not always possible since L is infinite for most software/hardware systems. <p> Event graphs closely resemble GRAFCETS [27], reviewed later. Finitely recursive processes (intimately related to the work of [46]) have also been used to model manufacturing systems in see <ref> [48] </ref>. The approach starts by defining a set of primitive processes (by explicitly listing their trace sets) and a set of operations on processes (three operations are defined: deterministic choice, synchronous and sequential composition). <p> Event-based models use events, rather than entities, as their basic elements (the underlying structure of an event is not captured). This level of detail has been proven suitable for solving control problems <ref> [48, 57, 80] </ref> and it is precisely for this reason that we use event-based models in this thesis.
Reference: [49] <author> M. Silva Javier. Martinez, H. </author> <title> Alla. Petri Nets for the Specification of FMSs. </title> <editor> In A. Kusiak, editor, </editor> <title> Modeling and Design of Flexible Manufacturing Systems. </title> <publisher> Elsevier, </publisher> <address> Amesterdam, </address> <year> 1986. </year>
Reference-contexts: A good survey of the use of Petri Nets in the modeling of manufacturing systems is provided in <ref> [49] </ref>. An example of using Petri Nets to capture software components can be found in [93]. An overview of the basic notions of Petri Nets and their use as a modeling tool is presented in [69, 76].
Reference: [50] <author> Pedro Muro Javier Martinez and Manuel Silva. </author> <title> Modeling, validation and software implementation of production systems using high level petri nets. </title> <booktitle> In Proceedings 1987 IEEE International conference on Robotics and Automation, </booktitle> <pages> pages 1180-1185, </pages> <address> March 31-April 3. </address>
Reference-contexts: The large amount of detail that needs to be captured often results in big and unmanageable Petri Net graphs. To overcome this problem, several modifications and additions have been introduced. Colored Petri Nets (see for example, [33], [39], [97], [13] and <ref> [50] </ref>) provide a compact graphical representation of ordinary Petri Nets. In a colored Petri Net, analogous events are merged into a single transition and the colors associated with the tokens are used to distinguish among the various instances of the transition.
Reference: [51] <author> Mohan V. Kalkunte and Robert G. Sargent. </author> <title> Modeling flexible manufacturing systems with event graphs. </title> <booktitle> In Proceedings of The First ORSA/TIMS Special Interest Conference on Flexible Manufacturing Systems, </booktitle> <pages> pages 183-198, </pages> <year> 1984. </year>
Reference-contexts: Their main disadvantage is that they are limited to the class of systems that have regular trace sets. However, they easily lend themselves to composition (shu*e, synchronous and parallel), a very powerful modeling tool. Event graphs are a special form of finite state machines (see <ref> [51] </ref> and [87] for their applications to manufacturing systems). An event graph is a directed graph with a 1 The above can be generalized by viewing the behavior of a system as sequences of sets of parallel events [103].
Reference: [52] <author> V. E. Kotov. </author> <title> An algebra for parallelism based on petri nets. </title> <editor> In G. Goos and J. Hartmanis, editors, </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> volume 64. </volume> <publisher> Springer-Verlag, </publisher> <year> 1978. </year>
Reference-contexts: Modified Petri Nets have been used (see [93]) to model software components and their assemblies. The comparison between Petri Nets and the formalism used here is made in Chapter II. However, our assembly approach has some similarity with the approach considered in [93] and <ref> [52] </ref>, for interconnecting Petri Nets; two Petri Nets are interconnected by identifying some of their places together. Communicating Sequential Processes (CSP) [46] and Communicating Systems (CS) [66] are two similar approaches for modeling discrete-event systems as processes.
Reference: [53] <author> P. Kozak and W.M. Wonham. </author> <title> Fully decentralized solutions of supervisory control problems. </title> <type> Technical Report # 9310, </type> <institution> Control Science and Engineering, Dept. of Electl. Engrg., Univ. of Toronto, Canada, </institution> <year> 1993. </year>
Reference-contexts: Hence, applying the recently developed algorithms for on-line supervisory control under partial observation (in [45] and Chapter VI) to decentralized control, with the hope of achieving similar gains in complexity and performance, is an appealing area of investigation. In <ref> [53] </ref> and [44] two methods for decentralized on-line control are given. In the method of [53] each local supervisor computes (online) the first partial observation policy given in [45]: the local control action is the intersection of the full observation policy control actions of all the traces generated by the system <p> In <ref> [53] </ref> and [44] two methods for decentralized on-line control are given. In the method of [53] each local supervisor computes (online) the first partial observation policy given in [45]: the local control action is the intersection of the full observation policy control actions of all the traces generated by the system that project as the current local observation. <p> It follows from these observations that the behavior generated by the control method of [44] always contains the behavior generated by the method of <ref> [53] </ref>. 142 Variants of the above decentralized schemes can be obtained by keeping the same rule for deriving the global control action and using other methods for computing the local control actions.
Reference: [54] <author> B. H. Krogh and R. S. Sreenivas. </author> <title> Essentially decision free petri nets for real-time resource allocation. </title> <booktitle> In Proceedings 1987 IEEE International conference on Robotics and Automation, </booktitle> <pages> pages 1005-1011, </pages> <address> March 31-April 3. </address>
Reference-contexts: Timed Petri Nets associate a time constant with each transition (the time it takes the action represented by the transition to execute). A special kind of timed Petri Nets (decision free Petri Nets <ref> [54] </ref>) can be interpreted as resource-activity graphs; the theory of minimax algebras [42] can then be used to measure their performance. Stochastic Petri Nets associate random firing times with their transitions.
Reference: [55] <author> R. Kumar. </author> <title> Observability formulas for discrete event dynamical systems. </title> <booktitle> In Proc. 1993 Conf. </booktitle> <institution> Information Sciences and Systems, Johns Hopkins University, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: In general, there are many (possibly infinitely many) maximal controllable and observable sublanguages. Part of this thesis is concerned with computing some of them on-line. (Observe that for closed languages, the property of observability is preserved under intersection and hence the infimal closed observable superlanguage exists; see <ref> [55, 61, 84] </ref>.) The notion of normality, a strong version of observability, defined below, is important in partial observation supervision since it results in a supremal normal sublanguage.
Reference: [56] <author> R. Kumar, V. Garg, and S. I. Marcus. </author> <title> On controllability and normality of discrete event dynamical systems. </title> <journal> Systems and Control Letters, </journal> <volume> 17 </volume> <pages> 157-168, </pages> <year> 1991. </year>
Reference-contexts: We should mention that existing algorithms also have linear complexity in the prefix-closed case (see <ref> [56] </ref>). Livelock-free case A finite state machine is termed livelock-free if each of its cycles goes through at least one marked state. It is worth mentioning that, on a more fundamental level, livelock-freeness is a property of the language marked by the machine.
Reference: [57] <author> S. Lafortune. </author> <title> Modeling and analysis of transaction execution in database systems. </title> <journal> IEEE Trans. Automatic Control, </journal> <volume> 33(5) </volume> <pages> 439-447, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Event-based models use events, rather than entities, as their basic elements (the underlying structure of an event is not captured). This level of detail has been proven suitable for solving control problems <ref> [48, 57, 80] </ref> and it is precisely for this reason that we use event-based models in this thesis.
Reference: [58] <author> S. Lafortune and E. Chen. </author> <title> The infimal closed controllable superlanguage and its application in supervisory control. </title> <journal> IEEE Trans. Automatic Control, </journal> <volume> 35(4) </volume> <pages> 398-405, </pages> <month> April </month> <year> 1990. </year> <month> 183 </month>
Reference-contexts: In fact, the total computational effort required by the algorithms presented in this chapter (when no bound is imposed) to produce a complete optimal control policy is no worse than the effort required by the traditional off-line algorithms <ref> [58, 99] </ref>. In addition, state information can be freely carried across lookahead windows, and this stands to significantly improve the control action itself. The availability of state information is dependent on the particular problem under 72 consideration and on the representation chosen for the knowledge about the system. <p> However, the behavior of an optimistic policy cannot be worse than the infimal closed controllable superlanguage <ref> [58, 61] </ref>. The second result states that increasing the window size results in a more restrictive policy (which is closer to the optimal one).
Reference: [59] <author> W. Li and P. E. Lauer. </author> <title> Using the structural operational approach to express true concurrency. </title> <editor> In E. J. Newhold and G. Chroust, editors, </editor> <booktitle> Formal Models in Programming. </booktitle> <publisher> Elsevier Science Publishers B. V., North-Holland, </publisher> <year> 1985. </year>
Reference-contexts: Concurrency can be handled by including transitions corresponding to all possible interleavings of actions [91] and parallelism can be handled by allowing the actions corresponding to transitions to be vectors (i.e. actions executed simultaneously) <ref> [59] </ref>. However, time is not handled. 2.4 The Rule-Based Formalism The modeling formalism introduced by [71] is best described as being logic-based, in the sense that its syntax is based on first-order logic languages, and rule-based, because the constructs that capture system dynamics changes- are similar to rules.
Reference: [60] <author> F. Lin and W. M. Wonham. </author> <title> Decentralized supervisory control of discrete-event systems. </title> <journal> Information Sciences, </journal> <volume> 44 </volume> <pages> 199-224, </pages> <year> 1988. </year>
Reference-contexts: Section 7.6 discusses the two special cases of modular control and of control under complete event observations. 7.2 Observations on On-line Decentralized Supervisory Con trol Decentralized formulations of supervisory control problems have been addressed in <ref> [26, 60, 62, 85] </ref>. The general formulation (see [85]) involves two or more "local" supervisors, each having its local subsets of observable and controllable events (in [60] certain restrictions are imposed on the observable and controllable subsets; these restrictions help with the important issue of synthesis). <p> The general formulation (see [85]) involves two or more "local" supervisors, each having its local subsets of observable and controllable events (in <ref> [60] </ref> certain restrictions are imposed on the observable and controllable subsets; these restrictions help with the important issue of synthesis). The local policies are developed by off-line methods based on the complete system model and a global legal language.
Reference: [61] <author> F. Lin and W. M. Wonham. </author> <title> On observability of discrete-event systems. </title> <journal> Information Sciences, </journal> <volume> 44 </volume> <pages> 173-198, </pages> <year> 1988. </year>
Reference-contexts: In general, there are many (possibly infinitely many) maximal controllable and observable sublanguages. Part of this thesis is concerned with computing some of them on-line. (Observe that for closed languages, the property of observability is preserved under intersection and hence the infimal closed observable superlanguage exists; see <ref> [55, 61, 84] </ref>.) The notion of normality, a strong version of observability, defined below, is important in partial observation supervision since it results in a supremal normal sublanguage. <p> However, the behavior of an optimistic policy cannot be worse than the infimal closed controllable superlanguage <ref> [58, 61] </ref>. The second result states that increasing the window size results in a more restrictive policy (which is closer to the optimal one).
Reference: [62] <author> F. Lin and W. M. Wonham. </author> <title> Decentralized control and coordination of discrete event systems with partial observation. </title> <journal> IEEE Trans. Automatic Control, </journal> <volume> 35(12) </volume> <pages> 1330-1337, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Section 7.6 discusses the two special cases of modular control and of control under complete event observations. 7.2 Observations on On-line Decentralized Supervisory Con trol Decentralized formulations of supervisory control problems have been addressed in <ref> [26, 60, 62, 85] </ref>. The general formulation (see [85]) involves two or more "local" supervisors, each having its local subsets of observable and controllable events (in [60] certain restrictions are imposed on the observable and controllable subsets; these restrictions help with the important issue of synthesis).
Reference: [63] <author> F. Lin and W.M. Wonham. </author> <title> On observability of discrete-event systems. </title> <journal> Information Sciences, </journal> <volume> 44(3) </volume> <pages> 173-198, </pages> <year> 1988. </year>
Reference-contexts: However, most work in the area of supervisor synthesis has focused on off-line supervisor synthesis methods which suffer from problems related to computational complexity and state-space explosion <ref> [26, 63, 79, 78, 96, 99] </ref>. <p> Moreover, it is shown that with proper selection of the event priorities the supremal controllable and normal sublanguage of the specification language, the benchmark of off-line solutions <ref> [63] </ref>, is contained in the resulting maximal. An important property of this algorithm is that its computational complexity is linear at each step (of course, the off-line computational effort that is required to generate the entire control policy is still exponential). <p> The worst case complexity of these algorithms is in the order of the square of the cardinality of the state set of G fi H. In <ref> [63] </ref>, a new constraint is added the SSCP: The set is also partitioned into the subset of observable events, o , and the subset of unobservable events, uo . Variation on this constraint are also considered in [26]. <p> 0 2 K; oe 2 )(P (s) = P (s 0 ) ^ soe 2 K ^ soe 2 L (G)) ) s 0 oe 2 K: Given a prefix closed legal language K, a partial observation supervisor generating K exists if and only if K is observable and controllable <ref> [63] </ref>. Unfortunately, unlike the full observation case (SSCP), if K does not satisfy the above condition, there is not an optimal sublanguage that could be generated instead; i.e., the supremal controllable and observable sublanguage need not exist (this is because the union of two observable languages is not necessarily observable). <p> is normal if, (8s 2 L (G))(P (s) 2 P (K) , s 2 K): As it turns out, the supremal controllable and normal sublanguage of the legal language K, denoted by supCN (K), also exists and is often offered as a solution to partial observation supervision problems; see e.g., <ref> [26, 63] </ref> (the computation of supCN (K) is addressed in [12, 18, 65]). In this thesis, we improve on this situation by specifying the appropriate parameters that force our algorithms to synthesize 66 partial observation supervisors that include the supremal controllable and normal sublanguage as part of the generated behavior. <p> We restrict ourselves to situation where the system language and the legal language are not be prefix-closed. This problem was first studied in <ref> [26, 63, 78] </ref> where it is determined that, unlike in the full observation case, a supremal controllable and observable sublanguage of the given legal language may not always exist; instead there may be several maximal controllable and observable sublanguages of the legal language (a good survey of these results appears in <p> VLP-PO always generates a maximal observable and controllable sublanguage and offers some flexibility in the selection of this maximal via event priorities. It is shown that the supremal controllable and normal sublanguage of the legal language, the traditional benchmark of off-line solutions <ref> [65, 63] </ref>, is contained in the resulting maximal for a specific subset of all possible priority assignments. A crucial property of this algorithm is that its computational complexity is linear at each step. The third algorithm, DI-VLP-PO, is a distributed version of VLP-PO.
Reference: [64] <author> B. Liskov and S. N. Zilles. </author> <title> Specification techniques for data abstractions. </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> March </month> <year> 1975. </year>
Reference-contexts: In this manner, the interface, and hence the component, can serve as a tool for abstraction and information hiding (see [75] and <ref> [64] </ref>). 35 36 A software/hardware component generalizes the concept of a software component by allowing its internals to enclose hardware [73]; i.e, these internals are interfaced to actual mechanical devices (through networks and other communication media), such as robots, AGVs and so forth.
Reference: [65] <author> G. Custeau M. Barbeau and R. St-Denis. </author> <title> An algorithm for computing the projection of the largest recognizable sublanguage of a legal language. </title> <type> Technical Report 111, </type> <institution> Universite de Sherbrooke, </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: (K) , s 2 K): As it turns out, the supremal controllable and normal sublanguage of the legal language K, denoted by supCN (K), also exists and is often offered as a solution to partial observation supervision problems; see e.g., [26, 63] (the computation of supCN (K) is addressed in <ref> [12, 18, 65] </ref>). In this thesis, we improve on this situation by specifying the appropriate parameters that force our algorithms to synthesize 66 partial observation supervisors that include the supremal controllable and normal sublanguage as part of the generated behavior. <p> VLP-PO always generates a maximal observable and controllable sublanguage and offers some flexibility in the selection of this maximal via event priorities. It is shown that the supremal controllable and normal sublanguage of the legal language, the traditional benchmark of off-line solutions <ref> [65, 63] </ref>, is contained in the resulting maximal for a specific subset of all possible priority assignments. A crucial property of this algorithm is that its computational complexity is linear at each step. The third algorithm, DI-VLP-PO, is a distributed version of VLP-PO.
Reference: [66] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <booktitle> Prentice-Hall International, </booktitle> <address> UK, </address> <publisher> LTD., </publisher> <year> 1989. </year>
Reference-contexts: To cope with this problem, nonstandard denotational semantics (as opposed to the standard one outlined above) is used. In this approach, the denotations are processes (see for example <ref> [66] </ref>) that model interleaving 3 ; for example, [2] uses this approach to define the semantics of a subset of Ada. 2.3.2 Operational Semantics The operational approach describes the semantics of a programming language by defining an abstract state machine, essentially an interpreter; the state of this machine records the essential <p> However, our assembly approach has some similarity with the approach considered in [93] and [52], for interconnecting Petri Nets; two Petri Nets are interconnected by identifying some of their places together. Communicating Sequential Processes (CSP) [46] and Communicating Systems (CS) <ref> [66] </ref> are two similar approaches for modeling discrete-event systems as processes. A process is viewed, as we explained in Chapter II, as a set of possible trajectories of events traces.
Reference: [67] <author> J. J. Moder and C. R. Phillips. </author> <title> Project Management with CPM and PERT. </title> <publisher> Reinhold Publishing Corp., </publisher> <address> NY, </address> <year> 1964. </year>
Reference-contexts: Activity and 12 PERT networks (see for example [31], <ref> [67] </ref> and [70]) are also used to model manufacturing systems for the purpose of performance evaluation. The critical path method (CPM) is the simplest technique used in analyzing these networks (it allows to determine critical jobs, resources and so forth).
Reference: [68] <author> H. Mortazavian. </author> <title> Modeling, control and verification of flexible manufacturing systems. </title> <booktitle> In Proceedings of The First ORSA/TIMS Special Interest Conference on Flexible Manufacturing Systems, </booktitle> <pages> pages 359-371, </pages> <year> 1984. </year>
Reference-contexts: Finally, event-based models rooted in first-order logic have also been applied to manufacturing systems. An example is provided in <ref> [68] </ref>. The signature of the model consists of a set of predicates, functions and a set of constants, each denoting a possible event of the manufacturing system. The set of traces that can be generated by the uncontrolled system is specified by a set of first-order sentences.
Reference: [69] <author> T. Murata. </author> <title> Petri nets: Properties, analysis, </title> <journal> and applications. Proc. of the IEEE, </journal> <volume> 77(4) </volume> <pages> 541-580, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: An example of using Petri Nets to capture software components can be found in [93]. An overview of the basic notions of Petri Nets and their use as a modeling tool is presented in <ref> [69, 76] </ref>. Compared with the formalism of [71], Petri Nets are generally used at a slightly higher level of abstraction. This can be seen as follows.
Reference: [70] <author> K. G. Murty. </author> <title> Network Programming. </title> <publisher> Prentice-Hall, Inc., </publisher> <address> NJ, </address> <note> to appear. </note>
Reference-contexts: Activity and 12 PERT networks (see for example [31], [67] and <ref> [70] </ref>) are also used to model manufacturing systems for the purpose of performance evaluation. The critical path method (CPM) is the simplest technique used in analyzing these networks (it allows to determine critical jobs, resources and so forth).
Reference: [71] <author> A. W. Naylor and M. C. Maletz. </author> <title> The Manufacturing Game: A Formal Approach to Manufacturing Software. </title> <journal> IEEE Transactions on Systems, Man and Cybernetics, </journal> <month> May-June </month> <year> 1986. </year>
Reference-contexts: Second, they are needed to support the development of generic control algorithms. This thesis expands on the above concepts by contributing to the software specification process and the development of generic control algorithms. 1.2 The Objective and Contributions of this Thesis The formalism of <ref> [71] </ref>, originally developed for modeling manufacturing systems, has been shown suitable for specifying software/hardware components (see [7, 73]); and we intend to use it here for that purpose. There are three main reasons behind this decision; first, the formalism is able to capture true parallelism and time. <p> This thesis is organized as follows. Chapter II gives a survey of the modeling formalisms typically used for the specification and high-level modeling of software/hardware systems (with an emphasis on manufacturing systems models); it also overviews in detail the rule-based modeling formalism of <ref> [71] </ref> used in Chapter III. Chapter III presents our assembly method for rule-based models and its application to a material transport system. <p> The second section reviews some of the formalisms used for specifying and modeling software/hardware systems (especially manufacturing systems). For the purpose of completeness, the third section reviews the area of programming language semantics. The last section reviews the rule-based formalism of <ref> [71] </ref> and illustrates its use through small examples. 2.1 Modeling Levels Computer-integrated manufacturing systems, and other software/hardware systems, can be modeled at various levels of detail. Models at different levels capture different aspects of the system. <p> The set of traces that can be generated by the uncontrolled system is specified by a set of first-order sentences. These models can be easily used in conjunction with the control algorithms developed in this thesis. Though both event-based models and the formalism of <ref> [71] </ref> capture a software/hardware 14 system at the logical level, the difference between the two lies in the amount of detail that can be captured by each. Event-based models use events, rather than entities, as their basic elements (the underlying structure of an event is not captured). <p> This level of detail has been proven suitable for solving control problems [48, 57, 80] and it is precisely for this reason that we use event-based models in this thesis. The rule-based models of <ref> [71] </ref> allow more flexibility in selecting the level of detail to be captured: Whenever we deem them appropriate for control purposes (and whenever they do not capture time), we can transform them to a form of event-based models suitable for use in conjunction with the control algorithms given by the second <p> An example of using Petri Nets to capture software components can be found in [93]. An overview of the basic notions of Petri Nets and their use as a modeling tool is presented in [69, 76]. Compared with the formalism of <ref> [71] </ref>, Petri Nets are generally used at a slightly higher level of abstraction. This can be seen as follows. <p> The main advantage of Petri Nets over the rule-based formalism of <ref> [71] </ref> (and some of the event-based models discussed in the previous subsection) is their intuitive graphical representation [36]. This advantage quickly becomes a drawback when Petri Nets are used to model real computer-integrated manufacturing systems [13]. <p> This kind of Petri Net structure is not needed in the rule-based formalism of <ref> [71] </ref> because rules can fire in parallel. A GRAFCET is a binary Petri Net whose places are associated with actions and transitions are associated with conditions. An enabled transition fires only if its corresponding condition is satisfied. <p> In this way, GRAFCETs resemble augmented Petri Nets, the condition action pair associated with a GRAFCET transition is essentially a rule. However, GRAFCETs are more powerful than Augmented Petri Nets since they allow transitions to fire in parallel. The main advantage of the rule-based formalism of <ref> [71] </ref> over GRAFCETS is its first-order logic structure, which allows for a concise specification of conditions and actions and, more importantly, permits reasoning about the model (this is essentially due to the representation of an action by the set of sentences of the rule's right side). <p> From that perspective we provide a brief review of the two major approaches used for specifying semantic models of programming languages (and hence models of software): the Denotational and the Operational approaches. The modeling formalism of <ref> [71] </ref> used in this thesis follows the lines of the operational approach. Two important points should be noted. First, this thesis is concerned with high-level models of software/hardware components, and these models do not and should not capture the "full" semantics of the software. <p> Concurrency can be handled by including transitions corresponding to all possible interleavings of actions [91] and parallelism can be handled by allowing the actions corresponding to transitions to be vectors (i.e. actions executed simultaneously) [59]. However, time is not handled. 2.4 The Rule-Based Formalism The modeling formalism introduced by <ref> [71] </ref> is best described as being logic-based, in the sense that its syntax is based on first-order logic languages, and rule-based, because the constructs that capture system dynamics changes- are similar to rules. <p> While the software interface is specified (at least in part) using the programming language, we do not yet have a language for specifying hardware interfaces. However, we can model (and thus specify) them using the formalism of <ref> [71] </ref> in the same way as software interfaces. A hardware interface typically designates a portion of the component's hardware to be accessible to the users of the component and specifies the ways in which these users should interact with this hardware. <p> The second subsection describes the global MTS and gives its model as an assembly of the models of the two local MTS's. 3.3.1 The Local Material Transport Systems We start with a physical and functional description of the two local MTS's. Then, the formalism of <ref> [71] </ref> is applied to model each MTS individually; as a result, two models are presented. Physical and Functional Description The main function of a material transport system is to transfer work-piece fixtures pallets- between pairs of locations on a factory floor. <p> The lower bound of the interval can be used to model communication or control delays and the 174 upper bound represents a hard deadline. Note that this approach to time, matches the approach taken by the rule based formalism of <ref> [71] </ref>, if the time interval associated with each event is taken to be of zero length.
Reference: [72] <author> A. W. Naylor and M. B. Shadmehr. </author> <title> A linear approach to updating in logic-based models of manufacturing systems and other discrete-event systems. </title> <type> Technical Report CSE-TR-11-89, </type> <institution> EECS Department- The University of Michigan, </institution> <year> 1989. </year> <month> 184 </month>
Reference-contexts: Obviously, this characterization, by itself, does not define a unique mapping between the configurations satisfying L and those satisfying R. In fact, to model the real system, we must somehow capture a very specific mapping (the real one). This is the task undertaken by <ref> [72] </ref> and, due to its important contribution to understanding the formalism, the rest of this section is devoted to reviewing it. In [72], given a change's right side and the current configuration (if the change is instantaneous, this configuration presumably satisfies the change's left side), the next configuration is obtained from <p> In fact, to model the real system, we must somehow capture a very specific mapping (the real one). This is the task undertaken by <ref> [72] </ref> and, due to its important contribution to understanding the formalism, the rest of this section is devoted to reviewing it. In [72], given a change's right side and the current configuration (if the change is instantaneous, this configuration presumably satisfies the change's left side), the next configuration is obtained from the original one by changing only what is necessary to satisfy the right side and the axioms (with this scheme, "the well-defined <p> The basic argument of <ref> [72] </ref> in favor of this selection is not mathematical, it is merely noted that this is the way most real systems operate. Let us illustrate the above selection method more precisely. <p> It was mentioned earlier that the interpretations of the static symbols do not change. Hence, we only need to worry about how the interpretation of the predicate P is transformed by the change. The transformation is referred to in <ref> [72] </ref> as updating. <p> Moreover, given a set S of possible interpretations of P , f P 1 is the closest in S to f P 0 if it is closer to f P 0 than any other interpretation of P in S. In <ref> [72] </ref>, it is shown that sets S that have a closest f P 1 to any f P 0 are of a special kind. <p> First of all, the right side of the change together with the axioms must define a t.r.o.p (and this is typically the case 33 in practical situations). This means that not all changes are allowable. Second, given the current configuration, the next configuration is defined by (2.4). In <ref> [72] </ref> it is argued that in most cases, when the right side together with the axioms define a t.r.o.p, the true and false sets f T p and f F p of this t.r.o.p. should be definable in terms of the static symbols of the language.
Reference: [73] <author> A. W. Naylor and R. A. Volz. </author> <title> Design of Integrated Manufacturing System Control Software. </title> <journal> IEEE Transactions on Systems, Man and Cybernetics, </journal> <pages> pages 881-897, </pages> <month> November-December </month> <year> 1987. </year>
Reference-contexts: This thesis expands on the above concepts by contributing to the software specification process and the development of generic control algorithms. 1.2 The Objective and Contributions of this Thesis The formalism of [71], originally developed for modeling manufacturing systems, has been shown suitable for specifying software/hardware components (see <ref> [7, 73] </ref>); and we intend to use it here for that purpose. There are three main reasons behind this decision; first, the formalism is able to capture true parallelism and time. Second, it can be applied uniformly to model the blending of software and hardware in software/hardware components. <p> We realize, however, that real discrete-event systems are finite by nature and if we decide to model them as infinite we may be confronted with the above problem. CHAPTER III ASSEMBLY OF RULE-BASED MODELS This chapter presents our method for assembling the rule-based models of <ref> [73] </ref>. It is organized as follows. The first section describes software/hardware components, the basic subsystems of a software/hardware system, and their assemblies. The second section describes the assembly for rule-based models, which mimics the assembly process of the software/hardware components (the actual systems). <p> In this manner, the interface, and hence the component, can serve as a tool for abstraction and information hiding (see [75] and [64]). 35 36 A software/hardware component generalizes the concept of a software component by allowing its internals to enclose hardware <ref> [73] </ref>; i.e, these internals are interfaced to actual mechanical devices (through networks and other communication media), such as robots, AGVs and so forth. In addition to the software interface, a software/hardware component also provides its user with a hardware interface. <p> From the specification side we have developed a method for assembling rule-based models of software/hardware components, with the aim of simplifying the specification task and reducing the specification effort. Rule-based models have proven to be powerful specification tools for software/hardware systems (see <ref> [73] </ref> and [7]). This is chiefly due to their capability to capture true parallelism and time, in addition to their grounding in first-order logic.
Reference: [74] <author> A. Ollengren. </author> <title> Definition of Programming Languages by Interpreting Automata. </title> <publisher> Academic Press. </publisher>
Reference-contexts: The literature is full of applications of this technique, see for example <ref> [74, 98] </ref>. The technique is easy to apply, in the sense that it does not involve heavy mathematical machinery. Its major weakness, however, is that the resulting machine tends to capture too much detail (even concerning interpreter "house keeping") which obscure the execution semantics of the programming language.
Reference: [75] <author> D. L. Parnas. </author> <title> A technique for the specification of software modules with examples. </title> <journal> Communications of the ACM, </journal> <year> 1972. </year>
Reference-contexts: A user of a software component is not allowed access to its body: Only the services listed by the components interface can be accessed from outside the component. In this manner, the interface, and hence the component, can serve as a tool for abstraction and information hiding (see <ref> [75] </ref> and [64]). 35 36 A software/hardware component generalizes the concept of a software component by allowing its internals to enclose hardware [73]; i.e, these internals are interfaced to actual mechanical devices (through networks and other communication media), such as robots, AGVs and so forth.
Reference: [76] <author> J. L. Peterson. </author> <title> Petri Net Theory and The Modeling of Systems. </title> <address> Englewood Cliffs, N. </address> <publisher> J. Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: An example of using Petri Nets to capture software components can be found in [93]. An overview of the basic notions of Petri Nets and their use as a modeling tool is presented in <ref> [69, 76] </ref>. Compared with the formalism of [71], Petri Nets are generally used at a slightly higher level of abstraction. This can be seen as follows.
Reference: [77] <author> G. Plotkin. </author> <title> A structural approach to operational semantics. </title> <booktitle> Lecture notes, </booktitle> <institution> Arhus University, </institution> <year> 1981. </year>
Reference-contexts: Its major weakness, however, is that the resulting machine tends to capture too much detail (even concerning interpreter "house keeping") which obscure the execution semantics of the programming language. Structural Operational Semantics (SOS) <ref> [77] </ref> avoids, or at least reduces, this weakness.
Reference: [78] <author> P. J. Ramadge and W. M. Wonham. </author> <title> Supervisory control of a class of discrete event processes. </title> <journal> SIAM J. Control and Optimization, </journal> <volume> 25(1) </volume> <pages> 206-230, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: assembly models, but is the alternative to the modeling the assembly from nothing, which is certainly a complex, time consuming and error prone operation. 5 For the purpose of control we adopt event-based models and the widely accepted supervisory control strategy (based on these models) initiated by Ramadge and Won-ham <ref> [78, 99] </ref> which has been successfully applied to manufacturing and other software/hardware systems (see [4, 10, 47])). Event-based models (reviewed in Chapter II) capture the system dynamics as event sequences. <p> However, most work in the area of supervisor synthesis has focused on off-line supervisor synthesis methods which suffer from problems related to computational complexity and state-space explosion <ref> [26, 63, 79, 78, 96, 99] </ref>. <p> We also introduce some relevant concepts from formal language theory. The framework of supervisory control followed in this thesis was initiated in <ref> [78, 99] </ref>. A good review of this work can be found in [80]. The discrete event system is modeled by a generator (or state machine) G = (; X; ffi; x 0 ; X m ). The set of all possible events of the system is denoted by . <p> We consider the general situation where the system language and the legal language may not be prefix-closed;i.e., blocking is an issue. This problem was first studied in <ref> [78] </ref>; its optimal solution is the control policy that restricts the behavior of the system to the supremal controllable sublanguage of the legal language [99]; this optimal control policy is traditionally synthesized all at once and off-line. <p> We restrict ourselves to situation where the system language and the legal language are not be prefix-closed. This problem was first studied in <ref> [26, 63, 78] </ref> where it is determined that, unlike in the full observation case, a supremal controllable and observable sublanguage of the given legal language may not always exist; instead there may be several maximal controllable and observable sublanguages of the legal language (a good survey of these results appears in
Reference: [79] <author> P.J. Ramadge. </author> <title> Some tractable supervisory control problems for discrete-event systems modeled by Buchi automata. </title> <journal> IEEE Trans. Autom. Control, </journal> <volume> 34(1) </volume> <pages> 10-19, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: However, most work in the area of supervisor synthesis has focused on off-line supervisor synthesis methods which suffer from problems related to computational complexity and state-space explosion <ref> [26, 63, 79, 78, 96, 99] </ref>. <p> In [38], parallel implementations of existing sequential supervisory control synthesis algorithms are given. However, this work is different from ours because no particular structure of the system or legal language is assumed and the emphasis is on fine grain parallelization. In <ref> [79] </ref>, system and legal language structures slightly similar to ours are used to reduce the problem complexity (within the context of Buchi automata).
Reference: [80] <author> P.J. Ramadge and W.M. Wonham. </author> <title> The control of discrete event systems. </title> <journal> Proc. of the IEEE, </journal> <volume> 77(1) </volume> <pages> 81-98, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: If denotes the set of all possible events in a system, then the behavior of the system is given by a subset L ae fl . L is the set of all the finite sequences of events traces- <ref> [48, 80] </ref> that the system can generate 1 . One way to describe the system consists of listing all the traces in L. This, however, is not always possible since L is infinite for most software/hardware systems. <p> Event-based models use events, rather than entities, as their basic elements (the underlying structure of an event is not captured). This level of detail has been proven suitable for solving control problems <ref> [48, 57, 80] </ref> and it is precisely for this reason that we use event-based models in this thesis. <p> We also introduce some relevant concepts from formal language theory. The framework of supervisory control followed in this thesis was initiated in [78, 99]. A good review of this work can be found in <ref> [80] </ref>. The discrete event system is modeled by a generator (or state machine) G = (; X; ffi; x 0 ; X m ). The set of all possible events of the system is denoted by . The state space is X. <p> 63, 78] where it is determined that, unlike in the full observation case, a supremal controllable and observable sublanguage of the given legal language may not always exist; instead there may be several maximal controllable and observable sublanguages of the legal language (a good survey of these results appears in <ref> [80] </ref>).
Reference: [81] <author> Ramarathnam Ravichandran and Amiya K. Chakravarty. </author> <title> Decision support in flexible manufacturing systems using timed petri nets. </title> <journal> Journal of Manufacturing Systems, </journal> <volume> 5(2), </volume> <year> 1986. </year>
Reference-contexts: Other kinds of Petri Nets have been proposed to overcome other problems. See <ref> [81] </ref> for timed PNS, [37, 13] for stochastic PNS, [90, 103] for augmented PNS, [27, 95] for GRAFCETS and [14] for PROT Nets. Timed Petri Nets associate a time constant with each transition (the time it takes the action represented by the transition to execute).
Reference: [82] <editor> Elaine Rich, editor. </editor> <booktitle> Artificial Intelligence. </booktitle> <publisher> McGraw-Hill Book Company, </publisher> <year> 1983. </year>
Reference-contexts: For an introduction to first-order logic see [32]; a more elaborate discussion of logic can be found in [16]. Rules are a construct of Artificial Intelligence typically used in conjunction with expert systems (see <ref> [5, 82] </ref>). Each model uses a first-order many-sorted [32] language to describe all the snapshots configurations- of a software/hardware system. This language is divided into two categories of symbols: the static and the dynamic symbols. The static symbols 24 are used to model the non-changing, static aspects of the system.
Reference: [83] <author> Robert U. Ayres. </author> <title> Technology Forcast for CIM. </title> <journal> Manufacturing Review, </journal> <volume> 2(1), </volume> <month> March </month> <year> 1989. </year>
Reference-contexts: Recent statistics have indicated that the cost of this software ranges from one third to a half of the total cost of a computer-integrated manufacturing system, including the cost of its computer and manufacturing hardware <ref> [83] </ref>. This fraction is rapidly increasing as manufacturing systems get more automated; it is expected to reach close to two thirds in the near future [83]. Similar statistics have also been reported about other kinds of embedded software [8, 15]. <p> ranges from one third to a half of the total cost of a computer-integrated manufacturing system, including the cost of its computer and manufacturing hardware <ref> [83] </ref>. This fraction is rapidly increasing as manufacturing systems get more automated; it is expected to reach close to two thirds in the near future [83]. Similar statistics have also been reported about other kinds of embedded software [8, 15].
Reference: [84] <author> K. Rudie and W. M. Wonham. </author> <title> The infimal prefix-closed and observable super-language of a given language. </title> <journal> Systems and Control Letters, </journal> <volume> 15 </volume> <pages> 361-371, </pages> <year> 1990. </year>
Reference-contexts: In general, there are many (possibly infinitely many) maximal controllable and observable sublanguages. Part of this thesis is concerned with computing some of them on-line. (Observe that for closed languages, the property of observability is preserved under intersection and hence the infimal closed observable superlanguage exists; see <ref> [55, 61, 84] </ref>.) The notion of normality, a strong version of observability, defined below, is important in partial observation supervision since it results in a supremal normal sublanguage.
Reference: [85] <author> K. Rudie and W.M. Wonham. </author> <title> Think globally, act locally: Decentralized supervisory control. </title> <journal> IEEE Trans. Autom. Control, </journal> <volume> 37(11) </volume> <pages> 1692-1708, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Section 7.6 discusses the two special cases of modular control and of control under complete event observations. 7.2 Observations on On-line Decentralized Supervisory Con trol Decentralized formulations of supervisory control problems have been addressed in <ref> [26, 60, 62, 85] </ref>. The general formulation (see [85]) involves two or more "local" supervisors, each having its local subsets of observable and controllable events (in [60] certain restrictions are imposed on the observable and controllable subsets; these restrictions help with the important issue of synthesis). <p> Section 7.6 discusses the two special cases of modular control and of control under complete event observations. 7.2 Observations on On-line Decentralized Supervisory Con trol Decentralized formulations of supervisory control problems have been addressed in [26, 60, 62, 85]. The general formulation (see <ref> [85] </ref>) involves two or more "local" supervisors, each having its local subsets of observable and controllable events (in [60] certain restrictions are imposed on the observable and controllable subsets; these restrictions help with the important issue of synthesis). <p> As expected there is no supremal co-observable 141 b b l Legal State Illegal State and controllable sublanguage. As in partial observation supervisory control, the methods for (off-line) synthesis of decentralized supervisors are very limited: Even restrictive solutions (to specially structured problems) have exponential complexities (see <ref> [85] </ref> on strongly decomposable sublanguages). Hence, applying the recently developed algorithms for on-line supervisory control under partial observation (in [45] and Chapter VI) to decentralized control, with the hope of achieving similar gains in complexity and performance, is an appealing area of investigation. <p> sublanguage; moreover, when the supremal controllable (with respect to the union of the local controllable event subsets) and normal (with respect to the union of the local observable event subsets) sublanguage is co-observable (and hence can be achieved via the off-line synthesis of a decentralized controller using the results of <ref> [85] </ref>), the method of [44] does not always generate it. Example 11 Consider the system G and legal language K depicted in Fig 7.1. Supervisor 1 observes only the event ff and Supervisor 2 observes only fi. All events are controllable to both supervisors. <p> Note that, s 2 K , T 1 (s) 2 K 1 ^ T 2 (s) 2 K 2 : (7.1) Obviously, K is prefix-closed. Also, note in passing that K is decomposable (see, e.g., <ref> [85] </ref>) with respect to T 1 and T 2 ; i.e., K = [T 1 ] 1 (T 1 (K)) " [T 2 ] 1 (T 2 (K)) " L (G 1 jjG 12 jjG 2 ): Each K i , i = 1; 2, is given in terms of the
Reference: [86] <author> M. K. Sain. </author> <title> Introduction to Algebraic Systems Theory. </title> <publisher> Academic Press, </publisher> <year> 1981. </year>
Reference-contexts: In what follows, we review the few articles we have encountered that present, more or less, a formal approach to assembly. Two fundamental ways of interconnecting (or assembling) systems are the series 59 and parallel interconnections <ref> [86] </ref>.
Reference: [87] <author> Lee Schruben. </author> <title> Simulation modeling with event graphs. </title> <journal> Communications of the ACM, </journal> <month> November </month> <year> 1983. </year> <month> 185 </month>
Reference-contexts: Their main disadvantage is that they are limited to the class of systems that have regular trace sets. However, they easily lend themselves to composition (shu*e, synchronous and parallel), a very powerful modeling tool. Event graphs are a special form of finite state machines (see [51] and <ref> [87] </ref> for their applications to manufacturing systems). An event graph is a directed graph with a 1 The above can be generalized by viewing the behavior of a system as sequences of sets of parallel events [103].
Reference: [88] <author> Mohammad B. Shadmehr. </author> <title> A study of a logic-based model for manufacturing systems. </title> <type> Technical report, </type> <institution> EECS Department- The University of Michigan, </institution> <year> 1987. </year> <type> PhD Thesis Proposal. </type>
Reference-contexts: The conflict problem occurs when parallel changes attempt to perform contradictory actions simultaneously. The continuity problem occurs when small time perturbations cause parallel changes to interrupt each other. Both of these problems are discussed and analyzed in <ref> [88, 89] </ref>; their analysis uses the tools developed for solving the updating problem discussed below. A detailed exposition of these problems is beyond the scope of this thesis, but the conflict problem, which is the most important of theses two problems, is illustrated by the following example.
Reference: [89] <author> Mohammad B. Shadmehr. </author> <title> The consistency and continuty problems. </title> <year> 1989. </year>
Reference-contexts: The conflict problem occurs when parallel changes attempt to perform contradictory actions simultaneously. The continuity problem occurs when small time perturbations cause parallel changes to interrupt each other. Both of these problems are discussed and analyzed in <ref> [88, 89] </ref>; their analysis uses the tools developed for solving the updating problem discussed below. A detailed exposition of these problems is beyond the scope of this thesis, but the conflict problem, which is the most important of theses two problems, is illustrated by the following example.
Reference: [90] <author> M. J. Shaw and A. B. Whinston. </author> <title> Task bidding and distributed planning in manufacturing systems. </title> <booktitle> In The Second Conference on Artificial Intelligence Applications, </booktitle> <pages> pages 184-189, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: Other kinds of Petri Nets have been proposed to overcome other problems. See [81] for timed PNS, [37, 13] for stochastic PNS, <ref> [90, 103] </ref> for augmented PNS, [27, 95] for GRAFCETS and [14] for PROT Nets. Timed Petri Nets associate a time constant with each transition (the time it takes the action represented by the transition to execute).
Reference: [91] <author> J. Shen. </author> <title> A structural operational semantics for the multitasking in concurrent programming systems. </title> <booktitle> In Proceedings of COMPSAC 87, </booktitle> <pages> pages 82-88, </pages> <year> 1987. </year>
Reference-contexts: The last two equations specify the rules corresponding to the concatenation construct; they are interpreted in the obvious way. Concurrency can be handled by including transitions corresponding to all possible interleavings of actions <ref> [91] </ref> and parallelism can be handled by allowing the actions corresponding to transitions to be vectors (i.e. actions executed simultaneously) [59].
Reference: [92] <author> Jane L. Snowdon and Jane C. Ammons. </author> <title> A survey of queueing networ packages for the analysis of manufacturing systems. Manufacturing Review, </title> <month> March </month> <year> 1983. </year>
Reference-contexts: Examples of such models are queuing and activity networks. Queuing networks (see for example <ref> [92] </ref> and [101]) are probabilistic models typically used during the design and planning stages of a manufacturing system's life-span; they help in evaluating design alternatives by answering questions such as, what is the best factory floor layout and what size should a machine's buffer be.
Reference: [93] <author> Stephen Yau and Mehmet Caglayan. </author> <title> Distributed software system design representation using modified petri nets. </title> <journal> IEEE Transaction on Software Engineering, </journal> <month> November </month> <year> 1983. </year>
Reference-contexts: A good survey of the use of Petri Nets in the modeling of manufacturing systems is provided in [49]. An example of using Petri Nets to capture software components can be found in <ref> [93] </ref>. An overview of the basic notions of Petri Nets and their use as a modeling tool is presented in [69, 76]. Compared with the formalism of [71], Petri Nets are generally used at a slightly higher level of abstraction. This can be seen as follows. <p> Algebraic specifications of abstract data types [30] and modules [29] do not rely on an underlying language; however, they do not handle (as they have been used) parallelism and real-time. Moreover, Petri Nets have also been used for specifying software components <ref> [93] </ref>; in addition to the disadvantages discussed earlier, time is not captured. 2.3.1 Denotational Semantics With the denotational approach, semantics is given to a programming language by associating each well-formed language construct with a denotation which models its "meaning". <p> Our assemblies can, in some sense, be perceived as mixed series and parallel interconnections; if we consider the configuration as the output of a model, then many-sorted equality provides a mutual series interconnection of the constituent models. Modified Petri Nets have been used (see <ref> [93] </ref>) to model software components and their assemblies. The comparison between Petri Nets and the formalism used here is made in Chapter II. However, our assembly approach has some similarity with the approach considered in [93] and [52], for interconnecting Petri Nets; two Petri Nets are interconnected by identifying some of <p> Modified Petri Nets have been used (see <ref> [93] </ref>) to model software components and their assemblies. The comparison between Petri Nets and the formalism used here is made in Chapter II. However, our assembly approach has some similarity with the approach considered in [93] and [52], for interconnecting Petri Nets; two Petri Nets are interconnected by identifying some of their places together. Communicating Sequential Processes (CSP) [46] and Communicating Systems (CS) [66] are two similar approaches for modeling discrete-event systems as processes.
Reference: [94] <author> Joseph E. Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Languages. </title> <publisher> The MIT Press, </publisher> <year> 1977. </year>
Reference-contexts: A good informal introduction to denotational semantics is given in [3, 28, 40]; for an elaborate and rigorous discussion, especially of the underlying mathematics, consult <ref> [94] </ref>. Consider a simple language, such as the one defined in [94, pages 12-14], consisting of two kinds of constructs: commands and expressions. Then its semantics can be defined using the following two functions, called semantic functions. <p> A good informal introduction to denotational semantics is given in [3, 28, 40]; for an elaborate and rigorous discussion, especially of the underlying mathematics, consult [94]. Consider a simple language, such as the one defined in <ref> [94, pages 12-14] </ref>, consisting of two kinds of constructs: commands and expressions. Then its semantics can be defined using the following two functions, called semantic functions. <p> Hence, the semantics of the execution of a given program corresponds to a trajectory of machine states (as opposed 2 The existence of semantic functions E and C satisfying the resulting set of clauses and their nature is a matter addressed by the theory of domains <ref> [94] </ref>. 3 Processes are typically given operational semantics! 22 to a "final" state, for the case of denotational semantics). The literature is full of applications of this technique, see for example [74, 98]. The technique is easy to apply, in the sense that it does not involve heavy mathematical machinery.
Reference: [95] <author> B. H. Thomas and C. McLean. </author> <title> Using grafcet to design generic controllers. </title> <booktitle> In Proceedings of the 1988 International Conference on Computer Integrated Manufacturing, </booktitle> <pages> pages 110-119, </pages> <institution> Rensselaer Polytechnic Institute, </institution> <address> Troy New York, </address> <month> May 23-25 </month> <year> 1988. </year>
Reference-contexts: Other kinds of Petri Nets have been proposed to overcome other problems. See [81] for timed PNS, [37, 13] for stochastic PNS, [90, 103] for augmented PNS, <ref> [27, 95] </ref> for GRAFCETS and [14] for PROT Nets. Timed Petri Nets associate a time constant with each transition (the time it takes the action represented by the transition to execute).
Reference: [96] <author> J. N. Tsitsiklis. </author> <title> On the control of discrete-event dynamical systems. </title> <journal> Math. Control Signals Systems, </journal> <volume> 2 </volume> <pages> 95-107, </pages> <year> 1989. </year>
Reference-contexts: However, most work in the area of supervisor synthesis has focused on off-line supervisor synthesis methods which suffer from problems related to computational complexity and state-space explosion <ref> [26, 63, 79, 78, 96, 99] </ref>. <p> Furthermore, off-line supervisor controller synthesis techniques for the above problem generally require building an observer for the system model, a step which is, in the worst case, of exponential complexity in the cardinality of the system state space <ref> [96] </ref>. 104 105 In the spirit of our results in Chapter V and recent work in [45] we propose a new algorithm for the on-line synthesis of control policies for partially observed discrete event systems.
Reference: [97] <author> N. Viswanadham and Y. Narahari. </author> <title> Colored petri net models for automated manufacturing systems. </title> <booktitle> In Proceedings 1987 IEEE International conference on Robotics and Automation, </booktitle> <pages> pages 1985-1990, </pages> <address> March 31-April 3. </address>
Reference-contexts: The large amount of detail that needs to be captured often results in big and unmanageable Petri Net graphs. To overcome this problem, several modifications and additions have been introduced. Colored Petri Nets (see for example, [33], [39], <ref> [97] </ref>, [13] and [50]) provide a compact graphical representation of ordinary Petri Nets. In a colored Petri Net, analogous events are merged into a single transition and the colors associated with the tokens are used to distinguish among the various instances of the transition.
Reference: [98] <author> Peter Wegner. </author> <title> The vienna definition language. </title> <journal> Computing Surveys, </journal> <volume> 4(1), </volume> <month> March </month> <year> 1972. </year>
Reference-contexts: The literature is full of applications of this technique, see for example <ref> [74, 98] </ref>. The technique is easy to apply, in the sense that it does not involve heavy mathematical machinery. Its major weakness, however, is that the resulting machine tends to capture too much detail (even concerning interpreter "house keeping") which obscure the execution semantics of the programming language. <p> Structural Operational Semantics (SOS) [77] avoids, or at least reduces, this weakness. The main idea behind this new approach is to use some of the successful features of the denotational style, basically, viewing memories and environments as functions (instead of complex data structures, such as trees <ref> [98] </ref>) and deriving the state transitions of the machine by induction on the constructs of the abstract syntax of the language.
Reference: [99] <author> W. M. Wonham and P. J. Ramadge. </author> <title> On the supremal controllable sublanguage of a given language. </title> <journal> SIAM J. Control and Optimization, </journal> <volume> 25(3) </volume> <pages> 637-659, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: assembly models, but is the alternative to the modeling the assembly from nothing, which is certainly a complex, time consuming and error prone operation. 5 For the purpose of control we adopt event-based models and the widely accepted supervisory control strategy (based on these models) initiated by Ramadge and Won-ham <ref> [78, 99] </ref> which has been successfully applied to manufacturing and other software/hardware systems (see [4, 10, 47])). Event-based models (reviewed in Chapter II) capture the system dynamics as event sequences. <p> However, most work in the area of supervisor synthesis has focused on off-line supervisor synthesis methods which suffer from problems related to computational complexity and state-space explosion <ref> [26, 63, 79, 78, 96, 99] </ref>. <p> We also introduce some relevant concepts from formal language theory. The framework of supervisory control followed in this thesis was initiated in <ref> [78, 99] </ref>. A good review of this work can be found in [80]. The discrete event system is modeled by a generator (or state machine) G = (; X; ffi; x 0 ; X m ). The set of all possible events of the system is denoted by . <p> Definition 1 L fl is called controllable with respect to L (G) and uc if L uc " L (G) L: Intuitively, it is easy to see that only controllable subsets (sublanguages) of K can be achieved by means of the control method outlined above. In <ref> [99] </ref> it is shown that the supremal controllable sublanguage of K, the optimal solution, denoted by K " , always exists. <p> This problem was first studied in [78]; its optimal solution is the control policy that restricts the behavior of the system to the supremal controllable sublanguage of the legal language <ref> [99] </ref>; this optimal control policy is traditionally synthesized all at once and off-line. Under the general framework adopted in this thesis, we propose to synthesize control policies for SSCP on-line, and by computing each control action as needed, following the execution of each system event. <p> In fact, the total computational effort required by the algorithms presented in this chapter (when no bound is imposed) to produce a complete optimal control policy is no worse than the effort required by the traditional off-line algorithms <ref> [58, 99] </ref>. In addition, state information can be freely carried across lookahead windows, and this stands to significantly improve the control action itself. The availability of state information is dependent on the particular problem under 72 consideration and on the representation chosen for the knowledge about the system.
Reference: [100] <author> W. M. Wonham and P. J. Ramadge. </author> <title> Modular supervisory control of discrete-event systems. </title> <journal> Math. Control Signals Systems, </journal> <volume> 1(1) </volume> <pages> 13-30, </pages> <year> 1988. </year>
Reference-contexts: This corresponds to the usual situation of modular control (see, e.g., <ref> [100] </ref>), with the important difference that the system G is partially observed. By the results in the previous section, the multi-agent DI-VLP-PO algorithm will produce a maximal observable 167 and controllable sublanguage of K. <p> without communication (e.g. by assuming that the remote agents always sends "NEUTRAL"): ACT = S Finally note that when all the events are observed and the entire system consists of a single machine G (i.e., not a shu*e) we are in the usual situation of modular control, as considered in <ref> [100] </ref>. In this case, the modified version of the multi-agent DI-VLP-PO discussed above, becomes an on-line version with communication, of the off-line solution in [100]: The intersection of the control actions that has to be performed after each event execution (in a standard on-line implementation of the solution in [100]) can <p> and the entire system consists of a single machine G (i.e., not a shu*e) we are in the usual situation of modular control, as considered in <ref> [100] </ref>. In this case, the modified version of the multi-agent DI-VLP-PO discussed above, becomes an on-line version with communication, of the off-line solution in [100]: The intersection of the control actions that has to be performed after each event execution (in a standard on-line implementation of the solution in [100]) can in some sense be considered a communication step analogous to the communication via exchange of messages in DI-VLP-PO. <p> in <ref> [100] </ref>. In this case, the modified version of the multi-agent DI-VLP-PO discussed above, becomes an on-line version with communication, of the off-line solution in [100]: The intersection of the control actions that has to be performed after each event execution (in a standard on-line implementation of the solution in [100]) can in some sense be considered a communication step analogous to the communication via exchange of messages in DI-VLP-PO. CHAPTER VIII CONCLUSION Our contributions have been listed in detail in Chapters III, IV, V, VI and VII.
Reference: [101] <author> David D. Yao. </author> <title> An fms network model with state-dependent routing. </title> <booktitle> In Proceedings of The First ORSA/TIMS Special Interest Conference on Flexible Manufacturing Systems, </booktitle> <pages> pages 129-141, </pages> <year> 1984. </year> <month> 186 </month>
Reference-contexts: Examples of such models are queuing and activity networks. Queuing networks (see for example [92] and <ref> [101] </ref>) are probabilistic models typically used during the design and planning stages of a manufacturing system's life-span; they help in evaluating design alternatives by answering questions such as, what is the best factory floor layout and what size should a machine's buffer be.
Reference: [102] <author> MengChu Zhou, Frank DiCesare, and Alan Desrochers. </author> <title> A top-down approach to systematic synthesis of petri net models for manufacturing systems. </title> <booktitle> In Proceedings 1989 IEEE International conference on Robotics and Automation, </booktitle> <pages> pages 534-539, </pages> <month> May 14-19. </month>
Reference-contexts: Hierarchical Petri Nets have also been proposed as a solution to the size problem (see for example <ref> [35, 39, 33, 102] </ref>).
Reference: [103] <author> Michael Zisman. </author> <title> Use of production systems for modelling asynchronous concurrent processes. </title> <editor> In Waterman and Hayes-Roth, editors, </editor> <title> Pattern-Directed Inference Systems. </title> <publisher> Academic Press, </publisher> <year> 1978. </year>
Reference-contexts: Event graphs are a special form of finite state machines (see [51] and [87] for their applications to manufacturing systems). An event graph is a directed graph with a 1 The above can be generalized by viewing the behavior of a system as sequences of sets of parallel events <ref> [103] </ref>. However, when these models are used for solving control problems, the usual approach consists of introducing new events to name each set of parallel events [46]. <p> Other kinds of Petri Nets have been proposed to overcome other problems. See [81] for timed PNS, [37, 13] for stochastic PNS, <ref> [90, 103] </ref> for augmented PNS, [27, 95] for GRAFCETS and [14] for PROT Nets. Timed Petri Nets associate a time constant with each transition (the time it takes the action represented by the transition to execute).
References-found: 104

