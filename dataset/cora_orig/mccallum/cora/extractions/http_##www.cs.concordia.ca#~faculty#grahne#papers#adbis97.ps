URL: http://www.cs.concordia.ca/~faculty/grahne/papers/adbis97.ps
Refering-URL: http://www.cs.concordia.ca/~faculty/grahne/papers/index.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fGosta.Grahne,Matti.Nykaneng@cs.helsinki.fi  
Title: Safety, Translation and Evaluation of Alignment Calculus  
Author: Gosta Grahne Matti Nykanen 
Address: P.O. Box 26, FIN-00014 University of Helsinki, Finland  
Affiliation: Department of Computer Science  
Abstract: In this paper we pursue the study of Alignment Calculus, a declarative string database query language that supports both string querying and restructuring. This language is aimed for applications such as molecular biology databases, where the sequence queries are combinatorial in nature. The declarative nature of this language does, however, require additional effort in its implementation. Here we solve this problem by first defining a domain independent syntactic subset of the full language and then developing a query evaluation mechanism for this sublanguage. This mechanism then handles the required restructuring operations in a finite manner. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> N. Balkir, E. Sukan, G. Ozsoyoglu, and Z. Ozsoyoglu. </author> <title> VISUAL a graphical icon-based query language. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <pages> pages 524-533, </pages> <year> 1996. </year>
Reference-contexts: In any case, the string handling concepts introduced in this work are in no way specific to the relational model; indeed, they are being applied for querying sequences of complex objects from object-oriented databases as well <ref> [1] </ref>. It is quite clear that a database language operating on string relations should have a pattern-matching ability in order to be able to express queries of the form "list all tuples of relation r where the second component is of the form (gc + a) fl ". <p> The purely relational part of the logic is handled by relational calculus. The string part of the logic is state based 1 A 0 b [0; 2] l a ab A 2 b <ref> [0; 1; 2] </ref> l a ab a ab [0] r (as opposed to second or higher order) like for example temporal and dynamic logic.
Reference: [2] <author> S. Chaudhuri and K. Shim. </author> <title> Optimization of queries with user-defined predicates. </title> <booktitle> In Very Large Data Bases Conference, </booktitle> <pages> pages 87-98, </pages> <year> 1996. </year> <month> 8 </month>
Reference-contexts: The purely relational part of the logic is handled by relational calculus. The string part of the logic is state based 1 A 0 b <ref> [0; 2] </ref> l a ab A 2 b [0; 1; 2] l a ab a ab [0] r (as opposed to second or higher order) like for example temporal and dynamic logic. <p> The purely relational part of the logic is handled by relational calculus. The string part of the logic is state based 1 A 0 b [0; 2] l a ab A 2 b <ref> [0; 1; 2] </ref> l a ab a ab [0] r (as opposed to second or higher order) like for example temporal and dynamic logic. <p> Now A 0 j= , because applying to [x 0 ; x 2 ] l yields the transpose t = <ref> [0; 2] </ref> l , and applying this t to the current alignment A 0 leads in turn into alignment A 1 , where A 1 j= was seen to hold. <p> In fact, no reorderings are saved in Example 7 at all, unless the resulting disjuncts are reoredered to apply the string formulae i last. This problem is similar to optimizing left-deep joins with user-defined predicates <ref> [2] </ref>, except that our predicates not only test existing relation columns but also create new ones, and their cost is heavily (even exponentially) influenced by the number of created columns. In other words, we are adding user-defined set-valued functions, whose costs depend on the expected sizes of their values.
Reference: [3] <author> J. Collado-Vides. </author> <title> The search for a grammatical theory of gene regulation is formally justified by showing the inadequacy of context-free grammars. </title> <booktitle> Computer Applications in the Biosciences, </booktitle> <volume> 7(3) </volume> <pages> 321-326, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction In this paper we continue our study of the problem of strings in databases [13]. Our primary source of motivation is the storage and qualitative processing of genetic information represented as sequences of symbols, and therefore amenable to methods from formal language theory <ref> [3, 4, 6, 19, 25, 26, 27] </ref>. Consequently, we have developed a declarative query language for combinatorial sequence queries. <p> However, in applications such as the aforementioned molecular biology databases, the language needs to have expressive power beyond regular sets <ref> [3] </ref>; hence, more expressive grammatic formalisms have been employed in computational biology [4, 6, 16, 25, 26]. In addition to data extraction features, the string language needs also data restructuring constructs [12, 20, 31].
Reference: [4] <author> J. Collado-Vides. </author> <title> Grammatical model of the regulation of gene expression. </title> <booktitle> Proceedings of the National Academy of Sciences of the USA, </booktitle> <volume> 89 </volume> <pages> 9405-9409, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction In this paper we continue our study of the problem of strings in databases [13]. Our primary source of motivation is the storage and qualitative processing of genetic information represented as sequences of symbols, and therefore amenable to methods from formal language theory <ref> [3, 4, 6, 19, 25, 26, 27] </ref>. Consequently, we have developed a declarative query language for combinatorial sequence queries. <p> However, in applications such as the aforementioned molecular biology databases, the language needs to have expressive power beyond regular sets [3]; hence, more expressive grammatic formalisms have been employed in computational biology <ref> [4, 6, 16, 25, 26] </ref>. In addition to data extraction features, the string language needs also data restructuring constructs [12, 20, 31].
Reference: [5] <author> C. Date. </author> <title> An Introduction to Database Systems. </title> <publisher> Addison-Wesley, </publisher> <address> 6th edition, </address> <year> 1994. </year>
Reference-contexts: Because the majority of current relational database management systems do not adequately support application-specific data types such as sequences, some molecular biology database designers have begun to move towards object-oriented database technology [10, Chapter 4]. Another solution, strongly advocated in for instance <ref> [5, Chapter 25] </ref>, is to introduce such types as relational domains, as we have done.
Reference: [6] <author> S. Dong and D. </author> <title> Searls. Gene structure prediction by linguistic methods. </title> <journal> Genomics, </journal> <volume> 23 </volume> <pages> 540-551, </pages> <year> 1994. </year>
Reference-contexts: 1 Introduction In this paper we continue our study of the problem of strings in databases [13]. Our primary source of motivation is the storage and qualitative processing of genetic information represented as sequences of symbols, and therefore amenable to methods from formal language theory <ref> [3, 4, 6, 19, 25, 26, 27] </ref>. Consequently, we have developed a declarative query language for combinatorial sequence queries. <p> However, in applications such as the aforementioned molecular biology databases, the language needs to have expressive power beyond regular sets [3]; hence, more expressive grammatic formalisms have been employed in computational biology <ref> [4, 6, 16, 25, 26] </ref>. In addition to data extraction features, the string language needs also data restructuring constructs [12, 20, 31].
Reference: [7] <author> M. Escobar-Molano, R. Hull, and D. Jacobs. </author> <title> Safety and translation of calculus queries with scalar functions (extended abstract). </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 253-264, </pages> <year> 1993. </year>
Reference-contexts: Finally, a fourth possibility would be to extend string formulae with stronger computational capabilities [19, 20], although in this case it might be problematic to maintain separate logical and operational semantics. An alternative to our productive formulae would have been to employ the embedded allowed (em-allowed) formulae <ref> [7] </ref>. (In particular, the expressive power of Theorems 3.2 and 3.3 would not have been affected.) We did not, however, adopt them, because our situation is different in the following three remarks. 1. <p> The translation of productive Alignment Calculus formulae in QDNF into equivalent finitely evaluable Alignment Algebra expressions is straightforward, once the following auxiliary result is established (see <ref> [7, Lemma 7.10] </ref>). Lemma 3.1 Let ff = a 1 ^: : :^a p be a conjunction of atomic formulae. <p> These implicit copyings are similar to the explicit transformations preceding the translation of an em-allowed formula into an algebraic expression <ref> [7, Transformation T15] </ref>. Choosing the reordering in Lemma 3.1 wisely is of paramount importance in Alignment Calculus, because intermediate results can have exponential size, as noted in Example 7.
Reference: [8] <author> T. Etzold and P. Argos. </author> <title> SRS an indexing and retrieval tool for flat file data libraries. </title> <booktitle> Computer Applications in the Biosciences, </booktitle> <volume> 9(1) </volume> <pages> 49-57, </pages> <year> 1993. </year>
Reference-contexts: In other words, each position in a tuple of a relation contains a finite string of arbitrary length instead of just a single atomic value. Present-day database query languages offer little support for string relations. For example, the Sequence Retrieval System (SRS) <ref> [8] </ref>, which has recently gained popularity in To appear in the First East-European Symposium on Advances in Databases and Information Systems (ADBIS'97), St.-Petersburg (Russia), September 2-5, 1997. molecular biology, does allow the database administrator to draw links from one preformatted data file to another [9], but only on its atomic non-sequence
Reference: [9] <author> T. Etzold and P. Argos. </author> <title> Transforming a set of biological flat file libraries to a fast access network. </title> <booktitle> Computer Applications in the Biosciences, </booktitle> <volume> 9(1) </volume> <pages> 59-64, </pages> <year> 1993. </year>
Reference-contexts: example, the Sequence Retrieval System (SRS) [8], which has recently gained popularity in To appear in the First East-European Symposium on Advances in Databases and Information Systems (ADBIS'97), St.-Petersburg (Russia), September 2-5, 1997. molecular biology, does allow the database administrator to draw links from one preformatted data file to another <ref> [9] </ref>, but only on its atomic non-sequence fields. Because the majority of current relational database management systems do not adequately support application-specific data types such as sequences, some molecular biology database designers have begun to move towards object-oriented database technology [10, Chapter 4].
Reference: [10] <institution> European Molecular Biology Network (EMBNET). </institution> <note> Strategies in Bioinformatics: a European Perspective, </note> <year> 1994. </year>
Reference-contexts: Because the majority of current relational database management systems do not adequately support application-specific data types such as sequences, some molecular biology database designers have begun to move towards object-oriented database technology <ref> [10, Chapter 4] </ref>. Another solution, strongly advocated in for instance [5, Chapter 25], is to introduce such types as relational domains, as we have done.
Reference: [11] <author> M. Garey and D. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. </title> <publisher> Freeman, </publisher> <year> 1979. </year>
Reference-contexts: Then known complexity results <ref> [11, Problem AL5] </ref> lead directly to the following complexity results. 1.
Reference: [12] <author> S. Ginsburg and X. Wang. </author> <title> Pattern matching by rs-operations: Towards a unified approach to querying sequenced data (extended abstract). </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 293-300, </pages> <year> 1992. </year>
Reference-contexts: In addition to data extraction features, the string language needs also data restructuring constructs <ref> [12, 20, 31] </ref>. <p> It is essential to let W depend not only on but also on db; otherwise there would be no domain independent way to express for instance Example 1. The safety concept of Ginsburg and Wang <ref> [12] </ref> falls short in this respect. <p> Note also that one of these buffers can be read in both directions, in contrast to other restructuring automaton models in the literature, where they are regarded as read-only channels <ref> [12, 20] </ref>.
Reference: [13] <author> G. Grahne, M. Nykanen, and E. Ukkonen. </author> <title> Reasoning about strings in databases. </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 303-312, </pages> <year> 1994. </year>
Reference-contexts: 1 Introduction In this paper we continue our study of the problem of strings in databases <ref> [13] </ref>. Our primary source of motivation is the storage and qualitative processing of genetic information represented as sequences of symbols, and therefore amenable to methods from formal language theory [3, 4, 6, 19, 25, 26, 27]. Consequently, we have developed a declarative query language for combinatorial sequence queries. <p> Still, extended temporal logic cannot express, for instance, the two-place predicate of equalness between strings, not to mention predicates such as saying that one string is a manifold of the other. We have therefore defined a logic called Alignment Calculus <ref> [13] </ref>, in which we can express both properties of individual strings and properties relating strings to each other. The purely relational part of the logic is handled by relational calculus. <p> Then for example A 0 j= , because contains the single-step walk such that A 0 j= . String formulae are equivalent to nondeterministic mul-titape finite state automata (FSAs) <ref> [13, Theorems 3.1 and 3.2] </ref>, which then provide an independent operational semantics. The string formula concept could naturally be extended above regular expressions as well [19]. The subclass of right-restricted string formulae is of particular interest. <p> There exists a string formula A with free ( A ) = fx 1 ; x 2 ; x 3 g such that [[9x 2 ; x 3 : A ]] = A, where both quantified variables x 2 and x 3 are bidirectional <ref> [13, Theorem 5.2] </ref>. (This A is therefore not even right-restricted.) From this, the full expressive power of Alignment Calculus is seen to equal the Arithmetical Hierarchy [24, Chapter 14]. <p> Note that this formula contains no relation symbols. We call such formulae pure and drop the subscript from their answers to indicate that they do not depend on the database. The operational equivalent to the Alignment Calculus is the Alignment Algebra <ref> [13, Theorems 3.3 and 3.4] </ref> obtained from relational algebra with the following two modifications. First, selection conditions A (: : :) are expressed using FSAs A. <p> It is, however, unclear whether such decomposition is feasible, or even possible, in view of Example 4, so we pose this comprehensivity restriction on the finiteness dependencies 2 basis () instead. 2.2 Estimates for Limitation Functions While the limitation problem is undecidable in general <ref> [13, Theorem 4.1] </ref>, it remains decidable for the right-restricted string formulae, which explains their importance. It is furthermore known that the corresponding functions are linear in the unidirectional and quadratic in the bidirectional case [14, Theorem 4.2][21, Theorem 5.2]. This can be generalized into the following result. <p> arity k is again finitely evaluable, and the (k + l)-tape FSA A satisfies the limitation property f1; : : : ; kg ; fk + 1; : : : ; k + lg. (The meaning of limitations properties for FSAs carries naturally over from string formulae by their equivalence <ref> [13, Theorems 3.1 and 3.2] </ref>.) Note that these finitely evaluable expressions are indeed compatible with the bottom-up evaluation method advocated in Section 2.1 above.
Reference: [14] <author> G. Grahne, M. Nykanen, and E. Ukkonen. </author> <title> Reasoning about strings in databases. </title> <journal> Journal of Computer and System Sciences, </journal> <note> 1997. To appear. Abstracted in [13]. </note>
Reference-contexts: Finally, Section 4 concludes our presentation. 1.1 Alignment Calculus This section presents an overview of Alignment Calculus. By necessity, this overview must remain at an illustrative level; detailed exposition can be found elsewhere <ref> [14, Section 2] </ref>[21, Section 3]. The basic semantical construction is the alignment. Figure 1 presents five different alignments A 0 ; : : : ; A 4 of the three strings a, b, and ab. A designated window column runs through each alignment. <p> In what follows, the main theme is to identify, and provide an implementation for, such a subclass. 2 Limitation Functions for String Formulae In <ref> [14, Definition 3.1] </ref>[21, Definition 4.2] we introduced the limitation problem as follows. Definition 2.1 Let be a string formula with free () = fx 1 ; : : : ; x k+l g. <p> It is furthermore known that the corresponding functions are linear in the unidirectional and quadratic in the bidirectional case <ref> [14, Theorem 4.2] </ref>[21, Theorem 5.2]. This can be generalized into the following result. <p> Indeed, if x k+2 is also bidirectional, these reasons become so elaborate that the limitation problem becomes undecidable <ref> [14, Theorem 4.1] </ref>[21, Theorem 5.1]. (This can also be seen from Example 4.) The proof of Theorem 2.2 is by estimating as W 0 : N k ! N the size of the graph built during the decision algorithm for the limitation properties of right-restricted string formulae [14, Theorem 4.2][21, Theorem <p> problem becomes undecidable [14, Theorem 4.1][21, Theorem 5.1]. (This can also be seen from Example 4.) The proof of Theorem 2.2 is by estimating as W 0 : N k ! N the size of the graph built during the decision algorithm for the limitation properties of right-restricted string formulae <ref> [14, Theorem 4.2] </ref>[21, Theorem 5.2]. <p> The proof of Theorem 3.2 rests on the earlier expressivity result that A can be chosen from a syntactic subset of pure Alignment Calculus called the quantifier limited formulae <ref> [14, Theorem 5.5] </ref>[21, Lemma 5.1].
Reference: [15] <author> S. Greibach. </author> <title> Checking automata and one-way stack languages. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 3 </volume> <pages> 196-217, </pages> <year> 1969. </year>
Reference-contexts: On the other hand, the evaluation of E seems to become much more complicated, when one of the output buffers is bidirectional. A 2-FSA A with one unidirectional input buffer 1 and one bidirectional output buffer 2 can namely be considered a nondeterministic checking stack automaton C <ref> [15, Definition 1.4] </ref>, which on input u first guesses a stack v to check but not modify, and then verifies that A would accept u and v. Then known complexity results [11, Problem AL5] lead directly to the following complexity results. 1.
Reference: [16] <author> C. Helgesen and P. Sibbald. </author> <title> PALM a pattern language for molecular biology. </title> <booktitle> In International Conference on Intelligent Systems in Molecular Biology, </booktitle> <pages> pages 172-180, </pages> <year> 1993. </year>
Reference-contexts: However, in applications such as the aforementioned molecular biology databases, the language needs to have expressive power beyond regular sets [3]; hence, more expressive grammatic formalisms have been employed in computational biology <ref> [4, 6, 16, 25, 26] </ref>. In addition to data extraction features, the string language needs also data restructuring constructs [12, 20, 31].
Reference: [17] <author> J. Hopcroft and J. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: This is in turn exponential, because the algorithm utilizes a generalization of the crossing sequence construction for converting two-way finite automata into classical ones <ref> [17, Chapter 2.6 and Exercises 2.18 to 2.20] </ref>. (Note that we are not eliminating bidirec-tionality from a right-restricted string formula; indeed, Example 2 already shows this to be impossible. <p> Finally in Sections 3.4 and 3.5 we discuss the translation and subsequent evaluation of these formulae. 3.1 Quantified Disjunctive Normal Form We say that an Alignment Calculus formula is in Quantified Disjunctive Normal Form (QDNF) if its structure adheres to the following context-free grammar <ref> [17, Chapter 4] </ref>. <p> This goal is attained as follows. Intuitively, A can now be considered a kind of an extended automaton A 0 with k input and l output buffers; a kind of an extended Mealy machine, as it were <ref> [17, Chapter 2.7] </ref>, for performing the requested sequence restructuring. Alignment Calculus does not, however, force the database programmer to think in these operational terms while writing queries; instead, the query translator assigns these roles to variables.
Reference: [18] <author> R. Krishnamurthy, R. Ramakrishnan, and O. Shmueli. </author> <title> A framework for testing safety and effective computability. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 52 </volume> <pages> 100-124, </pages> <year> 1996. </year>
Reference-contexts: A third possibility would be to add a fixpoint construct to the language, for example developing a Data-log with string formulae [20] [35, Chapter 5.1], although the interplay of sequence production and fixpoint computation would have to be carefully designed, perhaps using a sophisticated safety analysis <ref> [18] </ref>. Finally, a fourth possibility would be to extend string formulae with stronger computational capabilities [19, 20], although in this case it might be problematic to maintain separate logical and operational semantics.
Reference: [19] <author> F. Lefebvre. </author> <title> A grammar-based unification of several alignment and folding algorithms. </title> <booktitle> In International Conference on Intelligent Systems in Molecular Biology, </booktitle> <pages> pages 143-155, </pages> <year> 1996. </year>
Reference-contexts: 1 Introduction In this paper we continue our study of the problem of strings in databases [13]. Our primary source of motivation is the storage and qualitative processing of genetic information represented as sequences of symbols, and therefore amenable to methods from formal language theory <ref> [3, 4, 6, 19, 25, 26, 27] </ref>. Consequently, we have developed a declarative query language for combinatorial sequence queries. <p> String formulae are equivalent to nondeterministic mul-titape finite state automata (FSAs) [13, Theorems 3.1 and 3.2], which then provide an independent operational semantics. The string formula concept could naturally be extended above regular expressions as well <ref> [19] </ref>. The subclass of right-restricted string formulae is of particular interest. In these formulae, at most one variable is bidirectional; that is, mentioned also inside right transposes [: : :] r . <p> Finally, a fourth possibility would be to extend string formulae with stronger computational capabilities <ref> [19, 20] </ref>, although in this case it might be problematic to maintain separate logical and operational semantics.
Reference: [20] <author> G. Mecca and A. Bonner. </author> <title> Sequences, Datalog and transducers. </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 23-35, </pages> <year> 1995. </year>
Reference-contexts: In addition to data extraction features, the string language needs also data restructuring constructs <ref> [12, 20, 31] </ref>. <p> Thus, we believe our work to be applicable in a broad variety of string database applications. The declarative nature of Alignment Calculus does not immediately suggest an implementation strategy, as pointed out by Mecca and Bonner <ref> [20] </ref>. The problem is to analyse a given declarative query to find out what kinds of basic sequence restructuring and database operations are implictly involved, and whether those operations can be carried out in a finite manner. In this paper we explain how this analysis can be done. <p> The safety concept of Ginsburg and Wang [12] falls short in this respect. Another possible approach would have been to let the domain grow during query evaluation dynamically, but still in a controlled way, as in the Sequence Datalog of Mecca and Bonner <ref> [20] </ref>. 3 As Definition 1.1 encompasses the undecidable domain independence of relational calculus [32, Exercise 3.32], practical query evaluation must restrict its attention into some syntactic subclass of all domain independent Alignment Calculus formulae. <p> Another, related possibility would be to solve some limitation problems not covered by Theorem 2.1 or 2.2 with superpolynomial limit functions. A third possibility would be to add a fixpoint construct to the language, for example developing a Data-log with string formulae <ref> [20] </ref> [35, Chapter 5.1], although the interplay of sequence production and fixpoint computation would have to be carefully designed, perhaps using a sophisticated safety analysis [18]. <p> Finally, a fourth possibility would be to extend string formulae with stronger computational capabilities <ref> [19, 20] </ref>, although in this case it might be problematic to maintain separate logical and operational semantics. <p> Note also that one of these buffers can be read in both directions, in contrast to other restructuring automaton models in the literature, where they are regarded as read-only channels <ref> [12, 20] </ref>.
Reference: [21] <author> M. Nykanen. </author> <title> Alignment Calculus: a modal logic for querying string databases. </title> <type> Technical Report C-1996-97, </type> <institution> Department of Computer Science, University of Hel-sinki, Finland, </institution> <year> 1996. </year>
Reference-contexts: It is even the case that A can be replaced by the conjunction of two unidirectional string formulae 0 A and 00 A <ref> [21, Corollary 6.1] </ref>[14, Corollary 5.1]. Note that this formula contains no relation symbols. We call such formulae pure and drop the subscript from their answers to indicate that they do not depend on the database. <p> In particular, cascading unidirectional selections A ( A 0 (E fi fl )) = A 00 (E fi fl ) may result in a condition A 00 that is not right-restricted <ref> [21, Corollary 5.3] </ref>, and hence might be difficult to evaluate.
Reference: [22] <author> R. Ramakhrisnan, F. Bancilhon, and A. Silberschatz. </author> <title> Safety of recursive Horn clauses with infinite relations (extended abstract). </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 328-339, </pages> <year> 1987. </year>
Reference-contexts: This condition is denoted as = fx 1 ; : : : ; x k g ; fx k+1 ; : : : ; x k+l g, as it is a finiteness dependency <ref> [22] </ref> of [[]]. The limitation problem is then to decide whether a given finiteness dependency holds for the relation [[]] given implicitly as the string formula .
Reference: [23] <author> J. Richardson. </author> <title> Supporting lists in a data model (a timely approach). </title> <booktitle> In Very Large Data Bases Conference, </booktitle> <pages> pages 127-138, </pages> <year> 1992. </year>
Reference-contexts: Both of these goals can be simultaneously attained by a declarative language for expressing properties of strings. Richardson <ref> [23] </ref> suggested using the modalities of temporal logic for this purpose. Each successive position in a string is seen to be the timewise "next" instance of that string. The temporal modalities lend themselves naturally to reasoning about strings.
Reference: [24] <author> H. Rogers. </author> <title> Theory of Recursive Functions and Effective Computability. </title> <publisher> McGraw-Hill, </publisher> <year> 1967. </year>
Reference-contexts: g such that [[9x 2 ; x 3 : A ]] = A, where both quantified variables x 2 and x 3 are bidirectional [13, Theorem 5.2]. (This A is therefore not even right-restricted.) From this, the full expressive power of Alignment Calculus is seen to equal the Arithmetical Hierarchy <ref> [24, Chapter 14] </ref>. It is even the case that A can be replaced by the conjunction of two unidirectional string formulae 0 A and 00 A [21, Corollary 6.1][14, Corollary 5.1]. Note that this formula contains no relation symbols.
Reference: [25] <author> D. Rosenblueth, D. Thieffry, A. Huerta, H. Salgado, and J. Collado-Vides. </author> <title> Syntactic recognition of regulatory regions in Escherichia Coli. </title> <booktitle> Computer Applications in the Biosciences, </booktitle> <volume> 12(5) </volume> <pages> 415-422, </pages> <year> 1996. </year>
Reference-contexts: 1 Introduction In this paper we continue our study of the problem of strings in databases [13]. Our primary source of motivation is the storage and qualitative processing of genetic information represented as sequences of symbols, and therefore amenable to methods from formal language theory <ref> [3, 4, 6, 19, 25, 26, 27] </ref>. Consequently, we have developed a declarative query language for combinatorial sequence queries. <p> However, in applications such as the aforementioned molecular biology databases, the language needs to have expressive power beyond regular sets [3]; hence, more expressive grammatic formalisms have been employed in computational biology <ref> [4, 6, 16, 25, 26] </ref>. In addition to data extraction features, the string language needs also data restructuring constructs [12, 20, 31].
Reference: [26] <author> D. </author> <title> Searls. String Variable Grammar: A logic grammar formalism for the biological language of DNA. </title> <journal> Journal of Logic Programming, </journal> <pages> pages 73-102, </pages> <year> 1995. </year>
Reference-contexts: 1 Introduction In this paper we continue our study of the problem of strings in databases [13]. Our primary source of motivation is the storage and qualitative processing of genetic information represented as sequences of symbols, and therefore amenable to methods from formal language theory <ref> [3, 4, 6, 19, 25, 26, 27] </ref>. Consequently, we have developed a declarative query language for combinatorial sequence queries. <p> However, in applications such as the aforementioned molecular biology databases, the language needs to have expressive power beyond regular sets [3]; hence, more expressive grammatic formalisms have been employed in computational biology <ref> [4, 6, 16, 25, 26] </ref>. In addition to data extraction features, the string language needs also data restructuring constructs [12, 20, 31].
Reference: [27] <author> D. Searls and K. Murphy. </author> <title> Automata-theoretic models of mutation and alignment. </title> <booktitle> In International Conference on Intelligent Systems in Molecular Biology, </booktitle> <pages> pages 341-349, </pages> <year> 1995. </year>
Reference-contexts: 1 Introduction In this paper we continue our study of the problem of strings in databases [13]. Our primary source of motivation is the storage and qualitative processing of genetic information represented as sequences of symbols, and therefore amenable to methods from formal language theory <ref> [3, 4, 6, 19, 25, 26, 27] </ref>. Consequently, we have developed a declarative query language for combinatorial sequence queries.
Reference: [28] <author> P. Seshadri, M. Livny, and R. Ramakrishnan. SEQ: </author> <title> A model for sequence databases. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <pages> pages 232-239, </pages> <year> 1995. </year>
Reference-contexts: Consequently, we have developed a declarative query language for combinatorial sequence queries. This language differs from such languages as SEQ <ref> [28, 29] </ref>, where sequence elements and their underlying order type are distinct domains, in that the queries in our application area are more oriented toward parsing-type tasks than for example computing moving averages on temporally sequenced data [28, Example 2.1]. <p> This language differs from such languages as SEQ [28, 29], where sequence elements and their underlying order type are distinct domains, in that the queries in our application area are more oriented toward parsing-type tasks than for example computing moving averages on temporally sequenced data <ref> [28, Example 2.1] </ref>. We therefore extend the relational model to include finite strings over some finite alphabet (of at least 2 characters) as primary objects of information.
Reference: [29] <author> P. Seshadri, M. Livny, and R. Ramakrishnan. </author> <title> The design and implementation of a sequence database system. </title> <booktitle> In Very Large Data Bases Conference, </booktitle> <pages> pages 99-110, </pages> <year> 1996. </year>
Reference-contexts: Consequently, we have developed a declarative query language for combinatorial sequence queries. This language differs from such languages as SEQ <ref> [28, 29] </ref>, where sequence elements and their underlying order type are distinct domains, in that the queries in our application area are more oriented toward parsing-type tasks than for example computing moving averages on temporally sequenced data [28, Example 2.1].
Reference: [30] <author> L. Stockmeyer. </author> <title> The polynomial-time hierarchy. </title> <journal> Theoretical Computer Science, </journal> <volume> 3 </volume> <pages> 1-22, </pages> <year> 1977. </year>
Reference-contexts: It turns out that these are closely related to the polynomial-time hierarchy PH <ref> [30] </ref>. First, the following result shows that any query in PH has a productive formulation as a right-restricted Alignment Calculus formula; that is, one containing only right-restricted string formulae.
Reference: [31] <author> B. Subramanian, T. Leung, S. Vandenberg, and S. Zdonik. </author> <title> The AQUA approach to querying lists and trees in object-oriented databases. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <pages> pages 80-89, </pages> <year> 1995. </year>
Reference-contexts: In addition to data extraction features, the string language needs also data restructuring constructs <ref> [12, 20, 31] </ref>.
Reference: [32] <author> J. Ullman. </author> <title> Principles of Database and Knowledge-Base Systems, volume I. </title> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference-contexts: In these formulae, at most one variable is bidirectional; that is, mentioned also inside right transposes [: : :] r . All the other variables are unidirect ional and appear only within left transposes [: : :] l . 2 Alignment Calculus is then domain relational calculus <ref> [32, Chapter 3.8] </ref> over string relations equipped with string formulae. The truth of such an Alignment Calculus formula is examined with respect to an assignment and a pair A 0 ; db, and denoted customarily as hA 0 ; dbi j= . <p> domain symbol fl is added to represent all finite strings from the alphabet , together with symbols n , where n 2 N, for all strings u 2 fl of length juj n. 1.2 The Safety Problem in Alignment Calculus Relational calculus has the concept of a domain independent formula <ref> [32, Chapter 3.8] </ref>, whose answer stabilizes once the evaluation domain is "sufficiently large". What sufficiently large means depends in turn on the current database and the formula itself, but for every database there must be some sufficiently large domain. <p> Another possible approach would have been to let the domain grow during query evaluation dynamically, but still in a controlled way, as in the Sequence Datalog of Mecca and Bonner [20]. 3 As Definition 1.1 encompasses the undecidable domain independence of relational calculus <ref> [32, Exercise 3.32] </ref>, practical query evaluation must restrict its attention into some syntactic subclass of all domain independent Alignment Calculus formulae. <p> First, Section 3.1 defines a new normal form for Alignment Calculus, which is an exten sion of the safe DRC proposed by Ullman <ref> [32, Chapter 3.8] </ref>. Then in Section 3.2 we analyze these normalized formulae for limitedness. In Section 3.3 we discuss what kinds of combinatorial queries can be expressed using the formulae that survive this scrutiny. <p> define productive () to mean B ` required () ^ r ^ productive (D k ) ; where B = S p i=1 basis (a i ), required (D k ) = (X [ Y ) " free (D k ) ; ;, and ``' denotes "follows by Armstrong's axioms" <ref> [32, Chapter 7.3] </ref>. This complex rule is justified as follows. By definition, the burden of producing the variables X is on the closest similar conjunction 0 containing , or X = ; if such a 0 does not exist. <p> If they do, each D k is subsequently required to handle its own bound variables (which do exist, by the definition of QDNF) given X [ Y . Note that in our case forming B explicitly is costly. Instead, the closure algorithm for functional dependecies <ref> [32, Algorithm 7.1] </ref> should be replaced with a version which uses heuristics for selecting the next a i from ff to try. For example, Formula (1) is productive by this definition.
Reference: [33] <author> J. Ullman. </author> <title> Principles of Database and Knowledge-Base Systems, volume II. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: Note also that this ordering is implicitly generated during the heuristic closure computation in Formula (4). Applying Lemma 3.1 to Formula (4), we see that Formula (4) can indeed be translated into an equivalent finitely evaluable Alignment Algebra expression, if a variant of the Sideways Information Passing Strategy (SIPS) <ref> [33, Chapter 12.6] </ref> is employed. In fact, Appendix A provides an example of our strategy in its construction of explicit limitation functions for productive formulae. The translation of productive formulae to finitely evaluable expressions is very similar, and also outlined in Appendix A. <p> In other words, we are adding user-defined set-valued functions, whose costs depend on the expected sizes of their values. Finally we remark that some algebraic optimizations <ref> [33, Chapter 11.6] </ref> involving selections are no longer feasible in Alignment Algebra, because subclasses of string formulae are not necessarily closed under the required logical operation.
Reference: [34] <author> A. van Gelder. </author> <title> Deriving constraints among argument sizes in logic programs. </title> <type> Technical Report UCSC-CRL-89-41, </type> <institution> University of Califormia, Santa Cruz, </institution> <year> 1989. </year> <month> 9 </month>
Reference-contexts: More detailed constructions based on the structural analysis of are possible, using analogous techniques to argument size analysis of logic programs <ref> [34] </ref>. For example, tight limitation functions can be obtained for unidirectional string formulae, solving the mismatch between Examples 5 and 6. These constructions are, however, difficult to achieve without sophisticated analysis of , as the next example reveals.
Reference: [35] <author> X. Wang. </author> <title> Pattern Matching by Rs-Operations: Towards a Unified Approach to Querying Sequenced Data. </title> <type> PhD thesis, </type> <institution> University of Southern Carolina, </institution> <year> 1992. </year>
Reference-contexts: Another, related possibility would be to solve some limitation problems not covered by Theorem 2.1 or 2.2 with superpolynomial limit functions. A third possibility would be to add a fixpoint construct to the language, for example developing a Data-log with string formulae [20] <ref> [35, Chapter 5.1] </ref>, although the interplay of sequence production and fixpoint computation would have to be carefully designed, perhaps using a sophisticated safety analysis [18].
Reference: [36] <author> A. Weber. </author> <title> On the lengths of values in a finite transducer. </title> <journal> Acta Informatica, </journal> <volume> 29 </volume> <pages> 663-687, </pages> <year> 1992. </year>
Reference-contexts: Such reformulations require in general the decomposition of a given string formula, here , into others, here into 3 and x 2 7!x 3 ;x 1 7!x 2 3 (the latter of which is then redundant). Indeed, limitation-like problems do appear in the context of such decomposition problems <ref> [36] </ref>.
Reference: [37] <author> P. Wolper. </author> <title> Temporal logic can be more expressive. </title> <journal> Information and Control, </journal> <volume> 56 </volume> <pages> 72-99, </pages> <year> 1983. </year>
Reference-contexts: Richardson [23] suggested using the modalities of temporal logic for this purpose. Each successive position in a string is seen to be the timewise "next" instance of that string. The temporal modalities lend themselves naturally to reasoning about strings. But as shown by Wolper <ref> [37] </ref>, using only the modalities next and until, the language cannot express that a property holds in every even position of the string. Using Wolper's extended temporal logic would be a step in the right direction.
References-found: 37

