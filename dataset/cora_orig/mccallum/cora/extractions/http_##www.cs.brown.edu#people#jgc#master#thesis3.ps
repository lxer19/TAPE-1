URL: http://www.cs.brown.edu/people/jgc/master/thesis3.ps
Refering-URL: http://www.cs.brown.edu/people/jgc/
Root-URL: http://www.cs.brown.edu
Title: The Dynamic Adaptation of Parallel Mesh-Based Computation  
Author: by Jose Gabriel Casta~nos 
Degree: Thesis Submitted in partial fulfillment of the requirements for the Degree of Master of Science in the Department of  
Date: 1989  May 1996  
Address: Argentina,  
Affiliation: Licenciate in Operations Research Universidad Catolica  Computer Science at Brown University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Maria Cecilia Rivara: </author> <title> Selective refinement/derefinement algorithms for sequences of nested triangulations, </title> <journal> International Journal for Numerical Methods in Engineering, </journal> <volume> Vol. 28, </volume> <pages> 2889-2906, </pages> <year> 1989. </year>
Reference-contexts: By considering adaptivity as a whole we obtain new results that are not available when these problems are studied separately. We discuss the difficulties of designing parallel refinement algorithms and we introduce a refinement algorithm based on the Rivara's bisection algorithm for triangular elements <ref> [1] </ref>, [2]. By representing the adapted mesh as a forest of trees of elements we avoid the synchronization problems for which Jones et al use randomization [3]. We propose a new Parallel Nested Repartitioning algorithm that has its roots in the multilevel bisection algorithm of Barnard et al [16]. <p> problem by contrast with the static grid generation approach in which a fixed discretization of the geometry is done in a preprocessing step. 2 Adaptive methods can be schematically described as a feedback process where the auto-matic construction of a quasi-optimal mesh is performed in the course of the computation <ref> [1] </ref>. Rather than using a uniform mesh with grid points evenly spaced on a domain, adaptive mesh refinement techniques place more grid points where the solution is changing rapidly. The mesh is adaptively refined during the computation according to local error estimates on the domain [3]. <p> The refinement of elements is largely a local process. The compatibility of the mesh to the problem topology and correct treatment of the boundaries are not the only requirements for high-quality meshes. In addition it is desirable to have meshes whose elements are <ref> [1] </ref>: * conforming: the intersection of elements is either a common vertex or a common side. * non-degenerate: the interior angles of the elements are bounded away from zero. * smooth: the transition between small and big elements is not abrupt. 5 2.3 Mesh adaptation The following are the two principal <p> In its simplest form it bisects the longest edge of a triangle to form two new triangles with equal area. There are several variants of the serial bisection refinement algorithm. In Figure 1 we illustrate an example of the 2-triangles bisection algorithm <ref> [1] </ref> and [2] described in Figure 2. In Figure 1 (a) the element selected for refinement is shaded. The refinement of this element creates a non-conforming white node on its longest edge. The shaded element in 1 (b) must now be refined to to maintain a conforming mesh. <p> As it can be easily seen, the parallel algorithm is not a perfect parallelization of the serial one and it can result in a different mesh. The serial Rivara's algorithm <ref> [1] </ref> and [2] first selects an element E a from R. It then continues refining all the nonconforming elements 26 that result from the refinement of E a before proceeding with another element from R. In our parallel implementation we ignore this serialization.
Reference: [2] <author> Maria Cecilia Rivara: </author> <title> Algorithms for refining triangular grids suitable for adaptive and multigrid techniques, </title> <journal> International Journal for Numerical Methods in Engineering, </journal> <volume> Vol. 20, </volume> <pages> 745-756, </pages> <year> 1984. </year>
Reference-contexts: By considering adaptivity as a whole we obtain new results that are not available when these problems are studied separately. We discuss the difficulties of designing parallel refinement algorithms and we introduce a refinement algorithm based on the Rivara's bisection algorithm for triangular elements [1], <ref> [2] </ref>. By representing the adapted mesh as a forest of trees of elements we avoid the synchronization problems for which Jones et al use randomization [3]. We propose a new Parallel Nested Repartitioning algorithm that has its roots in the multilevel bisection algorithm of Barnard et al [16]. <p> In its simplest form it bisects the longest edge of a triangle to form two new triangles with equal area. There are several variants of the serial bisection refinement algorithm. In Figure 1 we illustrate an example of the 2-triangles bisection algorithm [1] and <ref> [2] </ref> described in Figure 2. In Figure 1 (a) the element selected for refinement is shaded. The refinement of this element creates a non-conforming white node on its longest edge. The shaded element in 1 (b) must now be refined to to maintain a conforming mesh. <p> As it can be easily seen, the parallel algorithm is not a perfect parallelization of the serial one and it can result in a different mesh. The serial Rivara's algorithm [1] and <ref> [2] </ref> first selects an element E a from R. It then continues refining all the nonconforming elements 26 that result from the refinement of E a before proceeding with another element from R. In our parallel implementation we ignore this serialization.
Reference: [3] <author> Mark T. Jones and Paul E. Plassmann: </author> <title> Parallel algorithms for the adaptive refinement and partitioning of unstructured meshes, </title> <booktitle> Proceedings of the Scalable High-Performance Computing Conference, </booktitle> <address> Knoxville, Tennessee, </address> <year> 1994. </year>
Reference-contexts: By representing the adapted mesh as a forest of trees of elements we avoid the synchronization problems for which Jones et al use randomization <ref> [3] </ref>. We propose a new Parallel Nested Repartitioning algorithm that has its roots in the multilevel bisection algorithm of Barnard et al [16]. It produces high quality partitions at a low cost, a very important requirement for recomputing partitions at runtime. <p> Rather than using a uniform mesh with grid points evenly spaced on a domain, adaptive mesh refinement techniques place more grid points where the solution is changing rapidly. The mesh is adaptively refined during the computation according to local error estimates on the domain <ref> [3] </ref>. Meshes are usually refined for two main reasons: [10]: * to obtain a better solution by increasing the resolution in a particular region (steady case). * to better resolve transient phenomena like shocks in the simulation of stiff unsteady two-dimensional flows [6]. <p> It then marks the nonconforming elements E b and E h for refinement by inserting them in R 1 and invokes the serial refinement algorithm again. 6.1 Refinement collision The parallel algorithm can run into two synchronization problems <ref> [3] </ref>. First, if processor P i refines an element E a and processor P j refines an adjacent element E b , it is possible that each processor could create a different node at the same position. <p> DIME allowed the refinement of triangles but was not able to coarsen them. Also it is not clear how its parallel refinement and load migration work. The Scalable Unstructured Mesh Computation (SUMAA3d) at the Argonne National Laboratories is another related project. The refinement algorithm <ref> [3] </ref> avoids the creation of duplicate nodes in the boundaries of processors by refining the elements in independent 89 PNR algorithm Serial algorithm Initial 1 Ref 2 Ref Initial 1 Ref 2 Ref Send mesh to P 0 20.59 32.85 34.85 21.52 57.24 256.91 Partition 18.05 17.81 18.38 17.70 55.47 267.27
Reference: [4] <author> Dimitri P. Bertsekas and John N. Tsisiklis: </author> <title> Parallel and Distributed Computation: Numerical Methods, </title> <address> 570-579, </address> <publisher> Prentice Hall, </publisher> <address> New Jersey, </address> <year> 1989. </year>
Reference-contexts: We claim that this modification does not affect the quality of the refinement. 6.2 Termination detection The algorithm for detecting the termination of parallel refinement is based on a general termination algorithm in <ref> [4] </ref>. A global termination condition is reached when no element is marked for refinement, so if R is the set of all the elements selected for refinement, then the algorithm finishes when R = ?.
Reference: [5] <author> Ivo Babuska, Jagdish Chandra and Joseph E. Flaherty (eds.): </author> <title> Adaptive computational methods for partial differential equations, </title> <publisher> SIAM, </publisher> <address> Philadelphia, </address> <year> 1983. </year>
Reference: [6] <author> M. Mamman and B. Larrouturou: </author> <title> Dynamical mesh adaptation for two-dimensional reactive flow simulations, Numerical Grid Generation in Computational Fluid Dynamics and Related Fields, </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1991. </year>
Reference-contexts: Meshes are usually refined for two main reasons: [10]: * to obtain a better solution by increasing the resolution in a particular region (steady case). * to better resolve transient phenomena like shocks in the simulation of stiff unsteady two-dimensional flows <ref> [6] </ref>. During the computation the mesh is refined and coarsened (called sometimes fission and fusion operations) as the regions of interest evolve and move. <p> i 1 ; E 0 : : : ; E 0 i n g that replace E i . * if E i 62 R, E i = E 0 The selection of elements for refinement (or coarsening) in R is made by examining the values of an "adaptation criteria" <ref> [6] </ref> that can be related to a discretization error. Usually these refinement methods cause the propagation of the refinement to other mesh elements so 6 an element E i 62 R might also be refined in order to obtain a conforming mesh. Coarsening algorithms have similar problems.
Reference: [7] <author> L. Ferragut, R. Montenegro and L. </author> <title> Plaza: Efficient refinement-derefinement algorithm of nested meshes to solve evolution problems, </title> <booktitle> Communications in Numerical Methods in Engineering, </booktitle> <volume> Vol. 10, </volume> <pages> 403-412, </pages> <year> 1994. </year>
Reference: [8] <author> Kenneth G. Powell, Philip L. Roe and James Quirk: </author> <title> Adaptive-mesh algorithms for computational fluid dynamics, Algorithmic Trends in Computational Fluid Dynamics, </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The success of an adaptive strategy will depend strongly on how well these different modules can communicate with each other. There is a wide variety of strategies for mesh refinement <ref> [8] </ref>. In the remaining part of this section we review some of the most common techniques for mesh generation and refinement. In the following section we introduce a strategy to implement adaptive meshes using a sequence of nested refinements. <p> Among the most common approaches we mention <ref> [8] </ref>: * structured meshes: there is a mapping from the physical space to the computational space. In the computational space the elements appear as squares (in two dimensions) or cubes (in three dimensions) and the neighbors and vertices of an element are easily calculated using an array based data structure.
Reference: [9] <author> J. E. Savage and M. Wloka: </author> <title> Parallelism in Graph Partitioning. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 13, </volume> <pages> 257-272, </pages> <year> 1991. </year> <month> 97 </month>
Reference-contexts: For this reason we have not yet implemented parallel heuristics such as the MOB heuristic <ref> [9] </ref> to try to improve the quality of the partition. 7.2 Using remote references for work migration Although we demonstrated in the previous section how to compute a partition t that balances the work, at this stage of the computation the mesh is still distributed according to an unbalanced partition t1
Reference: [10] <author> Roy Williams: </author> <title> Adaptive parallel meshes with complex geometry, Numerical Grid Gen--eration in Computational Fluid Dynamics and Related Fields, </title> <publisher> North Holland, </publisher> <year> 1991. </year>
Reference-contexts: reduce the complexity of the implementation without significantly affecting the performance. 2 Mesh-based computation The numerical solution of complex partial differential equations using computational resources requires the definition of a domain in which the problem is to be solved and a set of conditions to be applied at its boundaries <ref> [10] </ref>. The continuous domain and boundary conditions are discretized so they become amenable to computer manipulation. A computational mesh M is thereby produced. <p> The mesh is adaptively refined during the computation according to local error estimates on the domain [3]. Meshes are usually refined for two main reasons: <ref> [10] </ref>: * to obtain a better solution by increasing the resolution in a particular region (steady case). * to better resolve transient phenomena like shocks in the simulation of stiff unsteady two-dimensional flows [6]. <p> In the rest of this paper we assume that the domain is discretized using unstructured meshes. 2.2 Mesh generation The generation of meshes for unsteady problems is usually done in two distinct phases <ref> [10] </ref>: * initial mesh creation: involves the creation of a compatible unstructured mesh using the geometry description of the problem domain. The complex topology of the problem is discretized into a set of simpler elements. <p> This method involves the modi fication of the graph structure of the mesh. * p-refinement: can be thought as increasing the amount of information associated with a node without changing the geometry of the mesh <ref> [10] </ref>, where p is the polynomial order of some element. Through the rest of this paper we concentrate mainly on h-refinement although some of the techniques for mesh partitioning and migration are independent of the refinement strategy.
Reference: [11] <author> A. Bowyer: </author> <title> Computing Dirichlet tessalations, </title> <journal> Comp. J., </journal> <volume> 24, 162, </volume> <year> 1981. </year>
Reference: [12] <author> J. E. Akin: </author> <title> Finite Elements for Analysis and Design, </title> <publisher> Academic Press, </publisher> <year> 1994. </year>
Reference-contexts: of elements is either a common vertex or a common side. * non-degenerate: the interior angles of the elements are bounded away from zero. * smooth: the transition between small and big elements is not abrupt. 5 2.3 Mesh adaptation The following are the two principal strategies for mesh refinement <ref> [12] </ref> : * h-refinement: is performed by splitting an element into two or more smaller subele-ments (refinement) or by combining two or more subelements into one element (coarsening). h is a parameter of the size of the elements.
Reference: [13] <author> E. J. Schwabe, G. E. Blelloch, A. Feldmann, O. Ghattas, J. R. Gilbert, G. L. Miller, D. R. O'Hallaron, J. R. Shewchuck and S. Teng: </author> <title> A separator-based framework for automated partitioning and mapping of parallel algorithms for numerical solution of PDEs, </title> <booktitle> Proc. 1992 DAGS Symposium, </booktitle> <year> 1992. </year>
Reference-contexts: W is a set of pairs of adjacent elements so they have at least one node in common. We then use a graph partitioning algorithm to assign elements to processors. It is shown in <ref> [13] </ref> that partitioning by elements has several advantages over partitioning by nodes due to the way the matrix A is computed in the finite element method. The matrix A is the result of an assembly process.
Reference: [14] <author> John J. Barton and Lee R. Nackman: </author> <title> Scientific and Engineering C++: An introduction with advanced techniques and examples, </title> <publisher> Addison Wesley, </publisher> <year> 1994. </year>
Reference: [15] <author> H. D. Simon: </author> <title> Partitioning of unstructured meshes for parallel processing, </title> <journal> Computing Systems Eng., </journal> <year> 1991. </year>
Reference-contexts: The choice of the mesh type determines the data structures and algorithms available for refinement, partitioning and rebalancing. For example, a partitioning method adequate for unstructured meshes such as Recursive Spectral Bisection <ref> [15] </ref> is useless for structured meshes. A refinement algorithm will perform well on some type of meshes but is not recommended for anothers. And the migration algorithm described in Section 7.2 highly depends on how the mesh is actually stored. <p> This algorithm receives as input the partition obtained from the repartitioning of the mesh and migrates the elements and nodes according to this partition. 7.1 The mesh repartitioning problem While the PNR repartitioning algorithm is based on the serial multilevel algorithms presented in <ref> [15] </ref>, [20] and [18] it also makes use of the refinement history to achieve great reductions in execution time and an improvement in the quality of the partitions produced. 35 (a) (b) in 4 processors. <p> END FOR operation is repeated until jG i j is smaller than a defined constant K. * in the partitioning phase standard multilevel methods find a partition of the graph G k using any one of a number of different graph partitioning algorithms such as Recursive Spectral Bisection <ref> [15] </ref>. Note that typically jG k j t jG 0 j so their use of RSB is generally not very expensive. * in the uncoarsening phase these methods project the partition found for G i to the graph G i1 by reversing the collapsing process. <p> This partition is usually computed using a serial computer during a preprocessing step and it is not part of our system. Nevertheless it allows us to compare the quality of the partitions obtained using serial multilevel algorithms with more standard algorithms like Recursive Spectral Bisection 73 <ref> [15] </ref>. Recursive Spectral Bisection is known to produce very good partitions but it is too expensive to use for repartitioning the mesh. Our program assumes that there is an initial partition of the mesh and we generate this partition using Chaco in a preprocessing step.
Reference: [16] <author> S. T. Barnard and H. D. Simon: </author> <title> A fast multilevel implementation of recursive spectral bisection for partitioning unstructured problems, </title> <booktitle> Proceedings of the 6th SIAM conference on Parallel Processing for Scientific Computing, </booktitle> <pages> 711-718, </pages> <year> 1993. </year>
Reference-contexts: By representing the adapted mesh as a forest of trees of elements we avoid the synchronization problems for which Jones et al use randomization [3]. We propose a new Parallel Nested Repartitioning algorithm that has its roots in the multilevel bisection algorithm of Barnard et al <ref> [16] </ref>. It produces high quality partitions at a low cost, a very important requirement for recomputing partitions at runtime. It has a very natural parallel implementation that allows us to partition meshes of arbitrary size. <p> This contraction is implementing by finding a maximal independent set <ref> [16] </ref> or a maximal matching [20].
Reference: [17] <author> S. T. Barnard and H. D. Simon: </author> <title> A parallel implementation of multilevel recursive spectral bisection for application to adaptive unstructured meshes, </title> <booktitle> Proceedings of the 7th SIAM conference on Parallel Processing for Scientific Computing, </booktitle> <pages> 627-632, </pages> <year> 1995. </year>
Reference: [18] <author> G. Karypis and V. Kumar: </author> <title> A fast and high quality multilevel scheme for partitioning irregular graphs, </title> <type> Tech. Rep. CORR 95-035, </type> <institution> University of Minnesota, Dept. of Computer Science, </institution> <year> 1995. </year>
Reference-contexts: This algorithm receives as input the partition obtained from the repartitioning of the mesh and migrates the elements and nodes according to this partition. 7.1 The mesh repartitioning problem While the PNR repartitioning algorithm is based on the serial multilevel algorithms presented in [15], [20] and <ref> [18] </ref> it also makes use of the refinement history to achieve great reductions in execution time and an improvement in the quality of the partitions produced. 35 (a) (b) in 4 processors. The refinement of an element (b) causes the refinement to come back to the processor (c).
Reference: [19] <author> G. Karypis and V. Kumar: </author> <title> Parallel Multilevel Graph Partitioning, </title> <type> Tech. Rep. CORR 95-036, </type> <institution> University of Minnesota, Dept. of Computer Science, </institution> <year> 1995. </year>
Reference-contexts: It has a very natural parallel implementation that allows us to partition meshes of arbitrary size. The collapsing of the vertices is performed locally using the refinement history and avoiding the 1 communication overhead of other partitioning methods <ref> [19] </ref>. Compared to iterative local migration techniques [42] this method does not require several iterations to rebalance the work. <p> We have developed parallel refinement algorithms for unstructured meshes and used the refinement history to develop a Parallel Nested Repartitioning algorithm superior to the algorithms in <ref> [19] </ref> when applied to the partition of adapted meshes. Although we explained the theoretical problems of doing the refinement in parallel our tests showed very little overhead due to communication. We used the Parallel Nested Repartitioning algorithm to compute partitions on the fly.
Reference: [20] <author> B. Hendrickson and R. Leland: </author> <title> A multilevel algorithm for partitioning graphs, </title> <type> Technical Report SAND93-1301, </type> <institution> Sandia National Laboratories, </institution> <year> 1993. </year> <month> 98 </month>
Reference-contexts: This algorithm receives as input the partition obtained from the repartitioning of the mesh and migrates the elements and nodes according to this partition. 7.1 The mesh repartitioning problem While the PNR repartitioning algorithm is based on the serial multilevel algorithms presented in [15], <ref> [20] </ref> and [18] it also makes use of the refinement history to achieve great reductions in execution time and an improvement in the quality of the partitions produced. 35 (a) (b) in 4 processors. The refinement of an element (b) causes the refinement to come back to the processor (c). <p> This contraction is implementing by finding a maximal independent set [16] or a maximal matching <ref> [20] </ref>. Given a graph G (U; F ) where U is a set of vertices and F is a set of edges then U 0 U is an independent set of G if for all v 2 U 0 ; (v; w) 2 F ) w 62 U 0 . <p> We use windows to display the mesh where the elements are colored depending on which processor they are located. P 0 is usually responsible for managing the windows. This processor collects information from all the other processors and broadcasts the user commands to them. Finally we use the Chaco <ref> [20] </ref> graph partitioning program to generate the initial partitions and for some of the mesh repartitioning algorithms. Since Chaco is a sequential program we also run it in P 0 . 8.1 The user interface The user interface is designed around the Tcl/Tk scripting package [28], [29].
Reference: [21] <author> B. Hendrickson and R. Leland: </author> <title> The Chaco user's guide, </title> <type> Technical Report SAND93--2339, </type> <institution> Sandia National Laboratories, </institution> <year> 1993. </year>
Reference-contexts: In theory we can use any serial graph partitioning algorithm without affecting the structure of the PNR algorithm but in practice we use one of two approaches. In one case P P spawns a new process that calls Chaco <ref> [21] </ref>. This process finds a partition of M 1 0 using the multilevel algorithm (or any other partitioning algorithm supported by Chaco) and returns it to P P . In the other case P P computes the partition of M 1 0 directly. <p> The serial multilevel algorithm running in P 0 collapses the elements by computing a matching of the graph. For a complete description of the method see <ref> [21] </ref>. Note that if we were implementing this method in a parallel computer we would require to communicate at each level to find a matching of the graph. The results are shown in Tables 14, 15, 16 and 17. These results are also plotted in Figures 43, 44 and 45.
Reference: [22] <author> B. Hendrickson and R. Leland: </author> <title> The Chaco user's guide, Version 2.0, </title> <type> Technical Report SAND94-2692, </type> <institution> Sandia National Laboratories, </institution> <year> 1995. </year>
Reference: [23] <author> Message Passing Interface Forum: </author> <title> MPI: A Message Passing Interface Standard, </title> <year> 1994. </year>
Reference-contexts: These proxies keep track of the migration of objects as a result of load balancing. To evaluate these ideas we designed and implemented a system in C++. This program runs on a network of workstations (NOW) and uses MPI <ref> [23] </ref> to communicate between processors. The most salient characteristic of adaptive codes is the high sophistication of their data structures. <p> Our program has been designed to run on distributed memory parallel computers. The current version runs in parallel in a network of SUN workstations. For communication we use the MPI <ref> [23] </ref> message passing library. In particular our program uses the MPICH [26] implementation of MPI from the Argonne National Lab. MPI is becoming the standard for message passing libraries and there are efficient implementations for many parallel computers.
Reference: [24] <author> W. Gropp, E. Lusk and A. Skellum: </author> <title> Using MPI: Portable parallel programming with the Message Passing Interface, </title> <publisher> MPI Press, </publisher> <year> 1994. </year>
Reference: [25] <author> M. Snir, S. Otto, S. Huss-Lederman, D. Walker and J. Dongarra: </author> <title> MPI: The complete reference, </title> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference: [26] <author> W. Gropp and E. Lusk: </author> <title> User's Guide for MPICH: A portable Implementation of MPI, </title> <institution> Argonne National Lab and Missisipi State University. </institution>
Reference-contexts: Our program has been designed to run on distributed memory parallel computers. The current version runs in parallel in a network of SUN workstations. For communication we use the MPI [23] message passing library. In particular our program uses the MPICH <ref> [26] </ref> implementation of MPI from the Argonne National Lab. MPI is becoming the standard for message passing libraries and there are efficient implementations for many parallel computers. Although MPI has many different ways of sending a message between two computers we use the standard blocking send and receive.
Reference: [27] <author> R. Butler and E. Lusk: </author> <title> User's guide to the p4 Parallel Programming System, </title> <type> Technical Report ANL-92/17, </type> <institution> Argonne National Laboratory, </institution> <year> 1992. </year>
Reference: [28] <author> B. Welch: </author> <title> Practical Programming in Tcl and Tk, </title> <publisher> Prentice Hall, </publisher> <year> 1995. </year>
Reference-contexts: Since Chaco is a sequential program we also run it in P 0 . 8.1 The user interface The user interface is designed around the Tcl/Tk scripting package <ref> [28] </ref>, [29]. The user is presented with a window that displays the mesh. Using the mouse the user can click on individual elements to select them or it can drag the cursor to select a group of elements.
Reference: [29] <author> J. Ousterhout: </author> <title> Tcl and the Tk Toolkit, </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Since Chaco is a sequential program we also run it in P 0 . 8.1 The user interface The user interface is designed around the Tcl/Tk scripting package [28], <ref> [29] </ref>. The user is presented with a window that displays the mesh. Using the mouse the user can click on individual elements to select them or it can drag the cursor to select a group of elements.
Reference: [30] <author> Sun Microsystems: </author> <title> Tools.h++ Class Library: Introduction and Reference Manual, </title> <address> Sun-Pro, </address> <year> 1993. </year>
Reference-contexts: There is only one FEMesh object per processor. As this class is in essence a container for elements and nodes its two 62 most important data members are a list of pointer to elements and a list of pointers to nodes. These lists are implemented using the Tools++ <ref> [30] </ref> templates library. The list of elements is a list of pointers to the elements in the fine mesh assigned to the processor while the list of nodes is a list of pointers to all the nodes in the processor.
Reference: [31] <author> R. D. Williams: DIME: </author> <note> A User's Manual, Caltech Concurrent Computation Report C3P 861, </note> <year> 1990. </year>
Reference-contexts: This proves that the information from the refinement can be effectively used in the mesh partitioning algorithms. 10 Related projects This project follows the spirit of the Distributed Irregular Mesh Environment (DIME) <ref> [31] </ref>, [43] by Roy Williams at the California Institute of Technology. DIME allowed the refinement of triangles but was not able to coarsen them. Also it is not clear how its parallel refinement and load migration work.
Reference: [32] <author> B. Kernighan and S. Lin: </author> <title> An efficient heuristic procedure for partitioning graphs, </title> <journal> Bell System Technical Journal, </journal> <volume> 29, </volume> <pages> 291-307, </pages> <year> 1970. </year>
Reference-contexts: If u is assigned to processor P q then both r and s are initially assigned to P q . After projecting the partition to G i1 , they typically perform local heuristics such as Kernighan and Lin <ref> [32] </ref> on each G i1 for the purpose of improving the quality of the partition. To implement this algorithm on a parallel computer note that for each level of the coarsening phase we need to compute either an independent set or a matching of the graph. <p> We usually call Chaco for this purpose. This is very fast since jE k j is small. Finally we uncoarsen the graph for each level k &gt; i &gt; 0. At this time we also improve the partition using local heuristics that are a variation on Kernighan-Lin <ref> [32] </ref>. We compare pairs of elements assigned to different processors and if we find that there is an improvement in the quality of the partition, flip them.
Reference: [33] <author> K. Devine, J. Flaherty, R. Loy and S. Wheat: </author> <title> Parallel partitioning strategies for the adaptive solution of conservation laws, Modeling, Mesh Generation and Adaptive Nu 99 merical Methods for Partial Differential Equations, </title> <editor> I. Babuska, W. Henshaw, J Oliger, J. Flaherty, J. Hopcroft and T. Tezduyar (eds.), </editor> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: These independent sets are computed using Monte Carlo methods. Also the partitioning algorithm is based on the Orthogonal Recursive Bisection method. In general is possible to obtain much better partition using multilevel methods. In <ref> [33] </ref>, [42] an adaptive environment for unstructured problems is presented. In this project the migration is only done to adjacent processors using iterative local migration techniques. The load balancing algorithm is done by comparing the work between adjacent processors.
Reference: [34] <author> R. Lohner: </author> <title> Mesh Adaptation in Fluid Mechanics, </title> <journal> Engineering Fracture Mechanics, Pergammon, </journal> <volume> Vol 50, Num 5, </volume> <pages> 819-847, </pages> <year> 1995. </year>
Reference: [35] <author> L. Freitag, M. Jones and P. Plassmann: </author> <title> An Efficient Parallel Algorithm for Mesh Smoothing, </title> <booktitle> Proceedings of the 4th International Meshing Roundtable, Sandia National Laboratories, </booktitle> <pages> 47-58, </pages> <year> 1995. </year>
Reference: [36] <author> N. Hitschfeld: </author> <title> Algorithms and Data Structures for Handling a Fully Flexible Refinement Approach in Mesh Generation, </title> <booktitle> Proceedings of the 4th International Meshing Roundtable, Sandia National Laboratories, </booktitle> <pages> 265-276, </pages> <year> 1995. </year>
Reference: [37] <author> M. Price, C. Stops and G. Butlin: </author> <title> A Medial Object Toolkit for Meshing and Other Applications, </title> <booktitle> Proceedings of the 4th International Meshing Roundtable, Sandia National Laboratories, </booktitle> <pages> 219-229, </pages> <year> 1995. </year>
Reference: [38] <author> D. Vanderstraeten and R. Keunings: </author> <title> Optimized Partitioning of Unstructured Finite Element Meshes, International Journal for Numerical Methods in Engineering, </title> <publisher> John Wiley and Sons, </publisher> <editor> Ltd., </editor> <volume> Vol 38, </volume> <pages> 433-450, </pages> <year> 1995 </year> . 
Reference: [39] <author> P. L. George: </author> <title> Automatic mesh generation : application to finite element method, </title> <publisher> Wiley and Sons, Ltd., </publisher> <year> 1991. </year>
Reference: [40] <author> P. Knupp and S. Steinberg: </author> <title> Fundamentals of grid generation, </title> <publisher> CRC Press, </publisher> <year> 1993. </year>
Reference: [41] <author> L. A. Freitag, M. T. Jones and P. E. Plassmann: </author> <booktitle> New advances in the modeling of high-temperature superconductors, 1994 International Simulation Conference, Grand Challenges in Computer Simulation, </booktitle> <pages> 208-213, </pages> <address> La Jolla, California, </address> <year> 1994. </year>
Reference: [42] <author> C. Ozturan, H.L. deCougny, M. S. Shephard and J. E. Flaherty: </author> <title> Parallel Adaptive Mesh Refinement and Redistribution on Distributed Memory Computers, </title> <type> Technical Report TR93-26, </type> <institution> Department of Computer Science, Rensselaer Polytechnic Institute, </institution> <year> 1993. </year> <month> 100 </month>
Reference-contexts: It has a very natural parallel implementation that allows us to partition meshes of arbitrary size. The collapsing of the vertices is performed locally using the refinement history and avoiding the 1 communication overhead of other partitioning methods [19]. Compared to iterative local migration techniques <ref> [42] </ref> this method does not require several iterations to rebalance the work. Finally we design a mesh data structure where the elements and nodes are not assigned to a fixed processor throughout the computation but can easily migrate from one processor to another in order to rebalance the work. <p> These independent sets are computed using Monte Carlo methods. Also the partitioning algorithm is based on the Orthogonal Recursive Bisection method. In general is possible to obtain much better partition using multilevel methods. In [33], <ref> [42] </ref> an adaptive environment for unstructured problems is presented. In this project the migration is only done to adjacent processors using iterative local migration techniques. The load balancing algorithm is done by comparing the work between adjacent processors.
Reference: [43] <author> G. C. Fox, R. D. Williams and P. C. Messina: </author> <title> Parallel Computing Works!, </title> <publisher> Morgan Kaufmann Publishers, Inc. </publisher> <year> 1994. </year> <month> 101 </month>
Reference-contexts: This proves that the information from the refinement can be effectively used in the mesh partitioning algorithms. 10 Related projects This project follows the spirit of the Distributed Irregular Mesh Environment (DIME) [31], <ref> [43] </ref> by Roy Williams at the California Institute of Technology. DIME allowed the refinement of triangles but was not able to coarsen them. Also it is not clear how its parallel refinement and load migration work.
References-found: 43

