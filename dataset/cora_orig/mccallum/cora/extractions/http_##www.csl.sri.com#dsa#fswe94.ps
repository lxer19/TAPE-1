URL: http://www.csl.sri.com/dsa/fswe94.ps
Refering-URL: http://www.csl.sri.com/dsa/sadl-main.html
Root-URL: 
Title: and Composition of Software Architectures main points are illustrated by means of familiar architectures for
Author: Mark Moriconi and Xiaolei Qian 
Date: December, 1994, pp. 164-174.  
Address: New Orleans, Louisiana,  Menlo Park, California 94025  
Affiliation: of Software Engineering,  Computer Science Laboratory SRI International  
Note: Correctness Appeared in Proceedings of ACM SIGSOFT'94: Symposium on Foundations  The  which must be proved for every architecture.  
Abstract: The design of a large system typically involves the development of a hierarchy of different but related architectures. A criterion for the relative correctness of an architecture is presented, and conditions for architecture composition are defined which ensure that the correctness of a composite architecture follows from the correctness of its parts. Both the criterion and the composition requirements reflect special considerations from the domain of software architecture. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi and L. Lamport, </author> <title> "Composing Specifications", </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 15, No. 1, </volume> <month> January </month> <year> 1993, </year> <pages> pp. 73-132. </pages>
Reference-contexts: Map--pings relate concrete events to abstract events and are used as the basis for comparative simulation, a technique that complements ours. The problem of composition of specifications has been studied in a general semantic framework by Abadi and Lamport <ref> [1] </ref>. Their results are applicable to any domain, whereas our results are syntactic and specialized to the domain of software architecture. The advantage of a syntactic constraint is that it can be checked easily. The disadvantage is that it is more restrictive than semantic composition.
Reference: [2] <author> R. Allen and D. Garlan, </author> <title> "Formalizing Architectural Connection", </title> <booktitle> Proceedings of the Sixteenth International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1994, </year> <pages> pp. 71-80. </pages>
Reference-contexts: The fairness condition is that all values written into shared memory will eventually be read from the memory if it is possible to read them. For comparison purposes, the appendix contains an operational definition of the two forms of communication in standard CSP [8], following Allen and Garlan <ref> [2] </ref>. CSP can be used to model the safety properties, but not the fairness properties. We formalize the semantics of dataflow and shared-memory connections as TLA theories.
Reference: [3] <author> E. Brinksma, B. Jonsson, and F. Orava, </author> <title> "Refining Interfaces of Communicating Systems", </title> <booktitle> TAP-SOFT'91: Lecture Notes in Computer Science 494, </booktitle> <editor> S. Abramsky and T.S.E. Maibaum, Eds., </editor> <publisher> Springer-Verlag, </publisher> <year> 1991, </year> <pages> pp. 297-312. </pages>
Reference-contexts: For example, it is possible to quantify over infinite types (such as integers) and to reason about dynamic architectures with an unbounded number of processes. The technique of Hoare has been applied more recently to architecture by Broy [4], Brinksma <ref> [3] </ref>, and others. Broy's component refinements turn out to be conservative because interface signatures are preserved, but his connection refinements may not be because additional flows could be added to a channel.
Reference: [4] <author> M. Broy, </author> <title> "Compositional Refinement of Interactive Systems", No. </title> <type> 89, </type> <institution> Digital Systems Research Center, Palo Alto, California, </institution> <month> July </month> <year> 1992. </year> <pages> Page 10 </pages>
Reference-contexts: For example, it is possible to quantify over infinite types (such as integers) and to reason about dynamic architectures with an unbounded number of processes. The technique of Hoare has been applied more recently to architecture by Broy <ref> [4] </ref>, Brinksma [3], and others. Broy's component refinements turn out to be conservative because interface signatures are preserved, but his connection refinements may not be because additional flows could be added to a channel. <p> Their results are applicable to any domain, whereas our results are syntactic and specialized to the domain of software architecture. The advantage of a syntactic constraint is that it can be checked easily. The disadvantage is that it is more restrictive than semantic composition. Broy <ref> [4] </ref> gives three operators for composing functional-style architectures, but does not consider the composition of architectures involving multiple styles. 10 Conclusion An architecture for a large, complex system, and even some simple systems, will involve multiple levels of detail expressed in multiple architectural styles.
Reference: [5] <author> T. DeMarco, </author> <title> Structured Analysis and System Spec--ification, </title> <publisher> Yourdan Press, </publisher> <year> 1979. </year>
Reference-contexts: Several notations were developed for describing architectures, including those of Jackson [10], Yourdan and Constantine [17], and De-Marco <ref> [5] </ref>, but little attention was given to understanding the relationship between levels of abstraction. Moriconi and Hare [14] formalized a relationship between levels in a hierarchy and used the technique of Hoare [9] to prove the relative correctness of two stylistically different architectures.
Reference: [6] <author> H. B. Enderton, </author> <title> A Mathematical Introduction to Logic, </title> <publisher> Academic Press, </publisher> <year> 1972. </year>
Reference-contexts: The other associations say that channels are mapped to variables, that output ports are mapped to calls that supply values, and that 6 Note that our languages contain no function symbols. A treatment of them can be found in <ref> [6] </ref>. input ports are mapped to calls that receive values. <p> This requires a definition of the semantics of both forms of connection. We choose an axiomatic style of semantic definition suitable for describing both safety and fairness properties. 7 In general, the range of quantifiers must be restricted to a subset of the concrete domain, see <ref> [6] </ref>. But no restriction is required for our example, because every concrete-level object implements an abstract-level object.
Reference: [7] <author> D. Garlan and M. Shaw, </author> <title> "An Introduction to Software Architecture", </title> <booktitle> In Advances in Software Engineering and Knowledge Engineering, </booktitle> <volume> Volume 1, </volume> <editor> V. Ambriola and G. Tortora, Eds., </editor> <publisher> World Scientific Publishing Company, </publisher> <year> 1993. </year>
Reference-contexts: An abstract architecture usually is smaller and easier to understand; a concrete architecture usually reflects more implementation concerns. A given architecture can be homogeneous (consisting of one style) or heterogeneous (consisting of multiple styles). Garlan and Shaw <ref> [7] </ref> provide a taxonomy of some common styles, including dataflow, pipe-and-filter, client-server, and event-based systems. Before we can consider the relative correctness of two architectures, we first must decide on the meaning of the architectures.
Reference: [8] <author> C.A.R. Hoare, </author> <title> Communicating Sequential Processes, </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: The fairness condition is that all values written into shared memory will eventually be read from the memory if it is possible to read them. For comparison purposes, the appendix contains an operational definition of the two forms of communication in standard CSP <ref> [8] </ref>, following Allen and Garlan [2]. CSP can be used to model the safety properties, but not the fairness properties. We formalize the semantics of dataflow and shared-memory connections as TLA theories.
Reference: [9] <author> C.A.R. Hoare, </author> <title> "Proof of correctness of data representations", </title> <journal> Acta Informatica, </journal> <volume> Vol. 1, No. 4, </volume> <year> 1972, </year> <pages> pp. 271-281. </pages>
Reference-contexts: An interpretation mapping is called a theory interpretation if the mapped axioms of the abstract theory become theorems of the concrete theory. Note that theory interpretation is just Hoare's approach to reasoning about the correctness of implementations <ref> [9] </ref>. We additionally require that, if a sentence is not in the abstract theory, its image is not in the concrete theory. Let fi and fi 0 be theories associated with an abstract and a concrete architecture, respectively. Let I be an interpretation mapping from fi to fi 0 . <p> Moriconi and Hare [14] formalized a relationship between levels in a hierarchy and used the technique of Hoare <ref> [9] </ref> to prove the relative correctness of two stylistically different architectures. Hoare's technique involves a proof of only theory interpretation, and not of faithfulness. They were the first to introduce a completeness assumption for architectures.
Reference: [10] <author> M.A. Jackson, </author> <title> Principles of Program Design, </title> <publisher> Academic Press, </publisher> <year> 1975. </year>
Reference-contexts: Several notations were developed for describing architectures, including those of Jackson <ref> [10] </ref>, Yourdan and Constantine [17], and De-Marco [5], but little attention was given to understanding the relationship between levels of abstraction. Moriconi and Hare [14] formalized a relationship between levels in a hierarchy and used the technique of Hoare [9] to prove the relative correctness of two stylistically different architectures.
Reference: [11] <author> L. Lamport, </author> <title> "The Temporal Logic of Actions", </title> <type> Technical Report 79, </type> <institution> Digital Systems Research Center, Palo Alto, California, </institution> <month> December </month> <year> 1991. </year> <note> (to appear in ACM Transactions on Programming Languages and Systems) </note>
Reference-contexts: ) 7! Holds (t 1 ; t 2 ) Connects (t 1 ; t 2 ; t 3 ) 7! W rites (t 2 ; t 1 ) ^ Reads (t 3 ; t 1 ) In particular, we use a temporal logic, called the Temporal Logic of Actions (TLA) <ref> [11] </ref>, to define dataflow and shared-memory communication: * The semantics of dataflow places minimal restrictions on communication. It says that a multiset of values is transmitted between components. Values can be "lost" and out of order.
Reference: [12] <author> D.C. Luckham, L.M. Augustin, J.J. Kenney, J.S. Vera, D. Bryan, and W. Mann, </author> <title> "Specification and Analysis of System Architecture Using Rapide", </title> <note> to appear in IEEE Transactions on Software Engineering. </note>
Reference-contexts: Brinksma justifies channel splitting on the basis of behavioral reasoning; application of his rule can violate the completeness assumption. A Hoare-style representation mapping has been applied to dynamic architectures by Luckham et al <ref> [12, 13] </ref>. A language called Rapide is used to define executable ar Page 9 chitectures based on distributed event processing. Map--pings relate concrete events to abstract events and are used as the basis for comparative simulation, a technique that complements ours.
Reference: [13] <author> D.C. Luckham, J. Vera, D. Bryan, L. Augustin, and F. Belz", </author> <title> "Partial Orderings of Event Sets and Their Application to Prototyping Concurrent, Timed Systems", </title> <journal> Journal of Systems and Software, </journal> <volume> Vol. 21, No. 3, </volume> <month> June </month> <year> 1993, </year> <pages> pp. 253-265. </pages>
Reference-contexts: Brinksma justifies channel splitting on the basis of behavioral reasoning; application of his rule can violate the completeness assumption. A Hoare-style representation mapping has been applied to dynamic architectures by Luckham et al <ref> [12, 13] </ref>. A language called Rapide is used to define executable ar Page 9 chitectures based on distributed event processing. Map--pings relate concrete events to abstract events and are used as the basis for comparative simulation, a technique that complements ours.
Reference: [14] <author> M. Moriconi and D.F. Hare, </author> <title> "The PegaSys System: Pictures as Formal Documentation of Large Programs", </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 8, No. 4, </volume> <month> October </month> <year> 1986, </year> <pages> pp. 524-546. </pages>
Reference-contexts: Several notations were developed for describing architectures, including those of Jackson [10], Yourdan and Constantine [17], and De-Marco [5], but little attention was given to understanding the relationship between levels of abstraction. Moriconi and Hare <ref> [14] </ref> formalized a relationship between levels in a hierarchy and used the technique of Hoare [9] to prove the relative correctness of two stylistically different architectures. Hoare's technique involves a proof of only theory interpretation, and not of faithfulness. They were the first to introduce a completeness assumption for architectures.
Reference: [15] <author> M. Moriconi, X. Qian, and R. Riemenschneider, </author> <title> "Correct Architecture Refinement", </title> <note> to appear in IEEE Transactions on Software Engineering. </note>
Reference-contexts: By a theorem stated in <ref> [15] </ref> and proved in [16], the fact that induced mapping I 0 maps M back to D is enough to conclude that I D M is faithful. 8 Composing Architectures A useful form of architecture composition is illustrated in Figure 7. <p> Our approach applies to any logic used to represent an architecture; it does not depend on a particular architecture definition language or a particular kind of connector semantics. A more comprehensive treatment of the formal techniques in this paper can be found in a companion paper <ref> [15] </ref>. The work reported here may have implications in sev eral subareas of software-architecture research. * Language design. An architecture definition language (ADL) should treat all refineable objects, including components, interface points, and connectors, as first-class in the sense that they should be named objects with independent meaning. <p> This is true primarily because of the need to establish conservativeness (modulo renaming). An incremental development strategy that minimizes the number and difficulty of architecture-specific proofs is needed. One candidate approach involving correctness-preserving ar chitectural transformations is described in <ref> [15] </ref>. * Style design. Styles are an important vehicle for organizing reusable architectural design information.
Reference: [16] <author> M. Moriconi, X. Qian, and R. Riemenschneider, </author> <title> "A Formal Approach to Correct Refinement of Software Architectures", </title> <type> Technical Report SRI-CSL-94-13, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, California, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: By a theorem stated in [15] and proved in <ref> [16] </ref>, the fact that induced mapping I 0 maps M back to D is enough to conclude that I D M is faithful. 8 Composing Architectures A useful form of architecture composition is illustrated in Figure 7.
Reference: [17] <author> E. Yourdan and L.L. Constantine, </author> <title> Structured Design: Fundamentals of a Discipline of Computer Program and Systems Design, </title> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1979. </year>
Reference-contexts: Several notations were developed for describing architectures, including those of Jackson [10], Yourdan and Constantine <ref> [17] </ref>, and De-Marco [5], but little attention was given to understanding the relationship between levels of abstraction. Moriconi and Hare [14] formalized a relationship between levels in a hierarchy and used the technique of Hoare [9] to prove the relative correctness of two stylistically different architectures.
References-found: 17

