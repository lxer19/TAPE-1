URL: http://www.cs.unc.edu/~anderson/papers/disc99.ps.Z
Refering-URL: http://www.cs.unc.edu/~anderson/papers.html
Root-URL: http://www.cs.unc.edu
Title: Fast and Scalable Mutual Exclusion  
Author: James H. Anderson and Yong-Jik Kim 
Keyword: Fast mutual exclusion, local spinning, read/write atomicity, scalability, shared-memory systems  
Note: Work supported by NSF grant CCR 9732916. The first author was also supported by an Alfred P. Sloan Research Fellowship.  
Address: Chapel Hill  
Affiliation: Department of Computer Science University of North Carolina at  
Abstract: In 1993, Yang and Anderson presented an N-process algorithm for mutual exclusion under read/write atomicity that has fi(log N) time complexity, where "time" is measured by counting remote memory references. This algorithm was obtained by embedding instances of a two-process mutual exclusion algorithm within a binary arbitration tree. In the two-process algorithm that was used, all busy-waiting is done by "local spinning". Performance studies presented by Yang and Anderson showed that their N -process algorithm exhibits scalable performance under heavy contention. One drawback of using an arbitration tree, however, is that each process is required to perform fi(log N ) remote memory operations even when there is no contention. To remedy this problem, Yang and Anderson presented a variant of their algorithm that includes a "fast-path" mechanism that allows the arbitration tree to be bypassed in the absence of contention. This algorithm has the desirable property that contention-free time complexity is O(1). Unfortunately, the the fast-path mechanism that was used caused time complexity under contention to rise to fi(N ) in the worst case. To this day, the problem of designing a read/write mutual exclusion algorithm with O(1) time complexity in the absence of contention and fi(log N ) time complexity under contention has remained open. In this paper, we close this problem by presenting a fast-path mechanism that achieves these time complexity bounds when used in conjunction with Yang and Anderson's arbitration-tree algorithm. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. Anderson. </author> <title> The performance of spin lock alternatives for shared-memory multiprocessors. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 6-16, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: A number of queue-based local-spin mutual exclusion algorithms have been proposed in which only O (1) remote memory references are required for a process to enter and exit its critical section <ref> [1, 4, 6] </ref>. In each of these algorithms, waiting processes form a "spin queue". Read-modify-write instructions are used to enqueue a blocked process onto the end of the queue. Performance studies presented in [1, 4, 6] have shown that these algorithms scale well as contention increases. <p> O (1) remote memory references are required for a process to enter and exit its critical section <ref> [1, 4, 6] </ref>. In each of these algorithms, waiting processes form a "spin queue". Read-modify-write instructions are used to enqueue a blocked process onto the end of the queue. Performance studies presented in [1, 4, 6] have shown that these algorithms scale well as contention increases. In subsequent work, Yang and Anderson raised the question of whether read-modify-write operations are in fact necessary for scalable mutual exclusion [8].
Reference: [2] <author> R. Cypher. </author> <title> The communication requirements of mutual exclusion. </title> <booktitle> In Proceedings of the Seventh Annual Symposium on Parallel Algorithms and Architectures, </booktitle> <pages> pages 147-156, </pages> <year> 1995. </year>
Reference-contexts: Results by Cypher have shown that read/write atomicity is too weak for implementing mutual exclusion with a constant number of remote memory references per critical section access <ref> [2] </ref>. The actual lower bound established by him is an extremely slow-growing function of N . We suspect that (log N ) is probably a tight lower bound for this problem.
Reference: [3] <author> E. Dijkstra. </author> <title> Solution of a problem in concurrent programming control. </title> <journal> Communications of the ACM, </journal> <volume> 8(9):569, </volume> <year> 1965. </year>
Reference-contexts: 1 Introduction The mutual exclusion problem has been studied for many years, dating back to the seminal paper of Dijkstra <ref> [3] </ref>. In this problem, each of a set of N processes repeatedly executes a "critical section" of code. Each process's critical section is preceded by an "entry section" and followed by an "exit section".
Reference: [4] <author> G. Graunke and S. Thakkar. </author> <title> Synchronization algorithms for shared-memory multiprocessors. </title> <journal> IEEE Computer, </journal> <volume> 23 </volume> <pages> 60-69, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: A number of queue-based local-spin mutual exclusion algorithms have been proposed in which only O (1) remote memory references are required for a process to enter and exit its critical section <ref> [1, 4, 6] </ref>. In each of these algorithms, waiting processes form a "spin queue". Read-modify-write instructions are used to enqueue a blocked process onto the end of the queue. Performance studies presented in [1, 4, 6] have shown that these algorithms scale well as contention increases. <p> O (1) remote memory references are required for a process to enter and exit its critical section <ref> [1, 4, 6] </ref>. In each of these algorithms, waiting processes form a "spin queue". Read-modify-write instructions are used to enqueue a blocked process onto the end of the queue. Performance studies presented in [1, 4, 6] have shown that these algorithms scale well as contention increases. In subsequent work, Yang and Anderson raised the question of whether read-modify-write operations are in fact necessary for scalable mutual exclusion [8].
Reference: [5] <author> L. Lamport. </author> <title> A fast mutual exclusion algorithm. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 5(1) </volume> <pages> 1-11, </pages> <month> February </month> <year> 1987. </year>
Reference-contexts: := (false; y:indx); 34: if (:Slot [y:indx] ^ 35: :Proc [y:indx]) then 36: Reset := (true; y:indx + 1 mod N ); 37: Y := (true; y:indx + 1 mod N ) fi; 38: EXIT 2 (1); 39: EXIT N (p) following code fragment from Lamport's fast mutual exclusion algorithm <ref> [5] </ref>. shared variable X: 0::N 1; Y : boolean initially true private variable y: boolean process p:: Noncritical Section; X := p; if :y then "compete with other processes (slow path)" else Y := false; if X 6= p then "compete with other processes (slow path)" else "take the fast path"
Reference: [6] <author> J. Mellor-Crummey and M. Scott. </author> <title> Algorithms for scalable synchronization on shared-memory multiprocessors. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(1) </volume> <pages> 21-65, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: A number of queue-based local-spin mutual exclusion algorithms have been proposed in which only O (1) remote memory references are required for a process to enter and exit its critical section <ref> [1, 4, 6] </ref>. In each of these algorithms, waiting processes form a "spin queue". Read-modify-write instructions are used to enqueue a blocked process onto the end of the queue. Performance studies presented in [1, 4, 6] have shown that these algorithms scale well as contention increases. <p> O (1) remote memory references are required for a process to enter and exit its critical section <ref> [1, 4, 6] </ref>. In each of these algorithms, waiting processes form a "spin queue". Read-modify-write instructions are used to enqueue a blocked process onto the end of the queue. Performance studies presented in [1, 4, 6] have shown that these algorithms scale well as contention increases. In subsequent work, Yang and Anderson raised the question of whether read-modify-write operations are in fact necessary for scalable mutual exclusion [8].
Reference: [7] <author> M. Moir and J. Anderson. </author> <title> Wait-free algorithms for fast, long-lived renaming. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 25(1) </volume> <pages> 1-39, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: Thus, mechanisms for achieving constant time complexity in the absence of contention should remain of interest even if algorithms with better time complexity under contention are developed. The problem of implementing a fast-path mechanism bears some resemblance to the wait-free long-lived renaming problem <ref> [7] </ref>. Indeed, thinking about connections to renaming led us to discover our fast-path algorithm.
Reference: [8] <author> J.-H. Yang and J. Anderson. </author> <title> Fast, scalable synchronization with minimal hardware support. </title> <booktitle> In Proceedings of the 12th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 171-182. </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1993. </year> <month> 13 </month>
Reference-contexts: Performance studies presented in [1, 4, 6] have shown that these algorithms scale well as contention increases. In subsequent work, Yang and Anderson raised the question of whether read-modify-write operations are in fact necessary for scalable mutual exclusion <ref> [8] </ref>. Somewhat surprisingly, they showed that performance comparable to that of the queue-lock algorithms mentioned above could be achieved using only read and write operations. <p> In particular, the writes to the variable Infast can be removed, and the test of Infast in statement 6 can be replaced by a test of a similar variable (specifically the variable C [0] | see <ref> [8] </ref>) used in Yang and Anderson's algorithm. Results by Cypher have shown that read/write atomicity is too weak for implementing mutual exclusion with a constant number of remote memory references per critical section access [2]. The actual lower bound established by him is an extremely slow-growing function of N .
References-found: 8

