URL: http://www.cs.unc.edu/~anderson/papers/rtss96.ps.Z
Refering-URL: http://www.cs.unc.edu/Research/real-time.html
Root-URL: http://www.cs.unc.edu
Title: A Framework for Implementing Objects and Scheduling Tasks in Lock-Free Real-Time Systems  
Author: James H. Anderson and Srikanth Ramamurthy 
Address: Chapel Hill  
Affiliation: Department of Computer Science, University of North Carolina at  
Date: December 1996.  
Note: To be presented at the 17th IEEE Real-Time Systems Symposium,  
Abstract: We present an integrated framework for developing real-time systems in which lock-free algorithms are employed to implement shared objects. There are two key objectives of our work. The first is to enable functionality for object sharing in lock-free real-time systems that is comparable to that in lock-based systems. Our main contribution toward this objective is an efficient approach for implementing multi-object lock-free operations and transactions. A second key objective of our work is to improve upon previously proposed scheduling conditions for tasks that share lock-free objects. When developing such conditions, the key issue is to bound the cost of operation interferences. We present a general approach for doing this, based on linear programming. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Anderson and M. Moir, </author> <title> Universal Constructions for Multi-Object Operations, </title> <booktitle> Proceedings of the 14th Annual ACM Symposium on Principles of Distributed Computing, ACM, </booktitle> <address> New York, </address> <month> August </month> <year> 1995, </year> <pages> pp. 184-193. </pages>
Reference-contexts: A general MWCAS primitive is impractical to provide in hardware, so it must be implemented in software. For our purposes, such an implementation should be lock-free or wait-free. Unfortunately, previous lock-free and wait-free implementations of primitives like MWCAS have rather high worst-case time complexity <ref> [1, 5, 9, 18] </ref>. Thus, they are of limited utility in real-time systems. One of the main contributions of this paper is to show that a wait-free MWCAS primitive can be implemented efficiently if one assumes a priority-based uniprocessor task scheduler. <p> We denote operations by line segments, with time running from left to right. val count valid pid x: 12 2 true 2 Val (x) = 12 y: 3 1 false 3 Val (y) = 22 z: 8 3 true 4 Val (z) = 8 Save <ref> [3; 1] </ref>: 22 Status [3]: 0 (a) val count valid pid x: 5 0 false 4 Val (x) = 12 y: 10 1 false 4 Val (y) = 22 z: 17 2 false 4 Val (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; <p> 22 z: 8 3 true 4 Val (z) = 8 Save <ref> [3; 1] </ref>: 22 Status [3]: 0 (a) val count valid pid x: 5 0 false 4 Val (x) = 12 y: 10 1 false 4 Val (y) = 22 z: 17 2 false 4 Val (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; 1]: 22 Save [4; 2]: 8 Status [4]: 0 (b) val count valid pid x: 5 0 true 4 Val (x) = 5 y: 10 0 true 4 Val (y) = 10 z: 17 0 true 4 Val (z) <p> [3; 1]: 22 Status [3]: 0 (a) val count valid pid x: 5 0 false 4 Val (x) = 12 y: 10 1 false 4 Val (y) = 22 z: 17 2 false 4 Val (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save <ref> [4; 1] </ref>: 22 Save [4; 2]: 8 Status [4]: 0 (b) val count valid pid x: 5 0 true 4 Val (x) = 5 y: 10 0 true 4 Val (y) = 10 z: 17 0 true 4 Val (z) = 17 Status [4]: 2 (c) val count valid pid x: <p> 4 Val (y) = 10 z: 17 0 true 4 Val (z) = 17 Status [4]: 2 (c) val count valid pid x: 12 2 true 2 Val (x) = 12 y: 3 1 false 3 Val (y) = 22 z: 56 4 true 9 Val (z) = 56 Save <ref> [3; 1] </ref>: 22 Status [3]: 1 Status [4]: 1 (d) x, y, and z, with old/new values 12/5, 22/10, and 8/17, respectively.
Reference: [2] <author> J. Anderson, S. Ramamurthy, M. Moir, and K. Jeffay, </author> <title> Lock-Free Transactions for Real-Time Systems, </title> <booktitle> Proceedings of the First International Workshop on Real-Time Databases: Issues and Applications, </booktitle> <month> March </month> <year> 1996, </year> <pages> pp. 107-114. </pages>
Reference-contexts: Lock-Free Transactions The idea of using MWCAS to atomically access many objects can be generalized to implement arbitrary lock-free transactions on memory-resident data. Such an implemen-tation was presented recently by Anderson, Ramamurthy, Moir, and Jeffay <ref> [2] </ref>. In this implementation, memory that can be read and written by transactions is partitioned into blocks of words. These blocks are accessible by means of a bank of pointers, one for each block. <p> [3]: 0 (a) val count valid pid x: 5 0 false 4 Val (x) = 12 y: 10 1 false 4 Val (y) = 22 z: 17 2 false 4 Val (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; 1]: 22 Save <ref> [4; 2] </ref>: 8 Status [4]: 0 (b) val count valid pid x: 5 0 true 4 Val (x) = 5 y: 10 0 true 4 Val (y) = 10 z: 17 0 true 4 Val (z) = 17 Status [4]: 2 (c) val count valid pid x: 12 2 true 2
Reference: [3] <author> J. Anderson, S. Ramamurthy and K. Jeffay, </author> <title> Real-Time Computing with Lock-Free Shared Objects (Extended Abstract), </title> <booktitle> Proceedings of the 16th IEEE Real-Time Systems Symposium, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> Decem-ber </month> <year> 1995, </year> <pages> pp. 28-37. </pages>
Reference-contexts: An alternative to such schemes is to use lock-free algorithms for implementing objects. The general utility of lock-free objects in real-time applications was first established by Anderson, Ramamurthy, and Jeffay <ref> [3] </ref>. Operations on lock-free objects are usually implemented using retry loops. 1 Figure 1 depicts lock-free queue operations fl Work supported by NSF grants CCR 9216421 and CCR 9510156, by an Alfred P. Sloan Research Fellowship, and by a Young InvestigatorAward from the U.S. <p> For example, the enqueue implementation in loop iterations due to interfering concurrent enqueues. Anderson et al. observed that, on a uniprocessor, the cost of such failed loop iterations over an interval of time can be bounded by the number of job releases 3 within that interval <ref> [3] </ref>. This observation is the basis of scheduling conditions presented in [3] for the rate-monotonic (RM) [13], deadline-monotonic (DM) [12], and earliest-deadline-first (EDF) [13] schemes. <p> Anderson et al. observed that, on a uniprocessor, the cost of such failed loop iterations over an interval of time can be bounded by the number of job releases 3 within that interval <ref> [3] </ref>. This observation is the basis of scheduling conditions presented in [3] for the rate-monotonic (RM) [13], deadline-monotonic (DM) [12], and earliest-deadline-first (EDF) [13] schemes. Note that, with lock-free objects, the overhead term is the cost of failed loop iterations, and lower-priority tasks are most likely to pay this overhead cost. <p> Finally, an upper bound on the total cost of interferences in T i and higher-priority tasks during I is calculated using linear programming. We show that this approach can be applied to most common scheduling schemes. The scheduling conditions we derive are much tighter than those originally reported in <ref> [3] </ref>. How do lock-free objects implemented using the results of this paper compare to lock-based implementations? To answer this question, we conducted a number of simulation experiments involving randomly generated sets of tasks that perform both single- and multi-object operations. <p> Note that the current value of each word matches the desired old value. Inset (b) shows the variables after the first phase of m has completed, assuming no interferences by higher-priority tasks. Note that the current value of each word is unchanged. Also, Status <ref> [3] </ref> has been updated to indicate that task T 3 (which must be of lower priority) has been interfered with. <p> Inset (d) shows relevant variables at the termination of m, assuming an interference on word z by task T 9 (which must be of higher-priority) with new value 56. Status [4] is now 1, indicating the failure of T 4 's operation. Status <ref> [3] </ref> is still 1, indicating that T 3 's operation has also failed. Observe that T 4 has successfully restored the original values of words x and y. <p> We denote operations by line segments, with time running from left to right. val count valid pid x: 12 2 true 2 Val (x) = 12 y: 3 1 false 3 Val (y) = 22 z: 8 3 true 4 Val (z) = 8 Save <ref> [3; 1] </ref>: 22 Status [3]: 0 (a) val count valid pid x: 5 0 false 4 Val (x) = 12 y: 10 1 false 4 Val (y) = 22 z: 17 2 false 4 Val (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; <p> We denote operations by line segments, with time running from left to right. val count valid pid x: 12 2 true 2 Val (x) = 12 y: 3 1 false 3 Val (y) = 22 z: 8 3 true 4 Val (z) = 8 Save [3; 1]: 22 Status <ref> [3] </ref>: 0 (a) val count valid pid x: 5 0 false 4 Val (x) = 12 y: 10 1 false 4 Val (y) = 22 z: 17 2 false 4 Val (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; 1]: 22 Save [4; <p> 22 z: 8 3 true 4 Val (z) = 8 Save <ref> [3; 1] </ref>: 22 Status [3]: 0 (a) val count valid pid x: 5 0 false 4 Val (x) = 12 y: 10 1 false 4 Val (y) = 22 z: 17 2 false 4 Val (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; 1]: 22 Save [4; 2]: 8 Status [4]: 0 (b) val count valid pid x: 5 0 true 4 Val (x) = 5 y: 10 0 true 4 Val (y) = 10 z: 17 0 true 4 Val (z) <p> true 4 Val (z) = 8 Save [3; 1]: 22 Status <ref> [3] </ref>: 0 (a) val count valid pid x: 5 0 false 4 Val (x) = 12 y: 10 1 false 4 Val (y) = 22 z: 17 2 false 4 Val (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; 1]: 22 Save [4; 2]: 8 Status [4]: 0 (b) val count valid pid x: 5 0 true 4 Val (x) = 5 y: 10 0 true 4 Val (y) = 10 z: 17 0 true 4 Val (z) = 17 Status [4]: <p> 4 Val (y) = 10 z: 17 0 true 4 Val (z) = 17 Status [4]: 2 (c) val count valid pid x: 12 2 true 2 Val (x) = 12 y: 3 1 false 3 Val (y) = 22 z: 56 4 true 9 Val (z) = 56 Save <ref> [3; 1] </ref>: 22 Status [3]: 1 Status [4]: 1 (d) x, y, and z, with old/new values 12/5, 22/10, and 8/17, respectively. <p> 10 z: 17 0 true 4 Val (z) = 17 Status [4]: 2 (c) val count valid pid x: 12 2 true 2 Val (x) = 12 y: 3 1 false 3 Val (y) = 22 z: 56 4 true 9 Val (z) = 56 Save [3; 1]: 22 Status <ref> [3] </ref>: 1 Status [4]: 1 (d) x, y, and z, with old/new values 12/5, 22/10, and 8/17, respectively. <p> The second set of constraints follows from a result presented in <ref> [3] </ref>, which states that the total number of interferences in all jobs of tasks T 0 through T i in an interval I of length t is bounded by the maximum number of jobs of tasks T 0 through T i1 released in I. <p> The busy point b i (k) is the most recent point in time at or before r i (k) when T i and all higher-priority jobs either release a job or have no unfulfilled demand. In <ref> [3] </ref>, it is shown that if the k th job of T i misses its deadline, and if t is some point in [b i (k); r i (k + 1)), then the difference between the total demand placed on the processor by T i and higher-priority tasks in the interval <p> Predicted BU (BCU) values for lock-based objects are given by blocking predicted. Values for this case were obtained by using the scheduling condition given in [15]. BU (BCU) values predicted by the scheduling conditions presented in this paper and in <ref> [3] </ref> are given by lockfree predicted new and lockfree predicted old, respectively. Observe that the RM scheduling condition presented in this paper is much tighter than that given in [3]. <p> BU (BCU) values predicted by the scheduling conditions presented in this paper and in <ref> [3] </ref> are given by lockfree predicted new and lockfree predicted old, respectively. Observe that the RM scheduling condition presented in this paper is much tighter than that given in [3]. Also, the new condition results in better predications when there are fewer conflicts, and (although not shown here) when most operations are read-only. BU (BCU) values for wait-free objects are given by waitfree; these values were obtained by using the RM scheduling condition in [11].
Reference: [4] <author> T. Baker, </author> <title> Stack-Based Scheduling of Real-Time Processes, </title> <journal> Journal of Real-Time Systems, </journal> <volume> 3(1), </volume> <month> March </month> <year> 1991, </year> <pages> pp. 67-99. </pages>
Reference-contexts: A priority inversion exists when a given task must wait on a task of lower priority to release a critical section. A number of schemes have been proposed to bound blocking times associated with priority inversion; these include the priority inheritance protocol [15, 17], the priority ceiling protocol (PCP) <ref> [4, 15, 17] </ref>, the dynamic PCP (DPCP) [7], and the earliest-deadline-first scheme with dynamic deadline modification (EDF/DDM) [10]. An alternative to such schemes is to use lock-free algorithms for implementing objects. The general utility of lock-free objects in real-time applications was first established by Anderson, Ramamurthy, and Jeffay [3]. <p> Note that the current value of each word is unchanged. Also, Status [3] has been updated to indicate that task T 3 (which must be of lower priority) has been interfered with. Note that changing the value of Status <ref> [4] </ref> from 0 to 2 in inset (b) would have the effect of atomically changing the current value of each of x, y, and z to the desired new value. Inset (c) shows relevant variables at the termination of m, assuming no interferences by higher-priority tasks. <p> Inset (c) shows relevant variables at the termination of m, assuming no interferences by higher-priority tasks. The current value of each word is now the desired new value, and all valid fields are true (so the value of Status <ref> [4] </ref> is no longer relevant). Inset (d) shows relevant variables at the termination of m, assuming an interference on word z by task T 9 (which must be of higher-priority) with new value 56. Status [4] is now 1, indicating the failure of T 4 's operation. <p> the desired new value, and all valid fields are true (so the value of Status <ref> [4] </ref> is no longer relevant). Inset (d) shows relevant variables at the termination of m, assuming an interference on word z by task T 9 (which must be of higher-priority) with new value 56. Status [4] is now 1, indicating the failure of T 4 's operation. Status [3] is still 1, indicating that T 3 's operation has also failed. Observe that T 4 has successfully restored the original values of words x and y. <p> (z) = 8 Save [3; 1]: 22 Status [3]: 0 (a) val count valid pid x: 5 0 false 4 Val (x) = 12 y: 10 1 false 4 Val (y) = 22 z: 17 2 false 4 Val (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save <ref> [4; 0] </ref>: 12 Save [4; 1]: 22 Save [4; 2]: 8 Status [4]: 0 (b) val count valid pid x: 5 0 true 4 Val (x) = 5 y: 10 0 true 4 Val (y) = 10 z: 17 0 true 4 Val (z) = 17 Status [4]: 2 (c) val <p> [3; 1]: 22 Status [3]: 0 (a) val count valid pid x: 5 0 false 4 Val (x) = 12 y: 10 1 false 4 Val (y) = 22 z: 17 2 false 4 Val (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save <ref> [4; 1] </ref>: 22 Save [4; 2]: 8 Status [4]: 0 (b) val count valid pid x: 5 0 true 4 Val (x) = 5 y: 10 0 true 4 Val (y) = 10 z: 17 0 true 4 Val (z) = 17 Status [4]: 2 (c) val count valid pid x: <p> [3]: 0 (a) val count valid pid x: 5 0 false 4 Val (x) = 12 y: 10 1 false 4 Val (y) = 22 z: 17 2 false 4 Val (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; 1]: 22 Save <ref> [4; 2] </ref>: 8 Status [4]: 0 (b) val count valid pid x: 5 0 true 4 Val (x) = 5 y: 10 0 true 4 Val (y) = 10 z: 17 0 true 4 Val (z) = 17 Status [4]: 2 (c) val count valid pid x: 12 2 true 2 <p> count valid pid x: 5 0 false 4 Val (x) = 12 y: 10 1 false 4 Val (y) = 22 z: 17 2 false 4 Val (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; 1]: 22 Save [4; 2]: 8 Status <ref> [4] </ref>: 0 (b) val count valid pid x: 5 0 true 4 Val (x) = 5 y: 10 0 true 4 Val (y) = 10 z: 17 0 true 4 Val (z) = 17 Status [4]: 2 (c) val count valid pid x: 12 2 true 2 Val (x) = 12 <p> [3]: 1 Save [4; 0]: 12 Save [4; 1]: 22 Save [4; 2]: 8 Status <ref> [4] </ref>: 0 (b) val count valid pid x: 5 0 true 4 Val (x) = 5 y: 10 0 true 4 Val (y) = 10 z: 17 0 true 4 Val (z) = 17 Status [4]: 2 (c) val count valid pid x: 12 2 true 2 Val (x) = 12 y: 3 1 false 3 Val (y) = 22 z: 56 4 true 9 Val (z) = 56 Save [3; 1]: 22 Status [3]: 1 Status [4]: 1 (d) x, y, and z, with old/new <p> 0 true 4 Val (z) = 17 Status <ref> [4] </ref>: 2 (c) val count valid pid x: 12 2 true 2 Val (x) = 12 y: 3 1 false 3 Val (y) = 22 z: 56 4 true 9 Val (z) = 56 Save [3; 1]: 22 Status [3]: 1 Status [4]: 1 (d) x, y, and z, with old/new values 12/5, 22/10, and 8/17, respectively. <p> The cost of a lock-based operation includes the cost of acquiring and releasing a lock; for lock-based objects, an implementation based on the stack resource policy was assumed <ref> [4] </ref>. If the conflicts parameter is k, then at least one object is accessed by k tasks, and no object is accessed by more than k tasks. In our experiments, tasks were modeled as a sequence of three phases, of which only the second is an object-access phase.
Reference: [5] <author> G. Barnes, </author> <title> A Method for Implementing Lock-Free Shared Data Structures, </title> <booktitle> Proceedings of the Fifth Annual ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <year> 1993, </year> <pages> pp. 261-270. </pages>
Reference-contexts: A general MWCAS primitive is impractical to provide in hardware, so it must be implemented in software. For our purposes, such an implementation should be lock-free or wait-free. Unfortunately, previous lock-free and wait-free implementations of primitives like MWCAS have rather high worst-case time complexity <ref> [1, 5, 9, 18] </ref>. Thus, they are of limited utility in real-time systems. One of the main contributions of this paper is to show that a wait-free MWCAS primitive can be implemented efficiently if one assumes a priority-based uniprocessor task scheduler.
Reference: [6] <author> S. Baruah, R. Howell, and L. Rosier, </author> <title> Feasibility Problems for Recurring Tasks on One Processor, </title> <journal> Theoretical Computer Science, </journal> <volume> 118, </volume> <year> 1993, </year> <pages> pp. 3-20. </pages>
Reference-contexts: In particular, we only need to consider values less than or equal to the least common multiple (LCM) of the task periods. (If an upper bound on the utilization available for the tasks is known, then we can restrict t to a much smaller range <ref> [6] </ref>.) 4. Simulation Results In this section, we present results from simulation experiments conducted to compare lock-free, wait-free, and lock-based object implementations under the RM scheme.
Reference: [7] <author> M. I. Chen and K. J. Lin, </author> <title> Dynamic Priority Ceiling: A Concurrency Control Protocol for Real Time Systems, </title> <journal> Journal of Real-Time Systems, </journal> <volume> 2(1), </volume> <year> 1990, </year> <pages> pp. 325-346. </pages>
Reference-contexts: A number of schemes have been proposed to bound blocking times associated with priority inversion; these include the priority inheritance protocol [15, 17], the priority ceiling protocol (PCP) [4, 15, 17], the dynamic PCP (DPCP) <ref> [7] </ref>, and the earliest-deadline-first scheme with dynamic deadline modification (EDF/DDM) [10]. An alternative to such schemes is to use lock-free algorithms for implementing objects. The general utility of lock-free objects in real-time applications was first established by Anderson, Ramamurthy, and Jeffay [3].
Reference: [8] <author> M. Herlihy and J. Wing, </author> <title> Linearizability: A Correctness Condition for Concurrent Objects, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(3), </volume> <month> July </month> <year> 1990, </year> <pages> pp. 463-492. </pages>
Reference-contexts: Another subtlety involves the conditions under which a MWCAS operation may fail. Strictly speaking, it should be possible to linearize any MWCAS operation to some point during its execution at which it appears to take effect <ref> [8] </ref>. Successful MWCAS operations can be linearized to the state at which line 18 is executed.
Reference: [9] <author> A. Israeli and L. Rappoport, </author> <title> Disjoint-Access-Parallel Implementations of Strong Shared Memory Primitives, </title> <booktitle> Proceedings of the 13th Annual ACM Symposium on Principles of Distributed Computing, ACM, </booktitle> <address> New York, </address> <month> August </month> <year> 1994, </year> <pages> pp. 151-160. </pages>
Reference-contexts: A general MWCAS primitive is impractical to provide in hardware, so it must be implemented in software. For our purposes, such an implementation should be lock-free or wait-free. Unfortunately, previous lock-free and wait-free implementations of primitives like MWCAS have rather high worst-case time complexity <ref> [1, 5, 9, 18] </ref>. Thus, they are of limited utility in real-time systems. One of the main contributions of this paper is to show that a wait-free MWCAS primitive can be implemented efficiently if one assumes a priority-based uniprocessor task scheduler.
Reference: [10] <author> K. Jeffay, </author> <title> Scheduling Sporadic Tasks with Shared Resources in Hard Real-Time Systems, </title> <booktitle> Proceedings of the 13th IEEE Symposium on Real-Time Systems, </booktitle> <address> Phoenix, AZ, </address> <year> 1992, </year> <pages> pp. 89-99. </pages>
Reference-contexts: A number of schemes have been proposed to bound blocking times associated with priority inversion; these include the priority inheritance protocol [15, 17], the priority ceiling protocol (PCP) [4, 15, 17], the dynamic PCP (DPCP) [7], and the earliest-deadline-first scheme with dynamic deadline modification (EDF/DDM) <ref> [10] </ref>. An alternative to such schemes is to use lock-free algorithms for implementing objects. The general utility of lock-free objects in real-time applications was first established by Anderson, Ramamurthy, and Jeffay [3].
Reference: [11] <author> J. Lehoczky, L. Sha, and Y. Ding, </author> <title> The Rate Monotonic Scheduling Algorithm: Exact Characterization and Average Case Behavior, </title> <booktitle> Proceedings of the Tenth IEEE Real-Time Systems Symposium, </booktitle> <address> Santa Monica, CA, </address> <year> 1989, </year> <pages> pp. 166-171. </pages>
Reference-contexts: Also, the new condition results in better predications when there are fewer conflicts, and (although not shown here) when most operations are read-only. BU (BCU) values for wait-free objects are given by waitfree; these values were obtained by using the RM scheduling condition in <ref> [11] </ref>. Experimental BCU values are not tabulated for this case because the RM condition in [11] is necessary and sufficient. Our simulations indicate that only the cost ratio parameter significantly affects relative performance. Simulations for different r/w ratios and other nesting probabilities (not shown here) resulted in similar graphs. <p> BU (BCU) values for wait-free objects are given by waitfree; these values were obtained by using the RM scheduling condition in <ref> [11] </ref>. Experimental BCU values are not tabulated for this case because the RM condition in [11] is necessary and sufficient. Our simulations indicate that only the cost ratio parameter significantly affects relative performance. Simulations for different r/w ratios and other nesting probabilities (not shown here) resulted in similar graphs. In examining the effects of various cost ratios, it is best to focus on BCU values.
Reference: [12] <author> J.Y.T. Leung and J. Whitehead, </author> <title> On the Complexity of Fixed-Priority Scheduling of Periodic, Real-Time Tasks, Performance Evaluation, </title> <type> 2(4), </type> <year> 1982, </year> <pages> pp. 237-250. </pages>
Reference-contexts: This observation is the basis of scheduling conditions presented in [3] for the rate-monotonic (RM) [13], deadline-monotonic (DM) <ref> [12] </ref>, and earliest-deadline-first (EDF) [13] schemes. Note that, with lock-free objects, the overhead term is the cost of failed loop iterations, and lower-priority tasks are most likely to pay this overhead cost.
Reference: [13] <author> C. Liu and J. Layland, </author> <title> Scheduling Algorithms for Multiprogramming in a Hard Real-Time Environment, </title> <journal> Journal of the ACM, </journal> <volume> 30, </volume> <month> Jan. </month> <year> 1973, </year> <pages> pp. 46-61. </pages>
Reference-contexts: Anderson et al. observed that, on a uniprocessor, the cost of such failed loop iterations over an interval of time can be bounded by the number of job releases 3 within that interval [3]. This observation is the basis of scheduling conditions presented in [3] for the rate-monotonic (RM) <ref> [13] </ref>, deadline-monotonic (DM) [12], and earliest-deadline-first (EDF) [13] schemes. Note that, with lock-free objects, the overhead term is the cost of failed loop iterations, and lower-priority tasks are most likely to pay this overhead cost. <p> This observation is the basis of scheduling conditions presented in [3] for the rate-monotonic (RM) <ref> [13] </ref>, deadline-monotonic (DM) [12], and earliest-deadline-first (EDF) [13] schemes. Note that, with lock-free objects, the overhead term is the cost of failed loop iterations, and lower-priority tasks are most likely to pay this overhead cost.
Reference: [14] <author> A. Mok, </author> <title> Fundamental Design Problems of Distributed Systems for the Hard Real-Time Environment, </title> <type> Ph.D. Thesis, </type> <institution> MIT Laboratory for Computer Science, </institution> <year> 1983. </year>
Reference-contexts: Then, the current value of w, denoted Val (w), is defined as follows. 4 The only common scheduling policy that we know of that violates these requirements is least-laxity-first (LLF) scheduling <ref> [14] </ref>.
Reference: [15] <author> R. Rajkumar, </author> <title> Synchronization In Real-Time Systems APriority Inheritance Approach, </title> <publisher> Kluwer Academic Publications, </publisher> <year> 1991. </year>
Reference-contexts: A priority inversion exists when a given task must wait on a task of lower priority to release a critical section. A number of schemes have been proposed to bound blocking times associated with priority inversion; these include the priority inheritance protocol <ref> [15, 17] </ref>, the priority ceiling protocol (PCP) [4, 15, 17], the dynamic PCP (DPCP) [7], and the earliest-deadline-first scheme with dynamic deadline modification (EDF/DDM) [10]. An alternative to such schemes is to use lock-free algorithms for implementing objects. <p> A priority inversion exists when a given task must wait on a task of lower priority to release a critical section. A number of schemes have been proposed to bound blocking times associated with priority inversion; these include the priority inheritance protocol [15, 17], the priority ceiling protocol (PCP) <ref> [4, 15, 17] </ref>, the dynamic PCP (DPCP) [7], and the earliest-deadline-first scheme with dynamic deadline modification (EDF/DDM) [10]. An alternative to such schemes is to use lock-free algorithms for implementing objects. The general utility of lock-free objects in real-time applications was first established by Anderson, Ramamurthy, and Jeffay [3]. <p> Predicted BU (BCU) values for lock-based objects are given by blocking predicted. Values for this case were obtained by using the scheduling condition given in <ref> [15] </ref>. BU (BCU) values predicted by the scheduling conditions presented in this paper and in [3] are given by lockfree predicted new and lockfree predicted old, respectively. Observe that the RM scheduling condition presented in this paper is much tighter than that given in [3].
Reference: [16] <author> S. Ramamurthy, M. Moir, and J. Anderson, </author> <title> Real-Time Object Sharing with Minimal System Support, </title> <booktitle> Proceedings of the 15th Annual ACM Symposium on Principles of Distributed Computing, ACM, </booktitle> <address> New York, </address> <month> May </month> <year> 1996, </year> <pages> pp. 233-242. </pages>
Reference-contexts: Our implementation of MWCAS was inspired by recent results of Ramamurthy, Moir, and Anderson, who were the first to realize that properties of priority-based schedulers can be exploited to simplify wait-free (and lock-free) algorithms <ref> [16] </ref>. The basis of this realization is the fact that certain task interleavings cannot occur when using such schedulers. <p> In the following subsection, we consider the question of how to implement such a primitive efficiently. 2.2. A Wait-Free Implementation of MWCAS associated Read primitive. The implementation requires a CAS instruction. Requiring CAS is not a severe limitation, because Ramamurthy et al. <ref> [16] </ref> have shown that CAS can be implemented on most priority-based real-time systems from reads and writes with time complexity that is linear in the number of tasks sharing a common object. <p> For example, CAS is provided in hardware on the Motorola 680x0 line of processors and on the Intel Pentium. It can be implemented in constant time on the Intel 80x86 line of processors using a memory-to-memory move instruction (see <ref> [16] </ref> for details), and on the PowerPC using load-linked and store-conditional instructions. In our implementation, a task performs a MWCAS operation on a collection of words by invoking the MWCAS procedure. <p> In fact, if one assumes a conventional asynchronous task model, then the implementation does not work. The priority-based task model assumed here is the same as that considered in the work of Ramamurthy et al. <ref> [16] </ref>. This model is characterized by two simple requirements: (i) a task's priority may change over time, but not during a MWCAS or Read operation; (ii) if a given task has an enabled statement at a state, then no lower-priority task has an enabled statement at that state.
Reference: [17] <author> L. Sha, R. Rajkumar, and J. Lehoczky, </author> <title> Priority Inheritance Protocols: An Approach to Real-Time System Synchronization, </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39(9), </volume> <year> 1990, </year> <pages> pp. 1175-1185. </pages>
Reference-contexts: A priority inversion exists when a given task must wait on a task of lower priority to release a critical section. A number of schemes have been proposed to bound blocking times associated with priority inversion; these include the priority inheritance protocol <ref> [15, 17] </ref>, the priority ceiling protocol (PCP) [4, 15, 17], the dynamic PCP (DPCP) [7], and the earliest-deadline-first scheme with dynamic deadline modification (EDF/DDM) [10]. An alternative to such schemes is to use lock-free algorithms for implementing objects. <p> A priority inversion exists when a given task must wait on a task of lower priority to release a critical section. A number of schemes have been proposed to bound blocking times associated with priority inversion; these include the priority inheritance protocol [15, 17], the priority ceiling protocol (PCP) <ref> [4, 15, 17] </ref>, the dynamic PCP (DPCP) [7], and the earliest-deadline-first scheme with dynamic deadline modification (EDF/DDM) [10]. An alternative to such schemes is to use lock-free algorithms for implementing objects. The general utility of lock-free objects in real-time applications was first established by Anderson, Ramamurthy, and Jeffay [3].
Reference: [18] <author> N. Shavit and D. Touitou, </author> <title> Software Transactional Memory, </title> <booktitle> Proceedings of the 14th Annual ACM Symposium on Principles of Distributed Computing, ACM, </booktitle> <address> New York, </address> <month> August </month> <year> 1995, </year> <pages> pp. 204-213. </pages>
Reference-contexts: A general MWCAS primitive is impractical to provide in hardware, so it must be implemented in software. For our purposes, such an implementation should be lock-free or wait-free. Unfortunately, previous lock-free and wait-free implementations of primitives like MWCAS have rather high worst-case time complexity <ref> [1, 5, 9, 18] </ref>. Thus, they are of limited utility in real-time systems. One of the main contributions of this paper is to show that a wait-free MWCAS primitive can be implemented efficiently if one assumes a priority-based uniprocessor task scheduler.
References-found: 18

