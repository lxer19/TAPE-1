URL: ftp://ftp.cs.cornell.edu/pub/brd/scheme-mobile-robots.ps.Z
Refering-URL: http://www.cs.cornell.edu/Info/Projects/csrvl/mems.html
Root-URL: 
Title: Program Mobile Robots in Scheme concurrent applications easier to write, the run-time library provides multitasking
Author: Jonathan Rees Bruce Donald 
Note: To make  
Address: Ithaca, NY 14850  
Affiliation: Computer Science Robotics and Vision Laboratory Cornell University  
Abstract: We have implemented a software environment that permits a small mobile robot to be programmed using the Scheme programming language[3]. The environment supports incremental modifications to running programs and interactive debugging using a distributed read-evaluate-print loop. To ensure that the programming environment consumes a minimum of the robot's scarce on-board resources, it separates the essential on-board run-time system from the development environment, which runs on a separate workstation. The development environment takes advantage of the workstation's large address space and user environment. It is fully detachable, so that the robot can operate autonomously if desired, and can be reat-tached for retrospective analysis of the robot's behavior. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Harold Abelson and Gerald Jay Sussman. </author> <title> Lisp: A language for stratified design. </title> <journal> BYTE, </journal> <month> February </month> <year> 1988, </year> <pages> pages 207-218. </pages>
Reference-contexts: IRI-8802390 and IRI-9000532 and by a Presidential Young Investigator award to Bruce Donald, and in part by the Air Force Office of Sponsored Research, the Mathematical Sciences Institute, Intel Corporation, and AT&T Bell Laboratories. ity to use a functional programming style all aid the development of concise and reliable programs <ref> [1] </ref>. In this paper we promote the application of the Scheme dialect of Lisp to programming a mobile robot system whose limited resources might contraindicate the use of high-level language features and an integrated programming environment. The following example gives the flavor of the Scheme system.
Reference: [2] <author> Rodney A. Brooks. </author> <title> A robust layered control system for a mobile robot. </title> <booktitle> IEEE JRA RA-2 </booktitle> (1):14-23, 1986. 
Reference-contexts: We would like to experiment with and compare various programming language constructs and paradigms for describing robot control systems. Scheme should be an ideal medium for this. Of particular interest to us are subsumption architecture <ref> [2] </ref>, ALFA [7], and Amala [5]. Performance may be a problem in the future. Any interpreter for a virtual instruction set is likely to be 20 to 30 times slower than equivalent code compiled for the target hardware.
Reference: [3] <editor> William Clinger and Jonathan A. Rees, editors. </editor> <title> The revised 4 report on the algorithmic language Scheme. Lisp Pointers 4(3), </title> <publisher> ACM, </publisher> <year> 1991. </year>
Reference: [4] <author> William Clinger. </author> <title> The Scheme 311 compiler: An exercise in denotational semantics. </title> <booktitle> In Conference Record of the 1984 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 356-364. </pages>
Reference-contexts: Figure 3 summarizes the major software components of the Scheme system. 3.1 Run-time environment The run-time environment builds on the Scheme48 virtual machine architecture [12]. The virtual machine is byte-code based and stack-oriented, closely resembling the target machine of the Scheme 311 compiler <ref> [4] </ref>, and similar in spirit to [8]. The VM handles memory management: allocation instructions (such as cons) can cause garbage collections. The virtual machine is implemented by an interpreter and garbage collector written in C. Compiled for the 68000, the virtual machine consumes about 24 Kbytes of EPROM.
Reference: [5] <author> Mike Dixon. </author> <title> Embedded Computation and the Semantics of Programs. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1991. </year>
Reference-contexts: We would like to experiment with and compare various programming language constructs and paradigms for describing robot control systems. Scheme should be an ideal medium for this. Of particular interest to us are subsumption architecture [2], ALFA [7], and Amala <ref> [5] </ref>. Performance may be a problem in the future. Any interpreter for a virtual instruction set is likely to be 20 to 30 times slower than equivalent code compiled for the target hardware.
Reference: [6] <author> Bruce Donald and Jim Jennings. </author> <title> Constructive recognizability for task-directed robot programming. </title> <booktitle> In Proceedings of the 1992 IEEE International Conference on Robotics and Automation. </booktitle>
Reference-contexts: In particular, we intend to use the mobile robot for testing a mathematical theory of task-directed sensing and planning <ref> [6] </ref>. As the Scheme system continues to be exercised, opportunities to improve the programming infrastructure will continue to arise. The communications software needs to be made more robust, and further debugging aids, including a trace package and inspector, need to be implemented.
Reference: [7] <author> Erann Gat. ALFA: </author> <title> A language for programming reactive robotics control systems. </title> <booktitle> Proceedings of the 1991 IEEE International Conference on Robotics and Automation, </booktitle> <pages> pages 1116-1121. </pages>
Reference-contexts: The future construct [9] would be easy to implement in the Scheme virtual machine, but is probably inappropriate in this context, since its purpose is exploiting parallelism, not programming embedded systems. While there has been some work on special-purpose robot control languages (see e.g. [11] and review in <ref> [7] </ref>), we considered it safer to hedge our bets by putting our effort into building an uncommitted general-purpose infrastructure. 6 Future work Members of the Cornell Robotics and Vision Laboratory are using this Scheme system for prototyp-ing a variety of navigation, planning, and manipulation systems. <p> We would like to experiment with and compare various programming language constructs and paradigms for describing robot control systems. Scheme should be an ideal medium for this. Of particular interest to us are subsumption architecture [2], ALFA <ref> [7] </ref>, and Amala [5]. Performance may be a problem in the future. Any interpreter for a virtual instruction set is likely to be 20 to 30 times slower than equivalent code compiled for the target hardware.
Reference: [8] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: Figure 3 summarizes the major software components of the Scheme system. 3.1 Run-time environment The run-time environment builds on the Scheme48 virtual machine architecture [12]. The virtual machine is byte-code based and stack-oriented, closely resembling the target machine of the Scheme 311 compiler [4], and similar in spirit to <ref> [8] </ref>. The VM handles memory management: allocation instructions (such as cons) can cause garbage collections. The virtual machine is implemented by an interpreter and garbage collector written in C. Compiled for the 68000, the virtual machine consumes about 24 Kbytes of EPROM.
Reference: [9] <author> Robert H. Halstead. </author> <title> Multilisp: a language for concurrent symbolic computation. </title> <journal> ACM Transactions on Programming Languages and Systems 7(4) </journal> <pages> 501-538, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: The set is not really sufficient in that it does not include an easy way to wait on multiple events. We experimented with Concurrent ML's primitives [15], but found that programs using them were difficult to debug. The future construct <ref> [9] </ref> would be easy to implement in the Scheme virtual machine, but is probably inappropriate in this context, since its purpose is exploiting parallelism, not programming embedded systems.
Reference: [10] <author> Jim Jennings. </author> <title> Modular software and hardware for robot construction. </title> <type> Unpublished manuscript. </type>
Reference-contexts: The robot architecture is distributed and modular, so that different sensors and effectors are easily added and removed. Interprocessor communications is via 19.2 Kbaud serial lines. Low-level I/O is handled by a Cornell Generic Controller (CGC), a general-purpose control board based on an Intel 80C196 processor <ref> [10] </ref>. High-level task control and planning are performed by Scheme programs running on an off-the-shelf Mo-torola 68000 processor board (Gespak MPL 4080). The 68000 board has .5 Mbyte RAM and .25 Mbyte EPROM, and Scheme currently uses no off-board memory.
Reference: [11] <author> Leslie Pack Kaelbling and Stanley J. Rosenstein. </author> <title> Action and planning in embedded agents. In Designing Autonomous Agents: Theory and Practice from Biology to Engineering and Back, </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: The future construct [9] would be easy to implement in the Scheme virtual machine, but is probably inappropriate in this context, since its purpose is exploiting parallelism, not programming embedded systems. While there has been some work on special-purpose robot control languages (see e.g. <ref> [11] </ref> and review in [7]), we considered it safer to hedge our bets by putting our effort into building an uncommitted general-purpose infrastructure. 6 Future work Members of the Cornell Robotics and Vision Laboratory are using this Scheme system for prototyp-ing a variety of navigation, planning, and manipulation systems.
Reference: [12] <author> Richard Kelsey and Jonathan Rees. </author> <note> Scheme48 progress report. Manuscript in preparation. </note>
Reference-contexts: The two communicate with each other over a serial line. Figure 3 summarizes the major software components of the Scheme system. 3.1 Run-time environment The run-time environment builds on the Scheme48 virtual machine architecture <ref> [12] </ref>. The virtual machine is byte-code based and stack-oriented, closely resembling the target machine of the Scheme 311 compiler [4], and similar in spirit to [8]. The VM handles memory management: allocation instructions (such as cons) can cause garbage collections.
Reference: [13] <author> Henry Lieberman and Carl Hewitt. </author> <title> A real-time garbage collector based on the lifetimes of objects. </title> <journal> Communications of the ACM 26(6): </journal> <pages> 419-429, </pages> <year> 1983. </year>
Reference-contexts: With our current garbage collector, a garbage collection of a 50% full heap requires over half a second. This is slow, but we believe that this time can be improved upon by tuning the code or by switching to a generational collector <ref> [13] </ref>. Our choice of synchronization primitives is merely conventional, not necessarily final. The set is not really sufficient in that it does not include an easy way to wait on multiple events. We experimented with Concurrent ML's primitives [15], but found that programs using them were difficult to debug.
Reference: [14] <author> Jonathan Rees. </author> <title> A Scheme to Common Lisp transla-tor. </title> <note> Manuscript in preparation. </note>
Reference-contexts: For Scheme on the workstation, we are currently running Pseudoscheme <ref> [14] </ref> under Lucid Common Lisp, but MIT Scheme or any of various other Scheme implementations would work as well.
Reference: [15] <author> John H. Reppy. </author> <title> CML: a higher-order concurrent language. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 293-305, </pages> <year> 1991. </year>
Reference-contexts: The lock is released on any normal or exceptional return from the call to thunk. A second form of synchronization is condition variables as in <ref> [15] </ref>, which are single-assignment storage locations. A condition variable is created with make-condvar, assigned with condvar-ref, and set (at most once) with condvar-set!. <p> Another possible choice for a general-purpose robot programming language would have been ML (or Concurrent ML <ref> [15] </ref>). Scheme made more sense for us given the educational background of the students and researchers that use the robot. Also, the Scheme48 system already existed when this project started, and was already well suited for cross-development; adapting an existing ML implementation would have been much more work for us. <p> Our choice of synchronization primitives is merely conventional, not necessarily final. The set is not really sufficient in that it does not include an easy way to wait on multiple events. We experimented with Concurrent ML's primitives <ref> [15] </ref>, but found that programs using them were difficult to debug. The future construct [9] would be easy to implement in the Scheme virtual machine, but is probably inappropriate in this context, since its purpose is exploiting parallelism, not programming embedded systems.
Reference: [16] <author> Mitchell Wand. </author> <title> Continuation-based multiprocessing. </title> <booktitle> In Conference Record of the 1980 Lisp Conference, </booktitle> <pages> pages 19-28. </pages> <booktitle> The Lisp Conference, </booktitle> <address> P.O. Box 487, Redwood Estates CA, </address> <year> 1980. </year> <note> Proceedings reprinted by ACM. </note>
Reference-contexts: The implementation of threads is written entirely in Scheme, that is, above the level of the virtual machine. This is made possible, even easy, by the existence in Scheme of the call-with-current-continuation primitive, which the virtual machine implements efficiently. See <ref> [16] </ref> for an elegant presentation of this technique for building an operating system kernel. (Actually, thread switching uses the same low-level continuation mechanism that call-with-current-continuation does, but does not interact with dynamic-wind, described in the appendix.) Because threads are ordinary Scheme objects with no special status in the virtual machine, they
References-found: 16

