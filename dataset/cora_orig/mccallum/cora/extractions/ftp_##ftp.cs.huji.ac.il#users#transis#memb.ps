URL: ftp://ftp.cs.huji.ac.il/users/transis/memb.ps
Refering-URL: http://www.cs.huji.ac.il/labs/transis/abstracts94.html
Root-URL: http://www.cs.huji.ac.il
Title: An Asynchronous Membership Protocol that Tolerates Partitions  
Author: Danny Dolev Dalia Malki Ray Strong 
Keyword: Categories and Subject Descriptors: C.2.2 [Computer Communication Networks]: Network Protocols| Protocol Architectures; C.2.4 [Computer Communication Networks]: Distributed Systems|-Distributed Applications; D.4.5 [Operating Systems]: Reliability|Fault Tolerance; D.4.7 [Operating Systems]: Organization and Design|Distributed Systems General Terms: Distributed Algorithms, Fault Tolerance Additional Key Words and Phrases: Partitions, Membership, Asynchrony  
Abstract: This paper presents a membership protocol for maintaining the set of operational and connected machines in agreement. The protocol operates in an asynchronous environment prone to crash failures, omission failures and network partitions. The protocol is suitable for systems with machines that communicate via broadcast (or multicast) messages. It supports continued operation with partitions and provides the mechanism for merging of partitions. The principles of the protocol presented here have been successfully incorporated into the Transis system [3, 2], the Totem system [4], and the Horus system [29]. The membership protocol presented here is integrated in the communication system, such that the notifications of membership changes are delivered to the application among the stream of regular messages. Changes to the membership are coordinated with the delivery of regular messages in the system. This valuable approach was presented in [7, 9] in the context of a primary-partition system, and is extended here for partitionable systems. Its importance is in providing the distributed application builder with a virtually synchronous programming environment. This approach is suitable for many environments today, all of them supporting various forms of multicast communication among machines and among process groups.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> O. Amir, Y. Amir, and D. Dolev. </author> <title> Highly Available Application in the Transis Environment - a Test Case. In Proceedings of the Hardware and Software Architectures for Fault Tolerance Workshop, </title> <institution> at Le Mont Saint-Michel, France, </institution> <month> June </month> <year> 1993. </year> <note> to appear as LNCS proceedings. </note>
Reference-contexts: In this way, the membership service associates a membership-context with each message. The application can use this to perform consistent operations on received messages, and to merge the histories of joined partitions. For example, <ref> [1] </ref> describes a replicated mail server that exploits the Transis membership for efficiently implementing a partitionable service. Intuitively, at the basis of our membership protocol, there are two stages: (1) suggest a new membership set, (2) wait for agreement from every machine in the set. <p> The loop searches for the first message in MQ p that has full agreement: Definition 4.1 We say that a membership message has full agreement when MQ fl contains messages equiv q () from every q 2 : If MQ p <ref> [1] </ref> has full agreement, p updates AM p , updates AF p , and increments context p . The machines in the F set of MQ p [1] are removed from AM p , and AF p is assigned the union of all the faults-sets of pending membership messages. <p> that a membership message has full agreement when MQ fl contains messages equiv q () from every q 2 : If MQ p <ref> [1] </ref> has full agreement, p updates AM p , updates AF p , and increments context p . The machines in the F set of MQ p [1] are removed from AM p , and AF p is assigned the union of all the faults-sets of pending membership messages. This means that a suspected machine s remains in AF as long as there is any pending membership message that contains s in its faults set. <p> After all 15 the pending membership messages that contain s in the faults set are handled, s may rejoin the membership. In order make the installation of MQ p <ref> [1] </ref> deliverable to the user, p invokes unblock-membership (MQ p [1]; install) : The reason that the M-install event does not take place immediately is that unblock-membership needs to order this event with relation to all the regular messages in delayQ and pendingQ, in order to preserve the virtual synchrony rule <p> After all 15 the pending membership messages that contain s in the faults set are handled, s may rejoin the membership. In order make the installation of MQ p <ref> [1] </ref> deliverable to the user, p invokes unblock-membership (MQ p [1]; install) : The reason that the M-install event does not take place immediately is that unblock-membership needs to order this event with relation to all the regular messages in delayQ and pendingQ, in order to preserve the virtual synchrony rule (Requisite M.4). <p> If the minimal k such that MQ p [k] has full agreement is some k &gt; 1, then p checks for hidden agreement on MQ p <ref> [1] </ref>: Definition 4.2 We say that MQ p [1] has hidden agreement if ccone (MQ p [k]) contains messages equiv r (MQ p [1]) from every machine r in MQ p [1] " MQ p [k] : In the case that MQ p [k] has full agreement, if MQ p [1] <p> If the minimal k such that MQ p [k] has full agreement is some k &gt; 1, then p checks for hidden agreement on MQ p <ref> [1] </ref>: Definition 4.2 We say that MQ p [1] has hidden agreement if ccone (MQ p [k]) contains messages equiv r (MQ p [1]) from every machine r in MQ p [1] " MQ p [k] : In the case that MQ p [k] has full agreement, if MQ p [1] has hidden agreement, p delivers it as scattered <p> If the minimal k such that MQ p [k] has full agreement is some k &gt; 1, then p checks for hidden agreement on MQ p <ref> [1] </ref>: Definition 4.2 We say that MQ p [1] has hidden agreement if ccone (MQ p [k]) contains messages equiv r (MQ p [1]) from every machine r in MQ p [1] " MQ p [k] : In the case that MQ p [k] has full agreement, if MQ p [1] has hidden agreement, p delivers it as scattered membership, by invoking unblock-membership (MQ p [1]; scatter) : Otherwise, p rejects MQ p [1]. <p> p [k] has full agreement is some k &gt; 1, then p checks for hidden agreement on MQ p <ref> [1] </ref>: Definition 4.2 We say that MQ p [1] has hidden agreement if ccone (MQ p [k]) contains messages equiv r (MQ p [1]) from every machine r in MQ p [1] " MQ p [k] : In the case that MQ p [k] has full agreement, if MQ p [1] has hidden agreement, p delivers it as scattered membership, by invoking unblock-membership (MQ p [1]; scatter) : Otherwise, p rejects MQ p [1]. <p> <ref> [1] </ref>: Definition 4.2 We say that MQ p [1] has hidden agreement if ccone (MQ p [k]) contains messages equiv r (MQ p [1]) from every machine r in MQ p [1] " MQ p [k] : In the case that MQ p [k] has full agreement, if MQ p [1] has hidden agreement, p delivers it as scattered membership, by invoking unblock-membership (MQ p [1]; scatter) : Otherwise, p rejects MQ p [1]. The reason for "aborting" a membership message (via reject or scatter ) is that full agreement on the first message MQ p [1] might be impossible, if <p> p [k]) contains messages equiv r (MQ p <ref> [1] </ref>) from every machine r in MQ p [1] " MQ p [k] : In the case that MQ p [k] has full agreement, if MQ p [1] has hidden agreement, p delivers it as scattered membership, by invoking unblock-membership (MQ p [1]; scatter) : Otherwise, p rejects MQ p [1]. The reason for "aborting" a membership message (via reject or scatter ) is that full agreement on the first message MQ p [1] might be impossible, if machines in MQ p [1] have failed or disconnected from p. <p> <ref> [1] </ref>) from every machine r in MQ p [1] " MQ p [k] : In the case that MQ p [k] has full agreement, if MQ p [1] has hidden agreement, p delivers it as scattered membership, by invoking unblock-membership (MQ p [1]; scatter) : Otherwise, p rejects MQ p [1]. The reason for "aborting" a membership message (via reject or scatter ) is that full agreement on the first message MQ p [1] might be impossible, if machines in MQ p [1] have failed or disconnected from p. <p> agreement, if MQ p <ref> [1] </ref> has hidden agreement, p delivers it as scattered membership, by invoking unblock-membership (MQ p [1]; scatter) : Otherwise, p rejects MQ p [1]. The reason for "aborting" a membership message (via reject or scatter ) is that full agreement on the first message MQ p [1] might be impossible, if machines in MQ p [1] have failed or disconnected from p. However, if a certain machine is nonresponsive, it is eventually C-suspected by p, or by another machine in MQ p [1]. <p> delivers it as scattered membership, by invoking unblock-membership (MQ p <ref> [1] </ref>; scatter) : Otherwise, p rejects MQ p [1]. The reason for "aborting" a membership message (via reject or scatter ) is that full agreement on the first message MQ p [1] might be impossible, if machines in MQ p [1] have failed or disconnected from p. However, if a certain machine is nonresponsive, it is eventually C-suspected by p, or by another machine in MQ p [1]. <p> reject or scatter ) is that full agreement on the first message MQ p <ref> [1] </ref> might be impossible, if machines in MQ p [1] have failed or disconnected from p. However, if a certain machine is nonresponsive, it is eventually C-suspected by p, or by another machine in MQ p [1]. The suspected machine is added to AF , and is included in a following membership message from p, which is queued in MQ p . Therefore, in procedure handle-membership, p continues to examine the membership messages that follow MQ p [1] in the queue. <p> by p, or by another machine in MQ p <ref> [1] </ref>. The suspected machine is added to AF , and is included in a following membership message from p, which is queued in MQ p . Therefore, in procedure handle-membership, p continues to examine the membership messages that follow MQ p [1] in the queue. The membership messages in MQ p do not necessarily cancel each other: p handles multiple pending membership changes. If a certain membership message MQ p [k], k &gt; 1, already has full agreement, then MQ p [k] will be installed by p, and MQ p [1] will <p> p <ref> [1] </ref> in the queue. The membership messages in MQ p do not necessarily cancel each other: p handles multiple pending membership changes. If a certain membership message MQ p [k], k &gt; 1, already has full agreement, then MQ p [k] will be installed by p, and MQ p [1] will not be installed. In order to guarantee Requisite M.5, p must know whether "hidden" agreement on MQ p [1] is possible. Obviously, p has already noted that the machines outside MQ p [1] " MQ p [k] have detached, and p may be lacking agreement from these machines. <p> If a certain membership message MQ p [k], k &gt; 1, already has full agreement, then MQ p [k] will be installed by p, and MQ p <ref> [1] </ref> will not be installed. In order to guarantee Requisite M.5, p must know whether "hidden" agreement on MQ p [1] is possible. Obviously, p has already noted that the machines outside MQ p [1] " MQ p [k] have detached, and p may be lacking agreement from these machines. Thus, hidden agreement is defined within the set of machines that are currently connected to p. <p> already has full agreement, then MQ p [k] will be installed by p, and MQ p <ref> [1] </ref> will not be installed. In order to guarantee Requisite M.5, p must know whether "hidden" agreement on MQ p [1] is possible. Obviously, p has already noted that the machines outside MQ p [1] " MQ p [k] have detached, and p may be lacking agreement from these machines. Thus, hidden agreement is defined within the set of machines that are currently connected to p. <p> exists in MQ p then loop until exit f Let k be the minimal index such that 8q 2 MQ p [k], MQ q contains equiv q (MQ p [k]) ; if k == 1 then exit loop ; if k == 1 then /* full agreement on MQ p <ref> [1] </ref> */ AM = AM n F ; S F i , where F i is the faults-set in MQ p [i], i = 2 :: size-of (MQ p ) ; increment context ; unblock-membership (MQ p [1], install) ; if k &gt; 1 /* check hidden agreement on MQ p <p> loop ; if k == 1 then /* full agreement on MQ p <ref> [1] </ref> */ AM = AM n F ; S F i , where F i is the faults-set in MQ p [i], i = 2 :: size-of (MQ p ) ; increment context ; unblock-membership (MQ p [1], install) ; if k &gt; 1 /* check hidden agreement on MQ p [1] */ if hidden agreement on MQ p [1] a unblock-membership (MQ p [1], scatter) ; else /* reject MQ p [1] */ unblock-membership (MQ p [1], reject) ; 8r 2 AM pop messages from MQ r <p> */ AM = AM n F ; S F i , where F i is the faults-set in MQ p [i], i = 2 :: size-of (MQ p ) ; increment context ; unblock-membership (MQ p <ref> [1] </ref>, install) ; if k &gt; 1 /* check hidden agreement on MQ p [1] */ if hidden agreement on MQ p [1] a unblock-membership (MQ p [1], scatter) ; else /* reject MQ p [1] */ unblock-membership (MQ p [1], reject) ; 8r 2 AM pop messages from MQ r up to and including equiv r (MQ p [1]) (if it exists) ; g <p> F i , where F i is the faults-set in MQ p [i], i = 2 :: size-of (MQ p ) ; increment context ; unblock-membership (MQ p <ref> [1] </ref>, install) ; if k &gt; 1 /* check hidden agreement on MQ p [1] */ if hidden agreement on MQ p [1] a unblock-membership (MQ p [1], scatter) ; else /* reject MQ p [1] */ unblock-membership (MQ p [1], reject) ; 8r 2 AM pop messages from MQ r up to and including equiv r (MQ p [1]) (if it exists) ; g a Recall that hidden agreement is defined as: <p> i is the faults-set in MQ p [i], i = 2 :: size-of (MQ p ) ; increment context ; unblock-membership (MQ p <ref> [1] </ref>, install) ; if k &gt; 1 /* check hidden agreement on MQ p [1] */ if hidden agreement on MQ p [1] a unblock-membership (MQ p [1], scatter) ; else /* reject MQ p [1] */ unblock-membership (MQ p [1], reject) ; 8r 2 AM pop messages from MQ r up to and including equiv r (MQ p [1]) (if it exists) ; g a Recall that hidden agreement is defined as: 8r 2 MQ p [1] <p> i = 2 :: size-of (MQ p ) ; increment context ; unblock-membership (MQ p <ref> [1] </ref>, install) ; if k &gt; 1 /* check hidden agreement on MQ p [1] */ if hidden agreement on MQ p [1] a unblock-membership (MQ p [1], scatter) ; else /* reject MQ p [1] */ unblock-membership (MQ p [1], reject) ; 8r 2 AM pop messages from MQ r up to and including equiv r (MQ p [1]) (if it exists) ; g a Recall that hidden agreement is defined as: 8r 2 MQ p [1] " MQ p [k] : 9equiv r (MQ <p> (MQ p ) ; increment context ; unblock-membership (MQ p <ref> [1] </ref>, install) ; if k &gt; 1 /* check hidden agreement on MQ p [1] */ if hidden agreement on MQ p [1] a unblock-membership (MQ p [1], scatter) ; else /* reject MQ p [1] */ unblock-membership (MQ p [1], reject) ; 8r 2 AM pop messages from MQ r up to and including equiv r (MQ p [1]) (if it exists) ; g a Recall that hidden agreement is defined as: 8r 2 MQ p [1] " MQ p [k] : 9equiv r (MQ p [1]) 2 ccone (MQ <p> hidden agreement on MQ p <ref> [1] </ref> */ if hidden agreement on MQ p [1] a unblock-membership (MQ p [1], scatter) ; else /* reject MQ p [1] */ unblock-membership (MQ p [1], reject) ; 8r 2 AM pop messages from MQ r up to and including equiv r (MQ p [1]) (if it exists) ; g a Recall that hidden agreement is defined as: 8r 2 MQ p [1] " MQ p [k] : 9equiv r (MQ p [1]) 2 ccone (MQ p [k]) : procedure merge-membership (&lt;P; F; c&gt;, q): if p 2 F /* reverse the suspicion */ AF <p> <ref> [1] </ref>, scatter) ; else /* reject MQ p [1] */ unblock-membership (MQ p [1], reject) ; 8r 2 AM pop messages from MQ r up to and including equiv r (MQ p [1]) (if it exists) ; g a Recall that hidden agreement is defined as: 8r 2 MQ p [1] " MQ p [k] : 9equiv r (MQ p [1]) 2 ccone (MQ p [k]) : procedure merge-membership (&lt;P; F; c&gt;, q): if p 2 F /* reverse the suspicion */ AF = AF [ fqg ; if q 2 AM and c &gt; context /* q has detached */ <p> unblock-membership (MQ p <ref> [1] </ref>, reject) ; 8r 2 AM pop messages from MQ r up to and including equiv r (MQ p [1]) (if it exists) ; g a Recall that hidden agreement is defined as: 8r 2 MQ p [1] " MQ p [k] : 9equiv r (MQ p [1]) 2 ccone (MQ p [k]) : procedure merge-membership (&lt;P; F; c&gt;, q): if p 2 F /* reverse the suspicion */ AF = AF [ fqg ; if q 2 AM and c &gt; context /* q has detached */ AF = AF [ fqg ; if p 62 F <p> Furthermore, if p does not crash, then some membership message causally following is installed within a finite time. Proof: We consider the history segment T (possibly infinite), starting with the event in which becomes the first message in MQ p (i.e. MQ p <ref> [1] </ref>), and continuing for as long as there are no M-install events at p. If p does not crash, and T ends within a finite time, then by definition T is immediately followed by a M-install event. <p> We will focus on that last instance. 31 Let k be the minimal index found at this instance of handle-membership, such that MQ q [k] has full agreement. If k is 1, then q installs equiv q () MQ q <ref> [1] </ref>, and we are done. Otherwise, MQ q [1] and MQ q [k] are different messages, and MQ q [1] cause ! MQ q [k] : Every machine r 2 MQ q [1] " MQ q [k] satisfies the following: * r sent a message equiv r (MQ q [1]) (because <p> We will focus on that last instance. 31 Let k be the minimal index found at this instance of handle-membership, such that MQ q [k] has full agreement. If k is 1, then q installs equiv q () MQ q <ref> [1] </ref>, and we are done. Otherwise, MQ q [1] and MQ q [k] are different messages, and MQ q [1] cause ! MQ q [k] : Every machine r 2 MQ q [1] " MQ q [k] satisfies the following: * r sent a message equiv r (MQ q [1]) (because p has full agreement on = equiv p <p> If k is 1, then q installs equiv q () MQ q <ref> [1] </ref>, and we are done. Otherwise, MQ q [1] and MQ q [k] are different messages, and MQ q [1] cause ! MQ q [k] : Every machine r 2 MQ q [1] " MQ q [k] satisfies the following: * r sent a message equiv r (MQ q [1]) (because p has full agreement on = equiv p (MQ q [1])) : * r sent a message equiv r <p> If k is 1, then q installs equiv q () MQ q <ref> [1] </ref>, and we are done. Otherwise, MQ q [1] and MQ q [k] are different messages, and MQ q [1] cause ! MQ q [k] : Every machine r 2 MQ q [1] " MQ q [k] satisfies the following: * r sent a message equiv r (MQ q [1]) (because p has full agreement on = equiv p (MQ q [1])) : * r sent a message equiv r (MQ q [k]) (since q has full agreement on it). * By Lemma <p> q <ref> [1] </ref>, and we are done. Otherwise, MQ q [1] and MQ q [k] are different messages, and MQ q [1] cause ! MQ q [k] : Every machine r 2 MQ q [1] " MQ q [k] satisfies the following: * r sent a message equiv r (MQ q [1]) (because p has full agreement on = equiv p (MQ q [1])) : * r sent a message equiv r (MQ q [k]) (since q has full agreement on it). * By Lemma 5.2, equiv r (MQ q [1]) cause ! equiv r (MQ q [k]) : * Therefore, equiv <p> q [k] are different messages, and MQ q <ref> [1] </ref> cause ! MQ q [k] : Every machine r 2 MQ q [1] " MQ q [k] satisfies the following: * r sent a message equiv r (MQ q [1]) (because p has full agreement on = equiv p (MQ q [1])) : * r sent a message equiv r (MQ q [k]) (since q has full agreement on it). * By Lemma 5.2, equiv r (MQ q [1]) cause ! equiv r (MQ q [k]) : * Therefore, equiv r (MQ q [1]) 2 ccone (MQ q [k]) : Thus, MQ <p> the following: * r sent a message equiv r (MQ q <ref> [1] </ref>) (because p has full agreement on = equiv p (MQ q [1])) : * r sent a message equiv r (MQ q [k]) (since q has full agreement on it). * By Lemma 5.2, equiv r (MQ q [1]) cause ! equiv r (MQ q [k]) : * Therefore, equiv r (MQ q [1]) 2 ccone (MQ q [k]) : Thus, MQ q [1] has hidden agreement, and according to the protocol, q scatters MQ q [1] in this case. 2 32 6 Conclusions This paper has done the <p> full agreement on = equiv p (MQ q <ref> [1] </ref>)) : * r sent a message equiv r (MQ q [k]) (since q has full agreement on it). * By Lemma 5.2, equiv r (MQ q [1]) cause ! equiv r (MQ q [k]) : * Therefore, equiv r (MQ q [1]) 2 ccone (MQ q [k]) : Thus, MQ q [1] has hidden agreement, and according to the protocol, q scatters MQ q [1] in this case. 2 32 6 Conclusions This paper has done the following: It provided a full definition of the membership problem in asynchronous distributed communication systems, <p> * r sent a message equiv r (MQ q [k]) (since q has full agreement on it). * By Lemma 5.2, equiv r (MQ q <ref> [1] </ref>) cause ! equiv r (MQ q [k]) : * Therefore, equiv r (MQ q [1]) 2 ccone (MQ q [k]) : Thus, MQ q [1] has hidden agreement, and according to the protocol, q scatters MQ q [1] in this case. 2 32 6 Conclusions This paper has done the following: It provided a full definition of the membership problem in asynchronous distributed communication systems, and presented a full solution that operates above a causal <p> full agreement on it). * By Lemma 5.2, equiv r (MQ q <ref> [1] </ref>) cause ! equiv r (MQ q [k]) : * Therefore, equiv r (MQ q [1]) 2 ccone (MQ q [k]) : Thus, MQ q [1] has hidden agreement, and according to the protocol, q scatters MQ q [1] in this case. 2 32 6 Conclusions This paper has done the following: It provided a full definition of the membership problem in asynchronous distributed communication systems, and presented a full solution that operates above a causal communication layer. The definition allows multiple partitions to exist.
Reference: [2] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki. </author> <title> Membership Algorithms for Multicast Communication Groups. </title> <booktitle> In 6th Intl. Workshop on Distributed Algorithms proceedings (WDAG-6), (LCNS, </booktitle> <volume> 647), </volume> <pages> pages 292-312, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: The principles of the pro-tocol presented here have been successfully incorporated into the Transis system <ref> [3, 2] </ref>, the Totem system [4], and the Horus system [29]. The membership protocol presented here is integrated in the communication system, such that the notifications of membership changes are delivered to the application among the stream of regular messages. <p> All we demand in Requisite M.3 is that there exist circumstances (extreme as they may be, for all we know) that allow a certain set of machines to form a membership. 11 * Requisite M.4: The virtual synchrony principle of Requisite M.4 has been adopted by several membership systems <ref> [2, 28, 4] </ref> and is also present in [23] (which totally orders all the messages, including membership changes). However, it is not supported by all: the membership protocol in [24] preserves causal-order between membership changes and regular messages, but does not guarantee virtual synchrony. <p> On lower thresholds, the system may partition. The user has the control in trading resiliency with consistency. The protocol presented in [18] does not provide any solution for merging operational partitions upon reconnection. Related solutions to the membership problem that support partitions appear in <ref> [2, 4] </ref>. The membership protocol presented here differs in being active throughout any number of membership changes. Rather than ejecting from activation after each membership change, it cascades through 12 them and lets the causal order of messages determine the order of changes. <p> The membership protocol presented here differs in being active throughout any number of membership changes. Rather than ejecting from activation after each membership change, it cascades through 12 them and lets the causal order of messages determine the order of changes. The protocol in <ref> [2] </ref> supports a restricted version of Requisite M.4. 4 The Membership Protocol This section presents a protocol that implements the membership service. 4.1 Notation The membership protocol uses special messages, called membership messages, of the form &lt;P; F; context&gt;, containing a membership set P, a faults set F, and a unique
Reference: [3] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki. Transis: </author> <title> A Communication Sub-System for High Availability. </title> <booktitle> In 22nd Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 76-84, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: The principles of the pro-tocol presented here have been successfully incorporated into the Transis system <ref> [3, 2] </ref>, the Totem system [4], and the Horus system [29]. The membership protocol presented here is integrated in the communication system, such that the notifications of membership changes are delivered to the application among the stream of regular messages. <p> Note that our protocol uses broadcast communication, and therefore the symmetry does not incur any additional communication overhead. The essentials of the membership protocol presented here were implemented within several environments: A full implementation was done within the Transis system <ref> [3] </ref>. The Totem system [4] is based on a ring structure among the connected machines, and its underlying membership protocol is based on the principles of our membership protocol. A partial implementation of the merging algorithm was done within Horus [29]. <p> Henceforth, we assume that the causal communication module in our environment satisfies Requisites C.1, C.2, C.3. 8 2.2 Causal delivery and Transis The causal communication properties C.1, C.2, C.3, are currently supported in many systems, e.g. Transis <ref> [3] </ref>, Isis [8], Psync [27], Horus [29], and the Trans protocol [22]. The common factor to all of these systems is the relatively low overhead costs. In this subsection we give some details of the causal multicast in Transis. <p> The common factor to all of these systems is the relatively low overhead costs. In this subsection we give some details of the causal multicast in Transis. Transis contains the communication module responsible for the reliable and causal delivery of multicast messages in the system <ref> [3] </ref>. In Transis, each newly emitted message contains ACKs to previous messages. The ACKs form the cause ! relation directly, such that if m 0 contains an ACK to m, then m cause ! m 0 . The Transis communication sub-system receives the messages off the network.
Reference: [4] <author> Y. Amir, L. E. Moser, P. M. Melliar-Smith, D. A. Agarwal, and P. Ciarfella. </author> <title> Fast Message Ordering and Membership Using a Logical Token-Passing Ring. </title> <booktitle> In Intl. Conference on Distributed Computing Systems, </booktitle> <pages> pages 551-560, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: The principles of the pro-tocol presented here have been successfully incorporated into the Transis system [3, 2], the Totem system <ref> [4] </ref>, and the Horus system [29]. The membership protocol presented here is integrated in the communication system, such that the notifications of membership changes are delivered to the application among the stream of regular messages. Changes to the membership are coordinated with the delivery of regular messages in the system. <p> Note that our protocol uses broadcast communication, and therefore the symmetry does not incur any additional communication overhead. The essentials of the membership protocol presented here were implemented within several environments: A full implementation was done within the Transis system [3]. The Totem system <ref> [4] </ref> is based on a ring structure among the connected machines, and its underlying membership protocol is based on the principles of our membership protocol. A partial implementation of the merging algorithm was done within Horus [29]. <p> The membership service of <ref> [4] </ref> discusses the installation of a transient membership in these cases. It is beyond the scope of this paper to discuss the importance of this information for application builders, and we refer the interested reader to [4, 25]. <p> The membership service of [4] discusses the installation of a transient membership in these cases. It is beyond the scope of this paper to discuss the importance of this information for application builders, and we refer the interested reader to <ref> [4, 25] </ref>. We do require that if p installs , all the other members in will at least be able to report of a possible membership change at that point (or crash). Requisite M.5 Let M-install p () be an event of H. Let q be a machine in . <p> All we demand in Requisite M.3 is that there exist circumstances (extreme as they may be, for all we know) that allow a certain set of machines to form a membership. 11 * Requisite M.4: The virtual synchrony principle of Requisite M.4 has been adopted by several membership systems <ref> [2, 28, 4] </ref> and is also present in [23] (which totally orders all the messages, including membership changes). However, it is not supported by all: the membership protocol in [24] preserves causal-order between membership changes and regular messages, but does not guarantee virtual synchrony. <p> On lower thresholds, the system may partition. The user has the control in trading resiliency with consistency. The protocol presented in [18] does not provide any solution for merging operational partitions upon reconnection. Related solutions to the membership problem that support partitions appear in <ref> [2, 4] </ref>. The membership protocol presented here differs in being active throughout any number of membership changes. Rather than ejecting from activation after each membership change, it cascades through 12 them and lets the causal order of messages determine the order of changes.
Reference: [5] <author> K. Birman, R. Cooper, and B. Gleeson. </author> <title> Programming with Process Groups: Group and Multicast Semantics. </title> <type> TR 91-1185, </type> <institution> dept. of Computer Science, Cornell University, </institution> <month> Jan </month> <year> 1991. </year>
Reference-contexts: This might sound chaotic, at first. However, we require that: * Every pair of machines that go through two consecutive membership changes, receive the same set of messages between the two changes. (This is a generalization of the principle called virtual synchrony , see <ref> [5] </ref>). * Upon re-merging, all the machines in the new membership start with a consistent view of the membership, and agree on the messages that follow it. In this way, the membership service associates a membership-context with each message.
Reference: [6] <author> K. Birman and T. Joseph. </author> <title> Realiable Communication in the Presence of Failures. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 5(1) </volume> <pages> 47-76, </pages> <month> February </month> <year> 1987. </year>
Reference: [7] <author> K. Birman and T. Joseph. </author> <title> Exploiting Virtual Synchrony in Distributed Systems. </title> <booktitle> In 11th Ann. Symp. Operating Systems Principles, </booktitle> <pages> pages 123-138. </pages> <publisher> ACM, </publisher> <month> Nov 87. </month>
Reference: [8] <author> K. Birman, A. Schiper, and P. Stephenson. </author> <title> Lightweight Causal and Atomic Group Multicast. </title> <journal> ACM Trans. Comp. Syst., </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <year> 1991. </year>
Reference-contexts: Henceforth, we assume that the causal communication module in our environment satisfies Requisites C.1, C.2, C.3. 8 2.2 Causal delivery and Transis The causal communication properties C.1, C.2, C.3, are currently supported in many systems, e.g. Transis [3], Isis <ref> [8] </ref>, Psync [27], Horus [29], and the Trans protocol [22]. The common factor to all of these systems is the relatively low overhead costs. In this subsection we give some details of the causal multicast in Transis.
Reference: [9] <author> K. P. Birman. </author> <title> Reliable Distributed Computing with the Isis Toolkit, chapter Virtual Synchrony Model. </title> <publisher> IEEE Press, </publisher> <year> 1993. </year> <note> to appear. </note>
Reference-contexts: In distributed applications, the programs running on different machines can act upon messages according to the context. Thus, it is desired that the machines see the same messages between every pair of membership changes. This valuable principle is defined in <ref> [9] </ref>, and is called virtual synchrony. The next requisite expresses the demands on the relative order of message delivery and installations of membership changes: Requisite M.4 (Virtual-Synchrony) (1) Let M-deliver p (m), M-deliver p (m 0 ) be two events in the history H.
Reference: [10] <author> D. R. Cheriton and W. Zwaenepoel. </author> <title> Distributed Process Groups in the V Kernel. </title> <journal> ACM Trans. Comp. Syst., </journal> <volume> 2(3) </volume> <pages> 77-107, </pages> <month> May </month> <year> 1985. </year>
Reference: [11] <author> F. Cristian. </author> <title> Reaching Agreement on Processor Group Membership in Synchronous Distributed Systems. </title> <journal> Distributed Computing, </journal> <volume> 4(4) </volume> <pages> 175-187, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: The problem of maintaining a consistent view of the reachable operational machines is fundamental in the design of distributed systems. In <ref> [11] </ref>, a formal definition of the problem (and solution) is given for synchronous systems. To the best of our knowledge, the first formal definition of the requirements of membership in asynchronous environments is given in [28]. <p> In many similar systems, only one set (the primary) of machines is allowed to operate in the system, e.g. <ref> [28, 23, 24, 11] </ref>. Our approach is motivated by the assumption that 3 the membership service is part of a multicast communication substrate. As such, the membership service must not prevent the upper level applications from continuing operation in face of partitions. <p> For example, in [23], a correct machine that performs infinitely many attempts to join the membership must succeed with probability one. The synchronous membership protocol of <ref> [11] </ref> places a time-bound on the amount of time it takes a correct machine to join the membership, provided that it remains correct throughout this period. Ricciardi et al. [28] simply demand that machines are not taken out of the membership capriciously. <p> However, it is not supported by all: the membership protocol in [24] preserves causal-order between membership changes and regular messages, but does not guarantee virtual synchrony. There are several protocols that provide a membership service that is not related to multicast message delivery, such as <ref> [17, 11] </ref>. * Requisite M.5: In a primary partition membership, e.g. [28], whenever a membership is installed, it will become the (only) view of the system at all the operational machines.
Reference: [12] <author> S. E. Deering. </author> <title> Host extensions for IP multicasting. </title> <type> RFC 1112, </type> <institution> SRI Network Information Center, </institution> <month> August </month> <year> 1989. </year>
Reference: [13] <author> S. E. Deering and D. R. Cheriton. </author> <title> Multicast Routing in Datagram Internetworks and Extended LANs. </title> <journal> ACM Trans. Comp. Syst., </journal> <volume> 8(2) </volume> <pages> 85-110, </pages> <month> May </month> <year> 1990. </year>
Reference: [14] <author> M. Fischer, N. Lynch, and M. Paterson. </author> <title> Impossibility of Distributed Consensus with One Faulty Process. </title> <journal> J. ACM, </journal> <volume> 32 </volume> <pages> 374-382, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: Their paper defines a primary-partition membership service, that maintains the local views of all the operational machines in agreement. Since it is well known that reaching agreement in asynchronous environments is impossible <ref> [14] </ref>, the membership agreement must circumvent this difficulty somehow. The membership protocol in [28] uses an inaccurate failure detector, based on timeout: When a machine is presumed faulty, it is taken out of the view, such that further messages from the faulty machine are discarded . <p> This difficulty can be proved rigorously: the impossibility of maintaining a primary partition in agreement in an asynchronous system with faults stems from the impossibility of consensus in asynchronous systems <ref> [14] </ref>. In some systems, the situations in which there is no primary partition will be common, e.g. in wireless networks. Therefore, for these systems, the membership service should provide the option to continue operation within non-primary partitions. * At startup time, a distributed system may have several disconnected partitions.
Reference: [15] <author> H. Garcia-Molina and A. Spauster. </author> <title> Message Ordering in a Multicast Environment. </title> <booktitle> In 9th Intl. Conf. Distributed Computing Systems, </booktitle> <pages> pages 354-361. </pages> <publisher> IEEE, </publisher> <month> June 89. </month>
Reference: [16] <author> K. J. Goldman. </author> <title> Highly Concurrent Logically Synchronous Multicast. </title> <journal> Distributed Computing, </journal> <volume> 4(4) </volume> <pages> 189-208, </pages> <year> 1991. </year>
Reference: [17] <author> F. Jahanian and W. Moran. </author> <title> Strong, Weak and Hybrid Group Membership. unpublished, IBM internal draft, </title> <booktitle> 1992. </booktitle> <pages> 34 </pages>
Reference-contexts: However, it is not supported by all: the membership protocol in [24] preserves causal-order between membership changes and regular messages, but does not guarantee virtual synchrony. There are several protocols that provide a membership service that is not related to multicast message delivery, such as <ref> [17, 11] </ref>. * Requisite M.5: In a primary partition membership, e.g. [28], whenever a membership is installed, it will become the (only) view of the system at all the operational machines. <p> In Requisite M.5, we capture the notion that two machines p, q will go through the same sequence of membership changes until one of them crashes or until they detach from each other. It is possible to relax Requisite M.5 altogether: in the Weak Membership of <ref> [17] </ref>, there is no guarantee that all the members see a certain membership installation. Their protocol simply assures that if the communication is timely and there are no faults, then the membership will be in consensus. In periods of instability, the membership view might diverge at different machines. <p> Their protocol simply assures that if the communication is timely and there are no faults, then the membership will be in consensus. In periods of instability, the membership view might diverge at different machines. For purposes such as object replication, this membership is too weak (indeed, <ref> [17] </ref> also provides the Strong and the Hybrid memberships for consistent replication). Another issue is the possibility of a machine to return to the membership after being disconnected. In [28], it is assumed that a machine that is taken out of the membership never returns to it.
Reference: [18] <author> F. S. Kaashoek. </author> <title> Group Communication in Distributed Computer Systems. </title> <type> PhD thesis, </type> <institution> Vrije University, </institution> <year> 1992. </year>
Reference-contexts: If the user determines a majority threshold, the result is a primary-partition membership service. On lower thresholds, the system may partition. The user has the control in trading resiliency with consistency. The protocol presented in <ref> [18] </ref> does not provide any solution for merging operational partitions upon reconnection. Related solutions to the membership problem that support partitions appear in [2, 4]. The membership protocol presented here differs in being active throughout any number of membership changes.
Reference: [19] <author> M. F. Kaashoek and A. S. Tanenbaum. </author> <title> Group Communication in the Amoeba Distributed Operating System. </title> <booktitle> In Intl. Conference on Distributed Computing Systems, </booktitle> <volume> number 11, </volume> <pages> pages 882-891, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: There are other membership services that allow partitioned operation. The membership service of the Amoeba system <ref> [20, 19] </ref> lets the user determine the minimal size with which the system can continue operating. If the user determines a majority threshold, the result is a primary-partition membership service. On lower thresholds, the system may partition. The user has the control in trading resiliency with consistency.
Reference: [20] <author> M. F. Kaashoek, A. S. Tanenbaum, S. F. Hummel, and H. E. Bal. </author> <title> An Efficient Reliable Broadcast Protocol. </title> <journal> Operating Systems Review, </journal> <volume> 23(4) </volume> <pages> 5-19, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: There are other membership services that allow partitioned operation. The membership service of the Amoeba system <ref> [20, 19] </ref> lets the user determine the minimal size with which the system can continue operating. If the user determines a majority threshold, the result is a primary-partition membership service. On lower thresholds, the system may partition. The user has the control in trading resiliency with consistency.
Reference: [21] <author> L. Lamport. </author> <title> Time, Clocks, and the Ordering of Events in a Distributed System. </title> <journal> Comm. ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July 78. </month>
Reference-contexts: This event can occur between successful install events, during periods of instability. It indicates to the user that an intermediate attempt to install a new membership, , has failed. We define after Lamport <ref> [21] </ref> the causal order of messages, as induced by the order of events in a history H, as the reflexive, transitive closure of: (1) m cause ! m 0 if C-deliver q (m) H ! C-multicast q (m 0 ; fl) (2) m cause ! m 0 if C-multicast q (m;
Reference: [22] <author> P. M. Melliar-Smith, L. E. Moser, and V. Agrawala. </author> <title> Broadcast Protocols for Distributed Systems. </title> <journal> IEEE Trans. Parallel & Distributed Syst., </journal> <volume> (1), </volume> <month> Jan </month> <year> 1990. </year>
Reference-contexts: Henceforth, we assume that the causal communication module in our environment satisfies Requisites C.1, C.2, C.3. 8 2.2 Causal delivery and Transis The causal communication properties C.1, C.2, C.3, are currently supported in many systems, e.g. Transis [3], Isis [8], Psync [27], Horus [29], and the Trans protocol <ref> [22] </ref>. The common factor to all of these systems is the relatively low overhead costs. In this subsection we give some details of the causal multicast in Transis. Transis contains the communication module responsible for the reliable and causal delivery of multicast messages in the system [3].
Reference: [23] <author> P. M. Melliar-Smith, L. E. Moser, and V. Agrawala. </author> <title> Membership Algorithms for Asynchronous Distributed Systems. </title> <booktitle> In Intl. Conf. Distributed Computing Systems, </booktitle> <month> May 91. </month>
Reference-contexts: In many similar systems, only one set (the primary) of machines is allowed to operate in the system, e.g. <ref> [28, 23, 24, 11] </ref>. Our approach is motivated by the assumption that 3 the membership service is part of a multicast communication substrate. As such, the membership service must not prevent the upper level applications from continuing operation in face of partitions. <p> For example, in <ref> [23] </ref>, a correct machine that performs infinitely many attempts to join the membership must succeed with probability one. The synchronous membership protocol of [11] places a time-bound on the amount of time it takes a correct machine to join the membership, provided that it remains correct throughout this period. <p> that there exist circumstances (extreme as they may be, for all we know) that allow a certain set of machines to form a membership. 11 * Requisite M.4: The virtual synchrony principle of Requisite M.4 has been adopted by several membership systems [2, 28, 4] and is also present in <ref> [23] </ref> (which totally orders all the messages, including membership changes). However, it is not supported by all: the membership protocol in [24] preserves causal-order between membership changes and regular messages, but does not guarantee virtual synchrony. <p> Another example is the membership algorithm of <ref> [23] </ref>, which is based on a single total order of messages throughout the system. Their membership changes are induced by the unique sequence of messages, and therefore are also unique. Since we allow partitions to occur, we must confine such a commitment to within the set of connected machines.
Reference: [24] <author> S. Mishra, L. L. Peterson, and R. D. Schlichting. </author> <title> A Membership Protocol based on Partial Order. </title> <booktitle> In proc. of the intl. working conf. on Dependable Computing for Critical Applications, </booktitle> <month> Feb </month> <year> 1991. </year>
Reference-contexts: In many similar systems, only one set (the primary) of machines is allowed to operate in the system, e.g. <ref> [28, 23, 24, 11] </ref>. Our approach is motivated by the assumption that 3 the membership service is part of a multicast communication substrate. As such, the membership service must not prevent the upper level applications from continuing operation in face of partitions. <p> However, it is not supported by all: the membership protocol in <ref> [24] </ref> preserves causal-order between membership changes and regular messages, but does not guarantee virtual synchrony.
Reference: [25] <author> L. E. Moser, Y. Amir, P. M. Melliar-Smith, and D. A. Agarwal. </author> <title> Extended Virtual Synchrony. </title> <year> 1993. </year>
Reference-contexts: The membership service of [4] discusses the installation of a transient membership in these cases. It is beyond the scope of this paper to discuss the importance of this information for application builders, and we refer the interested reader to <ref> [4, 25] </ref>. We do require that if p installs , all the other members in will at least be able to report of a possible membership change at that point (or crash). Requisite M.5 Let M-install p () be an event of H. Let q be a machine in . <p> The problem definition presented here gives the basis for consistent operation with multiple partitions. One of the directions set forth by this research is the development of additional communication layers, to support specific applications. For example, the work of Moser et al. <ref> [25] </ref> on Extended Virtual Synchrony binds the membership service with uniform message delivery, in order to support replicated databases in partitionable environments. 7 Acknowledgements We have benefitted from the experience gathered in the Transis project at the Hebrew University, the Isis and the Horus projects at Cornell University, and the Totem
Reference: [26] <author> S. Navaratnam, S. Chanson, and G. Neufeld. </author> <title> Reliable Group Communication is Distributed Systems. </title> <booktitle> In Intl. Conf. Distributed Computing Systems, </booktitle> <pages> pages 439-446. </pages> <publisher> IEEE, </publisher> <month> June 88. </month>
Reference: [27] <author> L. L. Peterson, N. C. Buchholz, and R. D. Schlichting. </author> <title> Preserving and Using Context Information in Interprocess Communication. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 7(3) </volume> <pages> 217-246, </pages> <month> August 89. </month>
Reference-contexts: Henceforth, we assume that the causal communication module in our environment satisfies Requisites C.1, C.2, C.3. 8 2.2 Causal delivery and Transis The causal communication properties C.1, C.2, C.3, are currently supported in many systems, e.g. Transis [3], Isis [8], Psync <ref> [27] </ref>, Horus [29], and the Trans protocol [22]. The common factor to all of these systems is the relatively low overhead costs. In this subsection we give some details of the causal multicast in Transis.
Reference: [28] <author> A. M. Ricciardi and K. P. Birman. </author> <title> Using Process Groups to Implement Failure Detection in Asynchronous Environments. </title> <booktitle> In proc. annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 341-352, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: In [11], a formal definition of the problem (and solution) is given for synchronous systems. To the best of our knowledge, the first formal definition of the requirements of membership in asynchronous environments is given in <ref> [28] </ref>. Their paper defines a primary-partition membership service, that maintains the local views of all the operational machines in agreement. Since it is well known that reaching agreement in asynchronous environments is impossible [14], the membership agreement must circumvent this difficulty somehow. The membership protocol in [28] uses an inaccurate failure <p> environments is given in <ref> [28] </ref>. Their paper defines a primary-partition membership service, that maintains the local views of all the operational machines in agreement. Since it is well known that reaching agreement in asynchronous environments is impossible [14], the membership agreement must circumvent this difficulty somehow. The membership protocol in [28] uses an inaccurate failure detector, based on timeout: When a machine is presumed faulty, it is taken out of the view, such that further messages from the faulty machine are discarded . In reality, failure detection can be fine-tuned to avoid false-detection almost entirely. <p> In reality, failure detection can be fine-tuned to avoid false-detection almost entirely. This approach is practical, and we adopt it, with an important modification: a presumed failed machine can rejoin the membership, and does not need to give up. In the application requirement in <ref> [28] </ref>, at most one partition may exist, and machines outside the primary partition are either dead or give up. In large and critical systems, this approach is not realistic, and it is essential to enable operation in face of partitions. <p> In many similar systems, only one set (the primary) of machines is allowed to operate in the system, e.g. <ref> [28, 23, 24, 11] </ref>. Our approach is motivated by the assumption that 3 the membership service is part of a multicast communication substrate. As such, the membership service must not prevent the upper level applications from continuing operation in face of partitions. <p> In the startup procedure, each partition might form its own membership set. The only way to avoid multiple partitions forming at startup is to use an external source of agreement, such as a central name-server (as in e.g. <ref> [29, 28] </ref>), or use a predetermined configuration. However, allowing for multiple partitions to exist, the most natural way to start up the system is to let each machine form a singleton set, and then merge the sets into larger sets whenever the connection is possible. <p> The synchronous membership protocol of [11] places a time-bound on the amount of time it takes a correct machine to join the membership, provided that it remains correct throughout this period. Ricciardi et al. <ref> [28] </ref> simply demand that machines are not taken out of the membership capriciously. Since they make no constraints on the fault detection in the system, their requirement does not guarantee that any two machines will ever form a joined membership. <p> All we demand in Requisite M.3 is that there exist circumstances (extreme as they may be, for all we know) that allow a certain set of machines to form a membership. 11 * Requisite M.4: The virtual synchrony principle of Requisite M.4 has been adopted by several membership systems <ref> [2, 28, 4] </ref> and is also present in [23] (which totally orders all the messages, including membership changes). However, it is not supported by all: the membership protocol in [24] preserves causal-order between membership changes and regular messages, but does not guarantee virtual synchrony. <p> There are several protocols that provide a membership service that is not related to multicast message delivery, such as [17, 11]. * Requisite M.5: In a primary partition membership, e.g. <ref> [28] </ref>, whenever a membership is installed, it will become the (only) view of the system at all the operational machines. Another example is the membership algorithm of [23], which is based on a single total order of messages throughout the system. <p> For purposes such as object replication, this membership is too weak (indeed, [17] also provides the Strong and the Hybrid memberships for consistent replication). Another issue is the possibility of a machine to return to the membership after being disconnected. In <ref> [28] </ref>, it is assumed that a machine that is taken out of the membership never returns to it. This implies that if a machine is mistakenly taken out of the membership, then it gives up when it finds out that it was taken out of the membership.
Reference: [29] <author> R. van Renesse, R. Cooper, B. Glade, and P. Stephenson. </author> <title> A Risc Approach to Process Groups. </title> <booktitle> In Proceedings of the 5th ACM SIGOPS Workshop, </booktitle> <pages> pages 21-23, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: The principles of the pro-tocol presented here have been successfully incorporated into the Transis system [3, 2], the Totem system [4], and the Horus system <ref> [29] </ref>. The membership protocol presented here is integrated in the communication system, such that the notifications of membership changes are delivered to the application among the stream of regular messages. Changes to the membership are coordinated with the delivery of regular messages in the system. <p> The Totem system [4] is based on a ring structure among the connected machines, and its underlying membership protocol is based on the principles of our membership protocol. A partial implementation of the merging algorithm was done within Horus <ref> [29] </ref>. The porting of the same principles within different environments proves that the protocol is indeed suitable for many multicast environments, and can be implemented cleanly within a separate module. <p> In the startup procedure, each partition might form its own membership set. The only way to avoid multiple partitions forming at startup is to use an external source of agreement, such as a central name-server (as in e.g. <ref> [29, 28] </ref>), or use a predetermined configuration. However, allowing for multiple partitions to exist, the most natural way to start up the system is to let each machine form a singleton set, and then merge the sets into larger sets whenever the connection is possible. <p> Henceforth, we assume that the causal communication module in our environment satisfies Requisites C.1, C.2, C.3. 8 2.2 Causal delivery and Transis The causal communication properties C.1, C.2, C.3, are currently supported in many systems, e.g. Transis [3], Isis [8], Psync [27], Horus <ref> [29] </ref>, and the Trans protocol [22]. The common factor to all of these systems is the relatively low overhead costs. In this subsection we give some details of the causal multicast in Transis.
Reference: [30] <author> P. Verissimo, L. Rodrigues, and J. Rufino. </author> <title> The Atomic Multicast Protocol (AMp). </title> <editor> In D. Powell, editor, Delta-4: </editor> <booktitle> A Generic Architecture for Dependable Distributed Computing, </booktitle> <pages> pages 267-294. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <month> 35 </month>
References-found: 30

