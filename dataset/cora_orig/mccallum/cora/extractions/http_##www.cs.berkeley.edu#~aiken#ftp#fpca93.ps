URL: http://www.cs.berkeley.edu/~aiken/ftp/fpca93.ps
Refering-URL: http://www.cs.berkeley.edu/~aiken/pubs.html
Root-URL: 
Email: aiken@almaden.ibm.com  wimmers@almaden.ibm.com  
Title: Type Inclusion Constraints and Type Inference  
Author: Alexander Aiken Edward L. Wimmers 
Date: November 16, 1993  
Address: 650 Harry Rd., San Jose, CA 95120  650 Harry Rd., San Jose, CA 95120  
Affiliation: IBM Almaden Research Center  IBM Almaden Research Center  
Abstract: We present a general algorithm for solving systems of inclusion constraints over type expressions. The constraint language includes function types, constructor types, and liberal intersection and union types. We illustrate the application of our constraint solving algorithm with a type inference system for the lambda calculus with constants. In this system, every pure lambda term has a (computable) type and every term typable in the Hindley/Milner system has all of its Hindley/Milner types. Thus, the inference system is an extension of the Hindley/Milner system that can type a very large set of lambda terms.
Abstract-found: 1
Intro-found: 1
Reference: [AM91] <author> A. Aiken and B. Murphy. </author> <title> Implementing regular tree expressions. </title> <booktitle> In Proceedings of the 1991 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 427-447, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: In this variation, the solutions of the constraints are 15 used to determine where run-time type checks are required [AW92b]. Based on our previous experience with implementing set constraints, we believe that the algorithms presented here can be implemented efficiently in practice <ref> [AM91] </ref>. There are interesting types that the system described here cannot handle.
Reference: [AW92a] <author> A. Aiken and E. Wimmers. </author> <title> Solving systems of set constraints. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <pages> pages 329-340, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: systems of inclusion constraints; we find it necessary to restrict the use of intersection and union types to obtain an effective algorithm. 1 The work we present is based on earlier work in solving systems of set constraints, which are inclusion constraints over sets of terms of a free algebra <ref> [AW92a] </ref>. The essential difference between set constraints and the constraints we discuss here is the addition of function types. With function types come all the difficulties inherent in reasoning about sets of (possibly partially defined) functions, so the constraint theory is substantially different and more difficult than that in [AW92a], although <p> algebra <ref> [AW92a] </ref>. The essential difference between set constraints and the constraints we discuss here is the addition of function types. With function types come all the difficulties inherent in reasoning about sets of (possibly partially defined) functions, so the constraint theory is substantially different and more difficult than that in [AW92a], although the same basic techniques apply. To help motivate and illustrate the potential of type inference systems based on our algorithm for solving type inclusion constraints, in Section 3 we introduce a simple inclusion-based type inference system for the lambda calculus with constants. <p> An inductive system (defined precisely in Definition 5.2) is a system of constraints with one lower and upper bound per variable L i ff i U i . Using techniques developed in <ref> [AW92a] </ref>, we show that inductive systems can be transformed to a set of equations ff i = L i [ (fi i " U i ) where the fi i are fresh variables. <p> As the first step, we show that every inductive system of constraints has a solution. We make use of two previous results in the proof. The first is a technique for transforming inclusion constraints to an equivalent system of equations <ref> [AW92a] </ref>. The second is the fact that systems of contractive equations have unique solutions [MPS84]. The constraint-solving algorithm presented in Section 7 reduces an initial system of constraints to a set of systems of inductive constraints or reports that the initial system is inconsistent. <p> Then S is equivalent to the cascading equations ff i = L i [ (fi i " U i ) where the fi i are fresh variables. Proof: The proof adapts a similar proof for solving systems of set constraints over the Herbrand Universe <ref> [AW92a] </ref>. Assume that L i ff i U i and let fi i = ff i . <p> Second, show that the transitive closure terminates. Third, show that a system of inductive constraints closed under transitivity is an inductive system. We show only the first two parts; the third part can be proven by adapting a similar proof in <ref> [AW92a] </ref>. For the first part, rules 1-10 either make the right-hand side smaller or make the left-hand side smaller and do not change the right-hand side. Whenever rule 11 is applied, the result is an inductive constraint.
Reference: [AW92b] <author> A. Aiken and E. Wimmers. </author> <title> Type inference with set constraints. </title> <type> Research Report 8956, </type> <institution> IBM, </institution> <year> 1992. </year>
Reference-contexts: In this variation, the solutions of the constraints are 15 used to determine where run-time type checks are required <ref> [AW92b] </ref>. Based on our previous experience with implementing set constraints, we believe that the algorithms presented here can be implemented efficiently in practice [AM91]. There are interesting types that the system described here cannot handle.
Reference: [BWW + 89] <author> J. Backus, J. H. Williams, E. L. Wimmers, P. Lucas, and A. Aiken. </author> <title> The FL language manual parts 1 and 2. </title> <type> Technical Report RJ 7100 (67163), </type> <institution> IBM, </institution> <year> 1989. </year>
Reference-contexts: While their system handles higher-order functions, unions are required to be discriminative and there are no intersection types. 9 Current and Future Work The implementation described in Section 3 is being extended to handle analysis of programs written in FL, a dynamically typed functional language <ref> [BWW + 89] </ref>. In this variation, the solutions of the constraints are 15 used to determine where run-time type checks are required [AW92b]. Based on our previous experience with implementing set constraints, we believe that the algorithms presented here can be implemented efficiently in practice [AM91].
Reference: [CF91] <author> R. Cartwright and M. Fagan. </author> <title> Soft typing. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 278-292, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Intersection is also restricted so that it cannot appear on the left-hand side of constraints. The inference system that is closest in spirit to ours is soft typing, proposed by Cartwright and Fagan <ref> [CF91] </ref>. Their typing algorithm also generates type constraints that must be solved. The constraints are not solved directly; they are first encoded in a special representation in which circular unification can be used to obtain representations of solutions, which are then decoded back to types.
Reference: [CW85] <author> L. Cardelli and P. Wegner. </author> <title> On understanding types, data abstraction and polymorphism. </title> <journal> Computing Surverys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: If the constraints do not have a solution, the program is considered to be ill-typed|it might produce a run-time type error. Many generalizations of the Hindley/Milner algorithm have been proposed; see <ref> [CW85, Rey85] </ref> for surveys of the major research directions. One approach that has received considerable attention is relaxing the form of the type constraints from equations X = Y to inclusions X Y [Mit84, Rey85, FM88, Tha88, KPS92].
Reference: [FM88] <author> Y. Fuh and P. Mishra. </author> <title> Type inference with subtypes. </title> <booktitle> In Proceedings of the 1988 European Symposium on Programming, </booktitle> <pages> pages 94-114, </pages> <year> 1988. </year> <month> 16 </month>
Reference-contexts: Many generalizations of the Hindley/Milner algorithm have been proposed; see [CW85, Rey85] for surveys of the major research directions. One approach that has received considerable attention is relaxing the form of the type constraints from equations X = Y to inclusions X Y <ref> [Mit84, Rey85, FM88, Tha88, KPS92] </ref>. In inclusion-based type systems, deciding whether a program has a type is reduced to the question of whether a system of inclusion constraints has a solution.
Reference: [Hin69] <author> R. Hindley. </author> <title> The principal type-scheme of an object in combinatory logic. </title> <journal> Transactions of the American Mathematical Society, </journal> <volume> 146 </volume> <pages> 29-60, </pages> <year> 1969. </year>
Reference-contexts: 1 Introduction Type inference systems for functional languages are based on solving systems of type constraints. The best known and most widely used type inference algorithm was first discovered by Hindley and later independently by Milner <ref> [Hin69, Mil78] </ref>. In its simplest form, the algorithm generates type equations from the program text and then solves the equations. If the equations have a solution, the program is well-typed|it cannot "go wrong" and produce a type error when executed.
Reference: [KPS92] <author> D. Kozen, J. Palsberg, and M. I. Schwartzbach. </author> <title> Efficient inference of partial types. </title> <booktitle> In Foundations of Computer Science, </booktitle> <pages> pages 363-371, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Many generalizations of the Hindley/Milner algorithm have been proposed; see [CW85, Rey85] for surveys of the major research directions. One approach that has received considerable attention is relaxing the form of the type constraints from equations X = Y to inclusions X Y <ref> [Mit84, Rey85, FM88, Tha88, KPS92] </ref>. In inclusion-based type systems, deciding whether a program has a type is reduced to the question of whether a system of inclusion constraints has a solution. <p> Then S (S HM ) S (S IC ). Proof: By inspection of the constraints. 2 Partial types are a generalization of the Hindley/Milner system. Partial types were introduced in [Tha88]; the problem of solving inclusion constraints over partial types has received considerable attention recently <ref> [OW92, KPS92] </ref>. The partial types are t ::= c (t 1 ; : : : ; t n ) j t 1 ! t 2 j ff j 1 In works on partial types, 1 is written . Only the inference rule for application is modified from the Hindley/Milner system.
Reference: [Mil78] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: 1 Introduction Type inference systems for functional languages are based on solving systems of type constraints. The best known and most widely used type inference algorithm was first discovered by Hindley and later independently by Milner <ref> [Hin69, Mil78] </ref>. In its simplest form, the algorithm generates type equations from the program text and then solves the equations. If the equations have a solution, the program is well-typed|it cannot "go wrong" and produce a type error when executed. <p> In subsequent sections we give an effective algorithm for solving a general class of type constraints such as the ones found in Figure 2. 3.1 Let-Polymorphism One important component of the Hindley/Milner type system that we have not yet discussed is let-polymorphism <ref> [Mil78] </ref>. A full discussion of polymorphism is beyond the scope of this paper; in this short section we very briefly show how let-polymorphism is incorporated into our system. In the end, except for the non-standard presentation using constraints, the inference rules are the same as in the Hindley/Milner system.
Reference: [Mit84] <author> J. Mitchell. </author> <title> Coercion and type inference (summary). </title> <booktitle> In Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 175-185, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: Many generalizations of the Hindley/Milner algorithm have been proposed; see [CW85, Rey85] for surveys of the major research directions. One approach that has received considerable attention is relaxing the form of the type constraints from equations X = Y to inclusions X Y <ref> [Mit84, Rey85, FM88, Tha88, KPS92] </ref>. In inclusion-based type systems, deciding whether a program has a type is reduced to the question of whether a system of inclusion constraints has a solution.
Reference: [MPS84] <author> D. MacQueen, G. Plotkin, and R. Sethi. </author> <title> An ideal model for recursive polymophic types. </title> <booktitle> In Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 165-174, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: The advantage of converting from containments to equations is that type equations are well understood; we apply a known result to prove that for every choice for the fi i the equations have a unique solution <ref> [MPS84] </ref>. The second difficulty is determining the rules for decomposing arbitrary constraints into constraints on variables. In many cases the rules are obvious; for example, the constraint X [ Y Z holds iff X Z and Y Z. <p> Section 8 compares our work with some additional related work; Section 9 concludes with a discussion of current and future work. 2 Lambda Calculus and Types The definitions in this section are either standard or minor variations on standard definitions; the reader familiar with semantic models of types <ref> [MPS84] </ref> may skip to Section 3 and use this section only for reference. Our programming language is the strict lambda calculus with a finite set of strict constructors C. Each c 2 C has a fixed arity; c may be a nullary constructor (a constant). <p> We essentially adopt the ideal model of types, in which types are certain subsets of the semantic domain <ref> [MPS84] </ref>. <p> c (x 1 ; : : : ; x n ) c (y 1 ; : : : ; y n ) iff x i y i for i = 1; : : : ; n This definition of type is essentially equivalent to the usual definition based on ideals <ref> [MPS84] </ref> because every ideal is isomorphic with a downward-closed set of finite elements. We choose to work with the finite elements both because it is simpler and because we make direct use of induction on the finite elements in proofs. <p> We make use of two previous results in the proof. The first is a technique for transforming inclusion constraints to an equivalent system of equations [AW92a]. The second is the fact that systems of contractive equations have unique solutions <ref> [MPS84] </ref>. The constraint-solving algorithm presented in Section 7 reduces an initial system of constraints to a set of systems of inductive constraints or reports that the initial system is inconsistent. <p> Formally, TLV (ff i ) = fff i g TLV (0) = ; TLV (X [ Y ) = TLV (X) [ TLV (Y ) 9 Top-level variables are also called the non-expansive variables <ref> [MPS84] </ref>. There is one problem in transferring the intuition given above to the actual proof. Because function types are anti-monotonic in the domain argument, the sets D i are not necessarily downward-closed and so are not types. <p> Then the only top-level variables are variables other than the ff i . For any fixed substitution for these top-level free variables, the equations become contractive (have no top-level variables). Contractive equations have unique solutions <ref> [MPS84] </ref>. 2 6 Type Complement, Union, and Intersection At the highest level, our strategy for solving systems of type inclusion constraints is to transform an arbitrary system of constraints into an inductive system. This requires decomposing constraints into simple constraints on variables and adding transitive constraints.
Reference: [MR85] <author> P. Mishra and U. Reddy. </author> <title> Declaration-free type checking. </title> <booktitle> In Proceedings of the Twelfth Annual ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 7-21, </pages> <year> 1985. </year>
Reference-contexts: Then S (S P ) S (S IC ). Proof: By inspection of the constraints. 2 The work of Mishra and Reddy on declaration-free type checking was one of the original inspirations for this work <ref> [MR85] </ref>. Their algorithm for solving inclusion constraints is more restrictive than ours in several ways. It is restricted to a first-order language, and all unions are required to be discriminative, which means that disjuncts must have different outermost constructors (i.e., c (: : :) [ d (: : :)).
Reference: [OW92] <author> P. N. O'Keefe and M. Wand. </author> <title> Type inference for partial types is decidable. </title> <booktitle> In Proceedings of the 1992 European Symposium on Programming, </booktitle> <year> 1992. </year>
Reference-contexts: Then S (S HM ) S (S IC ). Proof: By inspection of the constraints. 2 Partial types are a generalization of the Hindley/Milner system. Partial types were introduced in [Tha88]; the problem of solving inclusion constraints over partial types has received considerable attention recently <ref> [OW92, KPS92] </ref>. The partial types are t ::= c (t 1 ; : : : ; t n ) j t 1 ! t 2 j ff j 1 In works on partial types, 1 is written . Only the inference rule for application is modified from the Hindley/Milner system.
Reference: [Rey85] <author> J. C. Reynolds. </author> <title> Three approaches to type structure. </title> <booktitle> In Proc. TAPSOFT Advanced Seminar on the ROle of Semantics in Software Development, </booktitle> <address> Berlin, </address> <month> March </month> <year> 1985. </year> <booktitle> Springer Lecture Notes in Computer Science. </booktitle>
Reference-contexts: If the constraints do not have a solution, the program is considered to be ill-typed|it might produce a run-time type error. Many generalizations of the Hindley/Milner algorithm have been proposed; see <ref> [CW85, Rey85] </ref> for surveys of the major research directions. One approach that has received considerable attention is relaxing the form of the type constraints from equations X = Y to inclusions X Y [Mit84, Rey85, FM88, Tha88, KPS92]. <p> Many generalizations of the Hindley/Milner algorithm have been proposed; see [CW85, Rey85] for surveys of the major research directions. One approach that has received considerable attention is relaxing the form of the type constraints from equations X = Y to inclusions X Y <ref> [Mit84, Rey85, FM88, Tha88, KPS92] </ref>. In inclusion-based type systems, deciding whether a program has a type is reduced to the question of whether a system of inclusion constraints has a solution.
Reference: [Rob65] <author> J. A. Robinson. </author> <title> A machine-oriented logic based on the resolution principle. </title> <journal> Journal of the ACM, </journal> <volume> 12(1) </volume> <pages> 23-41, </pages> <year> 1965. </year>
Reference-contexts: A conclusion A; S ` e : t holds for all solutions of S. This proof system is deterministic|there is only one type derivation for any lambda term, up to renaming of type variables. It is well-known that the solutions of the constraints S can be computed using unification <ref> [Rob65] </ref>. to replace equality constraints by containments.
Reference: [Tha88] <author> S. Thatte. </author> <title> Type inference with partial types. </title> <booktitle> In Automata, Languages and Programming: 15th International Colloquium, </booktitle> <pages> pages 615-629. </pages> <booktitle> Springer-Verlag Lecture Notes in Computer Science, </booktitle> <volume> vol. 317, </volume> <month> July </month> <year> 1988. </year>
Reference-contexts: Many generalizations of the Hindley/Milner algorithm have been proposed; see [CW85, Rey85] for surveys of the major research directions. One approach that has received considerable attention is relaxing the form of the type constraints from equations X = Y to inclusions X Y <ref> [Mit84, Rey85, FM88, Tha88, KPS92] </ref>. In inclusion-based type systems, deciding whether a program has a type is reduced to the question of whether a system of inclusion constraints has a solution. <p> Then S (S HM ) S (S IC ). Proof: By inspection of the constraints. 2 Partial types are a generalization of the Hindley/Milner system. Partial types were introduced in <ref> [Tha88] </ref>; the problem of solving inclusion constraints over partial types has received considerable attention recently [OW92, KPS92]. <p> Only the inference rule for application is modified from the Hindley/Milner system. The translation of the rule in <ref> [Tha88] </ref> into our notation is A; S ` e 1 : t 1 ; e 2 : t 2 Lemma 8.2 Let e be a lambda term and let S P be the partial type constraints of a type derivation, and let S IC be the corresponding inclusion constraints.
Reference: [Wan87] <author> M. Wand. </author> <title> A simple algorithm and proof for type inference. </title> <note> Fundamenta Informaticae, X:115-122, </note> <year> 1987. </year>
Reference-contexts: A set of rules for Hindley/Milner type inference is given in Figure 1. These rules are presented in a non-standard form; following Wand <ref> [Wan87] </ref>, a set of type constraints S is associated with each inference rule. A conclusion A; S ` e : t holds for all solutions of S. This proof system is deterministic|there is only one type derivation for any lambda term, up to renaming of type variables.
References-found: 18

