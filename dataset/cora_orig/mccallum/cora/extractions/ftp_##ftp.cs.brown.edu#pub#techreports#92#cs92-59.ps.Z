URL: ftp://ftp.cs.brown.edu/pub/techreports/92/cs92-59.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-92-59.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Kenneth Barker. </author> <title> Transaction management on multidatabase systems. </title> <type> Technical Report TR 90-23, </type> <institution> Department of Computing Science, The University of Alberta, </institution> <year> 1990. </year>
Reference-contexts: Specific work includes [20, 16, 24, 23, 12, 17]. Elmagarmid and Du [9] explore how different local concurrency control models affect their serialization order. Schemes that do not necessarily enforce serializable global transaction executions, but try to approximate it, include quasi-serializability [7] (also called multidatabase serializability <ref> [1] </ref>) and two-level serializability (2LSR) [18].
Reference: [2] <author> Y. Breitbart, H. Garcia-Molina, and A. Silberschatz. </author> <title> Overview of multidatabase transaction management. </title> <journal> VLDB Journal, </journal> <volume> 1(2) </volume> <pages> 181-239, </pages> <month> October </month> <year> 1992. </year> <month> 28 </month>
Reference-contexts: Gligor et.al. [13] were the first to really explore issues concerning multidatabase transaction serializability, and they came up with a list of requirements that need to be met by the global transaction manager. A thorough survey of the approaches to these problems can be found in <ref> [2] </ref>. Specific work includes [20, 16, 24, 23, 12, 17]. Elmagarmid and Du [9] explore how different local concurrency control models affect their serialization order.
Reference: [3] <author> Alejandro Buchmann, M. Tamer Ozsu, Mark Hornick, Dimitrios Georgakopoulos, and Frank A. Manola. </author> <title> A transaction model for active distributed object systems. </title> <editor> In A. Elmagarmid, editor, </editor> <title> Database Transaction Models for Advanced Applications. </title> <publisher> Morgan-Kaufmann, </publisher> <year> 1991. </year>
Reference-contexts: In addition to these relatively standard multidatabase requirements, the multidatabase also supports reactive tasks that is, tasks which need to be notified of interesting events in the database. While reactive tasks can be supported by active databases <ref> [5, 3, 14] </ref>, we view this process as conceptually different than activating the database. In particular, our requirements state that if a condition is violated, the task reacts to restore its own internal consistency. Thus, the constraints that define the interesting events really belong to a planning task.
Reference: [4] <author> Jr. C. T. Davies. </author> <title> Data processing spheres of control. </title> <journal> IBM Systems Journal, </journal> <volume> 17(2) </volume> <pages> 179-198, </pages> <year> 1978. </year>
Reference-contexts: are easy to enforce in a multidatabase, but they need supplementary restrictions on transaction structure to ensure consistent execution at the global level. 26 10.2 Open Nested Models Open nested transactions differ from standard nested transactions [19] in that the children of a parent operate under different spheres of control <ref> [4] </ref>. Unlike multilevel transactions [26], open nested transactions are not restricted to conform to a consistent number of levels. Because Interactions are defined for a multidatabase environment, we restrict our nesting to two levels, although the model does not preclude extension to deeper levels of nesting.
Reference: [5] <author> U. Dayal, B. Blaustein, U. Chakravarthy, M. Hsu, R. Ledin, D. McCarthy, A. Rosenthal, S. Sarin, M.J. Carey, M. Livny, and R. Jauhari. </author> <title> The HiPAC project: Combining active databases and timing constraints. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 17(1) </volume> <pages> 51-70, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: In addition to these relatively standard multidatabase requirements, the multidatabase also supports reactive tasks that is, tasks which need to be notified of interesting events in the database. While reactive tasks can be supported by active databases <ref> [5, 3, 14] </ref>, we view this process as conceptually different than activating the database. In particular, our requirements state that if a condition is violated, the task reacts to restore its own internal consistency. Thus, the constraints that define the interesting events really belong to a planning task.
Reference: [6] <author> Umeshwar Dayal, Meichun Hsu, and Rivka Ladin. </author> <title> Organizing long-running activities with triggers and transactions. </title> <booktitle> In SIGMOD Proceedings, </booktitle> <year> 1990. </year>
Reference-contexts: In other words, weak conflicts do not indicate something to prevent, but rather when defined recovery measures must be taken. Weak conflicts are expressed as an execution span over which an ECA-type rule is enforced. ECA rules <ref> [6] </ref> specify an event to monitor for, conditions that must be checked if the event occurs, and actions to take if the condition is violated. With Interactions, we define the event as an update operation on a specific data item in some local database. <p> However, while Interactions are responsible for their own consistency, ConTracts place the responsibility of dealing with conflicting operations in the database itself. One other transaction model that incorporates open nesting is the extended nested transaction model from <ref> [6] </ref>. This model assumes an underlying database that is active. 10.3 Recovery Approaches Our work differs from other work in open nested transactions because of the types of failure we support. All work, including ours, needs to deal with open nested transaction failures when a system failure occurs.
Reference: [7] <author> Weimin Du and Ahmed K. Elmagarmid. Quasi-serializability: </author> <title> A correctness criterion for global con-currency control in InterBase. </title> <booktitle> In Proceedings of the 15th VLDB, </booktitle> <pages> pages 347-355, </pages> <year> 1989. </year>
Reference-contexts: Specific work includes [20, 16, 24, 23, 12, 17]. Elmagarmid and Du [9] explore how different local concurrency control models affect their serialization order. Schemes that do not necessarily enforce serializable global transaction executions, but try to approximate it, include quasi-serializability <ref> [7] </ref> (also called multidatabase serializability [1]) and two-level serializability (2LSR) [18].
Reference: [8] <author> A. K. Elmagarmid, Y. Leu, W. Litwin, and M. Rusinkiewicz. </author> <title> A multidatabase transaction model for InterBase. </title> <booktitle> In VLDB Proceedings, </booktitle> <pages> pages 507-518, </pages> <year> 1990. </year>
Reference-contexts: An Interaction is programmed in terms of actions, that dictate what needs to be done to accomplish its task. These actions are grouped together into blocks that are executed together as atomic global transactions. As with Flex Transactions <ref> [8] </ref>, the Interaction can specify different ways to accomplish the task, depending on the multidatabase state. 2.3.1 Actions, Global Transactions and Steps An action is a partially ordered set of steps each of which accomplishes the same objective. Exactly one step must succeed for the action to succeed. <p> If no compensating code blocks succeed, the default could be to allow the user to fix the problem himself. This ability to do less-than-optimal compensation steps we call "sloppy compensation". 6.2 Dealing with Flexible Transactions Flexible transaction models such as <ref> [10, 8, 25, 22] </ref> allow the execution flow of an open nested transaction to depend in part on the information in the database. <p> An early open nested transaction model was Sagas [11]. A Saga is a sequence of independent atomic transactions. This work was extended to the nested Saga model [10]. In a nested Saga, a child can be either another Saga or a transaction. Nested Sagas, ConTracts [25], and Flex transactions <ref> [8] </ref> extend the open nested transaction model to allow flexibility in execution depending on the database state. With flexibility, different ways of achieving the same goals are specified.
Reference: [9] <author> Ahmed K. Elmagarmid and Weimin Du. </author> <title> A paradigm for concurrency control in heterogeneous distributed database systems. </title> <booktitle> In Proceedings of the 6th International Conference on Data Engineering, </booktitle> <pages> pages 37-46, </pages> <year> 1990. </year>
Reference-contexts: A thorough survey of the approaches to these problems can be found in [2]. Specific work includes [20, 16, 24, 23, 12, 17]. Elmagarmid and Du <ref> [9] </ref> explore how different local concurrency control models affect their serialization order. Schemes that do not necessarily enforce serializable global transaction executions, but try to approximate it, include quasi-serializability [7] (also called multidatabase serializability [1]) and two-level serializability (2LSR) [18].
Reference: [10] <author> Hector Garcia-Molina, Dieter Gawlick, Johannes Klein, Karl Kleissner, and Kenneth Salem. </author> <title> Coordinating multi-transaction activities. </title> <type> Technical Report CS-TR-247-90, </type> <institution> Princeton University Department of Computer Science, </institution> <month> February </month> <year> 1990. </year>
Reference-contexts: If no compensating code blocks succeed, the default could be to allow the user to fix the problem himself. This ability to do less-than-optimal compensation steps we call "sloppy compensation". 6.2 Dealing with Flexible Transactions Flexible transaction models such as <ref> [10, 8, 25, 22] </ref> allow the execution flow of an open nested transaction to depend in part on the information in the database. <p> An early open nested transaction model was Sagas [11]. A Saga is a sequence of independent atomic transactions. This work was extended to the nested Saga model <ref> [10] </ref>. In a nested Saga, a child can be either another Saga or a transaction. Nested Sagas, ConTracts [25], and Flex transactions [8] extend the open nested transaction model to allow flexibility in execution depending on the database state. With flexibility, different ways of achieving the same goals are specified. <p> Nested Sagas <ref> [10] </ref> require that the compensating Sagas be invoked recursively. The ConTracts work [25] makes some additional observations concerning compensation. Compensating transactions do not need to run in the inverse order of their corresponding transactions: In fact, compensating transactions are often completely independent and can run concurrently.
Reference: [11] <author> Hector Garcia-Molina and Kenneth Salem. Sagas. </author> <booktitle> In ACM SIGMOD Proceedings, </booktitle> <pages> pages 249-259. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference-contexts: The global subtransactions commit atomically with the global transaction commit. 2.2 Atomicity, Visibility and Conflict The global transactions in an Interaction commit atomically once all of their steps have executed. In this sense, Interactions are like Sagas <ref> [11] </ref>, in that this global transaction commitment makes its effects on the local databases visible both to other global transactions and Interactions as well as to independent transactions. <p> In the next section we outline the replacement recovery scheme, which avoids some of these pitfalls. 6.1 Non-Persistence of Compensation Persistence of compensation states that all (compensating) subtransactions in an open nested transaction must succeed if retried enough times. This requirement was first identified for Sagas <ref> [11] </ref>. While persistence of compensation may hold true in restricted situations, it does not hold true in a general open nested transaction environment. Open nested transactions periodically release the resources they hold, allowing other database transactions to interleave with their own operation. <p> The customer may no longer be able to go on the trip, but fully canceling the Pan Am flight and getting a refund is impossible. The customer has relinquished control over his money. In the early work on Sagas <ref> [11] </ref>, a concept called recovery blocks was proposed. A recovery block provides an alternate way of compensating a particular action, under the assumption that the first method was faulty. Recovery blocks work if the compensation is possible, but do not apply in our Pan Am bankruptcy example. <p> Concurrency within an open nested transaction is usually specified explicitly using constructs equivalent to fork and join <ref> [11, 21] </ref>. Once a concurrent thread has forked, it can execute atomic subtransactions concurrently with the thread that forked it. One issue with concurrent threads is that it may be necessary to semantically undo one thread while leaving the other concurrent threads intact. <p> Because Interactions are defined for a multidatabase environment, we restrict our nesting to two levels, although the model does not preclude extension to deeper levels of nesting. An early open nested transaction model was Sagas <ref> [11] </ref>. A Saga is a sequence of independent atomic transactions. This work was extended to the nested Saga model [10]. In a nested Saga, a child can be either another Saga or a transaction. <p> All of the models described in the previous section use a form of recovery called compensation. This form of recovery was first defined in detail by Garcia-Molina and Salem <ref> [11] </ref>. In their Sagas, each transaction has a corresponding compensating transaction.
Reference: [12] <author> Dimitrios Georgakapoulos, Marek Rusinkiewicz, and Amit Sheth. </author> <title> On serializability of multidatabase transactions through forced local conflicts. </title> <booktitle> In 1991 Data Engineering Proceedings, </booktitle> <pages> pages 314-323, </pages> <year> 1991. </year>
Reference-contexts: One Agent is associated with each local database. Its primary job is to help the Global Transaction Manager ensure that the resulting history containing all global subtransactions and independent transactions is serializable. There are several known algorithms for this <ref> [23, 12, 17] </ref>. The Agent also maintains a Step Library that contains code to translate the steps of the different global subtransactions from the multidatabase's DML to the local database's DML. <p> For the purposes of this paper, we assume that the Global Transaction Manager dictates some serialization order for the global subtransactions, and this order is enforced using the forced local conflict scheme <ref> [12] </ref>. That is, a "ticket" is kept in each local database for use by the multidatabase. The ticket is successively incremented by each global subtransaction, with the increment order following the dictated serialization order. Other possible schemes include [24, 23, 17]. <p> A thorough survey of the approaches to these problems can be found in [2]. Specific work includes <ref> [20, 16, 24, 23, 12, 17] </ref>. Elmagarmid and Du [9] explore how different local concurrency control models affect their serialization order. Schemes that do not necessarily enforce serializable global transaction executions, but try to approximate it, include quasi-serializability [7] (also called multidatabase serializability [1]) and two-level serializability (2LSR) [18].
Reference: [13] <author> Virgil Gligor and Radu Popescu-Zeletin. </author> <title> Transaction management in heterogeneous database management systems. </title> <journal> Information Systems, </journal> <volume> 11(4) </volume> <pages> 287-297, </pages> <year> 1986. </year>
Reference-contexts: This is a subject of future research. 10 Related Research 10.1 (Almost-) Serializable Models This work assumes an underlying multidatabase transaction manager that enforces the atomicity or semantic atomicity of global transactions on the multidatabase. This problem is currently receiving much scrutiny. Gligor et.al. <ref> [13] </ref> were the first to really explore issues concerning multidatabase transaction serializability, and they came up with a list of requirements that need to be met by the global transaction manager. A thorough survey of the approaches to these problems can be found in [2].
Reference: [14] <author> Scott E. Hudson and Roger King. Cactis: </author> <title> A database system for specifying functionally-defined data. </title> <booktitle> In IEEE OODBS Workshop, </booktitle> <year> 1986. </year>
Reference-contexts: In addition to these relatively standard multidatabase requirements, the multidatabase also supports reactive tasks that is, tasks which need to be notified of interesting events in the database. While reactive tasks can be supported by active databases <ref> [5, 3, 14] </ref>, we view this process as conceptually different than activating the database. In particular, our requirements state that if a condition is violated, the task reacts to restore its own internal consistency. Thus, the constraints that define the interesting events really belong to a planning task.
Reference: [15] <author> Henry F. Korth, Eliezer Levy, and Abraham Silberschatz. </author> <title> A formal approach to recovery by compensating transactions. </title> <booktitle> In VLDB Proceedings, </booktitle> <pages> pages 95-106, </pages> <year> 1990. </year>
Reference-contexts: Because open nested transactions make partial results visible early, recovery of one transaction can cascade to others. ConTracts address this problem by explicitly maintaining all dependencies. However, this maintenance is not always possible. For example, dependencies cannot be explicitly computed in a multidatabase. 27 Korth et.al. <ref> [15] </ref> describe compensation with respect to their entitywise 2PL correctness specification for transaction execution. They examine the effects of intervening conflicting transactions on the success of compensating transactions, and give some ideas on how to constrain executions so the resulting history is approximately sound.
Reference: [16] <author> Eliezer Levy, Henry F. Korth, and Abraham Silberschatz. </author> <title> An optimistic commit protocol for distributed transaction management. </title> <booktitle> In 1991 ACM SIGMOD Proceedings, </booktitle> <pages> pages 88-97, </pages> <year> 1991. </year>
Reference-contexts: The ticket is successively incremented by each global subtransaction, with the increment order following the dictated serialization order. Other possible schemes include [24, 23, 17]. For atomic commitment, we follow the "local commitment before global decision" algorithm defined in [20]. Another commit scheme is defined in <ref> [16] </ref>. 9 4.2 Scheduling Actions and Steps At any specific time, the different in-process Interactions in the database have one or more concurrent threads executing the different tasks and subtasks. <p> First is that the constraint of "persistence of compensation" <ref> [16] </ref> cannot be guaranteed except in restricted environments. A second problem is that with the newer, flexible transaction models, exact compensation is certainly possible, but the re-execution may diverge radically and/or unacceptably from the original execution. <p> A thorough survey of the approaches to these problems can be found in [2]. Specific work includes <ref> [20, 16, 24, 23, 12, 17] </ref>. Elmagarmid and Du [9] explore how different local concurrency control models affect their serialization order. Schemes that do not necessarily enforce serializable global transaction executions, but try to approximate it, include quasi-serializability [7] (also called multidatabase serializability [1]) and two-level serializability (2LSR) [18].
Reference: [17] <author> Sharad Mehrotra, Rajeev Rastogi, Yuri Breitbart, Henry F. Korth, and Avi Silberschatz. </author> <title> The concur-rency control problem in multidatabases: Characteristics and solutions. </title> <booktitle> In SIGMOD 1992 Proceedings, </booktitle> <pages> pages 288-297, </pages> <year> 1992. </year>
Reference-contexts: One Agent is associated with each local database. Its primary job is to help the Global Transaction Manager ensure that the resulting history containing all global subtransactions and independent transactions is serializable. There are several known algorithms for this <ref> [23, 12, 17] </ref>. The Agent also maintains a Step Library that contains code to translate the steps of the different global subtransactions from the multidatabase's DML to the local database's DML. <p> That is, a "ticket" is kept in each local database for use by the multidatabase. The ticket is successively incremented by each global subtransaction, with the increment order following the dictated serialization order. Other possible schemes include <ref> [24, 23, 17] </ref>. For atomic commitment, we follow the "local commitment before global decision" algorithm defined in [20]. <p> A thorough survey of the approaches to these problems can be found in [2]. Specific work includes <ref> [20, 16, 24, 23, 12, 17] </ref>. Elmagarmid and Du [9] explore how different local concurrency control models affect their serialization order. Schemes that do not necessarily enforce serializable global transaction executions, but try to approximate it, include quasi-serializability [7] (also called multidatabase serializability [1]) and two-level serializability (2LSR) [18].
Reference: [18] <author> Sharad Mehrotra, Rajeev Rastogi, Henry F. Korth, and Abraham Silberschatz. </author> <title> Non-serializable executions in heterogeneous distributed database systems. </title> <booktitle> In Proceedings of the First International Conference on Parallel and Distributed Information Systems, </booktitle> <year> 1991. </year>
Reference-contexts: Elmagarmid and Du [9] explore how different local concurrency control models affect their serialization order. Schemes that do not necessarily enforce serializable global transaction executions, but try to approximate it, include quasi-serializability [7] (also called multidatabase serializability [1]) and two-level serializability (2LSR) <ref> [18] </ref>.
Reference: [19] <author> J. Eliot B. Moss. </author> <title> Nested Transactions: An Approach to Reliable Distributed Computing. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1985. </year>
Reference-contexts: Both QSR and 2LSR are easy to enforce in a multidatabase, but they need supplementary restrictions on transaction structure to ensure consistent execution at the global level. 26 10.2 Open Nested Models Open nested transactions differ from standard nested transactions <ref> [19] </ref> in that the children of a parent operate under different spheres of control [4]. Unlike multilevel transactions [26], open nested transactions are not restricted to conform to a consistent number of levels.
Reference: [20] <author> Peter Muth and Thomas G. Rakow. </author> <title> Atomic commitment for integrated database systems. </title> <booktitle> In 1991 Data Engineering Proceedings, </booktitle> <pages> pages 296-304, </pages> <year> 1991. </year> <month> 29 </month>
Reference-contexts: The ticket is successively incremented by each global subtransaction, with the increment order following the dictated serialization order. Other possible schemes include [24, 23, 17]. For atomic commitment, we follow the "local commitment before global decision" algorithm defined in <ref> [20] </ref>. Another commit scheme is defined in [16]. 9 4.2 Scheduling Actions and Steps At any specific time, the different in-process Interactions in the database have one or more concurrent threads executing the different tasks and subtasks. <p> A thorough survey of the approaches to these problems can be found in [2]. Specific work includes <ref> [20, 16, 24, 23, 12, 17] </ref>. Elmagarmid and Du [9] explore how different local concurrency control models affect their serialization order. Schemes that do not necessarily enforce serializable global transaction executions, but try to approximate it, include quasi-serializability [7] (also called multidatabase serializability [1]) and two-level serializability (2LSR) [18].
Reference: [21] <author> Marian H. Nodine. </author> <title> Interactions: A non-serializable global transaction model for heterogeneous multi--databases. </title> <type> Technical Report CS-91-64, </type> <institution> Brown University Department of Computer Science, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: Concurrency within an open nested transaction is usually specified explicitly using constructs equivalent to fork and join <ref> [11, 21] </ref>. Once a concurrent thread has forked, it can execute atomic subtransactions concurrently with the thread that forked it. One issue with concurrent threads is that it may be necessary to semantically undo one thread while leaving the other concurrent threads intact.
Reference: [22] <author> Marian H. Nodine. </author> <title> Supporting long-running tasks on an evolving multidatabase using interactions and events. </title> <booktitle> In Proceedings of the Second International Conference on Parallel and Distributed Information Systems, </booktitle> <year> 1993. </year> <note> to appear. </note>
Reference-contexts: If no compensating code blocks succeed, the default could be to allow the user to fix the problem himself. This ability to do less-than-optimal compensation steps we call "sloppy compensation". 6.2 Dealing with Flexible Transactions Flexible transaction models such as <ref> [10, 8, 25, 22] </ref> allow the execution flow of an open nested transaction to depend in part on the information in the database.
Reference: [23] <author> William Perrizo, Joseph Rajkumar, and Prabhu Ram. </author> <title> Hydro: A heterogeneous distributed database system. </title> <booktitle> In SIGMOD Proceedings, </booktitle> <pages> pages 32-39, </pages> <year> 1991. </year>
Reference-contexts: One Agent is associated with each local database. Its primary job is to help the Global Transaction Manager ensure that the resulting history containing all global subtransactions and independent transactions is serializable. There are several known algorithms for this <ref> [23, 12, 17] </ref>. The Agent also maintains a Step Library that contains code to translate the steps of the different global subtransactions from the multidatabase's DML to the local database's DML. <p> That is, a "ticket" is kept in each local database for use by the multidatabase. The ticket is successively incremented by each global subtransaction, with the increment order following the dictated serialization order. Other possible schemes include <ref> [24, 23, 17] </ref>. For atomic commitment, we follow the "local commitment before global decision" algorithm defined in [20]. <p> A thorough survey of the approaches to these problems can be found in [2]. Specific work includes <ref> [20, 16, 24, 23, 12, 17] </ref>. Elmagarmid and Du [9] explore how different local concurrency control models affect their serialization order. Schemes that do not necessarily enforce serializable global transaction executions, but try to approximate it, include quasi-serializability [7] (also called multidatabase serializability [1]) and two-level serializability (2LSR) [18].
Reference: [24] <author> Calton Pu. </author> <title> Superdatabases for composition of heterogeneous databases. </title> <booktitle> In Proceedings of the 4th International Conference on Data Engineering, </booktitle> <pages> pages 548-555, </pages> <year> 1988. </year>
Reference-contexts: That is, a "ticket" is kept in each local database for use by the multidatabase. The ticket is successively incremented by each global subtransaction, with the increment order following the dictated serialization order. Other possible schemes include <ref> [24, 23, 17] </ref>. For atomic commitment, we follow the "local commitment before global decision" algorithm defined in [20]. <p> A thorough survey of the approaches to these problems can be found in [2]. Specific work includes <ref> [20, 16, 24, 23, 12, 17] </ref>. Elmagarmid and Du [9] explore how different local concurrency control models affect their serialization order. Schemes that do not necessarily enforce serializable global transaction executions, but try to approximate it, include quasi-serializability [7] (also called multidatabase serializability [1]) and two-level serializability (2LSR) [18].
Reference: [25] <author> Helmut Waechter and Andreas Reuter. </author> <title> The ConTract model. </title> <editor> In A. Elmagarmid, editor, </editor> <title> Database Transaction Models for Advanced Applications. </title> <address> Morgan-Kauffman, </address> <year> 1991. </year>
Reference-contexts: If no compensating code blocks succeed, the default could be to allow the user to fix the problem himself. This ability to do less-than-optimal compensation steps we call "sloppy compensation". 6.2 Dealing with Flexible Transactions Flexible transaction models such as <ref> [10, 8, 25, 22] </ref> allow the execution flow of an open nested transaction to depend in part on the information in the database. <p> In fact, more concurrency is possible during the compensation process, because compensation steps are usually fixed code (no branches or loops) with predetermined inputs (based on the inputs and/or results from the original step) <ref> [25] </ref>. However, depending on how the state is managed, two concurrent subtransactions that conflict on some state variable may not be able to be compensated for and re-executed concurrently. Consider the open nested transaction shown in Figure 7. <p> An early open nested transaction model was Sagas [11]. A Saga is a sequence of independent atomic transactions. This work was extended to the nested Saga model [10]. In a nested Saga, a child can be either another Saga or a transaction. Nested Sagas, ConTracts <ref> [25] </ref>, and Flex transactions [8] extend the open nested transaction model to allow flexibility in execution depending on the database state. With flexibility, different ways of achieving the same goals are specified. <p> Nested Sagas [10] require that the compensating Sagas be invoked recursively. The ConTracts work <ref> [25] </ref> makes some additional observations concerning compensation. Compensating transactions do not need to run in the inverse order of their corresponding transactions: In fact, compensating transactions are often completely independent and can run concurrently.
Reference: [26] <author> Gerhard Wiekum and Hans-J. Schek. </author> <title> Concepts and applications of multilevel transactions and open nested transactions. </title> <editor> In A. Elmagarmid, editor, </editor> <booktitle> Database Transaction Models for Advanced Applications, </booktitle> <pages> pages 515-547. </pages> <publisher> Morgan-Kaufmann, </publisher> <year> 1991. </year> <month> 30 </month>
Reference-contexts: Unlike multilevel transactions <ref> [26] </ref>, open nested transactions are not restricted to conform to a consistent number of levels. Because Interactions are defined for a multidatabase environment, we restrict our nesting to two levels, although the model does not preclude extension to deeper levels of nesting.
References-found: 26

