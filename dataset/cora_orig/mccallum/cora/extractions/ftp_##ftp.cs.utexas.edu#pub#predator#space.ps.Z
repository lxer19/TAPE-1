URL: ftp://ftp.cs.utexas.edu/pub/predator/space.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/schwartz/pub.htm
Root-URL: 
Title: Software Component Technologies and Space Applications  
Author: Don Batory 
Address: Austin, Texas 78712  
Affiliation: Department of Computer Sciences The University of Texas  
Abstract: In the near future, software systems will be more reconfigurable than hardware. This will be possible through the advent of software component technologies, which have been prototyped in universities and research labs. In this paper, we outline the foundations for these technologies and suggest how they might impact software for space applications.
Abstract-found: 1
Intro-found: 1
Reference: [Bax92] <author> I. Baxter, </author> <title> Design Maintenance Systems, </title> <journal> CACM April 1992, </journal> <pages> 73-89. </pages>
Reference-contexts: Minimal design changes often require major software rewrites. Rather than maintaining and evolving source code, an alternative is to maintain and evolve the design and to generate the corresponding source code automatically. This is the concept of design maintenance <ref> [Bax92] </ref>. Design maintenance asserts that the designs of software systems are quantized; there are primitive components of software design in every domain. A component encapsulates a domain-specific capability that software systems of that domain can exhibit. <p> Such elaborations can occur in many parts (e.g., classes) of a systems software. Moreover, an inherent part of an FRPT is the ability to perform reective computations, so that only the most efficient algorithms are generated. Composing components is equivalent to composing transformations <ref> [Bax92, Bat92] </ref>. The key ingredient that enables components to be composed is due to a disciplined design that stan-dardizes the abstractions (and their programming language interfaces) of a domain.
Reference: [Bat92] <author> D. Batory and S. OMalley, </author> <title> The Design and Implementation of Hierarchical Software Systems with Reusable Components, </title> <journal> ACM TOSEM, </journal> <month> October </month> <year> 1992. </year>
Reference-contexts: Such elaborations can occur in many parts (e.g., classes) of a systems software. Moreover, an inherent part of an FRPT is the ability to perform reective computations, so that only the most efficient algorithms are generated. Composing components is equivalent to composing transformations <ref> [Bax92, Bat92] </ref>. The key ingredient that enables components to be composed is due to a disciplined design that stan-dardizes the abstractions (and their programming language interfaces) of a domain.
Reference: [Bat93] <author> D. Batory, V. Singhal, M. Sirkin, and J. Thomas, </author> <title> Scalable Software Libraries, </title> <booktitle> ACM SIGSOFT 1993. </booktitle>
Reference-contexts: Thus a component must encapsulate more than just algorithms: it must also encapsulate reective computations, i.e., domain-specific decisions about when to use a particular algorithm and/or when to apply a domain-specific optimization. For most domains, reective computations are critical for generating efficient code <ref> [Bat93] </ref>. What programming paradigm supports such componentry? The rallying cry of object-orientation is that everything is an object. Object-oriented design methodologies and programming languages are indeed powerful, but they are insufficient for software components.
Reference: [Bat95a] <author> D. Batory, L. Coglianese, M. Goodwin, and S. Shafer, </author> <title> Creating Reference Architectures: An Example From Avionics, </title> <booktitle> ACM SIGSOFT Symposium on Software Reusability, </booktitle> <address> Seattle, </address> <year> 1995, </year> <pages> 27-37. </pages>
Reference-contexts: A primitive component, by definition, is reusable because it is used in the design of many family members. Domain modeling is the name given to software design methodologies that identify primitive components of software designs for a specific domain <ref> [Pri91, Gom94, Bat95a] </ref>. A second implication is that a primitive component of software design need not correspond to a primitive code module or package in a generated system.
Reference: [Bat95b] <author> D. Batory and B.J. Geraci, </author> <title> Validating Component Compositions in Software System Generators, </title> <institution> Department of Computer Sciences, University of Texas at Austin, TR-93-03, </institution> <month> February </month> <year> 1995. </year>
Reference-contexts: While demonstrating consistency falls short of formal verification, it is an major step forward in making software system generation practical <ref> [Per89, Bat95b] </ref>. Software component technologies and generator technologies have been developed for the domains of avionics, database systems, file systems, network protocols, and data structures. Related composition/ encapsulation technologies in software architectures are [Gor91, Per92, Gar93].
Reference: [Gar93] <author> D. Garlan and M. Shaw, </author> <title> An Introduction to Software Architecture, </title> <booktitle> in Advances in Software Engineering and Knowledge Engineering, Volume I, </booktitle> <publisher> World Scientific Publishing Company, </publisher> <year> 1993. </year>
Reference-contexts: Software component technologies and generator technologies have been developed for the domains of avionics, database systems, file systems, network protocols, and data structures. Related composition/ encapsulation technologies in software architectures are <ref> [Gor91, Per92, Gar93] </ref>. Readers who are interested in the technical details of these discussions are urged to consult the cited references. 3 Relevance to Software Development for Space Applications In the following, I address the community of software developers for space applications.
Reference: [Gom94] <author> H. Gomaa, L. Kerschberg, V. Sugumaran, C. Bosch, and I. Tavakoli, </author> <title> A Prototype Domain Modeling Environment for Reusable Software Architectures, </title> <booktitle> Third International Conference on Software Reuse, </booktitle> <address> Rio de Janeiro, </address> <month> November 1-4, </month> <year> 1994, </year> <pages> 74-83. </pages>
Reference-contexts: A primitive component, by definition, is reusable because it is used in the design of many family members. Domain modeling is the name given to software design methodologies that identify primitive components of software designs for a specific domain <ref> [Pri91, Gom94, Bat95a] </ref>. A second implication is that a primitive component of software design need not correspond to a primitive code module or package in a generated system.
Reference: [Gor91] <editor> M.M. Gorlick and R.R. Razouk, </editor> <title> Using Weaves for Software Construction and Analysis, </title> <booktitle> Proc. ICSE 1991, </booktitle> <pages> 23-34. </pages>
Reference-contexts: Software component technologies and generator technologies have been developed for the domains of avionics, database systems, file systems, network protocols, and data structures. Related composition/ encapsulation technologies in software architectures are <ref> [Gor91, Per92, Gar93] </ref>. Readers who are interested in the technical details of these discussions are urged to consult the cited references. 3 Relevance to Software Development for Space Applications In the following, I address the community of software developers for space applications.
Reference: [Par79] <author> D.L. Parnas, </author> <title> Designing Software for Ease of Extension and Contraction, </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> March </month> <year> 1979. </year>
Reference-contexts: But often the effort needed to make even minor changes to a system is far out of proportion to the changes themselves <ref> [Par79] </ref>. The problem is that source code is the most detailed and concrete realization of a software design. The most critical changes (and hence the most important evolutionary changes) to a software system are modifications to its design. Minimal design changes often require major software rewrites.
Reference: [Per89] <author> D.E. Perry, </author> <title> The Logic of Propagation in The Inscape Environment, </title> <booktitle> ACM SIGSOFT 1989, </booktitle> <pages> 114-121. </pages>
Reference-contexts: While demonstrating consistency falls short of formal verification, it is an major step forward in making software system generation practical <ref> [Per89, Bat95b] </ref>. Software component technologies and generator technologies have been developed for the domains of avionics, database systems, file systems, network protocols, and data structures. Related composition/ encapsulation technologies in software architectures are [Gor91, Per92, Gar93].
Reference: [Per92] <author> D.E. Perry and A.L. Wolf, </author> <title> Foundations for the Study of Software Architecture, </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <month> October </month> <year> 1992, </year> <pages> 40-52. </pages>
Reference-contexts: Software component technologies and generator technologies have been developed for the domains of avionics, database systems, file systems, network protocols, and data structures. Related composition/ encapsulation technologies in software architectures are <ref> [Gor91, Per92, Gar93] </ref>. Readers who are interested in the technical details of these discussions are urged to consult the cited references. 3 Relevance to Software Development for Space Applications In the following, I address the community of software developers for space applications.
Reference: [Pri91] <author> R. Prieto-Diaz and G. Arango (ed.), </author> <title> Domain Analysis and Software Systems Modeling, </title> <publisher> IEEE Computer Society Press 1991. </publisher>
Reference-contexts: A primitive component, by definition, is reusable because it is used in the design of many family members. Domain modeling is the name given to software design methodologies that identify primitive components of software designs for a specific domain <ref> [Pri91, Gom94, Bat95a] </ref>. A second implication is that a primitive component of software design need not correspond to a primitive code module or package in a generated system.
References-found: 12

