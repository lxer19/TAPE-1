URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/94-30.ps.Z
Refering-URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/README.html
Root-URL: 
Email: fjana, bharatg@cs.buffalo.edu  
Title: Set Constructors, Finite Sets, and Logical Semanticsy  
Author: Devashis Jana Bharat Jayaraman 
Keyword: set constructors, finite sets, Zermelo-Fraenkel set theory, freeness axioms, set unification, Herbrand structure, logical semantics.  
Address: Buffalo, NY 14260  
Affiliation: Department of Computer Science State University of New York at Buffalo  
Abstract: The use of sets in declarative programming has been advocated by several authors in the literature. A representation often chosen for finite sets is that of scons, parallel to the list constructor cons. The logical theory for such constructors is usually tacitly assumed to be some formal system of classical set theory. However, classical set theory is formulated for a general setting, dealing with both finite and infinite sets, and not making any assumptions about particular set constructors. In giving logical-consequence semantics for programs with finite sets, it is important to know exactly what connection exists between sets and set constructors. The main contribution of this paper lies in establishing these connections rigorously. We give a formal system, called SetAx, designed around the scons constructor. We distinguish between two kinds of set constructors, scons(x; y) and dscons(x; y), where both represent fxg [ y, but x 2 y is possible in the former, while x 62 y holds in the latter. Both constructors find natural uses in specifying sets in logic programs. The design of SetAx is guided by our choice of scons as a primitive symbol of our theory rather than as a defined one, and by the need to deduce nonmembership relations between terms, to enable the use of dscons. After giving the axioms SetAx, we justify it as a suitable theory for finite sets in logic programming with the aid of the classical theory and unification, and formulate Herbrand structure within it. Together, these provide a rigorous foundation for the set constructors in the context of logical semantics. y This manuscript is available as Technical Report TR 94-030, Department of Computer Science, SUNY Buffalo, August 1994. 
Abstract-found: 1
Intro-found: 1
Reference: [AG91] <author> Abiteboul, S. and Grumbach, S.: </author> <title> A Rule-Based Language with Functions and Sets, </title> <journal> ACM Trans. on Database Systems, </journal> <volume> Vol. 16, No. 1, </volume> <month> Mar. </month> <year> 1991, </year> <pages> pp. 1-30. </pages>
Reference-contexts: In comparison with both these works, the main contribution of our work is that we provide a rigorous justification that our axioms are both plausible and sufficient to capture the notion of finite sets. Finally, we note that our work differs fundamentally in objectives from those of <ref> [AG91, BNST91, Kup90] </ref> in that we are interested in establishing logical foundations that will facilitate giving logical-consequence semantics, whereas the above works are primarily interested in model-theoretic semantics. 19 Acknowledgments This research was supported by grant CCR 9004357 from the National Science Foundation.
Reference: [BNST91] <author> Beeri, C., Naqvi, S., Shmueli, O., and Tsur, S.: </author> <title> Set Constructors in a Logic Database Language, </title> <booktitle> Jnl. Logic Programming, </booktitle> <address> 1991:10:181-232. </address>
Reference-contexts: 1 Introduction The use of sets has been advocated by several authors in the literature on logic programming ([DOPR91], [Jay92], [JP89], [Kup90]) and deductive databases ([AG91], <ref> [BNST91] </ref>, [NT89]). In studying the inclusion of sets in logic programs, it is natural to study finite sets at first. A representation often chosen for finite sets is that of scons, parallel to the list constructor cons. <p> In comparison with both these works, the main contribution of our work is that we provide a rigorous justification that our axioms are both plausible and sufficient to capture the notion of finite sets. Finally, we note that our work differs fundamentally in objectives from those of <ref> [AG91, BNST91, Kup90] </ref> in that we are interested in establishing logical foundations that will facilitate giving logical-consequence semantics, whereas the above works are primarily interested in model-theoretic semantics. 19 Acknowledgments This research was supported by grant CCR 9004357 from the National Science Foundation.
Reference: [DOPR91] <author> Dovier, A., Omodeo, E. G., Pontelli, E., and Rossi, G.: flogg: </author> <title> A Logic Programming Language with Finite Sets, </title> <booktitle> Proc. Eight Int. Conf. on Logic Programming, </booktitle> <address> Paris, </address> <month> Jun. </month> <year> 1991, </year> <pages> pp. 111-124. </pages>
Reference-contexts: The unification procedure for set constructors is far more involved than first-order unification since the set constructors have an equality theory. A very brief sketch of such a unification procedure was given in [JP89], and this was subsequently improved upon in <ref> [DOPR91] </ref>. Our set unification procedure is based upon that in [DOPR93], but our presentation follows the conventions and definitions laid out in [JK91], i.e.,, the unification procedure is presented using rewrite rules, and explicit existential quantification is used for the new variables introduced during unification.
Reference: [DOPR93] <author> Dovier, A., Omodeo, E. G., Pontelli, E., and Rossi, G.: flogg: </author> <title> A Language for Programming in Logic with Finite Sets, </title> <note> submitted to Jnl. of Logic Programming, </note> <year> 1993. </year>
Reference-contexts: A very brief sketch of such a unification procedure was given in [JP89], and this was subsequently improved upon in [DOPR91]. Our set unification procedure is based upon that in <ref> [DOPR93] </ref>, but our presentation follows the conventions and definitions laid out in [JK91], i.e.,, the unification procedure is presented using rewrite rules, and explicit existential quantification is used for the new variables introduced during unification. Such an approach is necessitated since we have an untyped system (unlike that in [DOPR93]); it <p> in <ref> [DOPR93] </ref>, but our presentation follows the conventions and definitions laid out in [JK91], i.e.,, the unification procedure is presented using rewrite rules, and explicit existential quantification is used for the new variables introduced during unification. Such an approach is necessitated since we have an untyped system (unlike that in [DOPR93]); it also facilitates a simpler statement of the theorems pertaining to the justification of freeness. Finally, we establish the standard or Herbrand structure, and justify that the `commutativity' and `idempotency' of scons is indeed adequate for deriving the structure, as sometimes assumed in the literature. <p> Unification is generalised to solving constraints, where a constraint, in SetAx, is roughly a conjunction of atoms involving the set predicates set, =, and 2. 11 The following presentation is based upon <ref> [DOPR93] </ref>, but, explained in section 1, we follow the conventions laid out in [JK91]. Our presentation of the unification procedure is based on the following proposition. <p> This leads to a tree of derivations. Starting from a constraint K and using the rewrite rules above repeatedly until none is applicable results in a finite tree of derivations, each leaf of which is either F or a solved form. We use the correctness and termination proof in <ref> [DOPR93] </ref> to assert this. The termination proof is obtained by first showing that rules S1-5 easily terminate from the reduction in size of terms. We invoke the proof in [DOPR93] for the termination of rules E1-16 which are solely in terms of set and =. <p> We use the correctness and termination proof in <ref> [DOPR93] </ref> to assert this. The termination proof is obtained by first showing that rules S1-5 easily terminate from the reduction in size of terms. We invoke the proof in [DOPR93] for the termination of rules E1-16 which are solely in terms of set and =. Finally, rules M1-5 easily terminate by strict reduction in size of terms and because we know set and = already terminate. <p> We find that SetAx has essentially been described in [MW85], however, only x3 and the deduction of extensionality from SetAx of our paper overlaps with that work. A somewhat different axiomatic treatment is given in <ref> [DOPR93] </ref>. For example, they do not have the induction axiom which plays a crucial role in our development.
Reference: [FBLD73] <author> Fraenkel, A. A., Bar-Hillel, Y., Levy, A. and van Dalen, D.: </author> <title> Foundations of Set Theory, </title> <publisher> North-Holland, </publisher> <year> 1973. </year>
Reference-contexts: Finally, in x8, we give concluding remarks and brief comments on closely related work. Our usage of standard definitions of logic programming follows that in [Llo87]. We also make use of a few results from [Sup72] and <ref> [FBLD73] </ref> in relating our set constructors to finite sets. 2 Set Constructors We consider the set constructors in a logical framework, i.e., a first-order language L with equality, having an alphabet possessing a set of variables V , a set of constructor symbols C , a set of predicate symbols P <p> We begin with ZF without the axiom of infinity (ZF ), together with set (x) ! f inite (x), which we take as an adequate mathematical theory of finite sets (see <ref> [FBLD73] </ref> Chapter 2, x3.6). To this we add a definition of scons, viz., set (y) ! fx=yg = fxg [ y. From the motivations underlying SetAx we see the need to make explicit assumptions about constructor symbols.
Reference: [Jan94] <author> Jana, D.: </author> <title> Semantics of Subset-Logic Languages, </title> <type> Ph.D. dissertation, </type> <institution> Department of Computer Science, SUNY-Buffalo, </institution> <month> August </month> <year> 1994. </year>
Reference-contexts: This system was used to provide a semantics for the logic programming language called SuRE (for Subsets, Relations and Equations) [Jay91], and can be used for other languages based upon these set constructors. The interested reader is referred to <ref> [Jan94] </ref> for a thorough treatment of the former. The rest of this paper is organized as follows. In the section x2 we give the set constructors in a first-order logical framework. We give a transform for dscons so that it can be understood in terms of scons.
Reference: [Jay91] <author> Jayaraman, B.: </author> <title> The SuRE Programming Framework, </title> <type> TR 91-11, </type> <institution> SUNY at Buffalo, </institution> <address> New York, </address> <month> Aug. </month> <year> 1991. </year>
Reference-contexts: Together, these results provide a rigorous foundation for the set constructors in the context of logical semantics. This system was used to provide a semantics for the logic programming language called SuRE (for Subsets, Relations and Equations) <ref> [Jay91] </ref>, and can be used for other languages based upon these set constructors. The interested reader is referred to [Jan94] for a thorough treatment of the former. The rest of this paper is organized as follows. In the section x2 we give the set constructors in a first-order logical framework.
Reference: [Jay92] <author> Jayaraman, B.: </author> <booktitle> Implementaton of Subset-Equational Programming, Jnl. of Logic Programming, </booktitle> <volume> Vol. 12, No. 4, </volume> <pages> pp. 299-324. </pages>
Reference-contexts: 1 Introduction The use of sets has been advocated by several authors in the literature on logic programming ([DOPR91], <ref> [Jay92] </ref>, [JP89], [Kup90]) and deductive databases ([AG91], [BNST91], [NT89]). In studying the inclusion of sets in logic programs, it is natural to study finite sets at first. A representation often chosen for finite sets is that of scons, parallel to the list constructor cons.
Reference: [JK91] <author> Jouannaud, J.-P. and Kirchner, C.: </author> <title> Solving Equations in Abstract Algebras: A Rule-Based Survey of Unification, </title> <booktitle> in: Computational Logic: Essays in Honor of Alan Robinson, </booktitle> <publisher> MIT Press, </publisher> <year> 1991, </year> <pages> pp. 257-321. </pages>
Reference-contexts: A very brief sketch of such a unification procedure was given in [JP89], and this was subsequently improved upon in [DOPR91]. Our set unification procedure is based upon that in [DOPR93], but our presentation follows the conventions and definitions laid out in <ref> [JK91] </ref>, i.e.,, the unification procedure is presented using rewrite rules, and explicit existential quantification is used for the new variables introduced during unification. <p> Unification is generalised to solving constraints, where a constraint, in SetAx, is roughly a conjunction of atoms involving the set predicates set, =, and 2. 11 The following presentation is based upon [DOPR93], but, explained in section 1, we follow the conventions laid out in <ref> [JK91] </ref>. Our presentation of the unification procedure is based on the following proposition.
Reference: [JP89] <author> Jayaraman, B. and Plaisted, D. A.: </author> <title> Programming with Equations, Subsets, and Relations, </title> <booktitle> Proc. North American Conf. Logic Programming, </booktitle> <address> Cleveland, </address> <month> Oct. </month> <year> 1989, </year> <pages> pp. 1051-1068. </pages>
Reference-contexts: 1 Introduction The use of sets has been advocated by several authors in the literature on logic programming ([DOPR91], [Jay92], <ref> [JP89] </ref>, [Kup90]) and deductive databases ([AG91], [BNST91], [NT89]). In studying the inclusion of sets in logic programs, it is natural to study finite sets at first. A representation often chosen for finite sets is that of scons, parallel to the list constructor cons. <p> Both constructors find natural uses in specifying sets in logic programs. The scons is used for specifying sets in terms of parts that may well overlap with each other. The dscons is used for specifying sets in terms of an element and remainder. The scons constructor in <ref> [JP89] </ref> has been used in both senses|on the left-hand sides of rules it was used to mean dscons, while on the right-hand sides of rules it was used to mean scons. <p> In order to justify the freeness axioms, we use unification since the two are closely related. The unification procedure for set constructors is far more involved than first-order unification since the set constructors have an equality theory. A very brief sketch of such a unification procedure was given in <ref> [JP89] </ref>, and this was subsequently improved upon in [DOPR91]. <p> Axiom F1 expresses that different constructor symbols lead to distinct terms. Axioms F2-3 express injectivity, while axioms F4-5 are like the occurs check axiom (and were described in <ref> [JP89] </ref>). The axiom F5 imitates axiom M4 to a certain extent. For example x =2 x can be deduced from either. Let SetAx = SetAxnF reeAx.
Reference: [Kup90] <author> Kuper, G. M.: </author> <title> Logic Programming with Sets, </title> <journal> Jnl. of Computer and System Sciences, </journal> <volume> Vol. 41, No. 1, </volume> <month> Aug. </month> <year> 1990, </year> <pages> pp. 44-64. </pages>
Reference-contexts: 1 Introduction The use of sets has been advocated by several authors in the literature on logic programming ([DOPR91], [Jay92], [JP89], <ref> [Kup90] </ref>) and deductive databases ([AG91], [BNST91], [NT89]). In studying the inclusion of sets in logic programs, it is natural to study finite sets at first. A representation often chosen for finite sets is that of scons, parallel to the list constructor cons. <p> In comparison with both these works, the main contribution of our work is that we provide a rigorous justification that our axioms are both plausible and sufficient to capture the notion of finite sets. Finally, we note that our work differs fundamentally in objectives from those of <ref> [AG91, BNST91, Kup90] </ref> in that we are interested in establishing logical foundations that will facilitate giving logical-consequence semantics, whereas the above works are primarily interested in model-theoretic semantics. 19 Acknowledgments This research was supported by grant CCR 9004357 from the National Science Foundation.
Reference: [Llo87] <author> Lloyd, J. W.: </author> <title> Foundations of Logic Programming, </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: In x7, we establish the Herbrand structure and show that Herbrand interpretations model SetAx. Finally, in x8, we give concluding remarks and brief comments on closely related work. Our usage of standard definitions of logic programming follows that in <ref> [Llo87] </ref>.
Reference: [MW85] <author> Manna, Z. and Waldinger, R.: </author> <title> The Logical Basis for Computer Programming: Vol. 1: Deductive Reasoning, </title> <publisher> Addison-Wesley, </publisher> <year> 1985. </year>
Reference-contexts: In studying the inclusion of sets in logic programs, it is natural to study finite sets at first. A representation often chosen for finite sets is that of scons, parallel to the list constructor cons. The use of this constructor for declarative programming can be traced back to <ref> [MW85] </ref>, and has been advocated by other authors in the literature as well. The logical theory for such constructors is usually tacitly assumed to be some formal system of classical set theory, such as Zermelo-Fraenkel (ZF ) set theory ([FBLD73], [Sup72]). <p> We find that SetAx has essentially been described in <ref> [MW85] </ref>, however, only x3 and the deduction of extensionality from SetAx of our paper overlaps with that work. A somewhat different axiomatic treatment is given in [DOPR93]. For example, they do not have the induction axiom which plays a crucial role in our development.
Reference: [NT89] <author> Naqvi, S. and Tsur, S.: </author> <title> A Logical Language for Data and Knowledge Bases, </title> <publisher> Computer Science Press, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: 1 Introduction The use of sets has been advocated by several authors in the literature on logic programming ([DOPR91], [Jay92], [JP89], [Kup90]) and deductive databases ([AG91], [BNST91], <ref> [NT89] </ref>). In studying the inclusion of sets in logic programs, it is natural to study finite sets at first. A representation often chosen for finite sets is that of scons, parallel to the list constructor cons.
Reference: [Sup72] <author> Suppes, P.: </author> <title> Axiomatic Set Theory, 1960, </title> <publisher> Dover edn., </publisher> <address> New York, </address> <year> 1972. </year> <month> 20 </month>
Reference-contexts: The logical theory for such constructors is usually tacitly assumed to be some formal system of classical set theory, such as Zermelo-Fraenkel (ZF ) set theory ([FBLD73], <ref> [Sup72] </ref>). However, classical set theory is formulated for a general setting, dealing with both finite and infinite sets, and not making any assumptions about particular set constructors. <p> In x7, we establish the Herbrand structure and show that Herbrand interpretations model SetAx. Finally, in x8, we give concluding remarks and brief comments on closely related work. Our usage of standard definitions of logic programming follows that in [Llo87]. We also make use of a few results from <ref> [Sup72] </ref> and [FBLD73] in relating our set constructors to finite sets. 2 Set Constructors We consider the set constructors in a logical framework, i.e., a first-order language L with equality, having an alphabet possessing a set of variables V , a set of constructor symbols C , a set of predicate <p> Their definitions are as in <ref> [Sup72] </ref> Ch. 2,3. Using these definitions a formal statement of the Axiom of Choice can be given, and it can be deduced using induction, as is well-known in set theory ([FBLD73] p. 62). <p> We have z 2 fx=yg $ z = x _ z 2 y $ z 2 fxg _ z 2 y $ z 2 fxg [ y, by M3 and from properties of ZF , viz., Theorems 43 & 21, Chapter 2 <ref> [Sup72] </ref>. (ii): By induction on n and from D9 & D10. (iii): Assume set (z) and use induction axiom with (z) finite (z) 8y (set (y); y 6= ;; y P (z) ! 9x minimal (x; y)) We have not gone into the issue of the independence of each of the <p> We note that axiom FS3 can be deduced from the remaining axioms (from F1 and Prop. 1 (i)). Finally, we have the reverse implication. Theorem 7 F inZF j= SetAx Proof: Straightforward, using the properties of ZF , such as in Chapters 2 and 4 of <ref> [Sup72] </ref>. We give a few cases. F inSetAx: (FS5): We have set (z) ^ f inite (z) ! induction (z; ~w), by Theorem 32, Chapter 4 [Sup72]. Hence set (z) ! induction (z; ~w) since set (z) ! finite (z) is in F inZF . <p> Theorem 7 F inZF j= SetAx Proof: Straightforward, using the properties of ZF , such as in Chapters 2 and 4 of <ref> [Sup72] </ref>. We give a few cases. F inSetAx: (FS5): We have set (z) ^ f inite (z) ! induction (z; ~w), by Theorem 32, Chapter 4 [Sup72]. Hence set (z) ! induction (z; ~w) since set (z) ! finite (z) is in F inZF . M emAx: (M3): Assume set (z). <p> M emAx: (M3): Assume set (z). Now x = y _ x 2 z $ x 2 fyg _ x 2 z $ x 2 fyg [ z $ x 2 fy=zg, by Theorems 43 & 20, Chapter 2 <ref> [Sup72] </ref>, and by definition of scons. CoIdAx: (CI1): Assume set (z). So set (fyg [ z) and set (fxg [ z), i.e., set (fy=zg) and set (fx=zg). From definition of scons, and from Theorems 22 & 21, Chapter 2 [Sup72], we get, fx=fy=zgg = fxg [ fy=zg = fxg [ fyg <p> $ x 2 fy=zg, by Theorems 43 & 20, Chapter 2 <ref> [Sup72] </ref>, and by definition of scons. CoIdAx: (CI1): Assume set (z). So set (fyg [ z) and set (fxg [ z), i.e., set (fy=zg) and set (fx=zg). From definition of scons, and from Theorems 22 & 21, Chapter 2 [Sup72], we get, fx=fy=zgg = fxg [ fy=zg = fxg [ fyg [ z = fyg [ fxg [ z = fyg [ fx=zg = fy=fx=zgg. (CI2): Assume set (z). So set (fxg [ z), i.e., set (fx=zg). From definition of scons, and from Theorems 22 & 23, Chapter 2 [Sup72], <p> <ref> [Sup72] </ref>, we get, fx=fy=zgg = fxg [ fy=zg = fxg [ fyg [ z = fyg [ fxg [ z = fyg [ fx=zg = fy=fx=zgg. (CI2): Assume set (z). So set (fxg [ z), i.e., set (fx=zg). From definition of scons, and from Theorems 22 & 23, Chapter 2 [Sup72], we get, fx=fx=zgg = fxg [ fx=zg = fxg [ fxg [ z = fxg [ z = fx=zg. It remains to justify the freeness axioms of SetAx as an adequate system to enforce inequalities among objects that are not provably equal in SetAx .
References-found: 15

