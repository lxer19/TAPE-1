URL: http://www.cs.colorado.edu/~zorn/cs5535/Fall-1995/projects/wharton.ps
Refering-URL: http://www.cs.colorado.edu/~zorn/cs5535/Fall-1995/index.html
Root-URL: http://www.cs.colorado.edu
Title: Should C Replace FORTRAN as the Language of Scientific Programming?  
Author: Linda Wharton 
Date: CSCI 5535 Fall 1995  
Abstract: Anti-FORTRAN sentiment has recently become more prevalent. Where does the attitude originate? The most probable source is academia, where C and C++ are the languages of choice. Is there a fact based justification for the attitude? FORTRAN and C are evaluated to determine whether C is a better language than FORTRAN for scientific programming. The features of FORTRAN 77, FORTRAN 90, C and C++ are compared, and evaluated as to how well they meet the requirements of the scientific programming domain. FORTRAN was designed specifically for numerical programming, and thus better meets the requirements. Three algorithms in the scientific domain are coded in both FORTRAN and C. They are evaluated on performance, readability of the code and optimization potential. In all cases the FORTRAN implementations proved superior. Is there evidence to mandate that all upgrades and new development should be done in C, rather than FORTRAN? A good computer programmer can solve any given problem in any language, however it is best to code in the language specifically designed for the problem domain. In the case of scientific programming, that language is FORTRAN.
Abstract-found: 1
Intro-found: 1
Reference: [Baker92] <author> Baker, L., </author> <title> C Mathematical Function Handbook, </title> <publisher> McGraw-Hill, </publisher> <address> New York, NY, </address> <year> 1992. </year>
Reference-contexts: No intrinsic complex data type. As mentioned before, this can be programmed around, but will reduce the efficiency and readability of the resulting program. There are many pitfalls in C due to the syntax of the language <ref> [Baker92] </ref>. Suppose the goal was to divide by a de-referenced pointer: double *x; z=y/*x; The problem is that the division symbol and pointer de-reference symbol together create the syntax for the start of a comment.
Reference: [CSEP95] <institution> Computational Science Education Project, Fortran 90 and Computational Science, </institution> <note> http://csep1.phy.ornl.gov/csep.html,1995. </note>
Reference-contexts: Scientific programming is defined as programming that performs numerical computations on large amounts of data. The features and capabilities of FORTRAN and C programming languages are compared. C and FORTRAN have been evaluated by many authors, both in a historical sense [Wagener80] [Kernighan88], and in a functional sense [Press92] <ref> [CSEP95] </ref>. Several authors have identified possible areas where changes could be made to C to make it work more like FORTRAN in numerical applications [Leary94]. 2 The emphasis of the evaluation is on how well each language can implement and solve scientific problems. <p> FORTRAN 90 has incorporated all of the features, which now levels the playing field between FORTRAN and C. C and C++ are in close contention, since they only lack one feature; that of numerical polymorphism. Numeric polymorphism is where a function is generic over all argument types <ref> [CSEP95] </ref>. For example, the result returned by a call to COS (x) in FORTRAN 90 is the appropriate value of kind SINGLE, DOUBLE, IEEE or P6, depending on the kind of variable x. In FORTRAN 90, all computational intrinsic functions are generic over all type kinds provided. <p> Step two uses subroutines/functions pivot and tridiag to manipulate the matrix. Step three uses subroutine/function back. Step four uses a print routine that displays matrices. 13 FORTRAN Implementation of Gaussian Elimination with Back Substitution <ref> [CSEP95] </ref>: program/subroutine descriptions (full code in Appendix A, Part 1.) Program testg: determine the correct processing of the subroutines: pivot.f, triang.f, and back.f. The subroutines determine the solution to a series of simultaneous equations. <p> The array subscripts are manipulated in the same manner as they would be if the problem was being manually solved on paper. C Implementation of Gaussian Elimination with Back Substitution - no parameters passed <ref> [CSEP95] </ref>: function descriptions (full code in Appendix A, Part 2.) Declaration and initialization of variable matrix: #include &lt;stdio.h&gt; #define IMAX 5 #define JMAX 6 float matrix [IMAX][JMAX] = - - 4.0, 2.0,-2.5, 4.0, 1.0,-0.1 -, - 1.5, 2.5, 3.0,-1.0, 5.0, 3.0 -, - 5.0, 3.0, 3.0, 2.0,10.0, 4.0 - float solvec <p> END INTERFACE Programmers would access the routines via the generic name smooth, using either INTEGER or SINGLE type data. The interface transparently sends calls with INTEGER data to subroutine smooth_int, and sends calls with SINGLE data to the subroutine smooth_single. 17 FORTRAN Implementation of 3x3 Smoothing <ref> [CSEP95] </ref>: program/subroutine descriptions ( full code in Appendix A, Part 4.) Program testsm : program to test the subroutine smooth.f, which performs a 3 x 3 averaging operation on an arbitrary sized matrix. Subroutine smooth:computes a 3x3 average from an input matrix. <p> Optimization Potential There should be no problem optimizing the code in either of the languages, since there are no pointers or arrays involved in the calculations. 6 Related Work The Computational Science Education Project evaluated FORTRAN 77, FORTRAN 90, C and C++ and ranked them according to numerical robustness <ref> [CSEP95] </ref>. FORTRAN 90 was ranked first, based on having numeric polymorphism, real "kind" type parameterization and decimal precision selection. FORTRAN 77 ranked second due to its intrinsic support of complex variables, and C++ nudged out C for third place due to its capabilities in the general area of polymorphism.
Reference: [Chapra88] <author> Chapra, S. C., Canale, R. P., </author> <title> Numerical Methods for Engineers, Second Edition, </title> <publisher> McGraw-Hill, </publisher> <address> New York, NY, </address> <year> 1988. </year>
Reference-contexts: Although highly subjective, this topic is worth examining. Several authors <ref> [Chapra88] </ref> [Joyner92] [Morgan92] [Moylam92] have commented on this subject. Their thoughts are presented, along with my own. Once the possible origins of anti-FORTRAN sentiment have been identified, I proceed to investigate whether there is evidence to support that C is a better language than FORTRAN for scientific programming. <p> good computer language should implement the concepts behind the language cleanly and simply, and express the concepts in as few words and constructs as possible [Joyner92]. "Unfortunately, many programmers have an almost emotional attachment to their language and some go as far as to contend that all others are inferior" <ref> [Chapra88] </ref>. The question here is whether the concepts behind C are better suited to scientific programming than FORTRAN. FORTRAN 77 is the lingua franca of numerical analysis [Sullivan95], yet a movement seems afoot to declare FORTRAN obsolete and replace it with C. <p> Do FORTRAN and C equally support the programming techniques required for scientific programming? 3.1 Language Requirements for Scientific Programming Scientific programming and numerical methods have many requirements for execution on computers <ref> [Chapra88] </ref> [Vandergraft83]: The ability to efficiently and accurately perform computations on large systems of equations, requiring multi-dimensional arrays for storage - for example, there are weather modeling programs executing hourly that perform calculations on several gigabytes worth of data.
Reference: [Dubois93] <author> Dubois, P. F., Busby, L., </author> <title> Portable, Powerful FORTRAN Programs, </title> <journal> Computers in Physics, </journal> <volume> 7, </volume> <month> 1 (January </month> <year> 1993) </year> <month> 38-43. </month>
Reference-contexts: All of the above options, however, only determine the size of storage available for data. It does not control the precision of data calculations. FORTRAN 90 has a "kind" selector that allows the programmer to explicitly specify the desired precision for each variable and intrinsic functions <ref> [Dubois93] </ref>. This come in very handy in these days of increasing data word size. Where REAL may indicate 16 bits on one machine, it may indicate 32 bits on another machine. The kind selector returns control of data precision to the programmer.
Reference: [Ellis93] <author> Ellis, T. M. R., </author> <title> Fortran 77 Programming with an Introduction to the Fortran 90 Standard, Second Edition, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1993. </year>
Reference-contexts: One of the great features of dynamic memory allocation in FORTRAN 90 is that the compiler automatically takes care of allocating the correct amount of memory. This is unlike C, which requires the programmer to get it right <ref> [Ellis93] </ref>. The optional free source format of programming used by FORTRAN 90 is going to be a big success with users.
Reference: [Furzer92] <author> Furzer, I., </author> <title> Fortran 90: The View from Academia, </title> <journal> Chemical Engineer, </journal> <volume> 527, </volume> <month> (September </month> <year> 1992) </year> <month> 26. </month>
Reference-contexts: With the advent of FORTRAN 90, programmers now have the option to retain their old habits, if they prefer, or feel free to program in whatever column they like <ref> [Furzer92] </ref>. This section has determined that FORTRAN 90 and C have nearly the same features.
Reference: [Haney94] <author> Haney, S. W., </author> <title> Is C++ Fast Enough for Scientific Computing?, </title> <journal> Computers in Physics, </journal> <volume> 8, 6, </volume> <month> (November </month> <year> 1994) </year> <month> 690. </month>
Reference-contexts: Three numeric tasks are coded and implemented in both FORTRAN and C. Each implementation is evaluated on the criteria of speed of execution, how readable the code is, and how well the program lends itself to optimization. Related work on performance evaluation is presented [Sullivan95] <ref> [Haney94] </ref>. <p> Results showed that C was closer to the speed of FORTRAN 77 than C++, and the C++ results ranged from 150 - 700% slower than FORTRAN 77. Only if you execute C code on a Cray C90 can you hope to match FORTRAN 77 <ref> [Haney94] </ref>. Ben Zorn and Stephen Sullivan evaluated "Numerical Analysis Using Non-Procedural Paradigms" [Sullivan95]. They benchmarked Gaussian elimination on 1000 x 1000 sparse matrices in, among other languages, C++, FORTRAN 77 and FORTRAN 90.
Reference: [Jaeschke91] <author> Jaeschke, R., </author> <title> Standard C: A Status Report, </title> <journal> Dr. Dobbs Journal of Software Tools for the Professional Programmer, </journal> <volume> 16, </volume> <month> 8 (August </month> <year> 1991), </year> <month> 16. </month>
Reference-contexts: Using pointers in C drastically reduces the possibility of code optimization. This is due to aliasing, or the compiler not knowing how many pointers reference a location in memory <ref> [Jaeschke91] </ref>. No intrinsic complex data type. As mentioned before, this can be programmed around, but will reduce the efficiency and readability of the resulting program. There are many pitfalls in C due to the syntax of the language [Baker92].
Reference: [Jervis92] <author> Jervis, Robert, </author> <title> Numerical Extensions to C, </title> <journal> Dr. Dobbs Journal of Software Tools for the Professional Programmer, </journal> <volume> 17, </volume> <month> 8 (August </month> <year> 1992), </year> <month> 26. </month>
Reference-contexts: A similar error will occur when assigning the value from a de-referenced pointer: x=*a would multiply x by the address of pointer a, rather than assigning the de-referenced value of a to x. C does not adhere to the IEEE standards for data storage <ref> [Jervis92] </ref>, thus it is not possible to reliably identify NaNs, or Not-a-Number values. NaNs occur on instances such as a division by zero. Whatever bit pattern is stored in a numerical variable is in a format which the computer cannot interpret as a number.
Reference: [Joyner92] <author> Joyner, I., </author> <title> C++?? A Critique of C++, Second Edition, Unisys, </title> <publisher> North Ryde, </publisher> <address> Australia, </address> <year> 1992. </year>
Reference-contexts: Although highly subjective, this topic is worth examining. Several authors [Chapra88] <ref> [Joyner92] </ref> [Morgan92] [Moylam92] have commented on this subject. Their thoughts are presented, along with my own. Once the possible origins of anti-FORTRAN sentiment have been identified, I proceed to investigate whether there is evidence to support that C is a better language than FORTRAN for scientific programming. <p> It is easier, however, and the code runs more efficiently, when a language that was specifically designed for the problem domain is used. Any good computer language should implement the concepts behind the language cleanly and simply, and express the concepts in as few words and constructs as possible <ref> [Joyner92] </ref>. "Unfortunately, many programmers have an almost emotional attachment to their language and some go as far as to contend that all others are inferior" [Chapra88]. The question here is whether the concepts behind C are better suited to scientific programming than FORTRAN. <p> Several authors have voiced their opinion on whether or not C should be used for scientific programming: "Better languages [than C] exist for higher level functions such as scientific work" <ref> [Joyner92] </ref>. "Our message to C users is: look at FORTRAN again. Its still the best there is for engineering and science" [Morgan92]. "Scientific programming in C may someday become a bed of roses; for now, watch out for the thorns!"[Press92].
Reference: [Kernighan88] <author> Kernighan, B. W., Ritchie, D. M., </author> <title> The C Programming Language, Second Edition, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NY, </address> <year> 1988. </year>
Reference-contexts: Scientific programming is defined as programming that performs numerical computations on large amounts of data. The features and capabilities of FORTRAN and C programming languages are compared. C and FORTRAN have been evaluated by many authors, both in a historical sense [Wagener80] <ref> [Kernighan88] </ref>, and in a functional sense [Press92] [CSEP95]. Several authors have identified possible areas where changes could be made to C to make it work more like FORTRAN in numerical applications [Leary94]. 2 The emphasis of the evaluation is on how well each language can implement and solve scientific problems. <p> The language evolved from a compact language, BCPL, which had already been used to implement the OS6 operating system at Oxford <ref> [Kernighan88] </ref>. BCPL, and thus C, are part of the family of traditional procedural languages, but include routines that are "close to the machine", and aimed directly at systems programming [Ritchie93]. C uses library routines for input-output and interactions with the operating system, allowing the language to be portable.
Reference: [King93] <author> King, K. N., </author> <title> The History of Programming Languages, </title> <journal> Dr. Dobbs Journal of SoftwareTools for the Professional Programmer, </journal> <volume> 18, </volume> <month> 8 (August </month> <year> 1993), </year> <month> 18. </month>
Reference-contexts: His main goal was to make writing good programs easier and more pleasant for the individual programmer. Stroustrup said he chose C as the basis for C++ because it was the "best systems programming language available" <ref> [King93] </ref>. Thus, both C and C++ were designed as systems programming languages.
Reference: [Leary94] <author> Leary, K., </author> <title> Numerical C and DSP, </title> <journal> Dr. Dobbs Journal of Software Tools for the Professional Programmer, </journal> <volume> 19, </volume> <month> 8 (August </month> <year> 1994), </year> <month> 18. </month>
Reference-contexts: C and FORTRAN have been evaluated by many authors, both in a historical sense [Wagener80] [Kernighan88], and in a functional sense [Press92] [CSEP95]. Several authors have identified possible areas where changes could be made to C to make it work more like FORTRAN in numerical applications <ref> [Leary94] </ref>. 2 The emphasis of the evaluation is on how well each language can implement and solve scientific problems. There are currently two standards for each language. The features of these standard languages, FORTRAN 77, FORTRAN 90, C and C++, are compared. <p> The numerical programming community has recognized there are areas where C is weak in numerical processing and have addressed the problem by creating a new language, Numerical C. Numerical C is a superset of ANSI-standard C and contains additional language constructs geared toward mathematical-programming paradigms <ref> [Leary94] </ref>. The constructs enable the compiler to generate more efficient code by giving the compiler more information about the algorithm and by enforcing a canonical form on the input program. Con There are several major problems with using C, or C++, for numerical programming.
Reference: [[Metcalf90] <author> Metcalf, M., Reid, J., </author> <title> Fortran 90 Explained, </title> <publisher> Oxford University Press, </publisher> <address> New York, NY,1990. </address> <month> 25 </month>
Reference: [Metcalf91] <author> Metcalf, M., Reid, J., </author> <title> Whither Fortran?, </title> <journal> Fortran Forum, </journal> <volume> 10, 2, </volume> <month> (July 91) 18. </month>
Reference-contexts: Backus goal was to produce a language that was simple to understand, but almost as efficient in execution as assembly language. He was successful, in allowing scientists and engineers to write efficient, accurate numerical programs without requiring them to be computer experts <ref> [Metcalf91] </ref>. The language evolved into many dialects before first being standardized in 1966. Unfortunately, not many developers adhered to that standard. In 1978, another standard was published, that encompassed the best features of the many dialects. That standard was FORTRAN 77.
Reference: [Morgan92] <author> Morgan, N., </author> <title> Fortran 90: the end of schizophrenic engineers?, </title> <journal> Chemical Engineer, </journal> <volume> 527, </volume> <month> (September </month> <year> 1992) </year> <month> 25. </month>
Reference-contexts: Although highly subjective, this topic is worth examining. Several authors [Chapra88] [Joyner92] <ref> [Morgan92] </ref> [Moylam92] have commented on this subject. Their thoughts are presented, along with my own. Once the possible origins of anti-FORTRAN sentiment have been identified, I proceed to investigate whether there is evidence to support that C is a better language than FORTRAN for scientific programming. <p> In one Meteorology Research Laboratory, that sentiment is so strong that the Computer Facilities Division will not run code written in FORTRAN on their operational machines. Where and when did FORTRAN obtain the stigma of being an "old language" <ref> [Morgan92] </ref>? I have noticed that prejudice against FORTRAN mainly surfaces during interaction with two groups of people. The first group is made up of programmers who are pursuing or have recently obtained Computer Science degrees. <p> Its still the best there is for engineering and science" <ref> [Morgan92] </ref>. "Scientific programming in C may someday become a bed of roses; for now, watch out for the thorns!"[Press92].
Reference: [Moylam92] <author> Moylam, P. J., </author> <title> A Case Against C, </title> <type> Technical Report EE9240, </type> <institution> Department of Electronic and Computer Engineering, University of Newcastle, Australia, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: Although highly subjective, this topic is worth examining. Several authors [Chapra88] [Joyner92] [Morgan92] <ref> [Moylam92] </ref> have commented on this subject. Their thoughts are presented, along with my own. Once the possible origins of anti-FORTRAN sentiment have been identified, I proceed to investigate whether there is evidence to support that C is a better language than FORTRAN for scientific programming. <p> Once a language has built up a large user base, it develops an unstoppable momentum, generally becoming the current language of choice. "And, of course, each generation of programming educators teaches students its favorite language" <ref> [Moylam92] </ref>. Thus, even when FORTRAN is offered, it is not likely to be taken unless a student is specifically pursuing scientific computation or parallel processing. Table 1. <p> Definitively identifying the origins of anti-FORTRAN sentiment would at best be speculation, and impossible to prove. P. J. Moylam notes that "loyalty to a language is very largely an emotional issue which is not subject to rational debate" <ref> [Moylam92] </ref>. <p> This was due to the fact that systems programmers rarely need arrays of more than one dimension, so they 10 were not designed into the language [Ross93]. The lack of type checking in C makes it harder to program without errors <ref> [Moylam92] </ref>. It also puts more responsibility on the programmer to have an intimate knowledge of data types and how they are stored and manipulated on the computer. Using pointers in C drastically reduces the possibility of code optimization.
Reference: [Press89] <author> Press, W. H., Flannery, B. P., Teukolsky, S. A., Vetterling, W. </author> <title> T, Numerical Recipes: The Art of Scientific Computing (FORTRAN Version), </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, U.K. </address> <year> 1989. </year>
Reference-contexts: C also has the capability of data type conversion, via casting, whereas FORTRAN 90 only allows specific conversions <ref> [Press89] </ref>. This may, or may not, be an advantage. The numerical programming community has recognized there are areas where C is weak in numerical processing and have addressed the problem by creating a new language, Numerical C.
Reference: [Press92] <author> Press, W. H., Flannery, B. P., Teukolsky, S. A., Vetterling, W. </author> <title> T, Numerical Recipes in C, Second Edition, </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, U.K. </address> <year> 1992. </year>
Reference-contexts: Scientific programming is defined as programming that performs numerical computations on large amounts of data. The features and capabilities of FORTRAN and C programming languages are compared. C and FORTRAN have been evaluated by many authors, both in a historical sense [Wagener80] [Kernighan88], and in a functional sense <ref> [Press92] </ref> [CSEP95]. Several authors have identified possible areas where changes could be made to C to make it work more like FORTRAN in numerical applications [Leary94]. 2 The emphasis of the evaluation is on how well each language can implement and solve scientific problems. <p> Kernighan & Ritchie C actually has a major problem with precision in the case of float type data. More details are forthcoming in section 3.6, but the gist of the problem is that all float variables are converted to type double before any calculations are performed <ref> [Press92] </ref>, and the programmer has no control over the conversion. All of the above options, however, only determine the size of storage available for data. It does not control the precision of data calculations. <p> Expressions like (A + B)**4 compile in FORTRAN to be solved with only one add and two multiplies. For some reason, both C and C++ omitted the exponentiation operator, "perhaps the most galling insult to the scientific programmer" <ref> [Press92] </ref>. What Mr. Press forgets is that C 8 was not written for scientific programming. It was written for systems programming! Apparently computer operating systems have no need to square data. <p> This decision means that all of the real-number standard C library functions are of type double, and compute to double precision. The justification for these rules was "theres nothing wrong with a little extra precision" <ref> [Press92] </ref>. The worst problem with this is that all conversion between float and double is done automatically, with no hope of shutting it off. This takes the choice of data precision away from the programmer. Fortunately, ANSI C dropped the practice for arithmetic operations.
Reference: [Ritchie93] <author> Ritchie, D. M., </author> <title> The Development of the C Language, </title> <booktitle> Second ACM History of Programming Languages Conference (April 1993). </booktitle>
Reference-contexts: BCPL, and thus C, are part of the family of traditional procedural languages, but include routines that are "close to the machine", and aimed directly at systems programming <ref> [Ritchie93] </ref>. C uses library routines for input-output and interactions with the operating system, allowing the language to be portable. The impetus behind C was to create a compact, portable language that would be used to develop an operating system for the minimal memory computers of the 1970s. <p> Dennis Ritchie believes 6 that goal was met. "C is quirky, flawed, and an enormous success...[and] satisfied a need for a system implementation language efficient enough to displace assembly language" <ref> [Ritchie93] </ref>. C++ was first introduced in the early 1980s. It is an object-oriented language that retains C as a subset. Bjarne Stroustrup designed C++ primarily so that the author would not have to program in assembler, C or other various modern high-level languages [Stroustrup94]. <p> In my opinion, the biggest problem with using C for scientific programming is the way arrays were implemented. There is no efficient way to handle multi-dimensional arrays. Even the author, Dennis Ritchie, admits that Cs treatment of arrays is suspect <ref> [Ritchie93] </ref>. This was due to the fact that systems programmers rarely need arrays of more than one dimension, so they 10 were not designed into the language [Ross93]. The lack of type checking in C makes it harder to program without errors [Moylam92].
Reference: [Ross93] <author> Ross, John W., </author> <title> Calling C Functions with Variably Dimensioned Arrays, </title> <journal> Dr. Dobbs Journal of SoftwareTools for the Professional Programmer, </journal> <volume> 18, </volume> <month> 8 (August </month> <year> 1993), </year> <month> 52. </month>
Reference-contexts: There is no efficient way to handle multi-dimensional arrays. Even the author, Dennis Ritchie, admits that Cs treatment of arrays is suspect [Ritchie93]. This was due to the fact that systems programmers rarely need arrays of more than one dimension, so they 10 were not designed into the language <ref> [Ross93] </ref>. The lack of type checking in C makes it harder to program without errors [Moylam92]. It also puts more responsibility on the programmer to have an intimate knowledge of data types and how they are stored and manipulated on the computer.
Reference: [Stroustrup88] <author> Stroustrup, B., </author> <title> What is Object-Oriented Programming?, </title> <journal> IEEE Software, </journal> <volume> 5, 3, </volume> <month> (May </month> <year> 1988), </year> <month> 10. </month>
Reference-contexts: and concentrates on the search for empirical information as to which language, C or FORTRAN, better supports applications in the field of scientific programming. 3 Language Comparison According to Bjarne Stroustrup, "a language does not support a [programming] technique if it takes exceptional effort of skill to write such programs" <ref> [Stroustrup88] </ref>.
Reference: [Stroustrup94] <author> Stroustrup, B., </author> <title> The C++ Programming Language, Second Edition, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1994. </year>
Reference-contexts: C++ was first introduced in the early 1980s. It is an object-oriented language that retains C as a subset. Bjarne Stroustrup designed C++ primarily so that the author would not have to program in assembler, C or other various modern high-level languages <ref> [Stroustrup94] </ref>. His main goal was to make writing good programs easier and more pleasant for the individual programmer. Stroustrup said he chose C as the basis for C++ because it was the "best systems programming language available" [King93]. Thus, both C and C++ were designed as systems programming languages.
Reference: [Sullivan95] <author> Sullivan, Stephen J. and Zorn, Benjamin G., </author> <title> Numerical Analysis Using Non-Procedural Paradigms, </title> <journal> ACM Transactions on Mathematical Software, </journal> <volume> 21, </volume> <month> 3 (September </month> <year> 1995), </year> <month> 267. </month>
Reference-contexts: Three numeric tasks are coded and implemented in both FORTRAN and C. Each implementation is evaluated on the criteria of speed of execution, how readable the code is, and how well the program lends itself to optimization. Related work on performance evaluation is presented <ref> [Sullivan95] </ref> [Haney94]. <p> The question here is whether the concepts behind C are better suited to scientific programming than FORTRAN. FORTRAN 77 is the lingua franca of numerical analysis <ref> [Sullivan95] </ref>, yet a movement seems afoot to declare FORTRAN obsolete and replace it with C. In one Meteorology Research Laboratory, that sentiment is so strong that the Computer Facilities Division will not run code written in FORTRAN on their operational machines. <p> Only if you execute C code on a Cray C90 can you hope to match FORTRAN 77 [Haney94]. Ben Zorn and Stephen Sullivan evaluated "Numerical Analysis Using Non-Procedural Paradigms" <ref> [Sullivan95] </ref>. They benchmarked Gaussian elimination on 1000 x 1000 sparse matrices in, among other languages, C++, FORTRAN 77 and FORTRAN 90.
Reference: [Vandergraft83] <author> Vandergraft, J. S., </author> <title> Introduction to Numerical Computations, Second Edition, </title> <publisher> Academic Press, Inc., </publisher> <address> New York, NY, </address> <year> 1983. </year>
Reference-contexts: Do FORTRAN and C equally support the programming techniques required for scientific programming? 3.1 Language Requirements for Scientific Programming Scientific programming and numerical methods have many requirements for execution on computers [Chapra88] <ref> [Vandergraft83] </ref>: The ability to efficiently and accurately perform computations on large systems of equations, requiring multi-dimensional arrays for storage - for example, there are weather modeling programs executing hourly that perform calculations on several gigabytes worth of data.
Reference: [Wagener80] <author> Wagener, J. L., </author> <title> Fortran 77 Principles of Programming, </title> <publisher> Wiley & Sons, </publisher> <address> New York, NY, </address> <year> 1980. </year>
Reference-contexts: Scientific programming is defined as programming that performs numerical computations on large amounts of data. The features and capabilities of FORTRAN and C programming languages are compared. C and FORTRAN have been evaluated by many authors, both in a historical sense <ref> [Wagener80] </ref> [Kernighan88], and in a functional sense [Press92] [CSEP95]. <p> Then, in the 1950s, John Backus of IBM wrote a language that would convert high-level statements containing formulas into machine instructions. This language performed formula translation, and was thus named FORTRAN <ref> [Wagener80] </ref>. Backus goal was to produce a language that was simple to understand, but almost as efficient in execution as assembly language. He was successful, in allowing scientists and engineers to write efficient, accurate numerical programs without requiring them to be computer experts [Metcalf91]. <p> The method starts with an initial guess to the root, then uses Newtons formula to generate the next, and hopefully better, approximation to the root. The program verifies that the method converges, terminating execution if it starts to diverge. FORTRAN Implementation of Newtons Method <ref> [Wagener80] </ref>: program description ( full code in Appendix A, Part 6.) Program newton : extract a root of a fourth degree polynomial by using Newtons method. program newton integer n, loop real a,b,c,d,e complex x, root, f, df data n, x /1, (1.0,1.0)/ a = 1.0 c = 1.0 e =
References-found: 26

