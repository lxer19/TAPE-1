URL: http://www.isg.sfu.ca/~hak/documents/wambook.ps
Refering-URL: http://www.isg.sfu.ca/~hak/documents/wam.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Note: Warren's Abstract Machine  
Abstract-found: 0
Intro-found: 1
Reference: [AHU74] <author> Alfred Aho, John Hopcroft, and Jeffrey Ullmann. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1974. </year>
Reference-contexts: However, the occurs-check test is omitted in most actual Prolog implementations in order not to impede performance. We must also explicate the unify operation used in the matching phase (in read mode). It is a unification algorithm based on the UNION/FIND method <ref> [AHU74] </ref>, where variable substitutions are built, applied, and composed through dereference pointers. In M 0 (and in all later machines that will be considered here), this unification operation is performed on a pair of store addresses.
Reference: [AK90] <author> Hassan At-Kaci. </author> <title> The WAM: a (real) tutorial. </title> <type> PRL Research Report Number 5, </type> <institution> Digital Equipment Corporation, Paris Research Laboratory, Rueil-Malmaison, France, </institution> <year> 1990. </year>
Reference-contexts: In the light of WAM Principles 1, 2, and 3, we may now improve on M 3 . 5.1 Heap representation As many readers of <ref> [AK90] </ref> did, this reader may have wondered about the necessity of the extra level of indirection systematically introduced in the heap by an STR cell for each functor symbol. <p> The main reason for our not having used this better heap representation in Section 2.1 was essentially didactic, wishing to avoid having to mention references from outside the heap (e.g., from registers) before due time. In addition, we did not bother bringing up this optimization in <ref> [AK90] </ref> as we are doing here, as we had not realized that so little was in fact needed to incorporate it. 1 1 After dire reflection seeded by discussions with Fernando Pereira, we eventually realized that this optimization was indeed cheap|a fact that had escaped our attention. <p> Both pointed out to this author the incorrect replacement rule described (as that of the last occurrence of an unsafe variable) in <ref> [AK90] </ref>. In fact, the incorrect rule in [AK90] had been simply inherited verbatim from Warren's original report [War83] (Page 14, Line 3), and later explained by him as follows [War90]: "I agree that this is ambiguous or misleading. <p> Both pointed out to this author the incorrect replacement rule described (as that of the last occurrence of an unsafe variable) in <ref> [AK90] </ref>. In fact, the incorrect rule in [AK90] had been simply inherited verbatim from Warren's original report [War83] (Page 14, Line 3), and later explained by him as follows [War90]: "I agree that this is ambiguous or misleading. <p> call=1 if executed. 12 Let us first consider the simpler case where the clause containing the cut, be it shallow or deep, is the first (not necessarily in sequence thanks to 12 This fact was brought to our attention by Dean Rosenzweig [Ros91] who noticed that the scheme given in <ref> [AK90] </ref> was erroneous. We gratefully acknowledge his suggesting the corrected scheme we describe next. 74 Chapter 5 indexing) among those of the called procedure's to be executed upon entering the procedure with call or execute.
Reference: [Boi88] <author> Patrice Boizumault. </author> <title> Prolog: </title> <institution> l'implantation. Etudes et recherches en informatique. Masson, Paris, France, </institution> <year> 1988. </year>
Reference: [BP84] <author> Maurice Bruynooghe and Luis M. Pereira. </author> <title> Deduction revision by intelligent backtracking. </title> <editor> In John A. Campbell, editor, </editor> <booktitle> Implementations of Prolog, </booktitle> <pages> pages 194-215. </pages> <publisher> Ellis Horwood, Ltd., </publisher> <address> Chichester, UK, </address> <year> 1984. </year>
Reference-contexts: Also, since compilation as done by the WAM treats each procedure independently of the rest of the program, global analysis techniques can therefore be considered as in [Mel85, DW86a, DW86b, Deb89, DW89, vR90, vRD90]. Finally, one will find copious material about improving backtracking in Prolog in <ref> [PP82, BP84, Cox84, CCF88, ZTU90, Zho90] </ref>. At any rate, we hope to have contributed to give the reader a rapid and clear understanding with thorough, if not formal, justification of all the details of the essential abstract machine.
Reference: [CCF88] <author> Christian Codognet, Philippe Codognet, </author> <title> and Gilberto File. Yet another intelligent backtracking method. </title> <editor> In Robert Kowalski and Kenneth Bowen, editors, </editor> <booktitle> Logic Programming: Proceedings of the Fifth International Conference and Symposium, </booktitle> <pages> pages 447-465, </pages> <address> Cambridge, MA, 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Also, since compilation as done by the WAM treats each procedure independently of the rest of the program, global analysis techniques can therefore be considered as in [Mel85, DW86a, DW86b, Deb89, DW89, vR90, vRD90]. Finally, one will find copious material about improving backtracking in Prolog in <ref> [PP82, BP84, Cox84, CCF88, ZTU90, Zho90] </ref>. At any rate, we hope to have contributed to give the reader a rapid and clear understanding with thorough, if not formal, justification of all the details of the essential abstract machine.
Reference: [Chu90] <author> Damian Chu. </author> <title> Private communicatiion. Electronic Mail, </title> <month> August </month> <year> 1990. </year>
Reference-contexts: Let us argue with a specific example. 8 Consider the rule `a :- b (X; X); c:'. According to our definition, X is treated as a temporary variable. This results 8 The lame behavior of this example was pointed out to the author by Damian Chu <ref> [Chu90] </ref> and Michael Hanus [Han90]. 62 Chapter 5 a=0 : allocate % a :- put variable A1; A2 % b (X; X call b=2; 0 % ); deallocate % c execute c=0 % : Code for a :- b (X; X); c:, by our classification a=0 : allocate % a :-
Reference: [CM84] <author> William F. Clocksin and Christopher S. Mellish. </author> <title> Programming in Prolog. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany, 2nd edition, </address> <year> 1984. </year>
Reference-contexts: Nevertheless, to make this work also profitable to readers lacking this background, we have provided a quick summary of the necessary Prolog notions in Appendix A. As for notation, we implicitly use the syntax of so-called Edinburgh Prolog (see, for instance, <ref> [CM84] </ref>), which we also recall in that appendix.
Reference: [Cox84] <author> Peter T. Cox. </author> <title> Finding backtrack points for intelligent backtracking. </title> <editor> In John A. Campbell, editor, </editor> <booktitle> Implementations of Prolog, </booktitle> <pages> pages 216-133. </pages> <publisher> Ellis Horwood, Ltd., </publisher> <address> Chichester, UK, </address> <year> 1984. </year>
Reference-contexts: Also, since compilation as done by the WAM treats each procedure independently of the rest of the program, global analysis techniques can therefore be considered as in [Mel85, DW86a, DW86b, Deb89, DW89, vR90, vRD90]. Finally, one will find copious material about improving backtracking in Prolog in <ref> [PP82, BP84, Cox84, CCF88, ZTU90, Zho90] </ref>. At any rate, we hope to have contributed to give the reader a rapid and clear understanding with thorough, if not formal, justification of all the details of the essential abstract machine.
Reference: [Deb86] <author> Saumya K. Debray. </author> <title> Register allocation in a Prolog machine. </title> <booktitle> In Proceedings of the Symposium on Logic Programming, </booktitle> <pages> pages 267-275. </pages> <publisher> IEEE Computer Society, </publisher> <month> September </month> <year> 1986. </year>
Reference-contexts: Algorithms that do this well can be quite involved. A general method due to Debray <ref> [Deb86] </ref> works well in reasonable time. A more sophisticated but more (compile-time) expensive technique using Debray's method combined with a reordering of unification instructions can be found in [JDM88]. Register allocation is really auxiliary to the WAM design and can be performed by an independent module in the compiler.
Reference: [Deb89] <author> Saumya K. Debray. </author> <title> Static inference of modes and data dependencies in logic programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(3) </volume> <pages> 418-450, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Also, since compilation as done by the WAM treats each procedure independently of the rest of the program, global analysis techniques can therefore be considered as in <ref> [Mel85, DW86a, DW86b, Deb89, DW89, vR90, vRD90] </ref>. Finally, one will find copious material about improving backtracking in Prolog in [PP82, BP84, Cox84, CCF88, ZTU90, Zho90].
Reference: [DW86a] <author> Saumya K. Debray and David S. Warren. </author> <title> Automatic mode inference for Prolog programs. </title> <booktitle> In Proceedings of the Symposium on Logic Programming, </booktitle> <pages> pages 78-88. </pages> <publisher> IEEE Computer Society, </publisher> <month> September </month> <year> 1986. </year>
Reference-contexts: Also, since compilation as done by the WAM treats each procedure independently of the rest of the program, global analysis techniques can therefore be considered as in <ref> [Mel85, DW86a, DW86b, Deb89, DW89, vR90, vRD90] </ref>. Finally, one will find copious material about improving backtracking in Prolog in [PP82, BP84, Cox84, CCF88, ZTU90, Zho90].
Reference: [DW86b] <author> Saumya K. Debray and David S. Warren. </author> <title> Detection and optimization of functional computations in Prolog. </title> <editor> In Ehud Shapiro, editor, </editor> <booktitle> Proceedings of the Third International Conference on Logic Programming, </booktitle> <address> Berlin, Germany, </address> <year> 1986. </year> <note> Springer-Verlag. Lecture Notes in Computer Science 225. </note>
Reference-contexts: Also, since compilation as done by the WAM treats each procedure independently of the rest of the program, global analysis techniques can therefore be considered as in <ref> [Mel85, DW86a, DW86b, Deb89, DW89, vR90, vRD90] </ref>. Finally, one will find copious material about improving backtracking in Prolog in [PP82, BP84, Cox84, CCF88, ZTU90, Zho90].
Reference: [DW89] <author> Saumya K. Debray and David S. Warren. </author> <title> Functional computations in logic programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(3) </volume> <pages> 451-481, </pages> <month> July </month> <year> 1989. </year> <note> 106 References </note>
Reference-contexts: Also, since compilation as done by the WAM treats each procedure independently of the rest of the program, global analysis techniques can therefore be considered as in <ref> [Mel85, DW86a, DW86b, Deb89, DW89, vR90, vRD90] </ref>. Finally, one will find copious material about improving backtracking in Prolog in [PP82, BP84, Cox84, CCF88, ZTU90, Zho90].
Reference: [GLLO85] <author> John Gabriel, Tim Lindholm, Ewing Lusk, and Ross Overbeek. </author> <title> A tutorial on the Warren abstract machine. </title> <type> Privately circulated draft, </type> <institution> Argonne National Laboratory, Mathematics and Computer Science Division, Argonne, </institution> <address> IL 60439., </address> <year> 1985. </year>
Reference: [Han90] <author> Michael Hanus. </author> <title> Private communication. </title> <type> Technical correspondence, </type> <month> December </month> <year> 1990. </year>
Reference-contexts: A1 call q=1; 1 put unsafe value Y1; A1 put value Y1; A2 deallocate execute r=2 It has the effect of "globalizing" the value of Y1 so as to guarantee that it may be discarded without leaving a nonsensical reference in A1. 6 This example is due to Michael Hanus <ref> [Han90] </ref> and, independently, to Pascal van Henten-ryck [vH90]. Both pointed out to this author the incorrect replacement rule described (as that of the last occurrence of an unsafe variable) in [AK90]. <p> According to our definition, X is treated as a temporary variable. This results 8 The lame behavior of this example was pointed out to the author by Damian Chu [Chu90] and Michael Hanus <ref> [Han90] </ref>. 62 Chapter 5 a=0 : allocate % a :- put variable A1; A2 % b (X; X call b=2; 0 % ); deallocate % c execute c=0 % : Code for a :- b (X; X); c:, by our classification a=0 : allocate % a :- put variable Y1; A1 <p> Second, one must convince one's self that delayed trimming is indeed safe so as to warrant the simpler put value Y1; A2 instead of the expected 9 This solution using delayed trimming was also pointed out to this author by Michael Hanus <ref> [Han90] </ref> who apparently figured it out for himself, probably like many others who worked out a WAM implementation. 64 Chapter 5 a=0 : allocate % a :- put variable Y1; A1 % b (X; put unsafe value Y1; A2 % X call b=2; 1 % ); deallocate % c execute c=0
Reference: [Her71] <author> Jacques Herbrand. </author> <title> Logical Writings. </title> <publisher> Harvard University Press, </publisher> <address> Cambridge, MA, </address> <year> 1971. </year> <title> Edited by Warren D. </title> <type> Goldfarb. </type>
Reference-contexts: A Prolog in a Nutshell We first present basic notions for first-order terms and substitutions. Then, we describe a non-deterministic unification algorithm as a set of solution-preserving transformations on a set of equations due to Herbrand <ref> [Her71] </ref> (cf., Page 148) and rediscovered by Martelli-Montanari [MM82]. Then, we summarize the essence of Prolog's operational semantics. Terms and substitutions Let fS n g n0 be an indexed family of mutually disjoint sets of (function) symbols of arity n.
Reference: [JDM88] <author> Gerda Janssens, Bart Demoen, and Andre Marien. </author> <title> Improving the register allocation in WAM by reordering unification. </title> <editor> In Robert Kowalski and Kenneth Bowen, editors, </editor> <booktitle> Logic Programming: Proceedings of the Fifth International Conference and Symposium, </booktitle> <pages> pages 1388-1402, </pages> <address> Cambridge, MA, 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Algorithms that do this well can be quite involved. A general method due to Debray [Deb86] works well in reasonable time. A more sophisticated but more (compile-time) expensive technique using Debray's method combined with a reordering of unification instructions can be found in <ref> [JDM88] </ref>. Register allocation is really auxiliary to the WAM design and can be performed by an independent module in the compiler.
Reference: [Kow79] <author> Robert A. Kowalski. </author> <title> Logic for Problem Solving, </title> <booktitle> volume 7 of Artificial Intelligence Series. </booktitle> <publisher> North Holland, </publisher> <address> New York, NY, </address> <year> 1979. </year>
Reference-contexts: Edinburgh Prolog syntax uses [XjY ] instead of X:Y ; it also uses a simplified variant to express a list in extenso, allowing writing [1,2,3] rather than [1j [2j [3j []]]]. Prolog in a Nutshell 83 proposed by R. A. Kowalski <ref> [Kow79] </ref> as a computation rule. Technically, it is characterized as linear resolution over definite clauses, using a selection function.
Reference: [Kur87] <author> Peter Kursawe. </author> <title> How to invent a Prolog machine. </title> <journal> New Generation Computing, </journal> <volume> 5 </volume> <pages> 97-114, </pages> <year> 1987. </year>
Reference-contexts: For those interested in more advanced material using WAM ideas, some works are worth mentioning for further reading. In particular, the manner in which the WAM regards unification has a strong relation with partial evaluation techniques as explained in particular in <ref> [Kur87] </ref>. Also, since compilation as done by the WAM treats each procedure independently of the rest of the program, global analysis techniques can therefore be considered as in [Mel85, DW86a, DW86b, Deb89, DW89, vR90, vRD90].
Reference: [Mel85] <author> Christopher S. Mellish. </author> <title> Some global optimizations for a Prolog compiler. </title> <journal> Journal of Logic Programming, </journal> <volume> 1 </volume> <pages> 143-166, </pages> <year> 1985. </year>
Reference-contexts: Also, since compilation as done by the WAM treats each procedure independently of the rest of the program, global analysis techniques can therefore be considered as in <ref> [Mel85, DW86a, DW86b, Deb89, DW89, vR90, vRD90] </ref>. Finally, one will find copious material about improving backtracking in Prolog in [PP82, BP84, Cox84, CCF88, ZTU90, Zho90].
Reference: [MM82] <author> Alberto Martelli and Ugo Montanari. </author> <title> An efficient unification algorithm. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(2) </volume> <pages> 258-282, </pages> <month> April </month> <year> 1982. </year>
Reference-contexts: A Prolog in a Nutshell We first present basic notions for first-order terms and substitutions. Then, we describe a non-deterministic unification algorithm as a set of solution-preserving transformations on a set of equations due to Herbrand [Her71] (cf., Page 148) and rediscovered by Martelli-Montanari <ref> [MM82] </ref>. Then, we summarize the essence of Prolog's operational semantics. Terms and substitutions Let fS n g n0 be an indexed family of mutually disjoint sets of (function) symbols of arity n. Let S = S n0 S n be the set of all function symbols. <p> Two sets of equations are equivalent iff they both admit all and only the same solutions. Following <ref> [MM82] </ref>, we define two transformations on sets of equations|term decomposition and variable elimination. They both preserve solutions of sets of equations.
Reference: [MW88] <author> David Maier and David S. Warren. </author> <title> Computing with Logic: Logic Programming with Prolog. </title> <address> Benjamin/Cummings, Menlo Park, CA, </address> <year> 1988. </year>
Reference: [Per90] <author> Fernando Pereira. </author> <type> Personal communication. </type> <institution> Electronic mail, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: In particular, Fernando Pereira <ref> [Per90] </ref> suggested that instead of that shown in Figure 2.1 on Page 7, a more economical heap representation for p (Z; h (Z; W ); f (W )) ought to be that of Figure 5.1, where reference to the term from elsewhere must be from a store (or register) cell of <p> We are grateful to him for pointing this out. However, he himself warns <ref> [Per90] </ref>: "Now, this representation (which, I believe, is the one used by Quintus, SICStus Prolog, etc.) has indeed some disadvantages: 1.
Reference: [PP82] <author> Luis M. Pereira and Antonio Porto. </author> <title> Selective backtracking. </title> <editor> In Keith L. Clark and Sten- Ake Tarnlund, editors, </editor> <booktitle> Logic Programming, </booktitle> <pages> pages 107-114. </pages> <publisher> Academic Press, </publisher> <address> New York, NY, </address> <year> 1982. </year>
Reference-contexts: Also, since compilation as done by the WAM treats each procedure independently of the rest of the program, global analysis techniques can therefore be considered as in [Mel85, DW86a, DW86b, Deb89, DW89, vR90, vRD90]. Finally, one will find copious material about improving backtracking in Prolog in <ref> [PP82, BP84, Cox84, CCF88, ZTU90, Zho90] </ref>. At any rate, we hope to have contributed to give the reader a rapid and clear understanding with thorough, if not formal, justification of all the details of the essential abstract machine.
Reference: [Rob65] <author> John A. Robinson. </author> <title> A machine-oriented logic based on the resolution principle. </title> <journal> Journal of the ACM, </journal> <volume> 12 </volume> <pages> 23-41, </pages> <month> January </month> <year> 1965. </year>
Reference-contexts: It owes its origins to Automatic Theorem Proving based on the Resolution Principle discovered by J. A. Robinson <ref> [Rob65] </ref> and was 2 For example, 1:2:3:[] is a list. Edinburgh Prolog syntax uses [XjY ] instead of X:Y ; it also uses a simplified variant to express a list in extenso, allowing writing [1,2,3] rather than [1j [2j [3j []]]]. Prolog in a Nutshell 83 proposed by R. A. <p> Prolog in a Nutshell 83 proposed by R. A. Kowalski [Kow79] as a computation rule. Technically, it is characterized as linear resolution over definite clauses, using a selection function. Linear resolution is a particular restriction of the non-deterministic application of the general deduction rule defined in <ref> [Rob65] </ref> so that one single fixed clause keeps being transformed by resolving it against other clauses in a given set.
Reference: [Ros91] <author> Dean Rosenzweig. </author> <type> Personal communication. </type> <institution> Electronic mail, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: The treatment of cut was not part of the original WAM report [War83]. The material we present here is extrapolated from what was sketched in [War88] and suggestions from Dean Rosenzweig <ref> [Ros91] </ref>. As is well-known, the cut predicate (noted `!') is an extra-logical control annotation that helps the Prolog programmer trim the search space. <p> that will create a second choice point for call=1 if executed. 12 Let us first consider the simpler case where the clause containing the cut, be it shallow or deep, is the first (not necessarily in sequence thanks to 12 This fact was brought to our attention by Dean Rosenzweig <ref> [Ros91] </ref> who noticed that the scheme given in [AK90] was erroneous. We gratefully acknowledge his suggesting the corrected scheme we describe next. 74 Chapter 5 indexing) among those of the called procedure's to be executed upon entering the procedure with call or execute. <p> All the machinery we just presented is taken into account in the explicit definitions of the complete WAM instructions given in Appendix B. Exercise 5.6 The following is suggested by <ref> [Ros91] </ref>. The problem of knowing to which value B0 must be restored upon backtracking may be solved in a better way than systematically saving it as part of a choice point.
Reference: [Rus89] <author> David M. Russinoff. </author> <title> A verified Prolog compiler for the Warren abstract machine. </title> <type> MCC Technical Report Number ACT-ST-292-89, </type> <institution> Microelectronics and Computer Technology Corporation, Austin, TX, </institution> <month> July </month> <year> 1989. </year>
Reference: [vH90] <author> Pascal van Hentenryck. </author> <title> Private communication. Electronic mail, </title> <month> September </month> <year> 1990. </year>
Reference-contexts: Y1; A1 put value Y1; A2 deallocate execute r=2 It has the effect of "globalizing" the value of Y1 so as to guarantee that it may be discarded without leaving a nonsensical reference in A1. 6 This example is due to Michael Hanus [Han90] and, independently, to Pascal van Henten-ryck <ref> [vH90] </ref>. Both pointed out to this author the incorrect replacement rule described (as that of the last occurrence of an unsafe variable) in [AK90].
Reference: [vR90] <author> Peter L. van Roy. </author> <title> Can Logic Programming Execute as Fast as Imperative Programming? PhD thesis, </title> <institution> University of California at Berkeley, Berkeley, </institution> <address> CA, </address> <month> December </month> <year> 1990. </year>
Reference-contexts: Also, since compilation as done by the WAM treats each procedure independently of the rest of the program, global analysis techniques can therefore be considered as in <ref> [Mel85, DW86a, DW86b, Deb89, DW89, vR90, vRD90] </ref>. Finally, one will find copious material about improving backtracking in Prolog in [PP82, BP84, Cox84, CCF88, ZTU90, Zho90].
Reference: [vRD90] <author> Peter L. van Roy and Alvin Despain. </author> <title> The benefits of global dataflow analysis for an optimizing Prolog compiler. </title> <editor> In Saumya Debray and Manuel Hermenegildo, editors, </editor> <booktitle> Logic Programming: Proceedings of the 1990 North American Conference, </booktitle> <pages> pages 491-515, </pages> <address> Cambridge, MA, 1990. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Also, since compilation as done by the WAM treats each procedure independently of the rest of the program, global analysis techniques can therefore be considered as in <ref> [Mel85, DW86a, DW86b, Deb89, DW89, vR90, vRD90] </ref>. Finally, one will find copious material about improving backtracking in Prolog in [PP82, BP84, Cox84, CCF88, ZTU90, Zho90].
Reference: [War83] <author> David H. D. Warren. </author> <title> An abstract Prolog instruction set. </title> <type> Technical Note 309, </type> <institution> SRI International, </institution> <address> Menlo Park, CA, </address> <month> October </month> <year> 1983. </year>
Reference-contexts: Rather, this work's intention is to explain in simpler terms, and justify with informal discussions, David H. D. Warren's abstract machine specifically and exclusively. Our source is what he describes in <ref> [War83, War88] </ref>. <p> This allows us to explain as limpidly as possible specific principles proper to each. We then stitch and merge the different patches into larger pieces, introducing independent optimizations one at a time, converging eventually to the complete WAM design as described in <ref> [War83] </ref> or as overviewed in [War88]. Thus, in Chapter 2, we consider unification alone. Then, we look at flat resolution (that is, Prolog without backtracking) in Chapter 3. Following that, we turn to disjunctive definitions and backtracking in Chapter 4. <p> The only complication is that when an unbound REF cell is encountered in the query term in the heap, then it is to be bound to a new term that is built on the heap as an exemplar of the corresponding 1 As a matter of fact, in <ref> [War83] </ref>, Warren refers to the heap as the global stack. 10 Chapter 2 put structure h=2; X3 % ?-X3 = h set variable X2 % (Z; set variable X5 % W ); put structure f =1; X4 % X4 = f set value X5 % (W ); put structure p=3; X1 <p> Therefore, it is necessary to preserve continuation information by saving the value of CP along with permanent variables. 1 In <ref> [War83] </ref>, this stack is called the local stack to distinguish it from the global stack (see Footnote 1 at the bottom of Page 9). 24 Chapter 3 Let us recapitulate: M 2 is an augmentation of M 1 with the addition of a new data area, along with the heap (HEAP), <p> In summary, a choice point frame is allocated on the stack looking thus: 3 3 In <ref> [War83] </ref>, David Warren does not include the arity in a choice point, as we do here. He sets up things slightly differently so that this number can always be quickly computed. <p> In fact, the exact manner in which the number of arguments is retrieved at choice point creation time is not at all explained in <ref> [War83, War88] </ref>. Moreover, upon private inquiry, David H. D. Warren could not remember whether that was an incidental omission. <p> Of course, having introduced specially tagged data cells for constants and non-empty lists will require adapting accordingly the general-purpose unification algorithm given in Figure 2.7. The reader will find the complete algorithm in appendix Section B.2, on Page 104. Exercise 5.2 In <ref> [War83] </ref>, Warren also uses special instructions put nil Xi, get nil Xi, and to handle the list terminator constant ([]). Define the effect of these instructions, and give explicit pseudo-code implementing them. <p> Strictly speaking, the set instructions we have defined are not part of the WAM as described in <ref> [War83] </ref> or in [War88]. There, one will find that the Optimizing the Design 45 corresponding unify instructions are systematically used where we use set instructions. <p> Both pointed out to this author the incorrect replacement rule described (as that of the last occurrence of an unsafe variable) in [AK90]. In fact, the incorrect rule in [AK90] had been simply inherited verbatim from Warren's original report <ref> [War83] </ref> (Page 14, Line 3), and later explained by him as follows [War90]: "I agree that this is ambiguous or misleading. <p> In our opinion, the way the WAM classifies variables is perhaps the most puzzling item to justify for the learning reader. Indeed, although the definition we have used thus far is correct as given, it is not exactly that given and used in <ref> [War83] </ref> or [War88]. We presently analyze this discrepancy and discuss in particular the motivation, as well as some rather subtle consequences, of the original WAM designer's definition. In fact, our definition and justification of variable classification take David H. D. Warren's actual conception back to front. <p> However, register A1 still points to the discarded slot! It is therefore clear that for Warren's classification to be correct, something must be done to prevent this particular ailment. As far as this author could read, it has not been explained anywhere (including in <ref> [War83, War88] </ref>) how to prevent incorrect code as that of Figure 5.13 to be generated because of Warren's classification, let alone what correct code Optimizing the Design 63 a=0 : allocate % a :- put variable Y1; A1 % b (X; put value Y1; A2 % X call b=2; 1 % <p> Furthermore, the simpler case where the subsequence is reduced to a single variable-key clause degenerates into the expected simpler translation pattern requiring nothing more than we had before. Thus, the code for call=1 above looks like: 11 This example is a slight modification of that given in <ref> [War83] </ref>. The (admittedly silly) splitting of the two or=2 clauses is only to illustrate that this will not affect performance thanks to indexing. <p> All explicit definitions for the indexing instructions are given in Appendix B. Exercise 5.4 The effect of the switch on constant instruction described above is that given originally by Warren in <ref> [War83] </ref>. However, it does useless work as it eventually leads to a get constant instruction that redundantly tests whether register A1 contains that very same constant that was seen in A1 by switch on constant. <p> The treatment of cut was not part of the original WAM report <ref> [War83] </ref>. The material we present here is extrapolated from what was sketched in [War88] and suggestions from Dean Rosenzweig [Ros91]. As is well-known, the cut predicate (noted `!') is an extra-logical control annotation that helps the Prolog programmer trim the search space.
Reference: [War88] <author> David H. D. Warren. </author> <title> Implementation of Prolog. </title> <booktitle> Lecture notes, Tutorial No. 3, 5th International Conference and Symposium on Logic Programming, </booktitle> <address> Seattle, WA, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: Rather, this work's intention is to explain in simpler terms, and justify with informal discussions, David H. D. Warren's abstract machine specifically and exclusively. Our source is what he describes in <ref> [War83, War88] </ref>. <p> This allows us to explain as limpidly as possible specific principles proper to each. We then stitch and merge the different patches into larger pieces, introducing independent optimizations one at a time, converging eventually to the complete WAM design as described in [War83] or as overviewed in <ref> [War88] </ref>. Thus, in Chapter 2, we consider unification alone. Then, we look at flat resolution (that is, Prolog without backtracking) in Chapter 3. Following that, we turn to disjunctive definitions and backtracking in Chapter 4. At that point, we will have a complete, albeit nave, design for pure Prolog. <p> In fact, the exact manner in which the number of arguments is retrieved at choice point creation time is not at all explained in <ref> [War83, War88] </ref>. Moreover, upon private inquiry, David H. D. Warren could not remember whether that was an incidental omission. <p> Strictly speaking, the set instructions we have defined are not part of the WAM as described in [War83] or in <ref> [War88] </ref>. There, one will find that the Optimizing the Design 45 corresponding unify instructions are systematically used where we use set instructions. The reason is, as the reader may have noticed, that indeed this is possible provided that the put structure and put list instructions set mode to write. <p> In our opinion, the way the WAM classifies variables is perhaps the most puzzling item to justify for the learning reader. Indeed, although the definition we have used thus far is correct as given, it is not exactly that given and used in [War83] or <ref> [War88] </ref>. We presently analyze this discrepancy and discuss in particular the motivation, as well as some rather subtle consequences, of the original WAM designer's definition. In fact, our definition and justification of variable classification take David H. D. Warren's actual conception back to front. <p> However, register A1 still points to the discarded slot! It is therefore clear that for Warren's classification to be correct, something must be done to prevent this particular ailment. As far as this author could read, it has not been explained anywhere (including in <ref> [War83, War88] </ref>) how to prevent incorrect code as that of Figure 5.13 to be generated because of Warren's classification, let alone what correct code Optimizing the Design 63 a=0 : allocate % a :- put variable Y1; A1 % b (X; put value Y1; A2 % X call b=2; 1 % <p> The treatment of cut was not part of the original WAM report [War83]. The material we present here is extrapolated from what was sketched in <ref> [War88] </ref> and suggestions from Dean Rosenzweig [Ros91]. As is well-known, the cut predicate (noted `!') is an extra-logical control annotation that helps the Prolog programmer trim the search space.
Reference: [War89] <author> David H. D. Warren. </author> <title> Private communication. Electronic mail, </title> <month> October </month> <year> 1989. </year>
Reference-contexts: Secondly, although historically, David H. D. Warren made put variable Xn; Ai systematically allocate a heap cell as a patch to accommodate LCO, 10 this instruction can be justified otherwise, as we have 10 He states <ref> [War89] </ref>: "The put variable Xn; Ai instruction is a kind of hack which exists only to take care of the problems of a variable that is bound to be unsafe at LCO, namely a variable which has its first occurrence in the last call and isn't otherwise bound.
Reference: [War90] <author> David H. D. Warren. </author> <title> Private communication. Electronic mail, </title> <month> September </month> <year> 1990. </year>
Reference-contexts: In fact, the incorrect rule in [AK90] had been simply inherited verbatim from Warren's original report [War83] (Page 14, Line 3), and later explained by him as follows <ref> [War90] </ref>: "I agree that this is ambiguous or misleading. <p> Upon private inquiry, this is what Warren proposes <ref> [War90] </ref>: "The general principle is that one should make variables permanent if at all possible, and use put variable Xn; Ai only as a last resort. The problem is what to do about variables which occur in only one goal.
Reference: [Zho90] <author> Neng-Fa Zhou. </author> <title> Backtracking Optimizations in Compiled Prolog. </title> <type> PhD thesis, </type> <institution> Kyushu University, Fukuoka, </institution> <address> Japan, </address> <month> November </month> <year> 1990. </year>
Reference-contexts: Also, since compilation as done by the WAM treats each procedure independently of the rest of the program, global analysis techniques can therefore be considered as in [Mel85, DW86a, DW86b, Deb89, DW89, vR90, vRD90]. Finally, one will find copious material about improving backtracking in Prolog in <ref> [PP82, BP84, Cox84, CCF88, ZTU90, Zho90] </ref>. At any rate, we hope to have contributed to give the reader a rapid and clear understanding with thorough, if not formal, justification of all the details of the essential abstract machine.

References-found: 35

