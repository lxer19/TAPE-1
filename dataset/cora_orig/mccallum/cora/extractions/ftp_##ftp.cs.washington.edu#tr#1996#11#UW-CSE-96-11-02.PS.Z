URL: ftp://ftp.cs.washington.edu/tr/1996/11/UW-CSE-96-11-02.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-title.html
Root-URL: 
Email: -chambers,grove,jdean-@cs.washington.edu  
Title: Frameworks for Intra- and Interprocedural Dataow Analysis  
Author: Craig Chambers, Jeffrey Dean, and David Grove 
Address: Washington  
Affiliation: Department of Computer Science and Engineering University of  
Abstract: Technical Report 96-11-02 November 1996 
Abstract-found: 1
Intro-found: 1
Reference: [Aho et al. 86] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <address> Ad-dison-Wesley, Reading, MA, </address> <year> 1986. </year>
Reference-contexts: Section 5 describes our experience using these interfaces and identifies some areas for future work, and section 6 compares our design to other analysis frameworks. 2 Defining Intraprocedural Analyses Our framework performs dataow analyses over control ow graphs whose nodes are individual three-address-code-style <ref> [Aho et al. 86] </ref> statements. Dataow information at program points is drawn from a lattice of possible dataow information.
Reference: [Aiken & Wimmers 92] <author> A. Aiken and E. Wimmers. </author> <title> Solving Systems of Set Constraints. </title> <booktitle> In Proceedings of the 7th IEEE Symposium on Logic in Computer Science, pages 329--340, </booktitle> <address> Santa Cruz, CA, </address> <month> June </month> <year> 1992. </year>
Reference: [Alt & Martin 95] <author> Martin Alt and Florian Martin. </author> <title> Generation of efficient interprocedural analyzers with PAG. </title> <booktitle> In Proceedings of the Second INternational Symposium on Static Analysis, pages 33--50. </booktitle> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1995. </year>
Reference-contexts: PAG is a generator for both intra- and interprocedural dataow analyzers <ref> [Alt & Martin 95] </ref>. PAG defines several specialized but restricted languages in which the syntax-tree program representation, the domain data structures, the ow functions, and the high-level analysis engine are defined. PAGs intraprocedural analysis is fairly conventional, lacking support for composing analyses and transformations and lacking Sharlits path compression.
Reference: [Assmann 96] <author> Uwe Assmann. </author> <title> How to Uniformly Specify Program Analysis and Transformations with Graph Rewrite Systems. </title> <booktitle> In Proceedings of the CC96. 6th International Conference on Compiler Construction, pages 121--135. </booktitle> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1996. </year>
Reference-contexts: Assmann has developed a model for integrated analyses and transformations where everything ranging from the program representation to the dataow analysis information is represented by a particular graph model <ref> [Assmann 96] </ref>. Analyses and transformations are expressed as graph rewrite rules, which are fired whenever their preconditions over the input graph structure are satisfied, leading to more of a constraint-based avor of program analysis.
Reference: [Adl-Tabatbai et al. 96] <author> Ali-Reza Adl-Tabatbai, Thomas Gross, and Guei-Yuan Lueh. </author> <title> Code Reuse in an Optimizing Compiler. </title> <booktitle> In OOPSLA96 Conference Proceedings, pages 51--68, </booktitle> <address> San Jose, CA, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: It does have interesting support for path compression which enables faster analyses that compute summary ow functions for basic blocks or larger structures (in the style of interval analysis [Cocke 70]), for problems where ow functions are represented as GEN and KILL bit-vectors. The cmcc compiler <ref> [Adl-Tabatbai et al. 96] </ref>, like our intraprocedural analysis framework, uses object-oriented design to organize the code and provide an abstract class for analysis information. However, it does not support composing analyses and/or transformations nor aid in building interprocedural analyses.
Reference: [Chambers & Ungar 90] <author> Craig Chambers and David Ungar. </author> <title> Iterative Type Analysis and Extended Message Splitting: Optimizing Dynamically-Typed Object-Oriented Programs. </title> <journal> SIGPLAN Notices, </journal> <volume> 25(6):150--164, </volume> <month> June </month> <year> 1990. </year> <booktitle> In Proceedings of the ACM SIGPLAN 90 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: Consequently, it is important to be able to perform inlining, based on intermediate analysis results, while engaged in iterative analysis, in order to reach the best solutions <ref> [Chambers & Ungar 90] </ref>. Our framework manages the details of acting only tentatively on any transformations applied during iterative analysis, undoing the transformations effects if iteration causes the code to later be reanalyzed. <p> All of the existing analyses, save splitting, make only local transformations to the graph during analysis. Splitting may need to perform radical changes to the control ow graph, duplicating control paths to eliminate partially-redundant conditional tests <ref> [Chambers & Ungar 90] </ref>.
Reference: [Chambers et al. 95] <author> Craig Chambers, Jeffrey Dean, and David Grove. </author> <title> A Framework for Selective Recompilation in the Presence of Complex Intermodule Dependencies. </title> <booktitle> In 17th International Conference on Software Engineering, pages 221--230, </booktitle> <address> Seattle, WA, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: We plan to extend Vortex to selectively reanalyze only those parts of the program affected by a program change and recompile only those procedures that depended on the changed interprocedural summary information. Vortex already includes support for selective recompilation for changes to simple kinds of interprocedural summary information <ref> [Chambers et al. 95] </ref>. 5 Experience and Future Work The framework described in this paper has been implemented in the Vortex compiler. We have used the intraprocedural analysis framework in essentially its current form since mid-1994.
Reference: [Choi et al. 91] <author> Jong-Deok Choi, Ron Cytron, and Jeanne Ferrante. </author> <title> Automatic Construction of Sparse Data Flow Evaluation Graphs. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, pages 55--66, </booktitle> <address> Orlando, Florida, </address> <month> January </month> <year> 1991. </year>
Reference: [Click & Cooper 95] <author> Cliff Click and Keith D. Cooper. </author> <title> Combining Analyses, Combining Optimizations. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(2):181--196, </volume> <month> March </month> <year> 1995. </year>
Reference-contexts: Each composed analysis can examine the intermediate dataow information computed by the other composed analyses in order to share results and reach better fixpoints faster than would be possible by running each analysis separately in sequence <ref> [Click & Cooper 95] </ref>. In addition, complex monolithic analyses can be broken up into modular analysis components that may be reused as part of other analyses, and new analysis components can be written and added to existing composed analyses easily. <p> simulation of transformations is necessary; the framework automatically does this simulation for clients. 3 Composing Intraprocedural Analyses Intraprocedural analyses often can leverage off of each others intermediate results, enabling integrated analyses potentially to compute more precise solutions faster than separate analyses run in sequence until none makes any more changes <ref> [Click & Cooper 95] </ref>. For example, a pass integrating constant propagation and folding, alias analysis, receiver class set analysis, and inlining would be more powerful than each run separately, since each analysis and transformation interacts with the others, enabling the others to work better.
Reference: [Cocke 70] <author> John Cocke. </author> <title> Global common subexpression elimination. </title> <journal> SIGPLAN Notices, </journal> <volume> 5(7):20--24, </volume> <month> July </month> <year> 1970. </year>
Reference-contexts: Unlike our framework, it does not support composing analyses, running transformations undoably as part of analysis, or interprocedural analyses. It does have interesting support for path compression which enables faster analyses that compute summary ow functions for basic blocks or larger structures (in the style of interval analysis <ref> [Cocke 70] </ref>), for problems where ow functions are represented as GEN and KILL bit-vectors. The cmcc compiler [Adl-Tabatbai et al. 96], like our intraprocedural analysis framework, uses object-oriented design to organize the code and provide an abstract class for analysis information.
Reference: [Cooper et al. 92] <author> Keith D. Cooper, Mary W. Hall, and Ken Kennedy. </author> <title> Procedure Cloning. </title> <booktitle> In Proceedings of 1992 IEEE International Conference on Computer Languages, pages 96--105, </booktitle> <address> Oakland, CA, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: Their framework includes a particular call graph construction algorithm, although it appears that alternative algorithms could be used. Unlike our framework, the FIAT system does not directly provide support for context-sensitive analyses, although clients can implement them by hand as evidenced by their procedure cloning algorithm <ref> [Cooper et al. 92] </ref>. FIAT recomputes individual interprocedural analyses on demand if their information is needed by some other analysis but is out of date.
Reference: [Cousot & Cousot 77] <author> Patrick Cousot and Radhia Cousot. </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <booktitle> In Conference Record of the Fourth ACM Symposium on Principles of Programming Languages, pages 238--252, </booktitle> <address> Los Angeles, California, </address> <month> January </month> <year> 1977. </year>
Reference-contexts: Generalizing merge corresponds to the widening operator used in abstract interpretation <ref> [Cousot & Cousot 77] </ref>. To avoid unnecessary copy operations, some operations may modify an AnalysisInfo data structure in place.
Reference: [Cytron et al. 89] <author> Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> An Efficient Method of Computing Static Single Assignment Form. </title> <booktitle> In Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, pages 25--35, </booktitle> <address> Austin, Texas, </address> <month> January </month> <year> 1989. </year>
Reference: [Dean et al. 96] <author> Jeffrey Dean, Greg DeFouw, Dave Grove, Vassily Litvinov, and Craig Chambers. </author> <title> Vortex: An Optimizing Compiler for Object-Oriented Languages. </title> <booktitle> In OOPSLA96 Conference Proceedings, </booktitle> <address> San Jose, CA, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: A client dataow analysis is implemented simply by instantiating or parameterizing the generic framework with the particulars of that analysis. We have designed, implemented, and used a framework for implementing intra- and interprocedural dataow analyses as part of the Vortex optimizing compiler <ref> [Dean et al. 96] </ref>.
Reference: [Dhamdhere et al. 92] <author> Dhananjay M. Dhamdhere, Barry K. Rosen, and F. Kenneth Zadeck. </author> <title> How to Analyze Large Programs Efficiently and Informatively. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(7):212--223, </volume> <month> July </month> <year> 1992. </year> <booktitle> In Proceedings of the ACM SIGPLAN 92 Conference on Programming Language Design and Implementation. </booktitle>
Reference: [Dwyer & Clarke 98] <author> Matthew B. Dwyer and Lori A. Clarke. </author> <title> A Flexible Architecture for Building Data Flow Analyzers. </title> <booktitle> In 17th International Conference on Software Engineering, pages 554--564, </booktitle> <address> Berlin, Germany, </address> <month> March </month> <year> 1998. </year>
Reference: [Ferrante et al. 87] <author> Jeanne Ferrante, Karl J. Ottenstein, and Joe D. Warren. </author> <title> The Program Dependence Graph and its Use in Optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3):319--349, </volume> <month> July </month> <year> 1987. </year>
Reference: [Hall et al. 93] <author> M.W. Hall, J.M. Mellor-Crummey, A. Carle, and R. Rodriguez. FIAT: </author> <title> A Framework for Interproce 20 Frameworks for Intra- and Interprocedural Dataow Analysis Chambers et al. dural Analysis and Transformation. </title> <booktitle> In The Sixth Anunual Workshop on Parallel Languages and Compilers, </booktitle> <month> August </month> <year> 1993. </year>
Reference-contexts: Their architecture also supports a restricted kind of composed analysis. They do not address integrating transformations with analysis. FIAT is a framework for managing interprocedural analyses <ref> [Hall et al. 93] </ref>. Like our interprocedural framework, it relies on underlying intraprocedural analysis to analyze individual procedures. Their framework includes a particular call graph construction algorithm, although it appears that alternative algorithms could be used.
Reference: [Heintze 94] <author> Nevin Heintze. </author> <title> Set-Based Analysis of ML Programs. </title> <booktitle> In Proceedings of the ACM Conference on LISP and Functional Programming 94, pages 306--317, </booktitle> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year>
Reference: [Hendren et al. 93] <author> Laurie J. Hendren, Maryam Emami, Rakesh Ghiya, and Clark Verbrugge. </author> <title> A Practical Context-Sensitive Interprocedural Analysis Framework for C Compilers. </title> <type> Technical Report ACAPS Technical Memo 72, </type> <institution> McGill University School of COmputer Science, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: The McCAT optimizing C compiler includes a framework for context-sensitive interprocedural analyses <ref> [Hendren et al. 93] </ref>. This framework does not manage dataow information or help in reaching fixpoints, but only provides the basic program representation and the program call graph over which clients write their analyses manually.
Reference: [Jagannathan & Weeks 95] <author> Suresh Jagannathan and Stephen Weeks. </author> <title> A Unified Framework of Flow Analysis in HIgher-Order Languages. </title> <booktitle> In Conference Record of POPL 95: 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 393--407, </pages> <month> January </month> <year> 1995. </year>
Reference: [Johnson & Pingali 93] <author> Richard Johnson and Keshav Pingali. </author> <title> Dependence-Based Program Analysis. </title> <journal> SIGPLAN Notices, </journal> <volume> 28(6):78--89, </volume> <month> June </month> <year> 1993. </year> <booktitle> In Proceedings of the ACM SIGPLAN 93 Conference on Programming Language Design and Implementation. </booktitle>
Reference: [Kam & Ullman 76] <author> John B. Kam and Jeffrey D. Ullman. </author> <title> Global data flow analysis and iterative algorithms. </title> <journal> Journal of the ACM, </journal> <volume> 23(1):158--171, </volume> <month> January </month> <year> 1976. </year>
Reference-contexts: We have designed, implemented, and used a framework for implementing intra- and interprocedural dataow analyses as part of the Vortex optimizing compiler [Dean et al. 96]. Our framework is like others in that it is based on a lattice-theoretic model of dataow analysis <ref> [Kildall 73, Kam & Ullman 76] </ref>: clients provide an implementation of the domain of analysis, including operations to copy, merge, and compare domain elements, and the ow or transfer functions over domain elements for each kind of instruction in the control ow graph program representation.
Reference: [Kildall 73] <author> Gary A. Kildall. </author> <title> A Unified Approach to Global Program Optimization. </title> <booktitle> In Conference Record of the ACM Symposium on Principles of Programming Languages, pages 194--206, </booktitle> <address> Boston, Massachusetts, </address> <month> October </month> <year> 1973. </year>
Reference-contexts: We have designed, implemented, and used a framework for implementing intra- and interprocedural dataow analyses as part of the Vortex optimizing compiler [Dean et al. 96]. Our framework is like others in that it is based on a lattice-theoretic model of dataow analysis <ref> [Kildall 73, Kam & Ullman 76] </ref>: clients provide an implementation of the domain of analysis, including operations to copy, merge, and compare domain elements, and the ow or transfer functions over domain elements for each kind of instruction in the control ow graph program representation.
Reference: [Knoop & Steffen 92] <author> Jens Knoop and Bernhard Steffen. </author> <title> The Interprocedural Coincidence Theorem. </title> <booktitle> In Proceedings of the CC92. 4th International Conference on Compiler Construction, pages 125--140. </booktitle> <publisher> Springer-Verlag, </publisher> <month> October </month> <year> 1992. </year>
Reference: [Masticola et al. 95] <author> Stephen Masticola, Thomas J. Marlowe, and Barbara G. Ryder. </author> <title> Lattice Frameworks for Multi-source and Bidirectional Data Flow Problems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(5):777--803, </volume> <month> September </month> <year> 1995. </year>
Reference: [Sreedhar et al. 96] <author> Vugranam C. Sreedhar, Guang R. Gao, and Yong fong Lee. </author> <title> A New Framework for Exhaustive and Incremental Data Flow Analysis Using DJ Graphs. </title> <journal> SIGPLAN Notices, </journal> <pages> pages 278--290, </pages> <month> May </month> <year> 1996. </year> <booktitle> In Proceedings of the ACM SIGPLAN 96 Conference on Programming Language Design and Implementation. </booktitle>
Reference: [Tjiang & Hennessy 92] <author> Steven W. K. Tjiang and John L. Hennessy. </author> <title> Sharlit -- A Tool for Building Optimizers. </title> <journal> SIG-PLAN Notices, </journal> <volume> 27(7):82--93, </volume> <month> July </month> <year> 1992. </year> <booktitle> In Proceedings of the ACM SIGPLAN 92 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: analysis that incorporates each of these analyses would be difficult, and useful component analyses could not be reused or run in isolation. * A system whose flow functions use fixed GEN and KILL bit-vectors for each kind of statement, such as an analyzer produced by Sharlit when using path compression <ref> [Tjiang & Hennessy 92] </ref>, is not able to simulate the effect of flow dependent optimizations like these. 7 Frameworks for Intra- and Interprocedural Dataow Analysis Chambers et al. Our intraprocedural analysis framework supports building a single integrated dataow analysis by composing a group of separately-written component dataow analyses. <p> Masticola, Marlowe, and Ryder present the k-tuple dataow analysis framework [95], a model for composing dataow analyses that do not need to have a common single analysis direction. A number of analysis frameworks have been described in the literature. Sharlit is an analyzer generator that supports iterative intraprocedural analyses <ref> [Tjiang & Hennessy 92] </ref>. Unlike our framework, it does not support composing analyses, running transformations undoably as part of analysis, or interprocedural analyses.
Reference: [Weise et al. 94] <author> Daniel Weise, Roger F. Crew, Michael Ernst, and Bjarne Steensgaard. </author> <title> Value Dependence Graphs: Representation without Taxation. </title> <booktitle> In Conference Record of POPL 94: 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 297--310, </booktitle> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference: [Yi & Harrison 93] <author> Kwangkeun Yi and Williams Ludwell Harrison III. </author> <title> Automatic Generation and Management of In-terprocedural Program Analyses. </title> <booktitle> In Conference Record of the Twentieth Annual ACM SIGPLAN-SI-GACT Symposium on Principles of Programming Languages, pages 246--259, </booktitle> <address> Charleston, South Carolina, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: In contrast, our framework allows the client analysis to conveniently specify policies for dynamically determining the appropriate context-sensitivity for each procedure independently. System Z generates intra- and interprocedural analyzers from abstract interpreters specified in a special language <ref> [Yi & Harrison 93] </ref>. This system includes projection expressions which enable analyses to conveniently express more approximate analyses without directly modifying the underlying abstract interpreter. System Z does not appear to provide support for context-sensitive analyses, nor does it address combining abstract interpreters capturing different aspects of program behavior.
References-found: 30

