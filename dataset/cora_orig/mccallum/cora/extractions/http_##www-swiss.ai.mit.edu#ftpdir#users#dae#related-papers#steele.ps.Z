URL: http://www-swiss.ai.mit.edu/ftpdir/users/dae/related-papers/steele.ps.Z
Refering-URL: http://www-swiss.ai.mit.edu/ftpdir/users/dae/home.html
Root-URL: 
Email: gls@think.com  
Phone: (617) 234-2860  
Title: Building Interpreters by Composing Monads a generalization of monads that allows composition. Functional composition of
Author: Guy L. Steele Jr. 
Date: January 1994.  
Note: The data structures are organized as pseudomonads,  This is a preprint of a paper that is to appear in the Proceedings of the Twenty-first Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages,  
Address: 245 First Street Cambridge, Massachusetts 02142  
Affiliation: Thinking Machines Corporation  
Abstract: We exhibit a set of functions coded in Haskell that can be used as building blocks to construct a variety of interpreters for Lisp-like languages. The building blocks are joined merely through functional composition. Each building block contributes code to support a specific feature, such as numbers, continuations, functions calls, or nondeterminism. The result of composing some number of building blocks is a parser, an interpreter, and a printer that support exactly the expression forms and data types needed for the combined set of features, and no more. Our intent was that the Haskell type resolution system ought to be able to deduce the approprate data types automatically. Unfortunately there is a deficiency in current Haskell implementations related to recursive data types: circularity must be reflected statically in the type definitions. We circumvent this restriction by applying a purpose-built program simplifier that performs partial evaluation and a certain amount of program algebra. We construct a wide variety of interpreters in the style of Wadler by starting with the building blocks and a page of boiler-plate code, writing three lines of code (one to specify the building blocks and two to (redundantly) specify type compositions), and then applying the simplifier. The resulting code is acceptable Haskell code. We have tested a dozen different interpreters with various combinations of features. In this paper we discuss the overall code structuring strategy, exhibit several building blocks, briefly describe the partial evaluator, and present a number of automatically generated interpreters. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Apple Computer, Inc. </author> <title> Inside Macintosh (five volumes). </title> <publisher> Addison-Wesley (Reading, Massachusetts, </publisher> <pages> 1985-86). </pages>
Reference-contexts: A pseudomonad has an eye on one end and a hook on the other. You can chain them. (Hm. I'm mixing my metaphors. First towers, now chains.) When you hang a pseudomonad on a hook, there's still a hook left to use. I wonder whether the Macintosh toolbox <ref> [1] </ref> could be defined in terms of a large set of pseudomonads, lending some structure to the games played by various add-on software packages to intercept system calls? 19 Acknowledgments I wish to thank Philip Wadler, Mark Jones, Olivier Danvy, Paul Hudak, and the conference referees for their helpful remarks.
Reference: [2] <editor> Hudak, Paul, Peyton Jones, Simon, and Wadler, Philip, editors. </editor> <title> Report on the Programming Language Haskell: A Non-Strict, Purely Functional Language (Version 1.1). </title> <type> Technical Report. </type> <institution> Yale University and Glasgow University (New Haven and Glasgow (respectively), </institution> <month> August </month> <year> 1991). </year>
Reference-contexts: I had a vision of building blocks, like Legos or Tinker-toys, that could be used interchangeably and in combination to build interpreters. It seemed that if they could be combined by functional composition, then the Haskell <ref> [2] </ref> type system, or an extension of it, ought to be able to deduce the relevant data types automatically. It can be done. <p> The language specification is hazy, so it is hard to determine whether this is a language restriction or an implementation deficiency. The nub of the matter is that Haskell allows recursive and mutually recursive datatypes, provided that "an algebraic datatype intervenes" <ref> [2] </ref>. In current implementations this is apparently a static requirement; that is, any circularity of definition must be textually apparent rather than deduced by the type mechanism.
Reference: [3] <author> Jones, Mark P. </author> <type> Personal communication to Guy Steele, </type> <month> September </month> <year> 1993. </year>
Reference-contexts: Jones has begun to explore the possibility of recoding the interpreters presented here so as to use Gofer's simpler monadic programming style <ref> [3] </ref>.
Reference: [4] <author> Jones, Mark P. </author> <title> A system of constructor classes: Overloading and implicit higher-order polymor-phism. </title> <booktitle> In Proc. FPCA '93: The Sixth International Conference on Functional Programming Languages and Computer Architecture. ACM SIG-PLAN/SIGARCH and IFIP (London, </booktitle> <month> September </month> <year> 1993). </year>
Reference-contexts: Jonathan Rees has coded monadic interpreters in Scheme but this work apparently has not been published [9]. Mark Jones has developed Gofer, a variant of Haskell that allows additional polymorphism through the use of type classes <ref> [4] </ref>. Gofer supports programming with multiple monads, including a cleaner version of the monad comprehension syntax proposed by Wadler [15].
Reference: [5] <author> King, David J., and Wadler, Philip. </author> <title> Combining monads. </title> <booktitle> In Functional Programming, </booktitle> <address> Glasgow '92. </address> <publisher> Springer Verlag (Berlin, </publisher> <year> 1992). </year>
Reference-contexts: Nevertheless, further investigation is warranted. Certain simple but important cases, such as lists and simple coproducts, are well-behaved; when provided as pseudomonads to the composition operator & the result obeys the monad associative law and therefore really is always a monad. King and Wadler <ref> [5] </ref>, for example, consider not only lists but also trees, bags, and sets. Simon Peyton Jones and Wadler have investigated the use of monads to perform I/O and other "imperative" tasks within a working compiler coded in Haskell [7].
Reference: [6] <author> Moggi, Eugenio. </author> <title> An Abstract View of Programming Languages. </title> <type> Technical Report ECS-LFCS-90-113. </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh (Edinburgh, Scot-land, </institution> <month> April </month> <year> 1990). </year> <note> Lecture notes for a course taught at Stanford University, Spring 1989. </note>
Reference-contexts: A separate proof must be supplied that the resulting monad obeys the monad associative law (and this is consistent with the experience of Moggi <ref> [6] </ref> and others that monads do not compose in general). (We note in passing that there is in fact a more general theory of pseudmonads in which the first argument to a pseudobind operation is a pseudomonad rather than a monad. <p> Jones has begun to explore the possibility of recoding the interpreters presented here so as to use Gofer's simpler monadic programming style [3]. Many of the ideas presented here were anticipated by Moggi <ref> [6] </ref>: To give semantics to a complex language L we propose a stepwise approach, which starts from a monad (notion of computation) corresponding to a toy sublanguage of L and then at each step applies a monad construc tor which adds one feature to the language.
Reference: [7] <editor> Peyton Jones, Simon L., and Wadler, Philip. </editor> <title> Imperative functional programming. </title> <booktitle> In Proc. Twentieth Annual ACM Symposium on Principles of Programming Languages. </booktitle> <institution> Association for Computing Machinery (Charleston, South Carolina, </institution> <month> January </month> <year> 1993), </year> <pages> 1-14. </pages>
Reference-contexts: King and Wadler [5], for example, consider not only lists but also trees, bags, and sets. Simon Peyton Jones and Wadler have investigated the use of monads to perform I/O and other "imperative" tasks within a working compiler coded in Haskell <ref> [7] </ref>. Jonathan Rees has coded monadic interpreters in Scheme but this work apparently has not been published [9]. Mark Jones has developed Gofer, a variant of Haskell that allows additional polymorphism through the use of type classes [4].
Reference: [8] <author> Raymond, Eric, </author> <title> editor. The New Hacker's Dictionary. </title> <publisher> MIT Press (Cambridge, </publisher> <address> Massachusetts, </address> <year> 1991). </year>
Reference-contexts: So it is useful to have more than two type towers. We should have left a hook <ref> [8] </ref> so that the input type to the parser could be changed. Indeed, it is unsatisfactory that the interp functions shown here must always accept an extra environment argument env.
Reference: [9] <author> Rees, Jonathan. </author> <type> Personal communication to Guy Steele, </type> <month> October </month> <year> 1993. </year>
Reference-contexts: Simon Peyton Jones and Wadler have investigated the use of monads to perform I/O and other "imperative" tasks within a working compiler coded in Haskell [7]. Jonathan Rees has coded monadic interpreters in Scheme but this work apparently has not been published <ref> [9] </ref>. Mark Jones has developed Gofer, a variant of Haskell that allows additional polymorphism through the use of type classes [4]. Gofer supports programming with multiple monads, including a cleaner version of the monad comprehension syntax proposed by Wadler [15].
Reference: [10] <author> Reynolds, John C. </author> <title> Definitional interpreters for higher order programming languages. </title> <booktitle> In Proc. ACM National Conference. </booktitle> <institution> Association for Computing Machinery (Boston, </institution> <month> August </month> <year> 1972), </year> <pages> 717-740. </pages>
Reference-contexts: It owes its roots to all the work that Wadler cites, of course, notably that of Reynolds <ref> [10] </ref>. It is also in the spirit of my own earlier work with Sussman [13]. In this presentation I have omitted all the proofs, particularly proofs of monad associativity.
Reference: [11] <author> Steele, Guy L., Jr. </author> <title> How to Compose Monads. </title> <type> Technical Report. </type> <institution> Thinking Machines Corporation (Cambridge, Massachusetts, </institution> <month> July </month> <year> 1993). </year> <note> Unpublished. </note>
Reference-contexts: The theory of pseudomonads is described in a companion paper <ref> [11] </ref>. The support code in Figure 1 is taken verbatim from that paper. In order to convey necessary type information, it is convenient to reify monads and pseudomonads. We represent a monad in Haskell as an algebraic datatype Monad encapsulating the unit and bind operations for the monad.
Reference: [12] <author> Steele, Guy L., Jr., Fahlman, Scott E., Gabriel, Richard P., Moon, David A., Weinreb, Daniel L., Bobrow, Daniel G., DeMichiel, Linda G., Keene, Sonya E., Kiczales, Gregor, Perdue, Crispin, Pitman, Kent M., Waters, Richard C., and White, Jon L. </author> <title> Common Lisp: The Language (Second Edition). </title> <publisher> Digital Press (Bedford, </publisher> <address> Massachusetts, </address> <year> 1990). </year>
Reference-contexts: Thus unrolling continues only if the gating case statement can first be eliminated by partial evaluation. The simplifier uses a fast and fairly effective pretty-printer after the style of Waters <ref> [18, 12] </ref>. 10 The Nondeterministic Building Block The nondeterministic building block extends the term data type to include a choice construct Amb x y (surface syntax (x|y)), where x and y are top-level terms, and a failure operation Fail (surface syntax fail).
Reference: [13] <author> Steele, Guy Lewis, Jr., and Sussman, Gerald Jay. </author> <title> The Art of the Interpreter; or, The Modularity Complex (Parts Zero, One, and Two). </title> <type> AI Memo 453. </type> <institution> MIT Artificial Intelligence Laboratory (Cambridge, Massachusetts, </institution> <month> May </month> <year> 1978). </year>
Reference-contexts: It owes its roots to all the work that Wadler cites, of course, notably that of Reynolds [10]. It is also in the spirit of my own earlier work with Sussman <ref> [13] </ref>. In this presentation I have omitted all the proofs, particularly proofs of monad associativity. In some cases they do not exist; that is, some of the putative monads that arise in the interpreters presented here are not really associative.
Reference: [14] <author> Sussman, Gerald Jay, and Steele, Guy Lewis, Jr. </author> <title> SCHEME: An Interpreter for Extended Lambda Calculus. </title> <type> AI Memo 349. </type> <institution> MIT Artificial Intelligence Laboratory (Cambridge, Massachusetts, </institution> <month> December </month> <year> 1975). </year>
Reference-contexts: anew, resulting in a total of four possibilities. 13 The Continuation Building Block The continuation building block extends the term data type to include a construct Catch v y. (Wadler [16] called this construct Callcc, but this was an error; it has the form of the original Scheme CATCH construct <ref> [14] </ref>. However, his function callccK was indeed a "callcc"- type operation.) The continuation building block also alters the value data type to be a Haskell function that, when given a continuation (a Haskell function that maps values to values) produces a value. See Figure 15.
Reference: [15] <author> Wadler, Philip. </author> <title> Comprehending monads. </title> <booktitle> In Proc. 1990 ACM Symposium on Lisp and Functional Programming. ACM SIGPLAN/SIGACT/ SIGART (Nice, </booktitle> <address> France, </address> <month> June </month> <year> 1990), </year> <pages> 61-77. </pages> <note> To appear in the journal Mathematical Structures in Computer Science. </note>
Reference-contexts: 1 Introduction I really liked Phil Wadler's work on monads <ref> [15, 16] </ref>. But I was not entirely satisfied with the methodology for constructing new interpreters by writing a single interpreter and then plugging in various monads. <p> Mark Jones has developed Gofer, a variant of Haskell that allows additional polymorphism through the use of type classes [4]. Gofer supports programming with multiple monads, including a cleaner version of the monad comprehension syntax proposed by Wadler <ref> [15] </ref>. Representing monads as a Gofer type class allows the Gofer type system to deduce which monad is intended in a unit or bind operation, avoiding the need to reify monads in the manner shown in this paper.
Reference: [16] <editor> Wadler, Philip. </editor> <booktitle> The essence of functional programming. In Proc. Nineteenth Annual ACM Symposium on Principles of Programming Languages. </booktitle> <institution> Association for Computing Machinery (Albuquerque, </institution> <address> New Mexico, </address> <month> January </month> <year> 1992), </year> <pages> 1-14. </pages>
Reference-contexts: 1 Introduction I really liked Phil Wadler's work on monads <ref> [15, 16] </ref>. But I was not entirely satisfied with the methodology for constructing new interpreters by writing a single interpreter and then plugging in various monads. <p> In the first two cases, the term is lifted to the top of the term type tower by applying unit tmt. The interpreter interpN and printer showvalN are pretty much what you would expect after reading Wadler's paper <ref> [16] </ref>. Interpreting a constant Con n results in an equivalent value Num n, lifted to the top of the value type tower by applying unit tmv. <p> It also alters the value data type to be a list of values. See Once again the implementation of the interpreter closely follows the work of Wadler <ref> [16] </ref>. Failure results in a list of no value, but lifted to the top of value type tower. Choice involves interpreting each of the subex-pressions and then appending the two lists of results. <p> See Figure 12. Once again the implementation of the interpreter closely follows the work of Wadler <ref> [16] </ref>. However, we choose to nest the definition of lookup within the definition of one case of interpCBV. Note that makefunCBV accepts a function f and composes it with unit tmv. <p> that it is truly call-by-name: the two references to x in the body of "x.(x+x) each perform the calculation (2|3) anew, resulting in a total of four possibilities. 13 The Continuation Building Block The continuation building block extends the term data type to include a construct Catch v y. (Wadler <ref> [16] </ref> called this construct Callcc, but this was an error; it has the form of the original Scheme CATCH construct [14]. <p> it has the following marvelous properties, and if you will only do things this way instead you'll have a much easier time of it." Which is an excellent relation for theory to hold to practice. 17 Comparison with Other Work This paper is essentially one long reformulation of Wadler's work <ref> [16] </ref> to add the crucial capability of composition. It owes its roots to all the work that Wadler cites, of course, notably that of Reynolds [10]. It is also in the spirit of my own earlier work with Sussman [13]. <p> In some cases they do not exist; that is, some of the putative monads that arise in the interpreters presented here are not really associative. This obstructs proofs of program equivalence of the kind discussed by Wadler <ref> [16] </ref> but otherwise seems to have little practical effect. Nevertheless, further investigation is warranted. Certain simple but important cases, such as lists and simple coproducts, are well-behaved; when provided as pseudomonads to the composition operator & the result obeys the monad associative law and therefore really is always a monad. <p> What if some pseudomonad did some nontrivial computation on terms? Presto! We have macros. There should be a macros building block. It would leave the value type alone but transform the term data type, perhaps according to some macro environment. How about error messages with positions? Wadler <ref> [16] </ref> remarks, "The parser will produce [At] terms as suitable." So the term type must be extended, but it turns out that it is easiest to modify the parser so that its input data type is not merely a string but a pair of a string (remaining to be parsed) and
Reference: [17] <author> Wadler, Philip. </author> <title> Theorems for free! In Proc. </title> <booktitle> FPCA '89: The Fourth International Conference on Functional Programming Languages and Computer Architecture. ACM SIGPLAN/SIGARCH and IFIP (London, </booktitle> <month> September </month> <year> 1989), </year> <pages> 347-359. </pages>
Reference-contexts: It should be clear that, even using only the small set of building blocks presented here, we can automatically construct more interpreters than you can shake a stick at. (I was sorely tempted to title this paper "Interpreters for Free!" <ref> [17] </ref> but thought better of it.) I have constructed many more interpreters than I have shown here and am working on other building blocks, for state, output, and string data, for example.
Reference: [18] <author> Waters, Richard C. </author> <title> XP: A Common Lisp Pretty Printing System. </title> <type> AI Memo 1102. </type> <institution> MIT Artificial Intelligence Laboratory (Cambridge, Massachusetts, </institution> <month> March </month> <year> 1989). </year>
Reference-contexts: Thus unrolling continues only if the gating case statement can first be eliminated by partial evaluation. The simplifier uses a fast and fairly effective pretty-printer after the style of Waters <ref> [18, 12] </ref>. 10 The Nondeterministic Building Block The nondeterministic building block extends the term data type to include a choice construct Amb x y (surface syntax (x|y)), where x and y are top-level terms, and a failure operation Fail (surface syntax fail).
Reference: [19] <author> Wegbreit, Ben, Holloway, Glenn, Spitzen, Jay, and Townley, Judy. </author> <title> ECL Programmer's Manual. </title> <type> Technical Report 23-74. </type> <institution> Harvard University Center for Research in Computing Technology (Cambridge, Massachusetts, </institution> <month> December </month> <year> 1974). </year>
Reference-contexts: In the end, I have to say that the type checking was more help than hindrance, especially in the construction of the continuations building block. I had the same experience with Haskell that I had twenty years ago with ECL <ref> [19] </ref> (which was, in effect, also a strongly-typed dialect of Lisp): almost always, once I made the type checker happy, the program was correct.
References-found: 19

