URL: http://www.win.tue.nl/win/cs/csr/csr93/93.24.ps
Refering-URL: http://www.win.tue.nl/win/cs/csr/csr93.html
Root-URL: http://www.win.tue.nl
Title: Pure Type Systems with definitions  
Author: Paula Severi Erik Poll 
Date: September 1993  
Abstract: In this paper, an extension of Pure Type Systems (PTS's ) to include definitions is presented and the meta-theory of these PTS's with definitions is treated in detail. We prove that all the properties of a PTS are preserved by the extension. 
Abstract-found: 1
Intro-found: 1
Reference: [Bar92a] <author> Henk Barendregt. </author> <title> Lambda calculi with types. </title> <editor> In D. M. Gabbai, S. Abramsky, and T. S.E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> volume 1. </volume> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference-contexts: Howewer, the proofs of strong normalization apply only to the particular type system that they consider and do not extend to other type systems. 2 Pure Type Systems In this chapter the concept of Pure Type System (PTS) is defined as in <ref> [Bar92a] </ref>. Only the notion of topsort and the system C 1 (see definitions 2.11 and 2.14) are not defined in [Bar92a]. Definition 2.1. <p> system that they consider and do not extend to other type systems. 2 Pure Type Systems In this chapter the concept of Pure Type System (PTS) is defined as in <ref> [Bar92a] </ref>. Only the notion of topsort and the system C 1 (see definitions 2.11 and 2.14) are not defined in [Bar92a]. Definition 2.1. <p> The usual parenthesis conventions for abstraction, application and product will be used (see <ref> [Bar92a] </ref>). Definition 2.3. Let be a; a 0 2 T . The concept "the term a fi-reduces to the term a 0 " is written as a ! fi a 0 and is defined by (x:A: a)b ! fi a [x := b] and the compatibility rules. <p> Theorem 2.6. (Church Rosser for fi-reduction) Let 2 C and a 2 T be such that a !! fi b and a !! fi c. Then there exists a term d 2 T such that b !! fi d and c !! fi d. The following properties are in <ref> [Bar92a] </ref>. Theorem 2.7. (Correctness of Types) Let 2 C and d; D 2 T be such that ` d : D. Then ` D : s or D = s. <p> The mapping F V : T ! P (V ) defined in <ref> [Bar92a] </ref> is extended to T ffi . Definition 3.2. <p> On the other hand, we do not know any strongly normalizing PTS S for which theorem 5.45 cannot be used to prove strong normalization of S ffi . In particular, all strongly normalizing PTS's given in <ref> [Bar92a] </ref> have a completion that is C 1 . 35
Reference: [Bar92b] <author> H.P. Barendregt. </author> <title> Lambda calculi with types. </title> <editor> In D. M. Gabbai, S. Abramsky, and T. S.E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> volume 1. </volume> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference-contexts: Worse still, proving strong normalization for particular PTS's extended with definitions is already a problem. The strong normalization proofs for particular type systems given in [Coq85], [Luo89a], [GN91], <ref> [Bar92b] </ref> cannot be extended in any obvious way. In this chapter, we show how strong normalization of a PTS extended with definitions follows from strong normalization of another (larger) PTS.
Reference: [Coq85] <author> Thierry Coquand. </author> <title> Une Theorie des Constructions. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1985. </year>
Reference-contexts: Howewer the local definitions complicate matters and it is an open problem whether extending an arbitrary PTS with defintions preserves strong normalization or not. Worse still, proving strong normalization for particular PTS's extended with definitions is already a problem. The strong normalization proofs for particular type systems given in <ref> [Coq85] </ref>, [Luo89a], [GN91], [Bar92b] cannot be extended in any obvious way. In this chapter, we show how strong normalization of a PTS extended with definitions follows from strong normalization of another (larger) PTS.
Reference: [Daa80] <author> D.T. Van Daalen. </author> <title> The Language Theory of Automath. </title> <type> PhD thesis, </type> <institution> University of Eind-hoven, </institution> <year> 1980. </year>
Reference-contexts: In the systems of AUTOMATH family (see [dB80]) definitions are considered as part of the formal language. The meta-theory of these systems -including strong normalization is treated in detail in <ref> [Daa80] </ref>. Howewer, the proofs of strong normalization apply only to the particular type system that they consider and do not extend to other type systems. 2 Pure Type Systems In this chapter the concept of Pure Type System (PTS) is defined as in [Bar92a].
Reference: [dB80] <author> N.G. de Bruijn. </author> <title> A survey of the project AUTOMATH. </title> <editor> In J.P. Seldin and J. R. Hindley, editors, To H. B. </editor> <booktitle> Curry: Essays in Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 579-606. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: This enables us to prove that for all strongly normalizing PTS's that we know the extensions with definitions are also strongly normalizing. In the systems of AUTOMATH family (see <ref> [dB80] </ref>) definitions are considered as part of the formal language. The meta-theory of these systems -including strong normalization is treated in detail in [Daa80].
Reference: [ea91] <author> G. Dowek et al. </author> <title> The Coq proof assistant version 5.6, users guide. </title> <institution> Rapport de Recherche 134, INRIA, </institution> <year> 1991. </year>
Reference-contexts: 1 Introduction A PTS does not provide the possibility to introduce a definition, i.e. an abbreviation (name) for a larger term which can be used several times in a program or proof. A definition mechanism is essential for practical use, and indeed implementantions of PTS's such as Coq <ref> [ea91] </ref>, Lego [LP92] or Constructor [Hel91] do provide such facility, even though the formal definition of the systems they implement do not. In this chapter, we introduce an extension of the PTS with (non-recursive) definitions.
Reference: [GN91] <author> H. Geuvers and M. J. Nederhof. </author> <title> A modular proof of strong normalization for the calculus of constructions. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(2) </volume> <pages> 155-189, </pages> <year> 1991. </year>
Reference-contexts: Worse still, proving strong normalization for particular PTS's extended with definitions is already a problem. The strong normalization proofs for particular type systems given in [Coq85], [Luo89a], <ref> [GN91] </ref>, [Bar92b] cannot be extended in any obvious way. In this chapter, we show how strong normalization of a PTS extended with definitions follows from strong normalization of another (larger) PTS. <p> We need to prove it for the case of variables which are not definitions. Singly Sorted Specifications. In this section we prove strengthening for DPTS's with singly sorted specifications. This proof is similar to the one in <ref> [GN91] </ref> for the case of Pure Type Systems. First we prove a weaker statememt than strengthening: Lemma 5.15.
Reference: [HBV76] <author> Jan Willem Klop Henk Barendregt, Jan Bergstra and Henri Volken. </author> <title> Degrees, reductions and representability in the lambda calculus. </title> <type> Technical Report 22, </type> <institution> University of Utrecht, </institution> <year> 1976. </year>
Reference-contexts: V (A) ae (y:A B [x 0 := d]) otherwise (y:A: a)[x 0 := d] = (y:A [x 0 := d] a) if x 2 A (y:A a [x 0 := d]) otherwise We define a strategy similar to the perpetual strategy F 1 on -terms and for fi-reduction (see <ref> [HBV76] </ref>). The leftmost ffi-redex of a term could be either a global or a local definition. If the leftmost redex is a variable x such that x=a:A is in the context then the strategy gives the term obtained by unfolding this occurence of x by its definiendum a.
Reference: [Hel91] <author> Leen Helmink. </author> <title> Goal directed proof construction in type theory. </title> <booktitle> In Procs. of the first Workshop on Logical Frameworks. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: A definition mechanism is essential for practical use, and indeed implementantions of PTS's such as Coq [ea91], Lego [LP92] or Constructor <ref> [Hel91] </ref> do provide such facility, even though the formal definition of the systems they implement do not. In this chapter, we introduce an extension of the PTS with (non-recursive) definitions. The extension of a PTS with definitions looks very harmless and this may not seem a topic worthy of investigation.
Reference: [Klo90] <author> J.W. Klop. </author> <title> Term Rewriting Systems. </title> <institution> Centre for Mathematics and Computer Science Amsterdam, </institution> <year> 1990. </year>
Reference-contexts: It follows from the fact that the Combinatorial Reduction System &lt; T ffi ; ! fi &gt; is orthogonal (see <ref> [Klo90] </ref>). Theorem 4.14. (Church Rosser for fi-reduction) Let 2 C ffi and a; a 1 ; a 2 2 T ffi such that ` a !! fi a 1 and ` a !! fi a 2 .
Reference: [LP92] <author> Zhaohui Luo and Robert Pollack. </author> <title> LEGO proof development system: User's manual. </title> <type> Technical Report ECS-LFCS-92-211, </type> <institution> LFCS-University of Edinburgh, </institution> <year> 1992. </year>
Reference-contexts: 1 Introduction A PTS does not provide the possibility to introduce a definition, i.e. an abbreviation (name) for a larger term which can be used several times in a program or proof. A definition mechanism is essential for practical use, and indeed implementantions of PTS's such as Coq [ea91], Lego <ref> [LP92] </ref> or Constructor [Hel91] do provide such facility, even though the formal definition of the systems they implement do not. In this chapter, we introduce an extension of the PTS with (non-recursive) definitions.
Reference: [Luo89a] <author> Z. Luo. </author> <title> ECC, the Extended Calculus of Constructions. </title> <booktitle> In Logic in Computer Science, </booktitle> <pages> pages 386-395. </pages> <publisher> IEEE, </publisher> <year> 1989. </year>
Reference-contexts: Worse still, proving strong normalization for particular PTS's extended with definitions is already a problem. The strong normalization proofs for particular type systems given in [Coq85], <ref> [Luo89a] </ref>, [GN91], [Bar92b] cannot be extended in any obvious way. In this chapter, we show how strong normalization of a PTS extended with definitions follows from strong normalization of another (larger) PTS.
Reference: [Luo89b] <author> Z. Luo. </author> <title> ECC, the Extended Calculus of Constructions. </title> <booktitle> In Logic in Computer Science, </booktitle> <pages> pages 386-395. </pages> <publisher> IEEE, </publisher> <year> 1989. </year>
Reference-contexts: Definition 2.14. The Calculus of Constructions extended with an infinite type hierarchy can be described by the following PTS: S IN R 8m 2 IN (m; 0; 0) & The system C 1 extended with strong -types and cumulativity is the system ECC (see <ref> [Luo89b] </ref>). We can see that C 1 is an extension of C and of HOL writing fl instead of 0, 2 instead of 1 and 4 instead of 3. Note that there is no topsort in C 1 . Definition 2.15. Let S be a PTS. <p> Theorem 2.16. 1. The system C 1 is fi-strongly normalizing. 2. The systems of the -cube are fi-strongly normalizing. 3. The system HOL is fi-strongly normalizing. 3 Proof: The system ECC is strongly normalizing (see <ref> [Luo89b] </ref>) and contains C 1 , the systems of the -cube and HOL. 2 Not all PTS's are strongly normalizing. Example 2.17. <p> The system C 1 extended with definitions, i.e. (C 1 ) ffi . 2. The calculus of constructions extended with definitions, i.e. C ffi . 3. The system of higher order logic extended with definitions, i.e. HOL ffi is strongly normal izing. Proof: The system ECC (see <ref> [Luo89b] </ref>) is strongly normalizing and contains C 1 . Then C 1 is strongly normalizing too. This system C 1 is a completion of itself. Hence it follows from the previous theorem that C 1 extended with definitions is strongly normalizing.
Reference: [vBJ93] <author> Bert van Benthem Jutting. </author> <title> Typing in pure type systems. </title> <journal> Information and Computation, </journal> <volume> 105 </volume> <pages> 30-41, </pages> <year> 1993. </year>
Reference-contexts: In <ref> [vBJ93] </ref> the set T is partitioned into the sets T V and T S . We follow the main branch of a term. If we find a term of the form x:A:B or a constant then the term will be in T S .
References-found: 14

