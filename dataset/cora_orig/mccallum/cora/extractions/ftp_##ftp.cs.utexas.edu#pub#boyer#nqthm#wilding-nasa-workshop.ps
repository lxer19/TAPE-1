URL: ftp://ftp.cs.utexas.edu/pub/boyer/nqthm/wilding-nasa-workshop.ps
Refering-URL: ftp://ftp.cs.utexas.edu/pub/boyer/nqthm/nqthm-bibliography.html
Root-URL: 
Email: mmwildin@collins.rockwell.com  
Title: Robust Computer System Proofs in PVS  
Author: Matthew M. Wilding 
Address: Cedar Rapids, IA 52498 USA  
Affiliation: Advanced Technology Center Rockwell Collins, Inc.  
Abstract: Practical formal verification of complex computer systems requires proof robustness and efficiency to protect against inevitable mistakes and system specification and design changes. PVS is a theorem-proving system based on higher-order logic with which we demonstrate the kind of robust code proofs needed for verification of realistic-sized computing systems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> William R. Bevier. </author> <title> Kit: A study in operating system verification. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(11) </volume> <pages> 1368-81, </pages> <month> Novem-ber </month> <year> 1989. </year>
Reference-contexts: Microcode for the Motorola CAP processor is proved to implement several algorithms useful for digital signal processing [6]. Others verifications involve a stack of verified systems [2], an operating system kernel <ref> [1] </ref>, code for simple real-time systems [18], and floating-point microcode [6, 15]. Each of these projects employed the theorem proving system Nqthm [3] or its successor ACL2 [8].
Reference: [2] <author> William R. Bevier, Warren A. Hunt Jr., J Strother Moore, and William D. Young. </author> <title> An approach to systems verification. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5(4) </volume> <pages> 411-428, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Compiled routines from the C string library and elsewhere targeted to the Motorola 68020 are proved to meet their specifications [5]. Microcode for the Motorola CAP processor is proved to implement several algorithms useful for digital signal processing [6]. Others verifications involve a stack of verified systems <ref> [2] </ref>, an operating system kernel [1], code for simple real-time systems [18], and floating-point microcode [6, 15]. Each of these projects employed the theorem proving system Nqthm [3] or its successor ACL2 [8].
Reference: [3] <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: Others verifications involve a stack of verified systems [2], an operating system kernel [1], code for simple real-time systems [18], and floating-point microcode [6, 15]. Each of these projects employed the theorem proving system Nqthm <ref> [3] </ref> or its successor ACL2 [8]. The logics supported by Nqthm and ACL2 are weaker than that supported by PVS: they do not conveniently support higher-order functions and quantification.
Reference: [4] <author> Robert S. Boyer and J Strother Moore. </author> <title> Mechanized formal reasoning about programs and computing machines. </title> <editor> In R. Veroff, editor, </editor> <booktitle> Automated Reasoning and Its Applications: Essays in Honor of Larry Wos. </booktitle> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: We present sm, a slightly modified version of John Rushby's formalization of Bob Boyer's and J Moore's simple machine-level language <ref> [4, 14] </ref>.
Reference: [5] <author> Robert S. Boyer and Yuan Yu. </author> <title> Automated proofs of object code for a widely used microprocessor. </title> <journal> Journal of the ACM, </journal> <volume> 43(1) </volume> <pages> 166-192, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: A Piton [11] program that plays the puzzle-game Nim is proved to play optimally [17]. Compiled routines from the C string library and elsewhere targeted to the Motorola 68020 are proved to meet their specifications <ref> [5] </ref>. Microcode for the Motorola CAP processor is proved to implement several algorithms useful for digital signal processing [6]. Others verifications involve a stack of verified systems [2], an operating system kernel [1], code for simple real-time systems [18], and floating-point microcode [6, 15]. <p> The proofs of these correctness statements are very simple owing to the creation of some simple reasoning support we have built into PVS and some simple conventions we follow in the expression of code correctness. The style of proof is similar in some respects to other verification projects, particularly <ref> [5, 11, 17] </ref>. These proofs are less sensitive to changes and therefore more robust. 2.1 A Simple Machine Interpreter In order to make the ideas of this paper concrete we introduce a PVS computing machine formalization that supports examples in later sections.
Reference: [6] <author> Bishop Brock, Matt Kaufmann, and J Strother Moore. </author> <title> ACL2 theorems about commercial microprocessors. </title> <editor> In Mandayam Srivas and Al-bert Camilleri, editors, </editor> <booktitle> Formal Methods in Computer-Aided Design - FMCAD, volume 1166 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Compiled routines from the C string library and elsewhere targeted to the Motorola 68020 are proved to meet their specifications [5]. Microcode for the Motorola CAP processor is proved to implement several algorithms useful for digital signal processing <ref> [6] </ref>. Others verifications involve a stack of verified systems [2], an operating system kernel [1], code for simple real-time systems [18], and floating-point microcode [6, 15]. Each of these projects employed the theorem proving system Nqthm [3] or its successor ACL2 [8]. <p> Microcode for the Motorola CAP processor is proved to implement several algorithms useful for digital signal processing [6]. Others verifications involve a stack of verified systems [2], an operating system kernel [1], code for simple real-time systems [18], and floating-point microcode <ref> [6, 15] </ref>. Each of these projects employed the theorem proving system Nqthm [3] or its successor ACL2 [8]. The logics supported by Nqthm and ACL2 are weaker than that supported by PVS: they do not conveniently support higher-order functions and quantification. <p> This style difference stems from a difference in proof system functionality. Nqthm/ACL2 provides execution of definitions and encourages concrete, efficient models. (An ACL2 interpreter for a commercial processor executes microcode programs faster than the executable processor model being used for microcode development <ref> [6] </ref>.) PVS cannot conveniently address code 0 move 2 0 1 move 3 0 2 move 4 1 3 sub 4 2 4 jumpz 4 12 5 incr 2 6 moverind 4 2 7 moverind 5 3 8 sub 5 4 9 jumpz 5 2 10 move 3 2 11 jump
Reference: [7] <author> Warren A. Hunt, Jr. and Bishop C. Brock. </author> <title> A formal HDL and its use in the FM9001 verification. </title> <editor> In C. A. R. Hoare and M. J. C. Gordon, editors, </editor> <booktitle> Mechanized Reasoning and Hardware Design, </booktitle> <pages> pages 35-47, </pages> <address> Hemel Hempstead, UK, 1992. </address> <publisher> Prentice Hall International Series in Computer Science. </publisher>
Reference-contexts: While sm memory is represented by a function, memory in the Nqthm and ACL2 code proof interpreters is represented by a particular datastructure implementation. For example, memory in the formal model of the FM9001 is represented by a binary tree of memory elements <ref> [7] </ref>. This style difference stems from a difference in proof system functionality.
Reference: [8] <author> Matthew Kaufmann and J S. Moore. ACL2: </author> <title> An industrial strength version of Nqthm. </title> <booktitle> In Proceedings of the Eleventh Annual Conference on Computer Assurance (COMPASS-96), </booktitle> <pages> pages 23-31, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: Others verifications involve a stack of verified systems [2], an operating system kernel [1], code for simple real-time systems [18], and floating-point microcode [6, 15]. Each of these projects employed the theorem proving system Nqthm [3] or its successor ACL2 <ref> [8] </ref>. The logics supported by Nqthm and ACL2 are weaker than that supported by PVS: they do not conveniently support higher-order functions and quantification.
Reference: [9] <author> Steven P. Miller, David A. Greve, Matthew M. Wilding, and Mandayam Srivas. </author> <title> Formal verification of the AAMP-FV microcode. </title> <type> Technical report, </type> <institution> Rockwell Collins, Inc., Cedar Rapids, IA, </institution> <year> 1997. </year> <note> DRAFT. </note>
Reference-contexts: The Rockwell AAMP5 and AAMP-FV are processor designs with microcoded instruction sets. Partial microcode correctness of these processors has been established using PVS <ref> [9, 10] </ref>. The hardware that executes microcode has been formalized in the PVS logic, and proofs that the microcode correctly implements some of the processor instruction sets have been constructed. <p> While the application of PVS to realistic-sized processors in the AAMP5 and AAMP-FV projects led to a partial verification of their microcode, the experience of building these proofs led the developers to the pragmatic realization that practical computer systems proofs must be robust <ref> [9] </ref>. That is, computer system proofs must be able to demonstrate correctness with minimal human assistance despite modest system or specification changes. Mistakes in proof development and changes to system design and specification are inevitable for realistic-sized verifications. <p> Mistakes in proof development and changes to system design and specification are inevitable for realistic-sized verifications. For example, during the AAMP-FV verification effort a change was made in the formal model related to memory address decoding <ref> [9] </ref>. This change caused every previously-constructed instruction correctness proof to fail even though the change had little to do with the substance of most of the proofs. Large programming projects use software engineering techniques to make software robust despite inevitable changes.
Reference: [10] <author> Steven P. Miller and Mandayam Srivas. </author> <title> Formal verification of the AAMP5 microprocessor: A case study in the industrial use of formal methods. </title> <booktitle> In WIFT'95: Workshop on Industrial-Strength Formal specification Techniques, </booktitle> <address> Boca Raton, FL, 1995. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: The Rockwell AAMP5 and AAMP-FV are processor designs with microcoded instruction sets. Partial microcode correctness of these processors has been established using PVS <ref> [9, 10] </ref>. The hardware that executes microcode has been formalized in the PVS logic, and proofs that the microcode correctly implements some of the processor instruction sets have been constructed.
Reference: [11] <author> J Strother Moore. </author> <title> Piton A Mechanically Veri--fied Assembly-Level Language. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1996. </year>
Reference-contexts: Large programming projects use software engineering techniques to make software robust despite inevitable changes. So too must large machine-checked proof projects use techniques to develop robust proofs. Various projects besides the AAMP5 and AAMP-FV verifications have established computer system correctness using mechanical proof. A Piton <ref> [11] </ref> program that plays the puzzle-game Nim is proved to play optimally [17]. Compiled routines from the C string library and elsewhere targeted to the Motorola 68020 are proved to meet their specifications [5]. <p> For example, when the verified processor FM8501 was redesigned to increase its wordsize the Nqthm proof of the modified processor correctness theorem worked with minimal human assistance <ref> [11] </ref>. Theorem provers based on first-order quantifier-free logic have been successful on larger system correctness problems in part because their mostly-automatic approach to guiding the theorem prover. This paper explores how to use PVS to reason about computer systems in a robust style. <p> The proofs of these correctness statements are very simple owing to the creation of some simple reasoning support we have built into PVS and some simple conventions we follow in the expression of code correctness. The style of proof is similar in some respects to other verification projects, particularly <ref> [5, 11, 17] </ref>. These proofs are less sensitive to changes and therefore more robust. 2.1 A Simple Machine Interpreter In order to make the ideas of this paper concrete we introduce a PVS computing machine formalization that supports examples in later sections.
Reference: [12] <author> S. Owre, N. Shankar, and J. M. Rushby. </author> <title> The PVS Specification Language (Beta Release). </title> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> February </month> <year> 1993. </year>
Reference-contexts: Mechanical theorem provers can help overcome both of these problems with formal proof: proofs generated with computer programs can be easier to produce and more reliable. PVS is a verification system for "specifying and verifying digital systems" <ref> [12, 13, 16] </ref>. It supports a specification language that is based on a simply typed higher-order logic, and provides a large number of prover commands that allow machine-checked reasoning about expressions in the logic.
Reference: [13] <author> S. Owre, N. Shankar, and J. M. Rushby. </author> <title> User Guide for the PVS Specification and Verification System (Beta Release). </title> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> February </month> <year> 1993. </year>
Reference-contexts: Mechanical theorem provers can help overcome both of these problems with formal proof: proofs generated with computer programs can be easier to produce and more reliable. PVS is a verification system for "specifying and verifying digital systems" <ref> [12, 13, 16] </ref>. It supports a specification language that is based on a simply typed higher-order logic, and provides a large number of prover commands that allow machine-checked reasoning about expressions in the logic.
Reference: [14] <author> John Rushby. </author> <type> Personal Communication, </type> <month> Novem-ber </month> <year> 1996. </year>
Reference-contexts: We present sm, a slightly modified version of John Rushby's formalization of Bob Boyer's and J Moore's simple machine-level language <ref> [4, 14] </ref>.
Reference: [15] <author> David M. Russinoff. </author> <title> A mechanically checked proof of IEEE compliance of the AMD K5 floating-point square root microcode. </title> <note> Available as www.onr.com/user/russ/david/fsqrt.html, August 1996. </note>
Reference-contexts: Microcode for the Motorola CAP processor is proved to implement several algorithms useful for digital signal processing [6]. Others verifications involve a stack of verified systems [2], an operating system kernel [1], code for simple real-time systems [18], and floating-point microcode <ref> [6, 15] </ref>. Each of these projects employed the theorem proving system Nqthm [3] or its successor ACL2 [8]. The logics supported by Nqthm and ACL2 are weaker than that supported by PVS: they do not conveniently support higher-order functions and quantification.
Reference: [16] <author> N. Shankar, S. Owre, and J. M. Rushby. </author> <title> The PVS Proof Checker: A Reference Manual (Beta Release). </title> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> February </month> <year> 1993. </year>
Reference-contexts: Mechanical theorem provers can help overcome both of these problems with formal proof: proofs generated with computer programs can be easier to produce and more reliable. PVS is a verification system for "specifying and verifying digital systems" <ref> [12, 13, 16] </ref>. It supports a specification language that is based on a simply typed higher-order logic, and provides a large number of prover commands that allow machine-checked reasoning about expressions in the logic.
Reference: [17] <author> Matthew Wilding. </author> <title> A mechanically verified application for a mechanically verified environment. In Costas Courcoubetis, editor, </title> <booktitle> Computer-Aided Verification - CAV '93, volume 697 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: So too must large machine-checked proof projects use techniques to develop robust proofs. Various projects besides the AAMP5 and AAMP-FV verifications have established computer system correctness using mechanical proof. A Piton [11] program that plays the puzzle-game Nim is proved to play optimally <ref> [17] </ref>. Compiled routines from the C string library and elsewhere targeted to the Motorola 68020 are proved to meet their specifications [5]. Microcode for the Motorola CAP processor is proved to implement several algorithms useful for digital signal processing [6]. <p> The proofs of these correctness statements are very simple owing to the creation of some simple reasoning support we have built into PVS and some simple conventions we follow in the expression of code correctness. The style of proof is similar in some respects to other verification projects, particularly <ref> [5, 11, 17] </ref>. These proofs are less sensitive to changes and therefore more robust. 2.1 A Simple Machine Interpreter In order to make the ideas of this paper concrete we introduce a PVS computing machine formalization that supports examples in later sections.
Reference: [18] <author> Matthew Wilding. </author> <title> Machine-Checked Real-Time System Verification. </title> <type> PhD thesis, </type> <institution> University of Texas at Austin, </institution> <month> May </month> <year> 1996. </year> <note> Also available as ftp.cs.utexas.edu/pub/boyer/wilding-diss.ps.gz. Acknowledgements I thank David Greve and David Hardin of the Advanced Technology Center for many suggestions that improved this paper considerably. This work was accomplished under the Rock-well Collins IR&D program. </note>
Reference-contexts: Microcode for the Motorola CAP processor is proved to implement several algorithms useful for digital signal processing [6]. Others verifications involve a stack of verified systems [2], an operating system kernel [1], code for simple real-time systems <ref> [18] </ref>, and floating-point microcode [6, 15]. Each of these projects employed the theorem proving system Nqthm [3] or its successor ACL2 [8]. The logics supported by Nqthm and ACL2 are weaker than that supported by PVS: they do not conveniently support higher-order functions and quantification.
References-found: 18

