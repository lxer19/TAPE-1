URL: http://www.csl.sri.com/reports/postscript/combined.ps.gz
Refering-URL: http://www.csl.sri.com/reports/postscript/
Root-URL: 
Title: Combining System Properties: A Cautionary Example and Formal Examination 1  
Author: John Rushby 
Note: 1 This research was supported by the US Naval Research Laboratory under contract N00014-92-C-2177.  
Date: June 27, 1995  
Address: Menlo Park CA 94025 USA  
Affiliation: Computer Science Laboratory SRI International  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> K. A. Bartlett, R. A. Scantlebury, and P. T. Wilkinson. </author> <title> A note on reliable full-duplex transmission over half-duplex links. </title> <journal> Communications of the ACM, 12(5):260, </journal> <volume> 261, </volume> <month> May </month> <year> 1969. </year>
Reference-contexts: In this chapter, I present the protocols informally and explain the difficulties in combining them. 2.1 Fault Tolerance: The Alternating Bit Protocol The alternating bit protocol (ABP) is one of the simplest and earliest protocols designed to overcome message loss in the underlying communications medium <ref> [1] </ref>. It operates as follows. Sender: The sender attaches a single control bit to each message, alternating the value of the bit on successive messages. The sender transmits the message and its attached control bit and waits for a reply message carrying the same control bit. <p> boolean; begin return p.data = empty_msg; end; procedure move (var c:channel); -- Moves the messages in c along by one -- If efficiency matters, would be better -- to use pointers in a circular queue begin for i := N to 2 by -1 do c [i]:=c [i-1]; endfor; c <ref> [1] </ref> := empty_packet; end; rule "move msg channel" is_empty_packet (msg_channel [N]) ==&gt; begin move (msg_channel); end; rule "move ack channel" is_empty_packet (ack_channel [N]) ==&gt; begin move (ack_channel); end; Notice that the procedure move overwrites the packet at position N and does not check that it is an empty packet. <p> will specify these operations for the physical channels only. 18 type service: enum fabp, physical_m, physical_ag; function rtr (svc: service): boolean; begin switch svc case physical_m: return !is_empty_packet (msg_channel [N]); case physical_a: return !is_empty_packet (ack_channel [N]); end; function rts (svc: service): boolean; begin switch svc case physical_m: return is_empty_packet (msg_channel <ref> [1] </ref>); case physical_a: return is_empty_packet (ack_channel [1]); end; procedure send (svc: service; p: packet); begin assert rts (svc); switch svc case physical_m: msg_channel [1] := p; case physical_a: ack_channel [1] := p; end; procedure receive (svc: service; var p: packet); begin assert rtr (svc); switch svc case physical_m: p := msg_channel <p> physical channels only. 18 type service: enum fabp, physical_m, physical_ag; function rtr (svc: service): boolean; begin switch svc case physical_m: return !is_empty_packet (msg_channel [N]); case physical_a: return !is_empty_packet (ack_channel [N]); end; function rts (svc: service): boolean; begin switch svc case physical_m: return is_empty_packet (msg_channel <ref> [1] </ref>); case physical_a: return is_empty_packet (ack_channel [1]); end; procedure send (svc: service; p: packet); begin assert rts (svc); switch svc case physical_m: msg_channel [1] := p; case physical_a: ack_channel [1] := p; end; procedure receive (svc: service; var p: packet); begin assert rtr (svc); switch svc case physical_m: p := msg_channel [N]; msg_channel [N] := empty_packet; case <p> svc case physical_m: return !is_empty_packet (msg_channel [N]); case physical_a: return !is_empty_packet (ack_channel [N]); end; function rts (svc: service): boolean; begin switch svc case physical_m: return is_empty_packet (msg_channel <ref> [1] </ref>); case physical_a: return is_empty_packet (ack_channel [1]); end; procedure send (svc: service; p: packet); begin assert rts (svc); switch svc case physical_m: msg_channel [1] := p; case physical_a: ack_channel [1] := p; end; procedure receive (svc: service; var p: packet); begin assert rtr (svc); switch svc case physical_m: p := msg_channel [N]; msg_channel [N] := empty_packet; case physical_a: p := ack_channel [N]; ack_channel [N] := empty_packet; end; Our task now is to use these <p> [N]); case physical_a: return !is_empty_packet (ack_channel [N]); end; function rts (svc: service): boolean; begin switch svc case physical_m: return is_empty_packet (msg_channel <ref> [1] </ref>); case physical_a: return is_empty_packet (ack_channel [1]); end; procedure send (svc: service; p: packet); begin assert rts (svc); switch svc case physical_m: msg_channel [1] := p; case physical_a: ack_channel [1] := p; end; procedure receive (svc: service; var p: packet); begin assert rtr (svc); switch svc case physical_m: p := msg_channel [N]; msg_channel [N] := empty_packet; case physical_a: p := ack_channel [N]; ack_channel [N] := empty_packet; end; Our task now is to use these low-level primitives to construct higher-level opera <p> and receive functions to the case of the ABP service. 20 function rtr (svc: service): boolean; begin switch svc case physical_m: return !is_empty_packet (msg_channel [N]); case physical_a: return !is_empty_packet (ack_channel [N]); case abp: return !is_empty_packet (rval_a); end; function rts (svc: service): boolean; begin switch svc case physical_m: return is_empty_packet (msg_channel <ref> [1] </ref>); case physical_a: return is_empty_packet (ack_channel [1]); case abp: return is_empty_packet (sval_a); end; procedure send (svc: service; p: packet); begin assert rts (svc); switch svc case physical_m: msg_channel [1] := p; case physical_a: ack_channel [1] := p; case abp: sval_a := p; sbit_a := next_bit (sbit_a); sval_a.control := sbit_a; end; procedure <p> of the ABP service. 20 function rtr (svc: service): boolean; begin switch svc case physical_m: return !is_empty_packet (msg_channel [N]); case physical_a: return !is_empty_packet (ack_channel [N]); case abp: return !is_empty_packet (rval_a); end; function rts (svc: service): boolean; begin switch svc case physical_m: return is_empty_packet (msg_channel <ref> [1] </ref>); case physical_a: return is_empty_packet (ack_channel [1]); case abp: return is_empty_packet (sval_a); end; procedure send (svc: service; p: packet); begin assert rts (svc); switch svc case physical_m: msg_channel [1] := p; case physical_a: ack_channel [1] := p; case abp: sval_a := p; sbit_a := next_bit (sbit_a); sval_a.control := sbit_a; end; procedure receive (svc: service; var p: packet); <p> !is_empty_packet (ack_channel [N]); case abp: return !is_empty_packet (rval_a); end; function rts (svc: service): boolean; begin switch svc case physical_m: return is_empty_packet (msg_channel <ref> [1] </ref>); case physical_a: return is_empty_packet (ack_channel [1]); case abp: return is_empty_packet (sval_a); end; procedure send (svc: service; p: packet); begin assert rts (svc); switch svc case physical_m: msg_channel [1] := p; case physical_a: ack_channel [1] := p; case abp: sval_a := p; sbit_a := next_bit (sbit_a); sval_a.control := sbit_a; end; procedure receive (svc: service; var p: packet); begin assert rtr (svc); switch svc case physical_m: p := msg_channel [N]; msg_channel [N] := empty_packet; case physical_a: p := ack_channel [N]; <p> !is_empty_packet (rval_a); end; function rts (svc: service): boolean; begin switch svc case physical_m: return is_empty_packet (msg_channel <ref> [1] </ref>); case physical_a: return is_empty_packet (ack_channel [1]); case abp: return is_empty_packet (sval_a); end; procedure send (svc: service; p: packet); begin assert rts (svc); switch svc case physical_m: msg_channel [1] := p; case physical_a: ack_channel [1] := p; case abp: sval_a := p; sbit_a := next_bit (sbit_a); sval_a.control := sbit_a; end; procedure receive (svc: service; var p: packet); begin assert rtr (svc); switch svc case physical_m: p := msg_channel [N]; msg_channel [N] := empty_packet; case physical_a: p := ack_channel [N]; ack_channel [N] := empty_packet; case abp: <p> Then we extend rtr and rts. function rtr (svc: service): boolean; begin switch svc case physical_m: return !is_empty_packet (msg_channel [N]); case physical_a: return !is_empty_packet (ack_channel [N]); case abp: return !is_empty_packet (rval_a); case cp: return !is_empty_packet (rval_c); end; function rts (svc: service): boolean; begin switch svc case physical_m: return is_empty_packet (msg_channel <ref> [1] </ref>); case physical_a: return is_empty_packet (ack_channel [1]); case abp: return is_empty_packet (sval_a); case cp: return is_empty_packet (sval_c); end; And, similarly, we extend send and receive. 27 procedure send (svc: service; p: packet); begin assert rts (svc); switch svc case physical_m: msg_channel [1] := p; case physical_a: ack_channel [1] := p; case <p> function rtr (svc: service): boolean; begin switch svc case physical_m: return !is_empty_packet (msg_channel [N]); case physical_a: return !is_empty_packet (ack_channel [N]); case abp: return !is_empty_packet (rval_a); case cp: return !is_empty_packet (rval_c); end; function rts (svc: service): boolean; begin switch svc case physical_m: return is_empty_packet (msg_channel <ref> [1] </ref>); case physical_a: return is_empty_packet (ack_channel [1]); case abp: return is_empty_packet (sval_a); case cp: return is_empty_packet (sval_c); end; And, similarly, we extend send and receive. 27 procedure send (svc: service; p: packet); begin assert rts (svc); switch svc case physical_m: msg_channel [1] := p; case physical_a: ack_channel [1] := p; case abp: sval_a := p; sbit_a := <p> boolean; begin switch svc case physical_m: return is_empty_packet (msg_channel <ref> [1] </ref>); case physical_a: return is_empty_packet (ack_channel [1]); case abp: return is_empty_packet (sval_a); case cp: return is_empty_packet (sval_c); end; And, similarly, we extend send and receive. 27 procedure send (svc: service; p: packet); begin assert rts (svc); switch svc case physical_m: msg_channel [1] := p; case physical_a: ack_channel [1] := p; case abp: sval_a := p; sbit_a := next_bit (sbit_a); sval_a.control := sbit_a; case cp: sval_c := p; sval_c.checksum := 1; end; procedure receive (svc: service; var p: packet); begin assert rtr (svc); switch svc case physical_m: p := msg_channel [N]; msg_channel [N] <p> return is_empty_packet (msg_channel <ref> [1] </ref>); case physical_a: return is_empty_packet (ack_channel [1]); case abp: return is_empty_packet (sval_a); case cp: return is_empty_packet (sval_c); end; And, similarly, we extend send and receive. 27 procedure send (svc: service; p: packet); begin assert rts (svc); switch svc case physical_m: msg_channel [1] := p; case physical_a: ack_channel [1] := p; case abp: sval_a := p; sbit_a := next_bit (sbit_a); sval_a.control := sbit_a; case cp: sval_c := p; sval_c.checksum := 1; end; procedure receive (svc: service; var p: packet); begin assert rtr (svc); switch svc case physical_m: p := msg_channel [N]; msg_channel [N] := empty_packet; case physical_a: p :=
Reference: [2] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, D. L. Dill, and L. J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <journal> Information and Computation, </journal> <volume> 98(2) </volume> <pages> 142-170, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: the ability to explore very large numbers of states in a reasonable time that makes state exploration techniques useful: brute-force methods can often explore millions of states in a few hours, while symbolic methods based on Binary Decision Diagrams (BDDs) can explore even larger systems (numbers such as 10 20 <ref> [2] </ref> 13 and 10 1300 [4] appear in the literature). Nonetheless, it is often necessary to con-sciously "downscale" a system description in order to reduce it to a size that can be explored effectively.
Reference: [3] <author> K. Mani Chandy and Jayadev Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1988. </year>
Reference-contexts: A second objective of this report is to exemplify the use of formal methods in examining the behavior of systems under different assumptions. This topic was also examined by Peleska, but whereas he used CSP [6] and the FDR model checker [5], I use a notation based on Unity <ref> [3] </ref> and the Mur state exploration tool [8]. 1 2 Chapter 2 Informal Description and Analysis A protocol specification must describe the service to be provided, the assumptions on the environment in which it executes, and the procedural rules governing the behavior of the participants to the protocol and the messages <p> In the following section, I will describe exploration of ABP using the Mur state exploration system. 3.1 Exploring ABP with Mur Mur is a state exploration system developed by David Dill's group at Stanford University [8]. Mur "programs" are written in a language based on Unity <ref> [3] </ref>, with a C-like syntax. The Mur compiler generates a C++ program, which is then compiled and run to perform brute-force state exploration on the Mur program presented to the compiler. The states of a Mur program consist of all possible assignments to the variables appearing in the program.
Reference: [4] <author> Edmund M. Clarke, Orna Grumberg, and David E. </author> <title> Long. Model checking and abstraction. </title> <booktitle> In 19th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 343-354, </pages> <address> Albuquerque, NM, </address> <month> January </month> <year> 1992. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: large numbers of states in a reasonable time that makes state exploration techniques useful: brute-force methods can often explore millions of states in a few hours, while symbolic methods based on Binary Decision Diagrams (BDDs) can explore even larger systems (numbers such as 10 20 [2] 13 and 10 1300 <ref> [4] </ref> appear in the literature). Nonetheless, it is often necessary to con-sciously "downscale" a system description in order to reduce it to a size that can be explored effectively.
Reference: [5] <editor> Failures Divergence Refinement: </editor> <title> User Manual and Tutorial. Formal Systems (Europe) Ltd, </title> <publisher> Oxford, </publisher> <address> UK, 1.2fi edition, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: A second objective of this report is to exemplify the use of formal methods in examining the behavior of systems under different assumptions. This topic was also examined by Peleska, but whereas he used CSP [6] and the FDR model checker <ref> [5] </ref>, I use a notation based on Unity [3] and the Mur state exploration tool [8]. 1 2 Chapter 2 Informal Description and Analysis A protocol specification must describe the service to be provided, the assumptions on the environment in which it executes, and the procedural rules governing the behavior of
Reference: [6] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall International Series in Computer Science. Prentice Hall, </publisher> <address> Hemel Hempstead, UK, </address> <year> 1985. </year>
Reference-contexts: A second objective of this report is to exemplify the use of formal methods in examining the behavior of systems under different assumptions. This topic was also examined by Peleska, but whereas he used CSP <ref> [6] </ref> and the FDR model checker [5], I use a notation based on Unity [3] and the Mur state exploration tool [8]. 1 2 Chapter 2 Informal Description and Analysis A protocol specification must describe the service to be provided, the assumptions on the environment in which it executes, and the
Reference: [7] <author> Norman C. Hutchinson and Larry L. Peterson. </author> <title> The x-Kernel: An architecture for implementing network protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-76, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: This approach is already being explored in the fields of protocols and fault tolerance, where Schlichting, and others are developing "RISC-like" building blocks for tailoring fault-tolerant systems to particular constraints and assumptions <ref> [7, 9] </ref>.
Reference: [8] <author> Ralph Melton and David L. Dill. </author> <title> Mur Annotated Reference Manual. </title> <institution> Computer Science Department, Stanford University, Stanford, </institution> <address> CA, </address> <month> March </month> <year> 1993. </year>
Reference-contexts: This topic was also examined by Peleska, but whereas he used CSP [6] and the FDR model checker [5], I use a notation based on Unity [3] and the Mur state exploration tool <ref> [8] </ref>. 1 2 Chapter 2 Informal Description and Analysis A protocol specification must describe the service to be provided, the assumptions on the environment in which it executes, and the procedural rules governing the behavior of the participants to the protocol and the messages exchanged between them. <p> In the following section, I will describe exploration of ABP using the Mur state exploration system. 3.1 Exploring ABP with Mur Mur is a state exploration system developed by David Dill's group at Stanford University <ref> [8] </ref>. Mur "programs" are written in a language based on Unity [3], with a C-like syntax. The Mur compiler generates a C++ program, which is then compiled and run to perform brute-force state exploration on the Mur program presented to the compiler.
Reference: [9] <author> Shivakant Mishra, Larry L. Peterson, and Richard D. Schlichting. </author> <title> Consul: A communication substrate for fault-tolerant distributed programs. </title> <journal> Distributed Systems Engineering Journal, </journal> <volume> 1(2) </volume> <pages> 87-103, </pages> <month> December </month> <year> 1993. </year> <month> 34 </month>
Reference-contexts: This approach is already being explored in the fields of protocols and fault tolerance, where Schlichting, and others are developing "RISC-like" building blocks for tailoring fault-tolerant systems to particular constraints and assumptions <ref> [7, 9] </ref>.
Reference: [10] <author> Jan Peleska. </author> <title> On a unified formal approach for the development of fault-tolerant and secure systems. </title> <editor> In Hans Rischel, editor, </editor> <booktitle> Nordic Seminar on Dependable Computing Systems, </booktitle> <pages> pages 69-80, </pages> <address> Lyngby, Denmark, </address> <month> August </month> <year> 1994. </year> <institution> Technical University of Denmark. </institution>
Reference-contexts: In this report, I focus on a very small tutorial example. Suppose we know how to satisfy each of two requirements separately, how might we satisfy them jointly? The example I use is based on one by Jan Peleska <ref> [10] </ref>, who presents one communications protocol that can tolerate message loss and another that can defeat message corruption, and considers how to develop a protocol that can deal with both problems simultaneously. <p> Peleska <ref> [10] </ref> argues that this means we cannot expect to solve the overall problem by stacking two individually inadequate protocols, but must design a protocol to deal specifically with the combined threat. This is certainly one approach, but I believe there is a better one.
Reference: [11] <author> John Rushby. </author> <title> Critical system properties: Survey and taxonomy. </title> <type> Technical Report SRI-CSL-93-1, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> May </month> <year> 1993. </year> <title> Also available in Reliability Engineering and System Safety, </title> <journal> Vol. </journal> <volume> 43, No. 2, </volume> <pages> pp. 189-219, </pages> <year> 1994. </year> <month> 35 </month>
Reference-contexts: Introduction In an earlier report <ref> [11] </ref>, I described some of the characteristics of systems that are designed to satisfy critical properties such as dependability, safety, security, and real-time operation, and I discussed some of the techniques used in developing and providing assurance for these systems.
References-found: 11

