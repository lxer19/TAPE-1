URL: http://www.cs.washington.edu/homes/douglas/publish/thesis.ps.gz
Refering-URL: http://www.cs.washington.edu/homes/douglas/publish/index.html
Root-URL: http://www.cs.washington.edu
Title: Java Control Flow Obfuscation  
Author: Douglas Low 
Degree: A thesis submitted in partial fulfilment of the requirements for the degree of Master of Science in Computer Science  
Date: June 3, 1998  
Affiliation: University of Auckland  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Neil Aggarwal. </author> <title> A Java bytecode obfuscator, </title> <month> May </month> <year> 1997. </year> <note> http://www. monmouth.com/~neil/Obfuscate.html. </note>
Reference-contexts: This is a form of layout transformation (Section 3.3.1). These kinds of transformations make the Java program more difficult to understand but do not hide control flow. In addition to identifier scrambling, the Java obfuscator written by Aggarwal <ref> [1] </ref> performs the layout transformation of removing debugging information. Obfuscators have been written for languages other than Java. The C Shroud system is a source code obfuscator for the language C. It performs layout transformations like removing comments and indentation, and scrambling identifiers. <p> This class includes transformations such as inherent preventive transformations, which make particular deobfuscation techniques difficult to employ. Existing obfuscators fit well into our classification scheme. Crema and Jobe perform the layout transformation of scrambling identifier names in Java class files. Aggarwal's Java obfuscator <ref> [1] </ref> also scrambles identifier names and removes the debugging information from a Java class file. This transformation is another kind of layout obfuscation because debugging information is not required to execute a program. The HoseMocha obfuscator uses a different approach, exploiting a weakness in the Mocha decompiler. <p> THE JAVA BYTECODE INSTRUCTION SET 57 5.4.2 Push constant instructions Operand Stack Instruction Args Before After Description bipush B B Push 8-bit signed integer B. iconst n n Push int constant n; 0 n 5. fconst n n Push float constant n; n 2 <ref> [0; 1; 2] </ref>. ldc 1 I CP 8 CP [I] Push the item from the constant pool. ldc2 w I CP 16 CP [I] Push the long/double from the constant pool. The short instructions to push constants onto the stack execute quickly. These instructions include iconst n and fconst n.
Reference: [2] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers, Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year> <note> ISBN 0-201-10088-6. </note>
Reference-contexts: add some simple if-statements (i.e. predicates) to P : main () f S 1 ; g ) main () f S 1 ; S 2 ; g Such transformations are virtually useless | they can be easily undone by simple automatic techniques such as peephole optimisations (see Aho et al. <ref> [2] </ref>, pp. 554-558). Constant folding will replace the boolean expression (5==2) with false. Now it is obvious that S 3 will never be executed, hence this dead code can be eliminated, along with the statement if (false) S 3 . <p> This means that the Java bytecode can express arbitrary control flow, whereas the Java language can only (easily) express structured control flow. We say that the control flow graphs produced from Java programs will always be reducible, but Java bytecode can express non-reducible flow graphs (see Aho et al. <ref> [2] </ref>, pp. 606-608). The main feature of reducible flow graphs is that there are no jumps into the middle of a loop. Since expressing non-reducible flow graphs becomes very awkward in languages without gotos, we construct a transformation which converts a reducible flow graph to a non-reducible one. <p> THE JAVA BYTECODE INSTRUCTION SET 57 5.4.2 Push constant instructions Operand Stack Instruction Args Before After Description bipush B B Push 8-bit signed integer B. iconst n n Push int constant n; 0 n 5. fconst n n Push float constant n; n 2 <ref> [0; 1; 2] </ref>. ldc 1 I CP 8 CP [I] Push the item from the constant pool. ldc2 w I CP 16 CP [I] Push the long/double from the constant pool. The short instructions to push constants onto the stack execute quickly. These instructions include iconst n and fconst n. <p> In the bytecode, i, j and k are local variables 1, 2 and 3 respectively. at address 8. The standard algorithm for grouping a sequence of instructions into basic blocks relies on identifying which instructions are leaders (see Aho et al. <ref> [2] </ref>, pg. 528). An instruction is a leader if: * it is the first instruction in the sequence, or * it is the destination of a branch instruction, or * it follows a branch instruction. 64 CHAPTER 5. <p> This information is required to apply control flow obfuscations to a program. In Section 5.6.2 we discussed why the standard control flow graph building algorithm (see Aho et al. <ref> [2] </ref>, pg. 528) was unsuitable for languages that contain a C-style conditional operator. The algorithm to build a control flow graph is in Figure 7.2. M is the method that is being analysed. <p> For example, a class obtains its classRefs set by performing a union operation on all the classRefs sets of the methods that the class defines. The loops feature for method source code objects is determined using the algorithm for constructing natural loops (see Aho et al. <ref> [2] </ref>, pg. 604). The information in the loops feature allows our obfuscator to apply obfuscations such as inserting a branch into a loop. <p> The information in the loops feature allows our obfuscator to apply obfuscations such as inserting a branch into a loop. The algorithm for calculating the locals feature for basic block (bb) source code objects is based on the iterative algorithm for calculating reaching definitions (see Aho et al. <ref> [2] </ref>, pg. 625). The locals feature allows our obfuscator to generate code that uses the local variables of a method. A local variable needs to be initialised before it is first accessed. Also, the variable must be accessed with an operator which has a matching type. <p> However, this implementation fulfils the requirement that given a source code object S, we can determine the appropriateness of each obfuscating transformation applied to S. The control flow graph building algorithm is quite complicated and executes slowly. It differs from the standard algorithm (see Aho et al. <ref> [2] </ref>, pg. 528) due to the need to handle the conditional operator correctly. The standard algorithm breaks up the instruction implementing the conditional operator into several basic blocks. The operand stack is not empty on exit from some of these basic blocks. <p> Performing code motion on these types of expressions is a standard global optimisation performed by compilers and is known as hoisting (see Aho et al. <ref> [2] </ref>, pg. 714). We did not implement this transformation in our obfuscator due to lack of time. However, we did apply the transformation by hand to small examples of Java code.
Reference: [3] <author> David Aucsmith. </author> <title> Tamper-resistant software: An implementation. </title> <booktitle> In Lecture Notes in Computer Science No. </booktitle> <volume> 1174, </volume> <pages> pages 317-333, </pages> <month> May/June </month> <year> 1996. </year>
Reference-contexts: On a personal computer (PC), software is completely accessible for observation and modification by the user. This is a similar problem with which Java bytecodes are faced. The issue of protecting software on PC platforms has been addressed by Aucsmith <ref> [3] </ref>. This scheme uses a self-modifying, self-decrypting and installation unique segment of code (Integrity Verification Kernel). The code segment communicates with other such code segments to create an Interlocking Trust model. The code segments verify each others integrity.
Reference: [4] <author> David F. Bacon, Susan L. Graham, and Oliver J. Sharp. </author> <title> Compiler transformations for high-performance computing. </title> <journal> ACM Computing Surveys, </journal> <volume> 26 </volume> (4):345-420, December 1994. http://www.acm.org/pubs/toc/Abstracts/ 0360-0300/197406.html. 
Reference-contexts: Note that some of the code obfuscations discussed are traditional compiler optimisa-tions | we just use these optimisations for a different purpose. Array and loop reordering, and procedure inlining are examples of such optimisations <ref> [4] </ref>. 3.3.1 Layout obfuscation Layout obfuscations affect the information in the program code that is unnecessary to its execution. These obfuscations are typically trivial and reduce the amount of information available to a human reader. Examples include scrambling identifier names and removing comments and debugging information. 3.3. <p> Thus, we randomise the placement of any item, wherever possible, in the source application. For some types of items, such as methods within classes, this is trivial. In other cases, such as statements within basic blocks, a data dependency analysis (see <ref> [4, 53] </ref>) will have to be performed to determine which reorderings are legal. These transformations have low potency (they don't add much obscurity to the program) but their resilience is high, in many cases one-way. <p> In this way, unrelated statements that were previously part of several different procedures are brought together into bogus procedural abstractions. In certain cases it is also possible to reorder loops, for example by running them backwards. Such loop reversal transformations are common in high-performance compilers <ref> [4] </ref>. 4.6. DISCUSSION 47 4.6 Discussion We have given an overview of control aggregation and ordering obfuscations in this chapter but they need to be studied in more depth.
Reference: [5] <author> Joseph A. Bank. </author> <title> Java security. </title> <address> http://swissnet.ai.mit.edu/~jbank/ javapaper/javapaper.html, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: There is a further problem with transmitting only native code. Unlike Java bytecodes, native code is not subject to bytecode verification before execution [32]. So native code cannot be run with a guarantee that it will execute without performing illegal actions such as corrupting a user's files <ref> [5] </ref>. This is not a problem 2.5. PROTECTION THROUGH CODE OBFUSCATION 9 if the developer is a trusted member of the community | the user may accept assurances by the developer that the application is safe. <p> The problem with this distribution method is that the recipient may not be able to trust the program. The program may corrupt the user's system, either accidentally through poor programming, or deliberately, in the case of viruses. For this reason, Java bytecodes are subjected to rigorous bytecode verification <ref> [5] </ref>. This verification occurs before any potentially unsafe code is executed. The use of static as opposed to dynamic checking allows for greater run-time efficiency.
Reference: [6] <author> Alan Bertenshaw. </author> <title> String obfuscation in java. </title> <institution> Undergraduate project in Computer Science, The University of Auckland, </institution> <year> 1997. </year>
Reference-contexts: Instead, we could use a function f (i) to determine the position of the ith element in the list. Data obfuscations will not be discussed further in this thesis. For additional information about data obfuscation, see Bertenshaw <ref> [6] </ref> and Collberg et al. [10]. 3.3.3 Control flow obfuscation Control flow obfuscations affect the control flow of the program. Again we can classify them further according to what operation they perform (Figure 3.4). Chapter 4 covers control flow obfuscation in detail. 16 CHAPTER 3. <p> However, there is much more work to be performed in this area. Of particular interest are opaque constructs, which are covered in depth in Collberg et al. [11]. This thesis has given a broad outline of data obfuscations and preventive transformations. Further work on data obfuscations is in Bertenshaw <ref> [6] </ref> and Collberg et al. [10]. A P P E N D I X A Obfuscation Modules "I am a brain, Watson. The rest of me is a mere appendix." The Marazin Stone, Sir Arthur Conan Doyle An obfuscating transformation module is defined by a Prolog source code file.
Reference: [7] <author> Shyam R. Chidamber and Chris F. Kemerer. </author> <title> A metrics suite for object oriented design. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(6) </volume> <pages> 476-493, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: updated by F . 6 Data Structure Complexity Munson [38] E (P ) increases with the complexity of the static data structures declared in P : Data structure Factors increasing complexity Scalar variable none Array dimensions, complexity of element type Record number and complexity of fields 7 OO Metric Chidamber <ref> [7] </ref> E (C) increases with: a 7 the number of methods in C b 7 the depth (distance from the root) of C in the inheritance tree c 7 the number of direct subclasses of C d 7 the number of other classes to which C is coupled a e 7
Reference: [8] <author> Cristina Cifuentes and K. John Gough. </author> <title> Decompilation of binary programs. </title> <journal> Software Practice and Experience, </journal> <volume> 25(7) </volume> <pages> 811-829, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: INTRODUCTION 1.2 Reverse-Engineering Software To reverse-engineer a software application it is necessary to first gain physical access to it. Using disassemblers or decompilers <ref> [8] </ref>, the reverse-engineer can decompile it to source code, then analyse its control flow and data structures. Additional tools such as program slicers may be used to perform this analysis (see Marciniak [35], pp. 873-877). <p> Users identify their architecture/operating system combination to the server, which then provides the appropriate native code version of the application. Only having access to native code hinders but does not stop reverse-engineering. For example, there are decompilers to translate 80x86 machine code into C source code <ref> [8] </ref>. So using native codes for distribution does not provide the same level of security as hardware encryption devices. Additionally, a JIT or WAT compiler is required to translate the Java bytecodes into the native code of each architecture/operating system that is likely to be encountered.
Reference: [9] <author> Christian Collberg, Clark Thomborson, and Douglas Low. </author> <title> A taxonomy of obfuscating transformations. </title> <type> Technical Report 148, </type> <institution> Department of Computer Science, The University of Auckland, </institution> <address> New Zealand, </address> <month> July </month> <year> 1997. </year> <note> http://www.cs.auckland.ac.nz/~collberg/ Research/Publications/Collb% ergThomborsonLow97a/index.html. 133 134 BIBLIOGRAPHY </note>
Reference-contexts: All of these factors intensify the threat of reverse-engineering to 1.4. RELATED WORK 3 developers writing applications in Java. We will argue that the only feasible form of technical protection of mobile code such as Java bytecodes is code obfuscation <ref> [9] </ref>. We will examine how this technique can be applied to Java bytecodes in practice and how effectively they impede malicious reverse-engineering attacks. 1.4 Related Work Existing Java obfuscators like Crema [50] and Jobe [29] change the names of identifiers in Java programs to less meaningful ones. <p> INTRODUCTION Chapter 2 compares and contrasts several technical protection techniques for software: client-server models, encryption, signed native code and code obfuscation. Chapter 3 examines the technical protection technique of code obfuscation in detail. We discuss the obfuscating transformation classification and evaluation scheme which is presented in Collberg et al. <ref> [9] </ref>. Chapter 4 focuses on control flow obfuscation, a particular category of code obfuscation which hides the real control flow in a program. Many control flow obfuscations rely on the existence of opaque constructs. We define what opaque constructs are and present some methods to create such opaque constructs. <p> Thus, technical protection must be incorporated into software and be hardware independent if it is to be of any use in a mobile code environment. We discuss the technical protection techniques of client-server models, encryption, signed native code and code obfuscation, as described in Collberg et al. <ref> [9] </ref>. 5 6 CHAPTER 2. TECHNICAL PROTECTION TECHNIQUES 2.2 Protection by Server-Side Execution The first step in reverse-engineering an application involves gaining physical access to the code. By preventing physical access to the application, the problem of reverse-engineering is nipped in the bud. <p> Obfuscating transformations are the basis of code obfuscation. In this chapter, we discuss the obfuscating transformation classification and evaluation scheme which is presented in Collberg et al. <ref> [9] </ref>. 3.2 Obfuscating Transformations An obfuscator is a program used to transform program code. The output of an obfuscator is program code that is more difficult to understand but is functionally equivalent to the original. In order to achieve this, the obfuscator applies obfuscating transformations to the program code. <p> Before examining examples of control flow obfuscations, we first discuss the notion of opaque predicates, which are an important element of many control flow obfuscations. We summarise portions of the papers by Collberg et al. <ref> [9, 11] </ref> in this chapter. 4.2 Opaque Constructs Control-flow transformations must be cheap yet resilient to attack from deobfus-cators. Many such transformations rely on the existence of opaque constructs. Informally, a variable is opaque if it has a property that is known a priori to the 29 30 CHAPTER 4. <p> Given the time constraints of a Masters thesis, we were unable to complete a full implementation of the obfuscator as described in Collberg et al. <ref> [9] </ref>. 9.2.1 Additional features required Currently, our obfuscator is unable to transform methods which contain exception handlers. It is difficult to ensure that the behaviour of such methods is correct after an obfuscating transformation is applied to these methods.
Reference: [10] <author> Christian Collberg, Clark Thomborson, and Douglas Low. </author> <title> Breaking abstractions and unstructuring data structures. </title> <booktitle> In IEEE International Conference on Computer Languages 1998, </booktitle> <address> ICCL'98., Chicago, IL, </address> <month> May </month> <year> 1998. </year> <note> http://www.cs.auckland.ac.nz/~collberg/Research/ Publications/Collb% ergThomborsonLow97d/index.html. </note>
Reference-contexts: Instead, we could use a function f (i) to determine the position of the ith element in the list. Data obfuscations will not be discussed further in this thesis. For additional information about data obfuscation, see Bertenshaw [6] and Collberg et al. <ref> [10] </ref>. 3.3.3 Control flow obfuscation Control flow obfuscations affect the control flow of the program. Again we can classify them further according to what operation they perform (Figure 3.4). Chapter 4 covers control flow obfuscation in detail. 16 CHAPTER 3. <p> Of particular interest are opaque constructs, which are covered in depth in Collberg et al. [11]. This thesis has given a broad outline of data obfuscations and preventive transformations. Further work on data obfuscations is in Bertenshaw [6] and Collberg et al. <ref> [10] </ref>. A P P E N D I X A Obfuscation Modules "I am a brain, Watson. The rest of me is a mere appendix." The Marazin Stone, Sir Arthur Conan Doyle An obfuscating transformation module is defined by a Prolog source code file.
Reference: [11] <author> Christian Collberg, Clark Thomborson, and Douglas Low. </author> <title> Manufacturing cheap, resilient, and stealthy opaque constructs. </title> <booktitle> In ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages 1998, POPL'98, </booktitle> <address> San Diego, CA, </address> <month> January </month> <year> 1998. </year> <note> http://www.cs.auckland.ac.nz/~collberg/ Research/Publications/Collb% ergThomborsonLow98a/index.html. </note>
Reference-contexts: Before examining examples of control flow obfuscations, we first discuss the notion of opaque predicates, which are an important element of many control flow obfuscations. We summarise portions of the papers by Collberg et al. <ref> [9, 11] </ref> in this chapter. 4.2 Opaque Constructs Control-flow transformations must be cheap yet resilient to attack from deobfus-cators. Many such transformations rely on the existence of opaque constructs. Informally, a variable is opaque if it has a property that is known a priori to the 29 30 CHAPTER 4. <p> However, there is much more work to be performed in this area. Of particular interest are opaque constructs, which are covered in depth in Collberg et al. <ref> [11] </ref>. This thesis has given a broad outline of data obfuscations and preventive transformations. Further work on data obfuscations is in Bertenshaw [6] and Collberg et al. [10]. A P P E N D I X A Obfuscation Modules "I am a brain, Watson.
Reference: [12] <author> WingSoft Company. WingDis 2.03- the Java Decompiler, </author> <month> March </month> <year> 1997. </year> <note> http: //www.wingsoft.com/wingdis.shtml. </note>
Reference-contexts: C H A P T E R 8 Examples "Example is always more efficacious than precept." - Samuel Johnson 8.1 Introduction This chapter presents some examples of the transformations employed by our ob-fuscator. We also use the decompilers Mocha [51] and WingDis <ref> [12] </ref> to attempt to recover the Java source code from the transformed Java bytecode. By measuring the effect the transformations have on selected software complexity metrics, we can gauge their effectiveness.
Reference: [13] <author> Netscape Communications Corporation. Netscape communicator, </author> <month> March </month> <year> 1998. </year> <note> http://home.netscape.com/comprod/products/communicator/ index.html. </note>
Reference-contexts: If one of these errors occurs during the execution of a Java program, the error is reported rather than causing the Java run-time environment to crash. Java programs also designed to be run by web browsers such as Netscape Communicator <ref> [13] </ref>. In this case the programs are known as applets rather than applications. Downloading a web page with an applet in it will cause the applet to be executed. In contrast, applications are downloaded and executed in separate phases.
Reference: [14] <author> Symantec Corporation. </author> <title> Cafe Visual Java Development and Debugging Tools, </title> <month> March </month> <year> 1997. </year> <note> http://cafe.symantec.com/index.html. </note>
Reference-contexts: The native code is then executed in lieu of the original bytecodes. There are several JIT compilers available for a variety of operating systems. Several companies have included JIT compilers in their Java development kits, for example, Bor-land's JBuilder [26], Symantec's Cafe <ref> [14] </ref> and Microsoft's Visual J++ [27]. To avoid incurring the overhead of compilation every time Java bytecodes are executed, it is possible to store the compiled native codes. This is known as way-ahead-of-time (WAT) compilation. Several WAT compilers are under development, such as Toba [40] and NET [25].
Reference: [15] <author> Jeffrey Adgate Dean. </author> <title> Whole-Program Optimization of Object-Oriented Languages. </title> <type> PhD thesis, </type> <institution> University of Washington, </institution> <year> 1996. </year>
Reference-contexts: For a method invocation m:P (), the actual procedure called will depend on the run-time type of m. If more than one method can be invoked at a particular call site, we have to inline all possible methods <ref> [15] </ref> and select the appropriate code by branching on the type of m (see Figure 4.15). Hence, even after inlining and removal of methods, the obfuscated code may still contain some traces of the original abstractions. 46 CHAPTER 4.
Reference: [16] <author> R. A. DeMillo, W. M. McCracken, R. J. Martin, and J. F. Passafiume. </author> <title> Software Testing and Evaluation. </title> <publisher> The Benjamin/Cummings Publishing Company, Inc., </publisher> <year> 1987. </year>
Reference-contexts: In this thesis, we are mostly concerned about static analysis attacks on obfuscated programs. Static analysis of a program is performed without executing the program, whereas dynamic analysis takes place at run-time <ref> [16] </ref>. Common static analyses include detection of dead code and uninitialised variables. Dynamic analysis is performed by testing the program on sample input data. It is infeasible to test all control paths in a program due to combinatorial explosion.
Reference: [17] <author> James R. Gosler. </author> <title> Software protection: </title> <booktitle> Myth or reality? In CRYPTO'85 | Advances in Cryptology, </booktitle> <pages> pages 140-157, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: Some early attempts at technical protection are described in Suhler et al. [47] and Gosler <ref> [17] </ref>. However, all the techniques discussed by these authors rely on system specific hardware features. A common technique in the 1980's was to distribute software on specially formatted floppy disks, which standard system file copy routines fail to duplicate correctly.
Reference: [18] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year> <note> ISBN 0-201-63451-1. </note>
Reference-contexts: Thus, the job of a reverse-engineer is made harder as she must perform housekeeping tasks such as memory location to variable mapping, that are unnecessary with code that has not been stripped. 1.3 The Threat to Java Since the advent of Java <ref> [18] </ref>, the threat of reverse-engineering is being taken more seriously. The language was designed to be compiled into a platform independent bytecode format. A lot of the information contained in the source code remains in the bytecode, making decompilation easier [41]. <p> There is a separate instruction which handles long and double operands. 60 CHAPTER 5. JAVA OBFUSCATION IN PRACTICE 5.5 Java Bytecode Verifier Java bytecodes are intended to be distributed across the Internet among a variety of platforms <ref> [18] </ref>. The problem with this distribution method is that the recipient may not be able to trust the program. The program may corrupt the user's system, either accidentally through poor programming, or deliberately, in the case of viruses. For this reason, Java bytecodes are subjected to rigorous bytecode verification [5].
Reference: [19] <author> M. H. Halstead. </author> <title> Elements of Software Science. </title> <publisher> Elsevier North-Holland Inc., </publisher> <year> 1977. </year> <note> ISBN 0-44-00205-7. </note>
Reference-contexts: EVALUATION 19 Metric Metric Name Citation 1 Program Length Halstead <ref> [19] </ref> E (P ) increases with the number of operators and operands in P . 2 Cyclomatic Complexity McCabe [36] E (F ) increases with the number of predicates in F . 3 Nesting Complexity Harrison [20] E (F ) increases with the nesting level of conditionals in F . 4
Reference: [20] <author> Warren A. Harrison and Kenneth I. Magel. </author> <title> A complexity measure based on nesting level. </title> <journal> SIGPLAN Notices, </journal> <volume> 16(3) </volume> <pages> 63-74, </pages> <year> 1981. </year>
Reference-contexts: EVALUATION 19 Metric Metric Name Citation 1 Program Length Halstead [19] E (P ) increases with the number of operators and operands in P . 2 Cyclomatic Complexity McCabe [36] E (F ) increases with the number of predicates in F . 3 Nesting Complexity Harrison <ref> [20] </ref> E (F ) increases with the nesting level of conditionals in F . 4 Data Flow Complexity Oviedo [39] E (F ) increases with the number of inter-basic block variable refer ences in F . 5 Fan-in/out Complexity Henry [21] E (F ) increases with the number of formal parameters <p> The aim is to hide the real control flow behind statements that are irrelevant. The McCabe [36] and Harrison <ref> [20] </ref> metrics ( 2 and 3 in Table 3.1) suggest that there is a strong correlation between the perceived complexity of a piece of code and the number of predicates it contains.
Reference: [21] <author> Sallie Henry and Dennis Kafura. </author> <title> Software structure metrics based on information flow. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 7(5) </volume> <pages> 510-518, </pages> <month> September </month> <year> 1981. </year> <note> BIBLIOGRAPHY 135 </note>
Reference-contexts: number of predicates in F . 3 Nesting Complexity Harrison [20] E (F ) increases with the nesting level of conditionals in F . 4 Data Flow Complexity Oviedo [39] E (F ) increases with the number of inter-basic block variable refer ences in F . 5 Fan-in/out Complexity Henry <ref> [21] </ref> E (F ) increases with the number of formal parameters to F , and with the number of global data structures read or updated by F . 6 Data Structure Complexity Munson [38] E (P ) increases with the complexity of the static data structures declared in P : Data
Reference: [22] <author> Amir Herzberg and Shlomit S. Pinter. </author> <title> Public protection of software. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 5(4) </volume> <pages> 371-393, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: Encrypting the distributed code is one method of defeating decompilation (Figure 2.2). Unless decryption takes place in hardware, it will be possible to intercept and decrypt compiled code. Hardware decryption systems have been described in Herzberg and Pinter <ref> [22] </ref> and Wilhelm [52]. The idea is to have a co-processor (cryptochip) which decrypts instructions before they are executed by the main processor. The decrypted code is never stored in user accessible memory, so the degree of security depends on the scheme used to encrypt the code.
Reference: [23] <author> Susan Horwitz. </author> <title> Precise flow-insensitive May-Alias analysis is NP-hard. </title> <journal> TOPLAS, </journal> <volume> 19(1) </volume> <pages> 1-6, </pages> <month> January </month> <year> 1997. </year>
Reference-contexts: Figure 4.3 presents a trivial example. Static analysis is made significantly more complicated when aliasing can occur. Different versions of precise static alias analysis are NP-hard <ref> [23] </ref> or undecidable [42]. We exploit this fact to construct opaque predicates which are difficult to break by static analysis alone. There are many fast but imprecise alias analysis algorithms that will detect some aliases some of the time, but not all aliases all of the time.
Reference: [24] <author> C.-H. A. Hsieh, J. C. Gyllenhaal, and W. W. Hwu. </author> <title> Java bytecode to native code translation: The Caffeine prototype and preliminary results. </title> <booktitle> In IEEE, editor, Proceedings of the 29th annual IEEE/ACM International Symposium on Microarchitecture, </booktitle> <month> December 2-4, </month> <year> 1996, </year> <title> Paris, </title> <booktitle> France, </booktitle> <pages> pages 90-97, </pages> <address> 1109 Spring Street, Suite 300, Silver Spring, MD 20910, USA, December 1996. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [25] <author> Cheng-Hsueh A. Hsieh, Marie T. Conte, Teresa L. Johnson, John C. Gyllen-haal, and Wen mei W. Hwu. </author> <title> Optimizing NET compilers for improved Java performance. </title> <journal> IEEE Computer, </journal> <volume> 30(6) </volume> <pages> 67-75, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: To avoid incurring the overhead of compilation every time Java bytecodes are executed, it is possible to store the compiled native codes. This is known as way-ahead-of-time (WAT) compilation. Several WAT compilers are under development, such as Toba [40] and NET <ref> [25] </ref>. We can use JIT or WAT compilers to transform Java bytecodes into native codes, which are more difficult to decompile. The program requiring distribution is first compiled into Java bytecodes and stored on a server.
Reference: [26] <author> Borland International. JBuilder, </author> <month> September </month> <year> 1997. </year> <note> http://www.borland. com/jbuilder/index.html. </note>
Reference-contexts: The native code is then executed in lieu of the original bytecodes. There are several JIT compilers available for a variety of operating systems. Several companies have included JIT compilers in their Java development kits, for example, Bor-land's JBuilder <ref> [26] </ref>, Symantec's Cafe [14] and Microsoft's Visual J++ [27]. To avoid incurring the overhead of compilation every time Java bytecodes are executed, it is possible to store the compiled native codes. This is known as way-ahead-of-time (WAT) compilation.
Reference: [27] <institution> Microsoft International. Visual J++, </institution> <month> July </month> <year> 1997. </year> <note> http://www.microsoft. com/products/prodref/221_ov.htm. </note>
Reference-contexts: The native code is then executed in lieu of the original bytecodes. There are several JIT compilers available for a variety of operating systems. Several companies have included JIT compilers in their Java development kits, for example, Bor-land's JBuilder [26], Symantec's Cafe [14] and Microsoft's Visual J++ <ref> [27] </ref>. To avoid incurring the overhead of compilation every time Java bytecodes are executed, it is possible to store the compiled native codes. This is known as way-ahead-of-time (WAT) compilation. Several WAT compilers are under development, such as Toba [40] and NET [25].
Reference: [28] <author> Rex Jaeschke. </author> <title> Encrypting C source for distribution. </title> <journal> Journal of C Language Translation, </journal> <volume> 2(1), </volume> <year> 1990. </year> <note> http://jclt.iecc.com. </note>
Reference: [29] <author> Eron Jokipii. </author> <title> Jobe the Java obfuscator, </title> <note> 1996. http://www.primenet. com/~ej/index.html. </note>
Reference-contexts: We will examine how this technique can be applied to Java bytecodes in practice and how effectively they impede malicious reverse-engineering attacks. 1.4 Related Work Existing Java obfuscators like Crema [50] and Jobe <ref> [29] </ref> change the names of identifiers in Java programs to less meaningful ones. This is a form of layout transformation (Section 3.3.1). These kinds of transformations make the Java program more difficult to understand but do not hide control flow.
Reference: [30] <author> Jens Knoop, Bernhard Steffen, and Jurgen Vollmer. </author> <title> Parallelism for free: Efficient and optimal bitvector analyses for parallel programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 18(3) </volume> <pages> 268-299, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: The reason is their interleaving semantics: n statements in a parallel region PAR S 1 ; S 2 ; : : :; S n ; ENDPAR can be executed in n! different ways. Despite this, some static analyses of parallel programs can be performed in polynomial time <ref> [30] </ref>. Others require all n! inter-leavings to be considered. In Java, parallel regions are constructed using lightweight processes known as threads. Java threads have (from our point of view) two very useful properties: 1.
Reference: [31] <author> Mark D. LaDue. HoseMocha, </author> <month> January </month> <year> 1997. </year> <note> http://www.oasis.leo.org/ java/development/bytecode/obfuscators/Hos% eMocha.dsc.html. </note>
Reference-contexts: In Figure 3.6, a for-loop has been re-ordered to run backwards. An artificial data dependency is added to make it harder for a deobfuscator to undo this control ordering obfuscation. Targeted preventive transformations are designed to counter specific analysis tools. An example would be the HoseMocha <ref> [31] </ref> program which attacks a weakness in the Mocha [51] decompiler. HoseMocha inserts extra instructions after the return instructions in Java bytecodes. This transformation does not affect 3.4. EVALUATION 17 for (i=1;i&lt;=10;i++) T int B [50]; A [i]=i; g dependencies.
Reference: [32] <author> Tim Lindholm and Frank Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1997. </year> <note> http://java.sun.com:80/docs/books/vmspec/ html/VMSpecTOC.doc.html. </note>
Reference-contexts: This means that the portability of the application is reduced to the systems that the server supports. There is a further problem with transmitting only native code. Unlike Java bytecodes, native code is not subject to bytecode verification before execution <ref> [32] </ref>. So native code cannot be run with a guarantee that it will execute without performing illegal actions such as corrupting a user's files [5]. This is not a problem 2.5. <p> The version of Java that we describe in this chapter is version 1.0.2, as implemented in Sun Microsystems, Inc., Java Developer's Kit (JDK) 1.0.2. A full treatment of the Java class file format and instruction set is not given here. See Lindholm and Yellin <ref> [32] </ref> for a complete description of the Java Virtual Machine. 5.2 Executing Java Code In this section, we will discuss the issues involved in executing Java programs. The stages that are required can be seen in Figure 5.1.
Reference: [33] <author> Douglas Low. </author> <title> Protecting Java code via code obfuscation. </title> <journal> ACM Crossroads, </journal> <note> Spring issue 1998. http://www.acm.org/crossroads/xrds4-3/codeob. html. </note>
Reference: [34] <author> Apple's QuickTime lawsuit. http://www.macworld.com/pages/june.95/ News.848.html and may.95/News.705.html, </author> <month> May - June </month> <year> 1995. </year> <note> 136 BIBLIOGRAPHY </note>
Reference-contexts: Hence obtaining compensation for lost revenue through the legal system is more difficult. Small developers may not be able to afford long legal battles against large corporations with substantial resources <ref> [34] </ref>. Traditionally it has been difficult to reverse-engineer applications because they are large, monolithic and distributed as "stripped" object code. Stripping object code of its symbol table removes information like variable names and obscures references to library routines.
Reference: [35] <editor> John J. Marciniak, editor. </editor> <booktitle> Encyclopedia of Software Engineering. </booktitle> <publisher> John Wiley & Sons, Inc, </publisher> <year> 1994. </year> <note> ISBN 0-471-54004-8. </note>
Reference-contexts: Introduction "From small beginnings come great things." Proverb 1.1 Reverse-Engineering An extreme case of reverse-engineering is taking someone else's product apart to determine how it functions (see Marciniak <ref> [35] </ref>, pp. 1077-1084). More generally, reverse-engineering involves analysing an existing system, regardless of ownership. By itself, reverse-engineering is not illegal, and in fact it is commonly used to improve one's own products. <p> Using disassemblers or decompilers [8], the reverse-engineer can decompile it to source code, then analyse its control flow and data structures. Additional tools such as program slicers may be used to perform this analysis (see Marciniak <ref> [35] </ref>, pp. 873-877). One of the most important legitimate uses of software reverse-engineering is recovering lost information about a system. Businesses are still using original COBOL language programs for the sake of being able to access old records. <p> In this section we will discuss these measures. 3.4.1 Potency The concept of one program being harder to understand than another is vague since it is partially based on human perceptions. A large amount of research has been carried out in the Software Complexity Metrics branch (see Marciniak <ref> [35] </ref>, pp. 131-163) of Software Engineering concerning this problem. In this field, complexity metrics (see Table 3.1 for some popular ones) have been designed with a view to improving program readability.
Reference: [36] <author> Thomas J. McCabe. </author> <title> A complexity measure. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 2(4) </volume> <pages> 308-320, </pages> <month> December </month> <year> 1976. </year>
Reference-contexts: EVALUATION 19 Metric Metric Name Citation 1 Program Length Halstead [19] E (P ) increases with the number of operators and operands in P . 2 Cyclomatic Complexity McCabe <ref> [36] </ref> E (F ) increases with the number of predicates in F . 3 Nesting Complexity Harrison [20] E (F ) increases with the nesting level of conditionals in F . 4 Data Flow Complexity Oviedo [39] E (F ) increases with the number of inter-basic block variable refer ences in <p> The aim is to hide the real control flow behind statements that are irrelevant. The McCabe <ref> [36] </ref> and Harrison [20] metrics ( 2 and 3 in Table 3.1) suggest that there is a strong correlation between the perceived complexity of a piece of code and the number of predicates it contains.
Reference: [37] <author> Sape Mullender, </author> <title> editor. Distributed Systems. </title> <publisher> Addison-Wesley, </publisher> <address> 2nd edition, </address> <year> 1993. </year> <note> ISBN 0-201-62427-3. </note>
Reference-contexts: By preventing physical access to the application, the problem of reverse-engineering is nipped in the bud. Much research has been performed in the field of client-server mechanisms, for example Distributed Systems <ref> [37] </ref>. In Figure 2.1 (a), the application that requires protection is placed on a server and its services are provided to users over a remote connection. Thus, access to the application code is prevented.
Reference: [38] <author> John C. Munson and Taghi M. Kohshgoftaar. </author> <title> Measurement of data structure complexity. </title> <journal> Journal of Systems Software, </journal> <volume> 20 </volume> <pages> 217-225, </pages> <year> 1993. </year>
Reference-contexts: increases with the number of inter-basic block variable refer ences in F . 5 Fan-in/out Complexity Henry [21] E (F ) increases with the number of formal parameters to F , and with the number of global data structures read or updated by F . 6 Data Structure Complexity Munson <ref> [38] </ref> E (P ) increases with the complexity of the static data structures declared in P : Data structure Factors increasing complexity Scalar variable none Array dimensions, complexity of element type Record number and complexity of fields 7 OO Metric Chidamber [7] E (C) increases with: a 7 the number of
Reference: [39] <author> E. I. Oviedo. </author> <title> Control flow, data flow, and program complexity. </title> <booktitle> In Proceedings of IEEE COMPSAC, </booktitle> <pages> pages 146-152, </pages> <month> November </month> <year> 1980. </year>
Reference-contexts: with the number of operators and operands in P . 2 Cyclomatic Complexity McCabe [36] E (F ) increases with the number of predicates in F . 3 Nesting Complexity Harrison [20] E (F ) increases with the nesting level of conditionals in F . 4 Data Flow Complexity Oviedo <ref> [39] </ref> E (F ) increases with the number of inter-basic block variable refer ences in F . 5 Fan-in/out Complexity Henry [21] E (F ) increases with the number of formal parameters to F , and with the number of global data structures read or updated by F . 6 Data
Reference: [40] <author> Todd A. Proebsting, Greg Townsend, Patrick Bridges, John H. Hartman, Tim Newsham, and Scott A. Watterson. Toba: </author> <title> Java for applications, a way ahead of time (wat) compiler. </title> <booktitle> In Third USENIX Conference on Object-Oriented Technologies, </booktitle> <month> June </month> <year> 1997. </year> <note> http://www.cs.arizona.edu/sumatra/ papers/coots97.ps. </note>
Reference-contexts: To avoid incurring the overhead of compilation every time Java bytecodes are executed, it is possible to store the compiled native codes. This is known as way-ahead-of-time (WAT) compilation. Several WAT compilers are under development, such as Toba <ref> [40] </ref> and NET [25]. We can use JIT or WAT compilers to transform Java bytecodes into native codes, which are more difficult to decompile. The program requiring distribution is first compiled into Java bytecodes and stored on a server.
Reference: [41] <author> Todd A. Proebsting and Scott A. Watterson. </author> <title> Krakatoa: Decompilation in Java (Does bytecode reveal source?). </title> <booktitle> In Third USENIX Conference on Object-Oriented Technologies, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: The language was designed to be compiled into a platform independent bytecode format. A lot of the information contained in the source code remains in the bytecode, making decompilation easier <ref> [41] </ref>. Heavy use is made of standard library routines, so applications tend to be small, which aids reverse-engineering. All of these factors intensify the threat of reverse-engineering to 1.4. RELATED WORK 3 developers writing applications in Java. <p> EXAMPLES 8.4 Non-standard Code Patterns The paper by Proebsting and Watterson <ref> [41] </ref> discusses decompilation of Java by code pattern matching. By using non-standard patterns of bytecode instructions, it is possible to defeat such decompilers. That is, non-standard code patterns may be used as preventive transformations.
Reference: [42] <author> G. Ramalingam. </author> <title> The undecidability of aliasing. </title> <journal> TOPLAS, </journal> <volume> 16(5) </volume> <pages> 1467-1471, </pages> <month> September </month> <year> 1997. </year>
Reference-contexts: Figure 4.3 presents a trivial example. Static analysis is made significantly more complicated when aliasing can occur. Different versions of precise static alias analysis are NP-hard [23] or undecidable <ref> [42] </ref>. We exploit this fact to construct opaque predicates which are difficult to break by static analysis alone. There are many fast but imprecise alias analysis algorithms that will detect some aliases some of the time, but not all aliases all of the time. Such algorithms are conservative in behaviour.
Reference: [43] <author> R. Rivest, A. Shamir, and L. Adleman. </author> <title> A method for obtaining digital signatures and public-key cryptosystems. </title> <journal> Communications of the ACM, </journal> <pages> pages 120-126, </pages> <month> February </month> <year> 1978. </year>
Reference-contexts: This is not a problem 2.5. PROTECTION THROUGH CODE OBFUSCATION 9 if the developer is a trusted member of the community | the user may accept assurances by the developer that the application is safe. To avoid tampering, the developer has to digitally sign <ref> [43] </ref> the code as it is transmitted, proving to the user that the code is the original one provided by the developer (Figure 2.3).
Reference: [44] <author> Pamela Samuelson. </author> <title> Reverse-engineering someone else's software: </title> <booktitle> Is it legal? IEEE Software, </booktitle> <pages> pages 90-96, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Hence a major reverse-engineering effort is needed to recover source code from the compiled COBOL programs, such as warehouse inventory control systems. These programs need to be modified in order to eliminate the so-called Year 2000 problem. Wholesale reverse-engineering of applications violates copyright law <ref> [44] </ref> but this is not what worries developers. By extracting proprietary algorithms and data structures from a rival's application, and incorporating these items into their own, developers can dramatically reduce their software development cost and time.
Reference: [45] <author> Uwe Schoning. </author> <title> Complexity cores and hard problem instances. </title> <booktitle> In Proceedings of SIGAL'90, </booktitle> <pages> pages 232-240, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: The most resilient and stealthy opaque predicates are based on problems which have been shown to be in the NP class of problems or are undecidable. There are certain instances of NP problems are tractable <ref> [45] </ref>, so further research will have to determine which NP problems are suitable for creating opaque predicates.
Reference: [46] <author> Bjarne Steensgaard. </author> <title> Points-to analysis in almost linear time. </title> <booktitle> In Proceedings of the 23rd Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL'96), </booktitle> <pages> pages 32-41, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: There are many fast but imprecise alias analysis algorithms that will detect some aliases some of the time, but not all aliases all of the time. Such algorithms are conservative in behaviour. Steensgaard <ref> [46] </ref> demonstrates an interprocedural flow-insensitive points-to analysis that is very fast in practice for real programs written by humans. The points-to problem is 4.2.
Reference: [47] <author> Paul A. Suhler, Nager Bagherzadeh, Miroslaw Marlek, and Neil Iscoe. </author> <title> Software authorization systems. </title> <journal> IEEE Software, </journal> <volume> 3(5) </volume> <pages> 34-41, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: Some early attempts at technical protection are described in Suhler et al. <ref> [47] </ref> and Gosler [17]. However, all the techniques discussed by these authors rely on system specific hardware features. A common technique in the 1980's was to distribute software on specially formatted floppy disks, which standard system file copy routines fail to duplicate correctly.
Reference: [48] <author> Inc. </author> <title> Sun Microsystems. JavaBeans: The Only Component Architecture for Java, </title> <note> 1998. http://java.sun.com/beans/index.html. BIBLIOGRAPHY 137 </note>
Reference-contexts: The same name substitutions performed on the class MyClass, must also be applied to the references we have found in the other classes. The JavaBeans specification <ref> [48] </ref> defines a set of standard software component 68 CHAPTER 5. JAVA OBFUSCATION IN PRACTICE interfaces for Java. This allows a user to create an application out of components downloaded from different vendors.
Reference: [49] <author> Robert Tolksdorf. </author> <title> Programming languages for the Java virtual machine, </title> <month> September </month> <year> 1997. </year> <note> http://grunge.cs.tu-berlin.de/~tolk/vmlanguages. html. </note>
Reference-contexts: Obfuscations such as removing comments and formatting (Section 3.3.1) occur automatically when the Java source files are compiled into bytecodes. There are translators from many languages (including Ada and Scheme) to Java source or bytecode <ref> [49] </ref>. This means that our obfuscator can be applied to a variety of languages by utilising the appropriate translator. 7.4 Building an Internal Representation Our obfuscator builds the following internal representations of an application | an inheritance hierarchy of classes and a control flow graph for each method.
Reference: [50] <author> Hans Peter van Vliet. </author> <title> Crema | The Java obfuscator, </title> <note> 1996. http://www. ph-erfurt.de/information/java/dev/misc/Crema/index.html% </note> . 
Reference-contexts: We will examine how this technique can be applied to Java bytecodes in practice and how effectively they impede malicious reverse-engineering attacks. 1.4 Related Work Existing Java obfuscators like Crema <ref> [50] </ref> and Jobe [29] change the names of identifiers in Java programs to less meaningful ones. This is a form of layout transformation (Section 3.3.1). These kinds of transformations make the Java program more difficult to understand but do not hide control flow. <p> The output of an obfuscator is program code that is more difficult to understand but is functionally equivalent to the original. In order to achieve this, the obfuscator applies obfuscating transformations to the program code. Existing obfuscators like Crema <ref> [50] </ref> assume that the original and obfuscated programs must have identical behaviour. In this thesis we assume that it is possible to relax this constraint under certain circumstances. This means that the transformed program can be slower or larger 13 14 CHAPTER 3. <p> An example would be the HoseMocha [31] program which attacks a weakness in the Mocha [51] decompiler. HoseMocha inserts extra instructions after the return instructions in Java bytecodes. This transformation does not affect 3.4. EVALUATION 17 for (i=1;i&lt;=10;i++) T int B <ref> [50] </ref>; A [i]=i; g dependencies.
Reference: [51] <author> Hans Peter van Vliet. </author> <title> Mocha | The Java decompiler, </title> <note> 1996. http:// wkweb4.cableinet.co.uk/jinja/mocha.html. </note>
Reference-contexts: An artificial data dependency is added to make it harder for a deobfuscator to undo this control ordering obfuscation. Targeted preventive transformations are designed to counter specific analysis tools. An example would be the HoseMocha [31] program which attacks a weakness in the Mocha <ref> [51] </ref> decompiler. HoseMocha inserts extra instructions after the return instructions in Java bytecodes. This transformation does not affect 3.4. EVALUATION 17 for (i=1;i&lt;=10;i++) T int B [50]; A [i]=i; g dependencies. <p> C H A P T E R 8 Examples "Example is always more efficacious than precept." - Samuel Johnson 8.1 Introduction This chapter presents some examples of the transformations employed by our ob-fuscator. We also use the decompilers Mocha <ref> [51] </ref> and WingDis [12] to attempt to recover the Java source code from the transformed Java bytecode. By measuring the effect the transformations have on selected software complexity metrics, we can gauge their effectiveness.
Reference: [52] <author> U. G. Wilhelm. </author> <title> Cryptographically protected objects. </title> <address> http://lsewww.epfl. ch/~wilhelm/CryPO.html, </address> <month> May </month> <year> 1997. </year> <note> A french version appeared in the Proceedings of RenPar'9, Lausanne, CH. </note>
Reference-contexts: Encrypting the distributed code is one method of defeating decompilation (Figure 2.2). Unless decryption takes place in hardware, it will be possible to intercept and decrypt compiled code. Hardware decryption systems have been described in Herzberg and Pinter [22] and Wilhelm <ref> [52] </ref>. The idea is to have a co-processor (cryptochip) which decrypts instructions before they are executed by the main processor. The decrypted code is never stored in user accessible memory, so the degree of security depends on the scheme used to encrypt the code.
Reference: [53] <author> Michael Wolfe. </author> <title> High Performance Compilers For Parallel Computing, chapter 7. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year> <note> ISBN 0-8053-2730-4. </note>
Reference-contexts: Thus, we randomise the placement of any item, wherever possible, in the source application. For some types of items, such as methods within classes, this is trivial. In other cases, such as statements within basic blocks, a data dependency analysis (see <ref> [4, 53] </ref>) will have to be performed to determine which reorderings are legal. These transformations have low potency (they don't add much obscurity to the program) but their resilience is high, in many cases one-way.
References-found: 53

