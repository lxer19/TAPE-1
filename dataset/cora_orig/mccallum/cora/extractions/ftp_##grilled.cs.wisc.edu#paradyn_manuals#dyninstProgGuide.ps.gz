URL: ftp://grilled.cs.wisc.edu/paradyn_manuals/dyninstProgGuide.ps.gz
Refering-URL: http://www.cs.wisc.edu/~paradyn/manuals.html
Root-URL: 
Email: hollings@cs.umd.edu  
Title: dyninstAPI 05/01/98 P a r a d n P a r a l l e
Author: Jeffrey K. Hollingsworth Bryan Buck 
Address: College Park, MD 20742  
Affiliation: Computer Science Department University of Maryland  
Date: May 1998  
Pubnum: 1.1  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> J. K. Hollingsworth and B. P. Miller, </author> <title> "Using Cost to Control Instrumentation Overhead," </title> <note> Theoretical Com puter Science, (to appear), </note> <year> 1998. </year>
Reference-contexts: The problems with accurately estimating the cost of executing code are numerous and out of the scope of this document <ref> [1] </ref>. But, it is important to realize that the returned cost value is (at best) an estimate. The rest of the classes are derived classes of the class BPatch_snippet. BPatch_arithExpr (BPatch_binOp op, const BPatch_snippet &lOperand, const BPatch_snippet &rOperand) Perform the required binary operation. <p> #include &lt;stdio.h&gt; #include &lt;fcntl.h&gt; #include "BPatch.h" #include "BPatch_Vector.h" #include "BPatch_thread.h" BPatch bpatch; main (int argc, char *argv []) - if (argc != 4) - fprintf (stderr, "Usage: %s prog_filename pid log_filename"n",argv [0]); exit (1); - pid = atoi (argv [2]); // Attach to the program BPatch_thread *appThread = bpatch.attachProcess (argv <ref> [1] </ref>, pid); // Read the program's image and get an associated image object BPatch_image *appImage = appThread-&gt;getImage (); // Find the entry point to the procedure "write" BPatch_Vector&lt;BPatch_point *&gt; *points = appImage-&gt;findProcedurePoint ("write", BPatch_entry); if ((*points).size () == 0) - fprintf (stderr, "Unable to find entry point to ""write."""n"); exit (1); <p> initIfNeeded (testFlag, initSequence); // Generate the code that copies all writes to file descriptor 1 // to our log file. // Call write with the same data but for our file descriptor // The C code we generate is: // if (parameter [0] == 1) - // write (fd, parameter <ref> [1] </ref>, parameter [2]) // - // Find the write function call BPatch_function *writeFunc = appImage-&gt;findFunction ("write"); // Build up a parameter list with the items: // 1) The file description of our log file // 2) First parameter to the original function // 3) Second parameter to the original function BPatch_Vector&lt;BPatch_snippet <p> The file description of our log file // 2) First parameter to the original function // 3) Second parameter to the original function BPatch_Vector&lt;BPatch_snippet *&gt; writeArgs; BPatch_paramExpr paramBuf (1); BPatch_paramExpr paramNbyte (2); writeArgs.push_back (fdVar); writeArgs.push_back (&paramBuf); writeArgs.push_back (&paramNbyte); Page 29 dyninstAPI // Create a function call snippet write (fd, parameter <ref> [1] </ref>, parameter [2]) BPatch_funcCallExpr writeCall (*writeFunc, writeArgs); // (1) Build a vector of snippets with each statement being push on BPatch_Vector&lt;BPatch_snippet *&gt; copyWriteStatements; copyWriteStatements.push_back (&initIfNeeded); copyWriteStatements.push_back (&writeCall); // (2) Convert the vector into a sequence BPatch_sequence copyWrite (copyWriteStatements); // (3) Create the boolean expression ($param [0] == 1) BPatch_boolExpr compareFd (BPatch_eq,
Reference: 2. <author> J. K. Hollingsworth, B. P. Miller, and J. Cargille, </author> <title> "Dynamic Program Instrumentation for Scalable Perform ance Tools," </title> <booktitle> 1994 Scalable High-Performance Computing Conf., Knoxville, Tenn., </booktitle> <pages> pp. 841-850. </pages>
Reference-contexts: The goal of this API is to provide a machine independent interface to permit the creation of tools and applications that use runtime code patching. This API is based on the idea of Dynamic Instrumentation described in <ref> [2] </ref>. The unique feature of this interface is that it makes it possible to insert and change instrumentation in a running program. This differs from other post-linker instrumentation tools [4] that permit code to be inserted into a binary before it starts to execute. <p> For example, the MDL language [3]. Page 27 dyninstAPI #include &lt;stdio.h&gt; #include &lt;fcntl.h&gt; #include "BPatch.h" #include "BPatch_Vector.h" #include "BPatch_thread.h" BPatch bpatch; main (int argc, char *argv []) - if (argc != 4) - fprintf (stderr, "Usage: %s prog_filename pid log_filename"n",argv [0]); exit (1); - pid = atoi (argv <ref> [2] </ref>); // Attach to the program BPatch_thread *appThread = bpatch.attachProcess (argv [1], pid); // Read the program's image and get an associated image object BPatch_image *appImage = appThread-&gt;getImage (); // Find the entry point to the procedure "write" BPatch_Vector&lt;BPatch_point *&gt; *points = appImage-&gt;findProcedurePoint ("write", BPatch_entry); if ((*points).size () == 0) - <p> initSequence); // Generate the code that copies all writes to file descriptor 1 // to our log file. // Call write with the same data but for our file descriptor // The C code we generate is: // if (parameter [0] == 1) - // write (fd, parameter [1], parameter <ref> [2] </ref>) // - // Find the write function call BPatch_function *writeFunc = appImage-&gt;findFunction ("write"); // Build up a parameter list with the items: // 1) The file description of our log file // 2) First parameter to the original function // 3) Second parameter to the original function BPatch_Vector&lt;BPatch_snippet *&gt; writeArgs; <p> description of our log file // 2) First parameter to the original function // 3) Second parameter to the original function BPatch_Vector&lt;BPatch_snippet *&gt; writeArgs; BPatch_paramExpr paramBuf (1); BPatch_paramExpr paramNbyte (2); writeArgs.push_back (fdVar); writeArgs.push_back (&paramBuf); writeArgs.push_back (&paramNbyte); Page 29 dyninstAPI // Create a function call snippet write (fd, parameter [1], parameter <ref> [2] </ref>) BPatch_funcCallExpr writeCall (*writeFunc, writeArgs); // (1) Build a vector of snippets with each statement being push on BPatch_Vector&lt;BPatch_snippet *&gt; copyWriteStatements; copyWriteStatements.push_back (&initIfNeeded); copyWriteStatements.push_back (&writeCall); // (2) Convert the vector into a sequence BPatch_sequence copyWrite (copyWriteStatements); // (3) Create the boolean expression ($param [0] == 1) BPatch_boolExpr compareFd (BPatch_eq, BPatch_paramExpr (0),
Reference: 3. <author> J. K. Hollingsworth, B. P. Miller, M. J. R. Goncalves, O. Naim, Z. Xu, and L. Zheng, </author> <title> "MDL: A Language and Compiler for Dynamic Program Instrumentation," </title> <booktitle> (to appear) International Conference on Parallel Architectures and Compilation Techniques (PACT). </booktitle> <address> Nov. 1997, San Francisco. </address>
Reference-contexts: Using the API to directly create programs is possible, but somewhat tedious. We anticipate that most users of the API will be tool builders who will create higher level languages for specifying instrumentation. For example, the MDL language <ref> [3] </ref>. <p> appImage-&gt;findProcedurePoint ("write", BPatch_entry); if ((*points).size () == 0) - fprintf (stderr, "Unable to find entry point to ""write."""n"); exit (1); - // Generate code that opens the file the first time it is called. // The code to be generate is: // if (!flagVar) - // fd = open (argv <ref> [3] </ref>, O_WRONLY|O_CREAT, 0666); // flagVar = 1; // - // (1) Find the open function BPatch_function *openFunc = appImage-&gt;findFunction ("open"); // (2) Allocate a vector of snippets for the parameters to open BPatch_Vector&lt;BPatch_snippet *&gt; openArgs; // (3) Create a string constant expression from argv [3] BPatch_constExpr fileName (argv [3]); // (4) <p> - // fd = open (argv <ref> [3] </ref>, O_WRONLY|O_CREAT, 0666); // flagVar = 1; // - // (1) Find the open function BPatch_function *openFunc = appImage-&gt;findFunction ("open"); // (2) Allocate a vector of snippets for the parameters to open BPatch_Vector&lt;BPatch_snippet *&gt; openArgs; // (3) Create a string constant expression from argv [3] BPatch_constExpr fileName (argv [3]); // (4) Create two more constant expressions _WRONLY|O_CREAT and 0666 BPatch_constExpr fileFlags (O_WRONLY|O_CREAT); BPatch_constExpr fileMode (0666); // (5) Push 3 && 4 onto the list from step 2 openArgs.push_back (&fileName); openArgs.push_back (&fileFlags); openArgs.push_back (&fileMode); Page 28 dyninstAPI // (6) create a procedure call using function found <p> open (argv <ref> [3] </ref>, O_WRONLY|O_CREAT, 0666); // flagVar = 1; // - // (1) Find the open function BPatch_function *openFunc = appImage-&gt;findFunction ("open"); // (2) Allocate a vector of snippets for the parameters to open BPatch_Vector&lt;BPatch_snippet *&gt; openArgs; // (3) Create a string constant expression from argv [3] BPatch_constExpr fileName (argv [3]); // (4) Create two more constant expressions _WRONLY|O_CREAT and 0666 BPatch_constExpr fileFlags (O_WRONLY|O_CREAT); BPatch_constExpr fileMode (0666); // (5) Push 3 && 4 onto the list from step 2 openArgs.push_back (&fileName); openArgs.push_back (&fileFlags); openArgs.push_back (&fileMode); Page 28 dyninstAPI // (6) create a procedure call using function found at 1 and //
Reference: 4. <author> J. R. Larus and E. Schnarr, "EEL: </author> <title> Machine-Independent Executable Editing," </title> <booktitle> PLDI. </booktitle> <address> June 18-21, 1995, La Jolla, CA, </address> <pages> pp. 291-300. </pages>
Reference-contexts: This API is based on the idea of Dynamic Instrumentation described in [2]. The unique feature of this interface is that it makes it possible to insert and change instrumentation in a running program. This differs from other post-linker instrumentation tools <ref> [4] </ref> that permit code to be inserted into a binary before it starts to execute. The goal of this API is to keep the interface small and easy to understand. At the same time it needs to be sufficiently expressive to be useful for a variety of applications.
References-found: 4

