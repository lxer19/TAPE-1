URL: ftp://ftp.icsi.berkeley.edu/pub/techreports/1993/tr-93-074.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/techreports/1993.html
Root-URL: http://www.icsi.berkeley.edu
Title: How and When to Be Unique Extended Abstract  
Author: Shay Kutten Rafail Ostrovsky Boaz Patt-Shamir 
Affiliation: IBM T.J. Watson Research Center. UC Berkeley.  IBM T.J. Watson Research Center. MIT.  IBM T.J. Watson Research Center.  
Note: Preliminary Version Appeared in Prooceedings of the second Israel Symposium on Theory of Computing and Systems (ISTCS93) Netanya, Israel,  Research partly done during a visit to  Research partly done during a visit to  
Date: November, 1993  June 7th-9th, 1993.  
Pubnum: TR-93-074  
Abstract: One of the fundamental problems in distributed computing is how identical processors with identical local memory can choose unique IDs provided they can flip a coin. The variant considered in this paper is the asynchronous shared memory model (atomic registers), and the basic correctness requirement is that upon termination the processes must always have unique IDs. We study this problem from several viewpoints. On the positive side, we present the first protocol that solves the problem and terminates with probability 1. The protocol terminates in (optimal) O(log n) expected time, using O(n) shared memory space, where n is the number of participating processes. On the negative side, we show that no protocol can terminate with probability 1 if n is unknown, and that no finite-state protocol can terminate with probability 1 if the schedule is non-oblivious (i.e., may depend on the history of the shared variable). We also discuss the dynamic setting (where processes may join and leave the system dynamically), and give a deterministic protocol for the read-modify-write model that needs only 3 shared bits. 
Abstract-found: 1
Intro-found: 1
Reference: [ABD + 87] <author> Hagit Attiya, Amotz Bar-Noy, Danny Dolev, Daphne Koller, David Peleg, and Rudiger Reischuk. </author> <title> Achievable cases in an asynchronous environment. </title> <booktitle> In 28th Annual Symposium on Foundations of Computer Science, </booktitle> <address> White Plains, New York, </address> <pages> pages 337-346, </pages> <year> 1987. </year>
Reference-contexts: Previous Work. Symmetry breaking is one of the well-studied problems in the theory of distributed systems. For example, see <ref> [Bur81, JS85, CIL87, ABD + 87] </ref>.
Reference: [Bur81] <author> James E. Burns. </author> <title> Symmetry in systems of asynchronous processes. </title> <booktitle> In 21st Annual Symposium on Foundations of Computer Science, </booktitle> <address> Syracuse, New York, </address> <pages> pages 169-174, </pages> <year> 1981. </year>
Reference-contexts: Previous Work. Symmetry breaking is one of the well-studied problems in the theory of distributed systems. For example, see <ref> [Bur81, JS85, CIL87, ABD + 87] </ref>.
Reference: [CIL87] <author> Benny Chor, Amos Israeli, and Ming Li. </author> <title> On processor coordination using asynchronous hardware. </title> <booktitle> In Proceedings of the 6th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 86-97, </pages> <year> 1987. </year>
Reference-contexts: Previous Work. Symmetry breaking is one of the well-studied problems in the theory of distributed systems. For example, see <ref> [Bur81, JS85, CIL87, ABD + 87] </ref>.
Reference: [ES92] <author> Omer Egecioglu and Ambuj K. Singh. </author> <title> Naming symmetric processes using shared variables. </title> <type> Unpublished manuscript, </type> <year> 1992. </year>
Reference-contexts: As in [LP90], however, in the event of failure, the protocol never terminates. Recently, Egecioglu and Singh <ref> [ES92] </ref> have obtained independently a randomized protocol that assigns distinct IDs to the processes in O (n 7 ) expected time using O (n 4 ) shared variables. Our Results and Organization of the Paper.
Reference: [Eve79] <author> Shimon Even. </author> <title> Graph Algorithms. </title> <publisher> Computer Science Press, </publisher> <year> 1979. </year>
Reference-contexts: Our first step is to decompose the corresponding Markov process into irreducible processes. In graph theoretic language, consider the Markov graph G P : it is a directed graph; we decompose it into strongly-connected components <ref> [Eve79] </ref>. That is, we partition the nodes into equivalence classes ("strong components"), such that two nodes s and s 0 are in the same class if and only if there is a directed path in G P from s to s 0 and from s 0 to s.
Reference: [Fel68] <author> W. Feller. </author> <title> An Introduction to Probability Theory and its Applications, volume 1. </title> <publisher> Wiley, 3rd edition, </publisher> <year> 1968. </year>
Reference-contexts: We analyze the protocols for PIP in terms of Markov chains (we shall use the terminology of <ref> [Fel68] </ref>).
Reference: [JS85] <author> Ralph E. Johnson and Fred B. Schneider. </author> <title> Symmetry and similarity in distributed systems. </title> <booktitle> In Proceedings of the 4th ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pages 13-22, </pages> <year> 1985. </year>
Reference-contexts: Previous Work. Symmetry breaking is one of the well-studied problems in the theory of distributed systems. For example, see <ref> [Bur81, JS85, CIL87, ABD + 87] </ref>.
Reference: [Lam86] <author> Leslie Lamport. </author> <title> On interprocess communication (part II). </title> <journal> Distributed Computing, </journal> <volume> 1(2) </volume> <pages> 86-101, </pages> <year> 1986. </year>
Reference-contexts: Note that most message passing models provide some asymmetry simply by virtue of the topology of the underlying interconnection network. In this paper, we focus only on the completely symmetric shared memory systems. More specifically, we are concerned with the read-write registers model <ref> [Lam86] </ref>, where in a single action, a processor can either read or write the contents of a single register. (This model is also known by the name of "atomic registers".) We shall contrast this model with the read-modify-write model, in which a processor can, in a single indivisible step, access a
Reference: [Lei91] <author> Tom Leighton. </author> <title> Introduction to Parallel Algorithms and Architectures. </title> <address> Morgan-Kaufman, </address> <year> 1991. </year>
Reference-contexts: As a final twist, since we want the names to constitute the set f1; : : :; ng, we perform some kind of "prefix sums". In other words, we compute for each process the rank of its ID among the claimed IDs. Using standard techniques (see, e.g., <ref> [Lei91] </ref>), it can be done in O (log n) time, given the tree structure already existing in the shared memory. The formal specification of the protocol is given in Figure 1.
Reference: [LP90] <author> Richard J. Lipton and Arvin Park. </author> <title> The processor identity problem. </title> <journal> Info. Proc. Lett., </journal> <volume> 36 </volume> <pages> 91-94, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: In this setting, the processes typically run on the same physical machine, and the communication among them is realized via shared memory space. This problem, of giving distinct names to identical processes, is known by the name "Processor Identity Problem" <ref> [LP90] </ref>. In the sequel we denote it by PIP for short. We remark that PIP, due to its fundamental role, has many applications for some of the most basic distributed tasks, including mutual exclusion, choice coordination, and resource allocation. <p> Notice that we insist that processes never err. This rules out trivial solutions that require no communication (e.g., each process chooses a random ID, and the error probability is controlled by the size of the ID space). The original formulation of the problem by Lipton and Park <ref> [LP90] </ref> had additional requirements. First, that the initial state of the shared memory is arbitrary (the "dirty memory" model); and second, that upon termination, the IDs constitute exactly the set f1; : : : ; ng. Previous Work. <p> Previous Work. Symmetry breaking is one of the well-studied problems in the theory of distributed systems. For example, see [Bur81, JS85, CIL87, ABD + 87]. The Processor Identity Problem for the dirty memory model was first defined by Lipton and Park in <ref> [LP90] </ref>, where they also give a solution that uses O (Ln 2 ) shared bits (for any given parameter 1 L 0) and terminates in O (Ln 2 ) time with probability 1 c L , for some constant c &lt; 1. <p> However, if the protocol fails, then it never terminates. Since this event occurs with positive probability, that protocol has infinite expected termination time. The protocol of <ref> [LP90] </ref> was subsequently improved by Teng [Ten90], who shows how to get running time of O (n log 2 n) time with probability 1 1=n c , for any constant c &gt; 0. As in [LP90], however, in the event of failure, the protocol never terminates. <p> The protocol of <ref> [LP90] </ref> was subsequently improved by Teng [Ten90], who shows how to get running time of O (n log 2 n) time with probability 1 1=n c , for any constant c &gt; 0. As in [LP90], however, in the event of failure, the protocol never terminates. Recently, Egecioglu and Singh [ES92] have obtained independently a randomized protocol that assigns distinct IDs to the processes in O (n 7 ) expected time using O (n 4 ) shared variables. Our Results and Organization of the Paper. <p> Our protocol uses O (n) shared bits, and terminates in O (log n) expected time, where n is the number of participating processes. We solve the problem in its original formulation <ref> [LP90] </ref>, i.e., assuming the dirty memory model, and producing as the final names exactly the set f1; : : :; ng. We also discuss the dynamic model, where processes may join and leave the system arbitrarily.
Reference: [LT89] <author> Nancy A. Lynch and Mark R. Tuttle. </author> <title> An introduction to input/output automata. </title> <journal> CWI Quarterly, </journal> <volume> 2(3) </volume> <pages> 219-246, </pages> <year> 1989. </year>
Reference-contexts: Asynchronous Executions and Adversaries. Following the IO Automata model of Lynch and Tuttle, we model an execution of a system as an alternating sequence of states and actions, where in each step, one process makes an action to yield the next state (cf. <ref> [LT89] </ref>). To model asynchrony, we assume that the choice of which process takes the next step is under the control of an adversary. There are two types of adversaries we consider in this work. The oblivious adversary is simply an infinite sequence of processes names.
Reference: [Spe87] <author> Joel Spencer. </author> <title> Ten Lectures on the Probabilistic Method. </title> <publisher> SIAM, </publisher> <address> Philadelphia, Pennsylvania, </address> <year> 1987. </year>
Reference: [Tan81] <author> Andrew Tannenbaum. </author> <title> Computer Networks. </title> <publisher> Prentice Hall, </publisher> <year> 1981. </year>
Reference-contexts: This assumption seems especially reasonable where the processes are physical processors, and an ID which is guaranteed to be unique is "hardwired" in them (see, for example, the IEEE 48 Bit Standard <ref> [Tan81] </ref>). In some cases, however, one cannot get away with this approach. For instance, the processes might be virtual (i.e., software) processes that are spawned using the same code, and thus they are created identical.
Reference: [Ten90] <author> Shang-Hua Teng. </author> <title> The processor identity problem. </title> <journal> Info. Proc. Lett., </journal> <volume> 34 </volume> <pages> 147-154, </pages> <month> April </month> <year> 1990. </year> <note> i APPENDIX </note>
Reference-contexts: However, if the protocol fails, then it never terminates. Since this event occurs with positive probability, that protocol has infinite expected termination time. The protocol of [LP90] was subsequently improved by Teng <ref> [Ten90] </ref>, who shows how to get running time of O (n log 2 n) time with probability 1 1=n c , for any constant c &gt; 0. As in [LP90], however, in the event of failure, the protocol never terminates.
References-found: 14

