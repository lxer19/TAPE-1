URL: http://www.cse.psu.edu/~catuscia/papers/Confluenza/TCS/paper.ps
Refering-URL: http://www.cse.psu.edu/~catuscia/teaching/cg520/98Fall/references.html
Root-URL: http://www.cse.psu.edu
Email: E.mail: falaschi@dimi.uniud.it,  E.mail: gabbri@di.unipi.it,  E.mail: marriott@cs.monash.edu.au,  E.mail: catuscia@disi.unige.it,  
Title: Confluence in Concurrent Constraint Programming  
Author: Moreno Falaschi a;; Maurizio Gabbrielli b; Kim Marriott c and Catuscia Palamidessi d;; d DISI, 
Web: WWW: http://www.dimi.uniud.it/~falaschi  WWW: http://www.di.unipi.it/~gabbri/gabbri.html  WWW: http://www.cs.monash.edu.au/people/profiles/marriott.html  WWW: http://www.disi.unige.it/person/PalamidessiC  
Address: Via Delle  Italy.  Pisa, Corso Italia 40, 56125 Pisa, Italy.  Rd, Clayton 3168, Victoria, Australia.  Genova, Via Dodecaneso 35, 16146 Genova, Italy.  
Affiliation: a Dipartimento di Matematica e Informatica, Universita di Udine,  Scienze 206, Udine,  b Dipartimento di Informatica, Universita di  c Department of Computer Science, Monash University, Wellington  Universita di  
Abstract: Concurrent constraint programming (ccp), like most of the concurrent paradigms, has a mechanism of global choice which makes computations dependent on the scheduling of processes. This is one of the main reasons why the formal semantics of ccp is more complicated than the one of its deterministic and local-choice sub-languages. In this paper we study various subsets of ccp obtained by adding some restriction on the notion of choice, or by requiring confluency, i.e. independency from the scheduling strategy. We show that it is possible to define simple denota-tional semantics for these subsets, for various notions of observables. Finally, as an application of our results we develop a framework for the compositional analysis of full ccp. The basic idea is to approximate an arbitrary ccp program by a program in the restricted language, and then analyze the latter, by applying the standard techniques of abstract interpretation to its denotational semantics. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F.S. de Boer, A. Di Pierro and C. Palamidessi, </author> <title> An Algebraic Perspective of Constraint Logic Programming, </title> <type> Tech. Rep. </type> <institution> DISI (Dipartimento di Informatica e Scienze dell'Informazione), University of Genova, </institution> <year> 1995, </year> <note> Journal of Logic and Computation, to appear. </note>
Reference-contexts: that all the basic sub-agents of a final configuration must either be suspended or 6 Table 1 The transition system T D R1 htell (c); di ! hStop; c t di R2 h i=1 ask (c i ) ! A i ; di ! hA j ; di j 2 <ref> [1; n] </ref> and c j d hA; ci ! hA 0 ; c 0 i hB k A; ci ! hB k A 0 ; c 0 i hA; d t 9 x ci ! hB; d 0 t 9 x ci x A; ci ! h9 d 0 R5 hp <p> Proof. By structural induction on A. A = Stop. Obvious. A = tell (c). Obvious. A = i=1 ask (c i ) ! A i . Assume c 2 F (Quie )(A). Then either c 2 T n or there exists i 2 <ref> [1; n] </ref> such that c 2 " c i " F (Quie)(A i ), that is, c i c and c 2 F (Quie)(A i ). In the first case hA; ci suspends and therefore c is a resting point. <p> A = tell (c). Immediate since c 2 F * 1 (A). A = i=1 ask (c i ) ! A i . If hA; ci suspends then c 2 T n i=1 " c i and therefore c 2 F * 1 (A). Otherwise, there exists i 2 <ref> [1; n] </ref> such that c i c, hA; ci ! hA i ; ci is the first step of , and c 2 Quie (A i ). <p> If, for each i 2 <ref> [1; n] </ref> the agent A i is structurally confluent, and G is admissible, then G is structurally confluent. Proof. Consider two generic trees T; T 0 2 Ctree (G k tell (c); d) where c; d 2 C. <p> <ref> [1; n] </ref> the agent A i is structurally confluent, and G is admissible, then G is structurally confluent. Proof. Consider two generic trees T; T 0 2 Ctree (G k tell (c); d) where c; d 2 C. We have the following two cases. (i) There exist no i 2 [1; n] such that c i d. <p> In this case the root of each 19 tree in Ctree (G k tell (c); d) has only one outgoing arc of the form hG k tell (c); di ! hG; d t ci: If c i 6 d t c for any i 2 <ref> [1; n] </ref>, then Ctree (G k tell (c); d) contains only one tree and the thesis holds vacuously. Otherwise assume that c j 1 ; : : : ; c j i d t c for some fj 1 ; : : : ; j i g [1; n]. <p> any i 2 <ref> [1; n] </ref>, then Ctree (G k tell (c); d) contains only one tree and the thesis holds vacuously. Otherwise assume that c j 1 ; : : : ; c j i d t c for some fj 1 ; : : : ; j i g [1; n]. <p> Since A j k is structurally con fluent, for each k 2 <ref> [1; i] </ref> we have Stores (T j k ) = Stores (T 0 j k ). <p> Therefore Stores (T ) = Stores (T 0 ) holds. (ii) There exists fj 1 ; : : : ; j i g <ref> [1; n] </ref> such that c j 1 ; : : : ; c j i d. <p> di, and T 0 has the form hG k tell (c); di ! hG; d t ci ! m k=1 T 0 with m i, Root (T 0 j k ) = hA j k ; d t ci, and c j k c t d for each k 2 <ref> [1; m] </ref>. <p> By Lemma 30 we have that, for each k 2 <ref> [1; i] </ref>, Stores (T j k ) = Stores (T 0 j k ): (1) Since the outermost choice in G is admissible, we have now the following two cases: (a) If G is local then i = m (= n). <p> Then from (1) it follows that Stores (T ) = Stores (T 0 ). (b) If G is compatible, then for each h; k 2 <ref> [1; m] </ref> we have Stores (T 0 j h ) = Stores (T 0 j k ). <p> D [[Stop]] = fCg E2 0 D [[tell (c)]] = f" cg E3 0 D [[ i=1 ask (c i ) ! A i ]] = f (" c j " X j ) [ i=1 " c i j X j 2 D [[A j ]] for j 2 <ref> [1; n] </ref>g f i=1 " c i g E5 0 D [[9 c x 9 x (X " " c) j X 2 D [[A]]g y A]] where p (y):-A is the declaration of p in D namely we associate to an agent a set of sets of constraints. <p> Then it suffices to note that " e " " c = " (e t c) = " d " C. A = i=1 ask (c i ) ! A i . Rule R2 in Table 1 implies that there exists j 2 <ref> [1; n] </ref> such that c j c, d = c and B = A j . Let Y j 2 T * n (A j ). <p> Assume that X 2 T * n (A), d = min (X " " c) and that A is a mutually exclusive choice (the case of local choice is similar). We have two possibilities. (i) For any i 2 <ref> [1; n] </ref>, c i 6 c. Then the thesis holds with B = A. (ii) There exists j 2 [1; n] such that c j c. <p> We have two possibilities. (i) For any i 2 <ref> [1; n] </ref>, c i 6 c. Then the thesis holds with B = A. (ii) There exists j 2 [1; n] such that c j c. From Definition 37, Case 3, and the fact that c j c, it follows that " c " X =" c " Y j , where Y j 2 T * n (A j ). <p> In order to understand better the meaning of such a disjunctive constraint, we summarize here the definitions and results of <ref> [1] </ref> (although we don't need all that machinery in this paper), which introduced a logic of constraints and formally described it in terms of a lifting of the constraint system C to the power set.
Reference: [2] <author> F.S. de Boer, M. Gabbrielli, E. Marchiori and C. Palamidessi, </author> <title> Proving Concurrent Constraint Programs Correct, </title> <booktitle> in: Proc. 21st ACM Symp. on Principles of Programming Languages (ACM Press, </booktitle> <address> New York, </address> <year> 1994) </year> <month> 98-108. </month>
Reference-contexts: A similar lifting was previously introduced in <ref> [2] </ref>; the difference is that in [2] a notion of (classical) negation was also present. <p> A similar lifting was previously introduced in <ref> [2] </ref>; the difference is that in [2] a notion of (classical) negation was also present.
Reference: [3] <author> F.S. de Boer and C. Palamidessi, </author> <title> A Fully Abstract Model for Concurrent Constraint Programming, </title> <editor> in: S. Abramsky and T.S.E. Maibaum, eds., </editor> <booktitle> Proc. 40 TAPSOFT/CAAP'91, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 493 (Springer, </publisher> <address> Berlin, </address> <year> 1991) </year> <month> 296-319. </month>
Reference-contexts: Non-determinacy arises in two ways: because of a guarded choice construct and because of different process schedulings. Like for most of concurrent languages, the presence of guarded nondetermin-ism causes the denotational semantics of ccp to be rather complicated (see <ref> [3] </ref> and [16]), and therefore programs are difficult to analyze and to reason about. Various subsets of ccp, which admit a simpler semantics, have been investigated.
Reference: [4] <author> M. Codish, M. Falaschi, K. Marriott and W. Winsborough, </author> <title> Efficient Analysis of Concurrent Constraint Logic Programs, </title> <editor> in: A. Lingas, R. Karlsson and C. Carlsson, eds., </editor> <booktitle> Proc. ICALP'93, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 700 (Springer, </publisher> <address> Berlin, </address> <year> 1993) </year> <month> 633-644. </month>
Reference-contexts: A similar transformation was independently proposed in [17]. The idea of using confluence for more efficient program analysis was investigated also in <ref> [4] </ref>, in the context of concurrent logic programming (with atomic tell). In that paper, the focus was on the analysis based on operational semantics, where confluence is a convenient property because it ensures that it is sufficient to analyze only the computations which come from a particular selection rule.
Reference: [5] <author> M. Falaschi, M. Gabbrielli, K. Marriott and C. Palamidessi, </author> <title> Compositional Analysis for Concurrent Constraint Programming, </title> <booktitle> in: Proc. 8th IEEE Symp. on Logic In Computer Science (IEEE Computer Society Press, </booktitle> <address> Los Alamitos, CA, </address> <year> 1993) </year> <month> 210-221. </month>
Reference-contexts: Compositional analyses for ccp based on the denotational semantics have also been investigated in <ref> [5] </ref>. Also in that work programs are approximated so to simplify the semantic description.
Reference: [6] <author> P. Cousot and R. Cousot, </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints, </title> <booktitle> in: Proc. 4th ACM Symp. on Principles of Programming Languages (ACM Press, </booktitle> <address> New York, </address> <year> 1977) </year> <month> 238-252. </month>
Reference-contexts: Our interest for a simple denotational model is motivated by the possibility of using such model for the compositional analysis of ccp programs, following standard techniques from the theory of Abstract Interpretation <ref> [6] </ref>. Our results can also be exploited for full ccp: we can in fact approximate an arbitrary ccp program by a confluent or admissible program (in the sense that every result of the original program is also a result of the latter), and then analyze the 3 latter.
Reference: [7] <editor> L. Henkin, J.D. Monk and A. Tarski, </editor> <title> Cylindric Algebras, Part I (North-Holland, </title> <address> Amsterdam, </address> <year> 1971). </year>
Reference-contexts: The elements of C are called constraints. (ii) Var is a denumerable set of variables (or names), and for each x 2 Var the function 9 x : C ! C is a cylindrification operator <ref> [7] </ref>, i.e. it satisfies the following properties: (a) 9 x c c, (b) if c d then 9 x c 9 x d, (c) 9 x (c t 9 x d) = 9 x c t 9 x d, (iii) For each x; y 2 Var , d xy 2 C <p> following properties: (a) 9 x c c, (b) if c d then 9 x c 9 x d, (c) 9 x (c t 9 x d) = 9 x c t 9 x d, (iii) For each x; y 2 Var , d xy 2 C is a diagonal element <ref> [7] </ref>, i.e. it satisfies the following properties: (a) d xx = true, (b) if z is different from x; y then d xy = 9 z (d xz t d zy ), (c) if x is different from y then c d xy t 9 x (c t d xy ).
Reference: [8] <author> R. Jagadeesan, V.A. Saraswat and V. Shanbhogue, </author> <title> Angelic non-determinism in concurrent constraint programming, </title> <type> Tech. Rep., </type> <institution> Xerox Park, </institution> <year> 1991. </year>
Reference-contexts: Various subsets of ccp, which admit a simpler semantics, have been investigated. In particular, determinate ccp [16], where no form of choice is allowed, and local-choice ccp <ref> [8] </ref>, where choice is allowed, but it does not depend on the external environment (i.e., the choice of the branch does not depend on the present store: the guard is checked after the branch is selected). <p> We show that also for (structurally) confluent programs it is possible to define a denotational semantics along the lines of <ref> [8] </ref>, allowing us to retrieve the same class of observables. This is an extension of the results in [8], because local-choice ccp programs are clearly confluent (in the same way that logic programs are), but the converse is not always true. <p> We show that also for (structurally) confluent programs it is possible to define a denotational semantics along the lines of <ref> [8] </ref>, allowing us to retrieve the same class of observables. This is an extension of the results in [8], because local-choice ccp programs are clearly confluent (in the same way that logic programs are), but the converse is not always true. One of the drawbacks of the above notion of confluence, however, is that it is a co-semidecidable notion. <p> However, the interest for admissible ccp comes also from the fact that we can develop a denotational model correct (in the sense of program analysis) wrt a notion of observables more refined than the one considered in <ref> [8] </ref>: the input-output relation. Moreover, we show that for a subset of admissible programs (mutually-exclusive ccp, which essentially coincides with local-choice ccp), this model is correct (in the standard sense) wrt the input-output relation. <p> In particular, we have extended the results of <ref> [8] </ref> in two directions: First, the semantics shown in that paper has been extended to structurally confluent ccp, and proved still correct and fully abstract. Second, for the same class of programs we have developed a semantics for a more refined notion of observables (namely the input-output observables).
Reference: [9] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint Logic Programming, </title> <booktitle> in: Proc. 14th Annual ACM Symp. on Principles of Programming Languages (ACM Press, </booktitle> <address> New York, </address> <year> 1987) </year> <month> 111-119. </month>
Reference-contexts: Other notions of constraint systems, like the one based on First 4 We actually simplify the definition of [16] because we are interested only on finite observables. We don't require, for instance, the lattice to be complete. 4 Order Logic <ref> [9] </ref> can be seen as instances of this definition. All results of this paper still hold, of course, when more concrete systems are considered.
Reference: [10] <author> J. Lloyd. </author> <booktitle> Foundations of Logic Programming (2nd edition). </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1987 </year>
Reference-contexts: Intuitively, a process scheduling is a particular selection of a basic sub-agent for each transition in a computation. This concept generalizes the notion of the computation rule of Logic Programming <ref> [10] </ref>. Definition 3 Let C ! C 0 be a transition in T D . The selected agent in C is the (basic) agent of C if the transition is obtained by Rule R1, R2, or R5.
Reference: [11] <author> R. Milner, </author> <title> A Calculus of Communicating Systems, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 92 (Springer, </publisher> <address> Berlin, </address> <year> 1980). </year>
Reference: [12] <author> R. Milner, </author> <title> Communication and Concurrency (Prentice Hall International, </title> <address> UK, </address> <year> 1989). </year>
Reference: [13] <author> P. Panangaden and V. Shanbhogue, </author> <title> The expressive power of indeterminate dataflow primitives, </title> <note> Information and Computation 98(1) (1992) 99-131. </note>
Reference-contexts: Consider the following declaration D defining two producers p1 and p2, which respectively produce a stream of a's and b's of arbitrary length (where a, b are constants), and an agent m (angelic merge, <ref> [13] </ref>), which non-deterministically 37 merges its two input streams x and y into an output stream z. p1 (x) :- (ask (true) ! 9 x 0 (tell (x = [ajx 0 ]) k p1 (x 0 ))) + (ask (true) ! tell (x = [ ])) p2 (y) :- (ask (true)
Reference: [14] <author> V.A. Saraswat, </author> <title> Concurrent Constraint Programming, Logic Programming Series (The MIT Press, </title> <address> Cambridge, MA, </address> <year> 1993.) </year>
Reference: [15] <author> V.A. Saraswat and M. Rinard, </author> <title> Concurrent constraint programming, </title> <booktitle> in: Proc. 17th Annual ACM Symp. on Principles of Programming Languages (ACM Press, </booktitle> <address> New York, </address> <year> 1990) </year> <month> 232-245. </month>
Reference: [16] <author> V.A. Saraswat, M. Rinard and P. Panangaden, </author> <title> Semantics foundations of Concurrent Constraint Programming, </title> <booktitle> in: Proc. 18th Annual ACM Symp. on Principles of Programming Languages (ACM Press, </booktitle> <address> New York, </address> <year> 1991) </year> <month> 333-353. 41 </month>
Reference-contexts: Non-determinacy arises in two ways: because of a guarded choice construct and because of different process schedulings. Like for most of concurrent languages, the presence of guarded nondetermin-ism causes the denotational semantics of ccp to be rather complicated (see [3] and <ref> [16] </ref>), and therefore programs are difficult to analyze and to reason about. Various subsets of ccp, which admit a simpler semantics, have been investigated. In particular, determinate ccp [16], where no form of choice is allowed, and local-choice ccp [8], where choice is allowed, but it does not depend on the <p> most of concurrent languages, the presence of guarded nondetermin-ism causes the denotational semantics of ccp to be rather complicated (see [3] and <ref> [16] </ref>), and therefore programs are difficult to analyze and to reason about. Various subsets of ccp, which admit a simpler semantics, have been investigated. In particular, determinate ccp [16], where no form of choice is allowed, and local-choice ccp [8], where choice is allowed, but it does not depend on the external environment (i.e., the choice of the branch does not depend on the present store: the guard is checked after the branch is selected). <p> Section 6 shows applications to program analysis. 2 Concurrent constraint programming In this section we recall the definition of concurrent constraint programming, its operational semantics and observational behavior. We refer to <ref> [16] </ref> for more details. 2.1 Cylindric constraint systems Concurrent constraint programming is based on the notion of constraint system. Here we consider an abstract definition of such systems as lattices, following [16] 4 . <p> We refer to <ref> [16] </ref> for more details. 2.1 Cylindric constraint systems Concurrent constraint programming is based on the notion of constraint system. Here we consider an abstract definition of such systems as lattices, following [16] 4 . Other notions of constraint systems, like the one based on First 4 We actually simplify the definition of [16] because we are interested only on finite observables. <p> Here we consider an abstract definition of such systems as lattices, following <ref> [16] </ref> 4 . Other notions of constraint systems, like the one based on First 4 We actually simplify the definition of [16] because we are interested only on finite observables. We don't require, for instance, the lattice to be complete. 4 Order Logic [9] can be seen as instances of this definition. All results of this paper still hold, of course, when more concrete systems are considered.
Reference: [17] <author> E. Zaffanella, G. Levi and R. Giacobazzi, </author> <title> Abstracting synchronisation in concurrent constraint programming, </title> <editor> in: M. Hermenegildo and J. Penjam, eds., </editor> <booktitle> Proc. 6th Int'l Symp. on Programming Languages Implementation and Logic Programming, Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 844 (Springer, </publisher> <address> Berlin, </address> <year> 1994) </year> <month> 57-72. </month>
Reference-contexts: A similar transformation was independently proposed in <ref> [17] </ref>. The idea of using confluence for more efficient program analysis was investigated also in [4], in the context of concurrent logic programming (with atomic tell). <p> As a consequence of Theorem 56, for any result delivered by hA; ci in D, hME (A); ci gives the same result in some fixed computation tree for ME (D). Note that, as observed in <ref> [17] </ref>, the analysis based on the transformation ME can be improved by using A i k tell (c i ) rather than A i in the transformed agent.
References-found: 17

