URL: ftp://dimacs.rutgers.edu/pub/dimacs/TechnicalReports/TechReports/1997/97-64.ps.gz
Refering-URL: http://dimacs.rutgers.edu/TechnicalReports/1997.html
Root-URL: http://www.cs.rutgers.edu
Email: fdalia,reiter,rubing@research.att.com  
Title: Design and Implementation of a Java Playground  
Author: by Dahlia Malkhi Michael Reiter Avi Rubin 
Address: Florham Park, New Jersey, USA  
Affiliation: AT&T Labs|Research,  
Note: The  DIMACS is a partnership of Rutgers University, Princeton University, AT&T Labs, Bellcore, and Bell Labs. DIMACS is an NSF Science and Technology Center, funded under contract STC-91-19999; and also receives support from the New Jersey Commission on Science and Technology.  
Abstract: DIMACS Technical Report 97-64 September 1997 
Abstract-found: 1
Intro-found: 1
Reference: [BKKW96] <author> A. Baratloo, M. Karaul, Z. Kedem, and P. Wyckoff. </author> <title> Charlotte: Metacomputing on the Web. </title> <booktitle> In Proc. 9th Intl. Conf. on Parallel and Distributed Computing Systems, </booktitle> <year> 1996. </year>
Reference-contexts: Finally, our playground approach is limiting for applets intended to perform massively parallel computations on a vast array of machines, because our system centralizes applet executions on one or a few playgrounds. Examples of such intensive computations include large matrix computations (see, e.g., <ref> [BKKW96] </ref>) or cryptanalysis of ciphers. The emergence of more functional applets will undoubtedly raise new challenges in transparently executing them on a playground.
Reference: [DFW96] <author> D. Dean, E. W. Felten, and D. S. Wallach. </author> <title> Java security: From Hotjava to Netscape and beyond. </title> <booktitle> In Proceedings of the 1996 IEEE Symposium on Security and Privacy, </booktitle> <pages> pages 190-200, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: Moreover, mobile code "sandboxes" intended to constrain mobile code have in many cases proven unsatisfactory, in that errors in implementations enable mobile code to circument the sandbox's security mechanisms <ref> [DFW96, MF97] </ref>. One of the oldest ideas in security, computer or otherwise, is to physically separate the attacker from the resources of value. In this paper we present a novel approach for physically separating mobile code from those resources. <p> This approach has met with mixed success, in that even small implementation errors can enable applets to entirely bypass the security restrictions enforced by the sandbox <ref> [DFW96] </ref>. The second general approach is to execute only mobile code that is trusted based on some criteria. For example, Balfanz has proposed a Java filter that allows users to specify the servers from which to accept Java applets (see http://www.cs.princeton.edu/sip/). <p> Accessing and modifying protected resources Several bugs in the type safety mechanisms of Java have provided ways for applets to bypass Java sandboxes, including some in popular browsers <ref> [DFW96, MF97] </ref>. These penetrations typically enable the applet to perform any operation that the operating system allows, including reading and writing the user's files and opening network connections to other machines to attack them. <p> Although the sandbox mechanisms of most browsers are intended to separate applets in different web pages from one another, several ways of circumventing this separation have - 14 - been shown <ref> [DFW96, Lad96] </ref>. In our system, applets from each downloaded page run in a separate JVM on the playground under a separate user account, and hence cannot directly affect applets from another page (except by attacking the playground itself).
Reference: [Fla97] <author> D. Flanagan. </author> <title> Java in a Nutshell, Second edition, </title> <publisher> O'Reilly & Associates, </publisher> <year> 1997. </year>
Reference-contexts: A running Java applet consists of a collection of objects whose methods are invoked by a runtime system, and that in turn invoke one another's methods. For more information on Java see, e.g., <ref> [Fla97] </ref>. 3.1.1 Remote AWT classes The Abstract Window Toolkit (AWT) is the standard API for implementing graphical user interfaces (GUI) in Java programs. <p> Object serialization refers to the ability to write the complete state of an object to an output stream, and then recreate that object at some later time by reading its serialized state from an input stream <ref> [OSS96, Fla97] </ref>. Object serialization is central to remote method invocation|and thus to communication between the graphics server and the playground stubs|because it allows for method parameters to be passed to a remote method and the return value to be passed back.
Reference: [Her97] <author> A. Herbert. </author> <title> Secure mobile code management: Enabling Java for the enterprise. </title> <type> Manuscript, </type> <month> May </month> <year> 1997. </year>
Reference-contexts: We are unaware of descriptions of their system in the scientific literature, but information obtained from a white paper <ref> [Her97] </ref>, their web site (http://www.digitivity.com), and discussions with company representatives 1 have allowed us to identify several differences between our systems. <p> This may enable Digitivity to more easily tune its system's performance, but our approach promotes greater confidence in the security of our system by exposing it to maximum public scrutiny and understanding. Second, our system does not require trust in certain elements of the system that, according to <ref> [Her97] </ref>, are trusted in their architecture.
Reference: [Lad96] <author> M. Ladue. </author> <title> Pushing the limits of Java security. In Tricks of the Java Programming Gurus, </title> <editor> G. Vanderburg, ed., </editor> <publisher> Sams.net Publishing, </publisher> <year> 1996. </year>
Reference-contexts: This form of attack is typically considered very difficult to protect against, since it can be mounted simply by over-utilizing resources to which the applet has legitimate access. Ladue <ref> [Lad96] </ref> presents several such applets, e.g., that consume CPU even after the user clicks away from the applet origin page, that monopolize system locks, or that pop up windows on the user's screen endlessly. <p> One approach to defend against this is to configure the graphics server and/or the playground to limit the number or rate of window creations. In another type of denial of service, an applet may deny service to other applets within the JVM, e.g., by killing off others' threads <ref> [Lad96] </ref>. Although the sandbox mechanisms of most browsers are intended to separate applets in different web pages from one another, several ways of circumventing this separation have - 14 - been shown [DFW96, Lad96]. <p> Although the sandbox mechanisms of most browsers are intended to separate applets in different web pages from one another, several ways of circumventing this separation have - 14 - been shown <ref> [DFW96, Lad96] </ref>. In our system, applets from each downloaded page run in a separate JVM on the playground under a separate user account, and hence cannot directly affect applets from another page (except by attacking the playground itself). <p> For example, the applet can connect back to the server that served it, thus revealing the IP address of the user's machine. Note that such a connection is direct, thus bypassing any anonymity-providing proxies that the user might employ, such as the Anonymizer (see http://www.anonymizer.com). In <ref> [Lad96] </ref>, Ladue presents an applet that uses a sendmail trick to send mail on the user's behalf to a sendmail daemon running on the applet's server.
Reference: [LY97] <author> T. Lindholm and F. Yellin. </author> <title> The Java Virtual Machine Specification, </title> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: The applet that returns is in a format called Java bytecode, suitable for running in any JVM. This bytecode is subjected to a bytecode verification process, loaded into the browser's JVM, and executed. Further details can be found, e.g., in <ref> [LY97] </ref>. In our system, when a browser requests a web page, the request is sent to a proxy (Figure 1, step 1). The proxy forwards the request to the end server (step 2) and receives the requested page (step 3).
Reference: [MF97] <author> G. McGraw and E. W. Felten. </author> <title> Java Security: Hostile Applets, Holes, and Antidotes, </title> <publisher> John Wiley & Sons, </publisher> <year> 1997. </year>
Reference-contexts: Moreover, mobile code "sandboxes" intended to constrain mobile code have in many cases proven unsatisfactory, in that errors in implementations enable mobile code to circument the sandbox's security mechanisms <ref> [DFW96, MF97] </ref>. One of the oldest ideas in security, computer or otherwise, is to physically separate the attacker from the resources of value. In this paper we present a novel approach for physically separating mobile code from those resources. <p> The third approach to securing hosts from mobile code is simply to not run mobile code. A course-grained approach for Java is to simply disable Java in the browser. Another approach is to filter out all applets at a firewall [MRR97] (see also <ref> [MF97, Chapter 5] </ref>), which has the advantage of allowing applets served from behind the firewall to be executed. It has recently come to our attention that Digitivity, Inc., a California-based company, has independently proposed and is commercially developing a system similar to ours for defending against hostile Java applets. <p> Accessing and modifying protected resources Several bugs in the type safety mechanisms of Java have provided ways for applets to bypass Java sandboxes, including some in popular browsers <ref> [DFW96, MF97] </ref>. These penetrations typically enable the applet to perform any operation that the operating system allows, including reading and writing the user's files and opening network connections to other machines to attack them.
Reference: [MRR97] <author> D. Martin, S. Rajagopalan, and A. D. Rubin. </author> <title> Blocking Java applets at the firewall. </title> <booktitle> In Proceedings of the 1997 Internet Society Symposium on Network and Distributed System Security, </booktitle> <pages> pages 16-26, </pages> <month> February </month> <year> 1997. </year>
Reference-contexts: The third approach to securing hosts from mobile code is simply to not run mobile code. A course-grained approach for Java is to simply disable Java in the browser. Another approach is to filter out all applets at a firewall <ref> [MRR97] </ref> (see also [MF97, Chapter 5]), which has the advantage of allowing applets served from behind the firewall to be executed. <p> Trusted proxy One approach is to depend on the proxy to rewrite all incoming &lt;applet&gt; tags on HTML pages to point to the graphics server class (stored locally to the browser), and to further intercept and deny entry from any class files destined for protected machines (as in <ref> [MRR97] </ref>). Rewriting all &lt;applet&gt; tags ensures that the browser is never directed by an incoming page to load anything but the trusted graphics server.
Reference: [NL96] <author> G. C. Necula and P. Lee. </author> <title> Safe kernel extensions without run-time checking. </title> <booktitle> In Proceedings of the 2nd Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 229-243, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: This is the approach adopted for securing Microsoft's ActiveX content. In addition, a combination of this approach and the sandbox model is implemented in Netscape Communicator, which enforces access controls on an applet based on the signatures it possesses [WBDF97]. A third variation on this theme is proof-carrying code <ref> [NL96] </ref>, where the mobile code is accompanied by a proof that it satisfies certain properties. However, these techniques have not yet been applied to languages as rich as Java (or Java bytecodes). Our approach is compatible with both of the approaches described above.
Reference: [OSS96] <author> Sun Microsystems, Inc. </author> <title> Java Object Serialization Specification, Revision 1.2, </title> <month> December </month> <year> 1996. </year>
Reference-contexts: Object serialization refers to the ability to write the complete state of an object to an output stream, and then recreate that object at some later time by reading its serialized state from an input stream <ref> [OSS96, Fla97] </ref>. Object serialization is central to remote method invocation|and thus to communication between the graphics server and the playground stubs|because it allows for method parameters to be passed to a remote method and the return value to be passed back. <p> A first step toward securing RMI is to support authenticated and encrypted transport, so that a network attacker cannot alter or eavesdrop on communication between the browser and the playground. This can be achieved by interposing an encrypting connection implementation or similar protections at the object serialization layer (see <ref> [OSS96] </ref>). A more troubling threat is possible vulnerabilities in the object serialization routines that are used to marshal parameters to and return values from remote method invocations.
Reference: [RMIS97] <author> Sun Microsystems, Inc. </author> <title> Java Remote Method Invocation Specification, </title> <year> 1997. </year>
Reference-contexts: Once the BrowserServer object is initialized and prepared to service requests from the playground, it binds a remote reference to itself to the address assigned by the proxy; this binding is stored in an RMI name server <ref> [RMIS97] </ref>. The proxy remembers what address it assigned to each &lt;applet&gt; tag and provides this address to the playground in a similar fashion.
Reference: [WBDF97] <author> D. S. Wallach, D. Balfanz, D. Dean, and E. W. Felten. </author> <title> Extensible security architectures for Java. </title> <booktitle> In Proceedings of the 16th ACM Symposium on Operating Systems Principles, </booktitle> <month> October </month> <year> 1997. </year>
Reference-contexts: This is the approach adopted for securing Microsoft's ActiveX content. In addition, a combination of this approach and the sandbox model is implemented in Netscape Communicator, which enforces access controls on an applet based on the signatures it possesses <ref> [WBDF97] </ref>. A third variation on this theme is proof-carrying code [NL96], where the mobile code is accompanied by a proof that it satisfies certain properties. However, these techniques have not yet been applied to languages as rich as Java (or Java bytecodes). <p> However, it may well be possible with the more flexible policies implemented in recently (or soon-to-be) released versions of these products (e.g., <ref> [WBDF97] </ref>). Our system, as presently designed, would presumably constrain the applet to save the document on the playground.
References-found: 12

