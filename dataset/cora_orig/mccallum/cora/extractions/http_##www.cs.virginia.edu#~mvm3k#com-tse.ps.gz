URL: http://www.cs.virginia.edu/~mvm3k/com-tse.ps.gz
Refering-URL: http://www.cs.virginia.edu/~mvm3k/
Root-URL: http://www.cs.virginia.edu
Email: Email: -sullivan, marchukov-@Virginia.EDU; johns@asymmetrix.com  
Phone: Tel. (804) 982-2206, FAX: (804) 982-2214  
Title: Analysis of a Conflict Between Aggregation and Inter face Negotiation in Microsofts Component Object Model  
Author: Kevin J. Sullivan, Mark Marchukov, John Socha 
Address: Inc.  
Affiliation: University of Virginia Department of Computer Science and Asymetrix Learning Systems  
Abstract: Many software projects today are based on the integration of independently designed software components that are acquired on the market, rather than developed within the project itself. A component standard, or integration architecture, is a set of design rules meant to ensure that such components can be integrated in defined ways without undue effort. The rules of a component standard define, among other things, component interoperability and composition mechanisms. Understanding the properties of such mechanisms and interactions between them is important for the successful development and integration of software components, as well as for the evolution of component standards. This paper presents a rigorous analysis of two such mechanisms: component aggregation and dynamic interface negotiation, which were first introduced in Microsofts Component Object Model (COM). We show that interface negotiation does not function properly within COM aggregation boundaries. In particular, interface negotiation generally cannot be used to determine the identity and set of capabilities of aggregated components. This complicates integration within aggregates. We provide a mediator-based example, and show that the problem is in the sharing of interfaces inherent in COM aggregation. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> K. Brockschmidt, </author> <title> Inside OLE, </title> <publisher> Microsoft Press, </publisher> <year> 1995 </year>
Reference-contexts: These mechanisms were first introduced in Microsofts Component Object Model (COM), a standard that is now widely adopted by numerous software component vendors. COM provides the basis for higher-level standards: OLE <ref> [1] </ref> and ActiveX [25], the Distributed InterNet Applications Architecture (DNA) [14] and COM+ [10]. COM is supported on all Microsoft Windows platforms, Apples Macintosh, IBMs MVS, and some UNIX systems.
Reference: 2. <author> K. Brockschmidt, </author> <title> How OLE and COM Solve the Problems of Component Software Design, </title> <journal> Microsoft Systems Journal, v.11, </journal> <volume> no.5, </volume> <pages> pp. 63-82, </pages> <month> May </month> <year> 1996 </year>
Reference-contexts: It was found that when components were implemented as dynamically linked libraries, linkage problems occurred when services were changed <ref> [2] </ref>. If functions that a client expected in a library were not found the result was a catastrophic failure.
Reference: 3. <author> T. Bryant and A. Evans, </author> <title> Formalizing the object management group's core object model," Computer Standards & Interfaces, </title> <address> vol.17, no.5-6, </address> <year> 1995, </year> <pages> pp. 481-9 </pages>
Reference-contexts: They show that there are circumstances under which COM does not guarantee interoperability of independently designed components. More generally, any component standard or design that adopts mechanisms of interface negotiation and aggregation matching our model would suffer from the same problems. 6. Related Work Bryant and Evans <ref> [3] </ref> discuss a formalization of part of the OMG Core Object Model in Z, but they do not present the model or its consequences in detail. The authors say that the specification was meant to resolve ambiguities and inconsistencies in the standard and to ease negotiation among those defining it.
Reference: 4. <author> R. Englander, </author> <title> Developing Java Beans, </title> <publisher> OReilly and Associates, </publisher> <month> June </month> <year> 1997 </year>
Reference-contexts: Such a standard is a set of design rules meant to guarantee that independently designed components can be integrated in defined ways without undue effort. Examples of component standards are Mi-crosofts COM [2,5,9,13,16], Suns JavaBeans <ref> [4] </ref> and the CORBA object model [15]. Collectively, the rules of a component standard define a number of component instantia-tion, interoperation, composition, lifetime control, and other structures and mechanisms. Some of these mechanisms must be implemented by all compliant components; others are optional.
Reference: 5. <author> C. Goswell, </author> <title> The COM Programmers Cookbook, Microsoft Office Product Unit, </title> <note> Spring 1995, revised September 13, 1995, Available on the WorldWide Web at the time of submission of this paper through http://www.microsoft.com/oledev/olecom/com_co.htm </note>
Reference-contexts: This property is not made explicit in the COM specification or in many other widely published descriptions of COM. It is alluded to in Goswells highly technical and detailed Cookbook <ref> [5] </ref>. 23 The proof of this theorem is given in Appendix A. In a nutshell, because QueryInterface operations on inner components delegate to interfaces of outer components, queries on an inner interfaces for IID_IUnknown return the identity IUnknown of the outer component.
Reference: 6. <author> R. Grimes, </author> <title> Professional DCOM Programming, </title> <publisher> Wrox Press Inc, </publisher> <month> June </month> <year> 1997. </year> <month> 28 </month>
Reference-contexts: We said there that from any interface on a component it must be possible to get an interface of any type that the component exposes by calling QueryInterface just once. This rule is intuitive and adopted by several authoritative books <ref> [6, 25] </ref>. However, it is not the statement in the COM specification. The rules here, and in another authoritative book [16], are given in terms of what has been called stability (Appendix B, lines 4 through 12), and in terms of reflexivity, symmetry and transitivity (Appendix B, line 13ac). <p> A formal model of the reference counting rules of COM would help us verify whether that these rules ensure that components that follow them finalize and deallocate themselves when no longer referenced. Conflicts between reference counting and other mechanisms might remain. 27 The design of distributed COM (DCOM) <ref> [6] </ref>, which is the middleware that allows COM components to transparently communicate over the network, could also benefit from the kind of formal analysis that we have presented. The current DCOM design does not allow the outer and inner components of an aggregate reside in different address spaces.
Reference: 7. <author> W. Harris, </author> <title> Extending Mozilla, </title> <note> available on the WorldWide Web as a part of Net-scapes Mozilla technical documentation through http://www.mozilla.org/docs/tplist/catFlow/extendmoz.html </note>
Reference-contexts: Rather, dynamic interface negotiation and component aggregation can be seen as general mechanisms for component-based software design. For example, the designers of Netscapes Mozilla web browser incorporated versions of these mechanisms into their projectspecific design standard for independently developed modules [17] and plug-ins <ref> [7] </ref>. COM interface negotiation is an introspection and interoperability mechanism. When independently developed components are composed, they might not initially know each others capabilities.
Reference: 8. <author> I.S.C. Houston and M. Josephs, </author> <title> A formal description of the OMGs Core Object Model and the meaning of compatible extensions, </title> <journal> Computer Standards and Interfaces, </journal> <volume> vol. 17., </volume> <year> 1995, </year> <month> pp.553-558 </month>
Reference-contexts: The authors say that the specification was meant to resolve ambiguities and inconsistencies in the standard and to ease negotiation among those defining it. Its unclear how far this work has progressed. Houston and Josephs <ref> [8] </ref> give a more detailed Z model of the same OMG standard. They formalize the concept of a compatible extension to the Core Object Model and prove the compatibility of some simple extensions.
Reference: 9. <author> C. Kindel, </author> <title> The rules of the component object model, Microsoft Developer Network Library, </title> <type> Technical Articles: Windows: OLE COM, </type> <institution> Microsoft Corporation, </institution> <month> October 20, </month> <year> 1995. </year>
Reference-contexts: Other authoritative sources including Rogerson's "Inside COM" [16] and Kindel's "The Rules of COM" <ref> [9] </ref> use the version that we give as (Q4). This disagreement was a source of some confusion to us.
Reference: 10. <author> M. Kirtland, </author> <title> The COM+ Programming Model Makes it Easy to Write Components in Any Language, </title> <journal> Microsoft Systems Journal, </journal> <month> December, </month> <year> 1997, </year> <pages> pp. </pages> <year> 1928. </year>
Reference-contexts: These mechanisms were first introduced in Microsofts Component Object Model (COM), a standard that is now widely adopted by numerous software component vendors. COM provides the basis for higher-level standards: OLE [1] and ActiveX [25], the Distributed InterNet Applications Architecture (DNA) [14] and COM+ <ref> [10] </ref>. COM is supported on all Microsoft Windows platforms, Apples Macintosh, IBMs MVS, and some UNIX systems. Demand for COM components is estimated by Giga Information Group to be $410 million in 1997, with a projected 65 percent annual growth rate leading to a $3 billion market by 2001 [12].
Reference: 11. <author> Meisels, I. And M. Saaltink, </author> <title> The Z/EVES Reference Manual (for Version 1.3), </title> <type> Draft, </type> <institution> ORA Canada Technical Report TR-96-5493-03b, </institution> <month> December </month> <year> 1995, </year> <month> revised November </month> <year> 1996. </year>
Reference-contexts: We use Z as a convenient, reasonably well known formal specification language. Our model is based primarily on the rules of interface negotiation and aggregation given in the published COM specification. To verify the consistency of our model we used an automatic type checker and theorem prover Z/EVES <ref> [11] </ref>. To validate our model, we checked the theorems inferred from it against published works on COM, and also submitted them in a natural language form to the designers of the standard [26], who accepted the implications that we derived.
Reference: 12. <institution> Microsoft Corp., Microsoft Announces COM+, </institution> <note> Microsoft press release, Sept. 23, 1997. Available on the WorldWide Web at the time of submission of this paper through http://www.microsoft.com/corpinfo/press/1997/Sept97/COMplspr.htm </note>
Reference-contexts: COM is supported on all Microsoft Windows platforms, Apples Macintosh, IBMs MVS, and some UNIX systems. Demand for COM components is estimated by Giga Information Group to be $410 million in 1997, with a projected 65 percent annual growth rate leading to a $3 billion market by 2001 <ref> [12] </ref>. The importance of the interface negotiation and aggregation mechanisms defined in COM extends beyond COM components per se. Rather, dynamic interface negotiation and component aggregation can be seen as general mechanisms for component-based software design.
Reference: 13. <author> Microsoft Corp., </author> <title> The Component Object Model Specification, </title> <note> Draft Version 0.9, Oc-tober 24, 1995, </note> <institution> Microsoft Corporation and Digital Equipment Corporation. </institution> <note> Available on the WorldWide Web at the time of submission of this paper through http://www.microsoft.com/oledev/olecom/title.htm </note>
Reference-contexts: Second, to identify the cause and consequences of the conflict precisely, we develop a formal model of the interface negotiation and component aggregation mechanisms. Our models are based on the informal definitions of these mechanisms given in the COM specification <ref> [13] </ref>. Third, we show how the interference between the two mechanisms significantly We use the term aggregation not in its general sense, but to denote a particular component composition mechanism introduced by the COM specification. 3 complicates the implementation of an attractive component-based architectural style based on mediators [20,21,22]. <p> They allow clients to ask components for interfaces of types that clients need. Thus, in The semantics of these functions, which is also a part of the interface definition, is defined informally in p. 3.3.1 of the COM specification <ref> [13] </ref>. Spellchecker ptr 1 SetDictionary () ptr 2 ISpell IDictionary table of function pointers Client function3 () function1 () function2 () CheckWord () 5 dependently developed components negotiate for mutually familiar protocols through which they can interact meaningfully. <p> To model this aspect of QueryInterface precisely, we would have to introduce the notion of individual QueryInterface calls, which would complicate our model unnecessarily. Our theorems dont depend on this simplification in our model. 4.3. Components The COM specification uses the term component to denote both instances and classes <ref> [13, p.1.1.5] </ref>. Because interface negotiation and aggregation is defined on component instances only, we do not model classes of components. We model instances with the schema type Component, below. Our model of components is tailored specifically to the 16 needs of our analysis.
Reference: 14. <author> Microsoft Corporation, </author> <title> Windows DNA Windows Distributed interNet Applications Architecture, Integrating Web and Client/Server Computing: </title> <institution> A Microsoft Corp. </institution> <note> White Paper. Available on the WorldWide Web at the time of submission through http://www.microsoft.com/sitebuilder/dna/overview/dnawp.asp </note>
Reference-contexts: These mechanisms were first introduced in Microsofts Component Object Model (COM), a standard that is now widely adopted by numerous software component vendors. COM provides the basis for higher-level standards: OLE [1] and ActiveX [25], the Distributed InterNet Applications Architecture (DNA) <ref> [14] </ref> and COM+ [10]. COM is supported on all Microsoft Windows platforms, Apples Macintosh, IBMs MVS, and some UNIX systems.
Reference: 15. <author> Object Management Group, </author> <title> "The Common Object Request Broker: Architecture and Specification", </title> <booktitle> Object Management Group, </booktitle> <year> 1997 </year>
Reference-contexts: Such a standard is a set of design rules meant to guarantee that independently designed components can be integrated in defined ways without undue effort. Examples of component standards are Mi-crosofts COM [2,5,9,13,16], Suns JavaBeans [4] and the CORBA object model <ref> [15] </ref>. Collectively, the rules of a component standard define a number of component instantia-tion, interoperation, composition, lifetime control, and other structures and mechanisms. Some of these mechanisms must be implemented by all compliant components; others are optional.
Reference: 16. <author> D. Rogerson, </author> <title> Inside COM, </title> <publisher> Microsoft Press, </publisher> <year> 1997 </year>
Reference-contexts: The ability to assign IIDs in a decentralized manner allows independent designers to develop components without name clashes. The interface negotiation mechanism implemented by QueryInterface is at the heart of the design of COM: QueryInterface defines the component <ref> [16, p.56] </ref>. It is the only mechanism through which components expose interfaces to clients. <p> This rule is intuitive and adopted by several authoritative books [6, 25]. However, it is not the statement in the COM specification. The rules here, and in another authoritative book <ref> [16] </ref>, are given in terms of what has been called stability (Appendix B, lines 4 through 12), and in terms of reflexivity, symmetry and transitivity (Appendix B, line 13ac). We take the rules from the published specification. We prove as a theorem, below, that the rules imply the simplified version. <p> This is one of the main points in the informal rules 0 3 in Section 2, given in many COM-related publications as the rules for QueryInterface. The question arises: Are the rules of the COM specification (also presented in sources such as Inside COM <ref> [16] </ref>) necessary to provide this property, or do the simpler rules suffice? Our analysis shows that it is possible to simplify the published rules. <p> Other authoritative sources including Rogerson's "Inside COM" <ref> [16] </ref> and Kindel's "The Rules of COM" [9] use the version that we give as (Q4). This disagreement was a source of some confusion to us.
Reference: 17. <author> W. Scullin, </author> <title> Modularization Techniques, </title> <note> available on the WorldWide Web as a part of Netscapes Mozilla technical documentation through http://www.mozilla.org/docs/tplist/catFlow/modunote.htm </note>
Reference-contexts: Rather, dynamic interface negotiation and component aggregation can be seen as general mechanisms for component-based software design. For example, the designers of Netscapes Mozilla web browser incorporated versions of these mechanisms into their projectspecific design standard for independently developed modules <ref> [17] </ref> and plug-ins [7]. COM interface negotiation is an introspection and interoperability mechanism. When independently developed components are composed, they might not initially know each others capabilities.
Reference: 18. <author> A. Snyder, </author> <title> Modeling the C++ Object Model," </title> <booktitle> Proceedings of ECOOP91. European Conference on ObjectOriented Programming, </booktitle> <pages> pp. 1-20, </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: By contrast, we focus on novel programming mechanisms pertinent to component-based development: multi-interface components, dynamic interface negotiation, and aggregation. Snyder <ref> [18] </ref> applies a semiformal abstract object model in an analysis of the C++ object model. His analysis reveals several problems in the design of the language and identifies cases whose behavior did not appear to be defined by the existing language definition. From a methodological perspective, our approaches are similar.
Reference: 19. <author> M. Spivey, </author> <title> The Z Notation: A Reference Manual, </title> <publisher> Prentice-Hall, </publisher> <year> 1992 </year>
Reference-contexts: To be able to reason convincingly about the properties of the mechanisms of interest, we developed a mathematical model of interface negotiation and aggregation in the form of a formal specification written in Z <ref> [19] </ref>. We use Z as a convenient, reasonably well known formal specification language. Our model is based primarily on the rules of interface negotiation and aggregation given in the published COM specification. To verify the consistency of our model we used an automatic type checker and theorem prover Z/EVES [11].
Reference: 20. <author> Sullivan, K.J., Mediators: </author> <title> Easing the Design and Evolution of Integrated Systems, </title> <type> Ph.D. Dissertation, </type> <institution> University of Washington Department of Computer Science, </institution> <month> August </month> <year> 1994. </year>
Reference: 21. <author> Sullivan, K.J. and D. Notkin, </author> <title> Reconciling Environment Integration and Evolution, </title> <journal> ACM Transactions on Software Engineering and Methodology vol. </journal> <volume> 1, no. 3, </volume> <month> July </month> <year> 1992. </year>
Reference: 22. <author> Sullivan, K.J., I.J. Kalet and D. Notkin, </author> <title> Mediators in a Radiation Treatment Planning System, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 22, no. 8, </volume> <month> August </month> <year> 1996, </year> <pages> pp. 563-579. </pages>
Reference: 23. <author> Sullivan, K.J. and M. Marchukov, </author> <title> "Mediator Integration of COM Components," </title> <note> to appear in IEEE Software. 29 </note>
Reference-contexts: Although we do not discuss workarounds here, in another paper we describe a partial solution based on additional constraints on the interfaces through which aggregated components query peers <ref> [23] </ref>. Specifically, components inside aggregates can only query each other through hidden IUnknown interfaces. Querying through any other interface allows an adversarial outer component to confuse the inner by returning an outer interface.
Reference: 24. <author> Sullivan, K.J., J. Socha and M. Marchukov, </author> <title> "Using Formal Methods to Reason About Architectural Standards," </title> <booktitle> Proceedings of the 19th International Conference on Software Engineering, </booktitle> <pages> pp. 503-513, </pages> <publisher> ACM press, </publisher> <month> May </month> <year> 1997 </year>
Reference-contexts: The COM rules do not prohibit the use of aggregation to encapsulate a system of communicating components as a new component, but, as we discovered, the conflict between aggregation and interface negotiation leads to problems that cannot be ignored. Our analysis <ref> [24] </ref> showed the infeasibility of the proposed style and persuaded Socha to replace aggregation with a simpler but less efficient compositional mechanism of containment. To make the problems clear, consider what happened when we pursued the proposed mediator architectural style.
Reference: 25. <author> A. Williams, </author> <title> Developing ActiveX Web Controls, Coriolis Group, </title> <year> 1996 </year>
Reference-contexts: These mechanisms were first introduced in Microsofts Component Object Model (COM), a standard that is now widely adopted by numerous software component vendors. COM provides the basis for higher-level standards: OLE [1] and ActiveX <ref> [25] </ref>, the Distributed InterNet Applications Architecture (DNA) [14] and COM+ [10]. COM is supported on all Microsoft Windows platforms, Apples Macintosh, IBMs MVS, and some UNIX systems. <p> We said there that from any interface on a component it must be possible to get an interface of any type that the component exposes by calling QueryInterface just once. This rule is intuitive and adopted by several authoritative books <ref> [6, 25] </ref>. However, it is not the statement in the COM specification. The rules here, and in another authoritative book [16], are given in terms of what has been called stability (Appendix B, lines 4 through 12), and in terms of reflexivity, symmetry and transitivity (Appendix B, line 13ac).
Reference: 26. <author> T. Williams, </author> <title> Microsoft Corporation, </title> <type> Personal Communication. </type>
Reference-contexts: To verify the consistency of our model we used an automatic type checker and theorem prover Z/EVES [11]. To validate our model, we checked the theorems inferred from it against published works on COM, and also submitted them in a natural language form to the designers of the standard <ref> [26] </ref>, who accepted the implications that we derived. We first model the basic concepts underlying the interface negotiation and aggregation mechanisms: components, interfaces, interface types and identifiers. Then we state axioms formalizing the QueryInterface and aggregation rules. 4.1.
Reference: 27. <editor> X/Open Preliminary Specification X/Open DCE: </editor> <title> Remote Procedure Call, </title> <publisher> X/Open Company Ltd., </publisher> <year> 1993. </year>
Reference-contexts: COM does not require the use of a special interface definition language (IDL) for this purpose. C++ abstract class declarations, Java interfaces, and other mechanisms can be used. COM does take Microsofts version of the Distributed Computing Environment (DCE) IDL <ref> [27] </ref> as a preferred notation. in this IDL 1 interface IUnknown - HRESULT QueryInterface ([in] REFIID iid, [out] void **ppv) ; ULONG AddRef (void) ; ULONG Release (void) ; - Because IUnknown is the root of the interface type hierarchy, its operations are accessible through any interface. <p> IIDs are unique with high probability, distinguishing among interface types no matter where they were developed, when, or by whom. An IID is actually a 128-bit number generated by an algorithm that is a part of the X/Open DCE standard <ref> [27] </ref>. For example, the IID of the IUnknown type is 00000000-0000-0000-C000-000000000046, and has the mnemonic name IID_IUnknown. The ability to assign IIDs in a decentralized manner allows independent designers to develop components without name clashes.
References-found: 27

