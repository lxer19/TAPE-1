URL: http://ficus-www.cs.ucla.edu/classes/239_2.spring96/papers/UW-CSE-92-03-02.ps
Refering-URL: http://ficus-www.cs.ucla.edu/project-members/reiher/CS239_spring96.html
Root-URL: http://www.cs.ucla.edu
Title: How to Use a 64-Bit Virtual Address Space  
Author: Jeffrey S. Chase, Henry M. Levy, Miche Baker-Harvey, and Edward D. Lazowska 
Date: 92-03-02  
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering, FR-35 University of Washington  
Pubnum: Technical Report  
Abstract: The recent appearance of architectures with flat 64-bit virtual addressing opens an opportunity to reconsider our use of virtual address spaces. In this paper we argue for an alternative addressing model, in which all programs and data reside in a single global virtual address space shared by multiple protection domains. Hardware-based memory protection exists within the single address space, providing firewalls as strong as in conventional systems. We explore the tradeoffs in the use of a global virtual address space relative to the private address space model. We contend that a shared address space can eliminate obstacles to efficient sharing and exchange of data structures that are inherent in private address space systems. The shared address space offers advantages similar to some capability-based computer systems, but can be implemented on standard page-based hardware, without the performance costs and restricted data model typical of capability-based systems. We introduce Opal, an operating system to support this model on paged 64-bit architectures. The key feature of Opal is a flat virtual address space that includes data on long-term storage and across the network.
Abstract-found: 1
Intro-found: 1
Reference: [Anderson et al. 91a] <author> T. E. Anderson, B. N. Bershad, E. D. Lazowska, and H. M. Levy. </author> <title> Scheduler activations: Effective kernel support of the user-level management of parallelism. </title> <booktitle> In Proceedings of the 13th Symposium on Operating System Principles, </booktitle> <pages> pages 95-109, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Module-grain code sharing can substantially reduce storage demands and runtime load latency, and it is increasingly important as: (1) runtime packages implementing high-level programming abstractions (e.g., for graphics and user-interface support) continue to grow in size and popularity, and (2) traditional operating system kernel functions (e.g., thread management <ref> [Anderson et al. 91a] </ref>) migrate into runtime packages. Of course, globally linked modules must be relinked if they contain references to some other module that has been modified. However, modules that have large numbers of references to them tend to be standard runtime libraries that are modified relatively rarely.
Reference: [Anderson et al. 91b] <author> T. E. Anderson, H. M. Levy, B. N. Bershad, and E. D. Lazowska. </author> <title> The interaction of architecture and operating system design. </title> <booktitle> In Proceedings of the Fourth Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 108-121, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: Variations of these mechanisms are useful when there is partial trust. Section 3.4 outlines some of the possibilities. Current software and architectural trends motivate more creative use of direct sharing. Data copying and protection domain switches have increased in cost relative to integer performance on recent processors <ref> [Ousterhout 90, Anderson et al. 91b] </ref>. At the same time, software systems are growing in complexity, 3 encouraging decomposition into multiple protection domains. The recent move toward server-structured microkernel operating systems is one important example of this trend.
Reference: [Bershad et al. 90] <author> B. Bershad, T. Anderson, E. Lazowska, and H. Levy. </author> <title> Lightweight remote procedure call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(1), </volume> <month> February </month> <year> 1990. </year>
Reference-contexts: Linearized data must be packed by the sender and unpacked by the receiver; both must traverse and copy the entire structure. Transmitted data is copied from as few as two times (for optimized local RPC implementations <ref> [Bershad et al. 90] </ref>) to as many as four times or more (for transmission through Unix pipes, files, messages, or sockets).
Reference: [Birrell et al. 87] <author> A. Birrell, M. Jones, and E. Wobber. </author> <title> A simple and efficient implementation for small databases. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 149-154, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: Pickles have been used effectively for self-contained structures that are used in their entirety, e.g., a program reading a small private data base on startup <ref> [Birrell et al. 87] </ref>. Linearizing has serious limitations as a general-purpose mechanism for translating data structures from one address space to another. Linearized data must be packed by the sender and unpacked by the receiver; both must traverse and copy the entire structure.
Reference: [Chang & Mergen 88] <author> A. Chang and M. F. Mergen. </author> <title> 801 Storage: Architecture and Programming. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 28-50, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: It is most efficient to rely on voluntary compliance with locking protocols implemented in the runtime system, but the system can also enforce locking at a coarse granularity by arbitrating page access permissions within the segment. A similar scheme is described in <ref> [Chang & Mergen 88] </ref>. * Producer/Consumer. Data is passed through a segment that is writable by the producer but readonly to the consumer. The producer is fully isolated, but the consumer trusts the producer to comply with usage and synchronization conventions. * Argument/Result.
Reference: [Chao et al. 90] <author> C. Chao, M. Mackey, and B. Sears. </author> <title> Mach on a virtually addressed cache architecture. </title> <booktitle> In Usenix Mach Workshop Proceedings, </booktitle> <pages> pages 31-51, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: It might appear that copy-on-write is incompatible with uniform addressing, because it introduces aliasing in the form of multiple virtual mappings to the same physical page. But in fact, copy-on-write introduces only a restricted and benign form of aliasing called readonly aliasing <ref> [Chao et al. 90] </ref>. Readonly aliasing is a hidden optimization that neither violates the consistent interpretation of pointers nor interferes with the use of a virtually addressed data cache, leaving intact the benefits we claim for uniform addressing.
Reference: [Chase & Levy 91] <author> J. S. Chase and H. M. Levy. </author> <title> Supporting cooperation on wide-address computers. </title> <institution> Department of Computer Science and Engineering Technical Report 91-03-10, University of Washington, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: In fact, our original proposal for global addressing suggested that a shared address space on 64-bit architectures should be implemented as a policy in microkernel operating systems, which make no assumptions about virtual address space usage by protection domains <ref> [Chase & Levy 91] </ref>. We are now pursuing the pure single address space model for two reasons. First, we believe that context-dependent addressing introduces a dangerous non-uniformity to the system. Once it is present, programs can no longer assume that a virtual address has the same meaning to another domain.
Reference: [Cockshot et al. 84] <author> W. P. Cockshot, M. P. Atkinson, and K. J. Chisholm. </author> <title> Persistent object management system. </title> <journal> Software Practice and Experience, </journal> <volume> 14(1), </volume> <month> January </month> <year> 1984. </year>
Reference-contexts: A third pointer form may be needed to represent pointers to data outside of whatever naming context the surrogates are defined in. Examples include cross-segment pointers in a segmented architecture, or cross-database pointers in some persistent object stores <ref> [Cockshot et al. 84] </ref>. If there is no globally uniform name space for pointers, the reference may be qualified by a symbolic name (e.g., a file name). Symbolic names are designed for human consumption, and are inappropriate for use as pointers.
Reference: [Daley & Dennis 68] <author> R. C. Daley and J. B. Dennis. </author> <title> Virtual memory, processes, and sharing in MULTICS. </title> <journal> Communications of the ACM, </journal> <volume> 11(5) </volume> <pages> 306-312, </pages> <month> May </month> <year> 1968. </year>
Reference-contexts: Psyche restricts its address space to data in active use on a single computer, partly because the system runs in a 32-bit address space. However, most of the benefits claimed for context-independent addressing in Opal apply equally to non-persistent storage in Psyche. Systems with segmented addressing (e.g., Multics <ref> [Daley & Dennis 68] </ref>) have some of the properties of uniform-address systems. The first phase of address translation on segmented architectures concatenates a global segment identifier with a segment offset, yielding a long-form address from a global virtual address space.
Reference: [Dobberpuhl et al. 92] <author> D. Dobberpuhl, R. Witek, R. Allmon, R. Anglin, D. Bertucci, S. Britton, L. Chao, R. Conrad, D. Dever, B. Gieseke, S. Hassoun, G. Hoeppner, J. Kowaleski, K. Kuchler, M. Ladd, M. Leary, L. Madden, E. McLellan, D. Meyer, J. Montanaro, D. Priore, V. Rajagopalan, S. Samu-drala, and S. Santhanam. </author> <title> A 200mhz 64 bit dual issue CMOS microprocessor. </title> <booktitle> In International Solid-State Circuits Conference 1992, </booktitle> <month> February </month> <year> 1992. </year>
Reference-contexts: This trend can be seen, for example, in the architectures of the HP PA-RISC [Lee 89], and the IBM RS/6000 [Groves & Oehler 90]. The MIPS R4000 [MIP 91] and Digital's recently announced Alpha family <ref> [Dobberpuhl et al. 92] </ref> are the first architectures with unsegmented 64-bit address spaces. Unlike the move from 16- to 32-bit addressing, a 64-bit address space could be revolutionary instead of evolutionary with respect to the way operating systems and applications use virtual memory.
Reference: [Eppinger 89] <author> J. L. Eppinger. </author> <title> Virtual Memory Management for Transaction Processing Systems. </title> <type> PhD dissertation, </type> <institution> Carnegie Mellon University, </institution> <month> February </month> <year> 1989. </year> <month> CMU-CS-89-115. </month>
Reference-contexts: Pointers within shared pages can then be represented as unencoded virtual addresses. For example, virtual addresses can be saved directly in a mapped file if that file is always mapped at the same address by any program that uses it; this is the approach used by Camelot <ref> [Eppinger 89] </ref> to support databases with pointers in them. The problem with this solution is that the overlapping address ranges are negotiated ad hoc, so naming conflicts will occur if sharing patterns are not known statically. Furthermore, the mix of shared and private regions introduces dangerous ambiguity.
Reference: [Groves & Oehler 90] <author> R. D. Groves and R. Oehler. </author> <title> RISC system/6000 processor architecture. </title> <editor> In M. Misra, editor, </editor> <booktitle> IBM RISC System/6000 Technology, </booktitle> <pages> pages 16-23. </pages> <booktitle> International Business Machines, </booktitle> <year> 1990. </year> <month> 16 </month>
Reference-contexts: This trend can be seen, for example, in the architectures of the HP PA-RISC [Lee 89], and the IBM RS/6000 <ref> [Groves & Oehler 90] </ref>. The MIPS R4000 [MIP 91] and Digital's recently announced Alpha family [Dobberpuhl et al. 92] are the first architectures with unsegmented 64-bit address spaces.
Reference: [Herlihy & Liskov 82] <author> M. Herlihy and B. Liskov. </author> <title> A value transmission method for abstract data types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(4) </volume> <pages> 527-551, </pages> <month> October </month> <year> 1982. </year>
Reference-contexts: In the presence of sharing this is frequently not the case, as discussed in Section 2.4 2.1 Copy-Time Translation The standard technique for sharing data structures in process-based systems is to recursively linearize them for exchange through a file, pipe, or message <ref> [Herlihy & Liskov 82] </ref>. This technique was originally developed for gathering data into a message buffer (marshaling), but it has also been used to represent data structures on secondary storage (pickling).
Reference: [Hornick & Zdonik 87] <author> M. F. Hornick and S. B. Zdonik. </author> <title> A shared, segmented memory system for an object-oriented database. </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 5(1), </volume> <month> January </month> <year> 1987. </year>
Reference-contexts: The simplest scheme is to represent pointers as offsets into a file or memory segment. A variety of complex schemes for surrogates have been developed, using one or more levels of indirection through mapping tables. This approach is used by persistent object stores <ref> [Moss 89, Hornick & Zdonik 87] </ref> and commercial object-oriented database systems. The pointer indirection in these systems allows objects to be easily moved to a different part of the address space, to compact storage or to improve clustering properties. Reference-time translation has a heavy runtime cost.
Reference: [Koldinger et al. 91] <author> E. J. Koldinger, H. M. Levy, J. S. Chase, and S. J. Eggers. </author> <title> The protection looka-side buffer: Efficient protection for single-address space computers. </title> <type> Technical Report 91-11-05, </type> <institution> University of Washington, Department of Computer Science and Engineering, </institution> <month> November </month> <year> 1991. </year>
Reference-contexts: We have noted elsewhere <ref> [Koldinger et al. 91] </ref> that context-independent addressing frees processor hardware from the need to support multiple sets of address translations, allowing optimizations in the memory system, notably the trouble-free use of a virtually addressed data cache. <p> Thus the value of a cache line is never modified in a way that affects the value of another cache line. A more detailed discussion of the relationship between uniform addressing and virtual data caches can be found in <ref> [Koldinger et al. 91] </ref>. Because readonly aliasing is harmless, a uniform-address system can use copy-on-write in every instance that a process-based system can, except when pointers in the copied data must be translated.
Reference: [Lee 89] <author> R. B. Lee. </author> <title> Precision architecture. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 78-91, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: This trend can be seen, for example, in the architectures of the HP PA-RISC <ref> [Lee 89] </ref>, and the IBM RS/6000 [Groves & Oehler 90]. The MIPS R4000 [MIP 91] and Digital's recently announced Alpha family [Dobberpuhl et al. 92] are the first architectures with unsegmented 64-bit address spaces. <p> The Hewlett-Packard Precision <ref> [Lee 89] </ref> differs from other segmented architectures in that it allows applications to specify long-form virtual addresses directly. Thus the Precision could support a uniform-address operating system. However, long-form pointer dereference requires a sequence of four instructions, so most software for the Precision uses segmented addressing.
Reference: [Levy 84] <author> H. M. Levy. </author> <title> Capability-Based Computer Systems. </title> <publisher> Digital Press, </publisher> <address> Bedford, Massachusetts, </address> <year> 1984. </year>
Reference-contexts: Thus the Precision could support a uniform-address operating system. However, long-form pointer dereference requires a sequence of four instructions, so most software for the Precision uses segmented addressing. Most capability-based architectures <ref> [Organick 83, Levy 84] </ref> support uniform sharing of data structures.
Reference: [McJones & Swart 87] <author> P. R. McJones and G. F. Swart. </author> <title> Evolving the Unix system interface to support multithreaded programs. </title> <type> Technical Report 21, </type> <institution> DEC Systems Research Center, </institution> <month> September </month> <year> 1987. </year>
Reference-contexts: The majority of the state cloned by a fork is not needed by the child, inspiring efforts to improve performance by cloning data lazily (e.g., copy-on-write) or avoiding the copy altogether (e.g., the vfork primitive in 4.2 BSD). The cloning semantics of fork also interfere with support for threads <ref> [McJones & Swart 87] </ref>. Opal replaces fork with primitives to create and destroy protection domains, and initialize them by attaching segments and installing RPC endpoints. The parent domain starts a thread in the child by making a cross-domain call to it.
Reference: [MIP 91] <institution> MIPS Computer Systems, Inc., Sunnyvale, CA. </institution> <note> MIPS R4000 Microprocessor User's Manual, first edition, </note> <year> 1991. </year>
Reference-contexts: This trend can be seen, for example, in the architectures of the HP PA-RISC [Lee 89], and the IBM RS/6000 [Groves & Oehler 90]. The MIPS R4000 <ref> [MIP 91] </ref> and Digital's recently announced Alpha family [Dobberpuhl et al. 92] are the first architectures with unsegmented 64-bit address spaces.
Reference: [Moss 89] <author> J. E. B. Moss. </author> <title> The Mneme persistent object store. </title> <type> COINS Technical Report 89-107, </type> <institution> University of Massachusetts at Amherst, </institution> <month> October </month> <year> 1989. </year>
Reference-contexts: The simplest scheme is to represent pointers as offsets into a file or memory segment. A variety of complex schemes for surrogates have been developed, using one or more levels of indirection through mapping tables. This approach is used by persistent object stores <ref> [Moss 89, Hornick & Zdonik 87] </ref> and commercial object-oriented database systems. The pointer indirection in these systems allows objects to be easily moved to a different part of the address space, to compact storage or to improve clustering properties. Reference-time translation has a heavy runtime cost.
Reference: [Organick 83] <author> E. I. Organick. </author> <title> A Programmer's View of the Intel 432 System. </title> <publisher> McGraw-Hill, </publisher> <year> 1983. </year>
Reference-contexts: Thus the Precision could support a uniform-address operating system. However, long-form pointer dereference requires a sequence of four instructions, so most software for the Precision uses segmented addressing. Most capability-based architectures <ref> [Organick 83, Levy 84] </ref> support uniform sharing of data structures.
Reference: [Ousterhout 90] <author> J. K. Ousterhout. </author> <booktitle> Why aren't operating systems getting faster as fast as hardware? In Proceedings of the Summer 1990 USENIX Conference, </booktitle> <pages> pages 247-256, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Variations of these mechanisms are useful when there is partial trust. Section 3.4 outlines some of the possibilities. Current software and architectural trends motivate more creative use of direct sharing. Data copying and protection domain switches have increased in cost relative to integer performance on recent processors <ref> [Ousterhout 90, Anderson et al. 91b] </ref>. At the same time, software systems are growing in complexity, 3 encouraging decomposition into multiple protection domains. The recent move toward server-structured microkernel operating systems is one important example of this trend.
Reference: [Redell et al. 80] <author> D. Redell, Y. Dalal, T. Horsley, H. Lauer, W. Lynch, P. McJones, H. Murray, and S. Purcell. </author> <title> Pilot: An operating system for a personal computer. </title> <journal> Communications of the ACM, </journal> <volume> 23(2) </volume> <pages> 81-92, </pages> <month> February </month> <year> 1980. </year>
Reference-contexts: Only now is hardware advancing to the point that it is practical to organize a general-purpose operating system in this way. Cedar [Swinehart et al. 86] and its predecessor Pilot <ref> [Redell et al. 80] </ref> used a single virtual address space on hardware that supported only one protection domain. These were viewed as single-user systems because there was no hardware-based memory protection; both systems relied solely on defensive protection from the name scoping and type rules of a special-purpose programming language.
Reference: [Sabatella 90] <author> M. Sabatella. </author> <title> Issues in shared library design. </title> <booktitle> In Proceedings of the Usenix Conference, </booktitle> <pages> pages 11-22, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: In process-based systems, comparable support for shared libraries involves the same restrictions on absolute addressing that we have made, and even with those restrictions, requires dynamic linking and/or indirect addressing through linkage tables (e.g., for cross-module branches) <ref> [Sabatella 90] </ref>. 12 4.4 The Trouble With Fork The Unix fork operation is defined to clone the parent process execution context, including its private address space, in the child process.
Reference: [Saltzer 78] <author> J. H. Saltzer. </author> <title> Naming and binding of objects. </title> <editor> In R. Bayer, R. M. Graham, and G. Seegmuller, editors, </editor> <booktitle> Operating Systems: An Advanced Course (Lecture Notes in Computer Science 60), </booktitle> <pages> pages 99-208. </pages> <publisher> Springer-Verlag, </publisher> <year> 1978. </year>
Reference-contexts: Section 2 listed some of these apparent benefits, all of which stem from context-dependent addressing in process-based systems. The question we wish to answer is: what will we lose if we build our operating systems with fully context-independent addressing? Broadly, context-dependent naming has two useful properties <ref> [Saltzer 78] </ref>. * Free choice of names. Within a context, names can be assigned freely without danger of conflict with names used by other contexts (assuming no sharing occurs). * Retargetable name bindings. It is sometimes useful for users to deliberately assign different interpreta tions to the same name.
Reference: [Scott et al. 90] <author> M. L. Scott, T. J. LeBlanc, and B. D. Marsh. </author> <booktitle> Multi-model parallel programming in Psyche. In Proceedings of the Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 70-78, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: These were viewed as single-user systems because there was no hardware-based memory protection; both systems relied solely on defensive protection from the name scoping and type rules of a special-purpose programming language. Our proposal generalizes this model to multiple protection domains. The term "uniform addressing" was introduced in Psyche <ref> [Scott et al. 90] </ref>, which also has a single virtual address space shared by multiple protection domains. Psyche uses cooperating protection domains primarily as a means of separating different components of a single parallel application with different models of parallelism and different scheduling needs.
Reference: [Stonebraker 81] <author> M. Stonebraker. </author> <title> Operating system support for database management. </title> <journal> Communications of the ACM, </journal> <volume> 24(7) </volume> <pages> 412-418, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: Despite its name, the ASID has little to do with address spaces. 8 write calls. Also, the integration of file cache management with the virtual memory system avoids two-level caching problems, such as double paging and unnecessary consumption of swap space <ref> [Stonebraker 81] </ref>.
Reference: [Swinehart et al. 86] <author> D. Swinehart, P. Zellweger, R. Beach, and R. Hagmann. </author> <title> A structural view of the Cedar programming environment. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(8), </volume> <month> October </month> <year> 1986. </year>
Reference-contexts: Uniform-address systems have been built before on the claim of improved support for sharing, but these systems suffered from the limitations of their hardware platforms. Only now is hardware advancing to the point that it is practical to organize a general-purpose operating system in this way. Cedar <ref> [Swinehart et al. 86] </ref> and its predecessor Pilot [Redell et al. 80] used a single virtual address space on hardware that supported only one protection domain.
Reference: [Wilson 91] <author> P. R. Wilson. </author> <title> Pointer swizzling at page fault time: Efficiently supporting huge address spaces on standard hardware. </title> <journal> ACM SIGARCH Computer Architecture News, </journal> <volume> 19(4), </volume> <month> June </month> <year> 1991. </year> <institution> University of Illinois at Chicago Technical Report UIC-EECS-90-6, </institution> <month> December </month> <year> 1990. </year>
Reference-contexts: It has recently been suggested that a swizzling paging system could be used to support programs that demand more than 32 bits of address space, as a software alternative to wide-address hardware. Wil-son <ref> [Wilson 91] </ref> proposes a system that uses wide pointers in a disk representation of the data, swizzled to 2 The dereference sequence needs an add instruction as well as the usual two loads from memory.
Reference: [Young et al. 87] <author> M. Young, A. Tevanian, R. Rashid, D. Golub, J. Eppinger, J. Chew, W. Bolosky, D. Black, and R. Baron. </author> <title> The duality of memory and communication in the implementation of a mulitpro-cessor operating system. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 63-76, </pages> <month> November </month> <year> 1987. </year> <month> 17 </month>
Reference-contexts: A privileged domain has direct access to segments attached to client domains that rely on it for some service, e.g., supporting some aspect of the programming environment. The privileged component might be a debugger, an external paging server <ref> [Young et al. 87] </ref>, or a garbage collector or transaction manager for data structures that span client domains. * Soft Firewalls.
References-found: 30

