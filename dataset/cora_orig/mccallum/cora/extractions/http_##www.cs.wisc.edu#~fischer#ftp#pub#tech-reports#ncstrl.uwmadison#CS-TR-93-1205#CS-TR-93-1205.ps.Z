URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-93-1205/CS-TR-93-1205.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-93-1205/
Root-URL: http://www.cs.wisc.edu
Title: REPRESENTING AND QUERYING COMPLEX INFORMATION IN THE CORAL DEDUCTIVE DATABASE SYSTEM  
Author: by Divesh Srivastava 
Degree: A thesis submitted in partial fulfillment of the requirements for the degree of Doctor of Philosophy (Computer Sciences) at the  
Date: 1993  
Address: WISCONSIN MADISON  
Affiliation: UNIVERSITY OF  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> R. Agrawal and N. H. Gehani. </author> <title> Ode (Object Database and Environment): The language and the data model. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <address> Portland, Oregon, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: (3; 4); m path (2; 4) 2 path fpath (2; 4; [2; 4])g m path fm path (1; 4); m path (2; 4)g Context fm path (1; 4) fl ; m path (2; 4) fl g; m path (3; 4) 3 path fpath (2; 4; [2; 4]); path (1; 4; <ref> [1; 2; 4] </ref>)g m path fm path (1; 4); m path (2; 4)g Context fm path (1; 4) fl ; m path (2; 4) fl gm path (3; 4) Table 3.16: Ordered Search evaluation of hP path ; Q path i 72 The Magic-sets transformed program is straightforward and we do <p> Object-oriented database languages, such as E [72], O++ <ref> [1] </ref> and O 2 [25], among others, enhance the relational data model by providing support for abstract data types, encapsulation, object identifiers, methods, inheritance and polymorphism. Such sophisticated features are very useful for data modeling in many scientific, engineering, and multimedia applications. <p> However, each of these proposals is integrated with a computationally complete imperative language: CQL++ with O++ <ref> [1] </ref>, and Coral++ and ZQL [C++] with C++. CQL++ has a syntax similar to SQL syntax for class definition. These classes do not have any facility for data abstraction (i.e., all class members are public).
Reference: [2] <author> K. R. Apt, H. Blair, and A. Walker. </author> <title> Towards a theory of declarative knowledge. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 89-148. </pages> <publisher> Morgan-Kaufmann, </publisher> <address> San Mateo, Calif., </address> <year> 1988. </year>
Reference-contexts: and aggregation is stratified if there is no cyclic dependency between predicates "through" aggregation. (This can 35 be formalized using the notion of assignments of ordinal levels to program predicates as before.) The solutions proposed for stratified negation also apply to programs with stratified aggregation. 2 Apt, Blair and Walker <ref> [2] </ref> and Van Gelder [94] independently proposed a semantics for stratified programs. We give a brief description of their semantics for stratified programs, and refer the reader to [2, 94] for formal definitions. <p> We give a brief description of their semantics for stratified programs, and refer the reader to <ref> [2, 94] </ref> for formal definitions. The intuitive idea is to choose one of the minimal models of the entire program, based on the assignment of ordinal levels to predicates and an "iterated minimal model" construction procedure. <p> One of the main results of Apt et al. <ref> [2] </ref> was the following theorem. Theorem 3.1 Consider a stratified program P and an assignment of ordinal levels to the predicates of P . <p> Relation Facts 0 path fg m path fg Context m path (1; 4) 1 path fg m path fm path (1; 4)g Context m path (1; 4) fl ; m path (3; 4); m path (2; 4) 2 path fpath (2; 4; <ref> [2; 4] </ref>)g m path fm path (1; 4); m path (2; 4)g Context fm path (1; 4) fl ; m path (2; 4) fl g; m path (3; 4) 3 path fpath (2; 4; [2; 4]); path (1; 4; [1; 2; 4])g m path fm path (1; 4); m path (2; <p> 4) fl ; m path (3; 4); m path (2; 4) 2 path fpath (2; 4; <ref> [2; 4] </ref>)g m path fm path (1; 4); m path (2; 4)g Context fm path (1; 4) fl ; m path (2; 4) fl g; m path (3; 4) 3 path fpath (2; 4; [2; 4]); path (1; 4; [1; 2; 4])g m path fm path (1; 4); m path (2; 4)g Context fm path (1; 4) fl ; m path (2; 4) fl gm path (3; 4) Table 3.16: Ordered Search evaluation of hP path ; Q path i 72 The Magic-sets transformed program <p> (3; 4); m path (2; 4) 2 path fpath (2; 4; [2; 4])g m path fm path (1; 4); m path (2; 4)g Context fm path (1; 4) fl ; m path (2; 4) fl g; m path (3; 4) 3 path fpath (2; 4; [2; 4]); path (1; 4; <ref> [1; 2; 4] </ref>)g m path fm path (1; 4); m path (2; 4)g Context fm path (1; 4) fl ; m path (2; 4) fl gm path (3; 4) Table 3.16: Ordered Search evaluation of hP path ; Q path i 72 The Magic-sets transformed program is straightforward and we do
Reference: [3] <author> N. Arni, K. Ong, S. Tsur, and C. Zaniolo. </author> <title> The LDL++ system: Rationale, </title> <journal> technology and applications. </journal> <note> (Submitted), </note> <year> 1993. </year>
Reference-contexts: of the important aspects of our design, and how related proposals differ are as follows: * Coral++ uses the type system of an existing object-oriented programming language (i.e., C++) as an object data model rather than inventing yet another object data model which is the approach taken by, for instance, <ref> [3, 28, 32, 37, 45, 57, 77] </ref>. This 143 approach benefits from the support for data abstraction, inheritance, polymorphism and parametrized types already available in C++. <p> This translation is possible because of the lack of behavioral features and polymorphism in the data model. It is not clear how the translation approach generalizes once we introduce behavioral features in the model. LDL++ <ref> [3] </ref> is a deductive database system whose type system extends that of LDL [59] with an abstract data type facility that supports inheritance and predicate-valued methods. However, it does not support object sharing or ADT extents, and its support of encapsulation and object identity is limited.
Reference: [4] <author> I. Balbin, D. B. Kemp, K. Meenakshi, and K. Ramamohanarao. </author> <title> Propagating constraints in recursive deductive databases. </title> <booktitle> In Proceedings of the North American Conference on Logic Programming, </booktitle> <pages> pages 16-20, </pages> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: Relation Facts 0 path fg m path fg Context m path (1; 4) 1 path fg m path fm path (1; 4)g Context m path (1; 4) fl ; m path (3; 4); m path (2; 4) 2 path fpath (2; 4; <ref> [2; 4] </ref>)g m path fm path (1; 4); m path (2; 4)g Context fm path (1; 4) fl ; m path (2; 4) fl g; m path (3; 4) 3 path fpath (2; 4; [2; 4]); path (1; 4; [1; 2; 4])g m path fm path (1; 4); m path (2; <p> 4) fl ; m path (3; 4); m path (2; 4) 2 path fpath (2; 4; <ref> [2; 4] </ref>)g m path fm path (1; 4); m path (2; 4)g Context fm path (1; 4) fl ; m path (2; 4) fl g; m path (3; 4) 3 path fpath (2; 4; [2; 4]); path (1; 4; [1; 2; 4])g m path fm path (1; 4); m path (2; 4)g Context fm path (1; 4) fl ; m path (2; 4) fl gm path (3; 4) Table 3.16: Ordered Search evaluation of hP path ; Q path i 72 The Magic-sets transformed program <p> (3; 4); m path (2; 4) 2 path fpath (2; 4; [2; 4])g m path fm path (1; 4); m path (2; 4)g Context fm path (1; 4) fl ; m path (2; 4) fl g; m path (3; 4) 3 path fpath (2; 4; [2; 4]); path (1; 4; <ref> [1; 2; 4] </ref>)g m path fm path (1; 4); m path (2; 4)g Context fm path (1; 4) fl ; m path (2; 4) fl gm path (3; 4) Table 3.16: Ordered Search evaluation of hP path ; Q path i 72 The Magic-sets transformed program is straightforward and we do <p> If only Magic-sets transformation is used to optimize CQL programs, this could lead to the generation of constraint facts, even when the evaluation of the original program generates only ground facts. 2 A motivation for this work, as for Balbin et al. <ref> [4] </ref> and Mumick et al. [56], is to take advantage of the constraints present in the program to reduce the potentially relevant facts computed, and yet compute only ground facts during the bottom-up evaluation of the rewritten program. * Even when constraint facts are generated, we may ensure termination in evaluating <p> In particular, given the query: ? cheaporshort (madison; seattle; T ime; Cost): 78 one could compute many f light facts with Cost &gt; 150 and T ime &gt; 240; these facts are not relevant to answering the query. 2 The rewriting techniques proposed by Balbin et al. <ref> [4] </ref> and Mumick et al. [56] would not be able to optimize this program. The technique of Balbin et al. treats constraints in a manner similar to "ordinary" literals, and does not make use of semantic properties of constraints. <p> Our results are as follows: 1. In [82], we present an algorithm based on Magic-sets followed by a finite sequence of fold/unfold transformations that essentially mimics the algorithm of Mumick et al. [56]. This enables us to view the results of this chapter, and the algorithms in <ref> [4] </ref> and [56] in a uniform framework; namely, a combination of Magic-sets and (possibly simpler versions of) the algorithms Gen-Prop-predicate-constraints and Gen-Prop QRP-constraints, in some order. 2. <p> However, the rewriting technique does not terminate in general. A key feature of our rewriting technique is that it makes essential use of semantic properties of constraints, unlike previous techniques that had a similar objective <ref> [4, 56] </ref>. As a consequence, we are able to optimize a larger class of programs than previous techniques. 4.5.1 An Example First, we give a simple example of how the fold/unfold transformations can be used along with semantic properties of constraints to propagate constraint selections in a program. <p> We have thus generated and propagated the minimum QRP-constraints for the various derived predicates in the original program. 91 Neither the C-transformation of <ref> [4] </ref>, nor the GMT-transformation of [56] would be able to propagate all the constraints in this example. Since the C-transformation of [4] treats constraints as any other literal, it would not be able to propagate any constraints into the definition of p 2 ; the problem is that in rule r1, <p> We have thus generated and propagated the minimum QRP-constraints for the various derived predicates in the original program. 91 Neither the C-transformation of <ref> [4] </ref>, nor the GMT-transformation of [56] would be able to propagate all the constraints in this example. Since the C-transformation of [4] treats constraints as any other literal, it would not be able to propagate any constraints into the definition of p 2 ; the problem is that in rule r1, there is no explicit constraining literal on Y . <p> The other constraint is redundant. 6 This is a combinatorial upper-bound for the number of iterations taken. For most programs, we expect the bound to be considerably lower. 108 4.7 Understanding Previous Techniques Balbin et al. <ref> [4] </ref> and Mumick et al. [56] consider the problem of propagating constraints such as X &gt; 10 in a range-restricted, function-free CQL program P . 7 Both [4] and [56] use a combination of constraint propagation and Magic-sets. <p> For most programs, we expect the bound to be considerably lower. 108 4.7 Understanding Previous Techniques Balbin et al. <ref> [4] </ref> and Mumick et al. [56] consider the problem of propagating constraints such as X &gt; 10 in a range-restricted, function-free CQL program P . 7 Both [4] and [56] use a combination of constraint propagation and Magic-sets. A fundamental limitation of each of these techniques is that they do not utilize semantic properties of constraints. <p> The techniques presented in this chapter make essential use of such properties, and are hence able to optimize programs that could not be handled by previous techniques. 4.7.1 Balbin et al.'s C-transformation The approach taken by Balbin et al. <ref> [4] </ref> is to try to propagate constraints using (a more limited version than we consider of) fold/unfold and then apply the Magic-sets transformation. Given a program P , their technique is depicted in Figure 4.9. It can be split into three phases: 1. <p> In the third phase, they perform the Magic-sets rewriting on the C-transformed program. The resultant program is denoted P ad;C;mg . Thus, the approach of <ref> [4] </ref> is to C-transform the (adorned) program before the Magic-sets rewriting is applied. Further, given a program P which has only range-restricted rules, the transformation of [4] has the property that each of P ad ; P ad;C and P ad;C;mg has only range-restricted rules. <p> The resultant program is denoted P ad;C;mg . Thus, the approach of <ref> [4] </ref> is to C-transform the (adorned) program before the Magic-sets rewriting is applied. Further, given a program P which has only range-restricted rules, the transformation of [4] has the property that each of P ad ; P ad;C and P ad;C;mg has only range-restricted rules. Consequently, all the facts computed during the bottom-up evaluation of the C-transformed program as well as the magic rewritten program are ground facts. <p> Our algorithms for generating and propagating minimum QRP-constraints can be straightforwardly used to replace the constraint propagation phase of <ref> [4] </ref>'s technique. The resulting technique can optimize a larger class of programs than [4]. 4.7.2 Mumick et al.'s GMT-transformation The approach taken by Mumick et al. [56] (the Ground Magic-sets transformation, or GMT) directly extends the Magic-sets rewriting of [64] to support propagation of arithmetic constraints, without leading to computation of constraint facts. <p> Given a program P , the first step is an adornment phase. They generalize the class of bound (b) and free (f ) adornments to include a condition (c) adornment that describes selections involving arithmetic inequalities. They 8 <ref> [4] </ref> refers to constraints in P as constraining predicates; for instance, &gt; is a constraining predicate and X &gt; 3 is a constraining literal. 110 describe how sideways information passing strategies (sips) can be modified to allow conditions, in addition to bindings, to be passed sideways. <p> Semantic properties of constraints can also be used to enhance the adornment phase in the GMT-algorithm of [56], and permit a larger class of programs to be optimized. In contrast to <ref> [4] </ref>, the approach of [56] is to magic transform the (adorned) program before applying the fold/unfold transformations.
Reference: [5] <author> I. Balbin and K. Ramamohanarao. </author> <title> A generalization of the differential approach to recursive query evaluation. </title> <journal> Journal of Logic Programming, </journal> <volume> 4(3), </volume> <month> September </month> <year> 1987. </year>
Reference-contexts: It is sound and complete with respect to the declarative semantics of least Herbrand models (see Lloyd [50], for instance) for positive programs. When used in conjunction with Semi-naive evaluation <ref> [5, 6, 10] </ref>, it is guaranteed to prevent repeated computation. Further, it is more efficient than Prolog in many database applications, because it is set-oriented. However, Magic-sets evaluation has its limitations. <p> Note that each derivation made in an iteration of Naive bottom-up evaluation is repeated in subsequent iterations. 2 2.2.2 Semi-naive Evaluation Semi-naive evaluation <ref> [5, 6, 10, 27, 61] </ref> is an optimization of Naive evaluation, such that no derivation is repeated in the bottom-up evaluation. For simplicity, we consider only range-restricted programs; the bottom-up evaluation of such programs compute only ground facts.
Reference: [6] <author> F. Bancilhon. </author> <title> Naive evaluation of recursively defined relations. </title> <editor> In Brodie and Mylopoulos, editors, </editor> <title> On Knowledge Base Management Systems | Integrating Database and AI Systems. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: It is sound and complete with respect to the declarative semantics of least Herbrand models (see Lloyd [50], for instance) for positive programs. When used in conjunction with Semi-naive evaluation <ref> [5, 6, 10] </ref>, it is guaranteed to prevent repeated computation. Further, it is more efficient than Prolog in many database applications, because it is set-oriented. However, Magic-sets evaluation has its limitations. <p> corresponding to the query predicate q in the meaning of program P . 2 14 2.2 Bottom-up Evaluation 2.2.1 Naive Evaluation Consider a program P and a database D. (The set of all relations corresponding to EDB predicates is referred to as the database.) The Naive bottom-up evaluation (see Bancilhon <ref> [6] </ref>, for instance) of hP; Di proceeds in iterations. <p> Note that each derivation made in an iteration of Naive bottom-up evaluation is repeated in subsequent iterations. 2 2.2.2 Semi-naive Evaluation Semi-naive evaluation <ref> [5, 6, 10, 27, 61] </ref> is an optimization of Naive evaluation, such that no derivation is repeated in the bottom-up evaluation. For simplicity, we consider only range-restricted programs; the bottom-up evaluation of such programs compute only ground facts.
Reference: [7] <author> F. Bancilhon, D. Maier, Y. Sagiv, and J. D. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 1-15, </pages> <address> Cambridge, Massachusetts, </address> <month> March </month> <year> 1986. </year>
Reference-contexts: Existing deductive database systems (Aditi [93], CORAL [65, 1 2 68], Glue-NAIL [54, 62], and LDL [22, 59], among others) incorporate many different optimization strategies for answering queries. One of the most important optimization strategies used in these deductive database systems is Magic-sets <ref> [7, 11, 64, 73, 80] </ref>. Magic-sets is a general program transformation technique that seeks to restrict the computation to facts that are relevant to answering the query, where a fact is considered relevant if it would be computed in a top-down evaluation of the given query. <p> Top-down evaluation techniques, such as Prolog, usually achieve this objective by using answers to subgoals to bind arguments of other subgoals, and hence restrict the model to be computed to facts relevant to answering a query (or goal). Magic-sets transformations <ref> [7, 11, 64, 73, 80] </ref> are 21 used to imitate top-down computations using bottom-up computation. The major advantage they provide over Naive and Semi-naive bottom-up evaluation is that they allow a bottom-up computation to be specialized with respect to the query, thus improving the efficiency of answering queries.
Reference: [8] <author> F. Bancilhon and R. Ramakrishnan. </author> <title> An amateur's introduction to recursive query processing strategies. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 16-52, </pages> <address> Washington, D.C., </address> <month> May </month> <year> 1986. </year> <pages> 149 150 </pages>
Reference-contexts: This makes it easy for the users to specify queries, but it places the burden of query evaluation on the system. Thus deductive database systems must have powerful optimization techniques to efficiently answer queries (see <ref> [8, 66, 92] </ref> for a discussion). Existing deductive database systems (Aditi [93], CORAL [65, 1 2 68], Glue-NAIL [54, 62], and LDL [22, 59], among others) incorporate many different optimization strategies for answering queries. <p> In fact, it has no additional overheads compared to the usual Semi-naive evaluation. We also study rule orderings in detail in [67], and establish a close connection between cycles in rule graphs (which are a variant of rule/goal graphs defined in <ref> [8, 92] </ref>) and orderings that minimize the number of iterations and rule applications.
Reference: [9] <author> M. Baudinet, M. Niezette, and P. Wolper. </author> <title> On the representation of infinite temporal data and queries. </title> <booktitle> In Proceedings of the Tenth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 280-290, </pages> <address> Denver, Colorado, </address> <month> May </month> <year> 1991. </year>
Reference: [10] <author> R. Bayer. </author> <title> Query evaluation and recursion in deductive database systems. </title> <note> Unpublished Memorandum, </note> <year> 1985. </year>
Reference-contexts: It is sound and complete with respect to the declarative semantics of least Herbrand models (see Lloyd [50], for instance) for positive programs. When used in conjunction with Semi-naive evaluation <ref> [5, 6, 10] </ref>, it is guaranteed to prevent repeated computation. Further, it is more efficient than Prolog in many database applications, because it is set-oriented. However, Magic-sets evaluation has its limitations. <p> Note that each derivation made in an iteration of Naive bottom-up evaluation is repeated in subsequent iterations. 2 2.2.2 Semi-naive Evaluation Semi-naive evaluation <ref> [5, 6, 10, 27, 61] </ref> is an optimization of Naive evaluation, such that no derivation is repeated in the bottom-up evaluation. For simplicity, we consider only range-restricted programs; the bottom-up evaluation of such programs compute only ground facts.
Reference: [11] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the power of Magic. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 269-283, </pages> <address> San Diego, California, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: Existing deductive database systems (Aditi [93], CORAL [65, 1 2 68], Glue-NAIL [54, 62], and LDL [22, 59], among others) incorporate many different optimization strategies for answering queries. One of the most important optimization strategies used in these deductive database systems is Magic-sets <ref> [7, 11, 64, 73, 80] </ref>. Magic-sets is a general program transformation technique that seeks to restrict the computation to facts that are relevant to answering the query, where a fact is considered relevant if it would be computed in a top-down evaluation of the given query. <p> Top-down evaluation techniques, such as Prolog, usually achieve this objective by using answers to subgoals to bind arguments of other subgoals, and hence restrict the model to be computed to facts relevant to answering a query (or goal). Magic-sets transformations <ref> [7, 11, 64, 73, 80] </ref> are 21 used to imitate top-down computations using bottom-up computation. The major advantage they provide over Naive and Semi-naive bottom-up evaluation is that they allow a bottom-up computation to be specialized with respect to the query, thus improving the efficiency of answering queries. <p> This assumption can be easily relaxed using the notion of "predicate adornments," and the interested reader is referred to <ref> [11] </ref> for a detailed discussion. 22 Because of the correspondence between the subgoals set up in a top-down evaluation of the original program P , and the magic facts computed in a bottom-up evaluation of the Magic-sets transformed program M P , we often refer to magic facts as subgoals in <p> We refer the reader to <ref> [11, 64] </ref> for a detailed discussion of the Supplementary Magic-sets transformation, and give an example here. Example 2.4 (Supplementary Magic-sets Transformation) Consider the Magic-sets transformed program M P of Example 2.3.
Reference: [12] <author> C. Beeri, R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> The valid model semantics for logic programs. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 91-104, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: If the resulting head fact is also in the interpretation, the rule with the grouping atom as its head is said to be true. 2 All programs described in this thesis satisfy these conditions. Programs that do not satisfy these conditions can be rewritten, as in Beeri et al. <ref> [12] </ref>, to satisfy these conditions, without changing the meaning of programs. 13 Definition 2.20 (Herbrand Model) Consider a program P . <p> Several semantics have been proposed for general logic programs with negation and/or aggregation. These include the well-founded semantics [42, 87, 96, 97], the stable model semantics [31, 42], and the valid semantics <ref> [12, 87] </ref>. These semantics differ in the meaning they assign to a program when there are cyclic dependencies between subgoals through negation and/or aggregation.
Reference: [13] <author> C. Beeri, R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> Magic implementation of stratified programs. </title> <type> Manuscript, </type> <month> September 89. </month>
Reference-contexts: Although the orderings do not affect the number of inferences made, the processing becomes more set-oriented, with each rule application generating more facts. 3. Rule orderings have been proposed as a way of evaluating the (non-stratified) Magic-sets transformation of a stratified program <ref> [13] </ref>. The usual Semi-naive algorithm is capable of evaluating a limited number of rule or-derings, e.g. those that result in an SCC-by-SCC evaluation. However, it cannot correctly evaluate regular expressions over rules that order rule applications within an SCC.
Reference: [14] <author> N. Bidoit and P. Legay. </author> <title> WELL! An evaluation procedure for all logic programs. </title> <booktitle> In Proceedings of the International Conference on Database Theory, </booktitle> <pages> pages 335-348, </pages> <address> Paris, France, </address> <month> December </month> <year> 1990. </year>
Reference-contexts: There is no analogue to this step in the technique of [48]. 3.7.4 Techniques for computing the well-founded model There are several query evaluation techniques in the literature that compute answers under the well-founded model. For example, WELL! <ref> [14] </ref> is based on global SLS-resolution, XOLDTNF [21] is an extension of OLDT resolution, GUUS [49] is based on the alternating fixpoint semantics, and the techniques of Kemp et al. [40, 41, 43] and Morishita [53] are based on alternating fixpoint semantics and Magic-sets.
Reference: [15] <author> J. A. Blakeley. ZQL[C++]: </author> <title> Integrating the C++ language and an object query capability. </title> <booktitle> In Proceedings of the Workshop on Combining Declarative and Object-Oriented Databases, </booktitle> <pages> pages 138-144, </pages> <address> Washington, D.C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: This 143 approach benefits from the support for data abstraction, inheritance, polymorphism and parametrized types already available in C++. Other query languages that use the C++ type system include CQL++ [24], Ob jectStore [60] and ZQL [C++] <ref> [15] </ref>. * The Coral++ declarative query language supports the combination of Coral rules with C++ expressions in a clean fashion. This approach can effectively utilize the Coral implementation and the C++ compiler. <p> An initial implementation based on the run-time system of the Coral implementation [68] is underway. We now examine some of the closely related proposals in more detail. 5.6.1 Proposals Based on C++ ZQL [C++] <ref> [15] </ref> and CQL++ [24] are the proposals most closely related to Coral++ since they are also based on the C++ object model. 144 The Coral++ query language is more expressive than CQL++ or ZQL [C++], which are based on SQL.
Reference: [16] <author> A. Brodsky and Y. Sagiv. </author> <title> Inference of inequality constraints in logic programs. </title> <booktitle> In Proceedings of the Tenth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 227-240, </pages> <address> Denver, Colorado, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: Proposition 4.4 Given a CQL program P , where the only constraints allowed are of the form X c, X c, and X Y + c, determining whether any representation for the minimum predicate constraint for a predicate p is a finite constraint set is undecidable. 2 Brodsky and Sagiv <ref> [16] </ref> show that it is undecidable whether a specific procedure for computing minimum predicate constraints computes finite predicate constraints. Proposition 4.4 does not follow from their result since they do not address the issue of multiple representations. <p> This contradicts the original assumption that p (a) is not present in the least model, and concludes the proof of Claim 2, as well as the proof of the theorem. 2 Brodsky and Sagiv <ref> [16] </ref> study this problem of generating predicate constraints for a special case, where the only constraints allowed are of the form $i $j + c. <p> An important direction is to identify classes of programs for which there is a terminating procedure to compute minimum predicate constraints and minimum QRP-constraints. A promising candidate is the class of programs called "strongly unique" programs by Brodsky and Sagiv <ref> [16] </ref>. 125 By first propagating predicate constraints, it may be possible for a Magic-sets evaluation to terminate, whereas the evaluation may not have terminated otherwise.
Reference: [17] <author> F. Bry. </author> <title> Query evaluation in recursive databases: Bottom-up and top-down reconciled. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 5 </volume> <pages> 289-312, </pages> <year> 1990. </year>
Reference-contexts: The interested reader is referred to <ref> [17, 69, 86, 91] </ref> for details on the duality between top-down and bottom-up evaluation. Note that the first two steps of the Magic-sets transformation can be performed at "compile-time," while the final step can be performed only at "run-time," when the actual query is known.
Reference: [18] <author> F. Cacace, S. Ceri, S. Crespi-Reghizzi, L. Tanca, and R. Zicari. </author> <title> Integrating object-oriented data modeling with a rule-based programming paradigm. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 225-236, </pages> <address> Atlantic City, New Jersey, </address> <month> May </month> <year> 1990. </year> <month> 151 </month>
Reference: [19] <author> M. Carey, D. DeWitt, J. Richardson, and E. Shekita. </author> <title> Object and file management in the EXODUS extensible database system. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <month> Aug. </month> <year> 1986. </year>
Reference-contexts: The space overheads of the Ordered Search evaluation for the anc r program are less than those for the append program. 3.6.4 Ordered Search and Persistence Coral provides support for persistent data using the EXODUS client-server database toolkit <ref> [19] </ref>. Coral is the client process, and maintains buffers for persistent relations. Data stored using the EXODUS storage manager is paged into these buffers on demand, making use of the indexing and scan facilities of the storage manager. The Ordered Search implementation is orthogonal to the implementation of persistent relations.
Reference: [20] <author> W. Chen, M. Kifer, and D. S. Warren. Hilog: </author> <title> A first-order semantics for higher-order logic programming constructs. </title> <booktitle> In Proceedings of the North American Conference on Logic Programming, </booktitle> <pages> pages 1090-1114, </pages> <year> 1989. </year>
Reference-contexts: sets and multisets) and ordered relations (lists and arrays), which are useful in applications involving sequence data [76]. * The Coral++ query language can be largely understood in terms of standard Horn clause logic (with C++ method invocations treated as external functions), unlike Noodle [57] which is based on HiLog <ref> [20] </ref> and XSQL [45] which is based on F-logic [46]. <p> Noodle [57, 58] is a declarative query language for the SWORD declarative object-oriented database. Unlike Coral++ and XSQL, Noodle does not use path expressions to access attributes and invoke methods on objects. Instead, Noodle uses a syntax reminiscent of HiLog <ref> [20] </ref> for this purpose. Noodle also has a number of built-in classes to facilitate schema querying.
Reference: [21] <author> W. Chen and D. S. Warren. </author> <title> A goal-oriented approach to computing the well founded semantics. </title> <booktitle> In Proceedings of the Joint International Conference and Symposium on Logic Programming, </booktitle> <year> 1992. </year>
Reference-contexts: There is no analogue to this step in the technique of [48]. 3.7.4 Techniques for computing the well-founded model There are several query evaluation techniques in the literature that compute answers under the well-founded model. For example, WELL! [14] is based on global SLS-resolution, XOLDTNF <ref> [21] </ref> is an extension of OLDT resolution, GUUS [49] is based on the alternating fixpoint semantics, and the techniques of Kemp et al. [40, 41, 43] and Morishita [53] are based on alternating fixpoint semantics and Magic-sets.
Reference: [22] <author> D. Chimenti, R. Gamboa, R. Krishnamurthy, S. Naqvi, S. Tsur, and C. Zaniolo. </author> <title> The LDL system prototype. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 76-90, </pages> <year> 1990. </year>
Reference-contexts: Thus deductive database systems must have powerful optimization techniques to efficiently answer queries (see [8, 66, 92] for a discussion). Existing deductive database systems (Aditi [93], CORAL [65, 1 2 68], Glue-NAIL [54, 62], and LDL <ref> [22, 59] </ref>, among others) incorporate many different optimization strategies for answering queries. One of the most important optimization strategies used in these deductive database systems is Magic-sets [7, 11, 64, 73, 80].
Reference: [23] <author> J. Chomicki. </author> <title> Polynomial time query processing in temporal deductive databases. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 379-391, </pages> <address> Nashville, Tennessee, </address> <month> Apr. </month> <year> 1990. </year>
Reference: [24] <author> S. Dar, N. H. Gehani, and H. V. Jagadish. CQL++: </author> <title> An SQL for a C++ based object-oriented DBMS. </title> <booktitle> In Proceedings of the International Conference on Extending Database Technology, </booktitle> <address> Vienna, Austria, </address> <month> Mar. </month> <year> 1992. </year> <note> (A full version is available as AT&T Bell Labs Technical Memorandum 11252-910219-26). </note>
Reference-contexts: This 143 approach benefits from the support for data abstraction, inheritance, polymorphism and parametrized types already available in C++. Other query languages that use the C++ type system include CQL++ <ref> [24] </ref>, Ob jectStore [60] and ZQL [C++] [15]. * The Coral++ declarative query language supports the combination of Coral rules with C++ expressions in a clean fashion. This approach can effectively utilize the Coral implementation and the C++ compiler. <p> This approach can effectively utilize the Coral implementation and the C++ compiler. SWORD [57] and ObjectStore [60], for instance, take the alternative approach of inventing new syntax to query an object data model. * Coral++ is more expressive than most of the other proposals <ref> [24, 28, 32, 77] </ref>. In particular, it provides a facility for generalized recursive view definition in the query language. <p> An initial implementation based on the run-time system of the Coral implementation [68] is underway. We now examine some of the closely related proposals in more detail. 5.6.1 Proposals Based on C++ ZQL [C++] [15] and CQL++ <ref> [24] </ref> are the proposals most closely related to Coral++ since they are also based on the C++ object model. 144 The Coral++ query language is more expressive than CQL++ or ZQL [C++], which are based on SQL.
Reference: [25] <author> O. </author> <title> Deux. The O 2 database programming language. </title> <journal> Communications of the ACM, </journal> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: Object-oriented database languages, such as E [72], O++ [1] and O 2 <ref> [25] </ref>, among others, enhance the relational data model by providing support for abstract data types, encapsulation, object identifiers, methods, inheritance and polymorphism. Such sophisticated features are very useful for data modeling in many scientific, engineering, and multimedia applications.
Reference: [26] <author> S. W. Dietrich. </author> <title> Extension tables: Memo relations in logic programming. </title> <booktitle> In Proceedings of the Symposium on Logic Programming, </booktitle> <pages> pages 264-272, </pages> <year> 1987. </year>
Reference-contexts: Prolog is not complete even for Datalog, and may repeat derivations. Also, Prolog does not evaluate the class of left-to-right modularly stratified programs correctly. 2 3.7.2 QSQR/QoSaQ and Extension Tables Extension Tables <ref> [26] </ref> is similar to Prolog, except that it memos facts and subgoals and can detect loops. QSQR/QoSaQ [98, 99] is a top-down, memoing, set-oriented strategy that is closely related to bottom-up evaluation with Supplementary Magic rewriting. Like Prolog, these techniques cannot deal with left-to-right modularly stratified negation/aggregation.
Reference: [27] <author> A. C. Fong and J. Ullman. </author> <title> Induction variables in very high-level languages. </title> <booktitle> In Proc. Third ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 104-112, </pages> <year> 1976. </year>
Reference-contexts: Note that each derivation made in an iteration of Naive bottom-up evaluation is repeated in subsequent iterations. 2 2.2.2 Semi-naive Evaluation Semi-naive evaluation <ref> [5, 6, 10, 27, 61] </ref> is an optimization of Naive evaluation, such that no derivation is repeated in the bottom-up evaluation. For simplicity, we consider only range-restricted programs; the bottom-up evaluation of such programs compute only ground facts.
Reference: [28] <author> L. J. Gallagher. </author> <title> Object SQL: Language extensions for object data management. </title> <booktitle> In Proceedings of the ISMM First International Conference on Information and Knowledge Management, </booktitle> <pages> pages 17-26, </pages> <address> Baltimore, Maryland, </address> <month> Nov. </month> <year> 1992. </year> <month> 152 </month>
Reference-contexts: of the important aspects of our design, and how related proposals differ are as follows: * Coral++ uses the type system of an existing object-oriented programming language (i.e., C++) as an object data model rather than inventing yet another object data model which is the approach taken by, for instance, <ref> [3, 28, 32, 37, 45, 57, 77] </ref>. This 143 approach benefits from the support for data abstraction, inheritance, polymorphism and parametrized types already available in C++. <p> This approach can effectively utilize the Coral implementation and the C++ compiler. SWORD [57] and ObjectStore [60], for instance, take the alternative approach of inventing new syntax to query an object data model. * Coral++ is more expressive than most of the other proposals <ref> [24, 28, 32, 77] </ref>. In particular, it provides a facility for generalized recursive view definition in the query language.
Reference: [29] <author> S. Ganguly, S. Greco, and C. Zaniolo. </author> <title> Minimum and maximum predicates in logic programming. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <year> 1991. </year>
Reference-contexts: There are other proposed techniques that control the order of inferences in a bottom-up evaluation in some way. Sloppy Delta Iteration [78] provides a way to "hide" facts until they are to be used. Techniques for hiding facts are used in <ref> [29, 85] </ref> to evaluate programs with aggregate operations efficiently.
Reference: [30] <author> P. Gardner and J. Shepherdson. </author> <title> Unfold/Fold transformations of logic programs. </title> <editor> In J.-L. Lassez and G. Plotkin, editors, </editor> <booktitle> Computational Logic. </booktitle> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference: [31] <author> M. Gelfond and V. Lifschitz. </author> <title> The stable model semantics for logic programming. </title> <booktitle> In Proc. Fifth International Conference and Symposium on Logic Programming, </booktitle> <year> 1988. </year>
Reference-contexts: Several semantics have been proposed for general logic programs with negation and/or aggregation. These include the well-founded semantics [42, 87, 96, 97], the stable model semantics <ref> [31, 42] </ref>, and the valid semantics [12, 87]. These semantics differ in the meaning they assign to a program when there are cyclic dependencies between subgoals through negation and/or aggregation.
Reference: [32] <author> S. Greco, N. Leone, and P. Rullo. </author> <title> COMPLEX: An object-oriented logic programming system. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 4(4) </volume> <pages> 344-359, </pages> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: of the important aspects of our design, and how related proposals differ are as follows: * Coral++ uses the type system of an existing object-oriented programming language (i.e., C++) as an object data model rather than inventing yet another object data model which is the approach taken by, for instance, <ref> [3, 28, 32, 37, 45, 57, 77] </ref>. This 143 approach benefits from the support for data abstraction, inheritance, polymorphism and parametrized types already available in C++. <p> This approach can effectively utilize the Coral implementation and the C++ compiler. SWORD [57] and ObjectStore [60], for instance, take the alternative approach of inventing new syntax to query an object data model. * Coral++ is more expressive than most of the other proposals <ref> [24, 28, 32, 77] </ref>. In particular, it provides a facility for generalized recursive view definition in the query language. <p> Since ZQL [C++] also allows SQL subqueries to appear as predicates, it does not distinguish between the predicate truth semantics and the C++ expression truth semantics, unlike Coral++ and CQL++. 5.6.2 Proposals Based on Deductive Languages The COMPLEX data model <ref> [32] </ref> is a structural, typed data model that adds features such as object identity, object sharing and inheritance to the relational model. It does not support abstract data types, encapsulation, or methods; consequently, the data model is not as rich as the Coral++ data model.
Reference: [33] <author> A. R. Helm. </author> <title> Detecting and eliminating redundant derivations in deductive database systems. </title> <type> Technical Report RC 14244 (#63767), </type> <institution> IBM Thomas Watson Research Center, </institution> <month> December </month> <year> 1988. </year>
Reference-contexts: Such "redundant" derivations can be avoided by recognizing that every fact derived using rule r2 is also derived using rule r3, and vice versa. Consequently, a scheme that prunes redundant derivations (Helm <ref> [33] </ref>, for instance) could recognize this and never apply rule r3; the derivation of r3 : anc (1; 3) is not made in such a case. <p> Rule orderings are significant for several reasons. 1. Rule orderings have been proposed to prune redundant derivations and to allow the user to specify a desired semantics <ref> [33, 34, 35] </ref>. 2. Rule ordering can result in increased efficiency. For example, in an SCC-by-SCC evaluation of a program, rules in lower SCCs do not need to be considered while applying rules in higher SCCs; this can improve the efficiency of evaluation.
Reference: [34] <author> R. Helm. </author> <title> Inductive and deductive control of logic programs. </title> <booktitle> In Proceedings of the International Conference on Logic Programming, </booktitle> <pages> pages 488-511, </pages> <address> Melbourne, Australia, </address> <year> 1987. </year>
Reference-contexts: Rule orderings are significant for several reasons. 1. Rule orderings have been proposed to prune redundant derivations and to allow the user to specify a desired semantics <ref> [33, 34, 35] </ref>. 2. Rule ordering can result in increased efficiency. For example, in an SCC-by-SCC evaluation of a program, rules in lower SCCs do not need to be considered while applying rules in higher SCCs; this can improve the efficiency of evaluation.
Reference: [35] <author> T. Imielinski and S. Naqvi. </author> <title> Explicit control of logic programs through rule algebra. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 103-116, </pages> <year> 1988. </year>
Reference-contexts: Rule orderings are significant for several reasons. 1. Rule orderings have been proposed to prune redundant derivations and to allow the user to specify a desired semantics <ref> [33, 34, 35] </ref>. 2. Rule ordering can result in increased efficiency. For example, in an SCC-by-SCC evaluation of a program, rules in lower SCCs do not need to be considered while applying rules in higher SCCs; this can improve the efficiency of evaluation.
Reference: [36] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proceedings of the 14th ACM POPL, </booktitle> <pages> pages 111-119, </pages> <address> Munich, </address> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: An Herbrand model M 1 of program P is minimal if no proper subset of M 1 is a model of P . 2 The following result is a consequence of the results of Jaffar and Lassez <ref> [36] </ref>. <p> Jaffar and Lassez <ref> [36] </ref> described a functional semantics for hP; Di in terms of an immediate consequence operator T P;D , and showed that the least fixpoint of T P;D , given by T ! P;D , is equivalent to the meaning of hP; Di in terms of its least model.
Reference: [37] <author> M. H. Jamil and L. V. S. Lakshmanan. ORLOG: </author> <title> A logic for semantic object-oriented models. </title> <booktitle> In Proceedings of the ISMM First International Conference on Information and Knowledge Management, </booktitle> <pages> pages 584-592, </pages> <address> Baltimore, Maryland, </address> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: of the important aspects of our design, and how related proposals differ are as follows: * Coral++ uses the type system of an existing object-oriented programming language (i.e., C++) as an object data model rather than inventing yet another object data model which is the approach taken by, for instance, <ref> [3, 28, 32, 37, 45, 57, 77] </ref>. This 143 approach benefits from the support for data abstraction, inheritance, polymorphism and parametrized types already available in C++. <p> Unlike Coral++ and XSQL, Noodle does not use path expressions to access attributes and invoke methods on objects. Instead, Noodle uses a syntax reminiscent of HiLog [20] for this purpose. Noodle also has a number of built-in classes to facilitate schema querying. Orlog <ref> [37] </ref> combines the modeling capabilities of object-oriented and semantic data models, and is similar to Noodle in that its logic-based language for querying and implementing methods uses a higher-order syntax with first order semantics.
Reference: [38] <author> M. Jarke, S. Eherer, R. Gallersdoerfer, M. Jeusfeld, and M. Staudt. </author> <title> ConceptBase a deductive object base manager. </title> <note> Submitted, </note> <year> 1993. </year>
Reference-contexts: There are several other interesting proposals for combining semantically rich data models with deductive databases that are less closely related to Coral++. Concept-Base <ref> [38] </ref> and Quixote [100] are two such systems. ConceptBase is based on the Telos knowledge representation language, and allows the specification of methods using deductive rules and integrity constraints.
Reference: [39] <author> P. C. Kanellakis, G. M. Kuper, and P. Z. Revesz. </author> <title> Constraint query languages. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 299-313, </pages> <address> Nashville, Tennessee, </address> <month> Apr. </month> <year> 1990. </year> <month> 153 </month>
Reference-contexts: Also, while the Magic-sets optimization can propagate "constant" binding information (e.g., X = 5) from a query into the program such that the transformed program may be efficiently evaluated, the propagation of "constraint" binding information (e.g., X &lt; 5) leads to the computation of constraint facts <ref> [39, 64] </ref>, which are expensive to manipulate. The major goal of this thesis is to address and resolve these limitations of Magic-sets based bottom-up evaluation of deductive database queries. <p> The Magic-sets evaluation cannot utilize all the constraint information present in such program-query pairs without computing non-ground constraint facts <ref> [39, 64] </ref>, which are expensive to manipulate. With the Constraint-rewrite optimization, only "constraint relevant" facts are computed, and if the evaluation of the original program computes only ground facts, then so does the evaluation of the transformed program. <p> However, our techniques extend to programs with other types of constraints as well. In this chapter, we refer to programs with constraints in rule bodies as CQL programs (following the terminology used by Kanellakis et al. <ref> [39] </ref>). A constraint fact of the form: p (X) : C: where C is a comma separated sequence of constraints, is also represented as p (X; C). <p> Such facts are often useful in knowledge representation, natural language processing and could be particularly useful in a database that stores (and possibly manipulates) rules. There is another, possibly more important, use of variables | namely to specify constraint facts <ref> [39, 64] </ref>. However, the Coral data model does not allow values of (arbitrary) user-defined types in facts.
Reference: [40] <author> D. Kemp, D. Srivastava, and P. Stuckey. </author> <title> Magic sets and bottom-up evaluation of well-founded models. </title> <booktitle> In Proceedings of the International Logic Programming Symposium, </booktitle> <pages> pages 337-351, </pages> <address> San Diego, CA, U.S.A., </address> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: Even on this modified program, Ordered Search would compute the answer to the query using O (m) space and making O (m) derivations. 2 Example 3.2 (Working Parts) Consider the following program from Kemp et al. <ref> [40] </ref>, 29 which is modified from an example in Ross [74]. working (X) : tested (X): working (X) : essential part (X; Y ); working (Y ): working (X) : part (X; Y ); not has suspect part (X): has suspect part (X) : part (X; Y ); not working (Y <p> For example, WELL! [14] is based on global SLS-resolution, XOLDTNF [21] is an extension of OLDT resolution, GUUS [49] is based on the alternating fixpoint semantics, and the techniques of Kemp et al. <ref> [40, 41, 43] </ref> and Morishita [53] are based on alternating fixpoint semantics and Magic-sets. The class of programs handled by these techniques is larger than that handled by Ordered Search, but each of these techniques can repeat computation even for left-to-right modularly stratified programs.
Reference: [41] <author> D. Kemp, D. Srivastava, and P. Stuckey. </author> <title> Query restricted bottom-up evaluation of normal logic programs. </title> <booktitle> In Proceedings of the Joint International Conference and Symposium on Logic Programming, </booktitle> <year> 1992. </year>
Reference-contexts: For example, WELL! [14] is based on global SLS-resolution, XOLDTNF [21] is an extension of OLDT resolution, GUUS [49] is based on the alternating fixpoint semantics, and the techniques of Kemp et al. <ref> [40, 41, 43] </ref> and Morishita [53] are based on alternating fixpoint semantics and Magic-sets. The class of programs handled by these techniques is larger than that handled by Ordered Search, but each of these techniques can repeat computation even for left-to-right modularly stratified programs.
Reference: [42] <author> D. Kemp and P. Stuckey. </author> <title> Semantics of logic programs with aggregates. </title> <booktitle> In Proceedings of the International Logic Programming Symposium, </booktitle> <pages> pages 387-401, </pages> <address> San Diego, CA, U.S.A., </address> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: The technique of Ross [75] as well as our technique makes essential use of this property in evaluating programs with left-to-right modularly stratified negation. Several semantics have been proposed for general logic programs with negation and/or aggregation. These include the well-founded semantics <ref> [42, 87, 96, 97] </ref>, the stable model semantics [31, 42], and the valid semantics [12, 87]. These semantics differ in the meaning they assign to a program when there are cyclic dependencies between subgoals through negation and/or aggregation. <p> Several semantics have been proposed for general logic programs with negation and/or aggregation. These include the well-founded semantics [42, 87, 96, 97], the stable model semantics <ref> [31, 42] </ref>, and the valid semantics [12, 87]. These semantics differ in the meaning they assign to a program when there are cyclic dependencies between subgoals through negation and/or aggregation.
Reference: [43] <author> D. B. Kemp. </author> <title> On the Foundations of Query Evaluation in Deductive Databases. </title> <type> PhD thesis, </type> <institution> University of Melbourne, </institution> <month> Nov. </month> <year> 1992. </year> <note> Report No. CITRI/TR-92-70. </note>
Reference-contexts: In this section, we focus attention of the Magic-sets approach to improving the efficiency of answering queries. The Magic-sets transformation is important because it can result in significant improvements, and at the same time it is generally applicable (see Kemp <ref> [43] </ref> for details). One of the main objectives of efficient query evaluation is to avoid computing the entire model of the original program in answering a query. <p> For example, WELL! [14] is based on global SLS-resolution, XOLDTNF [21] is an extension of OLDT resolution, GUUS [49] is based on the alternating fixpoint semantics, and the techniques of Kemp et al. <ref> [40, 41, 43] </ref> and Morishita [53] are based on alternating fixpoint semantics and Magic-sets. The class of programs handled by these techniques is larger than that handled by Ordered Search, but each of these techniques can repeat computation even for left-to-right modularly stratified programs.
Reference: [44] <author> D. B. Kemp and P. J. Stuckey. </author> <title> Analysis based constraint query optimization. </title> <booktitle> In Proceedings of the International Conference on Logic Programming, </booktitle> <address> Budapest, Hungary, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Our technique for generating and propagating minimum QRP-constraints does not terminate, in general. A practical direction of research is to provide a terminating algorithm that generates and propagates QRP-constraints. (These constraints have to be non-minimal, because of our undecidability results.) Kemp and Stuckey <ref> [44] </ref> recently proposed an algorithm that modifies our technique for generating QRP-constraints, by using abstract interpretation to guarantee termination. An important direction is to identify classes of programs for which there is a terminating procedure to compute minimum predicate constraints and minimum QRP-constraints.
Reference: [45] <author> M. Kifer, W. Kim, and Y. Sagiv. </author> <title> Querying object-oriented databases. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 393-402, </pages> <address> San Diego, California, </address> <year> 1992. </year>
Reference-contexts: However, the Coral++ declarative language can create facts describing relationships between existing objects in the database. Rules in Coral++ are deliberately restricted to avoid creating new objects, since this is an issue that is not yet well-understood despite work by Maier [52], Kifer et al. <ref> [45] </ref>, and others. A number of issues, notably the resolution of conflicts when rules generate distinct objects with the same object identifier, remain unclear, especially in the presence of partially specified objects (e.g. some fields are variables, in the Coral++ context). <p> of the important aspects of our design, and how related proposals differ are as follows: * Coral++ uses the type system of an existing object-oriented programming language (i.e., C++) as an object data model rather than inventing yet another object data model which is the approach taken by, for instance, <ref> [3, 28, 32, 37, 45, 57, 77] </ref>. This 143 approach benefits from the support for data abstraction, inheritance, polymorphism and parametrized types already available in C++. <p> and ordered relations (lists and arrays), which are useful in applications involving sequence data [76]. * The Coral++ query language can be largely understood in terms of standard Horn clause logic (with C++ method invocations treated as external functions), unlike Noodle [57] which is based on HiLog [20] and XSQL <ref> [45] </ref> which is based on F-logic [46]. <p> Consequently, the data model is not as rich as the Coral++ data model. Further, LDL++ methods can be defined only using LDL++ rules; however, this can be done more naturally than in Coral++. 145 5.6.3 Proposals Based on Non-Horn Logics XSQL <ref> [45] </ref> extends SQL by adding path expressions that may have variables that range over classes, attributes and methods. This facilitates querying schema information as well as instance-level information in object-oriented databases, using a single declarative query language. <p> In Coral++, methods and other aspects of data abstraction borrowed from C++ are viewed as being outside the scope of the deductive machinery, notably the unification mechanism. A more comprehensive treatment of features like path expressions (e.g., as in XSQL <ref> [45] </ref>) may well enable more efficient (i.e., set-oriented) processing of certain queries. We make no attempt to give these features a logical semantics; we simply borrow the C++ semantics, in order to enable ease of implementation.
Reference: [46] <author> M. Kifer and G. Lausen. F-logic, </author> <title> a higher-order language for reasoning about objects, inheritance and schemes. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <year> 1989. </year>
Reference-contexts: which are useful in applications involving sequence data [76]. * The Coral++ query language can be largely understood in terms of standard Horn clause logic (with C++ method invocations treated as external functions), unlike Noodle [57] which is based on HiLog [20] and XSQL [45] which is based on F-logic <ref> [46] </ref>. <p> We make no attempt to give these features a logical semantics; we simply borrow the C++ semantics, in order to enable ease of implementation. The semantic foundations of XSQL, Noodle and Orlog (i.e., F-logic <ref> [46] </ref> and HiLog), have features that are difficult to support efficiently, at least in a bottom-up implementation. In particular, variables can get bound to predicate names only at run-time, and this causes problems with analysis of strongly connected components (SCCs) and can make Semi-naive evaluation inefficient.
Reference: [47] <author> J.-L. Lassez and M. J. Maher. </author> <title> On Fourier's algorithm for linear arithmetic constraints. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 9 </volume> <pages> 373-379, </pages> <year> 1992. </year>
Reference-contexts: p 0 r5 : p 0 The body of each rule includes a derived literal from the body of rule r1, and the projection of the constraints in the body of r1 onto the variables of the derived literal. (Such a projection can be performed using the techniques described in <ref> [47] </ref>, for instance.) Thus, although Y 4 is not present in the body of r1, it is implied by the conjunction of constraints (X + Y 6)&(X 2). <p> This is because "projection" (or quantifier elimination) of linear arithmetic constraint sets can be done exactly using the algorithm described in <ref> [47] </ref>, for instance. This concludes the induction. Hence, fact p (a) satisfies C k p (since it's number is k), and hence C p .
Reference: [48] <author> A. Lefebvre. </author> <title> Towards an efficient evaluation of recursive aggregates in deductive databases. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: In this case as well, dependencies between subgoals are maintained transitively, and our previous comparisons also apply to this case. 3.7.3 Subquery Completion A variant of QSQR, subquery completion, was described in Lefebvre <ref> [48] </ref> to deal with recursively defined aggregates. It uses the dependencies between subgoals maintained by QSQR to handle a class of acyclic programs with aggregation. <p> There is no analogue to this step in the technique of <ref> [48] </ref>. 3.7.4 Techniques for computing the well-founded model There are several query evaluation techniques in the literature that compute answers under the well-founded model.
Reference: [49] <author> N. Leone and P. Rullo. </author> <title> Safe computation of the well-founded semantics of Datalog queries. </title> <journal> Information Systems, </journal> <volume> 17(1) </volume> <pages> 17-31, </pages> <year> 1992. </year>
Reference-contexts: For example, WELL! [14] is based on global SLS-resolution, XOLDTNF [21] is an extension of OLDT resolution, GUUS <ref> [49] </ref> is based on the alternating fixpoint semantics, and the techniques of Kemp et al. [40, 41, 43] and Morishita [53] are based on alternating fixpoint semantics and Magic-sets.
Reference: [50] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> second edition, </address> <year> 1987. </year> <month> 154 </month>
Reference-contexts: However, bottom-up evaluation of recursive programs based on Magic-sets has many advantages over a top-down evaluation scheme such as Prolog. It is sound and complete with respect to the declarative semantics of least Herbrand models (see Lloyd <ref> [50] </ref>, for instance) for positive programs. When used in conjunction with Semi-naive evaluation [5, 6, 10], it is guaranteed to prevent repeated computation. Further, it is more efficient than Prolog in many database applications, because it is set-oriented. However, Magic-sets evaluation has its limitations.
Reference: [51] <author> Y. Lou and Z. M. Ozsoyoglu. LLO: </author> <title> An object-oriented deductive language with methods and method inheritance. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 198-207, </pages> <address> Denver, Colorado, </address> <month> May </month> <year> 1991. </year>
Reference: [52] <author> D. Maier. </author> <title> A logic for objects. </title> <type> Technical Report Technical report CS/E-86-012, </type> <institution> Oregon Graduate Center, Beaverton Oregon 97006-1999, </institution> <month> November </month> <year> 1986. </year>
Reference-contexts: However, the Coral++ declarative language can create facts describing relationships between existing objects in the database. Rules in Coral++ are deliberately restricted to avoid creating new objects, since this is an issue that is not yet well-understood despite work by Maier <ref> [52] </ref>, Kifer et al. [45], and others. A number of issues, notably the resolution of conflicts when rules generate distinct objects with the same object identifier, remain unclear, especially in the presence of partially specified objects (e.g. some fields are variables, in the Coral++ context).
Reference: [53] <author> S. Morishita. </author> <title> An alternating fixpoint tailored to magic programs. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <year> 1993. </year>
Reference-contexts: Hence, Ordered Search would use O (m) space and make O (m) derivations in computing the query answer. (For more details, see Example 3.8.) We describe other top-down and bottom-up techniques that can evaluate this program in Section 3.7. As an example, the technique of Morishita <ref> [53] </ref> would also use O (m) space and make O (m) derivations on this example. However, if rule r1 were removed from P even , the technique of [53] would make O (m 2 ) derivations, though it would still use only O (m) space. <p> As an example, the technique of Morishita <ref> [53] </ref> would also use O (m) space and make O (m) derivations on this example. However, if rule r1 were removed from P even , the technique of [53] would make O (m 2 ) derivations, though it would still use only O (m) space. <p> For example, WELL! [14] is based on global SLS-resolution, XOLDTNF [21] is an extension of OLDT resolution, GUUS [49] is based on the alternating fixpoint semantics, and the techniques of Kemp et al. [40, 41, 43] and Morishita <ref> [53] </ref> are based on alternating fixpoint semantics and Magic-sets. The class of programs handled by these techniques is larger than that handled by Ordered Search, but each of these techniques can repeat computation even for left-to-right modularly stratified programs. This can result in a loss of efficiency of evaluation.
Reference: [54] <author> K. Morris, J. D. Ullman, and A. Van Gelder. </author> <title> Design overview of the NAIL! system. </title> <booktitle> In Proceedings of the Third International Conference on Logic Programming, </booktitle> <year> 1986. </year>
Reference-contexts: Thus deductive database systems must have powerful optimization techniques to efficiently answer queries (see [8, 66, 92] for a discussion). Existing deductive database systems (Aditi [93], CORAL [65, 1 2 68], Glue-NAIL <ref> [54, 62] </ref>, and LDL [22, 59], among others) incorporate many different optimization strategies for answering queries. One of the most important optimization strategies used in these deductive database systems is Magic-sets [7, 11, 64, 73, 80].
Reference: [55] <author> I. S. Mumick. </author> <title> Query Optimization in Deductive and Relational Databases. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> Dec. </month> <year> 1991. </year> <note> Report No. STAN-CS-91-1400. </note>
Reference-contexts: The interested reader is referred to <ref> [55, 56, 64] </ref> for a detailed discussion. 4 We assume that all subgoals set up on a predicate p in a top-down evaluation have the same set of bound and free arguments.
Reference: [56] <author> I. S. Mumick, S. J. Finkelstein, H. Pirahesh, and R. Ramakrishnan. </author> <title> Magic conditions. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 314-330, </pages> <address> Nashville, Tennessee, </address> <month> Apr. </month> <year> 1990. </year>
Reference-contexts: The interested reader is referred to <ref> [55, 56, 64] </ref> for a detailed discussion. 4 We assume that all subgoals set up on a predicate p in a top-down evaluation have the same set of bound and free arguments. <p> If only Magic-sets transformation is used to optimize CQL programs, this could lead to the generation of constraint facts, even when the evaluation of the original program generates only ground facts. 2 A motivation for this work, as for Balbin et al. [4] and Mumick et al. <ref> [56] </ref>, is to take advantage of the constraints present in the program to reduce the potentially relevant facts computed, and yet compute only ground facts during the bottom-up evaluation of the rewritten program. * Even when constraint facts are generated, we may ensure termination in evaluating queries on CQL programs that <p> given the query: ? cheaporshort (madison; seattle; T ime; Cost): 78 one could compute many f light facts with Cost &gt; 150 and T ime &gt; 240; these facts are not relevant to answering the query. 2 The rewriting techniques proposed by Balbin et al. [4] and Mumick et al. <ref> [56] </ref> would not be able to optimize this program. The technique of Balbin et al. treats constraints in a manner similar to "ordinary" literals, and does not make use of semantic properties of constraints. <p> An important question is how Magic-sets interacts with the use of Gen-Prop-predicate-constraints and Gen-Prop-QRP-constraints. Our results are as follows: 1. In [82], we present an algorithm based on Magic-sets followed by a finite sequence of fold/unfold transformations that essentially mimics the algorithm of Mumick et al. <ref> [56] </ref>. This enables us to view the results of this chapter, and the algorithms in [4] and [56] in a uniform framework; namely, a combination of Magic-sets and (possibly simpler versions of) the algorithms Gen-Prop-predicate-constraints and Gen-Prop QRP-constraints, in some order. 2. <p> Our results are as follows: 1. In [82], we present an algorithm based on Magic-sets followed by a finite sequence of fold/unfold transformations that essentially mimics the algorithm of Mumick et al. <ref> [56] </ref>. This enables us to view the results of this chapter, and the algorithms in [4] and [56] in a uniform framework; namely, a combination of Magic-sets and (possibly simpler versions of) the algorithms Gen-Prop-predicate-constraints and Gen-Prop QRP-constraints, in some order. 2. <p> However, the rewriting technique does not terminate in general. A key feature of our rewriting technique is that it makes essential use of semantic properties of constraints, unlike previous techniques that had a similar objective <ref> [4, 56] </ref>. As a consequence, we are able to optimize a larger class of programs than previous techniques. 4.5.1 An Example First, we give a simple example of how the fold/unfold transformations can be used along with semantic properties of constraints to propagate constraint selections in a program. <p> We have thus generated and propagated the minimum QRP-constraints for the various derived predicates in the original program. 91 Neither the C-transformation of [4], nor the GMT-transformation of <ref> [56] </ref> would be able to propagate all the constraints in this example. <p> As described in <ref> [56] </ref>, the GMT-transformation does not handle constraints with arithmetic function symbols such as +. Consequently, it would not be able to propagate constraints either. 2 4.5.2 Generation of QRP-constraints Our algorithm, Gen-QRP-constraints, described in Appendix A.2, for generating QRP-constraints works iteratively. <p> The other constraint is redundant. 6 This is a combinatorial upper-bound for the number of iterations taken. For most programs, we expect the bound to be considerably lower. 108 4.7 Understanding Previous Techniques Balbin et al. [4] and Mumick et al. <ref> [56] </ref> consider the problem of propagating constraints such as X &gt; 10 in a range-restricted, function-free CQL program P . 7 Both [4] and [56] use a combination of constraint propagation and Magic-sets. <p> For most programs, we expect the bound to be considerably lower. 108 4.7 Understanding Previous Techniques Balbin et al. [4] and Mumick et al. <ref> [56] </ref> consider the problem of propagating constraints such as X &gt; 10 in a range-restricted, function-free CQL program P . 7 Both [4] and [56] use a combination of constraint propagation and Magic-sets. A fundamental limitation of each of these techniques is that they do not utilize semantic properties of constraints. <p> Our algorithms for generating and propagating minimum QRP-constraints can be straightforwardly used to replace the constraint propagation phase of [4]'s technique. The resulting technique can optimize a larger class of programs than [4]. 4.7.2 Mumick et al.'s GMT-transformation The approach taken by Mumick et al. <ref> [56] </ref> (the Ground Magic-sets transformation, or GMT) directly extends the Magic-sets rewriting of [64] to support propagation of arithmetic constraints, without leading to computation of constraint facts. Although, [56] presents the GMT-transformation as a single algorithm that combines Magic-sets with the propagation of constraints, to understand the GMT-transformation, it is best <p> technique can optimize a larger class of programs than [4]. 4.7.2 Mumick et al.'s GMT-transformation The approach taken by Mumick et al. <ref> [56] </ref> (the Ground Magic-sets transformation, or GMT) directly extends the Magic-sets rewriting of [64] to support propagation of arithmetic constraints, without leading to computation of constraint facts. Although, [56] presents the GMT-transformation as a single algorithm that combines Magic-sets with the propagation of constraints, to understand the GMT-transformation, it is best to think of GMT as a three step transformation, as shown in Figure 4.10: 1. Given a program P , the first step is an adornment phase. <p> We show in [82] that this final (and quite complicated) grounding step can be understood as a sequence of fold/unfold transformations using the system of Tamaki and Sato [88]. Thus, the technique of <ref> [56] </ref> can also be decomposed into a combination of the Magic-sets rewriting and the fold/unfold transformation, each of which is well-understood. Semantic properties of constraints can also be used to enhance the adornment phase in the GMT-algorithm of [56], and permit a larger class of programs to be optimized. <p> Thus, the technique of <ref> [56] </ref> can also be decomposed into a combination of the Magic-sets rewriting and the fold/unfold transformation, each of which is well-understood. Semantic properties of constraints can also be used to enhance the adornment phase in the GMT-algorithm of [56], and permit a larger class of programs to be optimized. In contrast to [4], the approach of [56] is to magic transform the (adorned) program before applying the fold/unfold transformations. <p> Semantic properties of constraints can also be used to enhance the adornment phase in the GMT-algorithm of <ref> [56] </ref>, and permit a larger class of programs to be optimized. In contrast to [4], the approach of [56] is to magic transform the (adorned) program before applying the fold/unfold transformations. <p> in which the Magic-sets transformation computes only ground facts: * First, when we use the bound-if-ground rule (equivalently, the class of bf adornments), where an argument of a subgoal is treated as bound only if it is ground; it is free otherwise. * Second, when we use Mumick et al's <ref> [56] </ref> class of bcf adornments for groundable programs, with grounding sips, in conjunction with their GMT algorithm. An important question is how Magic-sets interacts with the use of Gen-Prop-predicate-constraints and Gen-Prop-QRP-constraints in these cases. <p> One such possibility is the class of bcf adornments of Mumick et al. <ref> [56] </ref>, where the `c' adornment denotes an argument that is independently constrained. <p> The main problem is that for the class of bcf adornments, constraint magic rewriting alone does not guarantee that the evaluation of the rewritten program P mg computes only ground facts, even if the evaluation of the original program P computed only ground facts. However, for groundable programs <ref> [56] </ref>, one could replace the constraint magic rewriting described in Section 4.8.2 by (a suitably enhanced version of) the GMT algorithm, to obtain a magic rewriting that computes only ground facts.
Reference: [57] <author> I. S. Mumick and K. A. Ross. </author> <title> An architecture for declarative object-oriented databases. </title> <booktitle> In Proceedings of the JICSLP-92 Workshop on Deductive Databases, </booktitle> <pages> pages 21-30, </pages> <address> Washington, D.C., </address> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: of the important aspects of our design, and how related proposals differ are as follows: * Coral++ uses the type system of an existing object-oriented programming language (i.e., C++) as an object data model rather than inventing yet another object data model which is the approach taken by, for instance, <ref> [3, 28, 32, 37, 45, 57, 77] </ref>. This 143 approach benefits from the support for data abstraction, inheritance, polymorphism and parametrized types already available in C++. <p> This approach can effectively utilize the Coral implementation and the C++ compiler. SWORD <ref> [57] </ref> and ObjectStore [60], for instance, take the alternative approach of inventing new syntax to query an object data model. * Coral++ is more expressive than most of the other proposals [24, 28, 32, 77]. In particular, it provides a facility for generalized recursive view definition in the query language. <p> It also supports unordered relations (i.e., sets and multisets) and ordered relations (lists and arrays), which are useful in applications involving sequence data [76]. * The Coral++ query language can be largely understood in terms of standard Horn clause logic (with C++ method invocations treated as external functions), unlike Noodle <ref> [57] </ref> which is based on HiLog [20] and XSQL [45] which is based on F-logic [46]. <p> This facilitates querying schema information as well as instance-level information in object-oriented databases, using a single declarative query language. Noodle <ref> [57, 58] </ref> is a declarative query language for the SWORD declarative object-oriented database. Unlike Coral++ and XSQL, Noodle does not use path expressions to access attributes and invoke methods on objects. Instead, Noodle uses a syntax reminiscent of HiLog [20] for this purpose.
Reference: [58] <author> I. S. Mumick and K. A. Ross. </author> <title> The influence of class hierarchy choice on query language design. </title> <booktitle> In Proceedings of the Workshop on Combining Declarative and Object-Oriented Databases, </booktitle> <pages> pages 152-154, </pages> <address> Washington, D.C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: This facilitates querying schema information as well as instance-level information in object-oriented databases, using a single declarative query language. Noodle <ref> [57, 58] </ref> is a declarative query language for the SWORD declarative object-oriented database. Unlike Coral++ and XSQL, Noodle does not use path expressions to access attributes and invoke methods on objects. Instead, Noodle uses a syntax reminiscent of HiLog [20] for this purpose.
Reference: [59] <author> S. Naqvi and S. Tsur. </author> <title> A Logical Language for Data and Knowledge Bases. </title> <booktitle> Principles of Computer Science. </booktitle> <publisher> Computer Science Press, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: Thus deductive database systems must have powerful optimization techniques to efficiently answer queries (see [8, 66, 92] for a discussion). Existing deductive database systems (Aditi [93], CORAL [65, 1 2 68], Glue-NAIL [54, 62], and LDL <ref> [22, 59] </ref>, among others) incorporate many different optimization strategies for answering queries. One of the most important optimization strategies used in these deductive database systems is Magic-sets [7, 11, 64, 73, 80]. <p> Such sophisticated features are very useful for data modeling in many scientific, engineering, and multimedia applications. Deductive database languages, such as LDL <ref> [59] </ref>, Coral [65] and Glue-Nail! [62], among others, enhance the declarative query language by providing a facility for generalized recursive view definition, which is of considerable practical importance. However, data models for deductive databases are typically structural, and do not have the richness of object-oriented data models. <p> In deductive database languages such as LDL <ref> [59] </ref> and Coral [65], values can be Herbrand terms, which are essentially structured values. However, data modeling in many scientific and engineering applications require support for more sophisticated features such as abstract data types, encapsulation, methods and inheritance. <p> This translation is possible because of the lack of behavioral features and polymorphism in the data model. It is not clear how the translation approach generalizes once we introduce behavioral features in the model. LDL++ [3] is a deductive database system whose type system extends that of LDL <ref> [59] </ref> with an abstract data type facility that supports inheritance and predicate-valued methods. However, it does not support object sharing or ADT extents, and its support of encapsulation and object identity is limited. Consequently, the data model is not as rich as the Coral++ data model.
Reference: [60] <author> J. Orenstein, S. Haradhvala, B. Margulies, and D. Sakahara. </author> <title> Query processing in the ObjectStore database system. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 403-412, </pages> <address> San Diego, California, </address> <year> 1992. </year>
Reference-contexts: This 143 approach benefits from the support for data abstraction, inheritance, polymorphism and parametrized types already available in C++. Other query languages that use the C++ type system include CQL++ [24], Ob jectStore <ref> [60] </ref> and ZQL [C++] [15]. * The Coral++ declarative query language supports the combination of Coral rules with C++ expressions in a clean fashion. This approach can effectively utilize the Coral implementation and the C++ compiler. SWORD [57] and ObjectStore [60], for instance, take the alternative approach of inventing new syntax <p> use the C++ type system include CQL++ [24], Ob jectStore <ref> [60] </ref> and ZQL [C++] [15]. * The Coral++ declarative query language supports the combination of Coral rules with C++ expressions in a clean fashion. This approach can effectively utilize the Coral implementation and the C++ compiler. SWORD [57] and ObjectStore [60], for instance, take the alternative approach of inventing new syntax to query an object data model. * Coral++ is more expressive than most of the other proposals [24, 28, 32, 77]. In particular, it provides a facility for generalized recursive view definition in the query language.
Reference: [61] <author> R. Paige and J. T. Schwatz. </author> <title> Reduction in strength of high level operations. </title> <booktitle> In Proc. Fourth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 58-71, </pages> <year> 1977. </year> <month> 155 </month>
Reference-contexts: Note that each derivation made in an iteration of Naive bottom-up evaluation is repeated in subsequent iterations. 2 2.2.2 Semi-naive Evaluation Semi-naive evaluation <ref> [5, 6, 10, 27, 61] </ref> is an optimization of Naive evaluation, such that no derivation is repeated in the bottom-up evaluation. For simplicity, we consider only range-restricted programs; the bottom-up evaluation of such programs compute only ground facts.
Reference: [62] <author> G. Phipps, M. A. Derr, and K. A. Ross. </author> <title> Glue-NAIL!: A deductive database system. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 308-317, </pages> <year> 1991. </year>
Reference-contexts: Thus deductive database systems must have powerful optimization techniques to efficiently answer queries (see [8, 66, 92] for a discussion). Existing deductive database systems (Aditi [93], CORAL [65, 1 2 68], Glue-NAIL <ref> [54, 62] </ref>, and LDL [22, 59], among others) incorporate many different optimization strategies for answering queries. One of the most important optimization strategies used in these deductive database systems is Magic-sets [7, 11, 64, 73, 80]. <p> Such sophisticated features are very useful for data modeling in many scientific, engineering, and multimedia applications. Deductive database languages, such as LDL [59], Coral [65] and Glue-Nail! <ref> [62] </ref>, among others, enhance the declarative query language by providing a facility for generalized recursive view definition, which is of considerable practical importance. However, data models for deductive databases are typically structural, and do not have the richness of object-oriented data models.
Reference: [63] <author> T. Przymusinski. </author> <title> On the declarative semantics of stratified deductive databases. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 193-216, </pages> <year> 1988. </year>
Reference-contexts: Consequently, if each ground atom has the same ordinal level as the number of occurrences of the function symbol s, the condition for local stratification would be satisfied. 2 37 Przymusinski <ref> [63] </ref> proposed the perfect model semantics for the class of locally stratified programs. We do not present details of the perfect model semantics here, and refer the reader to [63] for formal definitions. <p> as the number of occurrences of the function symbol s, the condition for local stratification would be satisfied. 2 37 Przymusinski <ref> [63] </ref> proposed the perfect model semantics for the class of locally stratified programs. We do not present details of the perfect model semantics here, and refer the reader to [63] for formal definitions. As with stratified programs, the intuitive idea is to choose one of the minimal models of the entire program, based on the assignment of ordinal levels to ground atoms and an "iterated minimal model" construction procedure.
Reference: [64] <author> R. Ramakrishnan. </author> <title> Magic templates: A spellbinding approach to logic programs. </title> <booktitle> In Proceedings of the International Conference on Logic Programming, </booktitle> <pages> pages 140-159, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: Existing deductive database systems (Aditi [93], CORAL [65, 1 2 68], Glue-NAIL [54, 62], and LDL [22, 59], among others) incorporate many different optimization strategies for answering queries. One of the most important optimization strategies used in these deductive database systems is Magic-sets <ref> [7, 11, 64, 73, 80] </ref>. Magic-sets is a general program transformation technique that seeks to restrict the computation to facts that are relevant to answering the query, where a fact is considered relevant if it would be computed in a top-down evaluation of the given query. <p> Also, while the Magic-sets optimization can propagate "constant" binding information (e.g., X = 5) from a query into the program such that the transformed program may be efficiently evaluated, the propagation of "constraint" binding information (e.g., X &lt; 5) leads to the computation of constraint facts <ref> [39, 64] </ref>, which are expensive to manipulate. The major goal of this thesis is to address and resolve these limitations of Magic-sets based bottom-up evaluation of deductive database queries. <p> The Magic-sets evaluation cannot utilize all the constraint information present in such program-query pairs without computing non-ground constraint facts <ref> [39, 64] </ref>, which are expensive to manipulate. With the Constraint-rewrite optimization, only "constraint relevant" facts are computed, and if the evaluation of the original program computes only ground facts, then so does the evaluation of the transformed program. <p> Top-down evaluation techniques, such as Prolog, usually achieve this objective by using answers to subgoals to bind arguments of other subgoals, and hence restrict the model to be computed to facts relevant to answering a query (or goal). Magic-sets transformations <ref> [7, 11, 64, 73, 80] </ref> are 21 used to imitate top-down computations using bottom-up computation. The major advantage they provide over Naive and Semi-naive bottom-up evaluation is that they allow a bottom-up computation to be specialized with respect to the query, thus improving the efficiency of answering queries. <p> facts, where a fact is considered relevant only if it is an answer to a subgoal set up in a top-down evaluation of P . * Finally, a "seed' magic fact that corresponds to the query Q is added to the Magic sets transformed program M P . 3 Ramakrishnan <ref> [64] </ref> generalizes these notions of "bound" and "free" arguments of a subgoal to capture larger classes of binding patterns. <p> The interested reader is referred to <ref> [55, 56, 64] </ref> for a detailed discussion. 4 We assume that all subgoals set up on a predicate p in a top-down evaluation have the same set of bound and free arguments. <p> We refer the reader to <ref> [11, 64] </ref> for a detailed discussion of the Supplementary Magic-sets transformation, and give an example here. Example 2.4 (Supplementary Magic-sets Transformation) Consider the Magic-sets transformed program M P of Example 2.3. <p> One could also treat an argument "bound," if it is potentially restricted; this is the approach taken by Ramakrishnan <ref> [64] </ref>. <p> The resulting technique can optimize a larger class of programs than [4]. 4.7.2 Mumick et al.'s GMT-transformation The approach taken by Mumick et al. [56] (the Ground Magic-sets transformation, or GMT) directly extends the Magic-sets rewriting of <ref> [64] </ref> to support propagation of arithmetic constraints, without leading to computation of constraint facts. <p> Let the adorned program obtained be P ad . 2. In the second step, they take a bcf adorned program, and apply the Magic-sets transformation of <ref> [64] </ref> to get a program that may have non-range restricted magic rules. Let the Magic-sets transformed program be P ad;mg . 3. Finally, they ground the magic rules in P ad;mg to get a range restricted program P ad;mg;gr . <p> A shortcoming of these techniques for propagating constraints is that they are not able to take advantage of the pattern of constants in the actual query, known only at run-time, or the actual set of facts in the database predicates. 111 Magic-sets <ref> [64] </ref> is a rewriting strategy that is able to take advantage of constants in the actual query, as well as the actual set of facts in the database predicates, thereby restricting the computation to facts that are potentially relevant to answering a given query. <p> Such facts are often useful in knowledge representation, natural language processing and could be particularly useful in a database that stores (and possibly manipulates) rules. There is another, possibly more important, use of variables | namely to specify constraint facts <ref> [39, 64] </ref>. However, the Coral data model does not allow values of (arbitrary) user-defined types in facts.
Reference: [65] <author> R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> CORAL: Control, Relations and Logic. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <year> 1992. </year>
Reference-contexts: This makes it easy for the users to specify queries, but it places the burden of query evaluation on the system. Thus deductive database systems must have powerful optimization techniques to efficiently answer queries (see [8, 66, 92] for a discussion). Existing deductive database systems (Aditi [93], CORAL <ref> [65, 1 2 68] </ref>, Glue-NAIL [54, 62], and LDL [22, 59], among others) incorporate many different optimization strategies for answering queries. One of the most important optimization strategies used in these deductive database systems is Magic-sets [7, 11, 64, 73, 80]. <p> If hP; Qi is left-to-right modularly stratified, then an Ordered Search evaluation of SMT (P; Q) takes no more time (asymptotically) than Ross' method to evaluate hP; Qi. 2 3.6 Ordered Search in Practice Ordered Search has been implemented in the Coral deductive database system <ref> [65, 68] </ref>. In this section, we briefly describe our experience with the Ordered Search evaluation strategy in Coral. 3.6.1 Modules in Coral A Coral declarative program can be organized as a collection of interacting modules. <p> Such sophisticated features are very useful for data modeling in many scientific, engineering, and multimedia applications. Deductive database languages, such as LDL [59], Coral <ref> [65] </ref> and Glue-Nail! [62], among others, enhance the declarative query language by providing a facility for generalized recursive view definition, which is of considerable practical importance. However, data models for deductive databases are typically structural, and do not have the richness of object-oriented data models. <p> In deductive database languages such as LDL [59] and Coral <ref> [65] </ref>, values can be Herbrand terms, which are essentially structured values. However, data modeling in many scientific and engineering applications require support for more sophisticated features such as abstract data types, encapsulation, methods and inheritance. <p> However, data modeling in many scientific and engineering applications require support for more sophisticated features such as abstract data types, encapsulation, methods and inheritance. To support the data modeling needs of such applications, the Coral++ data model enhances the untyped Coral data model <ref> [65] </ref> with the C++ class facility. Values in Coral++ can additionally be of any class definable in C++, which can be manipulated using only the corresponding methods, supporting encapsulation. This allows a programmer to effectively use a combination of C++ and Coral. <p> It is based on the Coral query language <ref> [65] </ref> which supports general Horn clauses with complex terms, multiset-grouping, aggregation and negation. Coral++ extends the Coral query language by allowing C++ expressions for accessing attributes and invoking (side-effect free) methods of classes in program rules. <p> It also allows several aggregate operations on sets and multisets: these include count; min; max; sum; product; average and any. Some of the aggregate operations can be combined directly with the multiset-generation operations for increased efficiency (see Ramakrishnan et al. <ref> [65] </ref> for further details). A Coral declarative program can be organized as a collection of interacting modules. Modules provide a way, as the name suggests, to modularize Coral code. <p> We refer the interested reader to <ref> [65] </ref> for a discussion of these annotations and their effect on module evaluation. In the absence of any user-specified annotations, the Coral system chooses from among a set of default evaluation strategies.
Reference: [66] <author> R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> Efficient bottom-up evaluation of logic programs. </title> <editor> In J. Vandewalle, editor, </editor> <booktitle> The State of the Art in Computer Systems and Software Engineering. </booktitle> <publisher> Kluwer Academic Publishers, </publisher> <year> 1992. </year>
Reference-contexts: This makes it easy for the users to specify queries, but it places the burden of query evaluation on the system. Thus deductive database systems must have powerful optimization techniques to efficiently answer queries (see <ref> [8, 66, 92] </ref> for a discussion). Existing deductive database systems (Aditi [93], CORAL [65, 1 2 68], Glue-NAIL [54, 62], and LDL [22, 59], among others) incorporate many different optimization strategies for answering queries. <p> It is beyond the scope of this thesis to review them all, and we refer the reader to <ref> [66, 92] </ref> for a survey. In this section, we focus attention of the Magic-sets approach to improving the efficiency of answering queries. The Magic-sets transformation is important because it can result in significant improvements, and at the same time it is generally applicable (see Kemp [43] for details).
Reference: [67] <author> R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> Rule ordering in bottom-up fixpoint evaluation of logic programs. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <note> 1993. To appear. (A shorter version appeared in VLDB, </note> <year> 1990). </year>
Reference-contexts: The usual Semi-naive algorithm is capable of evaluating a limited number of rule or-derings, e.g. those that result in an SCC-by-SCC evaluation. However, it cannot correctly evaluate regular expressions over rules that order rule applications within an SCC. In <ref> [67] </ref>, we present two fixpoint algorithms that address the issue of how to apply rules in a specified order without repeating inferences. <p> It handles a more restricted set of control expressions compared to GSN, but is cheaper 74 than GSN. In fact, it has no additional overheads compared to the usual Semi-naive evaluation. We also study rule orderings in detail in <ref> [67] </ref>, and establish a close connection between cycles in rule graphs (which are a variant of rule/goal graphs defined in [8, 92]) and orderings that minimize the number of iterations and rule applications.
Reference: [68] <author> R. Ramakrishnan, D. Srivastava, S. Sudarshan, and P. Seshadri. </author> <title> Implementation of the CORAL deductive database system. </title> <booktitle> In Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <year> 1993. </year>
Reference-contexts: If hP; Qi is left-to-right modularly stratified, then an Ordered Search evaluation of SMT (P; Q) takes no more time (asymptotically) than Ross' method to evaluate hP; Qi. 2 3.6 Ordered Search in Practice Ordered Search has been implemented in the Coral deductive database system <ref> [65, 68] </ref>. In this section, we briefly describe our experience with the Ordered Search evaluation strategy in Coral. 3.6.1 Modules in Coral A Coral declarative program can be organized as a collection of interacting modules. <p> Hence, it is important to provide some of the benefits of tuple-at-a-time computation with bottom-up evaluation, and Ordered Search does just this. Ordered Search can also be used to evaluate programs with left-to-right modularly stratified aggregation; the algorithms described in Appendix A.1 and the Coral implementation <ref> [68] </ref> deal with programs with aggregation as well as programs with negation. <p> This methodology stems from the view that the query language has to be declarative, whereas creating, updating and deleting objects are operational notions. 5.5 Implementing Coral++ One of the fundamental design decisions of our proposal is to use the run-time system of the Coral implementation <ref> [68] </ref> as much as possible in the implementation of Coral++. Several design decisions are a practical consequence of this: * The notation for class definitions in Coral++ is the same as in C++. <p> An initial implementation based on the run-time system of the Coral implementation <ref> [68] </ref> is underway. <p> It is cleanly integrated with C++, providing the user the ability to program in a combination of programming styles, with minimal impedance mismatch. We proposed an implementation strategy for Coral++ that effectively uses the existing Coral run-time system <ref> [68] </ref> and the C++ compiler to implement object-oriented features of the data model and the query language. This, in our view, is one of the strong points of our proposal, and distinguishes it from many proposals in the literature describing query languages for object-oriented databases.
Reference: [69] <author> R. Ramakrishnan and S. Sudarshan. </author> <title> Top-Down vs. Bottom-Up Revisited. </title> <booktitle> In Proceedings of the International Logic Programming Symposium, </booktitle> <year> 1991. </year>
Reference-contexts: The interested reader is referred to <ref> [17, 69, 86, 91] </ref> for details on the duality between top-down and bottom-up evaluation. Note that the first two steps of the Magic-sets transformation can be performed at "compile-time," while the final step can be performed only at "run-time," when the actual query is known. <p> Unification of ground facts can be done in constant time using hash-consing for ground terms; indexing and insertion of ground facts in relations can also be done in constant time using hash based indexing (see <ref> [69] </ref>). Hence, the cost of each derivation depends on the operations on Context, and several of these operations are operations on sets: finding the node corresponding to a fact, taking the union of facts associated with nodes on Context, and deleting entire sets of facts associated with a ContextN ode.
Reference: [70] <author> P. Z. Revesz. </author> <title> A closed form for Datalog queries with integer order. </title> <booktitle> In International Conference on Database Theory, </booktitle> <pages> pages 187-201, </pages> <address> France, </address> <month> Dec. </month> <year> 1990. </year>
Reference: [71] <author> J. Richardson. </author> <title> Supporting lists in a data model (a timely approach). </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <pages> pages 127-138, </pages> <address> Vancouver, Canada, </address> <year> 1992. </year>
Reference: [72] <author> J. E. Richardson, M. J. Carey, and D. T. Schuh. </author> <title> The design of the E programming language. </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> 15(3) </volume> <pages> 494-534, </pages> <month> July </month> <year> 1993. </year> <month> 156 </month>
Reference-contexts: Object-oriented database languages, such as E <ref> [72] </ref>, O++ [1] and O 2 [25], among others, enhance the relational data model by providing support for abstract data types, encapsulation, object identifiers, methods, inheritance and polymorphism. Such sophisticated features are very useful for data modeling in many scientific, engineering, and multimedia applications.
Reference: [73] <author> J. Rohmer, R. Lescoeur, and J. M. Kerisit. </author> <title> The Alexander method | a technique for the processing of recursive axioms in deductive database queries. </title> <journal> New Generation Computing, </journal> <volume> 4 </volume> <pages> 522-528, </pages> <year> 1986. </year>
Reference-contexts: Existing deductive database systems (Aditi [93], CORAL [65, 1 2 68], Glue-NAIL [54, 62], and LDL [22, 59], among others) incorporate many different optimization strategies for answering queries. One of the most important optimization strategies used in these deductive database systems is Magic-sets <ref> [7, 11, 64, 73, 80] </ref>. Magic-sets is a general program transformation technique that seeks to restrict the computation to facts that are relevant to answering the query, where a fact is considered relevant if it would be computed in a top-down evaluation of the given query. <p> Top-down evaluation techniques, such as Prolog, usually achieve this objective by using answers to subgoals to bind arguments of other subgoals, and hence restrict the model to be computed to facts relevant to answering a query (or goal). Magic-sets transformations <ref> [7, 11, 64, 73, 80] </ref> are 21 used to imitate top-down computations using bottom-up computation. The major advantage they provide over Naive and Semi-naive bottom-up evaluation is that they allow a bottom-up computation to be specialized with respect to the query, thus improving the efficiency of answering queries.
Reference: [74] <author> K. Ross. </author> <title> Modular Stratification and Magic Sets for DATALOG programs with negation. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 161-171, </pages> <year> 1990. </year>
Reference-contexts: In Chapter 3 we describe a memoing evaluation technique, Ordered Search, which can evaluate a class of programs with negation and aggregation, known as left-to-right modularly stratified programs <ref> [74] </ref>, more efficiently than other memoing techniques in the literature. We provide both complexity results and performance results to demonstrate the efficiency of the Ordered Search evaluation. <p> For example, to evaluate several classes of programs with negation (or aggregation), it is necessary to order the inferences; in essence, all answers to a negative subgoal must be evaluated before making an inference that depends upon the negative subgoal. A completely breadth-first search strategy (Ross <ref> [74, 75] </ref>, for instance) would have to maintain redundant subgoal dependency information to achieve this. In this chapter we present a memoing technique to order the use of generated subgoals, that is a hybrid between pure breadth-first and pure depth-first search. <p> Even on this modified program, Ordered Search would compute the answer to the query using O (m) space and making O (m) derivations. 2 Example 3.2 (Working Parts) Consider the following program from Kemp et al. [40], 29 which is modified from an example in Ross <ref> [74] </ref>. working (X) : tested (X): working (X) : essential part (X; Y ); working (Y ): working (X) : part (X; Y ); not has suspect part (X): has suspect part (X) : part (X; Y ); not working (Y ): The database consists of the relations tested; part and <p> Ross <ref> [74] </ref> introduced the class of modularly stratified programs, generalizing locally stratified programs, where information about the model of a lower SCC is utilized to give the program a semantics based on an assignment of ordinal levels to ground atoms. <p> All performance numbers in this chapter are obtained on a DECstation 5000 rated at 25 MIPS, with 24 megabytes of main memory, running Ultrix 4.2. We use the program in Figure 3.3 (from Ross <ref> [74] </ref>), and compare alternative evaluation strategies on different input data sets. <p> subpart (P 1; P 3) : connection (C); P 1 = ((connectionfl)C) ! f rom; P 2 = ((connectionfl)C) ! to; ((connectionfl)C) ! ctype = "subpart"; subpart (P 2; P 3): all subparts (P 1; &lt; P 2 &gt;) : subpart (P 1; P 2): Consider the following query from <ref> [74] </ref>: "Find if a given part is working, where a part is known to be working either if it has been (successfully) tested or if it is constructed from smaller parts, and all the smaller parts are known to be working." This can be expressed in Coral++ as follows: working (P
Reference: [75] <author> K. A. Ross. </author> <title> The Semantics of Deductive Databases. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> Aug. </month> <year> 1991. </year> <note> Report No. STAN-CS-91-1386. </note>
Reference-contexts: For example, to evaluate several classes of programs with negation (or aggregation), it is necessary to order the inferences; in essence, all answers to a negative subgoal must be evaluated before making an inference that depends upon the negative subgoal. A completely breadth-first search strategy (Ross <ref> [74, 75] </ref>, for instance) would have to maintain redundant subgoal dependency information to achieve this. In this chapter we present a memoing technique to order the use of generated subgoals, that is a hybrid between pure breadth-first and pure depth-first search. <p> The bottom-up evaluation of the Magic-sets transformed program does compute the subgoals (i.e., magic facts) set up in the top-down evaluation. However, it does not maintain "dependencies" between subgoals and consequently the evaluation of the Magic-sets transformed program also computes incorrect answers to queries. 28 Ross <ref> [75] </ref> proposed a modified Magic-sets rewriting of hP even ; Q even i in conjunction with a bottom-up method for evaluating the rewritten program. <p> Definition 3.1 (Non-floundering Program) A program P is non-floundering if each negative subgoal set up in a top-down evaluation of P is ground. 2 As with the technique of Ross <ref> [75] </ref>, our technique deals only with non-floundering programs, and we assume that programs are non-floundering in the rest of this chapter. We now define SLP-trees, which characterize top-down Prolog-style program evaluations. Definition 3.2 (SLP-trees) ([75]) Let P be a non-floundering program, and let Q be a query. <p> path from Q 1 to Q 2 in the subgoal dependency graph S (P; Q). 2 When the solution of subgoal Q 1 depends on the solution of subgoal Q 2 , we loosely use the notation "subgoal Q 1 depends on subgoal Q 2 ". (Note that, unlike Ross <ref> [75] </ref>, we do not distinguish between positive and negative dependencies.) 3.3.2 Modular Stratification: Syntax and Semantics Definition 3.7 (Stratification) A program is stratified if there is an assignment of ordinal levels to predicates such that whenever a predicate occurs negatively in the body of a rule, the predicate in the head <p> The left-to-right modularly stratified model for the union of S and all SCCs S 0 S is given by M [ M 1. 2 In the subgoal dependency graph for left-to-right modularly stratified programs there is no cyclic dependency involving a negative subgoal. The technique of Ross <ref> [75] </ref> as well as our technique makes essential use of this property in evaluating programs with left-to-right modularly stratified negation. Several semantics have been proposed for general logic programs with negation and/or aggregation. <p> It computes and stores only information about direct dependencies as a linear ordering of the magic facts on Context; hence, the evaluation uses linear space and makes a linear number of derivations. Ross <ref> [75] </ref> proposed a rewriting (SMR) of hP even ; Q even i in conjunction with a bottom-up method for evaluating the rewritten program. This method explicitly stores all the subgoal dependency information for negative subgoals. <p> For instance, in Example 3.1, Ross' algorithm uses O (m 2 ) space, whereas Ordered Search uses O (m) space. Our technique for evaluating left-to-right modularly stratified programs is strictly better than the algorithm in <ref> [75] </ref>, in terms of the asymptotic space complexity. We now compare the asymptotic time complexity of the Ordered Search technique with other bottom-up evaluation strategies. Theorem 3.9 Let hP; Qi be a positive program-query pair. <p> Fully set-oriented computation causes problems for the evaluation of left-to-right modularly stratified programs, as illustrated by our comparisons with Ross <ref> [75] </ref>; it can result in an order of magnitude slow-down. Hence, it is important to provide some of the benefits of tuple-at-a-time computation with bottom-up evaluation, and Ordered Search does just this.
Reference: [76] <author> W. G. Roth. Mimsy: </author> <title> A system for analyzing time series data in the stock market domain. </title> <note> Technical Report To appear, </note> <institution> University of Wisconsin at Madison, </institution> <year> 1993. </year>
Reference-contexts: public: double low ; double high ; double average ( ) ; 135 int volume traded ; g ; Stock market information for individual companies can be naturally represented as array relations, which results in extremely efficient querying and manipulation of such information, as is demonstrated in the Mimsy system <ref> [76] </ref>. 2 5.4 Coral++: Query Language The Coral++ query language is modular, declarative and provides support for generalized recursive view definition. It is based on the Coral query language [65] which supports general Horn clauses with complex terms, multiset-grouping, aggregation and negation. <p> In particular, it provides a facility for generalized recursive view definition in the query language. It also supports unordered relations (i.e., sets and multisets) and ordered relations (lists and arrays), which are useful in applications involving sequence data <ref> [76] </ref>. * The Coral++ query language can be largely understood in terms of standard Horn clause logic (with C++ method invocations treated as external functions), unlike Noodle [57] which is based on HiLog [20] and XSQL [45] which is based on F-logic [46].
Reference: [77] <author> L. A. Rowe and M. R. Stonebraker. </author> <title> The POSTGRES data model. </title> <booktitle> In Proceedings of the Thirteenth International Conference on Very Large Databases, </booktitle> <pages> pages 83-96, </pages> <address> Brighton, England, </address> <month> Sept. </month> <year> 1987. </year>
Reference-contexts: of the important aspects of our design, and how related proposals differ are as follows: * Coral++ uses the type system of an existing object-oriented programming language (i.e., C++) as an object data model rather than inventing yet another object data model which is the approach taken by, for instance, <ref> [3, 28, 32, 37, 45, 57, 77] </ref>. This 143 approach benefits from the support for data abstraction, inheritance, polymorphism and parametrized types already available in C++. <p> This approach can effectively utilize the Coral implementation and the C++ compiler. SWORD [57] and ObjectStore [60], for instance, take the alternative approach of inventing new syntax to query an object data model. * Coral++ is more expressive than most of the other proposals <ref> [24, 28, 32, 77] </ref>. In particular, it provides a facility for generalized recursive view definition in the query language.
Reference: [78] <author> H. Schmidt, W. Kiessling, U. Guntzer, and R. Bayer. </author> <title> Compiling exploratory and goal-directed deduction into sloppy delta iteration. </title> <booktitle> In IEEE International Symposium on Logic Programming, </booktitle> <pages> pages 234-243, </pages> <year> 1987. </year>
Reference-contexts: This can result in a loss of efficiency of evaluation. There are other proposed techniques that control the order of inferences in a bottom-up evaluation in some way. Sloppy Delta Iteration <ref> [78] </ref> provides a way to "hide" facts until they are to be used. Techniques for hiding facts are used in [29, 85] to evaluate programs with aggregate operations efficiently.
Reference: [79] <author> J. Sebelik and P. Stepanek. </author> <title> Horn clause programs for recursive functions. </title> <editor> In K. Clark and S.-A. Tarnlund, editors, </editor> <booktitle> Logic Programming. </booktitle> <publisher> Academic Press, </publisher> <year> 1982. </year>
Reference-contexts: Proof: We first show that a variant of the safety (or finiteness) problem for logic programs is undecidable. Consider the Sebelik and Stepanek <ref> [79] </ref> reduction which showed that every partial recursive function can be expressed as a logic program P pr with one constant symbol and one unary function symbol.
Reference: [80] <author> H. Seki. </author> <title> On the power of Alexander templates. </title> <booktitle> In Proc. of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 150-159, </pages> <year> 1989. </year>
Reference-contexts: Existing deductive database systems (Aditi [93], CORAL [65, 1 2 68], Glue-NAIL [54, 62], and LDL [22, 59], among others) incorporate many different optimization strategies for answering queries. One of the most important optimization strategies used in these deductive database systems is Magic-sets <ref> [7, 11, 64, 73, 80] </ref>. Magic-sets is a general program transformation technique that seeks to restrict the computation to facts that are relevant to answering the query, where a fact is considered relevant if it would be computed in a top-down evaluation of the given query. <p> Top-down evaluation techniques, such as Prolog, usually achieve this objective by using answers to subgoals to bind arguments of other subgoals, and hence restrict the model to be computed to facts relevant to answering a query (or goal). Magic-sets transformations <ref> [7, 11, 64, 73, 80] </ref> are 21 used to imitate top-down computations using bottom-up computation. The major advantage they provide over Naive and Semi-naive bottom-up evaluation is that they allow a bottom-up computation to be specialized with respect to the query, thus improving the efficiency of answering queries.
Reference: [81] <author> D. Srivastava. </author> <title> Subsumption and indexing in constraint query languages with linear arithmetic constraints. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <pages> 8(3-4), </pages> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: The techniques described in Srivastava <ref> [81] </ref> can be used to check for implication of constraint sets of linear arithmetic constraints. <p> There are two possible solutions to this problem: * First, one can represent the minimum QRP-constraint in such a way that the intersection of no two disjuncts is satisfiable. The algorithms described in <ref> [81] </ref> can be used to obtain such non-overlapping disjuncts.
Reference: [82] <author> D. Srivastava and R. Ramakrishnan. </author> <title> Pushing constraint selections. </title> <journal> Journal of Logic Programming, </journal> <note> 1993. To appear. (A shorter version appeared in the Proceedings of the ACM Symposium on the Principles of Database Systems, </note> <year> 1992). </year>
Reference-contexts: For this class of programs, our algorithm for computing minimum QRP-constraints always terminates. The Magic-sets transformation has been widely studied for propagating bindings. An important question is how Magic-sets interacts with the use of Gen-Prop-predicate-constraints and Gen-Prop-QRP-constraints. Our results are as follows: 1. In <ref> [82] </ref>, we present an algorithm based on Magic-sets followed by a finite sequence of fold/unfold transformations that essentially mimics the algorithm of Mumick et al. [56]. <p> Let the Magic-sets transformed program be P ad;mg . 3. Finally, they ground the magic rules in P ad;mg to get a range restricted program P ad;mg;gr . We show in <ref> [82] </ref> that this final (and quite complicated) grounding step can be understood as a sequence of fold/unfold transformations using the system of Tamaki and Sato [88]. <p> For this program P , it is preferable to apply Gen-Prop-QRP-constraints followed by the constraint magic rewriting, independent of the facts in the database. The programs obtained by applying the rewritings in different orders are discussed in Srivastava and Ramakrishnan <ref> [82] </ref>. 2 The above example also illustrates that Constraint-rewrite and constraint magic rewriting are not confluent either. <p> For this program P , it is preferable to apply constraint magic rewriting followed by Gen-Prop-QRP-constraints, independent of the facts in the database, and pattern of constants in the actual query. The programs obtained by applying the rewritings in different orders are discussed in Srivastava and Ramakrishnan <ref> [82] </ref>. 2 Examples 4.8 and 4.9 show that, in general, no ordering of Gen-Prop-QRP-constraints and constraint magic rewriting is always superior to the other.
Reference: [83] <author> D. Srivastava, R. Ramakrishnan, S. Sudarshan, and P. Seshadri. </author> <title> Coral++: Adding object-orientation to a logic database language. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <year> 1993. </year> <month> 157 </month>
Reference-contexts: This methodology stems from the view that querying is possible in a declarative language, whereas creation, updates and deletion should be performed only using an imperative language. We discuss querying in this chapter and refer the interested reader to Srivastava et al. <ref> [83] </ref> for a description of the imperative features of Coral++. In summary, the proposal is simple, combines features of C++ and Coral|two existing languages|with minimal changes to either, and yields a powerful combination of the object-oriented and deductive paradigms.
Reference: [84] <author> B. Stroustrup. </author> <title> The C++ Programming Language (2nd Edition). </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: In relational query languages such as SQL, values in fields of tables have been restricted to be atomic constants (e.g., integers or strings). In logic programs, values can be Herbrand terms, which are essentially structured values. In Coral++, values can additionally be of any class definable in C++ <ref> [84] </ref>. (We chose C++ since it provides a well-understood and widely used object-oriented type system.) Coral++ provides support for maintaining extents, or collections of objects of a given type, either in a simple manner that reflects the inclusions associated with traditional IS-A hierarchies, or in a more sophisticated way through the
Reference: [85] <author> S. Sudarshan and R. Ramakrishnan. </author> <title> Aggregation and relevance in deductive databases. </title> <booktitle> In Proceedings of the Seventeenth International Conference on Very Large Databases, </booktitle> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: There are other proposed techniques that control the order of inferences in a bottom-up evaluation in some way. Sloppy Delta Iteration [78] provides a way to "hide" facts until they are to be used. Techniques for hiding facts are used in <ref> [29, 85] </ref> to evaluate programs with aggregate operations efficiently.
Reference: [86] <author> S. Sudarshan and R. Ramakrishnan. </author> <title> Optimizations of bottom-up evaluation with non-ground terms. </title> <booktitle> In Proceedings of the International Logic Programming Symposium, </booktitle> <year> 1993. </year>
Reference-contexts: The interested reader is referred to <ref> [17, 69, 86, 91] </ref> for details on the duality between top-down and bottom-up evaluation. Note that the first two steps of the Magic-sets transformation can be performed at "compile-time," while the final step can be performed only at "run-time," when the actual query is known.
Reference: [87] <author> S. Sudarshan, D. Srivastava, R. Ramakrishnan, and C. Beeri. </author> <title> Extending the well-founded and valid semantics for aggregation. </title> <booktitle> In Proceedings of the International Logic Programming Symposium, </booktitle> <year> 1993. </year>
Reference-contexts: The technique of Ross [75] as well as our technique makes essential use of this property in evaluating programs with left-to-right modularly stratified negation. Several semantics have been proposed for general logic programs with negation and/or aggregation. These include the well-founded semantics <ref> [42, 87, 96, 97] </ref>, the stable model semantics [31, 42], and the valid semantics [12, 87]. These semantics differ in the meaning they assign to a program when there are cyclic dependencies between subgoals through negation and/or aggregation. <p> Several semantics have been proposed for general logic programs with negation and/or aggregation. These include the well-founded semantics [42, 87, 96, 97], the stable model semantics [31, 42], and the valid semantics <ref> [12, 87] </ref>. These semantics differ in the meaning they assign to a program when there are cyclic dependencies between subgoals through negation and/or aggregation.
Reference: [88] <author> H. Tamaki and T. Sato. </author> <title> Unfold/fold transformations of logic programs. </title> <booktitle> In Proceedings of the Second International Conference on Logic Programming, </booktitle> <pages> pages 127-138, </pages> <institution> Uppsala, Sweden, </institution> <month> July </month> <year> 1984. </year>
Reference-contexts: This technique is based on two algorithms: 1. Gen-Prop-predicate-constraints, which generates and propagates constraints that are satisfied by program predicates based on their definitions. 2. Gen-Prop-QRP-constraints, which generates and propagates constraints based on the uses of program predicates, using fold/unfold transformations (Tamaki and Sato <ref> [88] </ref>) and constraint manipulation. We also show that determining whether (any representation for) the minimum QRP-constraint for a predicate is a finite constraint set is undecidable (Section 4.4). We describe a class of programs for which this problem is decidable (Section 4.6). <p> Our technique has two components to it: 1. For each derived predicate p of a program P , it generates QRP-constraints on p, using semantic properties of constraints. 2. It then uses the fold/unfold transformations <ref> [88] </ref> to propagate the QRP-constraint on p into the program rules defining p. Procedure Gen-Prop-QRP-constraints in Appendix A.2 describes this technique algorithmically. If the rewriting technique terminates, it propagates QRP-constraints for each derived predicate in the program, while preserving the core of the program. <p> Let the adorned program obtained be P ad . 2. Second, they perform a C-transformation on the adorned program. This is expressed as a sequence of fold, unfold, and definition steps using the fold/unfold transformations of Tamaki and Sato <ref> [88] </ref>. This step propagates constraints into the recursive rules, while obtaining a query-equivalent program. <p> Finally, they ground the magic rules in P ad;mg to get a range restricted program P ad;mg;gr . We show in [82] that this final (and quite complicated) grounding step can be understood as a sequence of fold/unfold transformations using the system of Tamaki and Sato <ref> [88] </ref>. Thus, the technique of [56] can also be decomposed into a combination of the Magic-sets rewriting and the fold/unfold transformation, each of which is well-understood.
Reference: [89] <author> R. E. Tarjan. </author> <title> Data Structures and Network Algorithms. </title> <institution> Society for Industrial and Applied Mathematics, </institution> <year> 1983. </year>
Reference-contexts: These operations can be efficiently implemented using the union-find technique <ref> [89] </ref>, with an amortized cost of O (ff (N )) per operation, where N is the total number of these operations on Context, and ff (N ) is the inverse Ackermann function.
Reference: [90] <author> A. Tarski. </author> <title> A Decision Method for Elementary Algebra and Geometry. </title> <institution> University of California Press, Berkeley, California, </institution> <year> 1951. </year>
Reference-contexts: The proof of Claim 1 follows from the decision procedure of Tarski <ref> [90] </ref> for the theory of real closed fields. All the operations needed for a rule application have straightforward analogues in Tarski's decision procedure; projection (on the variables of the head of a rule) corresponds to quantifier elimination, for instance.
Reference: [91] <author> J. D. Ullman. </author> <title> Bottom-up beats top-down for Datalog. </title> <booktitle> In Proceedings of the Eighth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 140-149, </pages> <address> Philadelphia, Pennsylvania, </address> <month> March </month> <year> 1989. </year>
Reference-contexts: The interested reader is referred to <ref> [17, 69, 86, 91] </ref> for details on the duality between top-down and bottom-up evaluation. Note that the first two steps of the Magic-sets transformation can be performed at "compile-time," while the final step can be performed only at "run-time," when the actual query is known.
Reference: [92] <author> J. D. Ullman. </author> <title> Principles of Database and Knowledge-Base Systems, Volumes I and II. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: This makes it easy for the users to specify queries, but it places the burden of query evaluation on the system. Thus deductive database systems must have powerful optimization techniques to efficiently answer queries (see <ref> [8, 66, 92] </ref> for a discussion). Existing deductive database systems (Aditi [93], CORAL [65, 1 2 68], Glue-NAIL [54, 62], and LDL [22, 59], among others) incorporate many different optimization strategies for answering queries. <p> It is beyond the scope of this thesis to review them all, and we refer the reader to <ref> [66, 92] </ref> for a survey. In this section, we focus attention of the Magic-sets approach to improving the efficiency of answering queries. The Magic-sets transformation is important because it can result in significant improvements, and at the same time it is generally applicable (see Kemp [43] for details). <p> In fact, it has no additional overheads compared to the usual Semi-naive evaluation. We also study rule orderings in detail in [67], and establish a close connection between cycles in rule graphs (which are a variant of rule/goal graphs defined in <ref> [8, 92] </ref>) and orderings that minimize the number of iterations and rule applications.
Reference: [93] <author> J. Vaghani, K. Ramamohanarao, D. B. Kemp, Z. Somogyi, and P. J. Stuckey. </author> <title> Design overview of the Aditi deductive database system. </title> <booktitle> In Proceedings of the Seventh International Conference on Data Engineering, </booktitle> <pages> pages 240-247, </pages> <month> Apr. </month> <year> 1991. </year>
Reference-contexts: This makes it easy for the users to specify queries, but it places the burden of query evaluation on the system. Thus deductive database systems must have powerful optimization techniques to efficiently answer queries (see [8, 66, 92] for a discussion). Existing deductive database systems (Aditi <ref> [93] </ref>, CORAL [65, 1 2 68], Glue-NAIL [54, 62], and LDL [22, 59], among others) incorporate many different optimization strategies for answering queries. One of the most important optimization strategies used in these deductive database systems is Magic-sets [7, 11, 64, 73, 80].
Reference: [94] <author> A. Van Gelder. </author> <title> Negation as failure using tight derivations for general logic programs. </title> <booktitle> In Proceedings of the Symposium on Logic Programming, </booktitle> <pages> pages 127-139, </pages> <year> 1986. </year> <month> 158 </month>
Reference-contexts: if there is no cyclic dependency between predicates "through" aggregation. (This can 35 be formalized using the notion of assignments of ordinal levels to program predicates as before.) The solutions proposed for stratified negation also apply to programs with stratified aggregation. 2 Apt, Blair and Walker [2] and Van Gelder <ref> [94] </ref> independently proposed a semantics for stratified programs. We give a brief description of their semantics for stratified programs, and refer the reader to [2, 94] for formal definitions. <p> We give a brief description of their semantics for stratified programs, and refer the reader to <ref> [2, 94] </ref> for formal definitions. The intuitive idea is to choose one of the minimal models of the entire program, based on the assignment of ordinal levels to predicates and an "iterated minimal model" construction procedure.
Reference: [95] <author> A. Van Gelder. </author> <title> Deriving constraints among argument sizes in logic programs. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <volume> 3 </volume> <pages> 361-392, </pages> <year> 1991. </year>
Reference-contexts: Van Gelder <ref> [95] </ref> also studies a similar but more restricted problem; the techniques of [95] can be used only to derive a single conjunction of constraints on the arguments of a predicate; general constraint sets (which are disjunctions of conjunctions) are not inferred. <p> Van Gelder <ref> [95] </ref> also studies a similar but more restricted problem; the techniques of [95] can be used only to derive a single conjunction of constraints on the arguments of a predicate; general constraint sets (which are disjunctions of conjunctions) are not inferred.
Reference: [96] <author> A. Van Gelder. </author> <title> The well-founded semantics of aggregation. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 127-138, </pages> <year> 1992. </year>
Reference-contexts: The technique of Ross [75] as well as our technique makes essential use of this property in evaluating programs with left-to-right modularly stratified negation. Several semantics have been proposed for general logic programs with negation and/or aggregation. These include the well-founded semantics <ref> [42, 87, 96, 97] </ref>, the stable model semantics [31, 42], and the valid semantics [12, 87]. These semantics differ in the meaning they assign to a program when there are cyclic dependencies between subgoals through negation and/or aggregation.
Reference: [97] <author> A. Van Gelder, K. Ross, and J. S. Schlipf. </author> <title> Unfounded sets and well-founded semantics for general logic programs. </title> <journal> Journal of the ACM, </journal> <volume> 38(3) </volume> <pages> 620-650, </pages> <year> 1991. </year>
Reference-contexts: The technique of Ross [75] as well as our technique makes essential use of this property in evaluating programs with left-to-right modularly stratified negation. Several semantics have been proposed for general logic programs with negation and/or aggregation. These include the well-founded semantics <ref> [42, 87, 96, 97] </ref>, the stable model semantics [31, 42], and the valid semantics [12, 87]. These semantics differ in the meaning they assign to a program when there are cyclic dependencies between subgoals through negation and/or aggregation.
Reference: [98] <author> L. Vieille. </author> <title> Recursive axioms in deductive databases: The query-subquery approach. </title> <booktitle> In Proceedings of the First International Conference on Expert Database Systems, </booktitle> <pages> pages 179-193, </pages> <address> Charleston, South Carolina, </address> <year> 1986. </year>
Reference-contexts: Prolog is not complete even for Datalog, and may repeat derivations. Also, Prolog does not evaluate the class of left-to-right modularly stratified programs correctly. 2 3.7.2 QSQR/QoSaQ and Extension Tables Extension Tables [26] is similar to Prolog, except that it memos facts and subgoals and can detect loops. QSQR/QoSaQ <ref> [98, 99] </ref> is a top-down, memoing, set-oriented strategy that is closely related to bottom-up evaluation with Supplementary Magic rewriting. Like Prolog, these techniques cannot deal with left-to-right modularly stratified negation/aggregation. The tuple-oriented search strategy of the Extension Tables variant ET* is closer to Prolog, but it repeats computation.
Reference: [99] <author> L. Vieille. </author> <title> From QSQ towards QoSaQ: Global optimizations of recursive queries. </title> <booktitle> In Proc. 2nd International Conference on Expert Database Systems, </booktitle> <month> Apr. </month> <year> 1988. </year>
Reference-contexts: Prolog is not complete even for Datalog, and may repeat derivations. Also, Prolog does not evaluate the class of left-to-right modularly stratified programs correctly. 2 3.7.2 QSQR/QoSaQ and Extension Tables Extension Tables [26] is similar to Prolog, except that it memos facts and subgoals and can detect loops. QSQR/QoSaQ <ref> [98, 99] </ref> is a top-down, memoing, set-oriented strategy that is closely related to bottom-up evaluation with Supplementary Magic rewriting. Like Prolog, these techniques cannot deal with left-to-right modularly stratified negation/aggregation. The tuple-oriented search strategy of the Extension Tables variant ET* is closer to Prolog, but it repeats computation.
Reference: [100] <author> K. Yokota, H. Tsuda, and Y. Morita. </author> <title> Specific features of a deductive object-oriented database language QUIXOTE. </title> <booktitle> In Proceedings of the Workshop on Combining Declarative and Object-Oriented Databases, </booktitle> <pages> pages 89-99, </pages> <address> Washington, D.C., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: There are several other interesting proposals for combining semantically rich data models with deductive databases that are less closely related to Coral++. Concept-Base [38] and Quixote <ref> [100] </ref> are two such systems. ConceptBase is based on the Telos knowledge representation language, and allows the specification of methods using deductive rules and integrity constraints.
References-found: 100

