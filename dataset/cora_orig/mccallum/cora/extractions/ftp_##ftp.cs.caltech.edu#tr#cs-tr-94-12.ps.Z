URL: ftp://ftp.cs.caltech.edu/tr/cs-tr-94-12.ps.Z
Refering-URL: ftp://ftp.cs.caltech.edu/tr/INDEX.html
Root-URL: http://www.cs.caltech.edu
Title: RVM7b -0 Theory and Use of Conditional Composition  
Author: Rajit Manohar K. Rustan M. Leino 
Date: July 1, 1994  
Address: Pasadena, CA 91125.  
Affiliation: Department of Computer Science California Institute of Technology  
Abstract: The somewhat debatable role of goto statements in practical programming is reflected in their theoretical properties, in that in the treatment both of their semantics and their correctness we are confronted with difficulties of a nature not previously encountered." From J. de Bakker. Mathematical Theory of Program Correctness. Chapter 10. Prentice-Hall, 1980. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R.-J.R. Back and M. Karttunen. </author> <title> A predicate transformer semantics for statements with multiple exits. </title> <institution> University of Helsinki, unpublished MS, </institution> <year> 1983. </year>
Reference-contexts: In this section, we suggest a disciplined approach to the introduction of such an operator into a programming language. We then demonstrate how one can use this operator to describe the semantics of exceptions [7], loop exits, and structured jumps <ref> [1] </ref>. 3.0. SEMANTICS OF PARTITIONS We describe how the semantics of conditional composition can be used to describe the semantics of a program given a partition of the state space. We identify an element of the partition with an element from the index set U . Restriction. <p> STRUCTURED JUMPS Another application of the semantics presented here is to define the meaning of a branch statement (cf. <ref> [1] </ref>, [2]). We describe how a structured branching technique can be implemented with two different statement labels. For two labels, we let U = fA; B ; N ; E g. Let A and B be the branch labels. <p> In this note we have presented a semantics which handles any partition of the state space uniformly. The results from [7] served as the foundation for the semantics presented here. Other early references to semantics in particular semantics of exception handling are [3] and the unpublished <ref> [1] </ref>. The formerly mentioned of these references provides a good discussion of how exception handling can simplify the structure of certain programs. It gives separate predicate transformers for normal and exceptional outcomes, whereas we do not distinguish between the two. In [1], an arbitrary number of outcomes is considered and a <p> semantics of exception handling are [3] and the unpublished <ref> [1] </ref>. The formerly mentioned of these references provides a good discussion of how exception handling can simplify the structure of certain programs. It gives separate predicate transformers for normal and exceptional outcomes, whereas we do not distinguish between the two. In [1], an arbitrary number of outcomes is considered and a structured branching scheme is discussed. In [7], wep:S is applied to a pair of predicates, whereas we only have one (partitioned) predicate. 4.
Reference: [2] <author> J. de Bakker. </author> <title> Mathematical Theory of Program Correctness. Chapter 10. </title> <publisher> Prentice-Hall, </publisher> <year> 1980. </year>
Reference-contexts: STRUCTURED JUMPS Another application of the semantics presented here is to define the meaning of a branch statement (cf. [1], <ref> [2] </ref>). We describe how a structured branching technique can be implemented with two different statement labels. For two labels, we let U = fA; B ; N ; E g. Let A and B be the branch labels.
Reference: [3] <author> F. Cristian. </author> <title> Correct and robust programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 10 </volume> <pages> 163-174, </pages> <year> 1984. </year>
Reference-contexts: In this note we have presented a semantics which handles any partition of the state space uniformly. The results from [7] served as the foundation for the semantics presented here. Other early references to semantics in particular semantics of exception handling are <ref> [3] </ref> and the unpublished [1]. The formerly mentioned of these references provides a good discussion of how exception handling can simplify the structure of certain programs. It gives separate predicate transformers for normal and exceptional outcomes, whereas we do not distinguish between the two.
Reference: [4] <author> E.W. Dijkstra and C.S. Scholten. </author> <title> Predicate Calculus and Program Semantics. </title> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: THEORY OF CONDITIONAL COMPOSITION We generalize the concept of function composition to conditional function composition. To enable us to do so, we first introduce a notation for tagged collections, which can be used to represent lists, arrays, or any other labeled collection of objects. Our proof format is from <ref> [4] </ref>. We use [ ] for everywhere brackets, which denote universal quantification over the state space, and the infix dot to denote function application. 1.0. <p> Proof. Follows from (48) and (42), (44), (46). 2 2.1. WEAKEST PRECONDITIONS We define function wp:S :Q to be the weakest condition on the initial state such that: execution of S terminates; on termination Q holds <ref> [4] </ref>. We examine the weakest precondition semantics for conditional composition. We use the usual wp semantics from [4] using the definition of wp presented in [8], [11] in terms of traces. wp:S :Q :x = h 8 t | first:t = x ^ t 2 S . fin:t ^ Q :(last <p> WEAKEST PRECONDITIONS We define function wp:S :Q to be the weakest condition on the initial state such that: execution of S terminates; on termination Q holds <ref> [4] </ref>. We examine the weakest precondition semantics for conditional composition. We use the usual wp semantics from [4] using the definition of wp presented in [8], [11] in terms of traces. wp:S :Q :x = h 8 t | first:t = x ^ t 2 S . fin:t ^ Q :(last :t )i (51) We confine our attention to predicates Q that are partitioned predicates. <p> a p T ):Q wp:(S ; if (p ffi idx ) ! T :(p ffi idx ) ! skip fi):Q = f (58): wp of ; g wp:S :(wp: if (p ffi idx ) ! T :(p ffi idx ) ! skip fi :Q) = f wp of IF (from <ref> [4] </ref>, [8], [11]) g wp:S :(((p ffi idx ) _ :(p ffi idx )) ^ ((p ffi idx ) ) wp:T :Q ) ^ (:(p ffi idx ) ) wp:skip:Q)) = f [X _ :X ]; (56) g = f (55) g 2 We now relate a p to the composition
Reference: [5] <author> R.M. Dijkstra. </author> <title> Operational Semantics: correction & embellishment. Internal Note rutger 16, </title> <year> 1993. </year>
Reference-contexts: We follow the path of [7], [8], [9] and [11] which first describe an operational semantics in terms of traces and then derive a weakest precondition semantics from it. RVM7b -9 2.0. TRACE SEMANTICS We will use the semantics of statements presented in [8], [11], <ref> [5] </ref>. We use X to denote the (non-empty) state space. Variables that refer to the state are implicitly assumed to be from X . Traces are nonempty sequences of states. fin:t is true just when t is a trace of finite length. inf :t is the negation of fin:t . <p> Theorem ; = a true (40) Proof. Follows from the definition of a true . 2 Theorem (Identity of ;) skip is the left and right identity of ; (41) Proof. Can be taken without modification from [8],[11]. 2 The following are some theorems about semicolon. Theorem (From <ref> [5] </ref>, [8], [11].) ; is associative. (42) ; is universally [-distributive in its left argument. (43) ; is positively [-distributive in its right argument. (44) We can use the definition of repetition and selection from [5], [8], or [11] without modification since the trace semantics for semicolon has not been changed. <p> Theorem (From <ref> [5] </ref>, [8], [11].) ; is associative. (42) ; is universally [-distributive in its left argument. (43) ; is positively [-distributive in its right argument. (44) We can use the definition of repetition and selection from [5], [8], or [11] without modification since the trace semantics for semicolon has not been changed. We use the definition of the IF statement given in [5]. Since we have defined all our earlier semantics in terms of trace sets, we rewrite the definition presented in [5] in the following manner. <p> in its left argument. (43) ; is positively [-distributive in its right argument. (44) We can use the definition of repetition and selection from <ref> [5] </ref>, [8], or [11] without modification since the trace semantics for semicolon has not been changed. We use the definition of the IF statement given in [5]. Since we have defined all our earlier semantics in terms of trace sets, we rewrite the definition presented in [5] in the following manner. <p> repetition and selection from <ref> [5] </ref>, [8], or [11] without modification since the trace semantics for semicolon has not been changed. We use the definition of the IF statement given in [5]. Since we have defined all our earlier semantics in terms of trace sets, we rewrite the definition presented in [5] in the following manner. For any predicate b, we define b? as follows: b? = fx | x 2 X ^ b:x . x g (45) Using this definition of b?, we define the IF statement from [5] as: ifh i . b i ! S i ifi = h <p> semantics in terms of trace sets, we rewrite the definition presented in <ref> [5] </ref> in the following manner. For any predicate b, we define b? as follows: b? = fx | x 2 X ^ b:x . x g (45) Using this definition of b?, we define the IF statement from [5] as: ifh i . b i ! S i ifi = h [ i . b i ?; S i i [ h 8 i . :b i i?; E (46) where E is defined as the set of all eternal traces.
Reference: [6] <author> H.P. Hofstee, and K.R.M. Leino. </author> <title> Class notes, CS284: Reasoning about Program Correctness: Sequential Programs. </title> <institution> California Institute of Technology, </institution> <note> Spring term 1993-94. </note>
Reference-contexts: TAGGED COLLECTIONS A quantifier Q is defined by a triple (?; u; f ) where ? is an associative and symmetric operator from D fi D ! D , u is the unit element of ?, and f is a function from T ! D (cf. <ref> [6] </ref>). A quantified expression, (or quantifier) is an expression of the form: hQ x | r :x . t:x i where x is an unordered list of identifier names (dummies), r :x (the range) is a predicate, and t:x (the term) is an expression of some type T . <p> Since F is simply a quantifier, we can use the following properties which follow from the general properties of quantification. However, we must be careful since t imposes certain restrictions on its arguments. We present some of the axioms from <ref> [6] </ref>. These axioms are simply instances of a few of the axioms for general quantifiers. The following two axioms can be used to eliminate quantification from an expression.
Reference: [7] <author> K.R.M. Leino and J.L.A. van de Snepscheut. </author> <title> Semantics of Exceptions. </title> <note> To appear, IFIP transactions 1994 </note>
Reference-contexts: Imposing a structure on the predicates used for the weakest precondition semantics allows us to identify the composition operators presented earlier with the composition of statements. We follow the path of <ref> [7] </ref>, [8], [9] and [11] which first describe an operational semantics in terms of traces and then derive a weakest precondition semantics from it. RVM7b -9 2.0. TRACE SEMANTICS We will use the semantics of statements presented in [8], [11], [5]. We use X to denote the (non-empty) state space. <p> In this section, we suggest a disciplined approach to the introduction of such an operator into a programming language. We then demonstrate how one can use this operator to describe the semantics of exceptions <ref> [7] </ref>, loop exits, and structured jumps [1]. 3.0. SEMANTICS OF PARTITIONS We describe how the semantics of conditional composition can be used to describe the semantics of a program given a partition of the state space. <p> Defining the partition of the state space in different ways can result in semantics for different language constructs. The sections below describe three such partitions of the state space. They use the following partitions: 1. For the semantics of exceptions presented in <ref> [7] </ref>, a boolean coordinate oc is introduced into the state which is used to partition the state space into two subspaces. 2. To extend the semantics presented in [7] to handle more than one exception, we let the oc coordinate be integer valued. 3. <p> They use the following partitions: 1. For the semantics of exceptions presented in <ref> [7] </ref>, a boolean coordinate oc is introduced into the state which is used to partition the state space into two subspaces. 2. To extend the semantics presented in [7] to handle more than one exception, we let the oc coordinate be integer valued. 3. Structured jumps use a partition in which an extra coordinate label is used to identify the label of the block to which a branch is to be executed. 3.1. <p> Structured jumps use a partition in which an extra coordinate label is used to identify the label of the block to which a branch is to be executed. 3.1. SEMANTICS OF EXCEPTIONS|NORMAL AND EXCEPTIONAL STATES In this section, we relate the semantics presented in <ref> [7] </ref> to those presented here. E is used to denote the a operator from [7]. Note that in [7], there is an underlying assumption that all programs begin in normal states. The functions considered in [7] are from D fi D ! D , which is a special case of the <p> SEMANTICS OF EXCEPTIONS|NORMAL AND EXCEPTIONAL STATES In this section, we relate the semantics presented in <ref> [7] </ref> to those presented here. E is used to denote the a operator from [7]. Note that in [7], there is an underlying assumption that all programs begin in normal states. The functions considered in [7] are from D fi D ! D , which is a special case of the generalized compositions presented here with U = f0; 1g. 3.1.0. <p> SEMANTICS OF EXCEPTIONS|NORMAL AND EXCEPTIONAL STATES In this section, we relate the semantics presented in <ref> [7] </ref> to those presented here. E is used to denote the a operator from [7]. Note that in [7], there is an underlying assumption that all programs begin in normal states. The functions considered in [7] are from D fi D ! D , which is a special case of the generalized compositions presented here with U = f0; 1g. 3.1.0. <p> SEMANTICS OF EXCEPTIONS|NORMAL AND EXCEPTIONAL STATES In this section, we relate the semantics presented in <ref> [7] </ref> to those presented here. E is used to denote the a operator from [7]. Note that in [7], there is an underlying assumption that all programs begin in normal states. The functions considered in [7] are from D fi D ! D , which is a special case of the generalized compositions presented here with U = f0; 1g. 3.1.0. FUNCTIONS OF TWO ARGUMENTS We have the following correspondence between functions and compositions presented in [7] and those explored in this note. <p> The functions considered in <ref> [7] </ref> are from D fi D ! D , which is a special case of the generalized compositions presented here with U = f0; 1g. 3.1.0. FUNCTIONS OF TWO ARGUMENTS We have the following correspondence between functions and compositions presented in [7] and those explored in this note. The correspondence follows from the fact that the normal state is identified with 0 2 U , and the exceptional state is identified with 1. <p> Exceptions Partitions iffih ffi false hffi ffi [[0]] ffii ffi [[1]] hffii ffi true Exceptions Partitions L 0 bx c bx c 0 We have that idx :x = 0 if x :oc = ? bx c 0 = x [oc := ?] The theorems presented in <ref> [7] </ref> follow from those presented here. In addition, we have the following corre spondence: nor = [[0]] ffi idx 3.1.1. TRACE SEMANTICS The program constructs presented in [7] are different from those presented here. <p> have that idx :x = 0 if x :oc = ? bx c 0 = x [oc := ?] The theorems presented in <ref> [7] </ref> follow from those presented here. In addition, we have the following corre spondence: nor = [[0]] ffi idx 3.1.1. TRACE SEMANTICS The program constructs presented in [7] are different from those presented here. In particular, execution always begins in the normal state, and the try operator lowers the exception before executing the exception handler. We have the following correspondence between the semantics presented in [7] and in this note. <p> TRACE SEMANTICS The program constructs presented in <ref> [7] </ref> are different from those presented here. In particular, execution always begins in the normal state, and the try operator lowers the exception before executing the exception handler. We have the following correspondence between the semantics presented in [7] and in this note. Exceptions Partitions S ; T S a [[0]] T S E T S a [[1]] (switch 0 ; T ) raise switch 1 skip fx . bx c 0 g Notice that the normal and exceptional states defined in [7] are not symmetric, a fact reflected <p> correspondence between the semantics presented in <ref> [7] </ref> and in this note. Exceptions Partitions S ; T S a [[0]] T S E T S a [[1]] (switch 0 ; T ) raise switch 1 skip fx . bx c 0 g Notice that the normal and exceptional states defined in [7] are not symmetric, a fact reflected in the table given above. RVM7b -16 Theorem S E T = S a [[1]] (switch 0 ; T ) Proof. <p> fs; u; x | sx 2 S ^ bx c 0 u 2 T ^ fin:s ^ ([[1]] ffi idx ):x . sx bx c 0 ug [ fs | s 2 S ^ (inf :s _ ([[0]] ffi idx ):(last :s)) . sg = f switch to notation in <ref> [7] </ref> g fs; u; x | sx 2 S ^ bx cu 2 T ^ fin:s ^ exc:x . sx bx cug [ fs | s 2 S ^ (inf :s _ nor:(last:s)) . sg = f from [7] g S E T 3.1.2. <p> ffi idx ):(last :s)) . sg = f switch to notation in <ref> [7] </ref> g fs; u; x | sx 2 S ^ bx cu 2 T ^ fin:s ^ exc:x . sx bx cug [ fs | s 2 S ^ (inf :s _ nor:(last:s)) . sg = f from [7] g S E T 3.1.2. WEAKEST PRECONDITIONS The semantics differ in the definition of the weakest preconditions. The reason for this difference is that [7] only considers programs that execute statements in the normal state. [7] defines the weakest precondition of a statement S given postcondition Q to be the <p> T ^ fin:s ^ exc:x . sx bx cug [ fs | s 2 S ^ (inf :s _ nor:(last:s)) . sg = f from <ref> [7] </ref> g S E T 3.1.2. WEAKEST PRECONDITIONS The semantics differ in the definition of the weakest preconditions. The reason for this difference is that [7] only considers programs that execute statements in the normal state. [7] defines the weakest precondition of a statement S given postcondition Q to be the condition that guarantees that: the program terminates in a normal state; on termination Q holds. <p> | s 2 S ^ (inf :s _ nor:(last:s)) . sg = f from <ref> [7] </ref> g S E T 3.1.2. WEAKEST PRECONDITIONS The semantics differ in the definition of the weakest preconditions. The reason for this difference is that [7] only considers programs that execute statements in the normal state. [7] defines the weakest precondition of a statement S given postcondition Q to be the condition that guarantees that: the program terminates in a normal state; on termination Q holds. <p> As opposed to this, we define the weakest precondition to be the condition that guarantees that: the program terminates; on termination Q holds. Also, we do not have to apply wp:S to a pair as in <ref> [7] </ref>, but to a single (partitioned) predicate. 3.2. MORE THAN ONE EXCEPTIONAL STATE If we extend the semantics in [7] to n exceptions, and we define E k to be a [[k]] , then we can use similar correspondences between the constructs presented in this note and [7] to obtain a <p> Also, we do not have to apply wp:S to a pair as in <ref> [7] </ref>, but to a single (partitioned) predicate. 3.2. MORE THAN ONE EXCEPTIONAL STATE If we extend the semantics in [7] to n exceptions, and we define E k to be a [[k]] , then we can use similar correspondences between the constructs presented in this note and [7] to obtain a semantics for programs with more than one exceptional state. 3.3. <p> pair as in <ref> [7] </ref>, but to a single (partitioned) predicate. 3.2. MORE THAN ONE EXCEPTIONAL STATE If we extend the semantics in [7] to n exceptions, and we define E k to be a [[k]] , then we can use similar correspondences between the constructs presented in this note and [7] to obtain a semantics for programs with more than one exceptional state. 3.3. LOOP EXITS Modula-3 is an example of a programming language with exceptions [10]. A loop exit in Modula-3 is considered to be the raising of an exception which causes control to be passed outside the loop. <p> The presented trace semantics was preceded by two attempts. As a first attempt, the trace semantics presented in <ref> [7] </ref> was extended to allow raise to be the left and right identity of E. This led to our next attempt in which we tried to formulate a symmetric semantics for exceptions. lower was introduced as the counterpart of raise. <p> This led to our next attempt in which we tried to formulate a symmetric semantics for exceptions. lower was introduced as the counterpart of raise. In this note we have presented a semantics which handles any partition of the state space uniformly. The results from <ref> [7] </ref> served as the foundation for the semantics presented here. Other early references to semantics in particular semantics of exception handling are [3] and the unpublished [1]. The formerly mentioned of these references provides a good discussion of how exception handling can simplify the structure of certain programs. <p> It gives separate predicate transformers for normal and exceptional outcomes, whereas we do not distinguish between the two. In [1], an arbitrary number of outcomes is considered and a structured branching scheme is discussed. In <ref> [7] </ref>, wep:S is applied to a pair of predicates, whereas we only have one (partitioned) predicate. 4.
Reference: [8] <author> J.J. Lukkien. </author> <title> An operational semantics for the guarded command language. In R.S. Bird, C.C. </title> <publisher> Morgan, </publisher> <editor> and J.C.P. Woodcock, editors, </editor> <booktitle> Mathematics of Program Construction, number 669 in Lecture Notes in Computer Science, </booktitle> <pages> pp 233-249. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Imposing a structure on the predicates used for the weakest precondition semantics allows us to identify the composition operators presented earlier with the composition of statements. We follow the path of [7], <ref> [8] </ref>, [9] and [11] which first describe an operational semantics in terms of traces and then derive a weakest precondition semantics from it. RVM7b -9 2.0. TRACE SEMANTICS We will use the semantics of statements presented in [8], [11], [5]. We use X to denote the (non-empty) state space. <p> We follow the path of [7], <ref> [8] </ref>, [9] and [11] which first describe an operational semantics in terms of traces and then derive a weakest precondition semantics from it. RVM7b -9 2.0. TRACE SEMANTICS We will use the semantics of statements presented in [8], [11], [5]. We use X to denote the (non-empty) state space. Variables that refer to the state are implicitly assumed to be from X . <p> Concatenation of traces is denoted by juxtaposition. Using these notational conventions, we have the following trace semantics for skip and assignment. skip = fx . x g (36) (v := E ) = fx . x x [v := E ]g (37) For sequential composition, we have <ref> [8] </ref>, [11] S ; T = fs; x ; t | sx 2 S ^ xt 2 T ^ fin:s . sxt g [ fs | s 2 S ^ inf :s . sg (38) We assume that there exists a total function idx : X ! U . <p> Theorem ; = a true (40) Proof. Follows from the definition of a true . 2 Theorem (Identity of ;) skip is the left and right identity of ; (41) Proof. Can be taken without modification from <ref> [8] </ref>,[11]. 2 The following are some theorems about semicolon. Theorem (From [5], [8], [11].) ; is associative. (42) ; is universally [-distributive in its left argument. (43) ; is positively [-distributive in its right argument. (44) We can use the definition of repetition and selection from [5], [8], or [11] without modification since the trace semantics for semicolon has not been changed. <p> without modification from <ref> [8] </ref>,[11]. 2 The following are some theorems about semicolon. Theorem (From [5], [8], [11].) ; is associative. (42) ; is universally [-distributive in its left argument. (43) ; is positively [-distributive in its right argument. (44) We can use the definition of repetition and selection from [5], [8], or [11] without modification since the trace semantics for semicolon has not been changed. We use the definition of the IF statement given in [5]. Since we have defined all our earlier semantics in terms of trace sets, we rewrite the definition presented in [5] in the following manner. <p> We examine the weakest precondition semantics for conditional composition. We use the usual wp semantics from [4] using the definition of wp presented in <ref> [8] </ref>, [11] in terms of traces. wp:S :Q :x = h 8 t | first:t = x ^ t 2 S . fin:t ^ Q :(last :t )i (51) We confine our attention to predicates Q that are partitioned predicates. <p> Since the traces of semicolon, skip, and assignment are the same as those in <ref> [8] </ref> and [11], all their results still hold. In particular, we have Theorem (From [8], [11].) [wp:skip:Q Q ] (56) [wp:(v := E ):Q Q [v := E ]] (57) We now examine the weakest precondition semantics for conditional composition. <p> Since the traces of semicolon, skip, and assignment are the same as those in <ref> [8] </ref> and [11], all their results still hold. In particular, we have Theorem (From [8], [11].) [wp:skip:Q Q ] (56) [wp:(v := E ):Q Q [v := E ]] (57) We now examine the weakest precondition semantics for conditional composition. <p> p T ):Q wp:(S ; if (p ffi idx ) ! T :(p ffi idx ) ! skip fi):Q = f (58): wp of ; g wp:S :(wp: if (p ffi idx ) ! T :(p ffi idx ) ! skip fi :Q) = f wp of IF (from [4], <ref> [8] </ref>, [11]) g wp:S :(((p ffi idx ) _ :(p ffi idx )) ^ ((p ffi idx ) ) wp:T :Q ) ^ (:(p ffi idx ) ) wp:skip:Q)) = f [X _ :X ]; (56) g = f (55) g 2 We now relate a p to the composition operator
Reference: [9] <author> J.J. Lukkien. </author> <title> Parallel Program Design and Generalized Weakest Preconditions. </title> <type> PhD thesis, </type> <institution> Groningen University, </institution> <year> 1991. </year> <title> Also, </title> <type> Caltech technical report CS TR 90-16. </type>
Reference-contexts: Imposing a structure on the predicates used for the weakest precondition semantics allows us to identify the composition operators presented earlier with the composition of statements. We follow the path of [7], [8], <ref> [9] </ref> and [11] which first describe an operational semantics in terms of traces and then derive a weakest precondition semantics from it. RVM7b -9 2.0. TRACE SEMANTICS We will use the semantics of statements presented in [8], [11], [5]. We use X to denote the (non-empty) state space.
Reference: [10] <author> G. Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: LOOP EXITS Modula-3 is an example of a programming language with exceptions <ref> [10] </ref>. A loop exit in Modula-3 is considered to be the raising of an exception which causes control to be passed outside the loop.
Reference: [11] <author> J.L.A. van de Snepscheut. </author> <title> On Lattice Theory and Program Semantics. </title> <type> Caltech technical report CS TR 93-19. </type>
Reference-contexts: Imposing a structure on the predicates used for the weakest precondition semantics allows us to identify the composition operators presented earlier with the composition of statements. We follow the path of [7], [8], [9] and <ref> [11] </ref> which first describe an operational semantics in terms of traces and then derive a weakest precondition semantics from it. RVM7b -9 2.0. TRACE SEMANTICS We will use the semantics of statements presented in [8], [11], [5]. We use X to denote the (non-empty) state space. <p> We follow the path of [7], [8], [9] and <ref> [11] </ref> which first describe an operational semantics in terms of traces and then derive a weakest precondition semantics from it. RVM7b -9 2.0. TRACE SEMANTICS We will use the semantics of statements presented in [8], [11], [5]. We use X to denote the (non-empty) state space. Variables that refer to the state are implicitly assumed to be from X . <p> Concatenation of traces is denoted by juxtaposition. Using these notational conventions, we have the following trace semantics for skip and assignment. skip = fx . x g (36) (v := E ) = fx . x x [v := E ]g (37) For sequential composition, we have [8], <ref> [11] </ref> S ; T = fs; x ; t | sx 2 S ^ xt 2 T ^ fin:s . sxt g [ fs | s 2 S ^ inf :s . sg (38) We assume that there exists a total function idx : X ! U . <p> Follows from the definition of a true . 2 Theorem (Identity of ;) skip is the left and right identity of ; (41) Proof. Can be taken without modification from [8],<ref> [11] </ref>. 2 The following are some theorems about semicolon. Theorem (From [5], [8], [11].) ; is associative. (42) ; is universally [-distributive in its left argument. (43) ; is positively [-distributive in its right argument. (44) We can use the definition of repetition and selection from [5], [8], or [11] without modification since the trace semantics for semicolon has not been changed. <p> from [8],<ref> [11] </ref>. 2 The following are some theorems about semicolon. Theorem (From [5], [8], [11].) ; is associative. (42) ; is universally [-distributive in its left argument. (43) ; is positively [-distributive in its right argument. (44) We can use the definition of repetition and selection from [5], [8], or [11] without modification since the trace semantics for semicolon has not been changed. We use the definition of the IF statement given in [5]. Since we have defined all our earlier semantics in terms of trace sets, we rewrite the definition presented in [5] in the following manner. <p> We examine the weakest precondition semantics for conditional composition. We use the usual wp semantics from [4] using the definition of wp presented in [8], <ref> [11] </ref> in terms of traces. wp:S :Q :x = h 8 t | first:t = x ^ t 2 S . fin:t ^ Q :(last :t )i (51) We confine our attention to predicates Q that are partitioned predicates. Let t = h F be a tagged collection of predicates. <p> Since the traces of semicolon, skip, and assignment are the same as those in [8] and <ref> [11] </ref>, all their results still hold. In particular, we have Theorem (From [8], [11].) [wp:skip:Q Q ] (56) [wp:(v := E ):Q Q [v := E ]] (57) We now examine the weakest precondition semantics for conditional composition. <p> Since the traces of semicolon, skip, and assignment are the same as those in [8] and <ref> [11] </ref>, all their results still hold. In particular, we have Theorem (From [8], [11].) [wp:skip:Q Q ] (56) [wp:(v := E ):Q Q [v := E ]] (57) We now examine the weakest precondition semantics for conditional composition. <p> T ):Q wp:(S ; if (p ffi idx ) ! T :(p ffi idx ) ! skip fi):Q = f (58): wp of ; g wp:S :(wp: if (p ffi idx ) ! T :(p ffi idx ) ! skip fi :Q) = f wp of IF (from [4], [8], <ref> [11] </ref>) g wp:S :(((p ffi idx ) _ :(p ffi idx )) ^ ((p ffi idx ) ) wp:T :Q ) ^ (:(p ffi idx ) ) wp:skip:Q)) = f [X _ :X ]; (56) g = f (55) g 2 We now relate a p to the composition operator ffi
Reference: [12] <author> J.D. Ullman. </author> <title> Principles of Database Systems, </title> <publisher> Computer Science Press, </publisher> <year> 1982. </year>
Reference-contexts: Then we may want to apply operation op to only some of the rows, discriminating based on the key. For the selection of the rows, we use a predicate over the index set, usually denoted p. We show some applications of CpB to relational databases <ref> [12] </ref>. We may think of Tag :D as the type of a keyed relation, in which some keys may have no value. In an actual database, that would be represented by the absence of a row. Here, however, we need some value associated with each key.
References-found: 12

