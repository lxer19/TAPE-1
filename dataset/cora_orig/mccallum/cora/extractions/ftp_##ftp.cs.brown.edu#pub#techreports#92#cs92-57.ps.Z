URL: ftp://ftp.cs.brown.edu/pub/techreports/92/cs92-57.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-92-57.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 0
Reference: [1] <author> S. Abiteboul, and P. Kanellakis. </author> <title> Object identity as a query language primitive. </title> <booktitle> Proc. of ACM SIGMOD Conf., </booktitle> <year> 1989. </year>
Reference-contexts: ASSIGN (E 1 , SET APPLY (E 2 , op-seq)) OQL: E 1 (op-seq (x)) E 2 (x) * Algebra: ASSIGN (E 1 , LIST CAT (E 2 , E 3 )) OQL: E 1 (x) E 2 (x) 6.9 Other Languages and Algebra OQL is partially influenced by IQL <ref> [1] </ref>. OQL is however simpler than IQL, because it manipulates only objects, it never makes explicit reference to oids, and it does not manipulate relations. It is also more powerful because it can express duplicate elimination, manipulate lists, handle inheritance trees. IQL is more powerful than languages in [5, 14].
Reference: [2] <author> F. Bancilhon, S. Cluet, and C. Delobel. </author> <title> A query language for the O 2 object-oriented database system. </title> <booktitle> Proc. of 2nd DBPL Workshop, </booktitle> <year> 1990. </year>
Reference-contexts: It is also more powerful because it can express duplicate elimination, manipulate lists, handle inheritance trees. IQL is more powerful than languages in [5, 14]. User-level query laguages such as EXCESS [8] and <ref> [2] </ref> are can be seen as sublanguages of OQL. Shaw and Zdonik [19], and Vadenberg and DeWitt [21] provide object-algebra for object-oriented databases. But neither of them attempt to manipulate mixture of sets and lists. A few other languages attempt to incorporate object-oriented features into logic programs.
Reference: [3] <author> F. Bancilhon, C. Delobel and P. Kanellakis. </author> <title> Introduction to the Data Model. Building an Object-Oriented Database System The Story of O2. </title> <publisher> Morgan Kaufman, </publisher> <pages> pp. 61-75, </pages> <year> 1992. </year>
Reference-contexts: Inheritance polymorphism is provided through late binding of methods based on actual classes of objects. Our data model is conceptually simple. It avoids the objects-versus-values dichotomy found in other data models such as in <ref> [11, 12, 3, 8] </ref>. This is achieved at no extra cost. We also show that it is possible to satisfy a variety of data modeling requirements such as values of O 2 , composite objects of ORION [4, 10], and own ref objects of EXODUS within the object-oriented paradigm. <p> the de fined objects in the database instance * the function fl maps variable names in G to objects which are the values currently assigned to the vari ables 3.6 Other Data Models The data model presented in this section eliminates the dichotomy of object-versus-values found in other data models <ref> [3, 8] </ref>. This simplifies the model, and removes any possibility of confusion between objects and values as pointed out in [15]. It is however possible to achieve the functionality and performance of values in our data model.
Reference: [4] <author> J. Banerjee, H-T Chou, J. F. Garza, W. Kim, D. Woelk, N. Ballou, and H-J Kim. </author> <title> Data model issues for object-oriented applications. </title> <journal> ACM Transactions on Information Systems, </journal> <volume> 5(1), </volume> <pages> pp. 3-26, </pages> <month> January, </month> <year> 1987. </year>
Reference-contexts: This is achieved at no extra cost. We also show that it is possible to satisfy a variety of data modeling requirements such as values of O 2 , composite objects of ORION <ref> [4, 10] </ref>, and own ref objects of EXODUS within the object-oriented paradigm. The conceptual simplicity of the data model does not imply lower performance. It is possible to engineer internal optimizations for good performance. 1 The query language OQL is the most important con-tribution of this paper. <p> Shared versus Own: Sharing and exclusive access are orthogonal issues to information representation. We think these two issues should be kept orthogonal in data models. Our data model does this by providing a separate Own qualifier for attributes. It is possible to provide composite object of ORION <ref> [4] </ref>, as well as own ref [8] objects of EXODUS within object-oriented paradigm. To implement composite objects, one has to introduce the concept ownership (not exclusive access) of an object by another object.
Reference: [5] <author> C. Beeri, S. Naqvi, R. Ramakrishnan, O. Shmueli, and S. Tsur. </author> <title> Sets and negation in a logic database language (LDL1). </title> <booktitle> Proc. of ACM PODS Symposium, </booktitle> <year> 1987. </year>
Reference-contexts: OQL is however simpler than IQL, because it manipulates only objects, it never makes explicit reference to oids, and it does not manipulate relations. It is also more powerful because it can express duplicate elimination, manipulate lists, handle inheritance trees. IQL is more powerful than languages in <ref> [5, 14] </ref>. User-level query laguages such as EXCESS [8] and [2] are can be seen as sublanguages of OQL. Shaw and Zdonik [19], and Vadenberg and DeWitt [21] provide object-algebra for object-oriented databases. But neither of them attempt to manipulate mixture of sets and lists.
Reference: [6] <author> L. Cardelli. </author> <title> A semantics of multiple inheritance. </title> <journal> Information and Computation, </journal> <volume> 76(1), </volume> <month> January, </month> <year> 1988. </year>
Reference-contexts: A method's body is a piece of code written in some programming language, and it implements the intended function. 3.2.3 Inheritance A class declaration may specify a superclass as a part of its class definition. Inheritance <ref> [6, 7] </ref> allows the user to derive new classes from existing classes. Only single-inheritance is allowed in our data model i.e., a class can have at most one superclass 2 . The inheritance relationship is a partial order on the classes, i.e., it is reflexive, antisymmetric and transitive.
Reference: [7] <author> L. Cardelli, and P. Wegner. </author> <title> On understanding types, data abstractions, and polymorphism. </title> <journal> ACM Computing Surveys, </journal> <volume> 17(4), </volume> <pages> pp. 471-522, </pages> <month> December, </month> <year> 1985. </year>
Reference-contexts: A method's body is a piece of code written in some programming language, and it implements the intended function. 3.2.3 Inheritance A class declaration may specify a superclass as a part of its class definition. Inheritance <ref> [6, 7] </ref> allows the user to derive new classes from existing classes. Only single-inheritance is allowed in our data model i.e., a class can have at most one superclass 2 . The inheritance relationship is a partial order on the classes, i.e., it is reflexive, antisymmetric and transitive.
Reference: [8] <author> M. Carey, D. DeWitt and S. Vandenberg. </author> <title> A data model and query language for Exodus. </title> <booktitle> Proc. of ACM SIGMOD Conf., </booktitle> <year> 1988. </year>
Reference-contexts: Inheritance polymorphism is provided through late binding of methods based on actual classes of objects. Our data model is conceptually simple. It avoids the objects-versus-values dichotomy found in other data models such as in <ref> [11, 12, 3, 8] </ref>. This is achieved at no extra cost. We also show that it is possible to satisfy a variety of data modeling requirements such as values of O 2 , composite objects of ORION [4, 10], and own ref objects of EXODUS within the object-oriented paradigm. <p> the de fined objects in the database instance * the function fl maps variable names in G to objects which are the values currently assigned to the vari ables 3.6 Other Data Models The data model presented in this section eliminates the dichotomy of object-versus-values found in other data models <ref> [3, 8] </ref>. This simplifies the model, and removes any possibility of confusion between objects and values as pointed out in [15]. It is however possible to achieve the functionality and performance of values in our data model. <p> We think these two issues should be kept orthogonal in data models. Our data model does this by providing a separate Own qualifier for attributes. It is possible to provide composite object of ORION [4], as well as own ref <ref> [8] </ref> objects of EXODUS within object-oriented paradigm. To implement composite objects, one has to introduce the concept ownership (not exclusive access) of an object by another object. <p> It is also more powerful because it can express duplicate elimination, manipulate lists, handle inheritance trees. IQL is more powerful than languages in [5, 14]. User-level query laguages such as EXCESS <ref> [8] </ref> and [2] are can be seen as sublanguages of OQL. Shaw and Zdonik [19], and Vadenberg and DeWitt [21] provide object-algebra for object-oriented databases. But neither of them attempt to manipulate mixture of sets and lists. A few other languages attempt to incorporate object-oriented features into logic programs.
Reference: [9] <author> D. H. Fishman, D. Beech, H. P. Cate, E. C. Chow, T. Connors, J. W. Davis, N. Derret, C. G. Hoch, W. Kent, P. Lyngbaek, B. Mahbod, M. A. Neimat, T. A. Ryan, and M. C. Shan. </author> <title> Iris: An object-oriented database management system. </title> <journal> ACM Transactions on Information Systems, </journal> <volume> 5(1), </volume> <pages> pp. 48-69, </pages> <address> Januray, </address> <year> 1987. </year>
Reference: [10] <author> W. Kim, J. Banerjee, H-T Chou, J. F. Garza, and D. Woelk. </author> <title> Composite object support in an object-oriented database system. </title> <booktitle> Proc. of ACM OOPSLA Conf., </booktitle> <year> 1987. </year>
Reference-contexts: This is achieved at no extra cost. We also show that it is possible to satisfy a variety of data modeling requirements such as values of O 2 , composite objects of ORION <ref> [4, 10] </ref>, and own ref objects of EXODUS within the object-oriented paradigm. The conceptual simplicity of the data model does not imply lower performance. It is possible to engineer internal optimizations for good performance. 1 The query language OQL is the most important con-tribution of this paper.
Reference: [11] <author> C. Lecluse, and P. Richard. </author> <title> Manipulation of structured values in object-oriented databases. </title> <booktitle> Proc. of 2nd DBPL Workshop, </booktitle> <year> 1989. </year>
Reference-contexts: Inheritance polymorphism is provided through late binding of methods based on actual classes of objects. Our data model is conceptually simple. It avoids the objects-versus-values dichotomy found in other data models such as in <ref> [11, 12, 3, 8] </ref>. This is achieved at no extra cost. We also show that it is possible to satisfy a variety of data modeling requirements such as values of O 2 , composite objects of ORION [4, 10], and own ref objects of EXODUS within the object-oriented paradigm.
Reference: [12] <author> C. Lecluse, and P. Richard. </author> <title> Modeling complex structures in object-oriented databases. </title> <booktitle> Proc. of ACM PODS Symposium, </booktitle> <year> 1989. </year>
Reference-contexts: Inheritance polymorphism is provided through late binding of methods based on actual classes of objects. Our data model is conceptually simple. It avoids the objects-versus-values dichotomy found in other data models such as in <ref> [11, 12, 3, 8] </ref>. This is achieved at no extra cost. We also show that it is possible to satisfy a variety of data modeling requirements such as values of O 2 , composite objects of ORION [4, 10], and own ref objects of EXODUS within the object-oriented paradigm.
Reference: [13] <author> G. M. Kuper, and M. Y. Verdi. </author> <title> A new approach to database logic. </title> <booktitle> Proc. of ACM PODS Symposium, </booktitle> <year> 1984. </year>
Reference: [14] <author> G. M. Kuper. </author> <title> The logical data model: A new approach to database logic. </title> <type> PhD Thesis, </type> <institution> Stanford University, </institution> <year> 1985. </year>
Reference-contexts: OQL is however simpler than IQL, because it manipulates only objects, it never makes explicit reference to oids, and it does not manipulate relations. It is also more powerful because it can express duplicate elimination, manipulate lists, handle inheritance trees. IQL is more powerful than languages in <ref> [5, 14] </ref>. User-level query laguages such as EXCESS [8] and [2] are can be seen as sublanguages of OQL. Shaw and Zdonik [19], and Vadenberg and DeWitt [21] provide object-algebra for object-oriented databases. But neither of them attempt to manipulate mixture of sets and lists.
Reference: [15] <author> O 2 Technology. </author> <title> The O 2 User Manual. </title> <month> June, </month> <year> 1992. </year>
Reference-contexts: Equality and Copying: The system provides three equality operators and two copy operators. The equality operators test for id-equality, shallow-equality, and deep-equality. The copy operators return shallow-copy and deep-copy of a given object. These operators have their standard meaning as in <ref> [15] </ref>, interested readers may also see [17]. 3.4 Class Extensions A database schema explicitly declares a set of classes C 2 C. The system maintains an extension for each class in C. The extension is the set of all objects of its associated class. <p> This simplifies the model, and removes any possibility of confusion between objects and values as pointed out in <ref> [15] </ref>. It is however possible to achieve the functionality and performance of values in our data model. Values: Values can be thought of as special objects which are never shared and have no behavior.
Reference: [16] <author> S. Reiss, and M. Sarkar. </author> <title> Generating abstractions for visualization. </title> <type> Technical Report CS-92-35. </type> <institution> Computer Science Department, Brown University , September, </institution> <year> 1992. </year>
Reference-contexts: This paper presents a data fl Support for this research was provided by NSF grants CCR9111507 and CCR9113226, by ARPA order 8225 and by ONR grant N00014-91-J-4052 1 Readers interested in our program visualization system are referred to <ref> [16] </ref> model, and a query language to be used with our program visualization system. The query language presented in this paper is named OQL (Object Query Language). OQL is declarative, and highly expressive. We use the query language for both definition and generation of abstractions.
Reference: [17] <author> M. Sarkar, and S. Reiss. </author> <title> A data model for object-oriented databases. </title> <type> Technical Report CS-92-56. </type> <institution> Computer Science Department, Brown University, </institution> <month> December, </month> <year> 1992. </year>
Reference-contexts: The inheriting class can define additional attributes and methods, or redefine inherited attributes and methods. However the resulting structure and method suite of the inheriting class must be compatible to the structure and method suite of its superclass respectively. For definitions of structural and method suite compatibility see <ref> [17] </ref>. Subclass Relationship: The actual subclass relationship must be specified by the user by naming the super 2 We feel single-inheritance is adequate for our modeling goal. <p> Equality and Copying: The system provides three equality operators and two copy operators. The equality operators test for id-equality, shallow-equality, and deep-equality. The copy operators return shallow-copy and deep-copy of a given object. These operators have their standard meaning as in [15], interested readers may also see <ref> [17] </ref>. 3.4 Class Extensions A database schema explicitly declares a set of classes C 2 C. The system maintains an extension for each class in C. The extension is the set of all objects of its associated class.
Reference: [18] <author> M. Sarkar, and S. Reiss. </author> <title> A query language for object-oriented databases with tuples, sets and lists. </title> <type> Technical Report CS-92-57. </type> <institution> Computer Science Department, Brown University, </institution> <month> December, </month> <year> 1992. </year>
Reference-contexts: Interested readers can find more examples in <ref> [18] </ref>. 6 Semantics of OQL The semantics of OQL is defined by an algorithm that translates OQL programs into algebraic operations, assignment operations and REPEAT UNTIL loops. In this section we describe an informal and intuitive meaning for OQL programs. Variables: OQL is similar in spirit to Datalog [20]. <p> We have already outlined the basic approach. Readers may find a formal algorithm in <ref> [18] </ref>. Reduction of algebra to OQL : Reduction of the algebra to OQL is proved by case-based induction. We omit most of the cases as our goal is to simply give the flavor of the proof. Details can be found in [18]. <p> Readers may find a formal algorithm in <ref> [18] </ref>. Reduction of algebra to OQL : Reduction of the algebra to OQL is proved by case-based induction. We omit most of the cases as our goal is to simply give the flavor of the proof. Details can be found in [18]. The proof proceeds by induction on number of operators in an algebraic expression E. An algebraic expression consists of EDB variables, IDB variables, class names, attribute names, method names, basic values, equality operators, predicates, and one or more algebraic operators.
Reference: [19] <author> G. M. Shaw, and S. B. Zdonik. </author> <title> A query algebra for object-oriented databases. </title> <booktitle> Proc. of Intl. Conf. on Data Engineering, </booktitle> <pages> pp. 152-162, </pages> <year> 1990. </year>
Reference-contexts: It is also more powerful because it can express duplicate elimination, manipulate lists, handle inheritance trees. IQL is more powerful than languages in [5, 14]. User-level query laguages such as EXCESS [8] and [2] are can be seen as sublanguages of OQL. Shaw and Zdonik <ref> [19] </ref>, and Vadenberg and DeWitt [21] provide object-algebra for object-oriented databases. But neither of them attempt to manipulate mixture of sets and lists. A few other languages attempt to incorporate object-oriented features into logic programs. But that is not the goal of OQL.
Reference: [20] <author> J. D. Ullman. </author> <title> Principles of data and knowledge-based systems. </title> <publisher> Computer Science Press. </publisher> <address> ISBN0-7167-8158-1, </address> <year> 1988. </year>
Reference-contexts: In this section we describe an informal and intuitive meaning for OQL programs. Variables: OQL is similar in spirit to Datalog <ref> [20] </ref>. OQL programs computes values of database variables whose values are undefined from database variables whose values are defined. These are called intensional database variables or IDB variables and extensional database variables or EDB variables respectively. <p> Rules are stratified if whenever there is a rule with head IDB variable P and a negated subgoal with predicate Q, there is no path in the dependency graph from P to Q. One can use the algorithm given in <ref> [20] </ref> to test for and find stratification. A stratified program is evaluated stratum by stratum, starting from the lowest to the highest. When stratum i is being evaluated, the values for the IDB variables at lower strata have already been computed.
Reference: [21] <author> S. L. Vandenberg, and D. J. DeWitt. </author> <title> Algebraic Support for Complex Objects with Arrays, Identity, and Inheritance. </title> <booktitle> Proc. of ACM SIGMOD Conf., </booktitle> <year> 1991. </year>
Reference-contexts: IQL is more powerful than languages in [5, 14]. User-level query laguages such as EXCESS [8] and [2] are can be seen as sublanguages of OQL. Shaw and Zdonik [19], and Vadenberg and DeWitt <ref> [21] </ref> provide object-algebra for object-oriented databases. But neither of them attempt to manipulate mixture of sets and lists. A few other languages attempt to incorporate object-oriented features into logic programs. But that is not the goal of OQL.
References-found: 21

