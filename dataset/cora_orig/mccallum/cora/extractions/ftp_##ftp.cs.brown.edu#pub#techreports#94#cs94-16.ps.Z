URL: ftp://ftp.cs.brown.edu/pub/techreports/94/cs94-16.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-94-16.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> S. Abramski and C. Hankin. </author> <title> An introduction to abstract interpretation. </title> <editor> In S. Abramski and C. Hankin, editors, </editor> <booktitle> Abstract Interpretation of Declarative Languages, chapter 1, </booktitle> <pages> pages 9-31. </pages> <publisher> Ellis Horwood Limited, </publisher> <year> 1987. </year>
Reference-contexts: The "collecting" semantics associates with the program the transformation t 2 : -(PSS) ! -(PSS) defined by t 2 = f&lt; * &gt;:: S : S 2 g: 2 Note that similar problems have been encountered in functional programming <ref> [1] </ref>. 3 -(PSS) is a complete lattice for set inclusion and t 2 is monotonic. However, lfp (t 2 ) is not a consistent approximation of lfp (t 1 ) (i.e. lfp (t 1 ) 62 lfp (t 2 )), since lfp (t 2 ) is the empty set.
Reference: [2] <author> R. Barbuti, M. Codish, R. Giacobazzi, and G. Levi. </author> <title> Modelling Prolog control. </title> <booktitle> In Proceedings of POPL'92, </booktitle> <pages> pages 95-104. </pages> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: Section 4 sketches the concrete semantics. Section 5 and 6 contain respectively the specification of the abstract operations and the abstract semantics. Section 7 discusses the abstract interpretation algorithm while section 8 presents related work, in particular the work of File and Rossi [12] and Barbuti et al. <ref> [2] </ref>. Section 9 concludes the paper. The appendices describe the concrete semantics and sketch the proofs of the main technical results. 2 Overview of the Framework Two Simple Examples We start by two extremely simple examples which are not handled well by existing abstract interpretation frameworks. <p> Finally, our approach has been shown computationally tractable in [4]. At the time of writing, no experimental result have been reported on their approach. The work of Barbuti et al. <ref> [2] </ref> also aims at modelling Prolog control. The main difference between their work and ours is that their framework is intended to use control information deduced from outside, while our framework both deduces and uses control information inside the framework. <p> However some applications such as cardinality analysis [4] could be improved by allowing the framework to use termination information from the outside as in <ref> [2] </ref>. Furthermore, our framework is able to provide precise information about non-termination. This is an important consequence of the fact that the limit of an infinite chain of incomplete substitution sequences is either an incomplete substitution sequence or an infinite sequence.
Reference: [3] <author> M. Baudinet. </author> <title> Proving Termination Properties of Prolog Programs: A Semantic Approach. </title> <booktitle> In Proc. Third IEEE Symp. on Logic In Computer Science, </booktitle> <pages> pages 336-347. </pages> <publisher> IEEE, </publisher> <year> 1988. </year>
Reference-contexts: If the execution produces m computed answer substitutions and then enters into an infinite loop, then S is an incomplete sequence &lt; 1 ; : : : ; m ; ? &gt;, where ? models non termination <ref> [3] </ref>. Finally, if the execution produces an infinite number of computed answer substitutions, then S is an infinite sequence &lt; 1 ; : : : ; i ; : : : &gt; (i 2 N). We note SUBST (S) the set of substitutions in S.
Reference: [4] <author> C. Braem, B. Le Charlier, S. Modart, and P. Van Hentenryck. </author> <title> Cardinality Analysis of Prolog. </title> <type> Technical report, </type> <institution> Department of Computer Science, Brown University, </institution> <month> March </month> <year> 1994. </year> <note> (Submitted to ILPS'94). </note>
Reference-contexts: A typical example is the definition of multi-directional procedures, using cuts and meta-predicates to select among several versions. Ignoring the depth-first search strategy and the cut prevents the compiler from performing various important compiler optimizations such as dead-code elimination <ref> [4] </ref>. 2. The existing frameworks are not expressive enough to capture certain analyses in their entirety. <p> It is important to point out that this paper is more than yet another abstract interpretation framework. The framework was motivated by computational considerations and its practicability and simplicity have been demonstatred on a cardinality analysis described in a companion paper <ref> [4] </ref>. The cardinality analysis, which is an instantiation of the framework to a specific abstract domain, approximates among other things the number of solutions to a goal. It is shown that the analysis requires only a small overhead compared to a mode/sharing analysis and outperforms existing determinacy analyses in precision. <p> Although this solution is elegant theoretically, it is somewhat heavy for an abstract interpretation framework which should lead to efficient implementations. We adopted a solution which is less natural from a denotational standpoint but leads to effective analyses as demonstrated by the companion paper <ref> [4] </ref>. The solution is best presented in three steps. First, t 2 is replaced by a transformation t 3 : t 3 = [ t 2 : t 3 is extensive (i.e. t 3 for all ). <p> Other are simple "conversion" operations between the three different domains. The newer operations are CONC, AI-CUT, EXTGS and they are explained in detail since they contain the main originality of our framework. Reference <ref> [4] </ref> proposes an implementation of these operations on a particular abstract domain. Concatenation of Abstract Sequences: CONC (fi,C,B)=B 0 . Let pr be a procedure of the form c 1 ; : : : ; c n (n 1). <p> In fact, any meta predicate can be dealt with except assert and retract because they modify the underlying program. We do not describe the abstract treatment of these built-ins for space reasons but they are taken into account by our implementation (see <ref> [4] </ref>). 6 Abstract Semantics Sets of Abstract Tuples The abstract semantics of a program P is defined as a set of abstract tuples (fi; p; B) where p is a predicate symbol of arity n occurring in P , fi 2 AS , B 2 ASS and dom (fi) = dom <p> Second, the input and ouput sequences for l are combined in all possible way through a unique operation EXTGS. This simplification was shown to provide a good trade-off between accuracy and efficiency for the abstract domains considered in <ref> [4] </ref>. This trade-off could be reconsidered for more elaborate domains. The abstract transformation is defined in terms of one function and one transformation given in figure 1. T is an auxiliary function for the definition of the transformation TSAT. <p> T (fi; c; sat) executes a clause by extending the abstract substitution fi to all variables in c, executing the body and restricting the result to the variables in the head. T (fi; g; sat) executes the body of a clause by considering each 8 In <ref> [4] </ref>, operations EXTC and EXT-NOCUT are combined into a single operation EXTCS. 10 T SAT (sat) = f (fi; p; B) : (fi; p) 2 U D and B = T (fi; p; sat)g where pr is the procedure defining p T (fi; pr; sat) =SEQ (C) where C = T <p> The key idea is that a postfixpoint can be computed by a generalization of existing generic abstract interpretation algorithms [5, 21, 16, 17]. We focus on the generalizations and their justifications here. See <ref> [4] </ref> for a description of the algorithm. The key generalization in the algorithm is the use of a more general form of widening, called E-widening, when updating the set of abstract tuples with a new result. <p> Pre-consistency of the B 0 i follows from B 0 i B i and the pre-consistency of B i due to Lemma 2. An example of E-widening is defined in <ref> [4] </ref>. 12 8 Related Work Perhaps the closest related work is the work of File and Rossi [12], who describe an extension of the framework in [6], where an OLDT abstract tree is adorned with information about sure success or failure of the goals. <p> The second difference comes from the fact that our framework may deduce sure success even though the success branch may be unknown, while it is not clear how to obtain this result in their approach. Finally, our approach has been shown computationally tractable in <ref> [4] </ref>. At the time of writing, no experimental result have been reported on their approach. The work of Barbuti et al. [2] also aims at modelling Prolog control. <p> Our framework is usually not able to compute precise termination information (except for non recursive procedures) since this is inherently outside the scope of computational induction, the basis of the abstract interpretation approach followed here. However some applications such as cardinality analysis <ref> [4] </ref> could be improved by allowing the framework to use termination information from the outside as in [2]. Furthermore, our framework is able to provide precise information about non-termination. <p> This approach overcomes some of the limitations of existing frameworks. In particular, it broadens the applicability of the abstract interpretation approach to new analyses and improves the precision of existing analyses. Its practicability has been demonstrated in the companion paper <ref> [4] </ref>. 13
Reference: [5] <author> M. Bruynooghe. </author> <title> A practical framework for the abstract interpretation of logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 10(2) </volume> <pages> 91-124, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Abstract interpretation has been shown to be a valuable tool to obtain high-performance implementation of Prolog [24, 25]. Yet traditional abstract interpretation frameworks of Prolog (e.g. <ref> [5, 19, 20] </ref>) usually ignores many features of Prolog, such as the depth-first search strategy and the cut operation. <p> The concrete semantics is a fixpoint semantics defined on normalized programs <ref> [5] </ref>, i.e. clause heads are of the form p (x 1 ,: : : ,x n ) and bodies contain atoms of the form p (x i 1 ,: : : ,x i n ), x i = x j , x i 1 = f (x i 2 ,: : <p> Organization Each abstract operation is motivated and specified by a consistency condition. Many of these operations are identical or simple generalizations of operations described in [16, 17], which were themselves inspired by <ref> [5] </ref>. Other are simple "conversion" operations between the three different domains. The newer operations are CONC, AI-CUT, EXTGS and they are explained in detail since they contain the main originality of our framework. Reference [4] proposes an implementation of these operations on a particular abstract domain. <p> We have h; pi 7! S; ) 7 The Generic Abstract Interpretation Algorithm We now discuss how postfixpoints of the abstract transformation can be computed. The key idea is that a postfixpoint can be computed by a generalization of existing generic abstract interpretation algorithms <ref> [5, 21, 16, 17] </ref>. We focus on the generalizations and their justifications here. See [4] for a description of the algorithm. The key generalization in the algorithm is the use of a more general form of widening, called E-widening, when updating the set of abstract tuples with a new result.
Reference: [6] <author> P. Codognet and G. </author> <title> File. Computations, abstractions and constraints in logic programs. </title> <booktitle> In Proceedings of (ICCL'92), </booktitle> <address> Oakland, U.S.A., </address> <month> April </month> <year> 1992. </year>
Reference-contexts: An example of E-widening is defined in [4]. 12 8 Related Work Perhaps the closest related work is the work of File and Rossi [12], who describe an extension of the framework in <ref> [6] </ref>, where an OLDT abstract tree is adorned with information about sure success or failure of the goals. The information is then used in the cut operation to prune the OLDT-tree whenever the cut is reached in all corresponding executions.
Reference: [7] <author> A. Cortesi, B. Le Charlier, and P. Van Hentenryck. </author> <title> Type analysis of prolog using type graphs. </title> <booktitle> In Proceedings of (PLDI'94), </booktitle> <address> Orlando, Florida, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Abstract interpretation frameworks ignoring the search rule and the cut cannot infer that p (X) surely succeeds and hence that the cut is executed. In fact, they simply ignore the cut and would conclude when instantiated with a type domain (e.g. <ref> [14, 7] </ref>) that r produces an element from fa; b; c; dg. Using our framework, it is possible to design an analysing concluding that r/1 only produces the element a. We now describe informally the basic ideas on how to obtain such an analysis.
Reference: [8] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Proceedings of (POPL'77). </booktitle>
Reference-contexts: The main technical contribution of this paper is to show how to apply the traditional fixpoint approach <ref> [8] </ref> to the conceptual idea. <p> Abstract Interpretation Algorithm The last step of the analysis is the computation of the abstract semantics with extensions of existing algorithms such as GAIA [17] and PLAI [21]. 3 Technical Difficulties and Adopted Solutions The foundation of this work is the fixpoint approach to abstract interpretation <ref> [8] </ref>. Starting from a concrete semantics, we try to define a collecting semantics, an abstract semantics approximating the collecting semantics, and an algorithm to compute part of the abstract semantics.
Reference: [9] <author> S. Dawson, C.R. Ramakrishnan, I.V. Ramakrishnan, </author> <title> and R.C. Sekar. Extracting Determinacy in Logic Programs. </title> <booktitle> In ICLP-93, </booktitle> <address> Budapest (Hungary), </address> <month> June </month> <year> 1993. </year>
Reference-contexts: A typical example is determinacy analysis, where existing approaches either resort to special-purpose proofs (e.g. [22]) or their frameworks ignore certain aspects of the analysis, e.g. the cut and/or how to obtain the determinacy information from input/output patterns (e.g. <ref> [13, 9] </ref>). This paper proposes a step in overcoming these limitations. A novel abstract interpretation framework is introduced, which captures the depth-first seach strategy and the cut operation (only dynamic predicates such as assert/retract are ignored). <p> Consider the program p (a). q (b). Assume that we are interested in determinacy analysis of p/1 called with a ground argument. Examinations of the clauses in isolation will not determine the determinacy of the goal. This was recognized in several places (e.g. <ref> [13, 9] </ref>) which proposes to use input/output patterns to remedy the problem. However, these works focus on determining the patterns and cannot integrate all aspects of the analysis in a single abstract interpretation framework.
Reference: [10] <author> A. de Bruin and E. de Vink. </author> <title> Continuation Semantics for Prolog with cut. </title> <booktitle> In Proc. TAPSOFT'89, Lecture Notes in Computer Science, </booktitle> <pages> pages 178-192, </pages> <address> Berlin, 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference: [11] <author> S.K. Debray and P. Mishra. </author> <title> Denotational and operational semantics for Prolog. </title> (5(1)):61-91, 1988. 
Reference: [12] <author> G. File and S. Rossi. </author> <title> Static analysis of Prolog with cut. </title> <booktitle> In Proc. of LPAR'93. </booktitle>
Reference-contexts: Section 4 sketches the concrete semantics. Section 5 and 6 contain respectively the specification of the abstract operations and the abstract semantics. Section 7 discusses the abstract interpretation algorithm while section 8 presents related work, in particular the work of File and Rossi <ref> [12] </ref> and Barbuti et al. [2]. Section 9 concludes the paper. <p> Pre-consistency of the B 0 i follows from B 0 i B i and the pre-consistency of B i due to Lemma 2. An example of E-widening is defined in [4]. 12 8 Related Work Perhaps the closest related work is the work of File and Rossi <ref> [12] </ref>, who describe an extension of the framework in [6], where an OLDT abstract tree is adorned with information about sure success or failure of the goals. The information is then used in the cut operation to prune the OLDT-tree whenever the cut is reached in all corresponding executions.
Reference: [13] <author> R. Giacobazzi. </author> <title> Detecting Determinate Computations by Bottom-up Abstract Interpretation. </title> <booktitle> In ESOP'92, </booktitle> <pages> pages 167-181, </pages> <year> 1992. </year>
Reference-contexts: A typical example is determinacy analysis, where existing approaches either resort to special-purpose proofs (e.g. [22]) or their frameworks ignore certain aspects of the analysis, e.g. the cut and/or how to obtain the determinacy information from input/output patterns (e.g. <ref> [13, 9] </ref>). This paper proposes a step in overcoming these limitations. A novel abstract interpretation framework is introduced, which captures the depth-first seach strategy and the cut operation (only dynamic predicates such as assert/retract are ignored). <p> Consider the program p (a). q (b). Assume that we are interested in determinacy analysis of p/1 called with a ground argument. Examinations of the clauses in isolation will not determine the determinacy of the goal. This was recognized in several places (e.g. <ref> [13, 9] </ref>) which proposes to use input/output patterns to remedy the problem. However, these works focus on determining the patterns and cannot integrate all aspects of the analysis in a single abstract interpretation framework.
Reference: [14] <author> G. Janssens and M. Bruynooghe. </author> <title> Deriving descriptions of possible values of program variables by means of abstract interpretation. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(4), </volume> <year> 1992. </year>
Reference-contexts: Abstract interpretation frameworks ignoring the search rule and the cut cannot infer that p (X) surely succeeds and hence that the cut is executed. In fact, they simply ignore the cut and would conclude when instantiated with a type domain (e.g. <ref> [14, 7] </ref>) that r produces an element from fa; b; c; dg. Using our framework, it is possible to design an analysing concluding that r/1 only produces the element a. We now describe informally the basic ideas on how to obtain such an analysis.
Reference: [15] <author> N.D. Jones and A. Mycroft. </author> <title> Stepwise development of operational and denotational semantics for Prolog. </title> <editor> In Sten -Ake Tarnlund, editor, </editor> <booktitle> Proceedings of ICLP'84, </booktitle> <pages> pages 281-288. </pages>
Reference: [16] <author> B. Le Charlier, K. Musumbu, and P. Van Hentenryck. </author> <title> A generic abstract interpretation algorithm and its complexity analysis. </title> <booktitle> In Proceedings of (ICLP'91). </booktitle>
Reference-contexts: Organization Each abstract operation is motivated and specified by a consistency condition. Many of these operations are identical or simple generalizations of operations described in <ref> [16, 17] </ref>, which were themselves inspired by [5]. Other are simple "conversion" operations between the three different domains. The newer operations are CONC, AI-CUT, EXTGS and they are explained in detail since they contain the main originality of our framework. <p> This operation is similar to operation AI-VAR of <ref> [16, 17] </ref> but returns an abstract sequence instead of an abstract substitution. <p> The first and the third are the same as in our previous papers <ref> [16, 17] </ref> and we provide their specifications without additional explanations. The second one is a simple generalization of an existing one to sequences. The fourth one is a more complex generalization and we explain it in detail. Extension at Clause entry: EXTC (c; fi) = fi 0 . <p> We denote SAT T the set of all those sets. Abstract Transformation This transformation is in the same spirit as the transformation proposed in <ref> [16] </ref>. The main difference is that (output) abstract substitutions are replaced by abstract sequences. Abstract operations are modified accordingly. For example, the semantics in [16] uses an operation UNION to collect clause results. This operation is now replaced by operation CONC. <p> We denote SAT T the set of all those sets. Abstract Transformation This transformation is in the same spirit as the transformation proposed in <ref> [16] </ref>. The main difference is that (output) abstract substitutions are replaced by abstract sequences. Abstract operations are modified accordingly. For example, the semantics in [16] uses an operation UNION to collect clause results. This operation is now replaced by operation CONC. Two major simplifications with respect to the concrete semantics have been however introduced to handle literals more simply. <p> We have h; pi 7! S; ) 7 The Generic Abstract Interpretation Algorithm We now discuss how postfixpoints of the abstract transformation can be computed. The key idea is that a postfixpoint can be computed by a generalization of existing generic abstract interpretation algorithms <ref> [5, 21, 16, 17] </ref>. We focus on the generalizations and their justifications here. See [4] for a description of the algorithm. The key generalization in the algorithm is the use of a more general form of widening, called E-widening, when updating the set of abstract tuples with a new result.
Reference: [17] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> Experimental Evaluation of a Generic Abstract Interpretation Algorithm for Prolog. </title> <journal> (TOPLAS), </journal> <month> January </month> <year> 1994. </year>
Reference-contexts: The new domain is likely to be computationally reasonable, since they are few situations where a large number of abstract substitutions will be maintained. Abstract Interpretation Algorithm The last step of the analysis is the computation of the abstract semantics with extensions of existing algorithms such as GAIA <ref> [17] </ref> and PLAI [21]. 3 Technical Difficulties and Adopted Solutions The foundation of this work is the fixpoint approach to abstract interpretation [8]. <p> To simplify the traditional problems with renaming, we use two sets of variables and substitutions <ref> [17] </ref>. (Program) substitutions (denoted by ) are of the form fx 1 =t 1 ; : : : ; x n =t n g, 5 where the t i are terms and the x i are (so-called) program variables (parameters). We assume another infinite (disjoint) set of (so-called) standard variables. <p> Organization Each abstract operation is motivated and specified by a consistency condition. Many of these operations are identical or simple generalizations of operations described in <ref> [16, 17] </ref>, which were themselves inspired by [5]. Other are simple "conversion" operations between the three different domains. The newer operations are CONC, AI-CUT, EXTGS and they are explained in detail since they contain the main originality of our framework. <p> This operation is similar to operation AI-VAR of <ref> [16, 17] </ref> but returns an abstract sequence instead of an abstract substitution. <p> The first and the third are the same as in our previous papers <ref> [16, 17] </ref> and we provide their specifications without additional explanations. The second one is a simple generalization of an existing one to sequences. The fourth one is a more complex generalization and we explain it in detail. Extension at Clause entry: EXTC (c; fi) = fi 0 . <p> We have h; pi 7! S; ) 7 The Generic Abstract Interpretation Algorithm We now discuss how postfixpoints of the abstract transformation can be computed. The key idea is that a postfixpoint can be computed by a generalization of existing generic abstract interpretation algorithms <ref> [5, 21, 16, 17] </ref>. We focus on the generalizations and their justifications here. See [4] for a description of the algorithm. The key generalization in the algorithm is the use of a more general form of widening, called E-widening, when updating the set of abstract tuples with a new result.
Reference: [18] <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming. Springer Series: </title> <journal> Symbolic Computation-Artificial Intelligence. </journal> <note> Springer-Velag, second, extended edition, </note> <year> 1987. </year>
Reference-contexts: The novelty is the notion of substitution sequences which models the sequence of computed answer substitutions (e.g. <ref> [18] </ref>) produced by the execution of p (x 1 ; : : : ; x n ). The resulting sequence can have different shapes. If the execution terminates (producing m computed answer substitutions), S is a finite sequence &lt; 1 ; : : : ; m &gt;.
Reference: [19] <author> K. Marriott and H. Stndergaard. </author> <title> Semantics-based dataflow analysis of logic programs. </title> <editor> In G. Ritter, editor, </editor> <booktitle> Information Processing'89, </booktitle> <pages> pages 601-606, </pages> <address> San Fransisco, California, </address> <year> 1989. </year>
Reference-contexts: 1 Introduction Abstract interpretation has been shown to be a valuable tool to obtain high-performance implementation of Prolog [24, 25]. Yet traditional abstract interpretation frameworks of Prolog (e.g. <ref> [5, 19, 20] </ref>) usually ignores many features of Prolog, such as the depth-first search strategy and the cut operation.
Reference: [20] <author> C.S. Mellish. </author> <title> Abstract interpretation of Prolog programs. In Abstract Interpretation of Declarative Languages, </title> <booktitle> chapter 8, </booktitle> <pages> pages 181-198. </pages> <publisher> Ellis Horwood Limited, </publisher> <year> 1987. </year>
Reference-contexts: 1 Introduction Abstract interpretation has been shown to be a valuable tool to obtain high-performance implementation of Prolog [24, 25]. Yet traditional abstract interpretation frameworks of Prolog (e.g. <ref> [5, 19, 20] </ref>) usually ignores many features of Prolog, such as the depth-first search strategy and the cut operation.
Reference: [21] <author> K. Muthukumar and M. Hermenegildo. </author> <title> Compile-Time Derivation of Variable Dependency Using Abstract Interpretation. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(2-3):315-347, </volume> <month> August </month> <year> 1992. </year>
Reference-contexts: Abstract Interpretation Algorithm The last step of the analysis is the computation of the abstract semantics with extensions of existing algorithms such as GAIA [17] and PLAI <ref> [21] </ref>. 3 Technical Difficulties and Adopted Solutions The foundation of this work is the fixpoint approach to abstract interpretation [8]. Starting from a concrete semantics, we try to define a collecting semantics, an abstract semantics approximating the collecting semantics, and an algorithm to compute part of the abstract semantics. <p> We have h; pi 7! S; ) 7 The Generic Abstract Interpretation Algorithm We now discuss how postfixpoints of the abstract transformation can be computed. The key idea is that a postfixpoint can be computed by a generalization of existing generic abstract interpretation algorithms <ref> [5, 21, 16, 17] </ref>. We focus on the generalizations and their justifications here. See [4] for a description of the algorithm. The key generalization in the algorithm is the use of a more general form of widening, called E-widening, when updating the set of abstract tuples with a new result.
Reference: [22] <author> D. Sahlin. </author> <title> Determinacy Analysis for Full Prolog. </title> <booktitle> In PEPM'91, </booktitle> <year> 1991. </year>
Reference-contexts: The existing frameworks are not expressive enough to capture certain analyses in their entirety. A typical example is determinacy analysis, where existing approaches either resort to special-purpose proofs (e.g. <ref> [22] </ref>) or their frameworks ignore certain aspects of the analysis, e.g. the cut and/or how to obtain the determinacy information from input/output patterns (e.g. [13, 9]). This paper proposes a step in overcoming these limitations.
Reference: [23] <author> D.A. Schmidt. </author> <title> Denotational Semantics. </title> <publisher> Allyn and Bacon, Inc., </publisher> <year> 1988. </year>
Reference-contexts: This new problem could possibly be solved by using another ordering on (some subset of) -(PSS). This ordering should in a way combine the ordering on PSS and inclusion in -(PSS). The traditional solution to this problem in denotational semantics consists in using a power domain construction (e.g. <ref> [23] </ref>). Although this solution is elegant theoretically, it is somewhat heavy for an abstract interpretation framework which should lead to efficient implementations. We adopted a solution which is less natural from a denotational standpoint but leads to effective analyses as demonstrated by the companion paper [4].
Reference: [24] <author> A. Taylor. </author> <title> LIPS on MIPS: Results from a Prolog Compiler for a RISC. </title> <booktitle> In Proceedings of (ICLP'90), </booktitle> <address> Jerusalem, Israel, June 1990. </address> <publisher> MIT Press. </publisher>
Reference-contexts: 1 Introduction Abstract interpretation has been shown to be a valuable tool to obtain high-performance implementation of Prolog <ref> [24, 25] </ref>. Yet traditional abstract interpretation frameworks of Prolog (e.g. [5, 19, 20]) usually ignores many features of Prolog, such as the depth-first search strategy and the cut operation.
Reference: [25] <author> P. Van Roy and A. Despain. </author> <title> High-Performance Computing with the Aquarius Compiler. </title> <journal> IEEE Computer, </journal> <volume> 25(1), </volume> <month> January </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Abstract interpretation has been shown to be a valuable tool to obtain high-performance implementation of Prolog <ref> [24, 25] </ref>. Yet traditional abstract interpretation frameworks of Prolog (e.g. [5, 19, 20]) usually ignores many features of Prolog, such as the depth-first search strategy and the cut operation.
References-found: 25

