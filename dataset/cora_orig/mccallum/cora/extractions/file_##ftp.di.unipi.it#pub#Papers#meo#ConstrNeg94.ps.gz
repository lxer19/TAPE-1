URL: file://ftp.di.unipi.it/pub/Papers/meo/ConstrNeg94.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Email: e-mail: paola@csr.unibo.it flevifran, levi, meog@di.unipi.it  
Title: Compilative Constructive Negation in Constraint Logic Programs  
Author: Paola Bruscoli, Francesca Levi, Giorgio Levi, Maria Chiara Meo 
Note: P where P is the Fitting's operator [12].  
Address: C.so Italia, 40 56125 Pisa, Italy  
Affiliation: Dipartimento di Informatica, Universita di Pisa,  
Abstract: In this paper we define a new compilative version of constructive negation (intensional negation) in CLP and we prove its (non-ground) correctness and completeness wrt the 3-valued completion. We show that intensional negation is essentially equivalent to constructive negation and that it is indeed more efficient, as one would expect from the fact that it is a compilative technique, with the transformation and the associated normalization process being performed once and for all on the source program. We define several formal non-ground semantics, based either on the derivation rule or on the least fixpoint of an immediate consequence operator. All these semantics are proved to correctly model the observable behavior, from the viewpoint of answer constraints. We give some equivalence theorems and we show that all our denotations are the non-ground representation of a single partial interpretation, which is 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> K. R. Apt. </author> <title> Introduction to Logic Programming. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, </booktitle> <pages> pages 495-574. </pages> <publisher> Elsevier, Amsterdam and The MIT Press, </publisher> <address> Cambridge, </address> <year> 1990. </year>
Reference-contexts: The reference fixpoint semantics is usually based on Fitting's operator [12]. Unfortunately, the nice equivalence and completeness results proved for the semantics of positive logic programs <ref> [29, 2, 19, 1] </ref> are not valid in the case of normal programs. In particular, we need to impose strong conditions on programs and goals, in order to deal with various incompleteness problems (e.g. floundering, inconsistency of the completion, the combination of tertium non datur and non-termination).
Reference: 2. <author> K. R. Apt and M. H. van Emden. </author> <title> Contributions to the theory of logic programming. </title> <journal> Journal of the ACM, </journal> <volume> 29(3) </volume> <pages> 841-862, </pages> <year> 1982. </year>
Reference-contexts: The reference fixpoint semantics is usually based on Fitting's operator [12]. Unfortunately, the nice equivalence and completeness results proved for the semantics of positive logic programs <ref> [29, 2, 19, 1] </ref> are not valid in the case of normal programs. In particular, we need to impose strong conditions on programs and goals, in order to deal with various incompleteness problems (e.g. floundering, inconsistency of the completion, the combination of tertium non datur and non-termination).
Reference: 3. <author> R. Barbuti, P. Mancarella, D. Pedreschi, and F. Turini. </author> <title> Intensional Negation of Logic Programs: Examples and Implementation Techniques. </title> <editor> In H. Ehrig, R. Kowalski, G. Levi, and U. Montanari, editors, </editor> <booktitle> TAPSOFT '87, volume 250 of Lecture Notes in Computer Science, </booktitle> <pages> pages 96-110. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year>
Reference-contexts: The problem of handling "non-ground" literals was tackled by various extensions of Negation As Failure, called constructive negation. Examples are intensional negation <ref> [3, 4] </ref>, Chan's constructive negation [7, 8], fail substitutions [20] and fail answers [11, 10]. The idea of intensional negation, originally sketched in [25] and then formalized for positive logic programs in [3, 4], is the following. <p> Examples are intensional negation <ref> [3, 4] </ref>, Chan's constructive negation [7, 8], fail substitutions [20] and fail answers [11, 10]. The idea of intensional negation, originally sketched in [25] and then formalized for positive logic programs in [3, 4], is the following. Given a normal program P , we derive a new program P 0 , which contains clauses which allow us to compute the answers to negative queries. Example 1. Let P be the program feven (0) ; even (s (s (X))) even (X)g.
Reference: 4. <author> R. Barbuti, P. Mancarella, D. Pedreschi, and F. Turini. </author> <title> A transformational approach to negation in logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 8 </volume> <pages> 201-228, </pages> <year> 1990. </year>
Reference-contexts: The problem of handling "non-ground" literals was tackled by various extensions of Negation As Failure, called constructive negation. Examples are intensional negation <ref> [3, 4] </ref>, Chan's constructive negation [7, 8], fail substitutions [20] and fail answers [11, 10]. The idea of intensional negation, originally sketched in [25] and then formalized for positive logic programs in [3, 4], is the following. <p> Examples are intensional negation <ref> [3, 4] </ref>, Chan's constructive negation [7, 8], fail substitutions [20] and fail answers [11, 10]. The idea of intensional negation, originally sketched in [25] and then formalized for positive logic programs in [3, 4], is the following. Given a normal program P , we derive a new program P 0 , which contains clauses which allow us to compute the answers to negative queries. Example 1. Let P be the program feven (0) ; even (s (s (X))) even (X)g.
Reference: 5. <author> A. Bottoni and G. Levi. </author> <title> The inverse of Fitting's functional. </title> <editor> In G. Gottlob, A. Leitsch, and D. Mundici, editors, </editor> <booktitle> Proc. Third Kurt Goedel Colloquium, Computational Logic and Proof Theory, KGC'93, volume 713 of Lecture Notes in Computer Science, </booktitle> <pages> pages 132-143. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: A similar method with a different proof of completeness is given in <ref> [5] </ref>. Stuckey's constructive negation can be shown to be an implementation of the above operational semantics.
Reference: 6. <author> P. Bruscoli, F. Levi, G. Levi, and M. C. Meo. </author> <title> Intensional negation in Constraint Logic Programs. </title> <type> Technical Report 11/93, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1993. </year>
Reference-contexts: Moving to CLP allows us to get more generality and to use the only existing formalization of constructive negation [27] for which there exists a completeness theorem. All the proofs of the results reported in the paper can be found in <ref> [6] </ref>. 2 The language and its semantic domains We will first recall the basic CLP concepts as defined in [16]. <p> are distinct variablesg; O CN (P ) = fc2p ( X) j true2:p ( X) CN ! P c2 and X are distinct variablesg: Results similar to those proved for intensional negation on the observational equivalence and on the correctness wrt answer constraints are valid for constructive negation as well <ref> [6] </ref>. Example 5.
Reference: 7. <author> D. Chan. </author> <title> Constructive Negation Based on the Completed Database. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 111-125, </pages> <address> Cambridge, Mass., 1988. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: The problem of handling "non-ground" literals was tackled by various extensions of Negation As Failure, called constructive negation. Examples are intensional negation [3, 4], Chan's constructive negation <ref> [7, 8] </ref>, fail substitutions [20] and fail answers [11, 10]. The idea of intensional negation, originally sketched in [25] and then formalized for positive logic programs in [3, 4], is the following. <p> The range of applicability of intensional negation was increased by defining an extended derivation rule for positive logic programs with universal quantification parametric w.r.t. the DCA [18]. Chan's constructive negation, in its original formulation <ref> [7] </ref> can be described as follows. Let :A be a (possibly non-ground) literal in the normal program P .
Reference: 8. <author> D. Chan. </author> <title> An Extension of Constructive Negation and its Application in Coroutin-ing. </title> <editor> In E. Lusk and R. Overbeek, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'89, </booktitle> <pages> pages 477-493, </pages> <address> Cambridge, Mass., 1989. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: The problem of handling "non-ground" literals was tackled by various extensions of Negation As Failure, called constructive negation. Examples are intensional negation [3, 4], Chan's constructive negation <ref> [7, 8] </ref>, fail substitutions [20] and fail answers [11, 10]. The idea of intensional negation, originally sketched in [25] and then formalized for positive logic programs in [3, 4], is the following. <p> The application of the above inference rule is undefined when the SLDtree is infinite. The mechanism of negative literals evaluation, inherited from Negation As Failure, is not "incremental", since it requires the construction of a full SLD-tree. This problem was solved in <ref> [8] </ref>, by considering a finite part of the SLD-tree, defined by a frontier, instead of the complete SLDtree. Using the Constraint Logic Programming (CLP ) notation [16, 15], each node of the frontier is a goal e i 2B i containing both constraints (equalities) and literals.
Reference: 9. <author> K. L. Clark. </author> <title> Negation as Failure. </title> <editor> In H. Gallaire and J. Minker, editors, </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: 1 Introduction The most popular semantics for normal logic programs is based on SLDN F - resolution (SLD-resolution with Negation As Failure) as operational semantics and on the program completion as declarative semantics <ref> [9, 19] </ref>. The reference fixpoint semantics is usually based on Fitting's operator [12]. Unfortunately, the nice equivalence and completeness results proved for the semantics of positive logic programs [29, 2, 19, 1] are not valid in the case of normal programs. <p> We do not make any assumption on . Rather we require that the structure &lt;( C ; ) be a model of the standard theory CET , given in <ref> [9] </ref> to axiomatize unification. Moreover if the set of function symbols is finite we assume the (weak) DCA be added to CET , thus achieving the completeness of the theory CET in the case of a language with finite set of function symbols.
Reference: 10. <author> W. Drabent. </author> <title> SLS-resolution without floundering. </title> <editor> In L. M. Pereira and A. Nerode, editors, </editor> <booktitle> Logic Programming and Non-monotonic Reasoning, Proceedings of the Second International Workshop, </booktitle> <pages> pages 82-98. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1993. </year>
Reference-contexts: The problem of handling "non-ground" literals was tackled by various extensions of Negation As Failure, called constructive negation. Examples are intensional negation [3, 4], Chan's constructive negation [7, 8], fail substitutions [20] and fail answers <ref> [11, 10] </ref>. The idea of intensional negation, originally sketched in [25] and then formalized for positive logic programs in [3, 4], is the following. <p> The optimization is concerned with the management of disjunctions, which are handled by using essentially the SLDtree structure of positive Horn clauses. The resulting theory allows us to identify commonalities and differences between the various constructive negation techniques. It is worth noting that there exists one example <ref> [11, 10] </ref> of constructive negation technique, which is not based on the program completion and is not therefore easily comparable to our technique. The second contribution of the paper is related to the formal semantics. None of the existing semantics for constructive negation correctly models answer constraints.
Reference: 11. <author> W. Drabent. </author> <title> What is Failure? An Approach to Constructive Negation. </title> <journal> Acta Informatica, </journal> <note> 1993. To appear. </note>
Reference-contexts: The problem of handling "non-ground" literals was tackled by various extensions of Negation As Failure, called constructive negation. Examples are intensional negation [3, 4], Chan's constructive negation [7, 8], fail substitutions [20] and fail answers <ref> [11, 10] </ref>. The idea of intensional negation, originally sketched in [25] and then formalized for positive logic programs in [3, 4], is the following. <p> The optimization is concerned with the management of disjunctions, which are handled by using essentially the SLDtree structure of positive Horn clauses. The resulting theory allows us to identify commonalities and differences between the various constructive negation techniques. It is worth noting that there exists one example <ref> [11, 10] </ref> of constructive negation technique, which is not based on the program completion and is not therefore easily comparable to our technique. The second contribution of the paper is related to the formal semantics. None of the existing semantics for constructive negation correctly models answer constraints.
Reference: 12. <author> M. </author> <title> Fitting. A Kripke-Kleene semantics for logic programs. </title> <journal> Journal of Logic Pro--gramming, </journal> <volume> 2 </volume> <pages> 295-312, </pages> <year> 1985. </year>
Reference-contexts: 1 Introduction The most popular semantics for normal logic programs is based on SLDN F - resolution (SLD-resolution with Negation As Failure) as operational semantics and on the program completion as declarative semantics [9, 19]. The reference fixpoint semantics is usually based on Fitting's operator <ref> [12] </ref>. Unfortunately, the nice equivalence and completeness results proved for the semantics of positive logic programs [29, 2, 19, 1] are not valid in the case of normal programs. <p> The 3-valued completion is also strongly related to the Fitting's operator P <ref> [12] </ref>, which acts upon 3-valued interpretations. The minimal 3-valued model M P of Comp (P ) is its least fixpoint P " ff. <p> Theorem 29. Let P be a normal program. [F 8 (P )] = [O 8 (P )]. 5 Correctness and completeness In this section we show that [O 8 (P )] = [F 8 (P )] = P " !, where P is Fitting's operator described in <ref> [12] </ref> and extended to constraint logic programs in [13]. The proof is based on the analysis of the relation between [F 8 (P )] and P . In such a way a completeness and correctness result is inherited by intensional negation.
Reference: 13. <author> M. Fitting and M. Ben-Jacob. </author> <title> Stratified and Three-valued Logic Programming Semantics. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 1054-1069. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: a normal program. [F 8 (P )] = [O 8 (P )]. 5 Correctness and completeness In this section we show that [O 8 (P )] = [F 8 (P )] = P " !, where P is Fitting's operator described in [12] and extended to constraint logic programs in <ref> [13] </ref>. The proof is based on the analysis of the relation between [F 8 (P )] and P . In such a way a completeness and correctness result is inherited by intensional negation.
Reference: 14. <author> M. Gabbrielli and G. Levi. </author> <title> Modeling Answer Constraints in Constraint Logic Programs. </title> <editor> In K. Furukawa, editor, </editor> <booktitle> Proc. Eighth Int'l Conf. on Logic Programming, pages 238- 252. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference-contexts: The structures considered in CLP are the "solution compact" ones as defined in [16, 15]. In the following we will denote by P fl the completed definitions of the predicates in P . 3 Partial -interpretations We extend the notion of -interpretation as introduced in <ref> [14] </ref> in order to provide three-valued models of the completion of a CLP program.
Reference: 15. <author> J. Jaffar and J. L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proc. Fourteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 111-119. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference-contexts: This problem was solved in [8], by considering a finite part of the SLD-tree, defined by a frontier, instead of the complete SLDtree. Using the Constraint Logic Programming (CLP ) notation <ref> [16, 15] </ref>, each node of the frontier is a goal e i 2B i containing both constraints (equalities) and literals. The literal :A is now rewritten as the result of the normalization of the formula :(e 1 2B 1 _ : : :_ e n 2B n ). <p> A constraint c is &lt;-satisfiable iff there exists a &lt;-valuation such that th (&lt;) j= c. is called an &lt;-solution of c. A constrained atom c2p ( X ) is &lt;-satisfiable iff c is &lt;-satisfiable. The structures considered in CLP are the "solution compact" ones as defined in <ref> [16, 15] </ref>. In the following we will denote by P fl the completed definitions of the predicates in P . 3 Partial -interpretations We extend the notion of -interpretation as introduced in [14] in order to provide three-valued models of the completion of a CLP program.
Reference: 16. <author> J. Jaffar and J. L. Lassez. </author> <title> Constraint Logic Programming. </title> <type> Technical report, </type> <institution> Department of Computer Science, Monash University, </institution> <month> June </month> <year> 1986. </year>
Reference-contexts: This problem was solved in [8], by considering a finite part of the SLD-tree, defined by a frontier, instead of the complete SLDtree. Using the Constraint Logic Programming (CLP ) notation <ref> [16, 15] </ref>, each node of the frontier is a goal e i 2B i containing both constraints (equalities) and literals. The literal :A is now rewritten as the result of the normalization of the formula :(e 1 2B 1 _ : : :_ e n 2B n ). <p> All the proofs of the results reported in the paper can be found in [6]. 2 The language and its semantic domains We will first recall the basic CLP concepts as defined in <ref> [16] </ref>. <p> If t is a syntactic object, F V (t) is the set of variables which are not explicitly quantified in t. A sentence is a well formed formula with no free variables. Definition 1. (CLP normal programs) <ref> [16] </ref> Let = C [ B and C " B = ;. <p> A constraint c is &lt;-satisfiable iff there exists a &lt;-valuation such that th (&lt;) j= c. is called an &lt;-solution of c. A constrained atom c2p ( X ) is &lt;-satisfiable iff c is &lt;-satisfiable. The structures considered in CLP are the "solution compact" ones as defined in <ref> [16, 15] </ref>. In the following we will denote by P fl the completed definitions of the predicates in P . 3 Partial -interpretations We extend the notion of -interpretation as introduced in [14] in order to provide three-valued models of the completion of a CLP program. <p> Moreover the symbols 2 and "," will be interpreted as ^. All the following definitions are related to a given &lt; (and thus to a given (; )). Definition 3. <ref> [16] </ref> The set of "domain instances" [c2p ( X)] of a constrained atom c2p ( X) is defined as [c2p ( X)] = fp ( X) j is an &lt;-solution of cg: Let S be a set of constrained atoms. Then [S] = S Definition 4.
Reference: 17. <author> K. Kunen. </author> <title> Negation in logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 4 </volume> <pages> 289-308, </pages> <year> 1987. </year>
Reference-contexts: The 3-valued completion is also strongly related to the Fitting's operator P [12], which acts upon 3-valued interpretations. The minimal 3-valued model M P of Comp (P ) is its least fixpoint P " ff. Kunen's semantics <ref> [17] </ref> is also defined in terms of P , namely fL j P " n j= 3 L for a finite ng = fL j Comp (P ) j= 3 Lg. <p> First of all, a partial interpretation, as defined in <ref> [17] </ref> is any total function F from the set of all ground atoms into ft; f ; ug, where ft; f ; ug are interpreted as true, false and undefined. <p> Proposition 31. Let P be a normal program. 8n 0, [T 8 P " n] = P " n and Using our terminology, theorem 6 of [26] (which is a generalization of theorem 6.3 in <ref> [17] </ref> for languages other than those with infinitely many function symbols of all arities) can be stated for CLP as follows. The notation th (&lt;) ^ P fl j= 3 S shows that the sentence S is a three-valued logical consequence of the theory th (&lt;) ^ P fl .
Reference: 18. <editor> F. Levi, P. Mancarella, and D. Pedreschi. Negazione Costruttiva e Quantificazione Universale in Programmazione Logica con Vincoli. In S. Costantini, editor, </editor> <booktitle> Proc. Seventh Italian Conference on Logic Programming, </booktitle> <pages> pages 273-287, </pages> <year> 1992. </year>
Reference-contexts: The range of applicability of intensional negation was increased by defining an extended derivation rule for positive logic programs with universal quantification parametric w.r.t. the DCA <ref> [18] </ref>. Chan's constructive negation, in its original formulation [7] can be described as follows. Let :A be a (possibly non-ground) literal in the normal program P .
Reference: 19. <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year> <note> Second edition. </note>
Reference-contexts: 1 Introduction The most popular semantics for normal logic programs is based on SLDN F - resolution (SLD-resolution with Negation As Failure) as operational semantics and on the program completion as declarative semantics <ref> [9, 19] </ref>. The reference fixpoint semantics is usually based on Fitting's operator [12]. Unfortunately, the nice equivalence and completeness results proved for the semantics of positive logic programs [29, 2, 19, 1] are not valid in the case of normal programs. <p> The reference fixpoint semantics is usually based on Fitting's operator [12]. Unfortunately, the nice equivalence and completeness results proved for the semantics of positive logic programs <ref> [29, 2, 19, 1] </ref> are not valid in the case of normal programs. In particular, we need to impose strong conditions on programs and goals, in order to deal with various incompleteness problems (e.g. floundering, inconsistency of the completion, the combination of tertium non datur and non-termination).
Reference: 20. <author> J. Maluszynski and T. Naslund. </author> <title> Fail Substitutions for Negation as Failure. </title> <editor> In E. Lusk and R. Overbeek, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'89, </booktitle> <pages> pages 461-476. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: The problem of handling "non-ground" literals was tackled by various extensions of Negation As Failure, called constructive negation. Examples are intensional negation [3, 4], Chan's constructive negation [7, 8], fail substitutions <ref> [20] </ref> and fail answers [11, 10]. The idea of intensional negation, originally sketched in [25] and then formalized for positive logic programs in [3, 4], is the following. <p> First, even if we start from normal logic programs, con-structive negation forces the introduction of (universally quantified) inequalities. One can stay within the logic programming setting based on substitutions only by assuming the DCA. This is, for example, the solution chosen in <ref> [20] </ref>. The most natural solution is then choosing the instance of CLP , where constraints are equalities and inequalities on the Herbrand domain. Moving to CLP allows us to get more generality and to use the only existing formalization of constructive negation [27] for which there exists a completeness theorem.
Reference: 21. <author> P. Mancarella, S. Martini, and D. Pedreschi. </author> <title> Complete Logic Programs with Domain Closure Axiom. </title> <journal> Journal of Logic Programming, </journal> <volume> 5(3) </volume> <pages> 263-276, </pages> <year> 1988. </year>
Reference-contexts: Moreover if the set of function symbols is finite we assume the (weak) DCA be added to CET , thus achieving the completeness of the theory CET in the case of a language with finite set of function symbols. Informally the DCA <ref> [21] </ref> ensures that in the interpretation domain of any model of the theory every object is a value of a non-variable term (under some variable valuation). By th (&lt;) we denote the set of all the ( C ; )- constraints true in &lt;.
Reference: 22. <author> P. Mancarella, D. Pedreschi, M. Rondinelli, and M. Tagliatti. </author> <title> Algebraic Properties of a Class of Logic Programs. </title> <editor> In S. K. Debray and M. Hermenegildo, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'90, </booktitle> <pages> pages 23-39. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference-contexts: The standard semantics of positive logic programs is then applicable to the result of the intensional negation transformation for restricted classes of normal programs only <ref> [22] </ref>. The range of applicability of intensional negation was increased by defining an extended derivation rule for positive logic programs with universal quantification parametric w.r.t. the DCA [18]. Chan's constructive negation, in its original formulation [7] can be described as follows.
Reference: 23. <author> V. Sassone. </author> <title> A Note on Logic Programming Fixpoint Semantics. </title> <type> Technical report, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1992. </year>
Reference-contexts: Moreover CLP provides a common framework in which to compare the intensional negation and constructive negation as defined by Stuckey. The generation of a positive program able to compute the logical consequence of P fl is achieved also in <ref> [23] </ref>. However, even in this case, the resulting program is a first order program (without negation) whereas our aim is to stick as much as possible to positive clauses.
Reference: 24. <author> T. Sato and F. Motoyoshi. </author> <title> A Complete Top-down Interpreter for First Order Programs. </title> <editor> In V. Saraswat and K.Ueda, editors, </editor> <booktitle> Proc. 1991 Int'l Symposium on Logic Programming, </booktitle> <pages> pages 35-53, </pages> <year> 1991. </year>
Reference-contexts: The above technique was then extended to CLP [27, 28] and a completeness result was proved. The problem of handling negation constructively has an alternative solution in the idea of using explicitely the formulas in the completion (first order program) as rewrite rules, with a suitable constraint extraction procedure. <ref> [24] </ref> has shown a top-down interpreter which is sound and complete w.r.t. three-valued logical consequences semantics. A similar method with a different proof of completeness is given in [5]. Stuckey's constructive negation can be shown to be an implementation of the above operational semantics.
Reference: 25. <author> T. Sato and H. Tamaki. </author> <title> Transformational Logic Programs Synthesis. </title> <booktitle> In Proceedings of the International Conference of Fifth Generation Computer Systems, </booktitle> <year> 1984, </year> <pages> pages 195-201, </pages> <year> 1984. </year>
Reference-contexts: The problem of handling "non-ground" literals was tackled by various extensions of Negation As Failure, called constructive negation. Examples are intensional negation [3, 4], Chan's constructive negation [7, 8], fail substitutions [20] and fail answers [11, 10]. The idea of intensional negation, originally sketched in <ref> [25] </ref> and then formalized for positive logic programs in [3, 4], is the following. Given a normal program P , we derive a new program P 0 , which contains clauses which allow us to compute the answers to negative queries. Example 1.
Reference: 26. <author> J. C. Shepherdson. </author> <title> Language and equality theory in logic programming. </title> <type> Technical Report PM-91-02, </type> <institution> School of Mathematics, University of Bristol, </institution> <year> 1991. </year>
Reference-contexts: The equivalence holds since for each finite n, T 8 P " n is a finite partial -interpretation. Proposition 31. Let P be a normal program. 8n 0, [T 8 P " n] = P " n and Using our terminology, theorem 6 of <ref> [26] </ref> (which is a generalization of theorem 6.3 in [17] for languages other than those with infinitely many function symbols of all arities) can be stated for CLP as follows.
Reference: 27. <author> P. J. Stuckey. </author> <title> Constructive Negation for Constraint Logic Programming. </title> <booktitle> In Proc. Sixth IEEE Symp. on Logic In Computer Science, </booktitle> <pages> pages 328-339. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: The literal :A is now rewritten as the result of the normalization of the formula :(e 1 2B 1 _ : : :_ e n 2B n ). The result of the computation is independent from the choice of the frontier. The above technique was then extended to CLP <ref> [27, 28] </ref> and a completeness result was proved. <p> The most natural solution is then choosing the instance of CLP , where constraints are equalities and inequalities on the Herbrand domain. Moving to CLP allows us to get more generality and to use the only existing formalization of constructive negation <ref> [27] </ref> for which there exists a completeness theorem. All the proofs of the results reported in the paper can be found in [6]. 2 The language and its semantic domains We will first recall the basic CLP concepts as defined in [16]. <p> The extension of a partial interpretation to ground constraints and to ground formulas is defined in <ref> [27] </ref>, by the following rules. Let c be a ground constraint. c is true in F iff th (&lt;) j= c and c is false in F iff th (&lt;) j= :c. <p> Therefore we need a notion of complex goal, similar to the one introduced for constructive negation <ref> [27] </ref>, and the derivation rule must be defined for complex goals. In addition to universally quantified disjunctions, since all the quantifiers need to be made explicit, complex goals contain also existentially quantified conjunctions. Definition 8. <p> We give a formal top-down semantics also for constructive negation. G CN G 0 denotes an SLDCN -derivation of the goal G 0 from G in the normal program P , as defined in <ref> [27, 28] </ref>. Definition 16. Let P be a normal program.
Reference: 28. <author> P. J. Stuckey. </author> <title> Constructive Negation for Constraint Logic Programming. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Melbourne, </institution> <year> 1991. </year>
Reference-contexts: The literal :A is now rewritten as the result of the normalization of the formula :(e 1 2B 1 _ : : :_ e n 2B n ). The result of the computation is independent from the choice of the frontier. The above technique was then extended to CLP <ref> [27, 28] </ref> and a completeness result was proved. <p> We give a formal top-down semantics also for constructive negation. G CN G 0 denotes an SLDCN -derivation of the goal G 0 from G in the normal program P , as defined in <ref> [27, 28] </ref>. Definition 16. Let P be a normal program. <p> The following theorems show the correctness and the completeness of SLD 8 - resolution with respect to the 3-valued logical consequences of th (&lt;)^P fl . Similar theorems were proved for constructive negation in <ref> [28] </ref>. Our proofs are strongly based on properties of F 8 (P ). 8F denotes the universal closure of F .
Reference: 29. <author> M. H. van Emden and R. A. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: The reference fixpoint semantics is usually based on Fitting's operator [12]. Unfortunately, the nice equivalence and completeness results proved for the semantics of positive logic programs <ref> [29, 2, 19, 1] </ref> are not valid in the case of normal programs. In particular, we need to impose strong conditions on programs and goals, in order to deal with various incompleteness problems (e.g. floundering, inconsistency of the completion, the combination of tertium non datur and non-termination).
References-found: 29

