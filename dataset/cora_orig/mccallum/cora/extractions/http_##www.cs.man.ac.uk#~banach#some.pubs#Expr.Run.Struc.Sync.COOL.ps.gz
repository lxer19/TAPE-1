URL: http://www.cs.man.ac.uk/~banach/some.pubs/Expr.Run.Struc.Sync.COOL.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~banach/Recent.publications.html
Root-URL: http://www.cs.man.ac.uk
Abstract-found: 0
Intro-found: 1
Reference: <author> Banach R. </author> <year> (1993), </year> <title> MONSTR: Term Graph Rewriting for Parallel Machines, in Term Graph Rewriting: Theory and Practice, </title> <editor> Sleep et al (eds.), </editor> <publisher> Wiley, </publisher> <pages> pp. 243-252. </pages>
Reference-contexts: In the current work we exploit the generalised computational model of Term Graph Rewriting (Sleep et al. 1993) and in particular the MONSTR model and associated compiler target language <ref> (Banach 1993, 1996a-d) </ref>, to develop an abstract formal framework for reasoning about some of the above mentioned issues. We pay particular attention to the way the global runtime structures are set up and to how various synchronisation properties of objects can be supported. <p> This is a traditional and extensively tested approach, having been used for a variety of language formalisms <ref> (Banach and Papadopoulos 1993, 1995a) </ref>. A full 18 Concurrent OO and MONSTR translation gives the added benefit of allowing rigorous reasoning about all aspects of a language; e.g. the way Banach et al. (1995) gives an alternative perspective on process calculi.
Reference: <author> Banach R. </author> <year> (1996a), </year> <title> MONSTR I | Fundamental Issues and the Design of MONSTR, </title> <journal> Journal of Universal Computer Science, </journal> <note> to appear. </note>
Reference-contexts: redex, depend solely on the symbol at the root (and so can be delegated to simple hardware). * No pointer equivalence is required for matching any redex node, that is not evident from Map (oe (root)), (ditto). * All execution graphs are balanced and state saturated. * The overwriting lemma <ref> (Banach 1996a, Lemma 5.10) </ref>, applies to most redirections, in practice enabling the convenient representation of rewriting by packet store manipulations, (and particularly the representation of redirection by packet overwriting).
Reference: <author> Banach R. </author> <year> (1996b), </year> <title> MONSTR II | Suspending MONSTR Semantics and Independence, </title> <note> submitted to Journal of Universal Computer Science. </note>
Reference: <author> Banach R. </author> <year> (1996c), </year> <title> MONSTR III | Finegrained Semantics and Serialisability, </title> <note> in preparation. </note>
Reference: <author> Banach R. </author> <year> (1996d), </year> <title> MONSTR IV | Coercing Semantics and Serialisability for Resilient Systems, </title> <note> in preparation. </note>
Reference-contexts: MONSTR 9 In fact, by tinkering a little with the operational semantics of MONSTR, a stronger version of the theorem can be shown, dispensing with the need for clauses 2 and 3 in the definition of strongly resilient systems <ref> (see Banach 1996d) </ref>. In any case idle functions are rarely used in practice, except for translating case selections, whereupon the subcomputations for each alternative can be created idle, awaiting activation when the selector subcomputation completes.
Reference: <author> Banach R., Balazs J., Papadopoulos G. A. </author> <year> (1995), </year> <title> A Translation of the Pi-Calculus into MONSTR, </title> <journal> Journal of Universal Computer Science, </journal> <volume> 1 (6), </volume> <pages> 335-394. </pages>
Reference: <author> Banach R., Papadopoulos G. A. </author> <year> (1993), </year> <title> Parallel Term Graph Rewriting and Concurrent Logic Programs, </title> <booktitle> Proc. </booktitle> <address> WPDP `93, Sofia, Bulgaria, </address> <month> May 4-7, </month> <pages> 303-322. </pages>
Reference-contexts: In the current work we exploit the generalised computational model of Term Graph Rewriting (Sleep et al. 1993) and in particular the MONSTR model and associated compiler target language <ref> (Banach 1993, 1996a-d) </ref>, to develop an abstract formal framework for reasoning about some of the above mentioned issues. We pay particular attention to the way the global runtime structures are set up and to how various synchronisation properties of objects can be supported. <p> This is a traditional and extensively tested approach, having been used for a variety of language formalisms <ref> (Banach and Papadopoulos 1993, 1995a) </ref>. A full 18 Concurrent OO and MONSTR translation gives the added benefit of allowing rigorous reasoning about all aspects of a language; e.g. the way Banach et al. (1995) gives an alternative perspective on process calculi.
Reference: <author> Banach R., Papadopoulos G. A. </author> <year> (1995a), </year> <title> Linear Behaviour of Term Graph Rewriting Programs, </title> <booktitle> Proc. ACM SAC `95, </booktitle> <address> Nashville TN., USA, </address> <month> Feb. </month> <pages> 26-28, </pages> <publisher> ACM Press, </publisher> <pages> 157-163. </pages>
Reference: <author> Banach R., Papadopoulos G. A. </author> <year> (1995b), </year> <title> Term Graph Rewriting as a Specification and Implementation Framework for Concurrent Object Oriented Programming Languages, </title> <booktitle> Proc. </booktitle> <address> MPPM `95, Berlin, Germany, </address> <month> Oct. </month> <pages> 9-12, </pages> <publisher> IEEE Press, </publisher> <pages> 151-158. </pages>
Reference-contexts: We then discussed a number of issues pertaining to synchronisation of concurrent method invocations between and within an object by lifting the relevant discussion from the level of a COOL to that of a set of MONSTR rewrite rules. This generalises our initial work <ref> (Banach and Papadopoulos 1995b) </ref>, where we focused on the object oriented functional language UFO (Sargeant 1993). It is important to note that our simple object abstraction renders the current work independent of any particular COOL.
Reference: <author> Henz M.,Smolka G., Wurtz J. </author> <year> (1994), </year> <title> Object-Oriented Concurrent Constraint Programming in Oz, </title> <booktitle> Proc. </booktitle> <address> PPCP, </address> <publisher> MIT Press, </publisher> <address> Cambridge MA., </address> <pages> 27-48. </pages>
Reference-contexts: And there is no reason why we could not apply the principles of our approach to other similar families of languages such as the concurrent constraint ones <ref> (Henz et al. 1994) </ref>.
Reference: <author> Nierstrasz O., Papathomas M. </author> <year> (1990), </year> <title> Viewing Objects as Patterns of Communicating Agents, </title> <booktitle> Proc. OOPSLA/ECOOP `90, </booktitle> <publisher> ACM Press, </publisher> <address> Ottawa, Canada, </address> <month> Oct. </month> <pages> 21-25, 38-43. </pages>
Reference-contexts: In Papathomas (1990) six different categories of OO languages are identified. It has 4 Concurrent OO and MONSTR also been argued <ref> (Nierstrasz and Papathomas 1990) </ref> that there is a need to develop semantic frameworks for reasoning about the way various features of concurrent OO languages operate, and to provide a common point of reference in comparing various such languages. <p> Therefore, during the process of designing a new COOL, whether it is an extension of some existing base language or a brand new one, the language designer can use the proposed framework to study cheaply, various aspects of the language's semantics <ref> (Nierstrasz and Papathomas 1990, Papathomas 1989) </ref>. Other uses of this framework are also possible. For instance, one could use MONSTR as a means of comparing similar features offered by different languages, and could thus study issues related to expressiveness or interaction of these features.
Reference: <author> Papathomas M. </author> <year> (1989), </year> <title> Concurrency Issues in Object-Oriented Languages, in Object Oriented Development, </title> <editor> ed. </editor> <address> D. </address> <institution> Tsichritzis, Centre Universitaire d' Informatique, University of Geneva, </institution> <month> 207-245. </month>
Reference: <author> Sargeant J. </author> <year> (1993), </year> <title> Uniting Functional and Object-Oriented Programming, </title> <booktitle> Proc. 1st JSST, </booktitle> <address> Kanazawa, Japan, </address> <month> Nov. </month> <pages> 4-6, </pages> <publisher> LNCS 742, Springer Verlag, </publisher> <pages> 1-26. </pages>
Reference-contexts: In fact the history of the instance variables through a computation may be represented by a sequence of constructors if a clean single assignment discipline for creation of new instance variable values is adhered to within method computations. (Such a discipline is specified in UFO <ref> (Sargeant 1993) </ref>; of course if a less clean story within method computations pertains, then stateholders may be required. <p> This generalises our initial work (Banach and Papadopoulos 1995b), where we focused on the object oriented functional language UFO <ref> (Sargeant 1993) </ref>. It is important to note that our simple object abstraction renders the current work independent of any particular COOL. This means that MONSTR provides good neutral ground for comparing different synchronisation semantics for COOLs, whether existing or proposed.
Reference: <author> Sleep M. R., Plasmeijer M. J., van Eekelen M. C. J. D. eds. </author> <year> (1993), </year> <title> Term Graph Rewriting: Theory and Practice, </title> <publisher> John Wiley, </publisher> <address> New York. </address>
Reference-contexts: In the current work we exploit the generalised computational model of Term Graph Rewriting <ref> (Sleep et al. 1993) </ref> and in particular the MONSTR model and associated compiler target language (Banach 1993, 1996a-d), to develop an abstract formal framework for reasoning about some of the above mentioned issues.
Reference: <author> Watson I., Woods V., Watson P., Banach R., Greenberg M., Sargeant J. </author> <year> (1988), </year> <month> Flagship: </month>
Reference-contexts: MONSTR is a rule based language that was designed with distributed systems in mind and in fact it has been implemented on at least one such architecture <ref> (Watson et al. 1988) </ref>. 2.1 MONSTR Rewrites The fundamental objects of MONSTR are term graphs. A term graph, is a directed graph where the nodes are labelled with symbols, assumed of fixed arity, and each node has a sequence of out-arcs to its child nodes.
References-found: 15

