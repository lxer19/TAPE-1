URL: http://www.research.att.com/library/trs/TRs/96/96.13/96.13.2.body.ps
Refering-URL: http://www.research.att.com/library/trs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fjf,mstraussg@research.att.com  
Title: An Information-Theoretic Treatment of Random-Self-Reducibility  
Author: Joan Feigenbaum and Martin Strauss 
Date: December 4, 1996  
Address: Murray Hill, NJ 07974 USA  
Affiliation: AT&T Labs,  
Abstract: We initiate the study of random-self-reducibility from an information-theoretic point of view. Specifically, we formally define the notion of a random-self-reduction that, with respect to a given ensemble of distributions, leaks a limited number bits, i.e., produces target instances y 1 ; : : : ; y k in such a manner that each y i has limited mutual information with the input x. We argue that this notion is useful in studying the relationships between random-self-reducibility and other properties of interest, including self-correctability and NP-hardness. In the case of self-correctability, we show that the information-theoretic definition of random-self-reducibility leads to somewhat different conclusions from those drawn by Feigenbaum, Fortnow, Laplante, and Naik [13], who used the standard definition. In the case of NP-hardness, we use the information-theoretic definition to strengthen the result of Feigenbaum and Fortnow [12], who proved, using the standard definition, that the polynomial hierarchy collapses if an NP-hard set is random-self-reducible. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi, J. Feigenbaum, and J. Kilian. </author> <title> On Hiding Information from an Oracle. </title> <journal> Journal of Computing and System Sciences, </journal> <volume> 39 </volume> <pages> 21-50, </pages> <year> 1989. </year>
Reference-contexts: Random-self-reducible functions have many applications, including: Cryptography: The fact that certain number-theoretic functions are random-self-reducible is used extensively in the theory of cryptography | e.g., to achieve probabilistic encryption [14] and cryptographically strong pseudorandom number generation [9]. Random-self-reductions also provide natural examples of instance-hiding schemes <ref> [1, 5, 6] </ref>, in which a weak, private computing device uses the resources of a powerful, shared computing device without revealing its private data.
Reference: [2] <author> L. Babai. </author> <title> Random oracles separate PSPACE from the polynomial-time hierarchy. </title> <journal> Information Processing Letters, </journal> <volume> 26 </volume> <pages> 51-53, </pages> <year> 1987. </year>
Reference-contexts: Furthermore, the random-self-reduction for PERM is very simple, whereas average-case hardness proofs are often complicated. Lower bounds: The random-self-reducibility of the parity function is used in <ref> [2] </ref> to obtain a simple proof that a random oracle separates the polynomial hierarchy (PH) from PSPACE. (An earlier proof of this result in [10] does not use random-self-reducibility.) In this work we investigate a new notion, random-self-reducibility with respect to an ensemble D = fD n g n1 , leaking
Reference: [3] <author> L. Babai and S. Moran. </author> <title> Arthur-Merlin games: A randomized proof system and a hierarchy of complexity classes. </title> <journal> Journal of Computing and System Sciences, </journal> <volume> 36 </volume> <pages> 254-276, </pages> <year> 1988. </year>
Reference-contexts: In this section, we show an analogous result for our notion of leaky rsr. The language class AM poly is defined in [12]; it consists of languages with Arthur-Merlin protocols <ref> [3] </ref> in which Arthur gets advice and the subsequent AM protocol need only be valid on the correct advice. In [12], it is shown that, if S is in NP and has a standard rsr, then the complement of S is in AM poly . <p> In [12], it is shown that, if S is in NP and has a standard rsr, then the complement of S is in AM poly . Since it is known <ref> [3, 16] </ref> that AM poly = NP=poly, membership of SAT in AM poly implies that co-NP NP=poly, whence the PH collapses [22]. In Section 2, we argued that O (log n) bits of leakage is the "right" amount to allow.
Reference: [4] <author> L. Babai, L. Fortnow, and C. Lund. </author> <title> Nondeterministic exponential time has two-prover interactive protocols. </title> <journal> Computational Complexity, </journal> <volume> 1 </volume> <pages> 3-40, </pages> <year> 1991. </year>
Reference-contexts: These ideas play a crucial role in the characterization of the language-recognition power of interactive proof systems <ref> [4, 18, 19] </ref>. A very active theme of current research in this area is the question of whether NP-complete sets have checkers, self-testers, or self-correctors [8, 12, 13]. We explore this theme further in this paper, using an information-theoretic perspective for the first time.
Reference: [5] <author> D. Beaver and J. Feigenbaum. </author> <title> Hiding instance in multioracle queries. </title> <booktitle> In Proc. 7th Symposium on Theoretical Aspects of Computer Science, Lecture Notes in Computer Science, </booktitle> <volume> vol. 415, </volume> <pages> pages 37-48. </pages> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: Random-self-reducible functions have many applications, including: Cryptography: The fact that certain number-theoretic functions are random-self-reducible is used extensively in the theory of cryptography | e.g., to achieve probabilistic encryption [14] and cryptographically strong pseudorandom number generation [9]. Random-self-reductions also provide natural examples of instance-hiding schemes <ref> [1, 5, 6] </ref>, in which a weak, private computing device uses the resources of a powerful, shared computing device without revealing its private data.
Reference: [6] <author> D. Beaver, J. Feigenbaum, J. Kilian, and P. Rogaway. </author> <title> Locally random reductions: Improvements and applications. </title> <journal> Journal of Cryptology, </journal> <note> to appear. Preliminary version in Proc. Crypto '90, </note> <month> pages 62-76, </month> <title> under the title "Security with low communication overhead." </title>
Reference-contexts: Random-self-reducible functions have many applications, including: Cryptography: The fact that certain number-theoretic functions are random-self-reducible is used extensively in the theory of cryptography | e.g., to achieve probabilistic encryption [14] and cryptographically strong pseudorandom number generation [9]. Random-self-reductions also provide natural examples of instance-hiding schemes <ref> [1, 5, 6] </ref>, in which a weak, private computing device uses the resources of a powerful, shared computing device without revealing its private data.
Reference: [7] <author> M. Blum and S. Kannan. </author> <title> Designing programs that check their work. </title> <journal> Journal of the ACM, </journal> <volume> 42 </volume> <pages> 269-291, </pages> <year> 1995. </year>
Reference-contexts: Interactive proof systems and program checkers, self-testers, and self-correctors: Random-self-reductions are crucial ingredients in many of the original examples of interactive proof systems and program checkers, self-testers, and self-correctors <ref> [7, 8, 15] </ref>. Intuitively, this is because the verifier, checker, tester, or corrector interrogates the prover or program by comparing its output on the specific input of interest to its outputs on other related random instances.
Reference: [8] <author> M. Blum, M. Luby, and R. Rubinfeld. Self-testing/correcting, </author> <title> with applications to numerical problems. </title> <journal> Journal of Computing and System Sciences, </journal> <volume> 59 </volume> <pages> 549-595, </pages> <year> 1993. </year>
Reference-contexts: Interactive proof systems and program checkers, self-testers, and self-correctors: Random-self-reductions are crucial ingredients in many of the original examples of interactive proof systems and program checkers, self-testers, and self-correctors <ref> [7, 8, 15] </ref>. Intuitively, this is because the verifier, checker, tester, or corrector interrogates the prover or program by comparing its output on the specific input of interest to its outputs on other related random instances. <p> These ideas play a crucial role in the characterization of the language-recognition power of interactive proof systems [4, 18, 19]. A very active theme of current research in this area is the question of whether NP-complete sets have checkers, self-testers, or self-correctors <ref> [8, 12, 13] </ref>. We explore this theme further in this paper, using an information-theoretic perspective for the first time. <p> A reduction may be considered sufficiently privacy-preserving if it divulges fully an x that is assigned high probability by D but conceals almost fully an x that is assigned low probability by D. Self-correction: Blum, Luby, and Rubinfeld <ref> [8] </ref> defined program self-correction in order to address the following question. <p> One may also parameterize self-correction in such a way that the program P is assumed to err on D n with probability at most *(n) (as Blum, Luby, and Rubinfeld did in their original paper <ref> [8] </ref>). 3 2.2 Mutual Information The mutual information I (a; b) between two events a; b is defined to be log Pr (a) Pr (b) Pr (a j b) : Conventions differ about the mutual information between two events if (at least) one of these events has probability zero.
Reference: [9] <author> M. Blum and S. Micali. </author> <title> How to generate cryptographically strong sequences of pseudo-random bits. </title> <journal> SIAM Journal on Computing, </journal> <volume> 13 </volume> <pages> 850-864, </pages> <year> 1984. </year>
Reference-contexts: Random-self-reducible functions have many applications, including: Cryptography: The fact that certain number-theoretic functions are random-self-reducible is used extensively in the theory of cryptography | e.g., to achieve probabilistic encryption [14] and cryptographically strong pseudorandom number generation <ref> [9] </ref>. Random-self-reductions also provide natural examples of instance-hiding schemes [1, 5, 6], in which a weak, private computing device uses the resources of a powerful, shared computing device without revealing its private data.
Reference: [10] <author> J. Cai. </author> <title> With probability one, a random oracle separates PSPACE from the polynomial hierarchy. </title> <journal> Journal of Computing and System Sciences, </journal> <volume> 38 </volume> <pages> 68-85, </pages> <year> 1989. </year>
Reference-contexts: Lower bounds: The random-self-reducibility of the parity function is used in [2] to obtain a simple proof that a random oracle separates the polynomial hierarchy (PH) from PSPACE. (An earlier proof of this result in <ref> [10] </ref> does not use random-self-reducibility.) In this work we investigate a new notion, random-self-reducibility with respect to an ensemble D = fD n g n1 , leaking l (n) bits.
Reference: [11] <author> J. Feigenbaum. </author> <title> Locally random reductions in interactive complexity theory. </title> <booktitle> DIMACS Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <volume> vol. 13, </volume> <pages> pages 73-98. </pages> <publisher> American Mathematical Society, </publisher> <address> Providence, </address> <year> 1993. </year>
Reference-contexts: For a more in-depth review of these definitions and of their role in complexity theory, see <ref> [11] </ref>. <p> Thus, "random-self-reduction" is really shorthand for "random-self-reduction leaking at most jxj." Note that we are restricting attention to nonadaptive reductions, i.e., those in which the query y i does not depend on the answers to the queries y 1 through y i1 ; see, e.g., <ref> [11] </ref> for a discussion of the more general, adaptive versions of these reductions.
Reference: [12] <author> J. Feigenbaum and L. Fortnow. </author> <title> Random-self-reducibility of complete sets. </title> <journal> SIAM Journal on Computing, </journal> <volume> 22 </volume> <pages> 994-1005, </pages> <year> 1993. </year>
Reference-contexts: These ideas play a crucial role in the characterization of the language-recognition power of interactive proof systems [4, 18, 19]. A very active theme of current research in this area is the question of whether NP-complete sets have checkers, self-testers, or self-correctors <ref> [8, 12, 13] </ref>. We explore this theme further in this paper, using an information-theoretic perspective for the first time. <p> In the next section, we give background and previous definitions, then introduce our new notion of a leaky random-self-reduction with respect to an ensemble. In Section 3, we compare random-self-reducible and self-correctible functions, building on [13]. In Section 4, we build on <ref> [12] </ref> by showing that, if SAT has even a leaky random-self-reduction, then the polynomial hierarchy collapses. 2 Preliminaries Throughout this paper, f is a function on f0; 1g fl , and x is an arbitrary input for which we would like to determine f (x). <p> Because of this restriction, we may assume that the random variables (i 1 ; x; r) and (i 2 ; x; r) are identically distributed, for all i 1 ; i 2 , as pointed out by Szegedy and reported in <ref> [12] </ref>, and thus we use (x; r) to denote this random variable and x for its distribution. <p> Theorem 10 ([13]) With respect to a CH-sampleable ensemble D, every function with a self-corrector in CH has a traditional rsr in CH. 4 Random-self-reducibility of SAT Feigenbaum and Fortnow <ref> [12] </ref> show that SAT is not random-self-reducible unless the PH collapses at the third level. In this section, we show an analogous result for our notion of leaky rsr. The language class AM poly is defined in [12]; it consists of languages with Arthur-Merlin protocols [3] in which Arthur gets advice <p> has a traditional rsr in CH. 4 Random-self-reducibility of SAT Feigenbaum and Fortnow <ref> [12] </ref> show that SAT is not random-self-reducible unless the PH collapses at the third level. In this section, we show an analogous result for our notion of leaky rsr. The language class AM poly is defined in [12]; it consists of languages with Arthur-Merlin protocols [3] in which Arthur gets advice and the subsequent AM protocol need only be valid on the correct advice. In [12], it is shown that, if S is in NP and has a standard rsr, then the complement of S is in AM <p> The language class AM poly is defined in <ref> [12] </ref>; it consists of languages with Arthur-Merlin protocols [3] in which Arthur gets advice and the subsequent AM protocol need only be valid on the correct advice. In [12], it is shown that, if S is in NP and has a standard rsr, then the complement of S is in AM poly . <p> We will henceforth reuse S to denote S n . We will consider two cases for S. First, suppose Pr ffiD n (S) &gt; 1=k 2 : (1) In this case, our proof follows the one in <ref> [12] </ref>. The crux of the proof in [12] is that Arthur can get as advice the measure of S, according to the single distribution on queries. In fact, it follows from the proof in [12] that Arthur need not get the measure exactly, but only to within the factor (1 1=k <p> We will henceforth reuse S to denote S n . We will consider two cases for S. First, suppose Pr ffiD n (S) &gt; 1=k 2 : (1) In this case, our proof follows the one in <ref> [12] </ref>. The crux of the proof in [12] is that Arthur can get as advice the measure of S, according to the single distribution on queries. In fact, it follows from the proof in [12] that Arthur need not get the measure exactly, but only to within the factor (1 1=k 3 ), where k is the number <p> n (S) &gt; 1=k 2 : (1) In this case, our proof follows the one in <ref> [12] </ref>. The crux of the proof in [12] is that Arthur can get as advice the measure of S, according to the single distribution on queries. In fact, it follows from the proof in [12] that Arthur need not get the measure exactly, but only to within the factor (1 1=k 3 ), where k is the number of queries made by the rsr. <p> Arthur gets the latter as advice, and the proof proceeds as in <ref> [12] </ref>. Next, instead of (1), suppose Pr ffiD n (S) 1=k 2 : (2) In this case, we show that S 2 BPP, whence S 2 AM poly .
Reference: [13] <author> J. Feigenbaum, L. Fortnow, S. Laplante, and A. Naik. </author> <title> On coherence, </title> <booktitle> random-self-reducibility, and self--correction. In Proc. 11th Conference on Computational Complexity, </booktitle> <pages> pages 59-67. </pages> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <year> 1996. </year>
Reference-contexts: These ideas play a crucial role in the characterization of the language-recognition power of interactive proof systems [4, 18, 19]. A very active theme of current research in this area is the question of whether NP-complete sets have checkers, self-testers, or self-correctors <ref> [8, 12, 13] </ref>. We explore this theme further in this paper, using an information-theoretic perspective for the first time. <p> Blum, Luby, and Rubinfeld observed that every f that has a standard random-self-reduction is also self-correctable, and it is a well-known open question whether the two properties are equivalent, i.e., whether every self-correctable function has a standard random-self-reduction. Recently, Feigenbaum, Fortnow, Laplante, and Naik <ref> [13] </ref> provided a partial answer to this question by exhibiting, under a plausible complexity theoretic hypothesis, a function that is self-correctable but does not have a standard random-self-reduction. <p> Specifically, we claim that, because inputs to a self-corrector are drawn from an ensemble D, inputs to a random-self-reduction should also be drawn from such an ensemble if the notions are to be compared meaningfully. To justify this claim, we show that the function f that is proven in <ref> [13] </ref> to be self-correctable with respect to a particular ensemble D, but not random-self-reducible according to the standard definition, is in fact random-self-reducible (leaking 0 bits) according to our definition, in which the random-self-reduction is given the ability to sample from D. <p> In the next section, we give background and previous definitions, then introduce our new notion of a leaky random-self-reduction with respect to an ensemble. In Section 3, we compare random-self-reducible and self-correctible functions, building on <ref> [13] </ref>. <p> These conventions make our analysis continuous. 3 RSR versus Self-correction Feigenbaum, Fortnow, Laplante, and Naik <ref> [13] </ref> consider the question of whether all self-correctible functions are rsr. They show that the question cannot be settled with current techniques, because there are currently unrefutable hypotheses that support both answers. Nonetheless, one can interpret the results of [13] as evidence that there is a function f and an ensemble <p> analysis continuous. 3 RSR versus Self-correction Feigenbaum, Fortnow, Laplante, and Naik <ref> [13] </ref> consider the question of whether all self-correctible functions are rsr. They show that the question cannot be settled with current techniques, because there are currently unrefutable hypotheses that support both answers. Nonetheless, one can interpret the results of [13] as evidence that there is a function f and an ensemble D such that f does not have a standard rsr but is self-correctable with respect to D | [13] gives a plausible hypothesis that implies the existence of such an f and D and an implausible hypothesis that implies <p> Nonetheless, one can interpret the results of <ref> [13] </ref> as evidence that there is a function f and an ensemble D such that f does not have a standard rsr but is self-correctable with respect to D | [13] gives a plausible hypothesis that implies the existence of such an f and D and an implausible hypothesis that implies the nonexistence of such an f and D. <p> While we cannot show definitively that all self-correctible functions have such rsr's, our results lend themselves to the opposite interpretation of those in <ref> [13] </ref>. 3.1 Inequivalence Feigenbaum, Fortnow, Laplante, and Naik [13] observe that certain functions f are self-correctible with respect to a singleton ensemble D, i.e., one that, for each n, puts all the weight on one string in f0; 1g n : The crux is that any program that computes f correctly <p> While we cannot show definitively that all self-correctible functions have such rsr's, our results lend themselves to the opposite interpretation of those in <ref> [13] </ref>. 3.1 Inequivalence Feigenbaum, Fortnow, Laplante, and Naik [13] observe that certain functions f are self-correctible with respect to a singleton ensemble D, i.e., one that, for each n, puts all the weight on one string in f0; 1g n : The crux is that any program that computes f correctly with probability 3=4 with respect to D already <p> While the peculiarities of D can make a function self-correctible, they do not necessarily endow that function with a standard rsr, as shown in <ref> [13] </ref>. We show here that, for such peculiar ensembles D, all self-correctible functions have rsr's that sample D. <p> Moreover, it succeeds all the time, because, if D n = ffi u n , then y = x, and so f (x) = f (y), whereas, if D n 6= ffi u n , then f (x) = f (y) = 0. More generally, the setup of <ref> [13] </ref> and our proof require that ffi u n put at least 1=4 of the weight on u n , if we take 3=4 to be the threshold for the program self-correction. In particular, we do not rely on the fact that many strings have probability zero. <p> If ffi u n is not a true delta function we may have to sample several times from D n to determine whether D n = ffi u n or D n is uniform. We conclude that the self-correctible function exhibited in <ref> [13] </ref> fails to be rsr simply because the standard definition of rsr does not allow the reduction to sample from the ensemble D. The fact that a standard rsr leaks at most n is not really used. 3.2 Equivalence In [13], it is shown that, if PF = #P, then any <p> We conclude that the self-correctible function exhibited in <ref> [13] </ref> fails to be rsr simply because the standard definition of rsr does not allow the reduction to sample from the ensemble D. The fact that a standard rsr leaks at most n is not really used. 3.2 Equivalence In [13], it is shown that, if PF = #P, then any function that is self-correctible with respect to a P-sampleable ensemble also has a standard rsr. <p> In this section, we proceed along similar lines, drawing a weaker conclusion from a weaker hypothesis: If P = NP, then any function that is self-correctible with respect to a P-sampleable D has a leaky rsr with respect to D. The proof in <ref> [13] </ref> uses the assumption PF = #P to conclude that a P-sampleable ensemble is simply a function in P. Instead, we use the weaker hypothesis P = NP and the technique of universal hashing [20] merely to approximate the ensemble. This is sufficient to produce a leaky rsr. <p> Theorem 8 Let D = fD n g n1 be a P-sampleable ensemble. If P = NP and f has a self-corrector with respect to D, then f has a leaky, reciprocating rsr with respect to D. Proof. Our proof builds on <ref> [13] </ref>. We will state facts that are justified in [13] and go into detail about points that are new in our proof. <p> If P = NP and f has a self-corrector with respect to D, then f has a leaky, reciprocating rsr with respect to D. Proof. Our proof builds on <ref> [13] </ref>. We will state facts that are justified in [13] and go into detail about points that are new in our proof. <p> Fix c. A query z is called superfluous with respect to x if Pr x (z) * 2 Pr D n (z); and very superfluous if Pr x (z) * 2 1 + n c Pr D n (z): The term superfluous originated in <ref> [13] </ref>, where it is used to describe z's with the property that no self-corrector can rely heavily on f (z) to recover f (x). The term has additional meaning here: If we promise that our rsr queries from D (a goal that originated in [13] and is related to reciprocity), then <p> (z): The term superfluous originated in <ref> [13] </ref>, where it is used to describe z's with the property that no self-corrector can rely heavily on f (z) to recover f (x). The term has additional meaning here: If we promise that our rsr queries from D (a goal that originated in [13] and is related to reciprocity), then a query z is superfluous precisely when it has more than log (k=* 2 ) bits of mutual information with x. In [13], it is shown how to construct a standard rsr with target ensemble D, by preparing samples z from x and another <p> The term has additional meaning here: If we promise that our rsr queries from D (a goal that originated in <ref> [13] </ref> and is related to reciprocity), then a query z is superfluous precisely when it has more than log (k=* 2 ) bits of mutual information with x. In [13], it is shown how to construct a standard rsr with target ensemble D, by preparing samples z from x and another distribution Pr 00 (x; z), then querying the non-superfluous samples from x mixed with the Pr 00 samples. <p> The corrector will want to sample y's from x and query the non-superfluous y's (which are sufficient to recover f (x)), while avoiding the very superfluous y's, because these have a lot of mutual information with x. The approximate counting allows this. It is shown in <ref> [13] </ref> that there is a polynomial-time computable function 0 that, with high probability, recovers f (x) from x and the pairs (z; ^ f (z)); where ^ f (z) = f (z) unless z is superfluous, in which case ^ f (z) may be arbitrary. <p> Note that Pr 0 (x; ) is a deficient probability distribution. Let the function k 00 (n) and the distribution Pr 00 x satisfy k Pr 0 (x; z) + k 00 Pr 00 (x; z) = Pr (z) for all z. As is shown in <ref> [13] </ref>, one can bound k 00 by a polynomial. Under the hypothesis PF = #P, the corrector in [13] can actually compute Pr 0 , k 00 and Pr 00 exactly and therefore sample from D. <p> As is shown in <ref> [13] </ref>, one can bound k 00 by a polynomial. Under the hypothesis PF = #P, the corrector in [13] can actually compute Pr 0 , k 00 and Pr 00 exactly and therefore sample from D. Under the hypothesis P = NP, we show how to sample from a distribution D x that depends on x but is uniformly close to D on all x.
Reference: [14] <author> S. Goldwasser and S. Micali. </author> <title> Probabilistic encryption. </title> <journal> Journal of Computing and System Sciences, </journal> <volume> 28 </volume> <pages> 270-299, </pages> <year> 1984. </year>
Reference-contexts: Random-self-reducible functions have many applications, including: Cryptography: The fact that certain number-theoretic functions are random-self-reducible is used extensively in the theory of cryptography | e.g., to achieve probabilistic encryption <ref> [14] </ref> and cryptographically strong pseudorandom number generation [9]. Random-self-reductions also provide natural examples of instance-hiding schemes [1, 5, 6], in which a weak, private computing device uses the resources of a powerful, shared computing device without revealing its private data.
Reference: [15] <author> S. Goldwasser, S. Micali, and C. Rackoff. </author> <title> The knowledge complexity of interactive proof systems. </title> <journal> SIAM Journal on Computing, </journal> <volume> 18 </volume> <pages> 186-208, </pages> <year> 1989. </year>
Reference-contexts: Interactive proof systems and program checkers, self-testers, and self-correctors: Random-self-reductions are crucial ingredients in many of the original examples of interactive proof systems and program checkers, self-testers, and self-correctors <ref> [7, 8, 15] </ref>. Intuitively, this is because the verifier, checker, tester, or corrector interrogates the prover or program by comparing its output on the specific input of interest to its outputs on other related random instances.
Reference: [16] <author> S. Goldwasser and M. Sipser. </author> <title> Private coins versus public coins in interactive proof systems. </title> <booktitle> Advances in Computing Research, </booktitle> <volume> vol. 5, </volume> <pages> pages 73-90. </pages> <publisher> JAI Press, </publisher> <address> Greenwich, </address> <year> 1989. </year>
Reference-contexts: In [12], it is shown that, if S is in NP and has a standard rsr, then the complement of S is in AM poly . Since it is known <ref> [3, 16] </ref> that AM poly = NP=poly, membership of SAT in AM poly implies that co-NP NP=poly, whence the PH collapses [22]. In Section 2, we argued that O (log n) bits of leakage is the "right" amount to allow.
Reference: [17] <author> R. Lipton. </author> <title> New directions in testing. </title> <booktitle> DIMACS Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <volume> vol. 2, </volume> <pages> pages 191-202. </pages> <publisher> American Mathematical Society, </publisher> <address> Providence, </address> <year> 1991. </year>
Reference-contexts: One important example of this connection between average-case complexity and worst-case complexity is the result of Lipton <ref> [17] </ref> that the PERM (permanent of integer matrices) function is random-self-reducible.
Reference: [18] <author> C. Lund, L. Fortnow, H. Karloff, and N. Nisan. </author> <title> Algebraic methods for interactive proof systems. </title> <journal> Journal of the ACM, </journal> <volume> 39 </volume> <pages> 859-868, </pages> <year> 1992. </year>
Reference-contexts: These ideas play a crucial role in the characterization of the language-recognition power of interactive proof systems <ref> [4, 18, 19] </ref>. A very active theme of current research in this area is the question of whether NP-complete sets have checkers, self-testers, or self-correctors [8, 12, 13]. We explore this theme further in this paper, using an information-theoretic perspective for the first time.
Reference: [19] <author> A. Shamir. </author> <title> IP = PSPACE. </title> <journal> Journal of the ACM, </journal> <volume> 39 </volume> <pages> 869-877, </pages> <year> 1992. </year>
Reference-contexts: These ideas play a crucial role in the characterization of the language-recognition power of interactive proof systems <ref> [4, 18, 19] </ref>. A very active theme of current research in this area is the question of whether NP-complete sets have checkers, self-testers, or self-correctors [8, 12, 13]. We explore this theme further in this paper, using an information-theoretic perspective for the first time.
Reference: [20] <author> M. Sipser. </author> <title> A complexity theoretic approach to randomness. </title> <booktitle> In Proc. 15th Symposium on Theory of Computation, </booktitle> <pages> pages 330-335. </pages> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1983. </year>
Reference-contexts: The proof in [13] uses the assumption PF = #P to conclude that a P-sampleable ensemble is simply a function in P. Instead, we use the weaker hypothesis P = NP and the technique of universal hashing <ref> [20] </ref> merely to approximate the ensemble. This is sufficient to produce a leaky rsr. Theorem 8 Let D = fD n g n1 be a P-sampleable ensemble. <p> The construction of Pr 00 depends on identifying superfluous queries. We can do this approximately, using universal hashing. The distributions x and D n are #P functions. As in <ref> [20] </ref>, for any constant c, there are functions ^ x and ^ D n in PF PH PF such that fi fi fi 1 ^ x fi fi &lt; n c ; and similarly for D n and ^ D n . <p> In this proof, note that k 2 =* 2 &gt; k queries are made, but the number of queries does not depend on the leakage. That is, the leakage 1=n c depends only on c and, for any desired c we can, by <ref> [20] </ref>, do our approximations to within (1 O (1=n c )). One can define a notion of self-corrector and rsr that have running time in the PH instead of P.
Reference: [21] <author> L. Valiant. </author> <title> The complexity of computing the permanent. </title> <journal> Theoretical Computer Science, </journal> <volume> 8 </volume> <pages> 189-201, </pages> <year> 1979. </year>
Reference-contexts: One important example of this connection between average-case complexity and worst-case complexity is the result of Lipton [17] that the PERM (permanent of integer matrices) function is random-self-reducible. The PERM function is also #P-complete <ref> [21] </ref>; thus, if PERM could be computed efficiently on average (with respect to the target distribution of the reduction), then every function in #P could, with a randomized algorithm, be computed efficiently in the worst case.
Reference: [22] <author> C. Yap. </author> <title> Some consequences of nonuniform conditions on uniform classes. </title> <journal> Theoretical Computer Science, </journal> <volume> 26 </volume> <pages> 287-300, </pages> <year> 1983. </year>
Reference-contexts: Since it is known [3, 16] that AM poly = NP=poly, membership of SAT in AM poly implies that co-NP NP=poly, whence the PH collapses <ref> [22] </ref>. In Section 2, we argued that O (log n) bits of leakage is the "right" amount to allow. That is, one should require that Pr x (z) n O (1) Pr ffiD n (z). For the results of this section, we need tighter control on the leakage.
References-found: 22

