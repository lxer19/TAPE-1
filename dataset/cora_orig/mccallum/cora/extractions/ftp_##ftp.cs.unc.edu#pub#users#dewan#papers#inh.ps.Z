URL: ftp://ftp.cs.unc.edu/pub/users/dewan/papers/inh.ps.Z
Refering-URL: http://www.cs.unc.edu/~dewan/res.html
Root-URL: http://www.cs.unc.edu
Email: SUMMARY  
Title: An Inheritance Model for Supporting Flexible Displays of Data Structures  
Author: PRASUN DEWAN 
Address: W. Lafayette IN 47907  
Affiliation: Department of Computer Sciences, Purdue University,  
Abstract: We have designed an inheritance model that reduces the effort required to define presentations of data structures of programs written in conventional languages. It assumes that the presentation of a data structure is determined by one or more attributes of the data structure; classifies data structures into several groups based on their types, contexts, siblings, ancestors, and other properties; and allows an attribute to be defined once for all members of a group. These groups are arranged in multiple intersecting hierarchies, and a subgroup is allowed to inherit attributes from its supergroup(s). This paper motivates, describes, and illustrates our method of grouping values and arranging the value groups in inheritance hierarchies. KEYWORDS: Inheritance Program visualization User interface development environments 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Alan H. Borning and Daniel H. Ingalls, </author> <title> Multiple Inheritance in Smalltalk-80, </title> <booktitle> Proceedings of the National Conference on Artificial Intelligence, </booktitle> <year> (1982). </year>
Reference-contexts: Attributes are associated not only with top-level data structures displayed to a user, but also the components of these values, and their components, and so on. Thus attributes are associated not only with the sequence, s, but also its elements such as s <ref> [1] </ref>, and the fields of these elements, such as s [1].f1. Suite constructs the presentation of a value using the attributes of the value and all its descendents. VALUE GROUPS Suite associates a displayed value with a large number of attributes (currently about 50). <p> Along the paths from the leaf nodes to the root node are type-child and constructor-child groups. P. Dewan Inheritance Model for Flexible Displays d 8 R.f2R.f1 SR S [last]S [middle]S [first] Enumeration SequenceRecord Generic s childs [2] childs <ref> [1] </ref> child S ChildR Child Sequence ChildRecord Child Generic Child IS-PART-OF Hierarchies An IS-PART-OF hierarchy is associated with each top-level structure value displayed by a program. <p> Thus s [2].f1 IS-PART-OF s [2] child, which IS-PART-OF s [2], which IS-PART-OF s child, which IS-PART-OF s. P. Dewan Inheritance Model for Flexible Displays d 9 s [2].f2s <ref> [1] </ref>.f2 s [2].f1s [1].f1 s [2] childs [1] child s [2]s [1] s child s In the definition of these hierarchies, we have extended the notion of ``type'' and ``value'' supported by conventional programming languages, in four main ways: d We support the notion of a type of all ``types''the ``generic type''. d We consider constructors as types, <p> Thus s [2].f1 IS-PART-OF s [2] child, which IS-PART-OF s [2], which IS-PART-OF s child, which IS-PART-OF s. P. Dewan Inheritance Model for Flexible Displays d 9 s [2].f2s <ref> [1] </ref>.f2 s [2].f1s [1].f1 s [2] childs [1] child s [2]s [1] s child s In the definition of these hierarchies, we have extended the notion of ``type'' and ``value'' supported by conventional programming languages, in four main ways: d We support the notion of a type of all ``types''the ``generic type''. d We consider constructors as types, which, in conventional languages, <p> This is illustrated by considering s [2].f1, whose attributes can be determined either by the structure-instance group s [2] or the context group R.f1, neither of which is a subgroup of the other. This problem is similar to the corresponding problem in object-oriented languages such as Extended Smalltalk <ref> [1] </ref> supporting multiple inheritance of variable and method declarations. In our scheme, a value group has at most two parents, as shown below. The IS-A hierarchies do not intersect each other, that is, have no common value group. <p> It allows certain attributes such as TitleString to be inherited along IS-A links while others such as Font to be inherited along IS-PART-OF links. P. Dewan Inheritance Model for Flexible Displays d 11 s <ref> [1] </ref>.f2 Generic Child s [1] child Record Child Sequence Child s child R.f2R.f1 SR s S [last]S [middle]S [first] EnumerationSequenceRecord Generic R (TitleString = ``WindowColour-&gt; '') R.f1 (TitleString = ``Foreground: '') s [1] s [1].f1 However, there are situations under which it is not flexible enough, since it does not allow an attribute to be <p> P. Dewan Inheritance Model for Flexible Displays d 11 s <ref> [1] </ref>.f2 Generic Child s [1] child Record Child Sequence Child s child R.f2R.f1 SR s S [last]S [middle]S [first] EnumerationSequenceRecord Generic R (TitleString = ``WindowColour-&gt; '') R.f1 (TitleString = ``Foreground: '') s [1] s [1].f1 However, there are situations under which it is not flexible enough, since it does not allow an attribute to be inherited along different links in diff erent value groups.
Reference: 2. <author> Prasun Dewan and Marvin Solomon, </author> <title> An Approach to Support Automatic Generation of User Interfaces, </title> <journal> ACM Transactions on Programming Languages and Systems 12(4) pp. </journal> <month> 566-609 (October </month> <year> 1990). </year>
Reference-contexts: An implementation of the model has been constructed for the Suite user interface development environment [3]. The specific value groups included in the model are motivated by our experience with developing interactive applications in various versions of Suite and its predecessor, Dost <ref> [2] </ref>. The idea of classifying program values into groups and allowing specific groups to inherit properties from more general groups is not new, and is supported, for instance, by object-oriented languages [13]. <p> Our contributions include application of this idea to the support of flexible displays of program data structures and new ways of grouping values and resolving multiple-inheritance motivated by this application. Brief descriptions of parts of the model described here have appeared in References [3] and <ref> [2] </ref>. SUITE We describe the abstract inheritance model using the concrete example of Suite. Interactive programs developed using Suite can display active values to users. An active value in Suite can be a character, integer, real, enumeration, subrange, record, variant record, array, sequence (variable length array), or pointer. <p> P. Dewan Inheritance Model for Flexible Displays d 7 INHERITANCE A value may be part of several groups. For instance, the value s <ref> [2] </ref>.f1 is a member of several groups including the simple-instance group associated with it; the structure-instance groups associated with s [2] and s; the context group associated with R.f1; the simple-type group associated with the type E; and the structure-type groups associated with the types R and S. <p> Along the paths from the leaf nodes to the root node are context, type, and constructor groups. In this hierarchy, each child node is a specialized form of the parent node. Thus s <ref> [2] </ref> IS-A S [middle], which IS-A R, which IS-A Record, which IS-A generic. To illustrate the IS-A hierarchy, consider the Suite ElideString attribute, which determines the presentation of a value when its Elided attribute is true. <p> Along the paths from the leaf nodes to the root node are type-child and constructor-child groups. P. Dewan Inheritance Model for Flexible Displays d 8 R.f2R.f1 SR S [last]S [middle]S [first] Enumeration SequenceRecord Generic s childs <ref> [2] </ref> childs [1] child S ChildR Child Sequence ChildRecord Child Generic Child IS-PART-OF Hierarchies An IS-PART-OF hierarchy is associated with each top-level structure value displayed by a program. <p> Each node in the hierarchy can be considered a part of its parent group. Thus s <ref> [2] </ref>.f1 IS-PART-OF s [2] child, which IS-PART-OF s [2], which IS-PART-OF s child, which IS-PART-OF s. P. Dewan Inheritance Model for Flexible Displays d 9 s [2].f2s [1].f2 s [2].f1s [1].f1 s [2] childs [1] child s [2]s [1] s child s In the definition of these hierarchies, we have extended the notion of <p> Each node in the hierarchy can be considered a part of its parent group. Thus s <ref> [2] </ref>.f1 IS-PART-OF s [2] child, which IS-PART-OF s [2], which IS-PART-OF s child, which IS-PART-OF s. P. Dewan Inheritance Model for Flexible Displays d 9 s [2].f2s [1].f2 s [2].f1s [1].f1 s [2] childs [1] child s [2]s [1] s child s In the definition of these hierarchies, we have extended the notion of ``type'' and ``value'' supported by <p> Each node in the hierarchy can be considered a part of its parent group. Thus s <ref> [2] </ref>.f1 IS-PART-OF s [2] child, which IS-PART-OF s [2], which IS-PART-OF s child, which IS-PART-OF s. P. Dewan Inheritance Model for Flexible Displays d 9 s [2].f2s [1].f2 s [2].f1s [1].f1 s [2] childs [1] child s [2]s [1] s child s In the definition of these hierarchies, we have extended the notion of ``type'' and ``value'' supported by conventional programming languages, in four main ways: d We support the notion of a type of all ``types''the ``generic type''. d We consider constructors <p> The problem is not eliminated, however, since we support multiple intersecting hierarchies. This is illustrated by considering s <ref> [2] </ref>.f1, whose attributes can be determined either by the structure-instance group s [2] or the context group R.f1, neither of which is a subgroup of the other. This problem is similar to the corresponding problem in object-oriented languages such as Extended Smalltalk [1] supporting multiple inheritance of variable and method declarations. <p> In Suite, we plan to support more graphical attributes and determine the usefulness of the model to specify values of these attributes. ACKNOWLEDGMENTS Discussions with Marvin Solomon contributed to an initial inheritance model described briefly in Reference <ref> [2] </ref>, and discussions with Eric Vasilik contributed to the refinement of this model. Eric also implemented the major components of the current model and most of the Suite attributes. Rajiv Choudhary implemented attributes of graphical presentations. Tim Korb explained X Intrinsics to the author.
Reference: 3. <author> Prasun Dewan, </author> <title> A Tour of the Suite User Interface Software, </title> <booktitle> Proceedings of the 3rd ACM SIGGRAPH Symposium on User Interface Software and Technology, </booktitle> <pages> pp. </pages> <month> 57-65 (October </month> <year> 1990). </year>
Reference-contexts: The value groups are arranged in multiple intersecting hierarchies, and a subgroup is allowed to inherit attributes from its supergroup (s). An implementation of the model has been constructed for the Suite user interface development environment <ref> [3] </ref>. The specific value groups included in the model are motivated by our experience with developing interactive applications in various versions of Suite and its predecessor, Dost [2]. <p> Our contributions include application of this idea to the support of flexible displays of program data structures and new ways of grouping values and resolving multiple-inheritance motivated by this application. Brief descriptions of parts of the model described here have appeared in References <ref> [3] </ref> and [2]. SUITE We describe the abstract inheritance model using the concrete example of Suite. Interactive programs developed using Suite can display active values to users. An active value in Suite can be a character, integer, real, enumeration, subrange, record, variant record, array, sequence (variable length array), or pointer. <p> Detailed descriptions of Suite attributes and motivation for supporting them are beyond the scope of this paper and are given in Reference <ref> [3] </ref>. In this paper, we focus mainly on the inheritance model provided by Suite for specification of attributes. Attributes are associated not only with top-level data structures displayed to a user, but also the components of these values, and their components, and so on. <p> To illustrate the IS-A hierarchy, consider the Suite ElideString attribute, which determines the presentation of a value when its Elided attribute is true. Figure 9 shows the result of setting the ElideString attribute of the value groups Record, R, S [middle], and s <ref> [3] </ref>, to "&lt;Record...&gt;", "&lt;R...&gt;", "&lt;S element...&gt;", and "&lt;s [3]...&gt;", respectively. The Child-IS-A hierarchy contains child groups and is illustrated by Figure 10. The root of the hierarchy is the generic child group and the leaf nodes are the instance-child groups. <p> In Suite, we have implemented these routines for C. Suite provides default definitions for the attributes supported by it. These definitions can be overridden dynamically both by programs and their users. The procedural and interactive interfaces provided by Suite for overridding attribute definitions are described in Reference <ref> [3] </ref>. PRELIMINARY EXPERIENCE We have used our implementation for displaying data structures of several prototype applications. We have built a simple ``process tool'', which displays the list of current processes on a particular host. A user can edit the process list to delete processes from that system. <p> Finally, we have implemented a prototype integrated project management application, which is described in detail in Reference <ref> [3] </ref>. Based on our experience with developing applications in Suite, the following preliminary conclusions can be drawn about different aspects of the model: Automation: We found that each application had to set very few attributes to describe the properties of its active values. <p> We have also found that quick visual feedback to new attribute definitions makes it easier to learn and use the model. Initially, users made attribute definitions by writing code that was invoked by the program. Recently, we have developed an interactive tool for dynamically changing attributes of value groups <ref> [3] </ref>. This tool has made it easier to learn the system, since users can dynamically make an attribute definition in various value groups and immediately determine the values whose displays are affected by the definition.
Reference: 4. <author> Gene Fisher, </author> <title> An Overview of a Graphical Multilanguage Applications Environment, </title> <journal> IEEE Transactions on Software Engineering 14(6) pp. </journal> <month> 774-786 (June </month> <year> 1988). </year>
Reference-contexts: INTRODUCTION Data structures are displayed by a variety of systems. Interpreters of interactive languages such as LISP and ML display them to show results of computations. Traditional debuggers and recent program visualization/animation systems such as Incense [9], Daisy <ref> [4] </ref>, PROVIDE [8], GELO [7], and Tango [12] display them to explain what a program is doing. <p> For instance, a user can ensure that the referent of values of a particular pointer type is always ``elided'' by making an appropriate definition in the context group associated with the pointer type. Program visualization and animation systems such as Incense [9], Daisy <ref> [4] </ref>, PROVIDE [8], GELO [7], and Tango [12] display data structures to allow users to monitor and/or understand programs.
Reference: 5. <author> Adele Goldberg and David Robson, </author> <title> Smalltalk-80: The Language and its Implementation, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass. </address> <year> (1983). </year>
Reference-contexts: We give greater precedence to the more specific subgroup over its supergroup while resolving attributes. This approach is similar to the approach taken by object-oriented languages such as Smalltalk <ref> [5] </ref>, which give greater precedence to a subclass over its superclass in resolving variable and method definitions.
Reference: 6. <author> Joel McCormack, Paul Asente, and Ralph Swick, </author> <title> X Toolkit Intrinsics-C Language Interface, X Window System, </title> <type> X Version 11, Release 4, </type> <month> (December </month> <year> 1989). </year>
Reference-contexts: As mentioned above, our work can be combined with subtyping in object-oriented languages by supporting subgroups corresponding to subtypes. P. Dewan Inheritance Model for Flexible Displays d 17 The Suite inheritance model is also related to the inheritance model supported by the X Intrinsics layer <ref> [6] </ref>, which is used by several X toolkits. X Intrinsics supports the notion of hierarchical widgets, which represent hierarchical X windows on the screen. Each widget is an instance of a widget class, which describes the methods that can be invoked on the widget.
Reference: 7. <author> Scott Meyers, Steven P. Reiss, and Carolyn Duby, </author> <title> Using GELO to Visualize Software Systems, </title> <booktitle> Proceedings of the 2nd ACM Symposium on User Interface Software and Technology, </booktitle> <month> (November </month> <year> 1989). </year>
Reference-contexts: INTRODUCTION Data structures are displayed by a variety of systems. Interpreters of interactive languages such as LISP and ML display them to show results of computations. Traditional debuggers and recent program visualization/animation systems such as Incense [9], Daisy [4], PROVIDE [8], GELO <ref> [7] </ref>, and Tango [12] display them to explain what a program is doing. Recent user interface development environments such as Peridot [10] and Chiron [14] display them to support ``active values'' or ``active variables'' program data structures whose displays can be edited to input new values for these data structures. <p> For instance, a user can ensure that the referent of values of a particular pointer type is always ``elided'' by making an appropriate definition in the context group associated with the pointer type. Program visualization and animation systems such as Incense [9], Daisy [4], PROVIDE [8], GELO <ref> [7] </ref>, and Tango [12] display data structures to allow users to monitor and/or understand programs. Some interface development environments such as Peridot [10] and Chiron [14] support the development of user interfaces that display data structures whose presentations can be edited to control the execution of the program.
Reference: 8. <author> Thomas G. Moher, </author> <title> PROVIDE: A Process Visualization and Debugging Environment, </title> <journal> IEEE Transactions on Software Engineering 14(6) pp. </journal> <month> 849-857 (June </month> <year> 1988). </year>
Reference-contexts: INTRODUCTION Data structures are displayed by a variety of systems. Interpreters of interactive languages such as LISP and ML display them to show results of computations. Traditional debuggers and recent program visualization/animation systems such as Incense [9], Daisy [4], PROVIDE <ref> [8] </ref>, GELO [7], and Tango [12] display them to explain what a program is doing. <p> For instance, a user can ensure that the referent of values of a particular pointer type is always ``elided'' by making an appropriate definition in the context group associated with the pointer type. Program visualization and animation systems such as Incense [9], Daisy [4], PROVIDE <ref> [8] </ref>, GELO [7], and Tango [12] display data structures to allow users to monitor and/or understand programs. Some interface development environments such as Peridot [10] and Chiron [14] support the development of user interfaces that display data structures whose presentations can be edited to control the execution of the program.
Reference: 9. <author> Brad A. Myers, Incense: </author> <title> A System for Displaying Data Structures, </title> <journal> Computer Graphics 17(3) pp. </journal> <month> 115-125 (July </month> <year> 1983). </year>
Reference-contexts: INTRODUCTION Data structures are displayed by a variety of systems. Interpreters of interactive languages such as LISP and ML display them to show results of computations. Traditional debuggers and recent program visualization/animation systems such as Incense <ref> [9] </ref>, Daisy [4], PROVIDE [8], GELO [7], and Tango [12] display them to explain what a program is doing. <p> For instance, a user can ensure that the referent of values of a particular pointer type is always ``elided'' by making an appropriate definition in the context group associated with the pointer type. Program visualization and animation systems such as Incense <ref> [9] </ref>, Daisy [4], PROVIDE [8], GELO [7], and Tango [12] display data structures to allow users to monitor and/or understand programs.
Reference: 10. <author> Brad A. Myers, </author> <title> Creating User Interfaces Using Programming by Example, Visual Programming, and Constraints, </title> <journal> ACM Transactions on Programming Languages and Systems 12(2) pp. </journal> <month> 143-177 (April </month> <year> 1990). </year>
Reference-contexts: Traditional debuggers and recent program visualization/animation systems such as Incense [9], Daisy [4], PROVIDE [8], GELO [7], and Tango [12] display them to explain what a program is doing. Recent user interface development environments such as Peridot <ref> [10] </ref> and Chiron [14] display them to support ``active values'' or ``active variables'' program data structures whose displays can be edited to input new values for these data structures. <p> Program visualization and animation systems such as Incense [9], Daisy [4], PROVIDE [8], GELO [7], and Tango [12] display data structures to allow users to monitor and/or understand programs. Some interface development environments such as Peridot <ref> [10] </ref> and Chiron [14] support the development of user interfaces that display data structures whose presentations can be edited to control the execution of the program.
Reference: 11. <author> Ben Shneiderman, </author> <title> Direct Manipulation: A Step Beyond Programming Languages, </title> <journal> IEEE Computer 16(8) pp. </journal> <month> 57-69 (Aug </month> <year> 1983). </year>
Reference-contexts: Recent user interface development environments such as Peridot [10] and Chiron [14] display them to support ``active values'' or ``active variables'' program data structures whose displays can be edited to input new values for these data structures. Active values support the construction of ``direct manipulation'' user interfaces <ref> [11] </ref>, which allow a user to manipulate objects by ``directly manipulating'' or editing visual representations of them. In many of these systems, users 1 can customize the displays of data structures.
Reference: 12. <author> John T. Stasko, </author> <title> Tango: A Framework and System for Algorithm Animation, </title> <journal> IEEE Computer 33(9) pp. </journal> <month> 27-39 (September </month> <year> 1990). </year>
Reference-contexts: INTRODUCTION Data structures are displayed by a variety of systems. Interpreters of interactive languages such as LISP and ML display them to show results of computations. Traditional debuggers and recent program visualization/animation systems such as Incense [9], Daisy [4], PROVIDE [8], GELO [7], and Tango <ref> [12] </ref> display them to explain what a program is doing. Recent user interface development environments such as Peridot [10] and Chiron [14] display them to support ``active values'' or ``active variables'' program data structures whose displays can be edited to input new values for these data structures. <p> Program visualization and animation systems such as Incense [9], Daisy [4], PROVIDE [8], GELO [7], and Tango <ref> [12] </ref> display data structures to allow users to monitor and/or understand programs. Some interface development environments such as Peridot [10] and Chiron [14] support the development of user interfaces that display data structures whose presentations can be edited to control the execution of the program.
Reference: 13. <author> Peter Wegner, </author> <title> The Object-Oriented Classification Paradigm, Research Directions in Object-Oriented Programming, </title> <editor> edited by Peter Wegner and Bruce D. Shriver, </editor> <publisher> MIT Press, </publisher> <address> Cambridge, MA (1987). </address>
Reference-contexts: The idea of classifying program values into groups and allowing specific groups to inherit properties from more general groups is not new, and is supported, for instance, by object-oriented languages <ref> [13] </ref>. Our contributions include application of this idea to the support of flexible displays of program data structures and new ways of grouping values and resolving multiple-inheritance motivated by this application. Brief descriptions of parts of the model described here have appeared in References [3] and [2]. <p> A value group defined by an instance and type group would be a child of the two defining groups. The Suite inheritance model is related to the inheritance models supported by object-oriented languages <ref> [13] </ref>. In object-oriented languages, the inheritance relationship is supported among types. Subtypes inherit variable and method definitions from their supertypes. Types and supertypes in an object-oriented language correspond to value groups and subgroups, respectively, in our model.
Reference: 14. <author> Michal Young, Richard N. Taylor, and Dennis B. Troup, </author> <title> Software Environment Architectures and User Interface Facilities, </title> <journal> IEEE Transactions on Software Engineering 14(6) pp. </journal> <month> 697-708 (June </month> <year> 1988). </year>
Reference-contexts: Traditional debuggers and recent program visualization/animation systems such as Incense [9], Daisy [4], PROVIDE [8], GELO [7], and Tango [12] display them to explain what a program is doing. Recent user interface development environments such as Peridot [10] and Chiron <ref> [14] </ref> display them to support ``active values'' or ``active variables'' program data structures whose displays can be edited to input new values for these data structures. <p> Program visualization and animation systems such as Incense [9], Daisy [4], PROVIDE [8], GELO [7], and Tango [12] display data structures to allow users to monitor and/or understand programs. Some interface development environments such as Peridot [10] and Chiron <ref> [14] </ref> support the development of user interfaces that display data structures whose presentations can be edited to control the execution of the program. In these systems, it is important to generate eye pleasing presentations of data structures since they are displayed over extended periods of time and to multiple users.
References-found: 14

