URL: http://www.research.att.com/~dalia/pubs/csfw97.ps.gz
Refering-URL: http://www.research.att.com/~dalia/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fdalia,reiterg@research.att.com  
Title: Unreliable Intrusion Detection in Distributed Computations  
Author: Dahlia Malkhi Michael Reiter 
Address: Murray Hill, New Jersey, USA  
Affiliation: AT&T Labs|Research,  
Abstract: Distributed coordination is difficult, especially when the system may suffer intrusions that corrupt some component processes. In this paper we introduce the abstraction of a failure detector that a process can use to (imperfectly) detect the corruption (Byzantine failure) of another process. In general, our failure detectors can be unreliable, both by reporting a correct process to be faulty or by reporting a faulty process to be correct. However, we show that if these detectors satisfy certain plausible properties, then the well-known distributed consensus problem can be solved. We also present a randomized protocol using failure detectors that solves the consensus problem if either the requisite properties of failure detectors hold or if certain highly probable events eventually occur. This work can be viewed as a generalization of benign failure detectors popular in the distributed computing literature. 
Abstract-found: 1
Intro-found: 1
Reference: [AT96] <author> M. K Aguilera and S. Toueg. </author> <title> Randomization and failure detection: A hybrid approach to solve consensus. </title> <booktitle> In Proceedings of the 10th International Workshop on Distributed Algorithms (WDAG), </booktitle> <volume> LNCS 1151, </volume> <pages> pp. 29-39, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: The drawback in randomized protocols is that there is no upper bound on the number of execution steps until a decision is made, and in theory an infinite run is possible (albeit with probability zero). A hybrid approach <ref> [DM94, AT96] </ref> uses both failure detection and randomization to get "the best of both worlds". Informally, a hybrid protocol en sures that if either the specified failure detection conditions hold or one of the (probable) situations created by randomizing techniques occur, then the protocol terminates correctly. <p> Our approach builds on previous hybrid protocols for the crash failure environment <ref> [DM94, AT96] </ref> and on techniques that combine determinism and randomization in the synchronous environment [GP90, Z96]. 2 Model The system consists of a group of n processes, p 0 ; : : : ; p n1 . <p> In addition, the modified protocol maintains: Theorem 7 Let t be a time after which all correct processes' failure detectors are ideal. Then the modified protocol terminates (at the latest) at the end of the first asynchronous round following t. Aguilera and Toueg <ref> [AT96] </ref> describe another common situation, where very few or no failures occur, the leader of the first round is correct, and few enough (or no) false failure detections are made so that the first leader is not suspected by any correct process.
Reference: [B83] <author> M. Ben-Or. </author> <title> Another advantage of free choice: completely asynchronous agreement protocols. </title> <booktitle> In Proceedings of the 2nd ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pp. 27-30, </pages> <year> 1983. </year>
Reference-contexts: This impossibility immediately stems from the basic impossibility result [FLP85] and the fact that a Byzantine asynchronous environment, strengthened with 3S (bz), allows solving consensus. On the other hand, a known approach to circumventing the basic impossibility result [FLP85] is to use randomization (see <ref> [R83, B83, CD89] </ref>). The drawback in randomized protocols is that there is no upper bound on the number of execution steps until a decision is made, and in theory an infinite run is possible (albeit with probability zero). <p> Ben-Or gave a method for tossing a coin in an asynchronous environment with up to t &lt; p n Byzantine faulty processes <ref> [B83] </ref>, that is expected to produce such a unanimous coin toss within a constant number of invocations. He later improved this with another protocol that is resilient to up to t &lt; n 7 Byzantine failures [B85].
Reference: [B85] <author> M. Ben-Or. </author> <title> Fast asynchronous Byzantine agreement. </title> <booktitle> In Proceedings of the 4th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pp. 149-151, </pages> <year> 1985. </year>
Reference-contexts: He later improved this with another protocol that is resilient to up to t &lt; n 7 Byzantine failures <ref> [B85] </ref>. Canetti and Rabin [CR93] used an asynchronous verifiable secret sharing scheme to achieve a coin-tossing protocol resilient to b n1 3 c Byzantine failures that has constant time expected termination with overwhelming probability. Another technique to speed up termination is to use precomputed random bits at run-time.
Reference: [BSS91] <author> K. P. Birman, A. Schiper and P. Stephenson. </author> <title> Lightweight causal and atomic group multicast. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <year> 1991. </year>
Reference-contexts: Note that Agreement and Source Order together imply that for any l and any process r, the l'th bcast-receive from r is the same at all correct processes. Causal Order is weaker than causal ordering properties typically defined in the literature (e.g., <ref> [BSS91] </ref>); this weaker definition is necessitated by our consideration of Byzantine failures. There are several efficient protocols for implementing Integrity, Agreement, Validity, and Source Order in our system model (without using failure detectors or randomization); see [BT85, Rei94, MR96]. <p> There are several efficient protocols for implementing Integrity, Agreement, Validity, and Source Order in our system model (without using failure detectors or randomization); see [BT85, Rei94, MR96]. Any of these can be extended using standard techniques to implement Causal Order (e.g., <ref> [BSS91] </ref>; also see [RG95]). Our specification of reliable broadcast is thus weaker than that for consensus, which we define in Section 3.
Reference: [BT85] <author> G. Bracha and S. Toueg. </author> <title> Asynchronous consensus and broadcast protocols. </title> <journal> Journal of the ACM 32(4) </journal> <pages> 824-840, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: There are several efficient protocols for implementing Integrity, Agreement, Validity, and Source Order in our system model (without using failure detectors or randomization); see <ref> [BT85, Rei94, MR96] </ref>. Any of these can be extended using standard techniques to implement Causal Order (e.g., [BSS91]; also see [RG95]). Our specification of reliable broadcast is thus weaker than that for consensus, which we define in Section 3. <p> Our protocol for solving consensus is a variation on the Paxos consensus protocol [L89], using a revolving leader scheme and adapted for the Byzantine failure environment using techniques from <ref> [BT85] </ref>. The protocol proceeds in rounds that are asynchronous, i.e., rounds may overlap. In each round, a single process is the leader. All messages are labeled with the round for which they are intended.
Reference: [CR93] <author> R. Canetti and T. Rabin. </author> <title> Fast asynchronous Byzan-tine agreement with optimal resilience. </title> <booktitle> In Proceedings of the 25th ACM Symposium on the Theory of Computing, </booktitle> <pages> pp. 42-51, </pages> <year> 1993. </year>
Reference-contexts: He later improved this with another protocol that is resilient to up to t &lt; n 7 Byzantine failures [B85]. Canetti and Rabin <ref> [CR93] </ref> used an asynchronous verifiable secret sharing scheme to achieve a coin-tossing protocol resilient to b n1 3 c Byzantine failures that has constant time expected termination with overwhelming probability. Another technique to speed up termination is to use precomputed random bits at run-time.
Reference: [CD89] <author> B. Chor and C. Dwork. </author> <title> Randomization in Byzantine agreement. </title> <booktitle> In Advances in Computing Research, Randomness in Computation, </booktitle> <volume> volume 5, </volume> <publisher> JAI Press, edited by S. Micali, </publisher> <pages> pp. 443-497, </pages> <year> 1989. </year>
Reference-contexts: This impossibility immediately stems from the basic impossibility result [FLP85] and the fact that a Byzantine asynchronous environment, strengthened with 3S (bz), allows solving consensus. On the other hand, a known approach to circumventing the basic impossibility result [FLP85] is to use randomization (see <ref> [R83, B83, CD89] </ref>). The drawback in randomized protocols is that there is no upper bound on the number of execution steps until a decision is made, and in theory an infinite run is possible (albeit with probability zero).
Reference: [CT96] <author> T. D. Chandra and S. Toueg. </author> <title> Unreliable failure detectors for reliable distributed systems. </title> <journal> Journal of the ACM, </journal> <volume> 43(2) </volume> <pages> 225-267, </pages> <month> March </month> <year> 1996. </year>
Reference-contexts: Chandra and Toueg showed, however, that if the failure detectors satisfy certain properties, then consensus can be solved <ref> [CT96] </ref>, thereby circumventing the impossibility result of [FLP85]. In this paper we extend the failure detectors paradigm to environments in which component processes may suffer intrusions by an attacker, and we consider the consensus problem in this environment. <p> More specifically, failure detectors are defined according to their Completeness, i.e., their ability to detect actual failures, and according to their Accuracy, i.e., their success in avoiding false failure detection <ref> [CT96] </ref>. One might try to define "Completeness" in the Byzantine environment to require the detection of faulty processes by the other correct processes. However, this notion is ill-defined when failures are Byzantine, since, in particular, a Byzantine faulty process may visibly behave like a correct one.
Reference: [CHT96] <author> T. D. Chandra, V. Hadzilacos and S. Toueg. </author> <title> The weakest failure detector for solving consensus. </title> <journal> Journal of the ACM, </journal> <volume> 43(4) </volume> <pages> 685-722, </pages> <month> July </month> <year> 1996. </year>
Reference-contexts: Our analysis complements a number of previously studied failure detector classes for benign failure environments, including the weakest failure detector for solving consensus in the crash-failure environment <ref> [CHT96] </ref>, the weakest conditions allowing other agreement problems to be solved in this model [GS96], and the weakest failure detector suitable for omission failure environments [DFKM96].
Reference: [DFKM96] <author> D. Dolev, R. Friedman, I. Keidar and D. Malkhi. </author> <title> Failure detectors in omission failure environments. </title> <type> Technical Report 96-1605, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> September </month> <year> 1996. </year>
Reference-contexts: complements a number of previously studied failure detector classes for benign failure environments, including the weakest failure detector for solving consensus in the crash-failure environment [CHT96], the weakest conditions allowing other agreement problems to be solved in this model [GS96], and the weakest failure detector suitable for omission failure environments <ref> [DFKM96] </ref>. A limitation of designing distributed protocols using 3S (bz) is that while 3S (bz) can typically be realized in practice (e.g., using carefully tuned time-outs), there may be rare situations in which even the weak requirements of 3S (bz) cannot be guaranteed.
Reference: [DM94] <author> D. Dolev and D. Malki. </author> <title> Consensus made practical. </title> <type> Technical Report 94-7, </type> <institution> Institute of Computer Science, the Hebrew University of Jerusalem, </institution> <month> March </month> <year> 1994. </year>
Reference-contexts: The drawback in randomized protocols is that there is no upper bound on the number of execution steps until a decision is made, and in theory an infinite run is possible (albeit with probability zero). A hybrid approach <ref> [DM94, AT96] </ref> uses both failure detection and randomization to get "the best of both worlds". Informally, a hybrid protocol en sures that if either the specified failure detection conditions hold or one of the (probable) situations created by randomizing techniques occur, then the protocol terminates correctly. <p> Our approach builds on previous hybrid protocols for the crash failure environment <ref> [DM94, AT96] </ref> and on techniques that combine determinism and randomization in the synchronous environment [GP90, Z96]. 2 Model The system consists of a group of n processes, p 0 ; : : : ; p n1 .
Reference: [FLP85] <author> M. J. Fischer, N. A. Lynch, and M. S. Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> Journal of the ACM 32(2) </journal> <pages> 374-382, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: Chandra and Toueg showed, however, that if the failure detectors satisfy certain properties, then consensus can be solved [CT96], thereby circumventing the impossibility result of <ref> [FLP85] </ref>. In this paper we extend the failure detectors paradigm to environments in which component processes may suffer intrusions by an attacker, and we consider the consensus problem in this environment. <p> This impossibility immediately stems from the basic impossibility result <ref> [FLP85] </ref> and the fact that a Byzantine asynchronous environment, strengthened with 3S (bz), allows solving consensus. On the other hand, a known approach to circumventing the basic impossibility result [FLP85] is to use randomization (see [R83, B83, CD89]). <p> This impossibility immediately stems from the basic impossibility result <ref> [FLP85] </ref> and the fact that a Byzantine asynchronous environment, strengthened with 3S (bz), allows solving consensus. On the other hand, a known approach to circumventing the basic impossibility result [FLP85] is to use randomization (see [R83, B83, CD89]). The drawback in randomized protocols is that there is no upper bound on the number of execution steps until a decision is made, and in theory an infinite run is possible (albeit with probability zero).
Reference: [GP90] <author> O. Goldreich and E. Petrank. </author> <title> The best of both worlds: Guaranteeing termination in fast Byzantine agreement protocols. </title> <journal> Information Processing Letters, </journal> <volume> Vol. 36, </volume> <pages> pp. 45-49, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: Our approach builds on previous hybrid protocols for the crash failure environment [DM94, AT96] and on techniques that combine determinism and randomization in the synchronous environment <ref> [GP90, Z96] </ref>. 2 Model The system consists of a group of n processes, p 0 ; : : : ; p n1 . Processes that follow their prescribed protocol are called correct, and all other processes are called faulty.
Reference: [GS96] <author> R. Guerraoui and A. Schiper. </author> <title> "-Accurate" failure detectors. </title> <booktitle> In the 10th International Workshop on Distributed Algorithms (WDAG), </booktitle> <volume> LNCS 1151, </volume> <pages> pp. 269-286, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: Our analysis complements a number of previously studied failure detector classes for benign failure environments, including the weakest failure detector for solving consensus in the crash-failure environment [CHT96], the weakest conditions allowing other agreement problems to be solved in this model <ref> [GS96] </ref>, and the weakest failure detector suitable for omission failure environments [DFKM96].
Reference: [L89] <author> L. Lamport. </author> <title> The part-time parliament. </title> <institution> Systems Research Center, Digital Equipment Corp., Palo Alto, </institution> <type> Technical Report 49, </type> <month> September </month> <year> 1989. </year>
Reference-contexts: All correct processes decide on the same value, called the consensus value. 3. If all of the correct processes hold the same value at the beginning of the protocol, then this is the consensus value. Our protocol for solving consensus is a variation on the Paxos consensus protocol <ref> [L89] </ref>, using a revolving leader scheme and adapted for the Byzantine failure environment using techniques from [BT85]. The protocol proceeds in rounds that are asynchronous, i.e., rounds may overlap. In each round, a single process is the leader. All messages are labeled with the round for which they are intended.
Reference: [MR96] <author> D. Malkhi and M. Reiter. </author> <title> A high-throughput secure reliable multicast protocol. </title> <booktitle> In Proceedings of the 9th IEEE Computer Security Foundations Workshop, </booktitle> <pages> pp. 9-17, </pages> <month> June </month> <year> 1996. </year> <note> Also, to appear in Journal of Computer Security. </note>
Reference-contexts: There are several efficient protocols for implementing Integrity, Agreement, Validity, and Source Order in our system model (without using failure detectors or randomization); see <ref> [BT85, Rei94, MR96] </ref>. Any of these can be extended using standard techniques to implement Causal Order (e.g., [BSS91]; also see [RG95]). Our specification of reliable broadcast is thus weaker than that for consensus, which we define in Section 3.
Reference: [MR97] <author> D. Malkhi and M. Reiter. </author> <title> Byzantine quorum systems. </title> <booktitle> In Proceedings of the 29th ACM Symposium on Theory of Computing (STOC), </booktitle> <month> May </month> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: In practice, other failure assumptions may hold, including less uniform ones. In the future, we plan to extend the treatment here to deal with other Byzantine failure assumptions by employing Byzantine quorum systems <ref> [MR97] </ref> to derive the consistency and liveness of our protocols, thus replacing the uniform requirement thresholds of d 2n+1 3 e and b n1 3 c + 1 in our protocols.
Reference: [R83] <author> M. Rabin. </author> <title> Randomized Byzantine generals. </title> <booktitle> In Proceedings of the 24th annual ACM Symposium on Foundations of Computer Science, </booktitle> <pages> pp. 403-409, </pages> <year> 1983. </year>
Reference-contexts: This impossibility immediately stems from the basic impossibility result [FLP85] and the fact that a Byzantine asynchronous environment, strengthened with 3S (bz), allows solving consensus. On the other hand, a known approach to circumventing the basic impossibility result [FLP85] is to use randomization (see <ref> [R83, B83, CD89] </ref>). The drawback in randomized protocols is that there is no upper bound on the number of execution steps until a decision is made, and in theory an infinite run is possible (albeit with probability zero). <p> Another technique to speed up termination is to use precomputed random bits at run-time. Methods to distribute shares of secret bits using a trusted dealer have been suggested by Rabin <ref> [R83] </ref> and Toueg [T84]. 6 Conclusions In this paper, we have shown how to build practical consensus protocols for environments that may suffer intrusions by an attacker.
Reference: [Rei94] <author> M. K. Reiter. </author> <title> Secure agreement protocols: Reliable and atomic group multicast in Rampart. </title> <booktitle> In Proceedings of the 2nd ACM Conference on Computer and Communications Security, </booktitle> <pages> pp. 68-80, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: There are several efficient protocols for implementing Integrity, Agreement, Validity, and Source Order in our system model (without using failure detectors or randomization); see <ref> [BT85, Rei94, MR96] </ref>. Any of these can be extended using standard techniques to implement Causal Order (e.g., [BSS91]; also see [RG95]). Our specification of reliable broadcast is thus weaker than that for consensus, which we define in Section 3.
Reference: [RG95] <author> M. K. Reiter and L. Gong. </author> <title> Securing causal relationships in distributed systems. </title> <journal> The Computer Journal 38(8) </journal> <pages> 633-642, </pages> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: There are several efficient protocols for implementing Integrity, Agreement, Validity, and Source Order in our system model (without using failure detectors or randomization); see [BT85, Rei94, MR96]. Any of these can be extended using standard techniques to implement Causal Order (e.g., [BSS91]; also see <ref> [RG95] </ref>). Our specification of reliable broadcast is thus weaker than that for consensus, which we define in Section 3.
Reference: [T84] <author> S. Toueg. </author> <title> Randomized Byzantine agreements. </title> <booktitle> In Proceedings of the 3rd ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pp. 163-178, </pages> <year> 1984. </year>
Reference-contexts: Another technique to speed up termination is to use precomputed random bits at run-time. Methods to distribute shares of secret bits using a trusted dealer have been suggested by Rabin [R83] and Toueg <ref> [T84] </ref>. 6 Conclusions In this paper, we have shown how to build practical consensus protocols for environments that may suffer intrusions by an attacker.
Reference: [Z96] <author> A. Zamsky. </author> <title> A randomized Byzantine agreement protocol with constant expected time and guaranteed termination in optimal (deterministic) time. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pp. 201-208, </pages> <year> 1996. </year>
Reference-contexts: Our approach builds on previous hybrid protocols for the crash failure environment [DM94, AT96] and on techniques that combine determinism and randomization in the synchronous environment <ref> [GP90, Z96] </ref>. 2 Model The system consists of a group of n processes, p 0 ; : : : ; p n1 . Processes that follow their prescribed protocol are called correct, and all other processes are called faulty.
References-found: 22

