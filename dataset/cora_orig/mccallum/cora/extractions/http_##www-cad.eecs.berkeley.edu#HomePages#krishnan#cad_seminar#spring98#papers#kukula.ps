URL: http://www-cad.eecs.berkeley.edu/HomePages/krishnan/cad_seminar/spring98/papers/kukula.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/HomePages/krishnan/cad_seminar/spring98/abstract/kukula.html
Root-URL: http://www.cs.berkeley.edu
Email: kukula@synopsys.com  fshiple,adnang@synopsys.com  
Title: Implicit State Enumeration for FSMs with Datapaths  
Author: James H. Kukula Thomas R. Shiple Adnan Aziz 
Note: DAC '98 Submission BDD representation of the corresponding 32-bit datapath.  
Date: October 10, 1997  
Address: OR  Mountain View, CA  
Affiliation: Synopsys, Inc., Beaverton,  Synopsys, Inc.,  
Abstract: We show how the classic BDD-based technique of implicit state enumeration for FSMs can be generalized to an automata-based approach for implicit state enumeration of FSMs interacting with datapaths of unbounded width. We present experimental results showing that our automata representation of an unbounded width datapath can be 10x more compact than the 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alur, C. Courcoubetis, T. A. Henzinger, and P.-H. Ho. </author> <title> Hybrid automata: An algorithmic approach to the specification and verification of hybrid systems. </title> <editor> In R. L. Grossman, A. Nerode, A. P. Ravn, and H. Rischel, editors, </editor> <title> Hybrid Systems I, </title> <booktitle> volume 736 of Lecture Notes in Computer Science, </booktitle> <pages> pages 209-229, </pages> <address> New Brunswick, NJ, 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: One approach taken in the analysis of EFSMs, and in the related area of hybrid systems, is to represent sets of data values implicitly (typically with polyhedra or automata), but to represent control states explicitly <ref> [6, 1, 5, 4] </ref>. In all of these works, state enumeration proceeds by visiting the control states explicitly, one-by-one, accumulating implicitly the data values possible at each control state.
Reference: [2] <author> E. Asarin, M. Bozga, A. Kerbrat, O. Maler, A. Pnueli, and A. Rasse. </author> <title> Data-structures for the verification of timed automata. </title> <editor> In O. Maler, editor, </editor> <booktitle> Proc. International Workshop on Hybrid 14 and Real-Time Systems, HART '97, volume 1201 of Lecture Notes in Computer Science, </booktitle> <pages> pages 346-360, </pages> <address> Grenoble, </address> <month> Mar. </month> <title> 1997. </title> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Asarin et al. use BDDs to represent the finite number of values that clocks can assume in discrete timed automata <ref> [2] </ref>; however, the sizes of the BDDs are sensitive to the number of bits needed to represent the clock values. In contrast, our analysis is insensitive to the bit widths of the data variables, since these variables are generalized to unbounded integers.
Reference: [3] <author> D. A. Basin and N. Klarlund. </author> <title> Hardware verification using monadic second-order logic. </title> <editor> In P. Wolper, editor, </editor> <booktitle> Proc. Computer Aided Verification, volume 939 of Lecture Notes in Computer Science, </booktitle> <pages> pages 31-41. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1995. </year>
Reference-contexts: We were strongly influenced by the work embodied in the MONA tool, which translates formulas in the monadic second-order logic over strings into automata <ref> [3] </ref>. The authors show how this machinery can be used in a deductive framework to perform equivalence checking on iterated systems. The tool MOSEL follows the same approach as MONA [16].
Reference: [4] <author> B. Boigelot, L. Bronne, and S. Rassart. </author> <title> An improved reachability analysis method for strongly linear hybrid systems. </title> <editor> In O. Grumberg, editor, </editor> <booktitle> Proc. Computer Aided Verification, volume 1254 of Lecture Notes in Computer Science, </booktitle> <pages> pages 167-178, </pages> <address> Haifa, June 1997. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: One approach taken in the analysis of EFSMs, and in the related area of hybrid systems, is to represent sets of data values implicitly (typically with polyhedra or automata), but to represent control states explicitly <ref> [6, 1, 5, 4] </ref>. In all of these works, state enumeration proceeds by visiting the control states explicitly, one-by-one, accumulating implicitly the data values possible at each control state.
Reference: [5] <author> B. Boigelot and P. Godefroid. </author> <title> Symbolic verification of communication protocols with infinite states spaces using QDDs. </title> <editor> In R. Alur and T. A. Henzinger, editors, </editor> <booktitle> Proc. Computer Aided Verification, volume 1102 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-12, </pages> <address> New Brunswick, NJ, July 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: One approach taken in the analysis of EFSMs, and in the related area of hybrid systems, is to represent sets of data values implicitly (typically with polyhedra or automata), but to represent control states explicitly <ref> [6, 1, 5, 4] </ref>. In all of these works, state enumeration proceeds by visiting the control states explicitly, one-by-one, accumulating implicitly the data values possible at each control state.
Reference: [6] <author> B. Boigelot and P. Wolper. </author> <title> Symbolic verification with periodic sets. </title> <editor> In D. L. Dill, editor, </editor> <booktitle> Proc. Computer Aided Verification, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 55-67, </pages> <address> Stanford, CA, June 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: One approach taken in the analysis of EFSMs, and in the related area of hybrid systems, is to represent sets of data values implicitly (typically with polyhedra or automata), but to represent control states explicitly <ref> [6, 1, 5, 4] </ref>. In all of these works, state enumeration proceeds by visiting the control states explicitly, one-by-one, accumulating implicitly the data values possible at each control state.
Reference: [7] <author> A. Boudet and H. Comon. </author> <title> Diophantine equations, Presburger arithmetic and finite automata. </title> <booktitle> In Trees and Algebra in Programming - CAAP, volume 1059 of Lecture Notes in Computer Science, </booktitle> <pages> pages 30-43. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: One of the key components in our approach is a method due to Boudet and Comon to translate an arbitrary system of linear relations into an automaton recognizing integer tuple solutions of the system <ref> [7] </ref>. However, they do not apply their work to the analysis of EFSMs. We perform implicit state enumeration on any EFSM whose transition relation can be described in Presburger arithmetic. <p> Using this encoding for natural numbers, Boudet and Comon have given a simple procedure for constructing automata from Presburger formulas <ref> [7] </ref>. The constructed automaton accepts just those integer tuples that satisfy the corresponding formula. Figure 4 shows the automaton that recognizes the integer tuples satisfying the Presburger formula x 1 + x 2 = x 3 .
Reference: [8] <author> R. K. Brayton, G. D. Hachtel, A. Sangiovanni-Vincentelli, F. Somenzi, A. Aziz, S.-T. Cheng, S. Edwards, S. Khatri, Y. Kukimoto, A. Pardo, S. Qadeer, R. K. Ranjan, S. Sarwary, T. R. Shiple, G. Swamy, and T. Villa. </author> <title> VIS: A system for verification and synthesis. </title> <editor> In R. Alur and T. A. Henzinger, editors, </editor> <booktitle> Proceedings of the Conference on Computer-Aided Verification, volume 1102 of Lecture Notes in Computer Science, </booktitle> <pages> pages 428-432, </pages> <address> New Brunswick, NJ, July 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: We developed a package, written in C, to manipulate automata with BDD transitions. We incorporated this into the VIS program <ref> [8] </ref>, along with a front-end package that interprets a dialect of Verilog that includes wires carrying unbounded integer values and arithmetic modules that operate on them. We used the standard VIS program to characterize the BDD approach to state reachability for fixed width datapaths.
Reference: [9] <author> J. R. Buchi. </author> <title> On a decision method in restricted second order arithmetic. </title> <booktitle> In Proc. Int. Congress Logic, Methodology, and Philosophy of Science, </booktitle> <pages> pages 1-11, </pages> <address> Berkeley, CA, 1960. </address> <publisher> Stanford University Press. </publisher>
Reference-contexts: Presburger arithmetic is the first-order theory of natural numbers with comparison and addition, 3 and specifically without multiplication. For every Presburger formula there is a finite automaton that recognizes the integer tuples that satisfy the formula <ref> [9] </ref>. 4 This link between finite automata and Presburger arithmetic is what makes automata useful for verification of EFSMs.
Reference: [10] <author> T. Bultan, R. Gerber, and W. Pugh. </author> <title> Symbolic model checking of infinite state programs using presburger arithmetic. </title> <editor> In O. Grumberg, editor, </editor> <booktitle> Proc. Computer Aided Verification, volume 1254 of Lecture Notes in Computer Science, </booktitle> <pages> pages 400-411, </pages> <address> Haifa, June 1997. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Finally, by treating control variables as special cases of integers, Bultan et al. are able to treat control and data uniformly, using polyhedra as the underlying representation <ref> [10] </ref>. In practice, to avoid an explosion in the polyhedral representation, they distinguish control and data and explicitly visit control states one-by-one.
Reference: [11] <author> K.-T. Cheng and A. Krishnakumar. </author> <title> Automatic functional test generation using the extended finite state machine model. </title> <booktitle> In Proc. 30th Design Automat. Conf., </booktitle> <pages> pages 86-91, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: For example, a designer might construct a parameterized fl Visiting from the University of Texas, Austin 1 library component that can be instantiated with arbitrary width. One would like to verify all possible instantiations. Specifically, we model digital systems as extended finite state machines (EFSMs) <ref> [11] </ref>, which are FSMs interacting with datapaths. In EFSMs, the state variables are partitioned into control variables (variables over finite domains) and data variables (unbounded integers). The behavior of an EFSM is defined by a set of transitions, each of which updates the values of both control and data variables. <p> We conclude with a summary, evaluation, and future plans in Section 5. 2 Related Work There has been much activity over the last decade in the analysis of EFSMs and iterated systems. Cheng and Krishnakumar formally defined EFSMs with data variables that constitute an n-dimensional linear space <ref> [11, 18] </ref>. Their first paper addresses functional test generation while the second discusses the computation of reachable states using finite unions of convex polyhedra as the underlying representation.
Reference: [12] <author> O. Coudert, C. Berthet, and J. C. Madre. </author> <title> Verification of synchronous sequential machines based on symbolic execution. </title> <editor> In J. Sifakis, editor, </editor> <booktitle> Proceedings of the Workshop on Automatic Verification Methods for Finite State Systems, volume 407 of Lecture Notes in Computer Science, </booktitle> <pages> pages 365-373. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: 1 Introduction The BDD-based approach to functional verification of finite state systems has enjoyed some success. This approach proceeds by first building BDDs for the next state functions and then using implicit state enumeration to explore the state transition graph <ref> [12] </ref>. For systems with up to a few hundred flip-flops this technique can be vastly more efficient than techniques that manipulate states explicitly. However, this approach usually fails for systems with wide numeric datapaths because the BDDs become too large.
Reference: [13] <author> P. Godefroid and D. E. </author> <title> Long. Symbolic protocol verification with queue BDDs. </title> <booktitle> In Proc. Logic in Computer Science, </booktitle> <pages> pages 198-206, </pages> <month> July </month> <year> 1996. </year> <month> 15 </month>
Reference-contexts: In contrast, our analysis is insensitive to the bit widths of the data variables, since these variables are generalized to unbounded integers. Godefroid and Long use an extension of BDDs, called QBDDs, to analyze systems containing unbounded queues <ref> [13] </ref>. Their integrated handling of control and data in the context of queues motivated us to search for a similar mechanism in the context of EFSMs.
Reference: [14] <author> A. Gupta and A. L. Fisher. </author> <title> Representation and symbolic manipulation of linearly inductive boolean functions. </title> <booktitle> In Proc. Int'l Conf. on Computer-Aided Design, </booktitle> <pages> pages 192-199, </pages> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: The authors show how this machinery can be used in a deductive framework to perform equivalence checking on iterated systems. The tool MOSEL follows the same approach as MONA [16]. Closely related is the work by Gupta <ref> [14] </ref>; she introduces linear inductive functions, which are sequential counterparts to BDDs, to represent iterated systems. She uses LIFs to perform implicit state enumeration on these systems by successively unrolling the systems in time.
Reference: [15] <author> J. G. Henriksen, J. Jensen, M. Jtrgensen, N. Larlund, R. Paige, T. Rauhe, and A. Sandholm. Mona: </author> <title> Monadic second-order logic in practice. In Tools and Algorithms for the Construction and Analysis of Systems, </title> <booktitle> First International Workshop, TACAS '95, volume 1019 of Lecture Notes in Computer Science, </booktitle> <pages> pages 89-110. </pages> <publisher> Springer-Verlag, </publisher> <month> May </month> <year> 1995. </year>
Reference-contexts: The framework we use for the verification of iterated systems is the same as that independently reported by Kesten et al. [17]. Both our work and theirs build on the automata representation for iterated systems of Henriksen et al. <ref> [15] </ref>. However, whereas Henriksen uses a deductive framework, we and Kesten perform implicit state enumeration, generating each successive set of reachable states directly from prior sets of reachable states, without unrolling the system or introducing growing numbers of variables. <p> Each transition of an automaton must specify for which inputs the automaton is to follow that transition. When the letters of the alphabet are bit vectors with large dimension, the transition labels can get very complex. Following <ref> [15] </ref>, we use BDDs with multiple terminals as a practical implementation technique to efficiently represent the transitions of an automaton. Specifically, each state of an automaton points to a BDD that determines the next state as a function of the incoming bit vector. <p> Henriksen et al. show the formula that encodes the global transition relation, for all n, and they give a procedure to translate such formulas to automata <ref> [15] </ref>. Roughly speaking, the method used to create the global transition relation is to introduce a one-hot encoded variable i, define a single philosopher in terms of i, and then universally quantify i.
Reference: [16] <author> P. Kelb, T. Margaria, M. Mendler, and C. Gsottberger. MOSEL: </author> <title> A flexible toolset for monadic second-order logic. </title> <booktitle> In TACAS '97: Int'l Workshop on Tools and Algorithms for the Construction and Analysis of Systems, volume 1217 of Lecture Notes in Computer Science, </booktitle> <pages> pages 183-202. </pages> <publisher> Springer-Verlag, </publisher> <month> Apr. </month> <year> 1997. </year>
Reference-contexts: The authors show how this machinery can be used in a deductive framework to perform equivalence checking on iterated systems. The tool MOSEL follows the same approach as MONA <ref> [16] </ref>. Closely related is the work by Gupta [14]; she introduces linear inductive functions, which are sequential counterparts to BDDs, to represent iterated systems. She uses LIFs to perform implicit state enumeration on these systems by successively unrolling the systems in time.
Reference: [17] <author> Y. Kesten, O. Maler, M. Marcus, A. Pnueli, and E. Shahar. </author> <title> Symbolic model checking with rich assertional languages. </title> <editor> In O. Grumberg, editor, </editor> <booktitle> Proc. Computer Aided Verification, volume 1254 of Lecture Notes in Computer Science, </booktitle> <pages> pages 424-435. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1997. </year>
Reference-contexts: Second, one may want to verify a design for all possible widths of a datapath. The same automata-based approach can be applied to iterated systems, which are systems with arrays of identical FSMs. Although this application of automata was noted recently by other researchers <ref> [17] </ref>, we present here the first experimental evidence of the efficacy of this approach. In Section 2 we discuss related work on the analysis of EFSMs. <p> She uses LIFs to perform implicit state enumeration on these systems by successively unrolling the systems in time. The framework we use for the verification of iterated systems is the same as that independently reported by Kesten et al. <ref> [17] </ref>. Both our work and theirs build on the automata representation for iterated systems of Henriksen et al. [15].
Reference: [18] <author> A. Krishnakumar and K.-T. Cheng. </author> <title> On the computation of the set of reachable states of hybrid models. </title> <booktitle> In Proc. 31st Design Automat. Conf., </booktitle> <pages> pages 615-621, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: We conclude with a summary, evaluation, and future plans in Section 5. 2 Related Work There has been much activity over the last decade in the analysis of EFSMs and iterated systems. Cheng and Krishnakumar formally defined EFSMs with data variables that constitute an n-dimensional linear space <ref> [11, 18] </ref>. Their first paper addresses functional test generation while the second discusses the computation of reachable states using finite unions of convex polyhedra as the underlying representation.
Reference: [19] <author> R. P. Kurshan and K. L. McMillan. </author> <title> A structural induction theorem for processes. </title> <booktitle> In Proc. Eighth Symp. Princ. of Distributed Computing, </booktitle> <pages> pages 239-247, </pages> <year> 1989. </year>
Reference-contexts: An example of an iterated system, which we will use throughout this section, is the Dining Philosophers with Encyclopedia example of Kurshan and McMillan <ref> [19] </ref>. In this example, n philosophers sit in a ring; each philosopher can be in one of three possible states: THINK, EAT and READ. Philosopher i communicates with its left neighbor (philosopher i 1 mod n) and right neighbor (philosopher i + 1 mod n).
Reference: [20] <author> H. R. Lewis and C. H. Papadimitriou. </author> <title> Elements of the Theory of Computation. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1981. </year> <month> 16 </month>
Reference-contexts: This machine recognizes the language 1 1 ! 0 0 ! fl Given automata representing languages f and g, there are well known algorithms to build new automata to represent the sets f , f _ g, and f ^ g <ref> [20] </ref>. We can also existentially quantify particular components of the bit vectors, forming an automaton with an alphabet of smaller dimension. For example, existentially quantifying the first component of the above language yields a new language in only one dimension, the language 100 fl .
References-found: 20

