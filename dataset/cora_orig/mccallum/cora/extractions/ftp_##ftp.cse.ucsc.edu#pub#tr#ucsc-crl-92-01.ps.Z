URL: ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-92-01.ps.Z
Refering-URL: ftp://ftp.cse.ucsc.edu/pub/tr/README.html
Root-URL: http://www.cse.ucsc.edu
Title: Debugging Optimized Code Without Being Misled  
Author: Max Copperman - 
Address: Santa Cruz, CA 95064  
Affiliation: Board of Studies in Computer and Information Sciences University of California at Santa Cruz  
Abstract: Optimizing compilers produce code that impedes source-level debugging. Examples are given in which optimization changes the behavior of a program even when the optimizer is correct, showing that in some circumstances it is not possible to completely debug an unoptimized version of a program. Source-level debuggers designed for unoptimized code may mislead the debugger user when invoked on optimized code. One situation that can mislead the user is a mismatch between where the user expects a breakpoint to be located and the breakpoint's actual location. This mismatch may occur due to statement reordering and discontiguous code generated from a statement. This paper describes a mapping between statements and breakpoint locations that ameliorates this problem. The mapping enables debugger behavior on optimized code that approximates debugger behavior on unoptimized code closely enough that the user need not make severe changes in debugging strategies. Another situation that can mislead the user is when optimization has caused the value of a variable to be noncurrent | to differ from the value that would be predicted by a close reading of the source code. This paper gives and proves a method of determining when this has occurred, and shows how a debugger can describe the relevant effects of optimization. The determination method is more general than previously published methods. The information a compiler must make available to the debugger for this task is also described. Categories and Subject Descriptors: D.2.5 [Software Engineering]: Testing and Debugging | debugging aids; D.2.6 [Software Engineering]: Programming Environments; D.3.4 [Programming Languages]: Processors | code generation, compilers, optimization General Terms: Algorithms, Languages Additional Keywords and Phrases: debugging, compiler optimization, reaching definitions, noncurrent variables 
Abstract-found: 1
Intro-found: 1
Reference: [AU77] <author> A. V. Aho, J. D. Ullman, </author> <title> "Principles of Compiler Design," </title> <publisher> Addison-Wesley, </publisher> <address> Menlo Park, CA, </address> <year> 1977. </year>
Reference-contexts: V that ought to reach P are those that reach P in a strictly unoptimized version of the program. 5 The required sets of definitions of V that reach any point in a program (optimized or unoptimized) can be computed using slight modifications of standard compiler technology (Aho and Ullman <ref> [AU77] </ref>). If the sets of definitions of V that reach P differ in the optimized and unoptimized version of the program, then V is not current. The debugger can use the sets of definitions to describe, in source-level terms, why V is not current. <p> This also ensures that if only one definition (store) for a variable reaches B, it reaches along all paths to B. In the absence of pointers and array references, reaching definitions could be computed using a standard algorithm (Aho and Ullman <ref> [AU77] </ref>). This would produce at most one definition of a given variable at the exit of a block. Using such an algorithm, an assignment through a pointer or array reference would kill all pending definitions. This would destroy information required for currentness determination.
Reference: [ASU86] <author> A. V. Aho, R. Sethi, J. D. Ullman, </author> <booktitle> "Compilers Principles, Techniques, and Tools," </booktitle> <publisher> Addison-Wesley, </publisher> <address> Menlo Park, CA, </address> <year> 1986. </year>
Reference: [Bal69] <author> R. M. Balzer, </author> <title> "EXDAMS EXtendable Debugging and Monitoring System," </title> <booktitle> Proceedings of AFIPS Spring Joint Computer Conference, </booktitle> <volume> Vol 34 pp. </volume> <pages> 125-134, </pages> <year> 1969. </year>
Reference-contexts: At that point, z had the value 3.141 (set at line 370) and y had the value 17; y was set at line 506 to y+bar (w).'. This was called flowback analysis by Balzer <ref> [Bal69] </ref>, and has been investigated by others ([MC91], [Kor88]); reaching sets may be adaptable to this purpose. Another research direction is dynamic currentness determination, which is how a debugger can collect 38 8.
Reference: [CM91a] <author> M. Copperman, C. E. McDowell, </author> <title> "A Further Note on Hennessy's "Symbolic Debugging of Optimized Code", </title> <type> UCSC Technical Report UCSC-CRL-91-04, </type> <month> February </month> <year> 1991. </year> <note> Submitted for publication to ACM Transactions on Programming Languages and Systems </note>
Reference-contexts: Using any such mapping, optimization can cause a debugger to provide an unexpected and potentially misleading value when asked to display an endangered variable. A debugger must be able to determine the currentness of a variable if it is to provide truthful behavior on optimized code. Hennessy [Hen82] <ref> [CM91a] </ref> and Coutant et al [CMR88] give solutions to special cases of the currentness determination problem. Table 8.1 summarizes a general solution to the problem for sequential optimizations. These results hold in the presence of both local and global optimizations and require no information about which optimizations have been performed.
Reference: [CM91b] <author> M. Copperman, C. E. McDowell, </author> <title> "Debugging Optimized Code Without Surprises," </title> <booktitle> Proceedings of the Supercomputer Debugging Workshop , Albuquerque, </booktitle> <month> November </month> <year> 1991. </year>
Reference: [Cop90] <author> M. Copperman, </author> <title> "Source-Level Debugging of Optimized Code: Detecting Unexpected Data Values," </title> <institution> University of California, Santa Cruz technical report UCSC-CRL-90-23, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: If flP is not an alias for V in some particular execution, the value that V contains at the breakpoint came from whatever definition would have reached if flP were not present. Therefore, this definition must also be considered to reach B. This is treated more formally in <ref> [Cop90] </ref> pp. 110-112. For any language that allows such aliasing, the assumption of a single definition reaching along a given path does not hold. Our results hold for languages that allow aliasing with one restriction on the compiler.
Reference: [Cop92] <author> M. Copperman, </author> <title> "Source-Level Debugging of Optimized Code Without Surprises," </title> <type> Doctoral thesis, </type> <institution> unpublished draft from University of California, Santa Cruz, </institution> <year> 1992. </year>
Reference-contexts: When a Breakpoint has Moved 31 6 When a Breakpoint has Moved Semantic breakpoints introduce additional complexity into currentness determination. This section merely outlines the difficulties. For a more complete discussion of currentness at semantic breakpoints, see <ref> [Cop92] </ref>.
Reference: [CMR88] <author> D. Coutant, S. Meloy, M. </author> <title> Ruscetta "DOC: a Practical Approach to Source-Level Debugging of Globally Optimized Code," </title> <booktitle> Proceedings of the SIGPLAN `88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 125-134, </pages> <year> 1988. </year>
Reference-contexts: Only those effects of optimization that affect the validity of the user's inferences need to be reported by the debugger. As noted by Coutant et al <ref> [CMR88] </ref>, much of the optimization performed upon a program is irrelevant to the user. It is only optimization that affects user-visible entities, such as source code variables and statement flow-of-control, that the user needs to be informed about. <p> A debugger must be able to determine the currentness of a variable if it is to provide truthful behavior on optimized code. Hennessy [Hen82] [CM91a] and Coutant et al <ref> [CMR88] </ref> give solutions to special cases of the currentness determination problem. Table 8.1 summarizes a general solution to the problem for sequential optimizations. These results hold in the presence of both local and global optimizations and require no information about which optimizations have been performed.
Reference: [FM80] <author> P. H. Feiler, R. Medina-Mora, </author> <title> "An Incremental Programming Environment," </title> <institution> Carnegie Mellon University Computer Science Department Report, </institution> <month> April </month> <year> 1980. </year>
Reference: [Hen82] <author> J. Hennessy, </author> <title> "Symbolic Debugging of Optimized Code," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 4, No. 3, </volume> <pages> pp. 323-344, </pages> <year> 1982. </year>
Reference-contexts: Overview If the value in a variable's storage location is suitable to be displayed to the user, the variable is current. The remainder of this paper describes how to determine whether a variable is current at a breakpoint the problem of currentness determination, first introduced by Hennessy <ref> [Hen82] </ref>. The fundamental idea behind our solution to the currentness determination problem is the following: if the definitions of a variable V that "actually" reach a point P are not the ones that "ought" to reach P , V is not current at P . <p> In unoptimized code, at each breakpoint the expected value of every variable is identical to its actual value. In optimized code, as we have seen, the actual value of a variable at some point may differ from its expected value at that point. Hennessy <ref> [Hen82] </ref> introduced the terms current, noncurrent, and endangered to describe the relationship between a variable's actual value and its expected value at a valid breakpoint. This relationship is described on the basis of a static analysis, one that inherently cannot use information about how the breakpoint was reached. <p> Using any such mapping, optimization can cause a debugger to provide an unexpected and potentially misleading value when asked to display an endangered variable. A debugger must be able to determine the currentness of a variable if it is to provide truthful behavior on optimized code. Hennessy <ref> [Hen82] </ref> [CM91a] and Coutant et al [CMR88] give solutions to special cases of the currentness determination problem. Table 8.1 summarizes a general solution to the problem for sequential optimizations.
Reference: [Kor88] <author> B. Korel, </author> <title> "PELAS Program Error-Locating Assistant System," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 14, No. 9, </volume> <pages> pp. 1253-1260, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: At that point, z had the value 3.141 (set at line 370) and y had the value 17; y was set at line 506 to y+bar (w).'. This was called flowback analysis by Balzer [Bal69], and has been investigated by others ([MC91], <ref> [Kor88] </ref>); reaching sets may be adaptable to this purpose. Another research direction is dynamic currentness determination, which is how a debugger can collect 38 8. Summary the minimal execution history information needed to determine whether an endangered variable is current or noncurrent when execution is suspended at a breakpoint.
Reference: [MC88] <author> B. Miller, J. Choi, </author> <title> "A Mechanism for Efficient Debugging of Parallel Programs," </title> <booktitle> Proceedings of the SIGPLAN/SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pp. 125-134, </pages> <address> Madison, Wisconsin, </address> <year> 1988. </year>
Reference: [MC91] <author> B. Miller, J. Choi, </author> <title> "Techniques for Debugging Parallel Programs with Flowback Analysis," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 13, No. 4, </volume> <pages> pp. 491-530, </pages> <year> 1991. </year>
Reference: [Pic90] <author> D. Pickens, MetaWare Incorporated, </author> <title> Santa Cruz, CA, personal communication regarding the MetaWare High C compiler. </title>
Reference: [PS88] <author> L. L. Pollack, M. L. Soffa, </author> <title> "High Level Debugging with the Aid of an Incremental Optimizer," </title> <booktitle> Hawaii International Conference on System Sciences, </booktitle> <month> January </month> <year> 1988. </year>
Reference: [PS92] <author> L. L. Pollack, M. L. Soffa, </author> <title> "Incremental Global Reoptimization of Programs," </title> <institution> Draft from Department of Computer Science, University of Pittsburgh, </institution> <month> May </month> <year> 1991. </year> <note> To appear in ACM Transactions on Programming Languages and Systems in 1992. 40 References </note>
Reference: [Str91] <author> L. Streepy, </author> <title> "CXdb A New View On Optimization," </title> <booktitle> Proceedings of the Supercomputer Debugging Workshop , Albuquerque, </booktitle> <month> November </month> <year> 1991. </year>
Reference-contexts: It is inappropriate to associate every instruction generated from a statement with that statement for the purposes of setting breakpoints, because if the instructions are not contiguous, many breakpoints may be reached for a single statement. In contrast, Streepy <ref> [Str91] </ref> describes a source-code/breakpoint-location mapping that allows breakpoints to be set at various levels of granularity, including expressions, basic blocks, and subroutines. <p> The address of this instruction is a breakpoint location for S. 11 Where no confusion will result, the representative instruction itself may be referred to as the breakpoint location. The mapping described herein is not in conflict with that described by Streepy <ref> [Str91] </ref>; each enables debugger capabilities missing from the other. This paper does not concern itself further with breakpoints for language entities other than statements, except to state that the results hold in the presence of such breakpoints. <p> Choosing the store as the breakpoint location for variable modifications is crucial to the correctness of the work presented in the remainder of the paper. Additional breakpoints, such as those described by Streepy <ref> [Str91] </ref>, could easily be incorporated into this model. The remainder of this paper assumes only syntactic breakpoints are available, because space constraints do not permit a complete discussion of the additional complexity needed to handle semantic breakpoints. Section 1 briefly discusses the problems raised by semantic breakpoints.
Reference: [WS78] <author> H. S. Warren, Jr., H. P. Schlaeppi, </author> <title> "Design of the FDS interactive debugging system," </title> <institution> IBM Research Report RC7214, IBM Yorktown Heights, </institution> <month> July </month> <year> 1978. </year>
Reference: [Ze83a] <author> P. Zellweger, </author> <title> "Interactive Source-Level Debugging of Optimized Programs," </title> <institution> Research Report CSL-83-1 , Xerox Palo Alto Research Center, </institution> <address> Palo Alto, CA, </address> <month> Jan. </month> <year> 1983. </year>
Reference: [Ze83b] <author> P. Zellweger, </author> <title> "An Interactive High-Level Debugger for Control-Flow Optimized Programs," </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. 18, No. 8, </volume> <pages> pp. </pages> <month> 159-172 Aug. </month> <year> 1983. </year>
Reference: [Zel84] <author> P. Zellweger, </author> <title> "Interactive Source-Level Debugging of Optimized Programs," </title> <institution> Research Report CSL-84-5, Xerox Palo Alto Research Center, </institution> <address> Palo Alto, CA, </address> <month> May </month> <year> 1984. </year>
Reference-contexts: In that case, if the statement were moved out of the loop by optimization, it would be appropriate to set the breakpoint where it ended up, so the values the debugger displays are the actual values used in the expression. Zellweger <ref> [Zel84] </ref> introduced the terms syntactic and semantic breakpoints. If no code motion or elimination has occurred, these are identical. <p> The choice of a breakpoint location for a statement S affects the correspondence between the actual debugging context and the expected debugging context considerably. Zellweger <ref> [Zel84] </ref> has a discussion of possible semantic breakpoint locations for statements whose generated code is discontiguous. The view taken in this work is that the best breakpoint location for a programming language construct is the location that corresponds most closely to the source level view of the program.
Reference: [ZJ90] <author> L. W. Zurawski, R. E. Johnson, </author> <title> "Debugging Optimized Code With Expected Behavior," </title> <institution> Unpublished draft from University of Illinois at Urbana-Champaign Department of Computer Science, </institution> <month> August </month> <year> 1990. </year>
References-found: 22

