URL: http://www.cs.ucsd.edu/users/mihir/papers/compip.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/mihir/papers/complexity-papers.html
Root-URL: http://www.cs.ucsd.edu
Title: The Complexity of Decision versus Search  
Author: Mihir Bellare Shafi Goldwasser 
Keyword: NP-completeness, self-reducibility, interactive proofs, program checking, sparse sets, quadratic residuosity.  
Date: 1, February 1994.  September 1992  
Note: Appears in SIAM J. on Computing, Vol. 23, No.  
Abstract: A basic question about NP is whether or not search reduces in polynomial time to decision. We indicate that the answer is negative: under a complexity assumption (that deterministic and non-deterministic double-exponential time are unequal) we construct a language in NP for which search does not reduce to decision. These ideas extend in a natural way to interactive proofs and program checking. Under similar assumptions we present languages in NP for which it is harder to prove membership interactively than it is to decide this membership, and languages in NP which are not checkable. fl Department of Computer Science & Engineering, Mail Code 0114, University of California at San Diego, 9500 Gilman Drive, La Jolla, CA 92093. E-mail: mihir@cs.ucsd.edu. Part of this work was done while the author was at MIT, partially supported by NSF grant No. CCR-8719689 and DARPA grant No. N00014-89-J-1988. y MIT Laboratory for Computer Science, 545 Technology Square, Cambridge, MA 02139, USA. E-mail: shafi@theory.lcs.mit.edu. Partially supported by NSF grant 25801, DARPA 71949, the Princeton computer science department, and grant No. 86-00301 from the United States - Israel Binational Science Foundation (BSF), Jerusalem, Israel. 
Abstract-found: 1
Intro-found: 1
Reference: [An] <author> D. Angluin. </author> <title> Lecture Notes on the Complexity of Some Problems in Number Theory. </title> <type> Technical Report 243, </type> <institution> Dept. of Computer Science, Yale University, </institution> <month> August </month> <year> 1982. </year>
Reference-contexts: Their construction does not, however, extend to competitive interactive proofs, because the correctness of their checker uses the fact that a program (in contrast to a cheating prover) is history independent. To prove Theorem 6.3, we begin by recalling some basic number theoretic facts. We refer the reader to <ref> [An, NZ] </ref> for number-theoretic background and justification of these facts. For x 2 Z fl N we let Q N (x) = 0 if x is a quadratic residue mod N , and 1 otherwise.
Reference: [Al] <author> E. Allender. </author> <title> Limitations of the Upward Separation Technique. </title> <booktitle> Mathematical Systems Theory 24, </booktitle> <pages> 53-67, </pages> <year> 1991. </year>
Reference-contexts: Define L = fy:0 g (jyj)jyj : y 2 L 0 g, where g (k) = 2 2 k . We claim that L is uniformly log-sparse and L 2 NP P. y [HSI] claimed the converse as well, but Allender <ref> [Al] </ref> points out that their proof is flawed and the theorem cannot be proved using techniques that relativize. 11 Define A to be the algorithm which on input x 2 f0; 1g n behaves as follows. If n is not in the range of g then A outputs 0.
Reference: [BFL] <author> L. Babai, L. Fortnow and C. Lund. </author> <title> Non-deterministic exponential time has two-prover interactive protocols. </title> <booktitle> Computational Complexity 1, </booktitle> <pages> 3-40, </pages> <year> 1991. </year>
Reference-contexts: In the case of multi-prover proofs, Babai, Fortnow and Lund <ref> [BFL] </ref> show that exponential time provers suffice for exponential time languages. We stress that all these works are concerned with upper bounding the complexity of provers in an "absolute" sense. <p> In particular, results of [FRS] imply that the class of languages which possess checkers in contained in MIP " coMIP (where MIP is the class of languages possessing multi-prover interactive proofs of membership). We note that MIP = NEXP, by the result of <ref> [BFL] </ref>. Blum and Kannan [BK] showed that Check = frIP " cofrIP. It follows that checkable languages have deciders. For completeness, however, let us see this directly. Lemma 5.2 Suppose L has a checker. Then it has a decider. 19 Proof: Let C be a checker for L.
Reference: [BBFG] <author> R. Beigel, M. Bellare, J. Feigenbaum and S. Goldwasser. </author> <title> Languages that are Easier than their Proofs. </title> <booktitle> Proceedings of the 32nd Symposium on Foundations of Computer Science, IEEE, </booktitle> <year> 1991. </year>
Reference-contexts: Finally, Spielman [Sp] has constructed an uncheckable set in P 2 under the assumption that E 2 6= E Publication Notes. These results appeared in a preliminary form in [BG]. Later, merged with [BF], they appeared in <ref> [BBFG] </ref>. 1.6 Relations to other Notions We focus in this paper on (competitive) interactive proofs and checking. Related notions are function-restricted interactive proofs [BK], multi-prover interactive proofs [BGKW] and coherence [Ya]. Here we discuss how these notions relate to ours and also how our results impinge on them.
Reference: [BF] <author> R. Beigel and J. Feigenbaum. </author> <title> Improved Bounds on Coherence and Checkability. </title> <address> YALEU/DCS/TR-819, </address> <month> September 11, </month> <year> 1990. </year>
Reference-contexts: Blum and Kannan [BK] introduced the notion of program checkers (see Section 5 for full definitions). Negative results in this domain begin with Yao [Ya] who presented a language in deterministic space 2 n log log n that does not have a checker. Beigel and Feigenbaum <ref> [BF] </ref> and Krawczyk [Kr] improved this to deterministic space n log fl n . The question of whether there are languages of reasonable complexity that are not checkable was answered by [BF] under an assumption: they showed there was one such in NP provided non-deterministic triple exponential time is not contained <p> Beigel and Feigenbaum <ref> [BF] </ref> and Krawczyk [Kr] improved this to deterministic space n log fl n . The question of whether there are languages of reasonable complexity that are not checkable was answered by [BF] under an assumption: they showed there was one such in NP provided non-deterministic triple exponential time is not contained in bounded probabilistic triple exponential time. We improve the assumption to double exponential time. <p> Finally, Spielman [Sp] has constructed an uncheckable set in P 2 under the assumption that E 2 6= E Publication Notes. These results appeared in a preliminary form in [BG]. Later, merged with <ref> [BF] </ref>, they appeared in [BBFG]. 1.6 Relations to other Notions We focus in this paper on (competitive) interactive proofs and checking. Related notions are function-restricted interactive proofs [BK], multi-prover interactive proofs [BGKW] and coherence [Ya]. <p> We establish the main technical lemmas needed for our proofs in terms of the equivalent notion of "deciders" (cf. Section 3), and then use these lemmas to derive our 8 results on competitive interactive proofs and checking in a simple way. In particular, (improving <ref> [BF] </ref>; see below) we do show that if NEE 6 BPEE then there is a language in NP frIP. Competitive multi-prover proofs. One could define competitive multi-prover proofs. However, using techniques of [FRS], one can show that the corresponding class of languages is identical to frIP. Coherence. <p> If L is not coherent we say it is incoherent. Beigel and Feigenbaum <ref> [BF] </ref> prove the existence of incoherent languages in NP under the assumption that nondeterministic triple exponential time is not contained in bounded probabilistic triple exponential time. <p> If L is not coherent we say it is incoherent. Beigel and Feigenbaum [BF] prove the existence of incoherent languages in NP under the assumption that nondeterministic triple exponential time is not contained in bounded probabilistic triple exponential time. Since checkable languages and languages in frIP are coherent (cf. <ref> [Ya, BF] </ref>), they thereby establish the existence of uncheckable languages in NP, and languages in NP frIP, under the same assumption. One can show that if search reduces to decision for L, or L has a competitive interactive proof then also L is coherent. <p> For the results of line (4), see Theorems 2.9, 4.4, 5.3 and 3.6. For those of line (5), see the (theorem and) discussion at the end of Section 5. Finally, under the assumption NEEE fl 6 BPEEE fl , <ref> [BF] </ref> establish the following: 9 (6) NP 6 Coh. 2 Decision versus Search in NP In this section we present a simple construction of a language in NP for which search does not reduce to decision, assuming that EE 6= NEE. <p> If L is not coherent we say it is incoherent. Previous negative results on checking were established by first exhibiting incoherent sets and then exploiting Yao's observation that any incoherent set is uncheckable (cf. <ref> [Ya, BF] </ref>). We note that our (stronger) results are obtained more directly. Moreover, our techniques indicate that even within NP the class of coherent sets could be much "larger" than the class of checkable ones. Let us sketch why this is so. <p> Let us sketch why this is so. The "disjoint union" of languages A and B, denoted AB, is f0x : x 2 Ag [f1x : x 2 B g; this construct is widely used in complexity theory (eg. [BD, HH]). It is easy to see (cf. <ref> [BF] </ref>) that LL is coherent for any language L. It is also easy to see that the transformation L 7! LL preserves many complexity characteristics of L; for example, membership in NP; compNP; compIP; Check; frIP.
Reference: [BG] <author> M. Bellare and S. Goldwasser. </author> <title> The Complexity of Decision versus Search. </title> <note> MIT-LCS Technical Memo. TM-444, </note> <month> April </month> <year> 1991. </year>
Reference-contexts: Finally, Spielman [Sp] has constructed an uncheckable set in P 2 under the assumption that E 2 6= E Publication Notes. These results appeared in a preliminary form in <ref> [BG] </ref>. Later, merged with [BF], they appeared in [BBFG]. 1.6 Relations to other Notions We focus in this paper on (competitive) interactive proofs and checking. Related notions are function-restricted interactive proofs [BK], multi-prover interactive proofs [BGKW] and coherence [Ya].
Reference: [BP] <author> M. Bellare and E. Petrank. </author> <title> Making Zero-Knowledge Provers Efficient. </title> <booktitle> Proceedings of the 24th Annual Symposium on the Theory of Computing, ACM, </booktitle> <year> 1992. </year>
Reference-contexts: Shamir's result [Sh] implies that polynomial space provers suffice to prove PSPACE languages. The best upper bound on the complexity of a prover of a coNP language, due to Lund, Fortnow, Karloff and Nisan [LFKN], is probabilistic, polynomial time with a #P oracle. Bellare and Petrank <ref> [BP] </ref> investigate the complexity of zero-knowledge (ZK) provers, and indicate that such provers can be reasonably efficient; specifically, they show that any language possessing a statistical ZK interactive proof possesses one with a prover who is a probabilistic, polynomial time machine with access to an NP oracle.
Reference: [BCGL] <author> S. Ben-David, B. Chor, O. Goldreich and M. Luby. </author> <title> On the Theory of Average Case Complexity. </title> <journal> Journal of Computer and System Sciences 44(2), </journal> <pages> 193-219, </pages> <year> 1992. </year>
Reference-contexts: Decision versus Search in other settings. The usual reduction of search to decision has a strong sequential flavor, and Karp, Upfal and Wigderson [KUW] investigated the degree to which this is necessary. Ben-David, Chor, Goldreich and Luby <ref> [BCGL] </ref> investigate the "decision versus search" question in the context of average-case complexity.
Reference: [BGKW] <author> M. Ben-Or, S. Goldwasser, J. Kilian and A. Wigderson. </author> <title> Multiprover Interactive Proof Systems: How to Remove Intractability Assumptions. </title> <booktitle> Proceedings of the 20th Annual Symposium on the Theory of Computing, ACM, </booktitle> <year> 1988. </year>
Reference-contexts: These results appeared in a preliminary form in [BG]. Later, merged with [BF], they appeared in [BBFG]. 1.6 Relations to other Notions We focus in this paper on (competitive) interactive proofs and checking. Related notions are function-restricted interactive proofs [BK], multi-prover interactive proofs <ref> [BGKW] </ref> and coherence [Ya]. Here we discuss how these notions relate to ours and also how our results impinge on them. First, let us list the (complexity classes corresponding to) the notions in this area. The Complexity Classes in this area. <p> Thus, if L and L both have competitive interactive proofs then L has a checker, while we do not know whether or not every checkable language has a competitive interactive proof. Checkers are also related to multi-prover interactive proofs <ref> [BGKW] </ref>. In particular, results of [FRS] imply that the class of languages which possess checkers in contained in MIP " coMIP (where MIP is the class of languages possessing multi-prover interactive proofs of membership). We note that MIP = NEXP, by the result of [BFL].
Reference: [BK] <author> M. Blum and S. Kannan. </author> <title> Designing Programs that Check their Work. </title> <booktitle> Proceedings of the 21st Annual Symposium on the Theory of Computing, ACM, </booktitle> <year> 1989. </year>
Reference-contexts: Blum and Kannan <ref> [BK] </ref> introduced the notion of program checkers (see Section 5 for full definitions). Negative results in this domain begin with Yao [Ya] who presented a language in deterministic space 2 n log log n that does not have a checker. <p> These results appeared in a preliminary form in [BG]. Later, merged with [BF], they appeared in [BBFG]. 1.6 Relations to other Notions We focus in this paper on (competitive) interactive proofs and checking. Related notions are function-restricted interactive proofs <ref> [BK] </ref>, multi-prover interactive proofs [BGKW] and coherence [Ya]. Here we discuss how these notions relate to ours and also how our results impinge on them. First, let us list the (complexity classes corresponding to) the notions in this area. The Complexity Classes in this area. <p> Function-restricted interactive proof systems are a variant of interactive proof systems introduced by Blum and Kannan <ref> [BK] </ref>. Like competitive interactive proofs, they make the restriction that the honest prover be a probabilistic, polynomial time machine with access to an oracle for the language in question. But, in contrast to competitive interactive proofs, they also restrict the dishonest prover. <p> We note that L has a decider if and only if it is in function-restricted IP (cf. <ref> [BK] </ref>). So deciders are just a way of characterizing languages in frIP. They can also be viewed as "checkers for yes instances." They are weaker than multi-prover interactive proofs: the results of [FRS] imply that if L has a decider then it has a multi-prover interactive proof. <p> We do not, of course, know whether or not quadratic-residuosity has a competitive statistical ZK interactive proof given that we do not know whether or not it has a competitive interactive proof at all. 5 Program Checking Blum and Kannan <ref> [BK] </ref> introduced the notion of program checkers. Informally, a checker for a function f is a probabilistic, polynomial time oracle machine which receives as an oracle a program P which purports to compute f . The checker also receives an input x. <p> We also recall that the characteristic function of a language L is the function L : f0; 1g fl ! f0; 1g defined by L (x) = 1 if x 2 L and 0 otherwise. Definition 5.1 <ref> [BK] </ref> Let C be a probabilistic polynomial time oracle TM. <p> In particular, results of [FRS] imply that the class of languages which possess checkers in contained in MIP " coMIP (where MIP is the class of languages possessing multi-prover interactive proofs of membership). We note that MIP = NEXP, by the result of [BFL]. Blum and Kannan <ref> [BK] </ref> showed that Check = frIP " cofrIP. It follows that checkable languages have deciders. For completeness, however, let us see this directly. Lemma 5.2 Suppose L has a checker. Then it has a decider. 19 Proof: Let C be a checker for L.
Reference: [BD] <author> A. Borodin and A. Demers. </author> <title> Some Comments on Functional Self-Reducibility and the NP Hierarchy. </title> <institution> Cornell University Technical Report TR76-284, </institution> <year> 1976. </year>
Reference-contexts: However, the underlying language L in Valiant's result is easy; in fact, it equals f0; 1g fl . Borodin and Demers <ref> [BD] </ref> strengthen Valiant's result in this regard by showing that under the same assumption, there is a NP-relation for which L 2 NP P but search still does not reduce to decision for . Hartmanis and Hemachandra [HH] present results similar to Valiant's but assuming P 6= UP " coUP. <p> They also show that if E 6= NE then there is a NP-relation for which search does not reduce to decision; this is the same conclusion as in the above-mentioned result of Borodin and Demers <ref> [BD] </ref>, but under an assumption which is different from that of [BD] (but, again, not known to be either weaker or stronger). Finally, Spielman [Sp] has constructed an uncheckable set in P 2 under the assumption that E 2 6= E Publication Notes. <p> They also show that if E 6= NE then there is a NP-relation for which search does not reduce to decision; this is the same conclusion as in the above-mentioned result of Borodin and Demers <ref> [BD] </ref>, but under an assumption which is different from that of [BD] (but, again, not known to be either weaker or stronger). Finally, Spielman [Sp] has constructed an uncheckable set in P 2 under the assumption that E 2 6= E Publication Notes. These results appeared in a preliminary form in [BG]. <p> We now say what it means for search to reduce to decision for an NP-relation. An equivalent formulation of the definition that follows appears in <ref> [BD] </ref>. Definition 2.2 Suppose is an NP-relation and W () is a polynomial time oracle machine. Let L = L . We say that W is a witness finder if for each x 2 L it is the case that W L (x) 2 (x). <p> Let us sketch why this is so. The "disjoint union" of languages A and B, denoted AB, is f0x : x 2 Ag [f1x : x 2 B g; this construct is widely used in complexity theory (eg. <ref> [BD, HH] </ref>). It is easy to see (cf. [BF]) that LL is coherent for any language L. It is also easy to see that the transformation L 7! LL preserves many complexity characteristics of L; for example, membership in NP; compNP; compIP; Check; frIP.
Reference: [Co] <author> S. Cook. </author> <title> The Complexity of Theorem Proving Procedures. </title> <booktitle> Proceedings of the 3rd Annual Symposium on the Theory of Computing, ACM, </booktitle> <year> 1971. </year>
Reference-contexts: We note that if L is NP-complete, then for any NP-relation that defines L, it is the case that search reduces to decision for (a consequence of the "self-reducibility" and NP-completeness of SAT as well as certain features of the proof of Cook's theorem <ref> [Co] </ref>, this fact is one of the most basic and well-known ones in the theory of computation). In particular, by our definition, search certainly reduces to decision for any NP-complete language. So the "hard" problems (from the point of view of search versus decision) will necessarily be non-NP-complete.
Reference: [ESY] <author> S. Even, A. Selman and Y. Yacobi. </author> <title> The Complexity of Promise Problems with Applications to Public-Key Cryptography. </title> <booktitle> Information and Control 2, </booktitle> <pages> 159-173, </pages> <year> 1984. </year>
Reference-contexts: The difference is that in the former we begin with a "promise" that the input already belongs to some set, and we have only to "decide" whether or not it falls in a given subset of this set. Such problems have been considered in many works; eg. <ref> [ESY] </ref>. The formalization we use is different from (but equivalent to) the ones used in these works, and is as follows. The problem is specified by a pair of disjoint sets (A; B).
Reference: [FRS] <author> L. Fortnow, J. Rompel and M. Sipser. </author> <title> On the Power of Multiprover Interactive Protocols. </title> <booktitle> Proceedings of the 3rd Annual Conference on Structure in Complexity Theory, IEEE, </booktitle> <year> 1988. </year>
Reference-contexts: As we will see (cf. Lemma 4.3) it is the case that compIP frIP. Blum and Kannan also established that Check frIP. On the other hand, based on the techniques of <ref> [FRS] </ref>, one can show that frIP MIP. Function-restricted interactive proofs were introduced in order to relate program checking to interactive proofs. <p> In particular, (improving [BF]; see below) we do show that if NEE 6 BPEE then there is a language in NP frIP. Competitive multi-prover proofs. One could define competitive multi-prover proofs. However, using techniques of <ref> [FRS] </ref>, one can show that the corresponding class of languages is identical to frIP. Coherence. The notion of coherence was introduced by Yao [Ya]. <p> We note that L has a decider if and only if it is in function-restricted IP (cf. [BK]). So deciders are just a way of characterizing languages in frIP. They can also be viewed as "checkers for yes instances." They are weaker than multi-prover interactive proofs: the results of <ref> [FRS] </ref> imply that if L has a decider then it has a multi-prover interactive proof. For us the motivation of Definition 3.1 is to "generalize" the notion of a witness finder in the light of our proof of Lemma 2.8. <p> Thus, if L and L both have competitive interactive proofs then L has a checker, while we do not know whether or not every checkable language has a competitive interactive proof. Checkers are also related to multi-prover interactive proofs [BGKW]. In particular, results of <ref> [FRS] </ref> imply that the class of languages which possess checkers in contained in MIP " coMIP (where MIP is the class of languages possessing multi-prover interactive proofs of membership). We note that MIP = NEXP, by the result of [BFL].
Reference: [FGMSZ] <author> M. Furer, O. Goldreich, Y. Mansour, M. Sipser, and S. Zachos. </author> <title> On Completeness and Soundness in Interactive Proof Systems. </title> <booktitle> Advances in Comput. Research Vol. </booktitle> <volume> 5, </volume> <editor> S. Micali ed., </editor> <publisher> JAI Press Inc. </publisher> <pages> 25 </pages>
Reference-contexts: An interactive proof (P; V ) for L is said to have perfect completeness if the probability of acceptance in the completeness condition is 1. We know that any language L possessing an interactive proof also possesses one with perfect completeness <ref> [FGMSZ] </ref>. Does any language possessing a competitive interactive proof also possesses a competitive interactive proof with perfect completeness? (One of the motivations for this question is the fact that our competitive proof for the special case of quadratic residuosity in Section 6 does not possess perfect completeness). * Zero-knowledge.
Reference: [GMW] <author> O. Goldreich, S. Micali and A. Wigderson. </author> <title> Proofs that Yield Nothing but their Validity. </title> <journal> JACM, </journal> <month> July </month> <year> 1991. </year>
Reference-contexts: Such power is also sufficient for almost all of the languages in IP that have been closely examined (specifically, the languages of graph isomorphism, graph non-isomorphism <ref> [GMW] </ref>, and quadratic non-residuosity [GMR]). On the other hand all known interactive proofs for complete languages for coNP require the prover to do more than decide membership in the language. <p> The answer depends on the kind of zero-knowledge one considers and on the kind of cryptographic assumptions one is willing to make. Let us first consider computational ZK. The result of Goldreich, Micali and Wigderson <ref> [GMW] </ref> implies that NP-complete languages have competitive ZK interactive proofs, given the existence of 18 one-way functions (more generally, it implies that if search reduces to decision for L then L has a competitive ZK interactive proof, given the existence of one-way functions). <p> All statistical ZK languages known to possess competitive interactive proofs are also known to possess statistical ZK competitive interactive proofs (these languages are graph isomorphism <ref> [GMW] </ref>, graph non-isomorphism [GMW], and quadratic non-residuosity [GMR]). <p> All statistical ZK languages known to possess competitive interactive proofs are also known to possess statistical ZK competitive interactive proofs (these languages are graph isomorphism <ref> [GMW] </ref>, graph non-isomorphism [GMW], and quadratic non-residuosity [GMR]).
Reference: [GMR] <author> S. Goldwasser, S. Micali and C. Rackoff. </author> <title> The Knowledge Complexity of Interactive Proofs. </title> <journal> SIAM J. Computing 18(1), </journal> <pages> 186-208, </pages> <year> 1989. </year>
Reference-contexts: Such power is also sufficient for almost all of the languages in IP that have been closely examined (specifically, the languages of graph isomorphism, graph non-isomorphism [GMW], and quadratic non-residuosity <ref> [GMR] </ref>). On the other hand all known interactive proofs for complete languages for coNP require the prover to do more than decide membership in the language. Similarly, all known interactive proofs for the language of quadratic residuosity require the prover to do more than decide quadratic residuosity. <p> NP-proof systems, however, are very restrictive. It becomes natural to ask: would the prover's task be alleviated if the parties were allowed interaction and the proof was now only required to be correct with high probability? In other words, we now consider interactive proofs (cf. <ref> [GMR] </ref>). We recall that in an interactive proof both parties are allowed to be probabilistic and the parties are allowed to exchange messages, for a polynomial number of rounds, before the verifier decides whether or not to accept. <p> Yet, we do know of interactive proofs for 2 QNR where it suffices for the prover to be able to tell membership in QR (i.e., QNR does have competitive interactive proofs) <ref> [GMR] </ref>. On the other hand, there is no known interactive proof for QR where it suffices for the prover to be able to decide membership in QR (i.e QR is not known to have a competitive interactive proof). <p> Let us consider the interactive proofs known for membership both in QR and QNR in more detail. First for membership of (x; N ) in QNR, the following protocol is repeated k times (cf. <ref> [GMR] </ref>). The verifier tosses a coin c 2 f0; 1g. <p> We usually specify an NP proof system as a pair (P; V ) where P is a prover satisfying the completeness condition. Clearly, L 2 NP if and only if it possesses an NP proof system. 15 Interactive proofs, which were introduced by Goldwasser, Micali and Rackoff <ref> [GMR] </ref>, are a natural extension of such NP proof systems. Both parties are now allowed to be probabilistic. <p> The probabilities are over the random choices of both parties in this conversation). Definition 4.1 (Interactive Proofs <ref> [GMR] </ref>) Let (P; V ) be a pair of (probabilistic) functions. <p> All statistical ZK languages known to possess competitive interactive proofs are also known to possess statistical ZK competitive interactive proofs (these languages are graph isomorphism [GMW], graph non-isomorphism [GMW], and quadratic non-residuosity <ref> [GMR] </ref>). We do not, of course, know whether or not quadratic-residuosity has a competitive statistical ZK interactive proof given that we do not know whether or not it has a competitive interactive proof at all. 5 Program Checking Blum and Kannan [BK] introduced the notion of program checkers. <p> That R runs in probabilistic, polynomial time is clear. We can now proceed to describe the protocols. We begin by recalling (following <ref> [GMR] </ref>) the basic (competitive) protocol to prove non-residuosity. <p> Proof: The first two items follow from basic properties of modular residues, and we refer the reader to <ref> [GMR] </ref> for proofs. The last item is clear. We now proceed to the competitive interactive proof for QR s . We will use Protocol QNR as a subprotocol.
Reference: [HH] <author> J. Hartmanis, and L. Hemachandra. </author> <title> Complexity Classes without Machines. </title> <booktitle> Theoretical Computer Science 58, </booktitle> <pages> 129-142, </pages> <year> 1988. </year>
Reference-contexts: Borodin and Demers [BD] strengthen Valiant's result in this regard by showing that under the same assumption, there is a NP-relation for which L 2 NP P but search still does not reduce to decision for . Hartmanis and Hemachandra <ref> [HH] </ref> present results similar to Valiant's but assuming P 6= UP " coUP. Impagliazzo and Naor [IN] indicate that, at least in relativized worlds, the assumption P 6= NP " coNP is not necessary for the conclusion of Valiant's result. <p> Let us sketch why this is so. The "disjoint union" of languages A and B, denoted AB, is f0x : x 2 Ag [f1x : x 2 B g; this construct is widely used in complexity theory (eg. <ref> [BD, HH] </ref>). It is easy to see (cf. [BF]) that LL is coherent for any language L. It is also easy to see that the transformation L 7! LL preserves many complexity characteristics of L; for example, membership in NP; compNP; compIP; Check; frIP.
Reference: [HSI] <author> J. Hartmanis, V. Sewelson and N. Immerman. </author> <title> Sparse Sets in NP-P: EXPTIME versus NEXPTIME. </title> <booktitle> Information and Control 65, </booktitle> <pages> 158-181, </pages> <year> 1985. </year>
Reference-contexts: That is, L (n) is the number of strings in L which have length n, and a language is log-sparse if it contains at most O (log n) strings of length at most n. Log-sparse languages were used in <ref> [HSI] </ref> where they were called "super-sparse." The next definition formalizes the idea of being able to efficiently identify some super-set of a language, and then specifies the notion of "uniform log-sparseness" in which we are interested. <p> Let us end this section by stating a lemma which we will use later. This lemma generalizes work of Hartmanis, Sewelson and Immerman <ref> [HSI] </ref>, who showed that there is a log-sparse language in NP P if EE 6= NEE. y Log-sparseness is weaker than uniform log-sparseness in that no candidate selector is required, but it is easy to see that a uniformly log-sparse language in NP P nonetheless exists under the same assumption. <p> Assume EE 6= NEE and suppose L 0 2 NEEEE. Define L = fy:0 g (jyj)jyj : y 2 L 0 g, where g (k) = 2 2 k . We claim that L is uniformly log-sparse and L 2 NP P. y <ref> [HSI] </ref> claimed the converse as well, but Allender [Al] points out that their proof is flawed and the theorem cannot be proved using techniques that relativize. 11 Define A to be the algorithm which on input x 2 f0; 1g n behaves as follows. <p> We discussed the open questions in Section 4.4. Acknowledgments Many people pointed out to us the error in <ref> [HSI] </ref>: we thank Eric Allender, Juris Hartmanis, Jack Lutz, and Osamu Watanabe in this regard. We thank Muli Safra, Lance Fortnow and Jack Lutz for helpful discussions, and Silvio Micali for suggesting the term "competitive interactive proofs." We thank Oded Goldreich for many helpful comments on the paper.
Reference: [IN] <author> R. Impagliazzo and M. Naor. </author> <title> Decision Trees and Downward Closures. </title> <booktitle> Proceedings of the 3rd Annual Conference on Structure in Complexity Theory, IEEE, </booktitle> <year> 1988. </year>
Reference-contexts: Hartmanis and Hemachandra [HH] present results similar to Valiant's but assuming P 6= UP " coUP. Impagliazzo and Naor <ref> [IN] </ref> indicate that, at least in relativized worlds, the assumption P 6= NP " coNP is not necessary for the conclusion of Valiant's result.
Reference: [IS] <author> R. Impagliazzo and M. </author> <title> Sudan. </title> <type> Private communication, </type> <month> May </month> <year> 1991. </year>
Reference-contexts: The model of competitive interactive proofs that we introduce here is for the purpose of studying the complexity of provers in a different way; namely, in terms of the "comparative" complexity of proving versus deciding. Recent Work. Independently of this work, Impagliazzo and Sudan <ref> [IS] </ref> show that if NE 6= coNE then there is a language in NP for which search does not reduce to decision. Here the conclusion 7 is the same as in Theorem 1.1, but the assumption is different (and not known to be either weaker or stronger).
Reference: [IT] <author> R. Impagliazzo and G. Tardos. </author> <title> Decision Versus Search Problems in Super-Polynomial Time. </title> <booktitle> Proceedings of the 30th Symposium on Foundations of Computer Science, IEEE, </booktitle> <year> 1989. </year>
Reference-contexts: The usual reduction of search to decision has a strong sequential flavor, and Karp, Upfal and Wigderson [KUW] investigated the degree to which this is necessary. Ben-David, Chor, Goldreich and Luby [BCGL] investigate the "decision versus search" question in the context of average-case complexity. Impagliazzo and Tardos <ref> [IT] </ref> consider the decision versus search question in the exponential case, and present an oracle relative to which E = NE but there is an exponential time binary predicate whose search problem is not solvable in exponential time. The Complexity of Provers.
Reference: [KUW] <author> R. Karp, E. Upfal and A. Wigderson. </author> <title> The Complexity of Parallel Search. </title> <journal> J. Computer and System Sciences 36, </journal> <pages> 225-253, </pages> <year> 1988. </year>
Reference-contexts: Decision versus Search in other settings. The usual reduction of search to decision has a strong sequential flavor, and Karp, Upfal and Wigderson <ref> [KUW] </ref> investigated the degree to which this is necessary. Ben-David, Chor, Goldreich and Luby [BCGL] investigate the "decision versus search" question in the context of average-case complexity.
Reference: [Ki] <author> J. Kilian. </author> <title> Achieving Zero-Knowledge Robustly. </title> <booktitle> Advances in Cryptology - Crypto 90 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 537, </volume> <editor> A. J. Menezes and S. Van-stone ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: But we do know that the latter conclusion may be established with stronger assumptions such as the existence of "ideal" secure circuit evaluation or the existence of "oblivious transfer." This follows from the result of Kilian <ref> [Ki] </ref> (and we refer the reader to that paper for details on what exactly are these assumptions). All statistical ZK languages known to possess competitive interactive proofs are also known to possess statistical ZK competitive interactive proofs (these languages are graph isomorphism [GMW], graph non-isomorphism [GMW], and quadratic non-residuosity [GMR]).
Reference: [KA] <author> K. Kompella and L. Adleman. </author> <title> Fast Checkers for Cryptography. </title> <booktitle> Advances in Cryptology - Crypto 90 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 537, </volume> <editor> A. J. Menezes and S. Vanstone ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Theorem 6.3 Let s be an integer 1. Then the promise problem (QR s ; QNR s ) possesses a competitive interactive proof. In related work, Kompella and Adleman <ref> [KA] </ref> present checkers for this same special case of quadratic residuosity when the modulus is the product of a constant number of primes (i.e. they present checkers for the promise problem (QR s ; QNR s )).
Reference: [Kr] <author> H. Krawczyk. </author> <type> Personal communication. </type>
Reference-contexts: Blum and Kannan [BK] introduced the notion of program checkers (see Section 5 for full definitions). Negative results in this domain begin with Yao [Ya] who presented a language in deterministic space 2 n log log n that does not have a checker. Beigel and Feigenbaum [BF] and Krawczyk <ref> [Kr] </ref> improved this to deterministic space n log fl n .
Reference: [La] <author> R. Ladner. </author> <title> On the Structure of Polynomial Time Reducibility. </title> <journal> J. Assoc. Comput. Mach. </journal> <volume> 22, </volume> <pages> 155-171, </pages> <year> 1975. </year>
Reference-contexts: By Lemma 2.8, search cannot reduce to decision for L. Note that the fact that search does not reduce to decision for L implies that L is not NP-complete. The existence of a non NP-complete language in NP P can however be established assuming only P 6= NP (cf. <ref> [La] </ref>). 3 Deciders and their Properties Before extending the ideas of the previous section to interactive proofs and checking, we pause to develop some technical materiel. This materiel will be useful in proving the results of later sections. <p> We thank Muli Safra, Lance Fortnow and Jack Lutz for helpful discussions, and Silvio Micali for suggesting the term "competitive interactive proofs." We thank Oded Goldreich for many helpful comments on the paper. We thank Satish Thate for 24 drawing our attention to the results of <ref> [La] </ref> mentioned in Section 2. Finally we thank a pair of (anonymous) referees for many valuable comments on the paper.
Reference: [LFKN] <author> C. Lund, L. Fortnow, H. Karloff and N. Nisan. </author> <title> Algebraic Methods for Interactive Proof Systems. </title> <booktitle> Proceedings of the 31st Symposium on Foundations of Computer Science, IEEE, </booktitle> <year> 1990. </year>
Reference-contexts: Let us describe some of them. Shamir's result [Sh] implies that polynomial space provers suffice to prove PSPACE languages. The best upper bound on the complexity of a prover of a coNP language, due to Lund, Fortnow, Karloff and Nisan <ref> [LFKN] </ref>, is probabilistic, polynomial time with a #P oracle. <p> The addition of interaction and randomness, however, seems to add significantly to the language recognition power of the system. It was established by Lund, Fortnow, Karloff and Nisan <ref> [LFKN] </ref> that IP (the class of languages possessing interactive proofs of membership) contains the polynomial time hierarchy, and Shamir [Sh] extended this to show that IP equals PSPACE. y When we say that this function is probabilistic we mean that to any x; c party A actually associates a distribution on
Reference: [NZ] <author> I. Niven and H. Zuckerman. </author> <title> An Introduction to the theory of Numbers. </title> <publisher> John Wiley and Sons, </publisher> <address> NY 1960. </address>
Reference-contexts: Their construction does not, however, extend to competitive interactive proofs, because the correctness of their checker uses the fact that a program (in contrast to a cheating prover) is history independent. To prove Theorem 6.3, we begin by recalling some basic number theoretic facts. We refer the reader to <ref> [An, NZ] </ref> for number-theoretic background and justification of these facts. For x 2 Z fl N we let Q N (x) = 0 if x is a quadratic residue mod N , and 1 otherwise.
Reference: [Se] <author> A. Selman. </author> <title> Natural Self-Reducible Sets. </title> <journal> SIAM J. Comput. </journal> <volume> 17(5), </volume> <pages> 989-996, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: The assumption P 6= NP suffices to indicate that the "usual" method of self-reduction (where one constructs a witness bit-by-bit, given an oracle for the language) may not always work: Selman <ref> [Se] </ref> shows that under this assumption there is a NP-relation for which L 2 NP P but, given a pair of strings (x; u) and an oracle for L , it is impossible to decide in polynomial time whether or not there is an extension of u which is a -witness
Reference: [Sh] <author> A. Shamir. IP=PSPACE. </author> <booktitle> Proceedings of the 31st Symposium on Foundations of Computer Science, IEEE, </booktitle> <year> 1990. </year>
Reference-contexts: The Complexity of Provers. Several recent works present results on the complexity of provers in interactive proofs. Let us describe some of them. Shamir's result <ref> [Sh] </ref> implies that polynomial space provers suffice to prove PSPACE languages. The best upper bound on the complexity of a prover of a coNP language, due to Lund, Fortnow, Karloff and Nisan [LFKN], is probabilistic, polynomial time with a #P oracle. <p> The addition of interaction and randomness, however, seems to add significantly to the language recognition power of the system. It was established by Lund, Fortnow, Karloff and Nisan [LFKN] that IP (the class of languages possessing interactive proofs of membership) contains the polynomial time hierarchy, and Shamir <ref> [Sh] </ref> extended this to show that IP equals PSPACE. y When we say that this function is probabilistic we mean that to any x; c party A actually associates a distribution on strings, and A (x; c) is a random element of this distribution. 16 4.2 Competitive Interactive Proofs A basic
Reference: [Sp] <author> D. Spielman. </author> <title> Private communication via Beigel and Feigenbaum, </title> <month> June </month> <year> 1991. </year>
Reference-contexts: Finally, Spielman <ref> [Sp] </ref> has constructed an uncheckable set in P 2 under the assumption that E 2 6= E Publication Notes. These results appeared in a preliminary form in [BG].
Reference: [Va] <author> L. Valiant. </author> <title> On the Relative Complexity of Checking and Evaluating. </title> <institution> University of Leeds Technical Report LS29JT, </institution> <month> October </month> <year> 1974. </year> <month> 26 </month>
Reference-contexts: We stress that all these results are about search versus decision for NP-relations, not NP-languages. So, in that sense, the conclusions are weaker than ours. Let us now describe some of this work. In what follows we let denote a polynomial time computable binary predicate. 6 Valiant <ref> [Va] </ref> appears to have been the first to indicate that there are NP-relations for which search is unlikely to reduce to decision; specifically, assuming P 6= NP " coNP, he presents a particular NP-relation with the property that search does not reduce to decision for . <p> We note, in this context, that there are languages (such as f0; 1g fl ) which are easy but have an associated search problem which is hard <ref> [Va] </ref>, and we certainly don't wish to think of search as being harder than decision for these languages. Appropriately, search does reduce to decision for these languages according to our definition.
Reference: [Ya] <author> A. Yao. </author> <title> Coherent Functions and Program Checkers. </title> <booktitle> Proceedings of the 22nd Annual Symposium on the Theory of Computing, ACM, </booktitle> <year> 1990. </year> <month> 27 </month>
Reference-contexts: Blum and Kannan [BK] introduced the notion of program checkers (see Section 5 for full definitions). Negative results in this domain begin with Yao <ref> [Ya] </ref> who presented a language in deterministic space 2 n log log n that does not have a checker. Beigel and Feigenbaum [BF] and Krawczyk [Kr] improved this to deterministic space n log fl n . <p> These results appeared in a preliminary form in [BG]. Later, merged with [BF], they appeared in [BBFG]. 1.6 Relations to other Notions We focus in this paper on (competitive) interactive proofs and checking. Related notions are function-restricted interactive proofs [BK], multi-prover interactive proofs [BGKW] and coherence <ref> [Ya] </ref>. Here we discuss how these notions relate to ours and also how our results impinge on them. First, let us list the (complexity classes corresponding to) the notions in this area. The Complexity Classes in this area. <p> Competitive multi-prover proofs. One could define competitive multi-prover proofs. However, using techniques of [FRS], one can show that the corresponding class of languages is identical to frIP. Coherence. The notion of coherence was introduced by Yao <ref> [Ya] </ref>. <p> If L is not coherent we say it is incoherent. Beigel and Feigenbaum [BF] prove the existence of incoherent languages in NP under the assumption that nondeterministic triple exponential time is not contained in bounded probabilistic triple exponential time. Since checkable languages and languages in frIP are coherent (cf. <ref> [Ya, BF] </ref>), they thereby establish the existence of uncheckable languages in NP, and languages in NP frIP, under the same assumption. One can show that if search reduces to decision for L, or L has a competitive interactive proof then also L is coherent. <p> If L is not coherent we say it is incoherent. Previous negative results on checking were established by first exhibiting incoherent sets and then exploiting Yao's observation that any incoherent set is uncheckable (cf. <ref> [Ya, BF] </ref>). We note that our (stronger) results are obtained more directly. Moreover, our techniques indicate that even within NP the class of coherent sets could be much "larger" than the class of checkable ones. Let us sketch why this is so.
References-found: 34

