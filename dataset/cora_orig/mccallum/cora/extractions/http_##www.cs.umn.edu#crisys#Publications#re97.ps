URL: http://www.cs.umn.edu/crisys/Publications/re97.ps
Refering-URL: http://www.cs.umn.edu/crisys/pubs.htm
Root-URL: http://www.cs.umn.edu
Email: heimdahl@cs.umn.edu  dkeenan@redwood.dn.hac.com  
Title: Generating Code from Hierarchical State-Based Requirements  
Author: Mats P.E. Heimdahl David J. Keenan 
Address: Minneapolis, MN 55455  16800 E. Centretech Pkwy, Bldg. 485, M/S 5M-82 Denver, CO 80011-9046  
Affiliation: University of Minnesota, Institute of Technology Department of Computer Science, 4-192 EE/CS Bldg.  Hughes Information Technology Systems  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> R. Balzer. </author> <title> A fifteen year perspective on automatic programming. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 11(11) </volume> <pages> 1257-1267, </pages> <month> November </month> <year> 1985. </year>
Reference-contexts: The following overview is by no means an exhaustive de scription of such systems, but rather a brief summary of some of the main transformational approaches. Early transformational systems, such as the TI (Transformational Implementation) system <ref> [1] </ref>, CIP (Computer-aided, Intuition-guided Programming) [2], and KIDS (Kestrel Interactive Development System) [16], were designed for use in general purpose programming. These types of systems are usually based upon wide spectrum languages that are iteratively transformed into lower level constructs.
Reference: [2] <author> F. L. Bauer, B. Moller, M. Partsch, and P. Pepper. </author> <title> Formal program construction by transformations-computer-aided, </title> <journal> intuition-guided programming. IEEE Transactions on Software Engineering, </journal> <volume> 15(2) </volume> <pages> 165-180, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: The following overview is by no means an exhaustive de scription of such systems, but rather a brief summary of some of the main transformational approaches. Early transformational systems, such as the TI (Transformational Implementation) system [1], CIP (Computer-aided, Intuition-guided Programming) <ref> [2] </ref>, and KIDS (Kestrel Interactive Development System) [16], were designed for use in general purpose programming. These types of systems are usually based upon wide spectrum languages that are iteratively transformed into lower level constructs.
Reference: [3] <author> S. Gerhart, D. Craigen, and T. Ralston. </author> <title> Experience with formal methods in critical systems. </title> <journal> IEEE Software, </journal> <volume> vol-11(1):21-39, </volume> <month> January </month> <year> 1994. </year>
Reference-contexts: In RSML, on the other hand, the state machines are used to model the behavior of the physical components in a system: the states are used to visualize the system state. During a large case study (TCAS) <ref> [3, 4, 15] </ref>, we found that using the state machines to highlight the state of the system made it easy for the engineers (domain experts) such as avionics engineers, pilots, air frame manufacturers, and FAA representatives to understand and validate the requirements specification.
Reference: [4] <author> S. Gerhart, D. Craigen, and T. Ralston. </author> <title> Formal methods reality check: Industrial usage. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 90-98, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: In RSML, on the other hand, the state machines are used to model the behavior of the physical components in a system: the states are used to visualize the system state. During a large case study (TCAS) <ref> [3, 4, 15] </ref>, we found that using the state machines to highlight the state of the system made it easy for the engineers (domain experts) such as avionics engineers, pilots, air frame manufacturers, and FAA representatives to understand and validate the requirements specification.
Reference: [5] <author> D. Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 231-274, </pages> <year> 1987. </year>
Reference-contexts: The language is based on hierarchical finite state machines and is in many ways similar to Statecharts by David Harel. For example, RSML supports parallelism, hierarchies, and guarded transitions borrowed from statecharts (Figure 1) <ref> [5, 8] </ref>. Transition (s): ESL-4 ! ESL-2 Location: Own-Aircraft .
Reference: [6] <author> D. Harel, H. Lachover, A. Naamad, A. Pnueli, M. Politi, R. Sherman, A. Shtull-Trauring, and M. Trakhtenbrot. Statemate: </author> <title> A working environment for the development of complex reactive systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(4), </volume> <month> April </month> <year> 1990. </year>
Reference-contexts: The level of automation of such general-purpose systems varies, but it seems unlikely that a fully automatic transformational system can be built using this approach. A different approach to code generation is taken by the Statemate system <ref> [6, 7, 12] </ref>. Statemate is a system for developing software for reactive systems that supports automatic generation of C, Ada, or VHDL code.
Reference: [7] <author> D. Harel and A. Naamad. </author> <title> The STATEMATE semantics of Statecharts. </title> <type> Technical Report CS95-31, </type> <institution> The Weizmann Institute of Science, </institution> <month> October </month> <year> 1995. </year>
Reference-contexts: The level of automation of such general-purpose systems varies, but it seems unlikely that a fully automatic transformational system can be built using this approach. A different approach to code generation is taken by the Statemate system <ref> [6, 7, 12] </ref>. Statemate is a system for developing software for reactive systems that supports automatic generation of C, Ada, or VHDL code.
Reference: [8] <author> D. Harel and A. Pnueli. </author> <title> On the development of reactive systems. </title> <editor> In K.R. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, </booktitle> <pages> pages 477-498. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: The language is based on hierarchical finite state machines and is in many ways similar to Statecharts by David Harel. For example, RSML supports parallelism, hierarchies, and guarded transitions borrowed from statecharts (Figure 1) <ref> [5, 8] </ref>. Transition (s): ESL-4 ! ESL-2 Location: Own-Aircraft .
Reference: [9] <author> D. Harel, A. Pnueli, J.P. Schmidt, and R. Sher-man. </author> <title> On the formal semantics of statecharts (extended abstract). </title> <booktitle> In 2nd Symposium on Logic in Computer Science, </booktitle> <pages> pages 54-64, </pages> <address> Ithaca, NY, </address> <year> 1987. </year>
Reference-contexts: Although we are using a different notation, the basic ideas for the formalization of the hierarchical structure of the state machines is borrowed from Harel et al. <ref> [9] </ref>.
Reference: [10] <author> M. P.E. Heimdahl and N.G. Leveson. </author> <title> Completeness and Consistency Analysis of State-Based Requirements. </title> <type> Technical Report CPS-94-52, </type> <institution> Michi-gan State University, </institution> <month> October </month> <year> 1994. </year> <note> Accepted for publication in IEEE Transactions on Software En-gineeriring. </note>
Reference-contexts: Furthermore, we have developed a collection of automated analysis procedures that check an RSML specification for desirable properties such as completeness, consistency, and determinism <ref> [10, 11] </ref>. However, even if a requirements specification is readable, understandable, and can be shown to be complete and consistent, designing and developing production quality code from such a black-box high-level specification can be a time consuming and error prone process.
Reference: [11] <author> M. P.E. Heimdahl and N.G. Leveson. </author> <title> Completeness and Consistency Analysis of State-Based Requirements. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> TSE-22(6):363-377, </volume> <month> June </month> <year> 1996. </year> <title> [12] i Logix. </title> <booktitle> The languages of Statemate, </booktitle> <month> March </month> <year> 1987. </year>
Reference-contexts: Furthermore, we have developed a collection of automated analysis procedures that check an RSML specification for desirable properties such as completeness, consistency, and determinism <ref> [10, 11] </ref>. However, even if a requirements specification is readable, understandable, and can be shown to be complete and consistent, designing and developing production quality code from such a black-box high-level specification can be a time consuming and error prone process. <p> Copyright 1997 by The Institute of Electrical and Electronics Engineering, Inc. All rights reserved. ical functions defined by the state transitions in the model <ref> [11] </ref>. We have developed a tool that translates an RSML specification to executable code. The translation closely follows the formal semantics of RSML and, thus, makes verification of the correctness of the generated code simple.
Reference: [13] <author> N. G. Leveson, M. Heimdahl, H. Hildreth, and J. Reese. </author> <title> TCAS II Requirements Specification. </title>
Reference-contexts: To evaluate our approach and to get an indication of how automatically generated code compares to manually written code, we performed some small case studies. We applied our technique to a subset of the TCAS II requirements specification <ref> [13, 15] </ref>.
Reference: [14] <author> N. G. Leveson, M. P.E. Heimdahl, H. Hildreth, J. Reese, and R. Ortega. </author> <title> Experiences using State-charts for a system requirements specification. </title> <booktitle> In Proceedings of the Sixth International Workshop on Software Specification and Design, </booktitle> <pages> pages 31-41, </pages> <year> 1991. </year>
Reference-contexts: In a previous investigation, the Irvine Safety Research Group, under the leadership of Dr. Nancy Leveson, developed a requirements specification language called the Requirements State Machine Language (RSML) suitable for the specification of safety-critical control embedded systems <ref> [14, 15] </ref>. To make RSML suitable as a requirements specification language usable by all stake holders in a specification effort, the syntax and semantics were developed with readability, understandability, and ease of use in mind. <p> The usefulness of the language was demonstrated through the successful development of a requirements specification for a large commercial avionics system called TCAS II (Traffic alert and Collision Avoidance System II) <ref> [14, 15] </ref>. Furthermore, we have developed a collection of automated analysis procedures that check an RSML specification for desirable properties such as completeness, consistency, and determinism [10, 11].
Reference: [15] <author> N. G. Leveson, M. P.E. Heimdahl, H. Hildreth, and J. D. Reese. </author> <title> Requirements specification for process-control systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(9), </volume> <month> September </month> <year> 1994. </year>
Reference-contexts: In a previous investigation, the Irvine Safety Research Group, under the leadership of Dr. Nancy Leveson, developed a requirements specification language called the Requirements State Machine Language (RSML) suitable for the specification of safety-critical control embedded systems <ref> [14, 15] </ref>. To make RSML suitable as a requirements specification language usable by all stake holders in a specification effort, the syntax and semantics were developed with readability, understandability, and ease of use in mind. <p> The usefulness of the language was demonstrated through the successful development of a requirements specification for a large commercial avionics system called TCAS II (Traffic alert and Collision Avoidance System II) <ref> [14, 15] </ref>. Furthermore, we have developed a collection of automated analysis procedures that check an RSML specification for desirable properties such as completeness, consistency, and determinism [10, 11]. <p> In RSML, on the other hand, the state machines are used to model the behavior of the physical components in a system: the states are used to visualize the system state. During a large case study (TCAS) <ref> [3, 4, 15] </ref>, we found that using the state machines to highlight the state of the system made it easy for the engineers (domain experts) such as avionics engineers, pilots, air frame manufacturers, and FAA representatives to understand and validate the requirements specification. <p> The reason for this, we believe, is that an RSML specification is conceptually close to the application domain and becomes easier to validate. For a thorough discussion on this topic, the reader is referred to <ref> [15] </ref>. This difference in modeling approach leads to a different approach to code generation. While Statemate, for example, bases its code generation on stepwise refinement, we are generating all code directly from the state machines with fully automated transformations that can be proven correct. <p> A macro is simply a named and/or table defined elsewhere in the document. A detailed description of the full notation can be found in <ref> [15] </ref>. 2.1 A Functional Framework The behavior of a finite-state machine can be formally defined using a next-state relation. In RSML, this relation is modeled by transitions and the sequencing of events. Thus, one can view a graphical RSML specification as the definition of the mathematical next-state relation F . <p> To evaluate our approach and to get an indication of how automatically generated code compares to manually written code, we performed some small case studies. We applied our technique to a subset of the TCAS II requirements specification <ref> [13, 15] </ref>.
Reference: [16] <author> D. R. Smith. Kids: </author> <title> A semiautomatic program de-velopment system. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(9) </volume> <pages> 1024-1043, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: The following overview is by no means an exhaustive de scription of such systems, but rather a brief summary of some of the main transformational approaches. Early transformational systems, such as the TI (Transformational Implementation) system [1], CIP (Computer-aided, Intuition-guided Programming) [2], and KIDS (Kestrel Interactive Development System) <ref> [16] </ref>, were designed for use in general purpose programming. These types of systems are usually based upon wide spectrum languages that are iteratively transformed into lower level constructs.
Reference: [17] <author> Interview with D. Bogden. </author> <title> Reliability in the real world of embedded automotive software. </title>
Reference-contexts: In many applications even using a compiler to translate from a high-level language such as C++ or Ada leads to unacceptably large and inefficient executables. Highly optimized hand coded assembly is still used in many time and space critical applications, for example, in the automotive industry <ref> [17] </ref>. Nevertheless, our goal is to be able to generate code that is efficient enough to be used in all but the most time and space critical applications.
References-found: 16

