URL: http://www.cs.wustl.edu/cs/techreports/1995/wucs-95-24.ps.Z
Refering-URL: http://www.cs.wustl.edu/cs/cs/publications.html
Root-URL: 
Title: Self-Stabilization by Window Washing  
Author: Adam M. Costello and George Varghese wucs-- 
Note: This work supported by a grant from the NSF.  
Address: Campus Box 1045  One Brookings Drive St. Louis, MO 63130-4899  
Affiliation: Department of Computer Science  Washington University  
Date: 13 Dec 1995  
Abstract: A useful way to design simple and robust protocols is to make them self-stabilizing. We describe a new general technique for self-stabilization called window washing. We apply this technique to generalized sliding window protocols that work on a number of topologies. This results in simple, efficient, and self-stabilizing protocols. As far as we know, both window washing and generalized sliding window protocols are new ideas. Our protocols can be used for data links, reliable broadcast, and flow control. 
Abstract-found: 1
Intro-found: 1
Reference: [AKY90] <author> Yehuda Afek, Shay Kutten, and Moti Yung. </author> <title> Memory-efficient self-stabilization on general networks. </title> <booktitle> In Proc. 4th Workshop on Distributed Algorithms, </booktitle> <pages> pages 15-28, </pages> <address> Italy, </address> <month> September </month> <year> 1990. </year> <note> Springer-Verlag (LNCS 486). </note>
Reference-contexts: Their general transformation is expensive; hence more efficient and less general techniques are useful. Tech 1 2 Costello and Varghese niques that transform any locally checkable protocol into a stabilizing equivalent are given in <ref> [AKY90, APV91, Var93] </ref>. However, our work on WW applies to protocols that are not locally checkable. Gouda and Multari [GM90] describe a two-node sliding protocol using unbounded integers. Real protocols require bounded integers. Spinelli [Spi93] describes a pair of two-node self-stabilizing sliding window protocols with bounded counters.
Reference: [APV91] <author> Baruch Awerbuch, Boaz Patt-Shamir, and George Varghese. </author> <title> Self-stabilization by local checking and correction. </title> <booktitle> In Proc. 32nd IEEE Symp. on Foundations of Computer Science, </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: Their general transformation is expensive; hence more efficient and less general techniques are useful. Tech 1 2 Costello and Varghese niques that transform any locally checkable protocol into a stabilizing equivalent are given in <ref> [AKY90, APV91, Var93] </ref>. However, our work on WW applies to protocols that are not locally checkable. Gouda and Multari [GM90] describe a two-node sliding protocol using unbounded integers. Real protocols require bounded integers. Spinelli [Spi93] describes a pair of two-node self-stabilizing sliding window protocols with bounded counters.
Reference: [Dij74] <author> Edsger W. Dijkstra. </author> <title> Self stabilization in spite of distributed control. </title> <journal> Comm. of the ACM, </journal> <volume> 17 </volume> <pages> 643-644, </pages> <year> 1974. </year> <note> Self-Stabilization by Window Washing 11 </note>
Reference-contexts: Previous Work Self-stabilizing protocols were introduced by Dijkstra <ref> [Dij74, Sch93] </ref>. There have been few general techniques for self-stabilization. Katz and Perry [KP90] showed how to compile an arbitrary asynchronous protocol into a stabilizing equivalent. Their general transformation is expensive; hence more efficient and less general techniques are useful. <p> Self-Stabilization by Window Washing 3 3. Counter Flushing As a point of departure, we review counter flushing <ref> [Dij74, Var94] </ref>. The abstract ideas are: * Nodes periodically inform their neighbors of "where" in the execution they are. * The leader node is always "right" by definition. 3 * Whenever a discrepancy is discovered, the leader ignores it, but a non-leader will re sync by altering its own state.
Reference: [FJM + 95] <author> Sally Floyd, Van Jacobson, Steven Mc-Canne, Ching-Gung Liu, and Lixia Zhang. </author> <title> A reliable multicast framework for light-weight sessions and application level framing. </title> <booktitle> In Proceedings of ACM SIG-COMM'94 Conference on Applications, Technologies, Architectures, and Protocols for Computer Communication, </booktitle> <address> Cam-bridge, Massachusetts, USA, </address> <pages> pages 342-356. </pages> <publisher> ACM SIGCOMM, ACM, </publisher> <month> August </month> <year> 1995. </year>
Reference-contexts: However, most current protocols 4 do not offer reliable one-to-many transmission|i.e., packets can be lost. Reliable multicast can simplify the design of many real applications includ 4 A few recent Internet protocols like SRM <ref> [FJM + 95] </ref> offer reliable multicast, but these protocols have not been proven to be self-stabilizing. Self-Stabilization by Window Washing 7 ing database update and distributed simulation.
Reference: [GM90] <author> Mohamed G. Gouda and Nicholas J. Mul-tari. </author> <title> Stabilizing communication protocols. </title> <type> Technical Report TR-90-20, </type> <institution> Dept. of Computer Science, University of Texas at Austin, </institution> <month> June </month> <year> 1990. </year>
Reference-contexts: Tech 1 2 Costello and Varghese niques that transform any locally checkable protocol into a stabilizing equivalent are given in [AKY90, APV91, Var93]. However, our work on WW applies to protocols that are not locally checkable. Gouda and Multari <ref> [GM90] </ref> describe a two-node sliding protocol using unbounded integers. Real protocols require bounded integers. Spinelli [Spi93] describes a pair of two-node self-stabilizing sliding window protocols with bounded counters. Our sliding protocol stabilizes using a completely different mechanism than Spinelli's.
Reference: [KBC94] <author> H. T. Kung, T. Blackwell, and A. Chap-man. </author> <title> Credit-based flow control for atm networks: Credit update protocol, adaptive credit allocation, and statistical multiplexing. </title> <booktitle> In Proceedings of SIG-COMM'94 Conference on Communications Architectures, Protocols, and Applications, </booktitle> <address> London, UK, </address> <pages> pages 101-114. </pages> <publisher> ACM SIGCOMM, ACM, </publisher> <month> August </month> <year> 1994. </year>
Reference-contexts: To the best of our knowledge, even the non-stabilizing version of our one-to-many sliding window protocol is new. We also show how small modifications achieve self-stabilization in the Credit Update Protocol (CUP) for flow control <ref> [KBC94] </ref>, which has been implemented in Bell-Northern Research ATM switches. Underlying these practical applications is a new theoretical technique that we call window washing. We had earlier [Var94] developed a technique called counter flushing which allowed a single leader to broadcast one message at a time to the receivers. <p> Our sliding protocol stabilizes using a completely different mechanism than Spinelli's. More interestingly, our stabilizing mechanism is a general idea that can be applied in other contexts; for instance, we apply our mechanisms to the general case of one-to-many sliding window protocols, and to the CUP flow control protocol <ref> [KBC94] </ref>. Our protocols stabilize faster, taking at most two actual round-trip delays to stabilize, whereas Spinelli's may take up to two worst-case round-trip delays. 1 In some real links the difference between a typical round-trip delay and a worst-case round-trip delay can be an order of magnitude. <p> The separation of data packets and sync packets is especially useful when the packets are ATM cells, which lack room for sequence numbers. The simplified code is shown in Figure 9. It is not new|it is virtually identical to the Credit Update Protocol (CUP) <ref> [KBC94] </ref> proposed for ATM flow control and implemented in Bell-Northern Research switches.
Reference: [KP90] <author> Shmuel Katz and Kenneth Perry. </author> <title> Self-stabilizing extensions for message-passing systems. </title> <booktitle> In Proc. 10th ACM Symp. on Principles of Distributed Computing, </booktitle> <address> Quebec City, Canada, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Previous Work Self-stabilizing protocols were introduced by Dijkstra [Dij74, Sch93]. There have been few general techniques for self-stabilization. Katz and Perry <ref> [KP90] </ref> showed how to compile an arbitrary asynchronous protocol into a stabilizing equivalent. Their general transformation is expensive; hence more efficient and less general techniques are useful. Tech 1 2 Costello and Varghese niques that transform any locally checkable protocol into a stabilizing equivalent are given in [AKY90, APV91, Var93].
Reference: [LT89] <author> Nancy A. Lynch and Mark R. Tuttle. </author> <title> An introduction to input/output automata. </title> <journal> CWI Quarterly, </journal> <volume> 2(3) </volume> <pages> 219-246, </pages> <year> 1989. </year>
Reference-contexts: We assume that there is a distinguished leader node. (There are many stabilizing protocols to construct a leader; e.g., [Per85] calculates a leader in O (D) time.) We model the nodes and links of the network using Input/Output Automata (IOA) <ref> [LT89] </ref>. Nodes communicate with each other by sending and receiving packets to and from links. Nodes and links are modeled by state machines.
Reference: [Per83] <author> Radia Perlman. </author> <title> Fault tolerant broadcast of routing information. </title> <booktitle> Computer Networks, </booktitle> <month> December </month> <year> 1983. </year>
Reference-contexts: A self-stabilizing protocol copes with a set of failures that subsumes most previous categories, and is robust against transient errors, including memory corruption and the injection of corrupt packets. Transient errors do occur in real networks and cause systems to fail unpredictably <ref> [Ros81, Per83] </ref>. Thus stabilizing protocols are more robust than traditional protocols. Furthermore, they are simpler, because they use uniform mechanisms to deal with different failures, and because they do not need special mechanisms for initialization. In this paper we describe a self-stabilizing version of the well-known sliding window protocol.
Reference: [Per85] <author> Radia Perlman. </author> <title> An algorithm for distributed computation of a spanning tree in an extended LAN. </title> <booktitle> In Proceedings of the the 9th Data Communication Symposium, </booktitle> <pages> pages 44-53, </pages> <month> September </month> <year> 1985. </year>
Reference-contexts: The network topology is modeled by a directed graph G = hV; Ei. Let n = jV j denote the number of network nodes and D the network diameter. We assume that there is a distinguished leader node. (There are many stabilizing protocols to construct a leader; e.g., <ref> [Per85] </ref> calculates a leader in O (D) time.) We model the nodes and links of the network using Input/Output Automata (IOA) [LT89]. Nodes communicate with each other by sending and receiving packets to and from links. Nodes and links are modeled by state machines.
Reference: [Ros81] <author> E. C. Rosen. </author> <title> Vulnerabilities of network control protocols: An example. </title> <journal> Computer Communications Review, </journal> <month> July </month> <year> 1981. </year>
Reference-contexts: A self-stabilizing protocol copes with a set of failures that subsumes most previous categories, and is robust against transient errors, including memory corruption and the injection of corrupt packets. Transient errors do occur in real networks and cause systems to fail unpredictably <ref> [Ros81, Per83] </ref>. Thus stabilizing protocols are more robust than traditional protocols. Furthermore, they are simpler, because they use uniform mechanisms to deal with different failures, and because they do not need special mechanisms for initialization. In this paper we describe a self-stabilizing version of the well-known sliding window protocol.
Reference: [Sch93] <author> M. Schneider. </author> <title> Self-stabilization. </title> <journal> ACM Computing Surveys, </journal> <volume> 25, </volume> <month> March </month> <year> 1993. </year>
Reference-contexts: Previous Work Self-stabilizing protocols were introduced by Dijkstra <ref> [Dij74, Sch93] </ref>. There have been few general techniques for self-stabilization. Katz and Perry [KP90] showed how to compile an arbitrary asynchronous protocol into a stabilizing equivalent. Their general transformation is expensive; hence more efficient and less general techniques are useful.
Reference: [Spi93] <author> John M. Spinelli. </author> <title> Self-stabilizing sliding window arq protocols. </title> <booktitle> Proc of IEEE Info-comm 93, </booktitle> <year> 1993. </year> <title> Self-stabilizing ARQ protocols on Channels with Bounded Memory or Bounded Delay. </title>
Reference-contexts: However, our work on WW applies to protocols that are not locally checkable. Gouda and Multari [GM90] describe a two-node sliding protocol using unbounded integers. Real protocols require bounded integers. Spinelli <ref> [Spi93] </ref> describes a pair of two-node self-stabilizing sliding window protocols with bounded counters. Our sliding protocol stabilizes using a completely different mechanism than Spinelli's.
Reference: [Tan81] <author> Andrew S. Tanenbaum. </author> <title> Computer Networks. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N. J., </address> <year> 1981. </year>
Reference-contexts: Such stop-and-wait protocols are inefficient in networks where the propagation delay is large compared to the transmission delay. Our new window washing technique allows the sender to pipeline a window of packets, improving throughput. In its simplest form with only one receiver, this is just a sliding window protocol <ref> [Tan81] </ref>. We consider the natural generalization: a one-to-many sliding window protocol with multiple receivers, and the application of our technique to make such a protocol self-stabilizing. One-to-many sliding window protocols would be useful for reliable broadcast, for example in ATM or IP networks. <p> Figure 2 shows an example stabilization scenario. Note that a token passing protocol can be used to broadcast a data message (carried in the token packet) from the leader to the other nodes. (In the case of a two-node ring, this reduces to the famous stop-and-wait data link protocol <ref> [Tan81] </ref>.) However, a message must be delivered to all re 4 Costello and Varghese In the initial state, the ring is full of garbage: After one round-trip delay, all garbage values have been flushed out: The leader remains stuck until its own value has filled the ring (at most one more <p> Thus the early work on counter flushing [Var94] applied to the problem of broadcasting a single message at a time to a set of receivers. We now show how to generalize this approach to allow pipelin-ing. 4. Window Washing A sliding window protocol <ref> [Tan81] </ref> is a two-node protocol enabling a sender node to send a sequence of messages to a receiver node without duplication, loss, or misordering. <p> The receiver keeps a receive sequence number R (initially 0) that records the last sequence number it accepted. For simplicity, we consider a sliding window protocol which neither buffers out-of-order messages nor does selective reject <ref> [Tan81] </ref>. That is, the receiver accepts a packet only if seq = R + 1, at which point the receiver copies seq into R, otherwise it discards the packet. <p> All arithmetic on sequence numbers is assumed to be modulo M , the size of the bounded integer space. Typically M is required to be greater than w <ref> [Tan81] </ref>. However, for self-stabilization we will require a larger value. The code for this protocol is shown in Figure 3. We have not modeled the arrival of messages from users to the sender|for simplicity, we assume that the sender generates a unique message for each sequence number.
Reference: [Var93] <author> George Varghese. </author> <title> Self-stabilization by local checking and correction. </title> <type> Ph.D. Thesis MIT/LCS/TR-583, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1993. </year>
Reference-contexts: Their general transformation is expensive; hence more efficient and less general techniques are useful. Tech 1 2 Costello and Varghese niques that transform any locally checkable protocol into a stabilizing equivalent are given in <ref> [AKY90, APV91, Var93] </ref>. However, our work on WW applies to protocols that are not locally checkable. Gouda and Multari [GM90] describe a two-node sliding protocol using unbounded integers. Real protocols require bounded integers. Spinelli [Spi93] describes a pair of two-node self-stabilizing sliding window protocols with bounded counters.


References-found: 15

