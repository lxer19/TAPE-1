URL: ftp://ftp.cs.washington.edu/homes/chambers/popl98-fipca-TR.ps.gz
Refering-URL: http://www.cs.washington.edu/research/projects/cecil/www/Papers/fipca.html
Root-URL: 
Phone: (206) 685-2094; fax: (206) 543-2969  
Title: Fast Interprocedural Class Analysis  
Author: Greg DeFouw, David Grove, and Craig Chambers 
Note: -gdefouw,grove,chambers-@cs.washington.edu  
Address: Seattle, Washington 98195 USA  
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract: Technical Report 97-07-02 July 1997 
Abstract-found: 1
Intro-found: 1
Reference: [Agesen 95] <author> Ole Agesen. </author> <title> The Cartesian Product Algorithm: Simple and Precise Type Inference of Parametric Polymor-phism. </title> <booktitle> In Proceedings ECOOP 95, </booktitle> <address> Aarhus, Denmark, </address> <month> August </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference: [Agesen et al. 93] <author> Ole Agesen, Jens Palsberg, and Michael I. Schwartzback. </author> <title> Type Inference of Self: Analysis of Objects with Dynamic and Multiple Inheritance. </title> <booktitle> In Proceedings ECOOP 93, </booktitle> <month> July </month> <year> 1993. </year>
Reference: [AK et al. 89] <author> Hassan A"it-Kaci, Robert Boyer, Patrick Lincoln, and Roger Nasr. </author> <title> Efficient Implementation of Lattice Operations. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(1):115146, </volume> <month> January </month> <year> 1989. </year>
Reference-contexts: The filter Edge.filter can be initialized in constant time and supports constant-time membership testing. The filter can be represented as a procedure to perform the subclass testing, for which there are several constant-time algorithms <ref> [AK et al. 89] </ref>. 2.4.2 Dataow Graph Construction In the worst case, all classes and methods in the original program will be reachable, implying that O (N) ASTs must be represented in the dataow graph. Each kind of AST node contributes O (1) nodes to the dataow graph.
Reference: [Ashley 96] <author> J. Michael Ashley. </author> <title> A Practical and Flexible Flow Analysis for Higher-Order Languages. </title> <booktitle> In Conference Record of the 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 184 194, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: Ashley presents an algorithm framework parameterized by a context-sensitivity operator and an operator for removing undesired precision of abstract values during analysis <ref> [Ashley 96, Ashley 97] </ref>. He instantiates his framework to produce an algorithm that performs only a bounded amount of propagation before falling back to a distinguished Unknown abstract value, which resembles our simply bounded OO 0-CFA O (N 2 ) algorithm.
Reference: [Ashley 97] <author> J. Michael Ashley. </author> <title> The Effectiveness of Flow Analysis for Inlining. </title> <booktitle> In Proceedings of the 1997 ACM SIG-PLAN International Conference on Functional Programming, </booktitle> <pages> pages 99111, </pages> <address> Amsterdam, The Netherlands, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: Ashley presents an algorithm framework parameterized by a context-sensitivity operator and an operator for removing undesired precision of abstract values during analysis <ref> [Ashley 96, Ashley 97] </ref>. He instantiates his framework to produce an algorithm that performs only a bounded amount of propagation before falling back to a distinguished Unknown abstract value, which resembles our simply bounded OO 0-CFA O (N 2 ) algorithm.
Reference: [Bacon & Sweeney 96] <author> David F. Bacon and Peter F. Sweeney. </author> <title> Fast Static Analysis of C++ Virtual Function Calls. </title> <booktitle> In OOPS-LA96 Conference Proceedings, </booktitle> <address> San Jose, CA, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: node refers to its containing supernode (super) (from which the representative supernode can be found). (The to_do and done fields of a supernode are temporary state maintained during analysis.) 2.2.3 Optimistic Elimination of Unreachable Classes and Procedures Our framework optimistically prunes unreachable classes and procedures, in the style of RTA <ref> [Bacon & Sweeney 96] </ref>.
Reference: [Chambers & Ungar 89] <author> Craig Chambers and David Ungar. </author> <title> Customization: Optimizing Compiler Technology for SELF, a Dynamically-Typed Object-Oriented Programming Language. </title> <booktitle> In Proceedings of the SIGPLAN 89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 146160, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: The base configuration represents an aggressive combination of intraprocedural and limited interprocedural optimizations which include: intraprocedural class analysis [Johnson 88, Chambers & Ungar 90], hard-wired class prediction for common messages (Cecil programs only) <ref> [Deutsch & Schiffman 84, Chambers & Ungar 89] </ref>, splitting [Chambers & Ungar 89], whole-program class hierarchy analysis [Dean et al. 95], cross-module inlining, static class prediction [Dean et al. 96, Dean 96] and closure optimizations (Cecil only). <p> The base configuration represents an aggressive combination of intraprocedural and limited interprocedural optimizations which include: intraprocedural class analysis [Johnson 88, Chambers & Ungar 90], hard-wired class prediction for common messages (Cecil programs only) [Deutsch & Schiffman 84, Chambers & Ungar 89], splitting <ref> [Chambers & Ungar 89] </ref>, whole-program class hierarchy analysis [Dean et al. 95], cross-module inlining, static class prediction [Dean et al. 96, Dean 96] and closure optimizations (Cecil only).
Reference: [Chambers & Ungar 90] <author> Craig Chambers and David Ungar. </author> <title> Iterative Type Analysis and Extended Message Splitting: Optimizing Dynamically-Typed Object-Oriented Programs. </title> <booktitle> In Proceedings of the ACM SIGPLAN 90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 150164, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: The base configuration represents an aggressive combination of intraprocedural and limited interprocedural optimizations which include: intraprocedural class analysis <ref> [Johnson 88, Chambers & Ungar 90] </ref>, hard-wired class prediction for common messages (Cecil programs only) [Deutsch & Schiffman 84, Chambers & Ungar 89], splitting [Chambers & Ungar 89], whole-program class hierarchy analysis [Dean et al. 95], cross-module inlining, static class prediction [Dean et al. 96, Dean 96] and closure optimizations (Cecil
Reference: [Chambers 93] <author> Craig Chambers. </author> <title> The Cecil Language: Specification and Rationale. </title> <type> Technical Report TR-93-03-05, </type> <institution> Department of Computer Science and Engineering. University of Washington, </institution> <month> March </month> <year> 1993. </year>
Reference: [Dean 96] <author> Jeffrey Dean. </author> <title> Whole Program Optimization of Object-Oriented Languages. </title> <type> PhD thesis, </type> <institution> University of Wash-ington, </institution> <month> November </month> <year> 1996. </year> <month> TR-96-11-05. </month>
Reference-contexts: and limited interprocedural optimizations which include: intraprocedural class analysis [Johnson 88, Chambers & Ungar 90], hard-wired class prediction for common messages (Cecil programs only) [Deutsch & Schiffman 84, Chambers & Ungar 89], splitting [Chambers & Ungar 89], whole-program class hierarchy analysis [Dean et al. 95], cross-module inlining, static class prediction <ref> [Dean et al. 96, Dean 96] </ref> and closure optimizations (Cecil only). We applied these optimizations through our Vortex compiler to produce C code, which we then compiled with gcc -O2 to produce executable code.
Reference: [Dean et al. 95] <author> Jeffrey Dean, David Grove, and Craig Chambers. </author> <title> Optimization of Object-Oriented Programs Using Static Class Hierarchy Analysis. </title> <booktitle> In Proceedings ECOOP 95, </booktitle> <address> Aarhus, Denmark, </address> <month> August </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: The base configuration represents an aggressive combination of intraprocedural and limited interprocedural optimizations which include: intraprocedural class analysis [Johnson 88, Chambers & Ungar 90], hard-wired class prediction for common messages (Cecil programs only) [Deutsch & Schiffman 84, Chambers & Ungar 89], splitting [Chambers & Ungar 89], whole-program class hierarchy analysis <ref> [Dean et al. 95] </ref>, cross-module inlining, static class prediction [Dean et al. 96, Dean 96] and closure optimizations (Cecil only). We applied these optimizations through our Vortex compiler to produce C code, which we then compiled with gcc -O2 to produce executable code.
Reference: [Dean et al. 96] <author> Jeffrey Dean, Greg DeFouw, Dave Grove, Vassily Litvinov, and Craig Chambers. </author> <title> Vortex: An Optimizing Compiler for Object-Oriented Languages. </title> <booktitle> In OOPSLA96 Conference Proceedings, </booktitle> <address> San Jose, CA, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: Accordingly, we implemented our framework in the Vortex optimizing compiler <ref> [Dean et al. 96] </ref> and applied all eight algorithms to the collection of large Cecil and Java programs described in Table 2. <p> and limited interprocedural optimizations which include: intraprocedural class analysis [Johnson 88, Chambers & Ungar 90], hard-wired class prediction for common messages (Cecil programs only) [Deutsch & Schiffman 84, Chambers & Ungar 89], splitting [Chambers & Ungar 89], whole-program class hierarchy analysis [Dean et al. 95], cross-module inlining, static class prediction <ref> [Dean et al. 96, Dean 96] </ref> and closure optimizations (Cecil only). We applied these optimizations through our Vortex compiler to produce C code, which we then compiled with gcc -O2 to produce executable code.
Reference: [DeFouw et al. 98] <author> Greg DeFouw, David Grove, and Craig Chambers. </author> <title> Fast Interprocedural Class Analysis. </title> <booktitle> In Conference Record of the 25th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1998. </year>
Reference: [Deutsch & Schiffman 84] <author> L. Peter Deutsch and Allan M. Schiffman. </author> <title> Efficient Implementation of the Smalltalk-80 System. </title> <booktitle> In Conference Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 297302, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: The base configuration represents an aggressive combination of intraprocedural and limited interprocedural optimizations which include: intraprocedural class analysis [Johnson 88, Chambers & Ungar 90], hard-wired class prediction for common messages (Cecil programs only) <ref> [Deutsch & Schiffman 84, Chambers & Ungar 89] </ref>, splitting [Chambers & Ungar 89], whole-program class hierarchy analysis [Dean et al. 95], cross-module inlining, static class prediction [Dean et al. 96, Dean 96] and closure optimizations (Cecil only).
Reference: [Flanagan & Felleisen 97] <author> Cormac Flanagan and Matthias Felleisen. </author> <title> Componential Set-Based Analysis. </title> <booktitle> In Proceedings of the ACM SIGPLAN 97 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 235248, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: This would lead to a kind of hierarchical, component-wise analysis of programs that may help the analyses scale to larger programs, along the lines of Flanagan and Felleisens componential set-based analysis <ref> [Flanagan & Felleisen 97] </ref>. 2.7 Clients of the Analysis Our analysis provides information to clients in two forms.
Reference: [Gosling et al. 96] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1996. </year>
Reference: [Grove et al. 97] <author> David Grove, Greg DeFouw, Jeffrey Dean, and Craig Chambers. </author> <title> Call Graph Construction in Object Oriented Languages. </title> <booktitle> In OOPSLA97 Conference Proceedings, </booktitle> <address> Atlanta, GA, </address> <month> October </month> <year> 1997. </year>
Reference-contexts: More generally, we wish to explore adding other more explicit forms of context-sensitivity to our fast analyses. In other work we have examined the impact of different context-sensitivity strategies on cost and precision of algorithms building upon the cubic-time classic OO 0-CFA algorithm <ref> [Grove et al. 97] </ref>, but we have not considered adapting those notions to the faster algorithms presented here, nor have we considered ways of bounding the worst-case cost of context-sensitivity.
Reference: [Heintze & McAllester 97] <author> Nevin Heintze and David McAllester. </author> <title> Linear-Time Subtransitive Control Flow Analysis. </title> <booktitle> In Proceedings of the ACM SIGPLAN 97 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 261272, </pages> <month> June </month> <year> 1997. </year>
Reference-contexts: Heintze and McAllester describe subtransitive control ow analysis which constructs an encoded representation of the 0-CFA dataow graph in linear time (for a restricted language model with function types bounded in size by a constant), but performing the transitive closure to compute the full explicit dataow graph requires quadratic time <ref> [Heintze & McAllester 97] </ref>. They offer other queries of their encoded representation, such as computing the call sites which have only one callee, which require only linear time. 3 Experimental Assessment In addition to asymptotic complexity results, we wish to understand how well the different algorithms perform in practice.
Reference: [Heintze 94] <author> Nevin Heintze. </author> <title> Set-Based Analysis of ML Programs. </title> <booktitle> In Proceedings of the ACM Conference on LISP and Functional Programming 94, </booktitle> <pages> pages 306317, </pages> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year>
Reference: [Henglein 91] <author> Fritz Henglein. </author> <title> Efficient Type Inference for Higher-Order Binding-Time Analysis. </title> <booktitle> In Functional Programming and Computer Architecture, </booktitle> <year> 1991. </year>
Reference: [Jagannathan & Weeks 95] <author> Suresh Jagannathan and Stephen Weeks. </author> <title> A Unified Treatment of Flow Analysis in Higher-Order Languages. </title> <booktitle> In Conference Record of the 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 393407, </pages> <month> January </month> <year> 1995. </year>
Reference: [Johnson 88] <author> Ralph Johnson. </author> <title> TS: AN Optimizing Compiler for Smalltalk. </title> <booktitle> In Proceedings OOPSLA 88, </booktitle> <pages> pages 1826, </pages> <month> No-vember </month> <year> 1988. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 23, number 11. </volume>
Reference-contexts: The base configuration represents an aggressive combination of intraprocedural and limited interprocedural optimizations which include: intraprocedural class analysis <ref> [Johnson 88, Chambers & Ungar 90] </ref>, hard-wired class prediction for common messages (Cecil programs only) [Deutsch & Schiffman 84, Chambers & Ungar 89], splitting [Chambers & Ungar 89], whole-program class hierarchy analysis [Dean et al. 95], cross-module inlining, static class prediction [Dean et al. 96, Dean 96] and closure optimizations (Cecil
Reference: [Nielson & Nielson 97] <author> Flemming Nielson and Hanne Riis Nielson. </author> <title> Infinitary Control Flow Analysis: A Collecting Semantics for Closure Analysis. </title> <booktitle> In Conference Record of the 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 332345, </pages> <month> January </month> <year> 1997. </year>
Reference: [Oxhj et al. 92] <author> Nicholas Oxhj, Jens Palsberg, and Michael I. Schwartzbach. </author> <title> Making Type Inference Practical. </title> <editor> In O. Lehrmann Madsen, editor, </editor> <booktitle> Proceedings ECOOP 92, </booktitle> <volume> LNCS 615, </volume> <pages> pages 329349, </pages> <address> Utrecht, The Netherlands, June 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference: [Plevyak & Chien 94] <author> John Plevyak and Andrew A. Chien. </author> <title> Precise Concrete Type Inference for Object-Oriented Languages. </title> <booktitle> In Proceedings OOPSLA 94, </booktitle> <pages> pages 324340, </pages> <address> Portland, OR, </address> <month> October </month> <year> 1994. </year>
Reference: [Shivers 88] <author> Olin Shivers. </author> <title> Control-Flow Analysis in Scheme. </title> <booktitle> In Proceedings of the SIGPLAN 88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 164174, </pages> <month> June </month> <year> 1988. </year>
Reference: [Shivers 91] <author> Olin Shivers. </author> <title> Control-Flow Analysis of Higher-Order Languages. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <month> May </month> <year> 1991. </year> <month> CMU-CS-91-145. </month>
Reference: [Steensgaard 96] <author> Bjarne Steensgaard. </author> <title> Points-to Analysis in Almost Linear Time. </title> <booktitle> In Conference Record of the 23rd ACM SIG-PLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 3241, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: Other authors of sub-quadratic algorithms have also encountered difficulties providing useful information to clients. For example, Steensgaard presents a near-linear-time algorithm for performing pointer analysis, but to completely query the resulting data structure to compute all points-to relationships among variables would require quadratic time <ref> [Steensgaard 96] </ref>.
Reference: [Stefanescu & Zhou 94] <author> Dan Stefanescu and Yuli Zhou. </author> <title> An Equational Framework for the Flow Analysis of Higher-Order Functional Programs. </title> <booktitle> In Proceedings of the ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 190 198, </pages> <month> June </month> <year> 1994. </year>
Reference: [Tarjan 75] <author> Robert E. Tarjan. </author> <title> Efficiency of a good but not linear set union union algorithm. </title> <journal> Journal of the ACM, </journal> <volume> 22(2):215225, </volume> <year> 1975. </year>
Reference-contexts: Later, when a class is propagated to any member of the unified supernode, it is immediately forwarded to all of the active members of the supernode, skipping the inactive members, ensuring that inactive nodes never incur additional work. We use fast union-find data structures <ref> [Tarjan 75] </ref> to support quickly unifying two arbitrary supernodes and (lazily) updating all the member nodes to refer to the new unified supernode (in O (Ua (U,U)+F) time for U unifications and F find-representative updates).
References-found: 30

