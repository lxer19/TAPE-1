URL: http://www.cs.wisc.edu/wpis/papers/pepm97.ps
Refering-URL: http://www.cs.wisc.edu/~reps/
Root-URL: 
Title: Interconvertibility of Set Constraints and Context-Free Language Reachability 1  
Author: David Melski Thomas Reps 
Affiliation: Computer Sciences Department University of Wisconsin  Computer Sciences Department University of Wisconsin  
Abstract: We show the interconvertibility of context-free-language reachability problems and a class of set-constraint problems: given a context-free-language reachability problem, we show how to construct a set-constraint problem whose answer gives a solution to the reachability problem; given a set-constraint problem, we show how to construct a context-free-language reachability problem whose answer gives a solution to the set-constraint problem. The interconvertibil-ity of these two formalisms offers an conceptual advantage akin to the advantage gained from the interconvertibility of finite-state automata and regular expressions in formal language theory, namely, a problem can be formulated in whichever formalism is most natural. It also offers some insight into the "O(n 3 ) bottleneck" for different types of program-analysis problems, and allows results previously obtained for context-free-language reachability problems to be applied to set-constraint problems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Callahan. </author> <title> The program summary graph and flow-sensitive interprocedural data flow analysis. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 47-56, </pages> <year> 1988. </year>
Reference-contexts: This approach was later applied to in-traprocedural bi-directional bit-vector problems [18]. Cooper and Kennedy used reachability to give efficient algorithms for interprocedural side-effect analysis [2] and alias analysis [3]. The first uses of CFL-reachability for program analysis were in 1988, in Callahan's work on flow-sensitive side-effect analysis <ref> [1] </ref> and Horwitz et al.'s work on interprocedural slicing [12, 13].
Reference: [2] <author> K.D. Cooper and K. Kennedy. </author> <title> Interprocedural side-effect analysis in linear time. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 57-66, </pages> <year> 1988. </year>
Reference-contexts: Kou [19] and Hecht [6] gave linear-time graph-reachability algorithms for solving intraprocedural "bit-vector" dataflow-analysis problems. This approach was later applied to in-traprocedural bi-directional bit-vector problems [18]. Cooper and Kennedy used reachability to give efficient algorithms for interprocedural side-effect analysis <ref> [2] </ref> and alias analysis [3]. The first uses of CFL-reachability for program analysis were in 1988, in Callahan's work on flow-sensitive side-effect analysis [1] and Horwitz et al.'s work on interprocedural slicing [12, 13].
Reference: [3] <author> K.D. Cooper and K. Kennedy. </author> <title> Fast interprocedural alias analysis. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-59, </pages> <year> 1989. </year>
Reference-contexts: Kou [19] and Hecht [6] gave linear-time graph-reachability algorithms for solving intraprocedural "bit-vector" dataflow-analysis problems. This approach was later applied to in-traprocedural bi-directional bit-vector problems [18]. Cooper and Kennedy used reachability to give efficient algorithms for interprocedural side-effect analysis [2] and alias analysis <ref> [3] </ref>. The first uses of CFL-reachability for program analysis were in 1988, in Callahan's work on flow-sensitive side-effect analysis [1] and Horwitz et al.'s work on interprocedural slicing [12, 13].
Reference: [4] <author> M. J. Fischer and A. R. Meyer. </author> <title> Boolean matrix multiplication and transitive closure. </title> <booktitle> In Conference Record of the IEEE 12th Symposium on Switching and Automata Theory, </booktitle> <year> 1971. </year>
Reference-contexts: However, because transitive closure can be performed in sub-cubic time <ref> [4] </ref>, this is not the correct explanation. We have long believed that the real source of the O (n 3 ) bottleneck is that a CFL-reachability problem needs to be solved.
Reference: [5] <author> F. Gecseg and M. Steinby. </author> <title> Tree Automata. </title> <publisher> Akademiai Kiado, </publisher> <year> 1984. </year>
Reference-contexts: Heintze formalizes this idea in [7]. The solution to a collection of set constraints can be written as a regular term grammar <ref> [5] </ref>, which is a formalism that allows certain infinite sets of terms to be represented in a finite manner. There are standard algorithms for dealing with regular term grammars (e.g., for determining membership) [5]. <p> The solution to a collection of set constraints can be written as a regular term grammar <ref> [5] </ref>, which is a formalism that allows certain infinite sets of terms to be represented in a finite manner. There are standard algorithms for dealing with regular term grammars (e.g., for determining membership) [5]. A regular term grammar consists of a finite, non-empty set of non-terminals, a set of function symbols, and a finite set of productions. Each function symbol has a fixed arity. Productions are of the form N )term where N is a non-terminal.
Reference: [6] <author> M.S. Hecht. </author> <title> Flow Analysis of Computer Programs. </title> <publisher> North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: A variety of work exists that has applied graph reacha-bility (of various forms) to analysis of imperative programs. Kou [19] and Hecht <ref> [6] </ref> gave linear-time graph-reachability algorithms for solving intraprocedural "bit-vector" dataflow-analysis problems. This approach was later applied to in-traprocedural bi-directional bit-vector problems [18]. Cooper and Kennedy used reachability to give efficient algorithms for interprocedural side-effect analysis [2] and alias analysis [3].
Reference: [7] <author> N. Heintze. </author> <title> Set-based program analysis. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pitts-burgh, PA, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: National Science Foundation under grants CCR-9100424 and CCR-9625667, and by the Defense Advanced Research Projects Agency (monitored by the Office of Naval Research under contracts N00014-92-J-1937 and N00014-97-1-0114). 2 1210 West Dayton Street, Madison, WI 53706; fmelski,repsg@cs.wisc.edu then becomes a problem of finding the least solution of the set-constraint problem <ref> [7] </ref>. The principal contribution of this paper is to relate these two techniques: * We give a construction for converting a CFL-reachability problem into a set-constraint problem. <p> can be solved in time O (n 3 ) (where the constant of proportionality is cubic in jj). 2.2 Set Constraints In this section, we define the class of set constraints considered in this paper. (The material in this section is a summary of work done by Heintze and Jaffar <ref> [7, 8, 9] </ref>.) 2.2.1 Set Expressions and Set Constraints In the class of set constraints we deal with, a set expression is either a set variable (denoted by V , W , X, etc.) or has one of the following forms: * c (V 1 ; : : : ; V <p> Heintze formalizes this idea in <ref> [7] </ref>. The solution to a collection of set constraints can be written as a regular term grammar [5], which is a formalism that allows certain infinite sets of terms to be represented in a finite manner. <p> Such constraints are said to be in explicit form <ref> [7] </ref>: A constraint is in explicit form if it is of the form V c (V 1 ; : : : ; V r ). <p> When no more constraints can be added, the constraints in explicit form are converted to a regular term grammar; this describes the least solution <ref> [7] </ref>. 2 The SC-Reduction Algorithm never generates new atomic expressions; this means that when the algorithm finishes, for a fixed variable Y , the number of constraints of the form Y c (V a 1 ; V a 2 ; : : : ; V a r ) in C is
Reference: [8] <author> N. Heintze. </author> <title> Set based analyis of ML programs. </title> <type> Technical Report CMU-CS-93-193, </type> <institution> Carnegie Mellon University, </institution> <year> 1993. </year>
Reference-contexts: can be solved in time O (n 3 ) (where the constant of proportionality is cubic in jj). 2.2 Set Constraints In this section, we define the class of set constraints considered in this paper. (The material in this section is a summary of work done by Heintze and Jaffar <ref> [7, 8, 9] </ref>.) 2.2.1 Set Expressions and Set Constraints In the class of set constraints we deal with, a set expression is either a set variable (denoted by V , W , X, etc.) or has one of the following forms: * c (V 1 ; : : : ; V <p> proportional to t, the total running time of the algorithm is bounded by O (t 3 ). 5 Related Work and Concluding Remarks The techniques described in this paper can be extended to apply to the class of set constraints used by Heintze to do set-based analysis of ML programs <ref> [8] </ref>. This class of set constraints is effectively a superset of the class of set constraints used in this paper. In particular, Heintze extends the set constraints to handle -terms and function applications.
Reference: [9] <author> N. Heintze and J. Jaffar. </author> <title> A decision procedure for a class of set constraints. </title> <type> Technical Report CMU-CS-91-110, </type> <institution> Carnegie Mellon University, </institution> <year> 1991. </year>
Reference-contexts: can be solved in time O (n 3 ) (where the constant of proportionality is cubic in jj). 2.2 Set Constraints In this section, we define the class of set constraints considered in this paper. (The material in this section is a summary of work done by Heintze and Jaffar <ref> [7, 8, 9] </ref>.) 2.2.1 Set Expressions and Set Constraints In the class of set constraints we deal with, a set expression is either a set variable (denoted by V , W , X, etc.) or has one of the following forms: * c (V 1 ; : : : ; V
Reference: [10] <author> N. Heintze and D. McAllester. </author> <title> Linear-time subtransitive control flow analysis. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <year> 1997. </year>
Reference-contexts: 2NPDA-recognition to problems of flow analysis and typability in the Amadio-Cardelli type system. (This is consistent with something we had observed in unpublished work, where we gave a linear-time reduction from the 2NPDA-recognition problem to CFL-reachability.) Heintze and McAllester have also examined the complexity of set-based analysis with data constructors <ref> [20, 10] </ref>. A variety of work exists that has applied graph reacha-bility (of various forms) to analysis of imperative programs. Kou [19] and Hecht [6] gave linear-time graph-reachability algorithms for solving intraprocedural "bit-vector" dataflow-analysis problems. This approach was later applied to in-traprocedural bi-directional bit-vector problems [18].
Reference: [11] <author> N. Heintze and D. McAllester. </author> <title> On the cubic bottleneck in subtyping and flow analysis. </title> <booktitle> In LICS '97: Proceedings of the IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1997. </year>
Reference-contexts: Heintze and McAllester have also obtained results that have a bearing on the "O (n 3 ) program-analysis bottleneck" by considering the problem of determining membership for languages defined by 2-way nondeterministic pushdown automata (2NPDA-recognition) <ref> [11] </ref>. The best known algorithm for solving the 2NPDA-recognition problem runs in O (n 3 ) time and they observe that if there is a linear-time reduction from 2NPDA-recognition to a given problem, then that problem is unlikely to be solvable in better than O (n 3 ) time. In [11] <p> <ref> [11] </ref>. The best known algorithm for solving the 2NPDA-recognition problem runs in O (n 3 ) time and they observe that if there is a linear-time reduction from 2NPDA-recognition to a given problem, then that problem is unlikely to be solvable in better than O (n 3 ) time. In [11] reductions are given from 2NPDA-recognition to problems of flow analysis and typability in the Amadio-Cardelli type system. (This is consistent with something we had observed in unpublished work, where we gave a linear-time reduction from the 2NPDA-recognition problem to CFL-reachability.) Heintze and McAllester have also examined the complexity of set-based
Reference: [12] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 35-46, </pages> <year> 1988. </year>
Reference-contexts: Cooper and Kennedy used reachability to give efficient algorithms for interprocedural side-effect analysis [2] and alias analysis [3]. The first uses of CFL-reachability for program analysis were in 1988, in Callahan's work on flow-sensitive side-effect analysis [1] and Horwitz et al.'s work on interprocedural slicing <ref> [12, 13] </ref>.
Reference: [13] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: 1 Introduction This paper concerns algorithms for converting between two techniques for formalizing program-analysis problems: context-free-language reachability and a class of set constraints. Context-free-language reachability (CFL-reach-ability) is a generalization of ordinary graph reachability (i.e., transitive closure). It has been used for a number of program-analysis applications, including interprocedural slicing <ref> [13, 15] </ref>, interprocedural dataflow analysis [14], and shape analysis [22]. Set constraints have been applied to program analysis by using them to collect (a superset of) the set of values that the program's variables may hold during execution. <p> and reason in terms of whichever paradigm is most appropriate. (This is analogous to the situation one has in formal language theory with finite-state automata and regular expressions, or with pushdown automata and context-free grammars.) For example, CFL-reachability leads to natural formulations of interprocedural dataflow analysis [15] and interprocedural slicing <ref> [24, 13] </ref>. Set-constraints lead to natural formulations of shape analysis [17, 26]. <p> Cooper and Kennedy used reachability to give efficient algorithms for interprocedural side-effect analysis [2] and alias analysis [3]. The first uses of CFL-reachability for program analysis were in 1988, in Callahan's work on flow-sensitive side-effect analysis [1] and Horwitz et al.'s work on interprocedural slicing <ref> [12, 13] </ref>.
Reference: [14] <author> S. Horwitz, T. Reps, and M. Sagiv. </author> <title> Demand interprocedural dataflow analysis. </title> <booktitle> In Proceedings of the Fourth ACM SIG-SOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 104-115, </pages> <month> October </month> <year> 1995. </year> <note> (Available on the WWW from URL http://www.cs.wisc.edu/wpis/papers/fse95.ps). </note>
Reference-contexts: Context-free-language reachability (CFL-reach-ability) is a generalization of ordinary graph reachability (i.e., transitive closure). It has been used for a number of program-analysis applications, including interprocedural slicing [13, 15], interprocedural dataflow analysis <ref> [14] </ref>, and shape analysis [22]. Set constraints have been applied to program analysis by using them to collect (a superset of) the set of values that the program's variables may hold during execution. Typically, a set variable is created for each program variable at each program point. <p> These ideas were elaborated on in a sequence of papers <ref> [15, 14, 24] </ref>, and also applied to shape analysis of functional programs [22]. All of these papers use only very limited forms of CFL-reachability, namely variations on Dyck-language reachabil-ity.
Reference: [15] <author> S. Horwitz, T. Reps, M. Sagiv, and G. Rosay. </author> <title> Speeding up slicing. </title> <booktitle> In Proceedings of the Third ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 11-20, </pages> <month> December </month> <year> 1994. </year> <note> (Available on the WWW from URL http://www.cs.wisc.edu/wpis/papers/fse94.ps). </note>
Reference-contexts: 1 Introduction This paper concerns algorithms for converting between two techniques for formalizing program-analysis problems: context-free-language reachability and a class of set constraints. Context-free-language reachability (CFL-reach-ability) is a generalization of ordinary graph reachability (i.e., transitive closure). It has been used for a number of program-analysis applications, including interprocedural slicing <ref> [13, 15] </ref>, interprocedural dataflow analysis [14], and shape analysis [22]. Set constraints have been applied to program analysis by using them to collect (a superset of) the set of values that the program's variables may hold during execution. <p> problem, one can think and reason in terms of whichever paradigm is most appropriate. (This is analogous to the situation one has in formal language theory with finite-state automata and regular expressions, or with pushdown automata and context-free grammars.) For example, CFL-reachability leads to natural formulations of interprocedural dataflow analysis <ref> [15] </ref> and interprocedural slicing [24, 13]. Set-constraints lead to natural formulations of shape analysis [17, 26]. <p> These ideas were elaborated on in a sequence of papers <ref> [15, 14, 24] </ref>, and also applied to shape analysis of functional programs [22]. All of these papers use only very limited forms of CFL-reachability, namely variations on Dyck-language reachabil-ity.
Reference: [16] <author> N. D. Jones and W. T. Laaser. </author> <title> Complete problems for deterministic polynomial time. </title> <booktitle> Theoretical Computer Science 3, </booktitle> <pages> pages 105-117, </pages> <year> 1977. </year>
Reference-contexts: It is also easily shown that the construction given in this section can be carried out in log-space. Since CFL-reachability problems are PTIME-complete (i.e., complete for PTIME under log-space reductions) [23], this means that the given class of set-constraint problems are also PTIME-complete <ref> [16] </ref>. 3.3 Analysis of the Running Time In general, an all-pairs CFL-reachability problem can be solved in time O (n 3 ), where n is the number of nodes in the graph.
Reference: [17] <editor> N.D. Jones and S.S. Muchnick. </editor> <title> Flow analysis and optimization of Lisp-like structures. </title> <editor> In S.S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <journal> Theory and Applications, </journal> <volume> chapter 4, </volume> <pages> pages 102-131. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Set-constraints lead to natural formulations of shape analysis <ref> [17, 26] </ref>.
Reference: [18] <author> U.P. Khedker and D.M. Dhamdhere. </author> <title> A generalized theory of bit vector data flow analysis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5) </volume> <pages> 1472-1511, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: A variety of work exists that has applied graph reacha-bility (of various forms) to analysis of imperative programs. Kou [19] and Hecht [6] gave linear-time graph-reachability algorithms for solving intraprocedural "bit-vector" dataflow-analysis problems. This approach was later applied to in-traprocedural bi-directional bit-vector problems <ref> [18] </ref>. Cooper and Kennedy used reachability to give efficient algorithms for interprocedural side-effect analysis [2] and alias analysis [3]. The first uses of CFL-reachability for program analysis were in 1988, in Callahan's work on flow-sensitive side-effect analysis [1] and Horwitz et al.'s work on interprocedural slicing [12, 13].
Reference: [19] <author> L.T. Kou. </author> <title> On live-dead analysis for global data flow problems. </title> <journal> J. ACM, </journal> <volume> 24(3) </volume> <pages> 473-483, </pages> <month> July </month> <year> 1977. </year>
Reference-contexts: A variety of work exists that has applied graph reacha-bility (of various forms) to analysis of imperative programs. Kou <ref> [19] </ref> and Hecht [6] gave linear-time graph-reachability algorithms for solving intraprocedural "bit-vector" dataflow-analysis problems. This approach was later applied to in-traprocedural bi-directional bit-vector problems [18]. Cooper and Kennedy used reachability to give efficient algorithms for interprocedural side-effect analysis [2] and alias analysis [3].
Reference: [20] <author> D. McAllester and N. Heintze. </author> <title> On the complexity of set-based analysis. </title> <booktitle> In ICFP '97: Proceedings of the Second ACM SIGPLAN International Conference on Functional Programming, </booktitle> <year> 1997. </year>
Reference-contexts: 2NPDA-recognition to problems of flow analysis and typability in the Amadio-Cardelli type system. (This is consistent with something we had observed in unpublished work, where we gave a linear-time reduction from the 2NPDA-recognition problem to CFL-reachability.) Heintze and McAllester have also examined the complexity of set-based analysis with data constructors <ref> [20, 10] </ref>. A variety of work exists that has applied graph reacha-bility (of various forms) to analysis of imperative programs. Kou [19] and Hecht [6] gave linear-time graph-reachability algorithms for solving intraprocedural "bit-vector" dataflow-analysis problems. This approach was later applied to in-traprocedural bi-directional bit-vector problems [18].
Reference: [21] <author> T. Reps. </author> <title> Demand interprocedural program analysis using logic databases. </title> <editor> In R. Ramakrishnan, editor, </editor> <booktitle> Applications of Logic Databases. </booktitle> <publisher> Kluwer Academic Publishers, </publisher> <year> 1994. </year>
Reference-contexts: For example, a demand algorithm might be used to compute the results of a program analysis only for points in the innermost loops of a given program. Because CFL-reachability problems can be solved in a demand-driven fashion (e.g., see <ref> [22, 21] </ref>), this paper shows that (in principle) set-constraint problems can also be solved in a demand-driven fashion. To our knowledge, this has not been investigated before in the literature on set con straints. * CFL-reachability lends itself to analysis of languages with a lazy semantics [22]. <p> In fact, the CFL-reachability Algorithm presented here in effect emulates semi-naive bottom-up evaluation of the equivalent DATALOG program. This suggests that the class of DATALOG programs that run in cubic time may be useful for program analysis (see also <ref> [21] </ref>). Many parts of a constructed CFL-reachability problem are more easily expressed in a DATALOG program. In particular, the addition of reverse edges, and the tracking of ground information is easy to express. The program would not necessarily be a chain program, but it would still run in cubic time.
Reference: [22] <author> T. Reps. </author> <title> Shape analysis as a generalized path problem. </title> <booktitle> In PEPM '95: Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <address> New York, NY, 1995. </address> <publisher> ACM. </publisher>
Reference-contexts: Context-free-language reachability (CFL-reach-ability) is a generalization of ordinary graph reachability (i.e., transitive closure). It has been used for a number of program-analysis applications, including interprocedural slicing [13, 15], interprocedural dataflow analysis [14], and shape analysis <ref> [22] </ref>. Set constraints have been applied to program analysis by using them to collect (a superset of) the set of values that the program's variables may hold during execution. Typically, a set variable is created for each program variable at each program point. <p> For example, a demand algorithm might be used to compute the results of a program analysis only for points in the innermost loops of a given program. Because CFL-reachability problems can be solved in a demand-driven fashion (e.g., see <ref> [22, 21] </ref>), this paper shows that (in principle) set-constraint problems can also be solved in a demand-driven fashion. To our knowledge, this has not been investigated before in the literature on set con straints. * CFL-reachability lends itself to analysis of languages with a lazy semantics [22]. <p> To our knowledge, this has not been investigated before in the literature on set con straints. * CFL-reachability lends itself to analysis of languages with a lazy semantics <ref> [22] </ref>. Set constraints are more readily used to analyze languages with a strict semantics. However, our interconvertibility results show that CFL-reachability can be used to analyze strict languages, and set constraints can be used to analyze lazy languages. <p> The basic technique is a modification of work done by Reps in using CFL-reachability to do shape analysis <ref> [22] </ref>. In essence, our encoding involves simulating the steps of the SC-Reduction Algorithm with the productions of a reachability problem. <p> These ideas were elaborated on in a sequence of papers [15, 14, 24], and also applied to shape analysis of functional programs <ref> [22] </ref>. All of these papers use only very limited forms of CFL-reachability, namely variations on Dyck-language reachabil-ity. The second author became aware of the connection to the more general concept of CFL-reachability sometime in the fall of 1994. (Of the papers mentioned above, only [22] mentions CFL-reachability explicitly and references Yan-nakakis's <p> to shape analysis of functional programs <ref> [22] </ref>. All of these papers use only very limited forms of CFL-reachability, namely variations on Dyck-language reachabil-ity. The second author became aware of the connection to the more general concept of CFL-reachability sometime in the fall of 1994. (Of the papers mentioned above, only [22] mentions CFL-reachability explicitly and references Yan-nakakis's paper [28].) The constructions of the present paper for converting set-constraint problems to CFL-reachability problems|together with the fact that set constraints have been used for program analysis|show that CFL-reachability using path languages other than Dyck languages is also of utility for program analysis.
Reference: [23] <author> T. Reps. </author> <title> On the sequential nature of interprocedural program-analysis problems. </title> <journal> Acta Inf., </journal> <volume> 33 </volume> <pages> 739-757, </pages> <year> 1996. </year>
Reference-contexts: This paper shows this to be the case for a class of set-constraint problems. * CFL-reachability is known to be log-space complete for polynomial time (or "PTIME-complete") <ref> [23] </ref>. Because the CFL-reachability to set-constraint construction can be performed in log-space, this paper demonstrates that a class of set-constraint problems are also PTIME-complete. <p> This leads to a contradiction. A similar argu ment works in the other direction. It is also easily shown that the construction given in this section can be carried out in log-space. Since CFL-reachability problems are PTIME-complete (i.e., complete for PTIME under log-space reductions) <ref> [23] </ref>, this means that the given class of set-constraint problems are also PTIME-complete [16]. 3.3 Analysis of the Running Time In general, an all-pairs CFL-reachability problem can be solved in time O (n 3 ), where n is the number of nodes in the graph.
Reference: [24] <author> T. Reps, S. Horwitz, and M. Sagiv. </author> <title> Precise inter-procedural dataflow analysis via graph reachability. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-61, </pages> <year> 1995. </year> <note> (Available on the WWW from URL http://www.cs.wisc.edu/wpis/papers/popl95.ps). </note>
Reference-contexts: and reason in terms of whichever paradigm is most appropriate. (This is analogous to the situation one has in formal language theory with finite-state automata and regular expressions, or with pushdown automata and context-free grammars.) For example, CFL-reachability leads to natural formulations of interprocedural dataflow analysis [15] and interprocedural slicing <ref> [24, 13] </ref>. Set-constraints lead to natural formulations of shape analysis [17, 26]. <p> These ideas were elaborated on in a sequence of papers <ref> [15, 14, 24] </ref>, and also applied to shape analysis of functional programs [22]. All of these papers use only very limited forms of CFL-reachability, namely variations on Dyck-language reachabil-ity.
Reference: [25] <author> T. Reps, M. Sagiv, and S. Horwitz. </author> <title> Interprocedu-ral dataflow analysis via graph reachability. </title> <type> Technical Report TR 94-14, </type> <institution> Datalogisk Institut, University of Copenhagen, </institution> <year> 1994. </year> <note> (Available on the WWW from URL http://www.cs.wisc.edu/wpis/papers/diku-tr94-14.ps). </note>
Reference-contexts: contributions of certain kinds of nonexecutable paths should be filtered out [27]; however, the dataflow-analysis algorithms given by Sharir and Pnueli are based on machinery other than pure graph reachability.) Dyck-language reachability was shown by Reps et al. to be of utility for a wide variety of interprocedural program-analysis problems <ref> [25] </ref>. These ideas were elaborated on in a sequence of papers [15, 14, 24], and also applied to shape analysis of functional programs [22]. All of these papers use only very limited forms of CFL-reachability, namely variations on Dyck-language reachabil-ity.
Reference: [26] <author> J.C. Reynolds. </author> <title> Automatic computation of data set definitions. </title> <booktitle> In Information Processing 68: Proceedings of the IFIP Congress, </booktitle> <pages> pages 456-461, </pages> <address> New York, NY, 1968. </address> <publisher> North-Holland. </publisher>
Reference-contexts: Set-constraints lead to natural formulations of shape analysis <ref> [17, 26] </ref>.
Reference: [27] <author> M. Sharir and A. Pnueli. </author> <title> Two approaches to interprocedural data flow analysis. </title> <editor> In S.S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <journal> Theory and Applications, </journal> <volume> chapter 7, </volume> <pages> pages 189-234. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: various kinds of matched-parenthesis (Dyck) languages, and neither paper relates the work to the more general concept of CFL-reachability. (Dyck languages had been used in earlier work on interprocedural dataflow analysis by Sharir and Pnueli to specify that the contributions of certain kinds of nonexecutable paths should be filtered out <ref> [27] </ref>; however, the dataflow-analysis algorithms given by Sharir and Pnueli are based on machinery other than pure graph reachability.) Dyck-language reachability was shown by Reps et al. to be of utility for a wide variety of interprocedural program-analysis problems [25].
Reference: [28] <author> M. Yannakakis. </author> <title> Graph-theoretic methods in database theory. </title> <booktitle> In Proceedings of the Symposium on Principles of Database Systems, </booktitle> <pages> pages 230-242, </pages> <year> 1990. </year>
Reference-contexts: The second author became aware of the connection to the more general concept of CFL-reachability sometime in the fall of 1994. (Of the papers mentioned above, only [22] mentions CFL-reachability explicitly and references Yan-nakakis's paper <ref> [28] </ref>.) The constructions of the present paper for converting set-constraint problems to CFL-reachability problems|together with the fact that set constraints have been used for program analysis|show that CFL-reachability using path languages other than Dyck languages is also of utility for program analysis. <p> It is also interesting to note another fact about CFL-reachability: every CFL-reachability problem can be stated as a chain program in DATALOG <ref> [28] </ref>; edges are represented as facts, and productions are encoded as Horn clauses. In fact, the CFL-reachability Algorithm presented here in effect emulates semi-naive bottom-up evaluation of the equivalent DATALOG program.
References-found: 28

