URL: http://cse.ogi.edu/~sheard/papers/dyntyping3.ps
Refering-URL: http://www.cse.ogi.edu/~sheard/sheard.html
Root-URL: http://www.cse.ogi.edu
Email: mbs@dcs.glasgow.ac.uk  sheard@cse.ogi.edu  simonpj@dcs.glasgow.ac.uk  
Title: Dynamic Typing as Staged Type Inference  
Author: Mark Shields Tim Sheard Simon Peyton Jones 
Address: Glasgow  Glasgow  
Affiliation: University of  Oregon Graduate Institute  University of  
Abstract: We introduce a new approach to dynamic typing, based on staged computation, which allows a single type-reconstruction algorithm to execute partly at compile time and partly at run-time. This approach seamlessly extends a single type system to accommodate types that are only known at run-time, while still supporting both type inference and polymorphism. The system is significantly more expressive than other approaches. Furthermore it can be implemented efficiently; most of the type inference is done at compile-time, leaving only some residual unification for run-time. We demonstrate our approach by examples in a small polymorphic functional language, and present its type system, type reconstruction algorithm, and operational semantics. Our proposal could also be readily adapted to many other programming languages. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi, L. Cardelli, B. Pierce, and G. Plotkin. </author> <title> Dynamic typing in a statically typed language. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(2) </volume> <pages> 237-268, </pages> <month> Apr </month> <year> 1991. </year>
Reference-contexts: If, however, the set of types is not known in advance, or is infinite, a universal datatype is required. This is typically impossible for a user to implement if the universal type embeds functions, especially in the presence of polymorphism. Existing proposals for dynamic typing <ref> [1, 17, 2] </ref> solve this problem by introducing a universal datatype of type Dyn as a language primitive, along with two operations: * dynamic t:t , which constructs a dynamic value containing both term t and a representation of its type t . * typecase d of fx 1 : t <p> Static types are generally inferred, and may be implicitly polymorphic with little added complexity for the programmer. Dynamic types must be mentioned explicitly within the branches of a typecase, and dynamic polymorphism is either forbidden <ref> [1] </ref>, restricted [17], or requires the complex machinery of functors and higher order unification [2]. * Combining dynamic values together to construct a new dynamic value is tedious and verbose to write, since each constituent value requires a separate typecase, and the result must be wrapped by dynamic. x3 will demonstrate <p> Solutions to the dual problem of adding dynamic types to a statically typed language appear in CLU and Cedar/Mesa (see <ref> [1] </ref> for a discussion), and were first considered for ML in unpublished work of Mycroft [21]. Most proposals to date have been variations on the typecase construct illustrated in the introduction. These vary in their "resolving power": the ability to distinguish dynamic values based on their type within a typecase. <p> Most proposals to date have been variations on the typecase construct illustrated in the introduction. These vary in their "resolving power": the ability to distinguish dynamic values based on their type within a typecase. At the simpler end of the spectrum is the system of Abadi et al <ref> [1] </ref>, which allows typecase patterns to contain type variables in order to express type dependencies within and between dynamic values. This means a family of dynamic values may be matched by a single typecase arm. However all dynamic values must be monomorphic. <p> Their simplest system allows a polymorphic dynamic value to be distinguished from all of its instances, and also allows a polymorphic dynamic value to be type specialised when pattern matching. Their more complex system also allows type variables within patterns much as in <ref> [1] </ref>. Pattern matching within typecase is formalised as first-order unification under a mixed quantifier prefix. Universally quantified variables denote where a pattern may match a family of dynamic values, where as existentially quantified variables de note where a pattern may match only suitably polymorphic dynamic values. <p> Dubois et al [11] allow functions to implicitly bind the types of their arguments, and also provide a typecase construct to support generic programming. The extension of <ref> [1] </ref> to arbitrary polymorphic dynamic values has also been considered by Abadi et al [2]. Their proposal extends patterns with higher order functor variables in order to match dynamic values with arbitrary polymorphic types. <p> We wish to develop a denotational semantics and semantic soundness theorem to complement the purely syntactical presentation of this paper. Models for monomorphic dynamic values <ref> [1] </ref> and two-level languages [20] have been developed in isolation. Their combination and generalisation to polymorphic dynamic values is non-trivial. Note, however, that their generalisation to arbitrary stages instead of just two should not be problematic, as all stages &gt; 0 may be collapsed to a single dynamic stage.
Reference: [2] <author> M. Abadi, L. Cardelli, B. Pierce, and D. Remy. </author> <title> Dynamic typing in polymorphic languages. </title> <journal> Journal of Functional Programming, </journal> <volume> 5(1) </volume> <pages> 111-130, </pages> <month> Jan </month> <year> 1995. </year>
Reference-contexts: If, however, the set of types is not known in advance, or is infinite, a universal datatype is required. This is typically impossible for a user to implement if the universal type embeds functions, especially in the presence of polymorphism. Existing proposals for dynamic typing <ref> [1, 17, 2] </ref> solve this problem by introducing a universal datatype of type Dyn as a language primitive, along with two operations: * dynamic t:t , which constructs a dynamic value containing both term t and a representation of its type t . * typecase d of fx 1 : t <p> Static types are generally inferred, and may be implicitly polymorphic with little added complexity for the programmer. Dynamic types must be mentioned explicitly within the branches of a typecase, and dynamic polymorphism is either forbidden [1], restricted [17], or requires the complex machinery of functors and higher order unification <ref> [2] </ref>. * Combining dynamic values together to construct a new dynamic value is tedious and verbose to write, since each constituent value requires a separate typecase, and the result must be wrapped by dynamic. x3 will demonstrate many instances where this is required. <p> Abadi et al <ref> [2] </ref> introduced a sufficient syntactic condition on the use of functor variables to guarantee the definiteness of solutions to these unification problems. We argue that our approach, to reject such terms altogether, simplifies our semantics greatly, allows significant implementation optimisations, and does not reduce expressibility critically. <p> Importantly, this restriction only applies to let-bound terms within a defer expression, and not to the way defer expressions are spliced or run. Compare this with the system of Abadi et al <ref> [2] </ref>, which requires higher-order unification to be able to manage dynamic values of polymorphic type. In practice this restriction is too severe; indeed the careful reader will have noticed the let bound expressions in the spectrograph example of x3.2 are not splice-free. <p> Dubois et al [11] allow functions to implicitly bind the types of their arguments, and also provide a typecase construct to support generic programming. The extension of [1] to arbitrary polymorphic dynamic values has also been considered by Abadi et al <ref> [2] </ref>. Their proposal extends patterns with higher order functor variables in order to match dynamic values with arbitrary polymorphic types. This adds a significant complexity to the language, and func tors must be syntactically restricted to avoid requiring full higher-order unification. <p> Once polymorphism is introduced the picture is less clear. We argue that our proposal is conceptually much simpler than that of Abadi et al <ref> [2] </ref>. We also argue that the additional expressiveness of our system over that of Leroy and Mauny [17] can be exploited to add features such as pretty-printing (x3.1) and dynamic code linking (x3.2) to a language simply by the addition of a few primitive functions.
Reference: [3] <author> A. Aiken and E. L. Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 31-41, </pages> <year> 1993. </year>
Reference-contexts: One approach is to abandon static type checking altogether, and instead, tag every run-time value with type information to gracefully detect ill-typed code. Another is to use a more expressive static type system. For example, ad-hoc polymor-phism [27], existential types [23], subtyping polymorphism [7], and set-based types <ref> [3] </ref> all help make writing some of the above programs feasible. A third approach, when the set of types is finite and known at compile-time, is to embed values within a user-defined datatype, effectively tagging them by their type. We call such tagged values dynamic values.
Reference: [4] <author> A. Aiken, E. L. Wimmers, and T. K. Lakshman. </author> <title> Soft typing with conditional types. </title> <booktitle> In Proceedings of the Twenty-First Annual ACM Symposium on Principles of Programming Languages, Portland, Oregon, </booktitle> <pages> pages 163-173, </pages> <year> 1994. </year>
Reference-contexts: For this reason we prefer to leave the check for closed code within the run rewrite rule. 7 Related Work Much work in dynamic typing has concentrated on soft typing : static analyses which determine when run-time type checks may be safely elided from programs in untyped languages <ref> [8, 4, 14] </ref>. Solutions to the dual problem of adding dynamic types to a statically typed language appear in CLU and Cedar/Mesa (see [1] for a discussion), and were first considered for ML in unpublished work of Mycroft [21].
Reference: [5] <author> H. Barendregt. </author> <title> Introduction to generalized type systems. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(2) </volume> <pages> 125-154, </pages> <year> 1991. </year>
Reference-contexts: = x in (f 1 true; f 2 3) would be annotated as let f :8ff; fi : ff ! fi ! ff = ff; fi:fl : x :ff : y :fi : x in (f Nat Bool 1 true; f Nat Nat 2 3) As in pure type systems <ref> [5] </ref> we use ff : fl : t for type abstraction instead of the usual flff : t, and use fl to denote the kind of all types. <p> To this end a type context, , is defined in their type and the stage of the lambda-abstraction they were bound in. As type variables may also be bound at arbitrary stages, we let also map type variables to their kind and stage, much as in pure type systems <ref> [5] </ref>. We abbreviate sequences of type variable bindings within by a single type variable vector binding. We write ftv () for the set of free type variables appearing within the types of term variables in , union the set of type variables themselves in the domain of .
Reference: [6] <author> H. P. Barendregt. </author> <title> Lambda calculi with types. </title> <editor> In S. Abramsky, D. M. Gabbay, and T. S. E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> volume 2, chapter 2, </volume> <pages> pages 117-309. </pages> <publisher> Oxford Science Publishers, </publisher> <year> 1992. </year>
Reference-contexts: We also write fv (t) (ftv (t )) for all the free variables (free type variables only) in term t, and similarly for types. postfix. It is defined much as in Barendregt <ref> [6] </ref>, and takes care to rename the bound variables in lambda abstractions, type abstractions, let and letrec expressions, and the type variable list of deferred expressions. This will be important in x5.4.2. Unit type substitution is also naturally extended to type contexts.
Reference: [7] <author> L. Cardelli, S. Martini, J. C. Mitchell, and A. Scedrov. </author> <title> An extension of system F with subtyping. </title> <journal> Information and Computation, </journal> 109(1/2):4-56, 1994. 
Reference-contexts: One approach is to abandon static type checking altogether, and instead, tag every run-time value with type information to gracefully detect ill-typed code. Another is to use a more expressive static type system. For example, ad-hoc polymor-phism [27], existential types [23], subtyping polymorphism <ref> [7] </ref>, and set-based types [3] all help make writing some of the above programs feasible. A third approach, when the set of types is finite and known at compile-time, is to embed values within a user-defined datatype, effectively tagging them by their type. We call such tagged values dynamic values.
Reference: [8] <author> R. Cartwright and M. Fagan. </author> <title> Soft typing. </title> <booktitle> In ACM SIGPLAN-91 Conference on Programming Language Design and Implementation, </booktitle> <address> Toronto, Ontario, </address> <pages> pages 278-292. </pages> <publisher> ACM Press, </publisher> <month> Jun </month> <year> 1991. </year>
Reference-contexts: For this reason we prefer to leave the check for closed code within the run rewrite rule. 7 Related Work Much work in dynamic typing has concentrated on soft typing : static analyses which determine when run-time type checks may be safely elided from programs in untyped languages <ref> [8, 4, 14] </ref>. Solutions to the dual problem of adding dynamic types to a statically typed language appear in CLU and Cedar/Mesa (see [1] for a discussion), and were first considered for ML in unpublished work of Mycroft [21].
Reference: [9] <author> R. Davies. </author> <title> A temporal logic approach to binding-time analysis. </title> <editor> In E. Clarke, editor, </editor> <booktitle> Proceedings of the Eleventh Annual IEEE Symposium on Logic in Computer Science, </booktitle> <address> New Brunswick, New Jersey, </address> <pages> pages 184-195. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> Jul </month> <year> 1996. </year>
Reference-contexts: This approach requires the programmer to perform complex type checking explicitly. It is also fairly verbose compared with our solution: apply : hi ! hi ! hi apply df dx = h ~ df ~ dx i Our approach is motivated by the recent work of Davies and Pfenning <ref> [10, 9] </ref> and Taha and Sheard [26] in staged computation. Our hi and ~ operators correspond with the next 12 and prev constructs of [10], extended to allow the cross--stage persistence of [26].
Reference: [10] <author> R. Davies and F. Pfenning. </author> <title> A modal analysis of staged computation. </title> <booktitle> In Proceedings of the 23rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <address> St. Petersburg Beach, Florida, </address> <pages> pages 258-270. </pages> <publisher> ACM Press, </publisher> <month> Jan </month> <year> 1996. </year>
Reference-contexts: Our main contribution is to regard dynamic typing as staged type inference, in which some program expressions have their type inference deferred until sufficient context is known at run-time. This approach builds directly on a general notion of staged computation <ref> [10, 26] </ref>, and is free of the above problems: * We introduce three operators for manipulating values of dynamic type, which make creating, combining and using dynamic values easy and concise (x2.2). <p> Then a run expression is rewritten by: run (ht 0 i) ! t 0 These operators have been studied by Davies and Pfenning <ref> [10] </ref> and Taha and Sheard [26], and can be seen as generalis-ing the work of Nielson and Nielson on two level functional languages [22]. <p> This approach requires the programmer to perform complex type checking explicitly. It is also fairly verbose compared with our solution: apply : hi ! hi ! hi apply df dx = h ~ df ~ dx i Our approach is motivated by the recent work of Davies and Pfenning <ref> [10, 9] </ref> and Taha and Sheard [26] in staged computation. Our hi and ~ operators correspond with the next 12 and prev constructs of [10], extended to allow the cross--stage persistence of [26]. <p> Our hi and ~ operators correspond with the next 12 and prev constructs of <ref> [10] </ref>, extended to allow the cross--stage persistence of [26]. Our run operator corresponds to the unbox pop operation of [10], with an appropriate dynamic check for closure. 8 Conclusions and Future Work We presented an approach to dynamic typing which extends staged computation to also stage type inference, and demonstrated its <p> Our hi and ~ operators correspond with the next 12 and prev constructs of <ref> [10] </ref>, extended to allow the cross--stage persistence of [26]. Our run operator corresponds to the unbox pop operation of [10], with an appropriate dynamic check for closure. 8 Conclusions and Future Work We presented an approach to dynamic typing which extends staged computation to also stage type inference, and demonstrated its convenience in programming examples for which type information is difficult (e.g., sprintf x3.1) or impossible (e.g., getCode x3.2) to
Reference: [11] <author> C. Dubois, F. Rouaix, and P. Weis. </author> <title> Extensional poly-morphism. </title> <booktitle> In Proceedings of the 22nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, California, </address> <pages> pages 118-129. </pages> <publisher> ACM Press, </publisher> <month> Jan </month> <year> 1995. </year>
Reference-contexts: Pattern matching within typecase is formalised as first-order unification under a mixed quantifier prefix. Universally quantified variables denote where a pattern may match a family of dynamic values, where as existentially quantified variables de note where a pattern may match only suitably polymorphic dynamic values. Dubois et al <ref> [11] </ref> allow functions to implicitly bind the types of their arguments, and also provide a typecase construct to support generic programming. The extension of [1] to arbitrary polymorphic dynamic values has also been considered by Abadi et al [2].
Reference: [12] <author> J.-Y. Girard. </author> <title> The system F of variable types, Fifteen years later. </title> <editor> In G. Huet, editor, </editor> <booktitle> Logical Foundations of Functional Programming, The UT Year of Programming Series, chapter 6. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Thus x : x + 1 is annotated as x : Nat : x + 1. * We make all type generalisation and specialisation explicit using the type abstraction and application of Sys tem F <ref> [12] </ref>.

Reference: [14] <author> F. Henglein and J. Rehof. </author> <title> Safe polymorphic type inference for a dynamically typed language: Translating Scheme to ML. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 192-203. </pages> <publisher> ACM Press, </publisher> <month> Jun </month> <year> 1995. </year>
Reference-contexts: For this reason we prefer to leave the check for closed code within the run rewrite rule. 7 Related Work Much work in dynamic typing has concentrated on soft typing : static analyses which determine when run-time type checks may be safely elided from programs in untyped languages <ref> [8, 4, 14] </ref>. Solutions to the dual problem of adding dynamic types to a statically typed language appear in CLU and Cedar/Mesa (see [1] for a discussion), and were first considered for ML in unpublished work of Mycroft [21].
Reference: [15] <author> N. D. Jones, C. K. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Pren-tice Hall International, </publisher> <year> 1993. </year>
Reference-contexts: They may be used to improve efficiency by allowing programs to be partially evaluated on-line <ref> [15] </ref>. 2 2.2 Staged Type Inference Our proposal extends these operators to stage the type in ference of dynamic expressions along with their evaluation. * ht i now defers both the type inference and evaluation of t by one stage: 1 + 1 : Nat inferred at compile-time 1 + 1
Reference: [16] <author> P. Lee and M. Leone. </author> <title> Optimizing ML with run-time code generation. </title> <booktitle> In ACM SIGPLAN-96 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 137-148, </pages> <address> Philadelphia, Pennsylvania, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: We currently only have an interpreted implementation of a superset of dyn, so its feasibility will only be known once an abstract machine and compiled implementation exist. Implementing code splicing and run-time type unification efficiently are the primary challenges. The work of Lee and Leone on run-time code generation <ref> [16] </ref> suggests the overhead for splicing may be only a small factor, and the extensive body of research on efficient unification for Prolog suggests type unification could also be inexpensive. We wish to develop a denotational semantics and semantic soundness theorem to complement the purely syntactical presentation of this paper.
Reference: [17] <author> X. Leroy and M. Mauny. </author> <title> Dynamics in ML. </title> <journal> Journal of Functional Programming, </journal> <volume> 3(4) </volume> <pages> 431-463, </pages> <year> 1993. </year>
Reference-contexts: If, however, the set of types is not known in advance, or is infinite, a universal datatype is required. This is typically impossible for a user to implement if the universal type embeds functions, especially in the presence of polymorphism. Existing proposals for dynamic typing <ref> [1, 17, 2] </ref> solve this problem by introducing a universal datatype of type Dyn as a language primitive, along with two operations: * dynamic t:t , which constructs a dynamic value containing both term t and a representation of its type t . * typecase d of fx 1 : t <p> Static types are generally inferred, and may be implicitly polymorphic with little added complexity for the programmer. Dynamic types must be mentioned explicitly within the branches of a typecase, and dynamic polymorphism is either forbidden [1], restricted <ref> [17] </ref>, or requires the complex machinery of functors and higher order unification [2]. * Combining dynamic values together to construct a new dynamic value is tedious and verbose to write, since each constituent value requires a separate typecase, and the result must be wrapped by dynamic. x3 will demonstrate many instances <p> This means a family of dynamic values may be matched by a single typecase arm. However all dynamic values must be monomorphic. Two approaches to supporting polymorphic dynamic values have been explored by Leroy and Mauny <ref> [17] </ref>. Their simplest system allows a polymorphic dynamic value to be distinguished from all of its instances, and also allows a polymorphic dynamic value to be type specialised when pattern matching. Their more complex system also allows type variables within patterns much as in [1]. <p> Once polymorphism is introduced the picture is less clear. We argue that our proposal is conceptually much simpler than that of Abadi et al [2]. We also argue that the additional expressiveness of our system over that of Leroy and Mauny <ref> [17] </ref> can be exploited to add features such as pretty-printing (x3.1) and dynamic code linking (x3.2) to a language simply by the addition of a few primitive functions. There are three main avenues for future research.
Reference: [18] <author> Microsoft. </author> <title> The component object model specification. </title> <type> Technical report, </type> <institution> Microsoft Corporation, </institution> <year> 1995. </year>
Reference-contexts: Using this strategy, a print function may be generated once, and re-applied many times, without the need to re-traverse the format string or re-type-check the resulting code. 3.2 Distributed Computing The distributed programming model popularised by Java and the Microsoft Component Object Model <ref> [18] </ref> allows library code residing on potentially remote machines to be linked, at run-time, into a running program. One challenge is to ensure such distributed programs remain well-typed. We show how our approach supports type-safe distributed programming with little impact on the underlying language.
Reference: [19] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference: [20] <author> E. Moggi. </author> <title> A categorical account of two-level languages. </title> <booktitle> In Proceedings of the Thirteenth Annual Conference on Mathematical Foundations of Programming Semantics, Electronic Notes in Theoretical Computer Science Volume 6. </booktitle> <publisher> Elsevier Science Publishers, </publisher> <year> 1997. </year>
Reference-contexts: We wish to develop a denotational semantics and semantic soundness theorem to complement the purely syntactical presentation of this paper. Models for monomorphic dynamic values [1] and two-level languages <ref> [20] </ref> have been developed in isolation. Their combination and generalisation to polymorphic dynamic values is non-trivial. Note, however, that their generalisation to arbitrary stages instead of just two should not be problematic, as all stages &gt; 0 may be collapsed to a single dynamic stage.
Reference: [21] <author> A. Mycroft. </author> <title> Dynamic types in ML. </title> <type> (unpublished draft article), </type> <year> 1983. </year>
Reference-contexts: Solutions to the dual problem of adding dynamic types to a statically typed language appear in CLU and Cedar/Mesa (see [1] for a discussion), and were first considered for ML in unpublished work of Mycroft <ref> [21] </ref>. Most proposals to date have been variations on the typecase construct illustrated in the introduction. These vary in their "resolving power": the ability to distinguish dynamic values based on their type within a typecase.
Reference: [22] <author> F. Nielson and H. R. Nielson. </author> <title> Two-level Functional Languages. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Then a run expression is rewritten by: run (ht 0 i) ! t 0 These operators have been studied by Davies and Pfenning [10] and Taha and Sheard [26], and can be seen as generalis-ing the work of Nielson and Nielson on two level functional languages <ref> [22] </ref>.
Reference: [23] <author> M. Odersky and K. Laufer. </author> <title> Putting type annotations to work. </title> <booktitle> In Proceedings of the 23rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <address> St. Petersburg Beach, Florida, </address> <pages> pages 54-67. </pages> <publisher> ACM Press, </publisher> <month> Jan </month> <year> 1996. </year>
Reference-contexts: One approach is to abandon static type checking altogether, and instead, tag every run-time value with type information to gracefully detect ill-typed code. Another is to use a more expressive static type system. For example, ad-hoc polymor-phism [27], existential types <ref> [23] </ref>, subtyping polymorphism [7], and set-based types [3] all help make writing some of the above programs feasible. A third approach, when the set of types is finite and known at compile-time, is to embed values within a user-defined datatype, effectively tagging them by their type. <p> Unfortunately, in the dynamic context, the rank-2 polymor-phism of run very quickly spreads to other functions, requiring their type to be given as an explicit annotation, and requiring a very much more sophisticated type system to deal with them <ref> [23] </ref>. This clearly contradicts our claim that we require "no explicit types".
Reference: [24] <author> J. Peterson and K. Hammond. </author> <title> Report on the Programming Language Haskell (Version 1.4), </title> <month> Apr </month> <year> 1997. </year>
Reference-contexts: graphics routines (newWindow and barGraph): map : (ff ! fi) ! Vector ff ! Vector fi fft : Nat ! Vector Complex ! Vector Complex newWindow : String ! IO Window barGraph : Nat ! Vector Real ! Window ! IO () We will use the monadic IO of Haskell <ref> [24] </ref> throughout this example. Side-effecting computations which yield a value of type t have type IO t , and are constructed using primitive operations and the do construct.
Reference: [25] <author> M. Shields, T. Sheard, and S. Peyton Jones. </author> <title> Dynamic typing as staged type inference. </title> <type> Technical Report TR-1997-26, </type> <institution> University of Glasgow, Department of Computing Science, </institution> <month> Aug </month> <year> 1997. </year> <note> Available from http://www.dcs.gla.ac.uk/~mbs/pub/tr_97_26.ps.gz. </note>
Reference-contexts: For example: h ( ~ f )( ~ x )i has two possible decompositions: hE 1 [ ~ f ]i and hE 1 [ ~ x ]i This is easily fixed (see <ref> [25] </ref>) by defining a family of terms and contexts, indexed by stage number. <p> In this paper however we choose to ignore the problem, and assume that when faced with a choice between splice redexes, eval chooses the leftmost. 5.5 Syntactic Soundness We now show our type system and operational semantics are in agreement. The full proof is in <ref> [25] </ref>. Lemma 1 (! Type Preserving) If ` n t : and t ! u then ` n u : Proof By case analysis on t. Most cases are standard, and make use of the usual lemmas for term and type substitution, extended to handle our multi-stage system. <p> That is, run has the rank-2 polymorphic type: run : 8ff : (8* : h*i; ff) ! ff confirming our intuition that a runnable dynamic expression must be runnable in all environments. A formal description of this type system can be found in <ref> [25] </ref>. Unfortunately, in the dynamic context, the rank-2 polymor-phism of run very quickly spreads to other functions, requiring their type to be given as an explicit annotation, and requiring a very much more sophisticated type system to deal with them [23].
Reference: [26] <author> W. Taha and T. Sheard. </author> <title> Multi-stage programming with explicit annotations. In Partial Evaluation and Semantics Based Program Analysis, </title> <address> pages 203-217. </address> <publisher> ACM Press, </publisher> <year> 1997. </year>
Reference-contexts: Our main contribution is to regard dynamic typing as staged type inference, in which some program expressions have their type inference deferred until sufficient context is known at run-time. This approach builds directly on a general notion of staged computation <ref> [10, 26] </ref>, and is free of the above problems: * We introduce three operators for manipulating values of dynamic type, which make creating, combining and using dynamic values easy and concise (x2.2). <p> Then a run expression is rewritten by: run (ht 0 i) ! t 0 These operators have been studied by Davies and Pfenning [10] and Taha and Sheard <ref> [26] </ref>, and can be seen as generalis-ing the work of Nielson and Nielson on two level functional languages [22]. <p> We briefly outline an enhancement to the type system of x5.3 which will reject examples such as these at compile time instead of run-time. This is based on a type system developed in previous work <ref> [26] </ref>. The type hi of deferred expressions is now partitioned into a type h*i for each environment *. The type checker keeps track of the environment each variable belongs to, in addition to its usual type and stage. <p> It is also fairly verbose compared with our solution: apply : hi ! hi ! hi apply df dx = h ~ df ~ dx i Our approach is motivated by the recent work of Davies and Pfenning [10, 9] and Taha and Sheard <ref> [26] </ref> in staged computation. Our hi and ~ operators correspond with the next 12 and prev constructs of [10], extended to allow the cross--stage persistence of [26]. <p> h ~ df ~ dx i Our approach is motivated by the recent work of Davies and Pfenning [10, 9] and Taha and Sheard <ref> [26] </ref> in staged computation. Our hi and ~ operators correspond with the next 12 and prev constructs of [10], extended to allow the cross--stage persistence of [26].
Reference: [27] <author> P. Wadler and S. Blott. </author> <title> How to make ad-hoc polymor-phism less ad hoc. </title> <booktitle> In Proceedings of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 60-76, </pages> <year> 1989. </year>
Reference-contexts: One approach is to abandon static type checking altogether, and instead, tag every run-time value with type information to gracefully detect ill-typed code. Another is to use a more expressive static type system. For example, ad-hoc polymor-phism <ref> [27] </ref>, existential types [23], subtyping polymorphism [7], and set-based types [3] all help make writing some of the above programs feasible. A third approach, when the set of types is finite and known at compile-time, is to embed values within a user-defined datatype, effectively tagging them by their type.
Reference: [28] <author> A. K. Wright and M. Felleisen. </author> <title> A syntactic approach to type soundness. </title> <journal> Information and Computation, </journal> <volume> 115(1) </volume> <pages> 38-94, </pages> <month> Nov </month> <year> 1994. </year>
Reference-contexts: Type variables must be in scope, and be binding time correct exactly as for term variables. Its definition is straightforward. Rule run ensures t yields a defer expression, and the exception expression u has a type consistent with the run expression's context. 5.4 Operational Semantics Following Wright and Felleisen <ref> [28] </ref> we present our operational semantics as a rewrite system with explicit redex contexts. This small-step semantics is entirely syntactical and simplifies our proof of type soundness. We distinguish a subset of terms to be values, shown in Figure 6.
References-found: 27

