URL: http://www.cs.gatech.edu/fac/rama/students/gukal/concurrency.ps.Z
Refering-URL: http://www.cs.gatech.edu/fac/rama/students/gukal/index.html
Root-URL: 
Email: e-mail: gukal@cc.gatech.edu  
Phone: Phone: (404) 853-9390  
Title: An Efficient Transient Versioning Method  
Author: Sreenivas Gukal Edward Omiecinski Umakishore Ramachandran 
Address: Atlanta, GA 30332  
Affiliation: College of Computing Georgia Institute of Technology  
Abstract: High-performance database systems have to support ad-hoc queries while providing high transaction throughput. Transient versioning methods, where prior versions are maintained temporarily, are developed to execute queries without affecting concurrent transactions. However, transactions in these methods do not exploit the prior versions. This paper presents a transient-versioning method, called Dynamic Versioning, which uses the transient versions to not only support queries but also increase concurrency among transactions. Data conflicts due to incompatible requests are resolved by dynamically creating dependence orders among the requesting transactions and queries. These orders help precisely identify the prior versions that have to be kept to ensure serializability for the queries. Since only the required versions are stored, the storage overhead for the transient versions is reduced to the minimum possible. We also propose techniques to efficiently support queries, based on their lengths and access patterns. We present the results of simulation experiments that show that our method provides high transaction concurrency and supports queries almost as efficiently as the other transient-versioning methods, while incurring only a fraction of the storage overhead. 
Abstract-found: 1
Intro-found: 1
Reference: [Agar 87a] <author> Agrawal, R., Carey, M., Livny, M. </author> <title> Concurrency Control Performance Modeling: Alternatives and Implications, </title> <journal> ACM Transactions on Database Systems, </journal> <month> December </month> <year> 1987. </year>
Reference-contexts: The operation time models the time for accessing the data item, performing any computations using the fetched value and determining the new value for the data item in case of updates. Resources are modeled in terms of resource units (similar to <ref> [Agar 87a] </ref> and [Agar 87b]). Each resource unit contains one CPU and two disks. Data pages are uniformly distributed among all the 8 available disks. Transactions from a common CPU queue are assigned to an available CPU.
Reference: [Agar 87b] <author> Agrawal, R., Carey, M., McVoy, L. </author> <title> The Performance of Alternative Strategies for Dealing with Deadlocks in Database Management Systems, </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> December </month> <year> 1987. </year>
Reference-contexts: The operation time models the time for accessing the data item, performing any computations using the fetched value and determining the new value for the data item in case of updates. Resources are modeled in terms of resource units (similar to [Agar 87a] and <ref> [Agar 87b] </ref>). Each resource unit contains one CPU and two disks. Data pages are uniformly distributed among all the 8 available disks. Transactions from a common CPU queue are assigned to an available CPU.
Reference: [AgSe 89] <author> Agrawal, D., Sengupta, S. </author> <title> Modular Synchronization in Multiversion Databases: Version Control and Concurrency Control, </title> <booktitle> ACM SIGMOD International Conference on Management of Data, </booktitle> <month> May </month> <year> 1989. </year>
Reference-contexts: These algorithms maintain prior versions of updated data items. Queries can read the prior versions, while transactions update the current version. The prior versions are transient; they are removed when the queries no longer need them. The transient-versioning algorithms proposed (eg., <ref> [AgSe 89] </ref>, [Chan 82], [Bobe 92a], [Moha 92]) use the prior versions only to support queries. Transactions see only the current version and execute based on a single-version concurrency control scheme. <p> Allowing multiple writers makes the task of maintaining the dependence graph NP-complete [Hadz 88]. In addition, keeping only a single committed version blocks the transactions from committing if a query is using the committed version. Several other approaches for supporting transient versioning have been proposed ([Reed 78], <ref> [AgSe 89] </ref>, [Moha 92], [Chan 82], [Bobe 92a], [Bobe 92b]). Multiversion timestamp ordering was introduced by [Reed 78]. Although read requests are never rejected, they may be blocked and may cause update transactions to abort. Another method that uses prior versions to support queries is described in [Chan 82]. <p> A fixed space on each data page is reserved for caching versions. The same method is extended in [Bobe 92b] to support queries of weaker consistencies more efficiently. The method presented in <ref> [AgSe 89] </ref> assigns a unique version number to all the versions created by a committed transaction. Each query is provided with a version number which determines which prior versions the query can access. This method is generalized to version periods by Mohan et al., [Moha 92].
Reference: [Baye 80] <author> Bayer, R., Heller, H., Reiser, A. </author> <title> Parallelism and Recovery in Database Systems, </title> <journal> ACM Transactions on Database Systems, </journal> <month> June </month> <year> 1980. </year>
Reference-contexts: Since it is beyond the scope of this paper to refer to all of them, we mention only the relevant work. A two-version two-phase locking algorithm was proposed by Bayer et al. <ref> [Baye 80] </ref>. The algorithm is based on the observation that in a shadowing environment all updates are done only to the shadow pages. Since the prior copies of the pages are maintained for recovery purposes, this algorithm proposes 2 that the readers be allowed to read the "before" values. <p> Since the prior copies of the pages are maintained for recovery purposes, this algorithm proposes 2 that the readers be allowed to read the "before" values. Two-version and multi-version two-phase locking methods are also presented in [Bern 87]. The two-version method is similar to that in <ref> [Baye 80] </ref>. The multi-version algorithm assumes that for a data item there is a single committed version used by readers and several uncommitted versions simultaneously being updated by the writers. Allowing multiple writers makes the task of maintaining the dependence graph NP-complete [Hadz 88].
Reference: [Bern 87] <author> Bernstein, P.A., Hadzilacos, V., Goodman, N. </author> <title> Concurrency Control and Recovery in Database Systems, </title> <publisher> Addison-Wesley Pub. Co., </publisher> <year> 1987. </year>
Reference-contexts: Since the prior copies of the pages are maintained for recovery purposes, this algorithm proposes 2 that the readers be allowed to read the "before" values. Two-version and multi-version two-phase locking methods are also presented in <ref> [Bern 87] </ref>. The two-version method is similar to that in [Baye 80]. The multi-version algorithm assumes that for a data item there is a single committed version used by readers and several uncommitted versions simultaneously being updated by the writers.
Reference: [Bobe 92a] <author> Bober, P., Carey, M. </author> <title> On Mixing Queries and Transactions via Multiversion Locking, </title> <booktitle> Proc. 8th International Conference on Data Engineering, </booktitle> <month> February </month> <year> 1992. </year>
Reference-contexts: These algorithms maintain prior versions of updated data items. Queries can read the prior versions, while transactions update the current version. The prior versions are transient; they are removed when the queries no longer need them. The transient-versioning algorithms proposed (eg., [AgSe 89], [Chan 82], <ref> [Bobe 92a] </ref>, [Moha 92]) use the prior versions only to support queries. Transactions see only the current version and execute based on a single-version concurrency control scheme. <p> In addition, keeping only a single committed version blocks the transactions from committing if a query is using the committed version. Several other approaches for supporting transient versioning have been proposed ([Reed 78], [AgSe 89], [Moha 92], [Chan 82], <ref> [Bobe 92a] </ref>, [Bobe 92b]). Multiversion timestamp ordering was introduced by [Reed 78]. Although read requests are never rejected, they may be blocked and may cause update transactions to abort. Another method that uses prior versions to support queries is described in [Chan 82]. This method employs page-level versioning and locking. <p> Although read requests are never rejected, they may be blocked and may cause update transactions to abort. Another method that uses prior versions to support queries is described in [Chan 82]. This method employs page-level versioning and locking. Prior versions are stored in a version pool. Bober & Carey <ref> [Bobe 92a] </ref> improve this method to support record-level versioning. Queries are synchronized using multi-version timestamp ordering. Since timestamp ordering is used, the versions created after a query is started are maintained until the query completes. A fixed space on each data page is reserved for caching versions. <p> Our method builds on the transient versioning ideas proposed by Bober & Carey <ref> [Bobe 92a] </ref> and Mohan et al., [Moha 92], while avoiding the storage overhead inherent in those two schemes. The following subsections describe the design of the dynamic versioning method. A small example sketched in Figure 1 is used to illustrate various concepts in the following discussion. <p> The overhead for garbage collection can be reduced using a "lazy" approach: an unnecessary prior version in a page is deleted only when a transaction tries to create a new version in the same page. Such an approach (similar to the method followed in <ref> [Bobe 92a] </ref>) is inexpensive since creating the new version will in any case dirty the page. 3.3 Supporting Queries One of the important problems in concurrency control [Dewi 92] is to prevent the execution of read-only transactions (referred as queries) from affecting concurrent update transactions (i.e., transactions which also update some <p> The idea in the second DV technique is similar to multi-version timestamp ordering (same as the method by Bober & Carey <ref> [Bobe 92a] </ref>). Third Technique The large space overhead in the second technique can be reduced in some 7 cases, without acquiring locks. The reason for the large space overhead in the second technique is that a query is made a predecessor of all uncommitted transactions. <p> The third technique is best suited for long-running queries accessing small and well-defined parts of the database. 4 Simulation Experiments and Results The simulation experiments evaluate the performance of the DV method compared to the methods of Bober & Carey <ref> [Bobe 92a] </ref> and Mohan et al., [Moha 92], the two recent transient versioning methods described in Section 2. This section reports the results of four simulation experiments. The first three experiments compare the three methods in an environment containing only transactions. <p> The record modification time and the operation time are exponentially distributed. We assume an 80-20 reference pattern (i.e., 80% of the references go to 20% of the database), since uniform reference pattern does not model hot-spot pages. 4.3 Transaction Concurrency The methods by <ref> [Bobe 92a] </ref> and [Moha 92] use the standard single version two-phase locking method for concurrency control for transactions. The transactions in these methods do not see the prior versions and are not affected by them. <p> The variable parameter values used are listed in Table 3. In this simulation, we compared the first DV technique with the methods by Bober & Carey <ref> [Bobe 92a] </ref> (same as the second DV technique) and Mohan et. al. [Moha 92]. In all the three methods, queries are not affected by the transactions and hence are independent of the extent of data contention. <p> If the version period is switched after 2000 transactions, the number of versions nearly doubles to 8961. 2 We consider only the two version period algorithm here, since it has less space overhead than the multiple version period algorithm. 16 The methods by Bober & Carey <ref> [Bobe 92a] </ref> and Mohan et. al. [Moha 92] use the transient versions to both eliminate locking overhead for queries and avoid blocking of transactions by queries. The DV method (first technique) incurs the locking overhead for queries. <p> We also developed different techniques for efficiently executing queries based on their lengths and access patterns. We presented results of simulation experiments that compared the performance and overheads of the dynamic versioning method with those of two other recent transient versioning methods ([Moha 92], <ref> [Bobe 92a] </ref>). The following are the main conclusions of our study. 17 * The DV method significantly reduces the number of transactions blocked due to data con- tention. <p> of short and long transactions, the DV method significantly reduces the starvation of short transactions by long transactions. * The DV method executes queries almost as efficiently as the other two methods. * The storage overhead for the transient versions in the DV method is only 25% of that for <ref> [Bobe 92a] </ref> and significantly lower than that needed by [Moha 92].
Reference: [Bobe 92b] <author> Bober, P., Carey, M. </author> <title> Multiversion query locking, </title> <booktitle> Proc. 18th International Conference on Very Large Data Bases, </booktitle> <month> August </month> <year> 1992. </year>
Reference-contexts: In addition, keeping only a single committed version blocks the transactions from committing if a query is using the committed version. Several other approaches for supporting transient versioning have been proposed ([Reed 78], [AgSe 89], [Moha 92], [Chan 82], [Bobe 92a], <ref> [Bobe 92b] </ref>). Multiversion timestamp ordering was introduced by [Reed 78]. Although read requests are never rejected, they may be blocked and may cause update transactions to abort. Another method that uses prior versions to support queries is described in [Chan 82]. This method employs page-level versioning and locking. <p> Queries are synchronized using multi-version timestamp ordering. Since timestamp ordering is used, the versions created after a query is started are maintained until the query completes. A fixed space on each data page is reserved for caching versions. The same method is extended in <ref> [Bobe 92b] </ref> to support queries of weaker consistencies more efficiently. The method presented in [AgSe 89] assigns a unique version number to all the versions created by a committed transaction. Each query is provided with a version number which determines which prior versions the query can access.
Reference: [Chan 82] <author> Chan, A., et al, </author> <title> The Implementation of an Integrated Concurrency Control and Recovery Scheme, </title> <booktitle> ACM SIGMOD International Conference on Management of Data, </booktitle> <month> June </month> <year> 1982. </year> <month> 18 </month>
Reference-contexts: These algorithms maintain prior versions of updated data items. Queries can read the prior versions, while transactions update the current version. The prior versions are transient; they are removed when the queries no longer need them. The transient-versioning algorithms proposed (eg., [AgSe 89], <ref> [Chan 82] </ref>, [Bobe 92a], [Moha 92]) use the prior versions only to support queries. Transactions see only the current version and execute based on a single-version concurrency control scheme. <p> In addition, keeping only a single committed version blocks the transactions from committing if a query is using the committed version. Several other approaches for supporting transient versioning have been proposed ([Reed 78], [AgSe 89], [Moha 92], <ref> [Chan 82] </ref>, [Bobe 92a], [Bobe 92b]). Multiversion timestamp ordering was introduced by [Reed 78]. Although read requests are never rejected, they may be blocked and may cause update transactions to abort. Another method that uses prior versions to support queries is described in [Chan 82]. <p> proposed ([Reed 78], [AgSe 89], [Moha 92], <ref> [Chan 82] </ref>, [Bobe 92a], [Bobe 92b]). Multiversion timestamp ordering was introduced by [Reed 78]. Although read requests are never rejected, they may be blocked and may cause update transactions to abort. Another method that uses prior versions to support queries is described in [Chan 82]. This method employs page-level versioning and locking. Prior versions are stored in a version pool. Bober & Carey [Bobe 92a] improve this method to support record-level versioning. Queries are synchronized using multi-version timestamp ordering.
Reference: [Dewi 92] <author> DeWitt, D., Gray, J. </author> <title> Parallel Database Systems: The Future of High Performance Database Systems, </title> <journal> Communications of the ACM, </journal> <month> June </month> <year> 1992. </year>
Reference-contexts: 1 Introduction One of the important concurrency control problems in high-performance database systems <ref> [Dewi 92] </ref> is to prevent the execution of queries (read-only transactions) from affecting concurrent update transactions. Long-running queries lock the data items for a long time and may starve transactions trying to update the same data items. <p> Such an approach (similar to the method followed in [Bobe 92a]) is inexpensive since creating the new version will in any case dirty the page. 3.3 Supporting Queries One of the important problems in concurrency control <ref> [Dewi 92] </ref> is to prevent the execution of read-only transactions (referred as queries) from affecting concurrent update transactions (i.e., transactions which also update some data items, called transactions in the rest of the paper).
Reference: [Gray 93] <author> Gray, J., Reuter, A. </author> <title> Transaction Processing: Concepts and Techniques, </title> <publisher> Morgan Kauf-mann Publishers, </publisher> <year> 1993. </year>
Reference-contexts: Usually a database page contains some free space to accommodate growing tuples or for inserting new tuples <ref> [Gray 93] </ref>. This space in a data page may be used for holding the transient versions of the records on the same data page. Since the number of versions maintained is small, in most cases this space should be sufficient. <p> Hence at low data contention (which means less chance of repeated conflicts), DV has the same or lower number of aborts than 2PL. At higher data contentions, DV results in more aborts. Note that in an actual system, aborts are rare <ref> [Gray 93] </ref>. In such an environment, DV will have the same or lower number of transaction aborts than 2PL, while reducing the blocking considerably. is increased, the throughput of both the methods reduces. However, the reduction in throughput for DV is much lower than that of 2PL.
Reference: [Gray 76] <author> Gray, J., Lorie, R., Putzolu, F., Traiger, I. </author> <title> Granularity of Locks and Degrees of Consistency in a Shared Data Base, Modeling in Data Base Systems, </title> <publisher> North Holland Publishing, </publisher> <year> 1976. </year>
Reference-contexts: One solution is to violate serializability and run the queries at degree 2 or degree 1 isolation <ref> [Gray 76] </ref>. 6 The problem becomes interesting if the queries wish to see a transaction consistent database. We consider here only the problem of running queries at degree 3 isolation, which requires repeatable reads.
Reference: [Hadz 88] <author> Hadzilacos, T. </author> <title> Serialization graph algorithms for multiversion concurrency control, </title> <booktitle> ACM SIGMOD International Conference on Management of Data, </booktitle> <month> March </month> <year> 1988. </year>
Reference-contexts: The multi-version algorithm assumes that for a data item there is a single committed version used by readers and several uncommitted versions simultaneously being updated by the writers. Allowing multiple writers makes the task of maintaining the dependence graph NP-complete <ref> [Hadz 88] </ref>. In addition, keeping only a single committed version blocks the transactions from committing if a query is using the committed version. Several other approaches for supporting transient versioning have been proposed ([Reed 78], [AgSe 89], [Moha 92], [Chan 82], [Bobe 92a], [Bobe 92b]).
Reference: [Moha 92] <author> Mohan, C., Pirahesh, H., Lorie, R. </author> <title> Efficient and Flexible Methods for Transient Ver-sioning of Records to Avoid Locking by Read-Only Transactions, </title> <booktitle> ACM SIGMOD International Conference on Management of Data, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: These algorithms maintain prior versions of updated data items. Queries can read the prior versions, while transactions update the current version. The prior versions are transient; they are removed when the queries no longer need them. The transient-versioning algorithms proposed (eg., [AgSe 89], [Chan 82], [Bobe 92a], <ref> [Moha 92] </ref>) use the prior versions only to support queries. Transactions see only the current version and execute based on a single-version concurrency control scheme. <p> This flexibility enables DV to support queries using a minimum number of prior versions. We present simulation experiments which compare the performance and overheads of the dynamic versioning method with those of two recent transient versioning methods ([Bobe 92a], <ref> [Moha 92] </ref>). The results show that DV reduces the number of transactions blocked due to data contention by 60% to 90%. The higher concurrency results in better resource utilization and higher transaction throughput. <p> Allowing multiple writers makes the task of maintaining the dependence graph NP-complete [Hadz 88]. In addition, keeping only a single committed version blocks the transactions from committing if a query is using the committed version. Several other approaches for supporting transient versioning have been proposed ([Reed 78], [AgSe 89], <ref> [Moha 92] </ref>, [Chan 82], [Bobe 92a], [Bobe 92b]). Multiversion timestamp ordering was introduced by [Reed 78]. Although read requests are never rejected, they may be blocked and may cause update transactions to abort. Another method that uses prior versions to support queries is described in [Chan 82]. <p> The method presented in [AgSe 89] assigns a unique version number to all the versions created by a committed transaction. Each query is provided with a version number which determines which prior versions the query can access. This method is generalized to version periods by Mohan et al., <ref> [Moha 92] </ref>. In this method, queries read the stable version of the database of the previous version period, while update transactions execute in the current version period. <p> Storing all the prior versions results in a huge storage overhead. The two recent methods described above ([Bobe 92a] and <ref> [Moha 92] </ref>) are good representatives of all the transient versioning methods. They are based on earlier methods but are more efficient and flexible. <p> Our method builds on the transient versioning ideas proposed by Bober & Carey [Bobe 92a] and Mohan et al., <ref> [Moha 92] </ref>, while avoiding the storage overhead inherent in those two schemes. The following subsections describe the design of the dynamic versioning method. A small example sketched in Figure 1 is used to illustrate various concepts in the following discussion. <p> The third technique is best suited for long-running queries accessing small and well-defined parts of the database. 4 Simulation Experiments and Results The simulation experiments evaluate the performance of the DV method compared to the methods of Bober & Carey [Bobe 92a] and Mohan et al., <ref> [Moha 92] </ref>, the two recent transient versioning methods described in Section 2. This section reports the results of four simulation experiments. The first three experiments compare the three methods in an environment containing only transactions. <p> The record modification time and the operation time are exponentially distributed. We assume an 80-20 reference pattern (i.e., 80% of the references go to 20% of the database), since uniform reference pattern does not model hot-spot pages. 4.3 Transaction Concurrency The methods by [Bobe 92a] and <ref> [Moha 92] </ref> use the standard single version two-phase locking method for concurrency control for transactions. The transactions in these methods do not see the prior versions and are not affected by them. <p> The variable parameter values used are listed in Table 3. In this simulation, we compared the first DV technique with the methods by Bober & Carey [Bobe 92a] (same as the second DV technique) and Mohan et. al. <ref> [Moha 92] </ref>. In all the three methods, queries are not affected by the transactions and hence are independent of the extent of data contention. <p> version period is switched after 2000 transactions, the number of versions nearly doubles to 8961. 2 We consider only the two version period algorithm here, since it has less space overhead than the multiple version period algorithm. 16 The methods by Bober & Carey [Bobe 92a] and Mohan et. al. <ref> [Moha 92] </ref> use the transient versions to both eliminate locking overhead for queries and avoid blocking of transactions by queries. The DV method (first technique) incurs the locking overhead for queries. <p> reduces the starvation of short transactions by long transactions. * The DV method executes queries almost as efficiently as the other two methods. * The storage overhead for the transient versions in the DV method is only 25% of that for [Bobe 92a] and significantly lower than that needed by <ref> [Moha 92] </ref>.
Reference: [Pira 90] <author> Pirahesh, H., Mohan, C., Cheng, J., Liu, T.S., Selinger, P. </author> <title> Parallelism in Relational Database Systems: </title> <booktitle> Architectural Issues and Design Approaches, IEEE 2nd Int'l Symp. on Databases in Parallel and Distributed Systems, </booktitle> <month> July </month> <year> 1990. </year>
Reference-contexts: Long-running queries lock the data items for a long time and may starve transactions trying to update the same data items. Transient-versioning algorithms have been proposed as an elegant way to support queries without affecting transactions <ref> [Pira 90] </ref>. These algorithms maintain prior versions of updated data items. Queries can read the prior versions, while transactions update the current version. The prior versions are transient; they are removed when the queries no longer need them.
Reference: [Reed 78] <author> Reed, D. </author> <title> Naming and Synchronization in a Decentralized Computer System, </title> <type> PhD Thesis, Technical Report MIT/LCS/TR-205, </type> <institution> MIT, </institution> <month> September </month> <year> 1978. </year>
Reference-contexts: In addition, keeping only a single committed version blocks the transactions from committing if a query is using the committed version. Several other approaches for supporting transient versioning have been proposed (<ref> [Reed 78] </ref>, [AgSe 89], [Moha 92], [Chan 82], [Bobe 92a], [Bobe 92b]). Multiversion timestamp ordering was introduced by [Reed 78]. Although read requests are never rejected, they may be blocked and may cause update transactions to abort. Another method that uses prior versions to support queries is described in [Chan 82]. This method employs page-level versioning and locking. Prior versions are stored in a version pool.
Reference: [Schw 90] <author> Schwetman, H. </author> <title> CSIM Users Guide, </title> <month> March </month> <year> 1990. </year> <month> 19 </month>
Reference-contexts: The same sets of transactions are used for all methods. For each set of input parameters, the system is simulated on a number of transaction sets until the 90% confidence interval for the transaction throughput is within a few percent. The simulator is written in CSIM <ref> [Schw 90] </ref>, a process-oriented simulation package. 9 Database Parameters Transaction Parameters Data Base Size 150,000 records References per Transaction Records per Data Page 10 Percentage of updates Page Fill Factor 83% Data Access Pattern 80-20 Resource Parameters Lock Acquisition (Release) Time 500 s Number of Resource Unitsy Latch Acquisition (Release) Time
References-found: 16

