URL: http://www.cs.indiana.edu/~asengupt/asengupt/thesis/oral/oral.ps
Refering-URL: http://www.cs.indiana.edu/~asengupt/
Root-URL: http://www.cs.indiana.edu
Title: Design and Implementation of a Database Environment for the Manipulation of Structured Documents  
Author: Arijit Sengupta 
Date: May 10, 1995  
Abstract: A method for implementing a structured document database system is presented. The present-day systems dealing with structured or tagged documents have not been able to produce capabilities that even simple database systems possess the ability to query the database based on the various properties of the database. Research in this area also has not been able to produce query languages and visual query interfaces similar to those that exist in the relational domain. The goal for the present research is to develop a complete database system for structured documents having data definition, manipulation and querying capabilities similar to those in the relational world. Only structured documents tagged with the SGML [Gol90] have been considered, in which detailed and complete information about the document structuring can be obtained from the Document Type Definition (DTD). Special systems that have been considered, used and evaluated are PAT (Open Text 5.0) [Ope94], sgmls 1.1, Exodus [Uni93], Shore [CDNM94] for purposes of data structures, parsing, data storage and retrieval, etc. Special considerations have been given to three special cases of data for experimentation purposes: (a) the Oxford English Dictionary (OED) database, (b) the Chadwyck Healy English Poetry full-text database, and (c) an experimental movie database. 
Abstract-found: 1
Intro-found: 1
Reference: [AB90] <author> A. L. Ambler and M.M. Burnett. </author> <title> Visual programming, programming by example, and program visualization : a taxonomy. </title> <editor> In E. P. Glinert, editor, </editor> <title> Visual programming environments : paradigms and systems. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1990. </year>
Reference-contexts: We plan to explore various methods of document visualization for this purpose. Two prominent visualization methods that are seem promising are the (i) Query By Example (QBE) [Ull88] and (ii) Programming by Example <ref> [AB90] </ref> (can be looked at as Querying by instance in the database scenario) 4.5.1 Query By Example The basic structure of a document can be obtained from the DTD (document type definition) [Gol90, SMB94].
Reference: [ACM93] <author> Serge Abiteboul, Sophie Cluet, and Tova Milo. </author> <title> Querying and updating the file. </title> <booktitle> Proceedings, 19th Intl. Conference on Very Large Data Bases, </booktitle> <pages> pages 73-84, </pages> <year> 1993. </year>
Reference-contexts: However, letting a query language do quantification over complex sorts inherently introduces the possibility of explosive complexity. In another variation of the complex-object approach, Abiteboul et al. <ref> [ACM93] </ref> and Christophides et al. [CACS94] used an object-oriented database to model textual data, especially data encoded in SGML format [Gol90].
Reference: [BBB + 88] <author> F. Bancilhon, G. Barbedette, V. Benzaken, C. Delobel, S. Gamerman, C. Lecluse, P. Pfeffer, P. Richard, and F. Velez. </author> <title> The design and implementation of O2, an object-oriented database system. </title> <editor> In K. R. Dittrich, editor, </editor> <booktitle> Advances in Object-Oriented Database Sys., volume 334 of Lecture Notes in CS, </booktitle> <pages> page 1. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1988. </year>
Reference-contexts: They used a mapping procedure to map the Data Type Definition (DTD) for the document into an object-oriented class definition in the language CO 2 , which is the programming language in the object-oriented database environment O 2 <ref> [BBB + 88] </ref>. In this mapping procedure, the document written in SGML was mapped to an instance of the class schema declared from the DTD. The query language associated with O 2 is then used to query the data.
Reference: [BYG89] <author> Richard A. Baeza-Yates and Gaston H. Gonnet. </author> <title> Efficient text searching of regular expressions. </title> <booktitle> Proceedings, 16th International Colloquium on Automata, Languages, and Programming, </booktitle> <pages> pages 46-62, </pages> <year> 1989. </year>
Reference-contexts: A data structure for indexing the data is first decided upon, and operations are provided that are efficient in utilizing the constructed data structure. The 5 work by Gonnet et al. is most notable in this approach. They used an indexing approach <ref> [GBY91, BYG89] </ref> with Patricia trees for prefix searches on semi-infinite strings (sistrings). The PAT software [Ope94] from Open Text uses this indexing approach for its query processing. The base for our work will be the PAT software.
Reference: [CACS94] <author> V. Christophides, S. Abiteboul, S. Cluet, and M. Scholl. </author> <title> From structured documents to novel query facilities. </title> <booktitle> SIGMOD RECORD, </booktitle> <volume> 23(2) </volume> <pages> 313-324, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: However, letting a query language do quantification over complex sorts inherently introduces the possibility of explosive complexity. In another variation of the complex-object approach, Abiteboul et al. [ACM93] and Christophides et al. <ref> [CACS94] </ref> used an object-oriented database to model textual data, especially data encoded in SGML format [Gol90]. <p> The next section deals with some of the queries that appear to be quite simple, but they are not possible with PAT and its query language. Moreover, PAT does not support updates. 6 * Object-oriented strategies, such as the one adopted by Christophides et al <ref> [CACS94] </ref>, seem to be able to incorporate most of the standard queries.
Reference: [CDNM94] <author> M. Carey, D. DeWitt, J. Naughton, and M.Solomon. </author> <title> Shoring up persistent applications. </title> <booktitle> ACM Sigmod Conference Proceedings, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: There are many different options for the implementation: 1. From Scratch: Build the system from scratch, using the indexing mechanisms for the words and regions, based on the Shore <ref> [CDNM94] </ref> or Exodus [Uni93] storage managers to store and retrieve data. In this case, efficiency regarding the word-related queries, such as regular expression searches, might not be achievable starting from scratch, but can possibly be accomplished through future enhancement. 13 2.
Reference: [Cha94] <author> Chadwyck-Healey. </author> <title> The English Poetry Full-Text Database, </title> <note> 1994. The works of more than 1,250 poets from 600 to 1900. </note>
Reference-contexts: However, the DTD sometimes has too much information for a simple document structure such as poems 12 <ref> [Cha94] </ref>. The first implementation of the interface would have the structure of a poem or the dictionary built into it which can be later restructured for use with any general DTD.
Reference: [CM94] <author> Mariano P. Consens and Tova Milo. </author> <title> Optimizing queries on files. </title> <booktitle> SIGMOD RECORD, </booktitle> <volume> 23(2) </volume> <pages> 301-312, </pages> <month> June </month> <year> 1994. </year>
Reference: [Col89] <author> Latha S. Colby. </author> <title> A recursive algebra for nested relations. </title> <type> Technical Report 259, </type> <institution> Indiana University, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: Fortunately, it has been experimentally shown that almost all of the possible queries (for relational systems) can be solved in polynomial time [Ull88]. For that reason, care is taken to keep the query languages within the polynomial complexity bounds. In fact, there has been much ongoing work <ref> [Col92, Col89] </ref> to keep expressive query languages within the polynomial boundary by imposing constraints and structures in the language. The structure of document databases is inherently complex, so any language utilizing the complex structure of the documents might have to be quite expressive.
Reference: [Col92] <author> Latha S. Colby. </author> <title> An algebra for list-oriented applications. </title> <type> Technical Report 347, </type> <institution> Indiana University, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: Fortunately, it has been experimentally shown that almost all of the possible queries (for relational systems) can be solved in polynomial time [Ull88]. For that reason, care is taken to keep the query languages within the polynomial complexity bounds. In fact, there has been much ongoing work <ref> [Col92, Col89] </ref> to keep expressive query languages within the polynomial boundary by imposing constraints and structures in the language. The structure of document databases is inherently complex, so any language utilizing the complex structure of the documents might have to be quite expressive. <p> Without a theoretical support, any language is bound to get restricted to ad-hoc syntaxes and structures. In our case, much theoretical foundation is provided by the work by Colby et al. <ref> [Col92] </ref> and also by Gonnet:87,Murata:92. A very recent work by Murata [Mur95] has also influenced a lot of the theory behind the proposed system.
Reference: [DGS86] <author> B.C. Desai, P. Goyal, and F. Sadri. </author> <title> A data model for use with formatted and textual data. </title> <address> JASIS, </address> <year> 1986. </year>
Reference-contexts: The ongoing work using this approach can be further divided into two broad categories based on the underlying theory behind the work: * Complex Object Approach: Desai et al. <ref> [DGS86] </ref> and Guting et al. [GZC89] used an algebraic approach in which they used constructs for specifying queries in algebraic form, with complex-object constructs 4 like set, unnest, project and group-by. The algebraic approach gave the possibility of optimization and rewriting or rephrasing queries.
Reference: [GBY91] <author> Gaston H. Gonnet and R. Baeza-Yates. </author> <title> Lexicographical indices for text: Inverted files vs pat trees. </title> <type> Technical Report TR-OED-91-01, </type> <institution> University of Waterloo, </institution> <year> 1991. </year>
Reference-contexts: Section 2 discusses the State of the Art in Databases as well as Structured Documents. This section also introduces the PAT system [Ope94] 1 and the Patricia Tree <ref> [GBY91] </ref> data structure. Section 3 discusses the General research questions involved. <p> A data structure for indexing the data is first decided upon, and operations are provided that are efficient in utilizing the constructed data structure. The 5 work by Gonnet et al. is most notable in this approach. They used an indexing approach <ref> [GBY91, BYG89] </ref> with Patricia trees for prefix searches on semi-infinite strings (sistrings). The PAT software [Ope94] from Open Text uses this indexing approach for its query processing. The base for our work will be the PAT software. <p> Of particular interest is the work by Gonnet et al. <ref> [GT87, GBY91] </ref>, where they describe the Patricia Tree. This data structure forms the base of the PAT software. This data structure is based on two main concepts. The first of these is the concept of sistrings or semi-infinite strings. <p> In this case, the external nodes of the PAT trees contain sistrings. "For a text of size n, there are n external nodes in the PAT trees and n 1 internal nodes, making the tree O (n) in size" <ref> [GBY91] </ref>. However, because of the massive storage requirements of large data, sometimes this specification is difficult to handle. The authors describe a modified version of the PAT trees, which they call PAT arrays, to store the same information with same efficiency with much less storage and processing requirements.
Reference: [Gol90] <author> Charles F. Goldfarb. </author> <title> The SGML Handbook. </title> <publisher> Clarendon Press, Oxford, </publisher> <year> 1990. </year>
Reference-contexts: Documents have been enhanced by the incorporation of tags which store information related to their structure. In particular, we consider documents in SGML format. (International Organization for Standardization, ISO 8879: Information processing | Text and office systems | Standard Generalized Markup Language (SGML), ([Geneva]: ISO, 1986), <ref> [Gol90, SMB94] </ref>). SGML is an international standard for the definition of device-independent, system-independent methods of representing texts in electronic form. It is one of the most prominent among those languages that are being used to "mark up" documents to insert information in the documents in addition to the normal text. <p> However, letting a query language do quantification over complex sorts inherently introduces the possibility of explosive complexity. In another variation of the complex-object approach, Abiteboul et al. [ACM93] and Christophides et al. [CACS94] used an object-oriented database to model textual data, especially data encoded in SGML format <ref> [Gol90] </ref>. They used a mapping procedure to map the Data Type Definition (DTD) for the document into an object-oriented class definition in the language CO 2 , which is the programming language in the object-oriented database environment O 2 [BBB + 88]. <p> The DTD contains descriptions of the Generic Identifiers (GIs) of elements that are permissible in a document of this type, and for each GI, the possible attributes, their range of values, and defaults <ref> [Gol90] </ref>. <p> methods that are seem promising are the (i) Query By Example (QBE) [Ull88] and (ii) Programming by Example [AB90] (can be looked at as Querying by instance in the database scenario) 4.5.1 Query By Example The basic structure of a document can be obtained from the DTD (document type definition) <ref> [Gol90, SMB94] </ref>. However, the DTD sometimes has too much information for a simple document structure such as poems 12 [Cha94]. The first implementation of the interface would have the structure of a poem or the dictionary built into it which can be later restructured for use with any general DTD.
Reference: [GPG89] <author> M. Gyssens, J. Paredaens, and D. Van Gucht. </author> <title> A grammar based approach toward unifying hierarchical data models. </title> <booktitle> SIGMOD, </booktitle> <pages> pages 263-272, </pages> <year> 1989. </year>
Reference-contexts: Gonnet et al. focus on dictionaries (viz. the News Oxford English Dictionary database), news clippings, legal documents, and other documents whose high degree of structuring makes them very difficult to be represented in table format [Loe94]. In another similar work, Gyssens et al. <ref> [GPG89] </ref> elaborate on the mathematical fundamentals of grammar-based models. They define algebra and calculus based on such grammars for various operations on the p-strings and the parse trees.
Reference: [GT87] <author> Gaston H. Gonnet and Frank Wm. Tompa. </author> <title> Mind your grammar: a new approach to modelling text. </title> <booktitle> Proceedings of the 13th VLDB Conference, </booktitle> <year> 1987. </year>
Reference-contexts: A recent work by Zhang [Zha95] for building a dictionary system using an object-oriented database system can also be classified under this category. * Grammar-based approach: This approach involves describing the database schema using Context Free Grammars (CFGs) or Attributed Grammars [Knu68]. Gonnet et al. <ref> [GT87] </ref> view the data model as a limited context-free grammar, and any database based on the model is formulated as a parse-tree of the grammar. The data model built on the grammar evidently involves use of ordered tuples and sets, lists, and union sorts. <p> Of particular interest is the work by Gonnet et al. <ref> [GT87, GBY91] </ref>, where they describe the Patricia Tree. This data structure forms the base of the PAT software. This data structure is based on two main concepts. The first of these is the concept of sistrings or semi-infinite strings.
Reference: [GZC89] <author> Guting, Zicari, and Choy. </author> <title> An algebra for structured office documents. </title> <booktitle> ACM TOIS, </booktitle> <year> 1989. </year>
Reference-contexts: The ongoing work using this approach can be further divided into two broad categories based on the underlying theory behind the work: * Complex Object Approach: Desai et al. [DGS86] and Guting et al. <ref> [GZC89] </ref> used an algebraic approach in which they used constructs for specifying queries in algebraic form, with complex-object constructs 4 like set, unnest, project and group-by. The algebraic approach gave the possibility of optimization and rewriting or rephrasing queries.
Reference: [Kim93] <author> W. Eliot Kimber. </author> <title> HyTime and SGML Understanding the HyTime HyQ Query Language 1.1. </title> <institution> IBM Corporation, </institution> <month> August 2 </month> <year> 1993. </year>
Reference: [Knu68] <author> Donald E. Knuth. </author> <title> Semantics of context-free languages. </title> <journal> Mathematical Systems Theory, </journal> <volume> 2(2) </volume> <pages> 127-145, </pages> <year> 1968. </year>
Reference-contexts: A recent work by Zhang [Zha95] for building a dictionary system using an object-oriented database system can also be classified under this category. * Grammar-based approach: This approach involves describing the database schema using Context Free Grammars (CFGs) or Attributed Grammars <ref> [Knu68] </ref>. Gonnet et al. [GT87] view the data model as a limited context-free grammar, and any database based on the model is formulated as a parse-tree of the grammar. The data model built on the grammar evidently involves use of ordered tuples and sets, lists, and union sorts.
Reference: [Loe94] <author> Arjan Loeffen. </author> <title> Text databases: A survey of text models and systems. </title> <booktitle> SIGMOD RECORD, </booktitle> <month> March </month> <year> 1994. </year>
Reference-contexts: The research in Documents is also quite advanced. Using a recent survey, Loeffen <ref> [Loe94] </ref> survey shows various different approaches to database systems, most of which can be classified under the following two broad categories according to the direction of design: 1. Top-down design approach 2. <p> In this method, queries can easily be formulated using regular expressions satisfying the grammar. Gonnet et al. focus on dictionaries (viz. the News Oxford English Dictionary database), news clippings, legal documents, and other documents whose high degree of structuring makes them very difficult to be represented in table format <ref> [Loe94] </ref>. In another similar work, Gyssens et al. [GPG89] elaborate on the mathematical fundamentals of grammar-based models. They define algebra and calculus based on such grammars for various operations on the p-strings and the parse trees.
Reference: [MN92] <author> Makoto Murata and Hisashi Nakatsuyama. </author> <title> Tree modal logic and attribute grammars for contextual queries. </title> <booktitle> In Proceedings of Principles of Document Processing, </booktitle> <month> Nov </month> <year> 1992. </year>
Reference-contexts: In another similar work, Gyssens et al. [GPG89] elaborate on the mathematical fundamentals of grammar-based models. They define algebra and calculus based on such grammars for various operations on the p-strings and the parse trees. In a related work by Murata et al. <ref> [MN92] </ref>, parse trees are used along with formulation of Tree Modal Logic to solve contextual queries. Contextual queries are those that allow user to retrieve document components by specifying conditions on components based on the hierarchical relationships.
Reference: [Mur95] <author> Makoto Murata. </author> <title> Towards a document query language based on tree regular grammar. </title> <note> Working Paper, </note> <month> Feb </month> <year> 1995. </year>
Reference-contexts: Without a theoretical support, any language is bound to get restricted to ad-hoc syntaxes and structures. In our case, much theoretical foundation is provided by the work by Colby et al. [Col92] and also by Gonnet:87,Murata:92. A very recent work by Murata <ref> [Mur95] </ref> has also influenced a lot of the theory behind the proposed system. <p> However it would be preferable if we could have access to some of the internals of their software so that an integrated system can be built. 2. Xerox Webster/Fuji Xerox: Most of the theoretical development done by Murata <ref> [Mur95] </ref> would be a foundation for our system, and we are happy to have his collaboration in this work. 5.3 Approximate plan The following is a sketch of the plan for the overall project: Date Task June 1995 Consolidate theoretical foundation Begin system analysis and initial design phase October 1995 Finalize
Reference: [Ope94] <institution> Open Text Corporation. Open Text 5.0, </institution> <year> 1994. </year>
Reference-contexts: This proposal presents an approach of using the hidden information in the structured documents for use in querying the documents based on similar grounds as relational databases. Section 2 discusses the State of the Art in Databases as well as Structured Documents. This section also introduces the PAT system <ref> [Ope94] </ref> 1 and the Patricia Tree [GBY91] data structure. Section 3 discusses the General research questions involved. <p> The 5 work by Gonnet et al. is most notable in this approach. They used an indexing approach [GBY91, BYG89] with Patricia trees for prefix searches on semi-infinite strings (sistrings). The PAT software <ref> [Ope94] </ref> from Open Text uses this indexing approach for its query processing. The base for our work will be the PAT software. <p> Major problems with the two major present-day strategies are as follows: 3.2.1 Problems with present database Strategies * Index strategies like PAT <ref> [Ope94] </ref> can do some interesting types of searches, but they cannot go beyond these limited searches to queries that involve relational database-like joins, complex selections, and other queries common in the relational paradigm. <p> A back-conversion not only loses some more information but also does not guarantee the resulting schema to be closed in the original domain. 3.2.2 Simple queries not so simple! The PAT query language <ref> [Ope94] </ref> is essentially a pattern search language. Although it implements many different types of searches and combinations of search results, it lacks much of the expressiveness that even the simplest SELECT-FROM-WHERE form of SQL (Structured Query Language) has. <p> Using the SGML model, the method of data definition has been discussed, and some ways of manipulating the data have also been discussed (Section 4.2). Section 4.3 discusses the data structure used in PAT <ref> [Ope94] </ref>, its uses and drawbacks, and suggests alternate structures capable of performing the operations and queries suggested in a previous section (Section 3.2). <p> It can be shown that, using this data structure, it is very easy and efficient to solve special queries like 9 (i) prefix searching, (ii) proximity searching, (iii) range searching, (iv) longest repetition searching, (v) "most frequent" searching and (vi) regular expression searching. The PAT query language <ref> [Ope94] </ref> actually has language constructs for the user to do such operations. One can easily observe that most of the operations that are facilitated by the PAT data structure are not of much importance in queries based on structural information. <p> The interfaces to the query engines that are presently in use either use a command line interface or a form interface to search for text in certain fields or regions <ref> [Ope94] </ref>. However, we propose to build an interface which would give it the feel of a real document to the person who is doing the search. We plan to explore various methods of document visualization for this purpose.
Reference: [Ous94] <author> John K Ousterhout. </author> <title> Tcl and the Tk Toolkit. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: However, this would require partial access to the PAT source code, and replacement of its indexing mechanism for indexing regions. The PAT application programming interface (API) can be used, but it would impose too many restrictions. An interface builder like Tcl/Tk <ref> [Ous94] </ref> can be used to construct the visual query interface on top of the query engine thus constructed. Of course, there needs to be good construction, storage, and retrieval of the index in this case, which can be handled by Shore or Exodus. 5.2 External communication 1.
Reference: [Pep95] <author> Steve Pepper. </author> <title> The whirlwind guide : Sgml tools and vendors. </title> <note> Anonymous ftp: ftp.ifi.uio.no/pub/SGML/SGML-Tools, </note> <month> Jan </month> <year> 1995. </year>
Reference-contexts: SGML parsers also exist to validate and check documents written in SGML. A regularly updated list of commercial and public-domain tools for SGML is available by anonymous ftp <ref> [Pep95] </ref>. 8 In spite of this, SGML document manipulators can do as much as a text editor (e.g., emacs) can do, while dealing with simple text.
Reference: [PT86] <author> Pistor and Traunmuller. </author> <title> A database language for sets, lists, and tables. </title> <booktitle> Information Systems, </booktitle> <year> 1986. </year>
Reference-contexts: The algebraic approach gave the possibility of optimization and rewriting or rephrasing queries. This method reflects the complex-object nature of documents, in which there are various instances of list, set, and bag-like structures. Pistor et al. <ref> [PT86] </ref> used a declarative approach in which they extended the Structured Query Language (SQL) with complex sorts to formulate queries involving complex objects. In this work, various ways of using the complex nature of the database were considered with different complex-object operators, use of embedded clauses, grouping objects, etc.
Reference: [SMB94] <author> C.M. Sperberg-McQueen and Lou Burnard, </author> <title> editors. Guidelines for Electronic Text Encoding and Interchange. </title> <address> TEI, </address> <year> 1994. </year>
Reference-contexts: Documents have been enhanced by the incorporation of tags which store information related to their structure. In particular, we consider documents in SGML format. (International Organization for Standardization, ISO 8879: Information processing | Text and office systems | Standard Generalized Markup Language (SGML), ([Geneva]: ISO, 1986), <ref> [Gol90, SMB94] </ref>). SGML is an international standard for the definition of device-independent, system-independent methods of representing texts in electronic form. It is one of the most prominent among those languages that are being used to "mark up" documents to insert information in the documents in addition to the normal text. <p> The DTD contains descriptions of the Generic Identifiers (GIs) of elements that are permissible in a document of this type, and for each GI, the possible attributes, their range of values, and defaults [Gol90]. A simple example of a DTD declaration (taken from <ref> [SMB94] </ref>) is shown below: &lt;!ELEMENT anthology - (poem+)&gt; &lt;!ELEMENT poem - (title?, stanza+)&gt; &lt;!ELEMENT title - O (#PCDATA) &gt; &lt;!ELEMENT stanza - O (line+) &gt; &lt;!ELEMENT line O O (#PCDATA) &gt; As is evident from the above example, the DTD essentially specifies a grammar in which the document is being represented. <p> As stated before, the type of document is defined in the DTD, and it describes the document structure. Work has been done extensively to establish guidelines for standardizing the DTDs for various types of documents, and these have been published <ref> [SMB94] </ref>. The guidelines provide a standard and consistent way of defining DTDs and are becoming widely accepted. Editors specifically used for SGML documents have been built, and many such commercial and public-domain editors exist for creating and editing SGML documents. <p> methods that are seem promising are the (i) Query By Example (QBE) [Ull88] and (ii) Programming by Example [AB90] (can be looked at as Querying by instance in the database scenario) 4.5.1 Query By Example The basic structure of a document can be obtained from the DTD (document type definition) <ref> [Gol90, SMB94] </ref>. However, the DTD sometimes has too much information for a simple document structure such as poems 12 [Cha94]. The first implementation of the interface would have the structure of a poem or the dictionary built into it which can be later restructured for use with any general DTD.
Reference: [Ull88] <author> Jeffrey D. Ullman. </author> <booktitle> Principles of Database and Knowledge-Base Systems, </booktitle> <volume> volume Vol 1. </volume> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference-contexts: In this model, data is represented in a hierarchy or a forest (a collection of trees) <ref> [Ull88] </ref>. According to Ullman: In this system, hierarchies of logical record types are scheme level concepts. The instances of the database corresponding to a scheme consist of a collection of trees whose nodes are records; each tree is called a database record. <p> In order to improve the efficiency of queries, various different indexing mechanisms were used, notable among them are the B + trees and hashing, 3 both static and dynamic <ref> [Ull88] </ref>. This idea has since been quite popular and has been used even for future generations which adapted it to incorporate increasing complexity. 2.1.3 Visual Level In this level, the main achievement has been IBM's Query By Example (QBE) [Zlo77, Ull88]. <p> This idea has since been quite popular and has been used even for future generations which adapted it to incorporate increasing complexity. 2.1.3 Visual Level In this level, the main achievement has been IBM's Query By Example (QBE) <ref> [Zlo77, Ull88] </ref>. In this method, the table schema is represented visually using table skeletons on the screen, and the queries are specified by using examples in the table skeleton. The concept is easily explained by Figure 1 representing the query: "Find the Customers under the Regional managers for every region". <p> Specific regions or tags in the document entered into the structure can have a second level of indexing in the form of structures like B + Trees <ref> [Ull88] </ref> or hashing. An and-or tree for the Document Type Definition (DTD) can also be maintained, which provides a means of doing a pre-search based on only the structural information for finding a preliminary "plan of path" towards the goal object. <p> Fortunately, it has been experimentally shown that almost all of the possible queries (for relational systems) can be solved in polynomial time <ref> [Ull88] </ref>. For that reason, care is taken to keep the query languages within the polynomial complexity bounds. In fact, there has been much ongoing work [Col92, Col89] to keep expressive query languages within the polynomial boundary by imposing constraints and structures in the language. <p> We plan to explore various methods of document visualization for this purpose. Two prominent visualization methods that are seem promising are the (i) Query By Example (QBE) <ref> [Ull88] </ref> and (ii) Programming by Example [AB90] (can be looked at as Querying by instance in the database scenario) 4.5.1 Query By Example The basic structure of a document can be obtained from the DTD (document type definition) [Gol90, SMB94].
Reference: [Uni93] <institution> University of Wisconsin, Madison. Using the Exodus Storage Manager V3.1, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: There are many different options for the implementation: 1. From Scratch: Build the system from scratch, using the indexing mechanisms for the words and regions, based on the Shore [CDNM94] or Exodus <ref> [Uni93] </ref> storage managers to store and retrieve data. In this case, efficiency regarding the word-related queries, such as regular expression searches, might not be achievable starting from scratch, but can possibly be accomplished through future enhancement. 13 2.
Reference: [Zha95] <author> Jian Zhang. </author> <title> Oodb and sgml techniques in text database: An electronic dictionary system. </title> <booktitle> SIGMOD RECORD, </booktitle> <volume> 24(1) </volume> <pages> 3-8, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: Moreover, since the mapping procedure was not straight forward, the authors made conversions to the schema to fit the conversion procedure. This procedure loses a lot of information that are contained in the original SGML document. A recent work by Zhang <ref> [Zha95] </ref> for building a dictionary system using an object-oriented database system can also be classified under this category. * Grammar-based approach: This approach involves describing the database schema using Context Free Grammars (CFGs) or Attributed Grammars [Knu68].
Reference: [Zlo77] <author> M. M. Zloof. </author> <title> Query by example: A database language. </title> <journal> IBM Systems Journal, </journal> <volume> 16(4), </volume> <year> 1977. </year> <month> 16 </month>
Reference-contexts: This idea has since been quite popular and has been used even for future generations which adapted it to incorporate increasing complexity. 2.1.3 Visual Level In this level, the main achievement has been IBM's Query By Example (QBE) <ref> [Zlo77, Ull88] </ref>. In this method, the table schema is represented visually using table skeletons on the screen, and the queries are specified by using examples in the table skeleton. The concept is easily explained by Figure 1 representing the query: "Find the Customers under the Regional managers for every region".
References-found: 30

