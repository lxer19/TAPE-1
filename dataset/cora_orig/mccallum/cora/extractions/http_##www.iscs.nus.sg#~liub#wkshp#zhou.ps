URL: http://www.iscs.nus.sg/~liub/wkshp/zhou.ps
Refering-URL: 
Root-URL: 
Email: zhou@mse.kyutech.ac.jp  
Title: Compiling Constraint Propagation  
Author: Neng-Fa Zhou 
Address: 680-4 Kawazu, Iizuka, Fukuoka 820, Japan  
Affiliation: Faculty of Computer Science and Systems Engineering Kyushu Institute of Technology  
Abstract: Finite-domain constraint logic programming CLP(FD) is an extension of logic programming that employs constraint propagation as one of the kernel operations. In early CLP(FD) systems, constraints are interpreted rather than compiled and a propagation procedure that is general enough for handling all types of constraints is adopted. In this paper, we describe a compiler for CLP(FD) that compiles CLP(FD) into Prolog that supports the delay mechanism and domain variables. Compared with other compilers, our compiler is simple but efficient. It is simple because the object language of compilation is just Pro-log. It is efficient because (1) the general purpose delay mechanism adopted is efficient; (2) the cost of triggering constraints is low since constraints are coarse-grained; and (3) constraints that share some variables are compiled into one propagation procedure, and the common delay-condition tests among the constraints are combined into one. The compiler has been implemented by modifying the B-Prolog compiler. The experimental results are very promising. For several benchmark programs, the compiler, although an emulator-based one, is on average nearly twice as fast as the CLP(FD) compiler developed by Codognet and Diaz, one of the fastest CLP(FD) compilers available now.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aggoun, A. and Beldiceanu, N. </author> : <title> Overview of the CHIP Compiler System, </title> <booktitle> Proc. of the 8th ICLP, </booktitle> <publisher> MIT Press, </publisher> <address> pp.775-789, </address> <year> 1991. </year>
Reference-contexts: The propagation procedure adopted is general enough for handling all types of constraints. Learning from the experience of compiling logic programs into the WAM [9], several researchers have extended the WAM for compiling CLP (FD). In the CHIP compiler <ref> [1] </ref>, constraints are compiled into low level instructions such that canonical-forms can be constructed quickly and different specialized propagation procedures can be used for different types of constraints.
Reference: [2] <author> Codognet, P. and Diaz, D.: </author> <title> Compiling Constraints in clp(FD), </title> <journal> Journal of Logic Programming, </journal> <pages> 185-226, </pages> <year> 1996. </year>
Reference-contexts: Recently, Codognet and Diaz at INRIA have developed a compiler, referred to as CD compiler below, that compiles every constraint into a sequence of primitive constraints in the form X in r where X is a domain variable and r specifies the range for X <ref> [2] </ref>. For each primitive constraint, a propagation procedure specific to the constraint is adopted. <p> This way of handling disjunctive constraints is said to be constructive and has been studied by many authors, e.g., <ref> [2, 6] </ref>. 5 Performance Evaluation The CLP (FD) compiler described in this paper has been implemented by modifying the B-Prolog compiler [10], an emulator-based fast Prolog system. For usual Prolog programs, B-Prolog is only a little slower than the WAM (cc) system on which the CD compiler is based.
Reference: [3] <author> Codognet, P. and Diaz, D.: </author> <title> A Simple and Efficient Boolean Solver for Constraint Logic Programming, </title> <journal> J. Automated Reasoning, </journal> <volume> 17 </volume> <pages> 97-128, </pages> <year> 1996. </year>
Reference-contexts: This open way of defining constraint propagation not only simplifies the constraint solver but also makes it easy to handle many other types of constraints such as Boolean constraints <ref> [3] </ref>. In this paper, we describe a different glass-box compiler that compiles CLP (FD) into Prolog that supports the delay mechanism and domain variables. Constraints are compiled basically into Prolog predicates one to one. In some cases, constraints that share some variables are compiled into only one predicate.
Reference: [4] <author> Dincbas, M., Van Hentenryck, P., Simonis, H., Aggoun, A., Graf, T., and Berthier, F.: </author> <title> The Constraint Logic Programming Language CHIP, </title> <booktitle> Proc. FGCS'88, ICOT, </booktitle> <pages> 693-702, </pages> <year> 1988. </year>
Reference-contexts: CLP (FD) has been used successfully to solve a large number of real-life problems in scheduling, planning, design, etc. In early CLP (FD) systems, such as in the CHIP system <ref> [4] </ref>, constraints are interpreted rather than compiled: constraints are first transformed into canonical-form terms and are then executed by an interpreter that performs, among other things, constraint propagation. The propagation procedure adopted is general enough for handling all types of constraints.
Reference: [5] <author> Van Hentenryck, P. </author> : <title> Constraint Satisfaction in Logic Programming, </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: It uses constraints actively to prune search spaces as follows: whenever a variable changes, i.e., the variable has been instantiated or its domain has been updated, the domains of all the remaining variables are filtered to contain only those values that are consistent with this variable. CLP (FD) <ref> [5, 6] </ref>, where constraint propagation is adopted as one of the kernel operations, is an instance of the general Constraint Logic Programming scheme proposed by Jaffer and Lassez [7]. CLP (FD) has been used successfully to solve a large number of real-life problems in scheduling, planning, design, etc. <p> Note that our event handler is not sensitive to changes to intermediate elements in domains. This means that our scheme cannot be used to implement the full lookahead algorithm <ref> [5, 8] </ref>. <p> The following benchmarks 1 were tested: * queens: The well-known N-queens problem. * color: Color Gardner's graph <ref> [5] </ref> with four colors. * sudoku: Let n = p N .
Reference: [6] <author> Van Hentenryck, P., Saraswat, V., and Deville,Y.: </author> <title> Design, Implementation, and Evaluation of the Constraint Language cc(FD), </title> <type> Tech. Report No.CS-93-02, </type> <institution> Brown University, </institution> <year> 1993. </year>
Reference-contexts: It uses constraints actively to prune search spaces as follows: whenever a variable changes, i.e., the variable has been instantiated or its domain has been updated, the domains of all the remaining variables are filtered to contain only those values that are consistent with this variable. CLP (FD) <ref> [5, 6] </ref>, where constraint propagation is adopted as one of the kernel operations, is an instance of the general Constraint Logic Programming scheme proposed by Jaffer and Lassez [7]. CLP (FD) has been used successfully to solve a large number of real-life problems in scheduling, planning, design, etc. <p> This way of handling disjunctive constraints is said to be constructive and has been studied by many authors, e.g., <ref> [2, 6] </ref>. 5 Performance Evaluation The CLP (FD) compiler described in this paper has been implemented by modifying the B-Prolog compiler [10], an emulator-based fast Prolog system. For usual Prolog programs, B-Prolog is only a little slower than the WAM (cc) system on which the CD compiler is based.
Reference: [7] <author> Jaffar, J. and Lassez, J-L.: </author> <title> Constraint Logic Programming, </title> <booktitle> Proc. 14th ACM POPL, </booktitle> <year> 1987. </year>
Reference-contexts: CLP (FD) [5, 6], where constraint propagation is adopted as one of the kernel operations, is an instance of the general Constraint Logic Programming scheme proposed by Jaffer and Lassez <ref> [7] </ref>. CLP (FD) has been used successfully to solve a large number of real-life problems in scheduling, planning, design, etc.
Reference: [8] <author> Kumar, V., </author> <title> Algorithms for Constraint Satisfaction Problems: A Survey, in: </title> <journal> AI Magazine, 1992,32-44. </journal>
Reference-contexts: 1 Introduction Constraint propagation is a prominent technique for solving constraint satisfaction problems (CSPs) <ref> [8] </ref>. It uses constraints actively to prune search spaces as follows: whenever a variable changes, i.e., the variable has been instantiated or its domain has been updated, the domains of all the remaining variables are filtered to contain only those values that are consistent with this variable. <p> Note that our event handler is not sensitive to changes to intermediate elements in domains. This means that our scheme cannot be used to implement the full lookahead algorithm <ref> [5, 8] </ref>. <p> Practically, this is not a drawback because it was found better to perform constraint propagation in a limited form and the full lookahead algorithm has in general worse performance than the forward checking and partial lookahead algorithms <ref> [8] </ref>. 3 Compiling Basic Constraints The compiler first translates a constraint into a canonical-form and then generates a predicate that performs the constraint propagation.
Reference: [9] <author> Warren, D.H.D. </author> : <title> An Abstract Prolog Instruction Set, </title> <journal> SRI International No. </journal> <volume> 309, </volume> <year> 1983. </year>
Reference-contexts: The propagation procedure adopted is general enough for handling all types of constraints. Learning from the experience of compiling logic programs into the WAM <ref> [9] </ref>, several researchers have extended the WAM for compiling CLP (FD). In the CHIP compiler [1], constraints are compiled into low level instructions such that canonical-forms can be constructed quickly and different specialized propagation procedures can be used for different types of constraints.
Reference: [10] <author> Zhou, </author> <note> N.F.: B-Prolog User's Manual, 1994, available from ftp.kyutech.ac.jp:pub/Language/prolog. </note>
Reference-contexts: In contrast, as constraints in our system is coarse-grained, the constraint queue tend to be short. Second, by compiling several constraints that share some variables into one predicate, we can greatly reduce the number of delay-condition tests. The compiler has been implemented by modifying the B-Prolog compiler <ref> [10, 11] </ref>, an emulator-based compiler. The experimental results are very promising. For several benchmark programs, our compiler is on average nearly twice as fast as the CD compiler. <p> This way of handling disjunctive constraints is said to be constructive and has been studied by many authors, e.g., [2, 6]. 5 Performance Evaluation The CLP (FD) compiler described in this paper has been implemented by modifying the B-Prolog compiler <ref> [10] </ref>, an emulator-based fast Prolog system. For usual Prolog programs, B-Prolog is only a little slower than the WAM (cc) system on which the CD compiler is based.
Reference: [11] <author> Zhou, </author> <title> N.F.: Parameter Passing and Control Stack Management in Prolog Implementation Revisited, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <month> November </month> <year> 1996. </year>
Reference-contexts: In contrast, as constraints in our system is coarse-grained, the constraint queue tend to be short. Second, by compiling several constraints that share some variables into one predicate, we can greatly reduce the number of delay-condition tests. The compiler has been implemented by modifying the B-Prolog compiler <ref> [10, 11] </ref>, an emulator-based compiler. The experimental results are very promising. For several benchmark programs, our compiler is on average nearly twice as fast as the CD compiler. <p> The action only tries to reduce the domain of non-trigger-variables. It is not difficult to understand that reducing the domain of a trigger variable is fruitless. Shared tests among clauses are combined into one by the compiler <ref> [11] </ref>. Thus, when X is found to be a nonvariable term, then the second clause will be skipped and the third clause will be executed. In Introduction, we have shown the generated predicate for the inequality constraint X#"=Y. As another example, let us consider the equality constraint X#=Y+C.
Reference: [12] <author> Zhou, </author> <title> N.F.: A Novel Implementation Method of Delay, </title> <booktitle> Proc. of JIC-SLP'96, </booktitle> <address> pp.97-111, </address> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: It would be impossible to implement a fast CLP (FD) system based on our scheme without a fast delay mechanism. Fortunately, we already have a fast delay mechanism implemented in the B-Prolog system <ref> [12] </ref>. Besides adopting the general purpose but fast delay mechanism, our compiler also has two advantages over the CD compiler concerning efficiency. First, in the CD compiler, each constraint with n variables is compiled into n primitive constraints. When a variable changes, n 1 constraints will be triggered. <p> Second, there is a large amount of data movements involved. To execute a simplified constraint with one less argument, the system must, in most cases, place a new frame onto the control stack and copy its arguments to the frame <ref> [12] </ref>. This is because the choice points placed above the current frame prevent the frame from being reused.
References-found: 12

