URL: ftp://info.mcs.anl.gov/pub/tech_reports/reports/P265.ps.Z
Refering-URL: http://www.mcs.anl.gov/publications/abstracts/abstracts91.htm
Root-URL: http://www.mcs.anl.gov
Title: A Taxonomy of Automatic Differentiation Tools  
Author: David W. Juedes 
Abstract: Many of the current automatic differentiation (AD) tools have similar characteristics. Unfortunately, it is often the case that the similarities between these various AD tools can not be easily ascertained by reading the corresponding documentation. To clarify this situation, a taxonomy of AD tools is presented. The taxonomy places AD tools into the Elemental, Extensional, Integral, Operational, and Symbolic classes. This taxonomy is used to classify twenty-nine AD tools. Each tool is examined individually with respect to the mode of differentiation used and the degree of derivatives computed. A list detailing the availability of the surveyed AD tools is provided in Appendix A. 
Abstract-found: 1
Intro-found: 1
Reference: [Adam69a] <author> D. S. Adamson and C. W. Winant, </author> <title> A SLANG simulation of an initially strong shock wave downstream of an infinite area change, </title> <booktitle> in Proceedings of the Conference on Applications of Continuous-System Simulation Languages, </booktitle> <year> 1969, </year> <pages> pp. 231-240. </pages>
Reference-contexts: They are characterized by source languages that directly provide automatic differentiation. Several of the earliest AD tools belong to the integral class. The best examples of these are SLANG <ref> [Adam69a, McCu69a, Tham69a] </ref> and PROSE [Tham75a, PROS77a, Tham82a, Krin84a, Pfei87a]. More recent examples of integral AD tools are the modeling language AMPL [Four90a], and the FM/FAD [Mazo91a] package. The operational tools have their origins in the ideas embodied by both the elemental and extensional tools.

Reference: [Chan82a] <author> Y. F. Chang and G. F. Corliss, </author> <title> Solving ordinary differential equations using Taylor series, </title> <journal> ACM Trans. Math. Software, </journal> <volume> 8 (1982), </volume> <pages> pp. 114-144. </pages>
Reference-contexts: Figure 2 illustrates this fact. PCOMP PCOMP PADRE2 PADRE2 GRESS GRESS DAPRE DAPRE FORTRAN CALCULUS ATOMFT JAKEF DAFOR GRAD Forward ModeReverse Mode (4) The general purpose ordinary differential equation (ODE) solver ATOMFT <ref> [Chan82a] </ref> is an AD tool in the sense that it provides the automatic generation of code to evaluate Taylor series; however, automatic differentiation is not its primary focus. ATOMFT is a FORTRAN preprocessor that generates FORTRAN source code to solve systems of ODEs.
Reference: [Chri90a] <author> B. D. Christianson, </author> <title> Automatic Hessians by reverse accumulation, </title> <type> Technical Report NOC TR228, </type> <institution> The Numerical Optimisation Center, Hatfield Polytechnic, Hat-field, U.K., </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: In ADOL-C, arbitrarily nested or recursive functions can be differentiated. Also, the trace of a function is stored sequentially in main memory and is automatically paged to disk when necessary. (14) The BC1 <ref> [Chri90a] </ref> package uses operator overloading in ADA to provide a new data type that aids in the calculation of derivatives. When functions using this new type are executed, the computational graph of that execution is created.
Reference: [PROS77a] <author> Control Data Corporation, </author> <title> PROSE A General Purpose Higher Level Language, </title> <note> 1977. Procedure Manual (Pub. No. 84003000 Rev. B), Calculus Operations Manual (Pub. No. 84003200 Rev. A), Calculus Applications Guide (Pub. No. 84000170 Rev A). </note>
Reference-contexts: They are characterized by source languages that directly provide automatic differentiation. Several of the earliest AD tools belong to the integral class. The best examples of these are SLANG [Adam69a, McCu69a, Tham69a] and PROSE <ref> [Tham75a, PROS77a, Tham82a, Krin84a, Pfei87a] </ref>. More recent examples of integral AD tools are the modeling language AMPL [Four90a], and the FM/FAD [Mazo91a] package. The operational tools have their origins in the ideas embodied by both the elemental and extensional tools.
Reference: [Corl91a] <author> G. F. Corliss, </author> <title> Overloading point and interval Taylor operators, in Automatic Differentiation of Algorithms: Theory, Implementation, and Application, </title> <editor> A. Griewank and G. F. Corliss, eds., </editor> <publisher> SIAM, </publisher> <address> Philadelphia, Penn., </address> <year> 1991, </year> <pages> pp. 139-146. </pages>
Reference-contexts: This computational graph, which is stored in a linearized form, is used by other routines to propagate derivatives in the reverse mode. The BC1 package can be used to generate first- and second-order partial derivatives (i.e., gradients and Hessians). (15) GC1 <ref> [Corl91a, Corl91b] </ref> is an ADA package for operations on interval valued Taylor series. To generate Taylor series, a user of GC1 writes a program that declares the appropriate variables to be of the Taylor type and uses the overloaded operations provided by GC1.

Reference: [Flan91b] <author> H. Flanders, </author> <title> Response to electronic mail survey. </title> <type> Personal communication, </type> <month> March </month> <year> 1991. </year>
Reference-contexts: These derivatives are calculated in the forward mode. 4.5 The Symbolic Tools. The class of symbolic AD tools contains five members. Of the members of this class, four use the forward mode of automatic differentiation, while only one uses the reverse mode. (25) The AD <ref> [Flan91b] </ref> program is a PC-based menu driven program for producing numeric function and derivative values. The AD program allows a function to be entered symbolically. Once entered, the symbolic representation of the function is parsed and a tree representing the function is built internally.
Reference: [Four90a] <author> R. Fourer, D. M. Gay, and B. W. Kernighan, </author> <title> A modeling language for mathematical programming, </title> <booktitle> Management Science, 36 (1990), </booktitle> <pages> pp. 519-554. </pages>
Reference-contexts: Several AD tools have been created with the help of language development tools like Lex and Yacc. The most notable of these AD tools are the FORTRAN precompilers JAKE [Spee80a] and PADRE2 [Kubo90a], and the modeling language AMPL <ref> [Four90a] </ref>. During the SIAM Workshop on Automatic Differentiation, it became clear that the forces driving AD technology had caused a variety of different tools to be created. Of these various tools, many of them had similar characteristics. <p> Several of the earliest AD tools belong to the integral class. The best examples of these are SLANG [Adam69a, McCu69a, Tham69a] and PROSE [Tham75a, PROS77a, Tham82a, Krin84a, Pfei87a]. More recent examples of integral AD tools are the modeling language AMPL <ref> [Four90a] </ref>, and the FM/FAD [Mazo91a] package. The operational tools have their origins in the ideas embodied by both the elemental and extensional tools. Operational tools provide automatic differentiation within the constructs provided by a programming language that provides polymorphic functions and operations. <p> The partial derivatives can be calculated to arbitrary order and with respect to arbitrarily many independent variables. ADDS also provides facilities for estimating rounding Taxonomy of Automatic Differentiation Tools 11 errors. (22) The modeling language AMPL <ref> [Four90a, Gayd91b] </ref> is a declarative language that was designed for expressing mathematical programming problems. Mathematical programming problems are described in AMPL by a sequence of nonlinear expressions. The AMPL translator emits a representation of the DAG for each nonlinear expression given.
Reference: [Garc91a] <author> O. Garc ia, </author> <title> A system for the differentiation of Fortran code and an application to parameter estimation in forest growth models, in Automatic Differentiation of Algorithms: Theory, Implementation, and Application, </title> <editor> A. Griewank and G. F. Corliss, eds., </editor> <publisher> SIAM, </publisher> <address> Philadelphia, Penn., </address> <year> 1991, </year> <pages> pp. 273-286. </pages>
Reference-contexts: The preprocessor puts some restrictions on the subset of FORTRAN used to define the subroutine (see [Step91a]). For example, EQUIVALENCE statements are not allowed. This package was designed to interface smoothly with the NAG library of mathematical software, but it is not NAG specific. (7) GRAD <ref> [Garc91a] </ref> is a FORTRAN preprocessor. GRAD takes as input a FORTRAN subroutine that computes a function and produces a FORTRAN subroutine that computes the function and its first-order partial derivatives with respect to specified independent variables.
Reference: [Gayd91b] <author> D. M. Gay, </author> <title> Response to electronic mail survey. </title> <type> Personal communication, </type> <month> March </month> <year> 1991. </year>
Reference-contexts: The partial derivatives can be calculated to arbitrary order and with respect to arbitrarily many independent variables. ADDS also provides facilities for estimating rounding Taxonomy of Automatic Differentiation Tools 11 errors. (22) The modeling language AMPL <ref> [Four90a, Gayd91b] </ref> is a declarative language that was designed for expressing mathematical programming problems. Mathematical programming problems are described in AMPL by a sequence of nonlinear expressions. The AMPL translator emits a representation of the DAG for each nonlinear expression given.
Reference: [Grie89a] <author> A. Griewank, </author> <title> On automatic differentiation, in Mathematical Programming: Recent Developments and Applications, </title> <editor> M. Iri and K. Tanabe, eds., </editor> <publisher> Kluwer Academic Publishers, </publisher> <year> 1989, </year> <pages> pp. 83-108. </pages> <note> Also appeared as Preprint MCS-P10-1088, </note> <institution> Mathematics and Computer Science Division, Argonne National Laboratory, Argonne, Ill., </institution> <month> October </month> <year> 1988. </year>
Reference-contexts: In the forward mode, derivative values propagate from the independent variables to the dependent variables. For more in-depth descriptions of these automatic differentiation techniques, see <ref> [Rall81a, Irim87a, Grie89a, etc.] </ref>. As noted by Griewank [Grie89a], neither the forward mode nor the reverse mode is optimal in all cases. <p> In the forward mode, derivative values propagate from the independent variables to the dependent variables. For more in-depth descriptions of these automatic differentiation techniques, see [Rall81a, Irim87a, Grie89a, etc.]. As noted by Griewank <ref> [Grie89a] </ref>, neither the forward mode nor the reverse mode is optimal in all cases. The forward mode can be used to produce the partial derivatives of all dependent variables with respect to a single independent variable in time proportional to the evaluation of F .
Reference: [Grie92a] <author> A. Griewank, D. Juedes, J. Srinivasan, and C. Tyner, ADOL-C, </author> <title> a package for the automatic differentiation of algorithms written in C/C++, </title> <journal> ACM Trans. Math. Software, </journal> <note> (to appear). Also appeared as Preprint MCS-P180-1190, </note> <institution> Mathematics and Computer Science Division, Argonne National Laboratory, Argonne, Ill., </institution> <year> 1990. </year>
Reference-contexts: Some languages, such as C++, also provide constructors and destructors for variables as they enter and leave their scope of existence. These facilities allow AD tools to transparently allocate and deallocate memory when necessary, as well as perform other maintenance procedures. The operational tools ADOL-C <ref> [Grie92a] </ref> and MXYZPTLK [Mich90a] make use of these facilities in C++. The final class of AD tools is the class of symbolic tools. <p> The languages ADA, C++, and PASCAL-SC were used to implement these packages. Two of the packages were implemented using ADA, four using C++, and two using PASCAL-SC. This fact is illustrated in Figure 3. MJ2 MXYZPTLK GC1BC1 RL1 ADOL-C C++ PASCAL-SC ADA (13) The ADOL-C <ref> [Grie92a, Jued90a] </ref> package consists of a definition of a class of active variables called adouble, and a library of supporting routines. ADOL-C was written using C++, and can be used to differentiate algorithms written in C or C++.
Reference: [Hill91a] <author> D. R. Hill and L. C. Rich, </author> <title> Automatic differentiation in MATLAB, Applied Taxonomy of Automatic Differentiation Tools 17 Numerical Mathematics, </title> <note> (to appear). </note>
Reference-contexts: The function and its derivatives (up to the 20th order) can then be evaluated at a point. The evaluation process propagates derivatives in the forward mode. Currently the AD package is only a demonstrational tool. (26) The GRAD <ref> [Hill91a] </ref> function within the MATLAB library of mathematical software can calculate gradients interactively. The parameters to the GRAD function are a character string containing the symbolic description of a function of n variables and a point in n-space (i.e., an array containing n real values).
Reference: [Hill85a] <author> K. E. Hillstrom, </author> <title> Users guide for JAKEF, </title> <type> Technical Memorandum ANL/MCS-TM-16, </type> <institution> Mathematics and Computer Science Division, Argonne National Laboratory, Argonne, Ill., </institution> <year> 1985. </year>
Reference-contexts: They usually automate the process of decomposing complicated right-hand-sides of equations into sequences of elementary operations. Typically, automatic differentiators in this class use precompilers to perform the transformation from the extensions to the original language. For example, the FORTRAN precompilers JAKEF <ref> [Hill85a] </ref>, GRESS [Horw88a] and PADRE2 [Kubo90a] transform their variants of FORTRAN into standard FORTRAN 77. For this reason, we classify them as extensional AD tools. The integral tools push the ideas embodied by the extensional tools one step further. <p> The subroutines propagate the values of variables and their partial derivatives using the forward mode. These subroutines can calculate first- and second-order partial derivatives with respect to an arbitrary number of independent variables. (10) JAKEF <ref> [Hill85a] </ref> is another FORTRAN precompiler. JAKEF is a version of JAKE [Spee80a] that was developed at Argonne National Laboratory and written using FORTRAN 77.
Reference: [Horw90a] <author> J. E. Horwedel, R. J. Raridon, and R. Q. Wright, </author> <title> Sensitivity analysis of AIRDOS-EPA using ADGEN with matrix reduction algorithms, </title> <type> Technical Memorandum ORNL/TM 11373, </type> <institution> Martin Marietta Energy Systems, Inc., Oak Ridge National Laboratory, Oak Ridge, Tenn. </institution> <month> 37830, </month> <year> 1989. </year>
Reference-contexts: The GRESS "Adgen" option produces code that propagates derivatives using the reverse mode. GRESS has been used successfully on a variety of problems. Examples of the application of GRESS can be found in <ref> [Horw89a, Horw90a, etc.] </ref>. (9) FORTRAN CALCULUS [Tham89a, Tham91a] (denoted here by FC) is a commercially available package for mathematical modeling. FC is an extension of FORTRAN 77 that provides macro statements for differentiation, optimization and integration, dynamic arrays, and vector and matrix operations.
Reference: [Horw88a] <author> J. E. Horwedel, B. A. Worley, E. M. Oblow, and F. G. Pin, </author> <note> GRESS version 1.0 users manual, Technical Memorandum ORNL/TM 10835, </note> <institution> Martin Marietta Energy Systems, Inc., Oak Ridge National Laboratory, Oak Ridge, Tenn. </institution> <month> 37830, </month> <year> 1988. </year>
Reference-contexts: AD tools aid in the transformation from the source language to a form which may easily be used to generate derivative values. This transformation may be either explicit or implicit. For example, the FORTRAN precompiler in the GRESS <ref> [Horw88a] </ref> package does an explicit transformation from its source language (a minor extension of FORTRAN) to standard FORTRAN. The taxonomy presented in this paper classifies automatic differentiators based on how, where, and when this transformation is performed. The most basic class is composed of the elemental AD tools. <p> They usually automate the process of decomposing complicated right-hand-sides of equations into sequences of elementary operations. Typically, automatic differentiators in this class use precompilers to perform the transformation from the extensions to the original language. For example, the FORTRAN precompilers JAKEF [Hill85a], GRESS <ref> [Horw88a] </ref> and PADRE2 [Kubo90a] transform their variants of FORTRAN into standard FORTRAN 77. For this reason, we classify them as extensional AD tools. The integral tools push the ideas embodied by the extensional tools one step further. <p> Unlike many other precompilers, GRAD uses no subroutines that represent elementary operations. The partial derivatives are calculated directly and are placed in specially named variables. The code generated by GRAD propagates derivatives in the forward mode. (8) The GRESS (GRadient Enhanced Software System) <ref> [Horw88a] </ref> package is a system for adding the ability to calculate normalized sensitivities and first-order partial derivatives to existing FORTRAN programs. The GRESS package consists of a FORTRAN precompiler and a library of supporting routines. The GRESS precompiler produces code that propagates derivatives using either the forward or reverse mode.
Reference: [Horw89a] <author> J. E. Horwedel, R. Q. Wright, and R. E. Maerker, </author> <title> Sensitivity analysis of EQ3, </title> <type> Technical Memorandum ORNL/TM 11407, </type> <institution> Oak Ridge National Laboratory, Oak Ridge, Tenn. </institution> <month> 37830, </month> <year> 1990. </year>
Reference-contexts: The GRESS "Adgen" option produces code that propagates derivatives using the reverse mode. GRESS has been used successfully on a variety of problems. Examples of the application of GRESS can be found in <ref> [Horw89a, Horw90a, etc.] </ref>. (9) FORTRAN CALCULUS [Tham89a, Tham91a] (denoted here by FC) is a commercially available package for mathematical modeling. FC is an extension of FORTRAN 77 that provides macro statements for differentiation, optimization and integration, dynamic arrays, and vector and matrix operations.
Reference: [Irim87a] <author> M. Iri and K. Kubota, </author> <title> Methods of fast automatic differentiation and applications, </title> <note> Research Memorandum RMI 87 - 02, </note> <institution> Department of Mathematical Engineering and Information Physics, Faculty of Engineering, University of Tokyo, </institution> <year> 1987. </year>
Reference-contexts: In the forward mode, derivative values propagate from the independent variables to the dependent variables. For more in-depth descriptions of these automatic differentiation techniques, see <ref> [Rall81a, Irim87a, Grie89a, etc.] </ref>. As noted by Griewank [Grie89a], neither the forward mode nor the reverse mode is optimal in all cases. <p> The trace is stored in a linearized form in auxiliary integer and real arrays. There is no facility in JAKEF for using auxiliary storage on large traces, although Speelpenning mentions in his unpublished thesis [Spee80a] how such a technique could be implemented. (11) PADRE2 <ref> [Irim87a, Kubo90a] </ref> is also a FORTRAN precompiler. PADRE2 is an extended version of PADRE, which was developed by N. Iwata [Iwat84a]. PADRE2 processes a FORTRAN function or subroutine that evaluates a scalar or vector function and then produces a modified subroutine.
Reference: [Iwat84a] <author> N. Iwata, </author> <title> Automatization of the computation of partial derivatives, </title> <type> master's thesis, </type> <institution> Graduate School, University of Tokyo, </institution> <year> 1984. </year> <title> (In Japanese). </title>
Reference-contexts: PADRE2 is an extended version of PADRE, which was developed by N. Iwata <ref> [Iwat84a] </ref>. PADRE2 processes a FORTRAN function or subroutine that evaluates a scalar or vector function and then produces a modified subroutine. This subroutine calculates the original function, its partial derivatives, and an estimate of the rounding error generated.
Reference: [Jerr89a] <author> M. Jerrell, </author> <title> Automatic differentiation and function minimization in C++, </title> <booktitle> in Proceedings of OOP-SLA, </booktitle> <publisher> ACM Press, </publisher> <year> 1989, </year> <pages> pp. </pages> <month> 18-24. </month> <title> [Jerr89b] , Automatic differentiation using almost any language, </title> <journal> ACM SIGNUM Newsletter, </journal> <year> (1989), </year> <pages> pp. </pages> <month> 2-9. </month> <title> [Jerr90a] , Automatic differentiation using C++, Journal of Object Oriented Programming, </title> <booktitle> (1990), </booktitle> <pages> pp. 17-24. </pages>
Reference-contexts: For example, the statement a = x + y + z is written as follows using the WCOMP package. call SWSUM (N,Y,Z,Q) // Q=Y+Z call SWSUM (N,Q,X,A) // A=X+Q Both packages support single and double precision arithmetic. (2) The MJ1 <ref> [Jerr89a] </ref> package contains the definition of an object for automatic differentiation and its associated operations. The MJ1 package uses Turbo Pascal v5.5 to define an Ad object. Each Ad object contains a scalar value, gradient vector, and Hessian matrix.
Reference: [Jued90a] <author> D. Juedes and A. Griewank, </author> <title> Implementing automatic differentiation efficiently, </title> <type> Technical Memorandum ANL/MCS-TM-140, </type> <institution> Mathematics and Computer Sciences Division, Argonne National Laboratory, Argonne, Ill., </institution> <year> 1990. </year>
Reference-contexts: The languages ADA, C++, and PASCAL-SC were used to implement these packages. Two of the packages were implemented using ADA, four using C++, and two using PASCAL-SC. This fact is illustrated in Figure 3. MJ2 MXYZPTLK GC1BC1 RL1 ADOL-C C++ PASCAL-SC ADA (13) The ADOL-C <ref> [Grie92a, Jued90a] </ref> package consists of a definition of a class of active variables called adouble, and a library of supporting routines. ADOL-C was written using C++, and can be used to differentiate algorithms written in C or C++.
Reference: [Krin84a] <author> B. Krinsky and J. Thames, </author> <title> The structure of synthetic calculus, </title> <booktitle> in Proceedings of the International Workshop on High-Level Computer Architecture, </booktitle> <institution> University of Maryland, </institution> <year> 1984. </year>
Reference-contexts: They are characterized by source languages that directly provide automatic differentiation. Several of the earliest AD tools belong to the integral class. The best examples of these are SLANG [Adam69a, McCu69a, Tham69a] and PROSE <ref> [Tham75a, PROS77a, Tham82a, Krin84a, Pfei87a] </ref>. More recent examples of integral AD tools are the modeling language AMPL [Four90a], and the FM/FAD [Mazo91a] package. The operational tools have their origins in the ideas embodied by both the elemental and extensional tools. <p> The FC package consists of a FORTRAN precompiler and a run-time library of supporting routines. 8 Part VIII. Experience with Automatic Differentiation Software FC's extension to FORTRAN is based on a paradigm referred to as synthetic calculus in <ref> [Tham82a, Krin84a, Tham89a, Tham91a] </ref>. The basic unit within this paradigm is a model . Models are subprograms that contain sets of formulas. Differentiation, optimization and integration are performed on specified models. Models may include macro statements for optimization and integration. This allows for the nesting of models.
Reference: [Kubo90a] <author> K. Kubota and M. Iri, PADRE2, </author> <note> version 1 | User's manual, Research Memorandum RMI 90-01, </note> <institution> Department of Mathematical Engineering and Information Physics, Faculty of Engineering, University of Tokyo, </institution> <year> 1990. </year>
Reference-contexts: Several AD tools have been created with the help of language development tools like Lex and Yacc. The most notable of these AD tools are the FORTRAN precompilers JAKE [Spee80a] and PADRE2 <ref> [Kubo90a] </ref>, and the modeling language AMPL [Four90a]. During the SIAM Workshop on Automatic Differentiation, it became clear that the forces driving AD technology had caused a variety of different tools to be created. Of these various tools, many of them had similar characteristics. <p> They usually automate the process of decomposing complicated right-hand-sides of equations into sequences of elementary operations. Typically, automatic differentiators in this class use precompilers to perform the transformation from the extensions to the original language. For example, the FORTRAN precompilers JAKEF [Hill85a], GRESS [Horw88a] and PADRE2 <ref> [Kubo90a] </ref> transform their variants of FORTRAN into standard FORTRAN 77. For this reason, we classify them as extensional AD tools. The integral tools push the ideas embodied by the extensional tools one step further. Integral tools have the ability to automatically differentiate functions integrated within their environment or language. <p> The trace is stored in a linearized form in auxiliary integer and real arrays. There is no facility in JAKEF for using auxiliary storage on large traces, although Speelpenning mentions in his unpublished thesis [Spee80a] how such a technique could be implemented. (11) PADRE2 <ref> [Irim87a, Kubo90a] </ref> is also a FORTRAN precompiler. PADRE2 is an extended version of PADRE, which was developed by N. Iwata [Iwat84a]. PADRE2 processes a FORTRAN function or subroutine that evaluates a scalar or vector function and then produces a modified subroutine.
Reference: [Laws71a] <author> C. L. Lawson, </author> <title> Computing derivatives using W-arithmetic and U-arithmetic, Internal Computing Memorandum CM-286, </title> <institution> Jet Propulsion Laboratory, Pasadena, </institution> <address> CA 91105, </address> <month> September </month> <year> 1971. </year>
Reference-contexts: Each procedure takes as input the values of an operation's arguments and its derivatives, and returns the result and its derivatives. The transformation from the source language is performed manually by decomposing a function into a sequence of procedure calls for the elementary operations. Lawson's WCOMP and UCOMP packages <ref> [Laws71a] </ref> are examples of elemental AD tools. Based on the concepts pioneered by the elemental tools, the class of extensional tools provide extensions to standard programming languages for automatic differentiation. They usually automate the process of decomposing complicated right-hand-sides of equations into sequences of elementary operations. <p> Tools that could be cross-classified were placed in the class whose characteristics best described them. 4.1 The Elemental Tools. Of the tools surveyed, three of them are elemental tools. All three of these tools produce derivatives in the forward mode. (1) The WCOMP and UCOMP <ref> [Laws71a, Math89a] </ref> packages consist of FORTRAN 77 subroutines for executing operations that propagate derivatives in the forward mode. The WCOMP package contains subroutines that perform operations using real-valued arrays of length N + 1. <p> In the FEED implementation, derivatives are propagated in the forward mode as operations are performed. This implementation is similar to the UCOMP package <ref> [Laws71a, Math89a] </ref>. 4.2 The Extensional Tools. The class of extensional tools contains the largest number (nine) of the surveyed tools. This class consists primarily of precompilers.
Reference: [Liep90a] <author> M. Liepel and K. Schittkowski, PCOMP: </author> <title> A FORTRAN code for automatic differentiation, </title> <type> Report No. 254, </type> <institution> DFG Schwerpunktprogramm Anwendungsbezogene Optimierung und Optimale Steuerung, Mathematisches Institut, Universitat Bayreuth, D-8580 Bayreuth, Germany, </institution> <year> 1990. </year>
Reference-contexts: The computational graph produced by a PADRE2 generated subroutine is stored exclusively in main memory. (12) The PCOMP <ref> [Liep90a] </ref> package consists of three independent parts. The first part (a) processes the description of function written in a subset of an extension to FORTRAN, and compiles it into an intermediate code.
Reference: [Lind91a] <author> R. Lindell, </author> <title> Response to electronic mail survey. </title> <type> Personal communication, </type> <month> March </month> <year> 1991. </year>
Reference-contexts: When variables from the two classes are used, derivative values are propagated in the forward mode. MXYZPTLK can be used to calculate arbitrary-order partial derivatives with re spect to arbitrarily many independent variables. (19) RL1 <ref> [Lind91a] </ref> is another operational AD tool written in C++. The RL1 package is used to generate derivatives for scalar or vector functions of a single real variable (time).
Reference: [Math89a] <author> MATH, MATH77, </author> <title> Release 3.0, A library of mathematical subprograms for FORTRAN 77, Internal Document D-134, Rev. B, </title> <institution> Jet Propulsion Laboratory, Pasadena, Calif. </institution> <month> 91105, May </month> <year> 1989. </year> <note> Also available as Program No. </note> <institution> NPO-18120 from COSMIC (Computer Software Management and Information Center), The University of Geor-gia, </institution> <address> Athens, GA. </address>
Reference-contexts: Tools that could be cross-classified were placed in the class whose characteristics best described them. 4.1 The Elemental Tools. Of the tools surveyed, three of them are elemental tools. All three of these tools produce derivatives in the forward mode. (1) The WCOMP and UCOMP <ref> [Laws71a, Math89a] </ref> packages consist of FORTRAN 77 subroutines for executing operations that propagate derivatives in the forward mode. The WCOMP package contains subroutines that perform operations using real-valued arrays of length N + 1. <p> In the FEED implementation, derivatives are propagated in the forward mode as operations are performed. This implementation is similar to the UCOMP package <ref> [Laws71a, Math89a] </ref>. 4.2 The Extensional Tools. The class of extensional tools contains the largest number (nine) of the surveyed tools. This class consists primarily of precompilers.
Reference: [Mazo91a] <author> V. Mazourik, </author> <title> Integration of automatic differentiation into a numerical library for PC's, in Automatic Differentiation of Algorithms: Theory, Implementation, and 18 Part VIII. Experience with Automatic Differentiation Software Application, </title> <editor> A. Griewank and G. F. Corliss, eds., </editor> <publisher> SIAM, </publisher> <address> Philadelphia, Penn., </address> <year> 1991, </year> <pages> pp. 286-293. </pages>
Reference-contexts: Several of the earliest AD tools belong to the integral class. The best examples of these are SLANG [Adam69a, McCu69a, Tham69a] and PROSE [Tham75a, PROS77a, Tham82a, Krin84a, Pfei87a]. More recent examples of integral AD tools are the modeling language AMPL [Four90a], and the FM/FAD <ref> [Mazo91a] </ref> package. The operational tools have their origins in the ideas embodied by both the elemental and extensional tools. Operational tools provide automatic differentiation within the constructs provided by a programming language that provides polymorphic functions and operations. <p> The DAG of an expression can also be used to produce FORTRAN or C routines for calculating the expression and its gradient at a point. (23) The FM/FAD <ref> [Mazo91a] </ref> package is a PC-based set of tools for problem management. Problems (i.e., functions) are defined in FM/FAD using DIFALG, an ALGOL-60 like programming language. Function definitions are compiled by the DIFALG compiler and the compiled version is used by the DIFALG interpreter.
Reference: [McCu69a] <author> J. D. McCully, </author> <title> The Q approach to problem solving, </title> <booktitle> in Proceedings of FJCC 69, AFIPS, </booktitle> <year> 1969, </year> <pages> pp. 691-699. </pages>
Reference-contexts: They are characterized by source languages that directly provide automatic differentiation. Several of the earliest AD tools belong to the integral class. The best examples of these are SLANG <ref> [Adam69a, McCu69a, Tham69a] </ref> and PROSE [Tham75a, PROS77a, Tham82a, Krin84a, Pfei87a]. More recent examples of integral AD tools are the modeling language AMPL [Four90a], and the FM/FAD [Mazo91a] package. The operational tools have their origins in the ideas embodied by both the elemental and extensional tools.
Reference: [Mich90a] <author> L. Michelotti, MXYZPTLK: </author> <title> A practical, user-friendly C++ implementation of differential algebra: User's guide, </title> <type> Technical Memorandum FN-535, </type> <institution> Fermi National Accelerator Laboratory, Batavia, Ill. </institution> <month> 60510, January </month> <year> 1990. </year>
Reference-contexts: Some languages, such as C++, also provide constructors and destructors for variables as they enter and leave their scope of existence. These facilities allow AD tools to transparently allocate and deallocate memory when necessary, as well as perform other maintenance procedures. The operational tools ADOL-C [Grie92a] and MXYZPTLK <ref> [Mich90a] </ref> make use of these facilities in C++. The final class of AD tools is the class of symbolic tools. <p> MJ2 is written using Turbo C++ v1.0. MJ2 uses operator overloading, and therefore the example code segment f = x + cos (z fl y) from x4.1 does not need to be modified. (18) The MXYZPTLK <ref> [Mich90a] </ref> package is an operational AD tool written in C++. The MXYZPTLK package defines two classes, DA and DAVector, and provides a library of supporting routines. A number of binary and unary operations are overloaded for these classes (e.g. +, *, sin, cos, etc.).
Reference: [Mona91a] <author> M. Monagan, </author> <title> Response to electronic mail survey. </title> <type> Personal communication, </type> <month> March </month> <year> 1991. </year>
Reference-contexts: The character string is parsed internally by the GRAD function, which then uses the forward mode to evaluate the gradient. The GRAD function can be called by C programs. (27) The newest version (5.1) of MAPLE <ref> [Mona91a] </ref> can perform automatic differentiation. In Maple, functions are expressed as Maple procedures. The Maple D routine produces Maple procedures that evaluate single derivative values for functions described by other Maple procedures. The Maple optimize routine can then be used to optimize these procedures.
Reference: [Neid91a] <author> R. D. Neidinger, </author> <title> An efficient method for the numerical evaluation of partial derivatives of arbitrary order, </title> <journal> ACM Trans. Math. Software, </journal> <note> (to appear). </note>
Reference-contexts: The standard operations are overloaded for this class. When operations are executed on members of this class, the derivative values are propagated along with the function values in the forward mode. Derivatives up to the third order can be calculated. (20) The RN1 <ref> [Neid91a] </ref> package is an operational AD tool written in PASCAL-SC. RN1 defines a new data type for which the standard operations are overloaded. When operations using this new type are executed, derivatives are propagated in the forward mode.
Reference: [Pfei87a] <author> F. W. Pfeiffer, </author> <title> Automatic differentiation in PROSE, </title> <journal> ACM SIGNUM Newsletter, </journal> <volume> 22 (1987), </volume> <pages> pp. 1-8. </pages>
Reference-contexts: They are characterized by source languages that directly provide automatic differentiation. Several of the earliest AD tools belong to the integral class. The best examples of these are SLANG [Adam69a, McCu69a, Tham69a] and PROSE <ref> [Tham75a, PROS77a, Tham82a, Krin84a, Pfei87a] </ref>. More recent examples of integral AD tools are the modeling language AMPL [Four90a], and the FM/FAD [Mazo91a] package. The operational tools have their origins in the ideas embodied by both the elemental and extensional tools.
Reference: [Rall81a] <author> L. B. Rall, </author> <title> Automatic Differentiation: Techniques and Applications, </title> <booktitle> vol. 120 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: In the forward mode, derivative values propagate from the independent variables to the dependent variables. For more in-depth descriptions of these automatic differentiation techniques, see <ref> [Rall81a, Irim87a, Grie89a, etc.] </ref>. As noted by Griewank [Grie89a], neither the forward mode nor the reverse mode is optimal in all cases.
Reference: [Rost91a] <author> N. Rostaing and M. Gaetano, </author> <title> Response to electronic mail survey. </title> <type> Personal communication, </type> <month> March </month> <year> 1991. </year>
Reference-contexts: Procedures for derivative values of arbitrary order and with respect to arbitrary independent variables can be generated. These procedures calculate derivatives in the forward mode. Maple procedures can be converted into FORTRAN or C subroutines. 12 Part VIII. Experience with Automatic Differentiation Software (28) The NR1 package <ref> [Rost91a] </ref> is a symbolic AD tool. NR1 is implemented in LISP within the Reduce Computer Algebra system. NR1 processes a Reduce procedure that satisfies certain restrictions and produces an array of Reduce expressions. These Reduce expressions calculate the gradient of the function in the reverse mode.
Reference: [Spee80a] <author> B. Speelpenning, </author> <title> Compiling Fast Partial Derivatives of Functions Given by Algorithms, </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, Urbana-Champaign, Ill. </institution> <month> 61801, January </month> <year> 1980. </year>
Reference-contexts: Several AD tools have been created with the help of language development tools like Lex and Yacc. The most notable of these AD tools are the FORTRAN precompilers JAKE <ref> [Spee80a] </ref> and PADRE2 [Kubo90a], and the modeling language AMPL [Four90a]. During the SIAM Workshop on Automatic Differentiation, it became clear that the forces driving AD technology had caused a variety of different tools to be created. Of these various tools, many of them had similar characteristics. <p> The subroutines propagate the values of variables and their partial derivatives using the forward mode. These subroutines can calculate first- and second-order partial derivatives with respect to an arbitrary number of independent variables. (10) JAKEF [Hill85a] is another FORTRAN precompiler. JAKEF is a version of JAKE <ref> [Spee80a] </ref> that was developed at Argonne National Laboratory and written using FORTRAN 77. JAKEF takes as input a FORTRAN subroutine defining a scalar or vector function, and generates a FORTRAN subroutine for computing the gradient or Jacobian of the function, respectively. <p> The trace is stored in a linearized form in auxiliary integer and real arrays. There is no facility in JAKEF for using auxiliary storage on large traces, although Speelpenning mentions in his unpublished thesis <ref> [Spee80a] </ref> how such a technique could be implemented. (11) PADRE2 [Irim87a, Kubo90a] is also a FORTRAN precompiler. PADRE2 is an extended version of PADRE, which was developed by N. Iwata [Iwat84a].
Reference: [Step91a] <author> B. R. Stephens and J. D. Pryce, DAPRE: </author> <title> A differentiation arithmetic system for FORTRAN, </title> <type> Technical Report ACM-91-3, </type> <institution> Royal Military College of Science, Shrivenham, U.K., </institution> <year> 1991. </year>
Reference-contexts: Partial derivatives can be calculated to an arbitrary-order and with respect to an arbitrary number of independent variables. The transformation creates calls to a library of Taxonomy of Automatic Differentiation Tools 7 subroutines for the elementary operations. These subroutines propagate derivative values in the forward mode. (6) DAPRE <ref> [Step91a] </ref> is a FORTRAN preprocessor. It takes as input a FORTRAN subroutine and produces a new FORTRAN subroutine in which all of the arithmetic operations are converted to calls to subroutines from a supporting run-time library. <p> The preprocessor puts some restrictions on the subset of FORTRAN used to define the subroutine (see <ref> [Step91a] </ref>). For example, EQUIVALENCE statements are not allowed. This package was designed to interface smoothly with the NAG library of mathematical software, but it is not NAG specific. (7) GRAD [Garc91a] is a FORTRAN preprocessor.
Reference: [Tesf91a] <author> L. Tesfatsion, </author> <title> Automatic evaluation of higher-order partial derivatives for nonlocal sensitivity analysis, in Automatic Differentiation of Algorithms: Theory, Implementation, and Application, </title> <editor> A. Griewank and G. F. Corliss, eds., </editor> <publisher> SIAM, </publisher> <address> Philadelphia, Penn., </address> <year> 1991, </year> <pages> pp. 157-165. </pages>
Reference-contexts: broken down into the elementary operations t1 = z fly, t1 = cos (t1), and f = x+t1, is written as follows using MJ1. t1.AdMultiply (z,y) ; t1.AdCos (t1) ; f.AdAdd (x,t1) ; (3) The implementation of the FEED (the fast efficient evaluation of derivatives) algorithm by Tesfatsion et al. <ref> [Tesf91a] </ref> consists of a suite of FORTRAN subroutines that evaluate a function value and its first-, second- and third-order partial derivatives with respect to N independent variables. In the FEED implementation, derivatives are propagated in the forward mode as operations are performed.

Reference: [Yosh89a] <author> T. Yoshida, </author> <title> Automatic derivative derivation system, </title> <journal> Transactions of Information Processing Society of Japan, </journal> <volume> 30 (1989), </volume> <pages> pp. 799-806. </pages> <note> (In Japanese). </note>
Reference-contexts: Of the tools surveyed, four are integral tools. Of these, one uses the forward mode of automatic differentiation, one uses the reverse mode, and two use both modes. (21) The ADDS (Automatic Derivative Derivation System) <ref> [Yosh89a] </ref> package is an AD tool that defines a new language. The ADDS package provides a language for describing scalar, vector, and matrix expressions, and their partial derivatives. Expressions defined in the ADDS language are translated into FORTRAN.
References-found: 38

