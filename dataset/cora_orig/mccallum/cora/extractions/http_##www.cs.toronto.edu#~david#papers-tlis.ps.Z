URL: http://www.cs.toronto.edu/~david/papers-tlis.ps.Z
Refering-URL: http://www.cs.toronto.edu/~david/papers.html
Root-URL: http://www.cs.toronto.edu
Title: Logics for Databases and Information Systems Edited by  
Author: Jan Chomicki, Gunter Saake 
Note: Kluwer Academic Publishers Boston/Dordrecht/London  
Address: Magdeburg  
Affiliation: Monmouth University University of  
Abstract-found: 0
Intro-found: 0
Reference: [AB94] <author> K. R. Apt and R. N. Bol. </author> <title> Logic Programming and Negation: A Survey. </title> <journal> Journal of Logic Programming, </journal> <volume> 19-20:971, </volume> <year> 1994. </year>
Reference-contexts: More sophisticated temporal connectives involving numeric bounds on time [Brz91; Brz93; Brz95] can be simulated using arithmetic constraints in the Constraint Logic Programming paradigm of Jaffar and Lassez [JL87]. One can also study the extensions of the above Horn clause languages with various kinds of negation <ref> [AB94] </ref>. Recently, Datalog 1S with negation has been used to define the operational semantics of active database systems: see Chapter ??. Temporal logic programming languages are directly amenable to efficient implementation using the existing logic programming technology.
Reference: [AH92] <author> R. Alur and T. A. Henzinger. </author> <title> Logics and Models of Real-Time: A Survey. </title> <booktitle> In Real-Time: Theory in Practice, </booktitle> <pages> pages 74106. </pages> <publisher> Springer-Verlag, LNCS 600, </publisher> <year> 1992. </year>
Reference-contexts: ] is defined as: 2 [k 1 ;k 2 ] X 1 = 9t 1 :t 0 + k 1 t 1 t 0 + k 2 ^ X 1 : Propositional temporal logic with real-time temporal connectives has been extensively used for the specification and verification of real-time systems <ref> [AH92; Koy89] </ref>. The first-order version of this logic has been applied to the specification of real-time integrity constraints [Cho95], and real-time logic programs [Brz93; Brz95]. Similarly to the 4 and 5 connectives the real time connectives (with integral bounds) are first-order definable in the theory of discrete linear order.
Reference: [AHV95] <author> S. Abiteboul, R. Hull, and V. Vianu. </author> <title> Foundations of Databases. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: only one company is formulated in 2-FOL as 9c; t:Works (t; x; c) ^ :9c 0 ; t 0 :(Works (t 0 ; x; c 0 ) ^ c 0 6= c): The semantics for this language is defined in the standard way, similarly to the semantics of relational calculus <ref> [AHV95] </ref>. Definition 15 (2-FOL: semantics) Let DB be a timestamp temporal database over D, T P , and ae, ' a formula in L P , and a two-sorted valuation. <p> This fact causes major problems when implementing query processors for temporal query languages as the common (and efficient) implementations inherently depend on the equivalence of relational algebra and calculus to be able to execute all queries <ref> [AHV95; Ull89] </ref>. 1.3.3 Space-efficient Encoding of Temporal Databases While abstract temporal databases provide a natural semantic domain for interpreting temporal queries, they are not immediately suitable for the implementation, as they are possibly infinite (e.g., when the database contains a fact holding for infinitely many time instants). <p> The latter paper also shows that the expressive power of ETL is incomparable to that of L P . For other temporal domains, the expressive power of temporal logic with monadic second-order connectives has not yet been studied. Fixpoints. For a general discussion of fixpoint query languages, see <ref> [AHV95] </ref>.
Reference: [AHVdB95] <author> S. Abiteboul, L. Herr, and J. Van den Bussche. </author> <title> Temporal Connec-tives versus Explicit Timestamps in Temporal Query Languages (preliminary report). </title> <booktitle> In International Workshop of Temporal Databases, </booktitle> <address> Z urich, Switzerland, </address> <month> September </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: For other temporal domains, the expressive power of temporal logic with monadic second-order connectives has not yet been studied. Fixpoints. For a general discussion of fixpoint query languages, see [AHV95]. A number of temporal fixpoint query languages have recently been recently proposed by Abiteboul et al. <ref> [AHVdB95] </ref>: TS-FIXPOINT: the extension of L P with inflationary fixpoints, T-FIXPOINT: the extension of temporal logic with inflationary fixpoints and some additional constructs: moves back and forth in time, and local and non inflationary variables (for details, see [AHVdB95]). 32 LOGICS FOR DATABASES AND INFORMATION SYSTEMS Abiteboul et al. [AHVdB95] also <p> fixpoint query languages have recently been recently proposed by Abiteboul et al. <ref> [AHVdB95] </ref>: TS-FIXPOINT: the extension of L P with inflationary fixpoints, T-FIXPOINT: the extension of temporal logic with inflationary fixpoints and some additional constructs: moves back and forth in time, and local and non inflationary variables (for details, see [AHVdB95]). 32 LOGICS FOR DATABASES AND INFORMATION SYSTEMS Abiteboul et al. [AHVdB95] also proposed the corresponding non-inflationary versions of those languages, and showed that TS-FIXPOINT is at least as expressive as T-FIXPOINT and that the relationship in the other direction depends on some unresolved questions in complexity theory. <p> al. <ref> [AHVdB95] </ref>: TS-FIXPOINT: the extension of L P with inflationary fixpoints, T-FIXPOINT: the extension of temporal logic with inflationary fixpoints and some additional constructs: moves back and forth in time, and local and non inflationary variables (for details, see [AHVdB95]). 32 LOGICS FOR DATABASES AND INFORMATION SYSTEMS Abiteboul et al. [AHVdB95] also proposed the corresponding non-inflationary versions of those languages, and showed that TS-FIXPOINT is at least as expressive as T-FIXPOINT and that the relationship in the other direction depends on some unresolved questions in complexity theory. On the other hand, T-FIXPOINT is more expressive than L P .
Reference: [AHVdB96] <author> S. Abiteboul, L. Herr, and J. Van den Bussche. </author> <title> Temporal Versus First-Order Logic to Query Temporal Databases. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 4957, </pages> <address> Montr eal, Canada, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: ^ closed (S 0 ) ) S S 0 ) where closed (S) 4 For the temporal domain (N; &lt;), the above extension is identical in expressive power to ETL, temporal logic with temporal connectives defined using regular expressions, studied by Wolper [Wol83] (the propositional case) and Abiteboul et al. <ref> [AHVdB96] </ref> (the first-order case). The latter paper also shows that the expressive power of ETL is incomparable to that of L P . For other temporal domains, the expressive power of temporal logic with monadic second-order connectives has not yet been studied. Fixpoints.
Reference: [All83] <author> J. F. Allen. </author> <title> Maintaining Knowledge about Temporal Intervals. </title> <journal> Communications of the ACM, </journal> <volume> 26(11):832843, </volume> <month> November </month> <year> 1983. </year>
Reference-contexts: However, it is easy to see that, e.g., I &lt; J can be expressed as I &lt; J , etc., and the new notation is thus merely syntactic sugar. We could also equivalently use Allen's algebra operators <ref> [All83] </ref>. The resulting language is equivalent to L I . We assume the usual Tarskian semantics for formulas in L I . Therefore L I is fairly easy to implement using standard relational techniques. <p> Unfortunately (and also in most cases) the syntax is based on the syntax of L I or some of its variants, e.g., languages that use Allen's interval algebra operators <ref> [All83] </ref>. This discrepancy leads to a tension between the syntactic constructs used in the language and the intended semantics of queries. While we focus mostly on temporal extensions of SQL, our observations are general enough to apply to temporal extensions of other query languages, e.g., TQuel [Sno87].
Reference: [All84] <author> J. F. Allen. </author> <title> Towards a General Theory of Action and Time. </title> <journal> Artificial Intelligence, </journal> <volume> 23:123154, </volume> <year> 1984. </year>
Reference-contexts: This definition can be used to define most of the common multi-dimensional temporal logics, e.g., the temporal logic with the now operator [Kam71], the Vlach and Aqvist system [ Aqv79], and most of the interval logics <ref> [All84; vB83] </ref>. TEMPORAL LOGIC IN INFORMATION SYSTEMS 29 Again, Definition 46 allows only logics with first-order definable temporal connec-tives. It also clarifies the difference between two distinct uses of intervals in temporal databases: 1. intervals as encodings of convex 1-dimensional sets, or 2. intervals as a representation of 2-dimensional points. <p> Thus applying set-based operations on these intervals does not have a clear and intuitive meaning. Note that in Section 1.3 we used solely the first paradigm. The second paradigm often corresponds to languages L (2) <ref> [All84; vB83] </ref>. To compare the expressive power of temporal logics with respect to the dimension of the temporal connectives we use the following observation.
Reference: [AM89] <author> M. Abadi and Z. Manna. </author> <title> Temporal Logic Programming. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 8(3):277295, </volume> <month> September </month> <year> 1989. </year> <note> 34 LOGICS FOR DATABASES AND INFORMATION SYSTEMS </note>
Reference-contexts: Temporal Logic Programming. Another way to escape the limitations of temporal logic is to keep its syntax but use different semantics for its Horn subset. This is analogous to the move from first-order logic to logic programming. Indeed, proposals by Abadi and Manna <ref> [AM89] </ref>, Baudinet [Bau92; Bau95], and Brzoska [Brz91; Brz93; Brz95] have been made to extend the language of Horn clauses with temporal connectives in such a way that there is still some notion of least model and resolution-based operational semantics, see Chapter ??. <p> Not surprisingly, those languages can be usually translated to the standard logic programming languages. For instance, the temporal connectives in Templog <ref> [AM89; Bau92; Bau95] </ref> can be simulated in Prolog using an additional predicate argument that can contain the successor function symbol [BCW93; CI88]. In this way, an exact correspondence is obtained between function-free Templog and Datalog 1S , an extension of Datalog with the successor function symbol in one predicate argument.
Reference: [ Aqv79] <author> L. Aqvist. </author> <title> A Conjectured Axiomatization of Two-Dimensional Reichen-bachian Tense Logic. </title> <journal> J. Philosophical Logic, </journal> <volume> 8:145, </volume> <year> 1979. </year>
Reference-contexts: This definition can be used to define most of the common multi-dimensional temporal logics, e.g., the temporal logic with the now operator [Kam71], the Vlach and Aqvist system <ref> [ Aqv79] </ref>, and most of the interval logics [All84; vB83]. TEMPORAL LOGIC IN INFORMATION SYSTEMS 29 Again, Definition 46 allows only logics with first-order definable temporal connec-tives.
Reference: [AS85] <author> B. Alpern and F. B. Schneider. </author> <title> Defining Liveness. </title> <journal> Information Processing Letters, </journal> <volume> 21:181185, </volume> <year> 1985. </year>
Reference-contexts: In a related work, Lipeck [Lip90] showed how to refine transaction specifications, so that temporal integrity constraints are never violated. Safety vs. Liveness. Does every temporal logic formula make sense as a temporal integrity constraint? Here the distinction between safety and liveness formulas <ref> [AS85; Pnu86] </ref> is very helpful. Intuitively, safety formulas say that nothing bad ever happens and liveness formulas that something good will happen. An example of a safety formula is 0 9x:p (x), of a liveness formula 2 9x:p (x).
Reference: [Bau92] <author> M. Baudinet. </author> <title> A Simple Proof of the Completeness of Temporal Logic Programming. </title> <editor> In L. Fari nas del Cerro and M. Penttonen, editors, </editor> <title> Intensional Logics for Programming. </title> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference-contexts: Temporal Logic Programming. Another way to escape the limitations of temporal logic is to keep its syntax but use different semantics for its Horn subset. This is analogous to the move from first-order logic to logic programming. Indeed, proposals by Abadi and Manna [AM89], Baudinet <ref> [Bau92; Bau95] </ref>, and Brzoska [Brz91; Brz93; Brz95] have been made to extend the language of Horn clauses with temporal connectives in such a way that there is still some notion of least model and resolution-based operational semantics, see Chapter ??. <p> Not surprisingly, those languages can be usually translated to the standard logic programming languages. For instance, the temporal connectives in Templog <ref> [AM89; Bau92; Bau95] </ref> can be simulated in Prolog using an additional predicate argument that can contain the successor function symbol [BCW93; CI88]. In this way, an exact correspondence is obtained between function-free Templog and Datalog 1S , an extension of Datalog with the successor function symbol in one predicate argument.
Reference: [Bau95] <author> M. Baudinet. </author> <title> On the Expressiveness of Temporal Logic Programming. Information and Computation, </title> <address> 117(2):157180, </address> <year> 1995. </year>
Reference-contexts: Temporal Logic Programming. Another way to escape the limitations of temporal logic is to keep its syntax but use different semantics for its Horn subset. This is analogous to the move from first-order logic to logic programming. Indeed, proposals by Abadi and Manna [AM89], Baudinet <ref> [Bau92; Bau95] </ref>, and Brzoska [Brz91; Brz93; Brz95] have been made to extend the language of Horn clauses with temporal connectives in such a way that there is still some notion of least model and resolution-based operational semantics, see Chapter ??. <p> Not surprisingly, those languages can be usually translated to the standard logic programming languages. For instance, the temporal connectives in Templog <ref> [AM89; Bau92; Bau95] </ref> can be simulated in Prolog using an additional predicate argument that can contain the successor function symbol [BCW93; CI88]. In this way, an exact correspondence is obtained between function-free Templog and Datalog 1S , an extension of Datalog with the successor function symbol in one predicate argument.
Reference: [BCP94] <author> E. Baralis, S. Ceri, and S. Paraboschi. </author> <title> Declarative Specification of Constraint Maintenance. </title> <booktitle> In International Conference on Entity-Relationship Approach, pages 205222. </booktitle> <publisher> Springer-Verlag, LNCS 881, </publisher> <year> 1994. </year>
Reference-contexts: There are currently no tools, formal or otherwise, that could help him in this task. The work on automatically generating triggers from constraint specifications [CW90] and declarative specification 24 LOGICS FOR DATABASES AND INFORMATION SYSTEMS of constraint maintenance <ref> [BCP94] </ref> can perhaps be generalized to temporal integrity constraints and triggers. Transaction Validation [dCCF82; Kun85; Lip90]. Here the assumption is that the database will only be updated by a fixed set of transactions. The transactions are analyzed in advance.
Reference: [BCST96] <author> M. B ohlen, J. Chomicki, R. T. Snodgrass, and D. Toman. </author> <title> Querying TSQL2 Databases with Temporal Logic. </title> <booktitle> In International Conference on Extending Database Technology, </booktitle> <pages> pages 325341, </pages> <address> Avignon, France, 1996. </address> <publisher> Springer Verlag, LNCS 1057. </publisher>
Reference-contexts: The semantics of this language is based on a natural extension of Definition 11. 22 LOGICS FOR DATABASES AND INFORMATION SYSTEMS We can use Theorem 29 to evaluate queries in this language efficiently over coalesced interval-encoded concrete temporal databases <ref> [BCST96] </ref>. Note that in this case all temporal relations have only one temporal attribute and therefore we can use coalescing. Alternatively we can compose the mappings defined in Definition 16 with Theorem 27 to obtain a query evaluation procedure for L .
Reference: [BCW93] <author> M. Baudinet, J. Chomicki, and P. Wolper. </author> <title> Temporal Deductive Databases. </title> <editor> In Tansel et al. </editor> <volume> [TCG + 93], chapter 13, </volume> <pages> pages 294320. </pages>
Reference-contexts: Not surprisingly, those languages can be usually translated to the standard logic programming languages. For instance, the temporal connectives in Templog [AM89; Bau92; Bau95] can be simulated in Prolog using an additional predicate argument that can contain the successor function symbol <ref> [BCW93; CI88] </ref>. In this way, an exact correspondence is obtained between function-free Templog and Datalog 1S , an extension of Datalog with the successor function symbol in one predicate argument.
Reference: [Brz91] <author> Ch. Brzoska. </author> <title> Temporal Logic Programming and its Relation to Constraint Logic Programming. </title> <editor> In Vijay Saraswat and Kazunori Ueda, editors, </editor> <booktitle> International Logic Programming Symposium, </booktitle> <pages> pages 661677. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Temporal Logic Programming. Another way to escape the limitations of temporal logic is to keep its syntax but use different semantics for its Horn subset. This is analogous to the move from first-order logic to logic programming. Indeed, proposals by Abadi and Manna [AM89], Baudinet [Bau92; Bau95], and Brzoska <ref> [Brz91; Brz93; Brz95] </ref> have been made to extend the language of Horn clauses with temporal connectives in such a way that there is still some notion of least model and resolution-based operational semantics, see Chapter ??. Not surprisingly, those languages can be usually translated to the standard logic programming languages. <p> In this way, an exact correspondence is obtained between function-free Templog and Datalog 1S , an extension of Datalog with the successor function symbol in one predicate argument. More sophisticated temporal connectives involving numeric bounds on time <ref> [Brz91; Brz93; Brz95] </ref> can be simulated using arithmetic constraints in the Constraint Logic Programming paradigm of Jaffar and Lassez [JL87]. One can also study the extensions of the above Horn clause languages with various kinds of negation [AB94].
Reference: [Brz93] <author> Ch. Brzoska. </author> <title> Temporal Logic Programming with Bounded Universal Modality Goals. </title> <editor> In David S. Warren, editor, </editor> <booktitle> International Conference on Logic Programming, </booktitle> <pages> pages 239256. </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: The first-order version of this logic has been applied to the specification of real-time integrity constraints [Cho95], and real-time logic programs <ref> [Brz93; Brz95] </ref>. Similarly to the 4 and 5 connectives the real time connectives (with integral bounds) are first-order definable in the theory of discrete linear order. <p> Temporal Logic Programming. Another way to escape the limitations of temporal logic is to keep its syntax but use different semantics for its Horn subset. This is analogous to the move from first-order logic to logic programming. Indeed, proposals by Abadi and Manna [AM89], Baudinet [Bau92; Bau95], and Brzoska <ref> [Brz91; Brz93; Brz95] </ref> have been made to extend the language of Horn clauses with temporal connectives in such a way that there is still some notion of least model and resolution-based operational semantics, see Chapter ??. Not surprisingly, those languages can be usually translated to the standard logic programming languages. <p> In this way, an exact correspondence is obtained between function-free Templog and Datalog 1S , an extension of Datalog with the successor function symbol in one predicate argument. More sophisticated temporal connectives involving numeric bounds on time <ref> [Brz91; Brz93; Brz95] </ref> can be simulated using arithmetic constraints in the Constraint Logic Programming paradigm of Jaffar and Lassez [JL87]. One can also study the extensions of the above Horn clause languages with various kinds of negation [AB94].
Reference: [Brz95] <author> Ch. Brzoska. </author> <title> Temporal Logic Programming in Dense Time. </title> <editor> In John W. Lloyd, editor, </editor> <booktitle> International Logic Programming Symposium, </booktitle> <pages> pages 303 317. </pages> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: The first-order version of this logic has been applied to the specification of real-time integrity constraints [Cho95], and real-time logic programs <ref> [Brz93; Brz95] </ref>. Similarly to the 4 and 5 connectives the real time connectives (with integral bounds) are first-order definable in the theory of discrete linear order. <p> Temporal Logic Programming. Another way to escape the limitations of temporal logic is to keep its syntax but use different semantics for its Horn subset. This is analogous to the move from first-order logic to logic programming. Indeed, proposals by Abadi and Manna [AM89], Baudinet [Bau92; Bau95], and Brzoska <ref> [Brz91; Brz93; Brz95] </ref> have been made to extend the language of Horn clauses with temporal connectives in such a way that there is still some notion of least model and resolution-based operational semantics, see Chapter ??. Not surprisingly, those languages can be usually translated to the standard logic programming languages. <p> In this way, an exact correspondence is obtained between function-free Templog and Datalog 1S , an extension of Datalog with the successor function symbol in one predicate argument. More sophisticated temporal connectives involving numeric bounds on time <ref> [Brz91; Brz93; Brz95] </ref> can be simulated using arithmetic constraints in the Constraint Logic Programming paradigm of Jaffar and Lassez [JL87]. One can also study the extensions of the above Horn clause languages with various kinds of negation [AB94].
Reference: [BSS96] <author> M. B ohlen, R. T. Snodgrass, and M. D. Soo. </author> <title> Coalescing in Temporal Databases. </title> <booktitle> In International Conference on Very Large Data Bases, </booktitle> <pages> pages 180191, </pages> <year> 1996. </year>
Reference-contexts: The formal justification of this approach lies in realization that the intended semantics of the language is point-based and therefore we can evaluate queries over any of the k:k-equivalent temporal databases (one of which is the coalesced one). For a detailed discussion of coalescing in temporal databases see <ref> [BSS96] </ref>. The most prominent representatives of this approach are TQuel [Sno87; Sno93], and TSQL2 [Sno95; SAA + 94]. However: Coalescing does not solve the problem with the above query: if a person works for three different companies she is still in the answer to the query.
Reference: [BTK91] <author> F. Bacchus, J. Tenenberg, and J. A. Koomen. </author> <title> A Non-Reified Temporal Logic. </title> <journal> Artificial Intelligence, </journal> <volume> 52(1):87108, </volume> <year> 1991. </year>
Reference-contexts: It is just the two-sorted version of first-order logic (2-FOL) over D and T P , with the limitation that the relations can have only one temporal argument <ref> [BTK91] </ref>.
Reference: [CGK96] <author> J. Chomicki, D. Goldin, and G. Kuper. </author> <title> Variable Independence and Aggregation Closure. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 4048, </pages> <address> Montr eal, Canada, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: There are several ways of dealing with this issue: We can choose a multi-dimensional temporal logic where all the introduced connectives preserve closure over the chosen encoding. We can introduce closure restriction for formulas in L P <ref> [CGK96; Tom97] </ref>. Such a restriction is designed to guarantee attribute independence of the free variables in the query and subsequently closure over an encoding obtained by taking an appropriate number of cartesian (self-)products of the single-dimensional encoding.
Reference: [Cho94] <author> J. Chomicki. </author> <title> Temporal Query Languages: A Survey. </title> <editor> In D. M. Gabbay and H. J. Ohlbach, editors, </editor> <booktitle> Temporal Logic, First International Conference, </booktitle> <pages> pages 506534. </pages> <publisher> Springer-Verlag, LNAI 827, </publisher> <year> 1994. </year> <note> REFERENCES 35 </note>
Reference-contexts: Temporal logic combines abstract, formal semantics with the amenability to efficient implementation. This chapter shows how temporal logic can be used in temporal database applications. Rather than presenting new results, we report on recent developments and survey the field in a systematic way using a unified formal framework <ref> [GHR94; Cho94] </ref>. The handbook [GHR94] is a comprehensive reference on mathematical foundations of temporal logic. In this chapter we study how temporal logic is used as a query and integrity constraint language. Consequently, model-theoretic notions, particularly formula satisfaction, are of primary interest. <p> Abstract query languages are discussed in Section 1.3.1, concrete ones in Section 1.3.4. One obtains an abstract temporal database by linking a standard relational database with a temporal domain. There are several alternative ways of doing that <ref> [Cho94] </ref>: The timestamp model is defined by augmenting all tuples in relations by an additional temporal attribute. The snapshot model is defined as a mapping of the temporal domain to the class of standard relational databases. This gives a Kripke structure with the temporal domain serving as the accessibility relation. <p> We would like to point out that vast majority of practical temporal query languages assume a point-based model of time (i.e., the truth of facts is associated with single time instants rather than with sets of time instants) <ref> [Cho94] </ref>. Unfortunately (and also in most cases) the syntax is based on the syntax of L I or some of its variants, e.g., languages that use Allen's interval algebra operators [All83]. <p> For a similar example in TQuel see <ref> [Cho94] </ref>. Strangely enough, this query accesses the relation Works only twice while the original query in Example 31 needs to access the relation three times. This is often considered to be a feature of the L I -based proposals and is attributed to the use of interval-based temporal attributes.
Reference: [Cho95] <author> J. Chomicki. </author> <title> Efficient Checking of Temporal Integrity Constraints Using Bounded History Encoding. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 20(2):149186, </volume> <month> June </month> <year> 1995. </year>
Reference-contexts: The first-order version of this logic has been applied to the specification of real-time integrity constraints <ref> [Cho95] </ref>, and real-time logic programs [Brz93; Brz95]. Similarly to the 4 and 5 connectives the real time connectives (with integral bounds) are first-order definable in the theory of discrete linear order. <p> In both cases infinity provides a convenient mathematical abstraction. 1.4.2 Temporal Integrity Maintenance We discuss now three different scenarios for temporal integrity maintenance: constraint checking, temporal triggers, and transaction validation. In this context, we also review the well-known distinction between safety and liveness properties [Pnu86]. Constraint Checking <ref> [Cho95; CT95; GL96; HS91; LS87] </ref>. The assumption here is that updates are arbitrary mappings producing finite states. An update is committed if in the resulting history all the constraints are potentially satisfied and aborted otherwise. Temporal Triggers [SW95]. Again, the basic assumption is that updates are arbitrary. <p> Biquantified formulas allow only future temporal operators and restricted quantification in the following sense: the quantifiers can be either external (not in the scope of any temporal connective) or internal (no temporal connective in their scope). Moreover, all external quantifiers are universal. Chomicki <ref> [Cho95] </ref> proposed the class of past temporal formulas, in which the only temporal connectives are 5 and since and their derivatives, without any restrictions on quantification. The main theoretical results are as follows. <p> As far as we know the above results are still the only known characterizations of the computational complexity of checking temporal integrity constraints formulated in temporal logic. For past formulas, Chomicki <ref> [Cho95] </ref> proposed a practical method for checking temporal logic constraints. <p> There remain many open problems in the area of temporal database integrity. For example, one should consider more expressive constraint languages that use non-first-order constructs (see Section 1.6) or temporal aggregation. It seems that Chomicki's method <ref> [Cho95] </ref> can be adapted to handle at least some of those extensions. Another topic is the semantics and implementation of evolving sets of constraints. For a more detailed discussion of open problems in this area see [Cho95]. 1.5 MULTIDIMENSIONAL TIME In Section 1.3 we considered only single-dimensional temporal databases: temporal relations <p> It seems that Chomicki's method <ref> [Cho95] </ref> can be adapted to handle at least some of those extensions. Another topic is the semantics and implementation of evolving sets of constraints. For a more detailed discussion of open problems in this area see [Cho95]. 1.5 MULTIDIMENSIONAL TIME In Section 1.3 we considered only single-dimensional temporal databases: temporal relations were allowed only a single temporal attribute.
Reference: [CI88] <author> J. Chomicki and T. Imieli nski. </author> <title> Temporal Deductive Databases and Infinite Objects. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 6173, </pages> <address> Austin, Texas, </address> <month> March </month> <year> 1988. </year>
Reference-contexts: Not surprisingly, those languages can be usually translated to the standard logic programming languages. For instance, the temporal connectives in Templog [AM89; Bau92; Bau95] can be simulated in Prolog using an additional predicate argument that can contain the successor function symbol <ref> [BCW93; CI88] </ref>. In this way, an exact correspondence is obtained between function-free Templog and Datalog 1S , an extension of Datalog with the successor function symbol in one predicate argument.
Reference: [CN95] <author> J. Chomicki and D. Niwinski. </author> <title> On the Feasibility of Checking Temporal Integrity Constraints. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 51(3):523535, </volume> <month> December </month> <year> 1995. </year>
Reference-contexts: Consequently, safety formulas are particularly suitable to the constraint checking scenario. On the other hand, liveness formulas are always potentially satisfiable. (A detailed discussion of safety vs. liveness in the database context can be found in <ref> [CN95] </ref>, and in the context of proving properties of concurrent programs in [MP92].) Similar considerations apply to temporal triggers, although because of the duality negations of safety formulas are of interest there.
Reference: [Cod72] <author> E. F. Codd. </author> <title> Relational Completeness of Data Base Sub-Languages. </title> <editor> In R. Rustin, editor, </editor> <booktitle> Data Base Systems, </booktitle> <pages> pages 3364. </pages> <publisher> Prentice-Hall, </publisher> <year> 1972. </year>
Reference-contexts: Domain independent relational calculus queries (those that depend only on the instance of ae and not on the underlying domain of values D) can be equivalently expressed in relational algebra <ref> [Cod72] </ref>. In this way the relational model provides a natural declarative paradigm for representing and querying information stored in a relational database, as well as the possibility of efficient implementation of queries through relational algebra.
Reference: [CT95] <author> J. Chomicki and D. Toman. </author> <title> Implementing Temporal Integrity Constraints Using an Active DBMS. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 7(4):566582, </volume> <month> August </month> <year> 1995. </year>
Reference-contexts: In both cases infinity provides a convenient mathematical abstraction. 1.4.2 Temporal Integrity Maintenance We discuss now three different scenarios for temporal integrity maintenance: constraint checking, temporal triggers, and transaction validation. In this context, we also review the well-known distinction between safety and liveness properties [Pnu86]. Constraint Checking <ref> [Cho95; CT95; GL96; HS91; LS87] </ref>. The assumption here is that updates are arbitrary mappings producing finite states. An update is committed if in the resulting history all the constraints are potentially satisfied and aborted otherwise. Temporal Triggers [SW95]. Again, the basic assumption is that updates are arbitrary. <p> These views should be materialized in every state, except for the first one, in the same way. In the first state, the views are initialized with empty relations. An implementation of the above method has been completed <ref> [CT95] </ref>. While in principle any temporal query language can be used to express temporal integrity constraints, in practice only temporal logic has been studied in this context.
Reference: [CW90] <author> S. Ceri and J. Widom. </author> <title> Deriving Production Rules for Constraint Maintenance. </title> <editor> In Dennis McLeod, Ron Sacks-Davis, and Hans-Joerg Schek, editors, </editor> <booktitle> International Conference on Very Large Data Bases, </booktitle> <pages> pages 566 577, </pages> <year> 1990. </year>
Reference-contexts: However, it is up to the trigger designer to guarantee that the integrity be restored by appropriately programming the action part of the trigger. There are currently no tools, formal or otherwise, that could help him in this task. The work on automatically generating triggers from constraint specifications <ref> [CW90] </ref> and declarative specification 24 LOGICS FOR DATABASES AND INFORMATION SYSTEMS of constraint maintenance [BCP94] can perhaps be generalized to temporal integrity constraints and triggers. Transaction Validation [dCCF82; Kun85; Lip90]. Here the assumption is that the database will only be updated by a fixed set of transactions.
Reference: [dCCF82] <author> J. M. V. de Castilho, M. A. Casanova, and A. L. Furtado. </author> <title> A Temporal Framework for Database Specifications. </title> <booktitle> In International Conference on Very Large Data Bases, </booktitle> <pages> pages 280291, </pages> <year> 1982. </year>
Reference-contexts: The work on automatically generating triggers from constraint specifications [CW90] and declarative specification 24 LOGICS FOR DATABASES AND INFORMATION SYSTEMS of constraint maintenance [BCP94] can perhaps be generalized to temporal integrity constraints and triggers. Transaction Validation <ref> [dCCF82; Kun85; Lip90] </ref>. Here the assumption is that the database will only be updated by a fixed set of transactions. The transactions are analyzed in advance. De Castilho et al. [dCCF82] proposed to check whether the transactions are always guaranteed to preserve the integrity constraints using theorem proving techniques. <p> Transaction Validation [dCCF82; Kun85; Lip90]. Here the assumption is that the database will only be updated by a fixed set of transactions. The transactions are analyzed in advance. De Castilho et al. <ref> [dCCF82] </ref> proposed to check whether the transactions are always guaranteed to preserve the integrity constraints using theorem proving techniques. Kung [Kun85] presented a model-checking [Eme90] approach to testing the consistency of transaction specifications with integrity constraints. Completeness, decidability, and computational complexity issues were not addressed in either work.
Reference: [Eme90] <author> E. A. Emerson. </author> <title> Temporal and Modal Logic. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B, chapter 16, </booktitle> <pages> pages 9951072. </pages> <publisher> Elsevier/MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Except for section 1.5, we adopt the single-dimensional view. Finally, there is a choice of linear vs. nonlinear time, i.e., whether time should be viewed as a single line or rather as a tree <ref> [Eme90] </ref>, or even an acyclic graph [Wol89]. Although nonlinear time is potentially applicable to some database problems like version control or workflows, there has been very little work in this area. Therefore, in this chapter we concentrate on temporal domains that are linearly ordered sets. <p> The transactions are analyzed in advance. De Castilho et al. [dCCF82] proposed to check whether the transactions are always guaranteed to preserve the integrity constraints using theorem proving techniques. Kung [Kun85] presented a model-checking <ref> [Eme90] </ref> approach to testing the consistency of transaction specifications with integrity constraints. Completeness, decidability, and computational complexity issues were not addressed in either work. It would be interesting to see whether recent advances in model checking and theorem proving techniques can be applied in this area.
Reference: [GHR94] <author> D. M. Gabbay, I. Hodkinson, and M. Reynolds. </author> <title> Temporal Logic: Mathematical Foundations and Computational Aspects. </title> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference-contexts: Temporal logic combines abstract, formal semantics with the amenability to efficient implementation. This chapter shows how temporal logic can be used in temporal database applications. Rather than presenting new results, we report on recent developments and survey the field in a systematic way using a unified formal framework <ref> [GHR94; Cho94] </ref>. The handbook [GHR94] is a comprehensive reference on mathematical foundations of temporal logic. In this chapter we study how temporal logic is used as a query and integrity constraint language. Consequently, model-theoretic notions, particularly formula satisfaction, are of primary interest. <p> This chapter shows how temporal logic can be used in temporal database applications. Rather than presenting new results, we report on recent developments and survey the field in a systematic way using a unified formal framework [GHR94; Cho94]. The handbook <ref> [GHR94] </ref> is a comprehensive reference on mathematical foundations of temporal logic. In this chapter we study how temporal logic is used as a query and integrity constraint language. Consequently, model-theoretic notions, particularly formula satisfaction, are of primary interest. Axiomatic systems and proof methods for temporal logic [GHR94] have found so far <p> The handbook <ref> [GHR94] </ref> is a comprehensive reference on mathematical foundations of temporal logic. In this chapter we study how temporal logic is used as a query and integrity constraint language. Consequently, model-theoretic notions, particularly formula satisfaction, are of primary interest. Axiomatic systems and proof methods for temporal logic [GHR94] have found so far relatively few applications in the context of information systems. Moreover, one needs to bear in mind that for the standard linearly-ordered time domains temporal logic is not recursively axiomatizable [GHR94], so recursive axiomatizations are by necessity incomplete. <p> Axiomatic systems and proof methods for temporal logic <ref> [GHR94] </ref> have found so far relatively few applications in the context of information systems. Moreover, one needs to bear in mind that for the standard linearly-ordered time domains temporal logic is not recursively axiomatizable [GHR94], so recursive axiomatizations are by necessity incomplete. Databases are inherently first-order structures and thus in this chapter we are primarily interested in first-order temporal logic. This is in sharp contrast with another major application area of temporal logic, program verification, where the formalisms studied are usually propositional [MP92; Pnu86]. <p> In this way the manipulation of the temporal dimension is completely hidden from the user, as it is performed on implicit temporal attributes. Historically, many different variants of temporal logic based on different sets of connectives have been developed <ref> [GHR94] </ref>. Some of the connectives, like 2 (sometime in the future), 0 (always in the future), or until are well-known and have been universally accepted. <p> The latter result was established by Kamp for complete linear orders, extended by Stavi for all linear orders, and later reproved several times using various proof techniques <ref> [Kam68; Sta79; GHR94; IK89] </ref>. On the other hand Kamp also proved the following separation result in a first-order setting L fsince;untilg @ L fsince;until;nowg v L P for dense linearly ordered time (@ denotes the strictly weaker than relationship of languages).
Reference: [GL96] <author> M. Gertz and U. Lipeck. </author> <title> Deriving Optimized Integrity Monitoring Triggers from Dynamic Integrity Constraints. </title> <journal> Data and Knowledge Engineering, </journal> <volume> 20(2):163193, </volume> <year> 1996. </year>
Reference-contexts: In both cases infinity provides a convenient mathematical abstraction. 1.4.2 Temporal Integrity Maintenance We discuss now three different scenarios for temporal integrity maintenance: constraint checking, temporal triggers, and transaction validation. In this context, we also review the well-known distinction between safety and liveness properties [Pnu86]. Constraint Checking <ref> [Cho95; CT95; GL96; HS91; LS87] </ref>. The assumption here is that updates are arbitrary mappings producing finite states. An update is committed if in the resulting history all the constraints are potentially satisfied and aborted otherwise. Temporal Triggers [SW95]. Again, the basic assumption is that updates are arbitrary.
Reference: [HS91] <author> K. H ulsmann and G. Saake. </author> <title> Theoretical Foundations of Handling Large Substitution Sets in Temporal Integrity Monitoring. </title> <journal> Acta Informatica, </journal> <volume> 28(4), </volume> <year> 1991. </year>
Reference-contexts: In both cases infinity provides a convenient mathematical abstraction. 1.4.2 Temporal Integrity Maintenance We discuss now three different scenarios for temporal integrity maintenance: constraint checking, temporal triggers, and transaction validation. In this context, we also review the well-known distinction between safety and liveness properties [Pnu86]. Constraint Checking <ref> [Cho95; CT95; GL96; HS91; LS87] </ref>. The assumption here is that updates are arbitrary mappings producing finite states. An update is committed if in the resulting history all the constraints are potentially satisfied and aborted otherwise. Temporal Triggers [SW95]. Again, the basic assumption is that updates are arbitrary.
Reference: [IK89] <author> N. Immerman and D. Kozen. </author> <title> Definability with Bounded Number of Bound Variables. Information and Computation, </title> <address> 83(2):121139, </address> <month> Novem-ber </month> <year> 1989. </year>
Reference-contexts: The latter result was established by Kamp for complete linear orders, extended by Stavi for all linear orders, and later reproved several times using various proof techniques <ref> [Kam68; Sta79; GHR94; IK89] </ref>. On the other hand Kamp also proved the following separation result in a first-order setting L fsince;untilg @ L fsince;until;nowg v L P for dense linearly ordered time (@ denotes the strictly weaker than relationship of languages).
Reference: [ISO92] <author> ISO. </author> <title> Database Language SQL. </title> <booktitle> ISO/IEC 9075:1992, International Organization for Standardization, </booktitle> <year> 1992. </year>
Reference-contexts: In this section, we focus on the proposals for temporal extensions of more practical query languages, especially SQL <ref> [ISO92] </ref>. When designing such an extension we need to overcome several obstacles: 1. The semantics of SQL and other practical languages is commonly based on a bag (duplicate) semantics rather than on a set (Tarskian) semantics.
Reference: [JL87] <author> J. Jaffar and J-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 111119, </pages> <year> 1987. </year> <note> 36 LOGICS FOR DATABASES AND INFORMATION SYSTEMS </note>
Reference-contexts: More sophisticated temporal connectives involving numeric bounds on time [Brz91; Brz93; Brz95] can be simulated using arithmetic constraints in the Constraint Logic Programming paradigm of Jaffar and Lassez <ref> [JL87] </ref>. One can also study the extensions of the above Horn clause languages with various kinds of negation [AB94]. Recently, Datalog 1S with negation has been used to define the operational semantics of active database systems: see Chapter ??.
Reference: [JSS94] <author> C. S. Jensen, M. D. Soo, and R. T. Snodgrass. </author> <title> Unifying Temporal Data Models via a Conceptual Model. </title> <journal> Information Systems, </journal> <volume> 19(7):513547, </volume> <year> 1994. </year>
Reference-contexts: The valid time (when a particular tuple is true) and the transaction time (when the particular tuple is inserted/deleted in the database) <ref> [JSS94] </ref>. Spatial databases: multiple dimensions over an interpreted domain can be used for representing spatial data where multiple dimensions serve as coordinates of points in a k-dimensional Euclidean space. 28 LOGICS FOR DATABASES AND INFORMATION SYSTEMS Most of the data modeling techniques require only fixed-dimensional data.
Reference: [Kam68] <author> J. A. W. Kamp. </author> <title> Tense Logic and the Theory of Linear Order. </title> <type> PhD thesis, </type> <institution> University of California, </institution> <address> Los Angeles, </address> <year> 1968. </year>
Reference-contexts: The latter result was established by Kamp for complete linear orders, extended by Stavi for all linear orders, and later reproved several times using various proof techniques <ref> [Kam68; Sta79; GHR94; IK89] </ref>. On the other hand Kamp also proved the following separation result in a first-order setting L fsince;untilg @ L fsince;until;nowg v L P for dense linearly ordered time (@ denotes the strictly weaker than relationship of languages).
Reference: [Kam71] <author> J. A. W. Kamp. </author> <title> Formal Properties of 'now'. </title> <journal> Theoria, </journal> <volume> 37:227273, </volume> <year> 1971. </year>
Reference-contexts: On the other hand Kamp also proved the following separation result in a first-order setting L fsince;untilg @ L fsince;until;nowg v L P for dense linearly ordered time (@ denotes the strictly weaker than relationship of languages). Thus on general structures L fsince;untilg is strictly weaker than L P <ref> [Kam71] </ref>. However, the proof of this fact uses structures that can not be modeled as abstract temporal databases because they are infinite in both the data and temporal dimensions. Also, the proof technique does not consider arbitrary temporal connectives. <p> Also, the proof technique does not consider arbitrary temporal connectives. Moreover, it is not clear if this proof technique can be adapted to discrete linear orders <ref> [Kam71] </ref>. Thus there was a hope that the gap in expressive power could be bridged by introducing additional connectives and/or by restricting the structures to abstract temporal databases that are finite at every moment of time. <p> This definition can be used to define most of the common multi-dimensional temporal logics, e.g., the temporal logic with the now operator <ref> [Kam71] </ref>, the Vlach and Aqvist system [ Aqv79], and most of the interval logics [All84; vB83]. TEMPORAL LOGIC IN INFORMATION SYSTEMS 29 Again, Definition 46 allows only logics with first-order definable temporal connec-tives.
Reference: [KKR95] <author> P. C. Kanellakis, G. M. Kuper, and P. Z. Revesz. </author> <title> Constraint Query Languages. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 51(1):2652, </volume> <month> August </month> <year> 1995. </year>
Reference-contexts: Constraint Encoding. A careful analysis of Definition 21 reveals that the intervals are essentially quantifier-free formulas in T h (&lt; Lin ) with exactly one free variable. This idea can be generalized to more general classes of constraints <ref> [KKR95] </ref>: Let (T; oe) be a point-based temporal domain with the signature oe. <p> The set C oe can serve as the basis of the temporal domain for a class of concrete temporal databases, similarly to intervals in Definition 21. An example of an alternative encoding is the use of periodic constraints [KSW95], or linear arithmetic constraints <ref> [KKR95] </ref>. <p> Such a restriction is designed to guarantee attribute independence of the free variables in the query and subsequently closure over an encoding obtained by taking an appropriate number of cartesian (self-)products of the single-dimensional encoding. We can use a more general encoding using constraints in some suitable constraint language <ref> [KKR95] </ref>. Another problem with using a multi-dimensional view of time is that it is much harder to define normal forms for temporal relations: in the single-dimensional case the TEMPORAL LOGIC IN INFORMATION SYSTEMS 31 coalesced relations provide a unique normal form (for the interval based encoding). <p> Datalog 1S with stratified negation strictly subsumes ETL but its relationship to T-FIXPOINT is unclear. None of the above deductive or fixpoint languages operates on concrete temporal databases, as discussed in Section 1.3.3. Datalog over constraint encodings has been studied in <ref> [KKR95; TCR94] </ref>. We conclude this discussion by showing a real-life query expressible in the temporal logic programming languages and temporal fixpoint query languages mentioned above but not in any variant of temporal logic, including those with monadic second-order definable connectives.
Reference: [Koy89] <author> R. Koymans. </author> <title> Specifying Message Passing and Time-Critical Systems with Temporal Logic. </title> <type> PhD thesis, </type> <institution> Technische Universiteit Eindhoven, </institution> <year> 1989. </year>
Reference-contexts: ] is defined as: 2 [k 1 ;k 2 ] X 1 = 9t 1 :t 0 + k 1 t 1 t 0 + k 2 ^ X 1 : Propositional temporal logic with real-time temporal connectives has been extensively used for the specification and verification of real-time systems <ref> [AH92; Koy89] </ref>. The first-order version of this logic has been applied to the specification of real-time integrity constraints [Cho95], and real-time logic programs [Brz93; Brz95]. Similarly to the 4 and 5 connectives the real time connectives (with integral bounds) are first-order definable in the theory of discrete linear order.
Reference: [KSW95] <author> F. Kabanza, J-M. Stevenne, and P. Wolper. </author> <title> Handling Infinite Temporal Data. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 51(1):317, </volume> <month> August </month> <year> 1995. </year>
Reference-contexts: The set C oe can serve as the basis of the temporal domain for a class of concrete temporal databases, similarly to intervals in Definition 21. An example of an alternative encoding is the use of periodic constraints <ref> [KSW95] </ref>, or linear arithmetic constraints [KKR95].
Reference: [Kun85] <author> C. H. Kung. </author> <title> On Verification of Database Temporal Constraints. </title> <booktitle> In ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 169 179, </pages> <address> Austin, Texas, </address> <year> 1985. </year>
Reference-contexts: The work on automatically generating triggers from constraint specifications [CW90] and declarative specification 24 LOGICS FOR DATABASES AND INFORMATION SYSTEMS of constraint maintenance [BCP94] can perhaps be generalized to temporal integrity constraints and triggers. Transaction Validation <ref> [dCCF82; Kun85; Lip90] </ref>. Here the assumption is that the database will only be updated by a fixed set of transactions. The transactions are analyzed in advance. De Castilho et al. [dCCF82] proposed to check whether the transactions are always guaranteed to preserve the integrity constraints using theorem proving techniques. <p> Here the assumption is that the database will only be updated by a fixed set of transactions. The transactions are analyzed in advance. De Castilho et al. [dCCF82] proposed to check whether the transactions are always guaranteed to preserve the integrity constraints using theorem proving techniques. Kung <ref> [Kun85] </ref> presented a model-checking [Eme90] approach to testing the consistency of transaction specifications with integrity constraints. Completeness, decidability, and computational complexity issues were not addressed in either work. It would be interesting to see whether recent advances in model checking and theorem proving techniques can be applied in this area.
Reference: [Lip90] <author> U. Lipeck. </author> <title> Transformation of Dynamic Integrity Constraints into Transaction Specifications. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 76(1):115142, </address> <year> 1990. </year>
Reference-contexts: The work on automatically generating triggers from constraint specifications [CW90] and declarative specification 24 LOGICS FOR DATABASES AND INFORMATION SYSTEMS of constraint maintenance [BCP94] can perhaps be generalized to temporal integrity constraints and triggers. Transaction Validation <ref> [dCCF82; Kun85; Lip90] </ref>. Here the assumption is that the database will only be updated by a fixed set of transactions. The transactions are analyzed in advance. De Castilho et al. [dCCF82] proposed to check whether the transactions are always guaranteed to preserve the integrity constraints using theorem proving techniques. <p> Completeness, decidability, and computational complexity issues were not addressed in either work. It would be interesting to see whether recent advances in model checking and theorem proving techniques can be applied in this area. In a related work, Lipeck <ref> [Lip90] </ref> showed how to refine transaction specifications, so that temporal integrity constraints are never violated. Safety vs. Liveness. Does every temporal logic formula make sense as a temporal integrity constraint? Here the distinction between safety and liveness formulas [AS85; Pnu86] is very helpful.
Reference: [Lor93] <author> N. A. Lorentzos. </author> <title> The Interval-Extended Relational Model and Its Application to Valid-time Databases. </title> <editor> In Tansel et al. </editor> <volume> [TCG + 93], </volume> <pages> pages 6791. </pages>
Reference-contexts: This result is fatal to the coalescing-based approaches as there is no unique coalescing for temporal dimension higher than one. Folding and Unfolding. The second approach is based on two additional operations: fold and unfold <ref> [Lor93] </ref>. These two operations allow us to explicitly convert a concrete temporal relation with interval-based timestamps to a temporal relation with point-based timestamps. The query from Example 31 can be correctly formulated using fold/unfold, as it now becomes possible to refer to unfolded temporal relations (with duplicates).
Reference: [LS87] <author> U. W. Lipeck and G. Saake. </author> <title> Monitoring Dynamic Integrity Constraints Based on Temporal Logic. </title> <journal> Information Systems, </journal> <volume> 12(3):255269, </volume> <year> 1987. </year>
Reference-contexts: Such a history is of course finite. However, the satisfaction of a temporal integrity constraint is defined with respect to an infinite history representing a possible future evolution of the database. The notion of potential constraint satisfaction (called also potential validity <ref> [LS87] </ref>) reconciles those two views. <p> In both cases infinity provides a convenient mathematical abstraction. 1.4.2 Temporal Integrity Maintenance We discuss now three different scenarios for temporal integrity maintenance: constraint checking, temporal triggers, and transaction validation. In this context, we also review the well-known distinction between safety and liveness properties [Pnu86]. Constraint Checking <ref> [Cho95; CT95; GL96; HS91; LS87] </ref>. The assumption here is that updates are arbitrary mappings producing finite states. An update is committed if in the resulting history all the constraints are potentially satisfied and aborted otherwise. Temporal Triggers [SW95]. Again, the basic assumption is that updates are arbitrary. <p> Lipeck and Saake <ref> [LS87] </ref> proposed the class of biquan-tified formulas (without using this specific term). Biquantified formulas allow only future temporal operators and restricted quantification in the following sense: the quantifiers can be either external (not in the scope of any temporal connective) or internal (no temporal connective in their scope).
Reference: [MP92] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Databases are inherently first-order structures and thus in this chapter we are primarily interested in first-order temporal logic. This is in sharp contrast with another major application area of temporal logic, program verification, where the formalisms studied are usually propositional <ref> [MP92; Pnu86] </ref>. We introduce here a number of fundamental concepts and distinctions that are used throughout the chapter. First, there is a choice of temporal ontology, which can be based either on time points (instants) or intervals (periods). <p> Consequently, safety formulas are particularly suitable to the constraint checking scenario. On the other hand, liveness formulas are always potentially satisfiable. (A detailed discussion of safety vs. liveness in the database context can be found in [CN95], and in the context of proving properties of concurrent programs in <ref> [MP92] </ref>.) Similar considerations apply to temporal triggers, although because of the duality negations of safety formulas are of interest there. <p> In the first two scenarios, future states can be arbitrary, while in the third they are partially determined by the given transactions. It may be interesting to investigate whether the methodology of proving safety and liveness properties developed by Manna and Pnueli <ref> [MP92] </ref> can be applied in the transaction validation scenario. 1.4.3 Temporal Constraint Checking We summarize here the results about restricted classes of temporal integrity constraints expressed in temporal logic. Lipeck and Saake [LS87] proposed the class of biquan-tified formulas (without using this specific term).
Reference: [Pnu86] <author> A. Pnueli. </author> <title> Applications of Temporal Logic to the Specification and Verification of Reactive Systems: a Survey of Current Trends. </title> <booktitle> In Current Trends in Concurrency, </booktitle> <pages> pages 510584. </pages> <publisher> Springer-Verlag, LNCS 224, </publisher> <year> 1986. </year>
Reference-contexts: Databases are inherently first-order structures and thus in this chapter we are primarily interested in first-order temporal logic. This is in sharp contrast with another major application area of temporal logic, program verification, where the formalisms studied are usually propositional <ref> [MP92; Pnu86] </ref>. We introduce here a number of fundamental concepts and distinctions that are used throughout the chapter. First, there is a choice of temporal ontology, which can be based either on time points (instants) or intervals (periods). <p> In both cases infinity provides a convenient mathematical abstraction. 1.4.2 Temporal Integrity Maintenance We discuss now three different scenarios for temporal integrity maintenance: constraint checking, temporal triggers, and transaction validation. In this context, we also review the well-known distinction between safety and liveness properties <ref> [Pnu86] </ref>. Constraint Checking [Cho95; CT95; GL96; HS91; LS87]. The assumption here is that updates are arbitrary mappings producing finite states. An update is committed if in the resulting history all the constraints are potentially satisfied and aborted otherwise. Temporal Triggers [SW95]. Again, the basic assumption is that updates are arbitrary. <p> In a related work, Lipeck [Lip90] showed how to refine transaction specifications, so that temporal integrity constraints are never violated. Safety vs. Liveness. Does every temporal logic formula make sense as a temporal integrity constraint? Here the distinction between safety and liveness formulas <ref> [AS85; Pnu86] </ref> is very helpful. Intuitively, safety formulas say that nothing bad ever happens and liveness formulas that something good will happen. An example of a safety formula is 0 9x:p (x), of a liveness formula 2 9x:p (x).
Reference: [SA86] <author> R. T. Snodgrass and I. Ahn. </author> <title> Temporal Databases. </title> <journal> IEEE Computer, </journal> <volume> 19(9), </volume> <year> 1986. </year>
Reference-contexts: However, in section 1.5 we briefly discuss interval-based temporal logic. (Intervals are predominant in AI applications.) Second, time can be single-dimensional or multidimensional. Multiple time dimensions can occur if, for example, multiple kinds of time (e.g., transaction time and valid time <ref> [SA86] </ref>) are required in an application. In addition we show that multiple temporal dimensions are necessary to evaluate general first-order temporal queries. Except for section 1.5, we adopt the single-dimensional view.
Reference: [SAA + 94] <author> R. T. Snodgrass, I. Ahn, G. Ariav, D. Batory, J. Clifford, C. E. Dyreson, R. Elmasri, F. Grandi, C. S. Jensen, W. Kafer, N. Kline, K. Kulkarni, T. Y. C. Leung, N. Lorentzos, J. F. Roddick, A. Segev, M. D. Soo, and S. A. Sripada. </author> <title> TSQL2 language specification. </title> <booktitle> SIGMOD Record, </booktitle> <address> 23(1):6586, </address> <month> March </month> <year> 1994. </year>
Reference-contexts: For a detailed discussion of coalescing in temporal databases see [BSS96]. The most prominent representatives of this approach are TQuel [Sno87; Sno93], and TSQL2 <ref> [Sno95; SAA + 94] </ref>. However: Coalescing does not solve the problem with the above query: if a person works for three different companies she is still in the answer to the query. The query is correct if the Works relation is coalesced after projecting out the attribute Company.
Reference: [SBJS96] <author> R. T. Snodgrass, M. H. B ohlen, C. S. Jensen, and A. </author> <title> Steiner. Adding Valid Time to SQL/Temporal. ISO/IEC JTC1/SC21/WG3 DBL MAD-146r2 21/11/96, (change proposal), International Organization for Standardization, 1996. </title> <type> REFERENCES 37 </type>
Reference-contexts: It is also possible to base such an extension on L but this possibility has been little explored. Languages based on L I . This group contains the majority of current proposals, in particular the SQL/Temporal proposal to the ANSI/ISO SQL standardization group <ref> [SBJS96] </ref> and ATSQL [SJB95], the applied version of TSQL2 [Sno93] . Both these languages are directly based on L I with Allen's algebra operators dressed in SQL syntax and using bag (duplicate) semantics. <p> The solution which most people come up with is the query below (we use an intuitive and simplified syntax to make our point; for full details on the syntax of SQL/Temporal see <ref> [SJB95; SBJS96] </ref>). Example 32 The query from Example 31 in SQL/Temporal: select r1.Name from Works r1, Works r2 where r1.Name = r2.Name and r1.Year before r2.Year Note that the Year attributes range over intervals and the before relationship denotes the before relationship between two intervals. <p> Similarly we can show many innocent-looking queries to be non-generic (in sense of Definition 26) and therefore necessarily incorrect with respect to their intended meaning. On the other hand the access to the interval endpoints (the nonsequenced semantics <ref> [SBJS96] </ref>) is essential to write non-trivial temporal queries in SQL/Temporal. There are two principal approaches that try to avoid the incorrect and unexpected behavior by modifying the semantics of the above languages. Coalescing.
Reference: [SJB95] <author> R. T. Snodgrass, C. S. Jensen, and M. H. B ohlen. </author> <title> Evaluating and Enhancing the Completeness of TSQL2. </title> <type> Technical Report TR 95-5, </type> <institution> Computer Science Department, University of Arizona, </institution> <year> 1995. </year>
Reference-contexts: It is also possible to base such an extension on L but this possibility has been little explored. Languages based on L I . This group contains the majority of current proposals, in particular the SQL/Temporal proposal to the ANSI/ISO SQL standardization group [SBJS96] and ATSQL <ref> [SJB95] </ref>, the applied version of TSQL2 [Sno93] . Both these languages are directly based on L I with Allen's algebra operators dressed in SQL syntax and using bag (duplicate) semantics. Let us try to formulate the query from Example 31 in such a language, e.g., TSQL2 or its successor, SQL/Temporal. <p> The solution which most people come up with is the query below (we use an intuitive and simplified syntax to make our point; for full details on the syntax of SQL/Temporal see <ref> [SJB95; SBJS96] </ref>). Example 32 The query from Example 31 in SQL/Temporal: select r1.Name from Works r1, Works r2 where r1.Name = r2.Name and r1.Year before r2.Year Note that the Year attributes range over intervals and the before relationship denotes the before relationship between two intervals.
Reference: [Sno87] <author> R. Snodgrass. </author> <title> The Temporal Query Language TQuel. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 12(2):247298, </volume> <month> June </month> <year> 1987. </year>
Reference-contexts: This discrepancy leads to a tension between the syntactic constructs used in the language and the intended semantics of queries. While we focus mostly on temporal extensions of SQL, our observations are general enough to apply to temporal extensions of other query languages, e.g., TQuel <ref> [Sno87] </ref>. Example 31 We demonstrate the differences between the approaches using the following query: List all persons who have been unemployed between jobs. <p> For a detailed discussion of coalescing in temporal databases see [BSS96]. The most prominent representatives of this approach are TQuel <ref> [Sno87; Sno93] </ref>, and TSQL2 [Sno95; SAA + 94]. However: Coalescing does not solve the problem with the above query: if a person works for three different companies she is still in the answer to the query.
Reference: [Sno93] <author> R. T. Snodgrass. </author> <title> An overview of TQuel. </title> <editor> In Tansel et al. </editor> <volume> [TCG + 93], </volume> <pages> pages 141182. </pages>
Reference-contexts: Languages based on L I . This group contains the majority of current proposals, in particular the SQL/Temporal proposal to the ANSI/ISO SQL standardization group [SBJS96] and ATSQL [SJB95], the applied version of TSQL2 <ref> [Sno93] </ref> . Both these languages are directly based on L I with Allen's algebra operators dressed in SQL syntax and using bag (duplicate) semantics. Let us try to formulate the query from Example 31 in such a language, e.g., TSQL2 or its successor, SQL/Temporal. <p> For a detailed discussion of coalescing in temporal databases see [BSS96]. The most prominent representatives of this approach are TQuel <ref> [Sno87; Sno93] </ref>, and TSQL2 [Sno95; SAA + 94]. However: Coalescing does not solve the problem with the above query: if a person works for three different companies she is still in the answer to the query.
Reference: [Sno95] <author> R. T. Snodgrass, </author> <title> editor. The TSQL2 Temporal Query Language. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1995. </year>
Reference-contexts: For a detailed discussion of coalescing in temporal databases see [BSS96]. The most prominent representatives of this approach are TQuel [Sno87; Sno93], and TSQL2 <ref> [Sno95; SAA + 94] </ref>. However: Coalescing does not solve the problem with the above query: if a person works for three different companies she is still in the answer to the query. The query is correct if the Works relation is coalesced after projecting out the attribute Company.
Reference: [Sta79] <author> J. Stavi. </author> <title> Functional Completeness over Rationals. </title> <type> Unpublished manuscript, </type> <institution> Bar-Ilan University, Israel, </institution> <year> 1979. </year>
Reference-contexts: The latter result was established by Kamp for complete linear orders, extended by Stavi for all linear orders, and later reproved several times using various proof techniques <ref> [Kam68; Sta79; GHR94; IK89] </ref>. On the other hand Kamp also proved the following separation result in a first-order setting L fsince;untilg @ L fsince;until;nowg v L P for dense linearly ordered time (@ denotes the strictly weaker than relationship of languages).
Reference: [SW95] <author> A. P. Sistla and O. Wolfson. </author> <title> Temporal Triggers in Active Databases. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 7(3):471486, </volume> <year> 1995. </year>
Reference-contexts: Constraint Checking [Cho95; CT95; GL96; HS91; LS87]. The assumption here is that updates are arbitrary mappings producing finite states. An update is committed if in the resulting history all the constraints are potentially satisfied and aborted otherwise. Temporal Triggers <ref> [SW95] </ref>. Again, the basic assumption is that updates are arbitrary. Definition 38 (Trigger Firing) Let (H 0 ; H 1 ; : : : ; H t ) be a finite history and T a Condition-Action trigger of the form if C then A [WC96].
Reference: [TC90] <author> A. Tuzhilin and J. Clifford. </author> <title> A Temporal Relational Algebra as a Basis for Temporal Relational Completeness. </title> <editor> In Dennis McLeod, Ron Sacks-Davis, and Hans-Joerg Schek, editors, </editor> <booktitle> International Conference on Very Large Data Bases, </booktitle> <pages> pages 1323, </pages> <year> 1990. </year>
Reference-contexts: This definition can be used to define an algebra over concrete relations that preserves the k:k mapping and is thus suitable for implementing L . This algebra can serve as the concrete counterpart of the temporal relational algebra introduced in Example 20 <ref> [TC90] </ref>. Constraint Encoding. A careful analysis of Definition 21 reveals that the intervals are essentially quantifier-free formulas in T h (&lt; Lin ) with exactly one free variable.
Reference: [TCG + 93] <author> A. Tansel, J. Clifford, S. Gadia, S. Jajodia, A. Segev, and R. T. Snodgrass, </author> <title> editors. Temporal Databases: Theory, Design, and Implementation. </title> <address> Ben-jamin/Cummings, </address> <year> 1993. </year>
Reference: [TCR94] <author> D. Toman, J. Chomicki, and D. S. Rogers. </author> <title> Datalog with Integer Periodicity Constraints. </title> <editor> In Maurice Bruynooghe, editor, </editor> <booktitle> International Logic Programming Symposium, </booktitle> <pages> pages 189203. </pages> <publisher> MIT Press, </publisher> <year> 1994. </year> <note> Full version to appear in Journal of Logic Programming. </note>
Reference-contexts: Datalog 1S with stratified negation strictly subsumes ETL but its relationship to T-FIXPOINT is unclear. None of the above deductive or fixpoint languages operates on concrete temporal databases, as discussed in Section 1.3.3. Datalog over constraint encodings has been studied in <ref> [KKR95; TCR94] </ref>. We conclude this discussion by showing a real-life query expressible in the temporal logic programming languages and temporal fixpoint query languages mentioned above but not in any variant of temporal logic, including those with monadic second-order definable connectives.
Reference: [TN96] <author> D. Toman and D. Niwinski. </author> <title> First-Order Queries over Temporal Databases Inexpressible in Temporal Logic. </title> <booktitle> In International Conference on Extending Database Technology, </booktitle> <pages> pages 307324, </pages> <address> Avignon, France, 1996. </address> <publisher> Springer-Verlag, LNCS 1057. </publisher>
Reference: [Tom96] <author> D. Toman. </author> <title> Point vs. Interval-based Query Languages for Temporal Databases. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 5867, </pages> <address> Montr eal, Canada, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: TEMPORAL LOGIC IN INFORMATION SYSTEMS 21 Languages based on L P . While query languages based on L P were often considered to be inherently inefficient, recent results (especially Theorem 27 <ref> [Tom96] </ref>) allow us to define a point-based extension of SQL that can be efficiently evaluated over concrete interval-based temporal databases.
Reference: [Tom97] <author> D. Toman. </author> <title> Point-based Temporal Extensions of SQL. </title> <booktitle> In International Conference on Deductive and Object-Oriented Databases, </booktitle> <year> 1997. </year>
Reference-contexts: The proposed language, SQL/TP, is a clean temporal extension of SQL <ref> [Tom97] </ref>: The syntax and semantics of SQL/TP are defined as a natural extension of SQL with an additional data type based on the point-based temporal domain T P . <p> Therefore it can be efficiently evaluated over concrete temporal databases based on interval encoding of timestamps (like any other SQL query). The SQL/TP proposal also includes a definition of meaningful duplicate semantics and aggregation operations that are compatible with standard SQL <ref> [Tom97] </ref>. <p> There are several ways of dealing with this issue: We can choose a multi-dimensional temporal logic where all the introduced connectives preserve closure over the chosen encoding. We can introduce closure restriction for formulas in L P <ref> [CGK96; Tom97] </ref>. Such a restriction is designed to guarantee attribute independence of the free variables in the query and subsequently closure over an encoding obtained by taking an appropriate number of cartesian (self-)products of the single-dimensional encoding.
Reference: [Ull89] <author> J. D. Ullman. </author> <booktitle> Principles of Database and Knowledge-Base Systems, </booktitle> <volume> volume 2. </volume> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: This fact causes major problems when implementing query processors for temporal query languages as the common (and efficient) implementations inherently depend on the equivalence of relational algebra and calculus to be able to execute all queries <ref> [AHV95; Ull89] </ref>. 1.3.3 Space-efficient Encoding of Temporal Databases While abstract temporal databases provide a natural semantic domain for interpreting temporal queries, they are not immediately suitable for the implementation, as they are possibly infinite (e.g., when the database contains a fact holding for infinitely many time instants).
Reference: [Var88] <author> M. Y. Vardi. </author> <title> A Temporal Fixpoint Calculus. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 250259, </pages> <year> 1988. </year>
Reference-contexts: On the other hand, T-FIXPOINT is more expressive than L P . These languages appear to be mainly of theoretical interest. Fix-point temporal logic T L <ref> [Var88] </ref> has been extensively used in program verification, although only in the propositional case. The first-order version of T L remains to be studied. In particular, its relationship to T-FIXPOINT and TS-FIXPOINT needs to be elucidated. Temporal Logic Programming.
Reference: [vB83] <author> J. F. A. K. van Benthem. </author> <title> The Logic of Time. </title> <address> D. </address> <publisher> Reidel, </publisher> <year> 1983. </year>
Reference-contexts: This definition can be used to define most of the common multi-dimensional temporal logics, e.g., the temporal logic with the now operator [Kam71], the Vlach and Aqvist system [ Aqv79], and most of the interval logics <ref> [All84; vB83] </ref>. TEMPORAL LOGIC IN INFORMATION SYSTEMS 29 Again, Definition 46 allows only logics with first-order definable temporal connec-tives. It also clarifies the difference between two distinct uses of intervals in temporal databases: 1. intervals as encodings of convex 1-dimensional sets, or 2. intervals as a representation of 2-dimensional points. <p> Thus applying set-based operations on these intervals does not have a clear and intuitive meaning. Note that in Section 1.3 we used solely the first paradigm. The second paradigm often corresponds to languages L (2) <ref> [All84; vB83] </ref>. To compare the expressive power of temporal logics with respect to the dimension of the temporal connectives we use the following observation.
Reference: [WC96] <author> J. Widom and S. Ceri, </author> <title> editors. Active Database Systems. </title> <publisher> Morgan Kauf-mann, </publisher> <year> 1996. </year> <note> 38 LOGICS FOR DATABASES AND INFORMATION SYSTEMS </note>
Reference-contexts: Temporal Triggers [SW95]. Again, the basic assumption is that updates are arbitrary. Definition 38 (Trigger Firing) Let (H 0 ; H 1 ; : : : ; H t ) be a finite history and T a Condition-Action trigger of the form if C then A <ref> [WC96] </ref>. Then T fires at instant t for a (ground) substitution to the free variables of C if :C (the result of applying the substitution to :C) is not potentially satisfied at t. The action executed is A.
Reference: [Wol83] <author> P. Wolper. </author> <title> Temporal Logic Can Be More Expressive. </title> <journal> Information and Control, </journal> <volume> 56:7299, </volume> <year> 1983. </year>
Reference-contexts: (S) ^8S 0 :(t 0 2 S 0 ^ closed (S 0 ) ) S S 0 ) where closed (S) 4 For the temporal domain (N; &lt;), the above extension is identical in expressive power to ETL, temporal logic with temporal connectives defined using regular expressions, studied by Wolper <ref> [Wol83] </ref> (the propositional case) and Abiteboul et al. [AHVdB96] (the first-order case). The latter paper also shows that the expressive power of ETL is incomparable to that of L P . For other temporal domains, the expressive power of temporal logic with monadic second-order connectives has not yet been studied.

References-found: 68

