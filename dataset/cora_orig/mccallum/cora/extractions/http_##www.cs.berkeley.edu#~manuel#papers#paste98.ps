URL: http://www.cs.berkeley.edu/~manuel/papers/paste98.ps
Refering-URL: http://www.cs.berkeley.edu/~aiken/cs263/projects.html
Root-URL: 
Title: Tracking down Exceptions in Standard ML Programs  
Author: Manuel Fahndrich Jeffrey S. Foster Alexander Aiken Jason Cu 
Address: Berkeley, California 94720  
Affiliation: Computer Science Division (EECS) University of California  
Date: February 1998  
Pubnum: Report No. UCB/CSD-98-996  
Abstract-found: 0
Intro-found: 1
Reference: [App92] <author> A. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year> <month> 6 </month>
Reference-contexts: This paper describes our experience applying the exception analysis tool eat to three Standard ML [MTH90] programs distributed with the SML/NJ <ref> [App92] </ref> compiler. With the help of pam, we classify the exceptions used in ml-lex, ml-yacc, and ml-burg into four categories and study the precision of the exception analysis with respect to the uncaught exceptions reported for the main function of each program.
Reference: [AW93] <author> A. Aiken and E. Wimmers. </author> <title> Type Inclusion Constraints and Type Inference. </title> <booktitle> In Proceedings of the 1993 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 31-41, </pages> <address> Copenhagen, Den-mark, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: It would however be trivial to add it to the pervasive signatures. 2.2 Implementation We have implemented our exception inference on top of the Berkeley ANalysis Engine. 1 bane is a framework for writing program analyses based on a mixture of constraints [FA97], including set-constraints <ref> [AW93] </ref>. bane separates the specification (constraint generation) of an analysis from its implementation (constraint solving). Our exception inference traverses the source code of the input program, generating type constraints and constraints that capture the local flow of exceptions. bane handles the representation and resolution of constraints.
Reference: [CC79] <author> P. Cousot and R. Cousot. </author> <title> Systematic Design of Program Analysis Frameworks. </title> <booktitle> In Sixth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 269-282, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: Without a good visualization tool, results of program analyses are very difficult to interpret and validate. 5 Related Work There are several other exception inference systems for ML. Yi [Yi94] uses an abstract interpretation <ref> [CC79] </ref> framework to perform a much more precise analysis than ours. Unfortunately, it scales poorly, requiring many hours of analysis time on ml-yacc, and the analysis results are very difficult to inspect. The systems described in [GS94, YR97] are simpler analyses than our own, and are in general less precise.
Reference: [FA97] <author> M. Fahndrich and A. Aiken. </author> <title> Program Analysis Using Mixed Term and Set Constraints. </title> <booktitle> In Proceedings of the 4th International Static Analysis Symposium, </booktitle> <year> 1997. </year>
Reference-contexts: 1 Introduction The ML type system guarantees that ML programs never terminate abnormally. Normal termination, however, may be caused by an exception, which is often undesirable. ML compilers infer a type for each expression in a program, but compute no information about exceptions produced or raised by an expression. In <ref> [FA97] </ref> we proposed an exception inference system to fill this gap. It subsumes the type inference by inferring ML types annotated with exceptions. <p> Related work appears in Section 5, and Section 6 concludes. 2 Exception Inference This section informally describes the exception inference used in our study and discusses some issues in working with real programs. A more formal treatment for a subset of SML can be found in <ref> [FA97] </ref>. The analysis is structured as a type and effect system [LG88]. For every expression e in the program, the analysis infers a type t and an effect . <p> It would however be trivial to add it to the pervasive signatures. 2.2 Implementation We have implemented our exception inference on top of the Berkeley ANalysis Engine. 1 bane is a framework for writing program analyses based on a mixture of constraints <ref> [FA97] </ref>, including set-constraints [AW93]. bane separates the specification (constraint generation) of an analysis from its implementation (constraint solving). Our exception inference traverses the source code of the input program, generating type constraints and constraints that capture the local flow of exceptions. bane handles the representation and resolution of constraints. <p> The systems described in [GS94, YR97] are simpler analyses than our own, and are in general less precise. To study the precision trade-off, we have also implemented a variation of <ref> [FA97] </ref> similar to [GS94]. On the three programs studied in this paper, the two versions produced identical results. However, for programs using more higher order features, the loss of precision in the second approach can be significant.
Reference: [FFA97] <author> J. Foster, M. Fahndrich, and A. Aiken. </author> <title> Flow-Insensitive Points-to Analysis with Term and Set Constraints. </title> <type> Technical Report UCB//CSD-97-964, </type> <institution> University of Cali-fornia, Berkeley, </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: Applying the analysis to three programs distributed with the SML/NJ compiler, we have discovered two minor exception related bugs. We are also currently applying eat to a very large program, a points-to analysis for C written in bane <ref> [FFA97] </ref>. Two problems arose in this context. First, although the inference does scale, the description file of the analysis results uses more than 100MB of disk space. As a result, the visualization becomes impractical. Factoring repeated information in the description file might help curb this blowup.
Reference: [FFK + 96] <author> C. Flanagan, M. Flatt, S. Krishnamurthi, S. Weirich, and M. Felleisen. </author> <title> Catching Bugs in the Web of Program Invariants. </title> <booktitle> In Proceedings of the 1996 ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 23-32, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: That approach however has the same shortcomings as the one described here with respect to assertion failures and certain pervasive exceptions. As a result, such exceptions are called unchecked in Java and need not be listed in method signatures. pam is in part inspired by MrSpidey <ref> [FFK + 96] </ref>, a static debugger for Scheme. MrSpidey performs set-based analysis on Scheme programs and presents the information to the programmer as graphical overlays over the source code. 6 Conclusions and Future Work We have evaluated the precision and utility of an exception inference for Standard ML.
Reference: [FP91] <author> T. Freeman and F. Pfenning. </author> <title> Refinement Types for ML. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 268-277. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: Several techniques can be used to improve the analysis in this area. [Yi94] models variants of datatypes and integers such that impossible branches can be pruned. Similarly, set-based analysis [Hei94] can also provide information to prune branches. Refinement types <ref> [FP91] </ref> are another approach to proving that certain branches of case statements are not needed. If datatypes are viewed as defining regular tree languages, then refinement types specify sub-languages of datatypes.
Reference: [GJS96] <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison Wes-ley Longman, Inc., </publisher> <year> 1996. </year>
Reference-contexts: Pervasive exceptions like Subscript are also modeled very conservatively by our analysis. In general, proving the absence of Subscript exceptions is equivalent to proving that no runtime check on array indexing is required. A long line of work on range-checking for array subscripts starts with [SI77]. Finally, in Java <ref> [GJS96] </ref>, methods must declare the set of exceptions that might be thrown during a call. This allows Java compilers to perform a similar (although non-polymorphic) exception verification. That approach however has the same shortcomings as the one described here with respect to assertion failures and certain pervasive exceptions.
Reference: [GS94] <author> J. C. Guzman and A. </author> <title> Suarez. An Extended Type System for Exceptions. </title> <booktitle> In Proceedings of the ACM SIGPLAN Workshop on ML and its Applications, </booktitle> <pages> pages 127-135, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Yi [Yi94] uses an abstract interpretation [CC79] framework to perform a much more precise analysis than ours. Unfortunately, it scales poorly, requiring many hours of analysis time on ml-yacc, and the analysis results are very difficult to inspect. The systems described in <ref> [GS94, YR97] </ref> are simpler analyses than our own, and are in general less precise. To study the precision trade-off, we have also implemented a variation of [FA97] similar to [GS94]. On the three programs studied in this paper, the two versions produced identical results. <p> The systems described in [GS94, YR97] are simpler analyses than our own, and are in general less precise. To study the precision trade-off, we have also implemented a variation of [FA97] similar to <ref> [GS94] </ref>. On the three programs studied in this paper, the two versions produced identical results. However, for programs using more higher order features, the loss of precision in the second approach can be significant. One problem with eat is that it isn't useful to prove the absence of assertion failures.
Reference: [Hei94] <author> N. Heintze. </author> <title> Set Based Analysis of ML Programs. </title> <booktitle> In Proceedings of the 1994 ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 306-17, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: To do so requires proving that certain raise expressions constitute dead code. Several techniques can be used to improve the analysis in this area. [Yi94] models variants of datatypes and integers such that impossible branches can be pruned. Similarly, set-based analysis <ref> [Hei94] </ref> can also provide information to prune branches. Refinement types [FP91] are another approach to proving that certain branches of case statements are not needed. If datatypes are viewed as defining regular tree languages, then refinement types specify sub-languages of datatypes.
Reference: [LG88] <author> J. Lucassen and D. Gifford. </author> <title> Polymorphic Effect Systems. </title> <booktitle> In Proceedings of the 15th Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 47-57, </pages> <year> 1988. </year>
Reference-contexts: A more formal treatment for a subset of SML can be found in [FA97]. The analysis is structured as a type and effect system <ref> [LG88] </ref>. For every expression e in the program, the analysis infers a type t and an effect . The type t corresponds closely to the SML type of e, except that exception types, datatypes, and function types carry extra type parameters for exception sets.
Reference: [MTH90] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: This paper describes our experience applying the exception analysis tool eat to three Standard ML <ref> [MTH90] </ref> programs distributed with the SML/NJ [App92] compiler. With the help of pam, we classify the exceptions used in ml-lex, ml-yacc, and ml-burg into four categories and study the precision of the exception analysis with respect to the uncaught exceptions reported for the main function of each program.
Reference: [SI77] <author> N. Suzuki and K. Ishihata. </author> <title> Implementation of an Array Bound Checker. </title> <booktitle> In Fourth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 132-143, </pages> <month> Jan-uary </month> <year> 1977. </year>
Reference-contexts: Constant propagation or simple set-based analysis could be used to remove a few of the spurious exceptions (marked by ). Similarly, our analysis is conservative with respect to pervasive exceptions. For example, showing that the Subscript exception is never raised requires range analysis <ref> [SI77] </ref>. On the other hand, eat is useful for detecting problems with control flow exceptions, and to infer the set of error exceptions. <p> Pervasive exceptions like Subscript are also modeled very conservatively by our analysis. In general, proving the absence of Subscript exceptions is equivalent to proving that no runtime check on array indexing is required. A long line of work on range-checking for array subscripts starts with <ref> [SI77] </ref>. Finally, in Java [GJS96], methods must declare the set of exceptions that might be thrown during a call. This allows Java compilers to perform a similar (although non-polymorphic) exception verification.
Reference: [Yi94] <author> K. Yi. </author> <title> Compile-Time Detection of Uncaught Exceptions for Standard ML Programs. </title> <booktitle> In Proceedings of the 1st International Static Analysis Symposium, volume 864 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer, </publisher> <year> 1994. </year>
Reference-contexts: Our visualization mode pam has been key in understanding the flow of exceptions discovered by our analysis. Without a good visualization tool, results of program analyses are very difficult to interpret and validate. 5 Related Work There are several other exception inference systems for ML. Yi <ref> [Yi94] </ref> uses an abstract interpretation [CC79] framework to perform a much more precise analysis than ours. Unfortunately, it scales poorly, requiring many hours of analysis time on ml-yacc, and the analysis results are very difficult to inspect. <p> One problem with eat is that it isn't useful to prove the absence of assertion failures. To do so requires proving that certain raise expressions constitute dead code. Several techniques can be used to improve the analysis in this area. <ref> [Yi94] </ref> models variants of datatypes and integers such that impossible branches can be pruned. Similarly, set-based analysis [Hei94] can also provide information to prune branches. Refinement types [FP91] are another approach to proving that certain branches of case statements are not needed.
Reference: [YR97] <author> K. Yi and S. Ryu. </author> <title> Towards a Cost-Effective Estimation of Uncaught Exceptions in SML Programs. </title> <booktitle> In Proceedings of the 4th International Static Analysis Symposium, </booktitle> <year> 1997. </year> <month> 7 </month>
Reference-contexts: Yi [Yi94] uses an abstract interpretation [CC79] framework to perform a much more precise analysis than ours. Unfortunately, it scales poorly, requiring many hours of analysis time on ml-yacc, and the analysis results are very difficult to inspect. The systems described in <ref> [GS94, YR97] </ref> are simpler analyses than our own, and are in general less precise. To study the precision trade-off, we have also implemented a variation of [FA97] similar to [GS94]. On the three programs studied in this paper, the two versions produced identical results.
References-found: 15

