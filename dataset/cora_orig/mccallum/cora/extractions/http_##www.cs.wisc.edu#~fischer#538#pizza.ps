URL: http://www.cs.wisc.edu/~fischer/538/pizza.ps
Refering-URL: http://www.cs.wisc.edu/~fischer/538/pizza.html
Root-URL: http://www.cs.wisc.edu
Title: Pizza into Java: Translating theory into practice  
Author: Martin Odersky Philip Wadler 
Affiliation: University of Karlsruhe  University of Glasgow  
Abstract: Pizza is a strict superset of Java that incorporates three ideas from the academic community: parametric polymor-phism, higher-order functions, and algebraic data types. Pizza is defined by translation into Java and compiles into the Java Virtual Machine, requirements which strongly constrain the design space. Nonetheless, Pizza fits smoothly to Java, with only a few rough edges. 
Abstract-found: 1
Intro-found: 1
Reference: [AW93] <author> Alexander Aiken and Edward L. Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Proc. Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 31-41. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: String extends a ) Cell&lt;a&gt; contains both Cell&lt;String&gt; and Cell&lt;Object&gt; as instances. It is possible to come up with type systems that allow these more general constraints <ref> [AW93, ESTZ95] </ref>, but there remain challenging problems in the areas of efficiency of type checking and user diagnostics. It seems that more research is needed until systems like these can be applied in mainstream languages. So, we eschew subsumption and require that type variables always match types exactly.
Reference: [AG96] <author> Ken Arnold and James Gosling. </author> <title> The Java Programming Language. Java Series, Sun Microsys-tems, </title> <note> 1996. ISBN 0-201-63455-4. </note>
Reference-contexts: Structure of this report. To read this paper, you will need a passing acquaintance with parametric polymorphism, higher-order functions, and algebraic types (see, e.g. [BW88, Pau91, CW85]); and a passing acquaintance with Java (see, e.g. <ref> [AG96, GJS96] </ref>). This paper is organised as follows. Section 2 introduces parametric polymorphism, Section 3 introduces higher-order functions, and Section 4 introduces algebraic data types. Each Pizza feature is accompanied by a description of its translation into Java. Section 5 explores further issues connected to the type system.
Reference: [BTCGS91] <author> Val Breazu-Tannen, Thierry Coquand, Carl A. Gunther, and Andre Scedrov. </author> <title> Inheritance as implicit coercion. </title> <journal> Information and Computation, </journal> <volume> 93 </volume> <pages> 172-221, </pages> <year> 1991. </year>
Reference-contexts: Type variables range over sub-types of one or more types, giving us bounded polymorphism <ref> [CCH + 89, BTCGS91] </ref>, and since the type variable may recursively appear in its own bound we have F-bounded poly-morphism [CCH + 89, BTCGS91]. The mixture of implicit instantiation with F-bounded polymorphism resembles type classes as used in Haskell, and may be implemented using similar techniques [WB89, Oho92, Jon93]. <p> Type variables range over sub-types of one or more types, giving us bounded polymorphism <ref> [CCH + 89, BTCGS91] </ref>, and since the type variable may recursively appear in its own bound we have F-bounded poly-morphism [CCH + 89, BTCGS91]. The mixture of implicit instantiation with F-bounded polymorphism resembles type classes as used in Haskell, and may be implemented using similar techniques [WB89, Oho92, Jon93].
Reference: [BCC + 96] <author> Kim Bruce, Luca Cardelli, Guiseppe Castagna, The Hopkins Objects Group, Gary T.Leavens, and Benjamin Pierce. </author> <title> On binary methods. </title> <journal> Theory and Practice of Object Systems, </journal> <volume> 1(3), </volume> <year> 1996. </year> <month> 13 </month>
Reference-contexts: Parameterised interfaces allow one to express precisely the type of operations where both arguments are of the same type, a notoriously hard problem for object-oriented languages <ref> [BCC + 96] </ref>. To demonstrate, we modify our previous example to find the minimum of a pair of elements, as shown in Example 2.4. The interface Ord is parameterised on the type elem, which here ranges over all types, and specifies a method less with an argument of type elem.
Reference: [BLM96] <author> J. A. Bank, B. Liskov, and A. C. Myers. </author> <title> Pa--rameterised types and Java. </title> <type> Technical Report MIT LCS TM-553, </type> <institution> Laboratory for Computer Science, Massachusetts Institute of Technology, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: In the presence of separate compilation, type checking in C++ must be delayed until link time, when all instance types are known. In contrast, Pizza types allow full type checking at compile time. Bank, Liskov, and Myers <ref> [BLM96] </ref> describe a polymorphic type system for Java, broadly similar to ours. The key difference is that we translate our language into the existing JVM, while they extend the JVM to support polymorphism. We believe these two approaches have complementary advantages, and are both worthy of pursuit. <p> For instance, instantiations of a polymorphic class at types int and float must have separate implementations in the heterogenous translation, even though the word-level operations are identical. These modest costs could be avoided only by altering the Java Virtual Machine (for instance, as suggested by <ref> [BLM96] </ref>), or by compiling Pizza directly to some other portable low-level code, such as Microsoft's Omnicode or Lucent's Dis. Visibility.
Reference: [Bru97] <author> Kim Bruce. </author> <title> Typing in object-oriented languages: Achieving expressibility and safety. </title> <journal> Computing Surveys, </journal> <note> to appear. </note>
Reference-contexts: All that is necessary is to complete each function type, by replacing any formal argument type A which is not a type variable by a new quantified type variable with bound A. A similar technique to model subtyping by matching has been advocated by Bruce <ref> [Bru97] </ref>. (Details of completion are described in the appendix.) Example 5.3 Existentially quantified type variables in pat terns. class List&lt;A&gt; f ... boolean equals (Object other) f if (other instanceof List) f switch Pair (this, (List)other) f case Pair (Nil, Nil): return true; case &lt;B&gt; Pair (Cons (A x, List&lt;A&gt; xs),
Reference: [BW88] <author> Richard S. Bird and Philip Wadler. </author> <title> Introduction to Functional Programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: We added this feature first, to the client's satisfaction, and are now at work adding the other features of Pizza. Structure of this report. To read this paper, you will need a passing acquaintance with parametric polymorphism, higher-order functions, and algebraic types (see, e.g. <ref> [BW88, Pau91, CW85] </ref>); and a passing acquaintance with Java (see, e.g. [AG96, GJS96]). This paper is organised as follows. Section 2 introduces parametric polymorphism, Section 3 introduces higher-order functions, and Section 4 introduces algebraic data types. Each Pizza feature is accompanied by a description of its translation into Java.
Reference: [CCH + 89] <author> Peter Canning, William Cook, Walter Hill, Wal-ter Olthoff, and John C. Mitchell. </author> <title> F-bounded polymorphism for object-oriented programming. </title> <booktitle> In Proc. Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 273-280, </pages> <month> Septem-ber </month> <year> 1989. </year>
Reference-contexts: We expect the best balance between performance and code size will typically be achieved by using the het-erogenous translation for base types and the homogenous translation for reference types. Related work. Pizza's type system is based on a mixture of Hindley-Milner type inference [DM82] and F-bounded polymorphism <ref> [CCH + 89] </ref>, closely related to type classes [WB89, Jon93]. There is also some use of existential types [CW85, MP88]. Superficially, Pizza types appear similar to the template mechanism of C++ [Str91]. Both allow parameterized types, both have polymorphic functions with implicit instantiation, and both have similar syntax. <p> Note that elem appears both as the bounded variable and in the bound: this form of recursive bound is well known to theorists of object-oriented type systems, and goes by the name of F-bounded polymorphism <ref> [CCH + 89] </ref>. The method min is defined using the method less, which is invoked for object x of type elem, and has argument y also of type elem. The class OrdInt is similar to the class Integer, except that it also implements the interface Ord&lt;OrdInt&gt;. <p> Type variables range over sub-types of one or more types, giving us bounded polymorphism <ref> [CCH + 89, BTCGS91] </ref>, and since the type variable may recursively appear in its own bound we have F-bounded poly-morphism [CCH + 89, BTCGS91]. The mixture of implicit instantiation with F-bounded polymorphism resembles type classes as used in Haskell, and may be implemented using similar techniques [WB89, Oho92, Jon93]. <p> Type variables range over sub-types of one or more types, giving us bounded polymorphism <ref> [CCH + 89, BTCGS91] </ref>, and since the type variable may recursively appear in its own bound we have F-bounded poly-morphism [CCH + 89, BTCGS91]. The mixture of implicit instantiation with F-bounded polymorphism resembles type classes as used in Haskell, and may be implemented using similar techniques [WB89, Oho92, Jon93].
Reference: [CW85] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, </title> <journal> and polymor-phism. Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> De-cember </month> <year> 1985. </year>
Reference-contexts: Related work. Pizza's type system is based on a mixture of Hindley-Milner type inference [DM82] and F-bounded polymorphism [CCH + 89], closely related to type classes [WB89, Jon93]. There is also some use of existential types <ref> [CW85, MP88] </ref>. Superficially, Pizza types appear similar to the template mechanism of C++ [Str91]. Both allow parameterized types, both have polymorphic functions with implicit instantiation, and both have similar syntax. However, the similarity does not run deep. <p> We added this feature first, to the client's satisfaction, and are now at work adding the other features of Pizza. Structure of this report. To read this paper, you will need a passing acquaintance with parametric polymorphism, higher-order functions, and algebraic types (see, e.g. <ref> [BW88, Pau91, CW85] </ref>); and a passing acquaintance with Java (see, e.g. [AG96, GJS96]). This paper is organised as follows. Section 2 introduces parametric polymorphism, Section 3 introduces higher-order functions, and Section 4 introduces algebraic data types. Each Pizza feature is accompanied by a description of its translation into Java. <p> What type should be assigned to a term after a cast? In the example above, (List)obj has the existential type 9a:List&lt;a&gt;: Existential types were originally introduced to model abstract types <ref> [CW85, MP88] </ref>, but there is also precedence to their modeling dynamic types [LM91]. can be used to define an equals method for lists. (In Java, all classes inherit an equals method from class Object, which they may override.) The method is passed an argument other of type Object, and a run-time
Reference: [DM82] <author> Luis Damas and Robin Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Proc. 9th ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1982. </year>
Reference-contexts: We expect the best balance between performance and code size will typically be achieved by using the het-erogenous translation for base types and the homogenous translation for reference types. Related work. Pizza's type system is based on a mixture of Hindley-Milner type inference <ref> [DM82] </ref> and F-bounded polymorphism [CCH + 89], closely related to type classes [WB89, Jon93]. There is also some use of existential types [CW85, MP88]. Superficially, Pizza types appear similar to the template mechanism of C++ [Str91]. <p> program the same functionality directly in Java. 5 Typing issues Pizza uses a mixture of explicit and implicit polymorphism, in that types of variables and methods are given explicitly where they are declared, but instantiated implicitly where they are used, in a way that corresponds to the Hindley-Milner type system <ref> [DM82] </ref>. Type variables range over sub-types of one or more types, giving us bounded polymorphism [CCH + 89, BTCGS91], and since the type variable may recursively appear in its own bound we have F-bounded poly-morphism [CCH + 89, BTCGS91].
Reference: [ESTZ95] <author> Jonathan Eifrig, Scott Smith, Valery Trifonov, Amy Zwarico. </author> <title> An interpretation of typed OOP in a language with state. </title> <booktitle> Lisp and Symbolic Computation 8(4) </booktitle> <pages> 357-397, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: String extends a ) Cell&lt;a&gt; contains both Cell&lt;String&gt; and Cell&lt;Object&gt; as instances. It is possible to come up with type systems that allow these more general constraints <ref> [AW93, ESTZ95] </ref>, but there remain challenging problems in the areas of efficiency of type checking and user diagnostics. It seems that more research is needed until systems like these can be applied in mainstream languages. So, we eschew subsumption and require that type variables always match types exactly.
Reference: [GJS96] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. Java Series, Sun Microsystems, </title> <note> 1996. ISBN 0-201-63451-1. </note>
Reference-contexts: Structure of this report. To read this paper, you will need a passing acquaintance with parametric polymorphism, higher-order functions, and algebraic types (see, e.g. [BW88, Pau91, CW85]); and a passing acquaintance with Java (see, e.g. <ref> [AG96, GJS96] </ref>). This paper is organised as follows. Section 2 introduces parametric polymorphism, Section 3 introduces higher-order functions, and Section 4 introduces algebraic data types. Each Pizza feature is accompanied by a description of its translation into Java. Section 5 explores further issues connected to the type system.
Reference: [Jon93] <author> M. P. Jones. </author> <title> A system of constructor classes: overloading and implicit higher-order polymor-phism. </title> <booktitle> In Proc. Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 52-61. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: Related work. Pizza's type system is based on a mixture of Hindley-Milner type inference [DM82] and F-bounded polymorphism [CCH + 89], closely related to type classes <ref> [WB89, Jon93] </ref>. There is also some use of existential types [CW85, MP88]. Superficially, Pizza types appear similar to the template mechanism of C++ [Str91]. Both allow parameterized types, both have polymorphic functions with implicit instantiation, and both have similar syntax. However, the similarity does not run deep. <p> The mixture of implicit instantiation with F-bounded polymorphism resembles type classes as used in Haskell, and may be implemented using similar techniques <ref> [WB89, Oho92, Jon93] </ref>.
Reference: [Lau95] <author> K. Laufer. </author> <title> A framework for higher-order functions in C++. </title> <booktitle> In Proc. Conf. Object-Oriented Technologies (COOTS), </booktitle> <address> Monterey, CA, June 1995. </address> <publisher> USENIX. </publisher>
Reference-contexts: We believe these two approaches have complementary advantages, and are both worthy of pursuit. Ideas for translating higher-order functions into classes belong to the folklore of the object-oriented community. A codification similar to ours has been described by Laufer <ref> [Lau95] </ref>. A facility similar to higher-order functions is provided by the anonymous classes proposed for the next version of Java [Sun96a]. Our observations about visibility problems appear to be new. Status. We have a complete design for Pizza, including type rules, as sketched in this paper.
Reference: [LO94] <author> Konstantin Laufer and Martin Odersky. </author> <title> Polymorphic type inference and abstract data types. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 16(5): </volume> <pages> 1411-1430, </pages> <year> 1994. </year>
Reference-contexts: Note that the syntax exploits the logical identity between (9X:P ) ! Q and 8X:(P ! Q), so that angle brackets can always be read as universal quantification. Type checking existential types is straightforward <ref> [LO94] </ref>. The type checker treats existentially bound variables as fresh type constants, which cannot be instantiated to anything. (Details of existentials are described in the appendix.) 9 6 Rough edges There are surprisingly few places where we could not achieve a good fit of Pizza to Java.
Reference: [LM91] <author> Xavier Leroy and Michel Mauny. </author> <title> Dynamics in ML. </title> <booktitle> Proc. Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 406-426. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1991. </year> <note> Lecture Notes in Computer Science 523. </note>
Reference-contexts: What type should be assigned to a term after a cast? In the example above, (List)obj has the existential type 9a:List&lt;a&gt;: Existential types were originally introduced to model abstract types [CW85, MP88], but there is also precedence to their modeling dynamic types <ref> [LM91] </ref>. can be used to define an equals method for lists. (In Java, all classes inherit an equals method from class Object, which they may override.) The method is passed an argument other of type Object, and a run-time test determines whether this object belongs to class List.
Reference: [MP88] <author> J. Mitchell and G. Plotkin. </author> <title> Abstract types have existential types. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 10(3) </volume> <pages> 470-502, </pages> <year> 1988. </year>
Reference-contexts: Related work. Pizza's type system is based on a mixture of Hindley-Milner type inference [DM82] and F-bounded polymorphism [CCH + 89], closely related to type classes [WB89, Jon93]. There is also some use of existential types <ref> [CW85, MP88] </ref>. Superficially, Pizza types appear similar to the template mechanism of C++ [Str91]. Both allow parameterized types, both have polymorphic functions with implicit instantiation, and both have similar syntax. However, the similarity does not run deep. <p> What type should be assigned to a term after a cast? In the example above, (List)obj has the existential type 9a:List&lt;a&gt;: Existential types were originally introduced to model abstract types <ref> [CW85, MP88] </ref>, but there is also precedence to their modeling dynamic types [LM91]. can be used to define an equals method for lists. (In Java, all classes inherit an equals method from class Object, which they may override.) The method is passed an argument other of type Object, and a run-time
Reference: [Oho92] <author> Atsushi Ohori. </author> <title> A compilation method for ML-style polymorphic record calculi. </title> <booktitle> In Proc. 19th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 154-165, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: The mixture of implicit instantiation with F-bounded polymorphism resembles type classes as used in Haskell, and may be implemented using similar techniques <ref> [WB89, Oho92, Jon93] </ref>.
Reference: [OP95] <author> Martin Odersky and Michael Philippsen. </author> <title> Espres-soGrinder distribution. </title> <address> http://wwwipd.ira.uka.de/~espresso. </address>
Reference-contexts: Our observations about visibility problems appear to be new. Status. We have a complete design for Pizza, including type rules, as sketched in this paper. We consider the design preliminary, and subject to change as we gain experience. We have implemented EspressoGrinder, a compiler for Java written in Java <ref> [OP95] </ref>. Interestingly, it was a commercial client who approached us to add higher-order functions to EspressoGrinder. We added this feature first, to the client's satisfaction, and are now at work adding the other features of Pizza. Structure of this report.
Reference: [Pau91] <author> L. C. Paulson. </author> <title> ML for the Working Programmer. </title> <publisher> Cambridge University Press, </publisher> <year> 1991. </year> <note> ISBN 0-521-39022-2. </note>
Reference-contexts: We added this feature first, to the client's satisfaction, and are now at work adding the other features of Pizza. Structure of this report. To read this paper, you will need a passing acquaintance with parametric polymorphism, higher-order functions, and algebraic types (see, e.g. <ref> [BW88, Pau91, CW85] </ref>); and a passing acquaintance with Java (see, e.g. [AG96, GJS96]). This paper is organised as follows. Section 2 introduces parametric polymorphism, Section 3 introduces higher-order functions, and Section 4 introduces algebraic data types. Each Pizza feature is accompanied by a description of its translation into Java.
Reference: [SS76] <author> Guy Steele and Gerald Jay Sussman. </author> <title> Lambda: The ultimate imperative. </title> <type> AI Memo 353, </type> <institution> MIT AI Lab, </institution> <month> March </month> <year> 1976. </year>
Reference-contexts: A similar problem arises for String. This is a problem for Java proper, but it may be aggravated in Pizza, which enhances the significance of interfaces by their use for bounded polymorphism. Tail calls. We would like for Pizza to support tail calls <ref> [SS76] </ref>, but this is difficult without support in the Java Vir tual Machine. We hope for such support in future versions of Java. Arrays.
Reference: [Str91] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language, Second Edition. </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: Related work. Pizza's type system is based on a mixture of Hindley-Milner type inference [DM82] and F-bounded polymorphism [CCH + 89], closely related to type classes [WB89, Jon93]. There is also some use of existential types [CW85, MP88]. Superficially, Pizza types appear similar to the template mechanism of C++ <ref> [Str91] </ref>. Both allow parameterized types, both have polymorphic functions with implicit instantiation, and both have similar syntax. However, the similarity does not run deep. C++ templates are implemented by macro expansion, such that all type checking is performed only on the function instances, not on the template itself.
Reference: [Sun96a] <author> Sun Microsystems. </author> <title> Inner classes in Java. </title> <address> http://java.sun.com/products/JDK/1.1/ designspecs/innerclasses. </address>
Reference-contexts: Ideas for translating higher-order functions into classes belong to the folklore of the object-oriented community. A codification similar to ours has been described by Laufer [Lau95]. A facility similar to higher-order functions is provided by the anonymous classes proposed for the next version of Java <ref> [Sun96a] </ref>. Our observations about visibility problems appear to be new. Status. We have a complete design for Pizza, including type rules, as sketched in this paper. We consider the design preliminary, and subject to change as we gain experience.
Reference: [Sun96b] <author> Sun Microsystems. </author> <title> Java core reflection. </title> <address> http://java.sun.com/products/JDK/1.1/ designspecs/reflection. </address>
Reference-contexts: New `reflection' facilities for the next version of Java solve this problem, and may cause us to reconsider our choice <ref> [Sun96b] </ref>. For now, we simply prohibit polymorphic array creation. In it's place, one may use higher-order functions, passing a function that explicitly creates the array.
Reference: [WB89] <author> Philip Wadler and Stephen Blott. </author> <title> How to make ad-hoc polymorphism less ad-hoc. </title> <booktitle> In Proc. 16th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 60-76, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Related work. Pizza's type system is based on a mixture of Hindley-Milner type inference [DM82] and F-bounded polymorphism [CCH + 89], closely related to type classes <ref> [WB89, Jon93] </ref>. There is also some use of existential types [CW85, MP88]. Superficially, Pizza types appear similar to the template mechanism of C++ [Str91]. Both allow parameterized types, both have polymorphic functions with implicit instantiation, and both have similar syntax. However, the similarity does not run deep. <p> The mixture of implicit instantiation with F-bounded polymorphism resembles type classes as used in Haskell, and may be implemented using similar techniques <ref> [WB89, Oho92, Jon93] </ref>.
Reference: [Wir77] <author> Niklaus Wirth. </author> <title> What can we do about the un-nessesary diversity of notation for syntactic definitions? Comm. </title> <journal> ACM, </journal> <volume> 20, </volume> <pages> pages 822-823, </pages> <month> November </month> <year> 1977. </year> <month> 14 </month>
Reference-contexts: We are now adding Pizza features to our EspressoGrinder compiler for Java, and look forward to feedback from experience with our design. Acknowledgments We'd like to thank the anonymous referees for their thorough and helpful comments. A Syntax extensions Java in EBNF format <ref> [Wir77] </ref>. B Pizza's Type System Since full Pizza is an extension of Java, and Java is too complex for a concise formal definition, we concentrate here on a subset of Pizza that reflects essential aspects of our extensions. The abstract syntax of Mini-Pizza programs is given in Figure 2.
References-found: 26

