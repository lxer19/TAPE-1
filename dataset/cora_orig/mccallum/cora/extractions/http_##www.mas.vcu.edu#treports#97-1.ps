URL: http://www.mas.vcu.edu/treports/97-1.ps
Refering-URL: http://www.mas.vcu.edu/technic.html
Root-URL: http://www.mas.vcu.edu
Email: boyle@td.anl.gov  dresler@vcu.edu  
Title: A Program-Algebraic Approach to Eliminating Common Subexpressions  
Author: James M. Boyle R. Daniel Resler 
Address: Argonne, IL 60439, USA  Richmond, VA 23284-2014, USA  
Affiliation: Technology Development Division Argonne National Laboratory  Dept. of Mathematical Sciences Virginia Commonwealth University  
Abstract: An operation often performed by optimizing compilers for higher-level languages is common-subexpression elimination. Traditionally, common-subexpression elimination is performed on a directed, acyclic graph representing the expression or program. This paper shows how common-subexpression elimination can be expressed algebraically, using a "program algebra" incorporating the syntax of typical higher-level language expressions plus -expressions from the calculus and functional programming. This approach has two major advantages| it is intuitive and easy to understand and it uses transformations for which correctness-preservation is easy to prove. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers, Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Moreover, a significant number of common subexpressions arise implicitly; for example, from repeated occurrences of a subscripted variable, such as a [i,j], whose address computation requires the evaluation of an addressing polynomial. Traditionally, common-subexpression elimination is performed on a directed, acyclic graph (DAG) representing the expression or program <ref> [1] </ref>. The purpose of this paper is to show how common-subexpression elimination can be expressed algebraically, using a "program algebra" incorporating the syntax of typical higher-level language expressions plus -expressions (see Section 2) from the calculus and functional programming. <p> Finally, we attempt to common only syntacticly identical subexpres-sions; we do not consider commutative and associative variants, nor variants clouded by aliasing. (Finding all possible common subexpres-sions based on algebraic identities for commutativity and associativity is a complex problem <ref> [1] </ref>.
Reference: [2] <author> H. P. Barendregt. </author> <title> The Lambda Calculus|Its Syntax and Semantics. </title> <publisher> North-Holland Publishing Company, </publisher> <year> 1981. </year> <note> VCU Mathematical Sciences Technical Report VCU-MAS-97-1 26 </note>
Reference-contexts: In this expression x is called the -variable, f (x) the -body, and e the -argument. The -expression without the argument is called a - abstraction, which is a (nameless) function; like a function, a -abstraction can be applied to an argument (see <ref> [2] </ref>, p. 6). The -expression gives a name (x) to the value of its argument; this name can be used to represent that value throughout the expression that is the -body.
Reference: [3] <author> James M. Boyle. </author> <title> Abstract programming and program transformation| an approach to reusing programs. </title> <editor> In Ted. J. Biggerstaff and Alan J. Perlis, editors, </editor> <booktitle> Software Reusability, </booktitle> <volume> volume I, chapter 15, </volume> <pages> pages 361-413. </pages> <publisher> ACM Press (Addison-Wesley), </publisher> <year> 1989. </year>
Reference-contexts: number of advantages: * It is based on familiar programming and mathematical notation, which facilitates human description and understanding of the process of com mon-subexpression elimination. * The manipulations necessary to eliminate common subexpressions can be expressed in the high-level notation of program transformations, which can be applied by TAMPR <ref> [3] </ref>, a fully automatic rewrite-rule based program transformation system. * Because the meaning of a program transformation depends on the meaning of the programming language in which the expressions are written (in this case, augmented with -expressions), it is easy to prove that the program transformations preserve the correctness of the <p> These advantages of the algebraic approach also apply to solving other types of problem, see <ref> [3, 5, 4] </ref>.
Reference: [4] <author> James M. Boyle. </author> <title> Automatic, self-adaptive control of unfold-fold transformations. </title> <editor> In E.-R Olderog, editor, </editor> <title> Programming Concepts, Methods and Calculi, </title> <journal> IFIP Transactions A-56, </journal> <pages> pages 83-103. </pages> <publisher> Elsevier Science B.V. (North Holland), </publisher> <year> 1994. </year>
Reference-contexts: These advantages of the algebraic approach also apply to solving other types of problem, see <ref> [3, 5, 4] </ref>. <p> VCU-MAS-97-1 7 The creation of this canonical form, from which RISC code can easily be generated, depends on transforming an expression through a sequence of intermediate canonical forms, each of which captures a part of the compilation process. (The role of canonical forms in program transformation is also discussed in <ref> [4] </ref>.) The following sections discuss the transformations and intermediate canonical forms necessary for elimination of common subex-pressions in complicated arithmetic expressions. 3.1 Introducing Identity -expressions into Expressions For common subexpressions to be eliminated, the value of each program variable, constant, and result of an operation in an expression must be associated
Reference: [5] <author> James M. Boyle and Terence J. Harmer. </author> <title> A practical functional program for the CRAY X-MP. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(1) </volume> <pages> 81-126, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: These advantages of the algebraic approach also apply to solving other types of problem, see <ref> [3, 5, 4] </ref>.
Reference: [6] <author> Z. Manna. </author> <title> Mathematical Theory of Computation. </title> <publisher> McGraw-Hill Inc., </publisher> <address> New York, </address> <year> 1974. </year>
Reference-contexts: Of course, one usually intends that a program transformation produce a result that is not only syntactically legal but also semantically valid. That is, one wants to show that the transformation is correctness-preserving|that the replacement subexpression generated by the application of the transformation is a refinement <ref> [6] </ref> of the subexpression matched by the pattern of the transformation. (One fragment of a program, p 2 , is a refinement of another, p 1 , if they produce the same result, are both undefined, or if p 1 is undefined and p 2 is defined.) In the case of
Reference: [7] <author> Victor L. Winter and James M. Boyle. </author> <title> Proving refinement transformations for deriving high-assurance software. </title> <booktitle> In Proceedings, High-Assurance Systems Engineering Workshop, Niagara on the Lake, </booktitle> <address> On-tario, Canada, </address> <month> Oct. </month> <pages> 21-22, </pages> <year> 1996, </year> <pages> pages 68-77. </pages> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1997. </year> <note> VCU Mathematical Sciences Technical Report VCU-MAS-97-1 27 </note>
Reference-contexts: Provided that the meaning of the -expression notation in the Poly grammar is the same as the meaning of -expressions in the calculus, the proofs are trivial. For more information on a methodology for carrying out a formal verification that TAMPR transformations preserve correctness, see <ref> [7] </ref>. Proof that the transformations discussed here achieve their goal|that they do common all syntactically identical -expressions|is more interesting, in part because the proof illustrates the important role of the canonical forms discussed in the preceding sections.
References-found: 7

