URL: http://www.cs.cornell.edu/Info/People/chandra/podc97/papers/umesh.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/chandra/podc97/newProgram.html
Root-URL: 
Email: fumesh,liskovg@lcs.mit.edu  
Title: Collecting Distributed Garbage Cycles by Back Tracing  
Author: Umesh Maheshwari Barbara Liskov 
Address: 545 Technology Square, Cambridge, MA 02139  
Affiliation: MIT Laboratory for Computer Science  
Abstract: Systems that store objects at a large number of sites require fault-tolerant and timely garbage collection. A popular technique is to trace each site independently using inter-site references as roots. However, this fails to collect cyclic garbage spread across sites. We present an algorithm that collects cyclic garbage by involving only the sites containing it. Our algorithm is based on finding objects highly likely to be cyclic garbage and tracing backward from them to check if they are reachable from any root. We present efficient techniques that make conducting such traces practical. The algorithm collects all distributed cyclic garbage, is safe in the presence of concurrent mutations, and has low space and time overhead. 
Abstract-found: 1
Intro-found: 1
Reference: [Ali85] <author> K. A. M. Ali. </author> <title> Garbage collection schemes for distributed storage systems. </title> <booktitle> In Proc. Workshop on Implementation of Functional Languages, </booktitle> <pages> pages 422-428, </pages> <year> 1985. </year>
Reference-contexts: However, for a local trace to be safe, object references from other sites must be treated as roots. Thus, many distributed systems use local tracing in combination with some variant of inter-site reference counting to track inter-site references <ref> [Bis77, Ali85, Bev87, SDP92, JJ92, BEN + 93, ML94] </ref>. Local tracing has the desirable locality property that col This research was supported in part by the Advanced Research Projects Agency of the Department of Defense, monitored by the Office of Naval Research, contract N00014-91-J-4136. <p> The challenge in collecting an inter-site garbage cycle is to preserve locality, that is, to involve only the sites containing the cycle. This has proven surprisingly difficult. Most previous schemes do not preserve locality. For example, some conduct complementary global traces in addition to local tracing <ref> [Ali85, JJ92] </ref>. The drawbacks of global tracing can be alleviated by tracing within groups of selected sites [LQP92, MKI + 95, RJ96], but inter-group cycles may never be collected. Few schemes for collecting inter-site cycles have the locality property. <p> Local Tracing Each site conducts a local trace independently of other sites. For a local trace to be safe, it must not collect objects reachable from other sites. Therefore, it treats incoming inter-site references as roots. Different methods may be employed to record inter-site references; e.g., one-bit reference counts <ref> [Ali85, JJ92] </ref>, weighted reference counts [Bev87], and reference lists [Bis77, SDP92, BEN + 93]. We use inter-site reference listing because it handles site failures and provides better fault-tolerance for messages [ML94]. It works as follows. Each site keeps a table of incoming references, called in-refs. <p> Global Tracing A complementary global trace is conducted periodically to collect cyclic garbage, while other garbage is collected more quickly by local tracing <ref> [Ali85, JJ92] </ref>. The drawback of global tracing is that it may not complete in a system with a large number of faulty sites. Hughes's algorithm propagates timestamps from inrefs to outrefs and collects objects timestamped below a certain global threshold [Hug85].
Reference: [BE86] <author> M. J. Beckerle and K. Ekanadham. </author> <title> Distributed garbage collection with no global synchronisation. </title> <type> Research Report RC 11667 (#52377), </type> <institution> IBM, </institution> <year> 1986. </year>
Reference-contexts: However, a single site can hold down the global threshold, prohibiting garbage collection in the entire system. Central Service Beckerle and Ekanadham proposed that each site send inref-outref reachability information to a fixed site, which uses the information to detect inter-site garbage cycles <ref> [BE86] </ref>. However, the fixed site becomes a performance 10 and fault tolerance bottleneck. Ladin and Liskov proposed a logically central but physically replicated service that tracks inter-site references and uses Hughes's algorithm to collect cycles [LL92].
Reference: [BEN + 93] <author> A. Birrell, D. Evers, G. Nelson, S. Owicki, and E. Wob-ber. </author> <title> Distributed garbage collection for network objects. </title> <type> Technical Report 116, </type> <institution> Digital Systems Research Center, </institution> <year> 1993. </year>
Reference-contexts: However, for a local trace to be safe, object references from other sites must be treated as roots. Thus, many distributed systems use local tracing in combination with some variant of inter-site reference counting to track inter-site references <ref> [Bis77, Ali85, Bev87, SDP92, JJ92, BEN + 93, ML94] </ref>. Local tracing has the desirable locality property that col This research was supported in part by the Advanced Research Projects Agency of the Department of Defense, monitored by the Office of Naval Research, contract N00014-91-J-4136. <p> For a local trace to be safe, it must not collect objects reachable from other sites. Therefore, it treats incoming inter-site references as roots. Different methods may be employed to record inter-site references; e.g., one-bit reference counts [Ali85, JJ92], weighted reference counts [Bev87], and reference lists <ref> [Bis77, SDP92, BEN + 93] </ref>. We use inter-site reference listing because it handles site failures and provides better fault-tolerance for messages [ML94]. It works as follows. Each site keeps a table of incoming references, called in-refs. <p> For safe execution, the sender Q retains its outref for c until R is known to have received the insert message. There are various protocols for sending, deferring, or avoiding insert messages while ensuring safety <ref> [SDP92, BEN + 93, ML94] </ref>. We assume that a safe insert protocol exists and that the full source list of an inref can be found when needed. A site P trims its outrefs during each local trace.
Reference: [Bev87] <author> D. I. Bevan. </author> <title> Distributed garbage collection using reference counting. </title> <booktitle> In PARLE, volume 259 of Lecture Notes in Computer Science, </booktitle> <pages> pages 176-187. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: However, for a local trace to be safe, object references from other sites must be treated as roots. Thus, many distributed systems use local tracing in combination with some variant of inter-site reference counting to track inter-site references <ref> [Bis77, Ali85, Bev87, SDP92, JJ92, BEN + 93, ML94] </ref>. Local tracing has the desirable locality property that col This research was supported in part by the Advanced Research Projects Agency of the Department of Defense, monitored by the Office of Naval Research, contract N00014-91-J-4136. <p> For a local trace to be safe, it must not collect objects reachable from other sites. Therefore, it treats incoming inter-site references as roots. Different methods may be employed to record inter-site references; e.g., one-bit reference counts [Ali85, JJ92], weighted reference counts <ref> [Bev87] </ref>, and reference lists [Bis77, SDP92, BEN + 93]. We use inter-site reference listing because it handles site failures and provides better fault-tolerance for messages [ML94]. It works as follows. Each site keeps a table of incoming references, called in-refs.
Reference: [Bis77] <author> P. B. Bishop. </author> <title> Computer systems with a very large address space and garbage collection. </title> <type> Technical Report MIT/LCS/TR-178, </type> <institution> MIT, </institution> <year> 1977. </year>
Reference-contexts: However, for a local trace to be safe, object references from other sites must be treated as roots. Thus, many distributed systems use local tracing in combination with some variant of inter-site reference counting to track inter-site references <ref> [Bis77, Ali85, Bev87, SDP92, JJ92, BEN + 93, ML94] </ref>. Local tracing has the desirable locality property that col This research was supported in part by the Advanced Research Projects Agency of the Department of Defense, monitored by the Office of Naval Research, contract N00014-91-J-4136. <p> Few schemes for collecting inter-site cycles have the locality property. The most prominent among these is based on migrating objects so that cyclic garbage ends up in a single site and is collected by local tracing <ref> [Bis77, SGP90, ML95] </ref>. However, migration is expensive and must deal with updating references to migrated objects; moreover, some systems do not support migration due to security or autonomy constraints. Other local schemes are prohibitively costly or complex [Sch89, LC97]. We present a practical scheme that has locality. <p> For a local trace to be safe, it must not collect objects reachable from other sites. Therefore, it treats incoming inter-site references as roots. Different methods may be employed to record inter-site references; e.g., one-bit reference counts [Ali85, JJ92], weighted reference counts [Bev87], and reference lists <ref> [Bis77, SDP92, BEN + 93] </ref>. We use inter-site reference listing because it handles site failures and provides better fault-tolerance for messages [ML94]. It works as follows. Each site keeps a table of incoming references, called in-refs. <p> Schemes with Locality Few schemes for collecting cyclic garbage have the locality property. The oldest among these is migration. The idea is to converge a suspected distributed garbage cycle to a single site: if it is indeed a garbage cycle, it will be collected by local tracing <ref> [Bis77] </ref>. Since migration is expensive, it is crucial to use a good heuristic for finding suspects; we proposed the distance heuristic in this context earlier [ML95]. However, some systems do not support migration due to security or autonomy constraints or due to heterogeneous architecture.
Reference: [Fuc95] <author> M. Fuchs. </author> <title> Garbage collection on an open network. </title> <editor> In H. Baker, editor, </editor> <booktitle> Proc. IWMM, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: This paper describes a technique for checking suspects by tracing back from a suspect to see if it is reachable from any root. This approach preserves locality and scalability. Back tracing was proposed earlier by Fuchs <ref> [Fuc95] </ref>. However, this proposal assumed that inverse information was available for references, and it ignored problems due to concurrent 1 mutations and forward local traces. We present efficient techniques for conducting back tracing that handle these and other practical problems. <p> We expect most garbage to be collected by local tracing and update messages. Back tracing is a complementary technique to detect uncollected garbage, and we use it for objects suspected to be on distributed garbage cycles. Back tracing was proposed earlier by Fuchs <ref> [Fuc95] </ref>. However, this proposal assumed that each object was contained in a site by itself and inverse information was available for references, and it ignored problems due to concurrent mutations and forward traces. We present practical techniques for conducting back tracing. <p> We say that a trace is active at an ioref if it has a call pending there; we say that a trace has visited an ioref if the ioref is marked visited by the trace. This algorithm is simpler than Fuchs's <ref> [Fuc95] </ref>. This is because Fuchs's algorithm is designed to detect garbage objects on the way even if the back trace was started from a live object. <p> However, it too requires full inref-outref reachability information, and its space overhead is larger: each inref i stores a set of vector timestamps; each vector corresponds to a path i is reachable from. Back tracing was proposed earlier by Fuchs <ref> [Fuc95] </ref>. However, this proposal assumed that inverse information was available for references, and it ignored problems due to concurrent mutations and forward local traces.
Reference: [HK82] <author> P. R. Hudak and R. M. Keller. </author> <title> Garbage collection and task deletion in distributed applicative processing systems. </title> <booktitle> In Conference Record of the 1982 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 168-178. </pages> <publisher> ACM Press, </publisher> <year> 1982. </year>
Reference-contexts: The scale of such systems poses new challenges to reclaiming the storage of objects unreachable by applications. Such objects are known as garbage. A simple way to collect garbage is to trace the graph of reachable objects and then collect objects not visited by the trace <ref> [HK82] </ref>. However, a global trace requires the cooperation of all sites before it can collect any garbage. Timely and fault tolerant collection requires that each site trace local objects and collect garbage independently of other sites.
Reference: [Hug85] <author> R. J. M. Hughes. </author> <title> A distributed garbage collection algorithm. </title> <booktitle> In Proc. 1985 FPCA, volume 201 of Lecture Notes in Computer Science, </booktitle> <pages> pages 256-272. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: The drawback of global tracing is that it may not complete in a system with a large number of faulty sites. Hughes's algorithm propagates timestamps from inrefs to outrefs and collects objects timestamped below a certain global threshold <ref> [Hug85] </ref>. The persistent roots always have the current time, and a global algorithm is used to compute the threshold. The advantage of using timestamps over mark bits is that, in effect, multiple marking phases can proceed concurrently.
Reference: [JJ92] <author> N.-C. Juul and E. </author> <month> Jul. </month> <title> Comprehensive and robust garbage collection in a distributed system. </title> <booktitle> In Proc. IWMM, volume 637 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: However, for a local trace to be safe, object references from other sites must be treated as roots. Thus, many distributed systems use local tracing in combination with some variant of inter-site reference counting to track inter-site references <ref> [Bis77, Ali85, Bev87, SDP92, JJ92, BEN + 93, ML94] </ref>. Local tracing has the desirable locality property that col This research was supported in part by the Advanced Research Projects Agency of the Department of Defense, monitored by the Office of Naval Research, contract N00014-91-J-4136. <p> The challenge in collecting an inter-site garbage cycle is to preserve locality, that is, to involve only the sites containing the cycle. This has proven surprisingly difficult. Most previous schemes do not preserve locality. For example, some conduct complementary global traces in addition to local tracing <ref> [Ali85, JJ92] </ref>. The drawbacks of global tracing can be alleviated by tracing within groups of selected sites [LQP92, MKI + 95, RJ96], but inter-group cycles may never be collected. Few schemes for collecting inter-site cycles have the locality property. <p> Local Tracing Each site conducts a local trace independently of other sites. For a local trace to be safe, it must not collect objects reachable from other sites. Therefore, it treats incoming inter-site references as roots. Different methods may be employed to record inter-site references; e.g., one-bit reference counts <ref> [Ali85, JJ92] </ref>, weighted reference counts [Bev87], and reference lists [Bis77, SDP92, BEN + 93]. We use inter-site reference listing because it handles site failures and provides better fault-tolerance for messages [ML94]. It works as follows. Each site keeps a table of incoming references, called in-refs. <p> Global Tracing A complementary global trace is conducted periodically to collect cyclic garbage, while other garbage is collected more quickly by local tracing <ref> [Ali85, JJ92] </ref>. The drawback of global tracing is that it may not complete in a system with a large number of faulty sites. Hughes's algorithm propagates timestamps from inrefs to outrefs and collects objects timestamped below a certain global threshold [Hug85].
Reference: [JL92] <author> R. E. Jones and R. D. Lins. </author> <title> Cyclic weighted reference counting without delay. </title> <type> Technical Report 28-92, </type> <institution> Computing Laboratory, The University of Kent at Canterbury, </institution> <year> 1992. </year>
Reference-contexts: This scheme requires two distributed traces over objects in a subgraph. Jones and Lins improved the scheme such that multiple sites could conduct traces in parallel, but it required global synchronization between sites <ref> [JL92] </ref>. Group Tracing Another method to alleviate the drawbacks of global tracing is to trace within a group of selected sites, thus collecting garbage cycles within the group. A group trace treats all references from outside the group as roots.
Reference: [LAC + 96] <author> B. Liskov, A. Adya, M. Castro, M. Day, S. Ghemawat, R. Gruber, U. Maheshwari, A. Myers, and L. Shrira. </author> <title> Safe and efficient sharing of persistent objects in Thor. </title> <booktitle> In Proc. 1996 SIGMOD, </booktitle> <pages> pages 318-329. </pages> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: Thus, the transfer barrier may be implemented by checking such references. In client-caching systems where objects from multiple servers may be fetched into a client cache <ref> [LAC + 96] </ref>, the barrier may be implemented by checking the transaction's read-write log at commit time. 6.1.2 Remote Copy If a reference to z is copied into y at another site Y, we handle it in one of the following ways depending on z: 1. <p> It does not migrate objects and its overheads are lower than other schemes with locality. Furthermore, it collects all distributed garbage cycles. We designed this scheme for implementation in a large, distributed object database <ref> [LAC + 96] </ref>. It is suitable for emerging distributed object systems that must scale to a large number of sites. Acknowledgements We are grateful to Chandrasekhar Boyapati and Andrew Myers for proofreading this paper.
Reference: [LC97] <author> S. Louboutin and V. Cahill. </author> <title> Comprehensive distributed garbage collection by tracking the causal dependencies of relevant mutator events. </title> <booktitle> In Proc. </booktitle> <address> ICDCS. </address> <publisher> IEEE Press, </publisher> <year> 1997. </year>
Reference-contexts: However, migration is expensive and must deal with updating references to migrated objects; moreover, some systems do not support migration due to security or autonomy constraints. Other local schemes are prohibitively costly or complex <ref> [Sch89, LC97] </ref>. We present a practical scheme that has locality. It has two parts. The first part identifies objects that are highly likely to be cyclic garbagethe suspects. We have previously designed a suitable technique for finding suspects using the distance heuristic [ML95]. <p> An inref i contains a set of paths instead of source sites; each path indicates a sequence of inrefs leading to i. Collecting a cycle located on N sites might take O (N 3 ) messages. Recently, Louboutin presented an improved scheme that sends only O (N ) messages <ref> [LC97] </ref>. However, it too requires full inref-outref reachability information, and its space overhead is larger: each inref i stores a set of vector timestamps; each vector corresponds to a path i is reachable from. Back tracing was proposed earlier by Fuchs [Fuc95].
Reference: [LJ93] <author> R. D. Lins and R. E. Jones. </author> <title> Cyclic weighted reference counting. </title> <editor> In K. Boyanov, editor, </editor> <booktitle> Proc. Workshop on Parallel and Distributed Processing. </booktitle> <publisher> North Holland, </publisher> <year> 1993. </year>
Reference-contexts: Thus, the scheme does not possess the locality property. Lins et al. proposed such a scheme as cyclic reference counting in a system that used reference counting for local collection instead of local tracing <ref> [LJ93] </ref>. This scheme requires two distributed traces over objects in a subgraph. Jones and Lins improved the scheme such that multiple sites could conduct traces in parallel, but it required global synchronization between sites [JL92].
Reference: [LL92] <author> R. Ladin and B. Liskov. </author> <title> Garbage collection of a distributed heap. </title> <booktitle> In Proc. </booktitle> <address> ICDCS. </address> <publisher> IEEE Press, </publisher> <year> 1992. </year>
Reference-contexts: However, the fixed site becomes a performance 10 and fault tolerance bottleneck. Ladin and Liskov proposed a logically central but physically replicated service that tracks inter-site references and uses Hughes's algorithm to collect cycles <ref> [LL92] </ref>. The central service avoids the need for a distributed algorithm to compute the global threshold. However, cycle collection still depends on timely correspondence between the service and all sites in the system.
Reference: [LQP92] <author> B. Lang, C. Queinniec, and J. Piquer. </author> <title> Garbage collecting the world. </title> <booktitle> In Proc. POPL '92, </booktitle> <pages> pages 39-50. </pages> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: This has proven surprisingly difficult. Most previous schemes do not preserve locality. For example, some conduct complementary global traces in addition to local tracing [Ali85, JJ92]. The drawbacks of global tracing can be alleviated by tracing within groups of selected sites <ref> [LQP92, MKI + 95, RJ96] </ref>, but inter-group cycles may never be collected. Few schemes for collecting inter-site cycles have the locality property. <p> A group trace treats all references from outside the group as roots. The problem with group tracing is configuring groups in order to collect all inter-site cycles. Lang et al. proposed using a tree-like hierarchy of embedded groups <ref> [LQP92] </ref>. This ensures that each cycle is covered by some group, but the smallest group covering, say, a two-site cycle may contain many more sites. Further, the policy for forming and disbanding groups dynamically is unclear. Maeda et al. proposed forming groups using subgraph tracing [MKI + 95].
Reference: [MKI + 95] <author> M. Maeda, H. Konaka, Y. Ishikawa, T. T. iyo, A. Hori, and J. Nolte. </author> <title> On-the-fly global garbage collection based on partly mark-sweep. </title> <editor> In H. Baker, editor, </editor> <booktitle> Proc. IWMM, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: This has proven surprisingly difficult. Most previous schemes do not preserve locality. For example, some conduct complementary global traces in addition to local tracing [Ali85, JJ92]. The drawbacks of global tracing can be alleviated by tracing within groups of selected sites <ref> [LQP92, MKI + 95, RJ96] </ref>, but inter-group cycles may never be collected. Few schemes for collecting inter-site cycles have the locality property. <p> This ensures that each cycle is covered by some group, but the smallest group covering, say, a two-site cycle may contain many more sites. Further, the policy for forming and disbanding groups dynamically is unclear. Maeda et al. proposed forming groups using subgraph tracing <ref> [MKI + 95] </ref>. A group consists of sites reached transitively from some objects suspected to be cyclic garbage. This work was done in the context of local tracing and inter-site weighted reference counting. Rodrigues and Jones proposed an improved scheme in the context of inter-site reference listing [RJ96].
Reference: [ML94] <author> U. Maheshwari and B. Liskov. </author> <title> Fault-tolerant distributed garbage collection in a client-server object-oriented database. </title> <booktitle> In Proc. </booktitle> <address> PDIS. </address> <publisher> IEEE Press, </publisher> <year> 1994. </year>
Reference-contexts: However, for a local trace to be safe, object references from other sites must be treated as roots. Thus, many distributed systems use local tracing in combination with some variant of inter-site reference counting to track inter-site references <ref> [Bis77, Ali85, Bev87, SDP92, JJ92, BEN + 93, ML94] </ref>. Local tracing has the desirable locality property that col This research was supported in part by the Advanced Research Projects Agency of the Department of Defense, monitored by the Office of Naval Research, contract N00014-91-J-4136. <p> Different methods may be employed to record inter-site references; e.g., one-bit reference counts [Ali85, JJ92], weighted reference counts [Bev87], and reference lists [Bis77, SDP92, BEN + 93]. We use inter-site reference listing because it handles site failures and provides better fault-tolerance for messages <ref> [ML94] </ref>. It works as follows. Each site keeps a table of incoming references, called in-refs. Each entry in the table, called an inref, stores a reference and a list of source sites known to contain that reference. <p> For safe execution, the sender Q retains its outref for c until R is known to have received the insert message. There are various protocols for sending, deferring, or avoiding insert messages while ensuring safety <ref> [SDP92, BEN + 93, ML94] </ref>. We assume that a safe insert protocol exists and that the full source list of an inref can be found when needed. A site P trims its outrefs during each local trace. <p> Otherwise, it will find all outrefs for z. The insert barrier is a small modification to the insert protocol described in Section 2. In systems that send the insert message synchronously, site X is informed when the insert message reaches Z <ref> [ML94] </ref>. Also, the insert barrier can be modified to suit schemes that avoid insert messages; in fact, little change is needed for systems using indirect protection [SDP92]. 6.2 Non-atomic Local Tracing Mutations may change the object graph while the local trace is computing back information.
Reference: [ML95] <author> U. Maheshwari and B. Liskov. </author> <title> Collecting cyclic distributed garbage by controlled migration. </title> <booktitle> In Proc. PODC, </booktitle> <pages> pages 57-63, </pages> <year> 1995. </year>
Reference-contexts: Few schemes for collecting inter-site cycles have the locality property. The most prominent among these is based on migrating objects so that cyclic garbage ends up in a single site and is collected by local tracing <ref> [Bis77, SGP90, ML95] </ref>. However, migration is expensive and must deal with updating references to migrated objects; moreover, some systems do not support migration due to security or autonomy constraints. Other local schemes are prohibitively costly or complex [Sch89, LC97]. We present a practical scheme that has locality. <p> We present a practical scheme that has locality. It has two parts. The first part identifies objects that are highly likely to be cyclic garbagethe suspects. We have previously designed a suitable technique for finding suspects using the distance heuristic <ref> [ML95] </ref>. The second part checks if the suspects are in fact garbage. This part has the luxury of using techniques that are too costly if applied to all objects but are acceptable if applied only to suspects. <p> The heuristic must be complete in identifying all cyclic garbage. Furthermore, it must have little time and space overhead per object since it must inspect a large number of objects. A suitable technique for finding suspects is the distance heuristic <ref> [ML95] </ref>. The distance of an object is the minimum number of inter-site references in any path from a persistent root to that object. The distance of garbage is infinity. In with two inter-site references and another with one; therefore, its distance is one. Suspects are found by estimating distances. <p> Instead, another technique must confirm suspected garbage before reclaiming it. The outcome of the this technique may be used to tune the suspicion threshold. For example, if too many suspects are found live, the threshold should be increased. In an earlier paper, we suggested migrating the suspects <ref> [ML95] </ref>. This paper presents a technique that does not migrate objects. 4 Back Tracing The key insight behind back tracing is that whether an object is reachable from a root is equivalent to whether a root is reachable from the object if all references are reversed. <p> Since migration is expensive, it is crucial to use a good heuristic for finding suspects; we proposed the distance heuristic in this context earlier <ref> [ML95] </ref>. However, some systems do not support migration due to security or autonomy constraints or due to heterogeneous architecture. Those that do must patch references to migrated objects. Shapiro et al. suggested virtual migration [SGP90]. Here, an object changes its logical space without migrating physically.
Reference: [RJ96] <author> H. Rodrigues and R. Jones. </author> <title> A cyclic distributed garbage collector for network objects. </title> <booktitle> In Proc. 10th Workshop on Distributed Algorithms, </booktitle> <year> 1996. </year>
Reference-contexts: This has proven surprisingly difficult. Most previous schemes do not preserve locality. For example, some conduct complementary global traces in addition to local tracing [Ali85, JJ92]. The drawbacks of global tracing can be alleviated by tracing within groups of selected sites <ref> [LQP92, MKI + 95, RJ96] </ref>, but inter-group cycles may never be collected. Few schemes for collecting inter-site cycles have the locality property. <p> A group consists of sites reached transitively from some objects suspected to be cyclic garbage. This work was done in the context of local tracing and inter-site weighted reference counting. Rodrigues and Jones proposed an improved scheme in the context of inter-site reference listing <ref> [RJ96] </ref>. One drawback of this approach is that multiple sites on the same cycle may initiate separate groups simultaneously, which would fail to collect the cycle. Conversely, a group may include more sites than necessary because a garbage cycle may point to chains of garbage or live objects.
Reference: [Sch89] <author> M. Schelvis. </author> <title> Incremental distribution of timestamp packets a new approach to distributed garbage collection. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 24(10) </volume> <pages> 37-48, </pages> <year> 1989. </year>
Reference-contexts: However, migration is expensive and must deal with updating references to migrated objects; moreover, some systems do not support migration due to security or autonomy constraints. Other local schemes are prohibitively costly or complex <ref> [Sch89, LC97] </ref>. We present a practical scheme that has locality. It has two parts. The first part identifies objects that are highly likely to be cyclic garbagethe suspects. We have previously designed a suitable technique for finding suspects using the distance heuristic [ML95]. <p> Shapiro et al. suggested virtual migration [SGP90]. Here, an object changes its logical space without migrating physically. However, a logical space may span a number of sites, so local tracing must involve inter-site tracing messages. Schelvis proposed forwarding local-reachability information along outgoing inter-site references <ref> [Sch89] </ref>. This algorithm is intricate and difficult to understand; however, some of its problems are apparent. The algorithm requires full reachability information between all inrefs and outrefs (not just suspected ones).
Reference: [SDP92] <author> M. Shapiro, P. Dickman, and D. Plainfoss e. </author> <title> Robust, distributed references and acyclic garbage collection. </title> <booktitle> In Proc. </booktitle> <address> PODC, </address> <year> 1992. </year>
Reference-contexts: However, for a local trace to be safe, object references from other sites must be treated as roots. Thus, many distributed systems use local tracing in combination with some variant of inter-site reference counting to track inter-site references <ref> [Bis77, Ali85, Bev87, SDP92, JJ92, BEN + 93, ML94] </ref>. Local tracing has the desirable locality property that col This research was supported in part by the Advanced Research Projects Agency of the Department of Defense, monitored by the Office of Naval Research, contract N00014-91-J-4136. <p> For a local trace to be safe, it must not collect objects reachable from other sites. Therefore, it treats incoming inter-site references as roots. Different methods may be employed to record inter-site references; e.g., one-bit reference counts [Ali85, JJ92], weighted reference counts [Bev87], and reference lists <ref> [Bis77, SDP92, BEN + 93] </ref>. We use inter-site reference listing because it handles site failures and provides better fault-tolerance for messages [ML94]. It works as follows. Each site keeps a table of incoming references, called in-refs. <p> For safe execution, the sender Q retains its outref for c until R is known to have received the insert message. There are various protocols for sending, deferring, or avoiding insert messages while ensuring safety <ref> [SDP92, BEN + 93, ML94] </ref>. We assume that a safe insert protocol exists and that the full source list of an inref can be found when needed. A site P trims its outrefs during each local trace. <p> In systems that send the insert message synchronously, site X is informed when the insert message reaches Z [ML94]. Also, the insert barrier can be modified to suit schemes that avoid insert messages; in fact, little change is needed for systems using indirect protection <ref> [SDP92] </ref>. 6.2 Non-atomic Local Tracing Mutations may change the object graph while the local trace is computing back information. The computed information must account for these mutations safely. Further, a back trace may visit a site while it is computing back information.
Reference: [SGP90] <author> M. Shapiro, O. Gruber, and D. Plainfoss e. </author> <title> A garbage detection protocol for a realistic distributed object-support system. </title> <institution> Rapports de Recherche 1320, INRIA-Rocquencourt, </institution> <year> 1990. </year>
Reference-contexts: Few schemes for collecting inter-site cycles have the locality property. The most prominent among these is based on migrating objects so that cyclic garbage ends up in a single site and is collected by local tracing <ref> [Bis77, SGP90, ML95] </ref>. However, migration is expensive and must deal with updating references to migrated objects; moreover, some systems do not support migration due to security or autonomy constraints. Other local schemes are prohibitively costly or complex [Sch89, LC97]. We present a practical scheme that has locality. <p> However, some systems do not support migration due to security or autonomy constraints or due to heterogeneous architecture. Those that do must patch references to migrated objects. Shapiro et al. suggested virtual migration <ref> [SGP90] </ref>. Here, an object changes its logical space without migrating physically. However, a logical space may span a number of sites, so local tracing must involve inter-site tracing messages. Schelvis proposed forwarding local-reachability information along outgoing inter-site references [Sch89].
Reference: [Tar72] <author> R. Tarjan. </author> <title> Depth first search and linear graph algorithms. </title> <journal> SIAM Journal of Computing, </journal> <volume> 1(2), </volume> <year> 1972. </year> <month> 12 </month>
Reference-contexts: In general, a backward edge introduces a strongly connected component, and the outsets of objects in a strongly connected component should all be equal. Fortunately, strongly connected components can be computed efficiently during a depth first traversal with linear performance <ref> [Tar72] </ref>. For each object, the algorithm finds the first object visited in its component, called its leader. The algorithm uses a counter to mark objects in the order they are visited. An auxiliary stack is used to find the objects in a component.
References-found: 23

