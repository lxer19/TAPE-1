URL: ftp://ftp.cs.kun.nl/pub/CSI/SoftwEng.FunctLang/papers/baks-FSTTCS93.ps.gz
Refering-URL: http://www.cs.kun.nl/~clean/Clean.Papers.html
Root-URL: 
Email: steffen@cs.kun.nl  
Title: Essential Intersection Type Assignment  
Author: Steffen van Bakel 
Address: Nijmegen, Toernooiveld 1, 6525 ED Nijmegen, The Netherlands.  
Affiliation: Department of Informatics, Faculty of Mathematics and Informatics, University of  
Abstract: This paper introduces a notion of intersection type assignment on the Lambda Calculus that is a restriction of the BCD-system as presented in [4]. This restricted system is essential in the following sense: it is an almost syntax directed system that satisfies all major properties of the BCD-system. The set of typeable terms can be characterized in the same way, the system is complete with respect to the simple type semantics, and it has the principal type property.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bakel S. van. </author> <title> Complete restrictions of the Intersection Type Discipline. </title> <journal> Theoretical Computer Science, </journal> <volume> 102 </volume> <pages> 135-163, </pages> <year> 1992. </year>
Reference-contexts: These two features are supported by a less complicated type structure. The system presented here is also an extension of the Strict Type Assignment System as presented in <ref> [1] </ref>. The major difference is that the essential system will prove to be closed for -reduction: If B ` E M : and M ! N , then B ` E N :. This does not hold for the strict system. <p> Completeness. B ` ` M : ) B ` M :. Since the type interpretation is simple, the results of [4] in fact show that type assignment in the BCD-system is complete with respect to simple type semantics. (Type assignment in the strict system as presented in <ref> [1] </ref> was proven in that paper to be complete with respect to the inference semantics.) 2 Essential type assignment for the lambda calculus In this section we present the Essential Type Assignment System, a restricted version of the system presented in [4]. <p> Compared to the BCD-system, the major feature of this system is a restricted version of the derivation rules, as well as a restriction of the set of types. It also forms a slight extension of the Strict Type Assignment System that was presented in <ref> [1] </ref>; the main difference is that that systems is not closed for - reduction, whereas the system presented here is. 2.1 Essential type assignment Strict types are the types that are strictly needed to assign a type to a term in the system as presented in [4] (see also [1]). <p> in <ref> [1] </ref>; the main difference is that that systems is not closed for - reduction, whereas the system presented here is. 2.1 Essential type assignment Strict types are the types that are strictly needed to assign a type to a term in the system as presented in [4] (see also [1]). In the set of strict types intersection type schemes and the type constant ! play a limited role. <p> Moreover, intersection type schemes (so also !) occur in strict types only as subtypes at the left hand side of an arrow type scheme. Definition 9 (cf. <ref> [1] </ref>). 1. <p> B ` e x:M : () 9 2 T S , 2 T s [ ! & B [ fx:g ` e M :]. 4. B ` E x: () 9 2 T S [x: 2 B & E ]. Proof. Easy. As in <ref> [1] </ref>, it is possible to prove that the essential type assignment system satisfies the main properties of the BCD-system: Theorem 15. 1. <p> The proof is based on the fact that for every 2 T there is a fl 2 T S such that ~ fl , and an approximation theorem. Property 17 <ref> [9, 1] </ref>. For every 2 T there is a fl 2 T S such that ~ fl .
Reference: [2] <author> Bakel S. van. </author> <title> Principal type schemes for the Strict Type Assignment System. </title> <booktitle> Logic and Computation, </booktitle> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: Then three operations on pairs of basis and type substitution, expansion and rise were specified that were proved sound and sufficient to generate, for every term in N , all possible pairs from its principal one. Using this technique which is similar to the one used in <ref> [2] </ref> in this section we will sketch the construction of the proof that the Essential Type Assignment System has the principal type property. For each lambda term the principal pair (of basis and type) will be defined. <p> The notion of principal pairs for terms in N will be generalized to arbitrary lambda terms in definition 33. We will now present three different operations on pairs of &lt;basis, type&gt;, namely substitution, expansion, and lifting as defined in <ref> [2] </ref>. Substitution is normally defined on types as the operation that replaces type-variables by types. For strict types this definition would not be correct. For example, the replacement of ' by ! would transform !' (or "') into !! ("!), which is not a strict type. <p> For example, the replacement of ' by ! would transform !' (or "') into !! ("!), which is not a strict type. Therefore, for strict types substitution is not defined as an operation that replaces type-variables by types, but as a mapping from types to types. Definition 27 <ref> [2] </ref>. 1. <p> In this process it can be that also other types need to be copied. It is a complex operation, possibly affecting more types than just the one to be expanded occurs in. (For a clear discussion of the complexity of this operation, see <ref> [2] </ref>.) Definition 28 [2]. The last type-variable of a strict type is defined by: 1. The last type-variable of ' is '. 2. The last type-variable of 1 " " n !t is the last type-variable of t . Definition 29 [2]. <p> In this process it can be that also other types need to be copied. It is a complex operation, possibly affecting more types than just the one to be expanded occurs in. (For a clear discussion of the complexity of this operation, see <ref> [2] </ref>.) Definition 28 [2]. The last type-variable of a strict type is defined by: 1. The last type-variable of ' is '. 2. The last type-variable of 1 " " n !t is the last type-variable of t . Definition 29 [2]. <p> clear discussion of the complexity of this operation, see <ref> [2] </ref>.) Definition 28 [2]. The last type-variable of a strict type is defined by: 1. The last type-variable of ' is '. 2. The last type-variable of 1 " " n !t is the last type-variable of t . Definition 29 [2]. For every 2 T s , n 2, basis B and 2 T S , the quadruple &lt;, n, B, &gt; determines an expansion E &lt;;n;B;&gt; : T S ! T S , that is constructed as follows. 1. <p> E &lt;;n;B;&gt; (B 0 ) = fx:E &lt;;n;B;&gt; () j x: 2 B 0 g. The last operation on pairs defined in this subsection is the operation of lifting. Definition 30 <ref> [2] </ref>. A lifting L is an operation denoted by a pair of pairs &lt;<B 0 , t 0 &gt;, &lt;B 1 , t 1 &gt;> such that t 0 E t 1 and B 1 E B 0 , and is defined by: 1. <p> L () = t 1 , if t 0 ; L () = , otherwise. 2. L (B) = B 1 , if B = B 0 ; L (B) = B, otherwise. 3. L (&lt;B, &gt;) = &lt;L (B), L ()&gt;. Definition 31 <ref> [2] </ref>. <p> Moreover, all three operations can be proven to be sound on all pairs. The technique needed for these proofs can be found in [13] and <ref> [2] </ref>; because of the direct similarities with especially the proofs in the latter paper, proofs will be omitted here. Theorem 32. Let A 2 N , &lt;B, &gt; be such that B ` E A:, and let O be an operation of substitution, expansion or rise. <p> Theorem 32. Let A 2 N , &lt;B, &gt; be such that B ` E A:, and let O be an operation of substitution, expansion or rise. Then O (B) ` E A:O (). Definition 33 (cf. <ref> [13, 2] </ref>). 1. Linear chains of operations are defined as chains that start with a number of expansions, followed by a substitution, and that end with a lifting. 2. Let M be a term.
Reference: [3] <author> Barendregt H. </author> <title> The Lambda Calculus: its Syntax and Semantics. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <note> revised edition, </note> <year> 1984. </year>
Reference: [4] <author> Barendregt H., M. Coppo, and M. Dezani-Ciancaglini. </author> <title> A filter lambda model and the completeness of type assignment. </title> <journal> The Journal of Symbolic Logic, </journal> <volume> 48(4) </volume> <pages> 931-940, </pages> <year> 1983. </year>
Reference-contexts: The Intersection Type Discipline as presented in [5] (a more enhanced system was presented in <ref> [4] </ref>) is an extension of Curry's system that does not have these drawbacks. The extension being made consists mainly of allowing for term variables (and terms) to have more than one type. <p> Because of this power, in the intersection system (and even in the system that does not contain !) type assignment is undecidable. The type assignment system presented in <ref> [4] </ref> (the BCD-system) is based on the system as presented in [5]; it defines the set of intersection types T in a more general way, and is strengthened further by introducing a partial order relation `' on types as well as adding the type assignment rule () and a more general <p> These rules not only allow of superfluous steps in derivations, but they also make it possible to give essentially different derivations for the same result. Moreover, in <ref> [4] </ref> the relation induced an equivalence relation ~ on types. Equivalence classes are big (for example: ! ~ !!, for all types ) and type assignment is closed for ~ . <p> The Essential Type Assignment System as presented in this paper is a true restriction of the system of <ref> [4] </ref> that satisfies all properties of that system, and is also an extension of Curry's system. <p> We will show that, in order to prove a completeness result using intersection types, there is no need to be as general as in <ref> [4] </ref>; this result can also be obtained for the essential system. The main advantage of the essential system over the intersection system is that the set of types assignable to a term is significantly smaller. <p> with the Lambda Calculus, including the definition of the set N of terms in ?-normal form (like there, I use the symbol ? instead of ), and the notion of approximant. 1 The Barendregt-Coppo-Dezani type assignment system In this subsection we give the definitions of the system as presented in <ref> [4] </ref> that are relevant for the results presented in this paper, together with its major features. Definition 1 [4]. 1. <p> I use the symbol ? instead of ), and the notion of approximant. 1 The Barendregt-Coppo-Dezani type assignment system In this subsection we give the definitions of the system as presented in <ref> [4] </ref> that are relevant for the results presented in this paper, together with its major features. Definition 1 [4]. 1. T , the set of BCD-types is inductively defined by: All type-variables ' 0 , ' 1 , : : : 2 T , ! 2 T , and if and t 2 T , then (!t ) and ("t ) 2 T . 2. <p> B B 0 () 8 x: 0 2 B 0 9 x: 2 B [ 0 ]. Definition 3 <ref> [4] </ref>. 1. BCD-type assignment and BCD-derivations are defined by the following natural deduction system. [x:] M :t x:M :!t (!E): M : t M :t ("I): M :"t M : M :t M :! (a) If x: is the only statement about x on which M :t depends. 2. <p> The relation between types assignable to a lambda term and those assignable to its approximants is formulated by the following: Property 4 [13]. B ` M : () 9 A 2 A (M ) [B ` A:]. The main result of <ref> [4] </ref> is the proof for completeness of type assignment. This is achieved by showing that the set of types derivable for a lambda term is a filter, i.e. a set closed under intersection and right closed for . <p> Filters and the filter -model F are defined by: Definition 5 <ref> [4] </ref>. A BCD-filter is a subset d T such that: ! 2 d, if , t 2 d then "t 2 d, and if t 2 d then 2 d. <p> F = fd j d is a BCD-filterg, and for d 1 , d 2 2 F define d 1 d 2 = ft 2 T j 9 2 d 2 [!t 2 d 1 ]g. The following properties are proved in <ref> [4] </ref>: - 8 M 2 fl [f j 9 B [B ` M :]g 2 F ]. <p> The method followed in <ref> [4] </ref> was to define a simple type interpretation on the filter lambda model and to use it for the proof of completeness. The main result of that paper was obtained by proving: Property 8 [4]. 1. Soundness. B ` M : ) B ` ` M :. 2. Completeness. <p> The method followed in <ref> [4] </ref> was to define a simple type interpretation on the filter lambda model and to use it for the proof of completeness. The main result of that paper was obtained by proving: Property 8 [4]. 1. Soundness. B ` M : ) B ` ` M :. 2. Completeness. B ` ` M : ) B ` M :. Since the type interpretation is simple, the results of [4] in fact show that type assignment in the BCD-system is complete with respect to simple type <p> The main result of that paper was obtained by proving: Property 8 <ref> [4] </ref>. 1. Soundness. B ` M : ) B ` ` M :. 2. Completeness. B ` ` M : ) B ` M :. Since the type interpretation is simple, the results of [4] in fact show that type assignment in the BCD-system is complete with respect to simple type semantics. (Type assignment in the strict system as presented in [1] was proven in that paper to be complete with respect to the inference semantics.) 2 Essential type assignment for the lambda calculus In <p> (Type assignment in the strict system as presented in [1] was proven in that paper to be complete with respect to the inference semantics.) 2 Essential type assignment for the lambda calculus In this section we present the Essential Type Assignment System, a restricted version of the system presented in <ref> [4] </ref>. Compared to the BCD-system, the major feature of this system is a restricted version of the derivation rules, as well as a restriction of the set of types. <p> that was presented in [1]; the main difference is that that systems is not closed for - reduction, whereas the system presented here is. 2.1 Essential type assignment Strict types are the types that are strictly needed to assign a type to a term in the system as presented in <ref> [4] </ref> (see also [1]). In the set of strict types intersection type schemes and the type constant ! play a limited role. <p> For this essential system, it is possible to prove completeness of type assignment with respect to the simple type semantics the same way as done in <ref> [4] </ref>. Since such a proof would be obtained in exactly the same way as in [4], we will not present it here. Instead, we will prove a completeness result using results proven in [9]. <p> For this essential system, it is possible to prove completeness of type assignment with respect to the simple type semantics the same way as done in <ref> [4] </ref>. Since such a proof would be obtained in exactly the same way as in [4], we will not present it here. Instead, we will prove a completeness result using results proven in [9]. In that paper, some restrictions of the BCD-system were investigated, and one of them proved to be essentially the same as the BCD-system. Definition 21 [9]. 1.
Reference: [5] <author> Coppo M., M. Dezani-Ciancaglini, and B. Venneri. </author> <title> Functional characters of solvable terms. </title> <journal> Zeitschrift fur Mathematische Logik und Grundlagen der Mathematik, </journal> <volume> 27 </volume> <pages> 45-58, </pages> <year> 1981. </year>
Reference-contexts: In Curry's system it is, for example, not possible to assign a type to the term (x:xx); moreover, although the lambda terms (cd:d) and ((xyz:xz (yz))(ab:a)) are fi-equal, the principal type schemes for these terms are different. The Intersection Type Discipline as presented in <ref> [5] </ref> (a more enhanced system was presented in [4]) is an extension of Curry's system that does not have these drawbacks. The extension being made consists mainly of allowing for term variables (and terms) to have more than one type. <p> Because of this power, in the intersection system (and even in the system that does not contain !) type assignment is undecidable. The type assignment system presented in [4] (the BCD-system) is based on the system as presented in <ref> [5] </ref>; it defines the set of intersection types T in a more general way, and is strengthened further by introducing a partial order relation `' on types as well as adding the type assignment rule () and a more general form of the rules concerning intersection.
Reference: [6] <author> Curry H.B. and R. </author> <title> Feys. </title> <booktitle> Combinatory Logic. </booktitle> <volume> volume 1. </volume> <publisher> North-Holland, </publisher> <address> Amster-dam, </address> <year> 1958. </year>
Reference-contexts: Introduction In the recent years several notions of type assignment for several (extended) lambda calculi have been studied. The oldest among these is the well understood and well defined notion of type assignment on lambda terms, known as the Curry Type Assignment System <ref> [6] </ref> which expresses abstraction and application. It is well known that in that system, the problem of typeability Given a term M , are there basis B and type such that B ` M : is decidable.
Reference: [7] <author> Dezani-Ciancaglini M. and I. Margaria. </author> <title> A characterisation of F-complete type assignments. </title> <journal> Theoretical Computer Science, </journal> <volume> 45 </volume> <pages> 121-157, </pages> <year> 1986. </year>
Reference-contexts: Then &lt;F , , [[ ]] &gt; is a -model. In constructing a complete system, the semantics of types plays a crucial role. As in <ref> [7] </ref>, [12] and essentially following [9], a distinction can be made between several notions of type interpretations and semantic satisfiability. There are, roughly, three notions of type semantics that differ in the meaning of an arrow type scheme: inference-, simple-, and F type interpretations.
Reference: [8] <author> Hindley J.R. </author> <title> The principal type scheme of an object in combinatory logic. </title> <journal> Transactions of the American Mathematical Society, </journal> <volume> 146 </volume> <pages> 29-60, </pages> <year> 1969. </year>
Reference-contexts: The type is then called a `principal type for M '. For Curry's system the operation O consists entirely of substitutions, i.e. operations that replace type-variables by types. Principal type schemes for Curry's system were defined in <ref> [8] </ref>. Since substitution is an easy operation, the set f&lt;B, &gt; j B ` M :g can be computed in Curry's system easily from the principal pair for M . In [13] was shown that the BCD-system has the principal type property.
Reference: [9] <author> Hindley J.R. </author> <title> The simple semantics for Coppo-Dezani-Salle type assignment. </title> <editor> In M. Dezani and U. Montanari, editors, </editor> <booktitle> International symposium on programming, volume 137 of Lecture Notes in Computer Science, </booktitle> <pages> pages 212-226. </pages> <publisher> Springer-Verlag, </publisher> <year> 1982. </year>
Reference-contexts: We will compare the notion of type assignment presented in this paper with the one defined in <ref> [9] </ref>; the set of derivable statements of these two systems will turn out to be exactly the same. <p> Then &lt;F , , [[ ]] &gt; is a -model. In constructing a complete system, the semantics of types plays a crucial role. As in [7], [12] and essentially following <ref> [9] </ref>, a distinction can be made between several notions of type interpretations and semantic satisfiability. There are, roughly, three notions of type semantics that differ in the meaning of an arrow type scheme: inference-, simple-, and F type interpretations. <p> The proof is based on the fact that for every 2 T there is a fl 2 T S such that ~ fl , and an approximation theorem. Property 17 <ref> [9, 1] </ref>. For every 2 T there is a fl 2 T S such that ~ fl . <p> Since such a proof would be obtained in exactly the same way as in [4], we will not present it here. Instead, we will prove a completeness result using results proven in <ref> [9] </ref>. In that paper, some restrictions of the BCD-system were investigated, and one of them proved to be essentially the same as the BCD-system. Definition 21 [9]. 1. <p> Instead, we will prove a completeness result using results proven in <ref> [9] </ref>. In that paper, some restrictions of the BCD-system were investigated, and one of them proved to be essentially the same as the BCD-system. Definition 21 [9]. 1. <p> It is straightforward to show that T N = T S , and N = E . Proposition 22 (cf. <ref> [9] </ref>). 1. If , t 2 T S , then t () E t . 2. Let fl be defined as in property 17. B ` M : () B fl ` N M : fl . Theorem 23. Conservativity.
Reference: [10] <author> Hindley J.R. </author> <title> The Completeness Theorem for Typing -terms. </title> <journal> Theoretical Computer Science, </journal> <volume> 22(1) </volume> <pages> 1-17, </pages> <year> 1983. </year>
Reference-contexts: The main result of that paper is that, using this model, completeness is proved by proving the statement: ` M : () [[ M ]] 2 (), where : T ! F is a simple type interpretation as defined in <ref> [10] </ref>. In order to prove the (-part of this statement (completeness), the relation is needed. The BCD-system has the principal type property, as was shown in [13]; the set of operations needed for this system consists of substitutions, expansions, and rises.
Reference: [11] <author> Hindley R. and G. Longo. </author> <title> Lambda calculus models and extensionality. </title> <journal> Zeitschrift fur Mathematische Logik und Grundlagen der Mathematik, </journal> <volume> 26 </volume> <pages> 289-310, </pages> <year> 1980. </year>
Reference: [12] <author> Mitchell J.C. </author> <title> Polymorphic Type Inference and Containment. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 211-249, </pages> <year> 1988. </year>
Reference-contexts: Then &lt;F , , [[ ]] &gt; is a -model. In constructing a complete system, the semantics of types plays a crucial role. As in [7], <ref> [12] </ref> and essentially following [9], a distinction can be made between several notions of type interpretations and semantic satisfiability. There are, roughly, three notions of type semantics that differ in the meaning of an arrow type scheme: inference-, simple-, and F type interpretations.
Reference: [13] <author> Ronchi della Rocca S. and B. Venneri. </author> <title> Principal type schemes for an extended type theory. </title> <journal> Theoretical Computer Science, </journal> <volume> 28 </volume> <pages> 151-169, </pages> <year> 1984. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: In order to prove the (-part of this statement (completeness), the relation is needed. The BCD-system has the principal type property, as was shown in <ref> [13] </ref>; the set of operations needed for this system consists of substitutions, expansions, and rises. A disadvantage of the BCD-system is that it is too general: in this system there are several ways to deduce a desired result, due to the presence of the derivation rules ("I), ("E) and (). <p> Equivalence classes are big (for example: ! ~ !!, for all types ) and type assignment is closed for ~ . And although the set f&lt;B, &gt; j B ` M :g can be generated using the three operations specified in <ref> [13] </ref>, the problem Given a term M and type , is there a B such that B ` M :? is complicated. <p> The relation between types assignable to a lambda term and those assignable to its approximants is formulated by the following: Property 4 <ref> [13] </ref>. B ` M : () 9 A 2 A (M ) [B ` A:]. The main result of [4] is the proof for completeness of type assignment. <p> Principal type schemes for Curry's system were defined in [8]. Since substitution is an easy operation, the set f&lt;B, &gt; j B ` M :g can be computed in Curry's system easily from the principal pair for M . In <ref> [13] </ref> was shown that the BCD-system has the principal type property. This was achieved in that paper by defining a principal pair consisting of basis and type for terms in N . <p> S (B) = fx:S (ff) j x:ff 2 B & S (ff) 6 !g. The operation of expansion is an operation on types that corresponds to notions of expansion as defined in <ref> [13] </ref>. It is an operation on types, that deals with the replacement of (sub)types by an intersection of a number of copies of that type. In this process it can be that also other types need to be copied. <p> Moreover, all three operations can be proven to be sound on all pairs. The technique needed for these proofs can be found in <ref> [13] </ref> and [2]; because of the direct similarities with especially the proofs in the latter paper, proofs will be omitted here. Theorem 32. Let A 2 N , &lt;B, &gt; be such that B ` E A:, and let O be an operation of substitution, expansion or rise. <p> Theorem 32. Let A 2 N , &lt;B, &gt; be such that B ` E A:, and let O be an operation of substitution, expansion or rise. Then O (B) ` E A:O (). Definition 33 (cf. <ref> [13, 2] </ref>). 1. Linear chains of operations are defined as chains that start with a number of expansions, followed by a substitution, and that end with a lifting. 2. Let M be a term.
References-found: 13

