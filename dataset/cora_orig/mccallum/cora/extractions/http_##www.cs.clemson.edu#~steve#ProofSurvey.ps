URL: http://www.cs.clemson.edu/~steve/ProofSurvey.ps
Refering-URL: http://www.cs.clemson.edu/~steve/resint.html
Root-URL: http://www.cs.clemson.edu
Title: Software Engineering: A Practitioners Approach, New York: McGraw-Hill, 1982. Theory of Recursive Functions and Effective
Author: Pressman, Roger S., . Rogers, Hartley, Jr., . Scott, D. S., 
Note: Preprint for Philosophy and Computers Press, 1974. 49.  Outline of a Mathematical Theory of Computation, in Proc. of 4 th Ann. Prin  
Abstract: Page 22 46. Popper, Karl R., Conjectures and Refutations, New York: Basic Books, Inc. 1965. 47. Popper, Karl R., Logic of Scientific Discovery, New York: Basic Books, Inc. 1959. 48. Popper, Karl R., Objective Knowledge: An Evolutionary Approach, Oxford: Clarendon ceton Conf. on Info. Sci. and Systems, Princeton: Princeton Uni. Press. 1970. pp 169176. 52. Spivey, J. M., The Z Notation: A Reference Manual, New York: Prentice-Hall, 1989. 53. Suppe, F., The Structure of Scientific Theories, Urbana, IL: University of Illinois Press, 1977. 54. Suppes, Patrick, Introduction to Logic, New York: Van Nostrand Reinhold Company, 1957. 55. Turner, A. J., private communications, July 24, 1990. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <editor> ACM, </editor> <title> Scaling Up: A Research Agenda for Software Engineering, Comm. </title> <editor> A. C. M.,33(3), </editor> <month> March, </month> <year> 1990, </year> <pages> pp 281293. </pages>
Reference: 2. <author> Barker, Stephen F., </author> <booktitle> Philosophy of Mathematics, in Foundations of Philosophy series, </booktitle> <editor> (Elize-beth and Monroe Beardsley, editors), </editor> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice-Hall, </publisher> <year> 1964. </year>
Reference: 3. <author> Barringer, Howard, </author> <title> A Survey of Verification Techniques for Parallel Programs, </title> <address> New York: </address> <note> Springer-Verlag. Lecture Notes in Computer Science, 191. </note>
Reference: 4. <author> Barwise, Jon, </author> <title> Mathematical Proofs of Computer System Correctness, </title> <journal> Notices of Amer. Math. </journal> <volume> Soc.,36, </volume> <year> 1989. </year> <pages> pp 844851. </pages> <note> See also 37(2), </note> <month> Feb, </month> <year> 1990, </year> <title> p 124. </title>
Reference: 1. <editor> Proponents of functional programming tout the correctness properties are easy to establish due to the functional paradigm. </editor> <title> Preprint for Philosophy and Computers Page 18 there are oracles (programmers) who must develop programs without controls. There are two ways in which specification can be useful: </title>
Reference: 1. <editor> If the specification is significantly shorter/simpler than the implementation. </editor> <title> If this is the case, then the specification is much easier to comprehend as a whole than the program, and it is easier to tell whether the specification captured the problem than it is to tell if the implementation solves it. Mathematical programs, because of the formal nature of their subject matter, often admit to succinct specifications. </title>



Reference: 1. <institution> One needs to be careful as to the definition of applied mathematics. </institution> <note> For this work, consider applied mathematics as the use of mathematics to investigate models. Hence, it is seen as a subject and not a title. </note>



Reference: 1. <editor> There is a dearth of models to choose from as far as the proof itself goes. </editor> <title> For example, in mathematics there are certain more or less standard approaches one takes based on the class of theorem or function. </title>
Reference: 2. <editor> There are few informal techniques. </editor> <title> Closely coupled with this is the difficulty in formulating the pre or post-conditions, invariants, or assertions (depending of ones approach). The lack of heuristics is seen as a deterrent. </title>
Reference: 3. <editor> Along with technique complaints, </editor> <title> there were complaints about the difficulty in dealing with semantics of implemented languages. In particular, the difficulty of dealing with side effects was cited. </title>

Reference: 1. <institution> Questions of algorithmic thinking versus mathematical thinking is an open area. </institution> <note> See, for example, [35]. </note>

Reference: 1. <editor> One group is able to understand and use pre and post conditions and loop invariants. </editor> <title> This is a rather small group, about 20% of those who pass the course. All in this group pass the course easily. </title>
Reference: 2. <editor> One group is able to understand and use pre and post conditions reasonably well. </editor> <title> Almost all of those pass the course. </title>

Reference: 1. <institution> Complexity of the program. </institution> <note> The proof is seen (by respondents) as exponential in length. </note>
Reference: 2. <institution> Proofs more complex by almost any measure than programming. </institution>
Reference: 3. <institution> Combinatorial complexity of proof of cases. </institution>
Reference: 4. <institution> Combinatorial complexity of interactions. </institution>
Reference: 5. <institution> Combinatorial complexity of input cases. </institution>

Reference: 3. <editor> Programming in the Real World The survey is discussed in this and the next sections. </editor> <title> In this section, we attempt to categorize the results of the survey into subject areas meaningful to computer scientists. Section 4 explores issues raised by the programmers responding to the posted query. The attempt to classify responses was not altogether successful. The author has attempted to put the comments into categories which most represented the thrust of the comments. These were essentially </title>
Reference: 1. <institution> Economic Realities, </institution>
Reference: 2. <institution> Software Engineering, </institution>
Reference: 3. <institution> Psychological and Educational, </institution>
Reference: 4. <institution> Programming Language Arguments, and </institution>

Reference: 1. <author> Time. </author> <title> The major component of the time axis is complexity in one form or another. The usual ideas of complexity apply: namely the number of lines of code. However, there are other issues such as the complexity of interactions which is closely related to specifications. </title>
Reference: 2. <author> Quality. </author> <title> Three major themes affect quality: the specifications; implementation system, including language; and the development environment. These are covered in their own sections. </title>
Reference: 3. <author> People. </author> <title> The dominant factors on this axis are the psychological and educational elements. </title>



Reference: 1. <institution> A short history of program verification is presented. </institution> <note> This history traces a debate which began in 1979 and continues to the present. This serves as a prologue for a survey of programming professionals and academics. </note>
Reference: 2. <editor> The survey was conducted by asking a question of certain newsgroups on USENET. </editor> <title> The responses were categorized to try to discover various impediments to program verification activities. The report is largely anecdotal and presented without comment. </title>
Reference: 3. <author> Finally, </author> <title> a short discussion of the surveys points is presented. We close with some directions that new philosophical investigations might take. </title>
Reference: 1. <institution> For the rules relating to quotes contained herein, </institution> <note> see page 2. </note>
References-found: 30

