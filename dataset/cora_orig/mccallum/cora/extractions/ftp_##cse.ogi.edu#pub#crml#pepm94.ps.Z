URL: ftp://cse.ogi.edu/pub/crml/pepm94.ps.Z
Refering-URL: http://www.cse.ogi.edu/PacSoft/publications/bibliograph.html
Root-URL: http://www.cse.ogi.edu
Email: ffegaras,sheard,tzhoug@cse.ogi.edu  
Title: Improving Programs which Recurse over Multiple Inductive Structures  
Author: Leonidas Fegaras Tim Sheard Tong Zhou 
Address: 20000 N.W. Walker Road P.O. Box 91000 Portland, OR 97291-1000  
Affiliation: Department of Computer Science and Engineering Oregon Graduate Institute of Science Technology  
Abstract: This paper considers generic recursion schemes for programs which recurse over multiple inductive structures simultaneously, such as equality, zip and the nth element of a list function. Such schemes have been notably absent from previous work. This paper defines a uniform mechanism for defining such programs and shows that these programs satisfy generic theorems. These theorems are the basis for an automatic improvement algorithm. This algorithm is an improvement over the algorithm presented earlier [14] because, in addition to inducting over multiple structures, it can be incorporated into any algebraic language and is no longer restricted to a "safe" subset. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Bird and O. deMoor. </author> <title> Solving Optimisation Problems with Catamorphisms. </title> <booktitle> In Mathematics of Program Construction, </booktitle> <pages> pp 45-66. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1992. </year> <note> LNCS 669. </note>
Reference-contexts: This can be achieved effectively by applying promotion theorems. Our stereotyped recursion schemes as well as the promotion theorems are highly influenced by the Squiggol school of program construction <ref> [12, 13, 11, 1] </ref>.
Reference: [2] <author> W. Chin. </author> <title> Safe Fusion of Functional Expressions. </title> <booktitle> Proceedings of the ACM Symposium on Lisp and Functional Programming, </booktitle> <address> San Francisco, California, </address> <pages> pp 11-20, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: For simple inductions our work is closely related to Wadler's work on listlessness and deforestation [17, 7, 16] and to Chin's work on fusion <ref> [2] </ref>. Deforestation works on all first order treeless terms. A treeless term is one which is exactly analogous to a safe term, but is described in a much different manner due to the lack of structure imposed on such terms.
Reference: [3] <author> R. Cockett and T. Fukushima. </author> <title> About Charity. </title> <type> Technical report, </type> <institution> Department of Computer Science, the University of Calgary, Alberta, Canada, </institution> <month> June </month> <year> 1992. </year> <note> Research Report No. 92/480/18. </note>
Reference-contexts: Languages which allow arbitrary recursive programs lack the structure necessary for automatic optimization. Much recent research has focused on the design of programming systems whose control structures are exclusively some generic recursion schemes <ref> [3, 9, 10] </ref>. We call this programming style algebraic programming because of its reliance on algebras and combinators for encoding control. Notable absent from these works are generic recursion schemes for inducting over multiple structures.
Reference: [4] <author> L. Fegaras. </author> <title> Efficient Optimization of Iterative Queries. </title> <booktitle> In Fourth International Workshop on Database Programming Languages, </booktitle> <address> Manhattan, New York City, </address> <pages> pp 200-225. </pages> <note> Springer-Verlag, Workshops on Computing, </note> <month> August </month> <year> 1993. </year>
Reference-contexts: 1 Introduction In previous work <ref> [14, 15, 6, 4, 5] </ref> we have shown how programming algebraically with generic recursion schemes provides a theory amenable to program calculation [13]. This theory provides a basis for automatic optimization techniques which capture many well-known transformations. <p> That is, the term g (f c (a; r)) must be transformed into a form T (g (r)), for some term T that depends on g (r) but not on r. Such work was previously reported in <ref> [14, 6, 5, 4] </ref> where this transformation is achieved by the generalization phase of the normalization algorithm.
Reference: [5] <author> L. Fegaras. </author> <title> A Transformational Approach to Database System Implementation. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Massachusetts, Amherst, </institution> <month> February </month> <year> 1993. </year> <note> Also appeared as CMPSCI Technical Report 92-68. </note>
Reference-contexts: 1 Introduction In previous work <ref> [14, 15, 6, 4, 5] </ref> we have shown how programming algebraically with generic recursion schemes provides a theory amenable to program calculation [13]. This theory provides a basis for automatic optimization techniques which capture many well-known transformations. <p> That is, the term g (f c (a; r)) must be transformed into a form T (g (r)), for some term T that depends on g (r) but not on r. Such work was previously reported in <ref> [14, 6, 5, 4] </ref> where this transformation is achieved by the generalization phase of the normalization algorithm.
Reference: [6] <author> L. Fegaras, T. Sheard, and D. Stemple. </author> <title> Uniform Traversal Combinators: Definition, Use and Properties. </title> <booktitle> In Proceedings of the 11th International Conference on Automated Deduction (CADE-11), </booktitle> <address> Saratoga Springs, 11 New York, </address> <pages> pp 148-162. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1992. </year> <note> LNCS 607. </note>
Reference-contexts: 1 Introduction In previous work <ref> [14, 15, 6, 4, 5] </ref> we have shown how programming algebraically with generic recursion schemes provides a theory amenable to program calculation [13]. This theory provides a basis for automatic optimization techniques which capture many well-known transformations. <p> This is an important step towards an automatic optimization phase in compilers of algebraic programs. Second we extend our earlier work <ref> [14, 6] </ref> by embedding our optimizations in a richer language. Our previous work To appear in ACM SIGPLAN Workshop on Partial Evaluation and Semantics-Based Program Manipulation, Orlando, Florida, June 1994. focused on a restricted language which has now been extended to include many features of a modern functional programming language. <p> Third we describe an improved algorithm for computing our optimizations. The improved algorithm works over the entire extended language while the original algorithm worked only on a syntactically identifiable subset of the restricted language. In addition the improved algorithm requires no explicit memoization phase (what we called generalization in <ref> [14, 6] </ref>.) 1.1 Goals Recursion is the Goto of functional programming. Languages which allow arbitrary recursive programs lack the structure necessary for automatic optimization. Much recent research has focused on the design of programming systems whose control structures are exclusively some generic recursion schemes [3, 9, 10]. <p> That is, the term g (f c (a; r)) must be transformed into a form T (g (r)), for some term T that depends on g (r) but not on r. Such work was previously reported in <ref> [14, 6, 5, 4] </ref> where this transformation is achieved by the generalization phase of the normalization algorithm.
Reference: [7] <author> A. Ferguson and P. Wadler. </author> <title> When will Deforestation Stop. </title> <booktitle> In Proceedings of 1988 Glasgow Workshop on Functional Programming, Rothesay, Isle of Bute, </booktitle> <pages> pp 39-56, </pages> <month> August </month> <year> 1988. </year> <note> Also as research report 89/R4 of Glasgow University. </note>
Reference-contexts: For simple inductions our work is closely related to Wadler's work on listlessness and deforestation <ref> [17, 7, 16] </ref> and to Chin's work on fusion [2]. Deforestation works on all first order treeless terms. A treeless term is one which is exactly analogous to a safe term, but is described in a much different manner due to the lack of structure imposed on such terms.
Reference: [8] <author> A. Gill, J. Launchbury, and S. Peyton Jones. </author> <title> A Short Cut to Deforestation. </title> <booktitle> Sixth Conference on Functional Programming Languages and Computer Architecture, Copenhagen, Denmark, </booktitle> <pages> pp 223-232, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Those not removed are recognizable and are simply skipped over in the improvement phase. The application domain of our fusion algorithm is more restricted than the domain of all these methods, but our algorithm is more effective since it is fully automated. In <ref> [8] </ref> a new, simple, but very effective, automatic technique is presented for implementing deforestation in a compiler. This method requires that each list-producing functions is expressed as a build call and each list-consuming functions is expressed as a foldr call.
Reference: [9] <author> T. Hagino. </author> <title> A Categorical Programming Language. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1987. </year>
Reference-contexts: Languages which allow arbitrary recursive programs lack the structure necessary for automatic optimization. Much recent research has focused on the design of programming systems whose control structures are exclusively some generic recursion schemes <ref> [3, 9, 10] </ref>. We call this programming style algebraic programming because of its reliance on algebras and combinators for encoding control. Notable absent from these works are generic recursion schemes for inducting over multiple structures.
Reference: [10] <author> R. Kieburtz and J. Lewis. </author> <title> Algebraic Design Language (Preliminary Definition). </title> <type> Technical Report #94-002, </type> <institution> Oregon Graduate Institute, </institution> <year> 1994. </year>
Reference-contexts: Languages which allow arbitrary recursive programs lack the structure necessary for automatic optimization. Much recent research has focused on the design of programming systems whose control structures are exclusively some generic recursion schemes <ref> [3, 9, 10] </ref>. We call this programming style algebraic programming because of its reliance on algebras and combinators for encoding control. Notable absent from these works are generic recursion schemes for inducting over multiple structures.
Reference: [11] <author> G. Malcolm. </author> <title> Data Structures and Program Transformation. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 14 </volume> <pages> 255-279, </pages> <year> 1990. </year>
Reference-contexts: This can be achieved effectively by applying promotion theorems. Our stereotyped recursion schemes as well as the promotion theorems are highly influenced by the Squiggol school of program construction <ref> [12, 13, 11, 1] </ref>.
Reference: [12] <author> G. Malcolm. </author> <title> Homomorphisms and Promotability. </title> <booktitle> In Mathematics of Program Construction, </booktitle> <pages> pp 335-347. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1989. </year> <note> LNCS 375. </note>
Reference-contexts: list (f n ; f c ) (Cons (a; l)) = f c (a; red list (f n ; f c ) l) For example, length (x) = red list (():Zero; (a; r):Succ (r)) x For each such inductive data type there is a generic theorem called the promotion theorem <ref> [12, 13] </ref>. <p> This can be achieved effectively by applying promotion theorems. Our stereotyped recursion schemes as well as the promotion theorems are highly influenced by the Squiggol school of program construction <ref> [12, 13, 11, 1] </ref>.
Reference: [13] <author> E. Meijer, M. Fokkinga, and R. Paterson. </author> <title> Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire. </title> <booktitle> In Proceedings of the 5th ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Cambridge, Massachusetts, </address> <pages> pp 124-144, </pages> <month> August </month> <year> 1991. </year> <note> LNCS 523. </note>
Reference-contexts: 1 Introduction In previous work [14, 15, 6, 4, 5] we have shown how programming algebraically with generic recursion schemes provides a theory amenable to program calculation <ref> [13] </ref>. This theory provides a basis for automatic optimization techniques which capture many well-known transformations. <p> list (f n ; f c ) (Cons (a; l)) = f c (a; red list (f n ; f c ) l) For example, length (x) = red list (():Zero; (a; r):Succ (r)) x For each such inductive data type there is a generic theorem called the promotion theorem <ref> [12, 13] </ref>. <p> The foldr operator is similar to our list reduction while the build operator is a dual-like function of foldr (this technique is an automation of the Hy-loSplit theorem of Meijer et al. <ref> [13] </ref>). The technique simply fuses adjacent foldr-build pairs by eliminating them completely ((foldr f ) ffi (build g) = g ffi f ). We believe that this method could be more effective if folds are promoted downwards or builds are promoted upwards in a term until they fuse. <p> This can be achieved effectively by applying promotion theorems. Our stereotyped recursion schemes as well as the promotion theorems are highly influenced by the Squiggol school of program construction <ref> [12, 13, 11, 1] </ref>.
Reference: [14] <author> T. Sheard and L. Fegaras. </author> <title> A Fold for All Seasons. </title> <booktitle> Sixth Conference on Functional Programming Languages and Computer Architecture, Copenhagen, Denmark, </booktitle> <pages> pp 233-242, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Introduction In previous work <ref> [14, 15, 6, 4, 5] </ref> we have shown how programming algebraically with generic recursion schemes provides a theory amenable to program calculation [13]. This theory provides a basis for automatic optimization techniques which capture many well-known transformations. <p> This is an important step towards an automatic optimization phase in compilers of algebraic programs. Second we extend our earlier work <ref> [14, 6] </ref> by embedding our optimizations in a richer language. Our previous work To appear in ACM SIGPLAN Workshop on Partial Evaluation and Semantics-Based Program Manipulation, Orlando, Florida, June 1994. focused on a restricted language which has now been extended to include many features of a modern functional programming language. <p> Third we describe an improved algorithm for computing our optimizations. The improved algorithm works over the entire extended language while the original algorithm worked only on a syntactically identifiable subset of the restricted language. In addition the improved algorithm requires no explicit memoization phase (what we called generalization in <ref> [14, 6] </ref>.) 1.1 Goals Recursion is the Goto of functional programming. Languages which allow arbitrary recursive programs lack the structure necessary for automatic optimization. Much recent research has focused on the design of programming systems whose control structures are exclusively some generic recursion schemes [3, 9, 10]. <p> That is, the term g (f c (a; r)) must be transformed into a form T (g (r)), for some term T that depends on g (r) but not on r. Such work was previously reported in <ref> [14, 6, 5, 4] </ref> where this transformation is achieved by the generalization phase of the normalization algorithm. <p> (f )) by Property 3 = c ffi E t Thus, by Definition 9, is equal to red t (). 2 If t is the simple inductive type T , then the unary promotion theorem is identical to the simple promotion theorem for simple reductions, as it is described in <ref> [14] </ref>.
Reference: [15] <author> T. Sheard and L. Fegaras. </author> <title> Optimizing Algebraic Programs. </title> <institution> Oregon Graduate Institute, </institution> <note> Technical report #94-004 A version of this paper is ftp-able from cse.ogi.edu:/pub/pacsoft/papers/OptAlgProg.ps. </note>
Reference-contexts: 1 Introduction In previous work <ref> [14, 15, 6, 4, 5] </ref> we have shown how programming algebraically with generic recursion schemes provides a theory amenable to program calculation [13]. This theory provides a basis for automatic optimization techniques which capture many well-known transformations. <p> The only mechanisms we have to prove this are the promotion theorems. We will not present the detailed proof here. Instead we will present a sketch of the proof. The detailed correctness proof for the normalization algorithm which includes only the simple promotion theorem can be found elsewhere <ref> [15] </ref>. Theorem 3 (Correctness of Normalization) The normalization algorithm always preserves the meaning of a term. Proof sketch: All the transformation rules of the normalization algorithm can be easily proved to preserve the meaning of a term, except for the two promotion laws. We consider the unary promotion phase first. <p> Programs containing such simple forms of second-order reductions can be normalized by using a promotion theorem similar to the one for first-order reductions <ref> [15] </ref>. 7 Related Work To our knowledge no other work deals with generic recursion schemes over multiple structures. For simple inductions our work is closely related to Wadler's work on listlessness and deforestation [17, 7, 16] and to Chin's work on fusion [2].
Reference: [16] <author> P. Wadler. </author> <title> Listlessness is Better than Laziness: Lazy Evaluation and Garbage Collection at Compile-time. </title> <booktitle> In Proceedings of the ACM Symposium on Lisp and Functional Programming, </booktitle> <address> Austin, Texas, </address> <month> August </month> <year> 1984. </year>
Reference-contexts: For simple inductions our work is closely related to Wadler's work on listlessness and deforestation <ref> [17, 7, 16] </ref> and to Chin's work on fusion [2]. Deforestation works on all first order treeless terms. A treeless term is one which is exactly analogous to a safe term, but is described in a much different manner due to the lack of structure imposed on such terms.
Reference: [17] <author> P. Wadler. </author> <title> Deforestation: Transforming Programs to Eliminate Trees. </title> <booktitle> Proceedings of the 2nd European Symposium on Programming, Nancy, France, </booktitle> <pages> pp 344-358, </pages> <month> March </month> <year> 1988. </year> <note> LNCS 300. 12 </note>
Reference-contexts: For simple inductions our work is closely related to Wadler's work on listlessness and deforestation <ref> [17, 7, 16] </ref> and to Chin's work on fusion [2]. Deforestation works on all first order treeless terms. A treeless term is one which is exactly analogous to a safe term, but is described in a much different manner due to the lack of structure imposed on such terms.
References-found: 17

