URL: http://www.cse.ogi.edu/DISC/projects/synthetix/sc_iwooos96.ps.gz
Refering-URL: http://www.cse.ogi.edu/DISC/projects/synthetix/publications.html
Root-URL: http://www.cse.ogi.edu
Email: (synthetix-request@cse.ogi.edu)  
Title: Specialization Classes: An Object Framework for Specialization  
Author: Crispin Cowan, Andrew Black, Charles Krasic, Calton Pu, and Jonathan Walpole Charles Consel and Eugen-Nicolae Volanschi 
Date: September 6, 1996  
Affiliation: Department of Computer Science and Engineering Oregon Graduate Institute of Science Technology  University of Rennes IRISA  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. Black, N. Hutchinson, E. Jul, H. Levy, and L. Carter. </author> <title> Distribution and Abstract Types in Emerald. </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 65-76, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Figure 1 illustrates specialization of a file system: the open file object FS, which understands the operations read () and write (), is said to be the target of the specialization. Following modern usage <ref> [1, 14] </ref>, we use the term type to refer to the interface exposed by an object and the term class to refer to the method code and the instance variables that implement that interface. 1 Hence, the type of the file describes the fact that it can be read and written;
Reference: [2] <author> R. H. Campbell, N. Islam, and P. Madany. </author> <title> Choices: Frameworks and Refinement. </title> <journal> Computing Systems, </journal> <volume> 5(3) </volume> <pages> 217-257, </pages> <year> 1992. </year>
Reference-contexts: In particular, Choices <ref> [2, 11] </ref>, AL-1/D [15], and Apertos [18] have investigated ways in which object-orientation can be used for OS re-configuration. Kiczales has been exploring the general question of how objects can be used as a meta-interface [13]. OS customization has also been studied outside the OO community.
Reference: [3] <author> C. Chambers. </author> <title> Predicate Classes. </title> <booktitle> In Proceedings of the European Conference on Object-Oriented Programming (ECOOP'93), </booktitle> <address> Kaiserstautern, Germany, </address> <month> July </month> <year> 1993. </year>
Reference-contexts: The Aegis project provides more customizability by placing most OS functionality in a user-level library attached to user applications [10]. We discuss some of these approaches in [9]. At the language level, specialization classes are similar to Chambers' predicate classes <ref> [3] </ref>, which allow, for example, the class of a buffer object to depend on whether the buffer is full, partially-full, or empty. <p> Specialization classes can be thought of as an implementation of predicate classes in which guarding is used to change the class of an object in response to independent, concurrent events; this idea is hinted at in reference <ref> [3] </ref>, but was not fully worked out or implemented. Specialization classes can also be applied to systems written in a language such as C, in which the objects are more conceptual than real. Specialization plans are similar to the Aster distributed application configuration language [12].
Reference: [4] <author> C. Consel and O. Danvy. </author> <title> Tutorial notes on partial evaluation. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 493-501, </pages> <year> 1993. </year>
Reference-contexts: If the complexity of the predicates is beyond the current capabilities of the partial evaluator, the programmer can still provide a hand-written implementation. We are using Tempo, a partial evaluator for C programs developed at IRISA, <ref> [5, 6, 4] </ref>. Given a program and part of its inputs, it generates a specialized version of the program in which all the computations depending on the known inputs are performed. Tempo processes a program in two phases.
Reference: [5] <author> C. Consel, L. Hornoff, J. Noye, F. Noel, and E.- N. Volanschi. </author> <title> A Uniform Approach for Compile-Time and Run-Time Specialization. </title> <booktitle> In International Workshop on Partial Evaluation, </booktitle> <address> Dagstuhl Castle, Germany, </address> <month> February </month> <year> 1996. </year> <note> Springer-Verlag LNCS. </note>
Reference-contexts: We thus use a formal method to specify when a specialization is valid. This lets us automatically detect when specialization circumstances have changed [8], and also automatically generate specialized implementations using partial evaluation <ref> [6, 5] </ref>. Section 2 describes our specialization model, which is applicable both in OO operating systems and in legacy kernels. Section 3 describes compilation techniques for this model. <p> Invariants can be used by partial evaluators to automatically prepare a specialized implementation that has been optimized using the invariants. Our use of invariants for specialization was originally inspired by the invariant input specification for Tempo <ref> [6, 5] </ref>, a powerful partial evaluator for C. Partial evaluation to exploit specialization gives us a formal relationship between the conditions and the optimized implementation. Partial evaluation is independent of whether a condition is an invariant or a quasi-invariant. <p> If the complexity of the predicates is beyond the current capabilities of the partial evaluator, the programmer can still provide a hand-written implementation. We are using Tempo, a partial evaluator for C programs developed at IRISA, <ref> [5, 6, 4] </ref>. Given a program and part of its inputs, it generates a specialized version of the program in which all the computations depending on the known inputs are performed. Tempo processes a program in two phases.
Reference: [6] <author> C. Consel and F. Noel. </author> <title> A general approach to run-time specialization and its application to C. </title> <booktitle> In 23rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL'96), </booktitle> <address> St. Petersburgh Beach, FL, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: We thus use a formal method to specify when a specialization is valid. This lets us automatically detect when specialization circumstances have changed [8], and also automatically generate specialized implementations using partial evaluation <ref> [6, 5] </ref>. Section 2 describes our specialization model, which is applicable both in OO operating systems and in legacy kernels. Section 3 describes compilation techniques for this model. <p> Invariants can be used by partial evaluators to automatically prepare a specialized implementation that has been optimized using the invariants. Our use of invariants for specialization was originally inspired by the invariant input specification for Tempo <ref> [6, 5] </ref>, a powerful partial evaluator for C. Partial evaluation to exploit specialization gives us a formal relationship between the conditions and the optimized implementation. Partial evaluation is independent of whether a condition is an invariant or a quasi-invariant. <p> If the complexity of the predicates is beyond the current capabilities of the partial evaluator, the programmer can still provide a hand-written implementation. We are using Tempo, a partial evaluator for C programs developed at IRISA, <ref> [5, 6, 4] </ref>. Given a program and part of its inputs, it generates a specialized version of the program in which all the computations depending on the known inputs are performed. Tempo processes a program in two phases.
Reference: [7] <author> C. Cowan, T. Autrey, C. Krasic, C. Pu, and J. Walpole. </author> <title> Fast Concurrent Dynamic Linking for an Adaptive Operating System. </title> <booktitle> In International Conference on Configurable Distributed Systems (IC-CDS'96), Annapolis, </booktitle> <address> MD, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: This replacement is called replugging, and requires fast, safe, concurrent dynamic linking. The problem is to facilitate very low latency execution of a function via an indirect function pointer, while concurrently allowing the pointer to be changed. Locks could be used, but locks may also substantially degrade performance. In <ref> [7] </ref>, we describe a portable algorithm that supports low-latency invocation of replaceable functions while allowing concurrent update of pointers to those functions. 3 Translation & Specialization Our previous efforts have manually applied our various specialization tools [7, 8, 16, 17]. <p> Locks could be used, but locks may also substantially degrade performance. In [7], we describe a portable algorithm that supports low-latency invocation of replaceable functions while allowing concurrent update of pointers to those functions. 3 Translation & Specialization Our previous efforts have manually applied our various specialization tools <ref> [7, 8, 16, 17] </ref>. Automatic translation of specialization plans should convert the high level specification of how to specialize the system into running code that integrates the various components. 3.1 Specialization Plans The specialization plan describes all possible ways in which the facility can be specialized.
Reference: [8] <author> C. Cowan, A. Black, C. Krasic, C. Pu, and J. Walpole. </author> <title> Automated Guarding Tools for Adaptive Operating Systems. </title> <booktitle> Work in progress, </booktitle> <month> December </month> <year> 1996. </year>
Reference-contexts: We thus use a formal method to specify when a specialization is valid. This lets us automatically detect when specialization circumstances have changed <ref> [8] </ref>, and also automatically generate specialized implementations using partial evaluation [6, 5]. Section 2 describes our specialization model, which is applicable both in OO operating systems and in legacy kernels. Section 3 describes compilation techniques for this model. <p> One is based on type-checking the kernel source code, and the other is based on fine-grained virtual memory protection. These techniques are discussed at length in <ref> [8] </ref>, but what they produce is a list of kernel source code statements that may violate quasi-invariant state. These writes to quasi-invariant state must be guarded. <p> Locks could be used, but locks may also substantially degrade performance. In [7], we describe a portable algorithm that supports low-latency invocation of replaceable functions while allowing concurrent update of pointers to those functions. 3 Translation & Specialization Our previous efforts have manually applied our various specialization tools <ref> [7, 8, 16, 17] </ref>. Automatic translation of specialization plans should convert the high level specification of how to specialize the system into running code that integrates the various components. 3.1 Specialization Plans The specialization plan describes all possible ways in which the facility can be specialized.
Reference: [9] <author> C. Cowan, J. Walpole, A. Black, J. Inouye, C. Pu, and S. Cen. </author> <title> Adaptable Operating Systems. </title> <editor> In R. Campbell and N. Islam, editors, </editor> <booktitle> Modern Operating Systems Research. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: The Aegis project provides more customizability by placing most OS functionality in a user-level library attached to user applications [10]. We discuss some of these approaches in <ref> [9] </ref>. At the language level, specialization classes are similar to Chambers' predicate classes [3], which allow, for example, the class of a buffer object to depend on whether the buffer is full, partially-full, or empty.
Reference: [10] <author> D. R. Engler, M. F. Kaashoek, and J. O. Jr. Ex-okernel: </author> <title> An Operating System Architecture for Application-level Resource Management. </title> <booktitle> In Symposium on Operating Systems Principles (SOSP), </booktitle> <address> Copper Mountain, Colorado, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: The Aegis project provides more customizability by placing most OS functionality in a user-level library attached to user applications <ref> [10] </ref>. We discuss some of these approaches in [9]. At the language level, specialization classes are similar to Chambers' predicate classes [3], which allow, for example, the class of a buffer object to depend on whether the buffer is full, partially-full, or empty.
Reference: [11] <author> A. Gopal, N. Islam, B.-H. Lim, and B. Mukher-jee. </author> <title> Structuring Operating Systems using Adaptive Objects for Improving Performance. </title> <booktitle> In Proceedings of the Fourth International Workshop on Object-Orientation in Operating Systems (IWOOOS '95), </booktitle> <pages> pages 130-133, </pages> <institution> Lund, Sweden, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: In particular, Choices <ref> [2, 11] </ref>, AL-1/D [15], and Apertos [18] have investigated ways in which object-orientation can be used for OS re-configuration. Kiczales has been exploring the general question of how objects can be used as a meta-interface [13]. OS customization has also been studied outside the OO community.
Reference: [12] <author> V. Issarny and C. Bidan. Aster: </author> <title> A Framework for Sound Customization of Distributed Runtime Systems. </title> <booktitle> In 16th International Conference on Distributed Computing Systems (ICDCS'96), </booktitle> <pages> pages 586-593, </pages> <address> Hong Kong, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: Specialization classes can also be applied to systems written in a language such as C, in which the objects are more conceptual than real. Specialization plans are similar to the Aster distributed application configuration language <ref> [12] </ref>. Aster operates at a higher level, using predicates that cannot be checked mechanically, but can be reasoned about mechanically. 5 Future Research We have proposed an object-oriented, mostly declarative model for specifying specializations in long-running programs such as operating systems.
Reference: [13] <author> G. Kiczales, J. des Rivieres, and D. G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: In particular, Choices [2, 11], AL-1/D [15], and Apertos [18] have investigated ways in which object-orientation can be used for OS re-configuration. Kiczales has been exploring the general question of how objects can be used as a meta-interface <ref> [13] </ref>. OS customization has also been studied outside the OO community. The SPIN project allows replacement OS components to be loaded into the kernel.
Reference: [14] <author> W. LaLonde and J. Pugh. </author> <title> Subclassing 6= subtyp-ing 6= is-a. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 3(5), </volume> <month> January </month> <year> 1991. </year>
Reference-contexts: Figure 1 illustrates specialization of a file system: the open file object FS, which understands the operations read () and write (), is said to be the target of the specialization. Following modern usage <ref> [1, 14] </ref>, we use the term type to refer to the interface exposed by an object and the term class to refer to the method code and the instance variables that implement that interface. 1 Hence, the type of the file describes the fact that it can be read and written;
Reference: [15] <author> H. Okamura, Y. Ishikawa, and M. Tokoro. </author> <month> AL-1/D: </month>
Reference-contexts: In particular, Choices [2, 11], AL-1/D <ref> [15] </ref>, and Apertos [18] have investigated ways in which object-orientation can be used for OS re-configuration. Kiczales has been exploring the general question of how objects can be used as a meta-interface [13]. OS customization has also been studied outside the OO community.
References-found: 15

