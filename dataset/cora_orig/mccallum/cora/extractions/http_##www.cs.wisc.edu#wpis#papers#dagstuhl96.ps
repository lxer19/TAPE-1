URL: http://www.cs.wisc.edu/wpis/papers/dagstuhl96.ps
Refering-URL: http://www.cs.wisc.edu/~reps/
Root-URL: 
Email: e-mail: -reps,turnidge-@cs.wisc.edu  
Title: Program Specialization via Program Slicing  
Author: Thomas Reps and Todd Turnidge 
Address: 1210 West Dayton Street, Madison, WI 53706 USA  
Affiliation: Computer Sciences Department, University of Wisconsin-Madison  
Abstract: This paper concerns the use of program slicing to perform a certain kind of program-specialization operation. We show that the specialization operation that slicing performs is different from the specialization operations performed by algorithms for partial evaluation, supercompilation, bifurcation, and deforestation. To study the relationship between slicing and these operations in a simplified setting, we consider the problem of slicing functional programs. We identify two different goals for what we mean by slicing a functional program and give algorithms that correspond to each of them.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Ballance, R.A., Maccabe, A.B., and Ottenstein, K.J., </author> <title> The program dependence web: A representation supporting control-, data-, and demand-driven interpretation of imperative languages, </title> <booktitle> Proceedings of the ACM SIGPLAN 90 Conference on Programming Language Design and Implementation, </booktitle> <address> (White Plains, NY, </address> <month> June 20-22, </month> <year> 1990), </year> <journal> ACM SIG-PLAN Notices 25(6) pp. </journal> <month> 257-271 (June </month> <year> 1990). </year>
Reference-contexts: Consequently, in this framework the semantics of a slice approximates the semantics of the full program. (Other approaches to lazy semantics for program dependence graphs include [35], [4], and <ref> [1] </ref>.) ` For readers who are uncomfortable with the semantic anomaly that a slice does not preserve the termination behavior of the original program, we would like to point out that this situation is far more acceptable than the semantic anomaly exhibited by partial evaluation, where, due to the well-known problems
Reference: 2. <author> Bates, S. and Horwitz, S., </author> <title> Incremental program testing using program dependence graphs, pp. </title> <booktitle> 384-396 in Conference Record of the Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Charleston, SC, </address> <month> January 10-13, </month> <year> 1993), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1993). </address>
Reference-contexts: For example, a C program and one of its backward slices is shown in Figure 1. Slicingand subsequent manipulation of slicesshows great promise for helping with many software-engineering problems: It has applications in program understanding, maintenance [9, 10], debugging [23], testing <ref> [3, 2] </ref>, differencing [12,14], reuse [27], and merging [12]. This paper concerns the use of slicing to perform program specialization, and how slicing-based specialization relates to partial evaluation and other specialization operations. <p> A with respect to Base, all changed behavior of B with respect to Base, and all behavior that is common to all three [31]. g Bates and Horwitz proposed to use slicing to avoid redoing the part of a test suite that is unaffected by a change to a program <ref> [2] </ref>. g Andersen Consulting's interactive Cobol System Renovation Environment (Cobol/SRE) is a system for re-engineering legacy systems written in Cobol [27]. It uses slicing as the fundamental operation that users employ to select program fragments of interest. Operations are provided for combining slices (i.e., union, intersection, and difference).
Reference: 3. <author> Binkley, D., </author> <title> Using semantic differencing to reduce the cost of regression testing, </title> <booktitle> Proceedings of the 1992 Conference on Software Maintenance (Orlando, </booktitle> <address> FL, </address> <month> November 9-12, </month> <year> 1992), </year> <pages> pp. </pages> <month> 41-50 </month> <year> (1992). </year>
Reference-contexts: For example, a C program and one of its backward slices is shown in Figure 1. Slicingand subsequent manipulation of slicesshows great promise for helping with many software-engineering problems: It has applications in program understanding, maintenance [9, 10], debugging [23], testing <ref> [3, 2] </ref>, differencing [12,14], reuse [27], and merging [12]. This paper concerns the use of slicing to perform program specialization, and how slicing-based specialization relates to partial evaluation and other specialization operations.
Reference: 4. <author> Cartwright, R. and Felleisen, M., </author> <title> The semantics of program dependence, </title> <booktitle> Proceedings of the ACM SIGPLAN 89 Conference on Programming Language Design and Implementation, </booktitle> <address> (Portland, OR, </address> <month> June 21-23, </month> <year> 1989), </year> <journal> ACM SIGPLAN Notices 24(7) pp. </journal> <month> 13-27 (July </month> <year> 1989). </year>
Reference-contexts: Consequently, in this framework the semantics of a slice approximates the semantics of the full program. (Other approaches to lazy semantics for program dependence graphs include [35], <ref> [4] </ref>, and [1].) ` For readers who are uncomfortable with the semantic anomaly that a slice does not preserve the termination behavior of the original program, we would like to point out that this situation is far more acceptable than the semantic anomaly exhibited by partial evaluation, where, due to the
Reference: 5. <author> Das, M., Reps, T., and Van Hentenryck, P., </author> <title> Semantic foundations of binding-time analysis for imperative programs, pp. </title> <booktitle> 100-110 in Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation (PEPM 95), </booktitle> <address> (La Jolla, California, June 21-23, 1995), </address> <publisher> ACM, </publisher> <address> New York, NY (1995). </address>
Reference-contexts: However, there is a non-standard setting in which the hoped-for relationships do hold. Ramalingam and Reps have defined an equational value-sequence-oriented semantics (as opposed to a conventional state-oriented semantics) for a variant of the program dependence graph [30] (see also <ref> [5] </ref>). Rather than treating each program point as a state-to-state transformer, the value-sequence semantics treats each program point as a value-sequence transformer that takes (possibly infinite) argument sequences from dependence predecessors to a (possibly infinite) output sequence. <p> would like to point out that this situation is far more acceptable than the semantic anomaly exhibited by partial evaluation, where, due to the well-known problems with non-termination of partial evaluators in the presence of static-infinite computations ([17, pp. 265-266], [36, pp. 501-502], [25, pp. 337], [18, pp. 299], and <ref> [5] </ref>), partial evaluation can introduce divergence. <p> Another kind of relationship between slicing and partial evaluation has been established by Das, Reps, and Van Hentenryck who showed how three variants of forward slicing can be used to carry out binding-time analysis for imperative programs <ref> [5] </ref>. This paper has been greatly influenced by the literature on partial evaluation and related operations, particularly by Mogensen's paper on program bifurcation [26].
Reference: 6. <author> Ferrante, J., Ottenstein, K., and Warren, J., </author> <title> The program dependence graph and its use in optimization, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 9(3) pp. </pages> <month> 319-349 (July </month> <year> 1987). </year>
Reference-contexts: Program slicing has been studied primarily in the context of imperative programming languages [37]. In such languages, slicing is typically carried out using program dependence graphs <ref> [19, 28, 6, 13] </ref>.
Reference: 7. <author> Field, J., </author> <title> A simple rewriting semantics for realistic imperative programs and its application to program analysis, </title> <booktitle> Proceedings of the SIGPLAN Workshop on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <address> (San Francisco, CA, </address> <month> June </month> <year> 1992), </year> <type> Technical Report YALEU/DCS/RR-909, </type> <institution> Department of Computer Science, Yale University, </institution> <address> New Haven, CT (1992). </address>
Reference: 8. <author> Futamura, Y. and Nogi, K., </author> <title> Generalized partial computation, pp. 133-152 in Partial Evaluation and Mixed Computation: </title> <booktitle> Proceedings of the IFIP TC2 Workshop on Partial Evaluation and Mixed Computation, </booktitle> <address> (Gammel Avernaes, Denmark, </address> <month> October 18-24, </month> <year> 1987), </year> <editor> ed. D. Bjo| rner, A.P. Ershov, and N.D. Jones,North-Holland, </editor> <address> New York, NY (1988). </address>
Reference-contexts: Program Specialization: Slicing Versus Partial Evaluation In some circles, the terms program specialization and partial evaluation are treated almost as synonyms, although sometimes program specialization carries the nuance of expressing a broader perspective that encompasses a number of kindred techniques, such as generalized partial evaluation <ref> [8] </ref>, supercompilation [38], bifurcation [26], and deforestation [40]. However, this overlooks an often unappreciated fact, namely that program slicing can also be used to perform a kind of program specializationand one that is different from the kinds of specializations that partial evaluation and its close relatives are capable of performing.
Reference: 9. <author> Gallagher, </author> <title> K.B., Using program slicing in software maintenance, </title> <type> Ph.D. dissertation and Tech. Rep. </type> <institution> CS-90-05, Computer Science Department, University of Maryland, Baltimore Campus, Baltimore, </institution> <note> MD (January 1990). </note>
Reference-contexts: For example, a C program and one of its backward slices is shown in Figure 1. Slicingand subsequent manipulation of slicesshows great promise for helping with many software-engineering problems: It has applications in program understanding, maintenance <ref> [9, 10] </ref>, debugging [23], testing [3, 2], differencing [12,14], reuse [27], and merging [12]. This paper concerns the use of slicing to perform program specialization, and how slicing-based specialization relates to partial evaluation and other specialization operations.
Reference: 10. <author> Gallagher, K.B. and Lyle, J.R., </author> <title> Using program slicing in software maintenance, </title> <journal> IEEE Transactions on Software Engineering SE-17(8) pp. </journal> <month> 751-761 (August </month> <year> 1991). </year>
Reference-contexts: For example, a C program and one of its backward slices is shown in Figure 1. Slicingand subsequent manipulation of slicesshows great promise for helping with many software-engineering problems: It has applications in program understanding, maintenance <ref> [9, 10] </ref>, debugging [23], testing [3, 2], differencing [12,14], reuse [27], and merging [12]. This paper concerns the use of slicing to perform program specialization, and how slicing-based specialization relates to partial evaluation and other specialization operations.
Reference: 11. <author> Horwitz, S., Pfeiffer, P., and Reps, T., </author> <title> Dependence analysis for pointer variables, </title> <booktitle> Proceedings of the ACM SIGPLAN 89 Conference on Programming Language Design and Implementation, </booktitle> <address> (Portland, OR, </address> <month> June 21-23, </month> <year> 1989), </year> <journal> ACM SIGPLAN Notices 24(7) pp. </journal> <month> 28-40 (July </month> <year> 1989). </year>
Reference: 12. <author> Horwitz, S., Prins, J., and Reps, T., </author> <title> Integrating non-interfering versions of programs, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 11(3) pp. </pages> <month> 345-387 (July </month> <year> 1989). </year>
Reference-contexts: For example, a C program and one of its backward slices is shown in Figure 1. Slicingand subsequent manipulation of slicesshows great promise for helping with many software-engineering problems: It has applications in program understanding, maintenance [9, 10], debugging [23], testing [3, 2], differencing [12,14], reuse [27], and merging <ref> [12] </ref>. This paper concerns the use of slicing to perform program specialization, and how slicing-based specialization relates to partial evaluation and other specialization operations. <p> Each thread computes a portion of what is computed by the original program. g Horwitz, Reps, and Prins proposed an algorithm for merging two variants A and B of a program Base <ref> [12] </ref>. The algorithm breaks down Base, A, and B into their constituent slices and chooses among them to create the merged program.
Reference: 13. <author> Horwitz, S., Reps, T., and Binkley, D., </author> <title> Interprocedural slicing using dependence graphs, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 12(1) pp. </pages> <month> 26-60 (January </month> <year> 1990). </year>
Reference-contexts: 1. Introduction Program slicing is an operation that identifies semantically meaningful decompositions of programs, where the decompositions consist of elements that are not textually contiguous <ref> [43, 28, 13] </ref>. Program slicing has been studied primarily in the context of imperative programming languages [37]. In such languages, slicing is typically carried out using program dependence graphs [19, 28, 6, 13]. <p> Program slicing has been studied primarily in the context of imperative programming languages [37]. In such languages, slicing is typically carried out using program dependence graphs <ref> [19, 28, 6, 13] </ref>. <p> program elements S consists of all program elements that might affect (either directly or transitively) the values of the variables used at members of S; (ii) a forward slice with respect to S consists of all program elements that might be affected by the computations performed at members of S <ref> [13] </ref>. For example, a C program and one of its backward slices is shown in Figure 1.
Reference: 14. <author> Horwitz, S., </author> <title> Identifying the semantic and textual differences between two versions of a program, </title> <booktitle> Proceedings of the ACM SIGPLAN 90 Conference on Programming Language Design and Implementation, </booktitle> <address> (White Plains, NY, </address> <month> June 20-22, </month> <year> 1990), </year> <journal> ACM SIGPLAN Notices 25(6) pp. </journal> <month> 234-245 (June </month> <year> 1990). </year>
Reference: 15. <author> Hughes, J., </author> <title> Backwards analysis of functional programs, pp. 187-208 in Partial Evaluation and Mixed Computation: </title> <booktitle> Proceedings of the IFIP TC2 Workshop on Partial Evaluation and Mixed Computation, </booktitle> <address> (Gammel Avernaes, Denmark, </address> <month> October 18-24, </month> <year> 1987), </year> <editor> ed. D. Bjo| rner, A.P. Ershov, and N.D. Jones,North-Holland, </editor> <address> New York, NY (1988). </address>
Reference-contexts: However, for slicing, we need to propagate projection functions backwardsfrom function outputs to function arguments. Thus, the slicing problem has similarities with algorithms that propagate projection functions backwards to perform strictness analysis of lazy functional languages [15,39]. Instead of the fixed, finite domain of projection functions used in <ref> [15] </ref> and [39], we will use regular tree grammars (see below), which can be viewed as (representations of) projection functions. <p> The context analysis that we have used to define the slicing algorithm is related to the neededness analysis defined by Hughes <ref> [15] </ref> and also to the strictness analysis of Wadler and Hughes, which is also capable of identifying whether the value of a subexpression is ignored [39, pp. 392]. Our analysis is somewhat different from these two and, in general, incomparable to them.
Reference: 16. <editor> Jones, N.D. and Muchnick, S.S., </editor> <title> Flow analysis and optimization of Lisp-like structures, pp. 102-131 in Program Flow Analysis: Theory and Applications, </title> <editor> ed. S.S. Muchnick and N.D. Jones,Prentice-Hall, </editor> <address> Englewood Cliffs, NJ (1981). </address>
Reference-contexts: We identify two different goals for what we mean by slicing a functional program and give algo rithms that correspond to each of them. g We adapt techniques from shape analysis <ref> [16] </ref>, strictness analysis [39], and program bifurcation [26] so that our slicing algorithms can handle certain kinds of heap-allocated data structures (e.g., lists, trees, and dags). <p> There are other benefits as well: Past work on shape analysis <ref> [16] </ref>, strictness analysis [39], and program bifurcation [26] for functional programs has developed techniques to handle certain kinds of heap-allocated data structures (e.g., lists, trees, and dags); we use similar techniques to formulate a slicing algorithm that can handle programs that use (heap-allocated) lists, trees, and dags. <p> C.B D X Y = J K J X Y X otherwise if X = i c i if X = d c d or Y = d c d hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh side of a grammar rule, but allows there to be more than one such pair in each right-hand side <ref> [16] </ref>. This yields a more powerful tree-definition formalism. <p> under the two approaches: N 1 .N 2 ciic N 3 .N 4 = N 1 .N 2 | N 3 .N 4 -N 1 -.-N 2 - ciic -N 3 -.-N 4 - = -N 1 , N 3 -.-N 2 , N 4 - (a) Jones and Muchnick <ref> [16] </ref> (b) Mogensen [26] Approach (a) forms a right-hand side with multiple alternatives; this preserves the links between N 1 and N 2 and between N 3 and N 4 . <p> In particular, the variant of regular tree grammars that we have used is based on Mogensen's work (as opposed to the version of regular tree grammars used by Jones and Muchnick <ref> [16] </ref> and the normalized set equations used by Reynolds [33]).
Reference: 17. <author> Jones, </author> <title> N.D., Automatic program specialization: A reexamination from basic principles, pp. 225-282 in Partial Evaluation and Mixed Computation: </title> <booktitle> Proceedings of the IFIP TC2 Workshop on Partial Evaluation and Mixed Computation, </booktitle> <address> (Gammel Avernaes, Denmark, </address> <month> October 18-24, </month> <year> 1987), </year> <editor> ed. D. Bjo| rner, A.P. Ershov, and N.D. Jones,North-Holland, </editor> <address> New York, NY (1988). </address>
Reference: 18. <author> Jones, N.D., Gomard, C.K., and Sestoft, P., </author> <title> Partial Evaluation and Automatic Program Generation, </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, NJ (1993). </address>
Reference-contexts: the original program, we would like to point out that this situation is far more acceptable than the semantic anomaly exhibited by partial evaluation, where, due to the well-known problems with non-termination of partial evaluators in the presence of static-infinite computations ([17, pp. 265-266], [36, pp. 501-502], [25, pp. 337], <ref> [18, pp. 299] </ref>, and [5]), partial evaluation can introduce divergence.
Reference: 19. <author> Kuck, D.J., Kuhn, R.H., Leasure, B., Padua, D.A., and Wolfe, M., </author> <title> Dependence graphs and compiler optimizations, pp. </title> <booktitle> 207-218 in Conference Record of the Eighth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Williamsburg, VA, </address> <month> January 26-28, </month> <year> 1981), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1981). </address>
Reference-contexts: Program slicing has been studied primarily in the context of imperative programming languages [37]. In such languages, slicing is typically carried out using program dependence graphs <ref> [19, 28, 6, 13] </ref>.
Reference: 20. <author> Launchbury, J., </author> <title> Projection Factorizations in Partial Evaluation, </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, UK (1991). </address>
Reference: 21. <author> Liu, Y.A. and Teitelbaum, T., </author> <title> Caching intermediate results for program improvement, </title> <booktitle> in Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation (PEPM 95), </booktitle> <address> (La Jolla, California, June 21-23, 1995), </address> <publisher> ACM, </publisher> <address> New York, NY (1995). </address>
Reference-contexts: Most work on slicing has concerned imperative programming languages. In the context of functional languages, a slicing-like operation is used by Liu and Teitel-baum as a cleanup step in their transformational methodology for deriving incremental versions of functional programs from non-incremental functional programs <ref> [21] </ref>. In their work, slices can be taken only with respect to projection functions that express finite-depth access patterns in a tree. A similar technique also appears in Romanenko's work on arity raising [34] (a method for handling partially static structures in a partial evaluator).
Reference: 22. <author> Livadas, P.E. and Rosenstein, A., </author> <title> Slicing in the presence of pointer variables, </title> <type> Technical Report SERC-TR-74-F, </type> <institution> Software Engineering Research Center, University of Florida, </institution> <address> Gainesville, FL (June 1994). </address>
Reference: 23. <author> Lyle, J. and Weiser, M., </author> <title> Experiments on slicing-based debugging tools, </title> <booktitle> in Proceedings of the First Conference on Empirical Studies of Programming, </booktitle> <address> (June 1986), </address> <publisher> Ablex Publishing Co. </publisher> <year> (1986). </year>
Reference-contexts: For example, a C program and one of its backward slices is shown in Figure 1. Slicingand subsequent manipulation of slicesshows great promise for helping with many software-engineering problems: It has applications in program understanding, maintenance [9, 10], debugging <ref> [23] </ref>, testing [3, 2], differencing [12,14], reuse [27], and merging [12]. This paper concerns the use of slicing to perform program specialization, and how slicing-based specialization relates to partial evaluation and other specialization operations.
Reference: 24. <author> Lyle, J.R., Wallace, D.R., Graham, J.R., Gallagher, K.B., Poole, J.P., and Binkley, D.W., Unravel: </author> <title> A CASE tool to assist evaluation of high integrity software, </title> <type> Report NISTIR 5691, </type> <institution> National Institute for Standards and Technology, Gaithersburg, </institution> <note> MD (August 1995). </note>
Reference: 25. <author> Mogensen, T., </author> <title> Partially static structures in a self-applicable partial evaluator, pp. 325-347 in Partial Evaluation and Mixed Computation: </title> <booktitle> Proceedings of the IFIP TC2 Workshop on Partial Evaluation and Mixed Computation, </booktitle> <address> (Gammel Avernaes, Denmark, </address> <month> October 18-24, </month> <year> 1987), </year> <editor> ed. D. Bjo| rner, A.P. Ershov, and N.D. Jones,North-Holland, </editor> <address> New York, NY (1988). </address>
Reference-contexts: termination behavior of the original program, we would like to point out that this situation is far more acceptable than the semantic anomaly exhibited by partial evaluation, where, due to the well-known problems with non-termination of partial evaluators in the presence of static-infinite computations ([17, pp. 265-266], [36, pp. 501-502], <ref> [25, pp. 337] </ref>, [18, pp. 299], and [5]), partial evaluation can introduce divergence.
Reference: 26. <author> Mogensen, T., </author> <title> Separating binding times in language specifications, pp. </title> <booktitle> 12-25 in Fourth International Conference on Functional Programming and Computer Architecture, </booktitle> <address> (Lon-don, UK, </address> <month> Sept. </month> <pages> 11-13, </pages> <address> 1989), </address> <publisher> ACM Press, </publisher> <address> New York, NY (1989). </address>
Reference-contexts: We identify two different goals for what we mean by slicing a functional program and give algo rithms that correspond to each of them. g We adapt techniques from shape analysis [16], strictness analysis [39], and program bifurcation <ref> [26] </ref> so that our slicing algorithms can handle certain kinds of heap-allocated data structures (e.g., lists, trees, and dags). <p> Program Specialization: Slicing Versus Partial Evaluation In some circles, the terms program specialization and partial evaluation are treated almost as synonyms, although sometimes program specialization carries the nuance of expressing a broader perspective that encompasses a number of kindred techniques, such as generalized partial evaluation [8], supercompilation [38], bifurcation <ref> [26] </ref>, and deforestation [40]. However, this overlooks an often unappreciated fact, namely that program slicing can also be used to perform a kind of program specializationand one that is different from the kinds of specializations that partial evaluation and its close relatives are capable of performing. Example. <p> There are other benefits as well: Past work on shape analysis [16], strictness analysis [39], and program bifurcation <ref> [26] </ref> for functional programs has developed techniques to handle certain kinds of heap-allocated data structures (e.g., lists, trees, and dags); we use similar techniques to formulate a slicing algorithm that can handle programs that use (heap-allocated) lists, trees, and dags. <p> Specifically, we will use the variant of regular tree gram mars that Mogensen used in his work on program bifurcation <ref> [26] </ref>. 1 A finite tree (or dag) T can be treated formally as a finite prefix-closed set of strings L (T), where L (T) consists of the set of access paths in T. <p> approaches: N 1 .N 2 ciic N 3 .N 4 = N 1 .N 2 | N 3 .N 4 -N 1 -.-N 2 - ciic -N 3 -.-N 4 - = -N 1 , N 3 -.-N 2 , N 4 - (a) Jones and Muchnick [16] (b) Mogensen <ref> [26] </ref> Approach (a) forms a right-hand side with multiple alternatives; this preserves the links between N 1 and N 2 and between N 3 and N 4 . <p> That is, our intention is to use type-(b) grammars as a way to define sets of access paths, one set per nonterminal. For this purpose, type-(a) grammars are no sharper than type-(b) grammars. In addition, it is computationally more expensive to use and manipulate type-(a) grammars <ref> [26] </ref>. (It should be noted that type-(b) grammars can be thought of as simply a formalism for defining prefix-closed regular string languages. Our use of the term regular tree grammars for them follows Mogensen's usage [26].) ` 3.2. <p> In addition, it is computationally more expensive to use and manipulate type-(a) grammars <ref> [26] </ref>. (It should be noted that type-(b) grammars can be thought of as simply a formalism for defining prefix-closed regular string languages. Our use of the term regular tree grammars for them follows Mogensen's usage [26].) ` 3.2. <p> While no reasonable programming languages have call-by-value conditionals, there do exist programming languages with call-by-name semantics. 5. A Re-Examination of Program Bifurcation In <ref> [26] </ref>, Mogensen describes a method to perform program bifurcation. <p> This paper has been greatly influenced by the literature on partial evaluation and related operations, particularly by Mogensen's paper on program bifurcation <ref> [26] </ref>. In particular, the variant of regular tree grammars that we have used is based on Mogensen's work (as opposed to the version of regular tree grammars used by Jones and Muchnick [16] and the normalized set equations used by Reynolds [33]).
Reference: 27. <author> Ning, J.Q., Engberts, A., and Kozaczynski, W., </author> <title> Automated support for legacy code understanding, </title> <journal> Commun. of the ACM 37(5) pp. </journal> <month> 50-57 (May </month> <year> 1994). </year>
Reference-contexts: For example, a C program and one of its backward slices is shown in Figure 1. Slicingand subsequent manipulation of slicesshows great promise for helping with many software-engineering problems: It has applications in program understanding, maintenance [9, 10], debugging [23], testing [3, 2], differencing [12,14], reuse <ref> [27] </ref>, and merging [12]. This paper concerns the use of slicing to perform program specialization, and how slicing-based specialization relates to partial evaluation and other specialization operations. <p> to all three [31]. g Bates and Horwitz proposed to use slicing to avoid redoing the part of a test suite that is unaffected by a change to a program [2]. g Andersen Consulting's interactive Cobol System Renovation Environment (Cobol/SRE) is a system for re-engineering legacy systems written in Cobol <ref> [27] </ref>. It uses slicing as the fundamental operation that users employ to select program fragments of interest. Operations are provided for combining slices (i.e., union, intersection, and difference). These fragments are then used to reorganize the program by extracting the code fragments and repackaging them into independent modules.
Reference: 28. <author> Ottenstein, K.J. and Ottenstein, L.M., </author> <title> The program dependence graph in a software development environment, </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> (Pittsburgh, PA, </address> <month> Apr. </month> <pages> 23-25, </pages> <year> 1984), </year> <journal> ACM SIGPLAN Notices 19(5) pp. </journal> <month> 177-184 (May </month> <year> 1984). </year>
Reference-contexts: 1. Introduction Program slicing is an operation that identifies semantically meaningful decompositions of programs, where the decompositions consist of elements that are not textually contiguous <ref> [43, 28, 13] </ref>. Program slicing has been studied primarily in the context of imperative programming languages [37]. In such languages, slicing is typically carried out using program dependence graphs [19, 28, 6, 13]. <p> Program slicing has been studied primarily in the context of imperative programming languages [37]. In such languages, slicing is typically carried out using program dependence graphs <ref> [19, 28, 6, 13] </ref>.
Reference: 29. <author> Pfeiffer, P. and Selke, </author> <title> R.P, On the adequacy of dependence-based representations for programs with heaps, </title> <booktitle> in Proceedings of the International Conference on Theoretical Aspects of Computer Software (TACS 91), (Sendai, </booktitle> <address> Japan, </address> <month> September </month> <year> 1991), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 526, </volume> <editor> ed. T. Ito and A.R. Meyer,Springer-Verlag, </editor> <address> New York, NY (1991). </address>
Reference: 30. <author> Ramalingam, G. and Reps, T., </author> <title> Semantics of program representation graphs, </title> <institution> TR-900, Computer Sciences Department, University of Wisconsin, Madison, </institution> <note> WI (December 1989). </note>
Reference-contexts: However, there is a non-standard setting in which the hoped-for relationships do hold. Ramalingam and Reps have defined an equational value-sequence-oriented semantics (as opposed to a conventional state-oriented semantics) for a variant of the program dependence graph <ref> [30] </ref> (see also [5]). Rather than treating each program point as a state-to-state transformer, the value-sequence semantics treats each program point as a value-sequence transformer that takes (possibly infinite) argument sequences from dependence predecessors to a (possibly infinite) output sequence.
Reference: 31. <author> Reps, T. and Yang, W., </author> <title> The semantics of program slicing and program integration, pp. </title> <booktitle> 360-374 in Proceedings of the Colloquium on Current Issues in Programming Languages, </booktitle> <address> (Barcelona, Spain, March 13-17, </address> <year> 1989), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 352, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1989). </address>
Reference-contexts: By selecting appropriate slices, the algorithm guarantees that the merged program exhibits all changed behavior of A with respect to Base, all changed behavior of B with respect to Base, and all behavior that is common to all three <ref> [31] </ref>. g Bates and Horwitz proposed to use slicing to avoid redoing the part of a test suite that is unaffected by a change to a program [2]. g Andersen Consulting's interactive Cobol System Renovation Environment (Cobol/SRE) is a system for re-engineering legacy systems written in Cobol [27].
Reference: 32. <author> Reps, T., </author> <title> Shape analysis as a generalized path problem, pp. </title> <booktitle> 1-11 in Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation (PEPM 95), </booktitle> <address> (La Jolla, California, June 21-23, 1995), </address> <publisher> ACM, </publisher> <address> New York, NY (1995). </address>
Reference: 33. <author> Reynolds, </author> <title> J.C., Automatic computation of data set definitions, pp. </title> <booktitle> 456-461 in Information Processing 68: Proceedings of the IFIP Congress 68, </booktitle> <publisher> North-Holland, </publisher> <address> New York, NY (1968). </address>
Reference-contexts: In particular, the variant of regular tree grammars that we have used is based on Mogensen's work (as opposed to the version of regular tree grammars used by Jones and Muchnick [16] and the normalized set equations used by Reynolds <ref> [33] </ref>). The context analysis that we have used to define the slicing algorithm is related to the neededness analysis defined by Hughes [15] and also to the strictness analysis of Wadler and Hughes, which is also capable of identifying whether the value of a subexpression is ignored [39, pp. 392].
Reference: 34. <author> Romanenko, S., </author> <title> Arity raiser and its use in program specialization, pp. </title> <booktitle> 341-360 in Proceedings of the Third European Symposium on Programming, </booktitle> <address> (Copenhagen, Denmark, </address> <month> May 15-18, </month> <year> 1990), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 432, </volume> <editor> ed. N. Jones,Springer-Verlag, </editor> <address> New York, NY (1990). </address>
Reference-contexts: In their work, slices can be taken only with respect to projection functions that express finite-depth access patterns in a tree. A similar technique also appears in Romanenko's work on arity raising <ref> [34] </ref> (a method for handling partially static structures in a partial evaluator). In contrast, the slicing method we have presented uses regular-tree grammars to express projection functions that have arbitrary-depth (but regular) access patterns.
Reference: 35. <author> Selke, </author> <title> R.P, A rewriting semantics for program dependence graphs, pp. </title> <booktitle> 12-24 in Confer--ence Record of the Sixteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Austin, TX, </address> <month> Jan. </month> <pages> 11-13, </pages> <address> 1989), </address> <publisher> ACM, </publisher> <address> New York, NY (1989). </address>
Reference-contexts: Consequently, in this framework the semantics of a slice approximates the semantics of the full program. (Other approaches to lazy semantics for program dependence graphs include <ref> [35] </ref>, [4], and [1].) ` For readers who are uncomfortable with the semantic anomaly that a slice does not preserve the termination behavior of the original program, we would like to point out that this situation is far more acceptable than the semantic anomaly exhibited by partial evaluation, where, due to
Reference: 36. <author> Sestoft, P., </author> <title> Automatic call unfolding in a partial evaluator, pp. 485-506 in Partial Evaluation and Mixed Computation: </title> <booktitle> Proceedings of the IFIP TC2 Workshop on Partial Evaluation and Mixed Computation, </booktitle> <address> (Gammel Avernaes, Denmark, </address> <month> October 18-24, </month> <year> 1987), </year> <editor> ed. D. Bjo| rner, A.P. Ershov, and N.D. Jones,North-Holland, </editor> <address> New York, NY (1988). </address>
Reference-contexts: not preserve the termination behavior of the original program, we would like to point out that this situation is far more acceptable than the semantic anomaly exhibited by partial evaluation, where, due to the well-known problems with non-termination of partial evaluators in the presence of static-infinite computations ([17, pp. 265-266], <ref> [36, pp. 501-502] </ref>, [25, pp. 337], [18, pp. 299], and [5]), partial evaluation can introduce divergence.
Reference: 37. <author> Tip, F., </author> <title> A survey of program slicing techniques, </title> <journal> Journal of Programming Languages 3 pp. </journal> <month> 121-181 </month> <year> (1995). </year>
Reference-contexts: 1. Introduction Program slicing is an operation that identifies semantically meaningful decompositions of programs, where the decompositions consist of elements that are not textually contiguous [43, 28, 13]. Program slicing has been studied primarily in the context of imperative programming languages <ref> [37] </ref>. In such languages, slicing is typically carried out using program dependence graphs [19, 28, 6, 13].
Reference: 38. <author> Turchin, </author> <title> V.F., The concept of a supercompiler, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 8(3) pp. </pages> <month> 292-325 (July </month> <year> 1986). </year>
Reference-contexts: Program Specialization: Slicing Versus Partial Evaluation In some circles, the terms program specialization and partial evaluation are treated almost as synonyms, although sometimes program specialization carries the nuance of expressing a broader perspective that encompasses a number of kindred techniques, such as generalized partial evaluation [8], supercompilation <ref> [38] </ref>, bifurcation [26], and deforestation [40]. However, this overlooks an often unappreciated fact, namely that program slicing can also be used to perform a kind of program specializationand one that is different from the kinds of specializations that partial evaluation and its close relatives are capable of performing. Example.
Reference: 39. <author> Wadler, P. and Hughes, R.J.M., </author> <title> Projections for strictness analysis, pp. </title> <booktitle> 385-407 in Third Conference on Functional Programming and Computer Architecture, </booktitle> <address> (Portland, OR, </address> <month> Sept. </month> <pages> 14-16, </pages> <year> 1987), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 274, </volume> <editor> ed. G. Kahn,Springer-Verlag, </editor> <address> New York, NY (1987). </address>
Reference-contexts: We identify two different goals for what we mean by slicing a functional program and give algo rithms that correspond to each of them. g We adapt techniques from shape analysis [16], strictness analysis <ref> [39] </ref>, and program bifurcation [26] so that our slicing algorithms can handle certain kinds of heap-allocated data structures (e.g., lists, trees, and dags). <p> There are other benefits as well: Past work on shape analysis [16], strictness analysis <ref> [39] </ref>, and program bifurcation [26] for functional programs has developed techniques to handle certain kinds of heap-allocated data structures (e.g., lists, trees, and dags); we use similar techniques to formulate a slicing algorithm that can handle programs that use (heap-allocated) lists, trees, and dags. <p> Thus, the slicing problem has similarities with algorithms that propagate projection functions backwards to perform strictness analysis of lazy functional languages [15,39]. Instead of the fixed, finite domain of projection functions used in [15] and <ref> [39] </ref>, we will use regular tree grammars (see below), which can be viewed as (representations of) projection functions. <p> The context analysis that we have used to define the slicing algorithm is related to the neededness analysis defined by Hughes [15] and also to the strictness analysis of Wadler and Hughes, which is also capable of identifying whether the value of a subexpression is ignored <ref> [39, pp. 392] </ref>. Our analysis is somewhat different from these two and, in general, incomparable to them. For instance, the latter analyses are both formulated in terms of a fixed, finite set of projection functions for characterizing neededness patterns of list-manipulation programs.
Reference: 40. <author> Wadler, P., </author> <title> Deforestation: Transforming programs to eliminate trees, </title> <note> Theoretical Computer Science 73 pp. </note> <month> 231-248 </month> <year> (1990). </year>
Reference-contexts: Slicing Versus Partial Evaluation In some circles, the terms program specialization and partial evaluation are treated almost as synonyms, although sometimes program specialization carries the nuance of expressing a broader perspective that encompasses a number of kindred techniques, such as generalized partial evaluation [8], supercompilation [38], bifurcation [26], and deforestation <ref> [40] </ref>. However, this overlooks an often unappreciated fact, namely that program slicing can also be used to perform a kind of program specializationand one that is different from the kinds of specializations that partial evaluation and its close relatives are capable of performing. Example.
Reference: 41. <author> Weise, D., Crew, R.F., Ernst, M., and Steensgaard, B., </author> <title> Value dependence graphs: Representation without taxation, pp. </title> <booktitle> 297-310 in Conference Record of the Twenty-First ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Portland, OR, </address> <month> Jan. </month> <pages> 16-19, </pages> <address> 1994), </address> <publisher> ACM, </publisher> <address> New York, NY (1994). </address>
Reference: 42. <author> Weiser, M., </author> <title> Reconstructing sequential behavior from parallel behavior projections, </title> <note> Information Processing Letters 17 pp. </note> <month> 129-135 (October </month> <year> 1983). </year>
Reference-contexts: Many of the proposed applications of slicing are based on its properties as a specialization operation. For example, g Weiser proposed using slicing to decompose programs into separate threads that can be run in parallel <ref> [42] </ref>. Each thread computes a portion of what is computed by the original program. g Horwitz, Reps, and Prins proposed an algorithm for merging two variants A and B of a program Base [12].
Reference: 43. <author> Weiser, M., </author> <title> Program slicing, </title> <journal> IEEE Transactions on Software Engineering SE-10(4) pp. </journal> <month> 352-357 (July </month> <year> 1984). </year>
Reference-contexts: 1. Introduction Program slicing is an operation that identifies semantically meaningful decompositions of programs, where the decompositions consist of elements that are not textually contiguous <ref> [43, 28, 13] </ref>. Program slicing has been studied primarily in the context of imperative programming languages [37]. In such languages, slicing is typically carried out using program dependence graphs [19, 28, 6, 13]. <p> We can actually identify two different goals for what we mean by slicing a functional program, which we call Type I and Type II slices. In Weiser's original definition of slicing for imperative programs, a slice is obtained from the original program by deleting zero or more statements <ref> [43, pp. 353] </ref>. Type I slicing is the analogue for functional programs of Weiser's slicing operation: subexpressions of the program, rather than statements, are deleted.
References-found: 43

