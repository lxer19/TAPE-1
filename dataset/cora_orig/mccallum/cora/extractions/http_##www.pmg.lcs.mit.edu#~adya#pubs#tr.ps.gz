URL: http://www.pmg.lcs.mit.edu/~adya/pubs/tr.ps.gz
Refering-URL: http://www.pmg.lcs.mit.edu/~adya/index.html
Root-URL: 
Title: Transaction Management for Mobile Objects using Optimistic Concurrency Control  
Author: Atul Adya 
Address: 545 Technology Square Cambridge, Massachusetts 02139  
Affiliation: Massachusetts Institute of Technology Laboratory for Computer Science  
Note: c Massachusetts Institute of Technology 1994. All rights reserved. This work was supported by the Advanced Research Projects Agency of the Department of Defense, monitored by the Office of Naval Research under contract N00014-91-J-4136.  
Date: July 1994  
Abstract-found: 0
Intro-found: 1
Reference: [Adya94] <author> Adya A., Gruber R., Liskov B., Maheshwari U. </author> <title> Efficient Optimistic Concurrency Control for Distributed Database Systems. </title> <note> In preparation. </note>
Reference-contexts: Thus, in our design, we have not adopted this strategy. In this chapter, we presented a strategy in which there is some space overhead per object for concurrency control. We have developed a scheme in which there is no space overhead per object; see <ref> [Adya94] </ref> for details.
Reference: [Agarwal87] <author> Agarwal D., Bernstein J., Gupta P., Sengupta S. </author> <title> Distributed Opti mistic Concurrency Control with Reduced Rollback. </title> <journal> Distributed Computing, </journal> <volume> 2(1) </volume> <pages> 45-59, </pages> <year> 1987. </year>
Reference-contexts: A multiversion pessimistic scheme that does not require read-only transactions to syn chronize with other transactions was suggested in [Weihl87]. An optimistic strategy that achieves the same effect has been presented in <ref> [Agarwal87] </ref>. Maintaining multiple versions may permit more transactions to commit than a single version scheme. However, it com plicates transaction processing and reduces the effective cache size at the server/client; multiple versions of objects have to maintained consuming more storage in the client cache. <p> For example, if S is modifying x and T has read it, an excessively low value of S.ts can abort T unnecessarily. Various techniques for choosing timestamps have been suggested in the literature. For example, the scheme described in <ref> [Agarwal87] </ref> requires each site to maintain a monotonically increasing counter that is updated according to incoming commit messages. But this scheme can lead to unnecessary aborts or retries because the counters at different servers are not updated at the same rate. <p> expect S's updates to be installed before T's updates or S to commit and T to abort if they cannot be serialized in that order. 3.2.2 Validation Using the Transaction History In this section, we develop the validation algorithm using an approach similar to the ones discussed in [Gruber89] and <ref> [Agarwal87] </ref>. We do not discuss issues such as logging in this section; these issues are addressed in the next two sections; in Sections 3.3 and 3.4, we suggest ways of modifying the scheme to make it more practical for implementation purposes.
Reference: [Bern87] <author> Bernstein P., Hadzilacos V., Goodman N. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley, </publisher> <address> Reading MA, </address> <year> 1987. </year>
Reference-contexts: This serial order is called the equivalent serial schedule. The concurrency control mechanism can guarantee serializability in a dis tributed system by scheduling conflicting transactions in the same relative order at all sites. Pessimistic schemes such as 2-phase locking <ref> [Bern87] </ref> achieve this affect by locking objects and delaying transactions that try to execute conflicting operations. Most distributed opti mistic schemes use timestamps to ensure that transactions at different sites are committed in the same relative order. Our design uses globally unique timestamps to guarantee serializability. <p> Moving x to B now would be incorrect. Thus, if two transactions are moving the same object, the system has to ensure that the object's ultimate destination is the server specified by the transaction that has been serialized later. This condition is similar to Thomas's write rule <ref> [Bern87] </ref> for blind writes. From the preceding discussion, we can see that supporting blind moves does complicate the commit protocol. To avoid these complications, our design disallows blind moves. As stated earlier, this will prevent concurrent move operations to be executed on the same object.
Reference: [Black90] <author> Black A. P., Artsy Y. </author> <title> Implementing Location Independent Invocation. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> Vol. 1, No. 1, </volume> <month> Jan uary </month> <year> 1990. </year>
Reference-contexts: The 2-phase commit protocol is also modified to guarantee atomic migration of objects. Our work on object migration is different from earlier work since our strategy is in tegrated with the concurrency control mechanism; we provide transaction semantics with respect to object migration also. The Hermes <ref> [Black90] </ref> and Emerald [Jul88] systems sup port object mobility but they do not have a client-server model like Thor and they do not support transactions.
Reference: [Ceri82] <author> Ceri S., Owicki S. </author> <title> On the Use of Optimistic Methods for Concurrency Control in Distributed Databases. </title> <booktitle> Proceedings of the 6th Berkeley Workshop, </booktitle> <pages> pages 117-130, </pages> <year> 1982. </year>
Reference-contexts: The seminal paper on optimistic concurrency control by Kung and Robinson [Kung81] moti vates the need for optimistic schemes and presents the idea of validation. Their central ized server scheme for serial and parallel validation is generalized to a distributed system 15 in <ref> [Ceri82] </ref>. Haerder [Haerder84] has developed the notion of forward and backward valida tion. Optimistic schemes have also been extended to exploit the semantics of abstract data types [Herlihy90]. Gruber [Gruber89] has suggested validation-based optimistic schemes for the nested transaction model.
Reference: [Day94] <author> Day M., Liskov B., Maheshwari U., Myers A. </author> <title> References to Remote Mobile Objects in Thor. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <note> 1994. To appear. </note>
Reference-contexts: The tradeoffs associated with location-independent and location-dependent references and the reasons for choosing the latter scheme are discussed in <ref> [Day94] </ref>. Given a reference, the corresponding object can be accessed by sending a request to the relevant server. This server uses the oref value to fetch the requested object. <p> Furthermore, it may or may not swizzle a complete object. Different options for swizzling and their associated performance tradeoffs are discussed in <ref> [Day94] </ref>. 24 2.3 Transactions All operations of an application are executed as part of a Thor transaction; a new transac tion starts automatically after the current transaction commits or aborts. While performing its computation, an application may read or modify objects in its frontend's cache. <p> Thus, the transaction mechanism must ensure that such foreground delays are minimized. Execution phase delays can be reduced by techniques such as caching and prefetching <ref> [Day94] </ref>. Our work is mainly focused on the validation and update phases, but we ensure that execution phase operations such as object (pre)fetch are not penalized. 3.1.3 Distributed Commit Process This section gives an overview of the two-phase protocol executed to commit a transaction.
Reference: [Day94] <author> Day M. </author> <title> Client Caching in an Object-Oriented Database. </title> <type> Ph.D. thesis, </type> <institution> Mas sachusetts Institute of Technology, </institution> <year> 1994. </year> <month> Forthcoming. </month>
Reference-contexts: The tradeoffs associated with location-independent and location-dependent references and the reasons for choosing the latter scheme are discussed in <ref> [Day94] </ref>. Given a reference, the corresponding object can be accessed by sending a request to the relevant server. This server uses the oref value to fetch the requested object. <p> Furthermore, it may or may not swizzle a complete object. Different options for swizzling and their associated performance tradeoffs are discussed in <ref> [Day94] </ref>. 24 2.3 Transactions All operations of an application are executed as part of a Thor transaction; a new transac tion starts automatically after the current transaction commits or aborts. While performing its computation, an application may read or modify objects in its frontend's cache. <p> Thus, the transaction mechanism must ensure that such foreground delays are minimized. Execution phase delays can be reduced by techniques such as caching and prefetching <ref> [Day94] </ref>. Our work is mainly focused on the validation and update phases, but we ensure that execution phase operations such as object (pre)fetch are not penalized. 3.1.3 Distributed Commit Process This section gives an overview of the two-phase protocol executed to commit a transaction.
Reference: [DeWitt84] <author> DeWitt D. J. et al. </author> <title> Implementation Techniques for Main Memory Database Systems. </title> <booktitle> Proceedings of the ACM SIGMOD International Con ference on Management of Data, </booktitle> <pages> pages 1-8, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: Many variations have been sug gested to optimize this protocol, e.g., presumed-abort/commit strategies. Mohan [Mohan83] has adapted the 2-phase commit protocol for a tree of processes. The coordinator log pro tocol suggested in [Stamos89] does not require a participant to flush the prepare record. Group commit <ref> [DeWitt84] </ref> strategies have been suggested in which log flushes of multiple transactions are grouped together to alleviate disk bandwidth problems; the Cedar sys tem [Hagmann87] uses this strategy. Non-blocking and 3-phase commit protocols have also been studied [Skeen81].
Reference: [Douglis91] <author> Douglis F., Ousterhout J. </author> <title> Transparent Process Migration: Alternatives and the Sprite Implementation. </title> <journal> Software | Practice and Experience, </journal> <volume> Vol. 2(18), </volume> <pages> 757-785, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: This model is neither a client-server model nor is it possible to move a set of objects to a specific site. Research has been conducted in the area of process migration for various operating environments. Systems such as Sprite <ref> [Douglis91] </ref>, V [Theimer85], DEMOS/MP [Powell83] and Accent [Zayas87] support this facility. Some of the problems faced in process migration schemes are similar to the ones faced in Thor, e.g., forwarding pointers have to be left at the old site and all relevant operations have to routed to the new site. <p> It would be interesting to design a utility that tries to make intelligent decisions based on different characteristics of the system and migrates objects. Previous work done in the area of load-balancing [Walds92] and process migration <ref> [Douglis91] </ref> can be used for designing this facility. This utility can monitor different aspects of the system and reconfigure the object placement accordingly. For example, it can determine which server is excessively loaded and with the help of the object usage pattern, migrate objects to lightly-loaded servers.
Reference: [Duchamp89] <author> Duchamp D. </author> <title> Analysis of Transaction Management Performance. </title> <booktitle> Proceed ings of the Twelfth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 177-190, </pages> <month> December </month> <year> 1989. </year> <month> 91 </month>
Reference-contexts: Non-blocking and 3-phase commit protocols have also been studied [Skeen81]. Camelot has implemented a non-blocking protocol but its perfor 16 mance is much worse than a 2-phase protocol <ref> [Duchamp89] </ref>. Non-blocking protocols are not of practical interest and systems rarely implement them. During the commit protocol for pessimistic systems, read-locks can be released dur ing the first phase but write-locks have to be retained till the second phases completes.
Reference: [Fishman84] <author> Fishman D. H., Lai M., </author> <title> Wilkinson Overview of the Jasmin Database Machine. </title> <booktitle> Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <year> 1984. </year>
Reference-contexts: A system implementation that caches objects and uses a classic optimistic scheme is Servio Logic's Gemstone [Maier86]. Gemstone is a distributed system that allows multiple clients but objects can be stored at only one server. The Jasmin database machine <ref> [Fishman84] </ref> also uses optimistic concurrency control for serializing trans actions; it too is a centralized server system. Their concurrency control control algorithm was later extended to the distributed case [Lai84]. However, they use multiple versions and also serialize transactions at a site in the order they are received.
Reference: [Franklin92] <author> Franklin M., Carey M. </author> <title> Client-Server Caching Revisited. </title> <type> Technical Re port 1089, </type> <institution> Computer Sciences Department University of Wisconsin Madi son, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: To improve system throughput, pessimistic schemes such as no-wait locking, callback locking and optimistic locking have been suggested <ref> [Franklin92] </ref>. These locking techniques make "optimistic" assumptions about lock acquisition and lock sharing to reduce synchronization overheads. Optimistic schemes take advantage of client caching by not requiring any message to be sent to the server if the object is already present 14 in the client cache. <p> Note that this scheme is different from a classical optimistic scheme where instead of acquiring locks at the end of the transaction, the servers execute a validation algorithm to check if the transaction has violated any serializability constraints. Franklin <ref> [Franklin92] </ref> and Wang [Wang91] have conducted studies to compare the perfor mance of these schemes for different workloads in a client-server model. These concurrency studies indicate that callback, no-wait and optimistic locking provide higher throughput than regular locking for most workloads. <p> The server can send the modified value to the frontends or simply ask them to invalidate the relevant objects. Or it may decide to send the update values of some objects and invalidate the rest. The advantages and disadvantages of these schemes for different workloads are discussed in <ref> [Franklin92] </ref>. On receiving an invalidation message for object x, a frontend aborts the current transaction if its application has read or written x; otherwise, depending on the strategy used it updates or invalidates x's cached copy. The frontend invalidates x's copy by converting it to a frontend-surrogate.
Reference: [Gifford83] <author> Gifford D. K. </author> <title> Information Storage in a Decentralized Computer System. </title> <type> Technical Report CSL-81-8, </type> <institution> Xerox Corporation, </institution> <month> March </month> <year> 1983. </year>
Reference-contexts: In general, the timestamp of an incoming transaction will usually be greater than the timestamp of a conflicting committed/prepared transaction. Thus, there will be few aborts due to excessively low or high timestamp values. Being close to real time, loosely synchronized clocks also reduce the likelihood of external consistency <ref> [Gifford83] </ref> being violated. A violation of external consistency occurs when the ordering of operations inside a system does not agree with the order a user expects.
Reference: [Gray79] <author> Gray J. N. </author> <title> Notes on Database Operating Systems. </title> <editor> In R. Bayer, R. M. Gra ham, and G. Seegmuller, editors, </editor> <booktitle> Operating Systems: An Advanced Course, Chapter 3.F, </booktitle> <pages> pages 394-481, </pages> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: To simplify the transaction model, Thor does not support nested transactions. 1.1.2 The Commit Process When a client commits a transaction, the system has to ensure that all servers agree on committing or aborting the transaction. This effect is usually achieved with the help of a 2-phase commit protocol <ref> [Gray79, Mohan83, Lindsay84] </ref>. Many variations have been sug gested to optimize this protocol, e.g., presumed-abort/commit strategies. Mohan [Mohan83] has adapted the 2-phase commit protocol for a tree of processes. The coordinator log pro tocol suggested in [Stamos89] does not require a participant to flush the prepare record.
Reference: [Gray93] <author> Gray J. N., Reuter A. </author> <title> Transaction Processing: Concepts and Techniques, </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo CA. </address>
Reference-contexts: Section 1.1 presents the motivation and an overview of our transaction management strategy. Section 1.2 discusses the issue of migrating objects among servers. Finally, Section 1.3 provides an overview of the remainder of this thesis. 1.1 Transactions and Concurrency Control Transactions <ref> [Gray93] </ref> are a convenient mechanism for building reliable distributed systems in the presence of concurrent access and failures. They allow operations on objects to be grouped together and provide the atomicity guarantee, i.e., either all or none of these operations are performed on the database state.
Reference: [Gruber89] <author> Gruber R. E. </author> <title> Optimistic Concurrency Control for Nested Distributed Transactions. </title> <type> S.M. thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1989. </year>
Reference-contexts: Their central ized server scheme for serial and parallel validation is generalized to a distributed system 15 in [Ceri82]. Haerder [Haerder84] has developed the notion of forward and backward valida tion. Optimistic schemes have also been extended to exploit the semantics of abstract data types [Herlihy90]. Gruber <ref> [Gruber89] </ref> has suggested validation-based optimistic schemes for the nested transaction model. A system implementation that caches objects and uses a classic optimistic scheme is Servio Logic's Gemstone [Maier86]. Gemstone is a distributed system that allows multiple clients but objects can be stored at only one server. <p> Reed [Reed83] describes a timestamping strategy for serializing transactions in this model. Systems such as Argus [Liskov84] and Camelot [Spector87] provide a computational model that supports nested transactions using pessimistic locking. An optimistic scheme for this model has been presented in <ref> [Gruber89] </ref>. To simplify the transaction model, Thor does not support nested transactions. 1.1.2 The Commit Process When a client commits a transaction, the system has to ensure that all servers agree on committing or aborting the transaction. <p> they would expect S's updates to be installed before T's updates or S to commit and T to abort if they cannot be serialized in that order. 3.2.2 Validation Using the Transaction History In this section, we develop the validation algorithm using an approach similar to the ones discussed in <ref> [Gruber89] </ref> and [Agarwal87]. We do not discuss issues such as logging in this section; these issues are addressed in the next two sections; in Sections 3.3 and 3.4, we suggest ways of modifying the scheme to make it more practical for implementation purposes. <p> This condition guarantees that T does not invalidate the read operations of any of these transactions. Note that the mos test was not needed for the scheme suggested in <ref> [Gruber89] </ref> because 37 the transaction manager allowed T to pass validation only if T.ts was greater than the timestamp of all previously validated transactions at that site. Since we do not require transactions to be validated in increasing order of timestamps, the tm has to perform the mos test also. <p> Section 3.4 shows how to reduce the overheads of this information. For prepared transactions, the tm maintains a data structure called the Validation Queue or vq; this idea has been suggested in <ref> [Gruber89] </ref>. This queue contains an entry for each prepared transaction S and each entry has the following attributes | ros, mos and ts. Essentially, the vq just contains those entries in the history list that were marked as prepared. <p> Let us call this requirement the conflict-detection property. To maintain this property and permit multiple validations at a server, we use a strategy similar to the one suggested in <ref> [Gruber89] </ref>. For an incoming transaction T, the idea is to take a fast snapshot (inside a critical section) of all the relevant activities that can occur during T's validation process and then perform T's validation using the snapshot.
Reference: [Gruber94] <author> Gruber R. E. </author> <title> Temperature-Based Concurrency Control. </title> <type> Ph.D. thesis, </type> <institution> Mas sachusetts Institute of Technology, </institution> <year> 1994. </year> <month> Forthcoming. </month>
Reference-contexts: Therefore, to support both low and high contention workloads, an adaptive scheme can be designed that usually uses optimistic concurrency control but dynamically changes to locking for hot spot objects. Such a technique is being developed by Gruber <ref> [Gruber94] </ref>. Optimistic schemes have been discussed in the literature but we do not know of any multi-server distributed system that serializes transactions using such an approach. <p> To achieve good performance in such envi ronments locking can be used. However, for low-conflict environments, optimistic schemes perform better than pessimistic schemes. Thus, a mechanism is needed that adapts dy namically according to the characteristics of the workload. Gruber <ref> [Gruber94] </ref> is exploring such a strategy. He proposes a hybrid approach in which the decision to use pessimistic or optimistic concurrency control is done on a per-object basis and this selection is done dynamically.
Reference: [Haerder84] <author> H aerder T. </author> <title> Observations on Optimistic Concurrency Control Schemes. </title> <booktitle> In formation Systems, </booktitle> <volume> 9 </volume> <pages> 111-120, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: The seminal paper on optimistic concurrency control by Kung and Robinson [Kung81] moti vates the need for optimistic schemes and presents the idea of validation. Their central ized server scheme for serial and parallel validation is generalized to a distributed system 15 in [Ceri82]. Haerder <ref> [Haerder84] </ref> has developed the notion of forward and backward valida tion. Optimistic schemes have also been extended to exploit the semantics of abstract data types [Herlihy90]. Gruber [Gruber89] has suggested validation-based optimistic schemes for the nested transaction model.
Reference: [Hagmann87] <author> Hagmann R. </author> <title> Reimplementing the Cedar File System Using Logging and Group Commit. </title> <booktitle> Proceedings of the Eleventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 155-162, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: The coordinator log pro tocol suggested in [Stamos89] does not require a participant to flush the prepare record. Group commit [DeWitt84] strategies have been suggested in which log flushes of multiple transactions are grouped together to alleviate disk bandwidth problems; the Cedar sys tem <ref> [Hagmann87] </ref> uses this strategy. Non-blocking and 3-phase commit protocols have also been studied [Skeen81]. Camelot has implemented a non-blocking protocol but its perfor 16 mance is much worse than a 2-phase protocol [Duchamp89]. Non-blocking protocols are not of practical interest and systems rarely implement them.
Reference: [Herlihy90] <author> Herlihy M. </author> <title> Apologizing Versus Asking Permission: Optimistic Concurrency Control for Abstract Data Types. </title> <journal> ACM Transactions on Database Systems. </journal> <volume> Vol. 15, No. 1, </volume> <pages> pages 96-124, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Work done as part of a transaction is synchronized or validated at the end of the transaction. A transaction validates successfully and is committed if it can be serialized with other transactions in the system. If the transaction is not serializable, it is aborted. Herlihy <ref> [Herlihy90] </ref> has classified pessimistic and optimistic schemes respectively as ask ing permission first and apologizing later . Either of the two schemes can be employed for centralized or distributed systems. Section 1.1.1 presents the client-server model and the concurrency control schemes used by past and existing systems. <p> Their central ized server scheme for serial and parallel validation is generalized to a distributed system 15 in [Ceri82]. Haerder [Haerder84] has developed the notion of forward and backward valida tion. Optimistic schemes have also been extended to exploit the semantics of abstract data types <ref> [Herlihy90] </ref>. Gruber [Gruber89] has suggested validation-based optimistic schemes for the nested transaction model. A system implementation that caches objects and uses a classic optimistic scheme is Servio Logic's Gemstone [Maier86]. Gemstone is a distributed system that allows multiple clients but objects can be stored at only one server.
Reference: [Jul88] <author> Jul E., Levy H., Hutchinson N., Black A. </author> <title> Fine-Grained Mobility in the Emerald System. </title> <journal> ACM Transactions on Computer Systems. </journal> <volume> Vol. 6, No. 1, </volume> <pages> pages 109-133, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: The 2-phase commit protocol is also modified to guarantee atomic migration of objects. Our work on object migration is different from earlier work since our strategy is in tegrated with the concurrency control mechanism; we provide transaction semantics with respect to object migration also. The Hermes [Black90] and Emerald <ref> [Jul88] </ref> systems sup port object mobility but they do not have a client-server model like Thor and they do not support transactions.
Reference: [Kung81] <author> Kung H. T., Robinson J. T. </author> <title> On Optimistic Methods for Concurrency Control. </title> <journal> ACM Transactions on Database Systems 6 </journal> <pages> 213-226, </pages> <month> January </month> <year> 1983. </year>
Reference-contexts: Such a technique is being developed by Gruber [Gruber94]. Optimistic schemes have been discussed in the literature but we do not know of any multi-server distributed system that serializes transactions using such an approach. The seminal paper on optimistic concurrency control by Kung and Robinson <ref> [Kung81] </ref> moti vates the need for optimistic schemes and presents the idea of validation. Their central ized server scheme for serial and parallel validation is generalized to a distributed system 15 in [Ceri82]. Haerder [Haerder84] has developed the notion of forward and backward valida tion.
Reference: [Lai84] <author> Lai M., Wilkinson W. </author> <title> Distributed Transaction Management in Jasmin. </title> <booktitle> Proceedings of the Tenth International Conference on Very Large Data Bases, </booktitle> <pages> pages 466-470, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: The Jasmin database machine [Fishman84] also uses optimistic concurrency control for serializing trans actions; it too is a centralized server system. Their concurrency control control algorithm was later extended to the distributed case <ref> [Lai84] </ref>. However, they use multiple versions and also serialize transactions at a site in the order they are received. Some systems use a combination of optimistic and pessimistic schemes for serializing transactions. A hybrid optimistic-pessimistic scheme has been suggested in [Lausen82].
Reference: [Lamb91] <author> Lamb C., Landis G., Orenstein J., Weinreb D. </author> <title> The ObjectStore Database System. </title> <journal> Communications of the ACM, </journal> <volume> Vol. 34, No. 10, </volume> <month> October </month> <year> 1991. </year>
Reference-contexts: If the lock request fails, the client transaction is aborted. These schemes have been used by some systems, e.g., Symbolic's Statice system [Weinreb88] uses no-wait locks and ObjectStore <ref> [Lamb91] </ref> uses callback locking. In optimistic locking, a client does not acquire any locks before any operation; at the end of the transaction, a server waits for clients to release conflicting locks on relevant objects and commits the transaction.
Reference: [Lamport78] <author> Lamport L. </author> <title> Time, Clocks, and the Ordering of Events in a Distributed System. </title> <journal> Communications of the ACM. </journal> <volume> Vol. 21, No. 7, </volume> <pages> pages 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: A negotiation-based scheme has been suggested in [Sinha85], but it suffers from the disadvantage of an extra network roundtrip delay on the critical path. Essentially, these schemes synchronize the counters at various sites as part of the con currency control mechanism. The Thor model assumes that loosely synchronized clocks <ref> [Lamport78] </ref> are available in the system; this is a reasonable assumption for current sys tems where protocols such as the Network Time Protocol [Mills88] provide such a facility.
Reference: [Lampson93] <author> Lampson B., Lomet D. </author> <title> A New Presumed Commit Optimization for Two Phase Commit. </title> <type> Technical Report CRL 93-1, </type> <institution> Digital Equipment Corporation. Cambridge Research Laboratory, </institution> <address> Cambridge, </address> <month> February </month> <year> 1993. </year>
Reference-contexts: Furthermore, allowing read locks to be released at the end of phase one adds more complexity to the algorithm. Lampson and Lomet <ref> [Lampson93] </ref> have suggested a presumed-commit strategy that reduces the number of background log writes and messages for the normal case. But these gains are achieved at the cost of retaining some commit information forever.
Reference: [Lausen82] <author> Lausen G. </author> <title> Concurrency Control in Database Systems: A Step Towards the Integration of Optimistic Methods and Locking. </title> <booktitle> Proceeding of the ACM An nual Conference, </booktitle> <pages> pages 64-68, </pages> <month> October </month> <year> 1982. </year>
Reference-contexts: However, they use multiple versions and also serialize transactions at a site in the order they are received. Some systems use a combination of optimistic and pessimistic schemes for serializing transactions. A hybrid optimistic-pessimistic scheme has been suggested in <ref> [Lausen82] </ref>. Another hybrid scheme has been proposed in [Rahm90]; this scheme uses optimistic con currency control for a transaction but switches to locking if the transaction aborts. The object-oriented database Mneme [Moss90] provides support for such schemes.
Reference: [Levy91] <author> Levy E., Korth H. F., Silberschatz A. </author> <title> An Optimistic Commit Protocol for Distributed Transaction Management. </title> <booktitle> Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 88-97, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Non-blocking protocols are not of practical interest and systems rarely implement them. During the commit protocol for pessimistic systems, read-locks can be released dur ing the first phase but write-locks have to be retained till the second phases completes. Levy <ref> [Levy91] </ref> has developed a protocol where all locks can be released after preparing a transaction. But this protocol provides a weaker guarantee than serializability, making the transaction model quite complicated.
Reference: [Lindsay84] <author> Lindsay, B. G., Haas, L. M., Wilms, P.F., and Yost, R. A. </author> <title> Compu tation and Communication in R*: A Distributed Database Manager. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1), </volume> <month> February </month> <year> 1984. </year>
Reference-contexts: To simplify the transaction model, Thor does not support nested transactions. 1.1.2 The Commit Process When a client commits a transaction, the system has to ensure that all servers agree on committing or aborting the transaction. This effect is usually achieved with the help of a 2-phase commit protocol <ref> [Gray79, Mohan83, Lindsay84] </ref>. Many variations have been sug gested to optimize this protocol, e.g., presumed-abort/commit strategies. Mohan [Mohan83] has adapted the 2-phase commit protocol for a tree of processes. The coordinator log pro tocol suggested in [Stamos89] does not require a participant to flush the prepare record.
Reference: [Liskov84] <author> Liskov B. L. </author> <title> Overview of the Argus Language and System. Programming Methodology Group Memo 40, </title> <institution> MIT Laboratory for Computer Science, Cam bridge, </institution> <address> MA, </address> <month> February </month> <year> 1984. </year>
Reference-contexts: The nested transaction model has been explored and discussed in the literature. The idea of nested transactions was proposed in [Moss81]. Reed [Reed83] describes a timestamping strategy for serializing transactions in this model. Systems such as Argus <ref> [Liskov84] </ref> and Camelot [Spector87] provide a computational model that supports nested transactions using pessimistic locking. An optimistic scheme for this model has been presented in [Gruber89].
Reference: [Liskov91] <author> Liskov B. L. </author> <title> Practical uses of synchronized clocks in distributed systems. </title> <booktitle> Proceedings of the Tenth Annual ACM Symposium on Principles of Dis tributed Computing, </booktitle> <month> August </month> <year> 1991. </year>
Reference-contexts: Thus, the read-watermark approach avoids space overhead per object, but read-only participants still require a log record to be flushed on the critical path. The tm can avoid updating X r at a read-only participant using a technique suggested in <ref> [Liskov91] </ref>. The tm maintains a stable copy of the read-watermark called the stable read-watermark or X rs with the invariant: X rs X r . The stable read-watermark is a value maintained on stable storage. X r is only maintained in memory; it is not kept on stable storage.
Reference: [Liskov91a] <author> Liskov B. L., Ghemawat S., Gruber R., Johnson P., Shrira L., Williams M. </author> <title> Replication in the Harp file system. </title> <booktitle> Proceedings of the Thir teenth ACM Symposium on Operating Systems Principles, </booktitle> <month> October </month> <year> 1991. </year>
Reference: [Liskov93] <author> Liskov B., Day M., Shrira L. </author> <title> Distributed Object Management in Thor. </title> <editor> In M. Tamer Ozsu and Umesh Dayal and Patrick Valduriez, editors, </editor> <booktitle> Distributed Object Management. </booktitle> <address> San Mateo, California, </address> <year> 1993. </year>
Reference-contexts: Our object migration approach is integrated with the concurrency control mechanism; this strategy allows us to provide transaction semantics with respect to movement of objects. Our work has been done in the context of a new object-oriented database system, Thor. Thor <ref> [Liskov93] </ref> is a distributed system based on the client-server model. It provides persis tent and highly available storage for objects by storing them at the servers. Each client runs on a workstation and executes its operations as part of an atomic transaction. <p> Finally, Chapter 6 concludes the thesis and mentions the areas for future work. 20 Chapter 2 System Architecture of Thor This chapter gives an overview of the Thor object-oriented database system. We discuss only those aspects of Thor that are relevant to this thesis; for a complete description, see <ref> [Liskov93] </ref>. The terminology and conventions developed in this chapter are used in the remainder of the thesis. Thor is a new object-oriented database management system (oodbms) that can be used in heterogeneous distributed systems and allows programs written in different programming languages to share objects.
Reference: [Lomet93] <author> Lomet D. </author> <title> Using Timestamping to Optimize Two Phase Commit. </title> <booktitle> Proceed ings of the Second International Conference on Parallel and Distributed Sys tems, </booktitle> <pages> pages 48-55, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Levy [Levy91] has developed a protocol where all locks can be released after preparing a transaction. But this protocol provides a weaker guarantee than serializability, making the transaction model quite complicated. Lomet has suggested a timestamping scheme <ref> [Lomet93] </ref> for the two-phase commit pro tocol in a pessimistic system where a transaction commits at some nodes and continues processing at other nodes. In this approach, the participants vote a timestamp range to the coordinator for the transaction's commit time.
Reference: [Mah93] <author> Maheshwari U. </author> <title> Distributed Garbage Collection in a Client-Server, Trans actional Persistent Object System. </title> <type> S.M. thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1993. </year>
Reference-contexts: Fewer external references are beneficial for the distributed garbage collection algorithm also <ref> [Mah93] </ref>. Inter server references can be reduced by moving an object to a server where most references to it 18 reside or vice-versa. <p> Thor provides a persistent root for the object universe. An object becomes persistent if it becomes accessible from the persistent root. If an object becomes unreachable from the root, its storage is reclaimed by a distributed garbage col lector <ref> [Mah93] </ref>. Each object has a globally unique id called oid . Objects contain data and references to other Thor objects. They are encapsulated so that an application using Thor can access their state only by calling their methods.
Reference: [Maier86] <author> Maier D. et al. </author> <title> Development of an Object-Oriented DBMS. </title> <journal> Proceedings of Oopsla-86, Sigplan Notices, </journal> <volume> Vol. 21, No. 11, </volume> <month> Pages 472-482,November </month> <year> 1986. </year>
Reference-contexts: Optimistic schemes have also been extended to exploit the semantics of abstract data types [Herlihy90]. Gruber [Gruber89] has suggested validation-based optimistic schemes for the nested transaction model. A system implementation that caches objects and uses a classic optimistic scheme is Servio Logic's Gemstone <ref> [Maier86] </ref>. Gemstone is a distributed system that allows multiple clients but objects can be stored at only one server. The Jasmin database machine [Fishman84] also uses optimistic concurrency control for serializing trans actions; it too is a centralized server system. <p> As discussed in Chapter 3, this choice was primarily made for efficiency reasons. However, backward validation does offer weaker semantics compared to forward validation because an application can observe inconsistent states of the database. Application programmers must be aware of this fact and program accordingly. The designers of Gemstone <ref> [Maier86] </ref> did not find this problem to be severe. The asynchronous commit strategy suggested in this thesis is useful for applications that usually expect their commits to succeed.
Reference: [Mills88] <author> Mills D. L. </author> <title> Network Time Protocol (Version 1): Specification and Imple mentation. </title> <type> DARPA-Internet Report RFC 1059, </type> <month> July </month> <year> 1988. </year> <month> 93 </month>
Reference-contexts: In this thesis, we adapt the optimistic schemes that have been suggested in the past and propose a validation strategy that truncates transaction history information frequently without causing unnecessary aborts. We assume the availability of an external service such as NTP <ref> [Mills88] </ref> that provides loosely synchronized clocks. This assumption allows a server to generate an appropriate timestamp for a committing transaction; it has also helped us in simplifying the validation process. <p> Essentially, these schemes synchronize the counters at various sites as part of the con currency control mechanism. The Thor model assumes that loosely synchronized clocks [Lamport78] are available in the system; this is a reasonable assumption for current sys tems where protocols such as the Network Time Protocol <ref> [Mills88] </ref> provide such a facility. To choose a timestamp for transaction T, the coordinator server uses its local clock and augments it with the server id to make T.ts globally unique.
Reference: [Mohan83] <author> Mohan C., Lindsay B. </author> <title> Efficient Commit Protocols for the Tree of Processes Model of Distributed Transactions. </title> <booktitle> Proceedings of the 2nd Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 76-88, </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1983. </year>
Reference-contexts: To simplify the transaction model, Thor does not support nested transactions. 1.1.2 The Commit Process When a client commits a transaction, the system has to ensure that all servers agree on committing or aborting the transaction. This effect is usually achieved with the help of a 2-phase commit protocol <ref> [Gray79, Mohan83, Lindsay84] </ref>. Many variations have been sug gested to optimize this protocol, e.g., presumed-abort/commit strategies. Mohan [Mohan83] has adapted the 2-phase commit protocol for a tree of processes. The coordinator log pro tocol suggested in [Stamos89] does not require a participant to flush the prepare record. <p> This effect is usually achieved with the help of a 2-phase commit protocol [Gray79, Mohan83, Lindsay84]. Many variations have been sug gested to optimize this protocol, e.g., presumed-abort/commit strategies. Mohan <ref> [Mohan83] </ref> has adapted the 2-phase commit protocol for a tree of processes. The coordinator log pro tocol suggested in [Stamos89] does not require a participant to flush the prepare record.
Reference: [Mohan86] <author> Mohan C., Lindsay B., Obermarck R. </author> <title> Transaction Management in R* Distributed Database Management System. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol. 11, No. 4, </volume> <pages> pages 378-396, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: It must also log a commit record on stable storage before sending its acknowledgement message to the coordinator. Similarly, the coordinator needs to log a commit record before informing the application about the commit/abort decision. Our design uses the presumed-abort strategy <ref> [Mohan86] </ref> and also does not require phase 2 messages to be sent to read-only participants (for details of the 2-phase commit protocol, see [Mohan86]). Note that the frontend waits only while the first phase of the protocol is being executed. <p> Similarly, the coordinator needs to log a commit record before informing the application about the commit/abort decision. Our design uses the presumed-abort strategy <ref> [Mohan86] </ref> and also does not require phase 2 messages to be sent to read-only participants (for details of the 2-phase commit protocol, see [Mohan86]). Note that the frontend waits only while the first phase of the protocol is being executed. Thus, this phase of the commit protocol is said to have executed in the foreground (see Chapter 2).
Reference: [Moss81] <author> Moss J. E. B. </author> <title> Nested Transactions: An Approach to Reliable Distributed Computing. </title> <type> Technical Report 260, </type> <institution> MIT Laboratory for Computer Science, </institution> <address> Cambridge, MA, </address> <month> April </month> <year> 1981. </year>
Reference-contexts: However, it com plicates transaction processing and reduces the effective cache size at the server/client; multiple versions of objects have to maintained consuming more storage in the client cache. The nested transaction model has been explored and discussed in the literature. The idea of nested transactions was proposed in <ref> [Moss81] </ref>. Reed [Reed83] describes a timestamping strategy for serializing transactions in this model. Systems such as Argus [Liskov84] and Camelot [Spector87] provide a computational model that supports nested transactions using pessimistic locking. An optimistic scheme for this model has been presented in [Gruber89].
Reference: [Moss90] <author> Moss J. E. B. </author> <title> Design of the Mneme Persistent Object Store. </title> <journal> ACM Trans actions on Information Systems, </journal> <volume> 8(2), </volume> <pages> pages 103-139, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: A hybrid optimistic-pessimistic scheme has been suggested in [Lausen82]. Another hybrid scheme has been proposed in [Rahm90]; this scheme uses optimistic con currency control for a transaction but switches to locking if the transaction aborts. The object-oriented database Mneme <ref> [Moss90] </ref> provides support for such schemes. The idea of hybrid concurrency control schemes has been applied to file systems also. <p> An object fetched from a server contains references in the form of xrefs. The frontend converts these references into virtual memory pointers of cached objects for better perfor mance. This process is termed as swizzling <ref> [Moss90] </ref>. The frontend may swizzle an object x on receiving it from the server or it may swizzle x lazily, i.e., swizzle the references when x is accessed for the first time by the application. Furthermore, it may or may not swizzle a complete object.
Reference: [Mull85] <author> Mullender S. J., Tanenbaum A. S. </author> <title> A Distributed File Service Based on Optimistic Concurrency Control. </title> <booktitle> Proceedings of the Tenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 51-62, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: The object-oriented database Mneme [Moss90] provides support for such schemes. The idea of hybrid concurrency control schemes has been applied to file systems also. The Amoeba file system <ref> [Mull85] </ref> employs such a technique for modifying files; updates on a single file are serialized using optimistic concurrency control whereas locking is used to modify multiple files. A multiversion pessimistic scheme that does not require read-only transactions to syn chronize with other transactions was suggested in [Weihl87].
Reference: [Oki85] <author> Oki B., Liskov B., Scheifler R. </author> <title> Reliable Object Storage to Support Atomic Actions. </title> <booktitle> Proceedings of the Tenth ACM Symposium on Operating Systems Principles, </booktitle> <month> Decemeber </month> <year> 1985. </year>
Reference-contexts: Instead, it can send this information during the execution phase of a transaction. This scheme has the advantage that the commit time delay is amortized over a transaction's lifetime; a similar scheme has been proposed in <ref> [Oki85] </ref>. The frontend piggybacks the current transaction's read/write information on fetch requests and liveness messages. At commit time, most of the transaction information has already reached the participants and the frontend just needs to send small commit-request/prepare messages.
Reference: [Oki88] <author> Oki B., Liskov B. </author> <title> Viewstamped Replication: A New Primary Copy Method to Support Highly-Available Distributed Systems. </title> <booktitle> Proceedings of the Seventh ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1988. </year>
Reference-contexts: A server A also maintains a table called the inlist that keeps track of objects at other servers that have references to objects at A. Each server is replicated to make objects highly available. We plan to use a primary copy scheme for replication <ref> [Oki88] </ref>. In this scheme, each server's objects will be replicated 22 at a number of machines. For each object, one of the machines that has a copy of that object will act as the primary server and the others act as backup servers. <p> If t a is sufficiently less then the time taken to complete a view change <ref> [Oki88] </ref>, the probability of a transaction being aborted due to the reinitialization of X r with X rs becomes insignificant. 3.4.2 Implementing the Version Field The preceding discussion assumed that an object's version field stores the timestamp of the transaction that installed the latest version.
Reference: [Powell83] <author> Powell M. L., Miller B. P. </author> <title> Process Migration in DEMOS/MP. </title> <booktitle> Proceed ings of the Ninth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 110-119, </pages> <month> October </month> <year> 1983. </year>
Reference-contexts: This model is neither a client-server model nor is it possible to move a set of objects to a specific site. Research has been conducted in the area of process migration for various operating environments. Systems such as Sprite [Douglis91], V [Theimer85], DEMOS/MP <ref> [Powell83] </ref> and Accent [Zayas87] support this facility. Some of the problems faced in process migration schemes are similar to the ones faced in Thor, e.g., forwarding pointers have to be left at the old site and all relevant operations have to routed to the new site.
Reference: [Rahm90] <author> Rahm E., Thomasian A. </author> <title> A New Distributed Optimistic Concurrency Con trol Method and a Comparison of its Performance with Two-Phase Locking. </title> <booktitle> Proceedings of the 10th International Conference on Distributed Computer Systems, </booktitle> <year> 1990. </year>
Reference-contexts: However, they use multiple versions and also serialize transactions at a site in the order they are received. Some systems use a combination of optimistic and pessimistic schemes for serializing transactions. A hybrid optimistic-pessimistic scheme has been suggested in [Lausen82]. Another hybrid scheme has been proposed in <ref> [Rahm90] </ref>; this scheme uses optimistic con currency control for a transaction but switches to locking if the transaction aborts. The object-oriented database Mneme [Moss90] provides support for such schemes. The idea of hybrid concurrency control schemes has been applied to file systems also.
Reference: [Reed83] <author> Reed D. P. </author> <title> Implementing Atomic Actions on Decentralized Data. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol. 1, No. 1, </volume> <pages> pages 3-23, </pages> <month> February </month> <year> 1983. </year>
Reference-contexts: The nested transaction model has been explored and discussed in the literature. The idea of nested transactions was proposed in [Moss81]. Reed <ref> [Reed83] </ref> describes a timestamping strategy for serializing transactions in this model. Systems such as Argus [Liskov84] and Camelot [Spector87] provide a computational model that supports nested transactions using pessimistic locking. An optimistic scheme for this model has been presented in [Gruber89].
Reference: [Sinha85] <author> Sinha K. M., Nandikar P.D., Mehndiratta S. L. </author> <title> Timestamp based certification schemes for transactions in distributed database systems. </title> <booktitle> Pro ceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pp 402-411, </pages> <year> 1985. </year>
Reference-contexts: But this scheme can lead to unnecessary aborts or retries because the counters at different servers are not updated at the same rate. A negotiation-based scheme has been suggested in <ref> [Sinha85] </ref>, but it suffers from the disadvantage of an extra network roundtrip delay on the critical path. Essentially, these schemes synchronize the counters at various sites as part of the con currency control mechanism.
Reference: [Skeen81] <author> Skeen D. </author> <title> Nonblocking Commit Protocols. </title> <booktitle> Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 133-142, </pages> <month> May </month> <year> 1981. </year> <month> 94 </month>
Reference-contexts: Group commit [DeWitt84] strategies have been suggested in which log flushes of multiple transactions are grouped together to alleviate disk bandwidth problems; the Cedar sys tem [Hagmann87] uses this strategy. Non-blocking and 3-phase commit protocols have also been studied <ref> [Skeen81] </ref>. Camelot has implemented a non-blocking protocol but its perfor 16 mance is much worse than a 2-phase protocol [Duchamp89]. Non-blocking protocols are not of practical interest and systems rarely implement them.
Reference: [Spector87] <author> Spector A. Z. et al. Camelot: </author> <title> A Distributed Transaction Facility for Mach and the Internet An Interim Report. </title> <type> Technical Report CMU-CS 87-129, </type> <institution> Deparment of Computer Science, Carnegie Mellon University, Pitts burgh, </institution> <address> PA, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: The nested transaction model has been explored and discussed in the literature. The idea of nested transactions was proposed in [Moss81]. Reed [Reed83] describes a timestamping strategy for serializing transactions in this model. Systems such as Argus [Liskov84] and Camelot <ref> [Spector87] </ref> provide a computational model that supports nested transactions using pessimistic locking. An optimistic scheme for this model has been presented in [Gruber89].
Reference: [Stamos89] <author> Stamos J. W. </author> <title> A Low-Cost Atomic Commit Protocol. </title> <institution> Research Report RJ7185, IBM, </institution> <address> San Jose, CA, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: This effect is usually achieved with the help of a 2-phase commit protocol [Gray79, Mohan83, Lindsay84]. Many variations have been sug gested to optimize this protocol, e.g., presumed-abort/commit strategies. Mohan [Mohan83] has adapted the 2-phase commit protocol for a tree of processes. The coordinator log pro tocol suggested in <ref> [Stamos89] </ref> does not require a participant to flush the prepare record. Group commit [DeWitt84] strategies have been suggested in which log flushes of multiple transactions are grouped together to alleviate disk bandwidth problems; the Cedar sys tem [Hagmann87] uses this strategy. <p> But the Thor model assumes that crashes are rare. It would be preferable to develop a strategy that reduces the number of foreground log flushes for the normal case, i.e., when there are no crashes. A strategy, called the coordinator log protocol, has been suggested in <ref> [Stamos89] </ref> to achieve this effect. The basic idea is to avoid a synchronous log flush (forcing the record before sending the vote reply) of the prepare record by a participant.
Reference: [Tam90] <author> Tam V., Hsu M. </author> <title> Token Transactions: Managing Fine-Grained Migration of Data. </title> <booktitle> Proceedings of the Ninth Symposium on Principles of Database Systems, </booktitle> <pages> pages 344-356, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: The Hermes [Black90] and Emerald [Jul88] systems sup port object mobility but they do not have a client-server model like Thor and they do not support transactions. The design suggested for a pessimistic system in <ref> [Tam90] </ref> supports transactions in a model where objects are migrated from one site to another if the latter site wants to modify the object. This model is neither a client-server model nor is it possible to move a set of objects to a specific site.
Reference: [Theimer85] <author> Theimer M. M., Lantz K. A., Cheriton D. R. </author> <title> Preemtable Remote Execution Facilities in for the V-system. </title> <booktitle> Proceedings of the Tenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 2-12, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: This model is neither a client-server model nor is it possible to move a set of objects to a specific site. Research has been conducted in the area of process migration for various operating environments. Systems such as Sprite [Douglis91], V <ref> [Theimer85] </ref>, DEMOS/MP [Powell83] and Accent [Zayas87] support this facility. Some of the problems faced in process migration schemes are similar to the ones faced in Thor, e.g., forwarding pointers have to be left at the old site and all relevant operations have to routed to the new site.
Reference: [Walds92] <author> Waldspurger C. et al. Spawn: </author> <title> A Distributed Computational Economy, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 18, No. 2, </volume> <month> February </month> <year> 1992. </year>
Reference-contexts: It would be interesting to design a utility that tries to make intelligent decisions based on different characteristics of the system and migrates objects. Previous work done in the area of load-balancing <ref> [Walds92] </ref> and process migration [Douglis91] can be used for designing this facility. This utility can monitor different aspects of the system and reconfigure the object placement accordingly.
Reference: [Wang91] <author> Wang Y., Rowe L. A. </author> <title> Cache Consistency and Concurrency Control in a Client/Server DBMS Architecture. </title> <booktitle> Proceedings of ACM SIGMOD Interna tional Conference on Management of Data, </booktitle> <pages> pages 367-376, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Note that this scheme is different from a classical optimistic scheme where instead of acquiring locks at the end of the transaction, the servers execute a validation algorithm to check if the transaction has violated any serializability constraints. Franklin [Franklin92] and Wang <ref> [Wang91] </ref> have conducted studies to compare the perfor mance of these schemes for different workloads in a client-server model. These concurrency studies indicate that callback, no-wait and optimistic locking provide higher throughput than regular locking for most workloads.
Reference: [Weihl87] <author> Weihl W. </author> <title> Distributed Version Management for Read-Only Actions. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-13, No. 1, </volume> <month> January </month> <year> 1987. </year>
Reference-contexts: A multiversion pessimistic scheme that does not require read-only transactions to syn chronize with other transactions was suggested in <ref> [Weihl87] </ref>. An optimistic strategy that achieves the same effect has been presented in [Agarwal87]. Maintaining multiple versions may permit more transactions to commit than a single version scheme.
Reference: [Weinreb88] <author> Weinreb D. et al. </author> <title> An Object-Oriented Database System to Support an Integrated Programming Environment. </title> <journal> IEEE Database Engineering Bulletin, </journal> 11(2):(33-43), June 1988. 
Reference-contexts: In no-wait locking, a client requests a lock but does not wait for the reply from the server; client processing proceeds in parallel with the lock request. If the lock request fails, the client transaction is aborted. These schemes have been used by some systems, e.g., Symbolic's Statice system <ref> [Weinreb88] </ref> uses no-wait locks and ObjectStore [Lamb91] uses callback locking. In optimistic locking, a client does not acquire any locks before any operation; at the end of the transaction, a server waits for clients to release conflicting locks on relevant objects and commits the transaction.
Reference: [Zayas87] <author> Zayas E. R. </author> <title> Attacking the Process Migration Bottleneck. </title> <booktitle> Proceedings of the Eleventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 13-24, </pages> <month> November </month> <year> 1987. </year> <month> 95 </month>
Reference-contexts: This model is neither a client-server model nor is it possible to move a set of objects to a specific site. Research has been conducted in the area of process migration for various operating environments. Systems such as Sprite [Douglis91], V [Theimer85], DEMOS/MP [Powell83] and Accent <ref> [Zayas87] </ref> support this facility. Some of the problems faced in process migration schemes are similar to the ones faced in Thor, e.g., forwarding pointers have to be left at the old site and all relevant operations have to routed to the new site.
References-found: 58

