URL: http://ftp.eecs.umich.edu/people/rundenst/papers/r-93-6.ps
Refering-URL: http://ftp.eecs.umich.edu/people/rundenst/papers/
Root-URL: http://www.eecs.umich.edu
Title: COMPONENT SYNTHESIS FROM FUNCTIONAL DESCRIPTIONS  
Author: Elke A. Rundensteiner Daniel D. Gajski flfl and Lubomir Bic flfl 
Keyword: Key Words: Functional Synthesis, Component Modeling, Functionality Recognition and Reduction, Register-Transfer Level Technology Mapping, Compatibility Graph.  
Note: Elke A. Rundensteiner was a Ph.D. student at the University of California, Irvine when performing this research. Her email address is rundenst@eecs.umich.edu.  
Address: 1301 Beal Ave.  Ann Arbor, Mi 48109-2122  Irvine, CA 92717  
Affiliation: Dept. of Electrical Eng. and Computer Science  University of Michigan  flfl Department of Information and Computer Science University of California, Irvine  
Abstract: In the literature, it is generally overlooked that designers use functional models more frequently than behavioral or gate-level models. In functional modeling, the functionality of one or more components, like arithmetic/logic units, memories, and counters, are described as separate concurrent blocks. We present an algorithm, called Functional Synthesis Algorithm (FSA), for synthesis from these functional descriptions. Our algorithm automatically synthesizes components needed to implement a functional description while minimizing hardware costs and performance. Since a functional description uses standard operators in the hardware description language, a mismatch between the operators of the language and the functionalities provided by library components arises. FSA solves this functionality mismatch problem by pattern matching of the description against a library of function patterns. In addition, FSA clusters functions to maximally match components from a given library. Experimental results show that automated functional synthesis produces designs that are comparable to those produced by human designers. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. K. Brayton, Richard Rudell, Alberto Sangiovanni-Vincentelli, and Albert R. Wang, </author> <title> MIS: A multiple-level logic optimization system, </title> <journal> IEEE Trans. on Computer-Aided Design, </journal> <month> Nov. </month> <year> 1987. </year> <month> 21 </month>
Reference-contexts: Given that both functional and behavioral abstractions are appropriate for describing certain types of designs, a production-quality synthesis system must handle both in order to be a useful tool. <ref> [1, 6] </ref>. High-level synthesis maps a behavioral description of the desired system to a RTL structure of generic components [15, 20]. Functional synthesis synthesizes a functional description of one or possibly several RTL components to component (s) from a given (technology-specific) library. <p> Functional synthesis introduced in this 4 paper synthesizes an arbitrarily complex functional description into component (s) from a technology-specific library. 2.3 Logic Level Synthesis Technology mapping at the logic level transforms optimized Boolean equations into an interconnection of technology-specific logic elements from a given library of gates <ref> [6, 1, 10] </ref>. Functional synthesis is concerned with technology mapping at a higher abstraction level of design, namely, functional design. The number of different patterns in functional synthesis is much smaller than in logic synthesis. A Boolean function can be described by many different combinations of logic operators.
Reference: [2] <author> R. Camposano, </author> <title> Path-Based Scheduling for Synthesis, </title> <journal> IEEE Trans. on Computer-Aided Design, </journal> <volume> Vol. 10, No. 1., </volume> <pages> pp. 85 - 93, </pages> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: Experimental results and conclusions are discussed in Sections 7 and 8, respectively. 3 2 RELATED RESEARCH 2.1 Behavioral Level Synthesis Since functional descriptions are used for concurrent finite-state designs, scheduling needed for high-level synthesis <ref> [20, 15, 2] </ref> is not applicable to functional synthesis. Therefore, sharing of units for operators in different time steps (states) is not needed. Functional synthesis is however related to the allocation and binding tasks in behavioral synthesis [20, 15].
Reference: [3] <author> N. D. Dutt and J. R. Kipps, </author> <title> Bridging High-Level Synthesis to RTL Technology Libraries, </title> <booktitle> Proc. 28th Design Automation Conf., </booktitle> <pages> pp. 526-529, </pages> <year> 1991. </year>
Reference-contexts: Functional synthesis synthesizes a functional description of one or possibly several RTL components to component (s) from a given (technology-specific) library. It can thus work in synergism with behavioral synthesis by mapping (functional descriptions of) RTL designs produced by the latter onto actual hardware <ref> [3] </ref>. Lastly, logic synthesis corresponds to automated design and logic optimization at the gate level. As can be seen in Figure 2, functional synthesis bridges the gap between behavioral and logic-level synthesis by addressing the technology mapping problem at the RTL level. <p> As can be seen in Figure 2, functional synthesis bridges the gap between behavioral and logic-level synthesis by addressing the technology mapping problem at the RTL level. Previous work has focussed on translating a generic RTL structure into a technology-specific one <ref> [8, 3] </ref>. These approaches were structure-based, i.e., they work on structural netlists that capture designs as a set of black boxes and their interconnections rather than functional descriptions. <p> Lastly, due to the smaller scope of functional compared to high-level synthesis problems, FSA finds optimal solutions for most example designs. 2.2 Register-Transfer Level Technology Mapping Previous work on RTL technology mapping has focussed on translating a generic RTL structure into a technology-specific one <ref> [8, 3] </ref>. These approaches work on structural netlists that capture designs as a set of black boxes and their interconnections rather than functional descriptions. <p> SYNNER also performs some logic optimization by reducing certain cascaded logic operations into one logic operation, e.g., it replaces two 2-bit ANDS by one 3-bit AND ([8], page 31). In contrast to this, FSA's library-driven approach represents a general solution toward functionality recognition. Dutt and Kipps <ref> [3] </ref> address the mapping of generic RTL components (with a fixed set of functions) into technology-specific RTL library cells using a rule-based approach.
Reference: [4] <author> N. D. Dutt, </author> <title> Generic Component Library Characterization for High Level Synthesis, </title> <booktitle> VLSI Design 91, The Fourth CSI/IEEE International Symposium on VLSI Design, </booktitle> <address> New Delhi, India, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: It consists of approximately 15,000 lines of C code not including the VHDL input compiler [9]. The experiments presented below are based on the following examples. Example 1 is an Adder/Subtracter from <ref> [4] </ref>; examples 2 and 3 are variations of an ALU from the Mano book ([11], pg. 337 and pg. 242); example 4 is a functionally reduced version of the TI 74181 ALU [21]; example 5 is a divide-by-3328 counter design from Rockwell; example 6 describes a combination of a counting and <p> the inputs of a commutative operation. 7.2 Technology Adaptation In this second experiment, we explore FSA's ability to perform technology adaptation by replacing the component-specific information by different libraries: (a) the TTL library [21], (b) the Mano library [11], and (c) the Generic Component Library GENUS developed at UC Irvine <ref> [4] </ref>. The Mano library contains a number of the components described in [11] in addition to all components from the Genus library, while the TTL library contains the components of the TTL library [21] plus those from Mano.
Reference: [5] <author> M. Kahrs, </author> <title> Matching a parts library in a silicon compiler, </title> <booktitle> Proc. Int. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 169-172, </pages> <year> 1986. </year>
Reference: [6] <author> K. Keutzer, DAGON: </author> <title> Technology Binding and Local Optimization by DAG Matching, </title> <booktitle> Proc. 24th Design Automation Conf., </booktitle> <pages> pp. 617-623, </pages> <year> 1987. </year>
Reference-contexts: Given that both functional and behavioral abstractions are appropriate for describing certain types of designs, a production-quality synthesis system must handle both in order to be a useful tool. <ref> [1, 6] </ref>. High-level synthesis maps a behavioral description of the desired system to a RTL structure of generic components [15, 20]. Functional synthesis synthesizes a functional description of one or possibly several RTL components to component (s) from a given (technology-specific) library. <p> Functional synthesis introduced in this 4 paper synthesizes an arbitrarily complex functional description into component (s) from a technology-specific library. 2.3 Logic Level Synthesis Technology mapping at the logic level transforms optimized Boolean equations into an interconnection of technology-specific logic elements from a given library of gates <ref> [6, 1, 10] </ref>. Functional synthesis is concerned with technology mapping at a higher abstraction level of design, namely, functional design. The number of different patterns in functional synthesis is much smaller than in logic synthesis. A Boolean function can be described by many different combinations of logic operators. <p> A Boolean function can be described by many different combinations of logic operators. The functions of current RTL components are rather simple and thus can be described by one statement. Therefore, FSA uses a simple pattern matching and reduction algorithm rather than the sophisticated approaches proposed for logic synthesis <ref> [6, 10] </ref>. 3 PROBLEM DESCRIPTION The input for functional synthesis is a functional description of a design written in a hardware description language 1 . The input description shown in Figure 3 consists of three concurrent conditional statements.
Reference: [7] <author> G. W. Leive, </author> <title> The Design, Implementation, and Analysis of the Automated Logic Synthesis and Module Selection System, </title> <institution> Carnegie-Mellon University, </institution> <type> Ph.D. Thesis, </type> <year> 1981. </year>
Reference-contexts: These approaches work on structural netlists that capture designs as a set of black boxes and their interconnections rather than functional descriptions. SYNNER <ref> [7, 8] </ref> takes a localized approach to the problem by selecting a component to implement a data path node one at a time based on some local criterion ([8], page 479).
Reference: [8] <author> G. W. Leive and D. E. Thomas, </author> <title> A Technology Relative Logic Synthesis and Module Selection System, </title> <booktitle> Proc. 18th Design Automation Conf., </booktitle> <pages> pp. 479-485, </pages> <year> 1981. </year>
Reference-contexts: As can be seen in Figure 2, functional synthesis bridges the gap between behavioral and logic-level synthesis by addressing the technology mapping problem at the RTL level. Previous work has focussed on translating a generic RTL structure into a technology-specific one <ref> [8, 3] </ref>. These approaches were structure-based, i.e., they work on structural netlists that capture designs as a set of black boxes and their interconnections rather than functional descriptions. <p> Lastly, due to the smaller scope of functional compared to high-level synthesis problems, FSA finds optimal solutions for most example designs. 2.2 Register-Transfer Level Technology Mapping Previous work on RTL technology mapping has focussed on translating a generic RTL structure into a technology-specific one <ref> [8, 3] </ref>. These approaches work on structural netlists that capture designs as a set of black boxes and their interconnections rather than functional descriptions. <p> These approaches work on structural netlists that capture designs as a set of black boxes and their interconnections rather than functional descriptions. SYNNER <ref> [7, 8] </ref> takes a localized approach to the problem by selecting a component to implement a data path node one at a time based on some local criterion ([8], page 479).
Reference: [9] <author> J. S. Lis and D. D. Gajski, </author> <title> Synthesis from VHDL, </title> <booktitle> ICCD, </booktitle> <pages> pp. 378-381, </pages> <year> 1988. </year>
Reference-contexts: &lt;= A + B when "00", A - B + "0001" when "11"; entity design1 is port (F : in BIT-VECTOR (1 downto 0); D : out BIT-VECTOR (3 downto 0) architecture design1-body of design1 is begin (b) Partitioned ECDFG. (d) Maximally Merged ECDFG.(c) Reduced ECDFG. (1) A language compiler <ref> [9] </ref> parses the input description, a functional description, into an internal ECDFG design representation [18]. <p> The netlist generator then creates a netlist of the resulting structure. In Figure 5 (d), the final design is produced by mapping the multi-functional operator node to an Adder/Subtracter unit <ref> [9] </ref>. 5 FUNCTIONALITY RECOGNITION A functional description uses standard language operators that do not always correspond directly to component functions. FSA solves this functionality mismatch by transforming a design representation of generic operator nodes into a representation consisting of library-supported operator nodes. <p> It consists of approximately 15,000 lines of C code not including the VHDL input compiler <ref> [9] </ref>. The experiments presented below are based on the following examples.
Reference: [10] <author> F. Mailhot and G. De Micheli, </author> <title> Technology Mapping Using Boolean Matching and Don't Care Sets. </title> <booktitle> Proc. European Conf. on Computer-Aided Design, </booktitle> <pages> pp. 212 - 216, </pages> <year> 1990. </year>
Reference-contexts: Functional synthesis introduced in this 4 paper synthesizes an arbitrarily complex functional description into component (s) from a technology-specific library. 2.3 Logic Level Synthesis Technology mapping at the logic level transforms optimized Boolean equations into an interconnection of technology-specific logic elements from a given library of gates <ref> [6, 1, 10] </ref>. Functional synthesis is concerned with technology mapping at a higher abstraction level of design, namely, functional design. The number of different patterns in functional synthesis is much smaller than in logic synthesis. A Boolean function can be described by many different combinations of logic operators. <p> A Boolean function can be described by many different combinations of logic operators. The functions of current RTL components are rather simple and thus can be described by one statement. Therefore, FSA uses a simple pattern matching and reduction algorithm rather than the sophisticated approaches proposed for logic synthesis <ref> [6, 10] </ref>. 3 PROBLEM DESCRIPTION The input for functional synthesis is a functional description of a design written in a hardware description language 1 . The input description shown in Figure 3 consists of three concurrent conditional statements. <p> We may also want to study whether there is any gain in replacing the simple pattern matching procedure used by FSA for functionality reduction by a more sophisticated method, such as those used in Boolean technology mapping <ref> [10] </ref>. ACKNOWLEDGEMENTS. This work was supported by NSF grant MIP-8922851, California MICRO grant #89-057, and contributions from TRW Inc. Elke A. Rundensteiner also thanks IBM for granting her an IBM Graduate Fellowship. We thank J.
Reference: [11] <author> M. M. Mano, </author> <title> Computer Engineering Hardware Design, </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1988. </year>
Reference-contexts: an ALU from the Mano book (<ref> [11] </ref>, pg. 337 and pg. 242); example 4 is a functionally reduced version of the TI 74181 ALU [21]; example 5 is a divide-by-3328 counter design from Rockwell; example 6 describes a combination of a counting and a logic unit with partially permuted inputs [11]; example 7 the ALU including input multiplexors and latches of the Am2901 [13]; examples 8 and 9 describe several concurrently executing components with shared input multiplexors and register files. 7.1 Design Quality and Algorithm Performance In the first experiment (Table 1), we explore the features and limitations of FSA using <p> The designer improved Mano2 by recognizing its equivalence with the Mano1 description. Namely, the Mano2 description uses complex expressions, such as "A + ones-complement (B) + 1" and "A + ones-complement (B)" in place of simpler expressions, such as, "A - B", and "A - B - 1" <ref> [11] </ref>. The latter functions are directly supported by the ALU in the underlying library, while the former are not. FSA's results could be improved for this example by adding the respective function patterns to FSA's functionality table. <p> The designer produced a better design for the CntLog example by reversing the inputs of a commutative operation. 7.2 Technology Adaptation In this second experiment, we explore FSA's ability to perform technology adaptation by replacing the component-specific information by different libraries: (a) the TTL library [21], (b) the Mano library <ref> [11] </ref>, and (c) the Generic Component Library GENUS developed at UC Irvine [4]. The Mano library contains a number of the components described in [11] in addition to all components from the Genus library, while the TTL library contains the components of the TTL library [21] plus those from Mano. <p> experiment, we explore FSA's ability to perform technology adaptation by replacing the component-specific information by different libraries: (a) the TTL library [21], (b) the Mano library <ref> [11] </ref>, and (c) the Generic Component Library GENUS developed at UC Irvine [4]. The Mano library contains a number of the components described in [11] in addition to all components from the Genus library, while the TTL library contains the components of the TTL library [21] plus those from Mano. The results using FSA with the B&B Component Mapper and ff=1 are given in Table 2.
Reference: [12] <author> M. C. McFarland, A. C. Parker, and R. Camposano, </author> <title> Tutorial on High Level Synthesis, </title> <booktitle> Proc. 25th Design Automation Conf., </booktitle> <pages> pp. 330-336, </pages> <month> June </month> <year> 1988. </year>
Reference: [13] <author> J. Mick and J. </author> <title> Brick, Bit-Slice Micro-Processor Design, </title> <address> McGrawHill, </address> <year> 1980. </year>
Reference-contexts: 4 is a functionally reduced version of the TI 74181 ALU [21]; example 5 is a divide-by-3328 counter design from Rockwell; example 6 describes a combination of a counting and a logic unit with partially permuted inputs [11]; example 7 the ALU including input multiplexors and latches of the Am2901 <ref> [13] </ref>; examples 8 and 9 describe several concurrently executing components with shared input multiplexors and register files. 7.1 Design Quality and Algorithm Performance In the first experiment (Table 1), we explore the features and limitations of FSA using a variety of different parameter settings and the TTL library [21].
Reference: [14] <author> B. M. Pangrle, Slicer: </author> <title> A Heuristic Approach to Connectivity Binding, </title> <booktitle> Proc. 25th Design Automation Conf., </booktitle> <pages> pp. 536-541, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: FSA uses a more accurate profit function than HAL [15]. Also HAL's [15] overall control strategy is greedy, and thus cannot guarantee an optimal solution. Given a fixed resource allocation and a schedule, Splicer <ref> [14] </ref> minimizes the number of connections between functional units and registers by using a branch-and-bound search with the number of multiplexers as criterion. Splicer uses a heuristic function in place of a proper bounding function which removes the guarantee of finding an optimal solution.
Reference: [15] <author> G. P. Paulin and J. P. Knight, </author> <title> Scheduling and Binding Algorithms for High-Level Synthesis, </title> <booktitle> Proc. 26th Design Automation Conf., </booktitle> <pages> pp. 1 - 6, </pages> <year> 1989. </year>
Reference-contexts: Given that both functional and behavioral abstractions are appropriate for describing certain types of designs, a production-quality synthesis system must handle both in order to be a useful tool. [1, 6]. High-level synthesis maps a behavioral description of the desired system to a RTL structure of generic components <ref> [15, 20] </ref>. Functional synthesis synthesizes a functional description of one or possibly several RTL components to component (s) from a given (technology-specific) library. It can thus work in synergism with behavioral synthesis by mapping (functional descriptions of) RTL designs produced by the latter onto actual hardware [3]. <p> Experimental results and conclusions are discussed in Sections 7 and 8, respectively. 3 2 RELATED RESEARCH 2.1 Behavioral Level Synthesis Since functional descriptions are used for concurrent finite-state designs, scheduling needed for high-level synthesis <ref> [20, 15, 2] </ref> is not applicable to functional synthesis. Therefore, sharing of units for operators in different time steps (states) is not needed. Functional synthesis is however related to the allocation and binding tasks in behavioral synthesis [20, 15]. <p> Therefore, sharing of units for operators in different time steps (states) is not needed. Functional synthesis is however related to the allocation and binding tasks in behavioral synthesis <ref> [20, 15] </ref>. EMERALD [20] formulates allocation as clique partitioning problem, but it can handle only straight-line blocks of assignment statements. Also, operators are grouped into sets of functions that do not necessarily correspond to the functionalities supported by existing RTL components. <p> In our work, we overcome this problem by prepruning the solution space based on the mergeability information derived from the given component library. FSA uses a more accurate profit function than HAL <ref> [15] </ref>. Also HAL's [15] overall control strategy is greedy, and thus cannot guarantee an optimal solution. Given a fixed resource allocation and a schedule, Splicer [14] minimizes the number of connections between functional units and registers by using a branch-and-bound search with the number of multiplexers as criterion. <p> In our work, we overcome this problem by prepruning the solution space based on the mergeability information derived from the given component library. FSA uses a more accurate profit function than HAL <ref> [15] </ref>. Also HAL's [15] overall control strategy is greedy, and thus cannot guarantee an optimal solution. Given a fixed resource allocation and a schedule, Splicer [14] minimizes the number of connections between functional units and registers by using a branch-and-bound search with the number of multiplexers as criterion. <p> By combining the branch-and-bound methodology with clique partitioning, FSA succeeds in pruning the search space without losing the guarantee of an optimal solution. In summary, FSA handles nested conditional branches. We do not assume a preallocation of functional units and unit binding as done in <ref> [15] </ref>. Our cost functions incorporate costs for both interconnection (in terms of multiplexors) and control costs (in terms of function select logic).
Reference: [16] <author> E. A. Rundensteiner, </author> <title> Object-Oriented Views: A Novel Approach to Tool Integration in Design Environments, </title> <type> Dissertation, </type> <institution> Info. and Computer Science Dept. Univ. of Cal. Irvine, </institution> <type> Tech. Rep. </type> <pages> 92-83, </pages> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: 5 would no longer be mutually exclusive because not all paths from n 5 would go through d 1 . 3 FSA actually utilizes a more general notion of mutually exclusiveness based on conditional expressions rather than on the existence of decision nodes; see discussion in Section 6.1 and in <ref> [16] </ref>. 6 v1 v2 v3 v1 v4 v6 v7 n2 (+) (-) (+) (+) (or) (and) (+) r6 r7 r11 r3 r4 r16 r15 (=) n3 r5 expression tree E root of expression tree data port control port decision node storage node operation node data arc a1 a4 E2 An expression <p> P i 2 P is a partition of G into subgraphs G i and M i 2 M is a legal mapping from P i to a set of functional units from U that minimizes the cost of the resulting design measured by a weighted sum of area and performance <ref> [16] </ref>. 7 4 OUR APPROACH TOWARDS FUNCTIONAL SYNTHESIS In this section, we outline our approach in solving the functional synthesis problem, while more detailed algorithms will be presented in later sections. The library-specific information used by FSA is kept in two tables, the functionality table and the unit table. <p> Figure 9 (b) shows how the corresponding CG is transformed. If all decisions for merging operator nodes have been made, i.e., CG = ;, then the solution pair (G; CG) is called a complete solution. Otherwise, it is a partial solution <ref> [16] </ref>. While reducing the number of operator units from two to one and the size of the decision node, new costs accrue in the form of more complex components and increased interconnection and control costs. <p> The area benefit includes area-operator-costs (n) := bound node area (n) bound node area (n 1 ) bound node area (n 2 ) (with bound node area () the minimal cost of implementing an operator node <ref> [16] </ref>) plus function decode and connection costs. <p> The delay benefit includes delay-operator-costs (n) := max ( bound node delay (n) bound node delay (n 1 ), bound node delay (n) - bound node delay (n 2 )) plus interconnection delay; with bound node delay () the minimal delay of implementing an operator node <ref> [16] </ref>. 6.5 The Heuristic Component Mapper FSA reformulates the component mapping problem as a clique partitioning problem on CG [20]. The goal is to find a minimal cost clique partition of the set of operator nodes of CG such that each clique can be mapped to one multi-functional unit. <p> SI e2 e5 - e3 AI + e2/4/5/6 e1 Operators u1: -+- u3: -AI 1 2 2 3 u6: -AI,SI Costs (a) Unit Table. (b) Trace of Applying the Heuristic Component Mapper to the Adder/Subtractor Design Example. 5 Due to space limitations, the cost and bound functions are given elsewhere <ref> [16] </ref>. 14 Algorithm 6.1. : Heuristic Component Mapper Input: Flow graph G, unit table U, the area/delay parameters ff, fi. Output: The flow graph G optimized for area cost and/or for delay. <p> It expands the current solution b using the selected edge e: The first child uses the edge e for operator merging, while the second child eliminates the edge e (Section 6.3). If a child cannot lead to a least-cost solution based on the bounding function <ref> [16] </ref>, it is discarded. If a child represents a complete solution, then it is compared against the current best solution to determine the new best solution. This process is repeated until either no partial solution remains in the active list or the time limit given by the user is exceeded. <p> We also study the solution quality (both area and delay) achieved by FSA for the heuristic and for the B&B component mapper (columns CM1 and CM2). For each, the solution quality of the design is described by the transistor count (Area) and the maximal delay through the design (Delay) <ref> [16] </ref>. The computation time measured in CPU seconds on a SUN4 is given in the CPU column. The last column displays the results achieved by the human designer (meaning the best possible design we could find by hand).
Reference: [17] <author> E. A. Rundensteiner and D. D. Gajski, </author> <title> Functional Synthesis Using Area and Delay Optimization, </title> <booktitle> Proc. 29th Design Automation Conf., </booktitle> <month> June </month> <year> 1992. </year>
Reference: [18] <author> E. A. Rundensteiner and D. D. Gajski, </author> <title> A Design Representation Model for High-Level Synthesis, </title> <type> Tech. Rep. 90-27, </type> <institution> Univ. of Cal., Irvine, </institution> <month> Sep. </month> <year> 1990. </year>
Reference-contexts: However, VHDL can easily be replaced by another language as long as the input compiler is modified accordingly. 2 The ECDFG design representation <ref> [18] </ref> is an extension of the commonly known Control/Data Flow Graph model with powerful constructs, such as, timing constraints, structural bindings, asynchronous events, etc. 5 types. Each unit u i 2 U is capable of performing a subset of the functions in O, denoted by functionality (u i ) O. <p> design1 is port (F : in BIT-VECTOR (1 downto 0); D : out BIT-VECTOR (3 downto 0) architecture design1-body of design1 is begin (b) Partitioned ECDFG. (d) Maximally Merged ECDFG.(c) Reduced ECDFG. (1) A language compiler [9] parses the input description, a functional description, into an internal ECDFG design representation <ref> [18] </ref>. Examples of both are given in Figures 5 (a) and 5 (b), respectively. (2) The functionality recognizer addresses the mismatch problem between the standard operators of the 8 language and the possibly complex functions supported by RTL library components 4 .
Reference: [19] <author> E. A. Rundensteiner, D. D. Gajski, and L. Bic, </author> <title> Component Synthesis: Technology Mapping from Register Transfer Descriptions, </title> <booktitle> Proc. Int. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 208-211, </pages> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: described below. * case 2: Do not map n 1 and n 2 to same unit: * CG ) CG 0 by simply deleting edge e from CG, 12 * G ) G 0 by simply setting G 0 = G: The rules for flow graph transformations are given in <ref> [19] </ref>, while below we give an example. Figure 9 (a) describes how n 1 and n 2 are mapped to the same component by merging them into one multi-functional operator node n k . <p> The final design returned by FSA is S4, which corresponds to the merged ECDFG graph shown in Figure 5 (d). The bounded design space traversed by FSA consists of 7 solution nodes, while the complete one consists of 30 nodes <ref> [19] </ref>. 7 EXPERIMENTAL RESULTS FSA currently runs on SUN3/SUN4 workstations under the UNIX operating system. It consists of approximately 15,000 lines of C code not including the VHDL input compiler [9]. The experiments presented below are based on the following examples.
Reference: [20] <author> C. Tseng and D. P. Siewiorek, </author> <title> Automated Synthesis of Data Paths in Digital Systems, </title> <journal> IEEE Trans. on CAD of Integrated Circuits and Systems, CAD-5, </journal> <volume> 3, </volume> <pages> pp. 379 - 395, </pages> <month> July, </month> <year> 1986. </year>
Reference-contexts: Given that both functional and behavioral abstractions are appropriate for describing certain types of designs, a production-quality synthesis system must handle both in order to be a useful tool. [1, 6]. High-level synthesis maps a behavioral description of the desired system to a RTL structure of generic components <ref> [15, 20] </ref>. Functional synthesis synthesizes a functional description of one or possibly several RTL components to component (s) from a given (technology-specific) library. It can thus work in synergism with behavioral synthesis by mapping (functional descriptions of) RTL designs produced by the latter onto actual hardware [3]. <p> Experimental results and conclusions are discussed in Sections 7 and 8, respectively. 3 2 RELATED RESEARCH 2.1 Behavioral Level Synthesis Since functional descriptions are used for concurrent finite-state designs, scheduling needed for high-level synthesis <ref> [20, 15, 2] </ref> is not applicable to functional synthesis. Therefore, sharing of units for operators in different time steps (states) is not needed. Functional synthesis is however related to the allocation and binding tasks in behavioral synthesis [20, 15]. <p> Therefore, sharing of units for operators in different time steps (states) is not needed. Functional synthesis is however related to the allocation and binding tasks in behavioral synthesis <ref> [20, 15] </ref>. EMERALD [20] formulates allocation as clique partitioning problem, but it can handle only straight-line blocks of assignment statements. Also, operators are grouped into sets of functions that do not necessarily correspond to the functionalities supported by existing RTL components. <p> Therefore, sharing of units for operators in different time steps (states) is not needed. Functional synthesis is however related to the allocation and binding tasks in behavioral synthesis [20, 15]. EMERALD <ref> [20] </ref> formulates allocation as clique partitioning problem, but it can handle only straight-line blocks of assignment statements. Also, operators are grouped into sets of functions that do not necessarily correspond to the functionalities supported by existing RTL components. <p> delay (n 1 ), bound node delay (n) - bound node delay (n 2 )) plus interconnection delay; with bound node delay () the minimal delay of implementing an operator node [16]. 6.5 The Heuristic Component Mapper FSA reformulates the component mapping problem as a clique partitioning problem on CG <ref> [20] </ref>. The goal is to find a minimal cost clique partition of the set of operator nodes of CG such that each clique can be mapped to one multi-functional unit. We present two algorithms to solve this problem: the heuristic and the branch-and-bound component mapper.
Reference: [21] <institution> The TTL Data Book for Design Engineers, Texas Instruments Incorporated, 2 nd Ed., </institution> <year> 1967. </year> <month> 22 </month>
Reference-contexts: The experiments presented below are based on the following examples. Example 1 is an Adder/Subtracter from [4]; examples 2 and 3 are variations of an ALU from the Mano book ([11], pg. 337 and pg. 242); example 4 is a functionally reduced version of the TI 74181 ALU <ref> [21] </ref>; example 5 is a divide-by-3328 counter design from Rockwell; example 6 describes a combination of a counting and a logic unit with partially permuted inputs [11]; example 7 the ALU including input multiplexors and latches of the Am2901 [13]; examples 8 and 9 describe several concurrently executing components with shared <p> the Am2901 [13]; examples 8 and 9 describe several concurrently executing components with shared input multiplexors and register files. 7.1 Design Quality and Algorithm Performance In the first experiment (Table 1), we explore the features and limitations of FSA using a variety of different parameter settings and the TTL library <ref> [21] </ref>. For instance, we ran area optimization (ff = 1:0) and delay optimization (ff = 0:0) as indicated in the second column of Table 1. We also compare FSA's performance when using the functionality recognition option versus when not using it as indicated by the FR column. <p> The designer produced a better design for the CntLog example by reversing the inputs of a commutative operation. 7.2 Technology Adaptation In this second experiment, we explore FSA's ability to perform technology adaptation by replacing the component-specific information by different libraries: (a) the TTL library <ref> [21] </ref>, (b) the Mano library [11], and (c) the Generic Component Library GENUS developed at UC Irvine [4]. The Mano library contains a number of the components described in [11] in addition to all components from the Genus library, while the TTL library contains the components of the TTL library [21] <p> <ref> [21] </ref>, (b) the Mano library [11], and (c) the Generic Component Library GENUS developed at UC Irvine [4]. The Mano library contains a number of the components described in [11] in addition to all components from the Genus library, while the TTL library contains the components of the TTL library [21] plus those from Mano. The results using FSA with the B&B Component Mapper and ff=1 are given in Table 2. Table 2 shows that FSA produces better designs using the TTL library than when using the Mano or the Genus library.
References-found: 21

