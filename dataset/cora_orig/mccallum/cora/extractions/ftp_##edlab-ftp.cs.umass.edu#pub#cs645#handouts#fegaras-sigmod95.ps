URL: ftp://edlab-ftp.cs.umass.edu/pub/cs645/handouts/fegaras-sigmod95.ps
Refering-URL: http://www.cs.umass.edu/~moss/645.html
Root-URL: 
Email: email: ffegaras,maierg@cse.ogi.edu  
Title: Towards an Effective Calculus for Object Query Languages  
Author: Leonidas Fegaras David Maier 
Address: 20000 N.W. Walker Road P.O. Box 91000 Portland, OR 97291-1000  
Affiliation: Department of Computer Science and Engineering Oregon Graduate Institute of Science Technology  
Abstract: We define a standard of effectiveness for a database calculus relative to a query language. Effectiveness judges suitability to serve as a processing framework for the query language, and comprises aspects of coverage, manipulability and efficient evaluation. We present the monoid calculus, and argue its effectiveness for object-oriented query languages, exemplified by OQL of ODMG-93. The monoid calculus readily captures such features as multiple collection types, aggregations, arbitrary composition of type constructors and nested query expressions. We also show how to extend the monoid calculus to deal with vectors and arrays in more expressive ways than current query languages do, and illustrate how it can handle identity and updates. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and C. Beeri. </author> <title> On the Power of Languages for the Manipulation of Complex Objects. </title> <booktitle> In International Workshop on Theory and Applications of Nested Relations and Complex Objects, </booktitle> <address> Darmstadt, </address> <year> 1987. </year>
Reference-contexts: Why add another to the pile? In answering that question, it helps to separate the proposals by their purpose. Some have been used to study issues of computational complexity and relative expressive power of different language features <ref> [19, 1] </ref>. Other have been proposed to extend the relational model to handle one extension or another, such as duplicates [14], aggregate computation [24], nested structures [25, 12], temporal expressions [18], and path expressions [20]. <p> One way of constructing sets is to union together a number of singleton set elements, e.g., f1g [ f2g [ f3g constructs the set f1; 2; 3g. Similarly, one way of constructing lists is to append singleton list elements, e.g., [1]++[2]++[3] constructs the list <ref> [1; 2; 3] </ref> (where ++ is the list append function). Both [ and ++ are associative operations, but only [ is commutative and idempotent (i.e., 8x : x [ x = x). It is the commu-tativity and idempotence properties of [ that make sets different from lists. <p> In a way, monoid comprehensions resemble the tuple relational calculus, but here query variables may range over multiple collection types while the output of the comprehension may yet be of a different collection type. For example, the following monoid comprehension setf (a; b) | a <ref> [1; 2; 3] </ref>; b ff4; 5gg g joins the list [1; 2; 3] with the bag ff4; 5gg and returns the following set (it is a set because the comprehension is tagged by the word set): f (1; 4); (1; 5); (2; 4); (2; 5); (3; 4); (3; 5)g Another example <p> For example, the following monoid comprehension setf (a; b) | a <ref> [1; 2; 3] </ref>; b ff4; 5gg g joins the list [1; 2; 3] with the bag ff4; 5gg and returns the following set (it is a set because the comprehension is tagged by the word set): f (1; 4); (1; 5); (2; 4); (2; 5); (3; 4); (3; 5)g Another example is sumf a | a [1; 2; 3]; a 2 <p> g joins the list <ref> [1; 2; 3] </ref> with the bag ff4; 5gg and returns the following set (it is a set because the comprehension is tagged by the word set): f (1; 4); (1; 5); (2; 4); (2; 5); (3; 4); (3; 5)g Another example is sumf a | a [1; 2; 3]; a 2 g 3 monoid type T zero unit (a) merge C/I list list (ff) [ ] [a] ++ set set (ff) fg fag [ CI bag bag (ff) ffgg ffagg ] C oset list (ff) [ ] [a] [ I string list (char) "" "a" concat sorted <p> The monoid oset captures lists with no duplicates. The operator [ is defined as follows: x [ y = x++(y x), where y x is the list y without any elements from x, e.g., <ref> [2; 5; 3; 1] </ref>[ [3; 2; 6] = [2; 5; 3; 1; 6]. The monoid string captures character strings. The monoid sorted [f ] is parameterized by the function f whose range is associated with a partial order . <p> The monoid oset captures lists with no duplicates. The operator [ is defined as follows: x [ y = x++(y x), where y x is the list y without any elements from x, e.g., [2; 5; 3; 1][ [3; 2; 6] = <ref> [2; 5; 3; 1; 6] </ref>. The monoid string captures character strings. The monoid sorted [f ] is parameterized by the function f whose range is associated with a partial order . The merge function of this monoid merges two sorted lists into a sorted list. <p> For example, setf (x; y) | x <ref> [1; 2] </ref>; y ff3; 4; 3gg g is equal to f (1; 3); (1; 4); (2; 3); (2; 4)g. <p> =!y | x new (1); y new (1) g ! true somef x = y | x new (1); y x; y := 2 g ! true sumf !x | x new (1); y x; y := 2 g ! 2 setf e | x new ([ ]); x := <ref> [1; 2] </ref>; e !x g ! f1; 2g listf !x | x new (0); e [1; 2; 3; 4]; x := !x + e g ! [1; 3; 6; 10] The first example indicates that different objects are distinct while the second indicates that objects can have equal states. <p> | x new (1); y x; y := 2 g ! true sumf !x | x new (1); y x; y := 2 g ! 2 setf e | x new ([ ]); x := [1; 2]; e !x g ! f1; 2g listf !x | x new (0); e <ref> [1; 2; 3; 4] </ref>; x := !x + e g ! [1; 3; 6; 10] The first example indicates that different objects are distinct while the second indicates that objects can have equal states. <p> true sumf !x | x new (1); y x; y := 2 g ! 2 setf e | x new ([ ]); x := [1; 2]; e !x g ! f1; 2g listf !x | x new (0); e [1; 2; 3; 4]; x := !x + e g ! <ref> [1; 3; 6; 10] </ref> The first example indicates that different objects are distinct while the second indicates that objects can have equal states. We have defined a monoid with higher-order primitives that captures these object-oriented computations as state transformers [16].
Reference: [2] <author> D. Beech. </author> <title> Collections of Objects in SQL3. </title> <booktitle> In VLDB'93, </booktitle> <pages> pp 244-255. </pages>
Reference-contexts: The second is that it is a small language, hence easier to comprehend, but contains most of the language features that are showing up in other object query languages and proposed relational extensions, such as SQL3 <ref> [2] </ref>. Those features include multiple collection types, arbitrary nesting of type constructors, method invocation, complex object state, path expressions, object identity, subqueries at arbitrary points in query expressions, and a subtype hierarchy. <p> One way of constructing sets is to union together a number of singleton set elements, e.g., f1g [ f2g [ f3g constructs the set f1; 2; 3g. Similarly, one way of constructing lists is to append singleton list elements, e.g., [1]++[2]++[3] constructs the list <ref> [1; 2; 3] </ref> (where ++ is the list append function). Both [ and ++ are associative operations, but only [ is commutative and idempotent (i.e., 8x : x [ x = x). It is the commu-tativity and idempotence properties of [ that make sets different from lists. <p> In a way, monoid comprehensions resemble the tuple relational calculus, but here query variables may range over multiple collection types while the output of the comprehension may yet be of a different collection type. For example, the following monoid comprehension setf (a; b) | a <ref> [1; 2; 3] </ref>; b ff4; 5gg g joins the list [1; 2; 3] with the bag ff4; 5gg and returns the following set (it is a set because the comprehension is tagged by the word set): f (1; 4); (1; 5); (2; 4); (2; 5); (3; 4); (3; 5)g Another example <p> For example, the following monoid comprehension setf (a; b) | a <ref> [1; 2; 3] </ref>; b ff4; 5gg g joins the list [1; 2; 3] with the bag ff4; 5gg and returns the following set (it is a set because the comprehension is tagged by the word set): f (1; 4); (1; 5); (2; 4); (2; 5); (3; 4); (3; 5)g Another example is sumf a | a [1; 2; 3]; a 2 <p> g joins the list <ref> [1; 2; 3] </ref> with the bag ff4; 5gg and returns the following set (it is a set because the comprehension is tagged by the word set): f (1; 4); (1; 5); (2; 4); (2; 5); (3; 4); (3; 5)g Another example is sumf a | a [1; 2; 3]; a 2 g 3 monoid type T zero unit (a) merge C/I list list (ff) [ ] [a] ++ set set (ff) fg fag [ CI bag bag (ff) ffgg ffagg ] C oset list (ff) [ ] [a] [ I string list (char) "" "a" concat sorted <p> The monoid oset captures lists with no duplicates. The operator [ is defined as follows: x [ y = x++(y x), where y x is the list y without any elements from x, e.g., <ref> [2; 5; 3; 1] </ref>[ [3; 2; 6] = [2; 5; 3; 1; 6]. The monoid string captures character strings. The monoid sorted [f ] is parameterized by the function f whose range is associated with a partial order . <p> The monoid oset captures lists with no duplicates. The operator [ is defined as follows: x [ y = x++(y x), where y x is the list y without any elements from x, e.g., [2; 5; 3; 1][ <ref> [3; 2; 6] </ref> = [2; 5; 3; 1; 6]. The monoid string captures character strings. The monoid sorted [f ] is parameterized by the function f whose range is associated with a partial order . The merge function of this monoid merges two sorted lists into a sorted list. <p> The monoid oset captures lists with no duplicates. The operator [ is defined as follows: x [ y = x++(y x), where y x is the list y without any elements from x, e.g., [2; 5; 3; 1][ [3; 2; 6] = <ref> [2; 5; 3; 1; 6] </ref>. The monoid string captures character strings. The monoid sorted [f ] is parameterized by the function f whose range is associated with a partial order . The merge function of this monoid merges two sorted lists into a sorted list. <p> For example, setf (x; y) | x <ref> [1; 2] </ref>; y ff3; 4; 3gg g is equal to f (1; 3); (1; 4); (2; 3); (2; 4)g. <p> = bagf h.name | c Cities, c.name="Portland", h c.hotels, r h.rooms, r.bed#=3 g (by rules 4 and 5 and by definition of .) 8 The normalization algorithm can also be used for handling the inefficiencies introduced when new programming language constructs are incorporated into relational languages, such as in SQL3 <ref> [2] </ref>. (SQL3 contains many new proposed relational extensions such as user-defined types, multiple collections types, routines, and triggers.) In particular, the begin-end statement in SQL3 may introduce inefficiencies when it contains bindings to large intermediate results. <p> Variable x ranges over this list (i.e., x is of type obj (int)) and the state of x is incremented by one (by x := !x + 1). The result of this computation is the list <ref> [2; 3] </ref>. <p> =!y | x new (1); y new (1) g ! true somef x = y | x new (1); y x; y := 2 g ! true sumf !x | x new (1); y x; y := 2 g ! 2 setf e | x new ([ ]); x := <ref> [1; 2] </ref>; e !x g ! f1; 2g listf !x | x new (0); e [1; 2; 3; 4]; x := !x + e g ! [1; 3; 6; 10] The first example indicates that different objects are distinct while the second indicates that objects can have equal states. <p> | x new (1); y x; y := 2 g ! true sumf !x | x new (1); y x; y := 2 g ! 2 setf e | x new ([ ]); x := [1; 2]; e !x g ! f1; 2g listf !x | x new (0); e <ref> [1; 2; 3; 4] </ref>; x := !x + e g ! [1; 3; 6; 10] The first example indicates that different objects are distinct while the second indicates that objects can have equal states.
Reference: [3] <author> C. Beeri and Y. Kornatzky. </author> <title> Algebraic Optimization of Object-Oriented Query Languages. </title> <booktitle> In International Conference on Database Theory, Paris, France, </booktitle> <pages> pp 72-88. </pages> <publisher> Springer-Verlag, </publisher> <month> December </month> <year> 1990. </year> <note> LNCS 470. </note>
Reference-contexts: One way of constructing sets is to union together a number of singleton set elements, e.g., f1g [ f2g [ f3g constructs the set f1; 2; 3g. Similarly, one way of constructing lists is to append singleton list elements, e.g., [1]++[2]++[3] constructs the list <ref> [1; 2; 3] </ref> (where ++ is the list append function). Both [ and ++ are associative operations, but only [ is commutative and idempotent (i.e., 8x : x [ x = x). It is the commu-tativity and idempotence properties of [ that make sets different from lists. <p> In a way, monoid comprehensions resemble the tuple relational calculus, but here query variables may range over multiple collection types while the output of the comprehension may yet be of a different collection type. For example, the following monoid comprehension setf (a; b) | a <ref> [1; 2; 3] </ref>; b ff4; 5gg g joins the list [1; 2; 3] with the bag ff4; 5gg and returns the following set (it is a set because the comprehension is tagged by the word set): f (1; 4); (1; 5); (2; 4); (2; 5); (3; 4); (3; 5)g Another example <p> For example, the following monoid comprehension setf (a; b) | a <ref> [1; 2; 3] </ref>; b ff4; 5gg g joins the list [1; 2; 3] with the bag ff4; 5gg and returns the following set (it is a set because the comprehension is tagged by the word set): f (1; 4); (1; 5); (2; 4); (2; 5); (3; 4); (3; 5)g Another example is sumf a | a [1; 2; 3]; a 2 <p> g joins the list <ref> [1; 2; 3] </ref> with the bag ff4; 5gg and returns the following set (it is a set because the comprehension is tagged by the word set): f (1; 4); (1; 5); (2; 4); (2; 5); (3; 4); (3; 5)g Another example is sumf a | a [1; 2; 3]; a 2 g 3 monoid type T zero unit (a) merge C/I list list (ff) [ ] [a] ++ set set (ff) fg fag [ CI bag bag (ff) ffgg ffagg ] C oset list (ff) [ ] [a] [ I string list (char) "" "a" concat sorted <p> The monoid oset captures lists with no duplicates. The operator [ is defined as follows: x [ y = x++(y x), where y x is the list y without any elements from x, e.g., <ref> [2; 5; 3; 1] </ref>[ [3; 2; 6] = [2; 5; 3; 1; 6]. The monoid string captures character strings. The monoid sorted [f ] is parameterized by the function f whose range is associated with a partial order . <p> The monoid oset captures lists with no duplicates. The operator [ is defined as follows: x [ y = x++(y x), where y x is the list y without any elements from x, e.g., [2; 5; 3; 1][ <ref> [3; 2; 6] </ref> = [2; 5; 3; 1; 6]. The monoid string captures character strings. The monoid sorted [f ] is parameterized by the function f whose range is associated with a partial order . The merge function of this monoid merges two sorted lists into a sorted list. <p> The monoid oset captures lists with no duplicates. The operator [ is defined as follows: x [ y = x++(y x), where y x is the list y without any elements from x, e.g., [2; 5; 3; 1][ [3; 2; 6] = <ref> [2; 5; 3; 1; 6] </ref>. The monoid string captures character strings. The monoid sorted [f ] is parameterized by the function f whose range is associated with a partial order . The merge function of this monoid merges two sorted lists into a sorted list. <p> Variable x ranges over this list (i.e., x is of type obj (int)) and the state of x is incremented by one (by x := !x + 1). The result of this computation is the list <ref> [2; 3] </ref>. <p> | x new (1); y x; y := 2 g ! true sumf !x | x new (1); y x; y := 2 g ! 2 setf e | x new ([ ]); x := [1; 2]; e !x g ! f1; 2g listf !x | x new (0); e <ref> [1; 2; 3; 4] </ref>; x := !x + e g ! [1; 3; 6; 10] The first example indicates that different objects are distinct while the second indicates that objects can have equal states. <p> true sumf !x | x new (1); y x; y := 2 g ! 2 setf e | x new ([ ]); x := [1; 2]; e !x g ! f1; 2g listf !x | x new (0); e [1; 2; 3; 4]; x := !x + e g ! <ref> [1; 3; 6; 10] </ref> The first example indicates that different objects are distinct while the second indicates that objects can have equal states. We have defined a monoid with higher-order primitives that captures these object-oriented computations as state transformers [16]. <p> = c..hotel#+1; This program has the following comprehension form: setf c | c setf c | c db.cities, c.name=city name g, c.hotels += h name=hotel name, address=hotel address, facilities=fg, employees=fg, rooms=fg i, c.hotel# += 1 g 5 Related Work There are many proposals for object query algebras (see for example <ref> [21, 13, 11, 3, 25] </ref>). In contrast to our algebra, these algebras support multiple bulk operators. But, as we have demonstrated in this paper, we get enough expressive power with just one operator, namely the monoid homomorphism.
Reference: [4] <author> V. Breazu-Tannen, P. Buneman, and S. Naqvi. </author> <title> Struc tural Recursion as a Query Language. </title> <booktitle> In Proceedings of the Third International Workshop on Database Programming Languages, </booktitle> <pages> pp 9-19. </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: For example, zero sum <ref> [4] </ref> = (j0; 0; 0; 0j) unit sum [4] (8; 2) = (j0; 0; 8; 0j) merge sum [4] ((j0; 1; 2; 0j); (j3; 0; 2; 1j)) = (j0 + 3; 1 + 0; 2 + 2; 0 + 1j) = (j3; 1; 4; 1j) Note that the monoid M [n] <p> For example, zero sum <ref> [4] </ref> = (j0; 0; 0; 0j) unit sum [4] (8; 2) = (j0; 0; 8; 0j) merge sum [4] ((j0; 1; 2; 0j); (j3; 0; 2; 1j)) = (j0 + 3; 1 + 0; 2 + 2; 0 + 1j) = (j3; 1; 4; 1j) Note that the monoid M [n] is not freely generated from M, as is <p> For example, zero sum <ref> [4] </ref> = (j0; 0; 0; 0j) unit sum [4] (8; 2) = (j0; 0; 8; 0j) merge sum [4] ((j0; 1; 2; 0j); (j3; 0; 2; 1j)) = (j0 + 3; 1 + 0; 2 + 2; 0 + 1j) = (j3; 1; 4; 1j) Note that the monoid M [n] is not freely generated from M, as is the case for the other collection monoids. <p> | x new (1); y x; y := 2 g ! true sumf !x | x new (1); y x; y := 2 g ! 2 setf e | x new ([ ]); x := [1; 2]; e !x g ! f1; 2g listf !x | x new (0); e <ref> [1; 2; 3; 4] </ref>; x := !x + e g ! [1; 3; 6; 10] The first example indicates that different objects are distinct while the second indicates that objects can have equal states. <p> Our framework is based on monoid homomorphisms, which were first introduced as an effective way to capture database queries by V. Tannen, et al. <ref> [4, 6, 5] </ref>. Their form of monoid homomorphism (also called structural recursion over the union presentation | SRU) is more expressive than ours. Operations of the SRU form, though, require the validation of the associativity, com-mutativity, and idempotence properties of the monoid associated with the output of this operation.
Reference: [5] <author> V. Breazu-Tannen, P. Buneman, and L. Wong. </author> <title> Natu rally Embedded Query Languages. </title> <booktitle> In 4th International Conference on Database Theory, </booktitle> <address> Berlin, Germany, </address> <pages> pp 140-154. </pages> <publisher> Springer-Verlag, </publisher> <month> October </month> <year> 1992. </year> <note> LNCS 646. </note>
Reference-contexts: In fact, a small subset of these functions, namely the monoid homomor-phisms from sets to sets, captures precisely the nested relational algebra (since they are equivalent to the set extension operator ext (f ), which has been shown to capture the nested relational algebra <ref> [5] </ref>). But monoid homomorphisms go beyond that to capture operations over multiple collection types, such as the join of a list with a bag that returns a set, plus predicates and aggregates. <p> The monoid oset captures lists with no duplicates. The operator [ is defined as follows: x [ y = x++(y x), where y x is the list y without any elements from x, e.g., <ref> [2; 5; 3; 1] </ref>[ [3; 2; 6] = [2; 5; 3; 1; 6]. The monoid string captures character strings. The monoid sorted [f ] is parameterized by the function f whose range is associated with a partial order . <p> The monoid oset captures lists with no duplicates. The operator [ is defined as follows: x [ y = x++(y x), where y x is the list y without any elements from x, e.g., [2; 5; 3; 1][ [3; 2; 6] = <ref> [2; 5; 3; 1; 6] </ref>. The monoid string captures character strings. The monoid sorted [f ] is parameterized by the function f whose range is associated with a partial order . The merge function of this monoid merges two sorted lists into a sorted list. <p> Our framework is based on monoid homomorphisms, which were first introduced as an effective way to capture database queries by V. Tannen, et al. <ref> [4, 6, 5] </ref>. Their form of monoid homomorphism (also called structural recursion over the union presentation | SRU) is more expressive than ours. Operations of the SRU form, though, require the validation of the associativity, com-mutativity, and idempotence properties of the monoid associated with the output of this operation.
Reference: [6] <author> V. Breazu-Tannen and R. Subrahmanyam. </author> <title> Logical and Computational Aspects of Programming with Sets/Bags/Lists. </title> <booktitle> In 18th International Colloquium on Automata, Languages and Programming, Madrid, Spain, </booktitle> <pages> pp 60-75, </pages> <month> July </month> <year> 1991. </year> <note> LNCS 510. </note>
Reference-contexts: The monoid oset captures lists with no duplicates. The operator [ is defined as follows: x [ y = x++(y x), where y x is the list y without any elements from x, e.g., [2; 5; 3; 1][ <ref> [3; 2; 6] </ref> = [2; 5; 3; 1; 6]. The monoid string captures character strings. The monoid sorted [f ] is parameterized by the function f whose range is associated with a partial order . The merge function of this monoid merges two sorted lists into a sorted list. <p> The monoid oset captures lists with no duplicates. The operator [ is defined as follows: x [ y = x++(y x), where y x is the list y without any elements from x, e.g., [2; 5; 3; 1][ [3; 2; 6] = <ref> [2; 5; 3; 1; 6] </ref>. The monoid string captures character strings. The monoid sorted [f ] is parameterized by the function f whose range is associated with a partial order . The merge function of this monoid merges two sorted lists into a sorted list. <p> For example, bag cardinality 1 hom bag!sum (x: 1) A is a well-formed homomorphism, while set cardinality hom set!sum (x: 1) A is not (since + is commutative but not idempotent). Without this restriction we would have (see also <ref> [6] </ref>): 1 = hom set!sum (x: 1) fag This restriction also prohibits the conversion of sets into lists (since set 6 list), but allows the conversion of sets into sorted lists. <p> true sumf !x | x new (1); y x; y := 2 g ! 2 setf e | x new ([ ]); x := [1; 2]; e !x g ! f1; 2g listf !x | x new (0); e [1; 2; 3; 4]; x := !x + e g ! <ref> [1; 3; 6; 10] </ref> The first example indicates that different objects are distinct while the second indicates that objects can have equal states. We have defined a monoid with higher-order primitives that captures these object-oriented computations as state transformers [16]. <p> Our framework is based on monoid homomorphisms, which were first introduced as an effective way to capture database queries by V. Tannen, et al. <ref> [4, 6, 5] </ref>. Their form of monoid homomorphism (also called structural recursion over the union presentation | SRU) is more expressive than ours. Operations of the SRU form, though, require the validation of the associativity, com-mutativity, and idempotence properties of the monoid associated with the output of this operation. <p> Operations of the SRU form, though, require the validation of the associativity, com-mutativity, and idempotence properties of the monoid associated with the output of this operation. These properties are hard to check by a compiler <ref> [6] </ref>, which makes the SRU operation impractical. They first recognized that there are some special cases where these conditions are automatically satisfied, such as for the ext (f ) operation (which is equivalent to hom M!M (f) for a monoid M).
Reference: [7] <author> P. Buneman. </author> <title> The Fast Fourier Transform as a Database Query. </title> <type> Technical report, </type> <institution> University of Pennsylvania, </institution> <month> March </month> <year> 1993. </year> <note> MS-CIS-93-37/L&C 60. </note>
Reference-contexts: This function can be computed by vec [n]f a [n i 1] | a [i] x g where vec [n] is the anticipated monoid for vectors of size n <ref> [7] </ref>. Note that we want to access both the value a and the associated index i from the vector x, but we do not want to impose any order on the way a [i] is accessed.
Reference: [8] <author> P. Buneman, L. Libkin, D. Suciu, V. Tannen, and L. Wong. </author> <title> Comprehension Syntax. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 23(1) </volume> <pages> 87-96, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: Monad comprehensions were first proposed as a convenient and practical database language by P. Trinder [27, 26, 10], who also presented many algebraic transformations over these forms as well as methods for converting comprehensions into joins. The monad comprehension syntax was also adopted by P. Buneman, et al. <ref> [8] </ref> as an alternative syntax to monoid homomorphisms. The comprehension syntax was used for capturing operations that involve collections of the same type while structural recursion was used for expressing the rest of the operations (such as converting one collection type to another, predicates, and aggregates).
Reference: [9] <author> R. Cattell. </author> <title> The Object Database Standard: ODMG-93. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1994. </year>
Reference-contexts: Such features end up being handled in an ad hoc manner by query processors. The gap only widens as one moves to object-oriented query languages, such as OQL of ODMG-93 <ref> [9] </ref>, which must deal with multiple bulk (collection) types, arbitrary nesting of type constructors, methods and embedded query expressions permitted whenever a collection may appear (not just in the where clause). (Such features are also making their way into relational query languages.) We seek a more effective formalism to model object
Reference: [10] <author> D. Chan and P. Trinder. </author> <title> Object Comprehensions: A Query Notation for Object-Oriented Databases. </title> <booktitle> In Twelfth British Conference on Databases, </booktitle> <pages> pp 55-72, </pages> <month> July </month> <year> 1994. </year> <note> LNCS 826. </note>
Reference-contexts: true sumf !x | x new (1); y x; y := 2 g ! 2 setf e | x new ([ ]); x := [1; 2]; e !x g ! f1; 2g listf !x | x new (0); e [1; 2; 3; 4]; x := !x + e g ! <ref> [1; 3; 6; 10] </ref> The first example indicates that different objects are distinct while the second indicates that objects can have equal states. We have defined a monoid with higher-order primitives that captures these object-oriented computations as state transformers [16]. <p> This is not possible for monad comprehensions, since they restrict the inputs and the output of a comprehension to be of the same type. Monad comprehensions were first proposed as a convenient and practical database language by P. Trinder <ref> [27, 26, 10] </ref>, who also presented many algebraic transformations over these forms as well as methods for converting comprehensions into joins. The monad comprehension syntax was also adopted by P. Buneman, et al. [8] as an alternative syntax to monoid homomorphisms.
Reference: [11] <author> S. Cluet and C. Delobel. </author> <title> A General Framework for the Optimization of Object-Oriented Queries. </title> <booktitle> In SIGMOD'92, </booktitle> <pages> pp 383-392. </pages>
Reference-contexts: = c..hotel#+1; This program has the following comprehension form: setf c | c setf c | c db.cities, c.name=city name g, c.hotels += h name=hotel name, address=hotel address, facilities=fg, employees=fg, rooms=fg i, c.hotel# += 1 g 5 Related Work There are many proposals for object query algebras (see for example <ref> [21, 13, 11, 3, 25] </ref>). In contrast to our algebra, these algebras support multiple bulk operators. But, as we have demonstrated in this paper, we get enough expressive power with just one operator, namely the monoid homomorphism.
Reference: [12] <author> P. Dadam, et al. </author> <title> A DBMS Prototype to Support Extended NF 2 Relations: An Integrated View on Flat Tables and Hierarchies. </title> <booktitle> In SIGMOD'86, </booktitle> <pages> pp 356-367. </pages>
Reference-contexts: Some have been used to study issues of computational complexity and relative expressive power of different language features [19, 1]. Other have been proposed to extend the relational model to handle one extension or another, such as duplicates [14], aggregate computation [24], nested structures <ref> [25, 12] </ref>, temporal expressions [18], and path expressions [20]. Our interest, however, is finding a query model that provides an adequate basis for defining, translating and evaluating actual DBMS query languages.
Reference: [13] <author> S. Danforth and P. Valduriez. </author> <title> A FAD for Data Intensive Applications. </title> <journal> Transactions on Knowledge and Data Engineering, </journal> <volume> 4(1) </volume> <pages> 34-51, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: = c..hotel#+1; This program has the following comprehension form: setf c | c setf c | c db.cities, c.name=city name g, c.hotels += h name=hotel name, address=hotel address, facilities=fg, employees=fg, rooms=fg i, c.hotel# += 1 g 5 Related Work There are many proposals for object query algebras (see for example <ref> [21, 13, 11, 3, 25] </ref>). In contrast to our algebra, these algebras support multiple bulk operators. But, as we have demonstrated in this paper, we get enough expressive power with just one operator, namely the monoid homomorphism.
Reference: [14] <author> U. Dayal, N. Goodman, and R. H. Katz. </author> <title> An Extended Relational Algebra with Control Over Duplicate Elimination. </title> <booktitle> In PODS'82, </booktitle> <pages> pp 117-123. </pages>
Reference-contexts: Some have been used to study issues of computational complexity and relative expressive power of different language features [19, 1]. Other have been proposed to extend the relational model to handle one extension or another, such as duplicates <ref> [14] </ref>, aggregate computation [24], nested structures [25, 12], temporal expressions [18], and path expressions [20]. Our interest, however, is finding a query model that provides an adequate basis for defining, translating and evaluating actual DBMS query languages.
Reference: [15] <editor> O. Deux, et al. </editor> <title> The Story of O2. </title> <journal> Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 91-108, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: We have chosen to concentrate on the OQL language of the ODMG-93 standard proposal, which closely resembles the query language of the O2 OODBMS <ref> [15] </ref>. We chose OQL for two main reasons. One is that essentially all U.S. OODB companies have committed to supporting an OQL interface to their systems in the near term.
Reference: [16] <author> L. Fegaras. </author> <title> A Uniform Calculus for Collection Types. </title> <type> Oregon Graduate Institute Technical Report 94-030. </type> <note> Available by anonymous ftp from cse.ogi.edu:/pub/crml/tapos.ps.Z. </note>
Reference-contexts: While the monoid M of the output is specified explicitly, the collection monoid N associated with the expression u in x u is inferred. (Details of this type inference process can be found elsewhere <ref> [16] </ref>.) We will use the following convention to represent variable bindings in a comprehension: Mf e | q; x u; s g = Mf e [u=x] | q; s [u=x] g where e [u=x] is the expression e with u substituted for all free occurrences of x. <p> One advantage of the normalization algorithm, or any algorithm on calculus expressions expressed via pattern-based rewrite, is that it can be shown to correctly preserve meaning by proving each rewrite transformation is correct. Proofs of correctness for the rules in Table 3 are given elsewhere <ref> [16] </ref>. Rules 5 and 6 may require some variable renaming to avoid name conflicts. If there is a generator v 0 e 1 in q and a generator v 0 e 2 in r then variable v 0 in r should be renamed. <p> We have defined a monoid with higher-order primitives that captures these object-oriented computations as state transformers <ref> [16] </ref>. These state transformers propagate the object heap (which contains bindings 10 from OIDs to object states) through all operations in an expression, and change it in response to any operation that creates a new object or modifies an existing object.
Reference: [17] <author> L. Fegaras and D. Maier. </author> <title> An Algebraic Framework for Physical OODB Design. </title> <note> Available by anonymous ftp from cse.ogi.edu:/pub/crml/oodb-design.ps.Z. </note>
Reference-contexts: We give evidence of manipulability by exhibiting a simple normalization system for putting expressions into a canonical form that maximizes opportunities for pipelining. We believe the monoid calculus is amenable to efficient evaluation. We sketch a translation into a logical algebra and a companion paper <ref> [17] </ref> presents a framework for mapping to physical operators. 2 The Monoid Comprehension Calculus Several recent proposals for object-oriented database languages, including OQL, support multiple collection types, such as sets, bags, lists, and arrays. These approaches define a language syntax, but they frequently fail to provide a concrete semantics.
Reference: [18] <author> S. K. Gadia. </author> <title> A Homogeneous Relational Model and Query Languages for Temporal Databases. </title> <journal> Transactions on Database Systems, </journal> <volume> 13(4) </volume> <pages> 418-448, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: Some have been used to study issues of computational complexity and relative expressive power of different language features [19, 1]. Other have been proposed to extend the relational model to handle one extension or another, such as duplicates [14], aggregate computation [24], nested structures [25, 12], temporal expressions <ref> [18] </ref>, and path expressions [20]. Our interest, however, is finding a query model that provides an adequate basis for defining, translating and evaluating actual DBMS query languages. To that end, we describe what we mean by a database calculus C being effective for a query language L.
Reference: [19] <author> N. Immerman, S. Patnaik, and D. Stemple. </author> <title> The Expressiveness of a Family of Finite Set Languages. </title> <booktitle> In PODS'91, </booktitle> <pages> pp 37-52. </pages>
Reference-contexts: Why add another to the pile? In answering that question, it helps to separate the proposals by their purpose. Some have been used to study issues of computational complexity and relative expressive power of different language features <ref> [19, 1] </ref>. Other have been proposed to extend the relational model to handle one extension or another, such as duplicates [14], aggregate computation [24], nested structures [25, 12], temporal expressions [18], and path expressions [20].
Reference: [20] <author> A. Kemper and G. Moerkotte. </author> <title> Advanced Query Processing in Object Bases Using Access Support Relations. </title> <booktitle> In VLDB'90, </booktitle> <pages> pp 290-301. </pages>
Reference-contexts: Other have been proposed to extend the relational model to handle one extension or another, such as duplicates [14], aggregate computation [24], nested structures [25, 12], temporal expressions [18], and path expressions <ref> [20] </ref>. Our interest, however, is finding a query model that provides an adequate basis for defining, translating and evaluating actual DBMS query languages. To that end, we describe what we mean by a database calculus C being effective for a query language L.
Reference: [21] <author> T. Leung, G. Mitchell, B. Subramanian, B. Vance, S. Vandenberg, and S. Zdonik. </author> <title> The AQUA Data Model and Algebra. </title> <booktitle> In Fourth International Workshop on Database Programming Languages, </booktitle> <address> Manhattan, New York City, </address> <pages> pp 157-175, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: = c..hotel#+1; This program has the following comprehension form: setf c | c setf c | c db.cities, c.name=city name g, c.hotels += h name=hotel name, address=hotel address, facilities=fg, employees=fg, rooms=fg i, c.hotel# += 1 g 5 Related Work There are many proposals for object query algebras (see for example <ref> [21, 13, 11, 3, 25] </ref>). In contrast to our algebra, these algebras support multiple bulk operators. But, as we have demonstrated in this paper, we get enough expressive power with just one operator, namely the monoid homomorphism.
Reference: [22] <author> D. Maier and B. Vance. </author> <title> A Call to Order. </title> <booktitle> In PODS'93, </booktitle> <pages> pp 1-16. </pages>
Reference-contexts: Here we examine a monoid for vectors, which could be a basis for extending the expressiveness of OQL. We also show how to handle identity and updates in the calculus. 4.1 Vectors and Arrays Vectors and arrays are important collection types for scientific and other applications <ref> [22] </ref>. In contrast to other collection types, there is no obvious monoid that captures vectors effectively. Vector operations should provide random access through indexing as well as bulk manipulation. We will first propose an effective form of vector comprehensions and then describe a monoid that captures these comprehensions.
Reference: [23] <author> A. Ohori. </author> <title> Representing Object Identity in a Pure Functional Language. </title> <booktitle> In International Conference on Database Theory, Paris, France, </booktitle> <pages> pp 41-55. </pages> <publisher> Springer-Verlag, </publisher> <month> December </month> <year> 1990. </year> <note> LNCS 470. </note>
Reference-contexts: We introduce a new type constructor obj (ff) that represents all objects with states represented by values of type ff. In addition, we extend the monoid calculus with the following operations <ref> [23] </ref>: * new (s) that creates a new object with state s; * !e that dereferences the object e (returns the state of e); * e := s that changes the state of the object e to s and returns true.
Reference: [24] <author> G. Ozsoyoglu, Z. Ozsoyoglu, and V. Matos. </author> <title> Extend ing Relational Algebra and Relational Calculus with Set-Valued Attributes and Aggregate Functions. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 12(4) </volume> <pages> 566-592, </pages> <month> De-cember </month> <year> 1987. </year>
Reference-contexts: Some have been used to study issues of computational complexity and relative expressive power of different language features [19, 1]. Other have been proposed to extend the relational model to handle one extension or another, such as duplicates [14], aggregate computation <ref> [24] </ref>, nested structures [25, 12], temporal expressions [18], and path expressions [20]. Our interest, however, is finding a query model that provides an adequate basis for defining, translating and evaluating actual DBMS query languages.
Reference: [25] <author> P. Pistor and R. Traunmueller. </author> <title> A Database Language for Sets, Lists, and Tables. </title> <journal> Information Systems, </journal> <volume> 11(4) </volume> <pages> 323-336, </pages> <year> 1986. </year>
Reference-contexts: Some have been used to study issues of computational complexity and relative expressive power of different language features [19, 1]. Other have been proposed to extend the relational model to handle one extension or another, such as duplicates [14], aggregate computation [24], nested structures <ref> [25, 12] </ref>, temporal expressions [18], and path expressions [20]. Our interest, however, is finding a query model that provides an adequate basis for defining, translating and evaluating actual DBMS query languages. <p> = c..hotel#+1; This program has the following comprehension form: setf c | c setf c | c db.cities, c.name=city name g, c.hotels += h name=hotel name, address=hotel address, facilities=fg, employees=fg, rooms=fg i, c.hotel# += 1 g 5 Related Work There are many proposals for object query algebras (see for example <ref> [21, 13, 11, 3, 25] </ref>). In contrast to our algebra, these algebras support multiple bulk operators. But, as we have demonstrated in this paper, we get enough expressive power with just one operator, namely the monoid homomorphism.
Reference: [26] <author> P. Trinder. </author> <title> Comprehensions: A Query Notation for DBPLs. </title> <booktitle> In Proceedings of the Third International Workshop on Database Programming Languages, </booktitle> <pages> pp 55-68, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: This is not possible for monad comprehensions, since they restrict the inputs and the output of a comprehension to be of the same type. Monad comprehensions were first proposed as a convenient and practical database language by P. Trinder <ref> [27, 26, 10] </ref>, who also presented many algebraic transformations over these forms as well as methods for converting comprehensions into joins. The monad comprehension syntax was also adopted by P. Buneman, et al. [8] as an alternative syntax to monoid homomorphisms.
Reference: [27] <author> P. Trinder and P. Wadler. </author> <title> Improving List Compre hension Database Queries. </title> <booktitle> In in Proceedings of TEN-CON'89, Bombay, India, </booktitle> <pages> pp 186-192, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: This is not possible for monad comprehensions, since they restrict the inputs and the output of a comprehension to be of the same type. Monad comprehensions were first proposed as a convenient and practical database language by P. Trinder <ref> [27, 26, 10] </ref>, who also presented many algebraic transformations over these forms as well as methods for converting comprehensions into joins. The monad comprehension syntax was also adopted by P. Buneman, et al. [8] as an alternative syntax to monoid homomorphisms.
Reference: [28] <author> S. Vandenberg and D. DeWitt. </author> <title> Algebraic Support for Complex Objects with Arrays, Identity, and Inheritance. </title> <booktitle> In SIGMOD'91, </booktitle> <pages> pp 158-167. </pages>
Reference-contexts: We demonstrate coverage by showing how to map the major features of OQL into monoid calculus. In order to make expressions easier to operate upon, we use a formalism where type constructors are independent (similarly to the approach of Vandenberg and DeWitt <ref> [28] </ref>), rather than providing indivisible combinations of constructors, as in nested relational models. We give evidence of manipulability by exhibiting a simple normalization system for putting expressions into a canonical form that maximizes opportunities for pipelining. We believe the monoid calculus is amenable to efficient evaluation.
Reference: [29] <author> P. Wadler. </author> <title> Comprehending Monads. </title> <booktitle> In Proceedings of the ACM Symposium on Lisp and Functional Programming, Nice, France, </booktitle> <pages> pp 61-78, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: We believe that our monoid homomorphism algebra is the most expressive subset of SRU where inconsistencies can always be detected at compile time, and, more importantly, where all programs can be put in canonical form. Monad comprehensions were first introduced by P. Wadler <ref> [29] </ref> as a generalization of list comprehensions (which already exist in some functional languages). Monoid comprehensions are related to monad comprehensions, but they are considerably more expressive. In particular, monoid comprehensions can mix inputs from different collection types and may return output of a different type.
Reference: [30] <author> L. Wong. </author> <title> Normal Forms and Conservative Properties for Query Languages over Collection Types. </title> <booktitle> In PODS'93, </booktitle> <pages> pp 26-36. 12 </pages>
Reference-contexts: Our normalization algorithm is highly influenced by L. Wong's work on normalization of monad comprehensions <ref> [30] </ref>. He presented some powerful rules for flattening nested comprehensions into canonical comprehensions whose generators are over simple paths. These canonical forms are equivalent to our canonical forms for monoid homomorphisms. 6 Conclusion We believe the monoid calculus provides an effective framework for processing object-oriented query languages such as OQL.
References-found: 30

