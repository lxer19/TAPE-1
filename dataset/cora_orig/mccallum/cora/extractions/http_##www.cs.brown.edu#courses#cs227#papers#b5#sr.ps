URL: http://www.cs.brown.edu/courses/cs227/papers/b5/sr.ps
Refering-URL: http://www.cs.brown.edu/courses/cs227/readinglist.html
Root-URL: http://www.cs.brown.edu/
Email: @cis.upenn.edu  shamim@bellcore.com  
Title: Structural Recursion as a Query Language  
Author: Val Breazu-Tannen, Peter Buneman val, peter Shamim Naqvi 
Address: Philadelphia, PA 19104-6389, USA  445 South St. Morristown, NJ 07960-1910, USA  
Affiliation: Department of Computer and Information Science University of Pennsylvania  BELLCORE  
Abstract: We propose a programming paradigm that tries to get close to both the semantic simplicity of relational algebra, and the expressive power of unrestricted programming languages. Its main computational engine is structural recursion on sets. All programming is done within a "nicely" typed lambda calculus, as in Machiavelli [OBB89]. A guiding principle is that how queries are implemented is as important as whether they can be implemented. As in relational algebra, the meaning of any relation transformer is guaranteed to be a total map taking finite relations to finite relations. A naturally restricted class of programs written with structural recursion has precisely the expressive power of the relational algebra. The same programming paradigm scales up, yielding query languages for the complex-object model [AB89]. Beyond that, there are, for example, efficient programs for transitive closure and we are also able to write programs that move out of sets, and then perhaps back to sets, as long as we stay within a (quite flexible) type system. The uniform paradigm of the language suggests positive expectations for the optimization problem. In fact, structural recursion yields finer grain programming therefore we expect that lower-level, and therefore better optimizations will be feasible.
Abstract-found: 1
Intro-found: 1
Reference: [AB89] <author> S. Abiteboul and C. Beeri. </author> <title> On the power of languages for the manipulation of complexobjects. </title> <type> Technical Report, </type> <institution> INRIA, </institution> <year> 1988. </year>
Reference-contexts: On a more conceptual level, relational algebra does not "scale-up", and new primitives had to be invented to deal with the complex object model. Even so the main concern in the design of languages for the complex object model, has been absolute expressiveness <ref> [BK86, HS88, AB89] </ref>. The optimization techniques, and the concerns for correctness have yet to be discussed. We will instead put forward a programming paradigm that tries to get close to both the semantic simplicity of relational algebra, and the expressive power of unrestricted programming languages. <p> In fact, as we shall see, a naturally restricted class of programs written with structural recursion has precisely the expressive power of the relational algebra/calculus (section 3). * The same programming paradigm scales up, yielding query languages for the complex-object model <ref> [AB89] </ref> * Beyond that, there are, for example, efficient programs for transitive closure (section 4). <p> In fact, we expect that lower-level, and therefore better optimizations will be feasible. More general possibilites are suggested by lazy evaluation. * The same programming paradigm scales up, yielding query languages for the complex-object model <ref> [AB89] </ref> (section 4). * Finally, we believe that in this paradigm, particularly because of the good fit of the type system and the data model, the database manipulations can be better integrated with other programming features, even references and modules. <p> In this section we will first show that our language is at least as expressive as Abiteboul and Beeri's algebra (and therefore calculus) for complex objects <ref> [AB89] </ref>. We have already shown how to express cartesian product and difference (section 2). The Abiteboul-Beeri algebra has an operation called replace which combines the relational algebra's selection and projection operations, moreover allowing algebraic operations to be applied recursively to subobjects.
Reference: [ACO83] <author> Albano. A., L. Cardelli, and R. Orsini.Galileo: </author> <title> A strongly typed, Interactive Conceptual Language. </title> <type> Technical Report, </type> <institution> Bell Laboratories, Bell Telephone Laboratories, Internal Technical document Services, </institution> <address> Murray Hill 1b-509, NJ, USA, </address> <year> 1983. </year>
Reference-contexts: We see at least two problems with embedded query languages. The first problem is the mismatch between data models and type systems (the infamous "impedance mismatch" problem). Good progress has been made in overcoming this problem (see for example, Pascal-R, Galileo <ref> [Sch77, ACO83] </ref>), and in fact, the present paper builds on Machiavelli [OBB89]. But there is also a second problem, which stems from the universality of the languages in which we try to integrate database manipulation primitives.
Reference: [AU79] <author> A. Aho and J. Ullman. </author> <title> Universality of data retrieval languages. </title> <booktitle> In Proceedings of POPL, </booktitle> <year> 1979. </year>
Reference-contexts: Interestingly, they also show that transitive closure (which, as shown by Aho and Ullman <ref> [AU79] </ref>, cannot be implemented in relational algebra), can, in fact, be specified as a query in this calculus: it is the least transitive relation containing the given one among all subsets of the (cartesian) squaring of the set of all elements that occur in the relation.
Reference: [BBKV88] <author> F. Bancilhon, T. Briggs, S. Khoshafian, and P. Valduriez. </author> <title> FAD, a powerful and simple database language. </title> <booktitle> In Proc. Intl. Conf. on Very Large Data Bases, </booktitle> <pages> pages 97-105, </pages> <year> 1988. </year>
Reference-contexts: In connection with other work [BNST87], we remark that the grouping operator along with the empty-insert presentation of sets gives interesting expressions for negation, difference and union ofsets. 5 Pump, partition, and hom FAD <ref> [BBKV88] </ref>, LDL [NT89] and Machiavelli [OBB89] all have a construct related to structural recursion on sets.
Reference: [BJO89] <author> P. Buneman, A. Jung, and A. Ohori. </author> <title> Using powerdomains to generalize relational databases. </title> <note> Theoretical Computer Science, To Appear, 1989.Available as a technical report from Department of Computer and Information Science, </note> <institution> University of Pennsylvania. </institution>
Reference-contexts: predicates, and without free tuple vari ables can be translated into semantically equivalent expressions in the relational algebra, and conversely. 4 Complex objects, transitive closure, and grouping Without going into the details of the complex object model, we remark that it makes a good match with our language's type system <ref> [BJO89, OBB89] </ref>. In this section we will first show that our language is at least as expressive as Abiteboul and Beeri's algebra (and therefore calculus) for complex objects [AB89]. We have already shown how to express cartesian product and difference (section 2).
Reference: [BK86] <author> F. Bancilhon and S. Khoshafian. </author> <title> A calculus for complex objects. </title> <booktitle> In Proc. ACM Symposium on Principles of Database Systems, </booktitle> <year> 1986. </year>
Reference-contexts: On a more conceptual level, relational algebra does not "scale-up", and new primitives had to be invented to deal with the complex object model. Even so the main concern in the design of languages for the complex object model, has been absolute expressiveness <ref> [BK86, HS88, AB89] </ref>. The optimization techniques, and the concerns for correctness have yet to be discussed. We will instead put forward a programming paradigm that tries to get close to both the semantic simplicity of relational algebra, and the expressive power of unrestricted programming languages.
Reference: [BNST87] <author> C. Beeri, S. Naqvi, O. Shmueli, and S. Tsur. </author> <title> Set constructors in a logic database language. </title> <booktitle> In Proceedings of PODS, </booktitle> <year> 1987. </year> <note> Full paper to appear in Journal of Logic Programming. </note>
Reference-contexts: It is not hard to see that this definition is correct (that is, the commutativity and idempotence conditions are satisfied), since the range of g D here consists only of graphs of functions D ! fff 2 g;. In connection with other work <ref> [BNST87] </ref>, we remark that the grouping operator along with the empty-insert presentation of sets gives interesting expressions for negation, difference and union ofsets. 5 Pump, partition, and hom FAD [BBKV88], LDL [NT89] and Machiavelli [OBB89] all have a construct related to structural recursion on sets.
Reference: [BS91] <author> V. Breazu-Tannen and R. Subrahmanyam. </author> <title> Logical and computational aspects of programming with lists/bags/sets. </title> <booktitle> In Proceedings of ICALP, </booktitle> <year> 1991. </year> <note> To appear. </note>
Reference-contexts: A guiding principle is that how queries are implemented is as important as if they can be implemented. To summarize the main advantages: * As in relational algebra, the meaning of any relation transformer is guaranteed to be a total map taking finite relations to finite relations. (see <ref> [BS91] </ref> for the denotational, and operational semantics of such languages, and for reasoning about such programs). * Relational queries have a natural representation using structural recursion. <p> In fact, these two kinds of definitions are not independent, one can express each by the other (and the correspondence extends to the associated reasoning by structural induction) as shown in <ref> [BS91] </ref>. <p> clauses above, but in order for this meaning to exist, we must require that the meanings of u and e form a commutative-idempotent monoid on the range of the meaning of (e; f; u), respectively that on the range of the meaning of (e; i), the meaning of i satisfies <ref> [BS91] </ref> (with a slight abuse of notation that confuses syntax and semantics) i (x; i (y; S)) = i (y; i (x; S)) (1) Using an obvious analogy, we will call condition (1) commutativity, and condition (2) idempotence. Such conditions make programming with sets more challenging, but also more interesting. <p> In what follows we will perpetrate a slight abuse of notation by writing semantic proofs of semantic facts in programming syntax. (In fact, the proofs for the next lemma can all be formalized in syntax too, by using one of the logics described in <ref> [BS91] </ref>.) We still need one more notation: the semantic transitive closure is denoted by R 7! R + . Lemma 4.1 1. ; is transitive. If T is transitive then i (r; T ) is also transitive. 2. Let T be transitive. <p> replace the definition of h above with 3 fun h (;) = e j h (Insert (x; S)) = if x 2 S then h (S) else u (f (x); h (S)) A cleaner method is to convert sets to bags and then to do structural recursion on bags. (see <ref> [BS91] </ref> for such recursion constructs). Indeed, this is suggested by the fact that such programs plus dropping the disjointness/partition conditions work just fine for computing aggregate operators on bags. It is then sufficient to program the fundamental function that coerces a set into a bag.
Reference: [HS88] <author> R. Hull and J. Su. </author> <title> On the expressive power of database queries with intermediate types. </title> <booktitle> In Proceedings of PODS, </booktitle> <year> 1988. </year>
Reference-contexts: On a more conceptual level, relational algebra does not "scale-up", and new primitives had to be invented to deal with the complex object model. Even so the main concern in the design of languages for the complex object model, has been absolute expressiveness <ref> [BK86, HS88, AB89] </ref>. The optimization techniques, and the concerns for correctness have yet to be discussed. We will instead put forward a programming paradigm that tries to get close to both the semantic simplicity of relational algebra, and the expressive power of unrestricted programming languages.
Reference: [INK91] <author> T. Imielinski, S. Naqvi, and Vadaparty K. </author> <title> Incomplete objects|a data model for design and planning applications. </title> <booktitle> In Proceedings of SIGMOD, </booktitle> <year> 1991. </year> <note> To appear. </note>
Reference-contexts: paper (with idempotent operations) is the ability to program flexibly with objects which lack equality (such as relations of algorithms) while this is quite restricted in the other languages mentioned. 6 Further research We expect that the linguistic techniques proposed here will also be applicable in dealing with incomplete objects <ref> [INK91] </ref>, a data model that captures the ideas of incomplete specifications. In particular, we are interested in studying the semantic properties of or-objects as sets of possible worlds. The transitive closure algorithms (section 4) seem to underscore the ability of structural recursion to represent efficient interesting algorithms.
Reference: [NT89] <author> S. Naqvi and S. Tsur. </author> <title> A Logical Language for Data and Knowledge Bases. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: Indeed, the plethora of "explosion" diagrams in any industrial catalog, points to the ever present need for such an operation. All practical query languages introduce a grouping operation, and this operation plays a central role in LDL <ref> [NT89] </ref>, which is based on a complex object model. As in the case of transitive closure we give a direct implementation of grouping, which avoids the use of powerset. <p> In connection with other work [BNST87], we remark that the grouping operator along with the empty-insert presentation of sets gives interesting expressions for negation, difference and union ofsets. 5 Pump, partition, and hom FAD [BBKV88], LDL <ref> [NT89] </ref> and Machiavelli [OBB89] all have a construct related to structural recursion on sets.
Reference: [OB88] <author> A. Ohori and P. Buneman. </author> <title> Type inference in a database programming language. </title> <booktitle> In Proc. ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 174-183, </pages> <address> Snowbird, Utah, </address> <month> July </month> <year> 1988. </year>
Reference-contexts: For more clarity, we will occasionally specify the type of expressions. A more subtle problem is whether our primitives can be typed in a polymorphic manner (thus leaving the type decorations off). This is particularly challenging in the case of tuples/records (see <ref> [OB88] </ref> and references therein). One example of a rich polymorphic type system for relational databases is to be found in Machiavelli [OBB89], and its ideas can be equally successfully applied to the language we consider here.
Reference: [OBB89] <author> A. Ohori, P. Buneman, and V. Breazu-Tannen. </author> <title> Database programming in Machiavelli a polymorphic language with static type inference. </title> <booktitle> In Proceedings of the ACM SIGMOD conference, </booktitle> <pages> pages 46-57, </pages> <month> May - June </month> <year> 1989. </year>
Reference-contexts: The first problem is the mismatch between data models and type systems (the infamous "impedance mismatch" problem). Good progress has been made in overcoming this problem (see for example, Pascal-R, Galileo [Sch77, ACO83]), and in fact, the present paper builds on Machiavelli <ref> [OBB89] </ref>. But there is also a second problem, which stems from the universality of the languages in which we try to integrate database manipulation primitives. <p> Its main computational engine is structural recursion on sets. All programming is done within a "nicely" typed lambda calculus, as in Machiavelli <ref> [OBB89] </ref>. A guiding principle is that how queries are implemented is as important as if they can be implemented. <p> This is particularly challenging in the case of tuples/records (see [OB88] and references therein). One example of a rich polymorphic type system for relational databases is to be found in Machiavelli <ref> [OBB89] </ref>, and its ideas can be equally successfully applied to the language we consider here. <p> predicates, and without free tuple vari ables can be translated into semantically equivalent expressions in the relational algebra, and conversely. 4 Complex objects, transitive closure, and grouping Without going into the details of the complex object model, we remark that it makes a good match with our language's type system <ref> [BJO89, OBB89] </ref>. In this section we will first show that our language is at least as expressive as Abiteboul and Beeri's algebra (and therefore calculus) for complex objects [AB89]. We have already shown how to express cartesian product and difference (section 2). <p> In connection with other work [BNST87], we remark that the grouping operator along with the empty-insert presentation of sets gives interesting expressions for negation, difference and union ofsets. 5 Pump, partition, and hom FAD [BBKV88], LDL [NT89] and Machiavelli <ref> [OBB89] </ref> all have a construct related to structural recursion on sets.
Reference: [Sch77] <author> J.W. Schmidt. </author> <title> Some high level language constructs for data of type relation. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 5(2), </volume> <year> 1977. </year>
Reference-contexts: We see at least two problems with embedded query languages. The first problem is the mismatch between data models and type systems (the infamous "impedance mismatch" problem). Good progress has been made in overcoming this problem (see for example, Pascal-R, Galileo <ref> [Sch77, ACO83] </ref>), and in fact, the present paper builds on Machiavelli [OBB89]. But there is also a second problem, which stems from the universality of the languages in which we try to integrate database manipulation primitives.
References-found: 14

