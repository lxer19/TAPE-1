URL: http://www.cs.colostate.edu/~ftppub/TechReports/1996/tr96-121.ps.Z
Refering-URL: http://www.cs.colostate.edu/~ftppub/
Root-URL: 
Email: mrice@uts.cs.wesleyan.edu seidman@cs.colostate.edu  
Phone: Phone: (970) 491-5862 Fax: (970) 491-2466  
Title: PGM Architectural Style  
Author: Michael D. Rice Stephen B. Seidman 
Web: WWW: http://www.cs.colostate.edu  
Address: Fort Collins, CO 80523-1873  
Date: September 17, 1996  
Affiliation: Computer Science Group Department of Computer Science Mathematics Department Colorado State University Wesleyan University  Department of Computer Science Colorado State University  
Note: Describing the  This research was partially sponsored by a grant from the Naval Research Laboratory.  
Pubnum: Technical Report CS-96-121  
Abstract: Computer Science Colorado Technical Report State University 
Abstract-found: 1
Intro-found: 0
Reference: [A] <author> R. Allen, HLA: </author> <title> A standards effort as architectural style, </title> <booktitle> Proceedings of the Second International Software Architecture, </booktitle> <pages> pp. 130-133, </pages> <year> 1996. </year> <month> 16 </month>
Reference-contexts: The set SemanticDescriptions contains abbreviations that correspond to a variety of communication capabilities, and the mapping semantic-descr assigns an abbreviation to each label in a setting. For example, the abbreviations uac and usc represent unidirectional asynchronous and synchronous communication, respectively. Each abbreviation a has a meaning <ref> [ a ] </ref> and a set of associated properties, including its text description. <p> The primary purpose for constructing an ASDL model of PGM was to obtain a deeper understanding of an industrially important architectural style. A similar approach was taken by Delisle and Garlan when they constructed a Z-based model of the architecture of a digital oscilloscope [DG]. More recently, Allen <ref> [A] </ref> has undertaken a similar effort by using WRIGHT to model the Department of Defenses High Level Architecture for Simulations (HLA) as an architectural style in order to obtain an understanding of the architectures built using this style. 7.
Reference: [AAG] <author> G. Abowd, R. Allan, and D. Garlan, </author> <title> Using style to understand descriptions of software architecture, </title> <booktitle> Proceedings of the ACM SIGSOFT93 Symposium on Foundations of Software Engineering, </booktitle> <pages> pp. 9-20, </pages> <year> 1993. </year>
Reference-contexts: First, identifying common architectural patterns for software systems is analogous to identifying basic data structures such as lists, stacks, and trees. The importance of identifying such useful architectural styles is now widely recognized <ref> [AAG] </ref>. Second, identifying appropriate architectural description notations is analogous to developing high level programming languages for describing and using data structures. In our view, a notion of abstract software types can provide a formal basis for software architectures, just as abstract data types do for data structures. <p> While this is similar to the approach taken with MILs, this approach cannot be used to represent the semantics of a style, since MILs carry no semantic information. A similar observation has recently been made by Abowd, Allan, and Garlan <ref> [AAG] </ref>, who state that an abstract representation of the elements of an architecture is insufficient to convey the meaning of the architecture, and that these elements must be interpreted if they are to be meaningful. <p> As a consequence, we will be including a version of the formalism as an annex to the draft PGM standard. 6. Related research The term architectural style was introduced by Abowd, Allen, and Garlan in <ref> [AAG] </ref>. In that paper, the authors formalize an abstract syntax (henceforth referred to as the AAG syntax) for software architectures and show how the abstract syntax can be mapped to a semantic model for each style. <p> The AAG syntax consists of Z schemas that specify sets of components and connectors, and an attachment mapping that is used to associate elements of those sets. The semantic models in <ref> [AAG] </ref> are also expressed using Z schemas, and the mapping from syntax to semantics is defined using the signature elements of the syntactic and semantic schemas. Finally, the constraints imposed on the syntax by the semantic model are derived by combining the syntactic and semantic schemas. <p> Finally, the constraints imposed on the syntax by the semantic model are derived by combining the syntactic and semantic schemas. Despite their common goals and their common use of Z formalism, there are some important differences between the approaches. First, the approach used in <ref> [AAG] </ref> often makes it difficult to separate the syntactic and semantic aspects of a style. <p> In addition, semantic models in <ref> [AAG] </ref> are built around transition functions representing state machines. This approach seems less expressive than the incorporation of process algebra expressions into ASDL schemas, as advocated here. In [AG], Allen and Garlan propose another approach for describing architectural components that is also somewhat similar to ASDL.
Reference: [AG] <author> R. Allan and D. Garlan, </author> <title> Formalizing architectural connection, </title> <booktitle> Proceedings of the 16th International Conference on Software Engineering, </booktitle> <pages> pp. 71-80, </pages> <year> 1994. </year>
Reference-contexts: In addition, semantic models in [AAG] are built around transition functions representing state machines. This approach seems less expressive than the incorporation of process algebra expressions into ASDL schemas, as advocated here. In <ref> [AG] </ref>, Allen and Garlan propose another approach for describing architectural components that is also somewhat similar to ASDL. This approach is associated with a description language called 15 WRIGHT. The instances and attachments described in [AG] correspond to ASDL nodes and labels. <p> In <ref> [AG] </ref>, Allen and Garlan propose another approach for describing architectural components that is also somewhat similar to ASDL. This approach is associated with a description language called 15 WRIGHT. The instances and attachments described in [AG] correspond to ASDL nodes and labels. Also, the idea of a connector provides a means of describing execution semantics. The ports on instances correspond to port processes and although this phrase is not used, roles correspond to ports on connectors. <p> In addition, CSP expressions are used to describe the semantics of the ports and connectors. This is roughly equivalent to our description of semantics using semantic descriptions and a composition expression. By contrast with ASDL, <ref> [AG] </ref> has no notion of encapsulation, and there is no type-theoretic basis that supports the specification of generic operations for constructing an architecture. Nonetheless, the spirit of the work in [AG] is similar to our own, most importantly in its recognition of the importance of using a formal notation to obtain <p> By contrast with ASDL, <ref> [AG] </ref> has no notion of encapsulation, and there is no type-theoretic basis that supports the specification of generic operations for constructing an architecture. Nonetheless, the spirit of the work in [AG] is similar to our own, most importantly in its recognition of the importance of using a formal notation to obtain a precise description of execution and interface semantics.
Reference: [DG] <author> N. Delisle and D. Garlan, </author> <title> Applying formal specification to industrial problems: a specification of an oscilloscope, </title> <booktitle> IEEE Software 7(1990), </booktitle> <pages> 29-37. </pages>
Reference-contexts: The primary purpose for constructing an ASDL model of PGM was to obtain a deeper understanding of an industrially important architectural style. A similar approach was taken by Delisle and Garlan when they constructed a Z-based model of the architecture of a digital oscilloscope <ref> [DG] </ref>. More recently, Allen [A] has undertaken a similar effort by using WRIGHT to model the Department of Defenses High Level Architecture for Simulations (HLA) as an architectural style in order to obtain an understanding of the architectures built using this style. 7.
Reference: [DK] <author> F. DeRemer and H. Kron, </author> <title> Programming-in-the-large versus programming in-the-small, </title> <journal> IEEE Transactions on Software Engineering 2(1976), </journal> <pages> 80-86. </pages>
Reference-contexts: 1 . Introduction Since the late 1970s, software systems have been designed as collections of modules that interact with their environments through well-defined interfaces <ref> [DK] </ref>. This perspective gave rise to a number of module interconnection languages (MILs) that could be used to describe the configuration of the modules and interfaces of a software system [PN].
Reference: [GP] <author> D. Garlan and D. E. Perry, </author> <title> Introduction to the special issue on software architecture, </title> <journal> IEEE Transactions on Software Engineering 21 (1995), </journal> <pages> 269-274. </pages>
Reference: [GS] <author> D. Garlan and M. Shaw, </author> <title> An introduction to software architecture, </title> <editor> in V. Ambriola and G. Tortora, eds., </editor> <booktitle> Advances in Software Engineering and Knowledge Engineering, </booktitle> <volume> vol. 1, </volume> <publisher> World Scientific, </publisher> <pages> pp. 1-39, </pages> <year> 1993. </year>
Reference-contexts: The modular view of software systems has been replaced by the study of abstract models of the structure of software systems, which have come to be called software architectures ([GP], <ref> [GS] </ref>). These models raise problems analogous to those which motivated the development of data structures, with program modules playing the role of data types. First, identifying common architectural patterns for software systems is analogous to identifying basic data structures such as lists, stacks, and trees.
Reference: [H] <author> C. A. R. Hoare, </author> <title> Communicating Sequential Processes, </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: Semantic interpretations are assigned to the templates interface by an interp mapping that associates a composition of guarded CSP processes <ref> [H] </ref> with each template. For example, if a template t has two ports p and q with direction attributes in and out, respectively, then the CSP process interp (t) = *(p ? x fi q ! x fi SKIP) 5 specifies that the template provides a non-terminating copy operation.
Reference: [J] <author> G. Jones, </author> <title> Programming in occam, </title> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: The Boolean guards act as preconditions for the channel operations. The syntax for the guards is an extension to CSP that was adapted from the occam language <ref> [J] </ref>. For example, if INPUT R, the queue is willing to receive data, and the process continues as described. If INPUT R, however, the queue is not willing to receive data, and the input portion of the queue process is equivalent to SKIP.
Reference: [KM] <author> R. M. Karp and R. E. Miller, </author> <title> Properties of a model for parallel computation: determinacy, termination, queuing, </title> <journal> SIAM Journal of Applied Mathematics 14 (1966), </journal> <pages> 1390-1411. </pages>
Reference: [KS] <author> D. J. Kaplan and R.S. Stevens, </author> <title> Processing graph method 2.0 semantics, </title> <type> manuscript, </type> <institution> US Naval Research Laboratory, </institution> <month> June, </month> <year> 1995. </year>
Reference-contexts: The utility and power of the model will be demonstrated by an application to an architectural style that has industrial significance. The Processing Graph Method (PGM) is a coarse-grain dataflow software architectural style developed at the US Naval Research Laboratory, primarily for signal processing applications <ref> [KS] </ref>. It has been used for more than ten years to design signal processing software for execution on a special-purpose multiprocessor. An effort is currently under way to develop an IEEE standard for PGM. <p> This effort is intended to support the migration of the methodology and software to commercially available multiprocessors and to provide a common basis for application developers working on different hardware platforms. The syntax and semantics of the PGM style are currently only described by natural language text <ref> [KS] </ref>. Since PGM is a very complex style, this text is often obscure and subject to varying interpretations. An ASDL description of the PGM style has the potential to provide a solid and reliable platform for developers and implementors. 3 2. <p> The current effort to develop an IEEE standard for PGM is intended to support the migration of the methodology and software to commercially available multiprocessors and to provide a common basis for application developers working on different hardware platforms. A PGM application <ref> [KS] </ref> consists of one or more PGM graphs and PGM command programs. The nodes of a PGM graph consist of PGM transitions that represent computations and data restructuring operations, and PGM places that represent data transfers. Graph edges may only exist between nodes of different category. <p> From that perspective, the constraints governing the configuration of PGM graphs can be regarded as defining a PGM architectural style. A textual description of these constraints is given in <ref> [KS] </ref>. The constraints are rather complex, and the text of [KS] is often subject to conflicting interpretations. In the following section, we will show how ASDL can be used to obtain a reliable description of the PGM style that can serve as a stable foundation for implementors. <p> From that perspective, the constraints governing the configuration of PGM graphs can be regarded as defining a PGM architectural style. A textual description of these constraints is given in <ref> [KS] </ref>. The constraints are rather complex, and the text of [KS] is often subject to conflicting interpretations. In the following section, we will show how ASDL can be used to obtain a reliable description of the PGM style that can serve as a stable foundation for implementors. <p> This document must include a correct and unequivocal definition of PGM. Until now, such definitions have been written in natural language <ref> [KS] </ref>, and the informality of natural language definitions has given rise to many rounds of discussion and clarification. The primary purpose of constructing an ASDL model of PGM was to create a formal model that could serve as a reference point for developers and implementors. <p> The primary purpose of constructing an ASDL model of PGM was to create a formal model that could serve as a reference point for developers and implementors. As an example, compare the following definition of the PGM queue, taken from <ref> [KS] </ref>, with the formalism of constraints (Q1) and (Q2) of PGM_Library. A queue is a place that shall execute by receiving tokens from its data input port and sending them out through its data output port.
Reference: [PGM] <institution> Draft Processing Graph Method Standard, Naval Research Laboratory, </institution> <month> January </month> <year> 1997. </year>
Reference-contexts: Similarly, an appropriate process responds to requests received on OUTPUT op by consuming data, outputting data, or outputting the number of tokens currently stored in the queue. Descriptions of these processes are given in <ref> [PGM] </ref>. Similar constraints are associated with ordinary transitions. These nodes represent computations, and they may have any number of input and output ports of different types. For reasons of space, neither these constraints, nor those describing the semantics of special transitions, can be given here.
Reference: [PN] <author> R. Prieto-Diaz and J. M. Neighbors, </author> <title> Module interconnection languages, </title> <journal> Journal of Systems and Software 6(1986), </journal> <pages> 307-334. </pages>
Reference-contexts: This perspective gave rise to a number of module interconnection languages (MILs) that could be used to describe the configuration of the modules and interfaces of a software system <ref> [PN] </ref>. In recent years, this syntactic view of software systems has come to be regarded as insufficient, since it says nothing about the semantics of the modules and interfaces.
Reference: [RR] <author> G. M. Reed and A. W. Roscoe, </author> <title> A timed model for communicating sequential processes, </title> <booktitle> Theoretical Computer Science 58 (1988), </booktitle> <pages> 249-261. </pages>
Reference-contexts: ASDL_Setting [Indices, Attributes, Parts, SemanticDescriptions] MIL_Setting [Indices, Attributes] ASDL_Library [Indices, Attributes, Parts] comp-expr : ProcessExpressions semantic-descr : Labels |fi SemanticDescriptions dom semantic-descr = ran label A composition expression is a restricted type of timed CSP process <ref> [RR] </ref> in which node names are viewed as processes. For example, it may specify that the nodes in a setting will be executed in parallel. The members of ProcessExpressions are described in [RS2].
Reference: [RS1] <author> M.D. Rice and S.B. Seidman, </author> <title> A formal model for module interconnection languages, </title> <journal> IEEE Transactions on Software Engineering 20 (1994), </journal> <pages> 88-101. </pages>
Reference-contexts: The Z schemas used in ASDL are derived from those used in the model for MILs proposed by Rice and Seidman in <ref> [RS1] </ref> (henceforth called the RS MIL model). As in the earlier model, the ASDL schemas are generic Z schemas. The syntax of a particular architectural style is represented by a specific instantiation of the generic schemas. Such an instantiation constrains the configuration of the elements that make up an architecture. <p> These types can be categorized into several groups that will be discussed in turn: MIL types, semantic types, unit types, and system types. 2.1 M I L Types The Z schemas of <ref> [RS1] </ref> were used to describe module interconnection languages, which express the structure of a software system in terms of constraints imposed on the systems modules and module interfaces.
Reference: [RS2] <author> M.D. Rice and S.B. Seidman, </author> <title> Using Z as a substrate for an architectural style description language, </title> <type> Technical Report 96-120, </type> <institution> Department of Computer Science, Colorado State University, </institution> <year> 1996. </year>
Reference-contexts: The members of Interpretations are described in <ref> [RS2] </ref>. The extended Setting schema contains a composition expression that specifies how the nodes in a setting are composed for execution purposes and a semantic description mapping that assigns a semantic abbreviation to each label used in a module. <p> For example, it may specify that the nodes in a setting will be executed in parallel. The members of ProcessExpressions are described in <ref> [RS2] </ref>. It is important to note that ASDL uses the Z and CSP formalisms orthogonally, so that there is no need to propose a common semantic domain for the two formalisms. <p> These connections and the associated interface semantics are described by an additional unit type. For reasons of space, we will not be able to present the corresponding schema here; full details can be found in <ref> [RS2] </ref>. This schema provides a set of virtual ports that represents the public interfaces of the unit, links between the virtual ports and the slots of the module, and semantic descriptions of the communication capabilities of the virtual ports. <p> We will not be able to present the corresponding schema here; full details can be found in <ref> [RS2] </ref>. 2.4 Operations ASDL contains a number of basic operations that support the incremental specification of the software types. These serve as guides for the design of application-dependent operations that are constructed by adding new signatures and constraints to existing operations or by incorporating existing operations into a new operation. <p> Detailed descriptions of these operations can be found in <ref> [RS2] </ref>. 7 3 . The PGM Architectural Style The Processing Graph Method (PGM) is a coarse-grain dataflow software methodology developed at the US Naval Research Laboratory, primarily for signal processing applications. <p> These nodes represent computations, and they may have any number of input and output ports of different types. For reasons of space, neither these constraints, nor those describing the semantics of special transitions, can be given here. Full details can be found in <ref> [RS2] </ref>. 12 The PGM-specific version of the ASDL semantic module schema is obtained by adding five new signature elements (indicated in boldface italics) and five new constraints to the ADSL_Setting schema. The PGM_Setting schema corresponds to a PGM graph.
Reference: [S] <author> J. M. Spivey, </author> <title> The Z Notation, A Reference Manual, </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: This paper gives an overview of ASDL and shows how it can be used to obtain a description of an industrialstrength software architectural style. Each ASDL software type is associated with a Z schema <ref> [S] </ref> that is invariant across all applications. The software types support the description of the execution and interface semantics of the components of an architecture or architectural style. In addition, ASDL provides schemas that correspond to basic operations for modifying the state described by the software types.
Reference: [SK] <author> R. S. Stevens and D. J. Kaplan, </author> <title> Determinacy of generalized schema, </title> <journal> IEEE Transactions on Computers 41 (1992), </journal> <pages> 776-779. </pages>
Reference-contexts: In many circumstances, the result of the execution of a PGM graph can be shown to be independent of the execution order of its individual transitions ([KM], <ref> [SK] </ref>). represents a place node corresponding to a queue. Ports are represented by small squares on node boundaries.
References-found: 18

