URL: http://www.cag.lcs.mit.edu/~robertb/online_simulator.ps
Refering-URL: http://www.cag.lcs.mit.edu/~robertb/talisman2/index.html
Root-URL: 
Email: robertb@lcs.mit.edu  
Title: Talisman: Fast and Accurate Multicomputer Simulation  
Author: Robert C. Bedichek 
Address: Cambridge, MA 02139  
Affiliation: Laboratory for Computer Science, NE43-629 Massachusetts Institute of Technology  
Abstract: Talisman is a simulator that models the execution semantics and timing of a multicomputer. Talisman is unique in combining high semantic accuracy, high timing accuracy, portability, and good performance. This good performance allows users to run significant programs on large simulated multicomputers. The combination of high accuracy and good performance yields an ideal tool for evaluating architectural trade-offs. Talisman models the semantics of virtual memory, a circuit-switched internode interconnect, I/O devices, and instruction execution in both user and supervisor modes. It also models the timing of processor pipelines, caches, local memory buses, and a circuit-switched interconnect. Talisman executes the same program binary images as a hardware prototype at a cost of about 100 host instructions per simulated instruction. On a suite of accuracy benchmarks run on the hardware and the simulator, Talisman and the prototype differ in reported running times by only a few percent. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Robert C. Bedichek. </author> <title> Some efficient architecture simulation techniques. </title> <booktitle> In Proceedings of the Winter 1990 USENIX Conference, </booktitle> <pages> pages 53-63, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: We achieved simulation efficiency by starting with a fast, threaded-code simulator and adding only those timing models needed to achieve accuracy. This approach resembles that used to gain semantic accuracy in Talisman's predecessor <ref> [1] </ref>. To measure timing accuracy, we ran a suite of benchmarks on Talisman and the Meerkat prototype. Test results guided our grafting of timing models onto the threaded-code simulator base. We introduce the roles of architecture simulation in Section 2. Section 3 describes some of the varied approaches to simulation. <p> Section 7 describes some of the specific advantages of using Talisman. 2 Roles and Benefits of Architecture Simulation Computer architecture simulators vary widely in their application. They are used by processor architects to evaluate uniprocessor design tradeoffs [8], operating system authors to debug their code <ref> [1] </ref> and to evaluate operating system performance [6, 25], parallel system architects to assess the performance of large systems [4, 9, 23], and end users to execute programs written for one system on a different host system [19, 26, 27]. <p> the same relationship to the literal values as the real time-available slots are to the register values: instruction handlers dereference operand pointers the same way for both register and immediate operands. 4 Talisman's predecessor kept just the DECIP in a host register and calculated IP when its value was needed <ref> [1] </ref>. The predecessor was written for a host with few registers, and it therefore made sense to calculate the IP from the DECIP. <p> supports both user and supervisor modes by allowing instructions to be discovered at run-time, and by modelling the semantics of virtual-to-physical address translation, cache and TLB manipulation operations, synchronous and asynchronous exceptions, the trap-time registers that support exception processing, 5 Talisman's predecessor used a hashing scheme to speed the lookup <ref> [1] </ref>. However, Talisman has a small table of devices, and the lookup time is not significant. various I/O devices, and supervisor-only instructions. Operating systems typically reveal code at run-time and so cannot run on simulators that depend on processing instructions prior to simulation [19].
Reference: [2] <author> Robert C. Bedichek. </author> <title> The Meerkat Multicomputer: Trade-offs in Mul--ticomputer Design. </title> <type> PhD thesis, </type> <institution> University of Washington, </institution> <month> August </month> <year> 1994. </year> <institution> Department of Computer Science technical report 94-06-06. </institution>
Reference-contexts: 1 Introduction This paper 1 describes the structure, performance, accuracy, calibration, and use of Talisman, the Meerkat 2 <ref> [2] </ref> system simulator. We used Talisman to extend performance results from a four node hardware prototype to systems with hundreds of nodes. We also used Talisman to evaluate the performance implications of architectural tradeoffs in the Meerkat design space. <p> We ran several parallel applications on four-node real and simulated Meerkat's. Table 3 shows the correspondence of Talisman and hardware results for a global combine, SOR, and FFT (see <ref> [2] </ref> for a description of these codes). The largest error is 7.8% on a 32-byte global combine. Errors on the complex tests are larger than on the simple tests. This is a product of our method for achieving timing accuracy. <p> Building as precise a breakpoint into the prototype would require redesigning the processor. * Talisman compiles conditional breakpoint expressions into target machine code (see <ref> [2] </ref> for details) to speed conditional breakpoint evaluation by several orders of magnitude.
Reference: [3] <author> James R. Bell. </author> <title> Threaded code. </title> <journal> Communications of the ACM (CACM), </journal> <volume> 16(2) </volume> <pages> 370-372, </pages> <month> June </month> <year> 1973. </year>
Reference-contexts: In addition, it had to model timing accurately. We could not afford to spend years constructing a complex simulator or waiting for results from a slow one. For these reasons, we wrote a simulator that translates instructions to threaded code <ref> [3, 14] </ref>, which is then executed. The threaded code is cached, so that the price of translation for most instructions is paid just once, the first time they are encountered in the code stream. The result is a simulator that has a slow-down of about 100 per simulated processor. <p> The result is a simulator that has a slow-down of about 100 per simulated processor. Its timing is close enough to the prototype's that we can use it to run large programs and make meaningful measurements. 4 Structure of Talisman sists of an instruction translator, a threaded-code interpreter <ref> [3] </ref>, cache models, a TLB model, a physical memory system model, and I/O models. Meerkat uses Motorola MC88100 processors [20] and we refer to MC88100 in the text below as the target. Meerkat programs are compiled, assembled, and linked with a set of GNU cross-development tools on a SPARCstation host.
Reference: [4] <author> Eric A. Brewer, Chrysanthos N. Dellacrocas, Adrian Colbrook, and William E. Weihl. PROTEUS: </author> <title> A high-performance parallel-architecture simulator. </title> <type> Technical Report MIT/LCS/TR-516, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1991. </year>
Reference-contexts: They are used by processor architects to evaluate uniprocessor design tradeoffs [8], operating system authors to debug their code [1] and to evaluate operating system performance [6, 25], parallel system architects to assess the performance of large systems <ref> [4, 9, 23] </ref>, and end users to execute programs written for one system on a different host system [19, 26, 27]. Simulators also vary in their performance and the level of detail they can model.
Reference: [5] <author> Eric A. Brewer and William E. Weihl. </author> <title> Developing parallel applications using high-performance simulation. ACM/ONR Workshop on Parallel and Dist. Debugging. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(12) </volume> <pages> 158-168, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: It is also used in some processors to translate an instruction set that programmers see into a more RISC-like form that is more efficient to execute [7, 11]. 3.3 Direct Execution The target program can also be executed directly on the simulator host <ref> [5, 13, 23] </ref> by encasing the program in an environment that makes it execute as though it were on the simulated system. This technique requires that either the host system have the same instruction set as the target or that the program be recompiled.
Reference: [6] <author> J. Bradley Chen and Brian N. Bershad. </author> <title> The impact of operating system performance on memory system performance. </title> <booktitle> Proceedings of the 14th ACM Symposium on Operating System Principles, </booktitle> <pages> pages 120-133, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: They are used by processor architects to evaluate uniprocessor design tradeoffs [8], operating system authors to debug their code [1] and to evaluate operating system performance <ref> [6, 25] </ref>, parallel system architects to assess the performance of large systems [4, 9, 23], and end users to execute programs written for one system on a different host system [19, 26, 27]. Simulators also vary in their performance and the level of detail they can model.
Reference: [7] <author> D. W. Clark. </author> <title> Pipelining and performance in the VAX-8800 processor. </title> <booktitle> Symposium on Architectural Support for ProgrammingLanguagesand Operating Systems, </booktitle> <month> October </month> <year> 1987. </year>
Reference-contexts: This idea has been used in a variety of simulators for a number of applications [8, 10, 17, 19, 26]. It is also used in some processors to translate an instruction set that programmers see into a more RISC-like form that is more efficient to execute <ref> [7, 11] </ref>. 3.3 Direct Execution The target program can also be executed directly on the simulator host [5, 13, 23] by encasing the program in an environment that makes it execute as though it were on the simulated system.
Reference: [8] <author> Robert F. Cmelik and David Keppel. Shade: </author> <title> A fast instruction-set simulator for execution profiling. </title> <booktitle> In Proceedings of the 1994 ACM SIGMETRICS Conference on Modeling and Measurement of Computer Systems, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: Section 7 describes some of the specific advantages of using Talisman. 2 Roles and Benefits of Architecture Simulation Computer architecture simulators vary widely in their application. They are used by processor architects to evaluate uniprocessor design tradeoffs <ref> [8] </ref>, operating system authors to debug their code [1] and to evaluate operating system performance [6, 25], parallel system architects to assess the performance of large systems [4, 9, 23], and end users to execute programs written for one system on a different host system [19, 26, 27]. <p> A common metric is the slow-down, or the average number of simulator host instructions executed per simulated instruction (see work by Magnusson and others for a more extensive discussion of slow-down [15, 12]). In general, the more detail that the simulator captures, the greater its slow-down <ref> [8, 19] </ref>. Slow but accurate simulators have the advantage of capturing subtleties of the target system. However, their slow speed limits the size of the system they can model and the number of simulated instructions they can execute. <p> Several techniques can improve the performance of macro simulators. Instead of decoding the operation fields each time an instruction is executed, the instruction is translated once into a form that is faster to execute. This idea has been used in a variety of simulators for a number of applications <ref> [8, 10, 17, 19, 26] </ref>. <p> The UNIX utility prof is a profiling tool that is not usually called a simulator. But it could be considered a direct execution simulator that wraps the target program in an environment enabling execution measurement. Shade <ref> [8] </ref> is thought of as a fast macro simulator that uses dynamic compilation. While it is more flexible than prof and uses dynamic instead of static compilation, it is also a tracing tool.
Reference: [9] <author> R.C. Covington, S. Madala, V. Mehta, J.R. Jump, and J.B. Sinclair. </author> <title> The Rice parallel processing testbed. </title> <booktitle> In Proceedings of the 1988 ACM SIGMETRICS and PERFORMANCE Conference, </booktitle> <pages> pages 4-11, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: They are used by processor architects to evaluate uniprocessor design tradeoffs [8], operating system authors to debug their code [1] and to evaluate operating system performance [6, 25], parallel system architects to assess the performance of large systems <ref> [4, 9, 23] </ref>, and end users to execute programs written for one system on a different host system [19, 26, 27]. Simulators also vary in their performance and the level of detail they can model.
Reference: [10] <author> Peter Deutsch and Alan M. Schiffman. </author> <title> Efficient implementation of the Smalltalk-80 system. </title> <booktitle> 11th Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 297-302, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: Several techniques can improve the performance of macro simulators. Instead of decoding the operation fields each time an instruction is executed, the instruction is translated once into a form that is faster to execute. This idea has been used in a variety of simulators for a number of applications <ref> [8, 10, 17, 19, 26] </ref>.
Reference: [11] <author> David R. Ditzel, Hubert R. MeLellan, and Alan D. Berenbaum. </author> <title> The hardware architecture of the CRISP microprocessor. </title> <booktitle> In Proceedings of the 14th Annual International Symposium on Computer Architecture; Computer Architecture News, </booktitle> <pages> pages 309-319, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: This idea has been used in a variety of simulators for a number of applications [8, 10, 17, 19, 26]. It is also used in some processors to translate an instruction set that programmers see into a more RISC-like form that is more efficient to execute <ref> [7, 11] </ref>. 3.3 Direct Execution The target program can also be executed directly on the simulator host [5, 13, 23] by encasing the program in an environment that makes it execute as though it were on the simulated system.
Reference: [12] <author> R. M. Fujimoto and W. B. Campbell. </author> <title> Efficient Instruction Level Simulation of Computers. </title> <journal> Transactions of the Society for Computer Simulation, </journal> <volume> 5(2) </volume> <pages> 109-124, </pages> <month> Apr. </month> <year> 1988. </year>
Reference-contexts: Simulators also vary in their performance and the level of detail they can model. A common metric is the slow-down, or the average number of simulator host instructions executed per simulated instruction (see work by Magnusson and others for a more extensive discussion of slow-down <ref> [15, 12] </ref>). In general, the more detail that the simulator captures, the greater its slow-down [8, 19]. Slow but accurate simulators have the advantage of capturing subtleties of the target system.
Reference: [13] <author> Stephen R. Goldschmidt. </author> <title> Simualtion of Multiprocessors: Accuracy and Performance. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: It is also used in some processors to translate an instruction set that programmers see into a more RISC-like form that is more efficient to execute [7, 11]. 3.3 Direct Execution The target program can also be executed directly on the simulator host <ref> [5, 13, 23] </ref> by encasing the program in an environment that makes it execute as though it were on the simulated system. This technique requires that either the host system have the same instruction set as the target or that the program be recompiled.
Reference: [14] <author> T.G. Lang, J.T. O'Quin, and R.O. Simpson. </author> <title> Threaded code interpreter for object code. </title> <journal> IBM Technical Disclosure Bulletin, </journal> <pages> pages 4238-4241, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: In addition, it had to model timing accurately. We could not afford to spend years constructing a complex simulator or waiting for results from a slow one. For these reasons, we wrote a simulator that translates instructions to threaded code <ref> [3, 14] </ref>, which is then executed. The threaded code is cached, so that the price of translation for most instructions is paid just once, the first time they are encountered in the code stream. The result is a simulator that has a slow-down of about 100 per simulated processor.
Reference: [15] <author> Peter Magnusson. </author> <title> Efficient simulation of parallel hardware. </title> <type> Masters thesis. </type> <institution> Royal Institute of Technology (KTH), Stockholm, Sweden, </institution> <year> 1992. </year>
Reference-contexts: Simulators also vary in their performance and the level of detail they can model. A common metric is the slow-down, or the average number of simulator host instructions executed per simulated instruction (see work by Magnusson and others for a more extensive discussion of slow-down <ref> [15, 12] </ref>). In general, the more detail that the simulator captures, the greater its slow-down [8, 19]. Slow but accurate simulators have the advantage of capturing subtleties of the target system.
Reference: [16] <author> Peter Magnusson and Bengt Werner. </author> <title> Efficient memory simulation in SimICS. </title> <booktitle> In Proceedings of the 28th Annual Simulation Symposium, </booktitle> <year> 1995. </year>
Reference-contexts: For our purposes, this difference in memory coherency was a small price to pay for a simpler cache model and smaller cache state. In addition, it causes no timing inaccuracies. Magnusson and Werner describe an alternative approach to modelling memory systems in their paper on SimICS <ref> [16] </ref>. 4.8 Modelling Instruction Memory Access Talisman models instruction cache cold misses, but not capacity misses. It models cold misses by distinguishing between translated and untranslated instructions. When a decode-me pseudo-instruction is encountered: 1.
Reference: [17] <author> Peter S. Magnusson. </author> <title> A design for efficient simulation of a multiprocessor. </title> <booktitle> MASCOTS '93 Proceedings of the 1993 Western Simulation Multiconference on International Workshop on Modeling, Analysis, </booktitle> <institution> and Simulation of Computer and Telecommunication Systems, </institution> <month> Jan-uary </month> <year> 1993. </year>
Reference-contexts: Several techniques can improve the performance of macro simulators. Instead of decoding the operation fields each time an instruction is executed, the instruction is translated once into a form that is faster to execute. This idea has been used in a variety of simulators for a number of applications <ref> [8, 10, 17, 19, 26] </ref>. <p> The first solution is straightforward and will only increase the page-crossing cost. The second solution could be done in conjunction with full modelling of the i-cache and will probably result in only a small decrease in performance. The third solution is possible, and is used by Magnusson <ref> [17] </ref>, but has a number of problems with instruction cache modelling, debugger breakpoints, register access, and support for multiple program workloads. 4.5 Modelling Basic Instruction Execution Time To model the number of cycles an instruction takes, each simulated processor has an associated current cycle count.
Reference: [18] <author> Henry Massalin and Calton Pu. </author> <title> Threads and input/output in the Synthesis kernel. </title> <booktitle> In Proceedings of the twelth ACM Symposium on operating system principles, </booktitle> <pages> pages 191-201, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: For example, a simulator that has to preprocess all instructions before the simulation is started cannot deal with an operating system that loads program text from a simulated disk. In addition, some operating systems generate code on the fly in response to user requests <ref> [18] </ref>. The execution cost of supervisor modelling is mostly seen in the memory access instructions, which must consult the TLB. To mitigate this cost, we carefully coded the TLB model to be efficient. We estimate that overall execution performance is reduced by less than ten percent due to supervisor-mode modelling.
Reference: [19] <author> Cathy May. </author> <title> Mimic: A fast S/370 simulator. </title> <booktitle> In Proceedings of the ACM SIGPLAN 1987 Symposium on Interpreters and Interpretive Techniques; SIGPLAN Notices, </booktitle> <volume> volume 22, </volume> <pages> pages 1-13, </pages> <address> St. Paul, Minnesota, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: to evaluate uniprocessor design tradeoffs [8], operating system authors to debug their code [1] and to evaluate operating system performance [6, 25], parallel system architects to assess the performance of large systems [4, 9, 23], and end users to execute programs written for one system on a different host system <ref> [19, 26, 27] </ref>. Simulators also vary in their performance and the level of detail they can model. A common metric is the slow-down, or the average number of simulator host instructions executed per simulated instruction (see work by Magnusson and others for a more extensive discussion of slow-down [15, 12]). <p> A common metric is the slow-down, or the average number of simulator host instructions executed per simulated instruction (see work by Magnusson and others for a more extensive discussion of slow-down [15, 12]). In general, the more detail that the simulator captures, the greater its slow-down <ref> [8, 19] </ref>. Slow but accurate simulators have the advantage of capturing subtleties of the target system. However, their slow speed limits the size of the system they can model and the number of simulated instructions they can execute. <p> Several techniques can improve the performance of macro simulators. Instead of decoding the operation fields each time an instruction is executed, the instruction is translated once into a form that is faster to execute. This idea has been used in a variety of simulators for a number of applications <ref> [8, 10, 17, 19, 26] </ref>. <p> Instead, instructions are first translated to decoded instructions, which are cached in structures called decoded instruction pages. Only instructions encountered during execution are translated and cached, so unlike Mimic <ref> [19] </ref>, there is little startup overhead. Decoded instructions contain up to six fields. The first field always points to the decoded instruction's handler, the code that interprets the instruction. This pointer makes it easy to dispatch decoded instructions. <p> However, Talisman has a small table of devices, and the lookup time is not significant. various I/O devices, and supervisor-only instructions. Operating systems typically reveal code at run-time and so cannot run on simulators that depend on processing instructions prior to simulation <ref> [19] </ref>. For example, a simulator that has to preprocess all instructions before the simulation is started cannot deal with an operating system that loads program text from a simulated disk. In addition, some operating systems generate code on the fly in response to user requests [18].
Reference: [20] <institution> MC88100 RISC Microprocessor User's Manual. Motorola Corporation, </institution> <address> 2900 South Diablo Way, Tempe, Arizona. </address>
Reference-contexts: Meerkat uses Motorola MC88100 processors <ref> [20] </ref> and we refer to MC88100 in the text below as the target. Meerkat programs are compiled, assembled, and linked with a set of GNU cross-development tools on a SPARCstation host. The resulting binary image can then be run on either the Meerkat prototype or on Talisman.
Reference: [21] <institution> MC88200 Cache/Memory Management User's Manual. Motorola Corporation, </institution> <address> 2900 South Diablo Way, Tempe, Arizona. </address>
Reference-contexts: Handlers access the time-available value by adding a constant to the register pointer 3 The timing of the data cache is modelled by keeping track of what the tag state of a real MC88200 cache <ref> [21] </ref> would be. Talisman models the MC88200's Least Recently Used (LRU) behavior by keeping the cycle count of the most recent access to each cache line. While this takes more storage than the LRU bit scheme that the hardware uses, it is simpler to understand and faster to execute. <p> The table lookup corresponds to the address decoders found in hardware between the processor address bus and the I/O device select signals 5 The I/O models include Meerkat's 32-bit cycle counter, interrupt controller status and control registers, internode status and control registers, internode DMA controller, MC88200 <ref> [21] </ref> (cache and memory management unit) control pages, and some pseudo-devices. Pseudo-devices models are accessed by the simulated program just as are other device models, but pseudo-devices do not correspond to any real devices. Pseudo-device models allow the simulated program control over execution statistics collection.
Reference: [22] <author> Carl Ponder. </author> <type> Personal communication, </type> <month> February </month> <year> 1994. </year>
Reference-contexts: They can also execute short sequences of code, enabling designers to evaluate architectural features and debug microcode. Microarchitecture simulators typically have a slow-down around 20,000 <ref> [22] </ref>, making them too slow for debugging all but the shortest code sequences. 3.2 Macroarchitecture Simulation Macroarchitecture simulators (also called macro simulators or instruction set architecture simulators) can execute longer-running programs. They are used for studying cache performance and debugging operating system code in advance of hardware availability.
Reference: [23] <author> Steven K. Reinhardt, Mark D. Hill, James R. Larus, Alvin R. Lebeck, James C. Lewis, and David A. Wood. </author> <title> The Wisconsin Wind Tunnel: Virtual prototyping of parallel computers. </title> <journal> Performance Evaluation Review, </journal> <volume> 21(1) </volume> <pages> 48-60, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: They are used by processor architects to evaluate uniprocessor design tradeoffs [8], operating system authors to debug their code [1] and to evaluate operating system performance [6, 25], parallel system architects to assess the performance of large systems <ref> [4, 9, 23] </ref>, and end users to execute programs written for one system on a different host system [19, 26, 27]. Simulators also vary in their performance and the level of detail they can model. <p> It is also used in some processors to translate an instruction set that programmers see into a more RISC-like form that is more efficient to execute [7, 11]. 3.3 Direct Execution The target program can also be executed directly on the simulator host <ref> [5, 13, 23] </ref> by encasing the program in an environment that makes it execute as though it were on the simulated system. This technique requires that either the host system have the same instruction set as the target or that the program be recompiled.
Reference: [24] <author> Mendel Rosenblum and Emmett Witchel. SimOS: </author> <title> A Platform for Complete Workload Studies. Personal Communication (to be published), </title> <year> 1995. </year>
Reference-contexts: A promising approach is the one taken by SimOS <ref> [24] </ref>. This simulator handles both user and kernel code by dynamically translating target instructions into short sequences of host-native code.
Reference: [25] <author> Margo Selzer, Peter Chen, and John Ousterhout. </author> <title> Disk scheduling revisited. </title> <booktitle> In Proceedings of the Winter 1990 USENIX Conference, </booktitle> <pages> pages 313-324, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: They are used by processor architects to evaluate uniprocessor design tradeoffs [8], operating system authors to debug their code [1] and to evaluate operating system performance <ref> [6, 25] </ref>, parallel system architects to assess the performance of large systems [4, 9, 23], and end users to execute programs written for one system on a different host system [19, 26, 27]. Simulators also vary in their performance and the level of detail they can model.
Reference: [26] <author> Richard L. Sites, Anton Chernoff, Mathew B. Kerk, Maurice P. Marks, and Scott G. Robinson. </author> <title> Binary translation. </title> <journal> Communications of the ACM, </journal> <pages> pages 69-81, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: to evaluate uniprocessor design tradeoffs [8], operating system authors to debug their code [1] and to evaluate operating system performance [6, 25], parallel system architects to assess the performance of large systems [4, 9, 23], and end users to execute programs written for one system on a different host system <ref> [19, 26, 27] </ref>. Simulators also vary in their performance and the level of detail they can model. A common metric is the slow-down, or the average number of simulator host instructions executed per simulated instruction (see work by Magnusson and others for a more extensive discussion of slow-down [15, 12]). <p> Several techniques can improve the performance of macro simulators. Instead of decoding the operation fields each time an instruction is executed, the instruction is translated once into a form that is faster to execute. This idea has been used in a variety of simulators for a number of applications <ref> [8, 10, 17, 19, 26] </ref>.
Reference: [27] <institution> Insignia Solutions. SoftPC Product Information, </institution> <year> 1991. </year>
Reference-contexts: to evaluate uniprocessor design tradeoffs [8], operating system authors to debug their code [1] and to evaluate operating system performance [6, 25], parallel system architects to assess the performance of large systems [4, 9, 23], and end users to execute programs written for one system on a different host system <ref> [19, 26, 27] </ref>. Simulators also vary in their performance and the level of detail they can model. A common metric is the slow-down, or the average number of simulator host instructions executed per simulated instruction (see work by Magnusson and others for a more extensive discussion of slow-down [15, 12]).
Reference: [28] <author> Richard M. Stallman and Roland H. Pesch. </author> <title> Using GDB: The GNU Source-Level Debugger. Free Software Foundation, </title> <type> 545 Tech Square, </type> <address> Cambridge, Ma. 02139, </address> <month> March </month> <year> 1992. </year>
References-found: 28

