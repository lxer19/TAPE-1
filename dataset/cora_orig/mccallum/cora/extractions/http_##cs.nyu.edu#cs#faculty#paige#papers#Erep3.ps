URL: http://cs.nyu.edu/cs/faculty/paige/papers/Erep3.ps
Refering-URL: http://cs.nyu.edu/cs/faculty/paige/research.html
Root-URL: http://www.cs.nyu.edu
Title: A Geometric Constraint Solver  
Author: William Bouma Ioannis Fudos Christoph Hoffmann Jiazhen Cai Robert Paige 
Date: August 1993  
Address: West Lafayette, IN 47907-1398  251 Mercer Str., New York, NY 10012  
Affiliation: Department of Computer Science, Purdue University  Department of Computer Science, Courant Institute  
Pubnum: Report CSD-TR-93-054,  
Abstract: We report on the development of a two-dimensional geometric constraint solver. The solver is a major component of a new generation of CAD systems that we are developing based on a high-level geometry representation. The solver uses a graph-reduction directed algebraic approach, and achieves interactive speed. We describe the architecture of the solver and its basic capabilities. Then, we discuss in detail how to extend the scope of the solver, with special emphasis placed on the theoretical and human factors involved in finding a solution | in an exponentially large search space | so that the solution is appropriate to the application and the way of finding it is intuitive to an untrained user. fl Supported in part by ONR contract N00014-90-J-1599, by NSF Grant CDA 92-23502, and by NSF Grant ECD 88-03017. y Supported by a David Ross fellowship. z Supported in part by ONR contract N00014-90-J-1890, by AFOSR grant 91-0308, and by NSF grant MIP 93-00210. x This report and others are available via anonymous ftp to arthur.cs.purdue.edu, in direc tory pub/cmh and subsidiaries 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Aldefeld. </author> <title> Variation of geometries based on a geometric-reasoning method. </title> <booktitle> Computer Aided Design, </booktitle> <volume> 20(3) </volume> <pages> 117-126, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: Bruderlin and Sohrt have implemented an experimental constraint solving system in Prolog. They do not address how to devise rules for determining automatically which of the possible solutions is the one the user intended. Aldefeld <ref> [1] </ref> uses a forward chaining inference mechanism. He assumes that lines are directed, and formulates additional rules that restrict the number of possible solutions. A similar method is presented in [52], where handling of over-constrained and underconstrained cases is given special consideration.
Reference: [2] <author> L. A. Barford. </author> <title> A Graphical, Language-Based Editor for Generic Solid Models Represented by Constraints. </title> <type> PhD thesis, </type> <institution> Dept of Computer Science, Cornell University, </institution> <month> March </month> <year> 1987. </year> <type> TR 87-813. </type>
Reference-contexts: Sketchpad [51] was the first system to use the method of numerical relaxation. Relaxation is slow but quite general. Many systems like ThingLab [3] and Magritte [22] can do relaxation as an alternative to some other method. In <ref> [2] </ref> a projection method is presented for finding a new solution that minimizes the Euclidean distance between the old and the new solution. Newton-Raphson iteration has been used in a number of systems, and is faster than relaxation, but it may converge to the wrong solution.
Reference: [3] <author> A. H. Borning. </author> <title> The programming language aspects of ThingLab, a constraint oriented simulation laboratory. </title> <journal> ACM TOPLAS, </journal> <volume> 3(4) </volume> <pages> 353-387, </pages> <year> 1981. </year> <month> 34 </month>
Reference-contexts: Sketchpad [51] was the first system to use the method of numerical relaxation. Relaxation is slow but quite general. Many systems like ThingLab <ref> [3] </ref> and Magritte [22] can do relaxation as an alternative to some other method. In [2] a projection method is presented for finding a new solution that minimizes the Euclidean distance between the old and the new solution. <p> In essence, augmented term rewriting is a graph transformation mechanism using term rewriting rules. Additionally, assignments are supported, as is variable typing, and these additions make augmented term rewriting more expressive than the term rewriting mechanism of pure PROLOG. ThingLab uses the Blue and Delta Blue algorithms described in <ref> [3, 21] </ref>, that are based on a local propagation of degrees of freedom within the constraint graph. Magritte [22] employs propagation to transform the undirected constraint graph, and then uses breadth-first search to derive all solutions. 2.4 Symbolic Constraint Solvers The constraints are transformed into a system of algebraic equations.
Reference: [4] <author> P. Borras, D. Clement, T. Despeyroux, J. Incerpi, G. Kahn, B. Lang, and V. Pascual. </author> <title> Centaur: the system. </title> <type> Technical Report Rapports de Recherche 777, </type> <institution> INRIA, </institution> <year> 1987. </year>
Reference-contexts: The special syntactic, semantic, and transformational capabilities of APTS [12] are well suited to a flexible, experimental development of a logical framework with an evolving Erep language and corresponding solver. Like systems such as Centaur <ref> [4] </ref> the Synthesizer Generator [42], and Refine [41], APTS has a single uniform formalism for lexical analysis, syntactic analysis, and pretty-printing. However, the semantic formalism in APTS has several advantages over the more conventional attribute grammar approach [28] that is used in the Synthesizer Generator. <p> We are not aware of any implementation that allows a comparable unrestricted circularity. The semantic formalism in APTS is also integrated with a conditional rewriting component that is lacking in both the Synthesizer Generator [42] and Centaur <ref> [4] </ref>, and is more abstract and user/friendly than Refine [41]. Although only a prototype implementation of APTS is currently available, the inference and rewriting engines used to compute and maintain semantic relations involve the use of such highly efficient algorithms that the observed performance is reasonable [11].
Reference: [5] <author> D. H. Brown Associates. </author> <title> Conceptual Design: Tradeoffs in Performance and Flexibility. </title> <booktitle> Notes on the design of Pro/ENGINEER, </booktitle> <year> 1991. </year>
Reference-contexts: To succeed, various propagation techniques have been tried, but none of them is guaranteed to derive a solution when one exists. For a review see [33, 46]. Sketchpad [51] uses propagation of degrees of freedom and propagation of known values. Pro/ENGINEER <ref> [5, 40] </ref> uses propagation of known values. Propagation of known values is the inverse process of the propagation of degrees of freedom. Propagation of degrees of freedom is a more abstract method that essentially does a graph reduction.
Reference: [6] <author> B. Bruderlin. </author> <title> Constructing Three-Dimensional Geometric Objects Defined by Constraints. </title> <booktitle> In Workshop on Interactive 3D Graphics, </booktitle> <pages> pages 111-129. </pages> <publisher> ACM, </publisher> <month> October 23-24 </month> <year> 1986. </year>
Reference-contexts: We call this approach rule-constructive solving. Although a Logic Programming style of programming is a good approach for prototyping and experimentation, the extensive computations searching and matching rewrite rules constitute a liability. Bruderlin and Sohrt <ref> [6, 46] </ref> solve constraints in this way and incorporate the Knuth-Bendix critical-pairs algorithm [29]. They show that their method is correct and solves all problems that can be constructed using ruler and compass.
Reference: [7] <author> B. </author> <title> Buchberger. Ein Algorithmus zum Auffinden der Basiselemente des Restklassenringes nach einem nulldimensionalen Polynomideal. </title> <type> PhD thesis, </type> <institution> University of Innsbruck, Austria, </institution> <year> 1965. </year>
Reference-contexts: Both methods can solve general nonlinear systems of algebraic equations. The methods have also been used in mechanical geometry theorem proving [16, 17, 15, 26]. In [30, 31], Kondo considers the addition and deletion of constraints by using the Buchberger's Algorithm <ref> [7, 8] </ref> to derive a polynomial that gives the 7 relationship between the deleted and added constraints. 2.5 Hybrid Solvers Often, constraint solving systems use a combination of the above methods. One method is attempted, and if it does not succeed, another one is tried.
Reference: [8] <author> B. </author> <title> Buchberger. Grobner Bases: An Algorithmic Method in Polynomial Ideal Theory. </title> <editor> In N. K. Bose, editor, </editor> <booktitle> Multidimensional Systems Theory, </booktitle> <pages> pages 184-232. </pages> <address> D. </address> <publisher> Reidel Publishing Co., </publisher> <year> 1985. </year>
Reference-contexts: Both methods can solve general nonlinear systems of algebraic equations. The methods have also been used in mechanical geometry theorem proving [16, 17, 15, 26]. In [30, 31], Kondo considers the addition and deletion of constraints by using the Buchberger's Algorithm <ref> [7, 8] </ref> to derive a polynomial that gives the 7 relationship between the deleted and added constraints. 2.5 Hybrid Solvers Often, constraint solving systems use a combination of the above methods. One method is attempted, and if it does not succeed, another one is tried. <p> Here, (x k ; y k ) is the center of circle k, and r k is its radius. Such constructions are done by precomputing a normal form of the system from which to the unknowns are easier to find. Preprocessing can be done using Grobner bases; e.g., <ref> [8] </ref>. 4.1.4 Graph Transformations The scope of the basic solver can be extended by certain graph transformations. For example, when two angle constraints ff and fi are given between three lines, then a third angle constraint can be added requiring an angle of 180 ffi ff fi. <p> in canonical order, we either prescribe a canonical sequence a-priori in which the geometric elements have to be computed, or else we compute a canonical basis for the ideal generated by the constraint equations that describe the geometric problem, and then enumerate the associated variety in a canonical way; e.g., <ref> [8] </ref>. In the first case, we would prescribe the solver algorithm to belong to a certain family. In the second case, the ideal basis computation is equivalent to solving the constraint problem and thus constitutes committing to a canonical solver. - Both ways compromise devising a neutral format of archiving.
Reference: [9] <author> B. Buchberger, G. Collins, and B. Kutzler. </author> <title> Algebraic methods for geometric reasoning. </title> <booktitle> Annual Reviews in Computer Science, </booktitle> <volume> 3 </volume> <pages> 85-120, </pages> <year> 1988. </year>
Reference-contexts: For example, the symbolic computation community has considered the general problem, in the context of automatically deriving and proving theorems from analytic geometry, and applying these techniques to vision problems <ref> [9, 14, 26, 27] </ref>. The geometric modeling community has considered the problem for the purpose of developing sketching systems in which a rough sketch, annotated with dimension and constraints, is instantiated to satisfy all constraints. This work will be reviewed in the next section. <p> Magritte [22] employs propagation to transform the undirected constraint graph, and then uses breadth-first search to derive all solutions. 2.4 Symbolic Constraint Solvers The constraints are transformed into a system of algebraic equations. The system is solved with symbolic algebraic methods, such as Grobner's bases, e.g., <ref> [9] </ref>, or the Wu-Ritt method [57, 14]. Both methods can solve general nonlinear systems of algebraic equations. The methods have also been used in mechanical geometry theorem proving [16, 17, 15, 26].
Reference: [10] <author> A. Bundy and R. Welham. </author> <title> Using Meta-level Inference for Selective Application of Multiple Rewrite Rule Sets in Algebraic Manipulation. </title> <journal> Artificial Intelligence, </journal> <volume> 16 </volume> <pages> 189-212, </pages> <year> 1981. </year>
Reference-contexts: A detailed description of a complete set of rules for 2D design can be found in [55], where the scope of the rules is also characterized. Finally, a technique called Meta-level Inference is introduced in <ref> [10] </ref>. The paper claims that this technique, combined with multiple sets of rules and their selective application, reduces the search space. The method has been applied in PRESS [10], a program for algebraic manipulation. 2.2.2 Graph-Constructive Solvers Another version of the constructive approach has two phases. <p> Finally, a technique called Meta-level Inference is introduced in <ref> [10] </ref>. The paper claims that this technique, combined with multiple sets of rules and their selective application, reduces the search space. The method has been applied in PRESS [10], a program for algebraic manipulation. 2.2.2 Graph-Constructive Solvers Another version of the constructive approach has two phases. During the first phase, the graph of constraints is analyzed and a sequence of construction steps is derived. During the second phase, the construction steps are carried out to derive the solution.
Reference: [11] <author> J. Cai. </author> <title> A language for semantic analysis. </title> <type> Technical Report 635, </type> <institution> New York University, Dept. of Comp. Science, </institution> <year> 1993. </year>
Reference-contexts: Although only a prototype implementation of APTS is currently available, the inference and rewriting engines used to compute and maintain semantic relations involve the use of such highly efficient algorithms that the observed performance is reasonable <ref> [11] </ref>. In contrast to Refine, implemented in Common Lisp, APTS is portable to a wide variety of machines and operating systems and, in particular, to any UNIX platform. 11 4 Solver Algorithmics and Extensibility First, we discuss our basic method for solving geometric constraints.
Reference: [12] <author> J. Cai, P. Facon, F. Henglein, R. Paige, and E. Schonberg. </author> <title> Type transformation and data structure choice. </title> <editor> In B. Moeller, editor, </editor> <booktitle> Constructing Programs From Specifications, </booktitle> <pages> pages 126-124. </pages> <publisher> North-Holland, </publisher> <year> 1991. </year>
Reference-contexts: Aside from well-known special purpose tools such as LEX and Yacc [25], our constraint solver also makes use of the high level language SETL2 [45] to specify complex combinatorial algorithms and the transformational system APTS <ref> [12] </ref> to perform syntactic analysis and symbolic manipulation of geometrical constraint specifications. 3. <p> The user is also expected to supply initial constraints between these geometric elements. This initial design is turned into an Erep specification and is passed as text to the constraint solver. The solver is written using two novel software tools | the APTS transformational programming system <ref> [12] </ref> and the high-level language SETL2 [45] | each having special features that the solver exploits. The front-end to the constraint solver engine is an APTS program that reads the Erep program and type checks it. For example, we check that only lines participate in angle constraints. <p> The special syntactic, semantic, and transformational capabilities of APTS <ref> [12] </ref> are well suited to a flexible, experimental development of a logical framework with an evolving Erep language and corresponding solver. Like systems such as Centaur [4] the Synthesizer Generator [42], and Refine [41], APTS has a single uniform formalism for lexical analysis, syntactic analysis, and pretty-printing.
Reference: [13] <author> J. Cai and R. Paige. </author> <title> Towards increased productivity of algorithm implementation. </title> <journal> ACM SIGSOFT, </journal> <note> to appear, </note> <year> 1993. </year>
Reference-contexts: Using SETL2 has allowed us to implement our algorithms with surprising speed. In the future we also hope to make use of a promising new technology, just now being reported, for mechanically transforming prototype SETL2 programs into high performance C code <ref> [13] </ref>. Another major part of our research develops a logical framework for specifying and solving 2-dimensional geometric constraints. The Erep language provides a formal syntax and semantics essential to problem specification and problem solving. We seek a rich language of geometries and constraints for conveniently describing two-dimensional drawings.
Reference: [14] <author> C.-S. Chou. </author> <title> Mechanical Theorem Proving. </title> <address> D. </address> <publisher> Reidel Publishing, </publisher> <address> Dordrecht, </address> <year> 1987. </year>
Reference-contexts: For example, the symbolic computation community has considered the general problem, in the context of automatically deriving and proving theorems from analytic geometry, and applying these techniques to vision problems <ref> [9, 14, 26, 27] </ref>. The geometric modeling community has considered the problem for the purpose of developing sketching systems in which a rough sketch, annotated with dimension and constraints, is instantiated to satisfy all constraints. This work will be reviewed in the next section. <p> The system is solved with symbolic algebraic methods, such as Grobner's bases, e.g., [9], or the Wu-Ritt method <ref> [57, 14] </ref>. Both methods can solve general nonlinear systems of algebraic equations. The methods have also been used in mechanical geometry theorem proving [16, 17, 15, 26].
Reference: [15] <author> C.-S. Chou. </author> <title> A Method for the Mechanical Derivation of Formulas in Elementary Geometry. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 3 </volume> <pages> 291-299, </pages> <year> 1987. </year>
Reference-contexts: The system is solved with symbolic algebraic methods, such as Grobner's bases, e.g., [9], or the Wu-Ritt method [57, 14]. Both methods can solve general nonlinear systems of algebraic equations. The methods have also been used in mechanical geometry theorem proving <ref> [16, 17, 15, 26] </ref>.
Reference: [16] <author> C.-S. Chou. </author> <title> An Introduction to Wu's Method for Mechanical Theorem Proving in Geometry. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 4 </volume> <pages> 237-267, </pages> <year> 1988. </year>
Reference-contexts: The system is solved with symbolic algebraic methods, such as Grobner's bases, e.g., [9], or the Wu-Ritt method [57, 14]. Both methods can solve general nonlinear systems of algebraic equations. The methods have also been used in mechanical geometry theorem proving <ref> [16, 17, 15, 26] </ref>.
Reference: [17] <author> C.-S. Chou and W. Schelter. </author> <title> Proving Geometry Theorems with Rewrite Rules. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 2 </volume> <pages> 253-273, </pages> <year> 1986. </year> <month> 35 </month>
Reference-contexts: The system is solved with symbolic algebraic methods, such as Grobner's bases, e.g., [9], or the Wu-Ritt method [57, 14]. Both methods can solve general nonlinear systems of algebraic equations. The methods have also been used in mechanical geometry theorem proving <ref> [16, 17, 15, 26] </ref>.
Reference: [18] <author> W. Clocksin and C. Mellish. </author> <title> Programming in Prolog. </title> <publisher> Springer Verlag, </publisher> <year> 1981. </year>
Reference-contexts: APTS uses a logic-based approach to semantics in which semantic rules that define relations are written in a Datalog-like language [54, 39] but with the full expressive power of Prolog <ref> [18] </ref>. These rules are written independently of the individual grammar productions and without reference to the parse tree structure. They define relations over a rich assortment of primitive and constructed domains, and have the brevity and convenience of unrestricted circular attribute grammars.
Reference: [19] <institution> D-Cubed Ltd, </institution> <address> 68 Castle Street, Cambridge, CB3 0AJ, England. </address> <booktitle> The Dimensional Constraint Manager, </booktitle> <month> May </month> <year> 1993. </year> <note> Version 2.5. </note>
Reference-contexts: Only horizontal and vertical distances are allowed in this method and so the applicability of the method is limited. Todd in [53] generalized the dimension 5 trees of Requicha. Owen in [38] presents an extension of this principle to include circularly dimensioned sketches, and DCM <ref> [19] </ref> is a commercial constraint solver using this method. Since our basic algorithm is based on many of the ideas of [38], we describe Owen's solvers in more detail. The constraint solver described in [38] is a graph-constructive solver in which the constraint graph is analyzed for triconnected components. <p> Algebraically, this is equivalent to solving only quadratic equations, so that the specific coordinate computations do not require sophisticated mathematical computations. In [38] a proof is given that the solver is complete for ruler-and-compass constructible point configurations with prescribed distances that are algebraically independent. DCM <ref> [19] </ref> shares with the algorithm of [38] the characteristic that it begins by determining the interaction of geometric element groupings before filling in the individual elements in each group. <p> Furthermore, since the length of segments and arcs often implicitly depends on the final placement, it is not clear whether the user can reasonably be expected to understand the effect of moving geometries. In DCM <ref> [19, 38] </ref>, a move instruction relocates a geometric element. Thereupon, the solution can be recomputed, and other elements can be moved. it appears that the solver uses the new position coordinates when applying the normal placement heuristics selecting a solution. We found the move instruction difficult.
Reference: [20] <author> W. Fitzgerald. </author> <title> Using Axial Dimensions to Determine the Proportions of Line Drawings in Computer Graphics. </title> <booktitle> Computer Aided Design, </booktitle> <volume> 13(6) </volume> <pages> 377-382, </pages> <month> November </month> <year> 1981. </year>
Reference-contexts: We call this approach graph-constructive solving. It is fast, more methodical than the rule-constructive approach, and is proved to be sound. However, as the repertoire of possible constraints increases, the graph-analysis algorithm has to be modified. Fitzgerald <ref> [20] </ref> follows the approach of dimensioned trees by Requicha [43]. Only horizontal and vertical distances are allowed in this method and so the applicability of the method is limited. Todd in [53] generalized the dimension 5 trees of Requicha.
Reference: [21] <author> B. Freeman-Benson, J. Maloney, and A. Borning. </author> <title> An Incremental Constraint Solver. </title> <journal> CACM, </journal> <volume> 33(1) </volume> <pages> 54-63, </pages> <year> 1990. </year>
Reference-contexts: In essence, augmented term rewriting is a graph transformation mechanism using term rewriting rules. Additionally, assignments are supported, as is variable typing, and these additions make augmented term rewriting more expressive than the term rewriting mechanism of pure PROLOG. ThingLab uses the Blue and Delta Blue algorithms described in <ref> [3, 21] </ref>, that are based on a local propagation of degrees of freedom within the constraint graph. Magritte [22] employs propagation to transform the undirected constraint graph, and then uses breadth-first search to derive all solutions. 2.4 Symbolic Constraint Solvers The constraints are transformed into a system of algebraic equations.
Reference: [22] <author> J. Gosling. </author> <title> Algebraic Constraints. </title> <type> Technical Report CMU-CS-83-132, CMU, </type> <year> 1983. </year>
Reference-contexts: Sketchpad [51] was the first system to use the method of numerical relaxation. Relaxation is slow but quite general. Many systems like ThingLab [3] and Magritte <ref> [22] </ref> can do relaxation as an alternative to some other method. In [2] a projection method is presented for finding a new solution that minimizes the Euclidean distance between the old and the new solution. <p> ThingLab uses the Blue and Delta Blue algorithms described in [3, 21], that are based on a local propagation of degrees of freedom within the constraint graph. Magritte <ref> [22] </ref> employs propagation to transform the undirected constraint graph, and then uses breadth-first search to derive all solutions. 2.4 Symbolic Constraint Solvers The constraints are transformed into a system of algebraic equations.
Reference: [23] <author> C. M. Hoffmann. </author> <title> On the semantics of generative geometry representations. </title> <booktitle> In 19th ASME Design Automation Conference, </booktitle> <year> 1993. </year>
Reference-contexts: Such a representation becomes the basis for archiving sketches in a neutral format, with the ability to retrieve the archived sketch and edit it | possibly in a different system with a different solver <ref> [24, 23] </ref>. Our solution is also a building block for a larger project of developing a new generation of CAD systems based on a neutral, high-level geometry representation that expresses design intent and preserves the ability to redesign. 2. <p> Instead, we have developed a paradigm for finding the right solution by using the solver interactively when its automatic heuristics are insufficient. Our system will be a component of a constraint-driven variational CAD system based on a high-level, declarative, editable geometry representation (Erep) as discussed in <ref> [24, 23] </ref>. Such an overall architecture poses several challenges. One of them is efficient variational constraint solving, and we address this problem here. Another, key challenge is to formulate the language in a neutral way, committing it neither to the particulars of the user interface nor of the solver algorithms. <p> In constraint-based, feature-based design, it is common to have available a variational constraint solver for 2D constraint problems, but not for 3D geometric constraints. This is particularly apparent in the persistent id problem discussed in <ref> [23] </ref>. A well-conceived 3D constraint solver conceivably can avoid these problems and assist in devising graphical techniques for generic design. In manufacturing applications one is interested in functional relationships between dimension variables, because such relationships can express design intent very flexibly.
Reference: [24] <author> C. M. Hoffmann and R. Juan. Erep, </author> <title> a editable, high-level representation for geometric design and analysis. </title> <editor> In P. Wilson, M. Wozny, and M. Pratt, editors, </editor> <title> Geometric and Product Modeling. </title> <publisher> North Holland, </publisher> <year> 1993. </year>
Reference-contexts: Such a representation becomes the basis for archiving sketches in a neutral format, with the ability to retrieve the archived sketch and edit it | possibly in a different system with a different solver <ref> [24, 23] </ref>. Our solution is also a building block for a larger project of developing a new generation of CAD systems based on a neutral, high-level geometry representation that expresses design intent and preserves the ability to redesign. 2. <p> Although the user could edit this textual problem specification, this is unnecessary, because the specification is edited and updated automatically from the visual gestures by the user interface. The language has been designed to achieve the objectives of <ref> [24] </ref> | a neutral problem specification that makes no assumptions about the architecture of the underlying constraint solving algorithm. Thus, it is quite easy to federate Owen's solver [38], or any other constraint solver capable of handling the geometric configurations we consider. <p> Instead, we have developed a paradigm for finding the right solution by using the solver interactively when its automatic heuristics are insufficient. Our system will be a component of a constraint-driven variational CAD system based on a high-level, declarative, editable geometry representation (Erep) as discussed in <ref> [24, 23] </ref>. Such an overall architecture poses several challenges. One of them is efficient variational constraint solving, and we address this problem here. Another, key challenge is to formulate the language in a neutral way, committing it neither to the particulars of the user interface nor of the solver algorithms. <p> Where editable design has been archived, it has been done in a proprietary format native to the particular CAD system, and is typically a record of the internal data structures of the CAD system. In <ref> [24] </ref> we have presented alternatives. Current trends in data exchange standards indicate a growing interest in archiving constraint-based designs in which this additional information has been formalized without commitment to a particular CAD system.
Reference: [25] <author> S. Johnson. </author> <title> Yacc yet another compiler compiler. </title> <type> Technical Report Computer Science Report 32, </type> <institution> AT&T Bell Laboratories, </institution> <address> Murray Hill, N.J., </address> <year> 1975. </year>
Reference-contexts: We explore the utility of several different general-purpose and interoperat-ing rapid prototyping languages and systems for developing specific tools for experimenting conveniently with a variety of ideas and approaches to constraint solving. Aside from well-known special purpose tools such as LEX and Yacc <ref> [25] </ref>, our constraint solver also makes use of the high level language SETL2 [45] to specify complex combinatorial algorithms and the transformational system APTS [12] to perform syntactic analysis and symbolic manipulation of geometrical constraint specifications. 3.
Reference: [26] <author> D. Kapur. </author> <title> A refutational approach to geometry theorem proving. </title> <editor> In D. Kapur and J. Mundy, editors, </editor> <booktitle> Geometric Reasoning, </booktitle> <pages> pages 61-93. </pages> <publisher> M.I.T. Press, </publisher> <year> 1989. </year>
Reference-contexts: For example, the symbolic computation community has considered the general problem, in the context of automatically deriving and proving theorems from analytic geometry, and applying these techniques to vision problems <ref> [9, 14, 26, 27] </ref>. The geometric modeling community has considered the problem for the purpose of developing sketching systems in which a rough sketch, annotated with dimension and constraints, is instantiated to satisfy all constraints. This work will be reviewed in the next section. <p> The system is solved with symbolic algebraic methods, such as Grobner's bases, e.g., [9], or the Wu-Ritt method [57, 14]. Both methods can solve general nonlinear systems of algebraic equations. The methods have also been used in mechanical geometry theorem proving <ref> [16, 17, 15, 26] </ref>.
Reference: [27] <author> D. Kapur and J. Mundy. </author> <title> Wu's method and its applications to perspective viewing. </title> <editor> In D. Kapur and J. Mundy, editors, </editor> <booktitle> Geometric Reasoning, </booktitle> <pages> pages 15-36. </pages> <publisher> M.I.T. Press, </publisher> <year> 1988. </year>
Reference-contexts: For example, the symbolic computation community has considered the general problem, in the context of automatically deriving and proving theorems from analytic geometry, and applying these techniques to vision problems <ref> [9, 14, 26, 27] </ref>. The geometric modeling community has considered the problem for the purpose of developing sketching systems in which a rough sketch, annotated with dimension and constraints, is instantiated to satisfy all constraints. This work will be reviewed in the next section.
Reference: [28] <author> D. Knuth. </author> <title> Semantics of context-free languages. </title> <journal> Mathematical Systems Theory, </journal> <volume> 2 </volume> <pages> 127-145, </pages> <year> 1968. </year>
Reference-contexts: Like systems such as Centaur [4] the Synthesizer Generator [42], and Refine [41], APTS has a single uniform formalism for lexical analysis, syntactic analysis, and pretty-printing. However, the semantic formalism in APTS has several advantages over the more conventional attribute grammar approach <ref> [28] </ref> that is used in the Synthesizer Generator. APTS uses a logic-based approach to semantics in which semantic rules that define relations are written in a Datalog-like language [54, 39] but with the full expressive power of Prolog [18].
Reference: [29] <author> D. Knuth and P. Bendix. </author> <title> Simple word problems in universal algebras. </title> <editor> In J. Leech, editor, </editor> <booktitle> Computational Problems in Abstract Algebra, </booktitle> <pages> pages 263-297. </pages> <publisher> Pergammon Press, Oxford, </publisher> <year> 1970. </year>
Reference-contexts: We call this approach rule-constructive solving. Although a Logic Programming style of programming is a good approach for prototyping and experimentation, the extensive computations searching and matching rewrite rules constitute a liability. Bruderlin and Sohrt [6, 46] solve constraints in this way and incorporate the Knuth-Bendix critical-pairs algorithm <ref> [29] </ref>. They show that their method is correct and solves all problems that can be constructed using ruler and compass. The method can also be proved to confirm geometric theorems that are provable in their system of axioms. Bruderlin and Sohrt have implemented an experimental constraint solving system in Prolog. <p> DCM can solve the configuration sometimes, depending on the way the problem is posed. We suspect that a complete ruler-and-compass constructible solver for the larger class of geometric elements requires graph rewriting rules that are equivalent to the Knuth-Bendix algorithm <ref> [29] </ref>. We also discuss a general method for extending the solver to configurations that cannot be done with the basic algorithm. Our strategy places two clusters related by three constraints. The extension goes beyond ruler-and-compass constructions, and requires a root finder for univariate polynomials.
Reference: [30] <author> K. Kondo. PIGMOD: </author> <title> parametric and interactive geometric modeller for mechanical design. </title> <booktitle> Computer Aided Design, </booktitle> <volume> 22(10) </volume> <pages> 633-644, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: The system is solved with symbolic algebraic methods, such as Grobner's bases, e.g., [9], or the Wu-Ritt method [57, 14]. Both methods can solve general nonlinear systems of algebraic equations. The methods have also been used in mechanical geometry theorem proving [16, 17, 15, 26]. In <ref> [30, 31] </ref>, Kondo considers the addition and deletion of constraints by using the Buchberger's Algorithm [7, 8] to derive a polynomial that gives the 7 relationship between the deleted and added constraints. 2.5 Hybrid Solvers Often, constraint solving systems use a combination of the above methods.
Reference: [31] <author> K. Kondo. </author> <title> Algebraic method for manipulation of dimensional relationships in geometric models. </title> <booktitle> Computer Aided Design, </booktitle> <volume> 24(3) </volume> <pages> 141-147, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: The system is solved with symbolic algebraic methods, such as Grobner's bases, e.g., [9], or the Wu-Ritt method [57, 14]. Both methods can solve general nonlinear systems of algebraic equations. The methods have also been used in mechanical geometry theorem proving [16, 17, 15, 26]. In <ref> [30, 31] </ref>, Kondo considers the addition and deletion of constraints by using the Buchberger's Algorithm [7, 8] to derive a polynomial that gives the 7 relationship between the deleted and added constraints. 2.5 Hybrid Solvers Often, constraint solving systems use a combination of the above methods.
Reference: [32] <author> G. Kramer. </author> <title> Solving Geometric Constraint Systems. </title> <publisher> MIT Press, </publisher> <year> 1992. </year> <month> 36 </month>
Reference-contexts: In addition, we infer that the commercial version has a significant number of additional rules and transformations that can be applied to the constraint graph in order to extend the scope of the basic algorithm. In many cases, the graph reduction requires linear time only. Kramer <ref> [32] </ref> uses a similar approach. However, instead of determining the equations of the geometric elements at each construction step, Kramer determines coordinate transformations that successively place points and associated coordinate frames relative to each other subject to constraints.
Reference: [33] <author> W. Leler. </author> <title> Constraint Programming Languages: Their Specification and Generation. </title> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference-contexts: The method then attempts to direct 6 the graph edges so that every equation can be solved in turn, initially only from the constants. To succeed, various propagation techniques have been tried, but none of them is guaranteed to derive a solution when one exists. For a review see <ref> [33, 46] </ref>. Sketchpad [51] uses propagation of degrees of freedom and propagation of known values. Pro/ENGINEER [5, 40] uses propagation of known values. Propagation of known values is the inverse process of the propagation of degrees of freedom. <p> In general, retraction is faster but less powerful than propagation of known values. Graph transformation is sometimes used in conjunction with some propagation method. In pure graph transformation, some subgraphs of the constraint graph are identified and are replaced by simpler subgraphs. Bertrand, described in <ref> [33] </ref>, is a general-purpose constraint specification language, and is implemented using a propagation method in conjunction with an inference mechanism. Leler calls this technique augmented term rewriting. In essence, augmented term rewriting is a graph transformation mechanism using term rewriting rules.
Reference: [34] <author> J. Li. </author> <title> Using algebraic constraints in interactive text and graphics editing. </title> <editor> In D. A. Duce and P. Jancene, editors, </editor> <volume> Eurographics '88, </volume> <pages> pages 197-205. </pages> <publisher> Elsevier North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: Both methods are global, unstable, and do not work for cyclically dimensioned sketches. CONSTRAINTS [48] uses retraction, which is a localized version of propagation of known values that stores information about each variable's interdependencies. A similar technique is used in <ref> [34] </ref>: First, known values are propagated locally. Then, the remaining simultaneous constraints are solved if they form a linear system of equations. In general, retraction is faster but less powerful than propagation of known values. Graph transformation is sometimes used in conjunction with some propagation method.
Reference: [35] <author> R. Light and D. Gossard. </author> <title> Modification of geometric models through variational geometry. </title> <booktitle> Computer Aided Design, </booktitle> <volume> 14 </volume> <pages> 209-214, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: Juno [37] uses the original sketch as initial state. The CPSM system of Solano and Brunet [47] also uses a numerical solver that first deals with sequential constraints and then solves circularly interdependent constraints. A modification of Newton-Raphson was developed in <ref> [35] </ref>, where an improved way for finding the inverse Jacobi matrix is presented. Furthermore, the paper proposes dividing the constraint matrix into submatrices, with the potential of providing the user with information about the constraint structure of the sketch.
Reference: [36] <author> E. H. Lockwood. </author> <title> A Book of Curves. </title> <publisher> Cambridge University Press, </publisher> <year> 1961. </year>
Reference-contexts: Particularly in the case of point loci, classical curves are obtained that are described in the literature; see, e.g., <ref> [36] </ref>, or the literature on plane kinematics. The curve of subcase 2 above, with d 2 = 0, is a conchoid of a line. In Figure 15 a segment end is constrained to a circle and the segment incident to a fixed perimeter point C.
Reference: [37] <author> G. Nelson. Juno, </author> <title> a costraint-based graphics system. </title> <booktitle> In SIGGRAPH, </booktitle> <pages> pages 235-243, </pages> <address> San Francisco, </address> <month> July 22-26 </month> <year> 1985. </year> <note> ACM. </note>
Reference-contexts: Newton-Raphson iteration has been used in a number of systems, and is faster than relaxation, but it may converge to the wrong solution. Unfortunately, when this happens, the user has no recourse to instruct the solver to find alternatives. Juno <ref> [37] </ref> uses the original sketch as initial state. The CPSM system of Solano and Brunet [47] also uses a numerical solver that first deals with sequential constraints and then solves circularly interdependent constraints.
Reference: [38] <author> J. Owen. </author> <title> Algebraic solution for geometry from dimensional constraints. </title> <booktitle> In ACM Symp. Found. of Solid Modeling, </booktitle> <pages> pages 397-407, </pages> <address> Austin, Tex, </address> <year> 1991. </year>
Reference-contexts: Fitzgerald [20] follows the approach of dimensioned trees by Requicha [43]. Only horizontal and vertical distances are allowed in this method and so the applicability of the method is limited. Todd in [53] generalized the dimension 5 trees of Requicha. Owen in <ref> [38] </ref> presents an extension of this principle to include circularly dimensioned sketches, and DCM [19] is a commercial constraint solver using this method. Since our basic algorithm is based on many of the ideas of [38], we describe Owen's solvers in more detail. The constraint solver described in [38] is a <p> Todd in [53] generalized the dimension 5 trees of Requicha. Owen in <ref> [38] </ref> presents an extension of this principle to include circularly dimensioned sketches, and DCM [19] is a commercial constraint solver using this method. Since our basic algorithm is based on many of the ideas of [38], we describe Owen's solvers in more detail. The constraint solver described in [38] is a graph-constructive solver in which the constraint graph is analyzed for triconnected components. <p> Owen in <ref> [38] </ref> presents an extension of this principle to include circularly dimensioned sketches, and DCM [19] is a commercial constraint solver using this method. Since our basic algorithm is based on many of the ideas of [38], we describe Owen's solvers in more detail. The constraint solver described in [38] is a graph-constructive solver in which the constraint graph is analyzed for triconnected components. Each triconnected component is reduced to a number of elements that interact with other components, and a determination is made how the various geometric elements whose nodes are in each graph component fit together. <p> A key aspect of the solver is that only constraint configurations are considered that can be solved using ruler-and-compass construction steps. Algebraically, this is equivalent to solving only quadratic equations, so that the specific coordinate computations do not require sophisticated mathematical computations. In <ref> [38] </ref> a proof is given that the solver is complete for ruler-and-compass constructible point configurations with prescribed distances that are algebraically independent. DCM [19] shares with the algorithm of [38] the characteristic that it begins by determining the interaction of geometric element groupings before filling in the individual elements in each <p> In <ref> [38] </ref> a proof is given that the solver is complete for ruler-and-compass constructible point configurations with prescribed distances that are algebraically independent. DCM [19] shares with the algorithm of [38] the characteristic that it begins by determining the interaction of geometric element groupings before filling in the individual elements in each group. <p> The language has been designed to achieve the objectives of [24] | a neutral problem specification that makes no assumptions about the architecture of the underlying constraint solving algorithm. Thus, it is quite easy to federate Owen's solver <ref> [38] </ref>, or any other constraint solver capable of handling the geometric configurations we consider. <p> The solver could be extended arbitrarily further, in an analogous manner, but at some point the number of construction steps becomes too large, and selecting which one to apply begins to interfere with the speed of the solver. 4.1 Solving with Graph Reduction As sketched in <ref> [38] </ref>, we first translate the constraint problem into a constraint graph. Specific graph reduction steps are applied that correspond to geometric construction steps with ruler and compass, and derive clusters of geometric elements that are correctly placed with respect to each other. <p> Furthermore, since the length of segments and arcs often implicitly depends on the final placement, it is not clear whether the user can reasonably be expected to understand the effect of moving geometries. In DCM <ref> [19, 38] </ref>, a move instruction relocates a geometric element. Thereupon, the solution can be recomputed, and other elements can be moved. it appears that the solver uses the new position coordinates when applying the normal placement heuristics selecting a solution. We found the move instruction difficult.
Reference: [39] <author> R. Paige. </author> <title> Apts external specification manual. internal documentation, </title> <year> 1993. </year>
Reference-contexts: However, the semantic formalism in APTS has several advantages over the more conventional attribute grammar approach [28] that is used in the Synthesizer Generator. APTS uses a logic-based approach to semantics in which semantic rules that define relations are written in a Datalog-like language <ref> [54, 39] </ref> but with the full expressive power of Prolog [18]. These rules are written independently of the individual grammar productions and without reference to the parse tree structure.
Reference: [40] <author> Pro/ENGINEER. </author> <title> Modeling Users Guide: 2D Sketcher. Parametric Technologies. Release 8.0. </title>
Reference-contexts: To succeed, various propagation techniques have been tried, but none of them is guaranteed to derive a solution when one exists. For a review see [33, 46]. Sketchpad [51] uses propagation of degrees of freedom and propagation of known values. Pro/ENGINEER <ref> [5, 40] </ref> uses propagation of known values. Propagation of known values is the inverse process of the propagation of degrees of freedom. Propagation of degrees of freedom is a more abstract method that essentially does a graph reduction.
Reference: [41] <institution> Reasoning Systems. </institution> <note> Refine User's Guide, 1990. Version 3.0. </note>
Reference-contexts: The special syntactic, semantic, and transformational capabilities of APTS [12] are well suited to a flexible, experimental development of a logical framework with an evolving Erep language and corresponding solver. Like systems such as Centaur [4] the Synthesizer Generator [42], and Refine <ref> [41] </ref>, APTS has a single uniform formalism for lexical analysis, syntactic analysis, and pretty-printing. However, the semantic formalism in APTS has several advantages over the more conventional attribute grammar approach [28] that is used in the Synthesizer Generator. <p> We are not aware of any implementation that allows a comparable unrestricted circularity. The semantic formalism in APTS is also integrated with a conditional rewriting component that is lacking in both the Synthesizer Generator [42] and Centaur [4], and is more abstract and user/friendly than Refine <ref> [41] </ref>. Although only a prototype implementation of APTS is currently available, the inference and rewriting engines used to compute and maintain semantic relations involve the use of such highly efficient algorithms that the observed performance is reasonable [11].
Reference: [42] <author> T. Reps and T. Teitelbaum. </author> <title> The Synthsizer Generator. </title> <publisher> Springer Verlag, </publisher> <year> 1988. </year>
Reference-contexts: The special syntactic, semantic, and transformational capabilities of APTS [12] are well suited to a flexible, experimental development of a logical framework with an evolving Erep language and corresponding solver. Like systems such as Centaur [4] the Synthesizer Generator <ref> [42] </ref>, and Refine [41], APTS has a single uniform formalism for lexical analysis, syntactic analysis, and pretty-printing. However, the semantic formalism in APTS has several advantages over the more conventional attribute grammar approach [28] that is used in the Synthesizer Generator. <p> We are not aware of any implementation that allows a comparable unrestricted circularity. The semantic formalism in APTS is also integrated with a conditional rewriting component that is lacking in both the Synthesizer Generator <ref> [42] </ref> and Centaur [4], and is more abstract and user/friendly than Refine [41]. Although only a prototype implementation of APTS is currently available, the inference and rewriting engines used to compute and maintain semantic relations involve the use of such highly efficient algorithms that the observed performance is reasonable [11].
Reference: [43] <author> A. Requicha. Dimensionining and tolerancing. </author> <type> Technical report, </type> <institution> Production Automation Project, University of Rochester, </institution> <month> May </month> <year> 1977. </year> <note> PADL TM-19. </note>
Reference-contexts: We call this approach graph-constructive solving. It is fast, more methodical than the rule-constructive approach, and is proved to be sound. However, as the repertoire of possible constraints increases, the graph-analysis algorithm has to be modified. Fitzgerald [20] follows the approach of dimensioned trees by Requicha <ref> [43] </ref>. Only horizontal and vertical distances are allowed in this method and so the applicability of the method is limited. Todd in [53] generalized the dimension 5 trees of Requicha.
Reference: [44] <author> J. Schwartz, R. Dewar, D. Dubinsky, and E. Schonberg. </author> <title> Programming with Sets: An introduction to SETL. </title> <publisher> Springer Verlag, </publisher> <year> 1986. </year>
Reference-contexts: A wide variety of heuristics seem available to us, but a proper evaluation requires extensive labor-intensive computational experiments. The ease with which complex combinatorial algorithms can be implemented and modified in the SETL language <ref> [44] </ref> is well known. Snyder's new SETL2 language [45] significantly improves SETL in regard to its convenience in algorithm specification, its compile- and run-time reliability and performance, and its portability.
Reference: [45] <author> K. Snyder. </author> <title> The SETL2 programming language. </title> <type> Technical report, </type> <institution> New York University, Computer Science, Courant Institute, </institution> <year> 1990. </year>
Reference-contexts: Aside from well-known special purpose tools such as LEX and Yacc [25], our constraint solver also makes use of the high level language SETL2 <ref> [45] </ref> to specify complex combinatorial algorithms and the transformational system APTS [12] to perform syntactic analysis and symbolic manipulation of geometrical constraint specifications. 3. <p> This initial design is turned into an Erep specification and is passed as text to the constraint solver. The solver is written using two novel software tools | the APTS transformational programming system [12] and the high-level language SETL2 <ref> [45] </ref> | each having special features that the solver exploits. The front-end to the constraint solver engine is an APTS program that reads the Erep program and type checks it. For example, we check that only lines participate in angle constraints. <p> A wide variety of heuristics seem available to us, but a proper evaluation requires extensive labor-intensive computational experiments. The ease with which complex combinatorial algorithms can be implemented and modified in the SETL language [44] is well known. Snyder's new SETL2 language <ref> [45] </ref> significantly improves SETL in regard to its convenience in algorithm specification, its compile- and run-time reliability and performance, and its portability.
Reference: [46] <author> W. Sohrt. </author> <title> Interaction with Constraints in three-dimensional Modeling. </title> <type> Master's thesis, </type> <institution> Dept of Computer Science, The University of Utah, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: We call this approach rule-constructive solving. Although a Logic Programming style of programming is a good approach for prototyping and experimentation, the extensive computations searching and matching rewrite rules constitute a liability. Bruderlin and Sohrt <ref> [6, 46] </ref> solve constraints in this way and incorporate the Knuth-Bendix critical-pairs algorithm [29]. They show that their method is correct and solves all problems that can be constructed using ruler and compass. <p> The method then attempts to direct 6 the graph edges so that every equation can be solved in turn, initially only from the constants. To succeed, various propagation techniques have been tried, but none of them is guaranteed to derive a solution when one exists. For a review see <ref> [33, 46] </ref>. Sketchpad [51] uses propagation of degrees of freedom and propagation of known values. Pro/ENGINEER [5, 40] uses propagation of known values. Propagation of known values is the inverse process of the propagation of degrees of freedom.
Reference: [47] <author> L. Solano and P. Brunet. </author> <title> A system for constructive constraint-based modeling. </title> <editor> In B. Falcidieno and T. Kunii, editors, </editor> <booktitle> Modeling in Computer Graphics. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Unfortunately, when this happens, the user has no recourse to instruct the solver to find alternatives. Juno [37] uses the original sketch as initial state. The CPSM system of Solano and Brunet <ref> [47] </ref> also uses a numerical solver that first deals with sequential constraints and then solves circularly interdependent constraints. A modification of Newton-Raphson was developed in [35], where an improved way for finding the inverse Jacobi matrix is presented.
Reference: [48] <author> G. L. Steele and G. L. Sussman. </author> <title> CONSTRAINTS A Language for Expressing Almost-Hierarchical Descriptions. </title> <booktitle> Artificial Intelligence, </booktitle> <pages> pages 1-39, </pages> <month> January </month> <year> 1980. </year> <month> 37 </month>
Reference-contexts: In the propagation of known values, we can account for special values and therefore make the method slightly more powerful than pure propagation of degrees of freedom. Both methods are global, unstable, and do not work for cyclically dimensioned sketches. CONSTRAINTS <ref> [48] </ref> uses retraction, which is a localized version of propagation of known values that stores information about each variable's interdependencies. A similar technique is used in [34]: First, known values are propagated locally. Then, the remaining simultaneous constraints are solved if they form a linear system of equations.
Reference: [49] <author> B. Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Read--ing, MA, </address> <year> 1991. </year>
Reference-contexts: The textual protocol for communicating these matters is encapsulated. 9 3.2 System Implementation The two-dimensional geometrical design system has two main components, a graphical interface and a constraint solver engine. The graphical interface is a C++ program <ref> [49] </ref> that interacts with X Windows in order to allow the user to sketch a drawing using labeled points, lines, circles, etc. The user is also expected to supply initial constraints between these geometric elements.
Reference: [50] <author> G. Sunde. </author> <title> Specification of shape by dimensions and other geometric constraints. </title> <editor> In M. J. Wozny, H. W. McLaughlin, and J. L. Encarnacao, editors, </editor> <booktitle> Geometric Modeling for CAD Applications, </booktitle> <pages> pages 199-213. </pages> <publisher> North Holland, IFIP, </publisher> <year> 1988. </year>
Reference-contexts: Aldefeld [1] uses a forward chaining inference mechanism. He assumes that lines are directed, and formulates additional rules that restrict the number of possible solutions. A similar method is presented in [52], where handling of over-constrained and underconstrained cases is given special consideration. Sunde in <ref> [50] </ref> also uses a rule-constructive method but has different rules for representing directed distance and undirected distance, thus adding flexibility for dealing with the root identification problem discussed in Section 5. In [58] the problem of nonunique solutions is handled by imposing an order on triples of geometric elements.
Reference: [51] <author> I. Sutherland. </author> <title> Sketchpad, a man-machine graphical communication system. </title> <booktitle> In Proc. of the spring Joint Comp. Conference, </booktitle> <pages> pages 329-345. IFIPS, </pages> <year> 1963. </year>
Reference-contexts: Numerical solvers based on Newton iteration are therefore inappropriate when the initial sketch is only topologically correct, or when the solver locks into a solution that is unsuited to the application and has no method with which to find more suitable alternatives. Sketchpad <ref> [51] </ref> was the first system to use the method of numerical relaxation. Relaxation is slow but quite general. Many systems like ThingLab [3] and Magritte [22] can do relaxation as an alternative to some other method. <p> To succeed, various propagation techniques have been tried, but none of them is guaranteed to derive a solution when one exists. For a review see [33, 46]. Sketchpad <ref> [51] </ref> uses propagation of degrees of freedom and propagation of known values. Pro/ENGINEER [5, 40] uses propagation of known values. Propagation of known values is the inverse process of the propagation of degrees of freedom.
Reference: [52] <author> H. Suzuki, H. Ando, and F. Kimura. </author> <title> Variation of geometries based on a geometric-reasoning method. </title> <journal> Comput. & Graphics, </journal> <volume> 14(2) </volume> <pages> 211-224, </pages> <year> 1990. </year>
Reference-contexts: Aldefeld [1] uses a forward chaining inference mechanism. He assumes that lines are directed, and formulates additional rules that restrict the number of possible solutions. A similar method is presented in <ref> [52] </ref>, where handling of over-constrained and underconstrained cases is given special consideration. Sunde in [50] also uses a rule-constructive method but has different rules for representing directed distance and undirected distance, thus adding flexibility for dealing with the root identification problem discussed in Section 5.
Reference: [53] <author> P. Todd. </author> <title> A k-tree generalization that characterizes consistency of dimensioned engineering drawings. </title> <journal> SIAM J. DISC. MATH., </journal> <volume> 2(2) </volume> <pages> 255-261, </pages> <year> 1989. </year>
Reference-contexts: However, as the repertoire of possible constraints increases, the graph-analysis algorithm has to be modified. Fitzgerald [20] follows the approach of dimensioned trees by Requicha [43]. Only horizontal and vertical distances are allowed in this method and so the applicability of the method is limited. Todd in <ref> [53] </ref> generalized the dimension 5 trees of Requicha. Owen in [38] presents an extension of this principle to include circularly dimensioned sketches, and DCM [19] is a commercial constraint solver using this method.
Reference: [54] <author> J. Ullman. </author> <title> Principles of Database and Knowledge-Base Systems. </title> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference-contexts: However, the semantic formalism in APTS has several advantages over the more conventional attribute grammar approach [28] that is used in the Synthesizer Generator. APTS uses a logic-based approach to semantics in which semantic rules that define relations are written in a Datalog-like language <ref> [54, 39] </ref> but with the full expressive power of Prolog [18]. These rules are written independently of the individual grammar productions and without reference to the parse tree structure.
Reference: [55] <author> A. Verroust, F. Schonek, and D. </author> <title> Roller. Rule-oriented method for parameterized computer-aided design. </title> <booktitle> Computer Aided Design, </booktitle> <volume> 24(3) </volume> <pages> 531-540, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: In [58] the problem of nonunique solutions is handled by imposing an order on triples of geometric elements. A detailed description of a complete set of rules for 2D design can be found in <ref> [55] </ref>, where the scope of the rules is also characterized. Finally, a technique called Meta-level Inference is introduced in [10]. The paper claims that this technique, combined with multiple sets of rules and their selective application, reduces the search space.
Reference: [56] <author> A. Witkin, K. Fleischer, and A. Barr. </author> <title> Energy Constraints on Parameterized models. </title> <journal> Computer Graphics, </journal> <volume> 21 </volume> <pages> 225-232, </pages> <year> 1987. </year>
Reference-contexts: Although this information is usually quantitative and not very specific, it may help the user make modifications if the solver fails. A method that represents constraints by an energy function and then searches for a local minimum using the energy gradient is presented in <ref> [56] </ref>. 2.2 Constructive Constraint Solvers This class of constraint solvers is based on the fact that most configurations in an engineering drawing are solvable by ruler, compass and protractor, or using another, less classical repertoire of construction steps.
Reference: [57] <author> Wu Wen-Tsun. </author> <title> Basic principles of mechanical theorem proving in geometries. </title> <journal> J. of Systems Sciences and Mathematical Sciences, </journal> <volume> 4 </volume> <pages> 207-235, </pages> <year> 1986. </year>
Reference-contexts: The system is solved with symbolic algebraic methods, such as Grobner's bases, e.g., [9], or the Wu-Ritt method <ref> [57, 14] </ref>. Both methods can solve general nonlinear systems of algebraic equations. The methods have also been used in mechanical geometry theorem proving [16, 17, 15, 26].
Reference: [58] <author> Y. Yamaguchi and F. Kimura. </author> <title> A constraint modeling system for variational geometry. </title> <editor> In M. J. Wozny, J. U. Turner, and K. Preiss, editors, </editor> <booktitle> Geometric Modeling for Product Engineering, </booktitle> <pages> pages 221-233. </pages> <publisher> Elsevier North Holland, </publisher> <year> 1990. </year>
Reference-contexts: Sunde in [50] also uses a rule-constructive method but has different rules for representing directed distance and undirected distance, thus adding flexibility for dealing with the root identification problem discussed in Section 5. In <ref> [58] </ref> the problem of nonunique solutions is handled by imposing an order on triples of geometric elements. A detailed description of a complete set of rules for 2D design can be found in [55], where the scope of the rules is also characterized.
References-found: 58

