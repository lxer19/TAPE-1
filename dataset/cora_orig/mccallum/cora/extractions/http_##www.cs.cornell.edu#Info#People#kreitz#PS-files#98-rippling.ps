URL: http://www.cs.cornell.edu/Info/People/kreitz/PS-files/98-rippling.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/kreitz/Abstracts/98-rippling.html
Root-URL: 
Email: fpientka,kreitzg@cs.cornell.edu  
Title: Instantiation of Existentially Quantified Variables in Inductive Specification Proofs  
Author: Brigitte Pientka and Christoph Kreitz 
Address: Ithaca, NY 14853-7501, U.S.A.  
Affiliation: Department of Computer Science,Cornell University  
Abstract: We present an automatic approach for instantiating existentially quantified variables in inductive specifications proofs. Our approach uses first-order meta-variables in place of existentially quantified variables and combines logical proof search with rippling techniques. We avoid the non-termination problems which usually occur in the presence of existentially quantified variables. Moreover, we are able to synthesize conditional substitutions for the meta-variables. We illustrate our approach by discussing the specification of the integer square root. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Armando, A. Smaill, and I. Green. </author> <title> Automatic synthesis of recursive programs: The proof-planning paradigm. </title> <booktitle> In Proceedings of the 12th IEEE International Automated Software Engineering Conference, </booktitle> <address> p 2-9. </address> <publisher> IEEE Computer Society, </publisher> <year> 1997. </year>
Reference-contexts: This does not matter if we are just interested in provabil-ity. In program synthesis, however, the identity of the existential witness plays a vital role of defining the program to be synthesized. Other approaches <ref> [1, 10, 16] </ref> use meta-annotations; the existentially quantified variable x is replaced by F (X) where capital letters indicate meta-variables. Middle-out reasoning [9] is used in order to instantiate the function F and its argument X. This problem requires a computationally expensive higher-order unification.
Reference: 2. <author> D. Basin and T. Walsh. </author> <title> A calculus for and termination of rippling. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 16(2) </volume> <pages> 147-180, </pages> <year> 1996. </year>
Reference-contexts: Rippling terminates unsuccessfully if the rewriting process is blocked, i.e. no wave-rule is applicable anymore and the induction hypothesis (given) does not match the induction conclusion (goal). In Basin & Walsh <ref> [2] </ref>, a calculus for rippling is presented and well-founded measure, called wave measure is defined, under which rippling terminates if no meta-variables occur in the goal. The wave measure associates weights to the wave-fronts to measure the width and the size of the wave-front.
Reference: 3. <author> J. L. Bates and R. L. Constable. </author> <title> Proofs as programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(1) </volume> <pages> 113-136, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: A program meeting this specification can be extracted from its proof via the proofs-as-programs principle <ref> [3] </ref>. This style is widely advocated [13] and supported in a number of implementations such as NuPRL [8]. The application of such systems however is limited by its low degree of automation. In order to overcome this drawback, we suggest incorporating techniques from inductive theorem proving.
Reference: 4. <author> W. Bibel, D. Korn, C. Kreitz, F. Kurucz et al.. </author> <title> A multi-level approach to program synthesis. In Logic Program Synthesis and Transformation,Springer, </title> <year> 1998. </year>
Reference-contexts: This process is called reverse rippling. For rippling and reverse rippling we use the rippling-distance strategy <ref> [11, 4] </ref>. Each wave-front is mapped to a selected (goal)-sink. The distance between a wave-front and its assigned (goal) sink in the term tree is called distance measure.
Reference: 5. <author> S. Biundo. </author> <title> Automated synthesis of recursive algorithms as a theorem proving tool. </title> <booktitle> In Proceedings of the 8th ECAI, </booktitle> <year> 1988. </year>
Reference-contexts: These examples span the range of specifications usually considered (see <ref> [5, 10, 16] </ref>) and do not require any case splits. We also can prove the specification for log 2 which results in a similar proof to the integer square root example. Moreover, we used the extended matching procedure to instantiate universally quantified variables in the hypothesis list. <p> Moreover, it supports the strength of our approach. The combination of logical proof search and rippling gives us the flexibility to deal with complex logical formulas. 8 Related Work One of the first approaches to automate the instantiation of existentially quantified variables has been by Biundo <ref> [5] </ref>. Existentially quantified variables are replaced by Skolem functions which describe the program which is to be synthesized. After induction the formula in the step case is put into clausal form. The synthesis proceeds by clause-set translations (e.g. rewriting and case splitting) which induce an AND/OR search space.
Reference: 6. <author> A. Bundy, A. Stevens, F. van Harmelen et al.. Rippling: </author> <title> A heuristic for guiding inductive proofs. </title> <journal> Artificial Intelligence, </journal> <volume> 62(2) </volume> <pages> 185-253, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: Both expressions have to be equal after some rewriting steps. The crucial question is how can we find a chain of rewriting steps, such that both expressions can be made equal by rewriting in the presence of meta-variables. In inductive theorem proving, an annotated rewriting technique, called rippling <ref> [7, 6] </ref>, has been used successfully in order to control the rewriting process. However, only little focus has been devoted to the automatic instantiation of existentially quantified variables. <p> Rewriting is restricted such that each application of a wave-rule is skeleton preserving and measure decreasing according to the defined wave measure. For instantiating existentially quantified variables via rippling, mainly two approaches have been suggested in the literature. In Bundy et al. <ref> [6] </ref> special existential wave-rules are suggested. Existential wave-rules can be derived from non-existential wave-rules.
Reference: 7. <author> A. Bundy, F. van Harmelen, A. Smaill et al.. </author> <title> Extensions to the rippling-out tactic for guiding inductive proofs. </title> <booktitle> In Proceedings of the 10th International CADE, </booktitle> <address> p 132-146. </address> <publisher> LNAI, </publisher> <year> 1990. </year>
Reference-contexts: Both expressions have to be equal after some rewriting steps. The crucial question is how can we find a chain of rewriting steps, such that both expressions can be made equal by rewriting in the presence of meta-variables. In inductive theorem proving, an annotated rewriting technique, called rippling <ref> [7, 6] </ref>, has been used successfully in order to control the rewriting process. However, only little focus has been devoted to the automatic instantiation of existentially quantified variables. <p> In each iteration y is incremented until (y + 1) 2 &gt; x. This example illustrates that the conventional rippling approach <ref> [7] </ref> to instantiate universally quantified variables in the induction hypothesis by rippling-in is not expressive enough. Moreover, it supports the strength of our approach.
Reference: 8. <author> R. L. Constable, S. F. Allen, H. M. Bromley, and et al. </author> <title> Implementing Meta-Mathematics with the NuPRLProof Development System. </title> <publisher> Prentice-Hall, </publisher> <pages> 1086. </pages>
Reference-contexts: A program meeting this specification can be extracted from its proof via the proofs-as-programs principle [3]. This style is widely advocated [13] and supported in a number of implementations such as NuPRL <ref> [8] </ref>. The application of such systems however is limited by its low degree of automation. In order to overcome this drawback, we suggest incorporating techniques from inductive theorem proving. The first difficult step within a proof is the choice of the appropriate induction scheme.
Reference: 9. <author> Jane T. Hesketh. </author> <title> Using Middle-Out Reasoning to Guide Inductive Theorem Proving. </title> <type> PhD thesis, </type> <institution> Dept. of Artificial Intelligence, University of Edinburgh, </institution> <year> 1991. </year>
Reference-contexts: In program synthesis, however, the identity of the existential witness plays a vital role of defining the program to be synthesized. Other approaches [1, 10, 16] use meta-annotations; the existentially quantified variable x is replaced by F (X) where capital letters indicate meta-variables. Middle-out reasoning <ref> [9] </ref> is used in order to instantiate the function F and its argument X. This problem requires a computationally expensive higher-order unification. The presence of higher-order variables also leads to non-termination of rippling, as the width and the size of the wave-front cannot be determined. <p> The work of Kraan et al.[10] builds upon the idea to replace existentially quantified variables by skolem functions in order to synthesize logical programs. In order to control better the search space within the inductive step, rippling and middle-out reasoning <ref> [9] </ref> are used to construct predicate definitions from specifications in classical logic. However, both approaches do not guarantee that the synthesized program is correct, it has to be verified after the synthesis. We believe that constructive type theory provides a firmer mathematical foundation than is found in these systems.
Reference: 10. <author> I. Kraan, D. Basin, and A. Bundy. </author> <title> Logic program synthesis via proof planning. In Logic Program Synthesis and Transformation, p 1-14. </title> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: This does not matter if we are just interested in provabil-ity. In program synthesis, however, the identity of the existential witness plays a vital role of defining the program to be synthesized. Other approaches <ref> [1, 10, 16] </ref> use meta-annotations; the existentially quantified variable x is replaced by F (X) where capital letters indicate meta-variables. Middle-out reasoning [9] is used in order to instantiate the function F and its argument X. This problem requires a computationally expensive higher-order unification. <p> These examples span the range of specifications usually considered (see <ref> [5, 10, 16] </ref>) and do not require any case splits. We also can prove the specification for log 2 which results in a similar proof to the integer square root example. Moreover, we used the extended matching procedure to instantiate universally quantified variables in the hypothesis list.
Reference: 11. <author> Ferenc Kurucz. </author> <title> Realisierung verschiedender Induktionsstrategien basierend auf dem Rippling-Kalkul. </title> <type> Master's thesis, </type> <institution> Technical University Darmstadt, </institution> <year> 1997. </year>
Reference-contexts: This process is called reverse rippling. For rippling and reverse rippling we use the rippling-distance strategy <ref> [11, 4] </ref>. Each wave-front is mapped to a selected (goal)-sink. The distance between a wave-front and its assigned (goal) sink in the term tree is called distance measure. <p> The tactic exL decomposes the existential quantifier on the left hand side. Applications of tactic andL resp. andR eliminate the conjunction on the left resp. right hand side. The generated rippling sequence is translated back into sequent proof by cut, substitution and lemma applications as described in <ref> [11] </ref>. 7 Extensions to Reverse Rippling Examples, that can be solved by our method include the specification of quotient remainder, append, half, or last. These examples span the range of specifications usually considered (see [5, 10, 16]) and do not require any case splits.
Reference: 12. <author> Per Martin-Lof. </author> <title> Constructive mathematics and computer programming. </title> <booktitle> In 6-th International Congress for Logic, Methodology and Philosophy of Science, </booktitle> <year> 1979, </year> <title> p 153-175. </title> <publisher> North-Holland, </publisher> <year> 1982. </year>
Reference-contexts: 1 Introduction Constructive type theory <ref> [12] </ref> offers the unique advantage of total correctness of synthesized programs. In this setting a specification is of the form 8input: 9output: spec (input; output) where input is a vector of arguments, output is a result and spec is a proposition describing the required relation between them.
Reference: 13. <author> B. Nordstrom, K. Petersson, and J. M. Smith. </author> <title> Programming in Martin-Lofs Type Theory. An introduction. </title> <publisher> Clarendon Press, Oxford, </publisher> <year> 1990. </year>
Reference-contexts: A program meeting this specification can be extracted from its proof via the proofs-as-programs principle [3]. This style is widely advocated <ref> [13] </ref> and supported in a number of implementations such as NuPRL [8]. The application of such systems however is limited by its low degree of automation. In order to overcome this drawback, we suggest incorporating techniques from inductive theorem proving.
Reference: 14. <author> J. Otten and C. </author> <title> Kreitz. A Uniform Proof Procedure for Classical and Non-classical Logics. </title> <booktitle> KI-96: Advances in Artificial Intelligence, </booktitle> <publisher> LNAI 1137, </publisher> <address> p 307-319. </address> <publisher> Springer. </publisher>
Reference-contexts: This approach allows us to treat meta-variables uniformly. We plan to extend and refine our method in this direction. Moreover, we plan to explore the use of specially tailored logical proof search methods such as connection method <ref> [14] </ref> or resolution [17] instead of direct proof search in the sequent calculus. These proof methods are more goal directed. For future research we aim to combine these techniques with a matching procedure which uses rippling and reverse rippling techniques.
Reference: 15. <author> B. Pientka. </author> <title> Automating the instantiation of existentially quantified variables. </title> <type> technical report, </type> <institution> Dept. of Computer Science, Cornell University,1998. </institution>
Reference-contexts: Moreover, by a simple heuristic, which is integrated in check subgoals we are able to synthesize conditional substitutions. These conditions form a case split in the proof. For a more detailed version we refer to <ref> [15] </ref>. 3 simplify is a combination of NuPRL's tactics Unfold, SupInf and Auto. It is a decision procedure that uses standard arithmetic. 6 Integrating into NuPRL In this section we discuss the integration of our proof method into NuPRL, an interactive, tactic based theorem prover.
Reference: 16. <author> A. Smaill and I .Green. </author> <title> Automating the synthesis of functional programs. </title> <type> Research paper 777, </type> <institution> Dept. of Artificial Intelligence, University of Edinburgh, </institution> <year> 1995. </year>
Reference-contexts: This does not matter if we are just interested in provabil-ity. In program synthesis, however, the identity of the existential witness plays a vital role of defining the program to be synthesized. Other approaches <ref> [1, 10, 16] </ref> use meta-annotations; the existentially quantified variable x is replaced by F (X) where capital letters indicate meta-variables. Middle-out reasoning [9] is used in order to instantiate the function F and its argument X. This problem requires a computationally expensive higher-order unification. <p> These examples span the range of specifications usually considered (see <ref> [5, 10, 16] </ref>) and do not require any case splits. We also can prove the specification for log 2 which results in a similar proof to the integer square root example. Moreover, we used the extended matching procedure to instantiate universally quantified variables in the hypothesis list. <p> However, both approaches do not guarantee that the synthesized program is correct, it has to be verified after the synthesis. We believe that constructive type theory provides a firmer mathematical foundation than is found in these systems. In Smaill & Green <ref> [16] </ref>, an approach for the synthesis of functional programs within the framework of constructive type theory is suggested. This approach builds on higher-order embeddings and higher-order rippling.
Reference: 17. <author> T. Tammet. </author> <title> A resolution theorem prover for intuitionistic logic. </title> <booktitle> In Proceedings of the 13th International CADE, LNAI 1104, </booktitle> <pages> p 2-16, </pages> <year> 1996. </year>
Reference-contexts: This approach allows us to treat meta-variables uniformly. We plan to extend and refine our method in this direction. Moreover, we plan to explore the use of specially tailored logical proof search methods such as connection method [14] or resolution <ref> [17] </ref> instead of direct proof search in the sequent calculus. These proof methods are more goal directed. For future research we aim to combine these techniques with a matching procedure which uses rippling and reverse rippling techniques.
References-found: 17

