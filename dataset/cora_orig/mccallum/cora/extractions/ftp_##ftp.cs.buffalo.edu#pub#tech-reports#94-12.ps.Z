URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/94-12.ps.Z
Refering-URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/README.html
Root-URL: 
Email: E-Mail: fbharat,govin-kg@cs.buffalo.edu  E-Mail: mantha@wrc.xerox.com  
Title: Preference Logic Programming: Optimization as Inference  
Author: Kannan Govindarajan Bharat Jayaraman Surya Mantha 
Address: Buffalo, NY 14260  Building 128  Webster, NY 14580  
Affiliation: Department of Computer Science State University of New York at Buffalo  System Sciences Laboratory  Xerox, Webster Research Center  
Abstract: Preference Logic Programming (PLP) is an extension of Constraint Logic Programming (CLP) for declaratively specifying optimization problems. In the PLP framework, the definite clauses of a CLP program are augmented by two new kinds of clauses: optimization clauses and arbiter clauses. Optimization clauses specify which predicates are to be optimized and arbiter clauses specify the criteria to be used for optimization. Together, these three kinds of clauses form a preferential theory, for which a possible worlds semantics was first given by Mantha et al. This paper shows how modal concepts can be used to capture the notion of optimization: Essentially, each world in the possible-worlds semantics for a preference logic program is a model of the program, and an ordering over these worlds is enforced by the arbiter clauses in the program. We introduce the notion of preferential consequence as truth in the optimal worlds. We propose an operational semantics that is an extension of SLD derivation and prove its soundness. Finally, we provide a variety of examples to illustrate our paradigm: minimum and maximum predicates, partial-order programming, syntactic ambiguity resolution and its application in document formatting, and general optimization problems. 
Abstract-found: 1
Intro-found: 1
Reference: [BMMW89] <author> A. Borning, M. J. Maher, A. Martindale, and M. Wilson. </author> <title> Constraint hierarchies and logic programming. </title> <editor> In Giorgio Levi and Maurizio Martelli, editors, </editor> <booktitle> Proceedings of the Sixth International Conference on Logic Programming, </booktitle> <pages> pages 149-164, </pages> <address> Lisbon, 1989. </address> <publisher> The MIT Press. </publisher> <pages> 16 </pages>
Reference-contexts: for negation; [GGZ91] shows how under certain monotonicity conditions, optimization predicates such as minimum and maximum predicates can be efficiently computed; [Par89, JOM93] discuss partial-order programming over lattice domains in which the notion of maximizing (minimizing) is incorporated directly into the semantics by taking least upper bounds (greatest lower bounds); <ref> [BMMW89, WB93] </ref> discuss Hierarchical CLP (HCLP) which is an extension to CLP where (numeric) strengths are associated with constraints, and the desired behavior of the system is captured by trying to satisfy the constraints in the "best" possible way.
Reference: [BMW92] <author> A. Brown, S. Mantha, and T. Wakayama. </author> <title> The Declarative Semantics of Document Processing. </title> <booktitle> In Proc. of the First International Workshop on Principles of Document Processing, </booktitle> <year> 1992. </year>
Reference-contexts: We should note that in some applications grammatical ambiguity is resolved by associating costs with different parses and preferring parses with lesser cost. Such problems may be termed optimal parsing problems, and they find application in a variety of areas, including document formatting <ref> [BMW92] </ref>, etc. Indeed, this was one of the principal motivating problems for the theory developed in this paper. <p> the definition need not be different nodes, i.e. one solution to the set of constraints may block another solution to the set of constraints. 6 A Practical Application of Preference Logic Programming This section describes how preference logic programs are powerful enough to express practical applications such as document formatting <ref> [BMW92] </ref>. In particular we describe how line-breaking as done by formatters such as T E Xand L a T E X [KP81], can be expressed as a preference logic program. Logically, a paragraph is a sequence of lines where each line is a sequence of words.
Reference: [BMW93] <author> A. Brown, S. Mantha, and T. Wakayama. </author> <title> Logical Reconstruction of Constraint Re laxation Hierarchies in Logic Programming. </title> <booktitle> In Proc. Intl. Symp. on Methodologies for Intelligent Systems, </booktitle> <year> 1993. </year>
Reference-contexts: Since relaxation is the dual of optimization, preference logic programs can be used to logically characterize relaxation <ref> [BMW93] </ref>. We are presently investigating this topic further. 5. Motivated by the line-breaking example, we are also interested in incrementally computing the optimal answers; extending [MS89, vH90] to preference logic programs. Acknowledgements This research was supported by a grant from the XEROX Research Foundation.
Reference: [BMW94] <author> A. Brown, S. Mantha, and T. Wakayama. </author> <title> Preference Logics : Towards a Unified Ap proach to Non-Monotonicity in Deductive Reasoning. </title> <note> To Appear in the Annals of Mathematics and Artificial Intelligence, </note> <year> 1994. </year>
Reference-contexts: Rather than characterize states of affairs themselves by single propositions, [Man91] suggests that the reason for the betterness of one state of affairs over another be captured by single propositions (preference criteria). Our discussion of preference logics below is based on <ref> [Man91, BMW94] </ref>. <p> In the tradition of modal logics, <ref> [BMW94] </ref> provides a possible worlds semantics for preference logics, as follows. Definition 1 A preference frame F is an ordered pair of the form hW; i, where W is a non-empty set of possible worlds and is a binary relation over W. <p> F is said to be valid in a class of frames F 0 (denoted j= F 0 F ) if it is valid in every frame in F 0 . Theorem 1 <ref> [BMW94] </ref> The Propositional Logic of Pure Preference P with the rule of inference mentioned above is both sound and complete in the class of all frames (U ). In other words, ` F iff j= U F . <p> pre-interpretation in which some of the function symbols are interpreted as in CLP, e.g., + in the shortest distance example, and the other function symbols are freely interpreted as in the Herbrand pre-interpretation. 2.3 General Preferential Theories In this subsection, we briefly review the general preferential theories as introduced in <ref> [BMW94] </ref>. Informally a preferential theory is an abstract specification of an optimization problem. It has two components: a first order theory T and an arbiter A. <p> For our application, we are interested in preference models that take into account all possible feasible solutions and impose an ordering only when required. For any given preferential theory and a pre-interpretation, such a model exists and is unique upto an isomorphism <ref> [BMW94] </ref>. <p> Note that adding the edge instance edge (a; c; 5) changes the shortest-path between a and c, i.e., optimization is a non-monotonic notion <ref> [BMW94] </ref>. 4 Examples of Preference Logic Programs In this section we compare the paradigm with related approaches and we also give additional examples of preference logic programs 4.1 Minimum and Maximum Predicates Ganguly et al [GGZ91] show how to express generalizations of graph-closure problems, such as the shortest path problem, using
Reference: [Che80] <author> B.F. Chellas. </author> <title> Modal Logic, an introduction. </title> <publisher> Cambridge University Press, </publisher> <year> 1980. </year>
Reference-contexts: Our discussion of preference logics below is based on [Man91, BMW94]. Familiarity with modal logic, as described in [Ram88] or <ref> [Che80] </ref>, is sufficient. 2 2.1 The Modal Logic of Pure Preference P The syntax of P is obtained by extending the syntax of propositional logic L by a monadic modal operator P f , with a corresponding rule of formation: if F is a formula of P, then so is P <p> The syntax of this logic is derived from the syntax of first-order logic (with quantifiers 9 and 8) by adding the modal operator P f with the associated rule of formation. We also assume that the Barcan formulae <ref> [Che80, Ram88] </ref> are true, that each function symbol is a rigid functor, that each term is a rigid designator, and the domain over which terms are constructed is fixed in all worlds. Under these assumptions, the logic can be proved to be sound and complete.
Reference: [Fag93] <author> F. Fages. </author> <title> On the Semantics of Optimization Predicates in CLP Languages. </title> <booktitle> In Proc. of 13th Annual Conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <year> 1993. </year>
Reference-contexts: The CLP framework provides a declarative approach only to one of these three components, namely, (1), since optimization is a meta-level concept in constraint logic. While several approaches to optimization have been proposed in the LP community <ref> [GGZ91, Fag93, MS89, Par89, JOM93] </ref>, it is not clear in these approaches that one can fully specify all three components of an optimization problem. The contribution of this paper lies in showing how the use of preference logic provides a natural, declarative, and general means of specifying optimization problems. <p> logic of preference, we are able to devise an efficient derivation procedure. 1 Several approaches have been proposed to the problem of incorporating optimization in a CLP framework: [MS89] discusses how to incorporate optimization queries into a CLP system by mapping the solutions of a query to a partial order; <ref> [Fag93] </ref> describes a semantics for optimization predicates in CLP languages based on Kunen-Fitting's semantics for negation; [GGZ91] shows how under certain monotonicity conditions, optimization predicates such as minimum and maximum predicates can be efficiently computed; [Par89, JOM93] discuss partial-order programming over lattice domains in which the notion of maximizing (minimizing) is <p> Such an approach was shown to be natural for describing the behavior of interactive graphics applications declaratively. Our proposed approach has many strengths: The key distinguishing feature of our approach is that it allows the programmer to program the preference criteria to suit the application. In contrast, <ref> [GGZ91, Fag93] </ref> only provide optimization predicates that can be expressed as maximizing or minimizing some objective function; similarly, in the partial-order programming framework of [Par89, JOM93], one computes the greatest lower bound or the least upper bound of elements in a partial order. <p> Moreover, our semantics for optimization is expressed by explicit selection, rather than via negation, as in <ref> [GGZ91, Fag93] </ref>. In comparison with HCLP, we note that our focus is on the class of optimization problems where it is more natural to compare alternative solutions and specify which is "better" with respect to preference criteria. <p> They give a first-order semantics for these programs and describe an efficient greedy fixpoint procedure for computing the stable models of these programs under certain monotonicity restrictions. Fages <ref> [Fag93] </ref> asserts that to avoid dependence of the result on ordering of goals, the optimization process should be localized to the goal given as argument to the meta-level predicates such as min. He also suggests that the constraints inherited from other goals should not change the optimality condition. <p> Under such conditions, Fages describes 8 how to provide semantics for such optimization predicates using negation, and how a branch and bound algorithm can be derived as a refinement of the semantics. The important difference between <ref> [GGZ91, Fag93] </ref> and our approach is that optimization in our framework is captured by explicit selection, without making use of negation.
Reference: [GGZ91] <author> S. Ganguly, S. Greco, and C. Zaniolo. </author> <title> Minimum and Maximum Predicates in Logic Programming. </title> <booktitle> In Proc. Tenth ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 154-163, </pages> <year> 1991. </year>
Reference-contexts: The CLP framework provides a declarative approach only to one of these three components, namely, (1), since optimization is a meta-level concept in constraint logic. While several approaches to optimization have been proposed in the LP community <ref> [GGZ91, Fag93, MS89, Par89, JOM93] </ref>, it is not clear in these approaches that one can fully specify all three components of an optimization problem. The contribution of this paper lies in showing how the use of preference logic provides a natural, declarative, and general means of specifying optimization problems. <p> been proposed to the problem of incorporating optimization in a CLP framework: [MS89] discusses how to incorporate optimization queries into a CLP system by mapping the solutions of a query to a partial order; [Fag93] describes a semantics for optimization predicates in CLP languages based on Kunen-Fitting's semantics for negation; <ref> [GGZ91] </ref> shows how under certain monotonicity conditions, optimization predicates such as minimum and maximum predicates can be efficiently computed; [Par89, JOM93] discuss partial-order programming over lattice domains in which the notion of maximizing (minimizing) is incorporated directly into the semantics by taking least upper bounds (greatest lower bounds); [BMMW89, WB93] discuss <p> Such an approach was shown to be natural for describing the behavior of interactive graphics applications declaratively. Our proposed approach has many strengths: The key distinguishing feature of our approach is that it allows the programmer to program the preference criteria to suit the application. In contrast, <ref> [GGZ91, Fag93] </ref> only provide optimization predicates that can be expressed as maximizing or minimizing some objective function; similarly, in the partial-order programming framework of [Par89, JOM93], one computes the greatest lower bound or the least upper bound of elements in a partial order. <p> Moreover, our semantics for optimization is expressed by explicit selection, rather than via negation, as in <ref> [GGZ91, Fag93] </ref>. In comparison with HCLP, we note that our focus is on the class of optimization problems where it is more natural to compare alternative solutions and specify which is "better" with respect to preference criteria. <p> c; 5) changes the shortest-path between a and c, i.e., optimization is a non-monotonic notion [BMW94]. 4 Examples of Preference Logic Programs In this section we compare the paradigm with related approaches and we also give additional examples of preference logic programs 4.1 Minimum and Maximum Predicates Ganguly et al <ref> [GGZ91] </ref> show how to express generalizations of graph-closure problems, such as the shortest path problem, using meta-level constructs such as min. They give a first-order semantics for these programs and describe an efficient greedy fixpoint procedure for computing the stable models of these programs under certain monotonicity restrictions. <p> Under such conditions, Fages describes 8 how to provide semantics for such optimization predicates using negation, and how a branch and bound algorithm can be derived as a refinement of the semantics. The important difference between <ref> [GGZ91, Fag93] </ref> and our approach is that optimization in our framework is captured by explicit selection, without making use of negation. <p> The important difference between [GGZ91, Fag93] and our approach is that optimization in our framework is captured by explicit selection, without making use of negation. The following is a formulation of the shortest-path problem in the framework of <ref> [GGZ91] </ref>: sh path (X; Y; C) min (C; (X; Y ); path (X; Y; C)): path (X; Y; C) arc (X; Y; C): path (X; Y; C) path (X; Y; C1); arc (Z; Y; C2); C = C1 + C2: The semantics of the min predicate is captured by the first-order <p> the first-order extension of the program which replaces the min clause with the following rule: sh path (X; Y; C) path (X; Y; C); :(path (X; Y; C1) ^ C1 &lt; C): Clearly, the paradigm of preference logic programming is powerful enough to express problems expressible in the framework of <ref> [GGZ91] </ref>, as illustrated by the shortest path example. 4.2 Partial Order Programming Partial order assertions were introduced in [Par89] as a programming paradigm that generalizes mathematical and declarative programming (logic and functional programming). <p> The derivation scheme is an extension of SLD-resolution where some of the derivation paths get pruned due to the arbiter: the arbiter can thus be thought of as offering control advice to the SLD engine about which paths are better. Unlike the negation based approach of <ref> [GGZ91] </ref>, our derivation scheme performs optimization by explicit selection, i.e. it prunes paths that compute sub-optimal solutions.
Reference: [Jay92] <author> B. Jayaraman. </author> <title> Implementation of Subset-Equational Languages. </title> <journal> Journal of Logic Pro gramming, </journal> <volume> 12(4) </volume> <pages> 299-324, </pages> <year> 1992. </year>
Reference-contexts: The following is a simple program that computes the set of all permutations of a set, i.e., the set of all list arrangements of the set (see <ref> [Jay92] </ref> for more details on this example): perms (f g) f [ ]g: perms (fXnT g) distr (X; perms (T )): distr (H; fLn g) f [HjL]g: The pattern fXnT g matches a set S such that X 2 S and T = S fXg).
Reference: [JL87] <author> J. Jaffar and J. L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proc. 14th ACM Sympo sium on Principles of Programming Languages, </booktitle> <pages> pages 111-119, </pages> <address> Munich, </address> <month> January </month> <year> 1987. </year>
Reference-contexts: 1 Introduction This paper presents a principled approach to extending Constraint Logic Programming (CLP) languages <ref> [JL87, vH89, JM] </ref> for declaratively specifying optimization problems. <p> We have also given a declarative account of optimization in terms of preferential consequence, i.e., truth in the optimal worlds. The resulting programming paradigm extends the CLP schemes of <ref> [JL87] </ref> by providing two new types of program clauses: optimization and arbiter. We showed the usefulness of the paradigm by expressing a variety of problems: shortest path, ambiguity resolution, partial order programming, and line breaking.
Reference: [JM] <author> J. Jaffar and M. J. Maher. </author> <title> Constraint Logic Programming : A Survey. </title> <note> To appear in the Journal of Logic Programming. </note>
Reference-contexts: 1 Introduction This paper presents a principled approach to extending Constraint Logic Programming (CLP) languages <ref> [JL87, vH89, JM] </ref> for declaratively specifying optimization problems.
Reference: [JOM93] <author> B. Jayaraman, M. Osorio, and K. Moon. </author> <title> Partial Order Logic Programming. </title> <type> Technical Report 93-040, </type> <institution> Dept. of Computer Science, SUNY at Buffalo, </institution> <year> 1993. </year>
Reference-contexts: The CLP framework provides a declarative approach only to one of these three components, namely, (1), since optimization is a meta-level concept in constraint logic. While several approaches to optimization have been proposed in the LP community <ref> [GGZ91, Fag93, MS89, Par89, JOM93] </ref>, it is not clear in these approaches that one can fully specify all three components of an optimization problem. The contribution of this paper lies in showing how the use of preference logic provides a natural, declarative, and general means of specifying optimization problems. <p> into a CLP system by mapping the solutions of a query to a partial order; [Fag93] describes a semantics for optimization predicates in CLP languages based on Kunen-Fitting's semantics for negation; [GGZ91] shows how under certain monotonicity conditions, optimization predicates such as minimum and maximum predicates can be efficiently computed; <ref> [Par89, JOM93] </ref> discuss partial-order programming over lattice domains in which the notion of maximizing (minimizing) is incorporated directly into the semantics by taking least upper bounds (greatest lower bounds); [BMMW89, WB93] discuss Hierarchical CLP (HCLP) which is an extension to CLP where (numeric) strengths are associated with constraints, and the desired <p> In contrast, [GGZ91, Fag93] only provide optimization predicates that can be expressed as maximizing or minimizing some objective function; similarly, in the partial-order programming framework of <ref> [Par89, JOM93] </ref>, one computes the greatest lower bound or the least upper bound of elements in a partial order. Moreover, our semantics for optimization is expressed by explicit selection, rather than via negation, as in [GGZ91, Fag93]. <p> In the formulation discussed in <ref> [JOM93] </ref>, partial order assertions have two basic forms: f (t) expr f (t) expr where each variable in expr also occurs in t.
Reference: [Kow79] <author> R. A. Kowalski. </author> <title> Algorithm = Logic + Control. </title> <journal> CACM, </journal> <volume> 22 </volume> <pages> 424-436, </pages> <year> 1979. </year>
Reference-contexts: Another important feature of PLP is that it allows one to specify both the logic and the control components of an algorithm <ref> [Kow79] </ref> in a modular and declarative fashion. The constraints of a PLP program specify the logic, and the preference clauses specify the control. Essentially, the preference clauses offer control advice to the SLD inference engine about which paths in the proof tree are better. <p> We showed the usefulness of the paradigm by expressing a variety of problems: shortest path, ambiguity resolution, partial order programming, and line breaking. In keeping with the spirit of Kowalski's famous equation "Algorithm = Logic + Control" <ref> [Kow79] </ref>, preference logic programming allows both logic and control to be specified in a modular and declarative fashion: The arbiter clauses in the preference logic program provide advice to the SLD inference engine about which paths in the proof tree are better than others.
Reference: [KP81] <author> D. E. Knuth and M. F. Plass. </author> <title> Breaking Paragraphs into Lines. </title> <journal> Software Practice and Experience, </journal> <volume> 11 </volume> <pages> 1119-1184, </pages> <year> 1981. </year>
Reference-contexts: Section 4 illustrates how various optimization problems can be expressed as preference logic programs. Section 5 describes the PTSLD-derivation scheme, and presents the soundness and completeness theorems and proofs for this derivation scheme. Section 6 discusses in some detail how a practical example, line-breaking <ref> [KP81] </ref>, can be expressed in the PLP framework. Section 7 presents conclusions and areas for future work. 2 The Logic of Preference The concept of preference has been studied extensively in decision theory, economics, ethics and philosophical logic. <p> In particular we describe how line-breaking as done by formatters such as T E Xand L a T E X <ref> [KP81] </ref>, can be expressed as a preference logic program. Logically, a paragraph is a sequence of lines where each line is a sequence of words. <p> This view of a paragraph can be captured by the following context free grammar with regular right hand sides (allowing regular right hand sides does not add any expressive power to context free grammars): &lt;para&gt; -&gt; &lt;line&gt; + &lt;line&gt; -&gt; [unit]+ <ref> [KP81] </ref> describes how to lay out a sequence of words forming a paragraph by computing the badness of the paragraph which depends on the badness of the lines that make up the paragraph. <p> The badness of a line is determined by the properties of the line such as the total width of the characters that make up the line, the number of white spaces in the line, the stretchability and shrinkability of the white spaces, the desired length of the line etc. <ref> [KP81] </ref> associates extra strechability with the 14 last line in the paragraph and insists that each line in the paragraph be such that the ratio of the difference between actual length and the desired length and the stretchability or shrinkability (the adjustment ratio) be bounded.
Reference: [Man91] <author> S. Mantha. </author> <title> First-Order Preference Theories and their Applications. </title> <type> PhD thesis, </type> <institution> Uni versity of Utah, </institution> <month> November </month> <year> 1991. </year>
Reference-contexts: It has been suggested that the preference relation of primary importance is the one between states of affairs (or possible worlds) characterized by possibly infinite sets of propositions. Rather than characterize states of affairs themselves by single propositions, <ref> [Man91] </ref> suggests that the reason for the betterness of one state of affairs over another be captured by single propositions (preference criteria). Our discussion of preference logics below is based on [Man91, BMW94]. <p> Rather than characterize states of affairs themselves by single propositions, [Man91] suggests that the reason for the betterness of one state of affairs over another be captured by single propositions (preference criteria). Our discussion of preference logics below is based on <ref> [Man91, BMW94] </ref>.
Reference: [MS89] <author> M. J. Maher and P. J. Stuckey. </author> <title> Expanding Query Power in Constraint Logic Pro gramming Languages. </title> <editor> In Ewing L. Lusk and Ross A. Overbeek, editors, </editor> <booktitle> Proceedings of the North American Conference on Logic Programming, </booktitle> <pages> pages 20-36, </pages> <address> Cleveland, Ohio, USA, </address> <year> 1989. </year>
Reference-contexts: The CLP framework provides a declarative approach only to one of these three components, namely, (1), since optimization is a meta-level concept in constraint logic. While several approaches to optimization have been proposed in the LP community <ref> [GGZ91, Fag93, MS89, Par89, JOM93] </ref>, it is not clear in these approaches that one can fully specify all three components of an optimization problem. The contribution of this paper lies in showing how the use of preference logic provides a natural, declarative, and general means of specifying optimization problems. <p> Because we are not carrying out general proving theorems in the logic of preference, we are able to devise an efficient derivation procedure. 1 Several approaches have been proposed to the problem of incorporating optimization in a CLP framework: <ref> [MS89] </ref> discusses how to incorporate optimization queries into a CLP system by mapping the solutions of a query to a partial order; [Fag93] describes a semantics for optimization predicates in CLP languages based on Kunen-Fitting's semantics for negation; [GGZ91] shows how under certain monotonicity conditions, optimization predicates such as minimum and <p> Since relaxation is the dual of optimization, preference logic programs can be used to logically characterize relaxation [BMW93]. We are presently investigating this topic further. 5. Motivated by the line-breaking example, we are also interested in incrementally computing the optimal answers; extending <ref> [MS89, vH90] </ref> to preference logic programs. Acknowledgements This research was supported by a grant from the XEROX Research Foundation. Surya Mantha would like to acknowledge the encouragement of Prof. Howard Blair and Prof. Anil Nerode during the development of the theory of preference logic.
Reference: [MST93] <author> V. W. Marek, G. F. Schwarz, and M. Truszczynski. </author> <title> Modal Nonmonotonic Logics : Ranges, Characterization, Computation. </title> <journal> JACM, </journal> <volume> 40(4) </volume> <pages> 963-990, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: The use of modal logic for this purpose is not surprising because optimization is a 15 non-monotonic notion and modal logics have been used in the past to characterize non-monotonic inference <ref> [MST93] </ref>. We have also given a declarative account of optimization in terms of preferential consequence, i.e., truth in the optimal worlds. The resulting programming paradigm extends the CLP schemes of [JL87] by providing two new types of program clauses: optimization and arbiter.
Reference: [MT91] <author> W. Marek and M. Truszczynski. </author> <title> Autoepistemic Logic. </title> <journal> JACM, </journal> <volume> 38(3) </volume> <pages> 588-619, </pages> <month> July </month> <year> 1991. </year> <month> 17 </month>
Reference-contexts: F is said to be a weak credulous preferential consequence of PT , if, for all pre-interpretations, F is true in some the weakly optimal world in the intended preference model. These notions of skeptical and credulous consequences are derived from similar notions in autoepis-temic logics, <ref> [MT91] </ref>. In this paper we will be using the notion of weak credulous preferential consequence. Constraint optimization problems are expressible as preferential theories as follows.
Reference: [Par89] <author> S. Parker. </author> <title> Partial Order Programming. </title> <booktitle> In Proc. ACM Conf. on Principles of Prog. Lang., </booktitle> <pages> pages 260-266, </pages> <year> 1989. </year>
Reference-contexts: The CLP framework provides a declarative approach only to one of these three components, namely, (1), since optimization is a meta-level concept in constraint logic. While several approaches to optimization have been proposed in the LP community <ref> [GGZ91, Fag93, MS89, Par89, JOM93] </ref>, it is not clear in these approaches that one can fully specify all three components of an optimization problem. The contribution of this paper lies in showing how the use of preference logic provides a natural, declarative, and general means of specifying optimization problems. <p> into a CLP system by mapping the solutions of a query to a partial order; [Fag93] describes a semantics for optimization predicates in CLP languages based on Kunen-Fitting's semantics for negation; [GGZ91] shows how under certain monotonicity conditions, optimization predicates such as minimum and maximum predicates can be efficiently computed; <ref> [Par89, JOM93] </ref> discuss partial-order programming over lattice domains in which the notion of maximizing (minimizing) is incorporated directly into the semantics by taking least upper bounds (greatest lower bounds); [BMMW89, WB93] discuss Hierarchical CLP (HCLP) which is an extension to CLP where (numeric) strengths are associated with constraints, and the desired <p> In contrast, [GGZ91, Fag93] only provide optimization predicates that can be expressed as maximizing or minimizing some objective function; similarly, in the partial-order programming framework of <ref> [Par89, JOM93] </ref>, one computes the greatest lower bound or the least upper bound of elements in a partial order. Moreover, our semantics for optimization is expressed by explicit selection, rather than via negation, as in [GGZ91, Fag93]. <p> Y; C) path (X; Y; C); :(path (X; Y; C1) ^ C1 &lt; C): Clearly, the paradigm of preference logic programming is powerful enough to express problems expressible in the framework of [GGZ91], as illustrated by the shortest path example. 4.2 Partial Order Programming Partial order assertions were introduced in <ref> [Par89] </ref> as a programming paradigm that generalizes mathematical and declarative programming (logic and functional programming). In the formulation discussed in [JOM93], partial order assertions have two basic forms: f (t) expr f (t) expr where each variable in expr also occurs in t.
Reference: [Ram88] <author> A. Ramsay. </author> <booktitle> Formal Methods in Artificial Intelligence. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1988. </year>
Reference-contexts: Our discussion of preference logics below is based on [Man91, BMW94]. Familiarity with modal logic, as described in <ref> [Ram88] </ref> or [Che80], is sufficient. 2 2.1 The Modal Logic of Pure Preference P The syntax of P is obtained by extending the syntax of propositional logic L by a monadic modal operator P f , with a corresponding rule of formation: if F is a formula of P, then so <p> The syntax of this logic is derived from the syntax of first-order logic (with quantifiers 9 and 8) by adding the modal operator P f with the associated rule of formation. We also assume that the Barcan formulae <ref> [Che80, Ram88] </ref> are true, that each function symbol is a rigid functor, that each term is a rigid designator, and the domain over which terms are constructed is fixed in all worlds. Under these assumptions, the logic can be proved to be sound and complete.
Reference: [vH89] <author> P. van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction This paper presents a principled approach to extending Constraint Logic Programming (CLP) languages <ref> [JL87, vH89, JM] </ref> for declaratively specifying optimization problems.
Reference: [vH90] <author> P. van Hentenryck. </author> <title> Incremental constraint satisfaction in logic programming. </title> <editor> In David H. D. Warren and Peter Szeredi, editors, </editor> <booktitle> Proceedings of the Seventh International Conference on Logic Programming, </booktitle> <pages> pages 189-202, </pages> <address> Jerusalem, 1990. </address> <publisher> The MIT Press. </publisher>
Reference-contexts: Since relaxation is the dual of optimization, preference logic programs can be used to logically characterize relaxation [BMW93]. We are presently investigating this topic further. 5. Motivated by the line-breaking example, we are also interested in incrementally computing the optimal answers; extending <ref> [MS89, vH90] </ref> to preference logic programs. Acknowledgements This research was supported by a grant from the XEROX Research Foundation. Surya Mantha would like to acknowledge the encouragement of Prof. Howard Blair and Prof. Anil Nerode during the development of the theory of preference logic.
Reference: [War80] <author> D. H. D. Warren. </author> <title> Logic Programming and Compiler Writing. </title> <journal> Software Practice and Experience, </journal> <volume> 10(II), </volume> <year> 1980. </year>
Reference-contexts: The translation from an attributed context free grammar to a definite clause program is a straight forward generalization of the translation from simple context free grammars to definite clause programs <ref> [War80] </ref>.
Reference: [WB93] <author> M. Wilson and A. Borning. </author> <title> Hierarchical Constraint Logic Programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 16 </volume> <pages> 277-318, </pages> <year> 1993. </year> <month> 18 </month>
Reference-contexts: for negation; [GGZ91] shows how under certain monotonicity conditions, optimization predicates such as minimum and maximum predicates can be efficiently computed; [Par89, JOM93] discuss partial-order programming over lattice domains in which the notion of maximizing (minimizing) is incorporated directly into the semantics by taking least upper bounds (greatest lower bounds); <ref> [BMMW89, WB93] </ref> discuss Hierarchical CLP (HCLP) which is an extension to CLP where (numeric) strengths are associated with constraints, and the desired behavior of the system is captured by trying to satisfy the constraints in the "best" possible way.
References-found: 23

