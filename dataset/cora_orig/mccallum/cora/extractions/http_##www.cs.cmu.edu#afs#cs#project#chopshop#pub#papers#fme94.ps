URL: http://www.cs.cmu.edu/afs/cs/project/chopshop/pub/papers/fme94.ps
Refering-URL: http://www.cs.cmu.edu/afs/cs/project/compose/www/paper_abstracts/dnj/fme94.html
Root-URL: 
Title: Abstract Model Checking of Infinite Specifications  
Author: Daniel Jackson 
Note: If ifs and ands were pots and pans, Thered be no need for tinkers hands Mother Goose  
Address: Pittsburgh, PA  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: A new method for analyzing specifications in languages like Z and VDM is proposed. Theorems are checked automatically by exhaustive search of the state space. An abstraction over the actual states can be defined that reduces an infinite state space to a finite number of equivalence classes, allowing it to be searched exhaustively by treating each class as a single abstract state. A prototype has been built that has verified some small theorems from the literature. 
Abstract-found: 1
Intro-found: 1
Reference: [Ack54] <author> W. Ackermann, </author> <title> Solvable Cases of the Decision Problem, </title> <publisher> North-Holland Publishing Company, </publisher> <address> Amsterdam, </address> <year> 1954. </year>
Reference-contexts: Theorems about unbounded objects are not necessarily undecidable. Even second-order logic is decidable when restricted to monadic predicates; for first-order logic, restricting quantifiers to occur only in certain patterns does the trick. Many of these results may be found in <ref> [Ack54] </ref>. The theory of equality with uninterpreted function symbols can be decided efficiently by congruence closure [NO80].
Reference: [AG93] <author> J.M. A tlee and J.D. Gannon, </author> <title> State-based Model Checking of Event-Driven Systems Requirements, </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> Jan. </month> <year> 1993. </year>
Reference: [BC+92] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill and J. Hwang, </author> <title> Symbolic Model Checking: 10 20 States and Beyond, </title> <booktitle> Information and Computation , 98(2), </booktitle> <pages> pp. 105120, </pages> <year> 1992. </year>
Reference-contexts: In hardware verification, model checking has been a great success, mainly because of the discovery of compact representations that allow a huge state space to be searched without explicit traversal of the reachability graph <ref> [BC+92] </ref>. Model checking therefore seems to be an ideal candidate for the analysis of software specifications. There is an obvious obstacle, however: few software specifications have finite state spaces. This paper proposes a model checking method that overcomes this difficulty. <p> A number of schemes have been developed for investigating the properties of a state machine; the most prominent are based on temporal logic <ref> [CES86, BC+92] </ref> or language containment [Kur86]. To my knowledge, this paper is the first application of model checking ideas to conventional, model-based* specifications. Model checking was developed primarily with hardware verification in mind, and has only recently been applied to software specifications at all. <p> Languages without named events are easier to handle; a notable success is A tlee and Gannons scheme [A G93] for translating P arnass SCR-style specifications [PM90] into the Kripke structures of the SMV model checker <ref> [BC+92] </ref>. Tools for investigating properties of finite machines specified in process algebras have been applied to software; examples are FDR [F SE92] and the Concurrency Workbench [CPS89].
Reference: [BGW92] <author> L. Bachmair, H. Gandzinger and U. Waldmann, </author> <title> Set Constraints are the Monadic Class, </title> <type> Technical Report MPI-I-92-240, </type> <institution> Max Planck Institute for Computer Science, </institution> <month> December </month> <year> 1992. </year>
Reference: [Bou93] <author> Francois Bourdoncle, </author> <title> Abstract Debugging of Higher Order Imperative Languages, </title> <booktitle> Proc. ACM Symposium of Programming L anguage Design and Implementation, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: Unlike the predicates here, however, the abstract versions of the primitive functions are deterministic, and return, instead of a set of possible abstract values, a single element that bounds them in the lattice. Abstract interpretation has been used almost ex clusively within compilers (but see <ref> [Bou93] </ref>). Analyses that have been designed for software engineering purposes (such as bug detection) have tended not use lattices, perhaps because the extra loss of information incurred when sets of values are replaced by a single value is unacceptable, and leads to ad hoc results.
Reference: [Bry88] <author> R.E. Bryant, </author> <title> Verifying a Static RAM Design by Logic Simulation, pp. </title> <booktitle> 335349 of Advanced Research in VLSI: Proceedings of the F ifth MIT Conference, </booktitle> <editor> ed. J. Allen and F.T. Leighton, </editor> <publisher> MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: When the abstraction is exact, all properties are pre-served, so the unrestricted logic may be used and the proof method is complete. The first use of symbolic constants in model checking appears to have been by Bryant, in the verification of a memory circuit <ref> [Bry88] </ref>. It is not obvious how to apply this framework to software specifications. This paper contributes two new ideas. First, [CGL92] regards abstractions as exact only when all primitive predicates (whether in the description of the machine or its specification) are congruences, and uses exactness to obtain completeness.
Reference: [CC77] <author> P. Cousot and R. Cousot, </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of P rograms by Construction or Appro ximation of F ixpoints, </title> <booktitle> Proc. 4th ACM Symposium on Principle of Programming L anguages, </booktitle> <pages> pp. 238 252, </pages> <month> January </month> <year> 1977. </year>
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson and A.P . Sistla, Automatic Verification of F inite-State Concurrent Systems Using Temporal Logic Specifications, </title> <journal> ACM Transactions of Programming Languages and Systems, </journal> <volume> 8(2), </volume> <pages> pp. 244263, </pages> <year> 1986. </year>
Reference-contexts: A number of schemes have been developed for investigating the properties of a state machine; the most prominent are based on temporal logic <ref> [CES86, BC+92] </ref> or language containment [Kur86]. To my knowledge, this paper is the first application of model checking ideas to conventional, model-based* specifications. Model checking was developed primarily with hardware verification in mind, and has only recently been applied to software specifications at all.
Reference: [CGL92] <author> E.M. Clarke, O. Grumberg and D.E. </author> <title> Long, Model Checking and Abstraction, </title> <booktitle> Proc. ACM Symposium of Principles of Programming Languages, </booktitle> <month> January </month> <year> 1992. </year>
Reference-contexts: R eplacing all three by concrete values gives a legitimate counterexample. How often this will work in practice remains to be seen. 8 Related Work Most of the ideas in this paper are taken from Clarke, Grumberg and Longs work on abstraction in temporal logic model checking <ref> [CGL92] </ref>. They show that ab stracting a state machine preserves the properties that can be expressed in the re FME 6/30/94, 1:40 PM9 stricted temporal logic CTL. When the abstraction is exact, all properties are pre-served, so the unrestricted logic may be used and the proof method is complete. <p> The first use of symbolic constants in model checking appears to have been by Bryant, in the verification of a memory circuit [Bry88]. It is not obvious how to apply this framework to software specifications. This paper contributes two new ideas. First, <ref> [CGL92] </ref> regards abstractions as exact only when all primitive predicates (whether in the description of the machine or its specification) are congruences, and uses exactness to obtain completeness.
Reference: [CPS89] <author> R. Cleaveland, J. Parrow and B. Steffen, </author> <title> The Concurrency Workbench, </title> <booktitle> Proc. of the Workshop on Automatic Verification Methods for FiniteState Systems, </booktitle> <pages> pp. 2437, </pages> <booktitle> Lecture Notes in Computer Science 407, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1989. </year>
Reference-contexts: Tools for investigating properties of finite machines specified in process algebras have been applied to software; examples are FDR [F SE92] and the Concurrency Workbench <ref> [CPS89] </ref>. Because process algebras have more elaborate models than simple state machines (due mainly to the distinction between internal and external choice), these tools cannot use standard model checking techniques and are thus currently confined to much smaller state spaces. Theorems about unbounded objects are not necessarily undecidable.
Reference: [GH80] <author> John V. Guttag and James J. Horning, </author> <title> Formal Specification as a Design Tool, </title> <booktitle> Seventh ACM Symp. on Principles of Programming Languages, </booktitle> <address> Las Vegas, </address> <month> Janu-ary </month> <year> 1980. </year>
Reference-contexts: An early and inuential paper on formal specification showed how to evaluate a design by casting informal queries as theorems <ref> [GH80] </ref>. F or a long time this has been the most compelling argument for formalization. If we could prove or dis Authors address: School of Computer Science, Carnegie Mellon University , 5000 F orbes Avenue, Pittsburgh, PA 15213. Email: daniel.jackson@cs.cmu.edu.
Reference: [GHW85] <author> John Guttag, James Horning and Jeannette Wing, </author> <title> The Larch Family of Specification Languages, </title> <journal> IEEE Software, </journal> <month> Sept. </month> <year> 1985. </year>
Reference-contexts: this work, various fragments of set theory: set constraints [HJ90, * This confusing term is used to distinguish languages like Z [Spi89] and VDM [Jon86], whose state spaces ar e constr ucted explicitly out of tuples, sets and r elations, from proper ty-oriented languages like the L arch Shared Language <ref> [GHW85] </ref>, which define the behaviour of operations without making the structure of the states explicit. State machine languages such as Statecharts [Har87] are not usually described as model-based. FME 6/30/94, 1:40 PM10 BGW92] and multilevel syllogistic [FOS80].
Reference: [FOS80] <author> A. Ferro, E.G. Omodeo and J.T. Schwartz, </author> <title> Decision Procedures for Elementary FME 6/30/94, 1:40 PM12 Sublanguages of Set Theory . I. Multilevel Syllogistic and Some Extensions. </title> <journal> Communications on Pure and Applied Mathematics, </journal> <volume> 40, </volume> <pages> pp. 265280, </pages> <year> 1987. </year>
Reference-contexts: State machine languages such as Statecharts [Har87] are not usually described as model-based. FME 6/30/94, 1:40 PM10 BGW92] and multilevel syllogistic <ref> [FOS80] </ref>. These could, I suspect, prove the theorems of Table 1, which, since they treat the pairs of a relation as single objects, are probably of the monadic class. But the full theory of relations is not decidable.
Reference: [FSE92] <author> FDR: </author> <title> User Manual and Tutorial, Formal Systems Europe Ltd., </title> <publisher> Oxford, </publisher> <address> England, </address> <month> October </month> <year> 1992. </year>
Reference: [Har87] <author> David Harel, Statecharts: </author> <title> A Visual Formalism for Complex Systems, </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8, </volume> <pages> pp. 231274, </pages> <year> 1987. </year>
Reference-contexts: The first obstacle to overcome is the incompatibility of representations; the state machine models appropriate for hardware are rarely good for software too, and even languages that are overtly state-machine-based (such as Statecharts <ref> [Har87] </ref>) are not suitable for direct model checking. Languages without named events are easier to handle; a notable success is A tlee and Gannons scheme [A G93] for translating P arnass SCR-style specifications [PM90] into the Kripke structures of the SMV model checker [BC+92]. <p> State machine languages such as Statecharts <ref> [Har87] </ref> are not usually described as model-based. FME 6/30/94, 1:40 PM10 BGW92] and multilevel syllogistic [FOS80]. These could, I suspect, prove the theorems of Table 1, which, since they treat the pairs of a relation as single objects, are probably of the monadic class.
Reference: [Hay93] <author> Ian Hayes, ed., </author> <title> Specification Case Studies, </title> <publisher> Prentice Hall International, </publisher> <editor> 2nd ed., </editor> <year> 1993. </year>
Reference-contexts: FME 6/30/94, 1:40 PM8 Theorem Source #Models ~ - - r = r [Jon86, p.158] 8 ~ dom (p - q) = dom (p) dom (q) [Jon86, p.159] 372 s dom (q) = - ~ s (p q) = (s p) q <ref> [Hay93, p.8] </ref> 5800 Table 1: A sample of theorems proved by the prototype checker They all appear in Z and VDM textbooks as examples of theorems that might be proved in the course of analyzing a specification.
Reference: [Hen75] <author> Peter Henderson, </author> <title> Finite State Modelling in Program Development, </title> <booktitle> Proc. International Conference on Reliable Software, </booktitle> <address> Los Angeles, </address> <year> 1975. </year>
Reference-contexts: Analyses that have been designed for software engineering purposes (such as bug detection) have tended not use lattices, perhaps because the extra loss of information incurred when sets of values are replaced by a single value is unacceptable, and leads to ad hoc results. The finite state modelling of <ref> [Hen75] </ref> and the typestates of [Str83] use at abstract state spaces like mine, but it is not clear how to apply these techniques to specifications. 9 Conclusion The case for writing formal specifications would be far more compelling if an automatic tool existed that could prove simple theorems about real specifications.
Reference: [HJ90] <author> N. Heintze and J. </author> <title> Jaffar , A Decision P rocedure for a Class of Herbrand Set Constraints, </title> <booktitle> Proc. 5th IEEE Symposium on Logic in Computer Science , June 1990. </booktitle>
Reference: [Jon86] <author> Cliff B. Jones, </author> <title> Systematic Software Development Using VDM, </title> <publisher> Prentice Hall International, </publisher> <year> 1986. </year>
Reference-contexts: A sample of some theorems that can be proved by the checker is given in Table 1. * - is override: p - q = (dom q p) q. FME 6/30/94, 1:40 PM8 Theorem Source #Models ~ - - r = r <ref> [Jon86, p.158] </ref> 8 ~ dom (p - q) = dom (p) dom (q) [Jon86, p.159] 372 s dom (q) = - ~ s (p q) = (s p) q [Hay93, p.8] 5800 Table 1: A sample of theorems proved by the prototype checker They all appear in Z and VDM textbooks <p> FME 6/30/94, 1:40 PM8 Theorem Source #Models ~ - - r = r [Jon86, p.158] 8 ~ dom (p - q) = dom (p) dom (q) <ref> [Jon86, p.159] </ref> 372 s dom (q) = - ~ s (p q) = (s p) q [Hay93, p.8] 5800 Table 1: A sample of theorems proved by the prototype checker They all appear in Z and VDM textbooks as examples of theorems that might be proved in the course of analyzing <p> invented for a number of special theories in which function symbols have fix ed interpretations, such as the theory of lists [NO80] and, more relevant to this work, various fragments of set theory: set constraints [HJ90, * This confusing term is used to distinguish languages like Z [Spi89] and VDM <ref> [Jon86] </ref>, whose state spaces ar e constr ucted explicitly out of tuples, sets and r elations, from proper ty-oriented languages like the L arch Shared Language [GHW85], which define the behaviour of operations without making the structure of the states explicit.
Reference: [Kur86] <author> R.P. Kurshan, </author> <title> Testing Containment of Regular Languages, </title> <type> Technical Report 1121-861010-33-TM, </type> <institution> AT&T Bell Laboratories, </institution> <year> 1986. </year>
Reference-contexts: A number of schemes have been developed for investigating the properties of a state machine; the most prominent are based on temporal logic [CES86, BC+92] or language containment <ref> [Kur86] </ref>. To my knowledge, this paper is the first application of model checking ideas to conventional, model-based* specifications. Model checking was developed primarily with hardware verification in mind, and has only recently been applied to software specifications at all.
Reference: [NO80] <author> Greg Nelson and Derek C. Oppen, </author> <title> Fast Decision Procedures Based on Congruence Closure, </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 27(2), </volume> <month> April </month> <year> 1980. </year>
Reference-contexts: Even second-order logic is decidable when restricted to monadic predicates; for first-order logic, restricting quantifiers to occur only in certain patterns does the trick. Many of these results may be found in [Ack54]. The theory of equality with uninterpreted function symbols can be decided efficiently by congruence closure <ref> [NO80] </ref>. Decision procedures have been invented for a number of special theories in which function symbols have fix ed interpretations, such as the theory of lists [NO80] and, more relevant to this work, various fragments of set theory: set constraints [HJ90, * This confusing term is used to distinguish languages like <p> The theory of equality with uninterpreted function symbols can be decided efficiently by congruence closure <ref> [NO80] </ref>. Decision procedures have been invented for a number of special theories in which function symbols have fix ed interpretations, such as the theory of lists [NO80] and, more relevant to this work, various fragments of set theory: set constraints [HJ90, * This confusing term is used to distinguish languages like Z [Spi89] and VDM [Jon86], whose state spaces ar e constr ucted explicitly out of tuples, sets and r elations, from proper ty-oriented languages like the
Reference: [PM90] <author> D. Parnas and J. Madey, </author> <title> Functional Documentation for Computer Systems Engineering, </title> <type> Technical Report TR-90-287, </type> <institution> Queens University, Kingston, </institution> <address> Ontario, </address> <month> September </month> <year> 1990. </year>
Reference-contexts: Languages without named events are easier to handle; a notable success is A tlee and Gannons scheme [A G93] for translating P arnass SCR-style specifications <ref> [PM90] </ref> into the Kripke structures of the SMV model checker [BC+92]. Tools for investigating properties of finite machines specified in process algebras have been applied to software; examples are FDR [F SE92] and the Concurrency Workbench [CPS89].
Reference: [PST91] <author> Ben Potter, Jane Sinclair and David Till, </author> <title> An Introduction to Formal Specification in Z, </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1991. </year>
Reference-contexts: Each set variable in the hypothesis can have 4 abstract values, so there are at most 64 cases to consider , and the model checking required is trivial. A more interesting case is the following theorem about relations, taken from <ref> [PST91, p. 215] </ref>*: This is converted to: * is the domain subtraction operator: s r = -x,y r | x s-.
Reference: [Spi89] <author> J.M. Spivey, </author> <title> The Z Notation: A R eference Manual, </title> <publisher> Prentice Hall International, </publisher> <year> 1989. </year>
Reference-contexts: procedures have been invented for a number of special theories in which function symbols have fix ed interpretations, such as the theory of lists [NO80] and, more relevant to this work, various fragments of set theory: set constraints [HJ90, * This confusing term is used to distinguish languages like Z <ref> [Spi89] </ref> and VDM [Jon86], whose state spaces ar e constr ucted explicitly out of tuples, sets and r elations, from proper ty-oriented languages like the L arch Shared Language [GHW85], which define the behaviour of operations without making the structure of the states explicit.
Reference: [Str83] <author> Robert E. Strom, </author> <title> Mechanisms for Compile-time Enforcement of Security , Proc. </title> <booktitle> ACM Symposium of Principles of Programming Languages, </booktitle> <month> January </month> <year> 1983. </year> <note> FME 6/30/94, 1:40 PM13 </note>
Reference-contexts: The finite state modelling of [Hen75] and the typestates of <ref> [Str83] </ref> use at abstract state spaces like mine, but it is not clear how to apply these techniques to specifications. 9 Conclusion The case for writing formal specifications would be far more compelling if an automatic tool existed that could prove simple theorems about real specifications.
References-found: 25

