URL: ftp://ftp.fzi.de/pub/PROST/papers/correctness.ps.Z
Refering-URL: http://www.fzi.de/prost/publications/overview.html
Root-URL: http://www.fzi.de
Title: II. Getting Class Correctness and System Correctness Equivalent How to Get Covariance Right tion). Object-oriented
Author: Franz Weber 
Note: 2.1 Introduction The most important idea of modular programming is the separation of what is done by a software component (the specification) from how it is done (the implementa  
Abstract: Covariant typing policies, as they are available in Eiffel or Sather, result in a type system in which the correct typing of a system is not implied by the correct typing of each class. This hinders a secure, incremental development of class libraries in these object-oriented languages. Classes which are added to a library may invalidate others that are already in the library. The paper shows how a covariant typing policy may be omitted without losing exibility. As a consequence we regain the equivalence of class correctness and system correctness (and hence class validity and system validity). The approach taken in this paper is based on the observation that inheritance is used either for the integration of subsystems or for the adaptation of general problem solutions to specific situations. It turns out that covariant typing policies are used for the latter situation. We show how adaptation may be solved by instantiation of schemes similar to generics. We give rules how such classes may be specified formally and what proof obligations evolve for building proven correct systems. The result of this paper is a typing and verification policy which enforces a clean design of class hierarchies. With this policy it is possible to develop classes independently and to compose them to a correct system without further global proof obligations or type checks. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andrew P. Black and Norman Hutchinson, </author> <title> Typechecking Polymorphism in Emerald, </title> <type> Technical Report CRL 91/1, </type> <institution> DEC Cambridge Research Lab, </institution> <year> 1991. </year>
Reference-contexts: The language constructs introduced in this paper allow free mixing of property classes and normal classes in contrast to the two level approach (separating interfaces and implementations) in the papers above. An approach with a very similar type system is described in <ref> [1] </ref>. The main difference is the extension of the notion of inheritance 40 Franz Weber and conformance by considering axiomatic specifications and specifications by pre- and postconditions of classes. The strongly typed object-oriented languages Modula-3, Trellis and Simula are statically type-safe because they restrict inheritance such that subtyping is guaranteed.
Reference: [2] <author> Peter S. Canning, William R. Cook, Walter L. Hill and Walter G. Olthoff, </author> <title> Interfaces for Strongly-Typed Object-Oriented Programming, </title> <journal> SIGPLAN Notices (special issue on OOPSLA 89), </journal> <volume> vol. 24, no. 10, </volume> <publisher> ACM, </publisher> <month> October </month> <year> 1989, </year> <pages> pp. 457467. </pages>
Reference-contexts: However, Palsberg and Schwartzbach show that in many situations type checks at run time may be avoided. An approach very close to the ideas in this paper is f-bounded polymorphism. The idea is already mentioned in [4]. F-bounded polymorphism is extended to a language design in <ref> [2] </ref> and [4]. F-bounded polymorphism is in principle the theoretic foundation of the construct like current and the inheritance rules for it. So f-bounded polymorphism is a good start when searching for the theoretical underpinning of the language rules in this paper.
Reference: [3] <author> Luca Cardelli and Peter Wegner, </author> <title> On Understanding Types, Data Abstraction, and Polymorphism, </title> <journal> Computing Surveys, </journal> <volume> vol. 17, no. 4, </volume> <publisher> ACM, </publisher> <year> 1985, </year> <pages> pp. 471522. </pages>
Reference-contexts: All basic notions used in this paper are described elsewhere. Subtyping and bounded type parameters are described in <ref> [3] </ref>. An overview on the theory behind object-oriented type systems is given in [6]. F-bounded polymorphism is described in [4]. Data refinement, axiomatic specifications, and model oriented specification are defined in [8]. In [7] P. Grogono describes the language Dee.
Reference: [4] <author> William R. Cook, Walter L. Hill and Peter S. Canning, </author> <title> Inheritance is not Subtyping, </title> <booktitle> in Principles of Programming Languages, </booktitle> <publisher> ACM Press, </publisher> <year> 1990, </year> <pages> pp. 125135. </pages>
Reference-contexts: All basic notions used in this paper are described elsewhere. Subtyping and bounded type parameters are described in [3]. An overview on the theory behind object-oriented type systems is given in [6]. F-bounded polymorphism is described in <ref> [4] </ref>. Data refinement, axiomatic specifications, and model oriented specification are defined in [8]. In [7] P. Grogono describes the language Dee. In Dee problems with covariant argument typing policy are solved by separating inheritance and conform 'i 1'n Getting Class Correctness and System Correctness Equivalent 39 ance. <p> Following this approach full static type checking is no longer possible. However, Palsberg and Schwartzbach show that in many situations type checks at run time may be avoided. An approach very close to the ideas in this paper is f-bounded polymorphism. The idea is already mentioned in <ref> [4] </ref>. F-bounded polymorphism is extended to a language design in [2] and [4]. F-bounded polymorphism is in principle the theoretic foundation of the construct like current and the inheritance rules for it. <p> However, Palsberg and Schwartzbach show that in many situations type checks at run time may be avoided. An approach very close to the ideas in this paper is f-bounded polymorphism. The idea is already mentioned in <ref> [4] </ref>. F-bounded polymorphism is extended to a language design in [2] and [4]. F-bounded polymorphism is in principle the theoretic foundation of the construct like current and the inheritance rules for it. So f-bounded polymorphism is a good start when searching for the theoretical underpinning of the language rules in this paper.
Reference: [5] <author> W. R. Cook, </author> <title> A Proposal for Making Eiffel Type-Safe, </title> <journal> The Computer Journal, </journal> <volume> vol. 32, no. 4, </volume> <year> 1989, </year> <pages> pp. 305311. </pages>
Reference-contexts: One aspect of formal correctness is correct typing. All problems concerning correctness have a corresponding problem in the formulation of typing rules. The first interpretation of compatibility requires a contravariant typing policy <ref> [5] </ref>. Eif-fel and languages with a similar type system try to implement the second interpretation by generic classes and by allowing a covariant typing policy [9]. <p> For expressing integrational compatibility we restrict the redefinition rule for normal classes during inheritance to subtyping (con-travariant argument typing policy). This is a well known policy (cf. <ref> [5] </ref>). We concentrate on property compatibility in this section. First we point out that one category of property compatibility may be expressed through generic classes. New mechanisms are needed only for self referential property compatibility. <p> To express our intention we define the class VEHICLE as class VEHICLE [ ] feature register_driver (d : D) The definition of the class TRUCK as class TRUCK inherit VEHICLE [TRUCKDRIVER] ... leads to the desired result (This approach is also described in <ref> [5] </ref>). Unfortunately, this solution is not possible for our LIBRARY scenario because we would have to make the type of current a generic parameter! The latter kind of property compatibility is called self referential. <p> routine definition of a generic instan-tiation of G is the effective routine definition of the corresponding type template of G, where all occurrences of the formal type parameters of G are replaced by the corresponding actual type parameters of the generic instantiation. 2.4.2.3 Routine Conformance For these definitions see also <ref> [5] </ref> and [8]. <p> Consequently all descendants of the normal class may use these axioms as theorems afterwards. 2.4.4 General Type Conformance The definitions here are in analogy to <ref> [5] </ref>. The approach is extended by additionally considering generic instantiations to be argument types for methods. <p> Two kinds of inheritance are considered. The first is contravariant inheritance (it is called just inheritance in Dee). It follows the usual rules as given in this paper or in <ref> [5] </ref>. Contravariant inheritance also implies conformance. Covariant inheritance is also allowed (called extensions). Extension does not imply conformance. So obviously the approach to conformance and contravariant typing policy of Dee is identical to the approach made in this paper. But the concept of extension is quite different to property classes.
Reference: [6] <author> Scott Danforth and Chris Tomlinson, </author> <title> Type Theories and Object-Oriented Programming, </title> <journal> Computing Surveys, </journal> <volume> vol. 20, no. 1, </volume> <publisher> ACM, </publisher> <year> 1988, </year> <pages> pp. 2972. </pages>
Reference-contexts: All basic notions used in this paper are described elsewhere. Subtyping and bounded type parameters are described in [3]. An overview on the theory behind object-oriented type systems is given in <ref> [6] </ref>. F-bounded polymorphism is described in [4]. Data refinement, axiomatic specifications, and model oriented specification are defined in [8]. In [7] P. Grogono describes the language Dee.
Reference: [7] <author> Peter Grogono, </author> <title> Issues in the Design of an Object-Oriented Programming Language, </title> <journal> Structured Programming, </journal> <volume> vol. 12, no. 1, </volume> <year> 1991, </year> <pages> pp. </pages> <note> 116. 42 Franz Weber </note>
Reference-contexts: Subtyping and bounded type parameters are described in [3]. An overview on the theory behind object-oriented type systems is given in [6]. F-bounded polymorphism is described in [4]. Data refinement, axiomatic specifications, and model oriented specification are defined in [8]. In <ref> [7] </ref> P. Grogono describes the language Dee. In Dee problems with covariant argument typing policy are solved by separating inheritance and conform 'i 1'n Getting Class Correctness and System Correctness Equivalent 39 ance. Two kinds of inheritance are considered.
Reference: [8] <author> C. B. Jones, </author> <title> Software development based on formal methods, in System Development and Ada, </title> <editor> eds. A. M. Habermann and U. Montanari, </editor> <booktitle> Lecture Notes in Computer Science No. </booktitle> <volume> 275, </volume> <publisher> Springer Verlag, </publisher> <year> 1987. </year>
Reference-contexts: This is a well known principle of data type refinement <ref> [8] </ref>. On the one hand this is a condition on the types and on the other hand a condition on the statements of the implementations to the pre and postconditions of the specification. <p> of a generic instan-tiation of G is the effective routine definition of the corresponding type template of G, where all occurrences of the formal type parameters of G are replaced by the corresponding actual type parameters of the generic instantiation. 2.4.2.3 Routine Conformance For these definitions see also [5] and <ref> [8] </ref>. <p> D i conforms to C i ( ). 2. C conforms to D. 3. is valid. 4. is valid. 2.4.2.4 Implementability of Routines All pre and postconditions of the effective routine definitions have to be implementable. According to <ref> [8] </ref>, implementable means that is valid. In this definition denotes the set of names of all formal arguments and the name current. <p> All basic notions used in this paper are described elsewhere. Subtyping and bounded type parameters are described in [3]. An overview on the theory behind object-oriented type systems is given in [6]. F-bounded polymorphism is described in [4]. Data refinement, axiomatic specifications, and model oriented specification are defined in <ref> [8] </ref>. In [7] P. Grogono describes the language Dee. In Dee problems with covariant argument typing policy are solved by separating inheritance and conform 'i 1'n Getting Class Correctness and System Correctness Equivalent 39 ance. Two kinds of inheritance are considered.
Reference: [9] <author> Bertrand Meyer, </author> <title> Eiffel: The Language, </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: All problems concerning correctness have a corresponding problem in the formulation of typing rules. The first interpretation of compatibility requires a contravariant typing policy [5]. Eif-fel and languages with a similar type system try to implement the second interpretation by generic classes and by allowing a covariant typing policy <ref> [9] </ref>. Because of the latter, in these languages the correct application of typing rules which only involve one class (class validity) does not imply a correct typing of a complete system built with a library (system validity). This violates the requirements for an incremental library building strategy. <p> In the second scenario we wanted to use an arbitrary but fixed implemen tation of the interface set. We call the first type of compatibility integration compatibility and the second one property compatibility <ref> [9] </ref>. If an interface should specify all functional requirements of its implementations, we should have different interfaces for integration compatibility and property compatibility. <p> For one category of property compatibility this may be done by generic classes. An example is given in figure 7 (from <ref> [9] </ref>). We want to support a company which manages a eet of vehicles and which wants to keep track of driver registration. <p> The strongly typed object-oriented languages Modula-3, Trellis and Simula are statically type-safe because they restrict inheritance such that subtyping is guaranteed. Hence the implementation of property compatibility is not possible in these languages. Eiffel allows a covariant argument typing policy <ref> [9] </ref>. The language is type safe by doing a global data ow analysis each time a system is linked together. The usage of a global data ow analysis already shows that the meaning of a class may not be fully described by its definition.
Reference: [10] <author> Stephen M. Omohundro, </author> <title> The SATHER language, </title> <type> Technical report, </type> <institution> International Computer Science Institute, Berkeley, </institution> <year> 1991. </year>
Reference-contexts: Implicitly, there are also global constraints to get a system to work. Sather also uses a covariant argument typing policy without doing global data ow analysis <ref> [10] </ref>. Thus the language is not type safe. However, the design decisions for Sather are very interesting in the light of this paper.
Reference: [11] <author> Jens Palsberg and Michael J. Schwartzbach, </author> <title> Type Substitution for Object-Oriented Programming, </title> <journal> SIGPLAN Notices (special issue on OOPSLA 90), </journal> <volume> vol. 25, no. 10, </volume> <publisher> ACM, </publisher> <month> October </month> <year> 1990, </year> <pages> pp. 151160. </pages>
Reference-contexts: Property classes are more restrictive than extensions but, on the other hand, they have a stronger logical semantics. Extensions may not be used as bounds for generic type parameters. A totally different approach is taken by J. Palsberg and M. Schwartzbach in <ref> [11] </ref>. They suggest to replace generic classes by type substitutions. The motivation behind this step is the fact that type substitution does not require to fix type parameters during class definition. The user of a class may arbitrarily choose a type of the definition as parameter.
Reference: [12] <author> J. Uhl, S. Drossopoulou, G. Persch, G. Goos, M. Dausmann, G. Winterstein and W. Kirchgssner, </author> <title> An Attribute Grammar for the Semantic Analysis of Ada, </title> <booktitle> Lecture Notes in Computer Science No. </booktitle> <volume> 139, </volume> <publisher> Springer Verlag, </publisher> <year> 1982. </year>
Reference-contexts: Exploiting this idea, the first parameter may be made explicit again. Then we would be able to abstract over the type of the first parameter of each routine. Therefore we have to separate classes form modules. We view modules similar to Ada <ref> [12] </ref> as a collection of types (which are classes in our case), procedures (routines) and (as a speciality in our case) a theory. Modules may be generic, i.e. parameterized by classes. We do not consider generic classes. The definition of SET according to these conventions is shown in figure 8.
References-found: 12

