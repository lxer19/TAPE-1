URL: http://www.cs.unc.edu/~olano/papers/pxflshading/pxflshading.ps.gz
Refering-URL: http://www.cs.unc.edu/~olano/papers/
Root-URL: http://www.cs.unc.edu
Keyword: CR Categories and Subject Descriptors D.3.2 [Language Classifications] Specialized Application Languages; I.3.1 [Computer Graphics] Hardware Architecture; I.3.3 [Computer Graphics] Picture/Image Generation; I.3.6 [Computer Graphics] Methodologies and Techniques; I.3.7 [Computer Graphics] Three-dimensional Graphics and Realism. Additional Keywords real-time image generation, procedural shading, shading language.  
Date: July 1924, 1998) 1  
Note: Proceedings of SIGGRAPH 98 (Orlando, Florida,  Abstract  
Abstract: Over the years, there have been two main branches of computer graphics imagesynthesis research; one focused on interactivity, the other on image quality. Procedural shading is a powerful tool, commonly used for creating high-quality images and production animation. A key aspect of most procedural shading is the use of a shading language, which allows a high-level description of the color and shading of each surface. However, shading languages have been beyond the capabilities of the interactive graphics hardware community. We have created a parallel graphics mult i-computer, PixelFlow, that can render images at 30 frames per second using a shading language. This is the first system to be able to support a shading language in real-time. In this paper, we describe some of the techniques that make this possible. 
Abstract-found: 1
Intro-found: 1
Reference: [Briggs92] <author> Preston Briggs, </author> <title> Register Allocation via Graph Coloring , PhD Dissertation, </title> <institution> Department of Computer Science, Rice University, Houston, Texas, </institution> <year> 1992. </year>
Reference: [Cook84] <author> Robert L . Cook, </author> <title> Shade Trees, </title> <booktitle> Proceedings of SIGGRAPH 84 (Minneapolis, </booktitle> <address> Minnesota, </address> <month> July 2327, </month> <year> 1984). </year> <booktitle> In Computer Graphics , v18n3. ACM SIGGRAPH, </booktitle> <month> July </month> <year> 1984. </year> <pages> pp. 223231. </pages>
Reference-contexts: This allowed them to run multiple shaders on the same scene without having to re-render. Previous uses of deferred shading for interactive graphics systems include [Deering88] and [Ellsworth91]. More recently, easier access to procedural shading capabilit ies has been provided to the graphics programmer . Cooks shade trees <ref> [Cook84] </ref> were the base of most later shading works. He turned simple expressions, describing the shading at a point on the surface, into a parse tree form, which was interpreted. He introduced the name appearance parameters for the parameters that affect the shading calculations.
Reference: [Cook87] <author> Robert L. Cook, </author> <title> The Reyes Image Rendering Architecture, </title> <booktitle> Proceedings of SIGGRAPH 87 (Anaheim, </booktitle> <address> California, </address> <month> July 2731, </month> <year> 1987). </year> <booktitle> In Computer Graphics , v21n4. ACM SIGGRAPH, </booktitle> <month> July </month> <year> 1987. </year> <pages> pp. 95102. </pages>
Reference-contexts: In addition to the shading language, RenderMan also provides a geometry description library (the RenderMan API) and a ge o-metric file format (called RIB). The reference implementation is Pixars PhotoRealistic RenderMan based on the REYES rendering algorithm <ref> [Cook87] </ref>, but other implementations now exist [Slusallek94][Gritz96]. The same application will run on all of these without change. RenderMan effectively hides the details of the implementation.
Reference: [Deering88] <author> Michael Deering, Stephanie Winner, Bic Schediwy, Chris Duffy and Neil Hunt, </author> <title> The Triangle Processor and Normal Vector Shader: A VLSI System for High Performance Graphics, </title> <booktitle> Proceedings of SI G-GRAPH 88 (Atlanta, </booktitle> <address> Georgia, </address> <month> August 15, </month> <year> 1988). </year> <booktitle> In Computer Graphics , v22n4, ACM SIGGRAPH, </booktitle> <month> August </month> <year> 1988. </year> <pages> pp. 2130. </pages>
Reference-contexts: In this technique, the parameters for shading are scan converted for a later shading pass. This allowed them to run multiple shaders on the same scene without having to re-render. Previous uses of deferred shading for interactive graphics systems include <ref> [Deering88] </ref> and [Ellsworth91]. More recently, easier access to procedural shading capabilit ies has been provided to the graphics programmer . Cooks shade trees [Cook84] were the base of most later shading works.
Reference: [Dietz92] <author> Henry G. Dietz, </author> <title> Common Subexpression Induction, </title> <booktitle> Proceedings of the 1992 International Conference on Parallel Processing (Saint Charles, </booktitle> <address> Illinois, </address> <month> August </month> <year> 1992). </year> <pages> pp. 174182. </pages>
Reference-contexts: For a SIMD machine like ours, this would give linear speed improvement with the number of instances we can execute t o-gether. Even more interesting would be to use the techniques of <ref> [Dietz92] </ref> and [Guenter95] to combine code within a shader and between shader instances with differing uniform parameter va l-ues. shader total (uniform + varying) varying only varying with allocation simple brick 171 97 16 fancy brick 239 175 101 ripple reflection 341 193 137 wood planks 216 152 97 Table 4:
Reference: [Ellsworth91] <author> David Ellsworth, </author> <title> Parallel Architectures and Algorithms for Real-time Synthesis of High-quality Images using Deferred Shading. </title> <booktitle> Workshop on Algorithms and Parallel VLSI Architectures (Pont-- Mousson, </booktitle> <address> France, </address> <month> June 12, </month> <year> 1990). </year>
Reference-contexts: In this technique, the parameters for shading are scan converted for a later shading pass. This allowed them to run multiple shaders on the same scene without having to re-render. Previous uses of deferred shading for interactive graphics systems include [Deering88] and <ref> [Ellsworth91] </ref>. More recently, easier access to procedural shading capabilit ies has been provided to the graphics programmer . Cooks shade trees [Cook84] were the base of most later shading works.
Reference: [Eyles97] <author> John Eyles, Steven Molnar, John Poulton, Trey Greer, Anselmo Lastra, Nick England and Lee Westover, PixelFlow: </author> <booktitle> The Realiz a-tion, Proceedings of the 1997 SIGGRAPH/Eurographics Workshop on Graphics Hardware (Los Angeles, </booktitle> <address> California, </address> <month> August 34, </month> <year> 1992). </year> <note> ACM SIGGRAPH, </note> <month> August </month> <year> 1997. </year> <pages> pp. 5768. </pages>
Reference-contexts: The following sections give Proceedings of SIGGRAPH 98 (Orlando, Florida, July 1924, 1998) 5 a brief overview of PixelFlow. For more details, refer to [Molnar92] or <ref> [Eyles97] </ref> 5.1 Low-level View A typical PixelFlow system consists of a host, a number of re n-dering nodes, a number of shad ing nodes, and a frame buffer node (Figure 6a).
Reference: [Gritz96] <author> Larry Gritz and James K. Hahn, BMRT: </author> <title> A Global Illumination Implementation of the RenderMan Standard, </title> <journal> Journal of Graphics Tools , v1n3, </journal> <year> 1996. </year> <pages> pp. 2947. </pages>
Reference: [Guenter95] <author> Brian Guenter, Todd B. Knoblock and Erik Ruf, Specializing Shaders, </author> <booktitle> Proceedings of SIGGRAPH 95 (Los Angeles, </booktitle> <address> California, </address> <month> August 611, </month> <year> 1995). </year> <booktitle> In Computer Graphics Proceedings, Annual Conference Series, ACM SIGGRAPH, </booktitle> <year> 1995. </year> <pages> pp. 343348. </pages>
Reference-contexts: For a SIMD machine like ours, this would give linear speed improvement with the number of instances we can execute t o-gether. Even more interesting would be to use the techniques of [Dietz92] and <ref> [Guenter95] </ref> to combine code within a shader and between shader instances with differing uniform parameter va l-ues. shader total (uniform + varying) varying only varying with allocation simple brick 171 97 16 fancy brick 239 175 101 ripple reflection 341 193 137 wood planks 216 152 97 Table 4: Shader memory
Reference: [Hanrahan90] <author> Pat Hanrahan and Jim Lawson, </author> <title> A Language for Shading and Lighting Calculations, </title> <booktitle> Proceedings of SIGGRAPH 90 (Dallas, </booktitle> <address> Texas, </address> <month> August 610, </month> <year> 1990). </year> <title> In Computer Graphics , v 24n4. </title> <booktitle> ACM SI G-GRAPH, </booktitle> <month> August </month> <year> 1990. </year> <pages> pp. 289298. </pages>
Reference: [Hill97] <author> B. Hill, Th. Roger and F. W. Vorhagen, </author> <title> Comparative Analysis of the Quantization of Color Spaces on the Basis of the CIELAB Color-Difference Formula, </title> <journal> ACM Transactions on Graphics , v16n2. ACM, </journal> <month> April </month> <year> 1997. </year> <pages> pp. 109154. </pages>
Reference-contexts: This format has about 10 7 relative error for the entire range of nu m-bers from 10 -38 to 10 38 . However, for some quantities used in shading this range is overkill (for colors, an 8 to 16 bit fixed-point representation can be sufficient <ref> [Hill97] </ref>). Worse, there are cases where floating-point has too much range but not enough precision. For example, a Mandelbrot fractal shader has an ins a-tiable appetite for precision, but only over the range [2,2] (Figure 4).
Reference: [Lastra95] <author> Anselmo Lastra, Steven Molnar, Marc Olano and Yulan Wang, </author> <title> Real-time Programmable Shading, </title> <booktitle> Proceedings of the 1995 Symp o-sium on Interactive 3D Graphics (Monterey, </booktitle> <address> California, </address> <month> April 912, </month> <year> 1995). </year> <note> ACM SIGGRAPH, </note> <year> 1995. </year> <pages> pp. 5966. </pages>
Reference-contexts: The har d-ware limitations of Pixel-Planes 5 limited the complexity of the shaders, and the low-level nature of the language limited its use. Lastra et. al. <ref> [Lastra95] </ref> presents previous work on the Pi x-elFlow shading implementation. It analyzes results from a Pi x-elFlow simulator for hand-coded shaders and draws a number of conclusions about the hardware requirements for procedural shading. <p> At the time of that paper, the shading language compiler was in its infancy, and we had not addressed many of the issues that make a real-time shading language possible. <ref> [Lastra95] </ref> is the foundation on which we built our shading language. 3 SHADING LANGUAGE A surface shader produces a color for each point on a surface, taking into account the color variations of the surface itself and the lighting effects.
Reference: [Leech98] <author> Jon Leech, </author> <title> OpenGL Extensions and Restrictions for PixelFlow, </title> <type> Technical Report TR98-019, </type> <institution> Department of Computer Science, Un i-versity of North Carolina at Chapel Hill. </institution>
Reference-contexts: It provides about the same capabilities as the RenderMan API, with a similar collection of functions, but with more focus on interactive graphics. By using OpenGL as our base we can easily port applications written for other hardware. We extended OpenGL to support procedural shading <ref> [Leech98] </ref>. We required that the procedural shading extensions have no impact on applications that do not use procedural sha ding. We also endeavored to make them fit the framework and philosophy of OpenGL. Our efforts to extend OpenGL should be readily usable by future real-time shading language systems.
Reference: [MasPar90] <author> MasPar Computer Corporation, </author> <title> MasPar Parallel Application Language (MPL) User Guide, </title> <year> 1990. </year>
Reference-contexts: This same distinction between shared ( uniform ) and SIMD array ( varying ) memory was made by Thinking Machines for the Connection Machine [ThinkingMachines89], though they called them mono and poly , and by MasPar for the MP-1 <ref> [MasPar90] </ref>, though their terms were singular and plural . 6.1.3 Fixed-point We can achieve significant speed improvements by using fixed-point operations for varying computations instead of floating-point. Our pixel processors do not support floating-point in hardware: every floating-point operation is built from basic int e-ger math operations.
Reference: [Max81] <author> N elson L. Max, </author> <title> Vectorized Procedural Models for Natural Te r-rain: Waves and Islands in the Sunset, </title> <booktitle> Proceedings of SIGGRAPH 81 (Dallas, </booktitle> <address> Texas, </address> <month> July </month> <year> 1981). </year> <booktitle> In Computer Graphics , v15n3. ACM SIGGRAPH, </booktitle> <month> August </month> <year> 1981. </year> <pages> pp. 317324. </pages>
Reference-contexts: Section 6 covers our i m-plementation and the optimizations that are done by PixelFlow and the pfman compiler. Finally, Section 7 has some conclusions. 2 RELATED WORK Early forms of programmable shading were accomplished by rewriting the shading code for the renderer (see, for example, <ref> [Max81] </ref>). Whitted and Weimer specifically allowed this in their testbed system [Whitted81]. Their span buffers are an impl e-mentation of a technique now called deferred shading , which we use on PixelFlow. In this technique, the parameters for shading are scan converted for a later shading pass.
Reference: [Molnar92] <author> Steven Molnar, John Eyles and John Poulton, PixelFlow: </author> <title> High-speed Rendering Using Image Composition, </title> <booktitle> Proceedings of SI G-GRAPH 92 (Chicago, </booktitle> <address> Illinois, </address> <month> July 2631, </month> <year> 1992). </year> <booktitle> In Computer Graphics , v26n2. ACM SIGGRAPH, </booktitle> <month> July </month> <year> 1992. </year> <pages> pp. 231240. </pages>
Reference-contexts: The following sections give Proceedings of SIGGRAPH 98 (Orlando, Florida, July 1924, 1998) 5 a brief overview of PixelFlow. For more details, refer to <ref> [Molnar92] </ref> or [Eyles97] 5.1 Low-level View A typical PixelFlow system consists of a host, a number of re n-dering nodes, a number of shad ing nodes, and a frame buffer node (Figure 6a).
Reference: [Muchnick97] <author> Steven Muchnick, </author> <title> Compiler Design and Implementation . Morgan Kaufmann, </title> <address> San Francisco, CA, </address> <year> 1997. </year>
Reference: [Neider93] <author> Jackie Neider, Tom Davis and Mason Woo, </author> <title> OpenGL Programming Guide: the official guide to learning OpenGL release 1 ., Addi-son-Wesley, </title> <year> 1993. </year>
Reference-contexts: Section 2 is a review of the relevant prior work. Section 3 co v-ers features of the pfman shading language, paying particular attention to the ways that it differs from the RenderMan shading language. Section 4 describes our extensions to the OpenGL API <ref> [Neider93] </ref> to support procedural shading. Section 5 gives a brief overview of the PixelFlow hardware. Section 6 covers our i m-plementation and the optimizations that are done by PixelFlow and the pfman compiler. <p> This is a library of graphics functions that the graphics application can call to describe the scene to the renderer. We elected to base our API on OpenGL <ref> [Neider93] </ref> instead of Re n-derMan. OpenGL is a popular API for interactive graphics appl i-cations, supported on a number of graphics hardware platforms. It provides about the same capabilities as the RenderMan API, with a similar collection of functions, but with more focus on interactive graphics.
Reference: [Olano98] <author> Marc Olano, </author> <title> A Programmable Pipeline for Graphics Hardware , PhD Dissertation, </title> <institution> Department of Computer Science, University of North Carolina at Chapel Hill, </institution> <year> 1998. </year>
Reference-contexts: RenderMan also allows other types of procedures, all of which could be implemented on PixelFlow, but have not been. We also do not have derivative functions, an important part of the Re n-derMan shading language. Details on how these features could be implemented on PixelFlow can be found in <ref> [Olano98] </ref> We created a shading language compiler, which hides the d e-tails of our hardware architecture. The compiler also allows us to invisibly do the optimizations necessary to run on our hardware. We found the most useful optimizations to be those that happen automatically.
Reference: [Perlin85] <author> Ken Perlin, </author> <title> An Image Synthesizer, </title> <booktitle> Proceedings of SIGGRAPH 85 (San Francisco, </booktitle> <address> California, </address> <month> July 2226, </month> <year> 1985). </year> <booktitle> In Computer Graphics , v19n3. ACM SIGGRAPH, </booktitle> <month> July </month> <year> 1985. </year> <pages> pp. 287296. </pages>
Reference-contexts: He also proposed an o r-thogonal subdivision of types of programmable functions into displacement, surface shading, light, and atmosphere trees. Perlins image synthesizer extends the simple expressions in Cooks shade trees to a full language with control structures <ref> [Perlin85] </ref>. He also introduced the powerful Perlin noise fun c tion, which produces random numbers with a band-limited fr e-quency spectrum. This style of noise plays a major role in many procedural shaders. The RenderMan shading language [Hanrahan90][Upstill90] further extends the work of Cook and Perlin.
Reference: [Pixar97] <editor> Pixar Animation Studios, </editor> <booktitle> PhotoRealistic RenderMan 3.7 Shading Language Extensions . Pixar animation studios, </booktitle> <month> March </month> <year> 1997. </year>
Reference-contexts: Fixed-point behaves like floating-point where the exponent is a compile-time constant. Small exponents can be interpreted as the number of fractional bits: a two byte integer is fixed&lt;16,0&gt; , while a two byte pure fraction is fixed&lt;16,16&gt; . Like recent versions of the RenderMan shading language <ref> [Pixar97] </ref>, pfman supports arrays of its basic types. However, where RenderMan uses separate types for points, vectors, no r-mals, and colors, pfman uses arrays with transformation attributes . By making each point be an array of floating-point or fixed-point numbers, we can choose the appropriate representation independently for every point.
Reference: [Rhoades92] <author> John Rhoades, Greg Turk, Andrew Bell, Andrei State , Ulrich Neumann and Amitabh Varshney, </author> <title> Real-time procedural textures, </title> <booktitle> Proceedings of the 1992 Symposium on Interactive 3D Graphics (Cambridge, </booktitle> <address> Massachusetts, March 29April 1, </address> <year> 1992). </year> <note> In Computer Graphics special issue. ACM SIGGRAPH, </note> <month> March </month> <year> 1992. </year> <pages> pp. 95100. </pages>
Reference-contexts: Previous efforts to support user-written procedural shading on a real-time graphics system are much more limited. The evol u-tion of graphics hardware is only just reaching the point where procedural shading is practical. The only implementation to date was Pixel-Planes 5, which supported a simple form of procedural shading <ref> [Rhoades92] </ref>. The language used by this system was quite low level. It used an assembly-like interpreted language with simple operations like copy, add, and multiply and a few more complex operations like a Perlin noise function.
Reference: [Slusallek94] <author> Philipp Slusallek, Thomas Pflaum and Hans-Peter Seidel, </author> <title> Implementing RenderManPractice, Problems and Enhancements, </title> <booktitle> Proceedings of Eurographics 94. In Computer Graphics Forum , v13n3, </booktitle> <year> 1994. </year> <pages> pp. 443454. </pages>
Reference: [ThinkingMachines89] <institution> Thinking Machines Corporation, Connection M a-chine Model CM-2 Technical Summary . Thinking Machines Corp oration, </institution> <note> Version 5.1, </note> <month> May </month> <year> 1989. </year>
Reference-contexts: They are fast and efficient because their storage and operations are replicated across the SIMD array. This same distinction between shared ( uniform ) and SIMD array ( varying ) memory was made by Thinking Machines for the Connection Machine <ref> [ThinkingMachines89] </ref>, though they called them mono and poly , and by MasPar for the MP-1 [MasPar90], though their terms were singular and plural . 6.1.3 Fixed-point We can achieve significant speed improvements by using fixed-point operations for varying computations instead of floating-point.
Reference: [Upstill90] <author> Steve Upstill, </author> <note> The RenderMan Companion , Addison-Wesley , 1990. </note>
Reference-contexts: Procedural shading is quite popular in the production industry where it is commonly used for rendering in feature films and commercials. The best known examples of this have been re n-dered using Pixars PhotoRealistic RenderMan software <ref> [Upstill90] </ref>. A key aspect of RenderMan is its shading language. The shading language provides a high-level description of each procedural shader. <p> Such a hand-optimized shader would no longer be portable, and performing the optimization would require considerable understanding of the PixelFlow internals normally hidden by the shading language. Not surprisingly, no one has done this yet. 4 API The RenderMan standard <ref> [Upstill90] </ref> defines not only the sha ding language, but also a graphics application program interface (API). This is a library of graphics functions that the graphics application can call to describe the scene to the renderer. We elected to base our API on OpenGL [Neider93] instead of Re n-derMan.
Reference: [Whitted81] <author> T . Whitted and D . M. Weimer, </author> <title> A software testbed for the development of 3-D raster graphics systems, </title> <booktitle> Proceedings of SI G-GRAPH 81 (Dallas, </booktitle> <address> Texas, </address> <month> July </month> <year> 1981). </year> <booktitle> In Computer Graphics , v15n3. ACM SIGGRAPH, </booktitle> <month> August </month> <year> 1981. </year> <pages> pp. 271277. </pages>
Reference-contexts: Finally, Section 7 has some conclusions. 2 RELATED WORK Early forms of programmable shading were accomplished by rewriting the shading code for the renderer (see, for example, [Max81]). Whitted and Weimer specifically allowed this in their testbed system <ref> [Whitted81] </ref>. Their span buffers are an impl e-mentation of a technique now called deferred shading , which we use on PixelFlow. In this technique, the parameters for shading are scan converted for a later shading pass.
References-found: 26

