URL: http://www.cms.dmu.ac.uk/~xdl/publication/compsac971-t.ps.gz
Refering-URL: http://www.cms.dmu.ac.uk/STRL/monographs/mono1.html
Root-URL: 
Email: Email: fxdl, hjy, hzedang@dmu.ac.uk  
Title: Formal Methods For The Re-Engineering of Computing Systems  
Author: X. Liu, H. Yang and H. Zedan 
Keyword: formal methods, re-engineering, wide spectrum language, real-time systems, refinement, reverse engineering, logic.  
Note: Contents  
Address: England  
Affiliation: Software Technology Research Laboratory De Montfort University,  
Abstract: We present a short review of formal methods and their use in the re-engineering of computing systems. The paper considers five classes of formal notations and theories, namely state/model-based, logic-based, algebraic-based, process algebra and net-based formalisms together with combined formalisms. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abrial, J. R., Schuman, S. A. and Meyer, B., </author> <title> Specification Language Z, </title> <publisher> Massachusetts Computer Associates Inc., </publisher> <address> Boston, </address> <year> 1979. </year>
Reference-contexts: Formal methods allows system functionalities to be precisely specified whilst structured methods permit the precise specification of systems structure. However, recently, there has been a substantial research activities to * integrate formal and structured methods, for example the formal specification language Z <ref> [1] </ref> [60]has been integrated with the structured method known as SSADM and * extend some formal methods allowing the treatment of non-functional requirements such as timing and probability [10,11,27,46,47,58]. <p> In this approach, there is no explicit representation of concurrency. Non-functional requirements (such as temporal requirement) could be expressed in some cases. Examples * Z <ref> [1] </ref> [60]. With the first version proposed in 1979, the Z notion is based on predicate calculus and Zermelo Fraenkel set theory.
Reference: [2] <author> Alur, R. and Dill, D. L., </author> <title> "Automata for Modeling Real-Time Systems", In M.S. </title> <editor> Paterson editor, </editor> <booktitle> ICALP 90: Automata, Languages and Programming, Lecture Notes in Computer Science, </booktitle> <year> 1990. </year>
Reference-contexts: Statecharts [31] provides an abstraction mechanism based on finite state machine. It represents an improved version of the structured methods. A graphic tool called "Statemate" <ref> [2] </ref> exists to implement the formalism. Methods similar to that of Statecharts may be found in [23].
Reference: [3] <author> Baeten, J. C. M. and Bergstra, J. A., </author> <title> "Real Time Process Algebra", </title> <journal> Formal Aspects of Computing, </journal> <volume> Vol. 3, </volume> <pages> pp. </pages> <month> 142-188 (Feb </month> <year> 1991). </year>
Reference-contexts: CCS concen-trates on a minimal set of operators needed for the full expression of non-deterministic concurrency and its resulting equivalences. CCS is not a real-time formalism either. Some extensions of CCS with real-time feature have been developed, such TCCS, SCCS, and TPCCS. * ACP [6] <ref> [3] </ref>. Algebra of Communicating Processes (ACP) was proposed by J.A. Bergstra in 1984. Until now, a rather large variety of ACP has been proposed, such as Real Time ACP (ACP ), Discrete Time ACP. ACP is also an action-based process algebra, which may be viewed as a modification of CCS.
Reference: [4] <author> Bennett, K. H., Bull, T. and Yang, H., </author> <title> "A Transformation System for Maintenance | Turning Theory into Practice", </title> <booktitle> IEEE Conference on Software Maintenance-1992, </booktitle> <address> Orlando, Florida, </address> <month> November, </month> <year> 1992. </year>
Reference: [5] <author> Benveniste, A. and Harter, P. K., </author> <title> "Proving Real-Time Properties of Programs with Temporal Logics", </title> <booktitle> Proceedings of ACM SIGOPS 8th annual ACM symposium on Operating systems Principles, </booktitle> <month> December </month> <year> 1981. </year>
Reference-contexts: In real-time temporal logics, quantitative properties can also be expressed such as periodicity, real-time response (deadline), and delays. Early approaches to real-time temporal 7 logics were reported in [51] <ref> [5] </ref>. Since then, real-time logics have been explored in great detail. * RTTL [49] [50]. RTTL (Real-Time Temporal Logic) uses a distinguished temporal domain, the ESM (Extended State Machine) state variables, and the set of ESM transitions to form temporal formula.
Reference: [6] <author> Bergstra, J. A. and Klop, J. W., </author> <title> "Process Algebra for Synchronous Communication", </title> <journal> Information and Control, </journal> <volume> Vol. 60, </volume> <pages> pp. </pages> <month> 109-137 (Jan/Feb/Mar </month> <year> 1984). </year>
Reference-contexts: CCS concen-trates on a minimal set of operators needed for the full expression of non-deterministic concurrency and its resulting equivalences. CCS is not a real-time formalism either. Some extensions of CCS with real-time feature have been developed, such TCCS, SCCS, and TPCCS. * ACP <ref> [6] </ref> [3]. Algebra of Communicating Processes (ACP) was proposed by J.A. Bergstra in 1984. Until now, a rather large variety of ACP has been proposed, such as Real Time ACP (ACP ), Discrete Time ACP.
Reference: [7] <author> Berthomieu, B. and Diaz, M., </author> <title> "Modeling and Verification of Time Dependent Systems Using Timed Petri Nets", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 17, </volume> <pages> pp. </pages> <month> 259-273 (March </month> <year> 1991). </year>
Reference-contexts: Petri nets provide a graphic representation with formal semantics of system behaviour. Until now, a large amount of vanities of Petri Net Theory has been proposed. Generally, petri nets can be classified into ordinary (classic) petri nets and timed petri nets. * Timed Petri Net [43] [21] <ref> [7] </ref> [8] [38] [53]. Petri Net theory was the first concurrent formalisms to deal with real-time. Two basic timed versions of Petri nets have been introduced: Timed petri Nets [124] and Time Petri Nets [43]. Both have been used in recent work [21] [7] [8] [38] [53]. <p> nets. * Timed Petri Net [43] [21] <ref> [7] </ref> [8] [38] [53]. Petri Net theory was the first concurrent formalisms to deal with real-time. Two basic timed versions of Petri nets have been introduced: Timed petri Nets [124] and Time Petri Nets [43]. Both have been used in recent work [21] [7] [8] [38] [53]. There are two questions that arise when time is introduced to net theory: (i) the location of the time delays (at places or transitions) and (ii) the type of delay (fixed delays, intervals or stochastic delays).
Reference: [8] <author> Billington, J., Wheeler, G. R. and Wilbur-Ham, M. C., "PROTEAN: </author> <title> a High-level Petri Net Tool for the Specification and Verification of Communication Protocol", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 14, </volume> <pages> pp. </pages> <month> 301-316 (March </month> <year> 1988). </year> <month> 21 </month>
Reference-contexts: Petri nets provide a graphic representation with formal semantics of system behaviour. Until now, a large amount of vanities of Petri Net Theory has been proposed. Generally, petri nets can be classified into ordinary (classic) petri nets and timed petri nets. * Timed Petri Net [43] [21] [7] <ref> [8] </ref> [38] [53]. Petri Net theory was the first concurrent formalisms to deal with real-time. Two basic timed versions of Petri nets have been introduced: Timed petri Nets [124] and Time Petri Nets [43]. Both have been used in recent work [21] [7] [8] [38] [53]. <p> * Timed Petri Net [43] [21] [7] <ref> [8] </ref> [38] [53]. Petri Net theory was the first concurrent formalisms to deal with real-time. Two basic timed versions of Petri nets have been introduced: Timed petri Nets [124] and Time Petri Nets [43]. Both have been used in recent work [21] [7] [8] [38] [53]. There are two questions that arise when time is introduced to net theory: (i) the location of the time delays (at places or transitions) and (ii) the type of delay (fixed delays, intervals or stochastic delays).
Reference: [9] <author> Bjrner, D. and Jones, C. B., </author> <title> Formal Specification and Software Development, </title> <publisher> Prentice-Hall Inter--national, </publisher> <year> 1982. </year>
Reference-contexts: A Z specification is written in terms of "schemas", each of which contains a signature part which declares items of interest and a predicate part which places a logical constraint on them. * VDM [35] <ref> [9] </ref> [34]. VDM (the Vienna Development Method) is a formal method for rigorous computing system development. It is similar to Z in most aspects, although not as popular as Z. VDM support model composition and decomposition, which facilitate both the forward and reverse engineering a lot.
Reference: [10] <author> Cau, A. and Zedan, H., </author> <title> "Refining Interval Temporal Logic specifications", </title> <type> Draft Paper, </type> <month> November </month> <year> 1996. </year>
Reference-contexts: The development of systems in this case is achieved by a set of correctness preserving refinement steps. Examples of these form are TAM [58] and the Refinement Calculus [57]. Examples * ITL [11] [47] [46] <ref> [10] </ref>. ITL (Interval Temporal Logic) has been developed in [11] [48]. This kind of logic is based on intervals of time, thought of as representing finite chunks of system behaviour. An interval may be divided into two contiguous subintervals, thus leading to chop operator. * Duration Calculus [12] [13]. <p> ITL avoids the proliferation of time variables in specifications, as do all temporal logics. ITL is sufficiently general to express any discrete computation. An executable subset of ITL, called Tempura [46], is well developed. Zedan and Cau proposed a set of new refinement techniques of ITL <ref> [10] </ref>, which gives ITL a strong ability to describe all the popular possible features of real-time systems. Since ITL has an executable subset Tempura, its verification and simulation can be largely facilitated. The development method of ITL fits popular re-engineering methodologies well.
Reference: [11] <author> Cau, A., Zedan, H., Coleman, N. and Moszkowski, B., </author> <title> "Using ITL and Tempura for Large Scale Specification and Simulation", </title> <booktitle> Proceedings of 4th EUROMICRO Workshop on Parallel and Distributed Processing, IEEE, </booktitle> <address> Braga, Portugal, </address> <year> 1996. </year>
Reference-contexts: Logic can be augmented with some concrete programming constructs to obtain what is known as wide-spectrum formalism. The development of systems in this case is achieved by a set of correctness preserving refinement steps. Examples of these form are TAM [58] and the Refinement Calculus [57]. Examples * ITL <ref> [11] </ref> [47] [46] [10]. ITL (Interval Temporal Logic) has been developed in [11] [48]. This kind of logic is based on intervals of time, thought of as representing finite chunks of system behaviour. <p> The development of systems in this case is achieved by a set of correctness preserving refinement steps. Examples of these form are TAM [58] and the Refinement Calculus [57]. Examples * ITL <ref> [11] </ref> [47] [46] [10]. ITL (Interval Temporal Logic) has been developed in [11] [48]. This kind of logic is based on intervals of time, thought of as representing finite chunks of system behaviour. An interval may be divided into two contiguous subintervals, thus leading to chop operator. * Duration Calculus [12] [13].
Reference: [12] <author> Chaochen, Z., Hoare, C. A. R. and Ravn, A. P., </author> <title> "A Calculua of Durations", </title> <journal> Information Processing Letters, </journal> <volume> Vol. 40, </volume> <pages> pp. </pages> <month> 269-276 (05 </month> <year> 1991). </year>
Reference-contexts: ITL (Interval Temporal Logic) has been developed in [11] [48]. This kind of logic is based on intervals of time, thought of as representing finite chunks of system behaviour. An interval may be divided into two contiguous subintervals, thus leading to chop operator. * Duration Calculus <ref> [12] </ref> [13]. Duration Calculus was introduced in [12] as a logic to specify and reason about requirements for real-time systems. It is an extension of Interval Temporal Logic where one can reason about integrated constraints over time-dependent and Boolean valued states without explicit mention of absolute time. <p> This kind of logic is based on intervals of time, thought of as representing finite chunks of system behaviour. An interval may be divided into two contiguous subintervals, thus leading to chop operator. * Duration Calculus <ref> [12] </ref> [13]. Duration Calculus was introduced in [12] as a logic to specify and reason about requirements for real-time systems. It is an extension of Interval Temporal Logic where one can reason about integrated constraints over time-dependent and Boolean valued states without explicit mention of absolute time.
Reference: [13] <author> Chaochen, Z., Ravn, A. P. and Hansen, M. R., </author> <title> "An Extended Duration Calculus for Hybris Systems", Hybrid Systems, R.L. </title> <editor> Grossman, A. Nerode, A. P. Ravn. H. Rischel(Eds.), </editor> <year> 1993. </year>
Reference-contexts: ITL (Interval Temporal Logic) has been developed in [11] [48]. This kind of logic is based on intervals of time, thought of as representing finite chunks of system behaviour. An interval may be divided into two contiguous subintervals, thus leading to chop operator. * Duration Calculus [12] <ref> [13] </ref>. Duration Calculus was introduced in [12] as a logic to specify and reason about requirements for real-time systems. It is an extension of Interval Temporal Logic where one can reason about integrated constraints over time-dependent and Boolean valued states without explicit mention of absolute time.
Reference: [14] <author> Cheng, B. H. C. and Gannod, G. C., </author> <title> "Abstraction of Formal Specifications from Program Code", </title> <booktitle> Proceedings for the 3rd International Conference on Tools for Artificial Intelligence, </booktitle> <year> 1991. </year>
Reference-contexts: These two features make Hoare Logic a suitable means in the first stage of reverse engineering, i.e. from source code program 6 to an abstraction at very low level. Some research has been done in this area, such as the development of the reverse engineering tool AutoSpec <ref> [14] </ref> [24]. There is no real-time feature in Hoare Logic. Some extension can be added to make Hoare Logic more suitable for real-time domain. A Real-time Hoare Logic has been proposed [30]. Hoare Logic is one of the mathematical pillars for program verification and formal methods.
Reference: [15] <author> Chllas, B. F., </author> <title> Modal Logic: An Introduction, </title> <publisher> Cambridge University Press, </publisher> <year> 1980. </year>
Reference-contexts: By using the semantics of predicate logic and other suitable formal logics, WP-Calculus has been proven to be a formalism suitable for reverse engineering of source code, especially at the low abstraction levels. * Modal Logic [42] <ref> [15] </ref>. Modal logic is the study of context-dependent properties such as necessity and possibility. In modal logic, the meaning of expressions depends on an implicit context, abstracted away from the object language.
Reference: [16] <author> Chu, W. C. and Yang, H., </author> <title> "A Formal Method for Software Maintenance", </title> <booktitle> IEEE International Conference on Software Maintenance (ICSM'96), </booktitle> <address> Monterey, CA , November 1996. </address>
Reference: [17] <author> Clarke, E., Emerson, E. A. and Sistla, A. P., </author> <title> "Automatic Verification of Finite Concurrent Systems Using Temporal Logic Specifications: A Practical Approach", </title> <booktitle> Proceedings of the 10th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1983. </year>
Reference-contexts: Probabilities are introduced by allowing two types of transitions, one labeled with actions and the other labeled with probabilities. The semantics of TPCTL is defined over the reactive transitions of TPCCS processes. TPCTL is a logic essentially extending the branching time modalities of CTL <ref> [17] </ref> with time and probabilities. Since formulas are interpreted over TPCCS processes, which are observed through actions that label transitions, the semantics of TPCTL is defined in terms of transitions rather than states.
Reference: [18] <author> Dijkstra, E. W., </author> <title> A Discipline of Programming, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1976, </year> <note> ISBN 0-13-215871-X. </note>
Reference-contexts: A Real-time Hoare Logic has been proposed [30]. Hoare Logic is one of the mathematical pillars for program verification and formal methods. Hoare Logic and its variants are used in numerous formal methods tools. * WP-Calculus <ref> [18] </ref>. Weakest Precondition Calculus was first proposed by E. W. Dijkstra in 1976. A precondition describes the initial state of a program, and a postcondition describes the final state.
Reference: [19] <author> Dijkstra, E. W. and Scholten, C. S., </author> <title> Predicate Calculus and Program Semantics, </title> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Several rather large-scale case studies have shown that Duration Calculus provides a high level of abstraction for both expressing and reasoning about about specifications. * Hoare Logic <ref> [19] </ref>. Hoare Logic has a long history, it may be viewed as an extension of First-order Predicate Calculus [19] that includes inference rules for reasoning about programming language constructs. Hoare Logic provides a means of demonstrating that a program is consistent with its specification. <p> Several rather large-scale case studies have shown that Duration Calculus provides a high level of abstraction for both expressing and reasoning about about specifications. * Hoare Logic <ref> [19] </ref>. Hoare Logic has a long history, it may be viewed as an extension of First-order Predicate Calculus [19] that includes inference rules for reasoning about programming language constructs. Hoare Logic provides a means of demonstrating that a program is consistent with its specification. Hoare Logic is not capable of specifying a system at high levels, however, it has distinct advantages in the low level specifications.
Reference: [20] <author> Eijk, P. H. J. van, Vissers, C. A. and Diaz, M., </author> <title> The Formal Description Technique LOTOS, </title> <publisher> Elsevier Science Publishers, </publisher> <year> 1989. </year>
Reference-contexts: Since LOTOS has an operational semantics, it is possible to implement these semantics in an interpreter. LOTOS has "a number of" various support tools, which are although not mature or narrow-aspected, do have some successful points <ref> [20] </ref>. LOTOS does not support real-time specifications. Although a Timed LOTOS has been proposed, it is not proven a suitable formalism for real-time systems. LOTOS has problems in specifying distributed systems it does not support dynamic reconfiguration which is an important and interesting characteristics in those systems.
Reference: [21] <author> Etessami, F. S. and Hura, G. S., </author> <title> "Rule-based Design Methodology for Solving Control Problems", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 17, </volume> <pages> pp. </pages> <month> 274-282 (March </month> <year> 1991). </year>
Reference-contexts: Petri nets provide a graphic representation with formal semantics of system behaviour. Until now, a large amount of vanities of Petri Net Theory has been proposed. Generally, petri nets can be classified into ordinary (classic) petri nets and timed petri nets. * Timed Petri Net [43] <ref> [21] </ref> [7] [8] [38] [53]. Petri Net theory was the first concurrent formalisms to deal with real-time. Two basic timed versions of Petri nets have been introduced: Timed petri Nets [124] and Time Petri Nets [43]. Both have been used in recent work [21] [7] [8] [38] [53]. <p> petri nets. * Timed Petri Net [43] <ref> [21] </ref> [7] [8] [38] [53]. Petri Net theory was the first concurrent formalisms to deal with real-time. Two basic timed versions of Petri nets have been introduced: Timed petri Nets [124] and Time Petri Nets [43]. Both have been used in recent work [21] [7] [8] [38] [53]. There are two questions that arise when time is introduced to net theory: (i) the location of the time delays (at places or transitions) and (ii) the type of delay (fixed delays, intervals or stochastic delays).
Reference: [22] <author> Fencott, C., </author> <title> Formal Methods for Concurrency, </title> <publisher> International Thomson Publishing Company, </publisher> <address> ISBN 1-85032-173-6, </address> <year> 1996. </year>
Reference-contexts: It is a formalism similar to CSP. CCS is also suitable for distributed and concurrent systems. At present, several variations of CCS has been developed, which forms a CCS family. CCS family includes CCS, CCS+, CCS*, SCCS, TCCS and TPCCS <ref> [22] </ref>. Two underlying concepts of CCS are agents and actions. A CCS model consists of a set of communicating processes (agents in CCS terminology). CCS adopts operational semantics. CCS is a successful formalism to build system models with respect to concurrency and distribution.
Reference: [23] <author> Gabrielian, A. and Franklin, M. K., </author> <title> "State-based Specification of Complex Real-time Systems", </title> <booktitle> Proceedings of the 9th Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1988. </year>
Reference-contexts: Statecharts [31] provides an abstraction mechanism based on finite state machine. It represents an improved version of the structured methods. A graphic tool called "Statemate" [2] exists to implement the formalism. Methods similar to that of Statecharts may be found in <ref> [23] </ref>. Statecharts have been proved to be at least as expressive as state machines, and the succinct justification for them is provided by the following "equation": Statecharts = state-transitions + depth + orthogonality + broadcast communication. Statecharts provides an abstraction mechanism based on finite state machine.
Reference: [24] <author> Gannod, C. and Cheng, B. H. C., </author> <title> "Strongest Postcondition Semantics as a Basis for Reverse Engineering", </title> <booktitle> Proc. of IEEE Working Conference on Reverse Engineering, </booktitle> , <address> Toronto, Ontario, </address> <month> July, </month> <year> 1995. </year>
Reference-contexts: These two features make Hoare Logic a suitable means in the first stage of reverse engineering, i.e. from source code program 6 to an abstraction at very low level. Some research has been done in this area, such as the development of the reverse engineering tool AutoSpec [14] <ref> [24] </ref>. There is no real-time feature in Hoare Logic. Some extension can be added to make Hoare Logic more suitable for real-time domain. A Real-time Hoare Logic has been proposed [30]. Hoare Logic is one of the mathematical pillars for program verification and formal methods.
Reference: [25] <author> Goguen, J. and Tardo, J., </author> <title> "An Introduction to OBJ: A Language for Writing and Testing Software Specifications,", </title> <editor> In Marvin Zelkowitz editor, </editor> <booktitle> Specification of Reliable Software, </booktitle> <year> 1979, </year> <note> Reprinted by Addison Wesley in 1985, `Specification Techniques', p391-420. </note>
Reference-contexts: Similar to the model-vased approach, no explicit representation of concurrency. Examples * OBJ <ref> [25] </ref>. OBJ is a wide spectrum first-order functional language that is rigorously based on equational logic. This semantics basis supports a declarative, specificational style, fa cilitates program verification, and allows OBJ to be used as a theorem prover. * LARCH [26]. <p> The shared language includes specification-building operations inspired by those in CLEAR, 10 although these are viewed as purely syntactic operations on lists of axioms rather than as semantically non-trivial as in CLEAR. Sample Description OBJ is used as a sample here. OBJ <ref> [25] </ref> is a broad spectrum algebraic specification/programming language based on order sorted equational logic. It is a specification language in which an algebra is defined using objects. Objects are carrier sets along with operations, and equational theories which are treated by the OBJ interpreter as re-write axioms.
Reference: [26] <author> Guttag, J. and Horning, J., </author> <title> Larch: Languages and Tools for Formal Specification, </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Examples * OBJ [25]. OBJ is a wide spectrum first-order functional language that is rigorously based on equational logic. This semantics basis supports a declarative, specificational style, fa cilitates program verification, and allows OBJ to be used as a theorem prover. * LARCH <ref> [26] </ref>. The Larch family of algebraic specification languages was developed at MIT and Xerox PARC to support the productive use of formal specifications in programming.
Reference: [27] <author> Hansson, H. A., </author> <title> "Time and Probability in Formal Design of Distributed Systems", Real-Time Safety Critical Systems Series, </title> <booktitle> Vol. </booktitle> <month> 2 </month> <year> (1994). </year>
Reference-contexts: RTL has been used with some success in industrial applications and it is also being used in a major IBM project called "ORE" which is integrating RTL with a real-time programming language. There is a feeling of confidence with RTL due to its pragmatic nature. * TPCTL <ref> [27] </ref>. Timed Probabilistic Computation Tree Logic (TPCTL deals with real-time constraints and reliability. Formulas of TPCTL are interpreted over a discrete time extension of Milner's Calculus of Communication Systems called TPCCS. Probabilities are introduced by allowing two types of transitions, one labeled with actions and the other labeled with probabilities. <p> For example, in the process where there is concurrent composition of two WAIT processes, the result is a process that waits for the maximum of two delays. There exist no tools for the manipulation of specifications written in TCSP. * TPCCS <ref> [27] </ref>. Timed Probabilistic Calculus of Communicating Systems (TPCCS) [27] is essentially an extension of Milner's CCS with discrete time and probabilities. To increase the description ability, a logic named Timed Probabilistic Computation Tree Logic (TPCTL) is proposed to describe the logic of and between TPCCS processes. <p> For example, in the process where there is concurrent composition of two WAIT processes, the result is a process that waits for the maximum of two delays. There exist no tools for the manipulation of specifications written in TCSP. * TPCCS <ref> [27] </ref>. Timed Probabilistic Calculus of Communicating Systems (TPCCS) [27] is essentially an extension of Milner's CCS with discrete time and probabilities. To increase the description ability, a logic named Timed Probabilistic Computation Tree Logic (TPCTL) is proposed to describe the logic of and between TPCCS processes. <p> A verification method for automatically proving that a system described in TPCCS satisfies properties formulated in TPCTL, is also well defined <ref> [27] </ref>. The main advantage of TPCCS is that it has a powerful description ability for real-time distributed systems. TPCCS can reason about both time and probabilities in distributed systems.
Reference: [28] <author> Hoare, C. A. R., </author> <title> Communicating Sequential Processes, </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1985. </year>
Reference-contexts: System behaviour is represented by constraints on all allowable observable communication between processes. Examples * CSP [29] <ref> [28] </ref>. The Communicating Sequential Processes (CSP) formal specification notation for concurrent systems was first introduced in [29]. Since this original proposal did not include a proof method, a complete version of CSP was proposed in [28]. * CCS [45]. Calculus of Communicating Systems (CCS) was proposed by Milner in 1989. <p> Examples * CSP [29] <ref> [28] </ref>. The Communicating Sequential Processes (CSP) formal specification notation for concurrent systems was first introduced in [29]. Since this original proposal did not include a proof method, a complete version of CSP was proposed in [28]. * CCS [45]. Calculus of Communicating Systems (CCS) was proposed by Milner in 1989. It is a formalism similar to CSP. CCS is also suitable for distributed and concurrent systems. At present, several variations of CCS has been developed, which forms a CCS family.
Reference: [29] <author> Hoare, C. A. R., </author> <title> "Communicating Sequential Processes", </title> <journal> Communication of ACM , Vol. </journal> <volume> 21, </volume> <pages> pp. </pages> <month> 666-677 (08 </month> <year> 1978). </year>
Reference-contexts: System behaviour is represented by constraints on all allowable observable communication between processes. Examples * CSP <ref> [29] </ref> [28]. The Communicating Sequential Processes (CSP) formal specification notation for concurrent systems was first introduced in [29]. Since this original proposal did not include a proof method, a complete version of CSP was proposed in [28]. * CCS [45]. <p> System behaviour is represented by constraints on all allowable observable communication between processes. Examples * CSP <ref> [29] </ref> [28]. The Communicating Sequential Processes (CSP) formal specification notation for concurrent systems was first introduced in [29]. Since this original proposal did not include a proof method, a complete version of CSP was proposed in [28]. * CCS [45]. Calculus of Communicating Systems (CCS) was proposed by Milner in 1989. It is a formalism similar to CSP. CCS is also suitable for distributed and concurrent systems.
Reference: [30] <author> Hooman, J., </author> <title> "Specification and Compositional Verification of Real-Time Systems", </title> <type> PhD Thesis, </type> <address> Eind-hoven, the Netherlands, </address> <year> 1991. </year> <month> 22 </month>
Reference-contexts: Some research has been done in this area, such as the development of the reverse engineering tool AutoSpec [14] [24]. There is no real-time feature in Hoare Logic. Some extension can be added to make Hoare Logic more suitable for real-time domain. A Real-time Hoare Logic has been proposed <ref> [30] </ref>. Hoare Logic is one of the mathematical pillars for program verification and formal methods. Hoare Logic and its variants are used in numerous formal methods tools. * WP-Calculus [18]. Weakest Precondition Calculus was first proposed by E. W. Dijkstra in 1976.
Reference: [31] <author> Hooman, J., Ramesh, S. and Roever, W. P. de, </author> <title> "A Compositional Semantics for Statecharts", Tech--nical Report, </title> <booktitle> The Netherland, </booktitle> <year> 1989. </year>
Reference-contexts: Both a lower and an upper bound are associated with each transition in a TPN. A state in the reachability graph is a tuple consisting of a marking, and a vector of possible firing intervals of enabled transitions in that marking. * Statecharts <ref> [31] </ref>. Statecharts [31] provides an abstraction mechanism based on finite state machine. It represents an improved version of the structured methods. A graphic tool called "Statemate" [2] exists to implement the formalism. Methods similar to that of Statecharts may be found in [23]. <p> Both a lower and an upper bound are associated with each transition in a TPN. A state in the reachability graph is a tuple consisting of a marking, and a vector of possible firing intervals of enabled transitions in that marking. * Statecharts <ref> [31] </ref>. Statecharts [31] provides an abstraction mechanism based on finite state machine. It represents an improved version of the structured methods. A graphic tool called "Statemate" [2] exists to implement the formalism. Methods similar to that of Statecharts may be found in [23].
Reference: [32] <author> ISO, </author> <title> "Information Systems Processing|Open Systems Interconnection|LOTOS", </title> <type> Technical Report, </type> <year> 1987. </year>
Reference-contexts: However, ACP is an executable formalism. ACP is equipped with a process graph semantics, and adopts bisimulation proof system. ACP allows a variety of communication paradigms, including ternary communication, through the choice of the communication function. * LOTOS <ref> [32] </ref> [39]. LOTOS (Language Of Temporal Ordering Specification) was developed to define implementation-independent formal standards of OSI services and protocols. LO-TOS has two very clearly separated parts. The first part provides a behavioural model derived from process algebra, principally from CCS but also from CSP. <p> LOTOS has formally defined syntax, static semantics and dynamic semantics. The static semantics are defined by an attributed grammar <ref> [32] </ref> and the dynamic semantics are described operationally in terms of inference rules. Since LOTOS has an operational semantics, it is possible to implement these semantics in an interpreter. LOTOS has "a number of" various support tools, which are although not mature or narrow-aspected, do have some successful points [20].
Reference: [33] <author> Jahanian, F. and Mok, A., </author> <title> "Safety Analysis of Timing Properties in Real-Time Systems", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. </volume> <month> 12 (09 </month> <year> 1986). </year>
Reference-contexts: This flexibility may result in "cleaner" specifications. No special development method is proposed in RTTL or required by RTTL. If applied to reverse engineering area, RTTL has a flexibility to fit different methodologies. * RTL <ref> [33] </ref>. RTL [33] is a real-time logic with four basic concepts: actions which may be composite or primitive, state predicates which provide assertions regarding the physical system state, events which are markers on the (sparse) time line, and timing constraints which provide assertions about the timing of events. <p> This flexibility may result in "cleaner" specifications. No special development method is proposed in RTTL or required by RTTL. If applied to reverse engineering area, RTTL has a flexibility to fit different methodologies. * RTL <ref> [33] </ref>. RTL [33] is a real-time logic with four basic concepts: actions which may be composite or primitive, state predicates which provide assertions regarding the physical system state, events which are markers on the (sparse) time line, and timing constraints which provide assertions about the timing of events.
Reference: [34] <author> Jones, C. B., </author> <title> Software Development: A Rigorous Approach, </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1980. </year>
Reference-contexts: A Z specification is written in terms of "schemas", each of which contains a signature part which declares items of interest and a predicate part which places a logical constraint on them. * VDM [35] [9] <ref> [34] </ref>. VDM (the Vienna Development Method) is a formal method for rigorous computing system development. It is similar to Z in most aspects, although not as popular as Z. VDM support model composition and decomposition, which facilitate both the forward and reverse engineering a lot.
Reference: [35] <author> Jones, C. B., </author> <title> Systematic Software Development Using VDM, </title> <publisher> Prentice-Hall International, Inc., </publisher> <address> Lon-don, </address> <year> 1986. </year>
Reference-contexts: A Z specification is written in terms of "schemas", each of which contains a signature part which declares items of interest and a predicate part which places a logical constraint on them. * VDM <ref> [35] </ref> [9] [34]. VDM (the Vienna Development Method) is a formal method for rigorous computing system development. It is similar to Z in most aspects, although not as popular as Z. VDM support model composition and decomposition, which facilitate both the forward and reverse engineering a lot.
Reference: [36] <author> Lano, K. C. and Haughton, H. P., </author> <title> "Formal Development in B", </title> <journal> Information and Software Technology, </journal> <volume> Vol. 37, </volume> <pages> pp. </pages> <month> 303-316 (June </month> <year> 1995). </year>
Reference-contexts: Time is not a part of VDM notation. When trying to apply VDM to real-time domain, novel features have to be added to VDM. VDM also keeps developing: VDM ++ , as a new version of VDM integrated with object-oriented idea, is a rather mature product now. * B-Method <ref> [36] </ref> [37] [62]. The B-method uses the Abstract Machine Notation to support the description of the target systems. The most eminent success of B method is that it already has a strong and quite mature tool B Toolkit, to support and automate the development of application systems.
Reference: [37] <author> Lano, K., </author> <title> The B Language and Method: A Guide to Practical Formal Development, </title> <publisher> Springer-Verlag, </publisher> <address> ISBN 3-540-76033-4, </address> <year> 1996. </year>
Reference-contexts: When trying to apply VDM to real-time domain, novel features have to be added to VDM. VDM also keeps developing: VDM ++ , as a new version of VDM integrated with object-oriented idea, is a rather mature product now. * B-Method [36] <ref> [37] </ref> [62]. The B-method uses the Abstract Machine Notation to support the description of the target systems. The most eminent success of B method is that it already has a strong and quite mature tool B Toolkit, to support and automate the development of application systems.
Reference: [38] <author> Leveson, N. G. and stolzy, J. L., </author> <title> "Safety Analysis Using Petri Nets", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 13, </volume> <pages> pp. </pages> <month> 386-397 (March </month> <year> 1987). </year>
Reference-contexts: Petri nets provide a graphic representation with formal semantics of system behaviour. Until now, a large amount of vanities of Petri Net Theory has been proposed. Generally, petri nets can be classified into ordinary (classic) petri nets and timed petri nets. * Timed Petri Net [43] [21] [7] [8] <ref> [38] </ref> [53]. Petri Net theory was the first concurrent formalisms to deal with real-time. Two basic timed versions of Petri nets have been introduced: Timed petri Nets [124] and Time Petri Nets [43]. Both have been used in recent work [21] [7] [8] [38] [53]. <p> Timed Petri Net [43] [21] [7] [8] <ref> [38] </ref> [53]. Petri Net theory was the first concurrent formalisms to deal with real-time. Two basic timed versions of Petri nets have been introduced: Timed petri Nets [124] and Time Petri Nets [43]. Both have been used in recent work [21] [7] [8] [38] [53]. There are two questions that arise when time is introduced to net theory: (i) the location of the time delays (at places or transitions) and (ii) the type of delay (fixed delays, intervals or stochastic delays).
Reference: [39] <author> Logrippo, L., Melanchuk, T. and Wors, R. J. D., </author> <title> "The Algebraic Specification Language LOTOS: an Industrial Experience", </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> Vol. 15, </volume> <pages> pp. </pages> <month> 59-66 (04 </month> <year> 1990). </year>
Reference-contexts: However, ACP is an executable formalism. ACP is equipped with a process graph semantics, and adopts bisimulation proof system. ACP allows a variety of communication paradigms, including ternary communication, through the choice of the communication function. * LOTOS [32] <ref> [39] </ref>. LOTOS (Language Of Temporal Ordering Specification) was developed to define implementation-independent formal standards of OSI services and protocols. LO-TOS has two very clearly separated parts. The first part provides a behavioural model derived from process algebra, principally from CCS but also from CSP.
Reference: [40] <author> Mahoney, B. P. and Hayes, I. J., </author> <title> "A Case Study in Timed Refinement: A Mine Pump", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 18, </volume> <pages> pp. </pages> <month> 817-825 (09 </month> <year> 1992). </year>
Reference-contexts: Time is not a part of Z notation. When trying to apply Z to real-time domain, novel features have to be added to Z. However, because of the rich expressibility of Z, Z has been used in a number of real-time applications, such as timed Z <ref> [40] </ref>. The main users of Z are found in UK and other European countries. Generally speaking, Z has been applied to a large amount of applications, some of which are rather large-scaled. It is one of the few formal methods that has been proved successful in industrial applications.
Reference: [41] <author> Manna, Z. and Pnueli, A., </author> <title> The Temporal Logic of Reactive and Concurrent Systems, </title> <publisher> Springer-Verlag, </publisher> <address> ISBN 0-387-97664-7, </address> , <year> 1996. </year>
Reference-contexts: The new formalism was soon seen as a potentially valuable tool for analysing the topology of time. Various types of semantics can be given to the temporal operators depending on whether time is linear, parallel or branching. Another aspect is whether time is discrete or continuous <ref> [41] </ref>. Temporal logic is state-based. A structure of states is the key concept that makes temporal logic suitable for system specification. Mainly, the types of temporal semantics include interval semantics, point semantics, linear semantics, branching semantics and partial order semantics [41]. <p> Another aspect is whether time is discrete or continuous <ref> [41] </ref>. Temporal logic is state-based. A structure of states is the key concept that makes temporal logic suitable for system specification. Mainly, the types of temporal semantics include interval semantics, point semantics, linear semantics, branching semantics and partial order semantics [41]. The various temporal logics can be used to reason about qualitative temporal properties. Safety properties that can be specified include mutual exclusion and absence of deadlock. Liveness properties include termination and responsiveness.
Reference: [42] <author> Mehmet, A. and Wanli, M., </author> <title> "An Overview of Temporal Logic Programming", </title> <booktitle> First International Conference, ICTL'94, Lecture Notes in AI , Vol. </booktitle> <volume> 827, </volume> <pages> pp. </pages> <month> 445-481 </month> <year> (1994). </year>
Reference-contexts: By using the semantics of predicate logic and other suitable formal logics, WP-Calculus has been proven to be a formalism suitable for reverse engineering of source code, especially at the low abstraction levels. * Modal Logic <ref> [42] </ref> [15]. Modal logic is the study of context-dependent properties such as necessity and possibility. In modal logic, the meaning of expressions depends on an implicit context, abstracted away from the object language.
Reference: [43] <author> Merlin, P. M. and Segall, A., </author> <title> "Recoverability of Communication Protocols-Implications of a Theoretical Study", </title> <journal> IEEE Transactions on Communications, </journal> <month> September </month> <year> 1976. </year>
Reference-contexts: Petri nets provide a graphic representation with formal semantics of system behaviour. Until now, a large amount of vanities of Petri Net Theory has been proposed. Generally, petri nets can be classified into ordinary (classic) petri nets and timed petri nets. * Timed Petri Net <ref> [43] </ref> [21] [7] [8] [38] [53]. Petri Net theory was the first concurrent formalisms to deal with real-time. Two basic timed versions of Petri nets have been introduced: Timed petri Nets [124] and Time Petri Nets [43]. Both have been used in recent work [21] [7] [8] [38] [53]. <p> classified into ordinary (classic) petri nets and timed petri nets. * Timed Petri Net <ref> [43] </ref> [21] [7] [8] [38] [53]. Petri Net theory was the first concurrent formalisms to deal with real-time. Two basic timed versions of Petri nets have been introduced: Timed petri Nets [124] and Time Petri Nets [43]. Both have been used in recent work [21] [7] [8] [38] [53]. There are two questions that arise when time is introduced to net theory: (i) the location of the time delays (at places or transitions) and (ii) the type of delay (fixed delays, intervals or stochastic delays).
Reference: [44] <author> Milner, R., </author> <title> "Some Directions in Concurrency Theory(panel statement)", </title> <booktitle> Proceedings of the international Conference on the fifth Generation Computer Systems, </booktitle> <year> 1988. </year>
Reference-contexts: In this approach, graphical languages with a formal semantics are used, which bring special advantages in system development and re-engineering. Examples * Petri Net [55] [52]. Petri Net theory is one of the first formalisms to deal with concurrency, nondeterminism and causal connections between events. According to <ref> [44] </ref> it was the first unified theory, with levels of abstraction, in which to describe and analyse all aspects of computer in the context of its environment. Petri nets provide a graphic representation with formal semantics of system behaviour.
Reference: [45] <author> Milner, R., </author> <title> Communication and Concurrency, </title> <publisher> Prentice Hall, </publisher> <address> Hertfordshire, </address> <year> 1989. </year>
Reference-contexts: Examples * CSP [29] [28]. The Communicating Sequential Processes (CSP) formal specification notation for concurrent systems was first introduced in [29]. Since this original proposal did not include a proof method, a complete version of CSP was proposed in [28]. * CCS <ref> [45] </ref>. Calculus of Communicating Systems (CCS) was proposed by Milner in 1989. It is a formalism similar to CSP. CCS is also suitable for distributed and concurrent systems. At present, several variations of CCS has been developed, which forms a CCS family.
Reference: [46] <author> Moszkowski, B., </author> <title> Executing Temporal Logic Programs, </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge UK, </address> <year> 1986. </year>
Reference-contexts: The validaty of these properties is achieved using the associated axiom system of the used logic. In some cases, a subset of the logic can be executed, for example the Tempura system <ref> [46] </ref>. The executable specification can then be used for simulation and rapid prototyping purposes. Logic can be augmented with some concrete programming constructs to obtain what is known as wide-spectrum formalism. The development of systems in this case is achieved by a set of correctness preserving refinement steps. <p> The development of systems in this case is achieved by a set of correctness preserving refinement steps. Examples of these form are TAM [58] and the Refinement Calculus [57]. Examples * ITL [11] [47] <ref> [46] </ref> [10]. ITL (Interval Temporal Logic) has been developed in [11] [48]. This kind of logic is based on intervals of time, thought of as representing finite chunks of system behaviour. An interval may be divided into two contiguous subintervals, thus leading to chop operator. * Duration Calculus [12] [13]. <p> ITL was first proposed by Moszkowski [47]. ITL avoids the proliferation of time variables in specifications, as do all temporal logics. ITL is sufficiently general to express any discrete computation. An executable subset of ITL, called Tempura <ref> [46] </ref>, is well developed. Zedan and Cau proposed a set of new refinement techniques of ITL [10], which gives ITL a strong ability to describe all the popular possible features of real-time systems. Since ITL has an executable subset Tempura, its verification and simulation can be largely facilitated.
Reference: [47] <author> Moszkowski, B., </author> <title> A Temporal Logic for Multilevel Reasoning about Hardware, </title> <publisher> IEEE Computer Society, </publisher> <month> February </month> <year> 1985. </year>
Reference-contexts: The development of systems in this case is achieved by a set of correctness preserving refinement steps. Examples of these form are TAM [58] and the Refinement Calculus [57]. Examples * ITL [11] <ref> [47] </ref> [46] [10]. ITL (Interval Temporal Logic) has been developed in [11] [48]. This kind of logic is based on intervals of time, thought of as representing finite chunks of system behaviour. <p> ITL was first proposed by Moszkowski <ref> [47] </ref>. ITL avoids the proliferation of time variables in specifications, as do all temporal logics. ITL is sufficiently general to express any discrete computation. An executable subset of ITL, called Tempura [46], is well developed.
Reference: [48] <author> Narayana, K. T. and Aaby, A. A., </author> <title> "Specification of Real-Time Systems in Real-Time Temporal Interval Logic", </title> <booktitle> Proceedings of Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1988. </year>
Reference-contexts: The development of systems in this case is achieved by a set of correctness preserving refinement steps. Examples of these form are TAM [58] and the Refinement Calculus [57]. Examples * ITL [11] [47] [46] [10]. ITL (Interval Temporal Logic) has been developed in [11] <ref> [48] </ref>. This kind of logic is based on intervals of time, thought of as representing finite chunks of system behaviour. An interval may be divided into two contiguous subintervals, thus leading to chop operator. * Duration Calculus [12] [13].
Reference: [49] <author> Ostroff, J. S., </author> <title> "Temporal Logic for Real-Time Systems", </title> <booktitle> Advanced Software Development Series, </booktitle> <address> England, </address> <year> 1989. </year>
Reference-contexts: In real-time temporal logics, quantitative properties can also be expressed such as periodicity, real-time response (deadline), and delays. Early approaches to real-time temporal 7 logics were reported in [51] [5]. Since then, real-time logics have been explored in great detail. * RTTL <ref> [49] </ref> [50]. RTTL (Real-Time Temporal Logic) uses a distinguished temporal domain, the ESM (Extended State Machine) state variables, and the set of ESM transitions to form temporal formula. These are then proven using an axiomatisation of the system's ESM trajectories. RTTL has a complex and non-compositional proof system.
Reference: [50] <author> Ostroff, J. S., </author> <title> "Deciding Properties of Timed Transition Models", </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> Vol. 1, </volume> <pages> pp. </pages> <month> 170-183 (April </month> <year> 1990). </year>
Reference-contexts: In real-time temporal logics, quantitative properties can also be expressed such as periodicity, real-time response (deadline), and delays. Early approaches to real-time temporal 7 logics were reported in [51] [5]. Since then, real-time logics have been explored in great detail. * RTTL [49] <ref> [50] </ref>. RTTL (Real-Time Temporal Logic) uses a distinguished temporal domain, the ESM (Extended State Machine) state variables, and the set of ESM transitions to form temporal formula. These are then proven using an axiomatisation of the system's ESM trajectories. RTTL has a complex and non-compositional proof system.
Reference: [51] <author> Ostroff, J. S. and Wonham, W. M., </author> <title> "A Temporal Logic Approach to Real-Time Control", </title> <booktitle> Proceedings of the 24th IEEE Conference on Decision and Control, </booktitle> <address> Florida, </address> <month> December </month> <year> 1985. </year>
Reference-contexts: In real-time temporal logics, quantitative properties can also be expressed such as periodicity, real-time response (deadline), and delays. Early approaches to real-time temporal 7 logics were reported in <ref> [51] </ref> [5]. Since then, real-time logics have been explored in great detail. * RTTL [49] [50]. RTTL (Real-Time Temporal Logic) uses a distinguished temporal domain, the ESM (Extended State Machine) state variables, and the set of ESM transitions to form temporal formula.
Reference: [52] <author> Peterson, J. L., </author> <title> Petri Net Theory and the Modeling of Systems, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1981. </year>
Reference-contexts: In this approach, graphical languages with a formal semantics are used, which bring special advantages in system development and re-engineering. Examples * Petri Net [55] <ref> [52] </ref>. Petri Net theory is one of the first formalisms to deal with concurrency, nondeterminism and causal connections between events. According to [44] it was the first unified theory, with levels of abstraction, in which to describe and analyse all aspects of computer in the context of its environment.
Reference: [53] <author> Razouk, R. R. and Phelps, C. V., </author> <title> "Performance Analysis of Timed Petri Nets", </title> <booktitle> Proceedings of 4th International Workshop on Protocol Verification and Testing, </booktitle> <month> June </month> <year> 1984. </year>
Reference-contexts: Until now, a large amount of vanities of Petri Net Theory has been proposed. Generally, petri nets can be classified into ordinary (classic) petri nets and timed petri nets. * Timed Petri Net [43] [21] [7] [8] [38] <ref> [53] </ref>. Petri Net theory was the first concurrent formalisms to deal with real-time. Two basic timed versions of Petri nets have been introduced: Timed petri Nets [124] and Time Petri Nets [43]. Both have been used in recent work [21] [7] [8] [38] [53]. <p> Petri Net [43] [21] [7] [8] [38] <ref> [53] </ref>. Petri Net theory was the first concurrent formalisms to deal with real-time. Two basic timed versions of Petri nets have been introduced: Timed petri Nets [124] and Time Petri Nets [43]. Both have been used in recent work [21] [7] [8] [38] [53]. There are two questions that arise when time is introduced to net theory: (i) the location of the time delays (at places or transitions) and (ii) the type of delay (fixed delays, intervals or stochastic delays).
Reference: [54] <author> Reed, G. M. and Roscoe, A. W., </author> <title> "Timed CSP: </title> <journal> Theory and Practice", REX Workshop|Real-Time : Theory and Practice, </journal> <year> 1992. </year> <month> 23 </month>
Reference-contexts: This is a weak point in represent distributed processing where in many situations things happen simultaneously and no ordering between events can be established. Also, LOTOS has weak data specification mechanisms and cannot express time explicitly. * TCSP <ref> [54] </ref>. Timed CSP [54] is an extension of Hoare's CSP, with a dense temporal model providing a global clock. A delay operator is included along with some extended parallel operators. <p> This is a weak point in represent distributed processing where in many situations things happen simultaneously and no ordering between events can be established. Also, LOTOS has weak data specification mechanisms and cannot express time explicitly. * TCSP <ref> [54] </ref>. Timed CSP [54] is an extension of Hoare's CSP, with a dense temporal model providing a global clock. A delay operator is included along with some extended parallel operators. There is an assumption of a minimum delay between any two dependent action occurrences, but no minimum delay on any two independent actions.
Reference: [55] <author> Reisig, W., </author> <title> Petri Nets: an Introduction, </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: In this approach, graphical languages with a formal semantics are used, which bring special advantages in system development and re-engineering. Examples * Petri Net <ref> [55] </ref> [52]. Petri Net theory is one of the first formalisms to deal with concurrency, nondeterminism and causal connections between events. According to [44] it was the first unified theory, with levels of abstraction, in which to describe and analyse all aspects of computer in the context of its environment.
Reference: [56] <author> Rescher, N. and Urquhart, A., </author> <title> "Temporal Logic", Library of Exact Philosophy, </title> <year> 1971. </year>
Reference-contexts: A modal logic is equipped with modal operators through which elements from different contexts can be combined. There are several approaches to the semantics of modal logic, such as `neighbourhood' semantics. Until now, there is no application of modal logic in software reverse engineering area. * Temporal Logic <ref> [56] </ref>. Temporal logic has its origins in philosophy, where it was used to analyse the structure or topology of time. In recent years, it has found a good value in real-time application. In physics and mathematics, time has traditionally been represented as just another variable.
Reference: [57] <author> Scholefield, D., </author> <title> "A Refinement Calculus for Real-Time Systems", </title> <type> PhD thesis, </type> <year> 1992. </year>
Reference-contexts: Logic can be augmented with some concrete programming constructs to obtain what is known as wide-spectrum formalism. The development of systems in this case is achieved by a set of correctness preserving refinement steps. Examples of these form are TAM [58] and the Refinement Calculus <ref> [57] </ref>. Examples * ITL [11] [47] [46] [10]. ITL (Interval Temporal Logic) has been developed in [11] [48]. This kind of logic is based on intervals of time, thought of as representing finite chunks of system behaviour.
Reference: [58] <author> Scholefield, D. and Zedan, H., "TAM: </author> <title> A Formal Framework for the Development of Distributed Real-Time Systems", Symposium on Formal Techniques in Real-Time and Fault Tolerant Systems, </title> <address> Nijmegen, Netherland, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: Logic can be augmented with some concrete programming constructs to obtain what is known as wide-spectrum formalism. The development of systems in this case is achieved by a set of correctness preserving refinement steps. Examples of these form are TAM <ref> [58] </ref> and the Refinement Calculus [57]. Examples * ITL [11] [47] [46] [10]. ITL (Interval Temporal Logic) has been developed in [11] [48]. This kind of logic is based on intervals of time, thought of as representing finite chunks of system behaviour.
Reference: [59] <author> Scholefield, D., Zedan, H. and He, J., </author> <title> "A Specification-oriented Semantics for the Refinement of Real-Time Systems", </title> <journal> Theoretical Computer Science, </journal> <volume> Vol. </volume> <month> 130 (August </month> <year> 1994). </year>
Reference: [60] <author> Spivey, J. M., </author> <title> Understanding Z, </title> <publisher> Cambridge University Press, </publisher> <year> 1988. </year>
Reference-contexts: In this approach, there is no explicit representation of concurrency. Non-functional requirements (such as temporal requirement) could be expressed in some cases. Examples * Z [1] <ref> [60] </ref>. With the first version proposed in 1979, the Z notion is based on predicate calculus and Zermelo Fraenkel set theory.
Reference: [61] <author> Turner, K. J., </author> <title> "DILL-Digital Logic in LOTOS", Formal Description Techniques, FORTE VII, </title> <publisher> North Holland, </publisher> <month> October </month> <year> 1993. </year>
Reference-contexts: LOTOS is able to capture a relatively complex temporal pattern of events, involving non=determinism, concurrency and synchronisation, by means of small algebraic expression built by using few conceptually simple operators <ref> [61] </ref>. LOTOS has formally defined syntax, static semantics and dynamic semantics. The static semantics are defined by an attributed grammar [32] and the dynamic semantics are described operationally in terms of inference rules. Since LOTOS has an operational semantics, it is possible to implement these semantics in an interpreter.
Reference: [62] <author> Wordsworth, J., </author> <title> Software Engineering with B, </title> <publisher> Addison Wesley Longman, </publisher> <address> ISBN 0-201-40356-0., </address> <year> 1996. </year>
Reference-contexts: When trying to apply VDM to real-time domain, novel features have to be added to VDM. VDM also keeps developing: VDM ++ , as a new version of VDM integrated with object-oriented idea, is a rather mature product now. * B-Method [36] [37] <ref> [62] </ref>. The B-method uses the Abstract Machine Notation to support the description of the target systems. The most eminent success of B method is that it already has a strong and quite mature tool B Toolkit, to support and automate the development of application systems.
Reference: [63] <author> Yang, H. and Bennett, K. H., </author> <title> "Aquairing Entity-Relationship Attribute Diagrams from Code and Data through Program Transformation", </title> <booktitle> IEEE International Conference on Software Maintenance (ICSM '95), </booktitle> <address> Nice, France, </address> <month> October, </month> <year> 1995. </year>
Reference: [64] <author> Zedan, H. and Heping, H., </author> <title> "An Executable Specification Language for Fast Prototyping Parallel Responsive Systems", </title> <booktitle> Computer Language, </booktitle> <volume> Vol. 22, </volume> <pages> pp. </pages> <month> 1-13 (01 </month> <year> 1996). </year> <month> 24 </month>
References-found: 64

