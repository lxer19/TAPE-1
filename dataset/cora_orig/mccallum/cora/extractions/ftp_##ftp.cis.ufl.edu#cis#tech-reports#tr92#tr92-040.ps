URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr92/tr92-040.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr92-abstracts.html
Root-URL: http://www.cis.ufl.edu
Title: A simple correctness proof of the MCS contention-free lock  
Author: Theodore Johnson Krishna Harathi 
Keyword: mutual exclusion, serializability, parallel processing, spin lock  
Affiliation: Computer and Information Sciences Department University of Florida  
Abstract: Mellor-Crummey and Scott present a spin-lock that avoids network contention by having processors spin on local memory locations. Their algorithm is equivalent to a lock-free queue with a special access pattern. The authors provide a complex and unintuitive proof of the correctness of their algorithm. In this paper, we provide a simple proof that the MCS lock is a correct critical section solution, which provides insight into why the algorithm is correct. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. E. Anderson. </author> <title> The performance of spin lock alternatives for shared memory multiprocessors. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 6-16, </pages> <year> 1990. </year>
Reference-contexts: In contrast, test-and-set spin waiting is not fair, and will severely limit performance <ref> [1, 2] </ref>. The authors of the MCS locks provide a complex proof of the correctness of their algorithm. In [4], they show correctness through a series of algorithm transformations. Since this proof provides little insight, they also provide intuitive correctness arguments.
Reference: [2] <author> R.R. Glenn, D.V. Pryor, J.M. Conroy, and T. Johnson. </author> <title> Characterizing memory hotspots in a shared memory mimd machine. In Supercomputing '91. </title> <journal> IEEE and ACM SIGARCH, </journal> <year> 1991. </year>
Reference-contexts: In contrast, test-and-set spin waiting is not fair, and will severely limit performance <ref> [1, 2] </ref>. The authors of the MCS locks provide a complex proof of the correctness of their algorithm. In [4], they show correctness through a series of algorithm transformations. Since this proof provides little insight, they also provide intuitive correctness arguments.
Reference: [3] <author> M. Herlihy and J. Wing. </author> <title> Linearizability: A correctness condition for concurrent objects. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(3) </volume> <pages> 463-492, </pages> <year> 1990. </year>
Reference-contexts: The decisive-instruction serializability of the MCS lock greatly simplifies its correctness proof, because the equivalent queue is in a single state at any instant. In contrast, a concurrent data structure that is linearizable but not serializable might be in several states simultaneously <ref> [3] </ref>. 3.1 The Queue ADT A queue is an Abstract Data Type that consists of finite set Q and two operations: enqueue and dequeue. The elements of Q are totally ordered.
Reference: [4] <author> J. Mellor-Crummey and M. Scott. </author> <title> Algorithms for scalable synchronization on shared-memory multiprocessors. </title> <type> Technical Report TR90-114, </type> <institution> Rice University Dept. of CS, </institution> <year> 1990. </year>
Reference-contexts: In contrast, test-and-set spin waiting is not fair, and will severely limit performance [1, 2]. The authors of the MCS locks provide a complex proof of the correctness of their algorithm. In <ref> [4] </ref>, they show correctness through a series of algorithm transformations. Since this proof provides little insight, they also provide intuitive correctness arguments. In this paper, we present a simple correctness proof for the MCS lock.
Reference: [5] <author> J.M. Mellor-Crummey and M.L. Scott. </author> <title> Algorithms for scalable synchronization on shared-memory multiprocessors. </title> <journal> ACM Trans. Computer Systems, </journal> <volume> 9(1) </volume> <pages> 21-65, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction Mellor-Crummey and Scott present a simple spin-lock for mutual exclusion <ref> [5] </ref>, which they call the MCS lock. Their algorithm has several desirable properties: it is is fair, because it is equivalent to a FIFO queue ADT with special access pattern, and it is is contention free, because each processor spins on a local variable. <p> for lock procedure release lock ( L: *lock, I: *qnode ) if I-&gt;next = nil // No known successor if compare and swap (L, I, nil) return // No successor, lock free repeat while I-&gt;next = nil // Wait for successor I-&gt;next-&gt;locked := false // Pass lock MCS-Lock Algorithm (from <ref> [5] </ref>). 3 Correctness We show that the MCS lock is correct by showing that it maintains a queue, and the head of the queue is the process that holds the lock. The MCS lock is decisive-instruction serializable [6].
Reference: [6] <author> D. Shasha and N. Goodman. </author> <title> Concurrent search structure algorithms. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(1) </volume> <pages> 53-90, </pages> <year> 1988. </year>
Reference-contexts: The MCS lock is decisive-instruction serializable <ref> [6] </ref>.
Reference: [7] <author> A. Silberschatz, J. Peterson, and P. Galvin. </author> <title> Operating System Concepts. </title> <publisher> Addison Wesley, </publisher> <year> 1991. </year> <month> 6 </month>
Reference-contexts: By the execution sequence assumption, this record remains in the queue until the process completes the operation. Therefore, no process access an invalid record when executing the release lock operation. 2 4 Critical Section Solution A critical section solution is correct if it satisfies the following three criteria <ref> [7] </ref>: 1. At most one process executes in the critical section at any given time. 2. If no process is executing in the critical section, and at least one process wishes to enter the critical section, then a process enters the critical section in a finite amount of time. 3.
References-found: 7

