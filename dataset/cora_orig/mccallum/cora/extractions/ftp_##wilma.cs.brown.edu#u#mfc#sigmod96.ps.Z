URL: ftp://wilma.cs.brown.edu/u/mfc/sigmod96.ps.Z
Refering-URL: http://www.cs.brown.edu/software/cokokola/
Root-URL: http://www.cs.brown.edu
Email: mfc@cs.brown.edu  sbz@cs.brown.edu  
Title: Rule Languages and Internal Algebras for Rule-Based Optimizers  
Author: Mitch Cherniack Stanley B. Zdonik 
Affiliation: Department of Computer Science, Brown University  Department of Computer Science, Brown University  
Abstract: Rule-based optimizers and optimizer generators use rules to specify query transformations. Rules act directly on query representations, which typically are based on query algebras. But most algebras complicate rule formulation, and rules over these algebras must often resort to calling to externally defined bodies of code. Code makes rules difficult to formulate, prove correct and reason about, and therefore compromises the effectiveness of rule-based systems. In this paper we present KOLA; a combinator-based algebra designed to simplify rule formulation. KOLA is not a user language, and KOLA's variable-free queries are difficult for humans to read. But KOLA is an effective internal algebra because its combinator-style makes queries manipulable and structurally revealing. As a result, rules over KOLA queries are easily expressed without the need for supplemental code. We illustrate this point, first by showing some transformations that despite their simplicity, require head and body routines when expressed over algebras that include variables. We show that these transformations are expressible without supplemental routines in KOLA. We then show complex transformations of a class of nested queries expressed over KOLA. Nested query optimizations, while having been studied before, have seriously challenged the rule-based paradigm. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and C. Beeri. </author> <title> On the power of languages for the manipulation of complex objects. </title> <type> Technical Report 846, </type> <institution> INRIA, </institution> <year> 1988. </year>
Reference-contexts: This helps to explain why for example, transformations of nested queries do not typically get implemented as instances of rules. Nested query optimization is particularly important and particularly difficult when nested queries are expressed over data with complex structure, as in nested relational [33], complex object <ref> [1] </ref> and object-oriented [27] databases. Such data models exacerbate both the classification and manipulation of nested queries by allowing tuples and objects to refer to sets and to each other. This potentially introduces data dependencies into queries, complicating their transformation as we later show.
Reference: [2] <author> A. Aho, R. Sethi, and J. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference: [3] <author> J. W. Backus. </author> <title> Can programming be liberated from the von Neumann style? A functional style and its algebra of programs. </title> <journal> Communications of the ACM, </journal> <volume> 21(8):613641, </volume> <month> August </month> <year> 1978. </year>
Reference-contexts: We complete our argument by presenting a variable-free (combinator-based) algebra, and showing how the problems discussed in this section go away. 3 KOLA: A Combinator Algebra KOLA's 2 combinator-style facilitates the kind of query manipulation that is difficult with variable-based algebras. KOLA has the flavor of Backus' FP <ref> [3] </ref> but unlike FP can build functions and predicates over sets. It provides for anonymous functions through formers; functionals that denote new functions in terms of existing ones. <p> But whereas [35] 410 add the machinery, we instead remove the variables. As we mentioned earlier, ours is not the first combinator-based algebra proposed in a database context. [15] and [5] propose an FP-style <ref> [3] </ref> query language. But combinator-style languages are difficult for users to master and thus ill-suited as query languages. [7], [6] and [4] use combinator-based algebras to present optimization rules. They do not consider the reasons why this style of algebra is useful for implementing rule-based optimizers.
Reference: [4] <author> C. Beeri and Y. Kornatzky. </author> <title> Algebraic optimization of object-oriented query languages. </title> <editor> In S. Abiteboul and P. C. Kanellakis, editors, </editor> <booktitle> Proceedings of the Third International Conference on Database Theory, number 470 in Lecture Notes in Computer Science, </booktitle> <pages> pages 7288, </pages> <address> Paris, France, </address> <month> December </month> <year> 1990. </year> <title> EATCS, </title> <publisher> Springer-Verlag. </publisher>
Reference-contexts: As we mentioned earlier, ours is not the first combinator-based algebra proposed in a database context. [15] and [5] propose an FP-style [3] query language. But combinator-style languages are difficult for users to master and thus ill-suited as query languages. [7], [6] and <ref> [4] </ref> use combinator-based algebras to present optimization rules. They do not consider the reasons why this style of algebra is useful for implementing rule-based optimizers. Combinator representations are often used within functional language compilers as internal representations of - expressions.
Reference: [5] <author> A. Bossi and C. Ghezzi. </author> <title> Using FP as a query language for relational data-bases. </title> <booktitle> Computer Languages, </booktitle> <address> 9(1):2537, </address> <year> 1984. </year>
Reference-contexts: But whereas [35] 410 add the machinery, we instead remove the variables. As we mentioned earlier, ours is not the first combinator-based algebra proposed in a database context. [15] and <ref> [5] </ref> propose an FP-style [3] query language. But combinator-style languages are difficult for users to master and thus ill-suited as query languages. [7], [6] and [4] use combinator-based algebras to present optimization rules. They do not consider the reasons why this style of algebra is useful for implementing rule-based optimizers.
Reference: [6] <author> V. Breazu-Tannen, P. Buneman, and L. Wong. </author> <title> Naturally embedded query languages. </title> <editor> In J. Biskup and R. Hull, editors, </editor> <booktitle> Database Theory - ICDT'92, 4th International Conference, volume 646 of LNCS. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Combinator-based internal algebras have been considered for queries before. In particular, <ref> [6] </ref> uses a combinator algebra to express the semantics for their query calculus and to allow category theory machinery to be used to reason about the correctness of transformations. We consider an alternative use, proposing combinators as the basis for query representations manipulated by an optimizer. <p> We consider an alternative use, proposing combinators as the basis for query representations manipulated by an optimizer. We propose an alternative combinator set to that of <ref> [6] </ref> that permits smaller translations of queries [11] at the expense of allowing some redundancy. We have implemented translators into our combinator set from both OQL [9] and AQUA [25]. (See [11] for details.) This makes our work similar in spirit to the use of combinators in functional language compilers. <p> Rule-based optimizations simplify correctness proofs of optimizations because rules are simpler to prove correct than algorithms. But this is exactly why rules should not include calls to code. As has been pointed out elsewhere ([3], <ref> [6] </ref>), combinator algebras make rule proofs easier because of the absence of variables. In fact, we have constructed a formal specification of KOLA using the Larch [19] specification tool LSL, and have constructed proofs of over 500 rules that form a pool from which a rule-based optimizer could draw. <p> However, we have designed, implemented and verified translators from both OQL and AQUA to KOLA, demonstrating KOLA's expressive power [11]. 6 Translation (which proceeds in similar fashion to that described in <ref> [6] </ref> and [13]) relies on combinators that permit generation of explicit environments (id and h i), and access to those environments ( 1 , 2 and ffi). For iteration, KOLA provides the environment accessing former, iter (which generalizes the pairwith combinator of [6]). <p> proceeds in similar fashion to that described in <ref> [6] </ref> and [13]) relies on combinators that permit generation of explicit environments (id and h i), and access to those environments ( 1 , 2 and ffi). For iteration, KOLA provides the environment accessing former, iter (which generalizes the pairwith combinator of [6]). The other issue concerns the expressibility of rules, especially given our avoidance of head and tail routines. Some transformations are only valid or appropriate provided that certain conditions hold. <p> As we mentioned earlier, ours is not the first combinator-based algebra proposed in a database context. [15] and [5] propose an FP-style [3] query language. But combinator-style languages are difficult for users to master and thus ill-suited as query languages. [7], <ref> [6] </ref> and [4] use combinator-based algebras to present optimization rules. They do not consider the reasons why this style of algebra is useful for implementing rule-based optimizers. Combinator representations are often used within functional language compilers as internal representations of - expressions.
Reference: [7] <author> P. Buneman and R. E. Frankel. </author> <title> FQL a functional query language. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conference on Management of Data, </booktitle> <year> 1979. </year>
Reference-contexts: As we mentioned earlier, ours is not the first combinator-based algebra proposed in a database context. [15] and [5] propose an FP-style [3] query language. But combinator-style languages are difficult for users to master and thus ill-suited as query languages. <ref> [7] </ref>, [6] and [4] use combinator-based algebras to present optimization rules. They do not consider the reasons why this style of algebra is useful for implementing rule-based optimizers. Combinator representations are often used within functional language compilers as internal representations of - expressions.
Reference: [8] <author> M. J. Carey, D. J. DeWitt, G. Graefe, D. M. Haight, J. E. Richardson, D. T. Schuh, E. J. Shekita, and S. L. Vandenberg. </author> <title> The EXODUS extensible DBMS project: An overview. </title> <editor> In S. B. Zdonik and D. Maier, editors, </editor> <booktitle> Readings in Object-Oriented Database Systems, </booktitle> <pages> pages 474 499. </pages> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> Los Altos, California, </address> <year> 1990. </year>
Reference-contexts: Declarative rules grant optimizers and optimizer generators the freedom to make intelligent implementation decisions. But most existing systems limit themselves by permitting rule inputs that are not declaratively expressed. The Starburst [20] optimizer and EXODUS <ref> [8] </ref> optimizer generator are example rule-based systems that permit rules to be supplemented with code. Code appears in two places: * Head Routines (called conditions in [8] and condition functions in [20]) are invoked in the heads (left-hand sides) of rules and analyze query representations to decide if they should be <p> But most existing systems limit themselves by permitting rule inputs that are not declaratively expressed. The Starburst [20] optimizer and EXODUS <ref> [8] </ref> optimizer generator are example rule-based systems that permit rules to be supplemented with code. Code appears in two places: * Head Routines (called conditions in [8] and condition functions in [20]) are invoked in the heads (left-hand sides) of rules and analyze query representations to decide if they should be transformed by rules. * Body Routines (called support functions in [8] and action routines in [20]) are invoked in the bodies (right-hand sides) of rules and <p> Code appears in two places: * Head Routines (called conditions in <ref> [8] </ref> and condition functions in [20]) are invoked in the heads (left-hand sides) of rules and analyze query representations to decide if they should be transformed by rules. * Body Routines (called support functions in [8] and action routines in [20]) are invoked in the bodies (right-hand sides) of rules and are used to transform query representations into alternative forms. Code fragments are restrictive, making the quality and correctness of generated optimizers depend on the quality and correctness of included code. <p> Rule blocks reduce the number of transformations that an optimizer needs to consider without complicating proofs establishing the correctness of the transformation. COKO will be presented in a later paper. 5 Related Work Rule-based optimization is a well-known approach to building extensible query optimizers. We mentioned EXODUS <ref> [8] </ref> and Starburst [20] as examples of rule-based systems.
Reference: [9] <author> R. Cattell, </author> <title> editor. The Object Database Standard: ODMG-93. </title> <address> Morgan-Kaufman, </address> <year> 1993. </year>
Reference-contexts: We propose an alternative combinator set to that of [6] that permits smaller translations of queries [11] at the expense of allowing some redundancy. We have implemented translators into our combinator set from both OQL <ref> [9] </ref> and AQUA [25]. (See [11] for details.) This makes our work similar in spirit to the use of combinators in functional language compilers.
Reference: [10] <author> M. Cherniack. </author> <title> Form(ers) over function(s): The KOLA query algebra. </title> <type> Technical report, </type> <institution> Brown University Department of Computer Science, </institution> <month> May </month> <year> 1995. </year> <note> In preparation. </note>
Reference-contexts: The proofs have been verified using the Larch theorem proving tool, LP. This work is described in <ref> [10] </ref>. Optimizer Extensibility: Rules that are expressed in a purely declarative fashion are easier to understand, reason about and manipulate than those that are not. Our work is a step forward in the direction of completely declarative rule sets. <p> Variables and -notation are neither provided nor required to denote functions. Tables 1 and 2 describe the operational semantics of some KOLA primitives and formers. (A formal specification of the entire algebra using Larch [19] is presented in <ref> [10] </ref>). The semantics equations show the results of invoking KOLA functions and predicates on their arguments. All functions are invoked via the infix operator, !, while predicates are invoked with ? (also infix). <p> The other issue concerns the expressibility of rules, especially given our avoidance of head and tail routines. Some transformations are only valid or appropriate provided that certain conditions hold. We permit preconditions within the KOLA rule language (for details see <ref> [10] </ref>), but they are expressed as attributes whose values are determined not with code, but with annotations and additional rules. For example, a function is injective if it results in unequal results when invoked on unequal objects (as in a key).
Reference: [11] <author> M. Cherniack and S. B. Zdonik. </author> <title> Combinator translations of queries. </title> <type> Technical Report CS-95-40, </type> <institution> Brown University Department of Computer Science, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: We consider an alternative use, proposing combinators as the basis for query representations manipulated by an optimizer. We propose an alternative combinator set to that of [6] that permits smaller translations of queries <ref> [11] </ref> at the expense of allowing some redundancy. We have implemented translators into our combinator set from both OQL [9] and AQUA [25]. (See [11] for details.) This makes our work similar in spirit to the use of combinators in functional language compilers. <p> We propose an alternative combinator set to that of [6] that permits smaller translations of queries <ref> [11] </ref> at the expense of allowing some redundancy. We have implemented translators into our combinator set from both OQL [9] and AQUA [25]. (See [11] for details.) This makes our work similar in spirit to the use of combinators in functional language compilers. <p> However, we have designed, implemented and verified translators from both OQL and AQUA to KOLA, demonstrating KOLA's expressive power <ref> [11] </ref>. 6 Translation (which proceeds in similar fashion to that described in [6] and [13]) relies on combinators that permit generation of explicit environments (id and h i), and access to those environments ( 1 , 2 and ffi). <p> These preconditions can be exploited and inferred without calls to code. Complexity: Combinators make queries larger. Intuitively, this is because variables, which occupy one node of a parse tree) must be replaced by functions, which can occupy several nodes. But we show in <ref> [11] </ref> that the complexity of translated queries are O (mn) in the size of the input, where size is measured in parse tree nodes, n is the number of nodes in the original query, and m is the maximum number of variables appearing simultaneously in the original query's environment (i.e., the
Reference: [12] <author> S. Cluet and G. Moerkotte. </author> <title> Nested queries in object bases. </title> <booktitle> In Proc. 4th Int'l Workshop on Database ProgrammingLanguages, </booktitle> <address> NY, NY, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: This potentially introduces data dependencies into queries, complicating their transformation as we later show. There has been much progress in nested query optimization [24], [17], [20], [30], [31], <ref> [12] </ref>, [14]. But nested queries tend to be fairly large and rules for them tend to lack generality or have especially complex head and body routines. <p> A great deal of research has been done in nested query optimization, but typically this research makes it into practice with complex rules that are difficult to formalize and reason about (e.g., <ref> [12] </ref> and [20]) or with transformations expressed informally over query languages (e.g., [24, 17, 31]). 4.1 Hidden Join Queries The class of queries we consider are hidden joins; nested queries that (like join queries) pair objects that are taken from two sets and that satisfy some relationship. <p> The rules we use for these transformations are generally applicable and perform the optimization in gradual steps, unlike the monolithic and overly specific rules that sometimes appear in the literature <ref> [12] </ref>. We describe and illustrate our technique showing how to transform from one Garage Query (K G 1 ) to the other (K G 2 ). <p> Rules that express the optimization monolithically (as in <ref> [12] </ref>) must analyze the query using complex head routines that delve to any level of nesting, to see if the query is of the desired form. (The query is not of the desired form for example if the query that is the function instantiating iterate is invoked on a set derived <p> Recognizing that a occurs in these expressions would then require a complex head routine. An alternative is to express the hidden join transformation in terms of a single complex monolithic rule. (This is the approach taken to express transformations in <ref> [12] </ref>). Such rules are problematic for two reasons. Complex Rules Need Complex Head and Body Routines. This is not surprising, given the arguments presented in Section 2. However, we can appreciate how complex the routines can be by considering how a monolithic rule would express the hidden join optimization. <p> A reasonable increase in query size resulting from translating queries into combinator form is tolerable because queries tend to be small (compared with functional programs for example). Nested queries have been studied extensively in the relational context [24], and have recently been examined in the context of object-oriented models <ref> [12] </ref>. In this paper, we have seen how structured data in these models can lead to very complex nested queries. The optimizations described, while useful, are expressed monolithically.
Reference: [13] <author> P.-L. Curien. </author> <title> Categorical Combinators, Sequential Algorithms, and Functional Programming. </title> <publisher> Birkhauser, </publisher> <year> 1993. </year>
Reference-contexts: However, we have designed, implemented and verified translators from both OQL and AQUA to KOLA, demonstrating KOLA's expressive power [11]. 6 Translation (which proceeds in similar fashion to that described in [6] and <ref> [13] </ref>) relies on combinators that permit generation of explicit environments (id and h i), and access to those environments ( 1 , 2 and ffi). For iteration, KOLA provides the environment accessing former, iter (which generalizes the pairwith combinator of [6]). <p> Variable combinator techniques produce new com-binators specific to particular programs. Fixed combinator sets include the SKI combinator set of Schonfinkel [34] (and its many variations) as well as the Category Theory-inspired combinator set of Curien <ref> [13] </ref>. Variable-set combinators are produced by -lifting [22] and supercombinator techniques [21]. Variable sets of combinators keep the size of translated expressions reasonably small while still producing the desired effect of making graph reduction efficient (the com-binators generated tend to be fairly complicated).
Reference: [14] <author> U. Dayal. </author> <title> Of nests and trees: A unified approach to processing queries that contain nested subqueries, aggregates and quantifiers. </title> <editor> In P. M. Stocker, W. Kent, and P. Hammersley, editors, </editor> <booktitle> Proceedings if the 13th International Conference on Very Large Databases, pages 197208, </booktitle> <address> Brighton, England, </address> <month> September </month> <year> 1987. </year> <month> Morgan-Kaufman. </month>
Reference-contexts: This potentially introduces data dependencies into queries, complicating their transformation as we later show. There has been much progress in nested query optimization [24], [17], [20], [30], [31], [12], <ref> [14] </ref>. But nested queries tend to be fairly large and rules for them tend to lack generality or have especially complex head and body routines. <p> To ensure that the cardinality of the result is the same as that of A, many algebras introduce an outer join operator that associates NULLs with elements of A which never satisfy the join predicate (e.g. <ref> [14] </ref>). That is, NULLs preserve values of A that are needed in the nesting but are lost by the join.
Reference: [15] <author> M. Erwig and U. W. Lipeck. </author> <title> A functional DBPL revealing high level optimizations. </title> <editor> In P. Kanellakis and J. W. Schmidt, editors, </editor> <title> Bulk Types & Persistent Data: </title> <booktitle> The Third International Workshop on Database Programming Languages, </booktitle> <pages> pages 306, </pages> <address> Nafplion, Greece, August 1991. </address> <publisher> Morgan Kaufmann Publishers, Inc. </publisher>
Reference-contexts: But whereas [35] 410 add the machinery, we instead remove the variables. As we mentioned earlier, ours is not the first combinator-based algebra proposed in a database context. <ref> [15] </ref> and [5] propose an FP-style [3] query language. But combinator-style languages are difficult for users to master and thus ill-suited as query languages. [7], [6] and [4] use combinator-based algebras to present optimization rules.
Reference: [16] <author> L. Fegaras, D. Maier, and T. Sheard. </author> <title> Specifying rule-based query optimizers in a reflective framework. </title> <editor> In S. Ceri, K. Tanaka, and S. Tsur, editors, </editor> <booktitle> Proceedings of the International Conference on Deductive and Object-Oriented Databases, </booktitle> <pages> pages 146168, </pages> <year> 1993. </year>
Reference-contexts: Many rule-based systems (e.g. [26]) use rules to map algebraic operators to plan-level implementations. The transformations addressed do not consider rewriting at the source level. <ref> [16] </ref> has similar motivations to ours in that they attempt to remove code fragments that appear in rules. Like [26] however, their work primarily addresses rules that express source-to-physical transformations.
Reference: [17] <author> R. A. Ganski and H. K. T. Wong. </author> <title> Optimization of nested SQL queries revisited. </title> <editor> In U. Dayal and I. Traiger, editors, </editor> <booktitle> Proceedings of the SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 2333, </pages> <address> San Francisco, California, </address> <month> May </month> <year> 1987. </year> <booktitle> ACM Special Interest Group on Management of Data, </booktitle> <publisher> ACM Press. </publisher>
Reference-contexts: Such data models exacerbate both the classification and manipulation of nested queries by allowing tuples and objects to refer to sets and to each other. This potentially introduces data dependencies into queries, complicating their transformation as we later show. There has been much progress in nested query optimization [24], <ref> [17] </ref>, [20], [30], [31], [12], [14]. But nested queries tend to be fairly large and rules for them tend to lack generality or have especially complex head and body routines. <p> A great deal of research has been done in nested query optimization, but typically this research makes it into practice with complex rules that are difficult to formalize and reason about (e.g., [12] and [20]) or with transformations expressed informally over query languages (e.g., <ref> [24, 17, 31] </ref>). 4.1 Hidden Join Queries The class of queries we consider are hidden joins; nested queries that (like join queries) pair objects that are taken from two sets and that satisfy some relationship.
Reference: [18] <author> G. Gardarin, F. Machuca, and P. Pucheral. OFL: </author> <title> A functional execution model for object query languages. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conference on Management of Data, </booktitle> <pages> pages 5970, </pages> <year> 1995. </year>
Reference-contexts: In this section, we explore the reasons why variable-based query algebras make it necessary for rules to include head 402 and body routines. We will use AQUA [25] as a case study, although our remarks apply to other variable-based algebras (e.g. <ref> [18] </ref>, [38], [36] and [23]). 2.1 Rules that Build New Functions Anonymous functions are functions denoted without names. An expressive query algebra should permit anonymous functions to be used within a query to express what should be done with each object in a queried collection. <p> The semantics equations can be used to derive a query's meaning. For example, the query below uses the primitive functions city and addr, ffi (the composition function former), iterate (a set function former similar to OFL's iterate operator <ref> [18] </ref>, and that captures both of AQUA's app and sel operators 3 ) and the constant predicate former, K p . (iterate's semantics is given in Table 2 all others are listed in Table 1).
Reference: [19] <author> J. Guttag, J. Hornung, S. Garland, K. Jones, A. Modet, and J. Wing. </author> <title> Larch: Languages and Tools for Formal Specifications. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: But this is exactly why rules should not include calls to code. As has been pointed out elsewhere ([3], [6]), combinator algebras make rule proofs easier because of the absence of variables. In fact, we have constructed a formal specification of KOLA using the Larch <ref> [19] </ref> specification tool LSL, and have constructed proofs of over 500 rules that form a pool from which a rule-based optimizer could draw. The proofs have been verified using the Larch theorem proving tool, LP. This work is described in [10]. <p> Variables and -notation are neither provided nor required to denote functions. Tables 1 and 2 describe the operational semantics of some KOLA primitives and formers. (A formal specification of the entire algebra using Larch <ref> [19] </ref> is presented in [10]). The semantics equations show the results of invoking KOLA functions and predicates on their arguments. All functions are invoked via the infix operator, !, while predicates are invoked with ? (also infix). <p> The rules used at each stage are listed in Figures 5 and 8. All of these rules have been proven correct with proofs verified by the Larch theorem prover, LP <ref> [19] </ref>. Step 1: Break up complex iterate This step has the effect of breaking up the query from the monolithic form, iterate (K p (T ); hF; Gi) ! A; where G is potentially very large, into a composition chain of iterate operations.
Reference: [20] <author> L. M. Haas, J. C. Freytag, G. M. Lohman, and H. Pirahesh. </author> <title> Extensible query processing in Starburst. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conference on Management of Data, </booktitle> <pages> pages 377388, </pages> <year> 1989. </year>
Reference-contexts: Declarative rules grant optimizers and optimizer generators the freedom to make intelligent implementation decisions. But most existing systems limit themselves by permitting rule inputs that are not declaratively expressed. The Starburst <ref> [20] </ref> optimizer and EXODUS [8] optimizer generator are example rule-based systems that permit rules to be supplemented with code. Code appears in two places: * Head Routines (called conditions in [8] and condition functions in [20]) are invoked in the heads (left-hand sides) of rules and analyze query representations to decide <p> The Starburst <ref> [20] </ref> optimizer and EXODUS [8] optimizer generator are example rule-based systems that permit rules to be supplemented with code. Code appears in two places: * Head Routines (called conditions in [8] and condition functions in [20]) are invoked in the heads (left-hand sides) of rules and analyze query representations to decide if they should be transformed by rules. * Body Routines (called support functions in [8] and action routines in [20]) are invoked in the bodies (right-hand sides) of rules and are used to transform query <p> appears in two places: * Head Routines (called conditions in [8] and condition functions in <ref> [20] </ref>) are invoked in the heads (left-hand sides) of rules and analyze query representations to decide if they should be transformed by rules. * Body Routines (called support functions in [8] and action routines in [20]) are invoked in the bodies (right-hand sides) of rules and are used to transform query representations into alternative forms. Code fragments are restrictive, making the quality and correctness of generated optimizers depend on the quality and correctness of included code. <p> This potentially introduces data dependencies into queries, complicating their transformation as we later show. There has been much progress in nested query optimization [24], [17], <ref> [20] </ref>, [30], [31], [12], [14]. But nested queries tend to be fairly large and rules for them tend to lack generality or have especially complex head and body routines. <p> A great deal of research has been done in nested query optimization, but typically this research makes it into practice with complex rules that are difficult to formalize and reason about (e.g., [12] and <ref> [20] </ref>) or with transformations expressed informally over query languages (e.g., [24, 17, 31]). 4.1 Hidden Join Queries The class of queries we consider are hidden joins; nested queries that (like join queries) pair objects that are taken from two sets and that satisfy some relationship. <p> COKO will be presented in a later paper. 5 Related Work Rule-based optimization is a well-known approach to building extensible query optimizers. We mentioned EXODUS [8] and Starburst <ref> [20] </ref> as examples of rule-based systems.
Reference: [21] <author> R. J. M. Hughes. </author> <title> The design and implementation of programming languages. </title> <type> PhD thesis, </type> <institution> University of Oxford, </institution> <year> 1984. </year>
Reference-contexts: Variable combinator techniques produce new com-binators specific to particular programs. Fixed combinator sets include the SKI combinator set of Schonfinkel [34] (and its many variations) as well as the Category Theory-inspired combinator set of Curien [13]. Variable-set combinators are produced by -lifting [22] and supercombinator techniques <ref> [21] </ref>. Variable sets of combinators keep the size of translated expressions reasonably small while still producing the desired effect of making graph reduction efficient (the com-binators generated tend to be fairly complicated). We settled on a fixed set of combinators for KOLA for two reasons: 1.
Reference: [22] <author> T. Johnsson. </author> <title> Lambda lifting: transforming programs to recursive equations. </title> <booktitle> In Conference on Functional Programming Languages and Computer Architecture, </booktitle> <publisher> LNCS. Springer Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Variable combinator techniques produce new com-binators specific to particular programs. Fixed combinator sets include the SKI combinator set of Schonfinkel [34] (and its many variations) as well as the Category Theory-inspired combinator set of Curien [13]. Variable-set combinators are produced by -lifting <ref> [22] </ref> and supercombinator techniques [21]. Variable sets of combinators keep the size of translated expressions reasonably small while still producing the desired effect of making graph reduction efficient (the com-binators generated tend to be fairly complicated). We settled on a fixed set of combinators for KOLA for two reasons: 1.
Reference: [23] <author> A. Kemper, G. Moerkotte, and K. Peithner. </author> <title> A blackboard architecture for query optimization in object bases. </title> <editor> In R. Agrawal, S. Baker, and D. Bell, editors, </editor> <booktitle> Proceedings if the 19th International Conference on Very Large Databases, </booktitle> <pages> pages 543554, </pages> <address> Dublin, Ireland, </address> <month> August </month> <year> 1987. </year> <month> Morgan-Kaufman. </month>
Reference-contexts: In this section, we explore the reasons why variable-based query algebras make it necessary for rules to include head 402 and body routines. We will use AQUA [25] as a case study, although our remarks apply to other variable-based algebras (e.g. [18], [38], [36] and <ref> [23] </ref>). 2.1 Rules that Build New Functions Anonymous functions are functions denoted without names. An expressive query algebra should permit anonymous functions to be used within a query to express what should be done with each object in a queried collection.
Reference: [24] <author> W. Kim. </author> <title> On optimizing an SQL-like nested query. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 7(3):443469, </volume> <month> September </month> <year> 1982. </year>
Reference-contexts: Such data models exacerbate both the classification and manipulation of nested queries by allowing tuples and objects to refer to sets and to each other. This potentially introduces data dependencies into queries, complicating their transformation as we later show. There has been much progress in nested query optimization <ref> [24] </ref>, [17], [20], [30], [31], [12], [14]. But nested queries tend to be fairly large and rules for them tend to lack generality or have especially complex head and body routines. <p> The transformation described is not new, but as far as we know has not been previously expressed in terms of a set of generally applicable and gradually transforming rules. Optimizer Correctness: The famous count bug of <ref> [24] </ref> illustrates how difficult it can be to formulate correct transformations. Rule-based optimizations simplify correctness proofs of optimizations because rules are simpler to prove correct than algorithms. But this is exactly why rules should not include calls to code. <p> A great deal of research has been done in nested query optimization, but typically this research makes it into practice with complex rules that are difficult to formalize and reason about (e.g., [12] and [20]) or with transformations expressed informally over query languages (e.g., <ref> [24, 17, 31] </ref>). 4.1 Hidden Join Queries The class of queries we consider are hidden joins; nested queries that (like join queries) pair objects that are taken from two sets and that satisfy some relationship. <p> The optimization of hidden joins involves transforming them into nestings of explicit joins, as in the KOLA query K G 2 of Figure 3. This kind of optimization may be advantageous because of the variety of implementation techniques known for performing nestings of joins <ref> [24] </ref>. <p> A reasonable increase in query size resulting from translating queries into combinator form is tolerable because queries tend to be small (compared with functional programs for example). Nested queries have been studied extensively in the relational context <ref> [24] </ref>, and have recently been examined in the context of object-oriented models [12]. In this paper, we have seen how structured data in these models can lead to very complex nested queries. The optimizations described, while useful, are expressed monolithically.
Reference: [25] <author> T. W. Leung, G. Mitchell, B. Subramanian, B. Vance, S. L. Vandenberg, and S. B. Zdonik. </author> <title> The AQUA data model and algebra. </title> <booktitle> In Proc. 4th Int'l Workshop on Database Programming Languages, </booktitle> <address> New York, New York, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: We propose an alternative combinator set to that of [6] that permits smaller translations of queries [11] at the expense of allowing some redundancy. We have implemented translators into our combinator set from both OQL [9] and AQUA <ref> [25] </ref>. (See [11] for details.) This makes our work similar in spirit to the use of combinators in functional language compilers. <p> This means that rule sets should be easily augmented to extend the functionality of existing optimizers. 1.3 Outline of the Paper In Section 2, we present the problems that variables introduce to the formulation of transformation rules. We use examples written in AQUA <ref> [25] </ref>. In Section 3 we present KOLA and show how KOLA simplifies the formulation of these same rules. In Section 4, we show that a KOLA-based rule language can express transformations that typically are not implemented as instances of rules (transformations of nested queries). <p> Therefore it is crucial that the algebra facilitate manipulation of the representation and not be simply a means of expressing a query. In this section, we explore the reasons why variable-based query algebras make it necessary for rules to include head 402 and body routines. We will use AQUA <ref> [25] </ref> as a case study, although our remarks apply to other variable-based algebras (e.g. [18], [38], [36] and [23]). 2.1 Rules that Build New Functions Anonymous functions are functions denoted without names.
Reference: [26] <author> G. Lohman. </author> <title> Grammar-like functional rules for representing query optimization alternatives. </title> <booktitle> In Proceedings of ACM SIGMOD, </booktitle> <month> June </month> <year> 1988. </year>
Reference-contexts: As well, it means that transformations involving manipulation of anonymous functions (as in Figures 1 and 2) require construction of new nodes and not just new trees, and therefore are inexpressible with rule languages based solely on unification. Many rule-based systems (e.g. <ref> [26] </ref>) use rules to map algebraic operators to plan-level implementations. The transformations addressed do not consider rewriting at the source level. [16] has similar motivations to ours in that they attempt to remove code fragments that appear in rules. Like [26] however, their work primarily addresses rules that express source-to-physical transformations. <p> Many rule-based systems (e.g. <ref> [26] </ref>) use rules to map algebraic operators to plan-level implementations. The transformations addressed do not consider rewriting at the source level. [16] has similar motivations to ours in that they attempt to remove code fragments that appear in rules. Like [26] however, their work primarily addresses rules that express source-to-physical transformations. They replace head routines with declarative preconditions that test the values of attributes that annotate the call-graph formed with rules at the nodes.
Reference: [27] <author> D. Maier and S. B. Zdonik. </author> <title> Fundamentals of object-oriented databases. Introduction to the book 'Readings in Object-Oriented Databases. </title>
Reference-contexts: This helps to explain why for example, transformations of nested queries do not typically get implemented as instances of rules. Nested query optimization is particularly important and particularly difficult when nested queries are expressed over data with complex structure, as in nested relational [33], complex object [1] and object-oriented <ref> [27] </ref> databases. Such data models exacerbate both the classification and manipulation of nested queries by allowing tuples and objects to refer to sets and to each other. This potentially introduces data dependencies into queries, complicating their transformation as we later show.
Reference: [28] <author> G. Mitchell. </author> <title> Extensible Query Processing in an Object-Oriented Database. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Brown University, </institution> <address> Providence, Rhode Island 02912-1910, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: To illustrate, we trace the reduction of the Garage Query <ref> [28] </ref> (K G 1 of Figure 3); a query that associates each of a set of Vehicles with the set of Addresses where the Vehicle might be located.
Reference: [29] <author> G. Mitchell, S. B. Zdonik, and U. Dayal. </author> <title> An architecture for query processing in persistent object stores. </title> <booktitle> In Proc. Hawaii Int'l Conference on System Scyences, </booktitle> <volume> Volume II, </volume> <pages> pages 787798, </pages> <year> 1992. </year>
Reference-contexts: But unification demands that a query's representation be revealing (in how the query should be transformed) and manipulable. Variable-based representations complicate unification in both respects. Our concern is with the expression of rules rather than the strategies for their use. The latter, while an important issue, <ref> [29] </ref> is not considered in this paper. 1.2 Our Contributions We propose a variable-free (combinator-based) algebra, KOLA, that supports the formulation of expressive transformation rules. (A good tutorial on combinators can be found in Turner's paper [37]). Combinator-based internal algebras have been considered for queries before.
Reference: [30] <author> M. Muralikrishna. </author> <title> Optimization and dataflow algorithms for nested tree queries. </title> <editor> In P. M. G. Apers and G. Wiederhold, editors, </editor> <booktitle> Proceedings iof the 15th International Conference on Very Large Databases, </booktitle> <pages> pages 7785, </pages> <address> Amsterdam, the Netherlands, </address> <month> August </month> <year> 1989. </year> <month> Morgan-Kaufman. </month>
Reference-contexts: This potentially introduces data dependencies into queries, complicating their transformation as we later show. There has been much progress in nested query optimization [24], [17], [20], <ref> [30] </ref>, [31], [12], [14]. But nested queries tend to be fairly large and rules for them tend to lack generality or have especially complex head and body routines.
Reference: [31] <author> M. Muralikrishna. </author> <title> Improving unnesting algorithms for join aggregate SQL queries. </title> <editor> In Yuan, editor, </editor> <booktitle> Proceedings of the 18th Int'l Conference on Very Large Databases, </booktitle> <address> Vancouver, Canada, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: This potentially introduces data dependencies into queries, complicating their transformation as we later show. There has been much progress in nested query optimization [24], [17], [20], [30], <ref> [31] </ref>, [12], [14]. But nested queries tend to be fairly large and rules for them tend to lack generality or have especially complex head and body routines. <p> A great deal of research has been done in nested query optimization, but typically this research makes it into practice with complex rules that are difficult to formalize and reason about (e.g., [12] and [20]) or with transformations expressed informally over query languages (e.g., <ref> [24, 17, 31] </ref>). 4.1 Hidden Join Queries The class of queries we consider are hidden joins; nested queries that (like join queries) pair objects that are taken from two sets and that satisfy some relationship.
Reference: [32] <author> J. Robinson. </author> <title> A machine-oriented logic based on the resolution principle. </title> <journal> Journal of the ACM, </journal> <volume> 12:2341, </volume> <year> 1965. </year>
Reference-contexts: In particular, representations based on variable-based query algebras (algebras that use variables to name manipulated data) make code fragments necessary supplements to rules. Intuitively, this is because rule-based optimization has the flavor of unification <ref> [32] </ref>; a rule and a query match if the rule head unifies with a part of the query, and the transformation of a matched query is expressed by substituting for the variables that appear in the rule body.
Reference: [33] <author> H. J. Schek and M. Scholl. </author> <title> The relational model with relation-valued attributes. </title> <journal> Information Systems, </journal> <volume> 11(2):137147, </volume> <year> 1986. </year>
Reference-contexts: This helps to explain why for example, transformations of nested queries do not typically get implemented as instances of rules. Nested query optimization is particularly important and particularly difficult when nested queries are expressed over data with complex structure, as in nested relational <ref> [33] </ref>, complex object [1] and object-oriented [27] databases. Such data models exacerbate both the classification and manipulation of nested queries by allowing tuples and objects to refer to sets and to each other. This potentially introduces data dependencies into queries, complicating their transformation as we later show.
Reference: [34] <author> M. Schonfinkel. </author> <title> Uber die bausteine der mathematischen logik. </title> <journal> Math. Annalen, </journal> <volume> 92:305316, </volume> <year> 1924. </year>
Reference-contexts: Fixed combinator sets use the same finite set of combinators as the target for every program's translation. Variable combinator techniques produce new com-binators specific to particular programs. Fixed combinator sets include the SKI combinator set of Schonfinkel <ref> [34] </ref> (and its many variations) as well as the Category Theory-inspired combinator set of Curien [13]. Variable-set combinators are produced by -lifting [22] and supercombinator techniques [21].
Reference: [35] <author> E. Sciore and J. S. Jr. </author> <title> A modular query optimizer generator. </title> <booktitle> In Proceedings of the 6th International Conference on Data Engineering, </booktitle> <pages> pages 146153, </pages> <address> Los Angeles, USA, </address> <year> 1990. </year>
Reference-contexts: Despite the wide-spread use of the rule-based approach, scant mention can be found discussing design issues for rule languages. Rather, rule languages are usually assumed to be by-products of algebra definitions and not considered in and of themselves. An exception is the work of Sciore and Sieg <ref> [35] </ref>, who suggest ways to augment rule languages over variable-based algebras to ensure formulation of a wide variety of rules. Proposed extensions include rule preconditions (expressed in code), and multivariables (abstractions of variable lists) that allow optimization rules to be independent of function arity. <p> In short, multivariables and precondition code are intended to address the same problem that we do; variables in query algebras make rules over algebraic representations difficult to express without additional machinery. But whereas <ref> [35] </ref> 410 add the machinery, we instead remove the variables. As we mentioned earlier, ours is not the first combinator-based algebra proposed in a database context. [15] and [5] propose an FP-style [3] query language.
Reference: [36] <author> D. D. Straube and M. T. Ozsu. </author> <title> Queries and query processing in object-oriented database systems. </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 8(4), </volume> <year> 1990. </year>
Reference-contexts: In this section, we explore the reasons why variable-based query algebras make it necessary for rules to include head 402 and body routines. We will use AQUA [25] as a case study, although our remarks apply to other variable-based algebras (e.g. [18], [38], <ref> [36] </ref> and [23]). 2.1 Rules that Build New Functions Anonymous functions are functions denoted without names. An expressive query algebra should permit anonymous functions to be used within a query to express what should be done with each object in a queried collection.
Reference: [37] <author> D. A. Turner. </author> <title> A new implementation technique for applicative languages. </title> <journal> Software Practice and Experience, </journal> <volume> 9:3149, </volume> <year> 1979. </year>
Reference-contexts: The latter, while an important issue, [29] is not considered in this paper. 1.2 Our Contributions We propose a variable-free (combinator-based) algebra, KOLA, that supports the formulation of expressive transformation rules. (A good tutorial on combinators can be found in Turner's paper <ref> [37] </ref>). Combinator-based internal algebras have been considered for queries before. In particular, [6] uses a combinator algebra to express the semantics for their query calculus and to allow category theory machinery to be used to reason about the correctness of transformations.
Reference: [38] <author> S. L. Vandenberg and D. J. DeWitt. </author> <title> Algebraic support for complex objects with arrays, identity, and inheritance. </title> <editor> In J. Clifford and R. King, editors, </editor> <booktitle> Proceedings of the SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 158167, </pages> <address> Denver, Colorado, </address> <month> May </month> <year> 1991. </year> <booktitle> ACM Special Interest Group on Management of Data, </booktitle> <publisher> ACM Press. </publisher> <pages> 412 </pages>
Reference-contexts: In this section, we explore the reasons why variable-based query algebras make it necessary for rules to include head 402 and body routines. We will use AQUA [25] as a case study, although our remarks apply to other variable-based algebras (e.g. [18], <ref> [38] </ref>, [36] and [23]). 2.1 Rules that Build New Functions Anonymous functions are functions denoted without names. An expressive query algebra should permit anonymous functions to be used within a query to express what should be done with each object in a queried collection.
References-found: 38

