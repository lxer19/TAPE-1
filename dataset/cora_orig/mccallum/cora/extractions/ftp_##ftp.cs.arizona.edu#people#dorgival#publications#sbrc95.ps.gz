URL: ftp://ftp.cs.arizona.edu/people/dorgival/publications/sbrc95.ps.gz
Refering-URL: http://www.cs.arizona.edu/people/dorgival/
Root-URL: http://www.cs.arizona.edu
Email: E-mail: fdorgival,bakken,nina,matti,rickg@cs.arizona.edu  
Title: A Customized Communication Subsystem for FT-Linda Sistemas distribudos tolerantes a falhas usualmente imp~oem maiores exig^encias
Author: Dorgival O. Guedes David E. Bakken Nina T. Bhatti Matti A. Hiltunen Richard D. Schlichting desenvolvidas replicando-se um processo em varias maquinas, onde todas Este artigo descreve o desen-volvimento de um protocolo uma aplica~c~ao especfica, o ambiente de execu~c~ao de FT-Linda, uma vers~ao tolerante a falhas da linguagem de coordena~c~ao Linda. O sistema exige um protocolo de comunica~c~ao capaz de prover detec~c~ao de falhas, iden-tifica~c~ao de participantes e um servi~co de se basea em um novo ambiente para composi~c~ao de micro-protocolos acionados por 
Note: Resumo  utilizado em combina~c~ao com o -kernel. This work supported in part by the Office of Naval Research under grant N00014-91-J-1015. Sponsored by Conselho Nacional de Pesquisa (CNPq), Brazil, Process no. 200861/93-0 Current address: Distributed  
Address: Tucson, AZ 85721, USA  10 Moulton Street MS 6/3D, Cambridge, MA 02138 USA  
Affiliation: Department of Computer Science University of Arizona  eventos que e  Systems Department, BBN Systems and Technologies,  
Abstract: Distributed fault-tolerant systems usually impose much stronger requirements on the underlying communication protocols than do applications developed without fault-tolerance in mind. That is true, for example, of applications composed of processes replicated on multiple hosts, where all replicas must keep the same view of the state of the communication. This paper describes how the communication substrate for a specific application with strong communication requirements was developed. The application, the runtime system for a fault-tolerant version of the Linda language called FT-Linda, requires a communication substrate capable of providing ordered atomic multicast, failure detection and membership services. The implementation relies on a new framework for the composition of event-driven micro-protocols that is used with the x-kernel. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> David E. Bakken. </author> <title> Supporting fault-tolerant parallel programming in linda. </title> <type> Technical Report TR 94-23, </type> <institution> Computer Science Department, University of Arizona, </institution> <address> Tucson, AZ, </address> <month> August </month> <year> 1994. </year> <type> Ph.D. Dissertation. </type>
Reference-contexts: It should be noted that the description of FT-Linda presented here was developed as a short introduction to provide just the background necessary for the analysis of the underlying communication substrate, the real focus of this paper. A detailed description of the semantics and implementation can be found in <ref> [1] </ref>. 2 FT-Linda 1 Linda basic concepts. Linda is a language for parallel programming based on tuple spaces (TS), a communication abstraction defined as a bag that can hold data elements called tuples. These tuples are data aggregates that have a logical name and zero or more values. <p> Currently it assumes that processors remain failed for the duration of the computation and are not reintegrated back into the system. 1 A detailed description of the language and its implementation can be found in <ref> [1] </ref> 2.1 Syntax and semantics To address the deficiencies mentioned above, FT-Linda includes provisions for defining stable TSs and a new syntax that allows a series of TS operations to be defined as atomic. Stable tuple spaces. <p> In this way, all interrupted tasks can be processed later by other workers. More details on this and other examples can be found in <ref> [1, 2] </ref>. 2.2 FT-Linda implementation Given the semantics just described, the challenge is to provide a reasonable implementation of atomic execution and stable TSs. <p> The state machine can be implemented easily using the abstractions provided by the x-kernel; specifically, the arrival of a message causes the proper operations in the state machine to be invoked. The reader is refered to <ref> [1] </ref> for a detailed description of this implementation. The communication substrate, on the other hand, is much more difficult to implement given that it incorporates a great variety of tasks on which the entire system depends.
Reference: [2] <author> David E. Bakken and Richard D. Schilichting. </author> <title> Supporting fault-tolerant parallel programming in linda. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 6(3), </volume> <month> March </month> <year> 1995. </year>
Reference-contexts: This paper describes a case study in which a customized service is constructed using this approach for FT-Linda, a version of the Linda coordination language designed for writing fault-tolerant parallel programs <ref> [2] </ref>. The service, an atomic ordered multicast protocol that is used as the communication substrate for the language runtime system, has proven to be difficult to construct in practice. This has been demonstrated, for example, by earlier experience with Consul, the protocol suite previously used by FT-Linda [14]. <p> In this way, all interrupted tasks can be processed later by other workers. More details on this and other examples can be found in <ref> [1, 2] </ref>. 2.2 FT-Linda implementation Given the semantics just described, the challenge is to provide a reasonable implementation of atomic execution and stable TSs.
Reference: [3] <author> Nina T. Bhatti and Richard D. Schlichting. </author> <title> Operating system support for configurable high-level protocols. </title> <type> Technical report, </type> <institution> Department of Computer Science, University of Arizona, </institution> <address> Tucson, AZ, USA, </address> <year> 1994. </year> <note> In preparation. </note>
Reference-contexts: with these considerations in mind that a new approach for implementing fault-tolerant services using micro-protocols and event-driven execution was developed. 3.1 Event-driven protocol composition 2 A communication substrate with the required properties is realized using a model for composing fine-grained software modules [9] and its associated x-kernel based implementation platform <ref> [3] </ref>. The basic building block of this model is a collection of micro-protocols, each of which implements a well-defined property. A micro-protocol, in turn, is structured as a collection of event handlers, which are procedure-like segments of code that are invoked when an event occurs.
Reference: [4] <author> Kenneth Birman, Andre Schiper, and Pat Stephenson. </author> <title> Lightweight causal and atomic group multicast. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: This ordered delivery guarantees that all replicas execute all commands in the same order. Provided that the commands are deterministic and executed atomically in relation to each other, state variables of all replicas are kept consistent. The SMA is the basis for a large number of fault-tolerant systems <ref> [4, 14, 17] </ref>. Achieving atomicity can be done by exploiting the characteristics of the SMA, since each command is executed by a state machine atomically and the underlying atomic multicast guarantees that all commands are executed in the same order.
Reference: [5] <author> Nicholas Carriero and David Gelernter. </author> <title> How to Write Parallel Programs: A First Course. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Other operations are defined, like rd, inp and rdp, but these are basically adaptations of in and out. Figure 1 shows how Linda can be used to implement a worker process under the bag-of-tasks paradigm <ref> [5] </ref>. process worker while true do in ("work",?subtask args) calc (subtask args; var result args) for (all new subtasks created by this subtask) out ("work", new subtask args) out ("result",result args) end while end proc Problems with failures.
Reference: [6] <author> Paolo Ciancarini. </author> <title> Distributed programming with logic tuple spaces. </title> <type> Technical Report UBLCS-93-7, </type> <institution> Laboratory for Computer Science, University of Bologna, </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: Stable tuple spaces. The original Linda language defined only one globally visible TS that is shared by all applications. After that, many different studies have suggested various features to allow multiple TSs to be defined under the control of the application <ref> [8, 6] </ref>. That feature is incorporated in FT-Linda, and is further extended with attributes. Tuple spaces may be assigned special attributes that define how they behave in the presence of failures, among other issues. Currently these attributes are resilience and scope.
Reference: [7] <author> Flaviu Cristian. </author> <title> Understanding fault-tolerant systems. </title> <journal> Communications of th, </journal> <volume> 34(2) </volume> <pages> 56-78, </pages> <address> e ACM 1991. </address>
Reference-contexts: Among these techniques, communication protocols that provide elaborate services like failure detection, membership management and atomic multicast are some of the important building blocks available <ref> [19, 7, 11] </ref>. Due to the strong requirements imposed on fault-tolerant systems, such protocols are usually extremely complex and constrained to provide only a single set of rigidly defined semantics, which makes them very difficult to construct and use.
Reference: [8] <author> Dorgival O. Guedes and Osvaldo S. F. Carvalho. </author> <title> Um nucleo Linda para o desenvolvi-mento de aplica~c~oes distribudas em uma rede unix. </title> <booktitle> In Proceedings of X Simposio Brasileiro de Redes de Computadores, </booktitle> <address> Recife, PE, Brazil, </address> <month> April </month> <year> 1992. </year> <month> SBC. </month>
Reference-contexts: Many current implementations use some kind of signature to partition tuples among the participating hosts. On these systems, the failure of a host may cause the loss of an unpredictable subset of tuples in the TS <ref> [8] </ref>. Lack of sufficient atomicity: Only the basic operations are defined to be atomic in Linda, what means intermediate states during the execution of a series of operations can be seen by other processes. <p> Stable tuple spaces. The original Linda language defined only one globally visible TS that is shared by all applications. After that, many different studies have suggested various features to allow multiple TSs to be defined under the control of the application <ref> [8, 6] </ref>. That feature is incorporated in FT-Linda, and is further extended with attributes. Tuple spaces may be assigned special attributes that define how they behave in the presence of failures, among other issues. Currently these attributes are resilience and scope.
Reference: [9] <author> Matti A. Hiltunen and Richard D. Schlichting. </author> <title> An approach to constructing modular fault-tolerant protocols. </title> <booktitle> In Proceedings of the 12th IEEE Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 105-114, </pages> <address> Princeton, NJ, USA, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: It was with these considerations in mind that a new approach for implementing fault-tolerant services using micro-protocols and event-driven execution was developed. 3.1 Event-driven protocol composition 2 A communication substrate with the required properties is realized using a model for composing fine-grained software modules <ref> [9] </ref> and its associated x-kernel based implementation platform [3]. The basic building block of this model is a collection of micro-protocols, each of which implements a well-defined property.
Reference: [10] <author> Matti A. Hiltunen and Richard D. Schlichting. </author> <title> Constructing a configurable group rpc service. </title> <booktitle> Submitted to 15th Conference on Distributed Computing Systems, </booktitle> <year> 1995. </year>
Reference-contexts: Event registration, detection, and invocation are implemented by a standard run-time or framework that is linked with the micro-protocols. The framework also supports 2 Text for this sub-section appeared previously in <ref> [10] </ref> shared data (e.g., messages) that can be accessed by the micro-protocols configured into the framework. The object formed by the linking of a collection of micro-protocols and associated framework is known as a composite protocol.
Reference: [11] <author> Matti A. Hiltunen and Richard D. Schlichting. </author> <title> Properties of membership services. </title> <booktitle> In Proceedings of the 2nd International Symposium on Autonomous Decentralized Systems, </booktitle> <address> Phoenix, AZ, USA, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: Among these techniques, communication protocols that provide elaborate services like failure detection, membership management and atomic multicast are some of the important building blocks available <ref> [19, 7, 11] </ref>. Due to the strong requirements imposed on fault-tolerant systems, such protocols are usually extremely complex and constrained to provide only a single set of rigidly defined semantics, which makes them very difficult to construct and use.
Reference: [12] <author> Norman C. Hutchinson and Larry L. Peterson. </author> <title> The x-kernel: An architecture for implementing network protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-76, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: In our design, the TS state machines and the communication substrate are implemented as protocols in the x-kernel, a system for composing network protocols <ref> [12] </ref>. The state machine can be implemented easily using the abstractions provided by the x-kernel; specifically, the arrival of a message causes the proper operations in the state machine to be invoked. The reader is refered to [1] for a detailed description of this implementation.
Reference: [13] <author> Leslie Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: Context graph handling: As in Psync [16], the ordering of messages is achieved by first determining their causal ordering <ref> [13] </ref>. That information is kept as a context graph representing the causal dependencies between messages. Reliability: The substrate may have to keep track of lost messages and be able to request their retransmission.
Reference: [14] <author> Shivakant Mishra, Larry L. Peterson, and Richard D. Schlichting. </author> <title> Consul: A communication substrate for fault-tolerant distributed programs. </title> <journal> Distributed Systems Engineering, </journal> <volume> 1 </volume> <pages> 87-103, </pages> <year> 1993. </year>
Reference-contexts: The service, an atomic ordered multicast protocol that is used as the communication substrate for the language runtime system, has proven to be difficult to construct in practice. This has been demonstrated, for example, by earlier experience with Consul, the protocol suite previously used by FT-Linda <ref> [14] </ref>. When compared to the original design done with Consul, the system constructed using micro-protocols is simpler and better tuned to the special characteristics of the FT-Linda runtime system. <p> This ordered delivery guarantees that all replicas execute all commands in the same order. Provided that the commands are deterministic and executed atomically in relation to each other, state variables of all replicas are kept consistent. The SMA is the basis for a large number of fault-tolerant systems <ref> [4, 14, 17] </ref>. Achieving atomicity can be done by exploiting the characteristics of the SMA, since each command is executed by a state machine atomically and the underlying atomic multicast guarantees that all commands are executed in the same order. <p> The communication substrate, on the other hand, is much more difficult to implement given that it incorporates a great variety of tasks on which the entire system depends. One approach to implementing the communication substrate is to use an available atomic multicast protocol, like Consul <ref> [14] </ref>, and just provide an interface between it and the TSSM. Another approach is to develop a new protocol specially tailored to the needs of the system. <p> The algorithms involved are directly derived from those developed for Psync and Consul, and are described only briefly. The reader is directed to <ref> [14] </ref> and [16] for a more detailed discussion. 4.1 Data structures The implementation is built around three main data structures, usually handled by specific micro-protocols, but of importance for the correct operation of the entire composite protocol.
Reference: [15] <author> Shivakant Mishra, Larry L. Peterson, and Richard D. Schlichting. </author> <title> Experience with modularity in consul. </title> <journal> Software | Practice and Experience, </journal> <volume> 23(10) </volume> <pages> 1059-1075, </pages> <month> Octo-ber </month> <year> 1993. </year>
Reference-contexts: The implementation can then be based on such a decomposition. As the experience with Consul shows, this can make the development much easier to understand, although the interaction among the parts can be difficult to model using the x-kernel <ref> [15] </ref>.
Reference: [16] <author> Larry L. Peterson, N. C. Buchholz, and Richard D. Schlichting. </author> <title> Preserving and using context information in interprocess communication. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7 </volume> <pages> 217-246, </pages> <year> 1989. </year>
Reference-contexts: Membership check: Information about a host that has not been transmitting for some time must be exchanged with other hosts before some agreement is reached about the state of a host suspected to be down. Context graph handling: As in Psync <ref> [16] </ref>, the ordering of messages is achieved by first determining their causal ordering [13]. That information is kept as a context graph representing the causal dependencies between messages. Reliability: The substrate may have to keep track of lost messages and be able to request their retransmission. <p> The algorithms involved are directly derived from those developed for Psync and Consul, and are described only briefly. The reader is directed to [14] and <ref> [16] </ref> for a more detailed discussion. 4.1 Data structures The implementation is built around three main data structures, usually handled by specific micro-protocols, but of importance for the correct operation of the entire composite protocol. <p> A detailed analysis of this algorithm shows that this guarantees that the same total order will be seen by all hosts in the group <ref> [16] </ref>. Again, we intend to take advantage of the flexibility of the composite protocol model to study how different topological sorting schemes will affect the performance of the FT-Linda runtime system. 4.3.9 Other micro-protocols There are a few additional micro-protocols that provide secondary aspects of the service.
Reference: [17] <author> David Powell. Delta-4: </author> <title> A Generic Architecture for Dependable Distributed Computing. </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: This ordered delivery guarantees that all replicas execute all commands in the same order. Provided that the commands are deterministic and executed atomically in relation to each other, state variables of all replicas are kept consistent. The SMA is the basis for a large number of fault-tolerant systems <ref> [4, 14, 17] </ref>. Achieving atomicity can be done by exploiting the characteristics of the SMA, since each command is executed by a state machine atomically and the underlying atomic multicast guarantees that all commands are executed in the same order.
Reference: [18] <author> Richard D. Schlichting and Fred B. Schneider. </author> <title> Fail-stop processors: An approach to designing fault-tolerant computing systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 1(3) </volume> <pages> 222-238, </pages> <month> August </month> <year> 1983. </year>
Reference-contexts: FT-Linda extends the original Linda model with stable tuple spaces and atomic execution of sequences of operations to provide improved support for building fault-tolerant applications. The model assumes that processors suffer only fail-stop failures <ref> [18] </ref>, where the runtime system provide failure notification by depositing a distinguished failure tuple into TS.
Reference: [19] <author> Fred Schneider. </author> <title> Abstractions for fault-tolerance in distributed systems. </title> <booktitle> In Proceedings of the Tenth IFIP World Computer Congress, </booktitle> <pages> pages 727-733, </pages> <address> Dubli, Ireland, </address> <month> September </month> <year> 1986. </year>
Reference-contexts: Among these techniques, communication protocols that provide elaborate services like failure detection, membership management and atomic multicast are some of the important building blocks available <ref> [19, 7, 11] </ref>. Due to the strong requirements imposed on fault-tolerant systems, such protocols are usually extremely complex and constrained to provide only a single set of rigidly defined semantics, which makes them very difficult to construct and use.
Reference: [20] <author> Fred Schneider. </author> <title> Implementing fault-tolerant services using the state machine approach. </title> <journal> ACM Computing Surveys, </journal> <volume> 22(4) </volume> <pages> 299-319, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Since the situation at hand also requires that tuples be shared among different processors, replication is a better choice. To implement replicated TSs we use the replicated state machine approach (SMA) <ref> [20] </ref>. In this technique, a fault-tolerant application is implemented as a state machine that contains state variables and makes modifications in response to commands from other state machines or external sources.
References-found: 20

