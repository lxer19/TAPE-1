URL: http://www.cs.jhu.edu/labs/pll/papers/subcon.ps
Refering-URL: http://www.cs.jhu.edu/labs/pll/home.html
Root-URL: http://www.cs.jhu.edu
Email: ftrifonov, scottg@cs.jhu.edu  
Title: Subtyping Constrained Types (Revised Draft)  
Author: Valery Trifonov Scott Smith 
Date: May 7, 1996  
Web: http://www.cs.jhu.edu/hog/  
Address: Baltimore, MD 21218, USA  
Affiliation: Department of Computer Science, Johns Hopkins University  
Abstract: A constrained type is a type that comes with a set of subtyping constraints on variables occurring in the type. Constrained type inference systems are a natural generalization of Hindley/Milner type inference to languages with subtyping. This paper develops several subtyping relations on polymorphic constrained types of a general form that allows recursive constraints and multiple bounds on type variables. We establish a full type abstraction property that equates a novel operational notion of subtyping with a semantic notion based on regular trees. The decidability of this notion of subtyping is open; we present a decidable approximation. Subtyping constrained types has applications to signature matching and to constrained type simplification. The relation will thus be a critical component of any programming language incorporating a constrained typing system.
Abstract-found: 1
Intro-found: 1
Reference: [AC93] <author> R. Amadio and L. Cardelli. </author> <title> Subtyping recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(4) </volume> <pages> 575-631, </pages> <month> September </month> <year> 1993. </year> <note> Extended abstract in POPL 1991. </note>
Reference-contexts: In the process of defining these subtyping relations, other results of independent interest are derived. First, an entailment relation K ` t t 0 over simple types t is axiomatized. The set C is a system of arbitrary type constraints, thus generalizing the system of <ref> [AC93] </ref> which only allows one upper, non-recursive bound of each variable C. We define two reduced forms of constraint sets, constraint maps (kernel) and canonical maps, which are also of use as more compact representations of constraint sets in algorithms such as type inference. <p> Both a semantic theory and a decidable axiomatization are developed. This primitive subtyping theory may be contrasted with existing theories of similar form. <ref> [AC93] </ref> is one such theory; in this work the constraint sets C are restricted to e.g. have no lower bounds and at most one upper bound on each type variable; furthermore none of the constraints in C [ ft t 0 g can be recursive. <p> It turns out that the addition of the solutions of recursive type equations to the ground types gives just enough points to define an appropriate semantics. In the next section a theorem will be proven which rigorously demonstrates this fact. We use the convenient notion of regular trees <ref> [Cou83, AC93] </ref> to model solutions of recursive type equations; another reason we use a regular tree model instead of e.g. ideals is that we expect it to scale better to more full-featured languages. We present the semantics of constraint sets in terms of regular trees over a ranked alphabet. <p> We present the semantics of constraint sets in terms of regular trees over a ranked alphabet. Let us review some definitions and results from <ref> [Cou83, AC93] </ref>. <p> With the extra assumption these are induction rules, similar to the (FIX) rule of [ESTZ95]. Two rules often present in systems with subtyping <ref> [AC93] </ref> but omitted here concern the general reflexivity and transitivity of the relation; and while it is easy to see that reflexivity is a meta-rule (K ` t t is always provable for FTV (t ) Dom (K)), transitivity only holds for consistent constraint maps. <p> Thus, each pair of type subterms in K [ ft t 0 g is only encountered at most once (though we may encounter syntactically identical pairs more than once). A parallel can be drawn between our system of subtyping rules and the system ` AC of Amadio and Cardelli <ref> [AC93] </ref>, which is based on a relation of equivalence between recursive types, and on the inductive rule () C ` AC t: t t 0 : t 0 Since recursive types can be encoded as type variables with identical upper and lower bounds, the corresponding rule for simple types with constraints <p> stronger version by successive applications of (") and (#); furthermore, the steps of the proof of K; t = t; t 0 = t 0 ` t t 0 follow closely the steps of the algorithm for computing C ` AC t: t t 0 : t 0 presented in <ref> [AC93] </ref>, which also effectively constructs the type contexts necessary in order to establish type equivalences. <p> Our system, while still incomplete with respect to the model we present, is capable of proving the corresponding forms of all sequents provable in <ref> [AC93] </ref>, in addition allowing multiple recursive upper and lower bounds on type variables, e.g. t &gt; ! t; t 0 = &gt; ! t 0 ` t t 0 . 3.6 Satisfiability of Canonical Constraint Maps A constrained type only has meaning if its constraints describe a non-empty set of instances, <p> We believe this direct approach to type soundness of constrained type systems should be applicable to other constrained type languages. Amadio and Cardelli <ref> [AC93] </ref> present a type system ` with recursive types (modeled by regular trees) and a subtyping relation on them equivalent to tree . <p> X = e in e 0 as let X = e in (X; e 0 ) for type-checking purposes. 5 We write the inference rules with a top-down propagation of the contexts; a bottom-up presentation with synthesized context components is also possible. 15 PROOF: Implied by the soundness of ` <ref> [AC93] </ref>: the typability of a term e under ` T sem implies the typability of LE (e) under ` , which by soundness of ` implies that the evaluation of LE (e) will not cause a run-time error.
Reference: [AW93] <author> A. Aiken and E. L. Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Proceedings of the International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 31-41, </pages> <year> 1993. </year>
Reference-contexts: A type inference algorithm for polymorphic constrained types of the form studies here was first discovered by Curtis [Cur90], and later independently discovered in somewhat different form, and first proven sound, by Aiken & Wimmers <ref> [AW93] </ref>. These constraint system are less restrictive than the previously cited formulations. For one, recursive constraints such as t t !intare legal. <p> on a single variable (multiple bounds such as ft t 1 ; t t 2 g are fl Partially supported by NSF grant CCR-9312433 y Partially supported by AFOSR grant F49620-93-1-0169 1 expressed equivalently as t t 1 " t 2 , where " is the type intersection operator of <ref> [AW93] </ref>). This extra flexibility allowed in the constraint sets produces a more powerful, but computationally more complex, inference algorithm. Our long-term goal is to apply the techniques of constrained types and constrained type inference to object-oriented programming languages; previous results include [EST95b, EST95a].
Reference: [AWL94] <author> A. Aiken, E. L. Wimmers, and T. K. Lakshman. </author> <title> Soft typing with conditional types. </title> <booktitle> In Conference Record of the Twenty-First Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 163-173, </pages> <year> 1994. </year>
Reference-contexts: The ideal model [MPS86] may also be used as a basis of a constrained type ordering 8 ideal <ref> [AWL94] </ref>, but it is not fully abstract. 8 sem is a surprisingly complex relation: we leave open the question whether 8 sem = 8 obs is decidable, and develop a powerful decidable approximation 8 dec . There are at least two applications of this subtyping relation 8 . <p> This is an example where differences arise when recursive constraint sets are allowedif recursive constraint sets were not allowed, the simple type basis would have been appropriate. Another candidate is the ideal model [MPS86] used in <ref> [AWL94] </ref>, it conversely has too many points. Polymorphic types such as 8t:t ! t may be substituted for type variables, but since our system is shallow these points are superfluous in our framework.
Reference: [BCC + 96] <author> Kim Bruce, Luca Cardelli, Giuseppe Castagna, The Hopkins Objects Group, Gary T. Leavens, and Ben-jamin Pierce. </author> <title> On binary methods. </title> <journal> Theory and Practice of Object Systems, </journal> <note> 1996. (to appear; see ftp://ftp.cs.iastate.edu/pub/techreports/TR95-08/TR.ps.Z). </note>
Reference-contexts: Constrained types are particularly appropriate for object-oriented programming languages: these types incorporate subtyping which is critical in an object-oriented setting, and their greater flexibility gives a reasonable solution to the binary methods problem <ref> [BCC + 96] </ref>. <p> There are many possibilities for the notion of instance. The simplest is to allow instances to range over the variable-free types constructed from &gt;, ?, and !. However, for our purposes this does not give enough points in the space of instances, e.g. when typing binary methods <ref> [BCC + 96] </ref> we have to work with recursive constraint sets such as ft ! t t; t t ! &gt;g, which have no solutions in this space.
Reference: [BM96] <author> Francois Bourdoncle and Stephan Merz. </author> <title> On the integration of functional programming, class-based object-oriented programming, and multi-methods. </title> <type> Manuscript. </type> <note> Available at http://www.ensmp.fr/bourdonc/mlsub.html, 1996. </note>
Reference-contexts: The idea of including subtyping constraints as part of typing judgements was first developed by Mitchell [Mit84, Mit91]. His constraint sets were restricted to be atomic, allowing coercions between type variables only. Numerous other researchers have defined restricted forms of constraint inference system, including <ref> [MR85, FM88, Kae92, BM96] </ref>. A type inference algorithm for polymorphic constrained types of the form studies here was first discovered by Curtis [Cur90], and later independently discovered in somewhat different form, and first proven sound, by Aiken & Wimmers [AW93]. <p> However the converse fails: for instance 8t: hi ) t n f&gt; ! &gt; ! t tg 8 8t: hi ) t n f&gt; ! t tg, but not the other way around as allowed by 8 dec . Bourdoncle and Merz <ref> [BM96] </ref> have independently addressed the problem of subtyping constrained types in the context of a system where recursive constraints are not allowed, with applications to typing of object-oriented programs with multi-methods.
Reference: [Car84] <author> L. Cardelli. </author> <title> A semantics of multiple inheritance. In Semantics of Data Types, </title> <booktitle> volume 173 of Lecture notes in Computer Science, </booktitle> <pages> pages 51-67. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: transitivity of tree it follows that 0 satisfies (A A 0 ) [ ft 0 t g, hence by Corollary 3.6 Cl (C [ C 0 [ (A A 0 ) [ ft 0 t g) is consistent. 3 This subtyping rule for contexts is similar to standard record subtyping <ref> [Car84] </ref>; indeed the closure conversion [[x]] = E: E.x, [[x: e]] = E: x: [[e]]- x i = E.x i j x i 2FV (e)fxg ; x = x -, and [[e e 0 ]] = E: [[e]] E ([[e 0 ]] E) makes the environment explicit and maps terms of
Reference: [Cou83] <author> B. Courcelle. </author> <title> Fundamental properties of infinite trees. </title> <journal> Theoretical Computer Science, </journal> <volume> 25 </volume> <pages> 95-169, </pages> <year> 1983. </year>
Reference-contexts: It turns out that the addition of the solutions of recursive type equations to the ground types gives just enough points to define an appropriate semantics. In the next section a theorem will be proven which rigorously demonstrates this fact. We use the convenient notion of regular trees <ref> [Cou83, AC93] </ref> to model solutions of recursive type equations; another reason we use a regular tree model instead of e.g. ideals is that we expect it to scale better to more full-featured languages. We present the semantics of constraint sets in terms of regular trees over a ranked alphabet. <p> We present the semantics of constraint sets in terms of regular trees over a ranked alphabet. Let us review some definitions and results from <ref> [Cou83, AC93] </ref>.
Reference: [Cur90] <author> Pavel Curtis. </author> <title> Constrained quantification in polymorphic type analysis. </title> <type> Technical Report CSL-90-1, </type> <institution> XEROX Palo Alto Research Center, CSLPubs.parc@xerox.com, </institution> <year> 1990. </year>
Reference-contexts: His constraint sets were restricted to be atomic, allowing coercions between type variables only. Numerous other researchers have defined restricted forms of constraint inference system, including [MR85, FM88, Kae92, BM96]. A type inference algorithm for polymorphic constrained types of the form studies here was first discovered by Curtis <ref> [Cur90] </ref>, and later independently discovered in somewhat different form, and first proven sound, by Aiken & Wimmers [AW93]. These constraint system are less restrictive than the previously cited formulations. For one, recursive constraints such as t t !intare legal.
Reference: [EST95a] <author> J. Eifrig, S. Smith, and V. Trifonov. </author> <title> Sound polymorphic type inference for objects. </title> <booktitle> In OOPSLA '95, </booktitle> <pages> pages 169-184, </pages> <year> 1995. </year>
Reference-contexts: This extra flexibility allowed in the constraint sets produces a more powerful, but computationally more complex, inference algorithm. Our long-term goal is to apply the techniques of constrained types and constrained type inference to object-oriented programming languages; previous results include <ref> [EST95b, EST95a] </ref>. Constrained types are particularly appropriate for object-oriented programming languages: these types incorporate subtyping which is critical in an object-oriented setting, and their greater flexibility gives a reasonable solution to the binary methods problem [BCC + 96]. <p> A principal typing property is established for our type inference algorithm. In this paper we work over a simple language with only function, top, and bottom types to reduce clutter. However, previous work <ref> [EST95b, EST95a] </ref> shows how state, records, variants, classes, and objects all may be incorporated in a constrained type framework, and we explicitly avoid semantic tools (such as the ideal model of types [MPS86]) which lack a strong potential to generalize to such constructs. <p> In addition, 8 dec is sufficiently strong to allow proving correctness of many useful simplifications of types inferred by the system. For example, 8 dec can be used to show the soundness of the constraint set simplification garbage collection of <ref> [EST95a] </ref>, which allows the removal of unreachable constraints. <p> Our experience with applications of constrained type systems to object-oriented languages <ref> [EST95b, EST95a] </ref> shows that keeping track of polarity makes a significant difference when simplifying types inferred for new objects (which are fixed points of classes)type variables associated with objects have often large upper bounds inherited from the class definition (before taking the fixed point); they are removed by our garbage collection <p> We introduce two natural notions of subtyping, observational 8 obs and semantic 8 sem , and prove that they are equivalent; we further give a decidable approximation 8 dec to these relations. Both results represent improvements over recent work on subtyping of constrained types with recursive constraints <ref> [EST95a, Pot96, Jim96a] </ref>. We also introduce a novel closed form of constraint types with contexts, which eliminates the problems associated with free type variables. Finally, we present a type system with principal constrained types, and establish its soundness via reduction to the system of Amadio and Cardelli.
Reference: [EST95b] <author> J. Eifrig, S. Smith, and V. Trifonov. </author> <title> Type inference for recursively constrained types and its application to OOP. </title> <booktitle> In Proceedings of the 1995 Mathematical Foundations of Programming Semantics Conference, volume 1 of Electronic Notes in Theoretical Computer Science. </booktitle> <publisher> Elsevier, </publisher> <year> 1995. </year> <note> http://www.elsevier.nl/locate/entcs/volume1.html. </note>
Reference-contexts: This extra flexibility allowed in the constraint sets produces a more powerful, but computationally more complex, inference algorithm. Our long-term goal is to apply the techniques of constrained types and constrained type inference to object-oriented programming languages; previous results include <ref> [EST95b, EST95a] </ref>. Constrained types are particularly appropriate for object-oriented programming languages: these types incorporate subtyping which is critical in an object-oriented setting, and their greater flexibility gives a reasonable solution to the binary methods problem [BCC + 96]. <p> A principal typing property is established for our type inference algorithm. In this paper we work over a simple language with only function, top, and bottom types to reduce clutter. However, previous work <ref> [EST95b, EST95a] </ref> shows how state, records, variants, classes, and objects all may be incorporated in a constrained type framework, and we explicitly avoid semantic tools (such as the ideal model of types [MPS86]) which lack a strong potential to generalize to such constructs. <p> Our experience with applications of constrained type systems to object-oriented languages <ref> [EST95b, EST95a] </ref> shows that keeping track of polarity makes a significant difference when simplifying types inferred for new objects (which are fixed points of classes)type variables associated with objects have often large upper bounds inherited from the class definition (before taking the fixed point); they are removed by our garbage collection <p> We may now establish soundness of the typing rules of Figure 2. In our previous proofs of soundness of constrained typing systems <ref> [EST95b] </ref>, a direct subject reduction argument was used. Recent observations concerning the close relation between constrained type systems and simple type systems [PS96] allow us to establish soundness based on soundness of a simple type system.
Reference: [ESTZ95] <author> J. Eifrig, S. Smith, V. Trifonov, and A. Zwarico. </author> <title> An interpretation of typed OOP in a language with state. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 8(4) </volume> <pages> 357-397, </pages> <year> 1995. </year>
Reference-contexts: With the extra assumption these are induction rules, similar to the (FIX) rule of <ref> [ESTZ95] </ref>.
Reference: [FM88] <author> Y.-C. Fuh and P. Mishra. </author> <title> Type inference with subtypes. </title> <booktitle> In European Symposium on Programming, </booktitle> <year> 1988. </year>
Reference-contexts: The idea of including subtyping constraints as part of typing judgements was first developed by Mitchell [Mit84, Mit91]. His constraint sets were restricted to be atomic, allowing coercions between type variables only. Numerous other researchers have defined restricted forms of constraint inference system, including <ref> [MR85, FM88, Kae92, BM96] </ref>. A type inference algorithm for polymorphic constrained types of the form studies here was first discovered by Curtis [Cur90], and later independently discovered in somewhat different form, and first proven sound, by Aiken & Wimmers [AW93].
Reference: [Jim96a] <author> Trevor Jim. </author> <title> Principal typings and type inference. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <year> 1996. </year> <note> (to appear). </note>
Reference-contexts: The algorithm for verifying entailment uses explicit unions and intersections in place of the canonicalization of the constraint maps in our rules; this may be a less efficient method if the relation is to be implemented. Jim <ref> [Jim96a] </ref> also defines a notion of 8 that relates fewer types than ours but is still powerful enough to prove some principal typing properties for constrained type systems. <p> We introduce two natural notions of subtyping, observational 8 obs and semantic 8 sem , and prove that they are equivalent; we further give a decidable approximation 8 dec to these relations. Both results represent improvements over recent work on subtyping of constrained types with recursive constraints <ref> [EST95a, Pot96, Jim96a] </ref>. We also introduce a novel closed form of constraint types with contexts, which eliminates the problems associated with free type variables. Finally, we present a type system with principal constrained types, and establish its soundness via reduction to the system of Amadio and Cardelli.
Reference: [Jim96b] <author> Trevor Jim. </author> <title> What are principal typings and what are they good for? In Conference Record of the Twenty-Third Annual ACM Symposium on Principles of Programming Languages, </title> <year> 1996. </year>
Reference-contexts: Their approach has the advantage that it is simpler, but the disadvantage that it is not as complete (and, is not as closely tied to flow analysis). 6 Principal constrained types in our system correspond to principal typings in other type systems <ref> [Jim96b] </ref>, because our constrained types include the typing context. Our system has no principal typings with respect to the let-environment G. 16 7 Conclusions There are still many questions to be dealt with before a full language design based on polymorphic constrained type inference can be proposed.
Reference: [JW95] <author> Suresh Jagannathan and Andrew Wright. </author> <title> Effective flow analysis for avoiding run-time checks. </title> <booktitle> In Proceedings of the 2nd International Static Analysis Symposium, volume 983 of LNCS, </booktitle> <pages> pages 207-224. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Polymorphic constrained types are related to the idea of polymorphic splitting found in the flow analysis of <ref> [JW95] </ref>. They add a notion of splitting the 0CFA flow analysis at let-constructs, inspired by Hindley/Milner let-polymorphism 1 . The main advantage of the typed view is that it 1 The flow analysis of [JW95] does not exactly correspond to the polymorphic constrained type inference of this paper for two technical <p> constrained types are related to the idea of polymorphic splitting found in the flow analysis of <ref> [JW95] </ref>. They add a notion of splitting the 0CFA flow analysis at let-constructs, inspired by Hindley/Milner let-polymorphism 1 . The main advantage of the typed view is that it 1 The flow analysis of [JW95] does not exactly correspond to the polymorphic constrained type inference of this paper for two technical 2 allows analysis of non-closed programs, and integrates the flow analysis with the type system in a direct fashion.
Reference: [Kae92] <author> S. Kaes. </author> <title> Type inference in the presence of overloading, subtyping and recursive types. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 193-204, </pages> <year> 1992. </year>
Reference-contexts: The idea of including subtyping constraints as part of typing judgements was first developed by Mitchell [Mit84, Mit91]. His constraint sets were restricted to be atomic, allowing coercions between type variables only. Numerous other researchers have defined restricted forms of constraint inference system, including <ref> [MR85, FM88, Kae92, BM96] </ref>. A type inference algorithm for polymorphic constrained types of the form studies here was first discovered by Curtis [Cur90], and later independently discovered in somewhat different form, and first proven sound, by Aiken & Wimmers [AW93].
Reference: [Mit84] <author> John C. Mitchell. </author> <title> Coercion and type inference (summary). </title> <booktitle> In Conference Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1984. </year>
Reference-contexts: Constrained type inference is strictly more general than Hindley/Milner type inference. These and other reasons make constrained types worthy of study. The idea of including subtyping constraints as part of typing judgements was first developed by Mitchell <ref> [Mit84, Mit91] </ref>. His constraint sets were restricted to be atomic, allowing coercions between type variables only. Numerous other researchers have defined restricted forms of constraint inference system, including [MR85, FM88, Kae92, BM96].
Reference: [Mit91] <author> John C. Mitchell. </author> <title> Type inference with simple subtypes. </title> <journal> Journal of Functional Programming, </journal> <volume> 1 </volume> <pages> 245-285, </pages> <year> 1991. </year>
Reference-contexts: Constrained type inference is strictly more general than Hindley/Milner type inference. These and other reasons make constrained types worthy of study. The idea of including subtyping constraints as part of typing judgements was first developed by Mitchell <ref> [Mit84, Mit91] </ref>. His constraint sets were restricted to be atomic, allowing coercions between type variables only. Numerous other researchers have defined restricted forms of constraint inference system, including [MR85, FM88, Kae92, BM96].
Reference: [MPS86] <author> D. B. MacQueen, G. Plotkin, and R. Sethi. </author> <title> An ideal model for recursive polymorphic types. </title> <journal> Information and Control, </journal> <volume> 71 </volume> <pages> 95-130, </pages> <year> 1986. </year>
Reference-contexts: We then define a semantic form 8 sem based on a regular tree interpretation, and prove it is a good model by showing it is exactly 8 obs , a full type abstraction property. The ideal model <ref> [MPS86] </ref> may also be used as a basis of a constrained type ordering 8 ideal [AWL94], but it is not fully abstract. 8 sem is a surprisingly complex relation: we leave open the question whether 8 sem = 8 obs is decidable, and develop a powerful decidable approximation 8 dec . <p> However, previous work [EST95b, EST95a] shows how state, records, variants, classes, and objects all may be incorporated in a constrained type framework, and we explicitly avoid semantic tools (such as the ideal model of types <ref> [MPS86] </ref>) which lack a strong potential to generalize to such constructs. <p> This is an example where differences arise when recursive constraint sets are allowedif recursive constraint sets were not allowed, the simple type basis would have been appropriate. Another candidate is the ideal model <ref> [MPS86] </ref> used in [AWL94], it conversely has too many points. Polymorphic types such as 8t:t ! t may be substituted for type variables, but since our system is shallow these points are superfluous in our framework.
Reference: [MR85] <author> P. Mishra and U. Reddy. </author> <title> Declaration-free type checking. </title> <booktitle> In Conference Record of the Twelfth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 7-21, </pages> <year> 1985. </year>
Reference-contexts: The idea of including subtyping constraints as part of typing judgements was first developed by Mitchell [Mit84, Mit91]. His constraint sets were restricted to be atomic, allowing coercions between type variables only. Numerous other researchers have defined restricted forms of constraint inference system, including <ref> [MR85, FM88, Kae92, BM96] </ref>. A type inference algorithm for polymorphic constrained types of the form studies here was first discovered by Curtis [Cur90], and later independently discovered in somewhat different form, and first proven sound, by Aiken & Wimmers [AW93].
Reference: [PO95] <author> Jens Palsberg and Patrick O'Keefe. </author> <title> A type system equivalent to flow analysis. </title> <booktitle> In Conference Record of the Twenty-Second Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 367-378, </pages> <year> 1995. </year>
Reference-contexts: PROOF SKETCH: The algorithm terminates, since each constraint it analyzes is between simple type subterms from the two given constrained types, and they are finitely many (an upper bound of O (n 3 ) for the time complexity of the algorithm is implied by the complexities of closure computation <ref> [PO95] </ref> and ` (Section 3)).
Reference: [Pot96] <author> Francois Pottier. </author> <title> Simplifying subtyping constraints. </title> <booktitle> In First International Conference on Functional Programming, </booktitle> <year> 1996. </year> <note> (to appear). </note>
Reference-contexts: of Definition 4.5: it suffices to note that the proof of K ` t 0 t 0 will only use the lower bounds of variables t 00 positively reachable from t 0 , and respectively upper bounds of negatively reachable variablesjust those left in by the garbage collection. 2 Pottier <ref> [Pot96] </ref> offers an alternative definition of reachability, which ignores the polarity of the occurences of type variables and instead keeps all constraints on variables which may be reached in any position from the root. <p> The proof proceeds by induction on the derivation structure. 2 6 Related Work Pottier <ref> [Pot96] </ref> has independently derived results that are related to some results of this paper. He defines a syntactic and a semantic notions of entailment on constraint sets, shows they are equivalent, and presents a type system with subsumption based on this entailment. <p> We introduce two natural notions of subtyping, observational 8 obs and semantic 8 sem , and prove that they are equivalent; we further give a decidable approximation 8 dec to these relations. Both results represent improvements over recent work on subtyping of constrained types with recursive constraints <ref> [EST95a, Pot96, Jim96a] </ref>. We also introduce a novel closed form of constraint types with contexts, which eliminates the problems associated with free type variables. Finally, we present a type system with principal constrained types, and establish its soundness via reduction to the system of Amadio and Cardelli. <p> Our confidence in the system stems from the fact that 8 dec subsumes the Amadio/Cardelli subtyping of recursive types, the type scheme instantiation in the Hindley/Milner system, and the subtyping relation of <ref> [Pot96] </ref>. Additionally, it turns out that the known simplifications of constraint sets do not test the limits of the system based on 8 dec ; indeed we have shown in this paper that 8 dec can be used to demonstrate the correctness of simplifications not included in other systems.
Reference: [PS92] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Safety analysis versus type inference for partial types. </title> <journal> Information Processing Letters, </journal> <pages> pages 175-180, </pages> <year> 1992. </year>
Reference-contexts: We conclude this introduction with a remark about the duality between constrained type inference, where recursive constraints and multiple bounds are allowed, and flow analysis algorithms. [PS96] establishes an isomorphism between a certain kind of flow analysis <ref> [PS92] </ref> and a monomorphic version of the constrained type system studied in this paper: the two systems accept precisely the same programs. Polymorphic constrained types are related to the idea of polymorphic splitting found in the flow analysis of [JW95].
Reference: [PS96] <author> Jens Palsberg and Scott Smith. </author> <title> Constrained types and their expressiveness. </title> <journal> TOPLAS, </journal> <note> 1996. (to appear; ftp://ftp.cs.jhu.edu/pub/scott/cte.ps.Z). 18 </note>
Reference-contexts: We conclude this introduction with a remark about the duality between constrained type inference, where recursive constraints and multiple bounds are allowed, and flow analysis algorithms. <ref> [PS96] </ref> establishes an isomorphism between a certain kind of flow analysis [PS92] and a monomorphic version of the constrained type system studied in this paper: the two systems accept precisely the same programs. <p> We may now establish soundness of the typing rules of Figure 2. In our previous proofs of soundness of constrained typing systems [EST95b], a direct subject reduction argument was used. Recent observations concerning the close relation between constrained type systems and simple type systems <ref> [PS96] </ref> allow us to establish soundness based on soundness of a simple type system. We believe this direct approach to type soundness of constrained type systems should be applicable to other constrained type languages.
References-found: 24

