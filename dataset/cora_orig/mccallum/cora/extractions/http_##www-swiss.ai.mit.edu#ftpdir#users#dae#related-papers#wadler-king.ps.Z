URL: http://www-swiss.ai.mit.edu/ftpdir/users/dae/related-papers/wadler-king.ps.Z
Refering-URL: http://www-swiss.ai.mit.edu/ftpdir/users/dae/home.html
Root-URL: 
Title: Combining Monads  
Author: David J. King Philip Wadler 
Affiliation: University of Glasgow  
Abstract: Monads provide a way of structuring functional programs. Most real applications require a combination of primitive monads. Here we describe how some monads may be combined with others to yield a combined monad.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Barr and C. Wells, </author> <title> Toposes, Triples, and Theories. </title> <publisher> Springer Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Now both forms of Cartesian product will be applied to the same arguments: <ref> [ 1; 2 ] </ref> fi [ 3; 4 ] = [ (1; 3); (1; 4); (2; 3); (2; 4) ]; Hence, interchanging qualifiers changes the meaning that the comprehension denotes. <p> cp; (cp-4) cp map L join M = join M map M cp cp; (cp-5) cp join L = map M join L cp map L cp: The (cp-3) property tells us that cp is a natural transformation, the others are known as the distributive laws and are discussed in <ref> [1] </ref>. We can prove these properties of cp by using the prod properties. <p> We say that a monad is idempotent when: (Idempotence) [ t j x u; y u ] M = [ t x y j x u ] M : Category theorists, for example, Barr and Wells <ref> [1] </ref> use the same name for a different concept: they define a monad to be idempotent when join M is an isomorphism. With our definition the exception monad is idempotent, whereas it is not with the category theorist's definition. Bag and set monads are com mutative but not idempotent.
Reference: [2] <author> M. Barr and C. Wells, </author> <title> Category Theory for Computing Science. </title> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: Now both forms of Cartesian product will be applied to the same arguments: <ref> [ 1; 2 ] </ref> fi [ 3; 4 ] = [ (1; 3); (1; 4); (2; 3); (2; 4) ]; Hence, interchanging qualifiers changes the meaning that the comprehension denotes. <p> (map L f ) prod; (prod-4) prod map L (join M map M prod) = join M map M prod prod; (prod-5) prod map L prod = prod join L : Interestingly, if (prod-1) and (prod-5) hold then (M L; prod) forms an L--algebra as described in Barr and Wells <ref> [2] </ref>. We can prove the last four properties of prod by using the homomorphism lemma again.
Reference: [3] <author> R. Bird, </author> <title> An Introduction to the Theory of Lists. In Logic of Programming and Calculi of Discrete Design, </title> <publisher> Springer Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Now both forms of Cartesian product will be applied to the same arguments: [ 1; 2 ] fi <ref> [ 3; 4 ] </ref> = [ (1; 3); (1; 4); (2; 3); (2; 4) ]; Hence, interchanging qualifiers changes the meaning that the comprehension denotes. <p> This definition can be found in Bird's paper <ref> [3] </ref>, a more general definition can be found in Spivey's paper [7]. 4.2 An M L monoid We define a special operation denoted which is a kind of Cartesian product, () :: M L a ! M L a ! M L a The identity element for is unit M nil
Reference: [4] <editor> P. Hudak, S. Peyton Jones and P. Wadler, editors, </editor> <title> Report on the functional programming language Haskell, Version 1.2, </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. 27, No. 5, </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: Most of the notation used will be consistent with the Haskell language <ref> [4] </ref>. The monad of state transformers St has type: type St a = State ! (a; State); this says that a state transformer on type a is a function from a state to a pair consisting of a value of type a and a new state. <p> Now both forms of Cartesian product will be applied to the same arguments: [ 1; 2 ] fi <ref> [ 3; 4 ] </ref> = [ (1; 3); (1; 4); (2; 3); (2; 4) ]; Hence, interchanging qualifiers changes the meaning that the comprehension denotes.
Reference: [5] <author> L. Meertens, </author> <title> Algorithmics towards programming as a mathematical activity. </title> <editor> In J. deBakker, M. Hazewinkel and L. Lenstra, editors, </editor> <booktitle> CWI Symposium on Mathematics and Computer Science, </booktitle> <volume> Vol. 1, </volume> <publisher> CWI monographs, North Holland, </publisher> <year> 1986. </year>
Reference-contexts: Similarly, for sets the operators are associative, symmetric and idempotent. On the other end of the scale, for trees the operators need not even be associative, and need not have nil as an identity. These structures are represented in the following hierarchy, known as the Boom hier archy, see <ref> [5] </ref>. Trees Lists Bags Sets Associative fi p p p Symmetric fi fi p p Idempotent fi fi fi p These structures are all finite and all form free algebraic structures. For instance, bags form the free symmetric monoid.
Reference: [6] <author> E. Moggi, </author> <title> Computational lambda-calculus and monads. </title> <booktitle> In IEEE Symposium on Logic in Computer Science, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Monads are taking root in the field of functional programming. Although their origins lay in the abstractions of category theory, they have a wide range of practical applications. Moggi <ref> [6] </ref> showed how they could be used to structure the semantics of computations. Since then Wadler [9, 10] adapted this idea to structure functional programs.
Reference: [7] <author> M. Spivey, </author> <title> A Categorical Approach to the Theory of Lists. In Mathematics of Program Construction, </title> <publisher> LNCS 375, Springer Verlag, </publisher> <year> 1989. </year>
Reference-contexts: This definition can be found in Bird's paper [3], a more general definition can be found in Spivey's paper <ref> [7] </ref>. 4.2 An M L monoid We define a special operation denoted which is a kind of Cartesian product, () :: M L a ! M L a ! M L a The identity element for is unit M nil L .
Reference: [8] <author> P. Wadler, </author> <title> How to Replace Failure by a List of Successes. </title> <booktitle> In Proceedings of Functional Programming and Computer Architecture, </booktitle> <publisher> Springer-Verlag, LNCS 201, </publisher> <month> September </month> <year> 1985. </year>
Reference-contexts: The combined monad M L may, for instance, be state transformers of lists. Or M L may be sets of lists, perhaps a useful structure for a query system. Another practical use of this technique is to combine a parsing monad <ref> [8] </ref> with an exception monad (described in Section 2). A parsing monad has the type: type P arse a = State ! L (a; State): A parse may fail producing an empty list or succeed producing a list of possible parses.
Reference: [9] <author> P. Wadler, </author> <title> Comprehending Monads. </title> <booktitle> In ACM Conference of Lisp and Functional Programming, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Monads are taking root in the field of functional programming. Although their origins lay in the abstractions of category theory, they have a wide range of practical applications. Moggi [6] showed how they could be used to structure the semantics of computations. Since then Wadler <ref> [9, 10] </ref> adapted this idea to structure functional programs. When structuring functional programs like parsers, type checkers or interpreters, it is often the case that the monad needed is a combination of many, a so called combined monad. <p> Laws (M-5) and (M-6) are the left and right unitary identities, law (M-7) is the associative property for monads. Wadler <ref> [9] </ref> describes a comprehension for monads which is sometimes more concise and clear than the above monad functions. The comprehension has the same form as list comprehension used in functional languages like Haskell.
Reference: [10] <author> P. Wadler, </author> <title> The essence of functional programming. </title> <booktitle> In 19'th ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Monads are taking root in the field of functional programming. Although their origins lay in the abstractions of category theory, they have a wide range of practical applications. Moggi [6] showed how they could be used to structure the semantics of computations. Since then Wadler <ref> [9, 10] </ref> adapted this idea to structure functional programs. When structuring functional programs like parsers, type checkers or interpreters, it is often the case that the monad needed is a combination of many, a so called combined monad.
References-found: 10

