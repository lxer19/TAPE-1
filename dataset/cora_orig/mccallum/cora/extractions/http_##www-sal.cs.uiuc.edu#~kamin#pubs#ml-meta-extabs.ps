URL: http://www-sal.cs.uiuc.edu/~kamin/pubs/ml-meta-extabs.ps
Refering-URL: http://www-sal.cs.uiuc.edu/~kamin/pubs/index.html
Root-URL: http://www.cs.uiuc.edu
Email: s-kamin@uiuc.edu  
Title: Building program generators the easy way (Extended Abstract)  
Author: Samuel Kamin 
Keyword: program generators, functional programming, domain-specific languages  
Affiliation: Computer Science Dept. University of Illinois at Urbana-Champaign  
Abstract: Program generators are languages whose programs produce programs in other languages. We show how program generators can be built easily as sets of definitions in a functional language. The method we present has the potential to be a useful application of functional languages in software development projects based on conventional languages. We illustrate the method with two examples: a top-down parser generator; and a version of the "Message Specification Language," developed at Oregon Graduate Institute. In the latter case, we are able to implement substantially the same language in 100 lines of Standard ML code, with no additional tools or optimizing compilers needed. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Ahmed, D. Gelernter, </author> <title> Program builders as alternatives to high-level languages, </title> <institution> Yale Univ. C.S. Dept. </institution> <type> TR 887, </type> <month> November </month> <year> 1991. </year>
Reference-contexts: We end with some conclusions about the power and limitations of the method. 1.1 Related work Program generators are very common, but program generating languages do not always seem to be considered as full-fledged languages, with data types, control structures, and so on. Examples include Gelernter's program builders <ref> [1] </ref>, and Waters's KBEmacs [16]. Each provides a fixed set of program-building operations, but there is no direct manipulation of programs, nor is it easy for users to define their own operations.
Reference: [2] <author> B. Balzer, N. Goldman, D. Wile, </author> <title> Rationale and Support for Domain Specific Languages, </title> <journal> USC/Information Sciences Institute, </journal> <note> available at http://www.isi.edu/software-sciences/dssa/dssls/dssls.html. 12 </note>
Reference-contexts: Each provides a fixed set of program-building operations, but there is no direct manipulation of programs, nor is it easy for users to define their own operations. Work at OGI [3] (on which section 4 of this paper is based) and at ISI <ref> [2] </ref> is specifically aimed at the development of program generators. In both cases, the specification is translated to a very-high-level language, from which an imperative language program is extracted. Our approach is more direct: the program-generating language provides operations that manipulate programs, not specifications.
Reference: [3] <author> J. Bell, F. Bellegarde, J. Hook, R.B. Kieburtz, A. Kotov, J. Lewis, L. McKinney, D.P. Oliva, T. Shear, L. Tong, L. Walton, and T. Zhou, </author> <title> Software design for reliabiity and reuse: A proof-of-concept demonstration, </title> <address> TRI-Ada '94. </address>
Reference-contexts: This method has two major advantages over other techniques of producing program generators. First, it is much simpler. Our main example in this paper is a version of the Message Specification Language described in <ref> [3, 15] </ref>. As described there, the language development involves an elaborate set of tools, including a very aggressive optimizing compiler for a functional language, which must translate functional code into conventional language (ADA) code. <p> We begin, in section 2, with a general description of the process of building a program generator. Section 3 gives a simple example: a program generator for top-down parsers. Section 4 gives our major example in this paper, a version of the Message Specification Language <ref> [3, 15] </ref> implemented using our method. We end with some conclusions about the power and limitations of the method. 1.1 Related work Program generators are very common, but program generating languages do not always seem to be considered as full-fledged languages, with data types, control structures, and so on. <p> Examples include Gelernter's program builders [1], and Waters's KBEmacs [16]. Each provides a fixed set of program-building operations, but there is no direct manipulation of programs, nor is it easy for users to define their own operations. Work at OGI <ref> [3] </ref> (on which section 4 of this paper is based) and at ISI [2] is specifically aimed at the development of program generators. In both cases, the specification is translated to a very-high-level language, from which an imperative language program is extracted. <p> ++ (nonterm "Exp")) ["+", "-", "*", "/"]) (fn lab =&gt; %`return false;`); 4 MSL-in-SML The Message Specification Language, or MSL, was designed as an approach to engineering reusable code in the domain of "message translation and validation." This is a domain of programming which has been studied by software engineers <ref> [3, 11] </ref> as a model area for the study of software re-use. The problem is to translate and validate incoming messages | bit streams | from a variety of sources in a variety of formats. <p> In past work, the language in which translation and validation has been performed is ADA. In this paper, we use C++. The formats of these messages are described only in semi-formal "interface control doc uments;" an example is given in Figure 2 of Bell et al. <ref> [3] </ref> and reproduced here in Figure 2. 3 As in the other examples in this paper of code produced by our program generators, we have taken the liberty of "beautifying" it for better readability, to the extent of changing indentation and line breaks. 6 No. <p> The approach taken by the group at OGI <ref> [3] </ref>|which is the point of departure for the current work|is to define the MSL language, in which message formats can be described formally, thereby allowing automatic translation to ADA. Figure 3 in [3] is reproduced here in Figure 3; it is the MSL specification for the interface control document in Figure 2. This description has two parts. The type declarations are an abstraction of ADA record definitions. <p> Given all the definitions in MSL-in-SML, the expression print (MType (newbitsource "A" "bit") (recordptr "target") ""); evaluates to the string shown in Figure 5. 4 We have attempted to show that much of the value of MSL, as defined in <ref> [3] </ref>, can be obtained directly in a functional language like SML. There remains some syntactic awkwardness, but in general the language illustrated in Figure 4 (MSL-in-SML) is not very much different from the one illustrated in Figure 3 (MSL). 4 There is no corresponding figure given in [3] with which to <p> as defined in <ref> [3] </ref>, can be obtained directly in a functional language like SML. There remains some syntactic awkwardness, but in general the language illustrated in Figure 4 (MSL-in-SML) is not very much different from the one illustrated in Figure 3 (MSL). 4 There is no corresponding figure given in [3] with which to compare our Figure 5. 9 val to_Confidence = alt [asc "HH" "High", asc "MM" "Medium", asc "LL" "Low", asc "NN" "None" ]; alt [infield "Altitude" (asc2int 2 (1, 99)), infield "Track_confidence" to_Confidence, infield "No_Value_or_Alt_less_than_1000" (skip 0)]; val to_Time = seq [infield "Hour" (asc2int 2 (0, 23)), infield <p> 0)]; val to_Time = seq [infield "Hour" (asc2int 2 (0, 23)), infield "Minute" (asc2int 2 (0, 59)) ]; val MType = seq [infield "Course" (asc2int 3 (0, 360)), delim "/", infield "Speed" (asc2int 4 (0, 5110)), delim "/", infield "Alt_or_TC" to_Alt_or_TC, infield "Time" to_Time ]; As compared to that of <ref> [3] </ref>, this approach is not only simpler | producing a similar language in about 100 lines of ML | and more reliable | the code produced by a message specification is entirely in the control of the language designer | but has the added virtue that the resulting program generator is
Reference: [4] <author> W. E. Carlson, P. Hudak, M. P. Jones, </author> <title> An experiment using Haskell to prototype "Geometric Region Servers" for navy command and control, </title> <institution> Research Report YALEU/DCS/RR-1031, Yale Univ. C. S. Dept., </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: The idea is associated with "combinator-style programming," in which a number of higher-order functions are defined which, together with the host language, form a functional language for a new domain. Examples are the functional parsing combinators of Hutton [7]; the "geometric region server" language reported in Carlson et al. <ref> [4] </ref>; the Haskore music notating language of Hudak et al. [6]; and the picture specification language reported by Finne and Peyton Jones [5].
Reference: [5] <author> S. Finne, S. Peyton Jones, </author> <title> Pictures: A simple structured graphics model, </title> <institution> Dept. of Computing Science, Univ. of Glasgow, </institution> <year> 1996. </year>
Reference-contexts: Examples are the functional parsing combinators of Hutton [7]; the "geometric region server" language reported in Carlson et al. [4]; the Haskore music notating language of Hudak et al. [6]; and the picture specification language reported by Finne and Peyton Jones <ref> [5] </ref>. Yet none of them make the observation that a set of combinators very similar to those used to performed the functional computation could be defined so as to generate conventional-language code.
Reference: [6] <author> P. Hudak, T. Makucevich, S. Gadde, B. Whong, </author> <title> Haskore music notation: An algebra of music, </title> <journal> J. Func. Prog., </journal> <note> to appear. </note>
Reference-contexts: Examples are the functional parsing combinators of Hutton [7]; the "geometric region server" language reported in Carlson et al. [4]; the Haskore music notating language of Hudak et al. <ref> [6] </ref>; and the picture specification language reported by Finne and Peyton Jones [5]. Yet none of them make the observation that a set of combinators very similar to those used to performed the functional computation could be defined so as to generate conventional-language code.
Reference: [7] <author> G. Hutton, </author> <title> Higher-order functions for parsing, </title> <journal> J. Func. Prog. </journal> <volume> 2(3), </volume> <pages> 323-343, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: The idea is associated with "combinator-style programming," in which a number of higher-order functions are defined which, together with the host language, form a functional language for a new domain. Examples are the functional parsing combinators of Hutton <ref> [7] </ref>; the "geometric region server" language reported in Carlson et al. [4]; the Haskore music notating language of Hudak et al. [6]; and the picture specification language reported by Finne and Peyton Jones [5].
Reference: [8] <author> S. Kamin, </author> <title> Report of a workshop on future directions in programming languages and compilers, </title> <journal> ACM SIGPLAN Notices 30 (7), </journal> <month> July </month> <year> 1995, </year> <pages> 9-28. </pages>
Reference: [9] <author> S. Kamin, </author> <title> The Challenge of Language Technology Transfer (Position Paper), </title> <journal> Computing Surveys 28A(4), </journal> <year> 1996. </year>
Reference-contexts: Thus, type Layout = CNode -&gt; Env -&gt; CCommand This example is discussed in detail in [10], and, in simplified form, in <ref> [9] </ref>. The paradigm given at the start of this section has proven to work quite well in the domain of program generators.
Reference: [10] <author> S. Kamin, </author> <title> ML as a Meta-Programming Language, </title> <institution> Univ. of Illinois, </institution> <month> Sept. </month> <year> 1996, </year> <note> available at www-sal.cs.uiuc.edu/~kamin/pubs. </note>
Reference-contexts: Thus, type Layout = CNode -&gt; Env -&gt; CCommand This example is discussed in detail in <ref> [10] </ref>, and, in simplified form, in [9]. The paradigm given at the start of this section has proven to work quite well in the domain of program generators.
Reference: [11] <author> C. Plinta, K. Lee, and M. Rissman, </author> <title> A model solution for C 3 I message translation and validation, </title> <type> Technical Report CMU/SEI-89-TR-12, </type> <institution> Software Engineering Institute, Carnegie Mellon University, </institution> <month> December </month> <year> 1989. </year>
Reference-contexts: ++ (nonterm "Exp")) ["+", "-", "*", "/"]) (fn lab =&gt; %`return false;`); 4 MSL-in-SML The Message Specification Language, or MSL, was designed as an approach to engineering reusable code in the domain of "message translation and validation." This is a domain of programming which has been studied by software engineers <ref> [3, 11] </ref> as a model area for the study of software re-use. The problem is to translate and validate incoming messages | bit streams | from a variety of sources in a variety of formats.
Reference: [12] <author> D. Spinellis, </author> <title> Implementing Haskell: Language implementation as a tool building exercise, </title> <booktitle> Software: Concepts and Tools 14, </booktitle> <year> 1993, </year> <month> 37-48. </month> <title> [13] . Standard ML of New Jersey User's Guide, </title> <month> February </month> <year> 1993. </year>
Reference-contexts: Yet none of them make the observation that a set of combinators very similar to those used to performed the functional computation could be defined so as to generate conventional-language code. As a dual data point, Spinellis <ref> [12] </ref> describes the the programming of the Glasgow Haskell compiler as an exercise in program generator construction, but fails to note that, using the technique described in this paper, those mini-program generators could have been written in Haskell itself, instead of Perl and C. 2 Building program generators It is a
Reference: [14] <editor> P. Wadler. </editor> <booktitle> The essense of functional programming, Proc. 19th ACM Symp. on Principles of Programming Languages, </booktitle> <address> Albuquerque, NM, </address> <month> Jan. </month> <year> 1992, </year> <pages> 1-14. </pages>
Reference-contexts: In effect, the &gt; operator | as well as the constant 10, the if, and, apparently, the entire ML language | needs to be lifted to type CNode -&gt; Env -&gt; whatever. This is an example of the well known concept of a monad <ref> [14] </ref>, but the problem is that we have no way to lift the entire ML language to this monad, nor to switch from ML's normal operation to this monad. Perhaps the deepest problem here is that we have no way to determine the adequacy of the chosen set of operators.
Reference: [15] <author> L. Walton and J. Hook, </author> <title> Message Specification Language (MSL): Reference Manual, Revision: </title> <institution> 1.8, Oregon Graduate Institute, </institution> <month> Oct. 6, </month> <year> 1994. </year>
Reference-contexts: This method has two major advantages over other techniques of producing program generators. First, it is much simpler. Our main example in this paper is a version of the Message Specification Language described in <ref> [3, 15] </ref>. As described there, the language development involves an elaborate set of tools, including a very aggressive optimizing compiler for a functional language, which must translate functional code into conventional language (ADA) code. <p> We begin, in section 2, with a general description of the process of building a program generator. Section 3 gives a simple example: a program generator for top-down parsers. Section 4 gives our major example in this paper, a version of the Message Specification Language <ref> [3, 15] </ref> implemented using our method. We end with some conclusions about the power and limitations of the method. 1.1 Related work Program generators are very common, but program generating languages do not always seem to be considered as full-fledged languages, with data types, control structures, and so on.
Reference: [16] <author> R. C. Waters, </author> <title> The Programmer's Apprentic: A session with KBEmacs, </title> <journal> IEEE Trans. Software Eng. </journal> <volume> SE-11(11), </volume> <pages> 1296-1320, </pages> <month> Nov. </month> <year> 1985. </year> <month> 13 </month>
Reference-contexts: Examples include Gelernter's program builders [1], and Waters's KBEmacs <ref> [16] </ref>. Each provides a fixed set of program-building operations, but there is no direct manipulation of programs, nor is it easy for users to define their own operations.
References-found: 15

