URL: http://www.cs.sunysb.edu/~sbprolog/manual.ps.gz
Refering-URL: http://www.cs.sunysb.edu/~sbprolog/xsb-page.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: The XSB Programmer's Manual Version 1.8  with contributions from  
Author: Konstantinos F. Sagonas Terrance Swift David S. Warren Juliana Freire Prasad Rao Hassan Davulcu Steve Dawson 
Date: February 1998  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> J. Alferes, C. Damasio, and L. Pereira. </author> <title> A logic programming system for non-monotonic reasoning. </title> <journal> Journal of Automated Reasoning, </journal> <year> 1995. </year>
Reference-contexts: That is, A is failed if after removing all successful literals in clauses that define A, and after failing all clauses for A with failed literals, recursion through negation remains. Many non-monotonic formalisms can be embedded into WFS, for instance the Well-founded semantics with explicit negation, (WFSX) <ref> [1] </ref>, adds explicit (or provable) negation to the default negation used by the Well-founded semantics. <p> Extended logic programs can be extremely useful when reasoning about actions, for model-based diagnosis, and for many other uses [2]. The library, slx provides a means to compile programs so that they can be executed by XSB according to the well-founded semantics with explicit negation <ref> [1] </ref>. Briefly, WFSX is an extension of the well-founded semantics to include explicit negation and which is based on the coherence principle in which an atom is taken to be default false if it is proven to be explicitly false, intutively: p ) not p: CHAPTER 9.
Reference: [2] <author> J. Alferes and L. Pereira. </author> <title> Reasoning with Logic Programms. </title> <year> 1995. </year>
Reference-contexts: Extended logic programs can be extremely useful when reasoning about actions, for model-based diagnosis, and for many other uses <ref> [2] </ref>. The library, slx provides a means to compile programs so that they can be executed by XSB according to the well-founded semantics with explicit negation [1].
Reference: [3] <author> F. Banchilhon, D. Maier, Y. Sagiv, and J. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In PODS. ACM, </booktitle> <year> 1986. </year>
Reference-contexts: It enters an infinite loop. The inability of Prolog to answer such queries, which arise frequently, comprises one of its major limitations as an implementation of logic. A number of approaches have been developed to solve programs like ancestor by reusing partial answers to the query ancestor (1,Y) <ref> [14, 38, 3, 40, 41] </ref>. Briefly, the ideas behind these algorithms can be described in the following manner. First, the program keeps track of places where calls to ancestor (1,Y) have been made. <p> Beyond the comparison with Prolog, our implementation strategy has several implications which may affect the user. First, XSB's evaluation is top-down, and solutions are derived a tuple at a time. This characterization allows it to be contrasted with, say, magic sets <ref> [3] </ref> which evaluate queries bottom-up and derive solutions a set at a time. There are advantages and disadvantages to XSB's evaluation method.
Reference: [4] <author> F. Banchilhon and R. Ramakrishnan. </author> <title> An amateur's introduction to recursive query processing strategies. </title> <booktitle> In Proc. of SIGMOD 1986 Conference, </booktitle> <pages> pages 16-52. </pages> <publisher> ACM, </publisher> <year> 1986. </year>
Reference-contexts: The same generation program furnishes a case of the usefulness of tabling for optimizing a Prolog program. Example 5.1.1 The query ?- sg (1,X),fail. was executed against the program sg (X,Y) :- cyl (X,X1), sg (X1,Y1), cyl (Y,Y1). using a 24x24x2 randomly generated cylinder <ref> [4] </ref>, as the base relation cyl/2. A cylinder can be thought of as a rectangular matrix of elements where each element in row N has links to a certain 1 Sometimes the term consuming nodes is also used in this case. CHAPTER 5.
Reference: [5] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the power of magic. </title> <journal> J. Logic Programming, </journal> <volume> 10(3) </volume> <pages> 255-299, </pages> <year> 1991. </year>
Reference: [6] <author> D. Boulanger. </author> <title> Fine-grained goal-directed declarative analysis of logic programs. </title> <booktitle> Proceedings of the International Workshop on Verification, Model Checking and Abstract Interpretation, </booktitle> <year> 1997. </year> <note> Available through http://www.dsi.unive.it/ bossi/VMCAI.html. </note>
Reference: [7] <author> W. Chen, M. Kifer, and D.S. Warren. HiLog: </author> <title> A foundation for higher-order logic programming. </title> <journal> J. Logic Programming, </journal> <volume> 15(3) </volume> <pages> 187-230, </pages> <year> 1993. </year>
Reference: [8] <author> W. Chen, T. Swift, and D.S. Warren. </author> <title> Efficient top-down computation of queries under the well-founded semantics. </title> <journal> J. Logic Programming, </journal> <volume> 24(3) </volume> <pages> 161-199, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: introduction to SLG resolution as it is implemented in XSB. For interested users, the ftp directory and web site contain papers covering in detail various aspects of tabling. An overview of SLG resolution, and a practical evaluation strategy for it are provided in [9, 34, 16]. <ref> [32, 29, 17, 8] </ref> describe fully the SLG-WAM as it is implemented in Version 1.8and analyze its performance. 5.1 SLG Evaluation 5.1.1 Tabling Consider the Prolog program ancestor (X,Y) :- parent (X,Y). ancestor (X,Y) :- ancestor (X,Z), parent (Z,Y). together with the query ?-ancestor (1,Y).
Reference: [9] <author> W. Chen and D. S. Warren. </author> <title> Tabled Evaluation with Delaying for General Logic Programs. </title> <journal> Journal of the ACM, </journal> <volume> 43(1) </volume> <pages> 20-74, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: introduction to SLG resolution as it is implemented in XSB. For interested users, the ftp directory and web site contain papers covering in detail various aspects of tabling. An overview of SLG resolution, and a practical evaluation strategy for it are provided in <ref> [9, 34, 16] </ref>. [32, 29, 17, 8] describe fully the SLG-WAM as it is implemented in Version 1.8and analyze its performance. 5.1 SLG Evaluation 5.1.1 Tabling Consider the Prolog program ancestor (X,Y) :- parent (X,Y). ancestor (X,Y) :- ancestor (X,Z), parent (Z,Y). together with the query ?-ancestor (1,Y). <p> In the language of <ref> [9] </ref>, the first call of a (leftmost) goal is called a generator node, and is expanded using program clauses as in SLD resolution (Prolog). Correct answer substitutions to the solution node are interned in the table entry (call plus returns) for a call.
Reference: [10] <author> M. Codish, B. Demoen, and K. Sagonas. </author> <title> Xsb as a general purpose program analyzer. </title> <type> Technical report, </type> <institution> KU Leuven, </institution> <year> 1996. </year>
Reference: [11] <author> S. Dawson, C. R. Ramakrishnan, I. V. Ramakrishnan, K. Sagonas, S. Skiena, T. Swift, and D. S. Warren. </author> <title> Unification factoring for efficient execution of logic programs. </title> <booktitle> In Proc. of the 22nd Symposium on Principles of Programming Languages, </booktitle> <pages> pages 247-258. </pages> <publisher> ACM, </publisher> <year> 1995. </year>
Reference: [12] <author> S. Dawson, C.R. Ramakrishnan, and D.S. Warren. </author> <title> Practical program analysis using general purpose logic programming systems | a case study. </title> <booktitle> In ACM PLDI, </booktitle> <year> 1996. </year> <note> To Appear. </note>
Reference: [13] <author> S. Debray. </author> <title> SB-Prolog System, Version 3.0, A User Manual, 1988. </title> <type> 166 BIBLIOGRAPHY 167 </type>
Reference: [14] <author> S. Dietrich. </author> <title> Extension Tables for Recursive Query Evaluation. </title> <type> PhD thesis, </type> <institution> SUNY at Stony Brook, </institution> <year> 1987. </year>
Reference-contexts: It enters an infinite loop. The inability of Prolog to answer such queries, which arise frequently, comprises one of its major limitations as an implementation of logic. A number of approaches have been developed to solve programs like ancestor by reusing partial answers to the query ancestor (1,Y) <ref> [14, 38, 3, 40, 41] </ref>. Briefly, the ideas behind these algorithms can be described in the following manner. First, the program keeps track of places where calls to ancestor (1,Y) have been made.
Reference: [15] <author> Christoph Draxler. </author> <title> Prolog to sql compiler, version 1.0. </title> <type> Technical report, </type> <institution> CIS Centre for Information and Speech Processing Ludwig-Maximilians-University, Munich, </institution> <year> 1992. </year>
Reference-contexts: XSB ORACLE INTERFACE 138 Caching compiler generated SQL statements with bind variables and efficient cursor management for cached statements * A powerful Prolog / SQL compiler based on <ref> [15] </ref>. * Full source code availability for ports to other versions of Oracle or other platforms * Independence from database schema by employing relation level * Performance as SQL by employing view level * No mode specification is required for optimized view compilation 12.2 Installation: Assuming Oracle is currently installed: 1. <p> All arguments are standard Prolog terms. Arg 1 through Arg n defines the attributes to be retrieved from the database, while DatabaseGoal defines the selection restrictions and join conditions. The compiler is a simple extension of <ref> [15] </ref> which generates SQL queries with bind variables and handles NULL values as described below (see section 12.3.7). It allows negation, the expression of arithmetic functions, and higher-order constructs such as grouping, sorting, and aggregate functions. Database goals are translated according to the following rules from [15]: * Disjunctive goals translate <p> a simple extension of <ref> [15] </ref> which generates SQL queries with bind variables and handles NULL values as described below (see section 12.3.7). It allows negation, the expression of arithmetic functions, and higher-order constructs such as grouping, sorting, and aggregate functions. Database goals are translated according to the following rules from [15]: * Disjunctive goals translate to distinct SQL queries connected through the UNION operator. * Goal conjunctions translate to joins. * Negated goals translate to negated EXISTS subqueries. * Variables with single occurrences in the body are not translated. * Free variables translate to grouping attributes. * Shared variables in goals <p> For more examples and implementation details see the demo in $XSB DIR/examples/xsb ora demo.P, and <ref> [15] </ref>. In the following, we show the definition of a simple join view between the two database predicates emp and dept. Assuming the declarations: | ?- db_import ('EMP'('ENAME','JOB','SAL','COMM','DEPTNO'),emp). | ?- db_import ('DEPT'('DEPTNO','DNAME','LOC'),dept). CHAPTER 12.
Reference: [16] <author> J. Freire, T. Swift, and D. Warren. </author> <title> A formal framework for scheduling in slg. </title> <type> Technical report, </type> <institution> SUNY at Stony Brook, </institution> <year> 1993. </year>
Reference-contexts: introduction to SLG resolution as it is implemented in XSB. For interested users, the ftp directory and web site contain papers covering in detail various aspects of tabling. An overview of SLG resolution, and a practical evaluation strategy for it are provided in <ref> [9, 34, 16] </ref>. [32, 29, 17, 8] describe fully the SLG-WAM as it is implemented in Version 1.8and analyze its performance. 5.1 SLG Evaluation 5.1.1 Tabling Consider the Prolog program ancestor (X,Y) :- parent (X,Y). ancestor (X,Y) :- ancestor (X,Z), parent (Z,Y). together with the query ?-ancestor (1,Y).
Reference: [17] <author> J. Freire, T. Swift, and D. Warren. </author> <title> Beyond depth-first: Improving tabled logic programs through alternative scheduling strategies. </title> <journal> Journal of Functional and Logic Programming, </journal> <year> 1998. </year>
Reference-contexts: introduction to SLG resolution as it is implemented in XSB. For interested users, the ftp directory and web site contain papers covering in detail various aspects of tabling. An overview of SLG resolution, and a practical evaluation strategy for it are provided in [9, 34, 16]. <ref> [32, 29, 17, 8] </ref> describe fully the SLG-WAM as it is implemented in Version 1.8and analyze its performance. 5.1 SLG Evaluation 5.1.1 Tabling Consider the Prolog program ancestor (X,Y) :- parent (X,Y). ancestor (X,Y) :- ancestor (X,Z), parent (Z,Y). together with the query ?-ancestor (1,Y). <p> The scheduling of answer returns is an important issue for effiency of evaluations. Indeed, the tabling scheduling strategy of XSB was thoroughly revised in version 1.5 to use a strategy that is more efficient in terms of time and space <ref> [17] </ref>. The same paper outlined implementatoin of a second scheduling strategy, Local Scheduling, which has applications to non-monotonic reasoning and when combined with answer subsumption can improve the performance of some programs by arbitrary amounts.
Reference: [18] <author> M. Gelfond and V. Lifshitz. </author> <title> The stable model semantics for logic programming. </title> <booktitle> In Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 1070-1080, </pages> <year> 1988. </year>
Reference-contexts: This semantics is a natural extension from a programmer's perspetive. It can be shown that a program is dynamically stratified if and only if it has a two-valued well-founded model. Furthermore, more elaborate forms of non-monotonic reasoning, such as stable models <ref> [18] </ref> can be built using the well-founded model. Indeed, XSB provides a residual program which, as explained below, can be used to evaluate stable models of a program. The intuition behind the Well-Founded semantics can be explained through the operations of tabling.
Reference: [19] <author> ISO working group JTC1/SC22. </author> <title> Prolog international standard. </title> <type> Technical report, </type> <institution> International Standards Organization, </institution> <year> 1995. </year>
Reference-contexts: Note that dynamic/1 can be used like a compiler directive, since it will be passed through to be executed when the module is loaded. Note, however, that the semantics is different from that of the standard <ref> [19] </ref> when the file contains clauses defining the so-specified predicate. table (+PredSpec) is an executable predicate, where PredSpec is a predicate specification for a dynamic predi CHAPTER 6. STANDARD PREDICATES 93 cate. (This is also a compiler directive when PredSpec specifies a compiled predicate.
Reference: [20] <author> D. Kemp and R. Topor. </author> <title> Completeness of a top-down query evaluation procedure for stratified databases. </title> <booktitle> In Logic Programming: Proc. of the Fifth International Conference and Symposium, </booktitle> <pages> pages 178-194, </pages> <year> 1988. </year>
Reference-contexts: A non-trivial program that uses tabling can be found as part of the XSB compiler, in $XSB_DIR/cmplib/mode.P. 5.2 Left-to-Right Dynamically Stratified Negation Most of the original definitions for tabling algorithms considered only definite programs, though some (e.g. <ref> [20, 37] </ref>) extended tabling to programs with restricted forms of stratified negation. Broadly, a program uses stratified negation whenever there is no recursion through negation. Refining this intuition can lead to an array of stratification classes.
Reference: [21] <author> R. Larson, D. S. Warren, J. Freire, and K. </author> <title> Sagonas. </title> <publisher> Syntactica. MIT Press, </publisher> <year> 1995. </year>
Reference: [22] <author> R. Larson, D. S. Warren, J. Freire, K. Sagonas, and P. Gomez. </author> <title> Semantica. </title> <publisher> MIT Press, </publisher> <year> 1995. </year> <note> In preparation. </note>
Reference: [23] <author> J. Leite. </author> <title> Logic program updates. </title> <type> Technical report, </type> <institution> Universidade Nova de Lisboa, </institution> <year> 1997. </year>
Reference-contexts: Many non-monotonic formalisms can be embedded into WFS, for instance the Well-founded semantics with explicit negation, (WFSX) [1], adds explicit (or provable) negation to the default negation used by the Well-founded semantics. Using WFSX, problems in domains such as diagnosis and hierarchical reasoning, or domains that require updates <ref> [23] </ref>, can be easily modelled as logic programs, and using the XSB preprocessor for WFSX (Section 9.9) such programs can be computed efficiently. As a final point, Version 1.8 of XSB also provides a basis for computing stable models of a program through what is called the residual program.
Reference: [24] <author> T. Lindholm and R.A. O'Keefe. </author> <title> Efficient implementation of a defensible semantics for dynamic PROLOG code. </title> <booktitle> In Proceedings of the International Conference on Logic Programming, </booktitle> <pages> pages 21-39, </pages> <year> 1987. </year>
Reference-contexts: Furthermore, tabling can be used with a dynamic predicate by explicitly declaring a predicate to be both dynamic and tabled. For clauses that are asserted as WAM code, the "immediate semantics" of dynamic predicates is used, not the so-called "logical semantics" of assert/retract <ref> [24] </ref>. This means that significant care must be taken when modifying the definition of a predicate which is currently being executed. Notice that this makes some operations difficult.
Reference: [25] <author> I. Niemela and P. Simons. </author> <title> Efficient implementation of the well-founded and stable model semantics. </title> <booktitle> In Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 289-303, </pages> <year> 1996. </year>
Reference-contexts: In fact, by using XSB in conjunction with a Stable Model generator, Smodels <ref> [25] </ref>, an efficient system has been devised for model checking of concurrent systems that is 10-20 times faster than competing systems [28]. CHAPTER 5.
Reference: [26] <author> T.C. Przymusinski. </author> <title> Every logic program has a natural stratification and an iterated least fixed point model. </title> <booktitle> In PODS, </booktitle> <pages> pages 11-21, </pages> <year> 1989. </year>
Reference-contexts: The adjective "left-to-right" comes from the fixed order in which the evaluation selects literals in the body. The adjective "dynamic" arises from the fact that run-time information is central to whether the derivation path remains suspended or not. LRD-stratified programs and their evaluation method are explained in detail in <ref> [34, 26] </ref>. However, the following simple program is LRD-stratified, but does not fit into other stratification classes (e.g. the more familiar class of (left-to-right) modularly stratified programs [30]. p:- q,: r,: s. r:-p,: q. <p> CHAPTER 5. USING TABLING IN XSB 47 p:- : s,,: r, q. r:-p,: q. which cannot be evaluated by the method sketched above. Such programs, are called dynamically stratified, but may not be stratified for any particular evaluation order <ref> [26] </ref>. Version 1.8 of XSB handles dynamically stratified programs through delaying negative literals when it becomes necessary to look to their right in a clause, and then simplifying away the delayed literals when and if their truth value becomes known.
Reference: [27] <author> Y. Ramakrishna, C.R. Ramakrishnan, I.V. Ramakrishnan, S. Smolka, T. Swift, and D. Warren. </author> <title> Efficient model checking using tabled resolution. </title> <booktitle> In Proceedings of CAV 97, </booktitle> <year> 1997. </year>
Reference: [28] <author> C.R. Ramakrishnan and S. Smolka. </author> <title> Fully local and efficient evaluation of alternating fixed points. </title> <type> Technical report, </type> <institution> SUNY Stony Brook, </institution> <year> 1997. </year>
Reference-contexts: In fact, by using XSB in conjunction with a Stable Model generator, Smodels [25], an efficient system has been devised for model checking of concurrent systems that is 10-20 times faster than competing systems <ref> [28] </ref>. CHAPTER 5.
Reference: [29] <author> P. Rao, I.V. Ramakrishnan, K. Sagonas, T. Swift, and D.S. Warren. </author> <title> Efficient table access mechanisms for logic programs. </title> <journal> Journal of Logic Programming, </journal> <note> 1998. To Appear. </note>
Reference-contexts: introduction to SLG resolution as it is implemented in XSB. For interested users, the ftp directory and web site contain papers covering in detail various aspects of tabling. An overview of SLG resolution, and a practical evaluation strategy for it are provided in [9, 34, 16]. <ref> [32, 29, 17, 8] </ref> describe fully the SLG-WAM as it is implemented in Version 1.8and analyze its performance. 5.1 SLG Evaluation 5.1.1 Tabling Consider the Prolog program ancestor (X,Y) :- parent (X,Y). ancestor (X,Y) :- ancestor (X,Z), parent (Z,Y). together with the query ?-ancestor (1,Y). <p> Another is to use the predicates retract nr/1 and reclaim space/1, described below. Asserting clauses as WAM code might be considerably slow for some applications. To remedy this, XSB provides an alternative to assert/1 which implements assert's functionality using the trie-based tabling data structures <ref> [29] </ref>. <p> In that case the joint index would never be used.) The executable declaration index (Predspec,trie) causes clauses for Predspec to be asserted using tries (see <ref> [29] </ref>, which is available through the XSB web page). The name trie indexing is something of a misnomer since the trie itself both indexes the term and represents it. In XSB, the above rie index is formed using a left-to-right traversal of the unit clauses.
Reference: [30] <author> K.A. Ross. </author> <title> The Semantics of Deductive Databases. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Stanford University, </institution> <year> 1991. </year> <note> BIBLIOGRAPHY 168 </note>
Reference-contexts: LRD-stratified programs and their evaluation method are explained in detail in [34, 26]. However, the following simple program is LRD-stratified, but does not fit into other stratification classes (e.g. the more familiar class of (left-to-right) modularly stratified programs <ref> [30] </ref>. p:- q,: r,: s. r:-p,: q.
Reference: [31] <institution> Medicine Rules. Diagnostica. </institution> <type> Technical report. </type> <note> http://medicinerules.com. </note>
Reference: [32] <author> K. Sagonas and T. Swift. </author> <title> An abstract machine for tabled evaluation of fixed-order stratified programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <note> 1998. To Appear. </note>
Reference-contexts: introduction to SLG resolution as it is implemented in XSB. For interested users, the ftp directory and web site contain papers covering in detail various aspects of tabling. An overview of SLG resolution, and a practical evaluation strategy for it are provided in [9, 34, 16]. <ref> [32, 29, 17, 8] </ref> describe fully the SLG-WAM as it is implemented in Version 1.8and analyze its performance. 5.1 SLG Evaluation 5.1.1 Tabling Consider the Prolog program ancestor (X,Y) :- parent (X,Y). ancestor (X,Y) :- ancestor (X,Z), parent (Z,Y). together with the query ?-ancestor (1,Y). <p> Exceptions: The same as call/1 (see section 6.7). tnot (+P) Tabling The semantics of tnot/1 allows for correct execution of programs with according to the well-founded semantics. P must be a tabled predicate, For a detailed description of the actions of tabled negation for in XSB Version 1.8 see <ref> [32, 35] </ref>. Chapter 5 contains further discussion of the functionality of tnot/1.
Reference: [33] <author> K. Sagonas, T. Swift, and D.S. Warren. </author> <title> XSB as an efficient deductive database engine. </title> <booktitle> In Proc. of SIGMOD 1994 Conference. ACM, </booktitle> <year> 1994. </year>
Reference: [34] <author> K. Sagonas, T. Swift, and D.S. Warren. </author> <title> The limits of fixed-order computation. </title> <booktitle> In International Workshop on Logic and Databases. </booktitle> <publisher> LNAI: Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: introduction to SLG resolution as it is implemented in XSB. For interested users, the ftp directory and web site contain papers covering in detail various aspects of tabling. An overview of SLG resolution, and a practical evaluation strategy for it are provided in <ref> [9, 34, 16] </ref>. [32, 29, 17, 8] describe fully the SLG-WAM as it is implemented in Version 1.8and analyze its performance. 5.1 SLG Evaluation 5.1.1 Tabling Consider the Prolog program ancestor (X,Y) :- parent (X,Y). ancestor (X,Y) :- ancestor (X,Z), parent (Z,Y). together with the query ?-ancestor (1,Y). <p> Broadly, a program uses stratified negation whenever there is no recursion through negation. Refining this intuition can lead to an array of stratification classes. While XSB evaluates all programs, whether stratified or not, its evaluation is especially efficient for LRD-stratified programs <ref> [34] </ref>, which we now explain. Consider a simple approach to incorporating negation into tabling, and assume, to avoid complications of floundering, that the entire program is ground | that no clause of the program contains any variable. <p> The adjective "left-to-right" comes from the fixed order in which the evaluation selects literals in the body. The adjective "dynamic" arises from the fact that run-time information is central to whether the derivation path remains suspended or not. LRD-stratified programs and their evaluation method are explained in detail in <ref> [34, 26] </ref>. However, the following simple program is LRD-stratified, but does not fit into other stratification classes (e.g. the more familiar class of (left-to-right) modularly stratified programs [30]. p:- q,: r,: s. r:-p,: q.
Reference: [35] <author> K. Sagonas, T. Swift, and D.S. Warren. </author> <title> An abstract machine for computing the well-founded semantics. </title> <booktitle> In Joint International Conference and Symposium on Logic Programming., </booktitle> <pages> pages 274-289, </pages> <year> 1996. </year>
Reference-contexts: Exceptions: The same as call/1 (see section 6.7). tnot (+P) Tabling The semantics of tnot/1 allows for correct execution of programs with according to the well-founded semantics. P must be a tabled predicate, For a detailed description of the actions of tabled negation for in XSB Version 1.8 see <ref> [32, 35] </ref>. Chapter 5 contains further discussion of the functionality of tnot/1.
Reference: [36] <author> K. Sagonas and D.S. Warren. </author> <title> Efficient execution of HiLog in WAM-based Prolog implementations. </title> <booktitle> In International Conference on Logic Programming, </booktitle> <year> 1995. </year> <note> To Appear. </note>
Reference: [37] <author> H. Seki. </author> <title> On the power of Alexandrer templates. </title> <booktitle> In Proc. of 8th PODS, </booktitle> <pages> pages 150-159. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: A non-trivial program that uses tabling can be found as part of the XSB compiler, in $XSB_DIR/cmplib/mode.P. 5.2 Left-to-Right Dynamically Stratified Negation Most of the original definitions for tabling algorithms considered only definite programs, though some (e.g. <ref> [20, 37] </ref>) extended tabling to programs with restricted forms of stratified negation. Broadly, a program uses stratified negation whenever there is no recursion through negation. Refining this intuition can lead to an array of stratification classes.
Reference: [38] <author> H. Tamaki and T. Sato. </author> <title> OLDT resolution with tabulation. </title> <booktitle> In Third International Conference on Logic Programming, </booktitle> <pages> pages 84-98, </pages> <year> 1986. </year>
Reference-contexts: It enters an infinite loop. The inability of Prolog to answer such queries, which arise frequently, comprises one of its major limitations as an implementation of logic. A number of approaches have been developed to solve programs like ancestor by reusing partial answers to the query ancestor (1,Y) <ref> [14, 38, 3, 40, 41] </ref>. Briefly, the ideas behind these algorithms can be described in the following manner. First, the program keeps track of places where calls to ancestor (1,Y) have been made.
Reference: [39] <author> A. van Gelder, K.A. Ross, and J.S. Schlipf. </author> <title> Unfounded sets and well-founded semantics for general logic programs. </title> <journal> JACM, </journal> <volume> 38(3) </volume> <pages> 620-650, </pages> <year> 1991. </year>
Reference-contexts: That is, the value of a ground atom may be undefined in addition to being true or false. From the perspective of stratification, these programs are not even dynamically stratified. XSB, in fact, handles such programs, evaluating them according to the Well-Founded Semantics <ref> [39] </ref>. This semantics is a natural extension from a programmer's perspetive. It can be shown that a program is dynamically stratified if and only if it has a two-valued well-founded model. Furthermore, more elaborate forms of non-monotonic reasoning, such as stable models [18] can be built using the well-founded model.
Reference: [40] <author> L. Vieille. </author> <title> Recursive query processing: The power of logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 69 </volume> <pages> 1-53, </pages> <year> 1989. </year>
Reference-contexts: It enters an infinite loop. The inability of Prolog to answer such queries, which arise frequently, comprises one of its major limitations as an implementation of logic. A number of approaches have been developed to solve programs like ancestor by reusing partial answers to the query ancestor (1,Y) <ref> [14, 38, 3, 40, 41] </ref>. Briefly, the ideas behind these algorithms can be described in the following manner. First, the program keeps track of places where calls to ancestor (1,Y) have been made. <p> INTERFACE 149 db delete index ('INDEX NAME') To delete an index named 'INDEX NAME' These following predicates are the supported PRODBI syntax for deleting and inserting rows: db add record ('DEPT',[30,'SALES','CHICAGO']) arguments are a list composed of field values and the table name to insert the row. delete record ('DEPT', <ref> [40, , ] </ref>) to delete rows from 'DEPT' matching the list of values men tioned in second argument. For other SQL statements use db sql/1 with the SQL statement as the first argument.
Reference: [41] <author> A. Walker. </author> <title> Backchain iteration: Towards a practical inference method that is simple enough to be proved terminating, sound, and complete. </title> <journal> J. Automated Reasoning, </journal> <volume> 11(1) </volume> <pages> 1-23, </pages> <address> 1993. Originally formulated in New York University TR 34, </address> <year> 1981. </year>
Reference-contexts: It enters an infinite loop. The inability of Prolog to answer such queries, which arise frequently, comprises one of its major limitations as an implementation of logic. A number of approaches have been developed to solve programs like ancestor by reusing partial answers to the query ancestor (1,Y) <ref> [14, 38, 3, 40, 41] </ref>. Briefly, the ideas behind these algorithms can be described in the following manner. First, the program keeps track of places where calls to ancestor (1,Y) have been made.
Reference: [42] <author> David S. Warren. </author> <title> Programming the PTQ grammar in XSB. </title> <editor> In Raghu Ramakrishnan, editor, </editor> <booktitle> Applications of Logic Databases, </booktitle> <pages> pages 217-234. </pages> <publisher> Kluwer Academic Publishers, </publisher> <year> 1995. </year>
Reference-contexts: What happens is that the input string (i.e. list) may be copied into and out of the table many times. To avoid this problem, the input list can be transformed into a set of datalog atoms. Currently this must be done manually, as explained in <ref> [42] </ref>, available in the tech reports directory. Chapter 9 Library Utilities In this chapter we introduce some useful predicates that are supplied with the system.
Reference: [43] <author> J. Xu. </author> <title> The PSB-Prolog User Manual, </title> <year> 1990. </year>
References-found: 43

