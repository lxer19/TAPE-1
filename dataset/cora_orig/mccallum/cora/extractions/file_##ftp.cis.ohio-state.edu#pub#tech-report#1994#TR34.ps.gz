URL: file://ftp.cis.ohio-state.edu/pub/tech-report/1994/TR34.ps.gz
Refering-URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/TRList.html
Root-URL: 
Email: email: framach,singhalg@cis.ohio-state.edu  
Title: Distributed Semaphores  
Author: Mahendra Ramachandran and Mukesh Singhal 
Keyword: Key phrases: Operating Systems, Process Synchronization, Semaphores, Dis tributed Memory Architectures.  
Address: Columbus, Ohio 43210-1277  
Affiliation: Department of Computer and Information Science The Ohio State University,  
Abstract: Semaphores provide a basic synchronization mechanism in uni- and multiprocessor systems. Supporting semaphores in distributed systems has not received much attention. DSM systems provide a shared memory programming model on distributed systems and thus increase the appeal of providing efficient, decentralized solutions for the semaphore mechanism in a distributed system. We present a distributed semaphore mechanism in this paper. We use a two-level hierarchy to processors to increase locality of reference and thus the efficiency of access. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Anne Dinning. </author> <title> "A Survey of Synchronization Methods for Parallel Computers". </title> <journal> IEEE Computer, </journal> <volume> 22(7) </volume> <pages> 66-77, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: In shared memory systems (uni-processor as well as multi-processor), a low-level hardware operation, Test&Set, is used to implement semaphores. This Test&Set instruction allows a process to read a memory address and modify it atomically. Various other implementations of semaphores for multi-processors have been proposed <ref> [1] </ref>. 1 Implementation and properties of semaphores are well understood in shared memory systems. However, implementing semaphores in a distributed system has not received sufficient attention. A distributed system is a network of processors interconnected by a communication network. The processors do not share memory and exchange information through messages.
Reference: [2] <author> Leslie Lamport. </author> <title> Time, Clocks and Ordering of Events in Distributed Systems. </title> <journal> Communications of the ACM, </journal> <month> July </month> <year> 1978. </year>
Reference-contexts: The lack of shared memory makes implemention of semaphores very difficult in a distributed system. An implementation of semaphores in such a system must rely on message passing. To protect a critical section in a distributed system, several algorithms based on message passing have been proposed <ref> [2, 3, 4, 5, 6, 7] </ref>. Note that, these algorithms indirectly implement binary semaphore in distributed systems. There is still a need for general purpose resource counting semaphores in distributed systems. Providing such mechanisms through the use of a centralized controller is undesirable for several reasons.
Reference: [3] <author> G. Ricart and A. K. Agrawala. </author> <title> An Optimal Algorithm for Mutual Exclusion in Computer Networks. </title> <journal> Communications of the ACM, </journal> <month> Jan </month> <year> 1981. </year>
Reference-contexts: The lack of shared memory makes implemention of semaphores very difficult in a distributed system. An implementation of semaphores in such a system must rely on message passing. To protect a critical section in a distributed system, several algorithms based on message passing have been proposed <ref> [2, 3, 4, 5, 6, 7] </ref>. Note that, these algorithms indirectly implement binary semaphore in distributed systems. There is still a need for general purpose resource counting semaphores in distributed systems. Providing such mechanisms through the use of a centralized controller is undesirable for several reasons.
Reference: [4] <author> M. Maekawa. </author> <title> A p N Algorithm for Mutual Exclusion in Decentralized Systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <month> May </month> <year> 1985. </year>
Reference-contexts: The lack of shared memory makes implemention of semaphores very difficult in a distributed system. An implementation of semaphores in such a system must rely on message passing. To protect a critical section in a distributed system, several algorithms based on message passing have been proposed <ref> [2, 3, 4, 5, 6, 7] </ref>. Note that, these algorithms indirectly implement binary semaphore in distributed systems. There is still a need for general purpose resource counting semaphores in distributed systems. Providing such mechanisms through the use of a centralized controller is undesirable for several reasons.
Reference: [5] <author> I. Suzuki and T. Kasami. </author> <title> A Distributed Mutual Exclusion Algorithm. </title> <journal> ACM Transactions on Computer Systems, </journal> <month> Nov </month> <year> 1985. </year> <month> 19 </month>
Reference-contexts: The lack of shared memory makes implemention of semaphores very difficult in a distributed system. An implementation of semaphores in such a system must rely on message passing. To protect a critical section in a distributed system, several algorithms based on message passing have been proposed <ref> [2, 3, 4, 5, 6, 7] </ref>. Note that, these algorithms indirectly implement binary semaphore in distributed systems. There is still a need for general purpose resource counting semaphores in distributed systems. Providing such mechanisms through the use of a centralized controller is undesirable for several reasons. <p> Acquiring a semaphore implies that the node which currently holds the semaphore must be determined. This can be accomplished in several ways. One approach is to broadcast the request message to every node in the cluster <ref> [5] </ref>. An alternative approach is to maintain a probable holder variable on each node that indicates the node likely to hold the semaphore [6]. This variable at a node indicates the node to whom it passed the semaphore most recently.
Reference: [6] <author> M. Naimi and M. Trehel. </author> <title> An Improvement of the log(n) Distributed Mutual Ex--clusion Algorithm. </title> <booktitle> In Proc. of the 7th International Conference on Distributed Computing Systems, </booktitle> <year> 1987. </year>
Reference-contexts: The lack of shared memory makes implemention of semaphores very difficult in a distributed system. An implementation of semaphores in such a system must rely on message passing. To protect a critical section in a distributed system, several algorithms based on message passing have been proposed <ref> [2, 3, 4, 5, 6, 7] </ref>. Note that, these algorithms indirectly implement binary semaphore in distributed systems. There is still a need for general purpose resource counting semaphores in distributed systems. Providing such mechanisms through the use of a centralized controller is undesirable for several reasons. <p> This can be accomplished in several ways. One approach is to broadcast the request message to every node in the cluster [5]. An alternative approach is to maintain a probable holder variable on each node that indicates the node likely to hold the semaphore <ref> [6] </ref>. This variable at a node indicates the node to whom it passed the semaphore most recently. The request message is sent to the node specified by the probable holder variable. <p> In the worst case, however, the request message must be forwarded to every node in the cluster. This would require n= p s i 1 messages to get to the holder node. As was shown in <ref> [6] </ref>, on average we expect O (log (n= p s i )) messages. If the holder node does not have any other requests pending, the current request can be satisfied immediately, incurring one additional message.
Reference: [7] <author> Mukesh Singhal. </author> <title> A Heuristically-Aided Algorithm for Mutual Exclusion in Distributed Systems. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 38(5), </volume> <month> May </month> <year> 1989. </year>
Reference-contexts: The lack of shared memory makes implemention of semaphores very difficult in a distributed system. An implementation of semaphores in such a system must rely on message passing. To protect a critical section in a distributed system, several algorithms based on message passing have been proposed <ref> [2, 3, 4, 5, 6, 7] </ref>. Note that, these algorithms indirectly implement binary semaphore in distributed systems. There is still a need for general purpose resource counting semaphores in distributed systems. Providing such mechanisms through the use of a centralized controller is undesirable for several reasons. <p> The broadcast approach, however, results in excessive message traffic (jLRj 1 messages per request) on the network. A reasonable compromise might be to maintain a history of recent holders of the semaphore and multicast the request message to a subset of the nodes in the LR set <ref> [7] </ref>. We are conducting simulation studies of these approaches to determine their suitability for various traffic patterns. In the rest of this section we assume the probable holder method to access the semaphore. When the requesting node becomes the holder of the semaphore, it performs the P operation.
Reference: [8] <author> Kai Li. </author> <title> "Shared Virtual Memory on Loosely Coupled Multiprocessors". </title> <type> PhD thesis, </type> <institution> Yale University, </institution> <month> September </month> <year> 1986. </year>
Reference-contexts: In recent years, there has been wide-spread interest in implementing shared memory programming paradigm on distributed systems. Such systems, called Distributed Shared Memory (DSM), make it possible to execute shared memory parallel programs on a distributed system <ref> [8, 9, 10, 11, 12, 13] </ref>.This makes it all the more important to provide shared variable-like synchronization mechanisms in distributed systems. Most DSM systems provide centralized implementations of mechanisms such as semaphores. A notable exception is Munin, which provides distributed locks for synchronization [14].
Reference: [9] <author> John Bennett, John Carter, and Willy Zwaenepoel. "Munin: </author> <title> Distributed Shared Memory Based on Type-Specific Memory Coherence". </title> <booktitle> In Symp. on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 168-175, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: In recent years, there has been wide-spread interest in implementing shared memory programming paradigm on distributed systems. Such systems, called Distributed Shared Memory (DSM), make it possible to execute shared memory parallel programs on a distributed system <ref> [8, 9, 10, 11, 12, 13] </ref>.This makes it all the more important to provide shared variable-like synchronization mechanisms in distributed systems. Most DSM systems provide centralized implementations of mechanisms such as semaphores. A notable exception is Munin, which provides distributed locks for synchronization [14].
Reference: [10] <author> U. Ramachandran and M. Y. A. Khalidi. </author> <title> An Implementation of Distributed Shared Memory. </title> <journal> Software Practice and Experience, </journal> <volume> 21(5) </volume> <pages> 443-464, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: In recent years, there has been wide-spread interest in implementing shared memory programming paradigm on distributed systems. Such systems, called Distributed Shared Memory (DSM), make it possible to execute shared memory parallel programs on a distributed system <ref> [8, 9, 10, 11, 12, 13] </ref>.This makes it all the more important to provide shared variable-like synchronization mechanisms in distributed systems. Most DSM systems provide centralized implementations of mechanisms such as semaphores. A notable exception is Munin, which provides distributed locks for synchronization [14].
Reference: [11] <author> Roberto Bisiani and Mosur Ravishankar. </author> <title> "Plus: A Distributed Shared-Memory System". </title> <booktitle> In International Symp. on Computer Architectures, </booktitle> <pages> pages 115-124, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: In recent years, there has been wide-spread interest in implementing shared memory programming paradigm on distributed systems. Such systems, called Distributed Shared Memory (DSM), make it possible to execute shared memory parallel programs on a distributed system <ref> [8, 9, 10, 11, 12, 13] </ref>.This makes it all the more important to provide shared variable-like synchronization mechanisms in distributed systems. Most DSM systems provide centralized implementations of mechanisms such as semaphores. A notable exception is Munin, which provides distributed locks for synchronization [14].
Reference: [12] <author> Brett Fleisch and Gerald Popek. </author> <title> "Mirage: A Coherent Distributed Shared Memory Design". </title> <booktitle> In Proceedings of the eleventh ACM Symp. on Operating System Principles, </booktitle> <pages> pages 211-223, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: In recent years, there has been wide-spread interest in implementing shared memory programming paradigm on distributed systems. Such systems, called Distributed Shared Memory (DSM), make it possible to execute shared memory parallel programs on a distributed system <ref> [8, 9, 10, 11, 12, 13] </ref>.This makes it all the more important to provide shared variable-like synchronization mechanisms in distributed systems. Most DSM systems provide centralized implementations of mechanisms such as semaphores. A notable exception is Munin, which provides distributed locks for synchronization [14].
Reference: [13] <author> Bill Nitzberg and Virginia Lo. </author> <title> "Distributed Shared Memory: A Survey of Issues and Algorithms". </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 52-60, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: In recent years, there has been wide-spread interest in implementing shared memory programming paradigm on distributed systems. Such systems, called Distributed Shared Memory (DSM), make it possible to execute shared memory parallel programs on a distributed system <ref> [8, 9, 10, 11, 12, 13] </ref>.This makes it all the more important to provide shared variable-like synchronization mechanisms in distributed systems. Most DSM systems provide centralized implementations of mechanisms such as semaphores. A notable exception is Munin, which provides distributed locks for synchronization [14].
Reference: [14] <author> John Carter, John Bennett, and Willy Zwaenepoel. </author> <title> "Implementation and Performance of Munin". </title> <booktitle> In ACM Symp. on Operating System Principles, </booktitle> <pages> pages 152-164, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Most DSM systems provide centralized implementations of mechanisms such as semaphores. A notable exception is Munin, which provides distributed locks for synchronization <ref> [14] </ref>. In this paper, we propose a distributed implementation of semaphores which efficiently performs P and V operations [15, 16] on semaphores. The rest the paper is organized as follows. Section 2 describes the system model we use. The algorithm for accessing a semaphore is given in Section 3.
Reference: [15] <author> E. W. Dijkstra. </author> <title> Solution of a Problem in Concurrent Programming Control. </title> <journal> Communications of the ACM, </journal> <pages> page 569, </pages> <month> Sep </month> <year> 1965. </year>
Reference-contexts: Most DSM systems provide centralized implementations of mechanisms such as semaphores. A notable exception is Munin, which provides distributed locks for synchronization [14]. In this paper, we propose a distributed implementation of semaphores which efficiently performs P and V operations <ref> [15, 16] </ref> on semaphores. The rest the paper is organized as follows. Section 2 describes the system model we use. The algorithm for accessing a semaphore is given in Section 3. The proof of correctness and performance of our algorithm is given in Sections 4 and 5 respectively.
Reference: [16] <author> E. W. Dijkstra. </author> <title> Cooperating Sequential Processes. </title> <editor> In F. Genuys, editor, </editor> <booktitle> Programming Languages, </booktitle> <pages> pages 43-112. </pages> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1968. </year> <month> 20 </month>
Reference-contexts: Most DSM systems provide centralized implementations of mechanisms such as semaphores. A notable exception is Munin, which provides distributed locks for synchronization [14]. In this paper, we propose a distributed implementation of semaphores which efficiently performs P and V operations <ref> [15, 16] </ref> on semaphores. The rest the paper is organized as follows. Section 2 describes the system model we use. The algorithm for accessing a semaphore is given in Section 3. The proof of correctness and performance of our algorithm is given in Sections 4 and 5 respectively.
References-found: 16

