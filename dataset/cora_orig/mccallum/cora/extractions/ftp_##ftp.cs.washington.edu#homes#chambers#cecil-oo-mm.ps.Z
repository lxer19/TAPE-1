URL: ftp://ftp.cs.washington.edu/homes/chambers/cecil-oo-mm.ps.Z
Refering-URL: http://www.cs.washington.edu/research/projects/cecil/www/Papers/cecil-oo-mm.html
Root-URL: 
Email: chambers@cs.washington.edu  
Title: Object-Oriented Multi-Methods in Cecil  
Author: Craig Chambers 
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering, FR-35 University of Washington,  
Date: July, 1992.  
Note: To be published in ECOOP 92 Conference Proceedings, Utrecht, the Netherlands,  
Abstract: Multiple dispatching provides increased expressive power over single dispatching by guiding method lookup using the values of all arguments instead of only the receiver. However, existing languages with multiple dispatching do not encourage the data-abstraction-oriented programming style that is encouraged by traditional single-dispatching languages; instead existing multiple-dispatching languages tend to foster a function-oriented programming style organized around generic functions. We propose an alternative view of multiple dispatching that is intended to promote a data-abstraction-oriented programming style. Instead of viewing a multi-method as outside of all objects, we view a multi-method as inside the objects for which the multi-method applies (on which it dispatches). Because objects are closely connected to the multi-methods implementing their operations, the internals of an object can be encapsulated by being accessible only to the closely-connected multi-methods. We are exploring this object-oriented view of multi-methods in the context of a new programming language named Cecil. 
Abstract-found: 1
Intro-found: 1
Reference: [Agrawal et al. 91] <author> Rakesh Agrawal, Linda G. DeMichiel, and Bruce G. Lindsay. </author> <title> Static Type Checking of Multi-Methods. </title> <booktitle> In OOPSLA 91 Conference Proceedings, </booktitle> <pages> pp. 113-128, </pages> <address> Phoenix, AZ, </address> <month> October, </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(11), </note> <month> November, </month> <year> 1991. </year>
Reference-contexts: CLOS also supports reective capabilities [Kiczales et al. 91], an interesting area which Cecil does not address. Recently, some researchers have developed a static type system for CLOS-like languages <ref> [Agrawal et al. 91] </ref>. However, their type system does not handle ambiguous messages, abstract methods, or parameterized classes, nor does it provide a clean separation between types and classes. The Cecil type system provides these additional features. Only a few languages outside the CLOS family support multiple dispatching.
Reference: [Bobrow et al. 86] <author> Daniel G. Bobrow, Kenneth Kahn, Gregor Kiczales, Larry Masinter, Mark Stefik, and Frank Zdybel. CommonLoops: </author> <title> Merging Lisp and Object-Oriented Programming. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 17-29, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: These languages are called multiple-dispatching languages; methods in a multiple-dispatching language are called multi-methods. Perhaps the best-known multiple-dispatching language is CLOS [Bobrow et al. 88]; CommonLoops <ref> [Bobrow et al. 86] </ref>, one of CLOSs predecessors, pioneered support for multi-methods. In a multiple-dispatching language, the programmer can handle several interesting arguments by writing multi-methods that dispatch on each interesting argument. <p> We also will explore programming environments for languages like Cecil, since we believe the presence of a supporting environment to be crucial for fostering a data-abstraction-oriented programming style. 5 Related Work Much of the related research has already been discussed. CLOS [Bobrow et al. 88] and its predecessor CommonLoops <ref> [Bobrow et al. 86] </ref> pioneered the use of multiple dispatching.
Reference: [Bobrow et al. 88] <author> D. G. Bobrow, L. G. DeMichiel, R. P. Gabriel, S. E. Keene, G. Kiczales, D. A. Moon. </author> <title> Common Lisp Object System Specification X3J13. </title> <journal> In SIGPLAN Notices 23(Special Issue), </journal> <month> September, </month> <year> 1988. </year>
Reference-contexts: These languages are called multiple-dispatching languages; methods in a multiple-dispatching language are called multi-methods. Perhaps the best-known multiple-dispatching language is CLOS <ref> [Bobrow et al. 88] </ref>; CommonLoops [Bobrow et al. 86], one of CLOSs predecessors, pioneered support for multi-methods. In a multiple-dispatching language, the programmer can handle several interesting arguments by writing multi-methods that dispatch on each interesting argument. <p> We also will explore programming environments for languages like Cecil, since we believe the presence of a supporting environment to be crucial for fostering a data-abstraction-oriented programming style. 5 Related Work Much of the related research has already been discussed. CLOS <ref> [Bobrow et al. 88] </ref> and its predecessor CommonLoops [Bobrow et al. 86] pioneered the use of multiple dispatching.
Reference: [Borning 86] <author> A. H. Borning. </author> <title> Classes Versus Prototypes in Object-Oriented Languages. </title> <booktitle> In Proceedings of the 1986 Fall Joint Computer Conference, </booktitle> <pages> pp. 36-40, </pages> <address> Dallas, TX, </address> <month> November, </month> <year> 1986. </year>
Reference: [Chambers et al. 89] <author> Craig Chambers, David Ungar, and Elgin Lee. </author> <title> An Efficient Implementation of SELF, a Dynamically-Typed Object-Oriented Language Based on Prototypes. </title> <booktitle> In OOPSLA 89 Conference Proceedings, </booktitle> <pages> pp. 49-70, </pages> <address> New Orleans, LA, </address> <month> October, </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(10), </note> <month> October, </month> <year> 1989. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference: [Chambers et al. 91] <author> Craig Chambers, David Ungar, Bay-Wei Chang, and Urs Hlzle. </author> <title> Parents are Shared Parts: Inheritance and Encapsulation in SELF. In Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: Furthermore, inheriting the instance variable part of the implementation of one data type into another is more difficult in SELF than in class-based languages, relying on complex inheritance rules and dynamic inheritance <ref> [Chambers et al. 91] </ref>. In Cecil, these problems with other prototype-based languages are addressed by allowing a field to be declared as local (the default) or shared (by prefixing the field keyword with the shared annotation). <p> Our SELF experience also encourages us to strive for the simplest possible inheritance rules that are adequate. Even the most straightforward extensions can have subtle interactions that make the extensions difficult to understand and to use <ref> [Chambers et al. 91] </ref>. Finally, complex inheritance patterns can hinder future program evolution. If method lookup can depend on program details such as parent ordering and argument ordering, the programmer must constantly be concerned with such details.
Reference: [Chambers & Ungar 91] <author> Craig Chambers and David Ungar. </author> <title> Making Pure Object-Oriented Languages Practical. </title> <booktitle> In OOPSLA 91 Conference Proceedings, </booktitle> <pages> pp. 1-15, </pages> <address> Phoenix, AZ, </address> <month> October, </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(10), </note> <month> October, </month> <year> 1991. </year>
Reference: [Chambers 92] <author> Craig Chambers. </author> <title> The Design and Implementation of the SELF Compiler, an Optimizing Compiler for Object-Oriented Programming Languages. </title> <type> Ph.D. thesis, </type> <institution> Department of Computer Science, Stanford University, </institution> <month> March, </month> <year> 1992. </year>
Reference-contexts: We use the loop method instead of user-defined recursion and required tail-recursion elimination as in Scheme [Rees & Clinger 86] because the latter precludes complete source-level debugging <ref> [Chambers 92, Hlzle et al. 92] </ref>. 8 force a non-local return (a return to the caller of the outermost lexically-enclosing method rather than to the caller of the closure, much like a return statement in C) by using the -- symbol instead of the - symbol.
Reference: [Chang & Ungar 90] <author> Bay-Wei Chang and David Ungar. </author> <title> Experiencing SELF Objects: An Object-Based Artificial Reality. </title> <type> Unpublished manuscript, </type> <year> 1990. </year>
Reference-contexts: The prototype SELF user interface <ref> [Chang & Ungar 90] </ref> could provide a good starting point for the design of the Cecil user interface, since it is graphical, interactive, and good at displaying non-hierarchical relationships among objects and at reecting the identity of shared objects.
Reference: [Cook et al. 90] <author> William Cook, Walter Hill, and Peter Canning. </author> <title> Inheritance is not Subtyping. </title> <booktitle> In Conference Record of the 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, CA, </address> <month> January, </month> <year> 1990. </year>
Reference-contexts: Other researchers also have argued the benefits of distinguishing between inheritance of implementation and inheritance of interface or specification <ref> [Snyder 86, Halbert & OBrien 86, Cook et al. 90] </ref>. Additionally, object declarations can be annotated with the role of the object in executing programs, in support of static type checking.
Reference: [Ellis & Stroustrup 90] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: However, a method can be subdivided only for particular values of a parameter or global variable, not its class; this is much like supporting only CLOSs eql specializers. Finally, a number of languages, including C++ <ref> [Ellis & Stroustrup 90] </ref> and Haskell [Hudak et al. 90], support static overloading on function arguments, but all overloading is resolved at compile-time based on the static types of the arguments rather than on their dynamic types as would be required for true multiple dispatching.
Reference: [Freeman-Benson 89] <author> Bjorn N. Freeman-Benson. </author> <title> A Proposal for Multi-Methods in SELF. </title> <type> Unpublished manuscript, </type> <month> December, </month> <year> 1989. </year>
Reference-contexts: Of course, Cecil also extends SELF with multiple dispatching. Freeman-Benson independently developed a proposal for adding multi-methods to SELF <ref> [Freeman-Benson 89] </ref>. 6 Conclusions Cecil is intended to support a data-abstraction-oriented programming style typical of single-dispatching object-oriented languages despite its reliance on multi-methods as the basic mechanism for procedural abstraction. Other multiple-dispatching languages such as CLOS organize programs around generic functions and consequently foster a function-oriented programming style.
Reference: [Gabriel et al. 91] <author> Richard P. Gabriel, Jon L White, and Daniel G. Bobrow. </author> <title> CLOS: </title> <booktitle> Integrating Object-Oriented and Functional Programming. In Communications of the ACM 34(9), </booktitle> <pages> pp. 28-38, </pages> <month> September, </month> <year> 1991. </year>
Reference-contexts: but this implementation is hidden from clients: a generic function 4 can be invoked by clients as if it were a simple function. * To a large extent, this approach to multi-methods integrates the function-oriented and object-oriented programming styles; merging Lisp and object-oriented programming was an explicit goal for CLOS <ref> [Gabriel et al. 91] </ref>. However, the extant generic-function-based approach to multiple-dispatching object-oriented languages tends to encourage a function-oriented programming style at the expense of a data-abstraction-oriented programming style.
Reference: [Goldberg & Robson 83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year> <month> 23 </month>
Reference-contexts: These argument constraints correspond to the parameter specializers of CLOS. Thus a multi-method can be viewed as part of several data types, specifically those for which it dispatches. In programming environments for single-dispatching languages, such as the Smalltalk-80 * environment <ref> [Goldberg & Robson 83, Goldberg 84] </ref>, browsers allow the programmer to view all the methods associated with a particular class.
Reference: [Goldberg 84] <author> Adele Goldberg. </author> <title> Smalltalk-80: The Interactive Programming Environment. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1984. </year>
Reference-contexts: These argument constraints correspond to the parameter specializers of CLOS. Thus a multi-method can be viewed as part of several data types, specifically those for which it dispatches. In programming environments for single-dispatching languages, such as the Smalltalk-80 * environment <ref> [Goldberg & Robson 83, Goldberg 84] </ref>, browsers allow the programmer to view all the methods associated with a particular class.
Reference: [Halbert & OBrien 86] <author> Daniel C. Halbert and Patrick D. OBrien. </author> <title> Using Types and Inheritance in Object-Oriented Languages. </title> <type> Technical report DEC-TR-437, </type> <institution> Digital Equipment Corp., </institution> <month> April, </month> <year> 1986. </year>
Reference-contexts: Other researchers also have argued the benefits of distinguishing between inheritance of implementation and inheritance of interface or specification <ref> [Snyder 86, Halbert & OBrien 86, Cook et al. 90] </ref>. Additionally, object declarations can be annotated with the role of the object in executing programs, in support of static type checking.
Reference: [Harrison & Ossher 90] <author> William Harrison and Harold Ossher. </author> <title> Subdivided Procedures: A Language Extension Supporting Extensible Programming. </title> <booktitle> In Proceedings of the 1990 International Conference on Computer Languages, </booktitle> <pages> pp. 190-197, </pages> <address> New Orleans, LA, </address> <month> March, </month> <year> 1990. </year>
Reference-contexts: A theoretical treatment of typing issues by Rouaix included a similar toy language that supported run-time overloading of functions [Rouaix 90]. The RPDE 3 environment supports subdivided methods where the value of a parameter to the method or of a global variable helps select among alternative method implementations <ref> [Harrison & Ossher 90] </ref>. However, a method can be subdivided only for particular values of a parameter or global variable, not its class; this is much like supporting only CLOSs eql specializers.
Reference: [Hebel & Johnson 90] <author> Kurt J. Hebel and Ralph E. Johnson. </author> <title> Arithmetic and Double Dispatching in Smalltalk-80. </title> <booktitle> In Journal of Object-Oriented Programming 2(6), </booktitle> <pages> pp. 40-44, </pages> <month> March, </month> <year> 1990. </year>
Reference-contexts: Hebel and Johnson developed a special browser to manage the highly-stylized double dispatching code for arithmetic over numbers and matrices in Smalltalk-80 <ref> [Hebel & Johnson 90] </ref>.
Reference: [Hlzle et al. 91a] <author> Urs Hlzle, Bay-Wei Chang, Craig Chambers, Ole Agesen, and David Ungar. </author> <title> The SELF Manual, </title> <note> Version 1.1. Unpublished manual, </note> <month> February, </month> <year> 1991. </year>
Reference-contexts: In particular, the restriction in most object-oriented languages that instance variables cannot be overridden limits the reusability of code to only those abstractions which wish to use the same representation. Other object oriented languages such as SELF <ref> [Ungar & Smith 87, Hlzle et al. 91a] </ref> and Trellis [Schaffert et al. 85, Schaffert et al. 86] have demonstrated the advantages of accessing instance variables solely through special get and set accessor methods. In the traditional generic-function-oriented view of multi-methods, however, accessing instance variables solely through multi-methods appears problematic. <p> Nevertheless, their interface might be useful even for a multiple-dispatching language such as Cecil to help display and organize multi-methods. Finally, Cecil owes much to SELF <ref> [Ungar & Smith 87, Hlzle et al. 91a] </ref>. Cecils classless object model and its uniform treatment of state and behavior are direct results of our experience with SELF.
Reference: [Hlzle et al. 91b] <author> Urs Hlzle, Craig Chambers, and David Ungar. </author> <title> Optimizing Dynamically-Typed Object-Oriented Programming Languages with Polymorphic Inline Caches. </title> <booktitle> In ECOOP 91 Conference Proceedings, </booktitle> <pages> pp. 21-38, </pages> <address> Geneva, Switzerland, </address> <month> July, </month> <year> 1991. </year>
Reference: [Hlzle et al. 92] <author> Urs Hlzle, Craig Chambers, and David Ungar. </author> <title> Debugging Optimized Code with Dynamic Deoptimization. </title> <booktitle> To appear in Proceedings of the SIGPLAN 92 Conference on Programming Language Design and Implementation, </booktitle> <address> San Francisco, CA, </address> <month> June, </month> <year> 1992. </year>
Reference-contexts: We use the loop method instead of user-defined recursion and required tail-recursion elimination as in Scheme [Rees & Clinger 86] because the latter precludes complete source-level debugging <ref> [Chambers 92, Hlzle et al. 92] </ref>. 8 force a non-local return (a return to the caller of the outermost lexically-enclosing method rather than to the caller of the closure, much like a return statement in C) by using the -- symbol instead of the - symbol.
Reference: [Hudak et al. 90] <author> Paul Hudak, Philip Wadler, Arvind, Brian Boutel, Jon Fairbairn, Joseph Fasel, Kevin Hammond, John Hughes, Thomas Johnsson, Dick Kieburtz, Rishiyur Nikhil, Simon Peyton Jones, Mike Reeve, David Wise, Jonathan Young. </author> <title> Report on the Programming Language Haskell, </title> <note> Version 1.0. Unpublished manual, </note> <month> April, </month> <year> 1990. </year>
Reference-contexts: However, a method can be subdivided only for particular values of a parameter or global variable, not its class; this is much like supporting only CLOSs eql specializers. Finally, a number of languages, including C++ [Ellis & Stroustrup 90] and Haskell <ref> [Hudak et al. 90] </ref>, support static overloading on function arguments, but all overloading is resolved at compile-time based on the static types of the arguments rather than on their dynamic types as would be required for true multiple dispatching.
Reference: [Ingalls 86] <author> Daniel H. H. Ingalls. </author> <title> A Simple Technique for Handling Multiple Polymorphism. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 347-349, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: Similar examples arise in other programming tasks. The problems of single dispatching thus extend beyond the realm of system implementors to that of the everyday programmer. 1.2 Double Dispatching In a single-dispatching language, the best solution to the asymmetry problem is double dispatching <ref> [Ingalls 86] </ref>. With double dispatching, the programmer can apply single dispatching to each interesting argument in turn, hand-simulating the effect of dispatching on all interesting arguments.
Reference: [Kiczales et al. 91] <author> Gregor Kiczales, James des Rivires, and Daniel G. Bobrow. </author> <title> The Art of the Meta-Object Protocol. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: CLOS also supports reective capabilities <ref> [Kiczales et al. 91] </ref>, an interesting area which Cecil does not address. Recently, some researchers have developed a static type system for CLOS-like languages [Agrawal et al. 91].
Reference: [LaLonde et al. 86] <author> Wilf R. LaLonde, Dave A. Thomas, and John R. Pugh. </author> <title> An Exemplar Based Smalltalk. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 322-330, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference: [Leavens 89] <author> Gary Todd Leavens. </author> <title> Verifying Object-Oriented Programs that use Subtypes. </title> <type> Ph.D. thesis, </type> <institution> MIT, </institution> <year> 1989. </year>
Reference-contexts: In addition to several interesting type system features, Kea includes multivariant functions (Keas version of multi-methods) whose static and dynamic semantics is defined in terms of a translation into the lambda calculus. Leavens describes NOAL, a statically-typed functional language that supports overloaded functions that are resolved at run-time <ref> [Leavens 89, Leavens & Weihl 90] </ref>. This language was designed primarily as a vehicle for exploring formal verification of programs with subtyping. A theoretical treatment of typing issues by Rouaix included a similar toy language that supported run-time overloading of functions [Rouaix 90].
Reference: [Leavens & Weihl 90] <author> Gary T. Leavens and William E. Weihl. </author> <title> Reasoning about Object-Oriented Programs that use Subtypes. </title> <booktitle> In OOPSLA/ECOOP 90 Conference Proceedings, </booktitle> <pages> pp. 212-223, </pages> <address> Ottawa, Canada, </address> <month> October, </month> <year> 1990. </year> <note> Published as SIGPLAN Notices 25(10), </note> <month> October, </month> <year> 1990. </year>
Reference-contexts: In addition to several interesting type system features, Kea includes multivariant functions (Keas version of multi-methods) whose static and dynamic semantics is defined in terms of a translation into the lambda calculus. Leavens describes NOAL, a statically-typed functional language that supports overloaded functions that are resolved at run-time <ref> [Leavens 89, Leavens & Weihl 90] </ref>. This language was designed primarily as a vehicle for exploring formal verification of programs with subtyping. A theoretical treatment of typing issues by Rouaix included a similar toy language that supported run-time overloading of functions [Rouaix 90].
Reference: [Lieberman 86] <author> Henry Lieberman. </author> <title> Using Prototypical Objects to Implement Shared Behavior in Object-Oriented Systems. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 214-223, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference: [Lieberman et al. 87] <author> Henry Lieberman, Lynn Andrea Stein, and David Ungar. </author> <booktitle> The Treaty of Orlando. In Addendum to the OOPSLA 87 Conference Proceedings, </booktitle> <pages> pp. 43-44, </pages> <address> Orlando, FL, </address> <month> October, </month> <year> 1987. </year> <note> Published as SIGPLAN Notices 23(5), </note> <month> May, </month> <year> 1988. </year>
Reference: [Meyer 88] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: Cecil allows a field to be given an initial value in the form of an expression that will be evaluated the first time the field is accessed; this supports functionality similar to the once functions of Eiffel <ref> [Meyer 88, Meyer 92] </ref> and other languages.
Reference: [Meyer 92] <author> Bertrand Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: Cecil allows a field to be given an initial value in the form of an expression that will be evaluated the first time the field is accessed; this supports functionality similar to the once functions of Eiffel <ref> [Meyer 88, Meyer 92] </ref> and other languages.
Reference: [Moon 86] <author> David A. Moon. </author> <title> Object-Oriented Programming with Flavors. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 1-8, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: For example, in the future research section of his introductory paper on Flavors, Moon mentions that Flavors could be extended to support multiadic operations, but expresses the concern that first a coherent and useful framework for organizing programs needs to be developed <ref> [Moon 86] </ref>. Before multi-methods will feel object-oriented to programmers used to single-dispatching languages, the programming methodology must support data-abstraction-oriented programming. Furthermore, the view that multi-methods exist external to all objects impedes encapsulating the internal implementation decisions of data types (or classes, or objects).
Reference: [Mugridge et al. 91] <author> W. B. Mugridge, J. G. Hosking, and J. Hamer. </author> <title> Multi-Methods in a Statically-Typed Programming Language. </title> <type> Technical report #50, </type> <institution> Department of Computer Science, University of Auckland, </institution> <year> 1991. </year>
Reference-contexts: The Cecil type system provides these additional features. Only a few languages outside the CLOS family support multiple dispatching. Kea is a polymorphic functional programming language with strong static typing <ref> [Mugridge et al. 91] </ref>. In addition to several interesting type system features, Kea includes multivariant functions (Keas version of multi-methods) whose static and dynamic semantics is defined in terms of a translation into the lambda calculus.
Reference: [Rees & Clinger 86] <editor> Jonathan Rees and William Clinger, editors. </editor> <title> Revised 3 Report on the Algorithmic Language Scheme. </title> <booktitle> In SIGPLAN Notices 21(12), </booktitle> <month> December, </month> <year> 1986. </year> <month> 24 </month>
Reference-contexts: We use the loop method instead of user-defined recursion and required tail-recursion elimination as in Scheme <ref> [Rees & Clinger 86] </ref> because the latter precludes complete source-level debugging [Chambers 92, Hlzle et al. 92]. 8 force a non-local return (a return to the caller of the outermost lexically-enclosing method rather than to the caller of the closure, much like a return statement in C) by using the --
Reference: [Rouaix 90] <author> Francois Rouaix. </author> <title> Safe Run-Time Overloading. </title> <booktitle> In Conference Record of the 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 355-366, </pages> <address> San Francisco, CA, </address> <month> January, </month> <year> 1990. </year>
Reference-contexts: This language was designed primarily as a vehicle for exploring formal verification of programs with subtyping. A theoretical treatment of typing issues by Rouaix included a similar toy language that supported run-time overloading of functions <ref> [Rouaix 90] </ref>. The RPDE 3 environment supports subdivided methods where the value of a parameter to the method or of a global variable helps select among alternative method implementations [Harrison & Ossher 90].
Reference: [Schaffert et al. 85] <author> Craig Schaffert, Topher Cooper, and Carrie Wilpolt. </author> <title> Trellis Object-Based Environment, Language Reference Manual. </title> <type> Technical report DEC-TR-372, </type> <month> November, </month> <year> 1985. </year>
Reference-contexts: In particular, the restriction in most object-oriented languages that instance variables cannot be overridden limits the reusability of code to only those abstractions which wish to use the same representation. Other object oriented languages such as SELF [Ungar & Smith 87, Hlzle et al. 91a] and Trellis <ref> [Schaffert et al. 85, Schaffert et al. 86] </ref> have demonstrated the advantages of accessing instance variables solely through special get and set accessor methods. In the traditional generic-function-oriented view of multi-methods, however, accessing instance variables solely through multi-methods appears problematic.
Reference: [Schaffert et al. 86] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt. </author> <title> An Introduction to Trellis/Owl. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 9-16, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: In particular, the restriction in most object-oriented languages that instance variables cannot be overridden limits the reusability of code to only those abstractions which wish to use the same representation. Other object oriented languages such as SELF [Ungar & Smith 87, Hlzle et al. 91a] and Trellis <ref> [Schaffert et al. 85, Schaffert et al. 86] </ref> have demonstrated the advantages of accessing instance variables solely through special get and set accessor methods. In the traditional generic-function-oriented view of multi-methods, however, accessing instance variables solely through multi-methods appears problematic.
Reference: [Snyder 86] <author> Alan Snyder. </author> <title> Encapsulation and Inheritance in Object-Oriented Programming Languages. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 38-45, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: Other researchers also have argued the benefits of distinguishing between inheritance of implementation and inheritance of interface or specification <ref> [Snyder 86, Halbert & OBrien 86, Cook et al. 90] </ref>. Additionally, object declarations can be annotated with the role of the object in executing programs, in support of static type checking. <p> For example, Flavors linearizes the class hierarchy, producing a total ordering on classes based on each class local left-to-right ordering of superclasses that can be searched without ambiguity just as in the single inheritance case. However, linearization can produce unexpected method lookup results, especially if the program contains errors <ref> [Snyder 86] </ref>. CLOS and CommonLoops extend this linearization approach to multi-methods, totally ordering multi-methods by prioritizing argument position, with earlier argument positions completely dominating later argument positions. Again, this removes the possibility of run-time ambiguities, at the cost of automatically resolving ambiguities that may be the result of programming errors.
Reference: [Ungar & Smith 87] <author> David Ungar and Randall B. Smith. </author> <title> SELF: The Power of Simplicity. </title> <booktitle> In OOPSLA 87 Conference Proceedings, </booktitle> <pages> pp. 227-241, </pages> <address> Orlando, FL, </address> <month> October, </month> <year> 1987. </year> <note> Published as SIGPLAN Notices 22(12), </note> <month> December, </month> <year> 1987. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: In particular, the restriction in most object-oriented languages that instance variables cannot be overridden limits the reusability of code to only those abstractions which wish to use the same representation. Other object oriented languages such as SELF <ref> [Ungar & Smith 87, Hlzle et al. 91a] </ref> and Trellis [Schaffert et al. 85, Schaffert et al. 86] have demonstrated the advantages of accessing instance variables solely through special get and set accessor methods. In the traditional generic-function-oriented view of multi-methods, however, accessing instance variables solely through multi-methods appears problematic. <p> Nevertheless, their interface might be useful even for a multiple-dispatching language such as Cecil to help display and organize multi-methods. Finally, Cecil owes much to SELF <ref> [Ungar & Smith 87, Hlzle et al. 91a] </ref>. Cecils classless object model and its uniform treatment of state and behavior are direct results of our experience with SELF.
Reference: [Ungar et al. 91] <author> David Ungar, Craig Chambers, Bay-Wei Chang, and Urs Hlzle. </author> <title> Organizing Programs without Classes. In Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: in SELF most data types are actually defined with two objects: one object, the prototype, includes all the instance-specific variables that objects of the data type need, while the other object, the traits object, is inherited by the prototype and holds the methods and shared state of the data type <ref> [Ungar et al. 91] </ref>. New SELF objects are created by cloning (shallow-copying) the prototype, thus giving new objects their own instance variables while sharing the parent traits object and its methods and state.
References-found: 40

