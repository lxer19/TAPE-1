URL: ftp://ftp.cs.washington.edu/tr/1994/02/UW-CSE-94-02-02.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-title.html
Root-URL: 
Title: An Algorithm for Exact Bounds on the Time Separation of Events in Concurrent Systems 1  
Author: Henrik Hulgaard, Steven M. Burns, Tod Amon and Gaetano Borriello 
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering, FR-35 University of Washington  2 Department of Computer Science, Southwest Texas State.  
Abstract: Technical Report 94-02-02 February 9, 1994 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, J. E. Hopcroft, and J. D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1974. </year>
Reference-contexts: can be analyzed, consider the 1 following concurrent system consisting of three processes that synchronize over two channels a and b, and perform some internal computation (delay ranges specified in brackets): Process 1 :: repeat f Synchronize a; Compute [4, 10]; g Process 2 :: repeat f Synchronize a; Compute <ref> [1, 2] </ref>; Synchronize b; Compute [1, 6]; g Process 3 :: repeat f Synchronize b; Compute [5, 20]; g There are many questions regarding the temporal behavior of this system that we might ask: "How slowly might the first process cycle?", or "How long might the second process be idle waiting <p> 1 following concurrent system consisting of three processes that synchronize over two channels a and b, and perform some internal computation (delay ranges specified in brackets): Process 1 :: repeat f Synchronize a; Compute [4, 10]; g Process 2 :: repeat f Synchronize a; Compute [1, 2]; Synchronize b; Compute <ref> [1, 6] </ref>; g Process 3 :: repeat f Synchronize b; Compute [5, 20]; g There are many questions regarding the temporal behavior of this system that we might ask: "How slowly might the first process cycle?", or "How long might the second process be idle waiting on the third process?", or <p> For the example in Figure 1, which corresponds to the three-process example in the introduction, we have E 0 = froot; a; bg and R 0 = froot [0;0];0 [4;10];1 [1;2];0 [1;6];1 [5;20];1 <ref> [1; 2] </ref> [1; 6] root [0; 0] through an edge indicates the value of the occurrence index offset, ", for the edge (e.g., b 7! a constrains a k relative to b k1 ). <p> For the example in Figure 1, which corresponds to the three-process example in the introduction, we have E 0 = froot; a; bg and R 0 = froot [0;0];0 [4;10];1 [1;2];0 [1;6];1 [5;20];1 [1; 2] <ref> [1; 6] </ref> root [0; 0] through an edge indicates the value of the occurrence index offset, ", for the edge (e.g., b 7! a constrains a k relative to b k1 ). <p> Before we present an algebraic solution that allows us to analyze the infinite unfolded graph, we present two additional examples constructed to illustrate both the simplicity and the complexity of the required analysis. Section 5 presents realistic applications of the timing analysis. a <ref> [1; 2] </ref> c b root ranges are [0; 0]. The first example, in Figure 6, is a process graph that represents two coupled pipelines. If the pipelines were not coupled at c, the maximum separation between a and e would be unbounded. <p> Adding more stages to both pipelines (before the synchronization, c) would allow e to get further ahead of a. f e [; ] d c [3; 3] [3; 3] [0; 0] root <ref> [1; 1] </ref>. Our second example, in Figure 7, exhibits interesting behavior. <p> The process graph in Figure 14 requires 149 unfoldings before the bounds converge and the number of unfoldings can be made arbitrarily large by changing the delay values of the process graph. 13 b d c [10; 10] [10; 10][5; 5] <ref> [1; 2] </ref> [1; 2] [1; 3] root [0; 0][0; 0] [10; 10] [10; 99] [10; 50] [10; 10] [10; 10] g d e f for the separation analysis t (b k ) t (d k2 ). <p> The process graph in Figure 14 requires 149 unfoldings before the bounds converge and the number of unfoldings can be made arbitrarily large by changing the delay values of the process graph. 13 b d c [10; 10] [10; 10][5; 5] <ref> [1; 2] </ref> [1; 2] [1; 3] root [0; 0][0; 0] [10; 10] [10; 99] [10; 50] [10; 10] [10; 10] g d e f for the separation analysis t (b k ) t (d k2 ). <p> The process graph in Figure 14 requires 149 unfoldings before the bounds converge and the number of unfoldings can be made arbitrarily large by changing the delay values of the process graph. 13 b d c [10; 10] [10; 10][5; 5] [1; 2] [1; 2] <ref> [1; 3] </ref> root [0; 0][0; 0] [10; 10] [10; 99] [10; 50] [10; 10] [10; 10] g d e f for the separation analysis t (b k ) t (d k2 ). <p> We overload F and use F [n] to denote the function for the graph G (k 0 +n) for n 0, i.e., F [n] = F root (k 0 +n) 7!t (0) = R n S n1 S n2 S 2 S 1 S 0 T : F [0] F <ref> [1] </ref> F [2] T S 0 X t1 X t (0) S 1 R 2 X t (0) from R n S n1 S n2 S 1 S 0 T. The figure shows the three graphs for the construction of F [0] , F [1] , and F [2] . multiple <p> 0 T : F [0] F <ref> [1] </ref> F [2] T S 0 X t1 X t (0) S 1 R 2 X t (0) from R n S n1 S n2 S 1 S 0 T. The figure shows the three graphs for the construction of F [0] , F [1] , and F [2] . multiple S i segments. From (12) it follows that some of the R i and S i matrices are the same. <p> A matrix closure algorithm <ref> [1] </ref> can be used to compute S fl because (F ; ; ; 0; 1) forms a closed semiring. This is the key observation that allows us to implicitly analyze the infinite unfolded process graph. <p> This ensures that the matrix S is independent of the number of unfoldings and we can use the closure of S to analyze the infinite graph. A simple non-strongly connected process graph is shown in Figure 18. ca <ref> [1; 1] </ref> [5; 5] [3; 3] path to s (fi) and we can assign an arbitrary constants to m (a (k) ) and m (c (k) ). <p> Using our implementation of the techniques described in this paper, a separation analysis can be performed in under 2 seconds on a SPARC 2. For example, if all the delays associated with rules within the blocks of Figure 23 are in the range <ref> [0; 1] </ref> (small in comparison to the delays associated with computation and data transfer) and we make the following assignments of delay ranges to the delay elements modeling the computations: 23 mdli" rao" bo" mslo" bi# msli# rai# mslo# msli" mdlo" mdli# mdlo# [2; 9] [2; 9] [2; 13] [2; 13] <p> in comparison to the delays associated with computation and data transfer) and we make the following assignments of delay ranges to the delay elements modeling the computations: 23 mdli" rao" bo" mslo" bi# msli# rai# mslo# msli" mdlo" mdli# mdlo# [2; 9] [2; 9] [2; 13] [2; 13] [5; 30] <ref> [30; 1] </ref> root [0; 0] have [0; 1] as the delay range. <p> with computation and data transfer) and we make the following assignments of delay ranges to the delay elements modeling the computations: 23 mdli" rao" bo" mslo" bi# msli# rai# mslo# msli" mdlo" mdli# mdlo# [2; 9] [2; 9] [2; 13] [2; 13] [5; 30] [30; 1] root [0; 0] have <ref> [0; 1] </ref> as the delay range. <p> A similar argument holds for (23). (24) and (25) are needed to insure that the set and reset signals to the latch are not active simultaneously. If we assume that all gate delays are in the range [2; 3] and all the wire delays are in the range <ref> [0; 1] </ref> except those specified explicitly in the table, we get the results shown in Table 2. The CPU time needed to verify the four conditions is less than half a second on a SPARC 2. Arc A Arc B (22) (23) (24) (25) OK p p [0; 5] [0; 1] <p> range <ref> [0; 1] </ref> except those specified explicitly in the table, we get the results shown in Table 2. The CPU time needed to verify the four conditions is less than half a second on a SPARC 2. Arc A Arc B (22) (23) (24) (25) OK p p [0; 5] [0; 1] 3 1 3 3 p p Table 2: Results of the maximum separation analysis for the D-element. (i) is the maxi mum separation corresponding to equation (i). 6 Conclusion We have presented an efficient exact solution to a fundamental problem for timing analysis and verification of concurrent systems, namely,
Reference: [2] <author> R. Alur and D. L. Dill. </author> <title> The theory of timed automata. </title> <editor> In J. W. de Bakker, C. Huizing, W. P. de Roever, and G. Rosenberg, editors, </editor> <booktitle> Real-Time: Theory in Practice, Lecture Notes in Computer Science #600, </booktitle> <pages> pages 28-73. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: One aspect which much of the research has in common is its focus on analyzing very general systems. This is true for approaches based on decision procedures (e.g., [16, 17]), model checking (e.g., [7, 18]), exhaustive simulation (e.g., [20]), language containment (e.g., <ref> [2, 26] </ref>), deductive proofs techniques (e.g., [27]) and theorem proving (e.g., [12]). For this reason, the timing analysis is usually at least of exponential time complexity and is often undecidable [15]. Because these approaches do not yield practical and efficient algorithms they are not particularly useful for synthesis purposes. <p> can be analyzed, consider the 1 following concurrent system consisting of three processes that synchronize over two channels a and b, and perform some internal computation (delay ranges specified in brackets): Process 1 :: repeat f Synchronize a; Compute [4, 10]; g Process 2 :: repeat f Synchronize a; Compute <ref> [1, 2] </ref>; Synchronize b; Compute [1, 6]; g Process 3 :: repeat f Synchronize b; Compute [5, 20]; g There are many questions regarding the temporal behavior of this system that we might ask: "How slowly might the first process cycle?", or "How long might the second process be idle waiting <p> For the example in Figure 1, which corresponds to the three-process example in the introduction, we have E 0 = froot; a; bg and R 0 = froot [0;0];0 [4;10];1 [1;2];0 [1;6];1 [5;20];1 <ref> [1; 2] </ref> [1; 6] root [0; 0] through an edge indicates the value of the occurrence index offset, ", for the edge (e.g., b 7! a constrains a k relative to b k1 ). <p> Before we present an algebraic solution that allows us to analyze the infinite unfolded graph, we present two additional examples constructed to illustrate both the simplicity and the complexity of the required analysis. Section 5 presents realistic applications of the timing analysis. a <ref> [1; 2] </ref> c b root ranges are [0; 0]. The first example, in Figure 6, is a process graph that represents two coupled pipelines. If the pipelines were not coupled at c, the maximum separation between a and e would be unbounded. <p> The process graph in Figure 14 requires 149 unfoldings before the bounds converge and the number of unfoldings can be made arbitrarily large by changing the delay values of the process graph. 13 b d c [10; 10] [10; 10][5; 5] <ref> [1; 2] </ref> [1; 2] [1; 3] root [0; 0][0; 0] [10; 10] [10; 99] [10; 50] [10; 10] [10; 10] g d e f for the separation analysis t (b k ) t (d k2 ). <p> The process graph in Figure 14 requires 149 unfoldings before the bounds converge and the number of unfoldings can be made arbitrarily large by changing the delay values of the process graph. 13 b d c [10; 10] [10; 10][5; 5] <ref> [1; 2] </ref> [1; 2] [1; 3] root [0; 0][0; 0] [10; 10] [10; 99] [10; 50] [10; 10] [10; 10] g d e f for the separation analysis t (b k ) t (d k2 ). <p> F and use F [n] to denote the function for the graph G (k 0 +n) for n 0, i.e., F [n] = F root (k 0 +n) 7!t (0) = R n S n1 S n2 S 2 S 1 S 0 T : F [0] F [1] F <ref> [2] </ref> T S 0 X t1 X t (0) S 1 R 2 X t (0) from R n S n1 S n2 S 1 S 0 T. The figure shows the three graphs for the construction of F [0] , F [1] , and F [2] . multiple S i <p> [0] F [1] F <ref> [2] </ref> T S 0 X t1 X t (0) S 1 R 2 X t (0) from R n S n1 S n2 S 1 S 0 T. The figure shows the three graphs for the construction of F [0] , F [1] , and F [2] . multiple S i segments. From (12) it follows that some of the R i and S i matrices are the same. <p> of Figure 23 are in the range [0; 1] (small in comparison to the delays associated with computation and data transfer) and we make the following assignments of delay ranges to the delay elements modeling the computations: 23 mdli" rao" bo" mslo" bi# msli# rai# mslo# msli" mdlo" mdli# mdlo# <ref> [2; 9] </ref> [2; 9] [2; 13] [2; 13] [5; 30] [30; 1] root [0; 0] have [0; 1] as the delay range. <p> 23 are in the range [0; 1] (small in comparison to the delays associated with computation and data transfer) and we make the following assignments of delay ranges to the delay elements modeling the computations: 23 mdli" rao" bo" mslo" bi# msli# rai# mslo# msli" mdlo" mdli# mdlo# <ref> [2; 9] </ref> [2; 9] [2; 13] [2; 13] [5; 30] [30; 1] root [0; 0] have [0; 1] as the delay range. <p> in the range [0; 1] (small in comparison to the delays associated with computation and data transfer) and we make the following assignments of delay ranges to the delay elements modeling the computations: 23 mdli" rao" bo" mslo" bi# msli# rai# mslo# msli" mdlo" mdli# mdlo# [2; 9] [2; 9] <ref> [2; 13] </ref> [2; 13] [5; 30] [30; 1] root [0; 0] have [0; 1] as the delay range. <p> range [0; 1] (small in comparison to the delays associated with computation and data transfer) and we make the following assignments of delay ranges to the delay elements modeling the computations: 23 mdli" rao" bo" mslo" bi# msli# rai# mslo# msli" mdlo" mdli# mdlo# [2; 9] [2; 9] <ref> [2; 13] </ref> [2; 13] [5; 30] [30; 1] root [0; 0] have [0; 1] as the delay range. <p> The delay through a C-element is set to <ref> [2; 3] </ref> in all cases. (i) is the maximum separation corresponding to equation (i). <p> A similar argument holds for (23). (24) and (25) are needed to insure that the set and reset signals to the latch are not active simultaneously. If we assume that all gate delays are in the range <ref> [2; 3] </ref> and all the wire delays are in the range [0; 1] except those specified explicitly in the table, we get the results shown in Table 2. The CPU time needed to verify the four conditions is less than half a second on a SPARC 2.
Reference: [3] <author> T. Amon and G. Borriello. </author> <title> An approach to symbolic timing verification. </title> <booktitle> In 29th ACM/IEEE Design Automation Conference, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: Both [24] and [30] handle only acyclic graphs. However, they provide a theoretical foundation upon which our solution is built. Both [8] and [6] use cyclic graph models but they deal only with fixed delays between events. Several verifiers have been developed for specific applications <ref> [3, 5, 21] </ref>. This paper is composed of six sections. We follow this introduction with a formalization of the timing analysis and in Section 3 we present an algorithm that solves the maximum separation problem for acyclic graphs. <p> Adding more stages to both pipelines (before the synchronization, c) would allow e to get further ahead of a. f e [; ] d c <ref> [3; 3] </ref> [3; 3] [0; 0] root [1; 1]. Our second example, in Figure 7, exhibits interesting behavior. <p> Adding more stages to both pipelines (before the synchronization, c) would allow e to get further ahead of a. f e [; ] d c <ref> [3; 3] </ref> [3; 3] [0; 0] root [1; 1]. Our second example, in Figure 7, exhibits interesting behavior. <p> The process graph in Figure 14 requires 149 unfoldings before the bounds converge and the number of unfoldings can be made arbitrarily large by changing the delay values of the process graph. 13 b d c [10; 10] [10; 10][5; 5] [1; 2] [1; 2] <ref> [1; 3] </ref> root [0; 0][0; 0] [10; 10] [10; 99] [10; 50] [10; 10] [10; 10] g d e f for the separation analysis t (b k ) t (d k2 ). <p> This ensures that the matrix S is independent of the number of unfoldings and we can use the closure of S to analyze the infinite graph. A simple non-strongly connected process graph is shown in Figure 18. ca [1; 1] [5; 5] <ref> [3; 3] </ref> path to s (fi) and we can assign an arbitrary constants to m (a (k) ) and m (c (k) ). <p> This class of non-strongly connected process graphs can be handled by introducing a more complex functional algebra (the elements of the algebra are functions in two variables). We do not describe this algebra because it is not needed for the subsequent applications. b a [5; 5] <ref> [3; 3] </ref> different values. For s = b, we have r (a) = 5 and r (b) = 3. 4.8 Efficiency Considerations There are two potential inefficiencies associated with the tse algorithm. These inefficiencies are not usually encountered in practical applications. 19 1. <p> The CPU time to verify the four conditions is less than a second on a SPARC 2. d skew t skew r (18) (19) (20) (21) OK 6 [0; 0] [0; 0] 3 3 0 0 6 [0; 0] <ref> [0; 3] </ref> 3 3 0 0 6 [0; 3] [0; 0] 0 0 3 3 6 [0; 0] [6; 6] 0 0 3 3 8 [0; 0] [0; 0] 5 5 4 4 8 [0; 3] [0; 5] 2 2 0 0 8 [0; 5] [0; 3] 0 0 1 1 <p> The CPU time to verify the four conditions is less than a second on a SPARC 2. d skew t skew r (18) (19) (20) (21) OK 6 [0; 0] [0; 0] 3 3 0 0 6 [0; 0] <ref> [0; 3] </ref> 3 3 0 0 6 [0; 3] [0; 0] 0 0 3 3 6 [0; 0] [6; 6] 0 0 3 3 8 [0; 0] [0; 0] 5 5 4 4 8 [0; 3] [0; 5] 2 2 0 0 8 [0; 5] [0; 3] 0 0 1 1 8 [0; 0] [12; 12] 0 0 <p> (19) (20) (21) OK 6 [0; 0] [0; 0] 3 3 0 0 6 [0; 0] <ref> [0; 3] </ref> 3 3 0 0 6 [0; 3] [0; 0] 0 0 3 3 6 [0; 0] [6; 6] 0 0 3 3 8 [0; 0] [0; 0] 5 5 4 4 8 [0; 3] [0; 5] 2 2 0 0 8 [0; 5] [0; 3] 0 0 1 1 8 [0; 0] [12; 12] 0 0 5 5 8 [12; 12] [0; 0] 5 5 8 8 Table 1: Timing analysis of STARI. d is the lower bound on the clock period (the <p> 0 0 6 [0; 0] <ref> [0; 3] </ref> 3 3 0 0 6 [0; 3] [0; 0] 0 0 3 3 6 [0; 0] [6; 6] 0 0 3 3 8 [0; 0] [0; 0] 5 5 4 4 8 [0; 3] [0; 5] 2 2 0 0 8 [0; 5] [0; 3] 0 0 1 1 8 [0; 0] [12; 12] 0 0 5 5 8 [12; 12] [0; 0] 5 5 8 8 Table 1: Timing analysis of STARI. d is the lower bound on the clock period (the upper bound is irrelevant for the correctness of STARI), skew t <p> The delay through a C-element is set to <ref> [2; 3] </ref> in all cases. (i) is the maximum separation corresponding to equation (i). <p> A similar argument holds for (23). (24) and (25) are needed to insure that the set and reset signals to the latch are not active simultaneously. If we assume that all gate delays are in the range <ref> [2; 3] </ref> and all the wire delays are in the range [0; 1] except those specified explicitly in the table, we get the results shown in Table 2. The CPU time needed to verify the four conditions is less than half a second on a SPARC 2.
Reference: [4] <author> F. Baccelli, G. Cohen, G. J. Olsder, and J.-P. Quadrat. </author> <title> Synchronization and Linearity. Wiley Series in Probability and Mathematical Statistics. </title> <publisher> John Wiley and Sons, </publisher> <year> 1992. </year>
Reference-contexts: To illustrate the kinds of systems that can be analyzed, consider the 1 following concurrent system consisting of three processes that synchronize over two channels a and b, and perform some internal computation (delay ranges specified in brackets): Process 1 :: repeat f Synchronize a; Compute <ref> [4, 10] </ref>; g Process 2 :: repeat f Synchronize a; Compute [1, 2]; Synchronize b; Compute [1, 6]; g Process 3 :: repeat f Synchronize b; Compute [5, 20]; g There are many questions regarding the temporal behavior of this system that we might ask: "How slowly might the first process <p> The process graph is a simple modification of the event-rule system developed in [6]. The model can also be viewed as an extension of [24] and [30], where we consider cyclic max-only or type-2 graphs, respectively. Process graphs are similar to timed event graphs <ref> [4] </ref>, marked graphs or decision free Petri nets. <p> 2 E and u 7! v 2 R 0 ; then v k+" 2 E : The set of edges in the unfolded process graph R is defined as: R = u k 7! v k+" fi [d;D];" 3 root a 0 a 1 a 2 a 3 [0, 0] <ref> [4, 10] </ref> [4, 10] [4, 10] [4, 10] [1,6][1,6][1,6] [1,6] a 4 Events can be characterized as repeatable or non-repeatable corresponding to whether there is a cycle in the process graph containing the event. The event root is non-repeatable as it has indegree of zero. <p> and u 7! v 2 R 0 ; then v k+" 2 E : The set of edges in the unfolded process graph R is defined as: R = u k 7! v k+" fi [d;D];" 3 root a 0 a 1 a 2 a 3 [0, 0] <ref> [4, 10] </ref> [4, 10] [4, 10] [4, 10] [1,6][1,6][1,6] [1,6] a 4 Events can be characterized as repeatable or non-repeatable corresponding to whether there is a cycle in the process graph containing the event. The event root is non-repeatable as it has indegree of zero. <p> 7! v 2 R 0 ; then v k+" 2 E : The set of edges in the unfolded process graph R is defined as: R = u k 7! v k+" fi [d;D];" 3 root a 0 a 1 a 2 a 3 [0, 0] <ref> [4, 10] </ref> [4, 10] [4, 10] [4, 10] [1,6][1,6][1,6] [1,6] a 4 Events can be characterized as repeatable or non-repeatable corresponding to whether there is a cycle in the process graph containing the event. The event root is non-repeatable as it has indegree of zero. <p> 2 R 0 ; then v k+" 2 E : The set of edges in the unfolded process graph R is defined as: R = u k 7! v k+" fi [d;D];" 3 root a 0 a 1 a 2 a 3 [0, 0] <ref> [4, 10] </ref> [4, 10] [4, 10] [4, 10] [1,6][1,6][1,6] [1,6] a 4 Events can be characterized as repeatable or non-repeatable corresponding to whether there is a cycle in the process graph containing the event. The event root is non-repeatable as it has indegree of zero. <p> Figure 3 shows a possible timing assignment for the graph in Figure 2 obtained by choosing the upper bound, D, for all delays. 0 10 28 48 68 root a 0 a 1 a 2 a 3 [0, 0] <ref> [4, 10] </ref> [4, 10] [4, 10] [4, 10] [1,6][1,6][1,6] [1,6] a 4 0 vertices are annotated with the timing assignment t (v k ) obtained by choosing the upper bound, D, for all delays. 2.4 Problem Definition The problem we address in this paper is: given two events, s and t <p> Figure 3 shows a possible timing assignment for the graph in Figure 2 obtained by choosing the upper bound, D, for all delays. 0 10 28 48 68 root a 0 a 1 a 2 a 3 [0, 0] <ref> [4, 10] </ref> [4, 10] [4, 10] [4, 10] [1,6][1,6][1,6] [1,6] a 4 0 vertices are annotated with the timing assignment t (v k ) obtained by choosing the upper bound, D, for all delays. 2.4 Problem Definition The problem we address in this paper is: given two events, s and t in E <p> Figure 3 shows a possible timing assignment for the graph in Figure 2 obtained by choosing the upper bound, D, for all delays. 0 10 28 48 68 root a 0 a 1 a 2 a 3 [0, 0] <ref> [4, 10] </ref> [4, 10] [4, 10] [4, 10] [1,6][1,6][1,6] [1,6] a 4 0 vertices are annotated with the timing assignment t (v k ) obtained by choosing the upper bound, D, for all delays. 2.4 Problem Definition The problem we address in this paper is: given two events, s and t in E 0 , <p> Figure 3 shows a possible timing assignment for the graph in Figure 2 obtained by choosing the upper bound, D, for all delays. 0 10 28 48 68 root a 0 a 1 a 2 a 3 [0, 0] <ref> [4, 10] </ref> [4, 10] [4, 10] [4, 10] [1,6][1,6][1,6] [1,6] a 4 0 vertices are annotated with the timing assignment t (v k ) obtained by choosing the upper bound, D, for all delays. 2.4 Problem Definition The problem we address in this paper is: given two events, s and t in E 0 , and a <p> Except for distributivity, these properties are trivially satisfied. Distributivity relies on the monotonicly non-decreasing nature of the functions in F . Notice that function composition () is not commutative. 1 Similar to a (max; +)-algebra <ref> [9, 4] </ref>. The main differences are that the elements of F are functions instead of numbers, the max-operator maximizes functions, and the +-operator composes functions. 9 4.2 Functional Formulation of Acyclic Algorithm We can now express phase 2 of the acyclic algorithm in terms of functions. <p> For example, changing the delays <ref> [4; 10] </ref> and [5; 20] to [999,1000] and [1000,1000], respectively, changes 2 k ? from 3 to 998.
Reference: [5] <author> Gaetano Borriello. </author> <title> A New Interface Specification Methodology and its Application to Transducer Synthesis. </title> <type> Ph.D. thesis, </type> <institution> University of California at Berkeley, </institution> <year> 1988. </year>
Reference-contexts: two channels a and b, and perform some internal computation (delay ranges specified in brackets): Process 1 :: repeat f Synchronize a; Compute [4, 10]; g Process 2 :: repeat f Synchronize a; Compute [1, 2]; Synchronize b; Compute [1, 6]; g Process 3 :: repeat f Synchronize b; Compute <ref> [5, 20] </ref>; g There are many questions regarding the temporal behavior of this system that we might ask: "How slowly might the first process cycle?", or "How long might the second process be idle waiting on the third process?", or "How can we best speed-up the performance of our system?" and <p> Both [24] and [30] handle only acyclic graphs. However, they provide a theoretical foundation upon which our solution is built. Both [8] and [6] use cyclic graph models but they deal only with fixed delays between events. Several verifiers have been developed for specific applications <ref> [3, 5, 21] </ref>. This paper is composed of six sections. We follow this introduction with a formalization of the timing analysis and in Section 3 we present an algorithm that solves the maximum separation problem for acyclic graphs. <p> For example, changing the delays [4; 10] and <ref> [5; 20] </ref> to [999,1000] and [1000,1000], respectively, changes 2 k ? from 3 to 998. <p> This ensures that the matrix S is independent of the number of unfoldings and we can use the closure of S to analyze the infinite graph. A simple non-strongly connected process graph is shown in Figure 18. ca [1; 1] <ref> [5; 5] </ref> [3; 3] path to s (fi) and we can assign an arbitrary constants to m (a (k) ) and m (c (k) ). <p> This class of non-strongly connected process graphs can be handled by introducing a more complex functional algebra (the elements of the algebra are functions in two variables). We do not describe this algebra because it is not needed for the subsequent applications. b a <ref> [5; 5] </ref> [3; 3] different values. For s = b, we have r (a) = 5 and r (b) = 3. 4.8 Efficiency Considerations There are two potential inefficiencies associated with the tse algorithm. These inefficiencies are not usually encountered in practical applications. 19 1. <p> 1] (small in comparison to the delays associated with computation and data transfer) and we make the following assignments of delay ranges to the delay elements modeling the computations: 23 mdli" rao" bo" mslo" bi# msli# rai# mslo# msli" mdlo" mdli# mdlo# [2; 9] [2; 9] [2; 13] [2; 13] <ref> [5; 30] </ref> [30; 1] root [0; 0] have [0; 1] as the delay range. <p> (21) OK 6 [0; 0] [0; 0] 3 3 0 0 6 [0; 0] [0; 3] 3 3 0 0 6 [0; 3] [0; 0] 0 0 3 3 6 [0; 0] [6; 6] 0 0 3 3 8 [0; 0] [0; 0] 5 5 4 4 8 [0; 3] <ref> [0; 5] </ref> 2 2 0 0 8 [0; 5] [0; 3] 0 0 1 1 8 [0; 0] [12; 12] 0 0 5 5 8 [12; 12] [0; 0] 5 5 8 8 Table 1: Timing analysis of STARI. d is the lower bound on the clock period (the upper bound <p> 3 3 0 0 6 [0; 0] [0; 3] 3 3 0 0 6 [0; 3] [0; 0] 0 0 3 3 6 [0; 0] [6; 6] 0 0 3 3 8 [0; 0] [0; 0] 5 5 4 4 8 [0; 3] <ref> [0; 5] </ref> 2 2 0 0 8 [0; 5] [0; 3] 0 0 1 1 8 [0; 0] [12; 12] 0 0 5 5 8 [12; 12] [0; 0] 5 5 8 8 Table 1: Timing analysis of STARI. d is the lower bound on the clock period (the upper bound is irrelevant for the correctness of STARI), <p> The CPU time needed to verify the four conditions is less than half a second on a SPARC 2. Arc A Arc B (22) (23) (24) (25) OK p p <ref> [0; 5] </ref> [0; 1] 3 1 3 3 p p Table 2: Results of the maximum separation analysis for the D-element. (i) is the maxi mum separation corresponding to equation (i). 6 Conclusion We have presented an efficient exact solution to a fundamental problem for timing analysis and verification of concurrent
Reference: [6] <author> S. M. Burns. </author> <title> Performance Analysis and Optimization of Asynchronous Circuits. </title> <type> Ph.D. thesis, </type> <institution> California Institute of Technology, </institution> <year> 1991. </year> <month> CS-TR-91-1. </month>
Reference-contexts: 1 following concurrent system consisting of three processes that synchronize over two channels a and b, and perform some internal computation (delay ranges specified in brackets): Process 1 :: repeat f Synchronize a; Compute [4, 10]; g Process 2 :: repeat f Synchronize a; Compute [1, 2]; Synchronize b; Compute <ref> [1, 6] </ref>; g Process 3 :: repeat f Synchronize b; Compute [5, 20]; g There are many questions regarding the temporal behavior of this system that we might ask: "How slowly might the first process cycle?", or "How long might the second process be idle waiting on the third process?", or <p> Loose bounds that may not enable all possible optimizations were obtained by [25]. Both [24] and [30] handle only acyclic graphs. However, they provide a theoretical foundation upon which our solution is built. Both [8] and <ref> [6] </ref> use cyclic graph models but they deal only with fixed delays between events. Several verifiers have been developed for specific applications [3, 5, 21]. This paper is composed of six sections. <p> Section 5 presents four applications of the timing analysis and finally Section 6 summarizes the contributions. 2 Problem Formalization 2.1 The Process Graph We represent a concurrent system as a directed graph, called the process graph. The process graph is a simple modification of the event-rule system developed in <ref> [6] </ref>. The model can also be viewed as an extension of [24] and [30], where we consider cyclic max-only or type-2 graphs, respectively. Process graphs are similar to timed event graphs [4], marked graphs or decision free Petri nets. <p> For the example in Figure 1, which corresponds to the three-process example in the introduction, we have E 0 = froot; a; bg and R 0 = froot [0;0];0 [4;10];1 [1;2];0 [1;6];1 [5;20];1 [1; 2] <ref> [1; 6] </ref> root [0; 0] through an edge indicates the value of the occurrence index offset, ", for the edge (e.g., b 7! a constrains a k relative to b k1 ). <p> The size of the representation of a particular function may be as large as the number of paths between the two events related by the function. Point 1 is potentially serious, however in most realistic process graphs, " ? = 1 (see <ref> [6] </ref>). k ? is more of a concern because it can be large if there exists a cycle c such that d (c)="(c) is almost equal to r. <p> IMEM FETCH PCADD REG1 REG2 ALUEXEC REG3 ID E AC sty Ys ZAs A B of the process graph components within each block, see <ref> [6] </ref>. 24 Rise Fall Rise Fall ID [50,51] [30,31] X [30,31] [30,31] sty [20,21] [20,21] AC [20,21] [20,21] we obtain the minimum and maximum separations in cycle period seen at point A of 80 and 107. <p> conditions is less than a second on a SPARC 2. d skew t skew r (18) (19) (20) (21) OK 6 [0; 0] [0; 0] 3 3 0 0 6 [0; 0] [0; 3] 3 3 0 0 6 [0; 3] [0; 0] 0 0 3 3 6 [0; 0] <ref> [6; 6] </ref> 0 0 3 3 8 [0; 0] [0; 0] 5 5 4 4 8 [0; 3] [0; 5] 2 2 0 0 8 [0; 5] [0; 3] 0 0 1 1 8 [0; 0] [12; 12] 0 0 5 5 8 [12; 12] [0; 0] 5 5 8 8
Reference: [7] <author> E. M. Clarke, E. A. Emerson, and A. P. Sosta. </author> <title> Automatic verification of finite state concurrent systems using temporal logic specification. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: One aspect which much of the research has in common is its focus on analyzing very general systems. This is true for approaches based on decision procedures (e.g., [16, 17]), model checking (e.g., <ref> [7, 18] </ref>), exhaustive simulation (e.g., [20]), language containment (e.g., [2, 26]), deductive proofs techniques (e.g., [27]) and theorem proving (e.g., [12]). For this reason, the timing analysis is usually at least of exponential time complexity and is often undecidable [15].
Reference: [8] <author> G. Cohen, P. Moller, J. P. Quadrat, and M. Viot. </author> <title> Evaluation of discrete event systems. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 77(1) </volume> <pages> 39-58, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Loose bounds that may not enable all possible optimizations were obtained by [25]. Both [24] and [30] handle only acyclic graphs. However, they provide a theoretical foundation upon which our solution is built. Both <ref> [8] </ref> and [6] use cyclic graph models but they deal only with fixed delays between events. Several verifiers have been developed for specific applications [3, 5, 21]. This paper is composed of six sections.
Reference: [9] <author> R. A. Cunighame-Green. </author> <title> Minimax Algebra. </title> <booktitle> Number 166 in Lecture Notes in Economics and Methe-matical Systems. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: Except for distributivity, these properties are trivially satisfied. Distributivity relies on the monotonicly non-decreasing nature of the functions in F . Notice that function composition () is not commutative. 1 Similar to a (max; +)-algebra <ref> [9, 4] </ref>. The main differences are that the elements of F are functions instead of numbers, the max-operator maximizes functions, and the +-operator composes functions. 9 4.2 Functional Formulation of Acyclic Algorithm We can now express phase 2 of the acyclic algorithm in terms of functions. <p> of Figure 23 are in the range [0; 1] (small in comparison to the delays associated with computation and data transfer) and we make the following assignments of delay ranges to the delay elements modeling the computations: 23 mdli" rao" bo" mslo" bi# msli# rai# mslo# msli" mdlo" mdli# mdlo# <ref> [2; 9] </ref> [2; 9] [2; 13] [2; 13] [5; 30] [30; 1] root [0; 0] have [0; 1] as the delay range. <p> 23 are in the range [0; 1] (small in comparison to the delays associated with computation and data transfer) and we make the following assignments of delay ranges to the delay elements modeling the computations: 23 mdli" rao" bo" mslo" bi# msli# rai# mslo# msli" mdlo" mdli# mdlo# <ref> [2; 9] </ref> [2; 9] [2; 13] [2; 13] [5; 30] [30; 1] root [0; 0] have [0; 1] as the delay range.
Reference: [10] <author> S. Gaubert. </author> <title> Theorie des Systemes Lineaires dans les Diodes. </title> <type> Ph.D. thesis, </type> <institution> L'ecole Nationale Superieure des Mines De Paris, </institution> <year> 1993. </year> <note> In French. </note>
Reference-contexts: To illustrate the kinds of systems that can be analyzed, consider the 1 following concurrent system consisting of three processes that synchronize over two channels a and b, and perform some internal computation (delay ranges specified in brackets): Process 1 :: repeat f Synchronize a; Compute <ref> [4, 10] </ref>; g Process 2 :: repeat f Synchronize a; Compute [1, 2]; Synchronize b; Compute [1, 6]; g Process 3 :: repeat f Synchronize b; Compute [5, 20]; g There are many questions regarding the temporal behavior of this system that we might ask: "How slowly might the first process <p> 2 E and u 7! v 2 R 0 ; then v k+" 2 E : The set of edges in the unfolded process graph R is defined as: R = u k 7! v k+" fi [d;D];" 3 root a 0 a 1 a 2 a 3 [0, 0] <ref> [4, 10] </ref> [4, 10] [4, 10] [4, 10] [1,6][1,6][1,6] [1,6] a 4 Events can be characterized as repeatable or non-repeatable corresponding to whether there is a cycle in the process graph containing the event. The event root is non-repeatable as it has indegree of zero. <p> and u 7! v 2 R 0 ; then v k+" 2 E : The set of edges in the unfolded process graph R is defined as: R = u k 7! v k+" fi [d;D];" 3 root a 0 a 1 a 2 a 3 [0, 0] <ref> [4, 10] </ref> [4, 10] [4, 10] [4, 10] [1,6][1,6][1,6] [1,6] a 4 Events can be characterized as repeatable or non-repeatable corresponding to whether there is a cycle in the process graph containing the event. The event root is non-repeatable as it has indegree of zero. <p> 7! v 2 R 0 ; then v k+" 2 E : The set of edges in the unfolded process graph R is defined as: R = u k 7! v k+" fi [d;D];" 3 root a 0 a 1 a 2 a 3 [0, 0] <ref> [4, 10] </ref> [4, 10] [4, 10] [4, 10] [1,6][1,6][1,6] [1,6] a 4 Events can be characterized as repeatable or non-repeatable corresponding to whether there is a cycle in the process graph containing the event. The event root is non-repeatable as it has indegree of zero. <p> 2 R 0 ; then v k+" 2 E : The set of edges in the unfolded process graph R is defined as: R = u k 7! v k+" fi [d;D];" 3 root a 0 a 1 a 2 a 3 [0, 0] <ref> [4, 10] </ref> [4, 10] [4, 10] [4, 10] [1,6][1,6][1,6] [1,6] a 4 Events can be characterized as repeatable or non-repeatable corresponding to whether there is a cycle in the process graph containing the event. The event root is non-repeatable as it has indegree of zero. <p> Figure 3 shows a possible timing assignment for the graph in Figure 2 obtained by choosing the upper bound, D, for all delays. 0 10 28 48 68 root a 0 a 1 a 2 a 3 [0, 0] <ref> [4, 10] </ref> [4, 10] [4, 10] [4, 10] [1,6][1,6][1,6] [1,6] a 4 0 vertices are annotated with the timing assignment t (v k ) obtained by choosing the upper bound, D, for all delays. 2.4 Problem Definition The problem we address in this paper is: given two events, s and t <p> Figure 3 shows a possible timing assignment for the graph in Figure 2 obtained by choosing the upper bound, D, for all delays. 0 10 28 48 68 root a 0 a 1 a 2 a 3 [0, 0] <ref> [4, 10] </ref> [4, 10] [4, 10] [4, 10] [1,6][1,6][1,6] [1,6] a 4 0 vertices are annotated with the timing assignment t (v k ) obtained by choosing the upper bound, D, for all delays. 2.4 Problem Definition The problem we address in this paper is: given two events, s and t in E <p> Figure 3 shows a possible timing assignment for the graph in Figure 2 obtained by choosing the upper bound, D, for all delays. 0 10 28 48 68 root a 0 a 1 a 2 a 3 [0, 0] <ref> [4, 10] </ref> [4, 10] [4, 10] [4, 10] [1,6][1,6][1,6] [1,6] a 4 0 vertices are annotated with the timing assignment t (v k ) obtained by choosing the upper bound, D, for all delays. 2.4 Problem Definition The problem we address in this paper is: given two events, s and t in E 0 , <p> Figure 3 shows a possible timing assignment for the graph in Figure 2 obtained by choosing the upper bound, D, for all delays. 0 10 28 48 68 root a 0 a 1 a 2 a 3 [0, 0] <ref> [4, 10] </ref> [4, 10] [4, 10] [4, 10] [1,6][1,6][1,6] [1,6] a 4 0 vertices are annotated with the timing assignment t (v k ) obtained by choosing the upper bound, D, for all delays. 2.4 Problem Definition The problem we address in this paper is: given two events, s and t in E 0 , and a <p> The process graph in Figure 14 requires 149 unfoldings before the bounds converge and the number of unfoldings can be made arbitrarily large by changing the delay values of the process graph. 13 b d c <ref> [10; 10] </ref> [10; 10][5; 5] [1; 2] [1; 2] [1; 3] root [0; 0][0; 0] [10; 10] [10; 99] [10; 50] [10; 10] [10; 10] g d e f for the separation analysis t (b k ) t (d k2 ). <p> The process graph in Figure 14 requires 149 unfoldings before the bounds converge and the number of unfoldings can be made arbitrarily large by changing the delay values of the process graph. 13 b d c <ref> [10; 10] </ref> [10; 10][5; 5] [1; 2] [1; 2] [1; 3] root [0; 0][0; 0] [10; 10] [10; 99] [10; 50] [10; 10] [10; 10] g d e f for the separation analysis t (b k ) t (d k2 ). <p> process graph in Figure 14 requires 149 unfoldings before the bounds converge and the number of unfoldings can be made arbitrarily large by changing the delay values of the process graph. 13 b d c <ref> [10; 10] </ref> [10; 10][5; 5] [1; 2] [1; 2] [1; 3] root [0; 0][0; 0] [10; 10] [10; 99] [10; 50] [10; 10] [10; 10] g d e f for the separation analysis t (b k ) t (d k2 ). The startup rules, root [0;0];0 7! a, root [210;210];0 root [310;310];0 7! g, have been left out for clarity. <p> in Figure 14 requires 149 unfoldings before the bounds converge and the number of unfoldings can be made arbitrarily large by changing the delay values of the process graph. 13 b d c [10; 10] [10; 10][5; 5] [1; 2] [1; 2] [1; 3] root [0; 0][0; 0] [10; 10] <ref> [10; 99] </ref> [10; 50] [10; 10] [10; 10] g d e f for the separation analysis t (b k ) t (d k2 ). The startup rules, root [0;0];0 7! a, root [210;210];0 root [310;310];0 7! g, have been left out for clarity. <p> 14 requires 149 unfoldings before the bounds converge and the number of unfoldings can be made arbitrarily large by changing the delay values of the process graph. 13 b d c [10; 10] [10; 10][5; 5] [1; 2] [1; 2] [1; 3] root [0; 0][0; 0] [10; 10] [10; 99] <ref> [10; 50] </ref> [10; 10] [10; 10] g d e f for the separation analysis t (b k ) t (d k2 ). The startup rules, root [0;0];0 7! a, root [210;210];0 root [310;310];0 7! g, have been left out for clarity. We now consider the structure of the m-values. <p> 149 unfoldings before the bounds converge and the number of unfoldings can be made arbitrarily large by changing the delay values of the process graph. 13 b d c <ref> [10; 10] </ref> [10; 10][5; 5] [1; 2] [1; 2] [1; 3] root [0; 0][0; 0] [10; 10] [10; 99] [10; 50] [10; 10] [10; 10] g d e f for the separation analysis t (b k ) t (d k2 ). The startup rules, root [0;0];0 7! a, root [210;210];0 root [310;310];0 7! g, have been left out for clarity. We now consider the structure of the m-values. <p> before the bounds converge and the number of unfoldings can be made arbitrarily large by changing the delay values of the process graph. 13 b d c <ref> [10; 10] </ref> [10; 10][5; 5] [1; 2] [1; 2] [1; 3] root [0; 0][0; 0] [10; 10] [10; 99] [10; 50] [10; 10] [10; 10] g d e f for the separation analysis t (b k ) t (d k2 ). The startup rules, root [0;0];0 7! a, root [210;210];0 root [310;310];0 7! g, have been left out for clarity. We now consider the structure of the m-values. <p> For example, changing the delays <ref> [4; 10] </ref> and [5; 20] to [999,1000] and [1000,1000], respectively, changes 2 k ? from 3 to 998.
Reference: [11] <author> S. Gaubert and C. Klimann. </author> <title> Rational computation in dioid algebra and its application to performance evaluation of discrete event systems. </title> <booktitle> In Algebraic computing in control, Lecture Notes in Computer Science # 165. </booktitle> <publisher> Springer Velag, </publisher> <year> 1991. </year>
Reference: [12] <author> Mike Gordon. </author> <title> HOL: A proof generating system for higher-order logic. </title> <editor> In G. Milne and P. A. Subrah-manyam, editors, </editor> <title> VLSI Specification, Verification and Synthesis. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1988. </year> <month> 30 </month>
Reference-contexts: This is true for approaches based on decision procedures (e.g., [16, 17]), model checking (e.g., [7, 18]), exhaustive simulation (e.g., [20]), language containment (e.g., [2, 26]), deductive proofs techniques (e.g., [27]) and theorem proving (e.g., <ref> [12] </ref>). For this reason, the timing analysis is usually at least of exponential time complexity and is often undecidable [15]. Because these approaches do not yield practical and efficient algorithms they are not particularly useful for synthesis purposes. <p> 0 0 6 [0; 3] [0; 0] 0 0 3 3 6 [0; 0] [6; 6] 0 0 3 3 8 [0; 0] [0; 0] 5 5 4 4 8 [0; 3] [0; 5] 2 2 0 0 8 [0; 5] [0; 3] 0 0 1 1 8 [0; 0] <ref> [12; 12] </ref> 0 0 5 5 8 [12; 12] [0; 0] 5 5 8 8 Table 1: Timing analysis of STARI. d is the lower bound on the clock period (the upper bound is irrelevant for the correctness of STARI), skew t and skew r are the variations in skew to <p> 0 0 3 3 6 [0; 0] [6; 6] 0 0 3 3 8 [0; 0] [0; 0] 5 5 4 4 8 [0; 3] [0; 5] 2 2 0 0 8 [0; 5] [0; 3] 0 0 1 1 8 [0; 0] <ref> [12; 12] </ref> 0 0 5 5 8 [12; 12] [0; 0] 5 5 8 8 Table 1: Timing analysis of STARI. d is the lower bound on the clock period (the upper bound is irrelevant for the correctness of STARI), skew t and skew r are the variations in skew to the transmitter and receiver, respectively.
Reference: [13] <author> M. R. Greenstreet. STARI: </author> <title> A Technique for High-Bandwidth Communication. </title> <type> Ph.D. thesis, </type> <institution> Princeton University, </institution> <month> January </month> <year> 1993. </year>
Reference-contexts: in the range [0; 1] (small in comparison to the delays associated with computation and data transfer) and we make the following assignments of delay ranges to the delay elements modeling the computations: 23 mdli" rao" bo" mslo" bi# msli# rai# mslo# msli" mdlo" mdli# mdlo# [2; 9] [2; 9] <ref> [2; 13] </ref> [2; 13] [5; 30] [30; 1] root [0; 0] have [0; 1] as the delay range. <p> range [0; 1] (small in comparison to the delays associated with computation and data transfer) and we make the following assignments of delay ranges to the delay elements modeling the computations: 23 mdli" rao" bo" mslo" bi# msli# rai# mslo# msli" mdlo" mdli# mdlo# [2; 9] [2; 9] <ref> [2; 13] </ref> [2; 13] [5; 30] [30; 1] root [0; 0] have [0; 1] as the delay range. <p> This information is useful when interfacing the microprocessor to an external synchronous component, especially in cases where the synchronous component is clocked using a signal produced by the microprocessor. 5.3 STARI STARI is a novel approach to high-bandwidth communication proposed by Greenstreet <ref> [13] </ref>. STARI combines synchronous and self-timed design techniques. The sender and receiver operate synchronously at the same clock rate, but the communication interface consists of an asynchronous FIFO queue. The overall structure is shown in Figure 24 (from [13, Figure 5]). <p> STARI combines synchronous and self-timed design techniques. The sender and receiver operate synchronously at the same clock rate, but the communication interface consists of an asynchronous FIFO queue. The overall structure is shown in Figure 24 (from <ref> [13, Figure 5] </ref>). Transmitter Receiver sync. completion encoding Global Clock FIFO sync. circuitrycircuitry The idea in STARI is to time the system such that the FIFO operates at the speed of the clock, accepting a new data item every clock cycle. <p> If the variations becomes too large, the FIFO overflows or underflows and STARI fails. The amount of variation of the delays that can be tolerated depends on the length of the FIFO, the clock period, and the delay of the FIFO elements. Greenstreet <ref> [13] </ref> has derived sufficient timing conditions under which STARI operates correctly. The correctness proof for these conditions is quite complicated (approx. 20 pages). Here we show how the maximum separation analysis can be used for timing verification of a STARI implementation.
Reference: [14] <author> I. N. Herstein. </author> <title> Topics in algebra. </title> <publisher> Blaisdell Publishing Company, </publisher> <year> 1964. </year>
Reference-contexts: It follows from (4) that function maximization is defined as set union: f g = f [g. Function composition, f = g h, is defined as f (x) = h (g (x)). Notice that we use left-to-right function composition <ref> [14] </ref>.
Reference: [15] <author> F. Jahanian. </author> <title> Verifying properties of systems with variable timing constraints. </title> <booktitle> In Proceedings of the IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 319-328, </pages> <year> 1989. </year>
Reference-contexts: For this reason, the timing analysis is usually at least of exponential time complexity and is often undecidable <ref> [15] </ref>. Because these approaches do not yield practical and efficient algorithms they are not particularly useful for synthesis purposes. In contrast, some synthesis and timing verification tools greatly restrict the classes of behavior which can be analyzed in favor of efficient verification algorithms.
Reference: [16] <author> F. Jahanian and A. K. Mok. </author> <title> Safety analysis of timing properties in real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 12(9) </volume> <pages> 890-904, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: Related work in timing verification comes from a variety of different research communities, and is quite extensive. One aspect which much of the research has in common is its focus on analyzing very general systems. This is true for approaches based on decision procedures (e.g., <ref> [16, 17] </ref>), model checking (e.g., [7, 18]), exhaustive simulation (e.g., [20]), language containment (e.g., [2, 26]), deductive proofs techniques (e.g., [27]) and theorem proving (e.g., [12]). For this reason, the timing analysis is usually at least of exponential time complexity and is often undecidable [15].
Reference: [17] <author> F. Jahanian and A. K. Mok. </author> <title> A graph-theoretic approach for timing analysis and its implementation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 36 </volume> <pages> 961-975, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: Related work in timing verification comes from a variety of different research communities, and is quite extensive. One aspect which much of the research has in common is its focus on analyzing very general systems. This is true for approaches based on decision procedures (e.g., <ref> [16, 17] </ref>), model checking (e.g., [7, 18]), exhaustive simulation (e.g., [20]), language containment (e.g., [2, 26]), deductive proofs techniques (e.g., [27]) and theorem proving (e.g., [12]). For this reason, the timing analysis is usually at least of exponential time complexity and is often undecidable [15].
Reference: [18] <author> F. Jahanian and D. A. Stuart. </author> <title> A method for verifying properties of modechart specifications. </title> <booktitle> In Proceedings of the 9th IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 12-21, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: One aspect which much of the research has in common is its focus on analyzing very general systems. This is true for approaches based on decision procedures (e.g., [16, 17]), model checking (e.g., <ref> [7, 18] </ref>), exhaustive simulation (e.g., [20]), language containment (e.g., [2, 26]), deductive proofs techniques (e.g., [27]) and theorem proving (e.g., [12]). For this reason, the timing analysis is usually at least of exponential time complexity and is often undecidable [15].
Reference: [19] <author> E. L. Lawler. </author> <title> Combinatorial Optimization: Networks and Matroids. </title> <publisher> Holt, Rinehart and Winston, </publisher> <address> New York, </address> <year> 1976. </year>
Reference-contexts: Since the m-values are constructed from a repetitive system (the process graph) the values eventually are determined by the maximum ratio cycles in the process graph <ref> [19] </ref>.
Reference: [20] <author> A. R. Martello and S. P. Levitan. </author> <title> Temporal analysis of time bounded digital systems. </title> <booktitle> In Correct hardware design and verification methods : IFIP WG10.2 Advanced Research Working Conference, </booktitle> <volume> CHARME '93, </volume> <month> May </month> <year> 1993. </year>
Reference-contexts: One aspect which much of the research has in common is its focus on analyzing very general systems. This is true for approaches based on decision procedures (e.g., [16, 17]), model checking (e.g., [7, 18]), exhaustive simulation (e.g., <ref> [20] </ref>), language containment (e.g., [2, 26]), deductive proofs techniques (e.g., [27]) and theorem proving (e.g., [12]). For this reason, the timing analysis is usually at least of exponential time complexity and is often undecidable [15]. <p> two channels a and b, and perform some internal computation (delay ranges specified in brackets): Process 1 :: repeat f Synchronize a; Compute [4, 10]; g Process 2 :: repeat f Synchronize a; Compute [1, 2]; Synchronize b; Compute [1, 6]; g Process 3 :: repeat f Synchronize b; Compute <ref> [5, 20] </ref>; g There are many questions regarding the temporal behavior of this system that we might ask: "How slowly might the first process cycle?", or "How long might the second process be idle waiting on the third process?", or "How can we best speed-up the performance of our system?" and <p> For example, changing the delays [4; 10] and <ref> [5; 20] </ref> to [999,1000] and [1000,1000], respectively, changes 2 k ? from 3 to 998.
Reference: [21] <author> A. R. Martello, S. P. Levitan, and D. M. Chiarulli. </author> <title> Timing verification using HDTV. </title> <booktitle> In 27th ACM/IEEE Design Automation Conference, </booktitle> <pages> pages 118-123, </pages> <year> 1990. </year>
Reference-contexts: Both [24] and [30] handle only acyclic graphs. However, they provide a theoretical foundation upon which our solution is built. Both [8] and [6] use cyclic graph models but they deal only with fixed delays between events. Several verifiers have been developed for specific applications <ref> [3, 5, 21] </ref>. This paper is composed of six sections. We follow this introduction with a formalization of the timing analysis and in Section 3 we present an algorithm that solves the maximum separation problem for acyclic graphs.
Reference: [22] <author> A. J. Martin. </author> <title> Programming in VLSI: From communicating processes to delay-insensitive circuits. In C.A.R. Hoare, editor, </title> <booktitle> UT Year of Programming Institute on Concurrent Programming. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: Correct operation of STARI is indicated with a checkmark in the OK column. 5.4 Isochronic Forks An exact solution to the maximum separation problem can be used to determine whether or not an asynchronous circuit designed under the assumptions of the quasi-delay-insensitive model <ref> [22] </ref> will work correctly even if the isochronic fork assumption is relaxed. The isochronic fork assumption states that certain signals in the circuit that fan out to separate circuit elements arrive at their respective elements at the same time.
Reference: [23] <author> A. J. Martin, S. M. Burns, T. K. Lee, D. Borkovic, and P. J. Hazewindus. </author> <title> The design of an asynchronous microprocessor. </title> <editor> In C.L. Seitz, editor, </editor> <booktitle> Advanced Research in VLSI: Proceedings of the Decennial Caltech Conference on VLSI, </booktitle> <pages> pages 351-373, </pages> <address> Cambridge, MA, 1989. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Clearly, being able to obtain tight bounds potentially enables the removal of more edges. One of the examples in [25] is a memory management unit (MMU) designed to interface to the Caltech Asynchronous Microprocessor <ref> [23] </ref>. The process graph (for one of the possible execution modes of the MMU) is shown in Figure 22. For the chosen delay intervals, k ? = 1 and " ? = 1. Analyzing the 23 edges using our exact algorithm takes 0:6 seconds on a SPARC 2. <p> The analysis results in the removal of six edges from the process graph or equivalently, the removal of six transistors from the circuit. This is the same result as in [25]. 5.2 Asynchronous Microprocessor A subset of the Caltech Asynchronous Microprocessor <ref> [23] </ref> has been modeled and analyzed using the techniques described in this paper. A block diagram of the processor is shown in Figure 23. The process graph for this simplified model consists of 60 events and 127 edges.
Reference: [24] <author> K. McMillan and D. L. Dill. </author> <title> Algorithms for interface timing verification. </title> <booktitle> In 1992 IEEE International Conference on Computer Design: VLSI in Computers and Processors, </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: Loose bounds that may not enable all possible optimizations were obtained by [25]. Both <ref> [24] </ref> and [30] handle only acyclic graphs. However, they provide a theoretical foundation upon which our solution is built. Both [8] and [6] use cyclic graph models but they deal only with fixed delays between events. Several verifiers have been developed for specific applications [3, 5, 21]. <p> The process graph is a simple modification of the event-rule system developed in [6]. The model can also be viewed as an extension of <ref> [24] </ref> and [30], where we consider cyclic max-only or type-2 graphs, respectively. Process graphs are similar to timed event graphs [4], marked graphs or decision free Petri nets. <p> Section 5 for some applications of this kind of timing analysis before examining the details of the Time Separation of Events (tse) algorithm. 3 Algorithm for an Acyclic Graph Our algorithm for analyzing a process graph is based on an algorithm that determines the maximum separation in an acyclic graph <ref> [24] </ref>, i.e., for a finite portion of the unfolded process graph. In Section 4 we will generalize this algorithm for infinite unfolded graphs. Consider a particular event occurrence of the event t, t ff . <p> The repetition period is 1, i.e., " ? = 1. Calling Unfold causes the construction of G (i) for i = 1; 2; 3, as illustrated in Figure 11. The bounds computed for these three graphs are: i [ ? ; &gt; ] 2 <ref> [24; 25] </ref> Thus after three unfoldings the bounds converge and the maximum separation of = 25 is reported. For this separation analysis it is not necessary to construct R and S and perform the closure, i.e., the tse algorithm will stop at line 4.
Reference: [25] <author> C. J. Myers and T. H.-Y. Meng. </author> <title> Synthesis of timed asynchronous circuits. </title> <journal> IEEE Transactions on Very Large Scale Integration (VLSI) Systems, </journal> <volume> 1(2) </volume> <pages> 106-119, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Loose bounds that may not enable all possible optimizations were obtained by <ref> [25] </ref>. Both [24] and [30] handle only acyclic graphs. However, they provide a theoretical foundation upon which our solution is built. Both [8] and [6] use cyclic graph models but they deal only with fixed delays between events. Several verifiers have been developed for specific applications [3, 5, 21]. <p> For each unfolding, the graph is extended with O (jE 0 j) new nodes and their functions. Given a cutset X for the graph, the bounds on are determined. This approach for finding the maximum separation between two events is efficient on some examples <ref> [25] </ref>, but has two major drawbacks. First, we know of no necessary condition for determining when to stop unfolding the graph and report the result, i.e., the bounds derived above may not converge. A simple example is shown in 0 for all k 0. <p> The repetition period is 1, i.e., " ? = 1. Calling Unfold causes the construction of G (i) for i = 1; 2; 3, as illustrated in Figure 11. The bounds computed for these three graphs are: i [ ? ; &gt; ] 2 <ref> [24; 25] </ref> Thus after three unfoldings the bounds converge and the maximum separation of = 25 is reported. For this separation analysis it is not necessary to construct R and S and perform the closure, i.e., the tse algorithm will stop at line 4. <p> This idea can be used to remove redundant circuitry in asynchronous circuits given (conservative) bounds on the actual delays of a speed-independent design. Superfluous edges can be removed by analyzing the process graph corresponding to the circuit. This approach has been taken by Myers and Meng <ref> [25] </ref> who use an inexact timing analysis algorithm, i.e., the algorithm doesn't necessarily give tight bounds on separation times. Clearly, being able to obtain tight bounds potentially enables the removal of more edges. One of the examples in [25] is a memory management unit (MMU) designed to interface to the Caltech <p> This approach has been taken by Myers and Meng <ref> [25] </ref> who use an inexact timing analysis algorithm, i.e., the algorithm doesn't necessarily give tight bounds on separation times. Clearly, being able to obtain tight bounds potentially enables the removal of more edges. One of the examples in [25] is a memory management unit (MMU) designed to interface to the Caltech Asynchronous Microprocessor [23]. The process graph (for one of the possible execution modes of the MMU) is shown in Figure 22. For the chosen delay intervals, k ? = 1 and " ? = 1. <p> Analyzing the 23 edges using our exact algorithm takes 0:6 seconds on a SPARC 2. The analysis results in the removal of six edges from the process graph or equivalently, the removal of six transistors from the circuit. This is the same result as in <ref> [25] </ref>. 5.2 Asynchronous Microprocessor A subset of the Caltech Asynchronous Microprocessor [23] has been modeled and analyzed using the techniques described in this paper. A block diagram of the processor is shown in Figure 23. The process graph for this simplified model consists of 60 events and 127 edges.
Reference: [26] <author> X. Nicolin, J. Sifakis, and S. Yovine. </author> <title> Compiling real-time specifications into extended automata. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(9) </volume> <pages> 794-804, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: One aspect which much of the research has in common is its focus on analyzing very general systems. This is true for approaches based on decision procedures (e.g., [16, 17]), model checking (e.g., [7, 18]), exhaustive simulation (e.g., [20]), language containment (e.g., <ref> [2, 26] </ref>), deductive proofs techniques (e.g., [27]) and theorem proving (e.g., [12]). For this reason, the timing analysis is usually at least of exponential time complexity and is often undecidable [15]. Because these approaches do not yield practical and efficient algorithms they are not particularly useful for synthesis purposes.
Reference: [27] <author> J. S. Ostroff. </author> <title> Deciding properties of timed transition models. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(2), </volume> <month> April </month> <year> 1990. </year>
Reference-contexts: One aspect which much of the research has in common is its focus on analyzing very general systems. This is true for approaches based on decision procedures (e.g., [16, 17]), model checking (e.g., [7, 18]), exhaustive simulation (e.g., [20]), language containment (e.g., [2, 26]), deductive proofs techniques (e.g., <ref> [27] </ref>) and theorem proving (e.g., [12]). For this reason, the timing analysis is usually at least of exponential time complexity and is often undecidable [15]. Because these approaches do not yield practical and efficient algorithms they are not particularly useful for synthesis purposes.
Reference: [28] <author> E. S. Selmer. </author> <title> On the linear diophantine problem of Frobenius. </title> <journal> J.-Reine-Angew.-Math., </journal> 293/294:1-17, 1977. 
Reference: [29] <author> K. Thulasiraman and M. N. S. Swamy. </author> <title> Graphs: Theory and Algorithms. </title> <publisher> John Wiley and Sons, </publisher> <year> 1992. </year>
Reference: [30] <author> P. Vanbekbergen, G. Goossens, and H. De Man. </author> <title> Specification and analysis of timing constraints in signal transition graphs. </title> <booktitle> In European Design Automation Conference, </booktitle> <month> March </month> <year> 1992. </year> <month> 31 </month>
Reference-contexts: Loose bounds that may not enable all possible optimizations were obtained by [25]. Both [24] and <ref> [30] </ref> handle only acyclic graphs. However, they provide a theoretical foundation upon which our solution is built. Both [8] and [6] use cyclic graph models but they deal only with fixed delays between events. Several verifiers have been developed for specific applications [3, 5, 21]. <p> The process graph is a simple modification of the event-rule system developed in [6]. The model can also be viewed as an extension of [24] and <ref> [30] </ref>, where we consider cyclic max-only or type-2 graphs, respectively. Process graphs are similar to timed event graphs [4], marked graphs or decision free Petri nets. <p> 1] (small in comparison to the delays associated with computation and data transfer) and we make the following assignments of delay ranges to the delay elements modeling the computations: 23 mdli" rao" bo" mslo" bi# msli# rai# mslo# msli" mdlo" mdli# mdlo# [2; 9] [2; 9] [2; 13] [2; 13] <ref> [5; 30] </ref> [30; 1] root [0; 0] have [0; 1] as the delay range. <p> in comparison to the delays associated with computation and data transfer) and we make the following assignments of delay ranges to the delay elements modeling the computations: 23 mdli" rao" bo" mslo" bi# msli# rai# mslo# msli" mdlo" mdli# mdlo# [2; 9] [2; 9] [2; 13] [2; 13] [5; 30] <ref> [30; 1] </ref> root [0; 0] have [0; 1] as the delay range.
References-found: 30

