URL: http://www.isi.edu/~ryu/papers/USC-CS-98-684.ps
Refering-URL: http://www.isi.edu/~ryu/publications.html
Root-URL: http://www.isi.edu
Email: fryu, bcng@ISI.EDU  
Title: Distributed Garbage Collection by Timeouts and Backward Inquiry  
Author: Sung-Wook Ryu, B. Clifford Neuman 
Keyword: Distributed Garbage Collection, Distributed objects, Cyclic Garbage, Timeouts, Back-Tracing  
Affiliation: Information Sciences Institute University of Southern California  
Abstract: We present a practical and efficient garbage collection mechanism for large scale distributed systems. The mechanism collects all garbage including distributed cyclic garbage without global synchronization or backward links. The primary method used for local and remote garbage collection is timeouts: each object has a time-to-live, and clients which have a link to an object must refresh the target object within the time-to-live to guarantee that the link will remain valid. For cyclic garbage collection: objects suspected to be garbage are detected by last referenceable timestamp propagation; and cyclic garbage is reclaimed by backward inquiry (back-tracing). Since, without additional overhead, the information about backward references can be obtained during the refreshing process, and since messages necessary for cyclic garbage collection are bundled with the messages used for the refreshing, communication, computation and storage overhead is minimized. This mechanism has been implemented and evaluated on Prospero directory service, and the performance results show that it works well for large scale distributed systems. 
Abstract-found: 1
Intro-found: 1
Reference: [Bevan, 1987] <author> D. I. Bevan, </author> <title> Distributed garbage collection using reference counting, </title> <booktitle> in Lecture Notes in Computer Science, </booktitle> <volume> vol. 259: </volume> <booktitle> PARLE. </booktitle> <address> Spring-Verlag, New York, </address> <year> 1987, </year> <month> pages176-187. </month>
Reference-contexts: CORBA [Vogel and Duddy, 1997] and DCOM [Chappell, 1996] use reference counting and they have the above problems. <ref> [Bevan, 1987] </ref> suggested a weighted reference counting algorithm to avoid the problems caused by extra messages and race conditions. Each object maintains a reference count, and each reference to the object has a weight.
Reference: [Baker et al., 1991] <author> Mary G. Baker, John H. Hartman, Michael D. Kupfer, Ken W. Shirriff, and John K. Ouster-hout, </author> <title> Measurements of a distributed file systems, </title> <booktitle> SOSP 1991, </booktitle> <pages> pages 198-212 </pages>
Reference: [Birrell et al., 1993] <author> Andrew Birrel, David Evers, Greg Nelson, Susan Owicki and Edward Wobber, </author> <title> Distributed garbage collection for network objects, </title> <type> Technical Report 116, </type> <institution> Digital Equipment Cooperation Systems Research Center, </institution> <month> December 15, </month> <year> 1993. </year>
Reference-contexts: When there is only a root node in the tree, the object is garbage. The shortcomings of the algorithm are the overhead of management of the inverted tree and two drawbacks of reference counting which were mentioned before. Reference listing <ref> [Shapiro et al., 1990; Birrell et al., 1993] </ref> was introduced to solve the problem of reference counting. <p> This algorithm works well in cases where there are only a few incoming links. The storage and management overhead for the reference list, however, is heavy, when a large number of incoming links exist. [Shapiro et al., 1990] uses migration to collect cyclic garbage, but <ref> [Birrell et al., 1993] </ref> does not collect cyclic garbage. In tracing algorithms [Juul and Jul, 1992; Lang et al., 1992], each system starts marking all of the accessible lo 12 cal objects from its root objects.
Reference: [Bishop, 1977] <author> P. B. Bishop, </author> <title> Computer Systems with a Very Large Address Space, and Garbage Collection. </title> <type> Technical Report MIT/LCS/TR-178, </type> <institution> MIT Laboratory for Computer Science, </institution> <address> Cambridge MA, </address> <month> May </month> <year> 1977. </year>
Reference-contexts: The information about backward references are calculated using these tables and local tracing. The overhead of calculating backward references is heavy, and it is very hard to preserve safety and completeness in the presence of concurrent mutators and garbage collectors. Migration <ref> [Bishop, 1977; Shapiro et al, 1990; Gupta, 1993] </ref> was also suggested to collect cyclic garbage. In this algorithm, all objects on a garbage cycle are migrated to a single system, and are collected during local garbage collection.
Reference: [Chappell, 1996] <author> David Chappell, </author> <title> Understanding ActiveX and OLE, </title> <publisher> Microsoft Press, </publisher> <year> 1996 </year>
Reference-contexts: We have implemented a garbage collection mechanism which uses timeouts, last referenceable timestamp propagation [Neuman, 1992] and backward inquiry. The primary method used for local and remote garbage collection is timeouts, which is similar to leases in Java RMI [RMI, 1997] and pinging in DCOM <ref> [Chappell, 1996] </ref>. Each object has a Time-To-Live (TTL) and an expiration, and each link maintains an expiration time of its target object. <p> A distributed object is a unit of information (e.g., an object of CORBA [Vogel and Duddy, 1997], DCOM <ref> [Chappell, 1996] </ref>, Distributed OODB, web or Prospero) and may contain data and methods. Data includes attributes and links. A link consists of the target object's name and attributes of the link. Every object has a unique identifier, so a link always points to at most one object. <p> Since objects can be removed in a loosely synchronized distributed system without deleting their links (e.g., during a server crash), the link count of an object can be greater than zero, even though no other objects are referencing the object. CORBA [Vogel and Duddy, 1997] and DCOM <ref> [Chappell, 1996] </ref> use reference counting and they have the above problems. [Bevan, 1987] suggested a weighted reference counting algorithm to avoid the problems caused by extra messages and race conditions. Each object maintains a reference count, and each reference to the object has a weight. <p> Objects whose last referenceable timestamp is not more recent than a lower bound are garbage, and they are reclaimed. He uses a local lower bound instead of a global lower bound, that is, the algorithm sacrifices safety for performance. DCOM <ref> [Chappell, 1996] </ref> uses pinging to examine clients' status. Clients periodically send a pinging message to the referencing object.
Reference: [Fuchs, 1995] <author> Matthew Fuchs, </author> <title> Garbage collection on an open network, </title> <booktitle> IWMM: international workshop on memory management (1995 : Kinross, </booktitle> <address> UK). - Berlin; New York, </address> <publisher> NY : Springer, </publisher> <year> 1995. </year> <booktitle> (Lecture notes in computer science 986), </booktitle> <pages> pages 251-265 </pages>
Reference-contexts: However, it cannot collect distributed cyclic garbage completely. <ref> [Fuchs, 1995] </ref> suggested a back-tracing mechanism, but this mechanism assumed that all objects maintain backward references, which is not scalable. [Maheshwari & Liskov, 1997] suggested an enhanced back-tracing mechanism which dynamically calculated backward references. However, the overhead of calculating and maintaining backward references is too heavy. <p> DCOM [Chappell, 1996] uses pinging to examine clients' status. Clients periodically send a pinging message to the referencing object. If an object has not got any timestamps from a client for a sufficient time interval, the client is assumed to have died. <ref> [Fuchs, 1995] </ref> suggested a back-tracing mechanism, but this mechanism assumed that all objects maintain backward references. Since distributed objects usually do not maintain backward references, the mechanism is not practical. It is also unscalable to maintain backward references. [Maheshwari & Liskov, 1997] suggested an enhanced back-tracing mechanism.
Reference: [Gupta & Fuchs, 1993] <author> Aloke Gupta, W. Kent Fuchs, </author> <title> Garbage collection in a distributed object-oriented system, </title> <journal> IEEE Transaction on Knowledge and data engineering, </journal> <volume> vol. 5, no. 2, </volume> <month> April </month> <year> 1993, </year> <pages> pages. 257-265. </pages>
Reference: [Hughes, 1985] <author> John Hughes. </author> <title> A distributed garbage collection algorithm. </title> <editor> In Jean-Pierre Jouannaud, editor, </editor> <booktitle> ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Nancy, France, </address> <month> September </month> <year> 1985, </year> <booktitle> number 201 in Lecture Notes in Computer Science, </booktitle> <pages> pages 256-272, </pages> <publisher> Springer-Verlag, </publisher> <year> 1985 </year>
Reference-contexts: Periodically, each system propagates timestamps to reachable objects from its root, and objects whose timestamps are less then a global lower bound are regarded as garbage. These algorithms do not need global synchronization, but the overhead of finding a global lower bound is extremely heavy. <ref> [Hughes, 1985] </ref> uses a distributed termination detection algorithm to find the global lower bound, but the algorithm was very expensive and did not scale well. [Ladin and Liskov, 1992] uses a logically centralized service which kept all information about inter-systems references, but this algorithm did not scale well either. [Neuman, 1992]
Reference: [Juul & Jul, 1992] <author> Niels Christian Jull & Eric Jul. </author> <title> Comprehensive and robust garbage collection in a distributed system, (1992 : Saint Malo, France) / by Yves Bekkers, </title> <editor> Jacques Cohen. </editor> - <address> Berlin; New York, </address> <publisher> NY : Springer-Verlag, </publisher> <year> 1992. </year> <booktitle> (Lecture notes in computer science 637), </booktitle> <pages> pages 103-115, </pages> <year> 1992. </year>
Reference: [Maheshwari & Liskov, 1997] <author> Umesh Maheshwari and Barbara H. Liskov, </author> <title> Collecting distributed garbage cycles by back tracing, </title> <booktitle> the ACM symposium on Principles of Distributed Computing, </booktitle> <month> August, </month> <year> 1997 </year>
Reference-contexts: However, it cannot collect distributed cyclic garbage completely. [Fuchs, 1995] suggested a back-tracing mechanism, but this mechanism assumed that all objects maintain backward references, which is not scalable. <ref> [Maheshwari & Liskov, 1997] </ref> suggested an enhanced back-tracing mechanism which dynamically calculated backward references. However, the overhead of calculating and maintaining backward references is too heavy. For the solution, we designed and implemented a practical and efficient distributed garbage collection mechanism. <p> Since distributed objects usually do not maintain backward references, the mechanism is not practical. It is also unscalable to maintain backward references. <ref> [Maheshwari & Liskov, 1997] </ref> suggested an enhanced back-tracing mechanism. Each system maintains two tables, inrefs and and outrefs which contain the information about remote references. The information about backward references are calculated using these tables and local tracing.
Reference: [Neuman, 1992] <author> Barry Clifford Neuman, </author> <title> The virtual system model: A scalable approach to organizing large systems, </title> <type> Ph.D. dissertation, </type> <institution> University of Washington, </institution> <year> 1992. </year>
Reference-contexts: Both of them do not scale well because they require global synchronization. <ref> [Neuman, 1992] </ref> uses a local lower bound instead of a global lower bound, that is, the algorithm sacrifices safety for performance. [Lang et al., 1992] introduced tracing within a group instead of global systems to avoid global synchronization. <p> However, the overhead of calculating and maintaining backward references is too heavy. For the solution, we designed and implemented a practical and efficient distributed garbage collection mechanism. We have implemented a garbage collection mechanism which uses timeouts, last referenceable timestamp propagation <ref> [Neuman, 1992] </ref> and backward inquiry. The primary method used for local and remote garbage collection is timeouts, which is similar to leases in Java RMI [RMI, 1997] and pinging in DCOM [Chappell, 1996]. <p> The backward inquiry is performed during refreshing pro cess, so the communication overhead is minimized. 2 The System Architecture Our garbage collection mechanism has been implemented on the Prospero directory service <ref> [Neuman, 1992] </ref> which manages distributed information, but the definitions and assumptions do not restrict the generality of our mechanism. A distributed object is a unit of information (e.g., an object of CORBA [Vogel and Duddy, 1997], DCOM [Chappell, 1996], Distributed OODB, web or Prospero) and may contain data and methods. <p> Objects whose LRTSs are not more recent than a local threshold are local garbage. The basic idea of LRTS was suggested by <ref> [Neuman, 1992] </ref>, and the idea has been expanded here. In Figure 1, when the client A accesses the object w, then the object w gets a new LRTS and the LRTS is propagated to the subsequent objects, x, y and z, during a refreshing process. <p> heavy. [Hughes, 1985] uses a distributed termination detection algorithm to find the global lower bound, but the algorithm was very expensive and did not scale well. [Ladin and Liskov, 1992] uses a logically centralized service which kept all information about inter-systems references, but this algorithm did not scale well either. <ref> [Neuman, 1992] </ref> uses timeouts and last referenceable timestapms for garbage collection. Objects whose last referenceable timestamp is not more recent than a lower bound are garbage, and they are reclaimed. He uses a local lower bound instead of a global lower bound, that is, the algorithm sacrifices safety for performance.
Reference: [Ladin and Liskov, 1992] <author> Rivka Ladin and Barbara Liskov. </author> <title> Garbage collection of a distributed heap. </title> <booktitle> International Conference on Distributed Computing Systems, </booktitle> <pages> pages 708-715, </pages> <year> 1992. </year>
Reference-contexts: Many solutions for distributed garbage collection have been suggested, but they are not suitable for large scale distributed systems because their target systems are small in scale or they cannot collect cyclic garbage. Especially, it is a challenging problem to collect distributed cyclic garbage. <ref> [Ladin and Liskov, 1992] </ref> uses a logically centralized service which kept all information about inter-systems refer 1 ences, and [Jull and Jul, 1992] uses a global comprehen-sive tracing algorithm. <p> These algorithms do not need global synchronization, but the overhead of finding a global lower bound is extremely heavy. [Hughes, 1985] uses a distributed termination detection algorithm to find the global lower bound, but the algorithm was very expensive and did not scale well. <ref> [Ladin and Liskov, 1992] </ref> uses a logically centralized service which kept all information about inter-systems references, but this algorithm did not scale well either. [Neuman, 1992] uses timeouts and last referenceable timestapms for garbage collection.
Reference: [Lang et al., 1992] <author> Bernard Lang, Christian Queinnec, and Jose Piquer. </author> <title> Garbage collecting the world. </title> <booktitle> In Conference Record of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 39-50, </pages> <year> 1992. </year>
Reference-contexts: Both of them do not scale well because they require global synchronization. [Neuman, 1992] uses a local lower bound instead of a global lower bound, that is, the algorithm sacrifices safety for performance. <ref> [Lang et al., 1992] </ref> introduced tracing within a group instead of global systems to avoid global synchronization. <p> The storage and management overhead for the reference list, however, is heavy, when a large number of incoming links exist. [Shapiro et al., 1990] uses migration to collect cyclic garbage, but [Birrell et al., 1993] does not collect cyclic garbage. In tracing algorithms <ref> [Juul and Jul, 1992; Lang et al., 1992] </ref>, each system starts marking all of the accessible lo 12 cal objects from its root objects. After completing the lo-cal marking step, systems exchange information about the reachability of remote references. Remotely referenced objects and their descendants are also marked. <p> These algorithms can collect distributed cyclic garbage. The overhead of the termination detection, however, is extremely heavy, and in large scale distributed systems, the centralized server becomes a bottleneck. In <ref> [Lang et al., 1992] </ref>, both reference counting and tracing is used. Reference counting is a basic algorithm, and tracing is used to collect cyclic garbage. To avoid global synchronization, this algorithm introduced tracing within a group.
Reference: [Lieberman & Hewitt, 1983] <author> H. Lieberman and C. Hewitt, </author> <title> A real-time garbage collector based on the lifetimes of objects, </title> <journal> Commun. ACM, </journal> <volume> vol. 26, </volume> <month> June </month> <year> 1983, </year> <pages> pages 419-429. </pages>
Reference: [Piquer, 1991] <author> Piquer, J. </author> <title> Indirect reference counting: A distributed garbage collection algorithm, </title> <booktitle> In Proceedings Parallel Architectures and Languages, Europe. </booktitle> <volume> vol. 1, </volume> <booktitle> Lecture Notes in Computer Science 505, </booktitle> <editor> E. H. L. Aarts, J. van Leeuwen, M. Rem, Eds. </editor> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991, </year> <pages> pages 150-165. </pages>
Reference-contexts: When the reference count of the object reaches zero, the object is reclaimed as garbage. Each reference has a virtually unique weight, so potential race conditions are avoided. The shortcomings of this algorithm is the limited number of references and the above two drawbacks of reference counting. <ref> [Piquer, 1991] </ref> suggested indirect reference counting to solve the problem of weighted reference counting. The algorithm localizes the creation and the duplication of references. For garbage collection, the algorithm maintains an inverted tree representing the diffusion tree of the references throughout the systems.
Reference: [RMI, 1997] <author> Sun Microsystems, </author> <title> Java Remote Method Invocation Specification, </title> <note> http://java.sun.com, 1997. </note>
Reference-contexts: We have implemented a garbage collection mechanism which uses timeouts, last referenceable timestamp propagation [Neuman, 1992] and backward inquiry. The primary method used for local and remote garbage collection is timeouts, which is similar to leases in Java RMI <ref> [RMI, 1997] </ref> and pinging in DCOM [Chappell, 1996]. Each object has a Time-To-Live (TTL) and an expiration, and each link maintains an expiration time of its target object.
Reference: [Schelvis, 1989] <author> Marcel Schelvis, </author> <title> Incremental Distribution Timestamp Packets: A new approach to distributed garbage collection, </title> <booktitle> In Proceeding of OOPSLA `89, </booktitle> <month> Oct. </month> <year> 1989, </year> <pages> pages 37-48. </pages>
Reference: [Shapiro et al., 1990] <author> M. Shapiro, O. Gruber and D. Plainfosse', </author> <title> A garbage detection protocol for a realistic distributed object-support system. </title> <institution> Rapport de Recherche INRIA 1320, INRIA-Rocquencourt, Paris, France, </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: When there is only a root node in the tree, the object is garbage. The shortcomings of the algorithm are the overhead of management of the inverted tree and two drawbacks of reference counting which were mentioned before. Reference listing <ref> [Shapiro et al., 1990; Birrell et al., 1993] </ref> was introduced to solve the problem of reference counting. <p> This algorithm works well in cases where there are only a few incoming links. The storage and management overhead for the reference list, however, is heavy, when a large number of incoming links exist. <ref> [Shapiro et al., 1990] </ref> uses migration to collect cyclic garbage, but [Birrell et al., 1993] does not collect cyclic garbage. In tracing algorithms [Juul and Jul, 1992; Lang et al., 1992], each system starts marking all of the accessible lo 12 cal objects from its root objects.
Reference: [Ungar & Jackson, 1988] <author> David Ungar and Frank Jack-son, </author> <title> The Tenuring Policies for Generation-Based Storage Reclamation, </title> <booktitle> OOPSLA, </booktitle> <month> September </month> <year> 1988, </year> <pages> pages 1-17. </pages>
Reference: [Vogel and Duddy, 1997] <author> Andreas Vogel and Keith Dyddy, </author> <title> Java Programming with CORBA, </title> <publisher> John Wiley & Sons, </publisher> <year> 1997. </year>
Reference-contexts: A distributed object is a unit of information (e.g., an object of CORBA <ref> [Vogel and Duddy, 1997] </ref>, DCOM [Chappell, 1996], Distributed OODB, web or Prospero) and may contain data and methods. Data includes attributes and links. A link consists of the target object's name and attributes of the link. <p> Since objects can be removed in a loosely synchronized distributed system without deleting their links (e.g., during a server crash), the link count of an object can be greater than zero, even though no other objects are referencing the object. CORBA <ref> [Vogel and Duddy, 1997] </ref> and DCOM [Chappell, 1996] use reference counting and they have the above problems. [Bevan, 1987] suggested a weighted reference counting algorithm to avoid the problems caused by extra messages and race conditions.
References-found: 20

