URL: http://polaris.cs.uiuc.edu/reports/1005.ps.gz
Refering-URL: http://polaris.cs.uiuc.edu/tech_reports.html
Root-URL: http://www.cs.uiuc.edu
Title: AN OVERVIEW OF INTERPROCEDURAL ANALYSIS TECHNIQUES FOR HIGH PERFORMANCE PARALLELIZING COMPILERS  
Author: BY DALE ALLAN SCHOUTEN 
Degree: 1986 THESIS Submitted in partial fulfillment of the requirements for the degree of Master of Science in Computer Science in the Graduate College of the  
Address: 1990 Urbana, Illinois  
Affiliation: B.S., University of Arizona,  University of Illinois at Urbana-Champaign,  
Abstract-found: 0
Intro-found: 1
Reference: [AK82] <author> J. R. Allen and K. Kennedy. </author> <title> PFC: A program to convert fortran to parallel form. </title> <type> Technical Report MASC-TR82-6, </type> <institution> Rice University, Houston, Texas, </institution> <month> March </month> <year> 1982. </year>
Reference-contexts: Therefore it is important to consider separate array references in subroutine calls. In general, analysis of array references is limited to cases in which the subscript expressions are a linear combination of iteration variables and loop invariants [Ban88] <ref> [AK82] </ref>. 38 In the following analyses, the main concern is with the types of array reference patterns that may be represented and how dependences are determined from this information.
Reference: [ASU86] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers : Principles, Techniques and Tools. </booktitle> <publisher> Addison Wesley, </publisher> <month> March </month> <year> 1986. </year>
Reference-contexts: types, they cannot be aliased, answering the question without any expensive analysis. 1 The use of programming tricks (sometimes known as `hacks') to circumvent language restrictions may invalidate certain assumptions that the compiler may make. 21 CHAPTER 3 INTERPROCEDURAL CONSTANT PROPAGATION Constant propagation is an important problem in dataflow analysis <ref> [ASU86] </ref>. It refers to determining at compile time the value of certain variables which are constant regardless of the input data. This information is useful in two ways. <p> If (i .eq. 2) then S1 . S1 . call P (A,B,C) S2 . call P (A,B,C) endif . S2 . S2 . . . . . . Do i = 1,N enddo 3.1 Interprocedural Constant Propagation While constant propagation is a problem which is addressed by all compilers <ref> [ASU86] </ref> [WZ85] [RL77], interprocedural constant propagation is not so often dealt with. In procedures, which are often written as general purpose routines with certain input parameters directly governing the control flow, constant propagation can be especially useful. One brute-force approach is detailed in Figure 3.3. <p> Dependence analysis is determined from the IN- and OUTsets of a given statement. An INset of a statement is the set of all variables that are read from due to an execution of the statement <ref> [ASU86] </ref>. Similarly, an OUTset of a statement is the set of all variables that are written to due to an execution of the statement. Normally, neglecting aliasing effects and procedure calls, the IN- and OUTsets can be determined by inspection.
Reference: [Ban76] <author> U. Banerjee. </author> <title> Data dependence in ordinary programs. </title> <type> Master's thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> November </month> <year> 1976. </year>
Reference-contexts: A (i,2*j-1) = . . . enddo enddo (a) A Linear? 0 i j 1 1 0 1 0 (b) A Linear? 0 i j 1 1 0 1 0 i 1 N 0 0 (c) Given this information (which can be automatically generated by the compiler), standard dependence tests <ref> [Ban76] </ref> [Ban88] [Wol82] [WB87] may be used for each atom image. Since all the needed information is available, it may be treated in the same way as any other reference. The main disadvantage is that there is no way to merge references. <p> Do j = 1,N Do i = lo,hi,step Mem (a*i + b + N*(j-1)) = . . . enddo enddo This loop illustrates how dependences may be detected with the Burke/Cytron method. Detecting dependences in this example reduces to the problem of detecting dependences in the nested loop of <ref> [Ban76] </ref> [Ban88] [Wol82] [WB87].
Reference: [Ban78] <author> J. Banning. </author> <title> A Method for Determining the Side Effects of Procedure Calls. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> August </month> <year> 1978. </year>
Reference-contexts: Using the above algorithm results in forcing this type of aliasing information on a situation in which it is not appropriate. A more complete approach is to maintain a set consisting of alias pairs <ref> [Ban78] </ref>. An alias pair is a tuple hv 1 ; v 2 i where v 1 and v 2 are aliased. An alias set is a set S of alias pairs that contains all of the aliases for a program. <p> 8 a i do if a i is global then S = S [ fhf Q elseif ha i ; gi 2 S for some global g then S = S [ fhf Q enddo endfor if S old 6= S then add Q to W endwhile end Banning's algorithm <ref> [Ban78] </ref> [Coo83] uses an iterative approach so that it can find accurate aliasing information in the presence of recursion. A worklist W is kept which contains all procedures that need to be analyzed.
Reference: [Ban88] <author> U. Banerjee. </author> <title> Dependence Analysis for Supercomputing. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1988. </year>
Reference-contexts: Therefore it is important to consider separate array references in subroutine calls. In general, analysis of array references is limited to cases in which the subscript expressions are a linear combination of iteration variables and loop invariants <ref> [Ban88] </ref> [AK82]. 38 In the following analyses, the main concern is with the types of array reference patterns that may be represented and how dependences are determined from this information. <p> (i,2*j-1) = . . . enddo enddo (a) A Linear? 0 i j 1 1 0 1 0 (b) A Linear? 0 i j 1 1 0 1 0 i 1 N 0 0 (c) Given this information (which can be automatically generated by the compiler), standard dependence tests [Ban76] <ref> [Ban88] </ref> [Wol82] [WB87] may be used for each atom image. Since all the needed information is available, it may be treated in the same way as any other reference. The main disadvantage is that there is no way to merge references. <p> 1 " S 2 6= ; , false otherwise. begin for each two corresponding boundary pairs, B i 2 S 1 ; B 0 i 2 S 1 i ) &gt; min (fi i ; fi 0 return false endfor return true end 49 4.4 Comparison of Different Methods test <ref> [Ban88] </ref> can be used to determine the dependences in this nested loop. This example will be used to compare the operation of each of the region analysis methods. Do j = 1,N C1: call P (C (1,j),lo,hi,step) Do j = 1,N enddo . . <p> Detecting dependences in this example reduces to the problem of detecting dependences in the nested loop of [Ban76] <ref> [Ban88] </ref> [Wol82] [WB87].
Reference: [BC86] <author> M. Burke and R. Cytron. </author> <title> Interprocedural dependence analysis and parallelization. </title> <booktitle> ACM SIGPLAN `86 Symposium on Compiler Construction, </booktitle> <pages> pages 162-175, </pages> <month> june </month> <year> 1986. </year> <month> 21(7). </month>
Reference-contexts: The main disadvantage is that there is no way to merge references. This problem is dealt with in most of the other methods at the expense of precision of the information. 40 4.3.2 Burke/Cytron Approach A similar method is suggested by Burke and Cytron <ref> [BC86] </ref>. Their approach is to linearize the array references. The actual array references in the code do not need to be linearized, just the information stored about the reference.
Reference: [BK89] <author> V. Balasundaram and K. Kennedy. </author> <title> A technique for summarizing data access and its use in parallelism enhancing transformations. </title> <booktitle> In Proceedings of the SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 41-53. </pages> <publisher> ASM Press, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: Since a triplet region corresponds exactly to a series of perfectly nested loops, dependence tests may be performed using the Banerjee/Wolfe [WB87] tests or any number of other tests common in dependence analysis [WB87] [Kuc78]. 47 4.3.6 Data Access Descriptors Data Access Descriptors (DAD) are suggested in <ref> [BK89] </ref>. A DAD describes array regions with simple sections. A simple section is described by orthogonal and diagonal bounds in the reference space of an array. The orthogonal bounds are simply upper and lower limits on each dimension. <p> If, for any orthogonal or diagonal boundary, the upper bound of one is less than the lower bound of the other or vice-versa, then there is a no intersection. Figure 4.12 shows the algorithms for merging simple sections and detecting intersections <ref> [BK89] </ref>. 48 i be boundary pairs such that B i = ff i i (x 1 ; : : : ; x n ) fi i 2 S 1 i = ff 0 i 2 S 2 MERGE: Input: simple sections S 1 and S 2 .
Reference: [CCKT86] <author> D. Callahan, K. D. Cooper, K. Kennedy, and L. Torczon. </author> <title> Interprocedural constant propagation. </title> <journal> Journal of the ACM, </journal> <pages> pages 152-161, </pages> <year> 1986. </year>
Reference-contexts: In <ref> [CCKT86] </ref>, several levels of complexity are suggested. * J = k or ? | The first possibility is that the jump functions be limited to either a constant value or unknown. <p> An example of this would be in Figure 3.4 where J M S 4 = 2 fl N . The symbolic expressions suggested in <ref> [CCKT86] </ref> include more complex expressions with conditional statements. Their algorithm may be outlined as follows : 1. Perform intraprocedural constant propagation for all procedures. 2. Determine jump functions. 3. Propagate constants through jump functions. 4. Perform intraprocedural constant propagation for all procedures. 26 First normal intraprocedural constant propagation is performed.
Reference: [CK87a] <author> D. Callahan and K. Kennedy. </author> <title> Analysis of interprocedural side effects in a parallel programming environment. </title> <editor> In E. N. Houstis, T. S. Papatheodorou, and C. D. Polychronopoulos, editors, </editor> <booktitle> Lecture Notes in Computer Science Vol. 297 : 1st International Conference on Supercomputing, </booktitle> <pages> pages 138-171. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: A more pragmatic approach is to find a representation that can describe sections of an array that are believed to be useful in practice, worrying less about precision in general. One such solution is the Restricted Regular Section Descriptor (RRSD) proposed by Callahan and Kennedy <ref> [CK87a] </ref>. A RRSD is defined as an array name and a list of expressions, where each expression is associated with one dimension of the array and indicates the elements that can be referenced in that dimension of the reference space of an array.
Reference: [CK87b] <author> K. D. Cooper and K. Kennedy. </author> <title> Complexity of interprocedural side-effect analysis. </title> <type> Technical Report 87-61, </type> <institution> Department of Computer Science, Rice University, Houston, Texas 77251-1892, </institution> <month> October </month> <year> 1987. </year>
Reference-contexts: (c 1 , . . .,c N ) If ( . . . ) then call h (c N , c 1 , . . .,c N1 ) endif c 1 = . . . return end 4.2 Efficient Techniques for Simple Summary Information One such technique is proposed in <ref> [CK87b] </ref>. <p> The following relations hold <ref> [CK87b] </ref> : REF (p) = LREF (p) [ [ [ MAP (e; REF (q))] (4.1) REF (p) = LREF + (p) [ [ [ MAP (e; REF (q))] (4.2) 2 Their presentation deals with the problem of finding the set of variables modified by a procedure call, but this is equivalent <p> This process will always halt, but as discussed above it could require O (N fi ) iterations. There is no small upper bound on the number of iterations because the system is not rapid in the Kam/Ullman sense [KU76] <ref> [CK87b] </ref>. This system of equations consisting of (4.1) is not rapid because of the presence of the MAP function.
Reference: [CK87c] <author> K. D. Cooper and K. Kennedy. </author> <title> Interprocedural side-effect analysis in linear time. </title> <type> Technical Report 87-62, </type> <institution> Department of Computer Science, Rice University, Houston, Texas 77251-1892, </institution> <month> October </month> <year> 1987. </year>
Reference-contexts: be determined from the following equation : LREF + (p) = RMOD (p) [ LREF (p) This is then used in (4.4) which is solved to determine REF (p) for all procedures. 4.2.1 Binding Multigraph Simple reference information may be calculated in linear time 4 by using a binding multigraph <ref> [CK87c] </ref>. A binding multigraph, fi = hN fi ; E fi i represents bindings of formal parameters. <p> The algorithm above is linear in the size of the binding multigraph, fi. A key assumption in <ref> [CK87c] </ref> is that the size of fi is linear in terms of the size of the call graph C. This assertion is based on the belief that the maximum number of parameters to any given procedure is independent of the size of the program.
Reference: [CKT85] <author> Keith D. Cooper, Ken Kennedy, and Linda Torczon. </author> <title> Interprocedural constant propagation. </title> <type> Technical Report TR85-29, </type> <institution> Department of Computer Science, Rice University, </institution> <address> P.O. Box 1892, Houston, Texas 77251-1892, </address> <month> December </month> <year> 1985. </year> <month> 62 </month>
Reference: [Coo83] <author> K. D. Cooper. </author> <title> Interprocedural Data Flow Analysis in a Programming Environment. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Rice University, Houston, Texas 77251-1892, </institution> <month> April </month> <year> 1983. </year>
Reference-contexts: a i do if a i is global then S = S [ fhf Q elseif ha i ; gi 2 S for some global g then S = S [ fhf Q enddo endfor if S old 6= S then add Q to W endwhile end Banning's algorithm [Ban78] <ref> [Coo83] </ref> uses an iterative approach so that it can find accurate aliasing information in the presence of recursion. A worklist W is kept which contains all procedures that need to be analyzed. <p> When the worklist is empty, the work is complete and all potential alias pairs are contained in S. 2.3.3 Extensions Some extensions to this information are useful. One extension that is useful in a programming environment was suggested by Cooper <ref> [Coo83] </ref>. This involves keeping a reference count of the sources of any given alias-pair. That way, when one source of an alias is removed, its reference count may be decremented. When a reference count reaches zero, aliases are recalculated.
Reference: [Gua87] <author> V. A. Guarna. </author> <title> Analysis of C programs for parallelization in the presence of pointers. </title> <type> Master's thesis, </type> <institution> University of Illlinois at Urbana, </institution> <month> December </month> <year> 1987. </year> <note> CSRD Report No. 695. </note>
Reference-contexts: Whenever two different pointers may contain the same value, they may indirectly refer to the same object. Unless some information is known about the values of the pointers involved, either through some form of constant propagation or pointer analysis <ref> [Gua87] </ref> [Gua88], any expression involving pointers must be assumed to be aliased to any object in the program. There are some cases in which heuristics may be used to replace the usage of a pointer with array references, which may be safely analyzed.
Reference: [Gua88] <author> V. A. Guarna. </author> <title> A technique for analyzing pointer and structure references in parallel restructuring compilers. </title> <booktitle> In Proceedings of ICPP 88, </booktitle> <volume> volume 2. </volume> <publisher> Penn State Press, </publisher> <month> August </month> <year> 1988. </year>
Reference-contexts: Whenever two different pointers may contain the same value, they may indirectly refer to the same object. Unless some information is known about the values of the pointers involved, either through some form of constant propagation or pointer analysis [Gua87] <ref> [Gua88] </ref>, any expression involving pointers must be assumed to be aliased to any object in the program. There are some cases in which heuristics may be used to replace the usage of a pointer with array references, which may be safely analyzed.
Reference: [Hec77] <author> M. S. Hecht. </author> <title> Flow Analysis of Computer Programs. </title> <publisher> North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: i where is a partial ordering relation on the elements of S, a meet (or greatest lower bound) of x and y is an element m 2 S such that m x and m y and there is no element z such that m z x and m z y <ref> [Hec77] </ref>. A join operator, or least upper bound is defined analogously [Hec77]. A partially ordered set together with a meet and join forms a lattice. The 25 meet operator for this constant propagation lattice is defined below. <p> S, a meet (or greatest lower bound) of x and y is an element m 2 S such that m x and m y and there is no element z such that m z x and m z y <ref> [Hec77] </ref>. A join operator, or least upper bound is defined analogously [Hec77]. A partially ordered set together with a meet and join forms a lattice. The 25 meet operator for this constant propagation lattice is defined below.
Reference: [KU76] <author> John B. Kam and Jeffery D. Ulllman. </author> <title> Global dataflow analysis and iterative algorithms. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 23(1) </volume> <pages> 158-171, </pages> <month> January </month> <year> 1976. </year>
Reference-contexts: This process will always halt, but as discussed above it could require O (N fi ) iterations. There is no small upper bound on the number of iterations because the system is not rapid in the Kam/Ullman sense <ref> [KU76] </ref> [CK87b]. This system of equations consisting of (4.1) is not rapid because of the presence of the MAP function. <p> Given LREF + (p), we can solve (4.4) iteratively and are guaranteed to solve it in D + 3 iterations, where D is the depth of the call graph <ref> [KU76] </ref>. Now the problem is to compute LREF + (p). In order to do that, two new definitions are needed.
Reference: [Kuc78] <author> D. J. Kuck. </author> <title> The Structure of Computers and Computations, Volume I. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: Once the information is gathered dependence tests may be performed in a straightforward manner. Since a triplet region corresponds exactly to a series of perfectly nested loops, dependence tests may be performed using the Banerjee/Wolfe [WB87] tests or any number of other tests common in dependence analysis [WB87] <ref> [Kuc78] </ref>. 47 4.3.6 Data Access Descriptors Data Access Descriptors (DAD) are suggested in [BK89]. A DAD describes array regions with simple sections. A simple section is described by orthogonal and diagonal bounds in the reference space of an array.
Reference: [LY88] <author> Z. Li and P. C. Yew. </author> <title> Interprocedural analysis and program restructuring for parallel programs. </title> <type> Technical Report CSRD Rpt No. 720, </type> <institution> UIUC, </institution> <month> January </month> <year> 1988. </year>
Reference-contexts: A method of representing array accesses in terms of linear combinations of iteration variables is suggested in <ref> [LY88] </ref>. Along with this information, the bounds on the iteration variables (in terms of loop invariants and outer loop iteration variables) is kept. <p> Do i = lo,hi,step S1: AR (a*i + b) = . . . enddo return (a) (b) Li's Method: The atom image as it appears in subroutine P is : AR -1 0 i i 1 hi lo + 1 * When this is translated through the procedure call <ref> [LY88] </ref>, we obtain the following atom image : C -1 0 j i 2 1 0 1 0 i 1 hi lo + 1 * * With this information, any of the standard dependence tests for multi-dimensional arrays and multiple nested loops can be used to determine if the outer loop
Reference: [Pol88] <author> C. D. Polychronopoulos. </author> <title> Parallel Programming and Compilers. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1988. </year>
Reference-contexts: Without reference information for a procedure call, the compiler must assume that all variables in the scope of the called procedure and all call-by-reference actual parameters may be used by or defined in a procedure call. In order to perform high level spreading [Vei85] <ref> [Pol88] </ref>, information about how various sections of code may interfere with 4 each other is needed. Obtaining this information again requires reference information from the procedure call.
Reference: [RG87] <author> S. Richardson and M. Ganapathi. </author> <title> Interprocedural analysis useless for code optimization. </title> <type> Technical Report CSL-TR-87-342, </type> <institution> Stanford University, </institution> <month> November </month> <year> 1987. </year>
Reference-contexts: These methods were described and compared in terms of efficiency and precision. It has been said that interprocedural analysis is useless <ref> [RG87] </ref>. While a good argument can be made that certain language features may be a great aid in interprocedural analysis, it is clear that interpro-cedural analysis is necessary in a parallel programming environment. The importance of maximizing dependence information makes such analysis indispensable. 61
Reference: [RL77] <author> John H. Reif and Harry R. Lewis. </author> <title> Symbolic evaluation and the global value graph. </title> <booktitle> Conf. Rec. Fourth ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 104-118, </pages> <month> January </month> <year> 1977. </year>
Reference-contexts: S1 . call P (A,B,C) S2 . call P (A,B,C) endif . S2 . S2 . . . . . . Do i = 1,N enddo 3.1 Interprocedural Constant Propagation While constant propagation is a problem which is addressed by all compilers [ASU86] [WZ85] <ref> [RL77] </ref>, interprocedural constant propagation is not so often dealt with. In procedures, which are often written as general purpose routines with certain input parameters directly governing the control flow, constant propagation can be especially useful. One brute-force approach is detailed in Figure 3.3.
Reference: [RND77] <author> E. M. Reingold, J. Nievergelt, and N. Deo. </author> <title> Combinatorial Algorithms: Theory and Practice. </title> <publisher> Prentice-Hall, </publisher> <year> 1977. </year>
Reference-contexts: This algorithm is detailed in Figure 2.5 How the aliases are `marked', or recorded, affects the accuracy of the information. One approach is to put aliased variables in the same equivalence class, much the same way in which Equivalence statements are implemented, using a union-find data structure <ref> [RND77] </ref>. Initially every variable is its own equivalence class. When an alias is discovered between two parameters, f 1 and f 2 , their equivalence classes are joined to form one new equivalence class of which both are members. Consider the example in Figure 2.6. <p> The approach is as follows : 1. Let S = [ p LGREF (p); 8 procedures p (where LGREF (p) is the set of reference pairs hg; T i where g is directly modified in p). 2. Find the strongly connected components (SCC's) of fi <ref> [RND77] </ref>. 3. Replace each SCC with a representative node n, replacing any occurrences of hv; T i in S with hn; T i for all the elements v of the SCC n. 4.
Reference: [Sch77] <author> R. W. Scheifler. </author> <title> An analysis of inline substitution for a structured programming language. </title> <journal> Communications of the ACM, </journal> <year> 1977. </year>
Reference-contexts: In a worst case scenario, the code growth, and thus the growth of analysis time, is exponential in the height of the callgraph <ref> [Sch77] </ref>. The expanded call graph may be thought of as a N-ary tree where N is the maximum number of calls in a single routine, and duplicate calls to a given routine are replaced 7 with separate copies of the routine.
Reference: [TIF86] <author> R. Triolet, F. Irigoin, and P. Feautrier. </author> <title> Direct parallelization of call statements. </title> <booktitle> ACM SIGPLAN 86 Symposium on Compiler Construction, </booktitle> <pages> pages 176-185, </pages> <year> 1986. </year>
Reference-contexts: However, it still has the drawback of conservative merging. 4.3.3 Triolet's Method Triolet suggested the use of a system of linear inequalities, to represent referenced regions of an array, resulting in a convex hull in the k-dimensional array reference space [Tri85] <ref> [TIF86] </ref>. This approach has 41 some serious limitations, however. It does not allow cycles in the call graph, therefore recursion can not be handled. Furthermore, dependence testing involves solving a system of linear inequalities, which is rather expensive. There are two main phases in the algorithm : 1.
Reference: [Tri85] <author> R. Triolet. </author> <title> Interprocedural analysis for program restructuring with parafrase. </title> <type> Technical Report CSRD Rpt No. 538, </type> <institution> UIUC, </institution> <month> December </month> <year> 1985. </year>
Reference-contexts: However, it still has the drawback of conservative merging. 4.3.3 Triolet's Method Triolet suggested the use of a system of linear inequalities, to represent referenced regions of an array, resulting in a convex hull in the k-dimensional array reference space <ref> [Tri85] </ref> [TIF86]. This approach has 41 some serious limitations, however. It does not allow cycles in the call graph, therefore recursion can not be handled. Furthermore, dependence testing involves solving a system of linear inequalities, which is rather expensive. There are two main phases in the algorithm : 1.
Reference: [Vei85] <author> A. V. Veidenbaum. </author> <title> Compiler Optimizations and Architecture Design Issues for Multiprocessors. </title> <type> PhD thesis, </type> <institution> University of Illinois, </institution> <month> May </month> <year> 1985. </year>
Reference-contexts: Without reference information for a procedure call, the compiler must assume that all variables in the scope of the called procedure and all call-by-reference actual parameters may be used by or defined in a procedure call. In order to perform high level spreading <ref> [Vei85] </ref> [Pol88], information about how various sections of code may interfere with 4 each other is needed. Obtaining this information again requires reference information from the procedure call.
Reference: [WB87] <author> M. J. Wolfe and U. Banerjee. </author> <title> Data dependence and its application to parallel processing. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 16(2) </volume> <pages> 137-178, </pages> <month> April </month> <year> 1987. </year>
Reference-contexts: . . . enddo enddo (a) A Linear? 0 i j 1 1 0 1 0 (b) A Linear? 0 i j 1 1 0 1 0 i 1 N 0 0 (c) Given this information (which can be automatically generated by the compiler), standard dependence tests [Ban76] [Ban88] [Wol82] <ref> [WB87] </ref> may be used for each atom image. Since all the needed information is available, it may be treated in the same way as any other reference. The main disadvantage is that there is no way to merge references. <p> Once the information is gathered dependence tests may be performed in a straightforward manner. Since a triplet region corresponds exactly to a series of perfectly nested loops, dependence tests may be performed using the Banerjee/Wolfe <ref> [WB87] </ref> tests or any number of other tests common in dependence analysis [WB87] [Kuc78]. 47 4.3.6 Data Access Descriptors Data Access Descriptors (DAD) are suggested in [BK89]. A DAD describes array regions with simple sections. <p> Once the information is gathered dependence tests may be performed in a straightforward manner. Since a triplet region corresponds exactly to a series of perfectly nested loops, dependence tests may be performed using the Banerjee/Wolfe <ref> [WB87] </ref> tests or any number of other tests common in dependence analysis [WB87] [Kuc78]. 47 4.3.6 Data Access Descriptors Data Access Descriptors (DAD) are suggested in [BK89]. A DAD describes array regions with simple sections. A simple section is described by orthogonal and diagonal bounds in the reference space of an array. <p> Detecting dependences in this example reduces to the problem of detecting dependences in the nested loop of [Ban76] [Ban88] [Wol82] <ref> [WB87] </ref>.
Reference: [Wol82] <author> M. J. Wolfe. </author> <title> Optimizing Supercompilers for Supercomputers. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1982. </year>
Reference-contexts: In the absence of analysis, a loop containing a call to a function or subroutine can not be parallelized. Without any further information, the compiler must assume that any parameter or global variable is referenced, thus eliminating any parallelization optimizations and many loop transformations <ref> [Wol82] </ref>. 2 There are three categories of information which are useful to the compiler but are hidden by procedure calls : * Aliasing Information | Knowing when two or more objects with different names may refer to the same memory location. * Constant Propagation | Propagating constants across procedure boundaries. * <p> = . . . enddo enddo (a) A Linear? 0 i j 1 1 0 1 0 (b) A Linear? 0 i j 1 1 0 1 0 i 1 N 0 0 (c) Given this information (which can be automatically generated by the compiler), standard dependence tests [Ban76] [Ban88] <ref> [Wol82] </ref> [WB87] may be used for each atom image. Since all the needed information is available, it may be treated in the same way as any other reference. The main disadvantage is that there is no way to merge references. <p> Detecting dependences in this example reduces to the problem of detecting dependences in the nested loop of [Ban76] [Ban88] <ref> [Wol82] </ref> [WB87].
Reference: [WZ85] <author> Mark N. Wegman and Frank Kenneth Zadeck. </author> <title> Constant propagation with conditional branches. </title> <booktitle> In Proceedings of Twelfth POPL, </booktitle> <pages> pages 291-299, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: S1 . call P (A,B,C) S2 . call P (A,B,C) endif . S2 . S2 . . . . . . Do i = 1,N enddo 3.1 Interprocedural Constant Propagation While constant propagation is a problem which is addressed by all compilers [ASU86] <ref> [WZ85] </ref> [RL77], interprocedural constant propagation is not so often dealt with. In procedures, which are often written as general purpose routines with certain input parameters directly governing the control flow, constant propagation can be especially useful. One brute-force approach is detailed in Figure 3.3.
References-found: 30

