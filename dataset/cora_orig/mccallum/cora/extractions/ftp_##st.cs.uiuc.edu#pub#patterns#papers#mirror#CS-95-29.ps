URL: ftp://st.cs.uiuc.edu/pub/patterns/papers/mirror/CS-95-29.ps
Refering-URL: http://st-www.cs.uiuc.edu/users/patterns/papers/
Root-URL: http://www.cs.uiuc.edu
Email: sullivan@cs.virginia.edu, ira@radonc.washington.edu, notkin@cs.washington.edu  
Title: Mediators in a Radiation Treatment Planning Environment  
Author: Kevin J. Sullivan Ira J. Kaletyz David Notkiny 
Note: This work was supported in part by grant number R01 LM04174 from the National Library of Medicine and contract number N01 CM97566 from the National Cancer Institute, by a grant from General Electric Medical Systems, and by the National Science Foundation under Grant Numbers CCR-9113367, CCR 8858804, and CCR-9502029, and by SRA (Tokyo Japan).  
Date: June 25, 1995  
Address: Charlottesville, VA 22903 USA  Seattle, WA 98195 USA  
Affiliation: Computer Science Department University of Virginia  yDepartment of Computer Science and Engineering zDepartment of Radiation Oncology University of Washington  
Abstract: We describe the architecture of Prism, an integrated system for planning radiation treatments for cancer patients. This architecture is based on the mediator design approach. The problem addressed by this approach is that common methods of designing integrated systems lead to undue module coupling, significantly complicating software development and evolution. The mediator approach was devised to ameliorate the conflict between integration and ease of software development and evolution. It does this by enabling the composition of visible and independently defined components into behaviorally integrated systems. We present Prism as evidence for two claims: first, the mediator method can overcome the problem of coupling, easing the design and evolution of real integrated systems; second, the method profitably can be learned and used by practicing software engineers. Prism continues to evolve in clinical use at University of Washington and Emory University Cancer Centers, and in trials at other institutions, including the University of Miami. It is an attractive subject for continuing research on integration, software structure, and the evolution of mediator-based architectures. 
Abstract-found: 1
Intro-found: 1
Reference: [Bobrow et al. 88] <author> D.G. Bobrow et al. </author> <title> Common Lisp Object System Specification X3JI3 Document 88-002R. </title> <journal> ACM SIGPLAN Notices 23, </journal> <month> September </month> <year> 1988. </year>
Reference-contexts: Figure 4 presents our Common Lisp [Steele 90] implementation of events as a CLOS <ref> [Bobrow et al. 88] </ref> type. The notification set is an association list that pairs operations to be implicitly invoked with the objects to which they are to be applied.
Reference: [Brooks 88] <author> F.P. Brooks, </author> <title> "Grasping Reality through Illusion|Interactive Graphics Serving Science," Plenary Address, SIGCHI Bulletin, </title> <booktitle> Conference Proceedings, Human Factors in Computing Systems, </booktitle> <month> May, </month> <year> 1988, </year> <pages> pp. 1-11. </pages>
Reference-contexts: In Fred Brooks's lexicon these are "generalizations, even those unsupported by testing over the whole domain of generalization, believed by the investigators willing to attach their names to them <ref> [Brooks 88, p.2] </ref>." Rules of thumb are distinguished from truthful and rigorous findings': "results properly established by soundly-designed experiments and stated in terms of the domain for which generalization is valid [Brooks 88, p.2]." The rationale for presenting well-supported rules of thumb is, finally, instrumental utility: "Over-generalized findings from other designers' <p> by testing over the whole domain of generalization, believed by the investigators willing to attach their names to them <ref> [Brooks 88, p.2] </ref>." Rules of thumb are distinguished from truthful and rigorous findings': "results properly established by soundly-designed experiments and stated in terms of the domain for which generalization is valid [Brooks 88, p.2]." The rationale for presenting well-supported rules of thumb is, finally, instrumental utility: "Over-generalized findings from other designers' experiences are more apt to be right than the designer's uninformed intuition. [Brooks 88, p. 2]." In our experience, mediators really work in real systems. Acknowledgments. <p> "results properly established by soundly-designed experiments and stated in terms of the domain for which generalization is valid [Brooks 88, p.2]." The rationale for presenting well-supported rules of thumb is, finally, instrumental utility: "Over-generalized findings from other designers' experiences are more apt to be right than the designer's uninformed intuition. <ref> [Brooks 88, p. 2] </ref>." In our experience, mediators really work in real systems. Acknowledgments. Jonathan Unger kindly provided a great deal of technical assistance. Thanks to Matt Conway for pointing out (in his dissertation proposal) the SIGCHI article by Fred Brooks.
Reference: [Chen 76] <author> P.P. Chen, </author> <title> "The Entity-Relational Model|Toward a Unified View of Data," </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 1,1, </volume> <pages> pp. 9-36, </pages> <month> March, </month> <year> 1976. </year>
Reference-contexts: The first phase articulates the decomposition of the system into modules. The second defines phase the module interfaces in a form suitable for efficient implementation. We call the first phase behavioral entity-relationship (ER) modeling because it applies entity-relation data modeling ideas <ref> [Chen 76] </ref> to decompose integrated system behaviors . One first identifies the behavioral components of the system that should be independently developed and (re)usable. Then one separately identifies the behavioral relationships needed to integrate these behaviors to produce the required system behavior.
Reference: [Collins et al. 91] <author> T. Collins, K. Ewert, C. Gerety, J. Gustafson, I. Thomas, "TICKLE: </author> <title> Object-Oriented Description and Composition Services for Software Engineering Environments," </title> <booktitle> Proceedings of the 3rd European Software Engineering Conference, </booktitle> <month> October </month> <year> 1991, </year> <title> Milan, </title> <booktitle> Italy, </booktitle> <pages> pp. 408-423. </pages>
Reference-contexts: An ABT abstractly defines a class of objects in terms both the operations the objects support and the events they announce [Sul-livan and Notkin 92, Sullivan 94]. (Other approaches based on a similar idea include TICKLE <ref> [Collins et al. 91] </ref> and the ISO "MIM" [ISO MIM 91].) Next, we implement the behavioral components of behavioral ER models as independent, visible ABT-based objects whose events and operations suffice to support their clients.
Reference: [Dijkstra 65] <author> E. Dijkstra, </author> <title> "Programming Considered as a Human Activity," </title> <booktitle> Proceedings of the 1965 IFIP Congress, </booktitle> <address> (Amsterdam, The Netherlands: </address> <publisher> North-Holland), </publisher> <year> 1965, </year> <pages> pp. 213-217, </pages> <editor> in E.N. Yourdon, Ed., </editor> <booktitle> Classics in Software Engineering, </booktitle> <address> (New York: </address> <publisher> Yourdon Press), </publisher> <year> 1979, </year> <pages> pp. 3-9. </pages>
Reference-contexts: Panels are then integrated with the patient case, etc. The decomposition of complex behaviors into independent behaviors integrated by mediators at all scales provided much intellectual and managerial leverage. This kind of decomposition meets the goal of modularization: to conquer by effectively dividing <ref> [Dijkstra 65] </ref>. 6.4 Keeping Graphical Views Consistent Viewing of plans in Prism is supported by view panels.
Reference: [Ellis and Stroustrup 90] <author> M.A. Ellis and B. Stroustrup, </author> <title> The Annotated C++ Reference Manual, </title> <publisher> (Addison-Wesley: </publisher> <address> Reading, Massachusetts), </address> <year> 1990. </year>
Reference-contexts: Kalet's second system has 41,000 lines of Pascal, 5,000 for dose distributions. Comparing with another system, the basic functions taking 18,000 lines in the original, core system take about 60,000 of C [Kernighan and Ritchie] and C++ <ref> [Ellis and Stroustrup 90] </ref> in GRATIS [Rosenman et al. 89], of which about 14,000 are for interface widgets.
Reference: [Fraass et al. 87] <author> B. A. Fraass and D. L. McShan, </author> <title> "3-D Treatment Planning I. Overview of a Clinical Planning System," </title> <editor> in I. A. D. Bruinvis, P. H. van der Giessen, H. J. van Kleffens and F. W. Wittkamper, eds., </editor> <booktitle> Proceedings of the Ninth International Conference on the Use of Computers in Radiation Therapy, </booktitle> <address> (Amsterdam: </address> <publisher> North-Holland), </publisher> <year> 1987, </year> <pages> pp. 273-277. </pages>
Reference: [Goitein et al. 83] <author> M. Goitein et al., </author> <title> "Multi-dimensional Treatment Planning: II. Beam's Eye-view, Back Projection, and Projection Through CT Sections," </title> <journal> International Journal of Radiation Oncology Biology and Physics 9, </journal> <year> 1983, </year> <pages> pp. 789-797. </pages>
Reference: [Goldberg and Robson 83] <author> A. Goldberg and D. Robson, </author> <title> Smalltalk-80: The Language and its Implementation, </title> <address> (Reading, Mass: </address> <publisher> Addison-Wesley), </publisher> <year> 1983. </year>
Reference-contexts: This makes it harder to reason about components by leaving key abstractions implicit [Reiss 90, Meyers 91]. Second, when objects must interact (e.g., when a change to a model should cause a view to update), one object often registers with and handles events from the other <ref> [Goldberg and Robson 83] </ref>. This compromises independence and represents the behavioral relationship implicitly. To begin to address these problems, the mediator method first adopts the abstract behavioral type (ABT) as a basic module construct.
Reference: [ISO MIM 91] <author> ISO/IEC JTC/SC21, </author> <title> "ISO/IEC IS 10165-1: </title> <booktitle> Information Technology| Open Systems Interconnection|Structure of Management Information|Part 1: Management Information Model," </booktitle> <month> June, </month> <year> 1991. </year>
Reference-contexts: An ABT abstractly defines a class of objects in terms both the operations the objects support and the events they announce [Sul-livan and Notkin 92, Sullivan 94]. (Other approaches based on a similar idea include TICKLE [Collins et al. 91] and the ISO "MIM" <ref> [ISO MIM 91] </ref>.) Next, we implement the behavioral components of behavioral ER models as independent, visible ABT-based objects whose events and operations suffice to support their clients.
Reference: [Jacky and Kalet 86] <author> Jacky, J.P. and Kalet, I.J., </author> <title> "An Object-Oriented Approach to a Large Scientific Application," </title> <booktitle> OOPSLA '86 Object Oriented Programming Systems, Languages and Applications Conference Proceedings, </booktitle> <editor> Meyrowitz, N., ed., </editor> <year> 1986, </year> <pages> pp. 368-376. </pages>
Reference-contexts: The awkwardness of such systems increases the cost and diminishes the quality of treatment plans. Second, the interfaces of earlier systems were inflexible. One uses Kalet's second system <ref> [Jacky and Kalet 86, Jacky and Kalet 87b] </ref> by constantly traversing a broad and deep menu tree to change plans, anatomical models, visualization parameters, etc. The visualization system is also inflexible, displaying a fixed set of views in a fixed screen layout.
Reference: [Jacky and Kalet 87b] <author> Jacky, J.P. and Kalet, I.J., </author> <title> "An Object-Oriented Programming Discipline for Standard Pascal," </title> <journal> Communications of the ACM 30,9, </journal> <pages> pp. 772-776, </pages> <month> September, </month> <year> 1987. </year>
Reference-contexts: also provide tools for visualizing plans and radiation fields, and for managing databases of patients, treatment machines, etc. 4 4.1 Related Systems While many RTP systems have been built [Goitein et al. 83, Kutcher 88, Fraass et al. 87, Rosenman et al. 89], including several at the University of Washington <ref> [Kalet and Jacky 82, Jacky and Kalet 87b] </ref>, none before Prism combined the rich functioning, tight integration, and adaptability Kalet saw as necessary for a highly effective treatment planning capability. Previous systems (including Kalet's) exhibited a number of shortcomings. <p> The awkwardness of such systems increases the cost and diminishes the quality of treatment plans. Second, the interfaces of earlier systems were inflexible. One uses Kalet's second system <ref> [Jacky and Kalet 86, Jacky and Kalet 87b] </ref> by constantly traversing a broad and deep menu tree to change plans, anatomical models, visualization parameters, etc. The visualization system is also inflexible, displaying a fixed set of views in a fixed screen layout. <p> Prism is evidently factored into independent parts integrated by separate mediators representing abstract behavioral relationships; and system evolution has been straightforward. Second, we can ask the client, Kalet (admittedly a co-author) whether the mediator method helped significantly. Kalet is qualified to answer, having built two earlier systems <ref> [Kalet and Jacky 82, Jacky and Kalet 87b] </ref> that have seen extensive clinical use, one designed using common object-oriented methods [Jacky and Kalet 87b]. <p> Second, we can ask the client, Kalet (admittedly a co-author) whether the mediator method helped significantly. Kalet is qualified to answer, having built two earlier systems [Kalet and Jacky 82, Jacky and Kalet 87b] that have seen extensive clinical use, one designed using common object-oriented methods <ref> [Jacky and Kalet 87b] </ref>. Kalet believes that without mediators, meeting the requirements for Prism would have taken far more resources than were spent or available; and the architecture would have been unnecessarily complex, hard to develop, and inflexible with respect to integration of new capabilities.
Reference: [Kalet and Jacky 82] <author> I. Kalet, and J. Jacky, </author> <title> "A Research-Oriented Treatment Planning Program System," </title> <booktitle> Computer Programs in Biomedicine 14, </booktitle> <pages> pp. 85-98, </pages> <year> 1982. </year>
Reference-contexts: also provide tools for visualizing plans and radiation fields, and for managing databases of patients, treatment machines, etc. 4 4.1 Related Systems While many RTP systems have been built [Goitein et al. 83, Kutcher 88, Fraass et al. 87, Rosenman et al. 89], including several at the University of Washington <ref> [Kalet and Jacky 82, Jacky and Kalet 87b] </ref>, none before Prism combined the rich functioning, tight integration, and adaptability Kalet saw as necessary for a highly effective treatment planning capability. Previous systems (including Kalet's) exhibited a number of shortcomings. <p> Previous systems (including Kalet's) exhibited a number of shortcomings. In many systems, different planning tasks are handled by different, stand-alone, "Unix-like" tools that run as separate processes and are loosely integrated using shared files. Kalet's first system <ref> [Kalet and Jacky 82] </ref> integrated modeling, dose computation, and visualization tools in this way. To modify the anatomical model, the dosimetrist has to terminate the dose display, run and then terminate anatomy modeling tools, execute the dose computation program, and then restart the dose display program. <p> Prism is evidently factored into independent parts integrated by separate mediators representing abstract behavioral relationships; and system evolution has been straightforward. Second, we can ask the client, Kalet (admittedly a co-author) whether the mediator method helped significantly. Kalet is qualified to answer, having built two earlier systems <ref> [Kalet and Jacky 82, Jacky and Kalet 87b] </ref> that have seen extensive clinical use, one designed using common object-oriented methods [Jacky and Kalet 87b].
Reference: [Kalet et al. 91] <author> I. Kalet, J. Jacky, S. Kromhout-Shiro, B. Lockyear, M. Niehaus, C. Sweeney, and J. Unger, </author> <title> "The Prism Radiation Treatment Planning System," </title> <type> Technical Report 91-10-03, </type> <institution> Radiation Oncology Department, University of Washington, </institution> <address> Seattle, WA, </address> <month> October 31, </month> <year> 1991. </year>
Reference-contexts: 1 Introduction We describe the software architecture of Prism, a system for radiation treatment planning <ref> [Kalet et al. 91] </ref>. The Prism architecture is based on the mediator approach to designing integrated systems [Sullivan and Notkin 92, Sullivan 94].
Reference: [Kalet et al. 92] <author> I. Kalet, J. Unger, C. Sweeney, S. Kromhout-Shiro, J. Jacky, and M. Niehaus, </author> <title> "Prism Graphical User Interface Specification," </title> <type> Technical Report 92-02-02, </type> <institution> Radiation Oncology Department, University of Washington, </institution> <address> Seattle, WA, March 18, </address> <year> 1992. </year>
Reference: [Kalet 92] <author> I. Kalet, </author> <title> "SLIK Programmer's Guide," </title> <type> Technical Report 92-02-01, </type> <institution> Radiation Oncology Department, University of Washington, </institution> <address> Seattle, WA, March 17, </address> <year> 1992. </year>
Reference-contexts: been far more difficult, even infeasible, to build a system meeting the requirements with the available resources using common design techniques. 5 The Mediator Approach to Designing Integrated Systems We detail the mediator method by using it to design a very simple integrated system|a user interface widget called a dialbox <ref> [Kalet 92] </ref>. Three such "subsystems" appear in the Prism beam panel (see Figure 1), the tool used to model a radiation beam. 5 to the patient. 6 The clock-like widgets along the top of the panel are dialboxes. They are used to orient the beam.
Reference: [Kalet 92c] <author> I. Kalet, </author> <title> "Artificial Intelligence Applications in Radiation Therapy," in Advances in Radiation Oncology Physics: Dosimetry, Treatment Planning, </title> <editor> and Brachyther-apy, J.A. Purdy, ed., </editor> <year> 1992, </year> <pages> pp. 1058-1085. </pages>
Reference-contexts: Third, to the extent that the functioning of earlier systems is rich and integrated, the software tends to be hard to develop and change. Despite its object-oriented structure, Kalet's second system did not accommodate the integration of AI-based planning tools <ref> [Kalet 92c, Paluszynski 89a] </ref>. Architectural inflexibility is a serious problem because it discourages the integration of rapidly evolving treatment planning capabilities. 4.2 Prism Prism was developed in an interdisciplinary collaboration between Sullivan and Notkin, software engineering researchers, and Kalet and his colleagues, radiotherapy planning researchers.
Reference: [Kernighan and Ritchie] <author> Kernighan and Ritchie, </author> <title> The C Programming Language, </title> <address> (Engle-wood Cliffs, N.J., </address> <year> 1978). </year>
Reference-contexts: In comparison to our core system, Kalet's first system has 47,000 Pascal lines. Kalet's second system has 41,000 lines of Pascal, 5,000 for dose distributions. Comparing with another system, the basic functions taking 18,000 lines in the original, core system take about 60,000 of C <ref> [Kernighan and Ritchie] </ref> and C++ [Ellis and Stroustrup 90] in GRATIS [Rosenman et al. 89], of which about 14,000 are for interface widgets.
Reference: [Kutcher 88] <author> G.J. Kutcher, R. Mohan, J.S. Laughlin, G. Barest, L. Brewster, C. Chue, C. Berman, and Z. Fuks, </author> <title> "Three Dimensional Radiation Treatment Planning," </title> <booktitle> Dosimetry in Radiotherapy: Proceedings of an International Symposium on Dosimetry in Radiotherapy 2, </booktitle> <address> Vienna, </address> <month> September, </month> <year> 1988, </year> <pages> pp. 39-63. 31 </pages>
Reference: [Lehman 84] <author> M.M. Lehman, </author> <title> "Program Evolution," </title> <editor> in M.M. Lehman and L.A. Belady, eds., </editor> <title> Program Evolution: Processes of Software Change, </title> <publisher> Academic Press, (London: Harcourt Brace Jovanovich), </publisher> <year> 1985, </year> <pages> pp. 9-38. </pages>
Reference-contexts: We are also confident that the key is that the method enables composition of visible, independent components into integrated systems using mediators as separate representations of semantically rich behavioral relationships. A related question is whether the approach eases software evolution <ref> [Lehman 84] </ref>. Of course, no design method will yield designs that accommodate arbitrary changes with ease. A method encourages the designer to make certain kinds designs decisions, meant by the framer of the method to produce particular properties in resulting designs, such as ease of change in particular dimensions.
Reference: [Meyer 88] <author> B. Meyer. </author> <title> Object-Oriented Software Construction, </title> <publisher> (Cambridge: Prentice-Hall), </publisher> <year> 1988. </year>
Reference-contexts: First, the system is well-structured with respect to accepted criteria: decomposition [Di-jkstra 65], information hiding [Parnas 72], modular continuity <ref> [Meyer 88] </ref>, etc. Prism is evidently factored into independent parts integrated by separate mediators representing abstract behavioral relationships; and system evolution has been straightforward. Second, we can ask the client, Kalet (admittedly a co-author) whether the mediator method helped significantly.
Reference: [Meyers 91] <author> S. Meyers, </author> <title> "Difficulties in Integrating Multiview Development Systems," </title> <journal> IEEE Software, </journal> <pages> pp. 49-57, </pages> <month> January, </month> <year> 1991. </year>
Reference-contexts: There are at least two problems with common uses of event mechanisms. First, the events components announce are often not declared in their interfaces. This makes it harder to reason about components by leaving key abstractions implicit <ref> [Reiss 90, Meyers 91] </ref>. Second, when objects must interact (e.g., when a change to a model should cause a view to update), one object often registers with and handles events from the other [Goldberg and Robson 83]. This compromises independence and represents the behavioral relationship implicitly.
Reference: [Notkin et al. 93] <author> D. Notkin, D. Garlan, W.G. Griswold, and K. Sullivan, </author> <title> "Adding Implicit Invocation to Languages: Three Approaches," </title> <booktitle> Proceedings of the JSSST International Symposium on Object Technologies for Advanced Software (November 1993). The proceedings appear as a Springer-Verlag Lecture Notes in Computer Science volume. </booktitle>
Reference-contexts: Fortunately, it is straightforward to implement ABTs in many languages. Object-oriented languages are especially well-suited, as they already support objects with operations in their interfaces. The problem then is to represent events in interfaces. Our solution is to represent events as attributes whose values are objects of event types <ref> [Notkin et al. 93] </ref>. 5.3.1 Implementing Events An event object maintains a set of notifications to be executed when the event is announced and exports operations to manipulate this set and to to announce the event.
Reference: [Paluszynski 89a] <author> W. Paluszynski, </author> <title> Designing Radiation Therapy for Cancer, an Approach to Knowledge-Based Optimization, </title> <type> Ph.D. Dissertation, </type> <institution> University of Washington, </institution> <year> 1990. </year>
Reference-contexts: Third, to the extent that the functioning of earlier systems is rich and integrated, the software tends to be hard to develop and change. Despite its object-oriented structure, Kalet's second system did not accommodate the integration of AI-based planning tools <ref> [Kalet 92c, Paluszynski 89a] </ref>. Architectural inflexibility is a serious problem because it discourages the integration of rapidly evolving treatment planning capabilities. 4.2 Prism Prism was developed in an interdisciplinary collaboration between Sullivan and Notkin, software engineering researchers, and Kalet and his colleagues, radiotherapy planning researchers.
Reference: [Parnas 72] <author> D. L. Parnas, </author> <title> "On the Criteria to Be Used in Decomposing Systems into Modules," </title> <journal> Communications of the ACM 5,12, </journal> <pages> pp. 1053-58, </pages> <month> December, </month> <year> 1972. </year>
Reference-contexts: Ease of change in all dimensions cannot be expected. 26 Information hiding|the identification and isolation of aspects of systems that tend to change independently|provided the basis for a method that produces systems that are robust with respect to changes in data structures and algorithms <ref> [Parnas 72] </ref>. The mediator method applies information hiding to different class of changes. We believe that integrated system tend to change independently in the set of behavioral components they comprise, the individual components, the set of behavioral relationships integrating the components, and the individual relationships. <p> First, the system is well-structured with respect to accepted criteria: decomposition [Di-jkstra 65], information hiding <ref> [Parnas 72] </ref>, modular continuity [Meyer 88], etc. Prism is evidently factored into independent parts integrated by separate mediators representing abstract behavioral relationships; and system evolution has been straightforward. Second, we can ask the client, Kalet (admittedly a co-author) whether the mediator method helped significantly.
Reference: [Reiss 90] <author> S. P. Reiss, </author> <title> "Connecting Tools using Message Passing in the Field Environment," </title> <journal> IEEE Software 7,4, </journal> <pages> pp. 57-66, </pages> <month> July, </month> <year> 1990. </year>
Reference-contexts: There are at least two problems with common uses of event mechanisms. First, the events components announce are often not declared in their interfaces. This makes it harder to reason about components by leaving key abstractions implicit <ref> [Reiss 90, Meyers 91] </ref>. Second, when objects must interact (e.g., when a change to a model should cause a view to update), one object often registers with and handles events from the other [Goldberg and Robson 83]. This compromises independence and represents the behavioral relationship implicitly.
Reference: [Rosenman et al. 89] <author> J. Rosenman, G.W. Sherouse, H. Fuchs, S. Pizer, A. Skinner, C. Mosher, K. Novins, and J. Tepper, </author> <title> "Three-dimensional Display Techniques in Radiation Therapy Treatment Planning", </title> <journal> International Journal of Radiation Oncology, Biology and Physics 16, </journal> <year> 1989, </year> <pages> pp. 263-269. </pages>
Reference-contexts: Kalet's second system has 41,000 lines of Pascal, 5,000 for dose distributions. Comparing with another system, the basic functions taking 18,000 lines in the original, core system take about 60,000 of C [Kernighan and Ritchie] and C++ [Ellis and Stroustrup 90] in GRATIS <ref> [Rosenman et al. 89] </ref>, of which about 14,000 are for interface widgets. Those functions taking 4,500 lines of Pascal in Prism, take about 12,000 lines of C in GRATIS. 1 Prism was built on a modest budget in person-hours and with a small project team.
Reference: [Scheifler and Gettys 86] <author> R.W. Scheifler and J. Gettys. </author> <title> "The X Window System," </title> <journal> ACM Transactions on Graphics, </journal> <volume> 5 ,2, </volume> <pages> pp. 79-109, </pages> <year> 1986. </year>
Reference-contexts: This modularization paid off when Kalet discovered that his initial design was unworkable. The problem was in incrementally updating contours drawn over background images in the X windows system <ref> [Scheifler and Gettys 86] </ref>. The behavioral relationship between objects and graphics had to be changed. The isolation of the graphics code in submediators enabled Kalet to fix the problem with no impact on the superstructure that deployed the submediators or on the objects related by the submediators.
Reference: [Steele 90] <author> G. Steele, Jr. </author> <title> COMMON LISP, </title> <booktitle> the Language, second edition, </booktitle> <address> (Burlington, MA: </address> <publisher> Digital Press), </publisher> <year> 1990. </year>
Reference-contexts: Figure 4 presents our Common Lisp <ref> [Steele 90] </ref> implementation of events as a CLOS [Bobrow et al. 88] type. The notification set is an association list that pairs operations to be implicitly invoked with the objects to which they are to be applied.
Reference: [Sullivan and Notkin 92] <author> K. Sullivan and D. Notkin, </author> <title> "Reconciling Environment Integration and Software Evolution," </title> <journal> ACM Transactions on Software Engineering and Methods, </journal> <volume> 1, 3, </volume> <month> July </month> <year> 1992. </year>
Reference-contexts: 1 Introduction We describe the software architecture of Prism, a system for radiation treatment planning [Kalet et al. 91]. The Prism architecture is based on the mediator approach to designing integrated systems <ref> [Sullivan and Notkin 92, Sullivan 94] </ref>. The problem addressed by this design method is that building integrated systems using common software design approaches leads to tight coupling of module definitions that significantly complicates software development and evolution. <p> Unfortunately, poorly integrated environments impose excessive burdens upon users, and small static environments are quickly outgrown [Taylor et al. 88, p. 2]." In earlier work, Sullivan and Notkin showed that common design methods unnecessarily complicate integrated system designs <ref> [Sullivan and Notkin 92, Sullivan 94] </ref>. In particular, design methods that take abstract data types (ADTs) as a basis for modularization do not handle integration requirements very well. Object-oriented extensions, such as classes, inheritance, polymorphism, dynamic binding, and multiple dispatch, do not overcome the basic problems. <p> When notified, the mediator checks the bit. If not set, the mediator sets it, does the update expecting to be re-notified in the process, and finally clears it. When notified during an update, the mediator just returns. We took this approach in Prism <ref> [Sullivan and Notkin 92, Sullivan 94] </ref>. 5.3 Implementing the System in Common Lisp/CLOS The problem now is to implement the behavioral ER model as a collection of ABT instances. Fortunately, it is straightforward to implement ABTs in many languages.
Reference: [Sullivan 94] <author> K. Sullivan, </author> <title> Reconciling Integration and Evolution: Behavioral Entity-Relationship Modeling and Design, </title> <type> Ph.D. Thesis, </type> <institution> University of Washington Department of Computer Science and Engineering Technical Report 94-08-01, </institution> <month> August </month> <year> 1994. </year>
Reference-contexts: 1 Introduction We describe the software architecture of Prism, a system for radiation treatment planning [Kalet et al. 91]. The Prism architecture is based on the mediator approach to designing integrated systems <ref> [Sullivan and Notkin 92, Sullivan 94] </ref>. The problem addressed by this design method is that building integrated systems using common software design approaches leads to tight coupling of module definitions that significantly complicates software development and evolution. <p> Unfortunately, poorly integrated environments impose excessive burdens upon users, and small static environments are quickly outgrown [Taylor et al. 88, p. 2]." In earlier work, Sullivan and Notkin showed that common design methods unnecessarily complicate integrated system designs <ref> [Sullivan and Notkin 92, Sullivan 94] </ref>. In particular, design methods that take abstract data types (ADTs) as a basis for modularization do not handle integration requirements very well. Object-oriented extensions, such as classes, inheritance, polymorphism, dynamic binding, and multiple dispatch, do not overcome the basic problems. <p> To begin to address these problems, the mediator method first adopts the abstract behavioral type (ABT) as a basic module construct. An ABT abstractly defines a class of objects in terms both the operations the objects support and the events they announce <ref> [Sul-livan and Notkin 92, Sullivan 94] </ref>. (Other approaches based on a similar idea include TICKLE [Collins et al. 91] and the ISO "MIM" [ISO MIM 91].) Next, we implement the behavioral components of behavioral ER models as independent, visible ABT-based objects whose events and operations suffice to support their clients. <p> When notified, the mediator checks the bit. If not set, the mediator sets it, does the update expecting to be re-notified in the process, and finally clears it. When notified during an update, the mediator just returns. We took this approach in Prism <ref> [Sullivan and Notkin 92, Sullivan 94] </ref>. 5.3 Implementing the System in Common Lisp/CLOS The problem now is to implement the behavioral ER model as a collection of ABT instances. Fortunately, it is straightforward to implement ABTs in many languages.
Reference: [Taylor et al. 88] <author> R.N. Taylor, R.W. Selby, M. Young, F.C. Belz, L.A. Clarke, J.C. Wile-den, L. Osterweil, A.L. Wolf, </author> <title> "Foundations for the Arcadia Environment Architecture," </title> <booktitle> Proceedings of ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <editor> P. Henderson, Ed., </editor> <address> Boston, Massachusetts, </address> <month> November 28-30, </month> <year> 1988, </year> <pages> pp. 1-13. 32 </pages>
Reference-contexts: Conversely, broad 2 and dynamic environments are typically loosely coupled and poorly integrated. Unfortunately, poorly integrated environments impose excessive burdens upon users, and small static environments are quickly outgrown <ref> [Taylor et al. 88, p. 2] </ref>." In earlier work, Sullivan and Notkin showed that common design methods unnecessarily complicate integrated system designs [Sullivan and Notkin 92, Sullivan 94]. In particular, design methods that take abstract data types (ADTs) as a basis for modularization do not handle integration requirements very well.
References-found: 32

