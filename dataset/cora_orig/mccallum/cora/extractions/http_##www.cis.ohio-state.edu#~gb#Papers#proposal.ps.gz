URL: http://www.cis.ohio-state.edu/~gb/Papers/proposal.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~gb/Papers/
Root-URL: 
Email: gb@cs.purdue.edu  
Title: Module Constructs for Object-Oriented and Functional Programming Languages  
Author: Gerald Baumgartner 
Degree: Dissertation Proposal  
Date: January 1, 1993  
Address: West Lafayette, IN 47907  
Affiliation: Department of Computer Sciences Purdue University  
Abstract: Object-oriented languages offer mechanisms to help structure large programs. However, the semantics of these constructs are often not very precisely defined. For example, the use of inheritance as a substitute for subtype polymorphism in many object-oriented languages either leads to an unsound or a too inflexible type system. In addition, ideas from module constructs of functional languages could increase the expressiveness of object-oriented languages and vice versa. We propose to design module constructs incorporating the best features found among module constructs of object-oriented languages and of functional languages. In particular, we plan to incorporate parametric polymorphism, subtype polymorphism, overloading, type abstraction, and compile-time type inference in a semantically clean manner. We try to achieve this with a minimum amount of declarations required from the programmer and a minimum amount of run-time type information.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping Recursive Types. </title> <type> DEC SRC Report 62, </type> <institution> Systems Research Center, Digital Equipment Corporation, Palo Alto, California, </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: Instead of defining a method inside a class, methods are only declared in a class and initialized with a top-level function constant. Virtual methods are not supported. The language offers structural type equivalence, including structural type equivalence of infinite expansions of recursive types <ref> [1, 2] </ref>, and subtyping with predefined subtype relationships for built-in types. Subtyping is independent of the inheritance hierarchy. Separate from classes, Modula-3 offers module constructs that allow, according to our terminology, the definition of objects. These modules cannot be instantiated and don't have inheritance.
Reference: [2] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> "Subtyping Recursive Types." </title> <booktitle> In Conference Record of the 18th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Orlando, Florida, </address> <month> 21-23 January </month> <year> 1991, </year> <pages> pp. 104-118. </pages>
Reference-contexts: Instead of defining a method inside a class, methods are only declared in a class and initialized with a top-level function constant. Virtual methods are not supported. The language offers structural type equivalence, including structural type equivalence of infinite expansions of recursive types <ref> [1, 2] </ref>, and subtyping with predefined subtype relationships for built-in types. Subtyping is independent of the inheritance hierarchy. Separate from classes, Modula-3 offers module constructs that allow, according to our terminology, the definition of objects. These modules cannot be instantiated and don't have inheritance.
Reference: [3] <author> Pierre America and Frank van der Linden. </author> <title> "A parallel object-oriented language with inheritance and subtyping." </title> <booktitle> In Proceedings of the OOP-SLA '90 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> Ottawa, Canada, </address> <month> 21-25 October </month> <year> 1990. </year> <journal> SIG-PLAN Notices, </journal> <volume> Vol. 25, No. 10, </volume> <month> October </month> <year> 1990, </year> <pages> pp. 161-168. </pages>
Reference-contexts: However, they can be parameterized and allow the separation of interface and implementation. The latter corresponds to our notion of type abstraction if modules are considered types with one element. Modula-3 provides opaque types, i.e., types with hidden components, as a means of data abstraction. 3.8 POOL-I POOL-I <ref> [3] </ref> is a strongly typed object-oriented language with parameterized classes, parameterized signatures, multiple inheritance, and subtyping de-coupled from inheritance. In addition to methods and fields, objects can 8 contain a process which is executed in parallel with the processes of other objects. Processes are not inherited.
Reference: [4] <author> Gerald Baumgartner and Vincent F. Russo. </author> <title> "Type abstraction and subtype polymorphism for object-oriented languages." </title> <booktitle> Submitted to the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <address> Albuquerque, New Mexico, </address> <month> June 23-25, </month> <year> 1993. </year>
Reference-contexts: By asking programmers to provide a modest amount of declarations in strategic places and by having some limited type information available at run time it should be possible to combine the best features of object-oriented and functional module constructs. Preliminary results in extending C++ modules <ref> [4] </ref> suggest that this can be done. Following we present motivation from our paper [4] why the module system should be incorporated with the type system while keeping subtyping and inheritance separated. <p> Preliminary results in extending C++ modules <ref> [4] </ref> suggest that this can be done. Following we present motivation from our paper [4] why the module system should be incorporated with the type system while keeping subtyping and inheritance separated. We also use our example from [6] to demonstrate the need for flexibility in structuring programs that goes beyond the capa 2 bilities of many object-oriented languages. <p> We also use our example from [6] to demonstrate the need for flexibility in structuring programs that goes beyond the capa 2 bilities of many object-oriented languages. Another example demonstrating the limitations of object-oriented languages can be found in [16] and in <ref> [4] </ref>. In the next two sections we review and define some terminology and then discuss module constructs found in several existing languages. Following that we outline our ideas for designing and implementing module constructs. 1.1 Incorporating Types and Modules Mathematically speaking, a type is a set of values. <p> Furthermore, making classes first-class objects requires a higher amount of run-time type information and makes the type system more complex since other types are not mentioned to be first-class. Based on our experience of adding a signature construct to C++ <ref> [4, 16] </ref> and separating subtyping from inheritance, we believe that it is possible to design module constructs to offer the best features from both the functional world and the object-oriented world. <p> Objects as elements of an abstract type are then accessed with a signature pointer containing a pointer to the object itself and a pointer to the signature table 1 . For details and for design alternatives see <ref> [4] </ref>. We propose to implement our module constructs in a preprocessor to ML. <p> See the release information for our implementation [5] for an explanation of the differences between the description in <ref> [4] </ref> and the implementation. 11 6 Conclusions We proposed the design of module constructs that combine the best features of the module constructs found in functional languages and object-oriented languages.
Reference: [5] <author> Gerald Baumgartner and Vince Russo. README. </author> <note> Available by anonymous ftp from ftp.cs.purdue.edu, directory pub/gb, </note> <institution> Department of Computer Sciences, Purdue University, </institution> <year> 1992. </year>
Reference-contexts: See the release information for our implementation <ref> [5] </ref> for an explanation of the differences between the description in [4] and the implementation. 11 6 Conclusions We proposed the design of module constructs that combine the best features of the module constructs found in functional languages and object-oriented languages.
Reference: [6] <author> Gerald Baumgartner and Ryan D. Stansifer. </author> <title> A Proposal to Study Type Systems for Computer Algebra. </title> <type> RISC-Linz Report 90-87.0, </type> <institution> Research Institute for Symbolic Computation, Linz, Austria, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: Preliminary results in extending C++ modules [4] suggest that this can be done. Following we present motivation from our paper [4] why the module system should be incorporated with the type system while keeping subtyping and inheritance separated. We also use our example from <ref> [6] </ref> to demonstrate the need for flexibility in structuring programs that goes beyond the capa 2 bilities of many object-oriented languages. Another example demonstrating the limitations of object-oriented languages can be found in [16] and in [4]. <p> Most programming languages choose therefore to restrict the power of inheritance. 1.2 Computer Algebra Using an example from computer algebra <ref> [6] </ref>, we demonstrate that a complex type hierarchy cannot be modeled by a class hierarchy. In computer algebra, the distinction between abstract types and concrete types arises naturally. Typical abstract types are group, ring, field, or euclidean-domain, while typical concrete types are integer, fraction, or distributed-polynomial.
Reference: [7] <author> Andrew Black, Norman Hutchinson, Eric Jul, and Henry Levy. </author> <title> "Object structure in the Emerald system." </title> <booktitle> In Proceedings of the OOPSLA '86 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> Portland, Oregon, </address> <month> 29 September - 2 October </month> <year> 1986. </year> <journal> SIG-PLAN Notices, </journal> <volume> Vol. 21, No. 11, </volume> <month> November, </month> <pages> pp. 78-86. </pages>
Reference-contexts: Objects need to be passed explicitly as the first argument of methods. Full type checking is done at compile time, but type information is also available at run time. 3.4 Emerald Emerald <ref> [7] </ref> provides objects and abstract types with multiple inheritance. It does not provide classes, but since it has first class types, it is possible to write objects that create other objects. These object-creators take on the role of classes. Emerald is strongly typed and provides subtyping.
Reference: [8] <author> Peter S. Canning, William R. Cook, Walter L. Hill, and Walter G. Olthoff. </author> <title> "Interfaces for strongly-typed object-oriented programming." </title> <booktitle> In Proceedings of OOPSLA '89 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> New Orleans, Louisiana, </address> <month> 1-6 October </month> <year> 1989. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. 24, No. 10, </volume> <month> Oc-tober </month> <year> 1989, </year> <pages> pp. 457-467. 15 </pages>
Reference-contexts: The solution is to factor out the implementation aspects of classes into prototypical objects [19] or to factor out the type aspects into interfaces <ref> [8, 11] </ref>. 2 Terminology Different programming languages use different semantics of their module constructs.
Reference: [9] <author> Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, Greg Nelson. </author> <title> "Modula-3 Language Definition." </title> <journal> ACM SIG-PLAN Notices, </journal> <volume> Vol. 27, No. 8, </volume> <month> August </month> <year> 1992, </year> <pages> pp. 15-43. </pages>
Reference-contexts: The inheritance hierarchy is used for subtyping purposes; since Eif-fel allows to rename methods when inheriting them, subtyping is unsound. A noteworthy feature of Eiffel is that the programmer can specify preconditions and postconditions of methods and class invariants. 3.7 Modula-3 Modula-3 <ref> [9] </ref> is an object-oriented systems programming language with single inheritance. Instead of defining a method inside a class, methods are only declared in a class and initialized with a top-level function constant. Virtual methods are not supported.
Reference: [10] <author> Luca Cardelli and Peter Wegner. </author> <title> "On understanding types, data abstraction, and polymorphism." </title> <journal> Computing Surveys, </journal> <volume> Vol. 17, No. 4, </volume> <month> De-cember </month> <year> 1985, </year> <pages> pp. 471-522. </pages>
Reference-contexts: Type inference Type inferences refers to deducing the type of variables which have not been declared from the context. The following terminology refers to ways to achieve strong typing without limiting ourselves to static typing. The definitions are similar to the ones found in Cardelli and Wegner <ref> [10] </ref>: Polymorphism A language is said to be polymorphic if some values and variables may have more than one concrete type. A polymorphic function is a function whose arguments can have more than one concrete type.
Reference: [11] <author> William R. Cook. </author> <title> "Interfaces and specifications for the Smalltalk-80 collection classes." </title> <booktitle> In Proceedings of OOPSLA '92 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> Vancou-ver, Canada, </address> <month> 18-22 October </month> <year> 1992. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. 27, No. 10, </volume> <month> October </month> <year> 1992, </year> <pages> pp. 1-15. </pages>
Reference-contexts: The solution is to factor out the implementation aspects of classes into prototypical objects [19] or to factor out the type aspects into interfaces <ref> [8, 11] </ref>. 2 Terminology Different programming languages use different semantics of their module constructs.
Reference: [12] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> "Inheritance is not subtyping." </title> <booktitle> In Proceedings of 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, </address> <month> 17-19 January </month> <year> 1990, </year> <pages> pp. 125-135. </pages>
Reference-contexts: However, a class is also used to specify the implementation of the type. In addition, class inheritance is often used for purposes of both reusing the implementation of the superclass and subtyping. Since inheritance and subtyping are semantically different <ref> [12] </ref>, this either weakens the expressiveness of the language or leads to type insecurities. An example from [30] illustrates this point. Consider two abstract types stack and dequeue (doubly ended queue). <p> A stack implementation could then just copy the doubly ended queue implementation and remove the additional operations. 3 In order for the type system to be sound it is not possible to use in-heritance for subtyping purposes and also allow the removal of operations <ref> [12] </ref>. Most programming languages choose therefore to restrict the power of inheritance. 1.2 Computer Algebra Using an example from computer algebra [6], we demonstrate that a complex type hierarchy cannot be modeled by a class hierarchy. In computer algebra, the distinction between abstract types and concrete types arises naturally.
Reference: [13] <author> James Donahue and Alan Demers. </author> <title> "Data types are values." </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 7, No. 3, </volume> <month> July </month> <year> 1985, </year> <pages> pp. 426-445. </pages>
Reference-contexts: Except for the tables for virtual method lookup no run-time type information is needed. In addition, C++ allows the programmer to overload functions and to define coercions that are automatically applied by the compiler if needed. 3.2 Russel According to our definition, Russel <ref> [13] </ref> is not an object-oriented language, but it has an interesting and radical type system. Russel does not have concrete types, only abstract types are provided. Russel defines a type to be a set of functions. Type information is used to interpret values drawn from un untyped universe.
Reference: [14] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <address> Reading, Massachusetts: </address> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Other object-oriented languages have been designed by incorporating the module constructs with the type system, but their module system is either less expressive, such as in C++ <ref> [14] </ref>, or their type system is unsound, such as in Eiffel [24]. On the other hand, in the functional programming language community, modules with different characteristics were developed, for example, ML's module system [21] with its parametric polymorphism. <p> a programming language, they are often left out and replaced by property names or only by comments. 3 Modules in Existing Languages In this section we give a short overview of the different language constructs and mechanisms provided in a range of object-oriented and functional programming languages. 3.1 C++ C++ <ref> [14] </ref> is probably the most widely used object-oriented language today. It provides classes with multiple inheritance and data abstraction using public, private, and subtype-visible (protected) declarations. Classes can be parameterized with type parameters. The inheritance hierarchy is used for subtyping purposes. C++ is strongly typed and supports virtual methods.
Reference: [15] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <address> Reading, Massachusetts: </address> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: 1 Introduction Module constructs are generally considered an important tool for helping structure large programs. Most modern programming languages, therefore, provide some kind of module constructs. 1 Smalltalk-80 <ref> [15] </ref> popularized a module concept that treats data as life entities, called objects, that are communicating by sending messages. This design proved very useful and intuitive for organizing large programs. Since then many other languages have been designed using similar module constructs; such languages are called object-oriented languages. <p> Pressing these implementations into the same hierarchy as the abstract types requires duplication of code to use the appropriate implementation for both general matrices and positive definite matrices. Similar arguments have been given in the literature that the collection class hierarchy of Smalltalk-80 <ref> [15] </ref> is not appropriate as a basis for sub-typing. While the problem does not arise with dynamic typing, it becomes an issue when trying to make Smalltalk-80 statically typed while retaining most of its flexibility.
Reference: [16] <author> Elana D. Granston and Vincent F. Russo. "Signature-based polymor-phism for C++." </author> <booktitle> In Proceedings of the USENIX C++ Technical Conference, </booktitle> <address> Washington, D.C., </address> <year> 1991. </year>
Reference-contexts: We also use our example from [6] to demonstrate the need for flexibility in structuring programs that goes beyond the capa 2 bilities of many object-oriented languages. Another example demonstrating the limitations of object-oriented languages can be found in <ref> [16] </ref> and in [4]. In the next two sections we review and define some terminology and then discuss module constructs found in several existing languages. <p> Furthermore, making classes first-class objects requires a higher amount of run-time type information and makes the type system more complex since other types are not mentioned to be first-class. Based on our experience of adding a signature construct to C++ <ref> [4, 16] </ref> and separating subtyping from inheritance, we believe that it is possible to design module constructs to offer the best features from both the functional world and the object-oriented world.
Reference: [17] <author> Paul Hudak and Joseph H. Fasel. </author> <title> "A gentle introduction to Haskell." </title> <journal> ACM SIGPLAN Notices, </journal> <volume> Vol. 27, No. 5, </volume> <month> May </month> <year> 1992, </year> <institution> Section T. </institution>
Reference-contexts: However, it has not been shown yet how to extend type inference to these module constructs, and no implementation exists so far. The provision for first-class classes will make a run-time representation of types necessary. 3.10 Haskell Haskell <ref> [17, 18] </ref> is a lazy, purely functional language based on a similar type system as ML. Like ML, it supports parametric polymorphism and its compiler infers types of expressions.
Reference: [18] <editor> Paul Hudak et al. </editor> <title> "Report on the programming Language Haskell: A non-strict, purely functional language, version 1.2." </title> <journal> ACM SIGPLAN Notices, </journal> <volume> Vol. 27, No. 5, </volume> <month> May </month> <year> 1992, </year> <note> Section R. </note>
Reference-contexts: However, it has not been shown yet how to extend type inference to these module constructs, and no implementation exists so far. The provision for first-class classes will make a run-time representation of types necessary. 3.10 Haskell Haskell <ref> [17, 18] </ref> is a lazy, purely functional language based on a similar type system as ML. Like ML, it supports parametric polymorphism and its compiler infers types of expressions.
Reference: [19] <author> Wilf R. LaLonde, Dave A. Thomas, and John R. Pugh. </author> <title> "An exemplar based Smalltalk." </title> <booktitle> In Proceedings of OOPSLA '86 Conference on 16 Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> Portland, Oregon, </address> <month> 29 September - 2 October </month> <year> 1986. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. 21, No. 11, </volume> <month> November, </month> <pages> pp. 322-330. </pages>
Reference-contexts: While the problem does not arise with dynamic typing, it becomes an issue when trying to make Smalltalk-80 statically typed while retaining most of its flexibility. The solution is to factor out the implementation aspects of classes into prototypical objects <ref> [19] </ref> or to factor out the type aspects into interfaces [8, 11]. 2 Terminology Different programming languages use different semantics of their module constructs.
Reference: [20] <author> Konstantin Laufer. </author> <title> Polymorphic Type Inference and Abstract Data Types. </title> <type> Ph.D. thesis, </type> <address> New York University, </address> <year> 1992. </year>
Reference-contexts: Syntactically, a type class consists of a list of function signatures. Semantically, a type class is the type of types. That is, both user-defined types and built-in types are instances of type classes. In addition, Haskell provides overloading. In <ref> [20] </ref>, Laufer presents an extension of both Haskell and ML with first-class abstract types by extending the type system with existential types. 4 Design of New Module Constructs All of the module concepts listed above lack some features. None of the object-oriented languages has parametric polymorphism.
Reference: [21] <author> David B. MacQueen. </author> <title> "Modules for Standard ML." </title> <journal> Polymorphism, </journal> <volume> Vol. 2, No. 2, </volume> <year> 1985. </year>
Reference-contexts: On the other hand, in the functional programming language community, modules with different characteristics were developed, for example, ML's module system <ref> [21] </ref> with its parametric polymorphism. Traditionally, the emphasis in the object-oriented programming language community has been on efficient implementation, while the emphasis in the functional language community has been on a semantically clean design and on type inference. <p> For a class to conform to a signature, the class needs to define the same property names. POOL-I offers constructs to automatically create get-value and/or put-value methods for fields declared in a class. 3.9 ML ML [25, 26] is an eager functional language with an elaborate module system <ref> [21, 22] </ref> based on the dependent types of Martin Lof's intuitionistic type theory [23]. The ML core language, i.e., ML without modules, offers a restricted form of parametric polymorphism. The restriction is that polymorphic functions cannot be used as arguments to functions.
Reference: [22] <author> David B. MacQueen. </author> <title> "An implementation of Standard ML modules." </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, </booktitle> <address> Snowbird, Utah, </address> <month> 25-27 July </month> <year> 1988. </year> <journal> Association for Computing Machinery, </journal> <pages> pp. 212-223. </pages>
Reference-contexts: For a class to conform to a signature, the class needs to define the same property names. POOL-I offers constructs to automatically create get-value and/or put-value methods for fields declared in a class. 3.9 ML ML [25, 26] is an eager functional language with an elaborate module system <ref> [21, 22] </ref> based on the dependent types of Martin Lof's intuitionistic type theory [23]. The ML core language, i.e., ML without modules, offers a restricted form of parametric polymorphism. The restriction is that polymorphic functions cannot be used as arguments to functions.
Reference: [23] <author> Per Martin Lof. </author> <title> "Constructive mathematics and computer programming." </title> <booktitle> In Proceedings of the 6th International Congress for Logic, Methodology, and Philosophy of Science. </booktitle> <address> Amsterdam: </address> <publisher> North Holland, </publisher> <year> 1982, </year> <pages> pp. 153-175. </pages>
Reference-contexts: POOL-I offers constructs to automatically create get-value and/or put-value methods for fields declared in a class. 3.9 ML ML [25, 26] is an eager functional language with an elaborate module system [21, 22] based on the dependent types of Martin Lof's intuitionistic type theory <ref> [23] </ref>. The ML core language, i.e., ML without modules, offers a restricted form of parametric polymorphism. The restriction is that polymorphic functions cannot be used as arguments to functions. <p> Universal polymorphism Universal polymorphism refers to either para metric polymorphism or subtype polymorphism. Ad-hoc polymorphism Ad-hoc polymorphism refers to either overload ing or coercion. According to Martin Lof's intuitionistic type theory <ref> [23] </ref>, types can be represented by arbitrary propositions, using primitive types such as integer as atoms together with type constructors, the logical connectors ^, _, !, and bounded and unbounded universal and existential quantification. For analyzing object-oriented language constructs, we are particularly interested in quantified types.
Reference: [24] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <address> New York, New York: </address> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: Other object-oriented languages have been designed by incorporating the module constructs with the type system, but their module system is either less expressive, such as in C++ [14], or their type system is unsound, such as in Eiffel <ref> [24] </ref>. On the other hand, in the functional programming language community, modules with different characteristics were developed, for example, ML's module system [21] with its parametric polymorphism. <p> Unlike most object-oriented languages, method dispatch is not only performed based on the first argument of a method but based on all arguments and on the return type. Scratch-pad is strongly typed, but it requires full run-time type information for method dispatch. 3.6 Eiffel Eiffel <ref> [24] </ref> is a small typed object-oriented language with multiple inheritance. The inheritance hierarchy is used for subtyping purposes; since Eif-fel allows to rename methods when inheriting them, subtyping is unsound.
Reference: [25] <author> Robin Milner and Mads Tofte. </author> <title> Commentary on Standard ML. </title> <address> Cam-bridge, Massachusetts: </address> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Signatures can contain property names. For a class to conform to a signature, the class needs to define the same property names. POOL-I offers constructs to automatically create get-value and/or put-value methods for fields declared in a class. 3.9 ML ML <ref> [25, 26] </ref> is an eager functional language with an elaborate module system [21, 22] based on the dependent types of Martin Lof's intuitionistic type theory [23]. The ML core language, i.e., ML without modules, offers a restricted form of parametric polymorphism. <p> Ideas for a type system can be found in intuitionistic type theory, denotational semantics, category theory, and in algebraic specification. We propose to design our module constructs as an extension of ML, since the formal definition of ML <ref> [25, 26] </ref> provides us with a formal framework that gives guidance in designing the type system.
Reference: [26] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The definition of Standard ML. </title> <address> Cambridge, Massachusetts: </address> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Signatures can contain property names. For a class to conform to a signature, the class needs to define the same property names. POOL-I offers constructs to automatically create get-value and/or put-value methods for fields declared in a class. 3.9 ML ML <ref> [25, 26] </ref> is an eager functional language with an elaborate module system [21, 22] based on the dependent types of Martin Lof's intuitionistic type theory [23]. The ML core language, i.e., ML without modules, offers a restricted form of parametric polymorphism. <p> Ideas for a type system can be found in intuitionistic type theory, denotational semantics, category theory, and in algebraic specification. We propose to design our module constructs as an extension of ML, since the formal definition of ML <ref> [25, 26] </ref> provides us with a formal framework that gives guidance in designing the type system.
Reference: [27] <author> John Mitchell, Sigurd Meldal, and Neel Madhav. </author> <title> "An extension of Standard ML modules with subtyping and inheritance." </title> <booktitle> In Conference Record of the 18th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Orlando, Florida, </address> <month> 21-23 January </month> <year> 1991, </year> <pages> pp. 270-278. </pages>
Reference-contexts: See, for example, the papers by Remy [28], Stansifer [31], and Wand [33]. Mitchell, Meldal, and Madhav <ref> [27] </ref> propose to extend ML modules with subtyping and inheritance. This extension would make ML an object-oriented language with a flexible form of multiple inheritance, parameterized signatures containing function signatures and axioms, functors, first-class 9 classes, and subtyping.
Reference: [28] <author> Didier Remy. </author> <title> "Typechecking records and variants in a natural extension of ML." </title> <booktitle> In Conference Record of the 16th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1989, </year> <pages> pp. 60-76. </pages>
Reference-contexts: Most of these attempts concentrate on introducing subtyping into the ML core language by providing extendable record types similar to classes with inheritance, and on extending type inference to handle extendable record types. See, for example, the papers by Remy <ref> [28] </ref>, Stansifer [31], and Wand [33]. Mitchell, Meldal, and Madhav [27] propose to extend ML modules with subtyping and inheritance. This extension would make ML an object-oriented language with a flexible form of multiple inheritance, parameterized signatures containing function signatures and axioms, functors, first-class 9 classes, and subtyping.
Reference: [29] <author> Craig Schaffert et al. </author> <title> "An introduction to Trellis/Owl." </title> <booktitle> In Proceedings of the OOPSLA '86 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> Portland, Oregon, </address> <month> 29 September-2 October </month> <year> 1986. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. 21, No. 11, </volume> <month> November, </month> <pages> pp. 9-16. 17 </pages>
Reference-contexts: is available as a consequence of using values from an untyped universe, but Russel offers implementation independence which is a notion similar to our notion of type abstraction. 6 By introducing some syntactic constraints it is assured that Russel programs can be fully type-checked at compile type. 3.3 Trellis/Owl Trellis/Owl <ref> [29] </ref> is an object-oriented language with multiple inheritance. Data abstraction is achieved by providing public, private, and subtype-visible declarations. Classes have two parts, a specification part and an implementation part. Only the specification part, i.e., only the function signatures of public methods are inherited.
Reference: [30] <author> Alan Snyder. </author> <title> "Encapsulation and inheritance in object-oriented pro-gramming languages." </title> <booktitle> In Proceedings of OOPSLA '86 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> Portland, Oregon, </address> <month> 29 September - 2 October </month> <year> 1986. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. 21, No. 11, </volume> <month> November, </month> <pages> pp. 38-45. </pages>
Reference-contexts: In addition, class inheritance is often used for purposes of both reusing the implementation of the superclass and subtyping. Since inheritance and subtyping are semantically different [12], this either weakens the expressiveness of the language or leads to type insecurities. An example from <ref> [30] </ref> illustrates this point. Consider two abstract types stack and dequeue (doubly ended queue). The abstract type dequeue provides the same operations as stack and in addition two operations for pushing and popping elements at the bottom of the stack. Therefore, dequeue is a subtype of stack.
Reference: [31] <author> Ryan Stansifer. </author> <title> "Type inference with subtypes." </title> <booktitle> In Conference Record of the 15th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, </address> <month> January </month> <year> 1988. </year>
Reference-contexts: Most of these attempts concentrate on introducing subtyping into the ML core language by providing extendable record types similar to classes with inheritance, and on extending type inference to handle extendable record types. See, for example, the papers by Remy [28], Stansifer <ref> [31] </ref>, and Wand [33]. Mitchell, Meldal, and Madhav [27] propose to extend ML modules with subtyping and inheritance. This extension would make ML an object-oriented language with a flexible form of multiple inheritance, parameterized signatures containing function signatures and axioms, functors, first-class 9 classes, and subtyping.
Reference: [32] <author> Robert S. Sutor and Richard D. Jenks. </author> <title> "The type inference and coercion facilities in the Scratchpad II interpreter." </title> <booktitle> In Proceedings of the SIG-PLAN '87 Symposium on Interpreters and Interpretive Techniques, </booktitle> <month> 24-26 June </month> <year> 1987, </year> <title> St. Paul, Minnesota. </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. 22, No. 7, </volume> <year> 1987, </year> <pages> pp. 56-63. </pages>
Reference-contexts: Emerald is strongly typed and provides subtyping. Abstract types can have multiple implementations; there is no facility for data abstraction. The main innovation of Emerald is that objects can be moved between machines. To help achieve that full run-time type information is provided. 3.5 Scratchpad II Scratchpad <ref> [32, 34] </ref>, a language designed for computer algebra, allows to write parameterized classes and provides a construct similar to parameterized signatures called category. Semantically, however, a category is not an abstract type containing objects but a higher-order type containing class types.
Reference: [33] <author> Mitchell Wand. </author> <title> "Complete type inference for simple objects." </title> <booktitle> In Proceedings of the 2nd IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1987, </year> <pages> pp. 37-44. </pages> <booktitle> Corrigendum in Proceedings of the 3rd IEEE Symposium on Logic in Computer science, </booktitle> <year> 1988, </year> <note> p. 132. </note>
Reference-contexts: Most of these attempts concentrate on introducing subtyping into the ML core language by providing extendable record types similar to classes with inheritance, and on extending type inference to handle extendable record types. See, for example, the papers by Remy [28], Stansifer [31], and Wand <ref> [33] </ref>. Mitchell, Meldal, and Madhav [27] propose to extend ML modules with subtyping and inheritance. This extension would make ML an object-oriented language with a flexible form of multiple inheritance, parameterized signatures containing function signatures and axioms, functors, first-class 9 classes, and subtyping.
Reference: [34] <author> Stephen M. Watt, Richard D. Jenks, Robert S. Sutor, and Barry M. Trager. </author> <title> The Scratchpad II Type System: Domains and Subdomains. </title> <type> Manuscript, </type> <institution> Mathematical Sciences Department, IBM Thomas J. Wat-son Research Center, </institution> <address> Yorktown Heights, NY, </address> <year> 1987. </year>
Reference-contexts: Emerald is strongly typed and provides subtyping. Abstract types can have multiple implementations; there is no facility for data abstraction. The main innovation of Emerald is that objects can be moved between machines. To help achieve that full run-time type information is provided. 3.5 Scratchpad II Scratchpad <ref> [32, 34] </ref>, a language designed for computer algebra, allows to write parameterized classes and provides a construct similar to parameterized signatures called category. Semantically, however, a category is not an abstract type containing objects but a higher-order type containing class types.
Reference: [35] <author> Peter Wegner. </author> <title> "Dimensions of object-based language design." </title> <booktitle> In Proceedings of OOPSLA '87 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> Orlando, Florida, </address> <month> 4-8 October </month> <year> 1987. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. 22, No. 12, </volume> <month> December </month> <year> 1987, </year> <pages> pp. 168-182. </pages>
Reference-contexts: These three concepts are generally considered the main ingredients of object-oriented languages. For example, Wegner <ref> [35] </ref> defines object-oriented = objects + classes + inheritance Objects and classes allow a programming style in which code is organized by data type instead of by functionality, which is helpful in structuring big programs. The use of inheritance allows reuse of existing code.
Reference: [36] <author> Niklaus Wirth. </author> <title> Programming in Modula-2. </title> <booktitle> Texts and Monographs in Computer Science. </booktitle> <address> Berlin-Heidelberg, Germany: </address> <publisher> Springer Verlag, </publisher> <year> 1985. </year> <month> 18 </month>
Reference-contexts: ML compilers infer the types of all variables except in cases involving overloaded built-in functions such as `+.' At run-time, no type information is available. The ML module system consists of constructs similar to implementation modules and definition modules in Modula-2 <ref> [36] </ref>. In addition, ML supports a form of function, called functor, that takes implementation modules as arguments and returns them as result. The effect of using functors is similar to using parameterized modules. Both functors and datatype declarations in the core language can be used to achieve data abstraction.
References-found: 36

