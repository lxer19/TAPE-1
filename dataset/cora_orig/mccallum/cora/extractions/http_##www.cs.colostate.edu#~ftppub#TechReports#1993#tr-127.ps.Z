URL: http://www.cs.colostate.edu/~ftppub/TechReports/1993/tr-127.ps.Z
Refering-URL: http://www.cs.colostate.edu/~ftppub/
Root-URL: 
Affiliation: Department of Computer Science Colorado State University  
Abstract: Uniqueness Analysis of Array Comprehensions Using the Omega Test David Garza and Wim Bohm Technical Report CS-93-127 October 21, 1993 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Steven Anderson and Paul Hudak. </author> <title> Compilation of Haskell Array Comprehensions for Scientific Computing. </title> <booktitle> In Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 137-149, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Some functional languages, such as Haskell, Id, and Sisal [4, 10, 13], have been designed to be used for scientific computing. Even though there have been significant improvements in the implementation of arrays for these languages <ref> [6, 2, 7, 1] </ref>, there are still several problems that have not been addressed. An array comprehension is a functional monolithic array constructor, defining an array as a whole entity. <p> Step 3 generates the constraints that check if there are any two overlapping regions. 9 5.2.1 Example We apply algorithm 3 to the following array comprehension: A=- 1D_array (1..2m) of | <ref> [1] </ref> = 1 %region 1 | [2*i] = i || i = 1 to m %region 2 | [2*j+1] = j || j = 1 to m-1- %region 3 Step 2 generates the following constraints: for region 1 step 2b generates no constraints, step 2c creates the constraint 1 x 1 <p> Secondly they introduce a data structure called atom which contains information about the array references and it is used to propagate this information to the calling procedure. Hudak and Anderson <ref> [1] </ref> propose the use of subscript analysis for functional monolithic arrays. They recognize the uniqueness problem which they call Detecting Write Collisions, and they propose the use of Banerjee Inequalities test to check for independence. <p> Besides uniqueness analysis there are other compile time checks that can be performed to reduce run-time inefficiencies of functional arrays. Currently we are studying the following problems: * Completeness Analysis: An efficiency problem of strict arrays, previously identified by Hudak and Anderson <ref> [1] </ref>, is that a check is needed to ensure that the whole array is defined.
Reference: [2] <author> Arvind and Rishiyur S. Nikhil. I-Structures: </author> <title> Data Structures for Parallel Computing. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(4) </volume> <pages> 598-632, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: Some functional languages, such as Haskell, Id, and Sisal [4, 10, 13], have been designed to be used for scientific computing. Even though there have been significant improvements in the implementation of arrays for these languages <ref> [6, 2, 7, 1] </ref>, there are still several problems that have not been addressed. An array comprehension is a functional monolithic array constructor, defining an array as a whole entity.
Reference: [3] <author> Utpal Banerjee. </author> <title> Dependence Analysis for Supercomputing. </title> <publisher> Kluwer Academic Publishing, </publisher> <year> 1988. </year>
Reference-contexts: In the formulation above we have assumed that the step of the generator expressions is always 1. Techniques for obtaining a step 1 for each loop variable can be found in e.g. [15]. 3 The Omega Test A significant number of data dependence tests <ref> [3, 15, 5] </ref> assume a predefined "standard" order of computation [5]. In array comprehensions we do not have such predefined order. The Omega test [11, 12] is an exact data dependence test, free of assumptions on order of evaluation, and based on integer linear programming techniques. <p> A brief description of the omega test follows. First each constraint is normalized, such that the gcd (greatest common divisor) of all the a i (1 i n) coefficients of the constraint is equal to 1. At this stage the traditional gcd test <ref> [3] </ref> can be used to check whether no solution exists. Normalized constraints are eliminated in an iterative process by forcing a coefficient of 1 on some variable which can then be eliminated. After eliminating the equality constraints, we can check for contradictions in the remaining constraints.
Reference: [4] <author> A.P.W. Bohm, D. C. Cann, J. T. Feo and R. R. Oldehoeft. </author> <title> SISAL 2.0 Reference Manual. </title> <type> Technical Report CS-91-118, </type> <institution> Computer Science Department, Colorado State University, </institution> <address> Fort Collins, CO, </address> <month> November </month> <year> 1991. </year>
Reference-contexts: Functional languages provide an implicitly parallel, machine independent programming paradigm, avoiding many of the problems of explicit, machine dependent, and non-deterministic programming associated with explicitly parallel imperative languages. Some functional languages, such as Haskell, Id, and Sisal <ref> [4, 10, 13] </ref>, have been designed to be used for scientific computing. Even though there have been significant improvements in the implementation of arrays for these languages [6, 2, 7, 1], there are still several problems that have not been addressed. <p> Moreover, Id and Haskell arrays are non-strict, i.e., not all elements of the array need to be defined. Sisal 2 <ref> [4] </ref> has incorporated the simpler form of non-recursive array generator. Sisal arrays are strict, i.e., they can be completely defined before any of the array elements needs to be used. An example of a non-strict Id style array comprehension for the pascal triangle is given in figure 1.
Reference: [5] <author> Michael Burke and Ron Cytron. </author> <title> Interprocedural Analysis and Parallelization. </title> <booktitle> In ACM SIG-PLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pages 162-175, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: In the formulation above we have assumed that the step of the generator expressions is always 1. Techniques for obtaining a step 1 for each loop variable can be found in e.g. [15]. 3 The Omega Test A significant number of data dependence tests <ref> [3, 15, 5] </ref> assume a predefined "standard" order of computation [5]. In array comprehensions we do not have such predefined order. The Omega test [11, 12] is an exact data dependence test, free of assumptions on order of evaluation, and based on integer linear programming techniques. <p> Techniques for obtaining a step 1 for each loop variable can be found in e.g. [15]. 3 The Omega Test A significant number of data dependence tests [3, 15, 5] assume a predefined "standard" order of computation <ref> [5] </ref>. In array comprehensions we do not have such predefined order. The Omega test [11, 12] is an exact data dependence test, free of assumptions on order of evaluation, and based on integer linear programming techniques. <p> Typical methods for testing data dependence in the presence of procedure calls base their analysis on obtaining a summary of the array references of each procedure and then testing for overlap between any of these array elements <ref> [14, 8, 5, 9] </ref>. One problem with these approaches is that except for [5] and [9] the approaches produce an approximate summary of the array references. For our problem we require precise information. <p> One problem with these approaches is that except for <ref> [5] </ref> and [9] the approaches produce an approximate summary of the array references. For our problem we require precise information. Burke and Cytron [5] propose to linearize the array space and to generate a list of array access information for each procedure. <p> One problem with these approaches is that except for <ref> [5] </ref> and [9] the approaches produce an approximate summary of the array references. For our problem we require precise information. Burke and Cytron [5] propose to linearize the array space and to generate a list of array access information for each procedure.
Reference: [6] <author> D. C. Cann. </author> <title> Compilation Techniques for High Performance Applicative Computation. </title> <type> Ph.D. thesis, </type> <institution> Colorado State University, Computer Science Department, </institution> <address> Fort Collins, CO, </address> <year> 1989. </year>
Reference-contexts: Some functional languages, such as Haskell, Id, and Sisal [4, 10, 13], have been designed to be used for scientific computing. Even though there have been significant improvements in the implementation of arrays for these languages <ref> [6, 2, 7, 1] </ref>, there are still several problems that have not been addressed. An array comprehension is a functional monolithic array constructor, defining an array as a whole entity.
Reference: [7] <author> G. R. Gao and Robert Kim Yates. </author> <title> An Efficient Monolithic Array Constructor. </title> <type> ACAPS Technical Memo 19, </type> <institution> School of Computer Science, McGill University, Montreal, Canada, </institution> <month> June </month> <year> 1990. </year>
Reference-contexts: Some functional languages, such as Haskell, Id, and Sisal [4, 10, 13], have been designed to be used for scientific computing. Even though there have been significant improvements in the implementation of arrays for these languages <ref> [6, 2, 7, 1] </ref>, there are still several problems that have not been addressed. An array comprehension is a functional monolithic array constructor, defining an array as a whole entity.
Reference: [8] <author> Paul Havlak, Ken Kennedy. </author> <title> Experience with Interprocedural Analysis of Array Side Effects. </title> <booktitle> In Supercomputing '90, </booktitle> <pages> pages 952-962, </pages> <year> 1990. </year>
Reference-contexts: Typical methods for testing data dependence in the presence of procedure calls base their analysis on obtaining a summary of the array references of each procedure and then testing for overlap between any of these array elements <ref> [14, 8, 5, 9] </ref>. One problem with these approaches is that except for [5] and [9] the approaches produce an approximate summary of the array references. For our problem we require precise information.
Reference: [9] <author> Zhiyuan Li and Pen-Chung Yew. </author> <title> Efficient Interprocedural Analysis for Program Parallelization and Restructuring. </title> <booktitle> In ACM SIGPLAN PPEALS, </booktitle> <pages> pages 85-99, </pages> <year> 1988. </year>
Reference-contexts: Subscript Expr: A pointer to a matrix similar to the atom data structure described in <ref> [9] </ref>, where each row corresponds to one dimension of the array and each column corresponds to one of the Num Vars loop variables of the region plus two extra columns: one that indicates if the subscript expression is linear and the other for the constant term. <p> Typical methods for testing data dependence in the presence of procedure calls base their analysis on obtaining a summary of the array references of each procedure and then testing for overlap between any of these array elements <ref> [14, 8, 5, 9] </ref>. One problem with these approaches is that except for [5] and [9] the approaches produce an approximate summary of the array references. For our problem we require precise information. <p> One problem with these approaches is that except for [5] and <ref> [9] </ref> the approaches produce an approximate summary of the array references. For our problem we require precise information. Burke and Cytron [5] propose to linearize the array space and to generate a list of array access information for each procedure. <p> Li and Yew <ref> [9] </ref> approach is very similar to Burke and Cytron's since they also form a set of array references and then apply a standard dependence test to prove independence between any two pairs of references.
Reference: [10] <author> R.S. Nikhil, </author> <title> Id (version 90.0) Reference Manual. </title> <type> TR CSG Memo 284-1, </type> <institution> MIT LCS 1990. </institution>
Reference-contexts: Functional languages provide an implicitly parallel, machine independent programming paradigm, avoiding many of the problems of explicit, machine dependent, and non-deterministic programming associated with explicitly parallel imperative languages. Some functional languages, such as Haskell, Id, and Sisal <ref> [4, 10, 13] </ref>, have been designed to be used for scientific computing. Even though there have been significant improvements in the implementation of arrays for these languages [6, 2, 7, 1], there are still several problems that have not been addressed. <p> The semantics of array comprehensions obeys the single-assignment rule of functional languages, which prescribes that an array-element may not be defined more than once. In the current implementation of Id a redefinition of an array element will give rise to a run-time error <ref> [10] </ref>. Checking for this error introduces run-time inefficiency in most implementations of Id. We say that an array is uniquely defined if non of its elements is defined more than once. Compile time uniqueness analysis avoids the inefficiency of run-time checks.
Reference: [11] <author> William Pugh. </author> <title> The Omega Test: a fast and practical integer programming algorithm for dependence analysis. </title> <booktitle> In Supercomputing 1991, </booktitle> <pages> pages 4-13, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: Compile time uniqueness analysis avoids the inefficiency of run-time checks. Uniqueness analysis is a form of array dependence analysis, and therefore employs subscript analysis techniques, similar to those used in optimizing and parallelizing conventional language compilers [15]. We have chosen the Omega test <ref> [11] </ref>, which is based on integer linear programming, for this work. We will derive algorithms that turn an array comprehension into an integer linear programming problem that then will serve as input for the Omega test. The rest of this paper is organized as follows. <p> In array comprehensions we do not have such predefined order. The Omega test <ref> [11, 12] </ref> is an exact data dependence test, free of assumptions on order of evaluation, and based on integer linear programming techniques. Although it has a worst-case exponential time complexity, this rarely occurs when using it for data dependence analysis.
Reference: [12] <author> William Pugh. </author> <title> A Practical Algorithm for Exact Array Dependence Analysis. </title> <journal> Communications of the ACM, </journal> <volume> 35(8) </volume> <pages> 102-114, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: In array comprehensions we do not have such predefined order. The Omega test <ref> [11, 12] </ref> is an exact data dependence test, free of assumptions on order of evaluation, and based on integer linear programming techniques. Although it has a worst-case exponential time complexity, this rarely occurs when using it for data dependence analysis.
Reference: [13] <author> Boleslaw K. Szymanski. </author> <title> Parallel Functional Languages and Compilers. </title> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: Functional languages provide an implicitly parallel, machine independent programming paradigm, avoiding many of the problems of explicit, machine dependent, and non-deterministic programming associated with explicitly parallel imperative languages. Some functional languages, such as Haskell, Id, and Sisal <ref> [4, 10, 13] </ref>, have been designed to be used for scientific computing. Even though there have been significant improvements in the implementation of arrays for these languages [6, 2, 7, 1], there are still several problems that have not been addressed.
Reference: [14] <author> Rimi Triolet, Francois Irigoin, and Paul Feautrier. </author> <title> Direct Parallelization of Call Statements. </title> <booktitle> In Proceedings of the SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pages 176-185, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Typical methods for testing data dependence in the presence of procedure calls base their analysis on obtaining a summary of the array references of each procedure and then testing for overlap between any of these array elements <ref> [14, 8, 5, 9] </ref>. One problem with these approaches is that except for [5] and [9] the approaches produce an approximate summary of the array references. For our problem we require precise information.
Reference: [15] <author> Hans Zima with Barbara Chapman. </author> <title> Supercompilers for Parallel and Vector Computers. </title> <publisher> ACM Press, </publisher> <address> NY, </address> <year> 1990. </year> <month> 14 </month>
Reference-contexts: Compile time uniqueness analysis avoids the inefficiency of run-time checks. Uniqueness analysis is a form of array dependence analysis, and therefore employs subscript analysis techniques, similar to those used in optimizing and parallelizing conventional language compilers <ref> [15] </ref>. We have chosen the Omega test [11], which is based on integer linear programming, for this work. We will derive algorithms that turn an array comprehension into an integer linear programming problem that then will serve as input for the Omega test. <p> In the formulation above we have assumed that the step of the generator expressions is always 1. Techniques for obtaining a step 1 for each loop variable can be found in e.g. <ref> [15] </ref>. 3 The Omega Test A significant number of data dependence tests [3, 15, 5] assume a predefined "standard" order of computation [5]. In array comprehensions we do not have such predefined order. <p> In the formulation above we have assumed that the step of the generator expressions is always 1. Techniques for obtaining a step 1 for each loop variable can be found in e.g. [15]. 3 The Omega Test A significant number of data dependence tests <ref> [3, 15, 5] </ref> assume a predefined "standard" order of computation [5]. In array comprehensions we do not have such predefined order. The Omega test [11, 12] is an exact data dependence test, free of assumptions on order of evaluation, and based on integer linear programming techniques.
References-found: 15

