URL: http://www.cs.princeton.edu/~wass/publications/STAN-CS-TN-96-39.ps.gz
Refering-URL: http://www.cs.princeton.edu/~wass/publications.html
Root-URL: http://www.cs.princeton.edu
Title: Complexity Measures f  or Assembly Sequences  
Author: P. Agarwal Ed. Michael Goldwasser Rajeev Motwani 
Address: Stanford, CA 94305-9045  
Affiliation: Stanford  Department of Computer Science Stanford University  
Note: Invited to special issue of Int. J. of Comp. Geometry and Applications,  Supported by a grant from the Stanford Integrated Manufacturing Association (SIMA), by NSF/ARPA Grant IRI-9306544, by NSF Grant CCR-9215219, by ARO MURI Grant DAAH04-96-1-0007 and by NSF Award CCR-9357849, with matching funds from IBM, Mitsubishi, Schlumberger Foundation, Shell Foundation, and Xerox Corporation. Supported by an Alfred P. Sloan Research Fellowship, an IBM Faculty Partnership Award, an ARO MURI Grant DAAH04-96-1-0007, and NSF Young Investigator Award CCR-9357849, with matching funds from IBM, Mitsubishi, Schlumberger Foundation, Shell Foundation, and Xerox Corporation.  
Pubnum: Technical Report No. STAN-CS-TN-96-39  
Abstract: Our work examines various complexity measures for two-handed assembly sequences. For many products there exists an exponentially large set of valid sequences, and a natural goal is to use automated systems to select wisely from the choices. Since assembly sequencing is a preprocessing phase for a long and expensive manufacturing process, any work towards finding a better assembly sequence is of great value when it comes time to assemble the physical product in mass quantities. Although there has been a great deal of algorithmic success for finding feasible assembly sequences, there has been very little success towards optimizing the costs of sequences. We attempt to explain this lack of progress, by proving the inherent difficulty in finding optimal, or even near-optimal, assembly sequences. We begin by introducing a formal framework for studying the optimization of several complexity measures. We consider a variety of different settings and natural cost measures for assembly sequences. Following which, we define a graph-theoretic problem which is a generalization of assembly sequencing, focusing on the combinatorial aspect of the family of feasible assembly sequences, while temporarily separating out the specific geometric assumptions inherent, to assembly sequencing. For our virtual assembly sequencing problem we are able to use techniques common to the theory of approximability to prove the hardness of finding even near-optimal sequences for most cost measures in our generalized framework. As a special case, we prove strong inapproximability results for the problem of scheduling with and/or precedence constraints. Of course, hardness results in our generalized framework do not immediately carry over to the original geometric problems. We continue by realizing several of these hardness results in rather simple geometric settings, proving the difficulty of some of the original problems. We are able to show strong inapproximability results in a far simpler setting than the domain of most assembly sequencers, for example using an assembly consisting solely of unit disks in the plane. These inapproximability results, to the best of our knowledge, are the strongest hardness results known for a purely combinatorial problem in a geometric setting. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Agarwal, M. de Berg, D. Halperin, and M. Sharir. </author> <title> Efficient generation of k-directional assembly sequences. </title> <booktitle> In Proc. 7th ACM Symp. on Discrete Algorithms, </booktitle> <pages> pages 122-131, </pages> <year> 1996. </year>
Reference-contexts: Therefore, we consider the additional problem of choosing the best such sequence for a product, when restricted to linear assembly sequences. Note that even when restricted to linear sequences, there still may be exponentially many valid sequences for a given product. 9 R2 Constant-sized Family of Motions. <ref> [1] </ref> Originally, our only assumption was that the number of blocking graphs is polynomially bounded in the number of parts. Now we consider instances where the number of graphs in bounded by some constant, k.
Reference: [2] <author> S. Arora. </author> <title> Polynomial-time approximation schemes for Euclidean TSP and other geometric problems. </title> <booktitle> In Proc. 37th Symp. on Found. Comput. Sci., </booktitle> <pages> pages 1-11, </pages> <year> 1996. </year>
Reference-contexts: For example, there exists some c &gt; 0 for which achieving a (1 + c)- approximation for the Metric TSP problem is NP-hard [45], however in the Euclidean plane, TSP can be approximated to within (1 + *) for all * &gt; 0 <ref> [2] </ref>. Similarly, achieving an n * -approximation for Minimum Independent Set is NP-hard [25], however for planar graphs, Minimum Independent Set can be approximated to within (1 + *) [6]. Similar results hold for most optimization problem when restricted to planar graphs [35].
Reference: [3] <author> S. Arora, L. Babai, J. Stern, and Z. Sweedyk. </author> <title> The hardness of approximate optima in lattices, codes and linear equations. </title> <booktitle> In Proc. 34th Symp. on Found. Comput. Sci., </booktitle> <pages> pages 724-733, </pages> <year> 1993. </year>
Reference-contexts: For problems in Class III, it is quasi-NP-hard to achieve a 2 log 1fl n factor approximation for any fl &gt; 0. LabelCover is the canonical problem in this class <ref> [3] </ref>, although the class contains several other natural problems such as Longest Path [32] and Nearest Lattice Vector [3]. <p> For problems in Class III, it is quasi-NP-hard to achieve a 2 log 1fl n factor approximation for any fl &gt; 0. LabelCover is the canonical problem in this class <ref> [3] </ref>, although the class contains several other natural problems such as Longest Path [32] and Nearest Lattice Vector [3]. <p> To the best of our knowledge, the geometric results in Section 9 provide the strongest inapprox-imability bounds shown for a natural, combinatorial, geometric problem. Similar lower bounds have been shown for the Nearest Lattice Vector problem <ref> [3] </ref>, however this problem is not combinatorial, and although it shares the same lower bound as our problem, we cannot directly relate the hardness of the two problems. 5 3 Definition of Assembly Sequencing In general terms, the input to an assembly sequencer is a product, consisting of a set of <p> We will look at the problem where we only charge an algorithm for the leaves that it schedules 7 . We show the inapproximability of this problem by showing that the LabelCover min problem <ref> [3, 4] </ref> is a special case. Following this, we show that the lower bound applies even when we further restrict the and/or problem to have degree bounded by two.
Reference: [4] <author> S. Arora and C. Lund. </author> <title> Hardness of approximations. </title> <editor> In D. Hochbaum, editor, </editor> <title> Approximation Algorithms for NP-Hard Problems. </title> <publisher> PWS Publishing Company, </publisher> <address> Boston, MA, </address> <year> 1996. </year>
Reference-contexts: our results will show, this problem is quite difficult. 3 Class Factor of Approximation that is hard Representative Problems I 1 + * Max-3Sat II O (log n) Set Cover III 2 log 1fl n LabelCover IV n * Clique The four classes and their representative problems. (Table 10.1 from <ref> [4] </ref>) Several software systems offer the user the option of optimizing the sequence over a choice of complexity measures [33, 47, 54], however these systems currently must rely on either a brute force search of the entire space, or else branch-and-bound type searches with no performance guarantees for the resulting sequence. <p> For this reason, we approach these problems using techniques common to the theory of approx-imability <ref> [4, 18, 31, 42] </ref>. Since we cannot expect to find the optimal sequence in polynomial time, we look for a polynomial time approximation algorithm which returns a solution whose cost can be bounded by some function of the true optimal cost. <p> Many researches have worked towards classifying the approximability of different NP-hard problems <ref> [4, 5, 12, 44] </ref>. We will consider four broad classes defined in [4], which group problems based on the strength of the inapproximability results which have been proven. <p> Many researches have worked towards classifying the approximability of different NP-hard problems [4, 5, 12, 44]. We will consider four broad classes defined in <ref> [4] </ref>, which group problems based on the strength of the inapproximability results which have been proven. Class I includes all problems for which approximating the optimal solution to within a factor of (1 + *) is NP-hard for some * &gt; 0. <p> Finally, Class IV consists of the hardest problems, namely those 3 that is, this would imply NP DTIME (n poly (log n) ). "A proof of quasi-NP-hardness is good evidence that the problem has no polynomial-time algorithm." <ref> [4] </ref> 4 for which it is NP-hard to achieve an n * approximation factor for some * &gt; 0. This class includes problems such as Clique [25] and Coloring [40]. <p> We will look at the problem where we only charge an algorithm for the leaves that it schedules 7 . We show the inapproximability of this problem by showing that the LabelCover min problem <ref> [3, 4] </ref> is a special case. Following this, we show that the lower bound applies even when we further restrict the and/or problem to have degree bounded by two. <p> This lower bound remains valid if both the and-degree and or-degree are bounded by two. 7.1 Proofs Proof of Theorem 7: The LabelCover problem, defined in <ref> [4] </ref>, is an artificial generalization of the Set Cover problem introduced in approximability theory. <p> It is easy to verify that the and/or instance has internal-tree precedence constraints. Notice that the number of non-leaf tasks in this construction is polynomially bounded in the size of the LabelCover min instance (namely, in jU j, jV j and N ). Combining this with the result of <ref> [4] </ref> which proves a similar lower bound for the approximability of LabelCover min , we get that it is quasi-NP-hard to achieve an 2 log 1fl n approximation for any fl &gt; 0. <p> That is, the LabelCover min results provide our strongest results even for the most general and/or scheduling problem, yet there is reason to believe this may be an even more difficult problem. It is already conjectured that LabelCover is truly n * -hard to approximate <ref> [4] </ref>, however it may be possible to strengthen the lower bounds for and/or scheduling without necessarily settling the LabelCover conjecture.
Reference: [5] <author> S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy. </author> <title> Proof verification and intractability of approximation problems. </title> <booktitle> In Proc. 33rd Symp. on Found. Comput. Sci., </booktitle> <pages> pages 13-22, </pages> <year> 1992. </year>
Reference-contexts: Many researches have worked towards classifying the approximability of different NP-hard problems <ref> [4, 5, 12, 44] </ref>. We will consider four broad classes defined in [4], which group problems based on the strength of the inapproximability results which have been proven.
Reference: [6] <author> B. Baker. </author> <title> Approximation algorithms for NP-complete problems on planar graphs. </title> <journal> J. ACM, </journal> <volume> 41(1) </volume> <pages> 153-180, </pages> <year> 1994. </year>
Reference-contexts: Similarly, achieving an n * -approximation for Minimum Independent Set is NP-hard [25], however for planar graphs, Minimum Independent Set can be approximated to within (1 + *) <ref> [6] </ref>. Similar results hold for most optimization problem when restricted to planar graphs [35].
Reference: [7] <author> D. Baldwin. </author> <title> Algorithmic methods and software tools for the generation of mechanical assembly sequences. M.Sc. </title> <type> thesis, </type> <institution> MIT, </institution> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: Section 10 discusses some particularly interesting complexity issues relating to and/or scheduling, and finally Section 11 discuss several other open directions for research, and contains concluding remarks. 2 Previous Work 2.1 Assembly Sequencing The use of automation in assembly sequencing has increased rapidly over the years <ref> [7, 16, 26, 27, 28, 37, 39, 50, 51, 53, 54] </ref>. Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process.
Reference: [8] <author> R. Bhatia, S. Khuller, and J. Naor. </author> <title> The loading time scheduling problem. </title> <booktitle> In Proc. 36th Symp. on Found. Comput. Sci., </booktitle> <pages> pages 72-81, </pages> <year> 1995. </year>
Reference-contexts: For jF j 3, we can achieve a (jF j 1)-approximation for minimizing the number of re-orientations, using a set of universal sequences, similar to the techniques used for approximating the Shortest Common Supersequence problem <ref> [8] </ref>. For more discussion on the relation between re-orientations and supersequences, see the proofs of Theorems 11 and 13. 11 5 and/or Scheduling As a special case, we consider the goal of removing a key part, while minimizing the number of removed parts, and restricting ourselves to linear steps (G2/R1/C5). <p> Our second set of results will show weaker inapproximability results for minimizing the number of re-orientations which apply when the family of motions is restricted to be of constant size (restriction R2). These results come from a natural reduction from the Loading Time Scheduling Problem <ref> [8] </ref>. Theorem 9 For the problem of removing a key part, when restricted to linear moves, while minimizing the number of removed parts, it is quasi-NP-hard to achieve a 2 log 1fl n -approximation for any fl &gt; 0. <p> Proof of Theorem 11: We begin by proving this result for the goal of removing a key part from the assembly. We will give a reduction from the Loading Time Scheduling Problem, defined a follows 19 <ref> [8] </ref>. There is a set of n jobs, and machines, and each job, j, can only be performed by some subset of the machines, M (j). An algorithm pays for loading a machine, but once that machine is loaded, it may perform any available operations at no additional cost. <p> For this reason, we claim that any solution to the LTSP instance can be translated to a solution with equal cost for removing the key part, and 8 actually, we reversal all edges of G, as <ref> [8] </ref> defines an edge from x to y as signifying that y cannot be run until after x. 20 vice versa, and thus we have an approximation preserving reduction. <p> At this point, we rely on results shown in <ref> [8] </ref>, combined with a result of [41], which prove these claims, where the number of machines corresponds to jF j.
Reference: [9] <author> P. Bonizzoni, M. Duella, and G. Mauri. </author> <title> Approximation complexity of longest common subsequence and shortest common supersequence over fixed alphabet. </title> <type> Technical Report 117/94, </type> <institution> Universita degli Studi di Milano, </institution> <year> 1994. </year>
Reference-contexts: The problem of finding the shortest common supersequence is known to be NP-hard [18], and more recently it was shown to be Max-SNP-hard, even over a binary alphabet <ref> [9] </ref>. Therefore, by doubling the alphabet as above, we get that our problem of removing a part is Max-SNP-hard, when jF j 4.
Reference: [10] <author> G. Boothroyd. </author> <title> Assembly Automation and Product Design. </title> <publisher> Marcel Dekker, Inc., </publisher> <address> New York, NY, </address> <year> 1991. </year>
Reference-contexts: There are many possible ways to define the cost of a sequence, depending on how these sequences will be used eventually in a manufacturing system. Several empirical measures have been suggested <ref> [10] </ref>, and more formal complexity measures are examined in a generalized system [54]. The importance of using automated reasoning to evaluate the complexity of assembly sequences is discussed, along with the introduction of several evaluation measures [52].
Reference: [11] <author> S. Chakrabarty and J. Wolter. </author> <title> A hierarchical approach to assembly planning. </title> <booktitle> In Proc. IEEE Int. Conf. on Robotics and Automation, </booktitle> <pages> pages 258-263, </pages> <year> 1994. </year>
Reference-contexts: The importance of using automated reasoning to evaluate the complexity of assembly sequences is discussed, along with the introduction of several evaluation measures [52]. A hierarchical approach is used to identify common subassemblies in products, thereby allowing more effort to be used towards finding a "better" assembly sequence <ref> [11] </ref>. Although practical, this technique simply delays the eventual need for better automated reasoning to overcome increasingly large data sets.
Reference: [12] <author> P. Crescenzi and V. Kahn. </author> <title> A compendium of NP optimization problems. </title> <type> Technical Report SI/RR-95/02, </type> <institution> Dipartimento di Scienceze dell'Informazione. Universita di Roma "La Sapienza", </institution> <year> 1995. </year>
Reference-contexts: Many researches have worked towards classifying the approximability of different NP-hard problems <ref> [4, 5, 12, 44] </ref>. We will consider four broad classes defined in [4], which group problems based on the strength of the inapproximability results which have been proven.
Reference: [13] <author> R. Dawson. </author> <title> On removing a ball without disturbing the others. </title> <journal> Mathematics Magazine, </journal> <volume> 57(1) </volume> <pages> 27-30, </pages> <year> 1984. </year>
Reference-contexts: Quite naturally, research from computational geometry relates very closely to assembly sequencing. The separability of objects has been well studied in the geometric community <ref> [13, 14, 15, 23, 48, 49] </ref>. In a single direction, a depth order of a set of parts is an ordering of the parts which allows for collision-free translations of the individual parts to infinity. <p> Similar separability issues are studied in two dimensions for more general classes of shapes, such as monotone or star-shaped polygons [49]. For a collection of balls in R d , there exists at least d + 1 balls, each of which can be translated to infinity in some direction <ref> [13] </ref>. However, there exists a set of convex parts in three dimensions which cannot be disassembled using two hands, with only translations to infinity, or even generalized rotations and translations [48].
Reference: [14] <author> M. de Berg, M. Overmars, and O. Schwarzkopf. </author> <title> Computing and verifying depth orders. </title> <journal> SIAM J. Comput., </journal> <volume> 23(2) </volume> <pages> 432-446, </pages> <year> 1994. </year>
Reference-contexts: Quite naturally, research from computational geometry relates very closely to assembly sequencing. The separability of objects has been well studied in the geometric community <ref> [13, 14, 15, 23, 48, 49] </ref>. In a single direction, a depth order of a set of parts is an ordering of the parts which allows for collision-free translations of the individual parts to infinity.
Reference: [15] <author> F. Dehne and J.-R. Sack. </author> <title> Translation separability of polygons. </title> <journal> Visual Computer, </journal> <volume> 3(4) </volume> <pages> 227-235, </pages> <year> 1987. </year>
Reference-contexts: Quite naturally, research from computational geometry relates very closely to assembly sequencing. The separability of objects has been well studied in the geometric community <ref> [13, 14, 15, 23, 48, 49] </ref>. In a single direction, a depth order of a set of parts is an ordering of the parts which allows for collision-free translations of the individual parts to infinity.
Reference: [16] <author> T. De Fazio and D. Whitney. </author> <title> Simplified generation of all mechanical assembly sequences. </title> <journal> IEEE Trans. on Robotics and Automation, </journal> <volume> 3(6) </volume> <pages> 640-658, </pages> <year> 1987. </year>
Reference-contexts: Section 10 discusses some particularly interesting complexity issues relating to and/or scheduling, and finally Section 11 discuss several other open directions for research, and contains concluding remarks. 2 Previous Work 2.1 Assembly Sequencing The use of automation in assembly sequencing has increased rapidly over the years <ref> [7, 16, 26, 27, 28, 37, 39, 50, 51, 53, 54] </ref>. Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process. <p> Most of this success can be achieved within the framework of nondirectional blocking graphs [50, 52], and as our work is intricately related to this approach, we review these approaches in more detail in Section 3.1. It is also possible to enumerate all possible assembly sequences <ref> [16] </ref>, although there may be exponentially many such sequences for a product. With the ability to find feasible sequences efficiently, several researchers have focused on the importance of using automated tools to choose cost-effective sequences.
Reference: [17] <author> U. Feige. </author> <title> A threshold of ln n for approximating set cover. </title> <booktitle> In Proc. 28th ACM Symp. Theory Comput., </booktitle> <pages> pages 314-318, </pages> <year> 1996. </year>
Reference-contexts: The typical such problem in this class is Set Cover, for which the threshold of approx-imability has been placed at ln n (1 + o (1)) <ref> [17] </ref>. For problems in Class III, it is quasi-NP-hard to achieve a 2 log 1fl n factor approximation for any fl &gt; 0. LabelCover is the canonical problem in this class [3], although the class contains several other natural problems such as Longest Path [32] and Nearest Lattice Vector [3]. <p> Similar results hold for most optimization problem when restricted to planar graphs [35]. There exists a (1 + o (1)) ln n lower bound for approximating the Set Cover problem <ref> [17] </ref>, however the Rectangle Cover problem, covering a set of axis-aligned rectangles with minimum number of points, has no such inapproximability results [42]. To the best of our knowledge, the geometric results in Section 9 provide the strongest inapprox-imability bounds shown for a natural, combinatorial, geometric problem.
Reference: [18] <author> M. Garey and D. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. </title> <editor> W. H. </editor> <publisher> Freeman, </publisher> <address> New York, NY, </address> <year> 1979. </year>
Reference-contexts: For this reason, we approach these problems using techniques common to the theory of approx-imability <ref> [4, 18, 31, 42] </ref>. Since we cannot expect to find the optimal sequence in polynomial time, we look for a polynomial time approximation algorithm which returns a solution whose cost can be bounded by some function of the true optimal cost. <p> However, we can prove the NP-completeness of Polygon Cover through a reduction from Planar Vertex Cover, which is known to be NP-complete <ref> [18] </ref>. Given an instance of Planar Vertex Cover, we can simply let each edge be represented by a (degenerate) polygon. <p> to each other until all of the remaining pegs share a common direction for removal, and hence our cost will be unchanged. 9.2 Finding a Common Supersequence Proof of Theorem 13: When constrained to using linear moves, we give a construction which reduces the problem of finding a common supersequence <ref> [18] </ref>, to the problem of removing a part from 22 an assembly consisting of polygons in two-dimensions. A string T is a supersequence of a string S, if S can be obtained by erasing zero or more symbols of T . <p> The problem of finding the shortest common supersequence is known to be NP-hard <ref> [18] </ref>, and more recently it was shown to be Max-SNP-hard, even over a binary alphabet [9]. Therefore, by doubling the alphabet as above, we get that our problem of removing a part is Max-SNP-hard, when jF j 4.
Reference: [19] <author> D. Gillies. </author> <title> Algorithms to schedule tasks with AND/OR precedence constraints. </title> <type> Ph.D. thesis, </type> <institution> University of Illinois, Urbana, IL, </institution> <year> 1991. </year>
Reference-contexts: It is worth noting that with classical and precedence constraints, this problem of minimizing the number of scheduled tasks can be solved exactly, in polynomially time by computing a depth order. A model for scheduling with and/or precedence constraints has been studied earlier <ref> [19, 20] </ref>, but with one key difference. <p> For this reason, we make no apriori assumptions about the structure of the precedence relations. Gillies and Lin <ref> [19, 20] </ref> prove the NP-hardness of many variants of the problem, however they do not consider the approximability of the hard problems. <p> A leaf-task is one with P i = ;, and thus it can be scheduled at any time. We say that an instance of and/or scheduling has partial-order precedence constraints if there are no cycles in the precedence graph (as in <ref> [19, 20] </ref>).
Reference: [20] <author> D. Gillies and J. Liu. </author> <title> Scheduling tasks with AND/OR precedence constraints. </title> <journal> SIAM J. Comput., </journal> <volume> 24(4) </volume> <pages> 797-810, </pages> <year> 1995. </year>
Reference-contexts: It is worth noting that with classical and precedence constraints, this problem of minimizing the number of scheduled tasks can be solved exactly, in polynomially time by computing a depth order. A model for scheduling with and/or precedence constraints has been studied earlier <ref> [19, 20] </ref>, but with one key difference. <p> For this reason, we make no apriori assumptions about the structure of the precedence relations. Gillies and Lin <ref> [19, 20] </ref> prove the NP-hardness of many variants of the problem, however they do not consider the approximability of the hard problems. <p> A leaf-task is one with P i = ;, and thus it can be scheduled at any time. We say that an instance of and/or scheduling has partial-order precedence constraints if there are no cycles in the precedence graph (as in <ref> [19, 20] </ref>).
Reference: [21] <author> S. Gottschlich, C. Ramos, and D. Lyons. </author> <title> Assembly and task planning: A taxonomy. </title> <journal> IEEE Robotics and Automation Magazine, </journal> <volume> 1(3) </volume> <pages> 4-12, </pages> <year> 1994. </year> <month> 29 </month>
Reference-contexts: Efficient algorithms have been developed, for many classes of motions, which are guaranteed to find a valid assembly sequence when one exists. The IEEE Technical Committee on Assembly and Task Planning summarized the current state of assembly sequencing by explaining <ref> [21] </ref>, "after years of work in this field, a basic planning methodology has emerged that is capable of producing a feasible plan : : : The challenges still facing the field are to develop efficient and robust analysis tools and to develop planners capable of finding optimal or near-optimal sequences rather
Reference: [22] <author> L. Guibas, D. Halperin, H. Hirukawa, and J.-C. Latombe R. Wilson. </author> <title> A simple and efficient procedure for polyhedral assembly partitioning under infinitesimal motions. </title> <booktitle> In Proc IEEE Int. Conf. on Robotics and Automation, </booktitle> <pages> pages 2553-2560, </pages> <year> 1995. </year>
Reference-contexts: For many classes of motions, described by a constant number of degrees of freedom, polynomial algorithms were developed which will find an assembly sequence if one exists <ref> [22, 24, 50, 52] </ref>. Most of this success can be achieved within the framework of nondirectional blocking graphs [50, 52], and as our work is intricately related to this approach, we review these approaches in more detail in Section 3.1. <p> Techniques from computational geometry allow for the construction of the NDBG for a variety of motion classes, including infinitesimal translations [52], extended translations (i.e., to infinity) [52], multiple step translations [24], and infinitesimal generalized motions (i.e., rigid body motions) <ref> [22, 52] </ref>. For each of these families of motions, the NDBG framework immediately provides a polynomial time algorithm for constructing a feasible assembly sequence, if one exists.
Reference: [23] <author> L. Guibas and F. Yao. </author> <title> On translating a set of rectangles. </title> <editor> In F. Preparata, editor, </editor> <booktitle> Computational Geometry, Advances in Computing Research, </booktitle> <pages> pages 61-77. </pages> <publisher> JAI Press Inc., </publisher> <year> 1983. </year>
Reference-contexts: Quite naturally, research from computational geometry relates very closely to assembly sequencing. The separability of objects has been well studied in the geometric community <ref> [13, 14, 15, 23, 48, 49] </ref>. In a single direction, a depth order of a set of parts is an ordering of the parts which allows for collision-free translations of the individual parts to infinity. <p> A classic result states that given a collection of convex shapes in two dimensions, for any translational direction there exists some ordering, such that the parts can be translated away one at a time <ref> [23] </ref>. Therefore, if trying to minimize the number of directions needed for an assembly sequence, this result tells us that one direction is always sufficient for an assembly of convex parts in two dimensions.
Reference: [24] <author> D. Halperin and R. Wilson. </author> <title> Assembly partitioning along simple paths: the case of multiple translations. </title> <booktitle> In Proc. IEEE Int. Conf. on Robotics and Automation, </booktitle> <pages> pages 1585-1592, </pages> <year> 1995. </year>
Reference-contexts: For many classes of motions, described by a constant number of degrees of freedom, polynomial algorithms were developed which will find an assembly sequence if one exists <ref> [22, 24, 50, 52] </ref>. Most of this success can be achieved within the framework of nondirectional blocking graphs [50, 52], and as our work is intricately related to this approach, we review these approaches in more detail in Section 3.1. <p> Techniques from computational geometry allow for the construction of the NDBG for a variety of motion classes, including infinitesimal translations [52], extended translations (i.e., to infinity) [52], multiple step translations <ref> [24] </ref>, and infinitesimal generalized motions (i.e., rigid body motions) [22, 52]. For each of these families of motions, the NDBG framework immediately provides a polynomial time algorithm for constructing a feasible assembly sequence, if one exists.
Reference: [25] <author> J. Hastad. </author> <title> Clique is hard to approximate within n 1* . In Proc. </title> <booktitle> 37th Symp. on Found. Comput. Sci., </booktitle> <pages> pages 627-636, </pages> <year> 1996. </year>
Reference-contexts: This class includes problems such as Clique <ref> [25] </ref> and Coloring [40]. We give a series of results, proving not only the hardness of finding the exact optimal solutions in this model, but even of finding reasonable approximation algorithms. To do so, we use approximation-preserving reductions [42, 44]. <p> Similarly, achieving an n * -approximation for Minimum Independent Set is NP-hard <ref> [25] </ref>, however for planar graphs, Minimum Independent Set can be approximated to within (1 + *) [6]. Similar results hold for most optimization problem when restricted to planar graphs [35].
Reference: [26] <author> R. Hoffman. </author> <title> A common sense approach to assembly sequence planning. </title> <booktitle> In Computer-Aided Mechanical Assembly Planning, </booktitle> <pages> pages 289-314. </pages> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1991. </year>
Reference-contexts: Section 10 discusses some particularly interesting complexity issues relating to and/or scheduling, and finally Section 11 discuss several other open directions for research, and contains concluding remarks. 2 Previous Work 2.1 Assembly Sequencing The use of automation in assembly sequencing has increased rapidly over the years <ref> [7, 16, 26, 27, 28, 37, 39, 50, 51, 53, 54] </ref>. Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process.
Reference: [27] <author> L. Homem de Mello and A. Sanderson. </author> <title> Computer-Aided Mechanical Assembly Planning. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1991. </year>
Reference-contexts: Section 10 discusses some particularly interesting complexity issues relating to and/or scheduling, and finally Section 11 discuss several other open directions for research, and contains concluding remarks. 2 Previous Work 2.1 Assembly Sequencing The use of automation in assembly sequencing has increased rapidly over the years <ref> [7, 16, 26, 27, 28, 37, 39, 50, 51, 53, 54] </ref>. Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process.
Reference: [28] <author> L. Homem de Mello and A. Sanderson. </author> <title> A correct and complete algorithms for the generation of mechanical assembly sequences. </title> <journal> IEEE Trans. on Robotics and Automation, </journal> <volume> 7(2) </volume> <pages> 228-240, </pages> <year> 1991. </year>
Reference-contexts: lies between polynomial and polylogarithmic in that 2 log 1fl n = o (n * ) for any * &gt; 0, and 2 log 1fl n = !(log c n) for any constant c. 2 N.B.: this is not to be confused with the and/or tree representation of assembly sequences <ref> [28] </ref> 2 a 2 log 1fl n -approximation to minimizing the total number of disks which must be removed to access the given disks is hard for any fl &gt; 0. The paper proceeds as follows. <p> Section 10 discusses some particularly interesting complexity issues relating to and/or scheduling, and finally Section 11 discuss several other open directions for research, and contains concluding remarks. 2 Previous Work 2.1 Assembly Sequencing The use of automation in assembly sequencing has increased rapidly over the years <ref> [7, 16, 26, 27, 28, 37, 39, 50, 51, 53, 54] </ref>. Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process. <p> Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process. Early systems resulted in inefficient generate-and-test sequencers, operating by generating candidate operations and testing their feasibility <ref> [28, 53] </ref>. However, if arbitrarily complex motions and paths are allowed, assembly sequencing was shown to be intractable [29, 34, 43, 54].
Reference: [29] <author> J. Hopcroft, J. Schwartz, and M. Sharir. </author> <title> On the complexity of motion planning for multiple independent objects: P-space hardness of the "Warehouseman's Problem". </title> <journal> Int. J. Robotics Research, </journal> <volume> 3(4) </volume> <pages> 76-88, </pages> <year> 1984. </year>
Reference-contexts: Early systems resulted in inefficient generate-and-test sequencers, operating by generating candidate operations and testing their feasibility [28, 53]. However, if arbitrarily complex motions and paths are allowed, assembly sequencing was shown to be intractable <ref> [29, 34, 43, 54] </ref>. This led some researchers to consider restricted, but still interesting, versions of the problem (e.g., monotone sequences, where each operation generates a final subassembly, and two-handed sequences, where every operation merges exactly two subassemblies).
Reference: [30] <author> T. Jiang and M. Li. </author> <title> On the approximation of shortest common supersequences and longest common subsequences. </title> <booktitle> In Automata, Languages and Programming (Proc. 21st ICALP), volume 820 of Lecture Notes in Computer Science, </booktitle> <pages> pages 191-202, </pages> <year> 1994. </year>
Reference-contexts: Therefore, by doubling the alphabet as above, we get that our problem of removing a part is Max-SNP-hard, when jF j 4. Also, it was shown in <ref> [30] </ref> that there exists a constant ffi &gt; 0, such that it is quasi-NP-hard to approximate the shortest common supersequence to within a factor of log ffi n.
Reference: [31] <author> D. Johnson. </author> <title> Approximation algorithms for combinatorial problems. </title> <journal> J. Comput. Systems Sci., </journal> <volume> 9 </volume> <pages> 256-278, </pages> <year> 1974. </year>
Reference-contexts: For this reason, we approach these problems using techniques common to the theory of approx-imability <ref> [4, 18, 31, 42] </ref>. Since we cannot expect to find the optimal sequence in polynomial time, we look for a polynomial time approximation algorithm which returns a solution whose cost can be bounded by some function of the true optimal cost.
Reference: [32] <author> D. Karger, R. Motwani, and G. Ramkumar. </author> <title> On approximating the longest path in a graph. </title> <booktitle> In Proc. of the Workshop on Algorithms and Data Structures, volume 709 of Lecture Notes in Computer Science, </booktitle> <pages> pages 421-432, </pages> <year> 1993. </year>
Reference-contexts: For problems in Class III, it is quasi-NP-hard to achieve a 2 log 1fl n factor approximation for any fl &gt; 0. LabelCover is the canonical problem in this class [3], although the class contains several other natural problems such as Longest Path <ref> [32] </ref> and Nearest Lattice Vector [3].
Reference: [33] <author> S. Kaufman, R. Wilson, R. Jones, T. Calton, and A. Ames. </author> <title> The Archimedes 2 mechanical assembly planning system. </title> <booktitle> In Proc IEEE Int. Conf. on Robotics and Automation, </booktitle> <pages> pages 3361-3368, </pages> <year> 1996. </year>
Reference-contexts: I 1 + * Max-3Sat II O (log n) Set Cover III 2 log 1fl n LabelCover IV n * Clique The four classes and their representative problems. (Table 10.1 from [4]) Several software systems offer the user the option of optimizing the sequence over a choice of complexity measures <ref> [33, 47, 54] </ref>, however these systems currently must rely on either a brute force search of the entire space, or else branch-and-bound type searches with no performance guarantees for the resulting sequence. 2.2 Approximation Theory For most of our variants, finding the optimal cost assembly sequence is NP-hard. <p> This algorithm runs in polynomially time, is quite simple, and has been implemented to construct assembly sequences for many of the above motion classes <ref> [33, 47] </ref>.
Reference: [34] <author> L. Kavraki, J.-C. Latombe, and R. Wilson. </author> <title> Complexity of partitioning an assembly. </title> <booktitle> In Proc. 5th Canad. Conf. Comput. Geom., </booktitle> <pages> pages 12-17, </pages> <address> Waterloo, Canada, </address> <year> 1993. </year>
Reference-contexts: Early systems resulted in inefficient generate-and-test sequencers, operating by generating candidate operations and testing their feasibility [28, 53]. However, if arbitrarily complex motions and paths are allowed, assembly sequencing was shown to be intractable <ref> [29, 34, 43, 54] </ref>. This led some researchers to consider restricted, but still interesting, versions of the problem (e.g., monotone sequences, where each operation generates a final subassembly, and two-handed sequences, where every operation merges exactly two subassemblies).
Reference: [35] <author> S. Khanna and R. Motwani. </author> <title> Towards a syntactic characterization of PTAS. </title> <booktitle> In Proc. 28th ACM Symp. Theory Comput., </booktitle> <pages> pages 329-337, </pages> <year> 1996. </year>
Reference-contexts: Similarly, achieving an n * -approximation for Minimum Independent Set is NP-hard [25], however for planar graphs, Minimum Independent Set can be approximated to within (1 + *) [6]. Similar results hold for most optimization problem when restricted to planar graphs <ref> [35] </ref>. There exists a (1 + o (1)) ln n lower bound for approximating the Set Cover problem [17], however the Rectangle Cover problem, covering a set of axis-aligned rectangles with minimum number of points, has no such inapproximability results [42].
Reference: [36] <author> M. Klawe, W Paul, N. Pippenger, and M. Yannakakis. </author> <title> On monotone formulae with restricted depth. </title> <booktitle> In Proc. 16th ACM Symp. Theory Comp., </booktitle> <pages> pages 539-550, </pages> <year> 1984. </year>
Reference-contexts: The problem here is that the number of internal nodes in this representation is no longer polynomial in the number of leaves, and this condition was necessary for our reductions. There is a wealth of research related to monotone formulae and circuits in this respect <ref> [36, 46, 56] </ref>, however it is open to strengthen any of our inapproximability results for and/or scheduling. 11 Conclusions & Open Problems We explain the lack of progress in finding optimal or near-optimal assembly sequences by formally proving the inapproximability for minimzing the cost of an assembly sequence for a variety
Reference: [37] <author> S. Krishnan and A. Sanderson. </author> <title> Path planning algorithms for assembly sequence planning. </title> <booktitle> In Proc. Int. Symp. on Intelligent Robotics, </booktitle> <pages> pages 428-439, </pages> <year> 1991. </year>
Reference-contexts: Section 10 discusses some particularly interesting complexity issues relating to and/or scheduling, and finally Section 11 discuss several other open directions for research, and contains concluding remarks. 2 Previous Work 2.1 Assembly Sequencing The use of automation in assembly sequencing has increased rapidly over the years <ref> [7, 16, 26, 27, 28, 37, 39, 50, 51, 53, 54] </ref>. Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process.
Reference: [38] <author> S. Lee. </author> <title> Backward assembly planning with assembly cost analysis. </title> <booktitle> In Proc IEEE Int. Conf. on Robotics and Automation, </booktitle> <pages> pages 2382-2391, </pages> <year> 1992. </year>
Reference-contexts: For a more detailed discussion, 4 In general, these tasks are not symmetric, for instance when flexible parts are deformed during assembly <ref> [38] </ref>. 6 see [52, 50, 54]. Figure 1 gives an example, taken from [52], of such an assembly tree for a simple two-dimensional product.
Reference: [39] <author> S. Lee and Y. Shin. </author> <title> Assembly planning based on geometric reasoning. </title> <journal> Computers and Graphics, </journal> <volume> 14(2) </volume> <pages> 237-250, </pages> <year> 1990. </year>
Reference-contexts: Section 10 discusses some particularly interesting complexity issues relating to and/or scheduling, and finally Section 11 discuss several other open directions for research, and contains concluding remarks. 2 Previous Work 2.1 Assembly Sequencing The use of automation in assembly sequencing has increased rapidly over the years <ref> [7, 16, 26, 27, 28, 37, 39, 50, 51, 53, 54] </ref>. Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process.
Reference: [40] <author> C. Lund and M. Yannakakis. </author> <title> On the hardness of approximating minimization problems. </title> <journal> J. ACM, </journal> <volume> 41(5) </volume> <pages> 960-981, </pages> <year> 1994. </year>
Reference-contexts: This class includes problems such as Clique [25] and Coloring <ref> [40] </ref>. We give a series of results, proving not only the hardness of finding the exact optimal solutions in this model, but even of finding reasonable approximation algorithms. To do so, we use approximation-preserving reductions [42, 44].
Reference: [41] <author> M. Middendorf. Supersequences, </author> <title> runs, and CD grammar systems. </title> <editor> In J. Dassow and A. Kelemenova, editors, </editor> <booktitle> Developments in Theoretical Computer Science, volume 6 of Topics in Computer Science, </booktitle> <pages> pages 101-114. </pages> <year> 1994. </year>
Reference-contexts: At this point, we rely on results shown in [8], combined with a result of <ref> [41] </ref>, which prove these claims, where the number of machines corresponds to jF j. <p> Finally, even if strings have consecutive occurences of the same symbol, it was shown that for an alphabet of size jj = 3, that finding a common supersequence with the minimum number of runs is NP-complete <ref> [41] </ref>. A run is defined as a group of consecutive occurences of the same symbol, and hence the number of runs is exactly equal to the number of re-orientation in our problem. For this reason, minimizing the number of re-orientations is NP-complete when jF j = 3.
Reference: [42] <author> R. Motwani. </author> <title> Approximation algorithms. </title> <type> Stanford Technical Report STAN-CS-92-1435, </type> <year> 1992. </year>
Reference-contexts: For this reason, we approach these problems using techniques common to the theory of approx-imability <ref> [4, 18, 31, 42] </ref>. Since we cannot expect to find the optimal sequence in polynomial time, we look for a polynomial time approximation algorithm which returns a solution whose cost can be bounded by some function of the true optimal cost. <p> This class includes problems such as Clique [25] and Coloring [40]. We give a series of results, proving not only the hardness of finding the exact optimal solutions in this model, but even of finding reasonable approximation algorithms. To do so, we use approximation-preserving reductions <ref> [42, 44] </ref>. Classical reductions, for instance those equating all NP-complete problems, show that finding the optimal solution for one problem can be used to find the optimal solution for another problem. <p> There exists a (1 + o (1)) ln n lower bound for approximating the Set Cover problem [17], however the Rectangle Cover problem, covering a set of axis-aligned rectangles with minimum number of points, has no such inapproximability results <ref> [42] </ref>. To the best of our knowledge, the geometric results in Section 9 provide the strongest inapprox-imability bounds shown for a natural, combinatorial, geometric problem. <p> The problem is the following, given a collection of polygons (possibly degenerate), in the plane, the goal is to pick a minimum number of points so that each polygon contains a point. An even more restricted problem, Rectangle Cover is defined in <ref> [42] </ref>, where all polygons are axis-aligned rectangles, however it is not even known if Rectangle Cover is NP-hard. However, we can prove the NP-completeness of Polygon Cover through a reduction from Planar Vertex Cover, which is known to be NP-complete [18].
Reference: [43] <author> B. Natarajan. </author> <title> On planning assemblies. </title> <booktitle> In Proc. 4th ACM Symp. on Computational Geometry, </booktitle> <pages> pages 299-308, </pages> <year> 1988. </year>
Reference-contexts: Early systems resulted in inefficient generate-and-test sequencers, operating by generating candidate operations and testing their feasibility [28, 53]. However, if arbitrarily complex motions and paths are allowed, assembly sequencing was shown to be intractable <ref> [29, 34, 43, 54] </ref>. This led some researchers to consider restricted, but still interesting, versions of the problem (e.g., monotone sequences, where each operation generates a final subassembly, and two-handed sequences, where every operation merges exactly two subassemblies).
Reference: [44] <author> C. Papadimitriou and M. Yannakakis. </author> <title> Optimization, approximation, and complexity classes. </title> <journal> J. Comput. Systems Sci., </journal> <volume> 43(3) </volume> <pages> 425-440, </pages> <year> 1991. </year>
Reference-contexts: Many researches have worked towards classifying the approximability of different NP-hard problems <ref> [4, 5, 12, 44] </ref>. We will consider four broad classes defined in [4], which group problems based on the strength of the inapproximability results which have been proven. <p> Class I includes all problems for which approximating the optimal solution to within a factor of (1 + *) is NP-hard for some * &gt; 0. The canonical problem for this class is Max-3Sat, and the class includes all Max-SNP-complete problems <ref> [44] </ref>, for example Vertex Cover, Metric TSP, Max Cut, and others. Class II groups those problems for which it is quasi-NP-hard 3 to achieve an approximation ratio of c log n for some c &gt; 0. <p> This class includes problems such as Clique [25] and Coloring [40]. We give a series of results, proving not only the hardness of finding the exact optimal solutions in this model, but even of finding reasonable approximation algorithms. To do so, we use approximation-preserving reductions <ref> [42, 44] </ref>. Classical reductions, for instance those equating all NP-complete problems, show that finding the optimal solution for one problem can be used to find the optimal solution for another problem.
Reference: [45] <author> C. Papadimitriou and M. Yannakakis. </author> <title> The traveling salesman problem with distances one and two. </title> <journal> Mathematics of Operations Research, </journal> <volume> 18(1) </volume> <pages> 1-11, </pages> <year> 1993. </year>
Reference-contexts: More often than not, an optimization problem becomes significantly easier when its input is restricted to a geometric setting. For example, there exists some c &gt; 0 for which achieving a (1 + c)- approximation for the Metric TSP problem is NP-hard <ref> [45] </ref>, however in the Euclidean plane, TSP can be approximated to within (1 + *) for all * &gt; 0 [2]. Similarly, achieving an n * -approximation for Minimum Independent Set is NP-hard [25], however for planar graphs, Minimum Independent Set can be approximated to within (1 + *) [6].
Reference: [46] <author> R. Raz and A. Wigderson. </author> <title> Monotone circuits for matching require linear depth. </title> <journal> J. ACM, </journal> <volume> 39(3) </volume> <pages> 736-744, </pages> <year> 1992. </year>
Reference-contexts: The problem here is that the number of internal nodes in this representation is no longer polynomial in the number of leaves, and this condition was necessary for our reductions. There is a wealth of research related to monotone formulae and circuits in this respect <ref> [36, 46, 56] </ref>, however it is open to strengthen any of our inapproximability results for and/or scheduling. 11 Conclusions & Open Problems We explain the lack of progress in finding optimal or near-optimal assembly sequences by formally proving the inapproximability for minimzing the cost of an assembly sequence for a variety
Reference: [47] <author> B. Romney, C. Godard, M. Goldwasser, and G. Ramkumar. </author> <title> An efficient system for geometric assembly sequence generation and evaluation. </title> <booktitle> In Proc. ASME Int. Computers in Engineering Conference, </booktitle> <pages> pages 699-712, </pages> <year> 1995. </year>
Reference-contexts: I 1 + * Max-3Sat II O (log n) Set Cover III 2 log 1fl n LabelCover IV n * Clique The four classes and their representative problems. (Table 10.1 from [4]) Several software systems offer the user the option of optimizing the sequence over a choice of complexity measures <ref> [33, 47, 54] </ref>, however these systems currently must rely on either a brute force search of the entire space, or else branch-and-bound type searches with no performance guarantees for the resulting sequence. 2.2 Approximation Theory For most of our variants, finding the optimal cost assembly sequence is NP-hard. <p> This algorithm runs in polynomially time, is quite simple, and has been implemented to construct assembly sequences for many of the above motion classes <ref> [33, 47] </ref>. <p> In our terms the goal is to find a sequence of operations which begin with the fully assembled product, and results in the complete decomposition into individual parts. Each leaf of the assembly tree must consist of an individual part. G2 Remove a key part. <ref> [47] </ref> Instead of disassembling the entire product, it is often desirable to quickly remove a single key part from an assembly without necessarily disassembling the entire product. The motivation 8 for this stems from issues of maintenance and recycling. <p> Although we are ignoring many such important issues, we consider a few such restricted versions of the assembly sequencing problem. R1 Linear Sequence. <ref> [47, 52] </ref> A linear assembly sequence is one in which each operation brings together a single part with an existing subassembly. Such sequences are reminiscent of a classical assembly line, in which each station is responsible for adding one part. <p> Our view is that studying these basic measures in depth is a necessary first step before examining specialized combinations of complexity measures. C1 Fewest Number of Directions. <ref> [47, 52, 54] </ref> The cost of an assembly sequence is equal to the number of directions in F which are used. Once a direction has been used, future uses of the same direction are free of charge.
Reference: [48] <author> J. Snoeyink and J. Stolfi. </author> <title> Objects that cannot be taken apart with two hands. </title> <booktitle> In Proc. ACM Symp. on Computational Geometry, </booktitle> <pages> pages 247-256, </pages> <year> 1993. </year>
Reference-contexts: Quite naturally, research from computational geometry relates very closely to assembly sequencing. The separability of objects has been well studied in the geometric community <ref> [13, 14, 15, 23, 48, 49] </ref>. In a single direction, a depth order of a set of parts is an ordering of the parts which allows for collision-free translations of the individual parts to infinity. <p> However, there exists a set of convex parts in three dimensions which cannot be disassembled using two hands, with only translations to infinity, or even generalized rotations and translations <ref> [48] </ref>. A surprising element of our problem is that the general lower bounds given in Section 8, are realized in Section 9, for a simple geometric setting consisting of a collection of unit disks in the plane.
Reference: [49] <author> G. Toussaint. </author> <title> Movable separability of sets. </title> <editor> In G. Toussaint, editor, </editor> <booktitle> Computational Geometry, </booktitle> <pages> pages 335-375. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, Netherlands, </address> <year> 1985. </year>
Reference-contexts: Quite naturally, research from computational geometry relates very closely to assembly sequencing. The separability of objects has been well studied in the geometric community <ref> [13, 14, 15, 23, 48, 49] </ref>. In a single direction, a depth order of a set of parts is an ordering of the parts which allows for collision-free translations of the individual parts to infinity. <p> Similar separability issues are studied in two dimensions for more general classes of shapes, such as monotone or star-shaped polygons <ref> [49] </ref>. For a collection of balls in R d , there exists at least d + 1 balls, each of which can be translated to infinity in some direction [13].
Reference: [50] <author> R. Wilson. </author> <title> On Geometric Assembly Planning. </title> <type> Ph.D. thesis, </type> <institution> Dept. Comput. Sci., Stanford Univ., Stanford, </institution> <address> CA, </address> <year> 1992. </year> <note> Stanford Technical Report STAN-CS-92-1416. </note>
Reference-contexts: We begin by studying a graph-theoretic generalization of assembly sequencing which we term virtual assembly sequencing (VAS). Much of the success in finding feasible sequences has been a result of the introduction of the non-directional blocking graph <ref> [50, 52] </ref>. For a given direction of motion, the geometric model of the product can be analyzed to construct a graph which represents the blocking relationships among the parts. <p> Section 10 discusses some particularly interesting complexity issues relating to and/or scheduling, and finally Section 11 discuss several other open directions for research, and contains concluding remarks. 2 Previous Work 2.1 Assembly Sequencing The use of automation in assembly sequencing has increased rapidly over the years <ref> [7, 16, 26, 27, 28, 37, 39, 50, 51, 53, 54] </ref>. Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process. <p> For many classes of motions, described by a constant number of degrees of freedom, polynomial algorithms were developed which will find an assembly sequence if one exists <ref> [22, 24, 50, 52] </ref>. Most of this success can be achieved within the framework of nondirectional blocking graphs [50, 52], and as our work is intricately related to this approach, we review these approaches in more detail in Section 3.1. <p> For many classes of motions, described by a constant number of degrees of freedom, polynomial algorithms were developed which will find an assembly sequence if one exists [22, 24, 50, 52]. Most of this success can be achieved within the framework of nondirectional blocking graphs <ref> [50, 52] </ref>, and as our work is intricately related to this approach, we review these approaches in more detail in Section 3.1. It is also possible to enumerate all possible assembly sequences [16], although there may be exponentially many such sequences for a product. <p> For a more detailed discussion, 4 In general, these tasks are not symmetric, for instance when flexible parts are deformed during assembly [38]. 6 see <ref> [52, 50, 54] </ref>. Figure 1 gives an example, taken from [52], of such an assembly tree for a simple two-dimensional product.
Reference: [51] <author> R. Wilson, L. Kavraki, and T. Lozano-Perez. </author> <title> Two-handed assembly sequencing. </title> <type> Stanford Technical Report STAN-CS-93-1478, </type> <year> 1993. </year>
Reference-contexts: Section 10 discusses some particularly interesting complexity issues relating to and/or scheduling, and finally Section 11 discuss several other open directions for research, and contains concluding remarks. 2 Previous Work 2.1 Assembly Sequencing The use of automation in assembly sequencing has increased rapidly over the years <ref> [7, 16, 26, 27, 28, 37, 39, 50, 51, 53, 54] </ref>. Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process.
Reference: [52] <author> R. Wilson and J.-C. Latombe. </author> <title> Geometric reasoning about mechanical assembly. </title> <journal> Artificial Intelligence, </journal> <volume> 71(2) </volume> <pages> 371-396, </pages> <year> 1994. </year>
Reference-contexts: We begin by studying a graph-theoretic generalization of assembly sequencing which we term virtual assembly sequencing (VAS). Much of the success in finding feasible sequences has been a result of the introduction of the non-directional blocking graph <ref> [50, 52] </ref>. For a given direction of motion, the geometric model of the product can be analyzed to construct a graph which represents the blocking relationships among the parts. <p> For many classes of motions, described by a constant number of degrees of freedom, polynomial algorithms were developed which will find an assembly sequence if one exists <ref> [22, 24, 50, 52] </ref>. Most of this success can be achieved within the framework of nondirectional blocking graphs [50, 52], and as our work is intricately related to this approach, we review these approaches in more detail in Section 3.1. <p> For many classes of motions, described by a constant number of degrees of freedom, polynomial algorithms were developed which will find an assembly sequence if one exists [22, 24, 50, 52]. Most of this success can be achieved within the framework of nondirectional blocking graphs <ref> [50, 52] </ref>, and as our work is intricately related to this approach, we review these approaches in more detail in Section 3.1. It is also possible to enumerate all possible assembly sequences [16], although there may be exponentially many such sequences for a product. <p> Several empirical measures have been suggested [10], and more formal complexity measures are examined in a generalized system [54]. The importance of using automated reasoning to evaluate the complexity of assembly sequences is discussed, along with the introduction of several evaluation measures <ref> [52] </ref>. A hierarchical approach is used to identify common subassemblies in products, thereby allowing more effort to be used towards finding a "better" assembly sequence [11]. Although practical, this technique simply delays the eventual need for better automated reasoning to overcome increasingly large data sets. <p> For a more detailed discussion, 4 In general, these tasks are not symmetric, for instance when flexible parts are deformed during assembly [38]. 6 see <ref> [52, 50, 54] </ref>. Figure 1 gives an example, taken from [52], of such an assembly tree for a simple two-dimensional product. <p> For a more detailed discussion, 4 In general, these tasks are not symmetric, for instance when flexible parts are deformed during assembly [38]. 6 see [52, 50, 54]. Figure 1 gives an example, taken from <ref> [52] </ref>, of such an assembly tree for a simple two-dimensional product. <p> Figure 2, also from <ref> [52] </ref>, gives an example of a two-dimensional product as well as two DBGs for infinitesimal translation. <p> In general, it seems that if the family of motions has a constant number of degrees of freedom, then the number of distinct equivalence classes is polynomially bounded. Techniques from computational geometry allow for the construction of the NDBG for a variety of motion classes, including infinitesimal translations <ref> [52] </ref>, extended translations (i.e., to infinity) [52], multiple step translations [24], and infinitesimal generalized motions (i.e., rigid body motions) [22, 52]. For each of these families of motions, the NDBG framework immediately provides a polynomial time algorithm for constructing a feasible assembly sequence, if one exists. <p> Techniques from computational geometry allow for the construction of the NDBG for a variety of motion classes, including infinitesimal translations <ref> [52] </ref>, extended translations (i.e., to infinity) [52], multiple step translations [24], and infinitesimal generalized motions (i.e., rigid body motions) [22, 52]. For each of these families of motions, the NDBG framework immediately provides a polynomial time algorithm for constructing a feasible assembly sequence, if one exists. <p> Techniques from computational geometry allow for the construction of the NDBG for a variety of motion classes, including infinitesimal translations [52], extended translations (i.e., to infinity) [52], multiple step translations [24], and infinitesimal generalized motions (i.e., rigid body motions) <ref> [22, 52] </ref>. For each of these families of motions, the NDBG framework immediately provides a polynomial time algorithm for constructing a feasible assembly sequence, if one exists. <p> Although we are ignoring many such important issues, we consider a few such restricted versions of the assembly sequencing problem. R1 Linear Sequence. <ref> [47, 52] </ref> A linear assembly sequence is one in which each operation brings together a single part with an existing subassembly. Such sequences are reminiscent of a classical assembly line, in which each station is responsible for adding one part. <p> Our view is that studying these basic measures in depth is a necessary first step before examining specialized combinations of complexity measures. C1 Fewest Number of Directions. <ref> [47, 52, 54] </ref> The cost of an assembly sequence is equal to the number of directions in F which are used. Once a direction has been used, future uses of the same direction are free of charge. <p> This is typically slow and might require additional expensive fixtures. In both of these cases, using an orientation that was encountered earlier in the process is of no advantage unless the product is still in that orientation. C3 Fewest Number of Non-Linear Steps. <ref> [52] </ref> A step is linear if one of the two subassemblies is a single part. The cost of an assembly sequence is equal to the number of non-linear steps. <p> The motivations for this measure are similar to those for the R1 restriction, however rather than absolutely requiring that all steps are linear, we simply attempt to minimize the use of non-linear operations. C4 Minimum Depth of an Assembly Sequence. <ref> [52] </ref> The cost of an assembly sequence is equal to the depth of the corresponding tree. <p> In polynomial time, we may check whether a set of graphs admits a feasible linear sequence for any of our goals. * A stack assembly is defined in <ref> [52] </ref>, as a product which can be completely (dis)assembled using translations along a single direction.
Reference: [53] <author> R. Wilson and J. Rit. </author> <title> Maintaining geometric dependencies in and assembly planner. </title> <booktitle> In Proc. IEEE Int. Conf. on Robotics and Automation, </booktitle> <pages> pages 890-895, </pages> <year> 1990. </year>
Reference-contexts: Section 10 discusses some particularly interesting complexity issues relating to and/or scheduling, and finally Section 11 discuss several other open directions for research, and contains concluding remarks. 2 Previous Work 2.1 Assembly Sequencing The use of automation in assembly sequencing has increased rapidly over the years <ref> [7, 16, 26, 27, 28, 37, 39, 50, 51, 53, 54] </ref>. Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process. <p> Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process. Early systems resulted in inefficient generate-and-test sequencers, operating by generating candidate operations and testing their feasibility <ref> [28, 53] </ref>. However, if arbitrarily complex motions and paths are allowed, assembly sequencing was shown to be intractable [29, 34, 43, 54].
Reference: [54] <author> J. Wolter. </author> <title> On the Automatic Generation of Plans for Mechanical Assembly. </title> <type> Ph.D. thesis, </type> <institution> University of Michigan, </institution> <year> 1988. </year>
Reference-contexts: Section 10 discusses some particularly interesting complexity issues relating to and/or scheduling, and finally Section 11 discuss several other open directions for research, and contains concluding remarks. 2 Previous Work 2.1 Assembly Sequencing The use of automation in assembly sequencing has increased rapidly over the years <ref> [7, 16, 26, 27, 28, 37, 39, 50, 51, 53, 54] </ref>. Progressing from days when assembly sequencing was purely a craft of the human designers, computers have become a powerful tool in the sequencing process. <p> Early systems resulted in inefficient generate-and-test sequencers, operating by generating candidate operations and testing their feasibility [28, 53]. However, if arbitrarily complex motions and paths are allowed, assembly sequencing was shown to be intractable <ref> [29, 34, 43, 54] </ref>. This led some researchers to consider restricted, but still interesting, versions of the problem (e.g., monotone sequences, where each operation generates a final subassembly, and two-handed sequences, where every operation merges exactly two subassemblies). <p> There are many possible ways to define the cost of a sequence, depending on how these sequences will be used eventually in a manufacturing system. Several empirical measures have been suggested [10], and more formal complexity measures are examined in a generalized system <ref> [54] </ref>. The importance of using automated reasoning to evaluate the complexity of assembly sequences is discussed, along with the introduction of several evaluation measures [52]. A hierarchical approach is used to identify common subassemblies in products, thereby allowing more effort to be used towards finding a "better" assembly sequence [11]. <p> I 1 + * Max-3Sat II O (log n) Set Cover III 2 log 1fl n LabelCover IV n * Clique The four classes and their representative problems. (Table 10.1 from [4]) Several software systems offer the user the option of optimizing the sequence over a choice of complexity measures <ref> [33, 47, 54] </ref>, however these systems currently must rely on either a brute force search of the entire space, or else branch-and-bound type searches with no performance guarantees for the resulting sequence. 2.2 Approximation Theory For most of our variants, finding the optimal cost assembly sequence is NP-hard. <p> For a more detailed discussion, 4 In general, these tasks are not symmetric, for instance when flexible parts are deformed during assembly [38]. 6 see <ref> [52, 50, 54] </ref>. Figure 1 gives an example, taken from [52], of such an assembly tree for a simple two-dimensional product. <p> Our view is that studying these basic measures in depth is a necessary first step before examining specialized combinations of complexity measures. C1 Fewest Number of Directions. <ref> [47, 52, 54] </ref> The cost of an assembly sequence is equal to the number of directions in F which are used. Once a direction has been used, future uses of the same direction are free of charge. <p> Note that this differs from restriction R2, in that we are not told which directions to use in restricting our search. C2 Fewest Re-orientations. <ref> [54] </ref> The cost of an assembly sequence is equal to the number of operations which use a direction which is different from the previous operation. <p> The key is that we will describe the shape of each peg in a way so that it can only be translated away from the base in a specifc region of the space of directions. As pointed out in <ref> [54] </ref>, this instance looks very much like a Set Cover problem, in that we must chose a minimum number of directions, where each direction allows for the removal of some set of pegs.
Reference: [55] <author> T. Woo and D. Dutta. </author> <title> Automatic disassembly and total ordering in three dimensions. </title> <journal> J. Engineering for Industry, </journal> <volume> 113(2) </volume> <pages> 207-213, </pages> <year> 1991. </year>
Reference-contexts: For a restricted class of inputs which have a so-called "total ordering" property, a greedy algorithm is given which claims to produce the minimal length sequence to remove any given part <ref> [55] </ref>, however the required input property does not have a clear definition, and as our results will show, this problem is quite difficult. 3 Class Factor of Approximation that is hard Representative Problems I 1 + * Max-3Sat II O (log n) Set Cover III 2 log 1fl n LabelCover IV
Reference: [56] <author> A. Yao. </author> <title> A lower bound for the monotone depth of connectivity. </title> <booktitle> In Proc. 35th Symp. on Found. Comput. Sci., </booktitle> <pages> pages 302-308, </pages> <year> 1994. </year> <month> 31 </month>
Reference-contexts: The problem here is that the number of internal nodes in this representation is no longer polynomial in the number of leaves, and this condition was necessary for our reductions. There is a wealth of research related to monotone formulae and circuits in this respect <ref> [36, 46, 56] </ref>, however it is open to strengthen any of our inapproximability results for and/or scheduling. 11 Conclusions & Open Problems We explain the lack of progress in finding optimal or near-optimal assembly sequences by formally proving the inapproximability for minimzing the cost of an assembly sequence for a variety
References-found: 56

