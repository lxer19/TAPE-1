URL: http://theory.lcs.mit.edu/tds/papers/Lynch/TM-480c.ps
Refering-URL: http://theory.lcs.mit.edu/tds/papers/Lynch/TM-480c.html
Root-URL: 
Title: Formal Aspects of  Action Transducers and Timed Automata  
Author: Nancy Lynch ; and Frits Vaandrager ; 
Keyword: Real-time; process algebra; action transducers; timed automata; timed trace inclusion; congruence properties  
Address: LCS, Cambridge, MA 02139, USA, lynch@theory.lcs.mit.edu 5 CWI, P.O. Box 94079, 1090 GB Amsterdam, The Netherlands,  
Affiliation: 4 MIT,  
Note: c  
Pubnum: Computing  
Email: fritsv@cwi.nl  
Date: (1995) 3: 1-000  1995 BCS  
Abstract: The timed automaton model of [LV92, LV93] is a general model for timing-based systems. A notion of timed action transducer is here defined as an automata-theoretic way of representing operations on timed automata. It is shown that two timed trace inclusion relations are substitutive with respect to operations that can be described by timed action transducers. Examples are given of operations that can be described in this way, and a preliminary proposal is given for an appropriate language of operators for describing timing-based systems. 
Abstract-found: 1
Intro-found: 1
Reference: [AD94] <author> R. Alur and D.L. Dill. </author> <title> A theory of timed automata. </title> <journal> Theoretical Computer Science, </journal> <volume> 126 </volume> <pages> 183-235, </pages> <year> 1994. </year>
Reference-contexts: Other untimed operations included are an interrupt operation similar to those used in Extended LOTOS [Bri88] and CSP [Hoa85], disjoint union, and a binary version of Kleene's star. We also describe several timed operations as timed action transducers: a CLOCK operation directly inspired by the clock variables of <ref> [AD94, AH94] </ref>, a BOUND operation that can block the passage of time, and a RATE operation that can change the speed of its argument. <p> Using only these operations and untimed operations, we can construct many of the other timed operations appearing in the literature, including a very general timer similar to that used in the timed !-automata model of Alur and Dill <ref> [AD94] </ref>, the timeout construct of Timed CSP [RR88, DS89], and the execution delay operation of the timed process algebra ATP [NS94]. We can also define a minor variant of Alur and Dill's timed automata [AD94], as well as the finite-state subcase of the timed automaton model of Merritt, Modugno and Tuttle <p> very general timer similar to that used in the timed !-automata model of Alur and Dill <ref> [AD94] </ref>, the timeout construct of Timed CSP [RR88, DS89], and the execution delay operation of the timed process algebra ATP [NS94]. We can also define a minor variant of Alur and Dill's timed automata [AD94], as well as the finite-state subcase of the timed automaton model of Merritt, Modugno and Tuttle [MMT91]. All of this provides evidence of the power of our proposed language. <p> Clocks Timed action transducers that are obtained via the patient construction do not impose time constraints on their arguments. One way to impose such constraints is by using explicit clock variables, as advocated in <ref> [AD94, AH94] </ref>. In this subsection, we show how clock variables can be expressed using timed action transducers. The unary timed action transducer CLOCK x models the effect of adding a clock variable x to a system. <p> CLOCK x is trivially Zeno- and t -respecting. Thus relations t fl and t are substitutive for this action transducer. Our definition of clocks directly follows the one proposed in <ref> [AD94, AH94] </ref>. <p> Clearly, BOUND b x is Zeno- and t - respecting. Thus relations t fl and t are substitutive for this action transducer. In the literature many other proposals can be found on how to constrain the passage of time: <ref> [AD94] </ref> uses a Buchi style acceptance criterion for this purpose, [HNSY92] advocates the use of program invariants, [AH94] proposes the related notion of delay predicates, [MP93] uses so-called important events, and [BPV94] uses stability with respect to linear inequalities. <p> However, results in this area still need to be worked out. An obvious question left open in this paper is to find a sound and complete axiomatisation of timed trace inclusion for the language L t or a fragment of it. Results of <ref> [AD94] </ref> can be adapted to show that, even if we exclude the RATE operator and only allow for rational numbers in clock constraints and bounds, deciding timed trace inclusion for L t is 1 hard. Hence there does not exist a 38 N.A. Lynch and F.W.
Reference: [AH94] <author> R. Alur and T.A. Henzinger. </author> <title> Real-time system = discrete system + clock variables. </title> <editor> In T. Rus and C. Rattray, editors, </editor> <booktitle> Theories and Experiences for Real-Time System Development | Papers presented at First AMAST Workshop on Real-Time System Development, </booktitle> <address> Iowa City, Iowa, </address> <month> November </month> <year> 1993, </year> <pages> pages 1-29. </pages> <publisher> World Scientific, </publisher> <year> 1994. </year>
Reference-contexts: Other untimed operations included are an interrupt operation similar to those used in Extended LOTOS [Bri88] and CSP [Hoa85], disjoint union, and a binary version of Kleene's star. We also describe several timed operations as timed action transducers: a CLOCK operation directly inspired by the clock variables of <ref> [AD94, AH94] </ref>, a BOUND operation that can block the passage of time, and a RATE operation that can change the speed of its argument. <p> A Timed Process Algebra In this section, we give examples of operations that can be expressed as timed action transducers. Together, these operations form a language that we will call L t . Paraphrasing Alur and Henzinger <ref> [AH94] </ref>, we can summarise the main idea behind L t as: real-time process algebra = untimed process algebra + timers. After the definition of the operators of L t in Section 5.1, we will discuss the expressivity of the language in Section 5.2. 5.1. Operators 5.1.1. <p> Clocks Timed action transducers that are obtained via the patient construction do not impose time constraints on their arguments. One way to impose such constraints is by using explicit clock variables, as advocated in <ref> [AD94, AH94] </ref>. In this subsection, we show how clock variables can be expressed using timed action transducers. The unary timed action transducer CLOCK x models the effect of adding a clock variable x to a system. <p> CLOCK x is trivially Zeno- and t -respecting. Thus relations t fl and t are substitutive for this action transducer. Our definition of clocks directly follows the one proposed in <ref> [AD94, AH94] </ref>. <p> CLOCK x is trivially Zeno- and t -respecting. Thus relations t fl and t are substitutive for this action transducer. Our definition of clocks directly follows the one proposed in [AD94, AH94]. In fact, it is possible to encode each (finite state) clock-constrained system in the sense of <ref> [AH94] </ref> within our language: by Theorem 3.1 we can encode the underlying finite automaton (with the clock constraints viewed as part of the transition labels), and if we then apply a CLOCK operator for each of the clock variables that is used, the resulting expression will generate the same timed traces <p> Thus relations t fl and t are substitutive for this action transducer. In the literature many other proposals can be found on how to constrain the passage of time: [AD94] uses a Buchi style acceptance criterion for this purpose, [HNSY92] advocates the use of program invariants, <ref> [AH94] </ref> proposes the related notion of delay predicates, [MP93] uses so-called important events, and [BPV94] uses stability with respect to linear inequalities.
Reference: [AL92] <author> M. Abadi and L. Lamport. </author> <title> An old-fashioned recipe for real time. </title> <editor> In de Bakker et al. </editor> <booktitle> [dBHRR92], </booktitle> <pages> pages 1-27. </pages>
Reference-contexts: The system allows a lamp to be switched on at any time; then between 9 and 10 time units after the last time the lamp has been switched on, it will be switched off. is strict or not. Alternatively, one can follow a suggestion of Abadi and Lamport <ref> [AL92] </ref>, and introduce, as additional elements of the time domain, the set of all `infinitesimally shifted' real numbers r , where t r iff t &lt; r, for any reals t and r. 32 N.A. Lynch and F.W. <p> Thus far, however, process algebraic techniques cannot claim much success when it comes to verification of timed systems. Here assertional methods appear to perform much better (see, for instance, [SALL93, HL94, BPV94]). Because the notion of explicit timers fits rather well with assertional proof techniques for real-time (see <ref> [AL92, BPV94] </ref>), we hope that it will be not too difficult to use these techniques, and in particular the simulation proof methods of [LV92, LV93], in the setting of our language L t .
Reference: [BB91] <author> J.C.M. Baeten and J.A. Bergstra. </author> <title> Real time process algebra. </title> <journal> Journal of Formal Aspects of Computing Science, </journal> <volume> 3(2) </volume> <pages> 142-188, </pages> <year> 1991. </year>
Reference-contexts: In the untimed setting, bisimulation equivalences have been reasonably successful as notions of implementation between transition systems [BW90, Mil89]. Consequently, bisimulation equivalences have also been proposed as implementation relations for the timed setting <ref> [BB91, Klu93, MT90, NS94, Yi90] </ref>. However, we do not believe that bisimulations will turn out to be very useful as implementation relations in the timed case. <p> On the other hand, there are several operators that have been proposed in the literature that do not fit our format of action transducers, in particular, the CCS-style choice operation present in <ref> [BB91, MT90, NS94, Yi90] </ref>. This operation cannot be expressed 4 N.A. Lynch and F.W. Vaandrager as a timed action transducer because the timed trace inclusion relation is not substitutive with respect to it. We briefly consider the design of an appropriate language of operators for describing timing-based systems. <p> Nicollin, Sifakis and Yovine [NSY93] give a translation from ATP into Alur-Dill automata, but do not investigate the reverse translation. In fact it appears that, besides our language, only the real-time ACP language of Baeten and Bergstra <ref> [BB91] </ref> is sufficiently expressive to allow for a direct encoding of Alur-Dill automata. We present our definitions and results for timed systems by first presenting related definitions and results for untimed systems, and then building upon those to obtain the corresponding timed concepts. <p> The operations from L t are sufficiently expressive to define | as derived operators | all the constructs that we have encountered in the literature on timed process algebras, except those that involve binding mechanisms (like the integration construct of <ref> [BB91] </ref>) and those that are not compatible with timed trace inclusion (like the + from CCS). In this section, we give some of these derived operators. Also, we show how one can encode within L t the finite state fragment of the timed-bounded automata model of [MMT91]. 5.2.1. <p> Another example, taken from <ref> [BB91] </ref>, is a watch that is perfect, except for some fluctuations of the ticks: WATCH 0 = WAIT 0:5 ; ((WAIT [0:5 *; 0:5 + *] ; tick ; STOP) ^ WAIT 1) ! : 5.2.3. <p> Another example is the choice operator + that plays a dominant role in many real-time process calculi (TCCS [MT90], the timed extension of CCS proposed in [Yi90], ATP [NS94], and ACP <ref> [BB91] </ref>). <p> However, it may be possible to find interesting partial results: axioms that allow the elimination of certain operators in favor of others, or complete axioma-tisations of subcalculi. For this it might be necessary to add to the language auxiliary operators such as the integration construct of timed ACP <ref> [BB91] </ref>. Before it can become practically useful, the language L t will have to be extended with a more powerful mechanism for recursion, and with the possibility to parameterise processes and actions with data.
Reference: [BBP94] <author> J.A. Bergstra, I. Bethke, and A. Ponse. </author> <title> Process algebra with iteration and nesting. </title> <journal> The Computer Journal, </journal> <volume> 37(4) </volume> <pages> 243-258, </pages> <year> 1994. </year>
Reference-contexts: Recently, the binary star has been studied in the context of ACP in <ref> [BBP94, FZ94] </ref>. The iteration construct exploits the ability of action transducers to copy their arguments: it uses an infinite number of copies of both the first and the second 16 N.A. Lynch and F.W. Vaandrager argument.
Reference: [BIM88] <author> B. Bloom, S. Istrail, and A.R. Meyer. </author> <title> Bisimulation can't be traced: Preliminary report. </title> <booktitle> In Conference Record of the 15 th ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, California, </address> <pages> pages 229-239, </pages> <year> 1988. </year> <note> Full version available as Technical Report 90-1150, </note> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, New York, </address> <month> August </month> <year> 1990. </year> <note> Accepted to appear in Journal of the ACM. </note>
Reference-contexts: Note that, since we always start copies of an argument automaton from a start state, our notion of copying is different from that of Bloom, Istrail and Meyer <ref> [BIM88] </ref>, who also allow copying from intermediate states. As a consequence, the trace preorder is substitutive for our operations, whereas it is not substitutive in general for the operations of [BIM88]. In this section we have defined the semantics of an action transducer as an operation on automata. <p> an argument automaton from a start state, our notion of copying is different from that of Bloom, Istrail and Meyer <ref> [BIM88] </ref>, who also allow copying from intermediate states. As a consequence, the trace preorder is substitutive for our operations, whereas it is not substitutive in general for the operations of [BIM88]. In this section we have defined the semantics of an action transducer as an operation on automata. In fact, it is often useful to interpret action transducers in a more general (and somewhat more complex) way, as operations on action transducers. We leave this generalisation to the reader. 2.4. <p> Discussion The main result of this paper is the characterisation in terms of action transducers of a very general class of operations that preserve inclusion of timed traces. For the untimed case, several substitutivity results for classes of operations have been reported in the literature (see, for instance, <ref> [Sim85, BIM88, GV92] </ref>). We believe our result to be the first one of this kind for the timed case. The combined complexity of multiple start states, infinitely many arguments, copying, activation and deactivation of arguments, internal actions, and different rates makes the proof of our result rather involved.
Reference: [BK90] <editor> J.C.M. Baeten and J.W. Klop, editors. </editor> <booktitle> Proceedings CONCUR 90, Amsterdam, volume 458 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1990. </year> <title> Action Transducers and Timed Automata 39 </title>
Reference: [BPV94] <author> D.J.B. Bosscher, I. Polak, and F.W. Vaandrager. </author> <title> Verification of an audio control protocol. </title> <editor> In H. Langmaack, W.-P. de Roever, and J. Vytopil, editors, </editor> <booktitle> Proceedings of the Third International School and Symposium on Formal Techniques in Real Time and Fault Tolerant Systems, Lubeck, </booktitle> <address> Germany, </address> <month> September </month> <year> 1994, </year> <booktitle> volume 863 of Lecture Notes in Computer Science, </booktitle> <pages> pages 170-192. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <note> Full version available as Report CS-R9445, </note> <institution> CWI, </institution> <address> Amsterdam, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: It is intended as a basis for formal reasoning about such systems, in particular, for verification of their correctness and for analysis of their complexity. In [LV92, LV93], we develop a full range of simulation proof methods for timed automata; these methods are used in <ref> [LLSA93, BPV94, HL94] </ref> to verify 1 A preliminary version of this paper appeared in W.R. Cleaveland, editor, Proceedings CONCUR'92, Stony Brook, New York. LNCS 630, pages 436-455. <p> In the literature many other proposals can be found on how to constrain the passage of time: [AD94] uses a Buchi style acceptance criterion for this purpose, [HNSY92] advocates the use of program invariants, [AH94] proposes the related notion of delay predicates, [MP93] uses so-called important events, and <ref> [BPV94] </ref> uses stability with respect to linear inequalities. It is not clear to us how these approaches can be transferred to a process algebraic setting, where automata are built up step by step and not given a priori. <p> For t 1, RATE [1;1+] introduces a tolerance of on all timing of its argument. We think that RATE action transducers can be useful in the process algebraic description of protocols that involve drifting clocks, such as the audio control protocol analyzed in <ref> [BPV94] </ref>. An interesting property of the RATE action transducers is that in general they do not preserve Wang's [Yi90] axiom of time determinism. <p> Use of process algebraic notation often allows one to give compact, intuitive specifications of timed systems. Thus far, however, process algebraic techniques cannot claim much success when it comes to verification of timed systems. Here assertional methods appear to perform much better (see, for instance, <ref> [SALL93, HL94, BPV94] </ref>). <p> Thus far, however, process algebraic techniques cannot claim much success when it comes to verification of timed systems. Here assertional methods appear to perform much better (see, for instance, [SALL93, HL94, BPV94]). Because the notion of explicit timers fits rather well with assertional proof techniques for real-time (see <ref> [AL92, BPV94] </ref>), we hope that it will be not too difficult to use these techniques, and in particular the simulation proof methods of [LV92, LV93], in the setting of our language L t .
Reference: [Bri88] <author> E. Brinksma. </author> <title> On the design of Extended LOTOS aspecification language for open distributed systems. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Twente, </institution> <year> 1988. </year>
Reference-contexts: These include most of the usual untimed operations from process algebra, in particular, sequential and parallel composition, external choice, action hiding and renaming. Other untimed operations included are an interrupt operation similar to those used in Extended LOTOS <ref> [Bri88] </ref> and CSP [Hoa85], disjoint union, and a binary version of Kleene's star. <p> An Untimed Process Algebra In this section, we give several examples of operations that can be expressed as action transducers; all these operations are directly inspired by operations from well-known "untimed" process algebras such as CSP [Hoa85], CIRCAL [Mil85], CCS [Mil89], Extended LOTOS <ref> [Bri88] </ref> and ACP [BW90]. <p> Such extensions are standard, however, and one could simply follow the approaches taken in process algebras such as Extended LOTOS <ref> [Bri88] </ref> or CRL [GP93]. We do not believe that one single approach, assertional or process algebraic, can solve all problems regarding the specification and verification of timed systems. A solution has to be sought rather in a smooth combination of various formalisms.
Reference: [BW90] <author> J.C.M. Baeten and W.P. Weijland. </author> <title> Process Algebra. </title> <booktitle> Cambridge Tracts in Theoretical Computer Science 18. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference-contexts: Showing that this property holds for a given timed automaton A is an interesting problem, but we do not address this problem in this paper. In the untimed setting, bisimulation equivalences have been reasonably successful as notions of implementation between transition systems <ref> [BW90, Mil89] </ref>. Consequently, bisimulation equivalences have also been proposed as implementation relations for the timed setting [BB91, Klu93, MT90, NS94, Yi90]. However, we do not believe that bisimulations will turn out to be very useful as implementation relations in the timed case. <p> An Untimed Process Algebra In this section, we give several examples of operations that can be expressed as action transducers; all these operations are directly inspired by operations from well-known "untimed" process algebras such as CSP [Hoa85], CIRCAL [Mil85], CCS [Mil89], Extended LOTOS [Bri88] and ACP <ref> [BW90] </ref>.
Reference: [dBHRR92] <editor> J.W. de Bakker, C. Huizing, W.P. de Roever, and G. Rozenberg, editors. </editor> <booktitle> Proceedings REX Workshop on Real-Time: Theory in Practice, Mook, </booktitle> <address> The Netherlands, </address> <month> June </month> <year> 1991, </year> <booktitle> volume 600 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference: [DS89] <author> J. Davies and S. Schneider. </author> <title> An introduction to Timed CSP. </title> <type> Technical Monograph PRG-75, </type> <institution> Oxford University Computing Laboratory, Programming Research Group, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: Using only these operations and untimed operations, we can construct many of the other timed operations appearing in the literature, including a very general timer similar to that used in the timed !-automata model of Alur and Dill [AD94], the timeout construct of Timed CSP <ref> [RR88, DS89] </ref>, and the execution delay operation of the timed process algebra ATP [NS94]. We can also define a minor variant of Alur and Dill's timed automata [AD94], as well as the finite-state subcase of the timed automaton model of Merritt, Modugno and Tuttle [MMT91]. <p> In this section, we give some of these derived operators. Also, we show how one can encode within L t the finite state fragment of the timed-bounded automata model of [MMT91]. 5.2.1. Wait constructs Using a single timer, we can program the process WAIT d of Timed CSP <ref> [RR88, DS89] </ref>, which waits time d and then terminates successfully. WAIT d = TIMER d x (x=d): More generally, we can specify a process that terminates successfully after waiting some nondeterministically chosen time from the closed interval [l; u]. WAIT [l; u] = TIMER u x (xl): 5.2.2. <p> With urgent actions it becomes trivial to define the urgent prefixing operators of TCCS [MT90] and ATP [NS94]: a:A = a ; A. Urgent actions are also useful for defining the timeout construct of Timed CSP. For a given delay d this operator is defined, as in <ref> [DS89] </ref>, by d = (A 2 (WAIT d ; abort ; B))nfabort g; where abort is a fresh label, not in the label set of A and B. If, at time d, A has not performed any visible action, an interrupt occurs and automaton B is started.
Reference: [FZ94] <author> W.J. Fokkink and H. Zantema. </author> <title> Basic process algebra with iteration: Completeness of its equational axioms. </title> <journal> The Computer Journal, </journal> <volume> 37(4) </volume> <pages> 259-267, </pages> <year> 1994. </year>
Reference-contexts: Recently, the binary star has been studied in the context of ACP in <ref> [BBP94, FZ94] </ref>. The iteration construct exploits the ability of action transducers to copy their arguments: it uses an infinite number of copies of both the first and the second 16 N.A. Lynch and F.W. Vaandrager argument.
Reference: [Gla93] <author> R.J. van Glabbeek. </author> <title> The linear time branching time spectrum II (the semantics of sequential systems with silent moves). </title> <editor> In E. Best, editor, </editor> <booktitle> Proceedings CONCUR 93, Hildesheim, Germany, volume 715 of Lecture Notes in Computer Science, </booktitle> <pages> pages 66-81. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Even though we advocate in this paper the use of timed trace equiv alence, we think it will be quite interesting to extend Van Glabbeek's <ref> [Gla93] </ref> lattice of process equivalences with a real-time dimension, and to study the impact of the patient construction on congruence properties for other equivalences as well. 5.4. Remarks Some untimed operators display undesired behaviour when transformed into timed operators via the patient construction. We give an example. <p> We expect that the situation in the timed case will be largely analogous to the one in the untimed linear time branching time spectrum of <ref> [Gla93] </ref> where, roughly speaking, we see that the finer the behavioural equivalence, the larger the class of operations for which it is substitutive. However, results in this area still need to be worked out.
Reference: [GP93] <author> J.F. Groote and A. Ponse. </author> <title> Proof theory for CRL: A language for processes with data. In D.J. Andrews, </title> <editor> J.F. Groote, and C.A. Middelburg, editors, </editor> <booktitle> Proceedings of the International Workshop on Semantics of Specification Languages, Workshops in Computer Science, </booktitle> <pages> pages 231-250. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Such extensions are standard, however, and one could simply follow the approaches taken in process algebras such as Extended LOTOS [Bri88] or CRL <ref> [GP93] </ref>. We do not believe that one single approach, assertional or process algebraic, can solve all problems regarding the specification and verification of timed systems. A solution has to be sought rather in a smooth combination of various formalisms.
Reference: [GSSL94] <author> R. Gawlick, R. Segala, J.F. Stgaard-Andersen, and N. Lynch. </author> <title> Liveness in timed and untimed systems. </title> <editor> In S. Abiteboul and E. Shamir, editors, </editor> <booktitle> Proceedings 21 th ICALP, Jerusalem, volume 820 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <note> A full version appears as MIT Technical Report number MIT/LCS/TR-587. </note>
Reference-contexts: Justification for the use of trace inclusions to define "implementation" appears, for example, in the work of Gawlick, Segala, Stgaard-Andersen and Lynch <ref> [GSSL94] </ref>. Basically, this justification amounts to showing that the set of admissible timed traces of A is not trivial. Doing this depends on a classification of the visible actions of A as input actions or output actions, as in the I/O automaton model of [LT87].
Reference: [GV92] <author> J.F. Groote and F.W. Vaandrager. </author> <title> Structured operational semantics and bisimu-lation as a congruence. </title> <journal> Information and Computation, </journal> <volume> 100(2) </volume> <pages> 202-260, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: In <ref> [GV92] </ref>, a sequential composition operator is described for which this is not the case: s 1 p s 1 s 2 For the patient version of this operator we obtain the undesired identity WAIT 1 ; WAIT 1 = WAIT 1: A very interesting issue that we can only touch upon <p> Discussion The main result of this paper is the characterisation in terms of action transducers of a very general class of operations that preserve inclusion of timed traces. For the untimed case, several substitutivity results for classes of operations have been reported in the literature (see, for instance, <ref> [Sim85, BIM88, GV92] </ref>). We believe our result to be the first one of this kind for the timed case. The combined complexity of multiple start states, infinitely many arguments, copying, activation and deactivation of arguments, internal actions, and different rates makes the proof of our result rather involved.
Reference: [HL94] <author> C. Heitmeyer and N.A. Lynch. </author> <title> The generalized railroad crossing | a case study in formal verification of real-time systems. </title> <booktitle> In Proceedings 15th IEEE Real-Time Systems Symposium, </booktitle> <address> San Juan, Puerto Rico, </address> <pages> pages 120-131, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: It is intended as a basis for formal reasoning about such systems, in particular, for verification of their correctness and for analysis of their complexity. In [LV92, LV93], we develop a full range of simulation proof methods for timed automata; these methods are used in <ref> [LLSA93, BPV94, HL94] </ref> to verify 1 A preliminary version of this paper appeared in W.R. Cleaveland, editor, Proceedings CONCUR'92, Stony Brook, New York. LNCS 630, pages 436-455. <p> Use of process algebraic notation often allows one to give compact, intuitive specifications of timed systems. Thus far, however, process algebraic techniques cannot claim much success when it comes to verification of timed systems. Here assertional methods appear to perform much better (see, for instance, <ref> [SALL93, HL94, BPV94] </ref>).
Reference: [HNSY92] <author> T.A. Henzinger, X. Nicollin, J. Sifakis, and S. Yovine. </author> <title> Symbolic model checking for real-time systems. </title> <booktitle> In Proceedings 7 th Annual Symposium on Logic in Computer Science, </booktitle> <address> Santa Cruz, California, </address> <pages> pages 394-406. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1992. </year>
Reference-contexts: Clearly, BOUND b x is Zeno- and t - respecting. Thus relations t fl and t are substitutive for this action transducer. In the literature many other proposals can be found on how to constrain the passage of time: [AD94] uses a Buchi style acceptance criterion for this purpose, <ref> [HNSY92] </ref> advocates the use of program invariants, [AH94] proposes the related notion of delay predicates, [MP93] uses so-called important events, and [BPV94] uses stability with respect to linear inequalities. <p> It is not clear to us how these approaches can be transferred to a process algebraic setting, where automata are built up step by step and not given a priori. Our approach to use BOUND operators can be viewed as a special case of the invariant approach of <ref> [HNSY92] </ref>, with a fixed invariant stating that the values of the clock variables never exceed the values of the corresponding bound variables. 5.1.4. Timers In applications, we will mostly want to use the clock and bound action transducers in combination.
Reference: [Hoa85] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, </address> <year> 1985. </year>
Reference-contexts: These include most of the usual untimed operations from process algebra, in particular, sequential and parallel composition, external choice, action hiding and renaming. Other untimed operations included are an interrupt operation similar to those used in Extended LOTOS [Bri88] and CSP <ref> [Hoa85] </ref>, disjoint union, and a binary version of Kleene's star. <p> We give one example in Section 3.4. 3. An Untimed Process Algebra In this section, we give several examples of operations that can be expressed as action transducers; all these operations are directly inspired by operations from well-known "untimed" process algebras such as CSP <ref> [Hoa85] </ref>, CIRCAL [Mil85], CCS [Mil89], Extended LOTOS [Bri88] and ACP [BW90].
Reference: [JSV93] <author> A.S.A. Jeffrey, S.A. Schneider, and F.W. Vaandrager. </author> <title> A comparison of additivity axioms in timed transition systems. </title> <type> Report CS-R9366, </type> <institution> CWI, </institution> <address> Amsterdam, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: The trajectory axiom S2 is a kind of converse to S1; it says that any time-passage step can be "filled in" with states for each intervening time, in a "consistent" way. For a further discussion of this axiom we refer to <ref> [LV93, JSV93] </ref>. 6 The difference is just the explicit indication of the amount of elapsed time in the time-passage action instead of using a .now function that associates the current time to a state. Action Transducers and Timed Automata 19 4.2.
Reference: [Kle56] <author> S.C. Kleene. </author> <title> Representation of events in nerve nets and finite automata. </title> <booktitle> In Automata Studies, </booktitle> <pages> pages 3-41. </pages> <publisher> Princeton University Press, </publisher> <year> 1956. </year>
Reference-contexts: A key identity satisfied by the operator is A fl B A ; (A fl B) 2 B: Kleene's star operation is best known in its unary form, but in fact the original operator introduced by Kleene in <ref> [Kle56] </ref> was binary. Recently, the binary star has been studied in the context of ACP in [BBP94, FZ94]. The iteration construct exploits the ability of action transducers to copy their arguments: it uses an infinite number of copies of both the first and the second 16 N.A. Lynch and F.W.
Reference: [Klu93] <author> A.S. Klusener. </author> <title> Models and axioms for a fragment of real time process algebra. </title> <type> PhD thesis, </type> <institution> Department of Mathematics and Computing Science, Technical University of Eindhoven, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: In the untimed setting, bisimulation equivalences have been reasonably successful as notions of implementation between transition systems [BW90, Mil89]. Consequently, bisimulation equivalences have also been proposed as implementation relations for the timed setting <ref> [BB91, Klu93, MT90, NS94, Yi90] </ref>. However, we do not believe that bisimulations will turn out to be very useful as implementation relations in the timed case. <p> However, we do not believe that bisimulations will turn out to be very useful as implementation relations in the timed case. The problem is that they do not allow one to abstract in specifications from the often very complex timing behaviour of implementations (see Chapter 10 of <ref> [Klu93] </ref> for an example). Since we believe that timed trace inclusion does form a good notion of implementation, we are interested in identifying operations on timed automata for which the timed trace inclusion relation is substitutive. This substitutivity is a prerequisite for the compositional verification of systems using timed automata. <p> It looks like that we have now reached a point at which any obvious generalisation of the class of operations violates the substitutivity property. We think that many other equivalences and preorders for timed systems that have been proposed in the literature, such as the timed bisimulation equivalence of <ref> [Klu93] </ref>, are also preserved by our class of action transducers.
Reference: [LA92] <author> N.A. Lynch and H. Attiya. </author> <title> Using mappings to prove timing properties. </title> <journal> Distributed Computing, </journal> <volume> 6(2) </volume> <pages> 121-139, </pages> <year> 1992. </year>
Reference-contexts: If, at time d, A has not performed any visible action, an interrupt occurs and automaton B is started. Note the use of the auxiliary label abort to force the choice between A and B at time d. Example. We consider a simple resource-granting system described in <ref> [LA92] </ref>. The system consists of two components, a watch and a manager. The watch ticks at an approximately-predictable rate, and the manager counts ticks in order to decide when to grant a resource. <p> MANAGER i1 for 0 &lt; i k MANAGER 0 = WAIT [0; l] ; grant The full system can now be described as the parallel composition of automata WATCH and MANAGER, with the tick action hidden: SYSTEM = (WATCH kMANAGER)nftick g: Essentially, the result about the resource-granting system proved in <ref> [LA92] </ref> is that SYSTEM t (WAIT [k c 1 l; k c 2 + l] ; grant) ! : Example. <p> We will refer to time-bounded automata as MMT-automata, derived from the names of the authors of [MMT91]. The MMT-automata model is an extension with real-time of the I/O automata model of [LT87]. It has been used extensively in <ref> [LA92, SALL93] </ref> for verification purposes. <p> Using this auxiliary expression, we define the L u -expression expr (B) by expr (B) = TIMER u 1 x 1 ( TIMER u n x n ((expr (A + ))) ); 8 Here we follow the definition from <ref> [LA92] </ref>, which is slightly more restrictive than the original definition of [MMT91] because it does not allow for strict bounds. This restriction is not crucial, but only convenient. 36 N.A. Lynch and F.W.
Reference: [Lam93] <author> L. Lamport. </author> <title> How to write a long formula. </title> <type> Research Report 119, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: Automaton A has actions CLEARING and BASIC , which correspond to the two different types of actions of T ( 0 ): clearing steps, and "basic" steps. The transitions of A are defined using precondition/effect style in Figure 1 4 . The 4 Here and elsewhere we use Lamport's <ref> [Lam93] </ref> list notation for conjunction. In this notation the formula b 1 ^ b 2 ^ b n is written as the aligned list ^ b 1 ^ b 2 ^ b n 10 N.A. Lynch and F.W.
Reference: [LLSA93] <author> B.W. Lampson, N.A. Lynch, and J.F. Stgaard-Andersen. </author> <title> Correctness of at-most-once message delivery protocols. </title> <booktitle> In FORTE'93 Sixth International Conference on Formal Description Techniques, </booktitle> <address> Boston, MA, </address> <month> October </month> <year> 1993, </year> <pages> pages 387-402, </pages> <year> 1993. </year>
Reference-contexts: It is intended as a basis for formal reasoning about such systems, in particular, for verification of their correctness and for analysis of their complexity. In [LV92, LV93], we develop a full range of simulation proof methods for timed automata; these methods are used in <ref> [LLSA93, BPV94, HL94] </ref> to verify 1 A preliminary version of this paper appeared in W.R. Cleaveland, editor, Proceedings CONCUR'92, Stony Brook, New York. LNCS 630, pages 436-455.
Reference: [LT87] <author> N.A. Lynch and M.R. Tuttle. </author> <title> Hierarchical correctness proofs for distributed al 40 N.A. </title> <editor> Lynch and F.W. Vaandrager gorithms. </editor> <booktitle> In Proceedings of the 6 th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 137-151, </pages> <month> August </month> <year> 1987. </year> <note> A full version is available as MIT Technical Report MIT/LCS/TR-387. </note>
Reference-contexts: Basically, this justification amounts to showing that the set of admissible timed traces of A is not trivial. Doing this depends on a classification of the visible actions of A as input actions or output actions, as in the I/O automaton model of <ref> [LT87] </ref>. Then A is required to have the property that each of its finite executions can be extended to an admissible execution in a way that includes any given "non-Zeno" input pattern. <p> Conditions 1 and 2 slightly strengthen similar constraints that are presented in [Vaa91] in the setting of SOS. Condition 3 does not occur in [Vaa91] because there only operations with a finite number of arguments are considered. However, a similar constraint appears in the I/O automaton model of <ref> [LT87] </ref>. Theorem 2.2. The relations fl and on automata are substitutive for all t -respecting action transducers. Proof Let T be a t -respecting action transducer. We show that is substitutive for T . The proof that fl is substitutive for T is similar but slightly simpler. <p> We will refer to time-bounded automata as MMT-automata, derived from the names of the authors of [MMT91]. The MMT-automata model is an extension with real-time of the I/O automata model of <ref> [LT87] </ref>. It has been used extensively in [LA92, SALL93] for verification purposes.
Reference: [LV92] <author> N.A. Lynch and F.W. Vaandrager. </author> <title> Forward and backward simulations for timing-based systems. </title> <editor> In de Bakker et al. </editor> <booktitle> [dBHRR92], </booktitle> <pages> pages 397-446. </pages>
Reference-contexts: 1. Introduction The timed automaton model of <ref> [LV92, LV93] </ref> is a general model for timing-based systems. It is intended as a basis for formal reasoning about such systems, in particular, for verification of their correctness and for analysis of their complexity. In [LV92, LV93], we develop a full range of simulation proof methods for timed automata; these methods <p> 1. Introduction The timed automaton model of <ref> [LV92, LV93] </ref> is a general model for timing-based systems. It is intended as a basis for formal reasoning about such systems, in particular, for verification of their correctness and for analysis of their complexity. In [LV92, LV93], we develop a full range of simulation proof methods for timed automata; these methods are used in [LLSA93, BPV94, HL94] to verify 1 A preliminary version of this paper appeared in W.R. Cleaveland, editor, Proceedings CONCUR'92, Stony Brook, New York. LNCS 630, pages 436-455. <p> Because the notion of explicit timers fits rather well with assertional proof techniques for real-time (see [AL92, BPV94]), we hope that it will be not too difficult to use these techniques, and in particular the simulation proof methods of <ref> [LV92, LV93] </ref>, in the setting of our language L t . Together with a limited repertoire of algebraic laws, this may then form the basis of a methodology in which the benefits of algebraic and assertional methods can be combined.
Reference: [LV93] <author> N.A. Lynch and F.W. Vaandrager. </author> <title> Forward and backward simulations part II: Timing-based systems. </title> <type> Report CS-R9314, </type> <institution> CWI, </institution> <address> Amsterdam, </address> <month> March </month> <year> 1993. </year> <note> Also, </note> <institution> MIT/LCS/TM-487.b, Laboratory for Computer Science, Massachusetts Institute of Technology, </institution> <address> Cambridge, MA. </address> <note> Submitted. </note>
Reference-contexts: 1. Introduction The timed automaton model of <ref> [LV92, LV93] </ref> is a general model for timing-based systems. It is intended as a basis for formal reasoning about such systems, in particular, for verification of their correctness and for analysis of their complexity. In [LV92, LV93], we develop a full range of simulation proof methods for timed automata; these methods <p> 1. Introduction The timed automaton model of <ref> [LV92, LV93] </ref> is a general model for timing-based systems. It is intended as a basis for formal reasoning about such systems, in particular, for verification of their correctness and for analysis of their complexity. In [LV92, LV93], we develop a full range of simulation proof methods for timed automata; these methods are used in [LLSA93, BPV94, HL94] to verify 1 A preliminary version of this paper appeared in W.R. Cleaveland, editor, Proceedings CONCUR'92, Stony Brook, New York. LNCS 630, pages 436-455. <p> The Timed Setting Now we extend the notions described in Section 2 to the case of timed systems. We follow the same general outline, introducing time systematically into all of the definitions and results. 4.1. Timed Automata We use a slight variant of the timed automaton model from <ref> [LV93] </ref>. 6 A timed automaton A is an automaton whose set of actions includes R + , the set of positive reals. Actions from R + are referred to as time-passage actions. <p> The trajectory axiom S2 is a kind of converse to S1; it says that any time-passage step can be "filled in" with states for each intervening time, in a "consistent" way. For a further discussion of this axiom we refer to <ref> [LV93, JSV93] </ref>. 6 The difference is just the explicit indication of the amount of elapsed time in the time-passage action instead of using a .now function that associates the current time to a state. Action Transducers and Timed Automata 19 4.2. <p> Action Transducers and Timed Automata 19 4.2. Timed Traces Executions of timed automata correspond to what are called sampling computations in [MP93]: they provide information about a run of a system at a countable number of points in time. In <ref> [LV93] </ref>, a notion of timed execution is also defined for timed automata: these are alternating sequences of trajectories and actions, which correspond to the super-dense computations of [MP93]. It can be argued that timed executions provide a more precise representation of the behaviour of real-time systems than (sampling) executions. <p> Because the notion of explicit timers fits rather well with assertional proof techniques for real-time (see [AL92, BPV94]), we hope that it will be not too difficult to use these techniques, and in particular the simulation proof methods of <ref> [LV92, LV93] </ref>, in the setting of our language L t . Together with a limited repertoire of algebraic laws, this may then form the basis of a methodology in which the benefits of algebraic and assertional methods can be combined.
Reference: [LX90] <author> K.G. Larsen and L. Xinxin. </author> <title> Compositionality through an operational semantics of contexts. </title> <editor> In M. Paterson, editor, </editor> <booktitle> Proceedings 17 th ICALP, Warwick, volume 443 of Lecture Notes in Computer Science, </booktitle> <pages> pages 526-539. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1990. </year> <note> An extended version appeared as: Report R89-13, </note> <institution> The University of Aalborg, Dept. of Mathematics and Computer Science, Aalborg, Denmark, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: However, action transducers are more convenient for our purposes. First, although it is easy to see how SOS specifications determine automata, it is less clear how to regard them as defining operations on automata. For action transducers, this correspondence is more direct. Second, as noted by Larsen and Xinxin <ref> [LX90] </ref>, action transducers are a convenient tool for studying compositionality questions, and their use tends to simplify proofs. Third, action transducers can easily be defined to allow multiple start states. <p> In fact, our action transducers also allow holes to be coloured, which allows us to express the condition that several holes (those of the same colour) must hold copies of the same automaton. The concepts of multiple start states and of coloured holes are not present in <ref> [LX90] </ref>. Results The major result of our paper is that the timed trace inclusion relation is substitutive with respect to all operations that can be described by our action transducers, provided they satisfy a number of conditions that concern the handling of internal and time-passage steps. <p> Remarks The importance of action transducers for process algebra and concurrency theory was first noted by Larsen and Xinxin <ref> [LX90] </ref>, who introduced a certain type of action transducer, which they call context systems, to study compositionality questions in the setting of process algebra. Our action transducers generalise those of Larsen and Xinxin [LX90] in several respects: the distinction between colours and holes, which allows us to copy arguments, is new <p> importance of action transducers for process algebra and concurrency theory was first noted by Larsen and Xinxin <ref> [LX90] </ref>, who introduced a certain type of action transducer, which they call context systems, to study compositionality questions in the setting of process algebra. Our action transducers generalise those of Larsen and Xinxin [LX90] in several respects: the distinction between colours and holes, which allows us to copy arguments, is new here. Also, Larsen and Xinxin [LX90] only consider operations with a finite number of arguments, and a setting where automata just have one start state and no explicit set of associated actions. <p> Our action transducers generalise those of Larsen and Xinxin <ref> [LX90] </ref> in several respects: the distinction between colours and holes, which allows us to copy arguments, is new here. Also, Larsen and Xinxin [LX90] only consider operations with a finite number of arguments, and a setting where automata just have one start state and no explicit set of associated actions.
Reference: [Mil85] <author> G.J. Milne. </author> <title> CIRCAL and the representation of communication, concurrency, and time. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(2) </volume> <pages> 270-298, </pages> <year> 1985. </year>
Reference-contexts: We give one example in Section 3.4. 3. An Untimed Process Algebra In this section, we give several examples of operations that can be expressed as action transducers; all these operations are directly inspired by operations from well-known "untimed" process algebras such as CSP [Hoa85], CIRCAL <ref> [Mil85] </ref>, CCS [Mil89], Extended LOTOS [Bri88] and ACP [BW90].
Reference: [Mil89] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Engle-wood Cliffs, </address> <year> 1989. </year>
Reference-contexts: Showing that this property holds for a given timed automaton A is an interesting problem, but we do not address this problem in this paper. In the untimed setting, bisimulation equivalences have been reasonably successful as notions of implementation between transition systems <ref> [BW90, Mil89] </ref>. Consequently, bisimulation equivalences have also been proposed as implementation relations for the timed setting [BB91, Klu93, MT90, NS94, Yi90]. However, we do not believe that bisimulations will turn out to be very useful as implementation relations in the timed case. <p> We give one example in Section 3.4. 3. An Untimed Process Algebra In this section, we give several examples of operations that can be expressed as action transducers; all these operations are directly inspired by operations from well-known "untimed" process algebras such as CSP [Hoa85], CIRCAL [Mil85], CCS <ref> [Mil89] </ref>, Extended LOTOS [Bri88] and ACP [BW90].
Reference: [MMT91] <author> M. Merritt, F. Modugno, and M. Tuttle. </author> <title> Time constrained automata. </title> <editor> In J.C.M. Baeten and J.F. Groote, editors, </editor> <booktitle> Proceedings CONCUR 91, Amsterdam, volume 527 of Lecture Notes in Computer Science, </booktitle> <pages> pages 408-423. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: We can also define a minor variant of Alur and Dill's timed automata [AD94], as well as the finite-state subcase of the timed automaton model of Merritt, Modugno and Tuttle <ref> [MMT91] </ref>. All of this provides evidence of the power of our proposed language. The decidability and closure properties of Alur-Dill automata suggest that they can be regarded as a real-time analogue of classical finite automata. <p> In this section, we give some of these derived operators. Also, we show how one can encode within L t the finite state fragment of the timed-bounded automata model of <ref> [MMT91] </ref>. 5.2.1. Wait constructs Using a single timer, we can program the process WAIT d of Timed CSP [RR88, DS89], which waits time d and then terminates successfully. <p> A minor difference between our execution delay operator and the one from ATP is that ours allows machine A to perform visible actions at time d. 5.2.4. MMT-automata It is possible to encode within L t each finite state timed-bounded automaton in the sense of <ref> [MMT91] </ref>. We will refer to time-bounded automata as MMT-automata, derived from the names of the authors of [MMT91]. The MMT-automata model is an extension with real-time of the I/O automata model of [LT87]. It has been used extensively in [LA92, SALL93] for verification purposes. <p> MMT-automata It is possible to encode within L t each finite state timed-bounded automaton in the sense of <ref> [MMT91] </ref>. We will refer to time-bounded automata as MMT-automata, derived from the names of the authors of [MMT91]. The MMT-automata model is an extension with real-time of the I/O automata model of [LT87]. It has been used extensively in [LA92, SALL93] for verification purposes. <p> Using this auxiliary expression, we define the L u -expression expr (B) by expr (B) = TIMER u 1 x 1 ( TIMER u n x n ((expr (A + ))) ); 8 Here we follow the definition from [LA92], which is slightly more restrictive than the original definition of <ref> [MMT91] </ref> because it does not allow for strict bounds. This restriction is not crucial, but only convenient. 36 N.A. Lynch and F.W. Vaandrager where u i equals b u (C i ) if C i is enabled in the start state, and 1 otherwise. <p> Lynch and F.W. Vaandrager where u i equals b u (C i ) if C i is enabled in the start state, and 1 otherwise. Without proof, we claim that expr (B) generates exactly the same timed behaviours as the MMT-automaton B according to the definition of <ref> [MMT91] </ref>. 5.3. Counterexamples Although the converse of Theorem 4.4 does not hold, our result appears to be quite sharp: for many examples of timed action transducers that are not Zeno-and t -respecting, the timed trace preorders are indeed not substitutive.
Reference: [MP93] <author> Z. Manna and A. Pnueli. </author> <title> Verifying hybrid systems. In R.L. </title> <editor> Grossman, A. Nerode, A.P. Ravn, and H. Rischel, editors, </editor> <booktitle> Hybrid Systems, volume 736 of Lecture Notes in Computer Science, </booktitle> <pages> pages 4-35. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Action Transducers and Timed Automata 19 4.2. Timed Traces Executions of timed automata correspond to what are called sampling computations in <ref> [MP93] </ref>: they provide information about a run of a system at a countable number of points in time. In [LV93], a notion of timed execution is also defined for timed automata: these are alternating sequences of trajectories and actions, which correspond to the super-dense computations of [MP93]. <p> called sampling computations in <ref> [MP93] </ref>: they provide information about a run of a system at a countable number of points in time. In [LV93], a notion of timed execution is also defined for timed automata: these are alternating sequences of trajectories and actions, which correspond to the super-dense computations of [MP93]. It can be argued that timed executions provide a more precise representation of the behaviour of real-time systems than (sampling) executions. However, our trajectory axiom S2 guarantees that for each (sampling) execution of a timed automaton there exists a corresponding timed execution. <p> In the literature many other proposals can be found on how to constrain the passage of time: [AD94] uses a Buchi style acceptance criterion for this purpose, [HNSY92] advocates the use of program invariants, [AH94] proposes the related notion of delay predicates, <ref> [MP93] </ref> uses so-called important events, and [BPV94] uses stability with respect to linear inequalities. It is not clear to us how these approaches can be transferred to a process algebraic setting, where automata are built up step by step and not given a priori.
Reference: [MT90] <author> F. Moller and C. Tofts. </author> <title> A temporal calculus of communicating systems. </title> <booktitle> In Baeten and Klop [BK90], </booktitle> <pages> pages 401-415. </pages>
Reference-contexts: In the untimed setting, bisimulation equivalences have been reasonably successful as notions of implementation between transition systems [BW90, Mil89]. Consequently, bisimulation equivalences have also been proposed as implementation relations for the timed setting <ref> [BB91, Klu93, MT90, NS94, Yi90] </ref>. However, we do not believe that bisimulations will turn out to be very useful as implementation relations in the timed case. <p> On the other hand, there are several operators that have been proposed in the literature that do not fit our format of action transducers, in particular, the CCS-style choice operation present in <ref> [BB91, MT90, NS94, Yi90] </ref>. This operation cannot be expressed 4 N.A. Lynch and F.W. Vaandrager as a timed action transducer because the timed trace inclusion relation is not substitutive with respect to it. We briefly consider the design of an appropriate language of operators for describing timing-based systems. <p> With urgent actions it becomes trivial to define the urgent prefixing operators of TCCS <ref> [MT90] </ref> and ATP [NS94]: a:A = a ; A. Urgent actions are also useful for defining the timeout construct of Timed CSP. <p> Another example is the choice operator + that plays a dominant role in many real-time process calculi (TCCS <ref> [MT90] </ref>, the timed extension of CCS proposed in [Yi90], ATP [NS94], and ACP [BB91]).
Reference: [MT92] <author> F. Moller and C. Tofts. </author> <title> Behavioural abstraction in TCCS. </title> <editor> In W. Kuich, editor, </editor> <booktitle> Proceedings 19 th ICALP, Vienna, volume 623 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: The loss of substitutivity may be viewed as a problem for a process algebra with CCS choice based on trace equivalence (it is not a problem if certain other equivalence are used, such as observational congruence <ref> [MT92] </ref>). Via Lemma 5.1 we have identified a general class of operations for which trace equivalence is a congruence and with patient versions for which timed trace equivalence is a congruence.
Reference: [NS92] <author> X. Nicollin and J. Sifakis. </author> <title> An overview and synthesis on timed process algebras. </title> <editor> In K.G. Larsen and A. Skou, editors, </editor> <booktitle> Proceedings of the 3rd International Workshop on Computer Aided Verification, Aalborg, Denmark, volume 575 of Lecture Notes in Computer Science, </booktitle> <pages> pages 376-398. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: As a starting point, we believe that such a language ought to include the basic untimed operations that are already well understood and generally accepted. To this end, we describe a simple and general construction, inspired by Nicollin and Sifakis <ref> [NS92] </ref>, to transform any untimed operation into a timed one that behaves essentially the same and moreover does not use or constrain the time. <p> Operators 5.1.1. The patient construction An important collection of timed action transducers can be obtained from un-timed action transducers. In this subsection we present a simple but important construction, inspired by Nicollin and Sifakis <ref> [NS92] </ref>, that transforms an untimed action transducer into a timed one, by simply inserting arbitrary time-passage steps. Suppose T is an (untimed) action transducer with R + " acts (T ) = ; and R + " acts (T; c) = ;, for all c.
Reference: [NS94] <author> X. Nicollin and J. Sifakis. </author> <title> The algebra of timed processes ATP: Theory and application. </title> <journal> Information and Computation, </journal> <volume> 114(1) </volume> <pages> 131-178, </pages> <year> 1994. </year>
Reference-contexts: In the untimed setting, bisimulation equivalences have been reasonably successful as notions of implementation between transition systems [BW90, Mil89]. Consequently, bisimulation equivalences have also been proposed as implementation relations for the timed setting <ref> [BB91, Klu93, MT90, NS94, Yi90] </ref>. However, we do not believe that bisimulations will turn out to be very useful as implementation relations in the timed case. <p> On the other hand, there are several operators that have been proposed in the literature that do not fit our format of action transducers, in particular, the CCS-style choice operation present in <ref> [BB91, MT90, NS94, Yi90] </ref>. This operation cannot be expressed 4 N.A. Lynch and F.W. Vaandrager as a timed action transducer because the timed trace inclusion relation is not substitutive with respect to it. We briefly consider the design of an appropriate language of operators for describing timing-based systems. <p> can construct many of the other timed operations appearing in the literature, including a very general timer similar to that used in the timed !-automata model of Alur and Dill [AD94], the timeout construct of Timed CSP [RR88, DS89], and the execution delay operation of the timed process algebra ATP <ref> [NS94] </ref>. We can also define a minor variant of Alur and Dill's timed automata [AD94], as well as the finite-state subcase of the timed automaton model of Merritt, Modugno and Tuttle [MMT91]. All of this provides evidence of the power of our proposed language. <p> With urgent actions it becomes trivial to define the urgent prefixing operators of TCCS [MT90] and ATP <ref> [NS94] </ref>: a:A = a ; A. Urgent actions are also useful for defining the timeout construct of Timed CSP. <p> Another example, taken from [BB91], is a watch that is perfect, except for some fluctuations of the ticks: WATCH 0 = WAIT 0:5 ; ((WAIT [0:5 *; 0:5 + *] ; tick ; STOP) ^ WAIT 1) ! : 5.2.3. Execution delay The execution delay operator of ATP <ref> [NSY93, NS94] </ref> is given by: dAe d (B) = (TIMER d x ((A ^ (abort ; B)) k C))nfabort ; cancelg; where C = (cancel 2 fabort; x=dg) ; x:1 ; STOP: dAe d (B) behaves as A until time d; at time d, A is interrupted and B is started. <p> Another example is the choice operator + that plays a dominant role in many real-time process calculi (TCCS [MT90], the timed extension of CCS proposed in [Yi90], ATP <ref> [NS94] </ref>, and ACP [BB91]).
Reference: [NSY93] <author> X. Nicollin, J. Sifakis, and S. Yovine. </author> <title> From ATP to timed graphs and hybrid systems. </title> <journal> Acta Informatica, </journal> <volume> 30(2) </volume> <pages> 181-202, </pages> <year> 1993. </year>
Reference-contexts: In the untimed setting, a crucial characteristic of algebras like CCS is that they can easily describe finite automata. Thus by analogy, a natural requirement for a real-time process language is that it can easily describe Alur-Dill automata. Nicollin, Sifakis and Yovine <ref> [NSY93] </ref> give a translation from ATP into Alur-Dill automata, but do not investigate the reverse translation. In fact it appears that, besides our language, only the real-time ACP language of Baeten and Bergstra [BB91] is sufficiently expressive to allow for a direct encoding of Alur-Dill automata. <p> Another example, taken from [BB91], is a watch that is perfect, except for some fluctuations of the ticks: WATCH 0 = WAIT 0:5 ; ((WAIT [0:5 *; 0:5 + *] ; tick ; STOP) ^ WAIT 1) ! : 5.2.3. Execution delay The execution delay operator of ATP <ref> [NSY93, NS94] </ref> is given by: dAe d (B) = (TIMER d x ((A ^ (abort ; B)) k C))nfabort ; cancelg; where C = (cancel 2 fabort; x=dg) ; x:1 ; STOP: dAe d (B) behaves as A until time d; at time d, A is interrupted and B is started.
Reference: [Plo81] <author> G.D. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Report DAIMI FN-19, </type> <institution> Computer Science Department, Aarhus University, </institution> <year> 1981. </year>
Reference-contexts: It should also enable verification of systems using a combination of compositional methods and methods based on levels of abstraction. Action transducers We represent operations by automaton-like objects that we call action transducers, rather than, for example, using SOS specifications <ref> [Plo81] </ref>. For an example of an action transducer, consider the operation jjj of interleaving parallel composition.
Reference: [RR88] <author> G.M. Reed and A.W. Roscoe. </author> <title> A timed model for communicating sequential processes. </title> <journal> Theoretical Computer Science, </journal> <volume> 58 </volume> <pages> 249-261, </pages> <year> 1988. </year>
Reference-contexts: Using only these operations and untimed operations, we can construct many of the other timed operations appearing in the literature, including a very general timer similar to that used in the timed !-automata model of Alur and Dill [AD94], the timeout construct of Timed CSP <ref> [RR88, DS89] </ref>, and the execution delay operation of the timed process algebra ATP [NS94]. We can also define a minor variant of Alur and Dill's timed automata [AD94], as well as the finite-state subcase of the timed automaton model of Merritt, Modugno and Tuttle [MMT91]. <p> In this section, we give some of these derived operators. Also, we show how one can encode within L t the finite state fragment of the timed-bounded automata model of [MMT91]. 5.2.1. Wait constructs Using a single timer, we can program the process WAIT d of Timed CSP <ref> [RR88, DS89] </ref>, which waits time d and then terminates successfully. WAIT d = TIMER d x (x=d): More generally, we can specify a process that terminates successfully after waiting some nondeterministically chosen time from the closed interval [l; u]. WAIT [l; u] = TIMER u x (xl): 5.2.2.
Reference: [SALL93] <author> J.F. Stgaard-Andersen, B.W. Lampson, and N.A. Lynch. </author> <title> Correctness of communication protocols a case study. </title> <type> Technical Report MIT/LCS/TR-589, </type> <institution> Laboratory for Computer Science, MIT, </institution> <address> Cambridge, MA, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: We will refer to time-bounded automata as MMT-automata, derived from the names of the authors of [MMT91]. The MMT-automata model is an extension with real-time of the I/O automata model of [LT87]. It has been used extensively in <ref> [LA92, SALL93] </ref> for verification purposes. <p> Use of process algebraic notation often allows one to give compact, intuitive specifications of timed systems. Thus far, however, process algebraic techniques cannot claim much success when it comes to verification of timed systems. Here assertional methods appear to perform much better (see, for instance, <ref> [SALL93, HL94, BPV94] </ref>).
Reference: [Sim85] <author> R. de Simone. </author> <title> Higher-level synchronising devices in meije-SCCS. </title> <journal> Theoretical Computer Science, </journal> <volume> 37 </volume> <pages> 245-267, </pages> <year> 1985. </year>
Reference-contexts: In fact, it is shown in [Vaa93] how SOS specifications in a variant of a format proposed by De Simone <ref> [Sim85] </ref> can be translated to equivalent action transducers, and vice versa. However, action transducers are more convenient for our purposes. First, although it is easy to see how SOS specifications determine automata, it is less clear how to regard them as defining operations on automata. <p> Discussion The main result of this paper is the characterisation in terms of action transducers of a very general class of operations that preserve inclusion of timed traces. For the untimed case, several substitutivity results for classes of operations have been reported in the literature (see, for instance, <ref> [Sim85, BIM88, GV92] </ref>). We believe our result to be the first one of this kind for the timed case. The combined complexity of multiple start states, infinitely many arguments, copying, activation and deactivation of arguments, internal actions, and different rates makes the proof of our result rather involved.
Reference: [Vaa91] <author> F.W. Vaandrager. </author> <title> On the relationship between process algebra and input/output automata (extended abstract). </title> <booktitle> In Proceedings 6 th Annual Symposium on Logic in Computer Science, Amsterdam, </booktitle> <pages> pages 387-398. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: Condition 3 does not explicitly mention internal steps; however, this condition is needed in Action Transducers and Timed Automata 9 the substitutivity proof because of complications caused by internal steps. Conditions 1 and 2 slightly strengthen similar constraints that are presented in <ref> [Vaa91] </ref> in the setting of SOS. Condition 3 does not occur in [Vaa91] because there only operations with a finite number of arguments are considered. However, a similar constraint appears in the I/O automaton model of [LT87]. Theorem 2.2. <p> Conditions 1 and 2 slightly strengthen similar constraints that are presented in <ref> [Vaa91] </ref> in the setting of SOS. Condition 3 does not occur in [Vaa91] because there only operations with a finite number of arguments are considered. However, a similar constraint appears in the I/O automaton model of [LT87]. Theorem 2.2. The relations fl and on automata are substitutive for all t -respecting action transducers. Proof Let T be a t -respecting action transducer.
Reference: [Vaa93] <author> F.W. Vaandrager. </author> <title> Expressiveness results for process algebras. </title> <editor> In J.W. de Bakker, W.P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Proceedings REX Workshop on Semantics: Foundations and Applications, </booktitle> <address> Beekbergen, The Netherlands, </address> <month> June </month> <year> 1992, </year> <booktitle> volume 666 of Lecture Notes in Computer Science, </booktitle> <pages> pages 609-638. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: In fact, it is shown in <ref> [Vaa93] </ref> how SOS specifications in a variant of a format proposed by De Simone [Sim85] can be translated to equivalent action transducers, and vice versa. However, action transducers are more convenient for our purposes.
Reference: [Yi90] <author> Wang Yi. </author> <title> Real-time behaviour of asynchronous agents. </title> <booktitle> In Baeten and Klop [BK90], </booktitle> <pages> pages 502-520. </pages>
Reference-contexts: In the untimed setting, bisimulation equivalences have been reasonably successful as notions of implementation between transition systems [BW90, Mil89]. Consequently, bisimulation equivalences have also been proposed as implementation relations for the timed setting <ref> [BB91, Klu93, MT90, NS94, Yi90] </ref>. However, we do not believe that bisimulations will turn out to be very useful as implementation relations in the timed case. <p> On the other hand, there are several operators that have been proposed in the literature that do not fit our format of action transducers, in particular, the CCS-style choice operation present in <ref> [BB91, MT90, NS94, Yi90] </ref>. This operation cannot be expressed 4 N.A. Lynch and F.W. Vaandrager as a timed action transducer because the timed trace inclusion relation is not substitutive with respect to it. We briefly consider the design of an appropriate language of operators for describing timing-based systems. <p> We think that RATE action transducers can be useful in the process algebraic description of protocols that involve drifting clocks, such as the audio control protocol analyzed in [BPV94]. An interesting property of the RATE action transducers is that in general they do not preserve Wang's <ref> [Yi90] </ref> axiom of time determinism. <p> Another example is the choice operator + that plays a dominant role in many real-time process calculi (TCCS [MT90], the timed extension of CCS proposed in <ref> [Yi90] </ref>, ATP [NS94], and ACP [BB91]).
References-found: 46

