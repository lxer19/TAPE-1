URL: http://www.cis.ohio-state.edu/~gb/Papers/Signature-design.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~gb/Papers/Signature-design.html
Root-URL: 
Email: gb@cs.purdue.edu russo@cs.purdue.edu  
Title: Signatures: A Language Extension for Improving Type Abstraction and Subtype Polymorphism in C  
Author: Gerald Baumgartner Vincent F. Russo 
Date: August 11, 1995  
Address: West Lafayette, IN 47907  
Affiliation: Department of Computer Sciences Purdue University  
Pubnum: Technical Report CSD-TR-95-051  
Abstract: C ++ uses inheritance as a substitute for subtype polymorphism. We give examples where this makes the type system too inflexible. We then describe a conservative language extension that allows a programmer to define an abstract type hierarchy independent of any implementation hierarchies, to retroactively abstract over an implementation, and to decouple subtyping from inheritance. This extension gives the user more of the flexibility of dynamic typing while retaining the efficiency and security of static typing. With default implementations and views flexible mechanisms are provided for implementing an abstract type by different concrete class types. We first show how the language extension can be implemented in a preprocessor to a C ++ compiler, and then detail and analyze the efficiency of an implementation we directly incorporated in the GNU C ++ compiler.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Kamal Abdali, Guy W. Cherry, and Neil Soiffer. </author> <title> An object-oriented approach to algebra system design. </title> <editor> In Bruce W. Char, editor, </editor> <booktitle> Proceedings of the 1986 Symposium on Symbolic and Algebraic Computation (SYMSAC '86), </booktitle> <pages> pages 24-30, </pages> <address> Waterloo, Ontario, Canada, </address> <month> 21-23 July </month> <year> 1986. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: While this wouldn't be difficult to implement, the syntax of views would become excessively complicated. Instead, all member functions with the same name are renamed the same. A similar renaming mechanism can be found in Views <ref> [1, 2] </ref>, an experimental computer algebra system written in Smalltalk, or in the algebraic specification language OBJ3 [19]. 4 Examples In this section, we present three examples that show a typical use of a signature with multiple implementations, how constants can be used to encode semantic information in a signature, and
Reference: [2] <author> S. Kamal Abdali, Guy W. Cherry, and Neil Soiffer. </author> <title> A Smalltalk system for algebraic manipulation. </title> <booktitle> In Proceedings of the OOPSLA '86 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 277-283, </pages> <address> Portland, Oregon, </address> <month> 29 September - 2 October </month> <year> 1986. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 21(11), </volume> <month> November </month> <year> 1986. </year>
Reference-contexts: While this wouldn't be difficult to implement, the syntax of views would become excessively complicated. Instead, all member functions with the same name are renamed the same. A similar renaming mechanism can be found in Views <ref> [1, 2] </ref>, an experimental computer algebra system written in Smalltalk, or in the algebraic specification language OBJ3 [19]. 4 Examples In this section, we present three examples that show a typical use of a signature with multiple implementations, how constants can be used to encode semantic information in a signature, and
Reference: [3] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(4) </volume> <pages> 575-631, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: Only recursive types require subtyping to be treated separately. Using the signature conformance check described earlier, arbitrary recursive types are disallowed 8 from being in a subtype relationship. It is possible, though, to extend subtyping to recursive types using an algorithm similar to the one in <ref> [3] </ref>. However, to guarantee that conformance remains sound, this would require an object-level encapsulation of conforming classes instead of the usual class-level encapsulation in C ++ .
Reference: [4] <author> Pierre America and Frank van der Linden. </author> <title> A parallel object-oriented language with inheritance and subtyping. </title> <booktitle> In Proceedings of the OOPSLA '90 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 161-168, </pages> <address> Ottawa, Canada, </address> <month> 21-25 October </month> <year> 1990. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 25(10), </volume> <month> October </month> <year> 1990. </year>
Reference-contexts: to types in Russell [16], signatures in ML [25, 26], type classes in Haskell [17], definition modules in Modula-2 [37], interface modules in Modula-3 [12], abstract types in Emerald [9], type modules in Trellis/Owl [29], categories in Axiom [22] and its predecessor Scratchpad II [35, 36], and types in POOL-I <ref> [4] </ref>. In this section, we specify syntax and semantics of signatures, signature pointers, and signature references. We then show how signatures allow the introduction of subtype polymorphism into C ++ independent of the inheritance mechanism. <p> by defining a data structure containing signature pointers of type S*. 13 #include &lt;iostream.h&gt; int main () - cout &lt;< p [0]-&gt;text () &lt;< p [1]-&gt;text () &lt;< ""n"; return 0; - When run, the above program will print the string "Hello World."n". 4.2 Properties Other languages, such as POOL-I <ref> [4] </ref> or Axiom [22], offer language constructs for defining properties of signature and implementation types. These properties are used as a shorthand for axioms written in first-order logic or equational logic to encode semantic information as part of the specification of an abstract type. <p> Emerald [9] has first-class types instead of classes, and Trellis/Owl [29] has a class hierarchy in which only type information but no implementation is inherited. Signatures in C ++ come closest to categories in Axiom [22] and types in POOL-I <ref> [4] </ref>. But Axiom is an abstract data type language, and POOL-I lacks overloading and private and protected member functions and fields. Also, while categories and domains in Axiom as well as types in POOL-I are first class, signatures and classes in our C ++ extension are not.
Reference: [5] <author> John Gilbert Presslie Barnes. </author> <title> Programming in ADA. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1982. </year>
Reference-contexts: Parametric polymorphism, which allows functions to work over a potentially infinite range of argument types, is mostly found in functional languages, such as ML [27, 28] and Haskell [17]. Generics in Ada <ref> [5] </ref> and templates in C ++ [18, 33] provide a limited form of parametric polymorphism as well. The form of polymorphism relevant to this paper is subtype polymorphism, or subtyping for short. It is found in some form in most strongly typed object-oriented languages.
Reference: [6] <author> Gerald Baumgartner. </author> <title> Type abstration using signatures. </title> <booktitle> In Stallman [31], section 7.6, </booktitle> <pages> pages 176-177. </pages> <note> Available as part of the GCC-2.7.0 distribution. </note>
Reference-contexts: For pragmatic reasons, however, such drastic changes are undesirable for an extension of C ++ , as they would affect the behavior of existing programs. Availability Parts of the language extension have been implemented in the GNU project C ++ compiler <ref> [6] </ref> as a compiler extension. The implementation is included in versions GCC-2.6.0 and higher. Acknowledgements We would like to thank Konstantin Laufer and Michal Young for reading parts of the paper and providing many valuable comments, and Andy Muckelbauer for numerous discussions about the implementation.
Reference: [7] <author> Gerald Baumgartner and Vincent F. Russo. </author> <title> Implementing signatures for C ++ . Technical Report CSD-TR-95-025, </title> <institution> Department of Computer Sciences, Purdue University, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: Such an implementation is described in <ref> [7] </ref>. Advantages of using thunks would be that there would be no overhead of testing the flags in a signature member function call, and that no zero offset would need to be added to the this pointer in case of single inheritance. Instead, thunks would simply contain the appropriate code. <p> In the absence of recursion or when the signature hierarchy is designed such that the RHS signature pointer is of a subsignature type, all signature tables can be statically allocated. For more efficient implementations see <ref> [7] </ref>. 20 6 Cost Analysis For the purpose of the following discussion assume that a pointer can be stored in a machine word.
Reference: [8] <author> Gerald Baumgartner and Ryan D. Stansifer. </author> <title> A proposal to study type systems for computer algebra. </title> <type> RISC-Linz Report 90-87.0, </type> <institution> Research Institute for Symbolic Computation, University of Linz, Linz, Austria, </institution> <month> March </month> <year> 1990. </year> <month> 22 </month>
Reference-contexts: () and move () functions with the same interface, it cannot be expressed in C ++ that this is the only requirement for addition to the display list and for manipulation of objects on the list. 2.2 Computer Algebra An example from computer algebra similar to the one found in <ref> [8] </ref> demonstrates how a complex type hierarchy cannot be modeled and implemented by a class hierarchy. In computer algebra, the distinction between abstract types and concrete types arises naturally. Typical abstract types are Group, Ring, Field, or EuclideanDomain, while typical concrete types are Integer, Fraction, or DistributedPolynomial.
Reference: [9] <author> Andrew Black, Norman Hutchinson, Eric Jul, and Henry Levy. </author> <title> Object structure in the Emerald system. </title> <booktitle> In Proceedings of the OOPSLA '86 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 78-86, </pages> <address> Portland, Oregon, </address> <month> 29 September - 2 October </month> <year> 1986. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 21(11), </volume> <month> November </month> <year> 1986. </year>
Reference-contexts: Signatures, in this language extension, are related to types in Russell [16], signatures in ML [25, 26], type classes in Haskell [17], definition modules in Modula-2 [37], interface modules in Modula-3 [12], abstract types in Emerald <ref> [9] </ref>, type modules in Trellis/Owl [29], categories in Axiom [22] and its predecessor Scratchpad II [35, 36], and types in POOL-I [4]. In this section, we specify syntax and semantics of signatures, signature pointers, and signature references. <p> However, ML and Modula-2 only have modules and no classes, while Modula-3 has both classes and modules but provides interfaces for modules only and not for classes. Russell [16] and Haskell [17] have notions related to signatures, but both lack classes. Emerald <ref> [9] </ref> has first-class types instead of classes, and Trellis/Owl [29] has a class hierarchy in which only type information but no implementation is inherited. Signatures in C ++ come closest to categories in Axiom [22] and types in POOL-I [4].
Reference: [10] <author> Peter S. Canning, William R. Cook, Walter L. Hill, and Walter G. Olthoff. </author> <title> Interfaces for strongly-typed object-oriented programming. </title> <booktitle> In Proceedings of the OOPSLA '89 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 457-467, </pages> <address> New Orleans, Louisiana, </address> <month> 1-6 October </month> <year> 1989. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 24(10), </volume> <month> October </month> <year> 1989. </year>
Reference-contexts: Proposed solutions include factoring out the implementation aspect of classes into prototypical objects [24] and factoring out the type aspect into interfaces <ref> [10, 14] </ref>. 2.3 Doubly Ended Queues Inheritance is not only an inadequate mechanism for achieving subtyping. If inheritance is used to define a subtype relationship, it can either make subtyping unsound or limit the flexibility of inheritance for code reuse. An example similar to one in [30] illustrates this point. <p> If S inherits from another signature U, the declarations of U are merged into S before the declarations of the resulting signature S are merged into T. This is the same definition as that of interface inheritance in <ref> [10] </ref>.
Reference: [11] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <editor> In G. Kahn, David B. MacQueen, and Gordon Plotkin, editors, </editor> <booktitle> Semantics of Data Types, volume 173 of Lecture Notes in Computer Science, </booktitle> <pages> pages 51-67. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, New York, </address> <year> 1984. </year> <booktitle> Proceedings of the International Symposium on the Semantics of Data Types, Sophia-Antipolis, </booktitle> <address> France, </address> <month> 27-29 June </month> <year> 1984. </year>
Reference-contexts: *); can be matched with any of the following class member functions: T * C::f (D *, E *); T * C::f (T *, E *); D * C::f (D *, E *); U * C::f (D *, E *); Note that conformance of member functions is defined using contravariance <ref> [11] </ref> of the argument types and covariance of the result types. This makes the signature-based notion of subtyping more general than C ++ 's class-based subtyping.
Reference: [12] <author> Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <title> Modula-3 language definition. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(8) </volume> <pages> 15-43, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: Signatures, in this language extension, are related to types in Russell [16], signatures in ML [25, 26], type classes in Haskell [17], definition modules in Modula-2 [37], interface modules in Modula-3 <ref> [12] </ref>, abstract types in Emerald [9], type modules in Trellis/Owl [29], categories in Axiom [22] and its predecessor Scratchpad II [35, 36], and types in POOL-I [4]. In this section, we specify syntax and semantics of signatures, signature pointers, and signature references. <p> We proposed language constructs for specifying and working with signature types. These constructs allow us to decouple subtyping from inheritance. The result, C ++ with signatures, has a type system related to those of several other modern programming languages. Similarly as in ML [25, 26], Modula-2 [37], and Modula-3 <ref> [12] </ref>, signatures in C ++ allow a clean separation of specification and implementation. However, ML and Modula-2 only have modules and no classes, while Modula-3 has both classes and modules but provides interfaces for modules only and not for classes.
Reference: [13] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> ACM Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: To illustrate why this is the case, we first define some terminology and follow with examples of the limitations of classes. 1.1 Types Semantically, a type can be viewed as a set of values <ref> [13] </ref>. In most traditional programming languages, such a set is characterized implicitly by providing an implementation for the type, e.g., using a primitive type the hardware provides or using a user-defined record type. <p> Cardelli and Wegner <ref> [13] </ref> distinguish four kinds of polymorphism: parametric polymorphism, subtype polymorphism, overloading, and coercion. Some forms of overloading and coercion appear in nearly every programming language, with relatively strong support in C ++ .
Reference: [14] <author> William R. Cook. </author> <title> Interfaces and specifications for the Smalltalk-80 collection classes. </title> <booktitle> In Proceedings of the OOPSLA '92 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 1-15, </pages> <address> Vancouver, Canada, </address> <month> 18-22 October </month> <year> 1992. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 27(10), </volume> <month> October </month> <year> 1992. </year>
Reference-contexts: Proposed solutions include factoring out the implementation aspect of classes into prototypical objects [24] and factoring out the type aspect into interfaces <ref> [10, 14] </ref>. 2.3 Doubly Ended Queues Inheritance is not only an inadequate mechanism for achieving subtyping. If inheritance is used to define a subtype relationship, it can either make subtyping unsound or limit the flexibility of inheritance for code reuse. An example similar to one in [30] illustrates this point.
Reference: [15] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In Proceedings of the 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 125-135, </pages> <address> San Francisco, California, </address> <month> 17-19 January </month> <year> 1990. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: A queue implementation could then just inherit the doubly ended queue implementation and ignore, or hide, the additional operations. For the type system to be sound it is not possible to define a subtype relationship based on inheritance and also allow to hide operations of a superclass <ref> [15] </ref>.
Reference: [16] <author> James Donahue and Alan Demers. </author> <title> Data types are values. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(3) </volume> <pages> 426-445, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: The key language construct added to support type abstraction in C ++ and to allow separating subtyping from inheritance is called a signature. Signatures, in this language extension, are related to types in Russell <ref> [16] </ref>, signatures in ML [25, 26], type classes in Haskell [17], definition modules in Modula-2 [37], interface modules in Modula-3 [12], abstract types in Emerald [9], type modules in Trellis/Owl [29], categories in Axiom [22] and its predecessor Scratchpad II [35, 36], and types in POOL-I [4]. <p> However, ML and Modula-2 only have modules and no classes, while Modula-3 has both classes and modules but provides interfaces for modules only and not for classes. Russell <ref> [16] </ref> and Haskell [17] have notions related to signatures, but both lack classes. Emerald [9] has first-class types instead of classes, and Trellis/Owl [29] has a class hierarchy in which only type information but no implementation is inherited.
Reference: [17] <author> Paul Hudak (ed.), Simon Peyton Jones (ed.), Philip Wadler (ed.), Brian Boutel, Jon Fairbairn, Joseph Fasel, Mara M. Guzman, Kevin Hammond, John Hughes, Thomas Johnsson, Dick Kieburtz, Rishiyur Nikhil, Will Partain, and John Peterson. </author> <title> Report on the programming language Haskell: A non-strict, purely functional language, version 1.2. </title> <journal> ACM SIGPLAN Notices, 27(5):Section R, </journal> <month> May </month> <year> 1992. </year>
Reference-contexts: Some forms of overloading and coercion appear in nearly every programming language, with relatively strong support in C ++ . Parametric polymorphism, which allows functions to work over a potentially infinite range of argument types, is mostly found in functional languages, such as ML [27, 28] and Haskell <ref> [17] </ref>. Generics in Ada [5] and templates in C ++ [18, 33] provide a limited form of parametric polymorphism as well. The form of polymorphism relevant to this paper is subtype polymorphism, or subtyping for short. It is found in some form in most strongly typed object-oriented languages. <p> The key language construct added to support type abstraction in C ++ and to allow separating subtyping from inheritance is called a signature. Signatures, in this language extension, are related to types in Russell [16], signatures in ML [25, 26], type classes in Haskell <ref> [17] </ref>, definition modules in Modula-2 [37], interface modules in Modula-3 [12], abstract types in Emerald [9], type modules in Trellis/Owl [29], categories in Axiom [22] and its predecessor Scratchpad II [35, 36], and types in POOL-I [4]. <p> However, ML and Modula-2 only have modules and no classes, while Modula-3 has both classes and modules but provides interfaces for modules only and not for classes. Russell [16] and Haskell <ref> [17] </ref> have notions related to signatures, but both lack classes. Emerald [9] has first-class types instead of classes, and Trellis/Owl [29] has a class hierarchy in which only type information but no implementation is inherited.
Reference: [18] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C ++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: Parametric polymorphism, which allows functions to work over a potentially infinite range of argument types, is mostly found in functional languages, such as ML [27, 28] and Haskell [17]. Generics in Ada [5] and templates in C ++ <ref> [18, 33] </ref> provide a limited form of parametric polymorphism as well. The form of polymorphism relevant to this paper is subtype polymorphism, or subtyping for short. It is found in some form in most strongly typed object-oriented languages. <p> The implementation of the methods in the new classes can just forward the operation to the implementation in the original library class. In C ++ , the task of creating these classes can be simplified using templates <ref> [18, 33] </ref>. However, even with templates this option entails substantial software engineering costs. Building all the extra classes is tedious at best, and clutters the program name space with a superfluous set of new class names. <p> Instead of using a signature, the type S above could have been defined just as well as an abstract class, i.e., a class containing pure virtual member function declarations <ref> [18] </ref>. The behavior of both implementations would be equivalent. However, if the type hierarchy becomes more complex, it can no longer be modelled precisely with a class hierarchy as shown in the earlier computer algebra example. <p> If more than one member function of C conforms to a single member function of S, the one that conforms best is selected using a variant of C ++ 's algorithm for selecting the function declaration that best matches the call of an overloaded function <ref> [18] </ref>. If a single member function of C conforms to more than one member function of S, an error is reported.
Reference: [19] <author> J.A. Goguen and T. Winkler. </author> <title> Introducing OBJ3. </title> <type> Technical Report CSL-88-9, </type> <institution> SRI International, </institution> <year> 1988. </year>
Reference-contexts: Instead, all member functions with the same name are renamed the same. A similar renaming mechanism can be found in Views [1, 2], an experimental computer algebra system written in Smalltalk, or in the algebraic specification language OBJ3 <ref> [19] </ref>. 4 Examples In this section, we present three examples that show a typical use of a signature with multiple implementations, how constants can be used to encode semantic information in a signature, and how signatures integrate with templates.
Reference: [20] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1983. </year>
Reference-contexts: No matter how the classes are structured, either code is duplicated, or PermutationMatrix is incorrectly allowed as an implementation of NegativeDefiniteMatrix. Similar arguments have been presented in the literature to show that the collection class hierarchy of Smalltalk-80 <ref> [20] </ref> is not appropriate as a basis for subtyping. While the problem does not arise directly in Smalltalk-80, since it is dynamically typed, it becomes an issue when trying to make Smalltalk-80 statically typed while retaining most of its flexibility.
Reference: [21] <author> Elana D. Granston and Vincent F. Russo. </author> <booktitle> Signature-based polymorphism for C ++ . In Proceedings of the 1991 USENIX C ++ Conference, </booktitle> <pages> pages 65-79, </pages> <address> Washington, D.C., 22-25 April 1991. </address> <publisher> USENIX Association. </publisher>
Reference-contexts: The last example also shows that by overloading the use of inheritance, its possibilities for code reuse have to be restricted in order not to break subtyping. 2.1 X-Windows Object Manager A practical example, illustrated in <ref> [21] </ref>, shows that inheritance, as a substitute for subtype polymorphism, is not flexible enough in dealing with multiple implementations of an abstract type. Imagine two libraries containing hierarchies of classes for X-Windows display objects. One hierarchy is rooted at OpenLookObject and the other at MotifObject. <p> The algorithm to check whether an implementation adheres to object-level encapsulation is beyond the scope of this paper. 3.5 The Signature of a Class As an alternative to the signature construct we also provide the sigof construct as found in <ref> [21] </ref>. Given a class C, the signature sigof (C) is constructed by duplicating all the public type definitions, constant definitions, and member function declarations from C into a new, anonymous signature. Field declarations and private and protected member functions are ignored.
Reference: [22] <author> Richard D. Jenks and Robert S. Sutor. </author> <title> AXIOM: The Scientific Computation System. </title> <publisher> Springer-Verlag, </publisher> <address> New York, New York, </address> <year> 1992. </year>
Reference-contexts: Signatures, in this language extension, are related to types in Russell [16], signatures in ML [25, 26], type classes in Haskell [17], definition modules in Modula-2 [37], interface modules in Modula-3 [12], abstract types in Emerald [9], type modules in Trellis/Owl [29], categories in Axiom <ref> [22] </ref> and its predecessor Scratchpad II [35, 36], and types in POOL-I [4]. In this section, we specify syntax and semantics of signatures, signature pointers, and signature references. We then show how signatures allow the introduction of subtype polymorphism into C ++ independent of the inheritance mechanism. <p> data structure containing signature pointers of type S*. 13 #include &lt;iostream.h&gt; int main () - cout &lt;< p [0]-&gt;text () &lt;< p [1]-&gt;text () &lt;< ""n"; return 0; - When run, the above program will print the string "Hello World."n". 4.2 Properties Other languages, such as POOL-I [4] or Axiom <ref> [22] </ref>, offer language constructs for defining properties of signature and implementation types. These properties are used as a shorthand for axioms written in first-order logic or equational logic to encode semantic information as part of the specification of an abstract type. <p> Russell [16] and Haskell [17] have notions related to signatures, but both lack classes. Emerald [9] has first-class types instead of classes, and Trellis/Owl [29] has a class hierarchy in which only type information but no implementation is inherited. Signatures in C ++ come closest to categories in Axiom <ref> [22] </ref> and types in POOL-I [4]. But Axiom is an abstract data type language, and POOL-I lacks overloading and private and protected member functions and fields.
Reference: [23] <author> Jacob Katzenelson, Shlomit S. Pinter, and Eugen Schenfeld. </author> <title> Type matching, type-graphs, and the Schanuel conjecture. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(4) </volume> <pages> 574-588, </pages> <month> Oc-tober </month> <year> 1992. </year> <month> 23 </month>
Reference-contexts: The other possibility is to make signature tables external and to have linker support to eliminate identical tables. Both the signature table manager and the link-time table comparison could be implemented efficiently using the type matching scheme described in <ref> [23] </ref>.
Reference: [24] <author> Wilf R. LaLonde, Dave A. Thomas, and John R. Pugh. </author> <title> An exemplar based Smalltalk. </title> <booktitle> In Proceedings of the OOPSLA '86 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 322-330, </pages> <address> Portland, Oregon, </address> <month> 29 September - 2 October </month> <year> 1986. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 21(11), </volume> <month> November </month> <year> 1986. </year>
Reference-contexts: While the problem does not arise directly in Smalltalk-80, since it is dynamically typed, it becomes an issue when trying to make Smalltalk-80 statically typed while retaining most of its flexibility. Proposed solutions include factoring out the implementation aspect of classes into prototypical objects <ref> [24] </ref> and factoring out the type aspect into interfaces [10, 14]. 2.3 Doubly Ended Queues Inheritance is not only an inadequate mechanism for achieving subtyping. If inheritance is used to define a subtype relationship, it can either make subtyping unsound or limit the flexibility of inheritance for code reuse.
Reference: [25] <author> David B. MacQueen. </author> <title> Modules for Standard ML. </title> <journal> Polymorphism, </journal> <volume> 2(2), </volume> <month> October </month> <year> 1985. </year>
Reference-contexts: The key language construct added to support type abstraction in C ++ and to allow separating subtyping from inheritance is called a signature. Signatures, in this language extension, are related to types in Russell [16], signatures in ML <ref> [25, 26] </ref>, type classes in Haskell [17], definition modules in Modula-2 [37], interface modules in Modula-3 [12], abstract types in Emerald [9], type modules in Trellis/Owl [29], categories in Axiom [22] and its predecessor Scratchpad II [35, 36], and types in POOL-I [4]. <p> We proposed language constructs for specifying and working with signature types. These constructs allow us to decouple subtyping from inheritance. The result, C ++ with signatures, has a type system related to those of several other modern programming languages. Similarly as in ML <ref> [25, 26] </ref>, Modula-2 [37], and Modula-3 [12], signatures in C ++ allow a clean separation of specification and implementation. However, ML and Modula-2 only have modules and no classes, while Modula-3 has both classes and modules but provides interfaces for modules only and not for classes.
Reference: [26] <author> David B. MacQueen. </author> <title> An implementation of Standard ML modules. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 212-223, </pages> <address> Snowbird, Utah, </address> <month> 25-27 July </month> <year> 1988. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: The key language construct added to support type abstraction in C ++ and to allow separating subtyping from inheritance is called a signature. Signatures, in this language extension, are related to types in Russell [16], signatures in ML <ref> [25, 26] </ref>, type classes in Haskell [17], definition modules in Modula-2 [37], interface modules in Modula-3 [12], abstract types in Emerald [9], type modules in Trellis/Owl [29], categories in Axiom [22] and its predecessor Scratchpad II [35, 36], and types in POOL-I [4]. <p> We proposed language constructs for specifying and working with signature types. These constructs allow us to decouple subtyping from inheritance. The result, C ++ with signatures, has a type system related to those of several other modern programming languages. Similarly as in ML <ref> [25, 26] </ref>, Modula-2 [37], and Modula-3 [12], signatures in C ++ allow a clean separation of specification and implementation. However, ML and Modula-2 only have modules and no classes, while Modula-3 has both classes and modules but provides interfaces for modules only and not for classes.
Reference: [27] <author> Robin Milner and Mads Tofte. </author> <title> Commentary on Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mas-sachusetts, </address> <year> 1991. </year>
Reference-contexts: Some forms of overloading and coercion appear in nearly every programming language, with relatively strong support in C ++ . Parametric polymorphism, which allows functions to work over a potentially infinite range of argument types, is mostly found in functional languages, such as ML <ref> [27, 28] </ref> and Haskell [17]. Generics in Ada [5] and templates in C ++ [18, 33] provide a limited form of parametric polymorphism as well. The form of polymorphism relevant to this paper is subtype polymorphism, or subtyping for short.
Reference: [28] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: Some forms of overloading and coercion appear in nearly every programming language, with relatively strong support in C ++ . Parametric polymorphism, which allows functions to work over a potentially infinite range of argument types, is mostly found in functional languages, such as ML <ref> [27, 28] </ref> and Haskell [17]. Generics in Ada [5] and templates in C ++ [18, 33] provide a limited form of parametric polymorphism as well. The form of polymorphism relevant to this paper is subtype polymorphism, or subtyping for short.
Reference: [29] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt. </author> <title> An introduction to Trellis/Owl. </title> <booktitle> In Proceedings of the OOPSLA '86 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 9-16, </pages> <address> Portland, Oregon, </address> <month> 29 September - 2 October </month> <year> 1986. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 21(11), </volume> <month> November </month> <year> 1986. </year>
Reference-contexts: Signatures, in this language extension, are related to types in Russell [16], signatures in ML [25, 26], type classes in Haskell [17], definition modules in Modula-2 [37], interface modules in Modula-3 [12], abstract types in Emerald [9], type modules in Trellis/Owl <ref> [29] </ref>, categories in Axiom [22] and its predecessor Scratchpad II [35, 36], and types in POOL-I [4]. In this section, we specify syntax and semantics of signatures, signature pointers, and signature references. <p> Russell [16] and Haskell [17] have notions related to signatures, but both lack classes. Emerald [9] has first-class types instead of classes, and Trellis/Owl <ref> [29] </ref> has a class hierarchy in which only type information but no implementation is inherited. Signatures in C ++ come closest to categories in Axiom [22] and types in POOL-I [4].
Reference: [30] <author> Alan Snyder. </author> <title> Encapsulation and inheritance in object-oriented programming languages. </title> <booktitle> In Proceedings of the OOPSLA '86 Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 38-45, </pages> <address> Portland, Oregon, </address> <month> 29 September - 2 October </month> <year> 1986. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 21(11), </volume> <month> November </month> <year> 1986. </year>
Reference-contexts: If inheritance is used to define a subtype relationship, it can either make subtyping unsound or limit the flexibility of inheritance for code reuse. An example similar to one in <ref> [30] </ref> illustrates this point. Consider two abstract types Queue and DEQueue (doubly ended queue). The abstract type DEQueue provides the same operations as Queue and in addition two operations for enqueuing at the head and for dequeuing from the tail of the queue. Therefore, DEQueue is a subtype of Queue.
Reference: [31] <author> Richard M. Stallman. </author> <title> Using and Porting GNU CC. Free Software Foundation, </title> <address> Cambridge, Mas-sachusetts, </address> <month> 14 June </month> <year> 1995. </year> <title> Available as part of the GCC-2.7.0 distribution. </title>
Reference-contexts: Using this method it is possible to write a compiler preprocessor, say cfrontfront, that translates from C ++ with signatures into C ++ without signatures. We then present our GCC <ref> [31] </ref> implementation, which is designed to minimize the run-time overhead. The implementation only modifies GCC's C ++ front end, cc1plus; the technique is independent of the compiler and, e.g., could be used to implement signatures in the AT&T cfront compiler as well.
Reference: [32] <author> Bjarne Stroustrup. </author> <booktitle> Multiple inheritance for C ++ . In Proceedings of the EUUG Spring '87 Conference, </booktitle> <address> Helsinki, Finnland, </address> <month> May </month> <year> 1987. </year> <title> European UNIX Users Group. </title> <note> Also available in the C ++ Translator Technical Papers collection from AT&T to attendees of OOPSLA '87. </note>
Reference-contexts: The type tag is needed to determine whether to call displayList [i].pMotifObject-&gt;display () or displayList [i].pOpenLookObject-&gt;display (). The inelegance of this solution should be apparent. In C ++ , as in other languages, multiple inheritance <ref> [32] </ref> can also be used to solve this problem.
Reference: [33] <author> Bjarne Stroustrup. </author> <booktitle> Parameterized types for C ++ . In Proceedings of the 1988 USENIX C ++ Conference, </booktitle> <pages> pages 1-18, </pages> <address> Denver, Colorado, </address> <month> 17-21 October </month> <year> 1988. </year> <institution> USENIX Association. </institution>
Reference-contexts: Parametric polymorphism, which allows functions to work over a potentially infinite range of argument types, is mostly found in functional languages, such as ML [27, 28] and Haskell [17]. Generics in Ada [5] and templates in C ++ <ref> [18, 33] </ref> provide a limited form of parametric polymorphism as well. The form of polymorphism relevant to this paper is subtype polymorphism, or subtyping for short. It is found in some form in most strongly typed object-oriented languages. <p> The implementation of the methods in the new classes can just forward the operation to the implementation in the original library class. In C ++ , the task of creating these classes can be simplified using templates <ref> [18, 33] </ref>. However, even with templates this option entails substantial software engineering costs. Building all the extra classes is tedious at best, and clutters the program name space with a superfluous set of new class names.
Reference: [34] <author> Bjarne Stroustrup and Dmitry Lenkov. </author> <title> Run-time type identification for C ++ (revised). </title> <booktitle> In Proceedings of the 1992 USENIX C ++ Conference, </booktitle> <pages> pages 313-339, </pages> <address> Portland, Oregon, </address> <month> 10-13 August </month> <year> 1992. </year> <booktitle> USENIX. </booktitle>
Reference-contexts: Both the signature table manager and the link-time table comparison could be implemented efficiently using the type matching scheme described in [23]. If a signature table manager is used and type information of objects is available at run time (e.g., using typeid <ref> [34] </ref>) the signature tables for virtual subclasses can be generated at run-time, eliminating the need for double indirection when looking up the address of a virtual member function and eliminating copying of signature tables when assigning one signature pointer to another. 1 This complexity is necessary to correctly handle assignments to
Reference: [35] <author> Robert S. Sutor and Richard D. Jenks. </author> <title> The type inference and coercion facilities in the Scratchpad II interpreter. </title> <booktitle> In Proceedings of the SIGPLAN '87 Symposium on Interpreters and Interpretive Techniques, </booktitle> <pages> pages 56-63, </pages> <address> St. Paul, Minnesota, </address> <month> 24-26 June </month> <year> 1987. </year> <journal> Association for Computing Machinery. ACM SIGPLAN Notices, </journal> <volume> 22(7), </volume> <month> July </month> <year> 1987. </year>
Reference-contexts: in this language extension, are related to types in Russell [16], signatures in ML [25, 26], type classes in Haskell [17], definition modules in Modula-2 [37], interface modules in Modula-3 [12], abstract types in Emerald [9], type modules in Trellis/Owl [29], categories in Axiom [22] and its predecessor Scratchpad II <ref> [35, 36] </ref>, and types in POOL-I [4]. In this section, we specify syntax and semantics of signatures, signature pointers, and signature references. We then show how signatures allow the introduction of subtype polymorphism into C ++ independent of the inheritance mechanism.
Reference: [36] <author> Stephen M. Watt, Richard D. Jenks, Robert S. Sutor, and Barry M. Trager. </author> <title> The Scratchpad II type system: Domains and subdomains. </title> <editor> In Alfonso M. Miola, editor, </editor> <booktitle> Computing Tools for Scientific Problem Solving, </booktitle> <pages> pages 63-82. </pages> <publisher> Academic Press, </publisher> <address> London, Great Britain, </address> <year> 1990. </year>
Reference-contexts: in this language extension, are related to types in Russell [16], signatures in ML [25, 26], type classes in Haskell [17], definition modules in Modula-2 [37], interface modules in Modula-3 [12], abstract types in Emerald [9], type modules in Trellis/Owl [29], categories in Axiom [22] and its predecessor Scratchpad II <ref> [35, 36] </ref>, and types in POOL-I [4]. In this section, we specify syntax and semantics of signatures, signature pointers, and signature references. We then show how signatures allow the introduction of subtype polymorphism into C ++ independent of the inheritance mechanism.
Reference: [37] <author> Niklaus Wirth. </author> <title> Programming in Modula-2. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin-Heidelberg, Germany, </address> <year> 1985. </year> <month> 24 </month>
Reference-contexts: The key language construct added to support type abstraction in C ++ and to allow separating subtyping from inheritance is called a signature. Signatures, in this language extension, are related to types in Russell [16], signatures in ML [25, 26], type classes in Haskell [17], definition modules in Modula-2 <ref> [37] </ref>, interface modules in Modula-3 [12], abstract types in Emerald [9], type modules in Trellis/Owl [29], categories in Axiom [22] and its predecessor Scratchpad II [35, 36], and types in POOL-I [4]. In this section, we specify syntax and semantics of signatures, signature pointers, and signature references. <p> We proposed language constructs for specifying and working with signature types. These constructs allow us to decouple subtyping from inheritance. The result, C ++ with signatures, has a type system related to those of several other modern programming languages. Similarly as in ML [25, 26], Modula-2 <ref> [37] </ref>, and Modula-3 [12], signatures in C ++ allow a clean separation of specification and implementation. However, ML and Modula-2 only have modules and no classes, while Modula-3 has both classes and modules but provides interfaces for modules only and not for classes.
References-found: 37

