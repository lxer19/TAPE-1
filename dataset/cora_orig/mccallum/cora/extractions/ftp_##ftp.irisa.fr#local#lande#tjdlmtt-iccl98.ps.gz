URL: ftp://ftp.irisa.fr/local/lande/tjdlmtt-iccl98.ps.gz
Refering-URL: http://www.irisa.fr/lande/vip.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: Email: fjensen,lemetayer,thorng@irisa.fr  
Title: Security and Dynamic Class Loading in Java: A Formalisation  
Author: T. Jensen D. Le Metayer T. Thorn IRISA/CNRS/INRIA 
Address: F-35042 Rennes Cedex, France  
Affiliation: Campus de Beaulieu  
Abstract: We give a formal specification of the dynamic loading of classes in the Java Virtual Machine (JVM) and of the visibility of members of the loaded classes. This specification is obtained by identifying the part of the run-time state of the JVM that is relevant for dynamic loading and visibility and consists of a set of inference rules defining abstract operations for loading, linking and verification of classes. The formalisation of visibility includes an axiomatisation of the rules for membership of a class under inheritance, and of accessibility of a member in the presence of accessibility modifiers such as private and protected. The contribution of the formalisation is twofold. First, it provides a clear and concise description of the loading process and the rules for member visibility compared to the informal definitions of the Java language and the JVM. Second, it is sufficiently simple to allow calculations of the effects of load operations in the JVM. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Bertelsen. </author> <title> Semantics of Java byte code. </title> <type> Technical report, </type> <institution> Department of Information Technology, Technical University of Denmark, </institution> <month> March </month> <year> 1997. </year>
Reference-contexts: However, this description does not deal with dynamic class loading at all. At the virtual machine level, the tour de force formalisation of the Java virtual machine by Bertelsen <ref> [1] </ref> seems too detailed to be used for practical calculations. In this paper, we propose a formalisation of the visibility rules in the hierarchy of classes loaded into a virtual machine and their evolution through dynamic loading and linking. <p> The formalisations of the semantics of Java published so far deal exclusively with either the type system [4, 14] of the compiler or the reduction rules of the virtual machine <ref> [1, 12] </ref>. Drossopoulou and Eisenbach [4] presents a formalisation of the type system of a substantial subset of Java (including arrays, dynamic method binding, object creation, exception handling, . . . ). <p> However, as opposed to the work described here, Qian starts with the closed world assumption (all classes have been previously loaded into the system by a single class loader) and does not take visibility rules into account. Bertelsen <ref> [1] </ref> presents a very precise definition of the virtual machine based on the informal specification in [9]. In addition to the heap and the environment, the state of the machine includes a stack of frames, each one corresponding to a method invocation. <p> This notion of view is thus close to the facets in Action Semantics 7 [11]. It should be clear that all the contributions reviewed here (except <ref> [1] </ref> which aims at comprehensiveness) focus on complementary aspects and shed some light on the language. Determining what the most interesting views of the semantics should be and how they interfere is certainly one major avenue for future research in this area.
Reference: [2] <author> L. Cardelli. </author> <title> Program fragments, linking and modulariza-tion. </title> <booktitle> In Proc. of 24th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 266277. </pages> <publisher> ACM Press, </publisher> <year> 1997. </year> <title> 7 The motivations for facets in Action Semantics are very much along the lines of the above discussion (tackling the complexity of the semantics of real programming language and providing a better insight on the main design choices through a separation of concerns) but they represent independent kinds of information (like functionality, </title> <journal> communications, declarations). </journal>
Reference-contexts: Its importance has been recognised recently by Cardelli <ref> [2] </ref> who proposes a formalisation of linking as a process of combining program fragments. The main goal in [2] is to provide a formal basis for the design of programming languages and module systems and it considers only static linking. <p> Its importance has been recognised recently by Cardelli <ref> [2] </ref> who proposes a formalisation of linking as a process of combining program fragments. The main goal in [2] is to provide a formal basis for the design of programming languages and module systems and it considers only static linking. A formal study of dynamic linking and its interaction with static typing is reported by Dean [3].
Reference: [3] <author> D. Dean. </author> <title> The security of static typing with dynamic linking. </title> <booktitle> In Proc. of 4th ACM Conf. on Computer and Communications Security, </booktitle> <pages> pages 1827. </pages> <publisher> ACM Press, </publisher> <year> 1997. </year>
Reference-contexts: The main goal in [2] is to provide a formal basis for the design of programming languages and module systems and it considers only static linking. A formal study of dynamic linking and its interaction with static typing is reported by Dean <ref> [3] </ref>. The paper presents a model of dynamic linking which is closely related to Java and proposes a restriction on the dynamic linking operation in order to ensure its soundness with respect to the static type checking.
Reference: [4] <author> S. Drossopoulou and S. Eisenbach. </author> <title> Java is type safe probably. </title> <booktitle> In 11th European Conference on Object Oriented Programming, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: Several formalisations of Java have been proposed in the literature. Each one has its own merits and sheds some light on the language, but we believe that none of them really satisfies the above criteria. At the language level, Drossopoulou and Eisenbach <ref> [4] </ref> have proposed an operational semantics and a type system for core Java, and proved that the type system is sound with respect to this semantics. However, this description does not deal with dynamic class loading at all. <p> The formalisations of the semantics of Java published so far deal exclusively with either the type system <ref> [4, 14] </ref> of the compiler or the reduction rules of the virtual machine [1, 12]. Drossopoulou and Eisenbach [4] presents a formalisation of the type system of a substantial subset of Java (including arrays, dynamic method binding, object creation, exception handling, . . . ). <p> The formalisations of the semantics of Java published so far deal exclusively with either the type system [4, 14] of the compiler or the reduction rules of the virtual machine [1, 12]. Drossopoulou and Eisenbach <ref> [4] </ref> presents a formalisation of the type system of a substantial subset of Java (including arrays, dynamic method binding, object creation, exception handling, . . . ). <p> These aspects are precisely the core of our contribution. On the other hand, we do not deal with type checking ourselves, considering it an orthogonal issue. So, the results presented in this paper are complementary to <ref> [4, 14] </ref>. This complementarity goes in both directions: visibility rules should be taken into account within type checking and a form of type checking should be included in the load time verifications of the abstract machine. This integration is a natural avenue for further work.
Reference: [5] <author> L. Gong. </author> <title> Going beyond the sandbox: An overview of the new security architecture in the Java development kit 1.2. </title> <booktitle> In Proc. of USENIX Symposium on Internet Technologies and Systems, </booktitle> <month> December </month> <year> 1997. </year>
Reference-contexts: Determining what the most interesting views of the semantics should be and how they interfere is certainly one major avenue for future research in this area. Another important extension of the existing results is the formalisation of specific security policies for Java applications <ref> [5, 6, 7] </ref> and the study of the impact of the safety properties studied so far on security issues.
Reference: [6] <author> L. Gong. </author> <title> Java security: Present and near future. </title> <journal> IEEE Micro, </journal> <volume> May-June:1419, </volume> <year> 1997. </year>
Reference-contexts: Determining what the most interesting views of the semantics should be and how they interfere is certainly one major avenue for future research in this area. Another important extension of the existing results is the formalisation of specific security policies for Java applications <ref> [5, 6, 7] </ref> and the study of the impact of the safety properties studied so far on security issues.
Reference: [7] <author> L. Gong. </author> <title> New security architectural directions for Java. </title> <booktitle> In Proc. of IEEE COMPCON, </booktitle> <pages> pages 97102, </pages> <year> 1997. </year>
Reference-contexts: Each class is associated with a specific class loader which corresponds to a specific name space in the virtual machine. The Java security model relies on name spaces to ensure that an untrusted applet cannot interfere with other Java pro grams <ref> [7] </ref>. Another important aspect of the security of the language is the visibility modifiers (default, public, protected, private) which are attached to classes and members in order to restrict the access to these. For instance, attributes with a default visibility are fully accessible only within their definition package. <p> Determining what the most interesting views of the semantics should be and how they interfere is certainly one major avenue for future research in this area. Another important extension of the existing results is the formalisation of specific security policies for Java applications <ref> [5, 6, 7] </ref> and the study of the impact of the safety properties studied so far on security issues.
Reference: [8] <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: In this paper, we propose a formalisation of the visibility rules in the hierarchy of classes loaded into a virtual machine and their evolution through dynamic loading and linking. The formalisation is based on the informal specification of the visibility rules in the Java language definition <ref> [8] </ref>. We relate each of our rules to the explanations taken from [8], explaining our interpretation when appropriate. The formalisation of dynamic class loading is based on [9]. <p> The formalisation is based on the informal specification of the visibility rules in the Java language definition <ref> [8] </ref>. We relate each of our rules to the explanations taken from [8], explaining our interpretation when appropriate. The formalisation of dynamic class loading is based on [9]. <p> In order to integrate this with the semantics of dynamic loading (Section 6) every rule is relative to a set of loaded classes S and a current class cc 2 LoadedClass. 4.1 Members Throughout this section, x-references refer to <ref> [8] </ref>. x6.4.2 states the conditions for class membership (which are re peated in x8.2): * Members inherited from its direct superclass (x8.1.3) * Members inherited from any direct superinterfaces (x8.1.4) * Members declared in the body of the class (x8.1.5) x6.4.3 states the conditions for interfaces membership: * Members inherited from <p> `member of' as a relation between m and c. member-of Member fi LoadedClass m 2 member (c:cf ) S; cc ` m member-of c (5) S; cc ` c inherits m S; cc ` m member-of c (6) The `inherits' relation is defined in the next section. 4.2 Inheritance Following <ref> [8] </ref> the rules for inheritance are divided into two parts. The first part gives an over-estimation, which is then constrained by the second. <p> The specification of the Java language <ref> [8, x6.6.1] </ref> states: A member (field or method) of a reference type or a constructor is accessible only if the type is accessible and the member or constructor is de clared to permit access.
Reference: [9] <author> T. Lindholm and F. Yelling. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: The formalisation is based on the informal specification of the visibility rules in the Java language definition [8]. We relate each of our rules to the explanations taken from [8], explaining our interpretation when appropriate. The formalisation of dynamic class loading is based on <ref> [9] </ref>. The two main contributions of the formalisation presented in this paper are the following: * It provides a clear and concise description of the loading process and the rules for member visibility compared to the definitions of the Java language and the Java virtual machine (JVM). <p> The behaviour of a class loader can thus be modelled by a function W : LoadedClass fi Class ,! LoadedClass 3 Although 2.16.2 in the JVM Specification <ref> [9] </ref> seems to indicate something else. The newer 1.1 implementation follows this rule, but we haven't been able to locate any documentation confirming this. that for a given class loader cl (itself a loaded class) and a class name n returns a loaded class c n . <p> S 2 State = P (LoadedClass) The state determines a set of semantic relations on inheritance, accessibility and visibility of names in classes, as explained in the preceding sections. The purpose of this section is to describe how the instructions of the virtual machine <ref> [9] </ref> transform this state. This transformation is itself dependent on the visibility relation determined by the current state of the machine. In the following, we formalise two abstract operations load and link that model the be-haviour of the JVM when loading and linking classes. <p> origin (f )):cf ; f ) f c 2 Class c a sub W (cc:cl; f c ) S; cc; ST ` typecheck (putfield (f )) (27) 6.4 Semantics of JVM instructions JVM machine instructions reference classes and their fields and methods via the constant pool of the current class <ref> [9, Ch. 5] </ref>. Each class defines a constant pool whose entries contain attributes of the entity referenced through that entry. This indirect naming avoids the need for fully qualified names to appear in the bytecode but is irrelevant for our purposes. <p> Bertelsen [1] presents a very precise definition of the virtual machine based on the informal specification in <ref> [9] </ref>. In addition to the heap and the environment, the state of the machine includes a stack of frames, each one corresponding to a method invocation. A frame consists of a program counter, an operand stack, a set of local variables and a current method identifier. <p> The report by Bertelsen contains a comprehensive definition of the instruction set of the Java Virtual Machine (only some instructions cannot be described precisely because they require concrete representations of the state). This specification was precise enough to reveal a number of ambiguities and errors in <ref> [9] </ref>. Because of its low level and exhaustive nature, this specification is in fact close to a formal reference manual and it is not evident whether it can easily be exploited to support formal reasoning on Java programs.
Reference: [10] <author> G. McGraw and E. Felten. </author> <title> Java Security: hostile applets, holes and antidotes. </title> <editor> J. </editor> <publisher> Wiley & Sons, </publisher> <year> 1997. </year>
Reference-contexts: This bug can be exploited to cause type confusion between two classes with the well known consequences for the security such as providing access to private variables from other classes <ref> [10] </ref>.
Reference: [11] <author> P. Mosses. </author> <title> Action Semantics, </title> <booktitle> volume 26 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: This notion of view is thus close to the facets in Action Semantics 7 <ref> [11] </ref>. It should be clear that all the contributions reviewed here (except [1] which aims at comprehensiveness) focus on complementary aspects and shed some light on the language.
Reference: [12] <author> Z. Qian. </author> <title> A formal specification of Java virtual machine instructions. </title> <type> Technical report, </type> <institution> Universitat Bremen, </institution> <year> 1997. </year>
Reference-contexts: As a consequence, we do not describe type checking either, considering it a complementary issue which can be tackled e.g., by using the system presented by Qian in <ref> [12] </ref>. Then we show that this formalisation allows us to expose in a straightforward way a security problem that was discovered empirically in [13]. It is assumed that the reader is familiar with Java and its terminology concerning classes, interfaces, and visibility modifiers. <p> The function typecheck-class verifies each instruction of a class using typecheck defined below. Type checking of JVM instruction is described in detail by Qian <ref> [12] </ref> and is not the aim of this paper. We give a brief presentation of the rules for type-checking two instructions that models method invocation and assignment (called invokevir-tual and putfield after their JVM equivalents) in order to demonstrate how visibility and loading interacts. Type-checking of JVM instructions in [12] operates <p> Qian <ref> [12] </ref> and is not the aim of this paper. We give a brief presentation of the rules for type-checking two instructions that models method invocation and assignment (called invokevir-tual and putfield after their JVM equivalents) in order to demonstrate how visibility and loading interacts. Type-checking of JVM instructions in [12] operates with a simulated stack ST of types mirroring the types of the objects on the run-time stack. <p> The formalisations of the semantics of Java published so far deal exclusively with either the type system [4, 14] of the compiler or the reduction rules of the virtual machine <ref> [1, 12] </ref>. Drossopoulou and Eisenbach [4] presents a formalisation of the type system of a substantial subset of Java (including arrays, dynamic method binding, object creation, exception handling, . . . ). <p> To the best of our knowledge, the only attempt at defining byte code verifications formally has been carried out by Qian <ref> [12] </ref> who includes a proof of soundness of a bytecode verifier with respect to a simplified specification of the Java virtual machine.
Reference: [13] <author> V. Saraswat. </author> <title> Java is not type-safe. </title> <type> Technical report, </type> <institution> AT&T Research, </institution> <year> 1997. </year> <note> http://www.research.att.com/ ~vj/bug.html. </note>
Reference-contexts: This combination of features inevitably leads to complexities and uncertainties which can have unfortunate consequences in terms of security. This is manifested by the 1 fact that apparently harmless programs can lead to unex-pected security flaws <ref> [13] </ref>. Furthermore some features of the informal specification of the language and the virtual machine are subject to different interpretations. <p> Then we show that this formalisation allows us to expose in a straightforward way a security problem that was discovered empirically in <ref> [13] </ref>. It is assumed that the reader is familiar with Java and its terminology concerning classes, interfaces, and visibility modifiers. The next section summarises our notation for these entities. 2 Syntax Below we formalise the concepts from Java programs relevant to our point of view. <p> Instructions with class references are treated similarly. 7 A bug in the ClassLoader mechanism V. Saraswat has recently reported a bug in the way in which the JVM determines whether two classes are equivalent <ref> [13] </ref>. This bug can be exploited to cause type confusion between two classes with the well known consequences for the security such as providing access to private variables from other classes [10]. <p> However, if only the names of the classes are checked for equality then the assignment is deemed correct, leading to a situation where the once private field i of class R is now considered public. See the report by Saraswat <ref> [13] </ref> for an extensive discussion of this problem. In this section we show how this problem and its solution can be become apparent by analysing the program using our formalism.
Reference: [14] <author> D. Syme. </author> <title> Proving Java type soundness. </title> <type> Technical Report 427, </type> <institution> Cambridge University, </institution> <month> June </month> <year> 1997. </year>
Reference-contexts: The formalisations of the semantics of Java published so far deal exclusively with either the type system <ref> [4, 14] </ref> of the compiler or the reduction rules of the virtual machine [1, 12]. Drossopoulou and Eisenbach [4] presents a formalisation of the type system of a substantial subset of Java (including arrays, dynamic method binding, object creation, exception handling, . . . ). <p> This shows a form of soundness of the type system for this subset of Java. A variation of this formalisation has been expressed and mechanically verified by Syme using a higher-order logic proof system called Declare <ref> [14] </ref>. The formalisation of the type system of Java is extremely useful both for a better understanding of the language and for discovering mistakes or omissions in the informal specifications. <p> These aspects are precisely the core of our contribution. On the other hand, we do not deal with type checking ourselves, considering it an orthogonal issue. So, the results presented in this paper are complementary to <ref> [4, 14] </ref>. This complementarity goes in both directions: visibility rules should be taken into account within type checking and a form of type checking should be included in the load time verifications of the abstract machine. This integration is a natural avenue for further work.
Reference: [15] <author> T. Thorn. </author> <title> Programming Languages for Mobile Code. </title> <journal> ACM Computing Surveys, </journal> <month> September </month> <year> 1997. </year>
Reference-contexts: What we would like to ensure ultimately is confidentiality and integrity properties. A short review of existing works in this direction can be found in <ref> [15] </ref>.
References-found: 15

