URL: ftp://ftp.sics.se/pub/SICS-reports/Reports/SICS-R--92-05--SE.ps.Z
Refering-URL: http://www.sics.se/libindex.html
Root-URL: 
Abstract: 1 . Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 2 . GCLAII . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 2.1 T h e D e f i n i t i o n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 2.2 The Rule Definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 2.2.1 The inference rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 2.2.2 The search strategies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 3 . Developing programs in the GCLA system . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 3.1 A simple example: Default reasoning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 3.1.1 Step 1: Writing the declarative part . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 3.1.2 Step 2: Writing strategies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 3.2 Another example: Functional programming . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 3.2.1 Step 1: The declarative part . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 3.2.2 Step 2: Writing strategies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 3.2.3 Step 3: Writing specialized rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 4 . Ot h er e x a m pl e s. .. .. .. .. .. .. . .. .. .. .. .. .. . .. .. .. .. .. . .. .. .. .. .. .. . .. .. .. .. .. .. . .. .. .. .. .. .. . .. .. 17 4.1 Sorting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 4.2 STRIPS like planning.............................................................. 21 4.3 Object oriented programming . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 4.4 Guiding the search among the assumptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 5 . Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 R e f e r e n c e s . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 Appendix A . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . i Appendix B . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . iii Appendix C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . vii 
Abstract-found: 1
Intro-found: 0
Reference: [Aro90] <author> M. Aronsson, L-H. Eriksson, A. Gredal, L. Hallns, P. Olin, </author> <title> The Programming Language GCLA: A Definitional Approach to Logic Programming, New Generation Computing 7(4), </title> <journal> pp. </journal> <volume> 381 - 404, </volume> <year> 1990. </year>
Reference-contexts: During the time there have been several versions. Two main versions can be discerned. One older version interpreting a GCLA program, having some inference rules given beforehand, called GCLA I <ref> [Aro90] </ref>. GCLA I had a very restricted set of control primitives, which led to a large search space for larger programs. From the GCLA I system the GCLA II system was developed.
Reference: [Aro91a] <author> M. Aronsson, </author> <title> GCLA User's manual, </title> <type> Technical Report SICS T91:21, </type> <year> 1991 </year>
Reference: [Aro91b] <author> M. Aronsson, </author> <title> A Definitional Approach to the Combination of Functional and Relational Programming, </title> <institution> Research Report SICS R91:10, </institution> <year> 1991 </year>
Reference-contexts: that occurs in the beginning of all the rule files loads the file rules.rul from the GCLA rules' library, i.e. sets GCLA up with the general rules described in the appendix. 4.1 Sorting This example shows integration of relational and functional programming, and has been presented in more detail in <ref> [Aro91b] </ref>. It has some interesting properties. One can note that the functional part, the clauses defining qsort and append, are executed by one set of inference rules, mostly left hand side rules (see the rules for functional execution above).
Reference: [Eri92] <author> L-H. Eriksson, </author> <title> A Finitary Version of the Calculus of Partial Inductive Definitions, </title> <booktitle> Extensions of Logic Programming: Proceedings of a workshop held at SICS, Februari 1991, Springer Lecture Notes in Artificial Intelligence. </booktitle>
Reference-contexts: Note that there exist no pi_right rule, since the complexity for that rule is to high (c.f. existentially quantified variables to the left). For further information about variables and their interpretation in GCLA see <ref> [Eri92] </ref>. The P-rule rule was not part of the GCLA I system, but is useful, for example the functional programming presented in section 3.2 uses this construct.
Reference: [Hal91] <author> L. Hallns, </author> <title> Partial Inductive Definitions, </title> <booktitle> Theoretical Computer Science vol. </booktitle> <pages> 87 pp 115 - 142, </pages> <year> 1991 </year>
Reference-contexts: It is a logical programming language, and has similar syntax as Prolog, while the declarative semantics is completely different. While Prolog is based on first order logic, GCLA is based on Partial inductive definition (PID), a framework developed by Lars Hallns <ref> [Hal91, HS-H88] </ref>. During the time there have been several versions. Two main versions can be discerned. One older version interpreting a GCLA program, having some inference rules given beforehand, called GCLA I [Aro90].
Reference: [HS-H88] <author> L. Hallns, P. Schroeder-Heister, </author> <title> A Proof-Theoretic Approach to Logic Programming, published in two parts in the Journal of Logic and Computation, part I: Clauses as Rules, </title> <journal> vol. </journal> <volume> 1(2), </volume> <pages> pp 261 - 283, </pages> <year> 1990, </year> <title> part II: Programs as Definitions, </title> <journal> vol. </journal> <volume> 1(5), </volume> <pages> pp 635 - 660, </pages> <year> 1991. </year>
Reference-contexts: It is a logical programming language, and has similar syntax as Prolog, while the declarative semantics is completely different. While Prolog is based on first order logic, GCLA is based on Partial inductive definition (PID), a framework developed by Lars Hallns <ref> [Hal91, HS-H88] </ref>. During the time there have been several versions. Two main versions can be discerned. One older version interpreting a GCLA program, having some inference rules given beforehand, called GCLA I [Aro90].
Reference: [Han92] <author> P. Hanschke, </author> <title> Terminological Reasoning and Partial Inductive Definitions, </title> <booktitle> Extensions of Logic Programming: Proceedings of a workshop held at SICS, Februari 1991, Springer Lecture Notes in Artificial Intelligence. </booktitle> - <pages> 34 </pages> - 
Reference-contexts: These versions can for example be used in the object oriented programming example in section 4.3. The extended version was invented during the development of a terminological reasoning application, which can be found in <ref> [Han92] </ref>. The example definition that we are going to use here is a small, academic one, since it is the behaviour of the meta level that is interesting.
Reference: [Kre92] <author> P. Kreuger, GCLAII, </author> <title> A Definitional Approach to Control, </title> <booktitle> Extensions of Logic Programming: Proceedings of a workshop held at SICS, Februari 1991, Springer Lecture Notes in Artificial Intelligence. </booktitle>
Reference-contexts: The rule definition is a restricted form of a GCLA I program with some primitives for accessing the definition, so the two parts share the same theoretical basis. For a more complete presentation of GCLA II's theoretical properties and its relation to PID see <ref> [Kre92] </ref>. The definition is intended to define the declarative knowledge of a domain while the rule definition is intended to define how the declarative knowledge is to be used. <p> Object level variables are treated as constants at the meta level. For a more comprehensive description of GCLAII and its theoretical properties the reader is referred to <ref> [Kre92] </ref>. The presentation here will focus on the syntax and properties that our prototype implementation has, therefore some differences to [Kre92] can occur. 2.1 The Definition The definition contains the declarative knowledge of the domain. In GCLA I this part was called the program. The syntax is similar to Prolog. <p> Object level variables are treated as constants at the meta level. For a more comprehensive description of GCLAII and its theoretical properties the reader is referred to <ref> [Kre92] </ref>. The presentation here will focus on the syntax and properties that our prototype implementation has, therefore some differences to [Kre92] can occur. 2.1 The Definition The definition contains the declarative knowledge of the domain. In GCLA I this part was called the program. The syntax is similar to Prolog. Since we talk about inductive definitions, we have no predicates or functions, just terms and conditions. <p> There can be more than one definiens for a term T. This primitive does not check whether T is an atom or not. The reader is refered to <ref> [Kre92] </ref> for a formal definition of the definiens operation unify (T1,T2) Unifies the object level terms T1 and T2. - 5 - not (T) not is true if T is proven false, i.e. not could be thought of as having the GCLA definition not (T) &lt;= T -&gt; false. <p> GCLA tries to fill in PT i with proofterms coding the derivation tree corresponding to rule_name's premises. As an example we give the inference rules implementing GCLA I, or, in fact, the rules for the calculus OLD in <ref> [Kre92] </ref>, and the corresponding code in GCLA II. The operator "@" is an infix (right associative) append operator that appends it's two arguments, "|" is an infix cons operator and "[" and "]" marks a list of assumptions. <p> Below is a generic derivation (in tree format) of a single step of a meta level inference step. For a description of this in linear form, and further descriptions about the calculus used at the meta level, we refer to <ref> [Kre92] </ref>. <p> For a complete listing of the code which implements the general rules and strategies in GCLA II see appendix A. For a more thorough treatment of GCLA and its properties we refer to <ref> [Kre92] </ref>. One should also note that even though the procedural part codes algorithms, which define how the declarative part is to be utilized, the coding of the rules and strategies is a subset of GCLA I and can thus be given a declarative reading.
Reference: [Nil82] <author> N. Nilsson, </author> <booktitle> Principles of Artificial Intelligence, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1982. </year>
Reference-contexts: succeeded and failed calls: - 21 - Succeeded calls Failed calls Total number of calls lra TOTAL 480 TOTAL 2574 TOTAL 3054 qs TOTAL 499 TOTAL 1422 TOTAL 1921 A significiant better performance for the qs strategy. 4.2 STRIPS like planning STRIPS is a planning system, invented by Nils Nilsson <ref> [Nil82] </ref>. In short, the system has a global database, which is altered when a planning operation is executed. From a starting state the system performs planning operations until it has reached some goal state, and the resulting sequence of planning operations is the plan.
References-found: 9

