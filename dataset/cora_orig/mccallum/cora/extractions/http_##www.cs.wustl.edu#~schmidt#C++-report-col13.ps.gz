URL: http://www.cs.wustl.edu/~schmidt/C++-report-col13.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/report-doc.html
Root-URL: 
Email: schmidt@cs.wustl.edu vinoski@iona.com  
Title: Object Interconnections Developing C++ Servant Classes Using the Portable Object Adapter (Column 13)  
Author: Douglas C. Schmidt Steve Vinoski 
Note: This column will appear in the June 1998 issue of the SIGS C++ Report magazine.  
Address: St. Louis, MO 63130 60 Aberdeen Ave., Cambridge, MA 02138  
Affiliation: Department of Computer Science IONA Technologies, Inc. Washington University,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> D. C. Schmidt and S. Vinoski, </author> <title> Object Adapters: Concepts and Terminology, </title> <journal> C++ Report, </journal> <volume> vol. 11, </volume> <month> Novem-ber/December </month> <year> 1997. </year>
Reference-contexts: 1 Introduction This is the third column in our series explaining the new OMG Portable Object Adapter. An Object Adapter is the CORBA component responsible for adapting CORBA's concept of objects to a programming language's concept of servants. As you'll recall from previous columns <ref> [1, 2] </ref>, CORBA objects are abstract entities defined by IDL interfaces. Likewise, servants are concrete implementations of CORBA objects written in a particular programming language, such as C++ or Java. The Portable Object Adapter (POA) [3] is a replacement for the Basic Object Adapter (BOA) defined in earlier CORBA specifications. <p> Works // with Orbix BOA interface. - public: // Initialize the ORB manager. ORB_Manager (int argc, char *argv []) - // First argument is assumed to be // server name. svr_name_ = argv <ref> [1] </ref>; - void activate (void *servant) - // Nothing to do, since servant base // class constructor performs activation // when the servant is created. - // Run the main ORB event loop. void run (void) - CORBA::Orbix.impl_is_ready (svr_name_); - private: char *svr_name_; -; 4 Collocation Issues One of the most
Reference: [2] <author> D. C. Schmidt and S. Vinoski, </author> <title> Using the Portable Object Adapter for Transient and Persistent CORBA Objects, </title> <journal> C++ Report, </journal> <volume> vol. 12, </volume> <month> April </month> <year> 1998. </year>
Reference-contexts: 1 Introduction This is the third column in our series explaining the new OMG Portable Object Adapter. An Object Adapter is the CORBA component responsible for adapting CORBA's concept of objects to a programming language's concept of servants. As you'll recall from previous columns <ref> [1, 2] </ref>, CORBA objects are abstract entities defined by IDL interfaces. Likewise, servants are concrete implementations of CORBA objects written in a particular programming language, such as C++ or Java. The Portable Object Adapter (POA) [3] is a replacement for the Basic Object Adapter (BOA) defined in earlier CORBA specifications.
Reference: [3] <institution> Object Management Group, </institution> <note> Specification of the Portable Object Adapter (POA), OMG Document orbos/97-05-15 ed., </note> <month> June </month> <year> 1997. </year>
Reference-contexts: As you'll recall from previous columns [1, 2], CORBA objects are abstract entities defined by IDL interfaces. Likewise, servants are concrete implementations of CORBA objects written in a particular programming language, such as C++ or Java. The Portable Object Adapter (POA) <ref> [3] </ref> is a replacement for the Basic Object Adapter (BOA) defined in earlier CORBA specifications. The newest version of CORBA, CORBA 2.2, [4], contains both the POA specification and the BOA specification.
Reference: [4] <author> Object Management Group, </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <editor> 2.2 ed., </editor> <month> Mar. </month> <year> 1998. </year>
Reference-contexts: Likewise, servants are concrete implementations of CORBA objects written in a particular programming language, such as C++ or Java. The Portable Object Adapter (POA) [3] is a replacement for the Basic Object Adapter (BOA) defined in earlier CORBA specifications. The newest version of CORBA, CORBA 2.2, <ref> [4] </ref>, contains both the POA specification and the BOA specification. The BOA specification will be removed in future versions of CORBA, however, because the POA specification supersedes the BOA.
Reference: [5] <author> D. Schmidt and S. Vinoski, </author> <title> Comparing Alternative Programming Techniques for Multi-threaded CORBA Servers: </title> <journal> Thread-per-Object, C++ Report, </journal> <volume> vol. 8, </volume> <month> July </month> <year> 1996. </year>
Reference-contexts: An OMG IDL compiler is responsible for translating IDL interfaces into a particular programming language. For instance, a POA-compliant IDL-to-C++ compiler would map the following interface for the stock quoting service described in <ref> [5] </ref>: module Stock - interface Quoter - // Return the current value of &lt;stock_name&gt;. long get_quote (in string stock_name); -; - into the C++ code shown below: namespace POA_Stock - class Quoter - public: virtual CORBA::Long get_quote (const char *stock_name) throw (CORBA::SystemException) = 0; // ... // ... <p> All C++ servant classes implement IDL interfaces. Before we can show an example of an application-defined C++ servant class definition, however, we need to supply an IDL interface to base it on. 3 A User-Defined Servant Class The IDL interface shown below was first shown in <ref> [5] </ref>. It defines a Quoter Factory that creates instances of the Quoter interface shown in Section 2. // IDL module Stock - interface Quoter_Factory - // Factory method that creates the // &lt;Quoter&gt; specified by &lt;name&gt;.
Reference: [6] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: It defines a Quoter Factory that creates instances of the Quoter interface shown in Section 2. // IDL module Stock - interface Quoter_Factory - // Factory method that creates the // &lt;Quoter&gt; specified by &lt;name&gt;. Quoter create_quoter (in string name); -; The create quoter operation is a factory method <ref> [6] </ref> that returns an object reference to a Quoter service specified by its name. As usual, this interface has been simplified to concentrate our focus on C++ servant class definitions. <p> Therefore, our C++ exception specifications only allow CORBA system exceptions to be raised since they can be thrown by all OMG IDL operations. 2 The My Quoter Factory servant class uses the inheritance-based approach to servant class definition, which is an example of the class form of the Adapter pattern <ref> [6] </ref>. As shown in Figure 1, the application derives a concrete class from the abstract skeleton base class, in this case named Quoter Factory from the POA Stock namespace, generated by the IDL compiler. <p> Each pure vir tual method, i.e., create quoter, inherited from the base class must be overridden and implemented by the application servant class. 3.2 Tie-Based Servant Another way to define a C++ servant is to use delegation, i.e., the object form of the Adapter pattern <ref> [6] </ref>, instead of inheritance. The POA specification calls this the tie approach 1 because the C++ instance being delegated to is tied into the servant. <p> In particular, it is unlikely that the signature of a non-CORBA class will serendipitously match the signature of the tie class. The problem with signature mismatches can be alleviated somewhat for the IDL-to-C++ mapping using the Adapter pattern <ref> [6] </ref>. One application of the Adapter pattern uses C++ template specializations. <p> Recent changes to CORBA and its services also affect collocation transparency. For instance, the OMG Security Service [8] officially introduced to the CORBA specification the notion of interceptors, which are examples of the Chain of Responsibility pattern <ref> [6] </ref>. Interceptors greatly enhance ORB flexibility by separating request processing from the 3 Steve is one of those designers, so we're not just guessing here! traditional ORB networking mechanisms required to send and receive requests and replies.
Reference: [7] <author> A. Gokhale and D. C. Schmidt, </author> <title> Evaluating the Performance of Demultiplexing Strategies for Real-time CORBA, </title> <booktitle> in Proceedings of GLOBECOM '97, </booktitle> <address> (Phoenix, AZ), </address> <publisher> IEEE, </publisher> <month> Novem-ber </month> <year> 1997. </year>
Reference-contexts: Internally, POA implementations maintain a map of servants that are registered by applications. At run-time this map is used by the POA to demultiplex incoming client requests to the appropriate servant <ref> [7] </ref>. The main purpose of ties is to allow classes that aren't related to skeletons by inheritance, i.e., the tied objects, to implement CORBA object operations. For each operation they supply, they expect the tied object to have a method with exactly the same signature.
Reference: [8] <institution> Object Management Group, OMG Security Service, OMG Document ptc/98-01-02, revision 1.2 ed., </institution> <month> January </month> <year> 1998. </year>
Reference-contexts: Recent changes to CORBA and its services also affect collocation transparency. For instance, the OMG Security Service <ref> [8] </ref> officially introduced to the CORBA specification the notion of interceptors, which are examples of the Chain of Responsibility pattern [6].
Reference: [9] <author> M. Shapiro, </author> <title> Flexible Bindings for Fine-Grain, Distributed Objects, </title> <type> Tech. Rep. </type> <institution> Rapport de recherche INRIA 2007, IN-RIA, </institution> <month> Aug. </month> <year> 1993. </year>
Reference-contexts: Interceptors greatly enhance ORB flexibility by separating request processing from the 3 Steve is one of those designers, so we're not just guessing here! traditional ORB networking mechanisms required to send and receive requests and replies. The CORBA interceptor concepts are based on Marc Shapiro's work on flexible bindings <ref> [9] </ref>, and on Orbix filters, which were the first application of Shapiro's work to CORBA-based systems. Other ORB vendors such as Sun and Borland/Visigenic now support interceptors as well. Interceptors are intimately tied into the connection between the client and server.
Reference: [10] <institution> Object Management Group, OMG Real-time Request for Proposal, OMG Document ptc/97-06-20 ed., </institution> <month> June </month> <year> 1997. </year>
Reference: [11] <institution> Object Management Group, Objects-by-Value, OMG Document orbos/98-01-18 ed., </institution> <month> January </month> <year> 1998. </year> <month> 7 </month>
Reference-contexts: Our next column will be the last in our POA series. It will cover on-demand servant activation via servant managers, which are extremely useful for creating highly-scalable server applications. After that, we'll begin covering the new Objects By Value specification <ref> [11] </ref> and its ramifications on CORBA applications. At the time of this writing (March 1998), this specification is in the process of OMG adoption. As always, if you have any questions about the material we covered in this column or in any previous ones, please email us at object_connect@cs.wustl.edu.
References-found: 11

