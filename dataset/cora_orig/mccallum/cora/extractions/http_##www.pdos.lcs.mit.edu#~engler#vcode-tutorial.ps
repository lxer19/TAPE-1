URL: http://www.pdos.lcs.mit.edu/~engler/vcode-tutorial.ps
Refering-URL: http://www.pdos.lcs.mit.edu/~engler/pldi96-abstract.html
Root-URL: 
Email: engler@lcs.mit.edu  
Title: A VCODE Tutorial  
Author: Dawson R. Engler 
Date: April 28, 1996  
Address: Cambridge, MA 02139  
Affiliation: Laboratory for Computer Science Massachusetts Institute of Technology  
Abstract: This paper is a short tutorial on VCODE, a fast, portable dynamic code generation system. It should be read after [1]. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. R. Engler. </author> <title> VCODE: a retargetable, extensible, very fast dynamic code generation system. </title> <booktitle> In Proceedings of the SIGPLAN '96 Conference on Programming Language Design and Implementation, </booktitle> <month> May </month> <year> 1996. </year>
Reference-contexts: The VCODE interface is that of an idealized load-store RISC architecture. VCODE instructions are simple primitives (e.g., add, sub, load) that map readily to modern architectures. This tutorial is intended for programmers interested in using the VCODE system or in readers interested in details not covered in <ref> [1] </ref>. Section 2 discusses a simple example program, touching on parts of the VCODE system. Section 3 discusses the VCODE instruction set and Section 4 provides a global view of the system (most of this information is provided in [1], we provide it here for completeness). <p> VCODE system or in readers interested in details not covered in <ref> [1] </ref>. Section 2 discusses a simple example program, touching on parts of the VCODE system. Section 3 discusses the VCODE instruction set and Section 4 provides a global view of the system (most of this information is provided in [1], we provide it here for completeness). <p> Table 3: Primary VCODE extensions typedef int (fliptr)(int); /fl Called at runtime to create a function which returns its argument + 1. fl/ iptr mkplus1 (v code flip, int nbytes) v reg arg <ref> [1] </ref>; /fl Begin code generation. The type string ("%i") indicates that this routine takes a single integer (i) argument; the register to hold this argument is returned in arg [0]. <p> & y; fl/ v uptr mk and (void) v reg type arg [2]; /fl Two arguments. fl/ /fl Create and function that returns the result of anding its two unsigned inputs fl/ v lambda ("and", "%u%u", arg, V LEAF, (void fl)malloc (512), 512); v andu (arg [0], arg [0], arg <ref> [1] </ref>); /fl And the two arguments fl/ v retu (arg [0]); /fl Return the result. fl/ return v end (0).u; and specifies it expects two unsigned inputs using the format string: "%u%u". <p> The registers the arguments are stored in are accessed via the arg vector. arg [0] contains the register holding the first argument, arg <ref> [1] </ref> the second. 5.3 Details The union returned by v end is a union of commonly-used function pointer types. It allows clients to eliminate many of the casts they would otherwise need. <p> doing so, the type is capitalized in the type string. mkwrite uses this mechanism to dynamically bind a pointer to tcb in the call to write: /fl generate call to write: %P indicates the first argument (tcb) is a constant fl/ v scalli (v iptr)write, "%P%p%p", tcb, arg [0], arg <ref> [1] </ref>); This feature can make the client's noticeably code cleaner. Frequently, it is the case that the number and type of arguments are not known statically. An example domain where this situation is common is compiling interpreters: interpreters that interactively consume user code and compile it on-the-fly to machine code. <p> currying its first argument, write takes a pointer (msg) and an int (nbytes) fl/ v lambda ("currywrite", "%p%i", arg, V NLEAF, malloc (512), 512); /fl generate call to write: %P indicates the first argument (tcb) is a constant fl/ res = v scalli ((v iptr)write, "%P%p%u", tcb, arg [0], arg <ref> [1] </ref>); v reti (res); /fl return result of calling write fl/ return v end (0).i; int main (void) struct tcb t1, t2; write ptr write1, write2; t1.dst port = 1; t1.src port = 2; write1 = mkwrite (&t1); t2.dst port = 3; t2.src port = 4; write2 = mkwrite (&t2); /fl
Reference: [2] <author> C. W. Fraser and D. R. Hanson. </author> <title> A retargetable compiler for ANSI C. </title> <journal> SIGPLAN Notices, </journal> <volume> 26(10), </volume> <month> October </month> <year> 1991. </year>
Reference-contexts: This process has also been influenced by a number of compiler intermediate representations, the strongest influence being the intermediate representation language of the lcc compiler <ref> [2] </ref>. The instruction set is built from a set of base operations (e.g., sub, mul) that are composed with a set of types (e.g., integer, unsigned). Each instruction takes register or immediate operands and, usually, performs a simple operation on them. <p> A sample function that computes logical and could be coded as follows: /fl generate code to compute bitwise and: unsigned and (unsigned x, unsigned y) return x & y; fl/ v uptr mk and (void) v reg type arg <ref> [2] </ref>; /fl Two arguments. fl/ /fl Create and function that returns the result of anding its two unsigned inputs fl/ v lambda ("and", "%u%u", arg, V LEAF, (void fl)malloc (512), 512); v andu (arg [0], arg [0], arg [1]); /fl And the two arguments fl/ v retu (arg [0]); /fl Return <p> char flmsg, int nbytes) printf ("dst port = %d, src port = %dn", tcb!dst port, tcb!src port); return 1; /fl Create a new function to call a write function with the given control block hardwired as its first argument. fl/ write ptr mkwrite (struct tcb fltcb) v reg type arg <ref> [2] </ref>; /fl two arguments fl/ v reg type res; /fl function result. fl/ /fl After currying its first argument, write takes a pointer (msg) and an int (nbytes) fl/ v lambda ("currywrite", "%p%i", arg, V NLEAF, malloc (512), 512); /fl generate call to write: %P indicates the first argument (tcb) is
References-found: 2

