URL: ftp://ftp.cs.arizona.edu/people/hiltunen/edcc1.ps.Z
Refering-URL: http://www.cs.arizona.edu/people/hiltunen/public.html
Root-URL: http://www.cs.arizona.edu
Title: A Model for Adaptive Fault-Tolerant Systems  
Author: Matti A. Hiltunen and Richard D. Schlichting 
Address: Tucson, AZ 85721, USA  
Affiliation: Department of Computer Science University of Arizona  
Abstract: An adaptive computing system is one that modifies its behavior based on changes in the environment. Since one common type of environment change in a distributed system is network or processor failure, fault-tolerant distributed systems can be viewed as an important subclass of adaptive systems. As such, use of adaptive methods for dealing with failures in this context has the same potential advantages of improved efficiency and structural simplicity as for adaptive systems in general. This paper describes a model for adaptive systems that can be applied in many failure scenarios arising in distributed systems. This model divides the adaptation process into three different phases|change detection, agreement, and action|that can be used as a common means for describing various fault-tolerance algorithms such as reliable transmission and membership protocols. This serves not only to clarify the logical structure and relationship of such algorithms, but also to provide a unifying implementation framework. Several adaptive fault-tolerant protocols are given as examples. A technique for implementing the model in a distributed system using an event-driven approach for composing protocols in parallel is also presented.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> B. Bhargava, K. Friesen, A. Helal, J. Riedl: </author> <title> Adaptability Experiments in the RAID Distributed Database System. </title> <booktitle> Proc. of the 9th IEEE Symposium on Reliable Distributed Systems (1990) 76 - 85 </booktitle>
Reference-contexts: Runtime adaptation has ? This work supported in part by the National Science Foundation under grant CCR 9003161 and the Office of Naval Research under grant N00014-91-J-1015. been studied in a number of different application areas ranging from database transactions <ref> [1] </ref> to real-time parallel systems [2, 3] to high-speed communication protocols [4]. Adaptive systems are important in the area of dependable computing since the actions taken by fault-tolerant systems in response to failures are often adaptive in nature [5]. <p> By nature, optimistic algorithms work well if the system is lightly loaded whereas pessimistic ones are better when the system is heavily loaded. Therefore, it would make sense to design an adaptive concurrency control protocol that changes between optimistic and pessimistic depending on the loading condition. See, for example, <ref> [1] </ref> for more discussion on adaptive concurrency control. 3.2 Adapting to failures This section examines examples of adaptive protocols where the change in the environment is a processor or communication link failure.
Reference: 2. <author> T. Bihari, K. Schwan: </author> <title> Dynamic Adaptation of Real-Time Software. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> vol. </volume> <pages> 9, </pages> <note> num. 2 (May 1991) 143 - 174 </note>
Reference-contexts: Runtime adaptation has ? This work supported in part by the National Science Foundation under grant CCR 9003161 and the Office of Naval Research under grant N00014-91-J-1015. been studied in a number of different application areas ranging from database transactions [1] to real-time parallel systems <ref> [2, 3] </ref> to high-speed communication protocols [4]. Adaptive systems are important in the area of dependable computing since the actions taken by fault-tolerant systems in response to failures are often adaptive in nature [5].
Reference: 3. <author> K. Schwan, T. Bihari, B. Blake: </author> <title> Adaptive, Reliable Software for Distributed and Parallel Real-Time Systems. </title> <booktitle> Proc. of the 6th IEEE Symposium on Reliability in Distributed Software and Database Systems (Mar. </booktitle> <year> 1987) </year> <month> 32 - 42 </month>
Reference-contexts: Runtime adaptation has ? This work supported in part by the National Science Foundation under grant CCR 9003161 and the Office of Naval Research under grant N00014-91-J-1015. been studied in a number of different application areas ranging from database transactions [1] to real-time parallel systems <ref> [2, 3] </ref> to high-speed communication protocols [4]. Adaptive systems are important in the area of dependable computing since the actions taken by fault-tolerant systems in response to failures are often adaptive in nature [5].
Reference: 4. <author> D. Schmidt, D. Box, T. Suda: </author> <title> ADAPTIVE: A Dynamically Assembled Protocol Transformation, Integration, and Evaluation Environment. </title> <journal> Concurrency: Practice and Experience, </journal> <note> vol.5, num. 4 (June 1993) 269 - 286 </note>
Reference-contexts: adaptation has ? This work supported in part by the National Science Foundation under grant CCR 9003161 and the Office of Naval Research under grant N00014-91-J-1015. been studied in a number of different application areas ranging from database transactions [1] to real-time parallel systems [2, 3] to high-speed communication protocols <ref> [4] </ref>. Adaptive systems are important in the area of dependable computing since the actions taken by fault-tolerant systems in response to failures are often adaptive in nature [5].
Reference: 5. <author> J. Goldberg, I. Greenberg, T. Lawrence: </author> <title> Adaptive Fault Tolerance. </title> <booktitle> Proc. of the IEEE Workshop on Advances in Parallel and Distributed Systems (1993) 127 - 132 </booktitle>
Reference-contexts: Adaptive systems are important in the area of dependable computing since the actions taken by fault-tolerant systems in response to failures are often adaptive in nature <ref> [5] </ref>. Here, we describe a model for adaptive systems that can be applied in many failure scenarios, especially those that arise in the context of asynchronous distributed computing architectures.
Reference: 6. <author> M. Hiltunen, R. Schlichting: </author> <title> An Approach to Constructing Modular Fault-Tolerant Protocols. </title> <booktitle> Proc. of the 12th IEEE Symposium on Reliable Distributed Systems (1993) 105 - 114 </booktitle>
Reference-contexts: Next, Sect. 4 shows how algorithms written using the model can easily be implemented using an event-driven approach for composing protocols in parallel <ref> [6] </ref>. Finally, Sect. 5 offers some conclusions. 2 A General Model for Adaptive Systems We model an adaptive system built on a distributed computing platform as responding to changes with the following three phases: 1. Change Detection. <p> This approach was originally designed to facilitate the modularization of fault-tolerant protocols <ref> [6] </ref>, but due to its general nature, it can be used for various other application areas as well. The approach supports parallel composition of micro-protocols into composite protocols, which are then composed in a traditional hierarchical manner with other protocols.
Reference: 7. <author> F. Cristian: </author> <title> Reaching Agreement on Processor-Group Membership in Synchronous Distributed Systems. </title> <journal> Distributed Computing, </journal> <volume> vol. 4 (1991) 175 - 187 </volume>
Reference-contexts: Fig. 3. Adapting to failure Membership. It is often important in distributed systems to keep track of which objects are active and which are inactive or failed, i.e., to keep track of the membership <ref> [7, 8, 9, 10] </ref>. The membership problem appears at many different levels in a system. For example, a token ring algorithm has to keep track of the sites in the ring, while an application-level process group has to keep track of the members in the group.
Reference: 8. <author> H. Kopetz, G. Grunsteidl, J. Reisinger: </author> <title> Fault-Tolerant Membership Service in a Synchronous Distributed Real-Time System. </title> <editor> In: A. Avizienis, J.C. Laprie (eds.): </editor> <title> Dependable Computing for Critical Applications (1991). Vienna: </title> <publisher> Springer-Verlag, </publisher> <pages> pp. 411 - 429 </pages>
Reference-contexts: Fig. 3. Adapting to failure Membership. It is often important in distributed systems to keep track of which objects are active and which are inactive or failed, i.e., to keep track of the membership <ref> [7, 8, 9, 10] </ref>. The membership problem appears at many different levels in a system. For example, a token ring algorithm has to keep track of the sites in the ring, while an application-level process group has to keep track of the members in the group.
Reference: 9. <author> S. Mishra, L. Peterson, R.D. Schlichting: </author> <title> A Membership Protocol Based on Partial Order. </title> <editor> In: J.F. Meyer, R.D. Schlichting (eds.): </editor> <title> Dependable Computing for Critical Applications 2 (1992). Vienna: </title> <publisher> Springer-Verlag, </publisher> <pages> pp. 309 - 331 </pages>
Reference-contexts: Fig. 3. Adapting to failure Membership. It is often important in distributed systems to keep track of which objects are active and which are inactive or failed, i.e., to keep track of the membership <ref> [7, 8, 9, 10] </ref>. The membership problem appears at many different levels in a system. For example, a token ring algorithm has to keep track of the sites in the ring, while an application-level process group has to keep track of the members in the group.
Reference: 10. <author> A. Ricciardi, K. Birman: </author> <title> Using Process Groups to Implement Failure Detection in Asynchronous Environments. </title> <booktitle> Proc. of the 10th ACM Symposium on Principles of Distributed Computing (1991) 341 - 353 </booktitle>
Reference-contexts: Fig. 3. Adapting to failure Membership. It is often important in distributed systems to keep track of which objects are active and which are inactive or failed, i.e., to keep track of the membership <ref> [7, 8, 9, 10] </ref>. The membership problem appears at many different levels in a system. For example, a token ring algorithm has to keep track of the sites in the ring, while an application-level process group has to keep track of the members in the group.
Reference: 11. <author> S. Mishra, L. Peterson, R. Schlichting: </author> <title> Consul: A Communication Substrate for Fault-Tolerant Distributed Programs. </title> <note> Distributed Systems Engineering (to appear 1994). </note>
Reference-contexts: For example, if we use a centralized algorithm and the old coordinator site fails, a different site has to start running the appropriate coordination algorithms. As an example, consider a membership protocol like that used in the Consul system <ref> [11] </ref>. This algorithm is based on examining successive waves (i.e., levels) of the context graph of causally-ordered messages maintained by the Psync group communication mechanism [12]. The change of membership can be represented in the general model of adaptive systems, as follows: 1. Change Detection.
Reference: 12. <author> L. Peterson, N. Buchholz, R. Schlichting: </author> <title> Preserving and Using Context Information in Interprocess Communication. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> vol. 7, </volume> <pages> num. </pages> <month> 3 (Aug. </month> <year> 1989) </year> <month> 217 - 246 </month>
Reference-contexts: As an example, consider a membership protocol like that used in the Consul system [11]. This algorithm is based on examining successive waves (i.e., levels) of the context graph of causally-ordered messages maintained by the Psync group communication mechanism <ref> [12] </ref>. The change of membership can be represented in the general model of adaptive systems, as follows: 1. Change Detection. Detection Policy: If no message has arrived from a site in T seconds, suspect failure and multicast "failure suspicion" message. 2. Agreement.
Reference: 13. <author> M. Kaashoek, A. Tanenbaum, S. Hummel, H. Bal: </author> <title> An Efficient Reliable Broadcast Protocol. </title> <journal> Operating Systems Review, </journal> <volume> vol. 23, </volume> <pages> num. </pages> <month> 4 (Oct. </month> <year> 1989) </year> <month> 5 - 19 </month>
Reference-contexts: Messages are sent directly to the ordering server, which then retransmits them in some total order to all receivers. In this case, all that is needed is FIFO order between the central server and receiving sites. Amoeba is an example of a system that uses such a scheme <ref> [13] </ref>. Alternatively, messages can be multicast directly to the receivers, with the central ordering service only sending ordering messages. An example of such a system is described in [14].
Reference: 14. <author> K. Marzullo, S. Armstrong, A. Freier: </author> <title> Multicast Transport Protocol. Internet RFC 1301 (1992) </title>
Reference-contexts: Amoeba is an example of a system that uses such a scheme [13]. Alternatively, messages can be multicast directly to the receivers, with the central ordering service only sending ordering messages. An example of such a system is described in <ref> [14] </ref>. Like any centralized service, a total ordering service using such an algorithm suffers from the problem of how to handle the failure of the central authority.
Reference: 15. <author> D. Powell: </author> <title> Failure Mode Assumptions and Assumption Coverage. </title> <booktitle> Proc. of the 22nd IEEE Symposium on Fault-Tolerant Computing (1992) 386 - 395 </booktitle>
Reference-contexts: Note that this approach is only practical if detecting the change in failure class is cheaper than tolerating the more difficult failure class to begin with. Assuming that this is true, the biggest problem may be determining how to 2 This categorization can be refined further if desired <ref> [15] </ref>. Fig. 4. Adapting to changes in failure class reestablish a correct state given that incorrect execution may have taken place between the time the environment change occurred and the adaptive action was initiated.
Reference: 16. <author> F. Cristian, H. Aghili, H. Strong, D. Dolev: </author> <title> Atomic Broadcast: From Simple Message Diffusion to Byzantine Agreement. </title> <booktitle> Proc. of the 15th IEEE Symposium on Fault-Tolerant Computing (1985) 200 -206 </booktitle>
Reference-contexts: Timing Policy: Immediately. Note that the solution is not really much cheaper than running negative acks to start with. The only possible advantage of the above proposal could be in reducing the number of unnecessary nacks and retransmissions. Synchronous atomic broadcast. In <ref> [16] </ref>, a set of broadcast protocols that tolerate different classes of failures is described. The assumption is that the underlying network is synchronous and that each pair of sites is connected by enough disjoint paths to tolerate network failures.
Reference: 17. <author> A. Gopal, S. Toueg: </author> <title> Inconsistency and Contamination. Proc. of the 10th ACM Symposium on Principles of Distributed Computing (1991) 257 -272 This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: This may cause these sites to enter an inconsistent state relative to other sites. Furthermore, if a site that is in inconsistent state sends a message to other sites, it can contaminate the rest of the system. The concepts of inconsistency and contamination are discussed in <ref> [17] </ref>, although in that paper, the assumption is that processor rather than network failures lead to inconsistency and contamination. Dealing with this kind of occurrence using an adaptive system allows the system to continue providing total ordering of messages despite the change in the environment. <p> To deal with the change from reliable to unreliable, we change to an asynchronous reliability protocol, such as the use of negative acknowledgements. We can use a scheme similar to the one presented in <ref> [17] </ref> to detect the occurrence of change in failure class. Assume the sender of a message, say site p, includes the sequence of messages delivered to the user at site p, DEL p , in the header of each message sent. <p> If this is not the case, the total order must have been violated. This basic idea can be optimized to cut down the overhead on each message either by using the approach taken in <ref> [17] </ref> of sending message counts instead of the complete history, or by using the fact that messages that are stable|that is, received by every site|can be removed from the message delivery history.
References-found: 17

