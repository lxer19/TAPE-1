URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR349.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Title: MERGING INTERACTIVE, MODULAR, AND OBJECT-ORIENTED PROGRAMMING  
Author: Sho-Huan Simon Tung 
Degree: Submitted to the faculty of the Graduate School in partial fulfillment of the requirements for the degree Doctor of Philosophy in the  
Note: This material is based on work supported by the Sandia National Laboratories under contract number 75-5466 and by the National Science Foundation under grant number CCR-8803432 and by the Motorola Inc.  
Affiliation: Department of Computer Science Indiana University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Abelson, H., Sussman, G. J., and Sussman, J. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press, </publisher> <year> 1984. </year>
Reference-contexts: However, this goal is not entirely achieved, since dynamically extended bindings cannot access lexical variables in a module. This restriction is too strong to be acceptable. 8 CHAPTER 2. RELATED WORK 9 Some Scheme implementations support first class environments <ref> [1] </ref>. A first class environment captures the current lexical environment at the point when the first class environment is created. When used with eval or access, which allow expressions or variables to be evaluated dynamically in a first class environment, some form of packaging facilities can be supported.
Reference: [2] <author> Adams, N., and Rees, J. </author> <title> Object-oriented programming in Scheme. </title> <booktitle> In 1988 ACM Conference on Lisp and Functional Programming (1988), </booktitle> <pages> pp. 277-288. </pages>
Reference-contexts: RELATED WORK 14 decision later without affecting client code. Several systems have been proposed to support object-oriented programming in Scheme. These systems are reviewed in the remainder of this section. Adams and Rees's proposal <ref> [2] </ref> uses procedures to represent objects that respond to messages. Instance variables are implemented as lexical variables and can be accessed only by methods defined within an object. Their system does not explicitly support the notion of classes. <p> CLOS, Flavors, Com- monLoops, CommonObjects, and Oaklisp are examples of Lisp-based object-oriented languages supporting the class/instance approach [39, 53, 5, 63, 47]. Adams and Rees's proposal and Drescher's proposal for object-oriented programming in Scheme adopt the delegation/prototype approach <ref> [2, 18] </ref>. Another important feature of object-oriented languages is dynamic lookup of object operations. Syntactically, dynamic lookup of operations of an object may be expressed by passing a message to an object or by passing an object to a generic function.
Reference: [3] <author> America, P. </author> <title> A parallel object-oriented language with inheritance and subtyping. </title> <booktitle> In Proceedings of OOPSLA EOOOP '90, Object-Oriented Programming Systems, Languages, and Applications (October 1990), </booktitle> <pages> pp. 161-168. </pages> <note> printed as SIGPLAN Notices, 25(10). </note>
Reference-contexts: CLOS, Flavors, and CommonLoops interpret the inheritance graph as a linear chain which can be used with method combinations to resolve conflicts. POOL separates subtyping from inheritance to allow flexible treatment of multiple inheritance for strongly typed languages <ref> [3] </ref>. A detailed discussion about resolving conflicts of multiple inheritance can be found in [64]. We adopt a weaker version of the Eiffel and Trellis/Owl's approach. A warning message is given if a class inherits from more than one direct superclass that define CHAPTER 5.
Reference: [4] <author> Bawden, A., and Rees, J. </author> <title> Syntactic closures. </title> <booktitle> In Proceedings of the 1988 ACM Conference on LISP and Functional Programming (Salt Lake City, </booktitle> <address> Utah., </address> <month> July </month> <year> 1988). </year>
Reference-contexts: Modules are anonymous. They communicate with each other by sharing items specified in interfaces. Interfaces are named environments that may contain both syntax bindings and value bindings. They also proposed a syntactic extension facility in the context of modules based on syntactic environments <ref> [4] </ref>. However, they did not address the problem of fitting their system into Scheme's interactive programming style. Standard ML is a statically scoped functional programming language with a secure polymorphic type system [29]. However, its type system limits its flexibility as an interactive language. <p> This traditional macro mechanism seems to be simple and flexible. However, it suffers from two kinds of variable capturing problems which prevents it from being used reliably <ref> [42, 4, 10] </ref>: CHAPTER 4. <p> Bawden and Rees developed syntactic closures, which uses syntactic environments to keep track of the syntactic roles of identifiers <ref> [4] </ref>. Together with Hanson's "alias" facility, syntactic closures can be used to support high level macros [27].
Reference: [5] <author> Bobrow, D., Kahn, K., Kiczales, G., Masinter, L., Stefik, M., and Zdybel, F. CommonLoops: </author> <title> Merging Lisp and object-oriented programming. </title> <booktitle> In Proceedings of OOPSLA'86, Object-Oriented Programming Systems, Languages, and Applications (November 1986), </booktitle> <pages> pp. 17-29. </pages> <note> printed as SIGPLAN Notices, 21(11). </note>
Reference-contexts: Self does not distinguish state from behavior and does not have variables either. Information about an object is stored in slots of the object and is accessed by passing a message to that object. CLOS (Common Lisp Object System) [6] and its ancestors Flavors [53] and Com- monLoops <ref> [5] </ref> are three object systems designed for Common Lisp. CLOS, Flavors and CommonLoops all support generic functions and multiple inheritance. A generic function is defined by methods whose definitions are distributed over a chain of inherited classes. <p> ADDING THE OBJECT SYSTEM 76 not belong to a class and can easily modify its inheritance structure. However, the cost of this simplicity and flexibility is a loss of structure. CLOS, Flavors, Com- monLoops, CommonObjects, and Oaklisp are examples of Lisp-based object-oriented languages supporting the class/instance approach <ref> [39, 53, 5, 63, 47] </ref>. Adams and Rees's proposal and Drescher's proposal for object-oriented programming in Scheme adopt the delegation/prototype approach [2, 18]. Another important feature of object-oriented languages is dynamic lookup of object operations. <p> Hash tables associated with individual generic functions may be referred to as callee caches. Caches may also be associated with each individual call point of a generic function. This technique may be referred to as in-line caching or caller caches <ref> [16, 5] </ref>. In-line caching of method addresses relies on the observation that the locality of type usages in a program is usually high [16]. Some Lisp-based object systems allow generic functions to dispatch on multiple arguments. <p> Some Lisp-based object systems allow generic functions to dispatch on multiple arguments. A common technique for implementing generic functions in these systems is to use different dispatch mechanisms to implement generic functions with a single method, with multiple methods, or dispatch on multiple arguments <ref> [5, 41, 19] </ref>. Implementation The implementation of generic functions is based on the observation that any generic function is either chained or unchained: 1. A chained generic function has all of its methods defined in classes that form a class chain. CHAPTER 5. ADDING THE OBJECT SYSTEM 97 2.
Reference: [6] <author> Bobrow, D. G., DeMichiel, L. G., Gabriel, R. P., Keene, S. E., Kiczales, G., and Moon, D. A. </author> <title> Common Lisp Object System Specification. </title> <journal> SIGPLAN NOTICES 23, </journal> <month> 9 (September </month> <year> 1988), </year> <pages> 1-48. </pages>
Reference-contexts: Self does not distinguish state from behavior and does not have variables either. Information about an object is stored in slots of the object and is accessed by passing a message to that object. CLOS (Common Lisp Object System) <ref> [6] </ref> and its ancestors Flavors [53] and Com- monLoops [5] are three object systems designed for Common Lisp. CLOS, Flavors and CommonLoops all support generic functions and multiple inheritance. A generic function is defined by methods whose definitions are distributed over a chain of inherited classes.
Reference: [7] <author> Borning, A. H., and Ingalls, D. H. H. </author> <title> Multiple inheritance in Smalltalk80. </title> <booktitle> In Proceedings of 1982 AAAI National Conference on Artificial Intelligence (1985), </booktitle> <pages> pp. 234-238. </pages>
Reference-contexts: More advanced object-oriented languages support multiple inheritance, which allows a class to inherit several direct super classes. Multiple inheritance provides more opportunities for code reuse but it is more difficult to implement efficiently <ref> [7, 45] </ref>. The two most common approaches to supporting inheritance in object-oriented languages are the class/instance approach and the delegation/prototype approach [48, 67, 68]. The class/instance approach employs class declarations to specify the behavior of instances. A class may inherit from its superclasses. <p> However, their method can be applied only to statically-typed languages. Borning and Ingalls presented a mechanism of accessing instance state in an implementation of Smalltalk-80 supporting multiple inheritance <ref> [7] </ref>. The mechanism compiles multiple copies for methods of classes that are involved in multiple inheritance with different offsets. Krogdahl describes a slot-access implementation technique for a restricted form of multiple inheritance that does not allow a class to be inherited more than once by a common subclass [45].
Reference: [8] <author> Brooks Jr, F. P. </author> <title> The Mythical Man-Month. </title> <publisher> Addison-Wesley, </publisher> <year> 1982. </year> <note> 127 BIBLIOGRAPHY 128 </note>
Reference-contexts: This feature encourages experimental programming and fast proto- typing which are effective approaches to understanding vaguely defined problems. In addition, interactive programming is a valuable debugging technique and can significantly improve the productivity of programmers <ref> [8] </ref>. Modular programming, however, is best suited for problems whose solutions are understood. Modular programming encourages solving a problem by decomposing the problem into modules. This process requires an understanding of the problem and the structure of its solution.
Reference: [9] <author> Cardelli, L., Donahue, J., Glassman, L., Jordan, M., Kalsow, B., and Nelson, G. </author> <type> Modula-3 report. Tech. Rep. 31, </type> <institution> DEC Systems Research Center, </institution> <year> 1988. </year>
Reference-contexts: Unlike Symmetric Lisp's Kappa form, which is parameterized over individual items in an environment, functors parameterize an environment (structure) over its sub-environments (sub-structures). In addition to module facilities for interactive languages, we also looked at a few conventional modular languages such as CLU [49], Modula-2 [81], Modula-3 <ref> [9] </ref>, and Ada [79]. CLU supports parameterized abstract data types. Modula-2 separates the definition of a module from its implementation, and it requires a one-to-one correspondence between the two components. Modula-3 differs from Modula-2 by allowing an implementation module to be associated with several interface specifications. This CHAPTER 2.
Reference: [10] <editor> Clinger, W., and Rees, J. </editor> <title> Macros that work. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages (January 1991), </booktitle> <pages> pp. 155-162. </pages>
Reference-contexts: This traditional macro mechanism seems to be simple and flexible. However, it suffers from two kinds of variable capturing problems which prevents it from being used reliably <ref> [42, 4, 10] </ref>: CHAPTER 4. <p> Together with Hanson's "alias" facility, syntactic closures can be used to support high level macros [27]. Unifying and extending ideas from hygienic macro expansion and syntactic closures, Clinger and Rees developed an algorithm that runs in linear time and allows the use of a pattern-based language for writing macros <ref> [10] </ref>. Hieb and Dybvig have developed a comprehensive macro system that runs with constant overhead, enforces the hygiene condition with a controlled variable capturing mechanism, and maintains referential transparency for all local macros. [33].
Reference: [11] <author> Connor, R. C. H., Dearle, A., Morrison, R., and Brown, A. L. </author> <title> An object addressing mechanism for statically typed languages with multiple inher-itance. </title> <booktitle> In Proceedings of OOPSLA '89, Object-Oriented Programming Systems, Languages, and Applications (October 1989), </booktitle> <pages> pp. 279-286. </pages> <note> printed as SIGPLAN Notices, 24(10). </note>
Reference-contexts: However, both of the two methods are global optimization techniques and cannot be used for interactive program development. Connor et al. described an object addressing mechanism for statically-typed languages with multiple inheritance <ref> [11] </ref>. Unlike traditional object addressing mechanisms which associate address maps to objects, their approach associates mutable address maps that are associated with variable locations where objects may be assigned. However, their method can be applied only to statically-typed languages.
Reference: [12] <author> Cox, B. </author> <title> Object-Oriented Programming, An Evolutionary Approach. </title> <publisher> Addison Wesley, </publisher> <year> 1987. </year>
Reference-contexts: Object-oriented programming features classes, objects, and inheritance. These features allow existing code to be extended, specialized, or reused for different situations. Object-oriented programs are often written not only for providing solutions of problems but also for adopting the solutions to variants of the problems <ref> [12] </ref>. Many real world applications are developed using the object-oriented paradigm. Examples of these applications include graphical user interfaces, data base systems, visualization systems, and parallel or distributed computing systems.
Reference: [13] <author> Cox, B. J. </author> <title> There is a silver bullet. </title> <journal> Byte (October 1990), </journal> <pages> 209-218. </pages>
Reference-contexts: Actually constructing these applications would provide important feedback on how to improve the functionality of the IMOOP system. The ability to accumulate and reuse existing code is critical to further advances in software engineering technology <ref> [13] </ref>. IMOOP supports both modules and classes and allows them to be mixed in the same program. This feature encourages the construction of libraries of reusable modules and classes. The resulting libraries would be more versatile than libraries for languages that support only object-oriented programming or only modular programming.
Reference: [14] <author> Curtis, P., and Rauen, J. </author> <title> A module system for Scheme. </title> <booktitle> In Conference Record of the 1990 ACM Lisp and Functional Programming (1990). </booktitle>
Reference-contexts: In their system, imported identifiers are bound early in the module definition phase. This requires the module dependency to be acyclic and defeats CHAPTER 2. RELATED WORK 11 possibilities for flexible interaction. Curtis and Rauen recently proposed a module system designed for large scale programming in Scheme <ref> [14] </ref>. In their proposal, a module is an isolated scope which may be nested inside other modules. Modules are anonymous. They communicate with each other by sharing items specified in interfaces. Interfaces are named environments that may contain both syntax bindings and value bindings.
Reference: [15] <author> Dahl, O., Myhrhaug, B., and Nygaard, K. </author> <title> Simula67 Common Base Language, second ed. </title> <institution> Norwegian Computing Center, </institution> <year> 1970. </year>
Reference-contexts: Smalltalk-80 is a programming system integrated with an object-oriented language and an interactive programming environment [26, 25]. The Smalltalk-80 language is based on ideas of Simula-67. These ideas describe the basic concepts of object- oriented programming and are indicated by a few words object, message, class, method, and inheritance <ref> [15, 26] </ref>. An object consists of some private memory and a set of methods. A message is a request for an object to carry out one of its methods. A class describes the implementation of a kind of similar objects.
Reference: [16] <author> Deutsch, L. P., and Schiffman, A. M. </author> <title> Efficient implementation of the Smalltalk-80 system. </title> <booktitle> In Conference Record of the Tenth Annual ACM Symposium on Principles of Programming Languages (1983), </booktitle> <pages> pp. 297-302. </pages>
Reference-contexts: Hash tables associated with individual generic functions may be referred to as callee caches. Caches may also be associated with each individual call point of a generic function. This technique may be referred to as in-line caching or caller caches <ref> [16, 5] </ref>. In-line caching of method addresses relies on the observation that the locality of type usages in a program is usually high [16]. Some Lisp-based object systems allow generic functions to dispatch on multiple arguments. <p> Caches may also be associated with each individual call point of a generic function. This technique may be referred to as in-line caching or caller caches [16, 5]. In-line caching of method addresses relies on the observation that the locality of type usages in a program is usually high <ref> [16] </ref>. Some Lisp-based object systems allow generic functions to dispatch on multiple arguments. A common technique for implementing generic functions in these systems is to use different dispatch mechanisms to implement generic functions with a single method, with multiple methods, or dispatch on multiple arguments [5, 41, 19].
Reference: [17] <author> Dixon, R., Mckee, T., Vaughan, M., and Schweizer, P. </author> <title> A fast method dispatcher for compiled languages with multiple inheritance. </title> <booktitle> In Proceedings of OOPSLA '89, Object-Oriented Programming Systems, Languages, and Applications (October 1989), </booktitle> <pages> pp. 211-214. </pages> <note> printed as SIGPLAN Notices, 24(10). </note>
Reference-contexts: The technique can be used for other object oriented languages with similar features. CHAPTER 5. ADDING THE OBJECT SYSTEM 92 Previous Work Dixon et al. suggested an approach which uses a two dimensional table to store slot offsets <ref> [17] </ref>. Rather than assigning a unique index to each slot name, they use an algorithm that allows different slot names to share the same index. The indices are chosen so that no two slots accessible by the same object have the same index.
Reference: [18] <author> Drescher, G. L. </author> <title> Object Scheme: Object inheritance as fluid binding. </title> <institution> Thinking Machines Corporation, </institution> <year> 1990. </year>
Reference-contexts: Their system does not explicitly support the notion of classes. Multiple inheritance is supported by delegating unsupported messages of an object to its parent objects. In addition, they have developed an efficient implementation technique for method invocation. Dresher's Object Scheme <ref> [18] </ref> uses a generalized fluid binding mechanism to represent objects and to support inheritance. Like Adams and Rees's system, Ob- ject Scheme does not distinguish between classes and instances. This distinction, if needed, can be established by convention. Object Scheme concisely supports object- oriented programming with only four additional primitives. <p> CLOS, Flavors, Com- monLoops, CommonObjects, and Oaklisp are examples of Lisp-based object-oriented languages supporting the class/instance approach [39, 53, 5, 63, 47]. Adams and Rees's proposal and Drescher's proposal for object-oriented programming in Scheme adopt the delegation/prototype approach <ref> [2, 18] </ref>. Another important feature of object-oriented languages is dynamic lookup of object operations. Syntactically, dynamic lookup of operations of an object may be expressed by passing a message to an object or by passing an object to a generic function.
Reference: [19] <author> Dussud, P. H. TICLOS: </author> <title> An implementation of CLOS for the explorer family. </title> <booktitle> In Proceedings of OOPSLA '89, Object-Oriented Programming Systems, Languages, and Applications (October 1989), </booktitle> <pages> pp. 215-220. </pages> <note> printed as SIGPLAN Notices, 24(10). BIBLIOGRAPHY 129 </note>
Reference-contexts: Some Lisp-based object systems allow generic functions to dispatch on multiple arguments. A common technique for implementing generic functions in these systems is to use different dispatch mechanisms to implement generic functions with a single method, with multiple methods, or dispatch on multiple arguments <ref> [5, 41, 19] </ref>. Implementation The implementation of generic functions is based on the observation that any generic function is either chained or unchained: 1. A chained generic function has all of its methods defined in classes that form a class chain. CHAPTER 5. ADDING THE OBJECT SYSTEM 97 2.
Reference: [20] <author> Dybvig, R. K. </author> <title> The Scheme Programming Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: The imp language presents the basic semantic properties of an interactive modular programming system designed for a window-based user interface. The IMP system (Interactive Modular Programming) is an approach to supporting interactive modular programming for the Scheme programming language <ref> [58, 35, 20] </ref>. The IMOOP system (Interactive, Modular, and Object-Oriented Programming) extends IMP with supports for object-oriented programming. The most interesting feature of the IMOOP system is that it allows joint uses of the three paradigms to solve problems. <p> Note that the syntax is further simplified and the with statement is no longer necessary. Chapter 4 The IMP System Chapter 3 discusses semantic foundations for interactive modular programming. This chapter describes the IMP programming system|a practical system designed for interactive modular programming in Scheme <ref> [58, 35, 20] </ref>. IMP is based on Scheme and the imp language. This chapter addresses many practical issues of supporting interactive modular programming in Scheme.
Reference: [21] <author> Dybvig, R. K. </author> <title> Three Implementation Models for Scheme. </title> <type> PhD thesis, </type> <institution> University of North Carolina, Chapel Hill, </institution> <year> 1987. </year>
Reference-contexts: The most interesting part of Figure 21 is the letrec expression, which is used to establish bindings for free variables in m1. The procedure get-box returns a box object (an indirection cell) <ref> [21, 43] </ref> associated with an entry of the private environment. The box is used to reference or to assign free variables that are bound to locally defined private variables. It seems that allocating boxes for private variables is unnecessary, since they are not visible outside the letrec expression.
Reference: [22] <author> Dybvig, R. K., and Hieb, R. </author> <title> Engines from continuations. </title> <journal> Journal of Computer Languages 14, </journal> <volume> 2 (1989), </volume> <pages> 109-123. </pages>
Reference-contexts: In Scheme, continuations can be obtained explicitly, stored in data structures, and later invoked to return to the computation. First-class continuations are particularly useful for implementing coroutines, processes, exception handling mechanisms, and nonblind backtracking <ref> [32, 22, 31, 30] </ref>. The richness of Scheme is supported only by a small number of core syntactic forms. However, Scheme is not confined by the core forms: additional syntactic forms may be defined using syntactic definitions.
Reference: [23] <author> Friedman, D. P., and Felleisen, M. </author> <title> A closer look at export and import statements. </title> <booktitle> Computer Language 11, 1 (1986), </booktitle> <pages> 29-37. </pages>
Reference-contexts: A third area concerns language-centered programming environments. This chapter reviews related work in these areas. 2.1 Modules and Name Space Management Among many concrete proposals we have looked at, Felleisen and Friedman's module proposal is the only module system designed with consideration for interactive programming <ref> [23] </ref>. Interactive languages require late binding for flexible program development. By restricting exported values to procedures, they support various late binding techniques for defining modules and importing items. The ultimate goal is to allow arbitrary load orders for modules and to permit interactive extension and redefinition of bindings in modules.
Reference: [24] <author> Friedman, D. P., Wand, M., and Haynes, C. T. </author> <title> Essentials of Programming Languages. </title> <publisher> MIT Press and McGraw-Hill, </publisher> <year> 1991. </year>
Reference-contexts: THE IMP SYSTEM 40 can allow type errors to be discovered before running the program. However, dynamically typed languages are more flexible and more expressive than statically typed languages. Scheme implementation are required to be properly tail recursive <ref> [24] </ref>. Proper tail recursion allows looping constructs of a language to be implemented with tail- recursive procedures. This feature simplifies Scheme since looping constructs need not be predefined. Scheme supports both functional and imperative programming. <p> THE IMP SYSTEM 41 (define add (lambda (x ) (lambda (y) (+ x y)))) (define add3 (add 3)) (define add5 (add 5)) (add3 3) =) 6 continuation passing style <ref> [24, 65] </ref>. Scheme also supports first-class continuations.
Reference: [25] <author> Goldberg, A. </author> <title> Smalltalk-80 The Interactive Programming Environment. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: Generic packages, however, can only be instantiated statically through declarations. 2.2 Ob ject-Oriented Languages This section reviews a few object-oriented languages. Implementation techniques of object-oriented languages are reviewed in Chapter 5. Smalltalk-80 is a programming system integrated with an object-oriented language and an interactive programming environment <ref> [26, 25] </ref>. The Smalltalk-80 language is based on ideas of Simula-67. These ideas describe the basic concepts of object- oriented programming and are indicated by a few words object, message, class, method, and inheritance [15, 26]. An object consists of some private memory and a set of methods.
Reference: [26] <author> Goldberg, A., and Robson, D. </author> <title> Smalltalk-80 The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: Generic packages, however, can only be instantiated statically through declarations. 2.2 Ob ject-Oriented Languages This section reviews a few object-oriented languages. Implementation techniques of object-oriented languages are reviewed in Chapter 5. Smalltalk-80 is a programming system integrated with an object-oriented language and an interactive programming environment <ref> [26, 25] </ref>. The Smalltalk-80 language is based on ideas of Simula-67. These ideas describe the basic concepts of object- oriented programming and are indicated by a few words object, message, class, method, and inheritance [15, 26]. An object consists of some private memory and a set of methods. <p> Smalltalk-80 is a programming system integrated with an object-oriented language and an interactive programming environment [26, 25]. The Smalltalk-80 language is based on ideas of Simula-67. These ideas describe the basic concepts of object- oriented programming and are indicated by a few words object, message, class, method, and inheritance <ref> [15, 26] </ref>. An object consists of some private memory and a set of methods. A message is a request for an object to carry out one of its methods. A class describes the implementation of a kind of similar objects.
Reference: [27] <author> Hanson, C. </author> <title> A syntactic closures mocro facility. </title> <type> unpublished manuscript. </type>
Reference-contexts: Bawden and Rees developed syntactic closures, which uses syntactic environments to keep track of the syntactic roles of identifiers [4]. Together with Hanson's "alias" facility, syntactic closures can be used to support high level macros <ref> [27] </ref>. Unifying and extending ideas from hygienic macro expansion and syntactic closures, Clinger and Rees developed an algorithm that runs in linear time and allows the use of a pattern-based language for writing macros [10].
Reference: [28] <author> Hanson, D. R. </author> <title> Is block structure necessary? Software Practice and Experience 11 (1981), </title> <type> 853-866. </type>
Reference-contexts: One is Scheme's lack of support for modular programming, and the other is a consistency problem associated with interactive program development in Scheme. 4.2.1 Modular Programming Lexical scoping is the only name-space management mechanism supported by Scheme. The advantages of lexical scoping are <ref> [28, 77] </ref>: 1. The programmer can determine the binding of a variable reference by looking at the static program text. 2. The compiler can determine variables' run-time locations at compile time. CHAPTER 4. <p> #f) (define pop #f) (let ([stack '()]) (set! init (lambda () (set! stack '()))) (set! push (lambda (v ) (set! stack (cons v stack )))) (set! pop (lambda () (let ([v (car stack )]) (set! stack (cdr stack )) v )))) However, lexical scoping also has a number of limitations <ref> [82, 28] </ref>. One of them is that the lexical structure of a program is forced to be tree like, and an other one is that direct communication among variables in different branches of a program tree is impossible.
Reference: [29] <author> Harper, R., Milner, R., and Tofte, M. </author> <title> The definition of Standard ML. </title> <type> Tech. Rep. </type> <institution> ECS-LFCS-89-81, Department of Computer Science, University of Edinburgh, </institution> <year> 1989. </year>
Reference-contexts: They also proposed a syntactic extension facility in the context of modules based on syntactic environments [4]. However, they did not address the problem of fitting their system into Scheme's interactive programming style. Standard ML is a statically scoped functional programming language with a secure polymorphic type system <ref> [29] </ref>. However, its type system limits its flexibility as an interactive language. Modifying the value of an existing top-level binding has no effect on other bindings occurring before the modification. As a result, almost all modifications of a program require that the entire program be reloaded.
Reference: [30] <author> Haynes, C. T. </author> <title> Logic continuations. </title> <booktitle> In Proceedings of the Third International Conference on Logic Programming (July 1986), </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 671-685. </pages>
Reference-contexts: In Scheme, continuations can be obtained explicitly, stored in data structures, and later invoked to return to the computation. First-class continuations are particularly useful for implementing coroutines, processes, exception handling mechanisms, and nonblind backtracking <ref> [32, 22, 31, 30] </ref>. The richness of Scheme is supported only by a small number of core syntactic forms. However, Scheme is not confined by the core forms: additional syntactic forms may be defined using syntactic definitions.
Reference: [31] <author> Haynes, C. T., and Friedman, D. P. </author> <title> Abstracting timed preemption with engines. </title> <journal> Journal of Computer Languages 12, </journal> <volume> 2 (1987), </volume> <pages> 109-121. </pages>
Reference-contexts: In Scheme, continuations can be obtained explicitly, stored in data structures, and later invoked to return to the computation. First-class continuations are particularly useful for implementing coroutines, processes, exception handling mechanisms, and nonblind backtracking <ref> [32, 22, 31, 30] </ref>. The richness of Scheme is supported only by a small number of core syntactic forms. However, Scheme is not confined by the core forms: additional syntactic forms may be defined using syntactic definitions.
Reference: [32] <author> Haynes, C. T., and Friedman, D. P. </author> <title> Embedding continuations in procedural objects. </title> <journal> ACM Transactions on Programming Languages and Systems 9, </journal> <month> 4 (Oct. </month> <year> 1987), </year> <pages> 582-598. </pages>
Reference-contexts: In Scheme, continuations can be obtained explicitly, stored in data structures, and later invoked to return to the computation. First-class continuations are particularly useful for implementing coroutines, processes, exception handling mechanisms, and nonblind backtracking <ref> [32, 22, 31, 30] </ref>. The richness of Scheme is supported only by a small number of core syntactic forms. However, Scheme is not confined by the core forms: additional syntactic forms may be defined using syntactic definitions.
Reference: [33] <author> Hieb, R., and Dybvig, R. K. </author> <title> Syntactic abstraction in Scheme. </title> <type> unpublished manuscript. BIBLIOGRAPHY 130 </type>
Reference-contexts: Hieb and Dybvig have developed a comprehensive macro system that runs with constant overhead, enforces the hygiene condition with a controlled variable capturing mechanism, and maintains referential transparency for all local macros. <ref> [33] </ref>. Using macros in the context of modules introduces a similar kind of capturing problem: A macro defined in a module may introduce variable references or macro calls that can be captured by bindings or macros defined in modules that use the macro. <p> j (with module expression) Imports ::= (fm-all j Selectg . . . ) Select ::= (m-sel fid j (local-id ex-id)g + ) expression ::= (with-var module variable) j hother Scheme expressionsi 4.6.2 Design and Implementation This section presents an example of incorporating Hieb and Dybvig's hygienic macro system in IMP <ref> [33] </ref>. The syntax of IMP extended with support for macros is presented in Figure 27. The syntactic structure of import and import-syntax are the same. A module can import all the macros from imported modules or selectively import specific macros and rename them to resolve name conflicts.
Reference: [34] <author> Hudak, P. </author> <title> Conception, evolution, and application of functional programming languages. </title> <journal> ACM Computing Surveys 21, </journal> <month> 3 (September </month> <year> 1989), </year> <pages> 359-411. </pages>
Reference-contexts: Imperative programming relies on assignments to shared locations to communicate among different parts of a program. Functional programming, however, does not allow assignments; functions communicate only by passing values explicitly. Many researchers have argued that functional programs are more concise and higher level <ref> [34] </ref>. However, in many situations, assignments are more intuitive, and forbidding their use can significantly complicate solutions of many problems. One of the most important features of Scheme is that it treats procedures as first-class objects.
Reference: [35] <author> IEEE. </author> <title> IEEE Standard for the Scheme Programming Language. </title> <publisher> Institute of Electrical and Electronic Engineers, Inc., </publisher> <address> New York, NY, </address> <year> 1991. </year> <note> IEEE Std 11781990. </note>
Reference-contexts: The imp language presents the basic semantic properties of an interactive modular programming system designed for a window-based user interface. The IMP system (Interactive Modular Programming) is an approach to supporting interactive modular programming for the Scheme programming language <ref> [58, 35, 20] </ref>. The IMOOP system (Interactive, Modular, and Object-Oriented Programming) extends IMP with supports for object-oriented programming. The most interesting feature of the IMOOP system is that it allows joint uses of the three paradigms to solve problems. <p> Note that the syntax is further simplified and the with statement is no longer necessary. Chapter 4 The IMP System Chapter 3 discusses semantic foundations for interactive modular programming. This chapter describes the IMP programming system|a practical system designed for interactive modular programming in Scheme <ref> [58, 35, 20] </ref>. IMP is based on Scheme and the imp language. This chapter addresses many practical issues of supporting interactive modular programming in Scheme. <p> THE IMP SYSTEM 37 4.1 An Overview of Scheme Scheme, a dialect of Lisp, was designed in 1975 at MIT by Guy Lewis Steel Jr. and Gerald Jay Sussman [72]. Scheme is a small language that has a simple syntax and an exceptionally clear semantics <ref> [58, 35] </ref>. 4.1.1 Syntax The notation . . . denotes zero or more occurrences of the preceding form. Scheme supports many data types. A few examples of these data types include booleans, numbers, characters, symbols, lists, vectors, and procedures.
Reference: [36] <author> Jagannathan, S. </author> <title> A Programming Language Supporting First-Class Parallel Environments. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: Symbols defined as external in a package can be exported. Various mechanisms are available to access or to import exported symbols. However, packages are low level implementation concepts and provide much weaker expressive power for name space management than environments. Symmetric Lisp <ref> [36] </ref> is a programming language based on environments. The map expression constructs an environment containing zero or more regions. Expressions CHAPTER 2. RELATED WORK 10 associated with the regions are evaluated in parallel.
Reference: [37] <author> Kamin, S. </author> <title> Inheritance in Smalltalk-80: a denatational definition. </title> <booktitle> In ACM Symposium on Principles of Programming Languages (1988), </booktitle> <pages> pp. 80-87. </pages>
Reference-contexts: ADDING THE OBJECT SYSTEM 85 (let ([p1 (make-instance point (x 3) (y 4))] [p2 (make-instance manpoint (x 1) (y 5))]) (closer p1 p2 )) the point class and the manpoint class using two public procedures <ref> [37] </ref>. The distance procedure defined in the point class is exported to the manpoint class using the name point-distance, and the distance procedure defined in the manpoint class is exported to the point class using the name man-distance.
Reference: [38] <author> Kaplan, S., Carroll, A. M., Love, C., and LaLiberte, D. M. </author> <title> Epoch GNU Emacs for the X Window System. </title> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <year> 1990. </year>
Reference-contexts: For some applications, the programmer may be required to manually fix the generated code. 4.5.4 User Interface A prototype IMP user interface has been constructed by interfacing the Epoch editor (a multi-window variant of the GNU Emacs editor) and the IMP system <ref> [38] </ref>. The IMP system runs as an inferior process within Emacs and implements commands for manipulating modules, files, and projects. New statements can be added to modules displayed in Emacs windows and can be sent and evaluated in IMP's read-eval-print- loop directly. The IMP system also implements the refresh-binding command.
Reference: [39] <author> Keene, S. E. </author> <title> Object-Oriented Programming in Common Lisp. </title> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: ADDING THE OBJECT SYSTEM 76 not belong to a class and can easily modify its inheritance structure. However, the cost of this simplicity and flexibility is a loss of structure. CLOS, Flavors, Com- monLoops, CommonObjects, and Oaklisp are examples of Lisp-based object-oriented languages supporting the class/instance approach <ref> [39, 53, 5, 63, 47] </ref>. Adams and Rees's proposal and Drescher's proposal for object-oriented programming in Scheme adopt the delegation/prototype approach [2, 18]. Another important feature of object-oriented languages is dynamic lookup of object operations.
Reference: [40] <author> Kernighan, B. W., and Ritchie, D. M. </author> <title> The C Programming Language. </title> <publisher> Prentice Hall, </publisher> <address> Englewood, New Jersey, </address> <year> 1988. </year> <note> The second edition. </note>
Reference-contexts: Smalltalk-80 is a uniformly object-oriented system. Objects are used to represents numbers, character strings, file directories, and even computer programs like compilers and text editors. Features of the Smalltalk-80 programming environment are presented in the next section. C++ is an object-oriented extension of the C programming language <ref> [40, 70, 71] </ref>. C++ requires virtual functions to be declared explicitly for messages that have more than one method and provides a visibility control mechanism for variables and methods defined in a class. Private variables or methods are only accessible to functions or friend functions of the class.
Reference: [41] <author> Kiczales, G., and Rodriguez, L. </author> <title> Efficient method dispatch in PCL. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming (1990), </booktitle> <pages> pp. 99-105. </pages>
Reference-contexts: A global hash table that stores commonly used methods may be shared by all the generic functions in a program. Hash tables may also be associated with individual classes or individual generic functions <ref> [53, 41] </ref>. More advanced implementations uses special techniques to control the size and density of these hash tables [41]. In [60], Rose gives a detailed analysis about implementing dynamic lookup on stock hardware using assembly code. Hash tables associated with individual generic functions may be referred to as callee caches. <p> Hash tables may also be associated with individual classes or individual generic functions [53, 41]. More advanced implementations uses special techniques to control the size and density of these hash tables <ref> [41] </ref>. In [60], Rose gives a detailed analysis about implementing dynamic lookup on stock hardware using assembly code. Hash tables associated with individual generic functions may be referred to as callee caches. Caches may also be associated with each individual call point of a generic function. <p> Some Lisp-based object systems allow generic functions to dispatch on multiple arguments. A common technique for implementing generic functions in these systems is to use different dispatch mechanisms to implement generic functions with a single method, with multiple methods, or dispatch on multiple arguments <ref> [5, 41, 19] </ref>. Implementation The implementation of generic functions is based on the observation that any generic function is either chained or unchained: 1. A chained generic function has all of its methods defined in classes that form a class chain. CHAPTER 5. ADDING THE OBJECT SYSTEM 97 2.
Reference: [42] <author> Kohlbecker, E. E., Friedman, D. P., Felleisen, M., and Duba, B. </author> <title> Hygienic macro expansion. </title> <booktitle> In Proceedings of the 1986 ACM Symposium on LISP and Functional Programming (Aug. </booktitle> <year> 1986), </year> <pages> pp. 151-161. </pages>
Reference-contexts: This traditional macro mechanism seems to be simple and flexible. However, it suffers from two kinds of variable capturing problems which prevents it from being used reliably <ref> [42, 4, 10] </ref>: CHAPTER 4. <p> Recently, various techniques have been developed that solve these problems. Kohl- becker, et al., invented hygienic macro expansion, which uses "time-stamps" to distinguish between macro-generated identifiers and program identifiers <ref> [42] </ref>. However, CHAPTER 4.
Reference: [43] <author> Kranz, D., Kelsey, R., Rees, J., Hudak, P., Philbin, J., and Adams, N. </author> <title> Orbit: An optimizing compiler for Scheme. </title> <booktitle> Proceedings of the SIGPLAN '86 Symposium on Compiler Construction (1986), </booktitle> <pages> 219-233. </pages> <note> published as SIGPLAN Notices 21, </note> <month> 7 (July </month> <year> 1986). </year>
Reference-contexts: The most interesting part of Figure 21 is the letrec expression, which is used to establish bindings for free variables in m1. The procedure get-box returns a box object (an indirection cell) <ref> [21, 43] </ref> associated with an entry of the private environment. The box is used to reference or to assign free variables that are bound to locally defined private variables. It seems that allocating boxes for private variables is unnecessary, since they are not visible outside the letrec expression.
Reference: [44] <author> Krasner, G., Ed. </author> <title> Smalltalk-80: Bits of History, Words of Advice. </title> <address> AddisonWesley, Reading, MA., </address> <year> 1983. </year>
Reference-contexts: This section presents a simple approach to implementing generic functions. CHAPTER 5. ADDING THE OBJECT SYSTEM 96 Previous Work The most common approach to implementing dynamic lookup is using method caches <ref> [44] </ref>. Method caches store commonly used methods in a program. Existing implementations of object-oriented programming systems differ on the data structures used in implementing method caches and the places where method caches are used.
Reference: [45] <author> Krogdahl, S. </author> <title> Multiple inheritance in Simula-like languages. BIT 25 (1985), </title> <type> 318-326. BIBLIOGRAPHY 131 </type>
Reference-contexts: More advanced object-oriented languages support multiple inheritance, which allows a class to inherit several direct super classes. Multiple inheritance provides more opportunities for code reuse but it is more difficult to implement efficiently <ref> [7, 45] </ref>. The two most common approaches to supporting inheritance in object-oriented languages are the class/instance approach and the delegation/prototype approach [48, 67, 68]. The class/instance approach employs class declarations to specify the behavior of instances. A class may inherit from its superclasses. <p> The mechanism compiles multiple copies for methods of classes that are involved in multiple inheritance with different offsets. Krogdahl describes a slot-access implementation technique for a restricted form of multiple inheritance that does not allow a class to be inherited more than once by a common subclass <ref> [45] </ref>. His technique computes offsets between "reference points" of slots of different classes and uses the offsets to compute slot addresses for instances of different classes. Most other object-oriented systems use a combination of table look up and indirections to determine the addresses of slots.
Reference: [46] <author> Lamping, J. O. </author> <title> A unified system of parameterization for programming lan-guages. </title> <booktitle> In 1988 ACM Conference On Lisp and Functional Programming (July 1988), </booktitle> <pages> pp. 316-326. </pages>
Reference-contexts: This abstraction, when applied, generates a map with regions specified by the kappa expression. Symmetric Lisp explores many possible uses of environments in a parallel programming language. Instead of the single environment domain used in Symmetric Lisp, Lamping's model of transparent parameterization <ref> [46] </ref> uses two environment domains to determine the meaning of an expression.
Reference: [47] <author> Lang, K. J., and Pearlmutter, B. A. Oaklisp: </author> <title> An object-oriented Scheme with first class types. </title> <booktitle> In Proceedings of OOPSLA '86, Object-Oriented Programming Systems, Languages, and Applications (November 1986), </booktitle> <pages> pp. 30-37. </pages> <note> printed as SIGPLAN Notices, 21(11). </note>
Reference-contexts: However, it is difficult to identify instance variables and methods of an Object Scheme object, since this information is not directly specified and must be inferred with bindings in the surrounding lexical environment and their side effects. This drawback makes Object Scheme code difficult to read. Oaklisp <ref> [47] </ref> supports object-oriented programming by extending Scheme's function call semantics with support for generic functions and allowing the user to define first-class types. <p> ADDING THE OBJECT SYSTEM 76 not belong to a class and can easily modify its inheritance structure. However, the cost of this simplicity and flexibility is a loss of structure. CLOS, Flavors, Com- monLoops, CommonObjects, and Oaklisp are examples of Lisp-based object-oriented languages supporting the class/instance approach <ref> [39, 53, 5, 63, 47] </ref>. Adams and Rees's proposal and Drescher's proposal for object-oriented programming in Scheme adopt the delegation/prototype approach [2, 18]. Another important feature of object-oriented languages is dynamic lookup of object operations.
Reference: [48] <author> Lieberman, H. </author> <title> Using prototypical objects to implement shared behavior in object-oriented systems. </title> <booktitle> In Proceedings of OOPSLA '86, Object-Oriented Programming Systems, Languages, and Applications (November 1986), </booktitle> <pages> pp. 214-223. </pages> <note> printed as SIGPLAN Notices, 21(11). </note>
Reference-contexts: Multiple inheritance provides more opportunities for code reuse but it is more difficult to implement efficiently [7, 45]. The two most common approaches to supporting inheritance in object-oriented languages are the class/instance approach and the delegation/prototype approach <ref> [48, 67, 68] </ref>. The class/instance approach employs class declarations to specify the behavior of instances. A class may inherit from its superclasses. It may also add new instance variables or methods to extend or specialize the inherited behaviors.
Reference: [49] <author> Liskov, B., Snyder, A., Atkinson, R., and Schaffert, C. </author> <title> Abstraction mechanisms in CLU. </title> <journal> Communications of the ACM 20, </journal> <volume> 8 (1977), </volume> <pages> 564-576. </pages>
Reference-contexts: Functors are parameterized structures. Unlike Symmetric Lisp's Kappa form, which is parameterized over individual items in an environment, functors parameterize an environment (structure) over its sub-environments (sub-structures). In addition to module facilities for interactive languages, we also looked at a few conventional modular languages such as CLU <ref> [49] </ref>, Modula-2 [81], Modula-3 [9], and Ada [79]. CLU supports parameterized abstract data types. Modula-2 separates the definition of a module from its implementation, and it requires a one-to-one correspondence between the two components. Modula-3 differs from Modula-2 by allowing an implementation module to be associated with several interface specifications.
Reference: [50] <author> MacQueen, D. </author> <title> Modules for Standard ML. </title> <booktitle> In Conference Record of the 1984 ACM Symposium on Lisp and Functional Programming (1984), </booktitle> <pages> pp. 198-207. </pages>
Reference-contexts: As a result, almost all modifications of a program require that the entire program be reloaded. The module extension to Standard ML associates each module with two environments: a signature containing the interface of the module, and a structure containing the implementation of the module <ref> [50] </ref>. The types and values of a structure can be imported as a whole structure or as individual items. Functors are parameterized structures. Unlike Symmetric Lisp's Kappa form, which is parameterized over individual items in an environment, functors parameterize an environment (structure) over its sub-environments (sub-structures).
Reference: [51] <author> Meyer, B. </author> <title> Eiffel: A language and environment for software engineering. </title> <journal> The Journal of Systems and Software (1988). </journal>
Reference-contexts: Unfortunately, the boundaries between the layers of abstraction are mostly invisible, with no formal definition. Both customers and system developers have difficulty choosing a level of abstraction for a problem and staying in its boundaries. Eiffel is a language and environment for software development <ref> [51] </ref>. The language supports static type checking, object-oriented programming, exception handling, and systematic use of assertions and invariants. The type system is integrated with the CHAPTER 2. RELATED WORK 16 object system by using the inheritance relation to represent the subtype relation.
Reference: [52] <author> Meyer, B. </author> <title> Eiffel: The language. </title> <type> Tech. rep., </type> <institution> Interactive Software Engineering Inc., </institution> <year> 1989. </year>
Reference-contexts: These approaches are not completely satisfactory, since slots with the same name may mean the same thing sometimes and may mean different things at other times. Eiffel uses renaming to resolve conflicts among inherited features <ref> [52] </ref>. The utilities of our module system provide a similar capability. IMOOP treats inherited slots with the same name as separate slots or allows the slots to be combined to form a single slot. Suppose two classes have been defined for an application.
Reference: [53] <author> Moon, D. A. </author> <title> Object-oriented programming with Flavors. </title> <booktitle> In Proceedings of OOPSLA '86, Object-Oriented Programming Systems, Languages, and Applications (November 1986), </booktitle> <pages> pp. 1-8. </pages> <note> printed as SIGPLAN Notices, 21(11). </note>
Reference-contexts: Self does not distinguish state from behavior and does not have variables either. Information about an object is stored in slots of the object and is accessed by passing a message to that object. CLOS (Common Lisp Object System) [6] and its ancestors Flavors <ref> [53] </ref> and Com- monLoops [5] are three object systems designed for Common Lisp. CLOS, Flavors and CommonLoops all support generic functions and multiple inheritance. A generic function is defined by methods whose definitions are distributed over a chain of inherited classes. <p> ADDING THE OBJECT SYSTEM 76 not belong to a class and can easily modify its inheritance structure. However, the cost of this simplicity and flexibility is a loss of structure. CLOS, Flavors, Com- monLoops, CommonObjects, and Oaklisp are examples of Lisp-based object-oriented languages supporting the class/instance approach <ref> [39, 53, 5, 63, 47] </ref>. Adams and Rees's proposal and Drescher's proposal for object-oriented programming in Scheme adopt the delegation/prototype approach [2, 18]. Another important feature of object-oriented languages is dynamic lookup of object operations. <p> Most other object-oriented systems use a combination of table look up and indirections to determine the addresses of slots. Flavors stores slot offsets in mapping tables CHAPTER 5. ADDING THE OBJECT SYSTEM 93 that are associated with each generic functions <ref> [53] </ref>. Rose gave a detailed analysis about the trade-offs on execution speed, program size, and system flexibility using assembly code with different table lookup strategies using static or relocated tables, large or small table sizes, and larger or small table offsets [60]. <p> A global hash table that stores commonly used methods may be shared by all the generic functions in a program. Hash tables may also be associated with individual classes or individual generic functions <ref> [53, 41] </ref>. More advanced implementations uses special techniques to control the size and density of these hash tables [41]. In [60], Rose gives a detailed analysis about implementing dynamic lookup on stock hardware using assembly code. Hash tables associated with individual generic functions may be referred to as callee caches.
Reference: [54] <author> Parnas, D. L. </author> <title> On the criteria to be used in decomposing systems into modules. </title> <booktitle> Communications of the ACM (December 1972), </booktitle> <pages> 1053-1058. </pages>
Reference-contexts: A user program is able to access any routines available in the system. The benefit of the open system approach is enhanced software reusability and extensibility. The drawback of the open system approach is that it violates the information hiding principle <ref> [54] </ref>. The designers of Genera admit this: The system software has been designed with calling interfaces at various levels of abstraction. Unfortunately, the boundaries between the layers of abstraction are mostly invisible, with no formal definition. <p> The first one is to support the information hiding principle. The information hiding principle states that a module should provide to its users all the required information to use the module, and nothing more <ref> [54] </ref>. The second one is to facilitate the design and organization of programs. A program should be allowed to be decomposed into modules with each 18 CHAPTER 3. SEMANTIC FOUNDATIONS 19 module providing services to and receiving services from other modules.
Reference: [55] <author> Pugh, W., and Weddell, G. </author> <title> Two-directional record layout for multiple inheritance. </title> <booktitle> In ACM SIGPLAN '90 Conference on Programming Language Design and Implementation (June 1990), </booktitle> <pages> pp. 85-91. </pages> <note> printed as SIGPLAN Notices, 25(6). </note>
Reference-contexts: Since slot indices are not unique, the size of the table is reduced. Pugh and Weddell developed a two-directional record (instance) layout method that allows a fixed offset to be assigned to each field (slot) at compile time with low space overhead <ref> [55] </ref>. However, both of the two methods are global optimization techniques and cannot be used for interactive program development. Connor et al. described an object addressing mechanism for statically-typed languages with multiple inheritance [11].
Reference: [56] <author> Queinnec, C., and Padget, J. </author> <title> A detailed summary of a deterministic model of modules and macros for Lisp. </title> <type> Tech. Rep. </type> <institution> LIX/RR/90/01, Ecole Polytechnique, BIBLIOGRAPHY 132 Laboratoire d'Informatique, </institution> <address> 91128 Palaiseau Cedex (France), </address> <month> July-December </month> <year> 1989. </year>
Reference-contexts: Lamping's model is able to express a variety of language constructs, including module linkage. However, his model may be too dynamic to implement efficiently. Queinnec and Padget have designed a module system for Lisp <ref> [56] </ref>. The design goals of their system are to support separate compilation and to control the visibility of resources. A module is available for use after it is defined and loaded.
Reference: [57] <author> Reddy, U. </author> <title> Objects as closures: Abstract semantics of object-oriented languages. </title> <booktitle> In 1988 ACM Conference on Lisp and Functional Programming (July 1988), </booktitle> <pages> pp. 289-297. </pages>
Reference-contexts: A class describes the implementation of a kind of similar objects. Smalltalk-80 supports single inheritance, meaning that a class can inherit variables and method from at most one direct super class. A simple denotational definition of its inheritance mechanism based on the concept of closure can be found in <ref> [57] </ref>. Smalltalk-80 is a uniformly object-oriented system. Objects are used to represents numbers, character strings, file directories, and even computer programs like compilers and text editors. Features of the Smalltalk-80 programming environment are presented in the next section.
Reference: [58] <editor> Rees, J., and Clinger, W. (Editors), </editor> <title> Revised 4 report on the algorithmic language Scheme. Lisp Pointers 4, </title> <booktitle> 3 (1991), </booktitle> <pages> 1-55. </pages>
Reference-contexts: The imp language presents the basic semantic properties of an interactive modular programming system designed for a window-based user interface. The IMP system (Interactive Modular Programming) is an approach to supporting interactive modular programming for the Scheme programming language <ref> [58, 35, 20] </ref>. The IMOOP system (Interactive, Modular, and Object-Oriented Programming) extends IMP with supports for object-oriented programming. The most interesting feature of the IMOOP system is that it allows joint uses of the three paradigms to solve problems. <p> Note that the syntax is further simplified and the with statement is no longer necessary. Chapter 4 The IMP System Chapter 3 discusses semantic foundations for interactive modular programming. This chapter describes the IMP programming system|a practical system designed for interactive modular programming in Scheme <ref> [58, 35, 20] </ref>. IMP is based on Scheme and the imp language. This chapter addresses many practical issues of supporting interactive modular programming in Scheme. <p> THE IMP SYSTEM 37 4.1 An Overview of Scheme Scheme, a dialect of Lisp, was designed in 1975 at MIT by Guy Lewis Steel Jr. and Gerald Jay Sussman [72]. Scheme is a small language that has a simple syntax and an exceptionally clear semantics <ref> [58, 35] </ref>. 4.1.1 Syntax The notation . . . denotes zero or more occurrences of the preceding form. Scheme supports many data types. A few examples of these data types include booleans, numbers, characters, symbols, lists, vectors, and procedures. <p> The notation fx j yg indicates the appearance of either x or y but not both. The + indicates one or more occurrences of the preceding form. The syntactic categories Ide and Exp are as defined in the Revised 4 Report <ref> [58] </ref>. The LExp are Scheme lambda expressions. This module system extends imp by allowing the import statement to specify how name conflicts should be resolved among imported variables. <p> Section B.1.1 and B.1.2 are organized into entries. Each entry describes a language feature which is either a syntactic construct or a built-in procedure. The format of an entry follows the Revised 4 Report with the following modifications <ref> [58] </ref>: * The header line of an entry starts with a bold-faced syntactic keyword or a procedure name. * The rest of the header line is formatted in an italic type style. * Meta names module, class, variable, slot , and instance-variable represent Scheme identifiers, expression indicates IMOOP expressions which also <p> The selected variables may be assigned local names that may be different from their original names. The scheme module is also imported implicitly. Public variables of the scheme module includes at least all the essential procedures defined in the Revised 4 Report <ref> [58] </ref>. Imports is interpreted dynamically using the public environments of m-alls and m-sels when determining locations of variables in the module. Name conflicts among variables in imported modules are resolved from left to right (see Section B.1.3).
Reference: [59] <author> Rodr iguez, R. G., Duba, B. F., and Felleisen, M. </author> <title> Can you trust your read-eval-print loop? unpublished manuscript. </title>
Reference-contexts: As a result, the programmer cannot completely rely on the static program text to understand a program's behavior <ref> [59] </ref>. The example in Figure 15 illustrates this problem: The call (fun 3 4) right after the definition of fun returns (7 . 7).
Reference: [60] <author> Rose, J. R. </author> <title> Fast dispatch mechanisms for stock hardware. </title> <booktitle> In Proceedings of OOPSLA '88, Object-Oriented Programming Systems, Languages, and Applications (November 1988), </booktitle> <pages> pp. 27-35. </pages> <note> printed as SIGPLAN Notices, 23(11). </note>
Reference-contexts: Rose gave a detailed analysis about the trade-offs on execution speed, program size, and system flexibility using assembly code with different table lookup strategies using static or relocated tables, large or small table sizes, and larger or small table offsets <ref> [60] </ref>. Implementation An instance is implemented as a tagged vector of slots. The tag determines the type of the instance, i.e., the encoded class index (see below). The implementation of instance access uses offsets stored in mapping tables. <p> Hash tables may also be associated with individual classes or individual generic functions [53, 41]. More advanced implementations uses special techniques to control the size and density of these hash tables [41]. In <ref> [60] </ref>, Rose gives a detailed analysis about implementing dynamic lookup on stock hardware using assembly code. Hash tables associated with individual generic functions may be referred to as callee caches. Caches may also be associated with each individual call point of a generic function.
Reference: [61] <author> Schaffert, C., Cooper, T., Bullis, B., Kilian, M., and Wilpolt, C. </author> <title> An introduction to Trellis/Owl. </title> <booktitle> In Proceedings of OOPSLA '86, Object-Oriented Programming Systems, Languages, and Applications (November 1986), </booktitle> <pages> pp. 9-16. </pages> <note> printed as SIGPLAN Notices, 21(11). </note>
Reference-contexts: A method defined in a superclass is automatically inherited by its subclasses. Just as object-oriented languages supporting multiple inheritance must resolve conflicts among inherited slots, they must also resolve conflicts among inherited operations. Several approaches may be used to resolve conflicts of inherited operations. Eiffel and Trellis/Owl <ref> [61] </ref> require the programmer to explicitly resolve the conflict by renaming or redefining the operation in the child class. CLOS, Flavors, and CommonLoops interpret the inheritance graph as a linear chain which can be used with method combinations to resolve conflicts.
Reference: [62] <author> Schmidt, D. A. </author> <title> Denotational Semantics. </title> <publisher> Allyn and Bacon, Inc., </publisher> <address> Boston, MA, </address> <year> 1986. </year>
Reference-contexts: Denotational semantics is an important tool for the design and implementation of programming language systems [69]. The denotational semantics of a programming language provides a formal and precise definition of the language and is useful for its users and its implementors <ref> [62, 76] </ref>. However, complete specifications of realistic programming languages in denotational semantics are often difficult to read. To overcome this difficulty, Chapter 3 presents the denotational semantics of a toy language designed to show the most interesting semantic properties of interactive modular programming. <p> The design of imp is intended to map to the multi-window user interface model for interactive modular programming. The first section of this chapter describes basic requirements for interactive modular programming. Section 2 gives an overview of the -calculus and its denotational semantics <ref> [69, 62] </ref>. Sections 3 and 4 illustrate the semantics and present programming examples demonstrating the flexibility of the imp language. 3.1 Semantic Requirements Modular programming provides at least two important functionalities. The first one is to support the information hiding principle.
Reference: [63] <author> Snyder, A. CommonObjects: </author> <title> An overview. </title> <journal> SIGPLAN Notices 21, </journal> <month> 10 (October </month> <year> 1986), </year> <pages> 19-28. </pages>
Reference-contexts: Meta-classes specifies the behaviors of classes and allows the user to extend the object system itself. Both CLOS and Flavors support interactive programming. Methods can be defined independently from their classes. Both classes and methods can be modified interactively. CommonObjects is another object system designed for Common Lisp <ref> [63] </ref>. Com- monObjects differs most significantly from the previous three systems in its emphasis on encapsulation. Most object systems allow objects to be encapsulated with interfaces that define operations on objects. <p> ADDING THE OBJECT SYSTEM 76 not belong to a class and can easily modify its inheritance structure. However, the cost of this simplicity and flexibility is a loss of structure. CLOS, Flavors, Com- monLoops, CommonObjects, and Oaklisp are examples of Lisp-based object-oriented languages supporting the class/instance approach <ref> [39, 53, 5, 63, 47] </ref>. Adams and Rees's proposal and Drescher's proposal for object-oriented programming in Scheme adopt the delegation/prototype approach [2, 18]. Another important feature of object-oriented languages is dynamic lookup of object operations.
Reference: [64] <author> Snyder, A. </author> <title> Encapsulation and inheritance in object-oriented programming lan-guages. </title> <booktitle> In Proceedings of OOPSLA '86, Object-Oriented Programming Systems, Languages, and Applications (November 1986), </booktitle> <pages> pp. 38-45. </pages> <note> printed as SIGPLAN Notices, 21(11). </note>
Reference-contexts: These utilities allow a flexible and efficient slot access mechanism without compromising encapsulation, simplify the treatment of generic functions, support flexible handling of conflicts resulting from multiple inheritance, and permit tight integration of modular programming and object-oriented programming. Encapsulation refers to the degree of independence among different classes <ref> [64] </ref>. CHAPTER 5. ADDING THE OBJECT SYSTEM 77 Most Lisp-based object-oriented programming systems provide weak encapsulation by allowing unrestricted access to an object's state. As a result, the object's internal representation cannot be safely modified without affecting other classes. <p> This restriction also permits strong encapsulation since a class can freely change the internal representation of its instances without affecting client code so long as the changes maintain the external interface of the class <ref> [64] </ref>. However, slot reference and modification can still be provided via exported procedures. The ability to export/import procedures increases the flexibility of slot access without compromising encapsulation. <p> POOL separates subtyping from inheritance to allow flexible treatment of multiple inheritance for strongly typed languages [3]. A detailed discussion about resolving conflicts of multiple inheritance can be found in <ref> [64] </ref>. We adopt a weaker version of the Eiffel and Trellis/Owl's approach. A warning message is given if a class inherits from more than one direct superclass that define CHAPTER 5.
Reference: [65] <author> Springer, G., and Friedman, D. P. </author> <title> Scheme and the Art of Programming. </title> <publisher> MIT Press and McGraw-Hill, </publisher> <year> 1989. </year>
Reference-contexts: This property allows the use of first-class procedures to represent objects with local state that interface with the rest of a program through message passing. First class procedures also support a programming technique known as currying <ref> [65] </ref>. Curry- ing allows a function to be applied in separate steps with each step remembering the results of previous steps and returning a new first-class procedure with the remembered information. Figure 13 gives an example of using the currying technique. <p> THE IMP SYSTEM 41 (define add (lambda (x ) (lambda (y) (+ x y)))) (define add3 (add 3)) (define add5 (add 5)) (add3 3) =) 6 continuation passing style <ref> [24, 65] </ref>. Scheme also supports first-class continuations.
Reference: [66] <author> Steele Jr, G. L. </author> <title> Common Lisp. </title> <publisher> Digital Press, </publisher> <year> 1990. </year> <note> Second Edition. </note>
Reference-contexts: It is unclear how first class environments can be used to support recursive modules or to allow referencing a first class environment before it is created. Common Lisp's <ref> [66] </ref> package system uses symbol tables to represent modules. Symbols defined as external in a package can be exported. Various mechanisms are available to access or to import exported symbols. However, packages are low level implementation concepts and provide much weaker expressive power for name space management than environments.
Reference: [67] <author> Stein, L. A. </author> <title> Delegation is inheritance. </title> <booktitle> In Proceedings of OOPSLA '87, ObjectOriented Programming Systems, Languages, and Applications (December 1987), </booktitle> <pages> pp. 138-146. </pages> <note> printed as SIGPLAN Notices, 22(12). BIBLIOGRAPHY 133 </note>
Reference-contexts: Multiple inheritance provides more opportunities for code reuse but it is more difficult to implement efficiently [7, 45]. The two most common approaches to supporting inheritance in object-oriented languages are the class/instance approach and the delegation/prototype approach <ref> [48, 67, 68] </ref>. The class/instance approach employs class declarations to specify the behavior of instances. A class may inherit from its superclasses. It may also add new instance variables or methods to extend or specialize the inherited behaviors.
Reference: [68] <author> Stein, L. A., Liberman, H., and Ungar, D. </author> <title> A shared view of sharing: The Treaty of Orlando. In Object-Oriented Concepts, Databases, and Applications, </title> <editor> W. Kim and F. H. Lochovsky, Eds. </editor> <publisher> ACM Press, </publisher> <year> 1989, </year> <journal> ch. </journal> <volume> 3, </volume> <pages> pp. 31-48. </pages>
Reference-contexts: Supporting separate compilation and project compilation with foreign references are also straightforward. Chapter 5 Adding The Ob ject System Object-oriented programming offers a natural way to model the variable nature of many real world applications <ref> [68] </ref>. The most important feature of an object oriented programming system is that it allows programs to be written in a way that is flexible and extensible. As a result, object-oriented programs are easier to reuse, maintain, and extend. <p> Multiple inheritance provides more opportunities for code reuse but it is more difficult to implement efficiently [7, 45]. The two most common approaches to supporting inheritance in object-oriented languages are the class/instance approach and the delegation/prototype approach <ref> [48, 67, 68] </ref>. The class/instance approach employs class declarations to specify the behavior of instances. A class may inherit from its superclasses. It may also add new instance variables or methods to extend or specialize the inherited behaviors.
Reference: [69] <author> Stoy, J. E. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1977. </year>
Reference-contexts: Programming environments are also often designed to facilitate interactive, modular, or object-oriented program development. Chapter 2 reviews previous work in name space management, modular programming languages, object- oriented programming languages, and language-centered programming environments. Denotational semantics is an important tool for the design and implementation of programming language systems <ref> [69] </ref>. The denotational semantics of a programming language provides a formal and precise definition of the language and is useful for its users and its implementors [62, 76]. However, complete specifications of realistic programming languages in denotational semantics are often difficult to read. <p> The design of imp is intended to map to the multi-window user interface model for interactive modular programming. The first section of this chapter describes basic requirements for interactive modular programming. Section 2 gives an overview of the -calculus and its denotational semantics <ref> [69, 62] </ref>. Sections 3 and 4 illustrate the semantics and present programming examples demonstrating the flexibility of the imp language. 3.1 Semantic Requirements Modular programming provides at least two important functionalities. The first one is to support the information hiding principle. <p> CHAPTER 3. SEMANTIC FOUNDATIONS 20 3.2 The -Calculus and its Semantics The -calculus is a language defined with notations and conversion rules that allow the evaluation of lambda expressions denoting first-class anonymous functions <ref> [69] </ref>. The syntax of the -calculus is presented in Figure 2. The -calculus conversion/reduction rules allow -expressions to be reduced or "evaluated" to simpler -expressions. The fi-reduction rule corresponds intuitively to applying a function to its arguments. <p> However, x is bound and y is free in (lambda (x ) (x y)). For the complete expression, x occurs both free (in the rightmost occurrence) and bound (in the remaining two occurrences) <ref> [69] </ref>. Note that in an expression an identifier can be both free and bound. However, each occurrence of an identifier is either free or bound but not both. <p> The Church-Rosser Theorem guarantees that different reduction sequences produce the same result as long as they terminate <ref> [69] </ref>. The -calculus was originally invented to study the behavior of functions. How- ever, the -calculus by itself is merely a syntactic system defined with transformation rules and does not define semantics. That is, it is unclear what abstract value a -expression denotes [69]. <p> same result as long as they terminate <ref> [69] </ref>. The -calculus was originally invented to study the behavior of functions. How- ever, the -calculus by itself is merely a syntactic system defined with transformation rules and does not define semantics. That is, it is unclear what abstract value a -expression denotes [69]. Fortunately, the techniques of denotational semantics allow the semantics of most programming languages, including the semantics of the -calculus, to be expressed in a formal manner. The denotational semantics of a programming language is composed of the syntax, domains, and semantic functions of the language.
Reference: [70] <author> Stroustrup, B. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Smalltalk-80 is a uniformly object-oriented system. Objects are used to represents numbers, character strings, file directories, and even computer programs like compilers and text editors. Features of the Smalltalk-80 programming environment are presented in the next section. C++ is an object-oriented extension of the C programming language <ref> [40, 70, 71] </ref>. C++ requires virtual functions to be declared explicitly for messages that have more than one method and provides a visibility control mechanism for variables and methods defined in a class. Private variables or methods are only accessible to functions or friend functions of the class.
Reference: [71] <author> Stroustrup, B. </author> <title> An overview of C++. </title> <journal> SIGPLAN Notices 21, </journal> <month> 10 (October </month> <year> 1986), </year> <pages> 7-18. </pages>
Reference-contexts: Smalltalk-80 is a uniformly object-oriented system. Objects are used to represents numbers, character strings, file directories, and even computer programs like compilers and text editors. Features of the Smalltalk-80 programming environment are presented in the next section. C++ is an object-oriented extension of the C programming language <ref> [40, 70, 71] </ref>. C++ requires virtual functions to be declared explicitly for messages that have more than one method and provides a visibility control mechanism for variables and methods defined in a class. Private variables or methods are only accessible to functions or friend functions of the class.
Reference: [72] <author> Sussman, G. J., and Steel Jr, G. L. </author> <title> Scheme: an interpreter for extended lambda calculus. </title> <type> Tech. rep., </type> <institution> Massachusetts Institute of Technology Artificial Intelligence Memo 349, </institution> <year> 1975. </year>
Reference-contexts: Section 6 illustrates problems and presents solutions of incorporating a macro system for IMP. 36 CHAPTER 4. THE IMP SYSTEM 37 4.1 An Overview of Scheme Scheme, a dialect of Lisp, was designed in 1975 at MIT by Guy Lewis Steel Jr. and Gerald Jay Sussman <ref> [72] </ref>. Scheme is a small language that has a simple syntax and an exceptionally clear semantics [58, 35]. 4.1.1 Syntax The notation . . . denotes zero or more occurrences of the preceding form. Scheme supports many data types.
Reference: [73] <author> Swinehart, D., Zellweger, P., Beach, R., and Hagmann, R. </author> <title> A struc-tural view of the Cedar programming environment. </title> <journal> ACM Transactions on Programming Languages and Systems 8, </journal> <month> 4 (October </month> <year> 1986), </year> <pages> 419-490. </pages>
Reference-contexts: Smalltalk-80 supports interactive program development through recompilation. A class can be modified interactively with its subclass automatically recompiled. Interactive programming environments have been traditionally based on dynamically typed languages such as Lisp or Smalltalk. However, Cedar is an interactive programming environment based on a strongly typed, compiler-oriented language <ref> [74, 73] </ref>. Cedar uses delayed type binding and a run-time type system to provide the flexibility required by interactive programming. A Cedar user can create multiple instances of UserExecutive interactively. Each UserExecutive has its own state and performs its own operations.
Reference: [74] <author> Teitelman, W. </author> <title> A tour through Cedar. </title> <booktitle> IEEE Software (April 1984), </booktitle> <pages> 44-73. </pages>
Reference-contexts: Smalltalk-80 supports interactive program development through recompilation. A class can be modified interactively with its subclass automatically recompiled. Interactive programming environments have been traditionally based on dynamically typed languages such as Lisp or Smalltalk. However, Cedar is an interactive programming environment based on a strongly typed, compiler-oriented language <ref> [74, 73] </ref>. Cedar uses delayed type binding and a run-time type system to provide the flexibility required by interactive programming. A Cedar user can create multiple instances of UserExecutive interactively. Each UserExecutive has its own state and performs its own operations.
Reference: [75] <author> Teitelman, W., and Masinter, L. </author> <title> The Interlisp programming environment. </title> <booktitle> IEEE Computer 14, 4 (1981), </booktitle> <pages> 25-34. </pages>
Reference-contexts: Many other programming languages are invented, however, to 1 CHAPTER 1. INTRODUCTION 2 support different programming techniques or program development paradigms. Interactive programming is an important programming technique that is most suitable for solving problems that are not well understood <ref> [80, 75] </ref>. An interactive programming system allows a programmer to enter programs or program fragments directly into the system and to receive the output from that program or fragment immediately, reducing the usual compile-link-execute step conceptually to a single evaluate step. <p> CHAPTER 2. RELATED WORK 15 2.3 Integrated Languages and Environments The Interlisp programming environment developed during the 1970's contains a set of programming tools for expert programmers <ref> [75] </ref>. The primary goal of Interlisp is to support experimental programming and structured growth. Some problems in computer science are not well understood and cannot be specified in advanced. The solutions for these problems must evolve through a series of experiments and enhancements.
Reference: [76] <author> Tennent, R. D. </author> <title> The denotational semantics of programming languages. </title> <journal> Communications of the ACM 19, </journal> <month> 8 (August </month> <year> 1976), </year> <pages> 437-453. </pages>
Reference-contexts: Denotational semantics is an important tool for the design and implementation of programming language systems [69]. The denotational semantics of a programming language provides a formal and precise definition of the language and is useful for its users and its implementors <ref> [62, 76] </ref>. However, complete specifications of realistic programming languages in denotational semantics are often difficult to read. To overcome this difficulty, Chapter 3 presents the denotational semantics of a toy language designed to show the most interesting semantic properties of interactive modular programming.
Reference: [77] <author> Tennent, R. D. </author> <title> Two examples of block structure. </title> <booktitle> Software Practice and Experience 12 (1982), </booktitle> <pages> 385-392. </pages>
Reference-contexts: One is Scheme's lack of support for modular programming, and the other is a consistency problem associated with interactive program development in Scheme. 4.2.1 Modular Programming Lexical scoping is the only name-space management mechanism supported by Scheme. The advantages of lexical scoping are <ref> [28, 77] </ref>: 1. The programmer can determine the binding of a variable reference by looking at the static program text. 2. The compiler can determine variables' run-time locations at compile time. CHAPTER 4.
Reference: [78] <author> Ungar, D., and Smith, R. B. </author> <title> Self: </title> <booktitle> The power of simpicity. In Proceedings of OOPSLA '87, Object-Oriented Programming Systems, Languages, and Applications (December 1987), </booktitle> <pages> pp. 227-242. </pages> <note> printed as SIGPLAN Notices, 22(12). </note>
Reference-contexts: In addition, C++ supports generic classes CHAPTER 2. RELATED WORK 13 which are parameterized classes. Like Ada's generic packages, generic classes must be instantiated statically before used. Recent versions of C++ also support multiple inheritance. The Self programming language is an object-oriented language that has no classes <ref> [78] </ref>. Object creation and inheritance are facilitated by prototyping. Any object in Self can be cloned or copied to create new objects, and any object can inherit behaviors from its parent objects. Self does not distinguish state from behavior and does not have variables either.
Reference: [79] <author> US Government Department of Defense. </author> <title> The programming language ADA reference manual. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <month> 106 </month> <year> (1981). </year>
Reference-contexts: In addition to module facilities for interactive languages, we also looked at a few conventional modular languages such as CLU [49], Modula-2 [81], Modula-3 [9], and Ada <ref> [79] </ref>. CLU supports parameterized abstract data types. Modula-2 separates the definition of a module from its implementation, and it requires a one-to-one correspondence between the two components. Modula-3 differs from Modula-2 by allowing an implementation module to be associated with several interface specifications. This CHAPTER 2.
Reference: [80] <author> Walker, J. H., Moon, D. A., Weinreb, D. L., and McMahon, M. </author> <title> The Symbolics Genera programming environment. </title> <booktitle> IEEE Software 4, </booktitle> <month> 6 (November </month> <year> 1987), </year> <pages> 36-45. BIBLIOGRAPHY 134 </pages>
Reference-contexts: Many other programming languages are invented, however, to 1 CHAPTER 1. INTRODUCTION 2 support different programming techniques or program development paradigms. Interactive programming is an important programming technique that is most suitable for solving problems that are not well understood <ref> [80, 75] </ref>. An interactive programming system allows a programmer to enter programs or program fragments directly into the system and to receive the output from that program or fragment immediately, reducing the usual compile-link-execute step conceptually to a single evaluate step. <p> Some problems in computer science are not well understood and cannot be specified in advanced. The solutions for these problems must evolve through a series of experiments and enhancements. Interlisp supports this program "evolution" process through a set of integrated tools. Symbolics Genera is a Lisp-based programming environment <ref> [80] </ref>. The goal of Genera is to support the methodology of evolutionary refinement for software development. Some of the interesting features of Genera are its data-level integration and its open system approach.
Reference: [81] <author> Wirth, N. </author> <title> Programming in Modula-2. </title> <publisher> Springer Verlag, </publisher> <year> 1983. </year>
Reference-contexts: Functors are parameterized structures. Unlike Symmetric Lisp's Kappa form, which is parameterized over individual items in an environment, functors parameterize an environment (structure) over its sub-environments (sub-structures). In addition to module facilities for interactive languages, we also looked at a few conventional modular languages such as CLU [49], Modula-2 <ref> [81] </ref>, Modula-3 [9], and Ada [79]. CLU supports parameterized abstract data types. Modula-2 separates the definition of a module from its implementation, and it requires a one-to-one correspondence between the two components. Modula-3 differs from Modula-2 by allowing an implementation module to be associated with several interface specifications.
Reference: [82] <author> Wulf, W., and Shaw, M. </author> <title> Global variable considered harmful. </title> <journal> ACM SIGPLAN Notices (Februry 1973), </journal> <pages> 28-34. </pages>
Reference-contexts: #f) (define pop #f) (let ([stack '()]) (set! init (lambda () (set! stack '()))) (set! push (lambda (v ) (set! stack (cons v stack )))) (set! pop (lambda () (let ([v (car stack )]) (set! stack (cdr stack )) v )))) However, lexical scoping also has a number of limitations <ref> [82, 28] </ref>. One of them is that the lexical structure of a program is forced to be tree like, and an other one is that direct communication among variables in different branches of a program tree is impossible.
References-found: 82

