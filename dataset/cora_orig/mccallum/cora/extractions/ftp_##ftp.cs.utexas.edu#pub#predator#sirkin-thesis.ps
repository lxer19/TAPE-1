URL: ftp://ftp.cs.utexas.edu/pub/predator/sirkin-thesis.ps
Refering-URL: http://www.cs.utexas.edu/users/schwartz/pub.htm
Root-URL: http://www.cs.utexas.edu
Author: Martin J. Sirkin 
Date: 1994  
Note: Copyright  
Abstract-found: 0
Intro-found: 1
Reference: [Abb92] <author> M. Abbott, and L. Peterson. </author> <title> A Language-Based Approach to Protocol Implementation. </title> <type> Technical Report 92-2, </type> <institution> University of Arizona, </institution> <year> 1992. </year>
Reference-contexts: The name GenVoca was given to the model that unified the designs of two software system generators: Genesis, a generator of database systems, and Avoca, a generator of network protocols. Just as our project developed from Genesis, another language/compiler-based project <ref> [Abb92] </ref> was spawned from Avoca. It is worth noting that this follow-on project to Avoca added a set of features to GenVoca that is almost identical to ours. <p> In the domain of data structures, both this work (Predator) and Predator-2 (P2) [Bat93a] address the generation of efficient data structure code. P++ [Sin93] provides an extension of the C++ language which allows definition and combination of realms and components, based on the lessons learned from Predator. <ref> [Abb92] </ref> describes a protocol customization compiler which is based on the Avoca project and bears many similarities to the Predator system. ADAGE [Cog93] is a GenVoca-based system in the domain of avionics software.
Reference: [Acm91] <editor> ACM. </editor> <title> Next generation database systems. </title> <journal> Communications of the ACM, </journal> <volume> 34(10), </volume> <month> October </month> <year> 1991. </year>
Reference-contexts: While those concepts will be fully explored later in this dissertation, a few will be mentioned here: 1. We have included a consistent, high level interface often found in persistent object bases [Lam91] and databases <ref> [Acm91, Bat88, Bat90, Dat83] </ref>. 2. Our system relies heavily on compiler and transformation technology. Our components are always created dynamically to suit the particular data structures and operations needed. 3. Utilizing compiler technology also allows us to extensively explore the area of domain-specific optimizations.
Reference: [Aho83] <author> A. Aho, J. Hopcroft, and J. Ullman. </author> <title> Data Structures and Algorithms, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass, </address> <year> 1983. </year>
Reference-contexts: The next attempt at providing a Predator-based quicksort was far more successful. Since the algorithm for quicksort is common and well understood, we took an existing version of the algorithm from <ref> [Aho83] </ref> as the base. The conversion of the algorithm to Predator code took less than 30 minutes. 77 The converted version, while a working quicksort algorithm, was not yet ready to compare against the BSD version. This was because: 1.
Reference: [Bal85] <author> R. Balzer. </author> <title> A Fifteen-Year Perspective on Automatic Programming. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE 11, </volume> <month> November, </month> <year> 1985. </year>
Reference-contexts: NPTs, therefore, deal with program transformations. Programmers write data-structure independent algorithms, and specify container implementations as compositions of components. The transformation of programs and data types are done automatically through the use of in-line expansion and partial evaluation. More details on transformational processes can be found in <ref> [Par83, Gri90, Bal85, Coh93] </ref>. Containers are first-class objects. Thus, the more traditional forms of composition, such as that in Figure 2.2 can easily be supported. That is, a list of trees would be represented as follows: a container, which is a binary tree of elements would first be declared.
Reference: [Bat88] <author> D. Batory, J. Barnett, J. Garza, K. Smith, K. Tsukuda, B. Twichell, and T. Wise. </author> <title> GENESIS: An extensible database management system. </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> November </month> <year> 1988. </year>
Reference-contexts: Software architectures deal with the scalability issues of programming-in-the-large. GenVoca is but one approach to create scalable domain-specific software architectures [Hei90, Hei91, Cam92, Wei90]. It is a model of hierarchical software construction that has been used in software generators for a variety of rather disparate domains (databases <ref> [Bat88, Bat90] </ref>, network communication [Hut91, Oma90], and avionics [Cog93]). Its key feature is that it exploits the maturity of domains by standardizing their fundamental abstractions, and then standardiz 7 ing the way in which software systems of the domain are built from these abstractions. <p> While those concepts will be fully explored later in this dissertation, a few will be mentioned here: 1. We have included a consistent, high level interface often found in persistent object bases [Lam91] and databases <ref> [Acm91, Bat88, Bat90, Dat83] </ref>. 2. Our system relies heavily on compiler and transformation technology. Our components are always created dynamically to suit the particular data structures and operations needed. 3. Utilizing compiler technology also allows us to extensively explore the area of domain-specific optimizations. <p> Other system generators [Hei90, Haa90] also possess organizations similar to GenVoca. As mentioned in Section 1.5, GenVoca is derived from two independently-conceived software system generators, Genesis <ref> [Bat88, Bat90] </ref> and Avoca [Hut91, Oma90]. The foundation for GenVoca has its roots in Parnas families of systems [Par76], Habermanns FAMOS project [Hab76], and Goguens model of parameterized programming [Gog86, Tra93]. <p> Our interface for DS largely reects work performed in databases <ref> [Bat88, Bat90, Kor91] </ref> and persistent object bases [Lam91]. It is high-level, in that the interface provides little more than basic relational operations. <p> However, without layering (i.e. vertical parameterization), we find templates insufficient to model the full range of data structures available with NPTs. 6.5 GenVoca systems Our NPT work is based on the GenVoca domain modelling approach [Bat92b]. The concepts for GenVoca are based on two independent projects; Genesis <ref> [Bat88, Bat90] </ref>, which is a generator of database systems, and Avoca [Oma90], which is a generator of network protocols. Despite the radically different domains for the two projects, it was observed that they approached the generation of software systems in a similar manner.
Reference: [Bat90] <author> D. Batory. </author> <title> The Genesis Database System Compiler: User Manual. </title> <type> Technical Report 90-27, </type> <institution> University of Texas, </institution> <year> 1990. </year>
Reference-contexts: Software architectures deal with the scalability issues of programming-in-the-large. GenVoca is but one approach to create scalable domain-specific software architectures [Hei90, Hei91, Cam92, Wei90]. It is a model of hierarchical software construction that has been used in software generators for a variety of rather disparate domains (databases <ref> [Bat88, Bat90] </ref>, network communication [Hut91, Oma90], and avionics [Cog93]). Its key feature is that it exploits the maturity of domains by standardizing their fundamental abstractions, and then standardiz 7 ing the way in which software systems of the domain are built from these abstractions. <p> While those concepts will be fully explored later in this dissertation, a few will be mentioned here: 1. We have included a consistent, high level interface often found in persistent object bases [Lam91] and databases <ref> [Acm91, Bat88, Bat90, Dat83] </ref>. 2. Our system relies heavily on compiler and transformation technology. Our components are always created dynamically to suit the particular data structures and operations needed. 3. Utilizing compiler technology also allows us to extensively explore the area of domain-specific optimizations. <p> Other system generators [Hei90, Haa90] also possess organizations similar to GenVoca. As mentioned in Section 1.5, GenVoca is derived from two independently-conceived software system generators, Genesis <ref> [Bat88, Bat90] </ref> and Avoca [Hut91, Oma90]. The foundation for GenVoca has its roots in Parnas families of systems [Par76], Habermanns FAMOS project [Hab76], and Goguens model of parameterized programming [Gog86, Tra93]. <p> Our interface for DS largely reects work performed in databases <ref> [Bat88, Bat90, Kor91] </ref> and persistent object bases [Lam91]. It is high-level, in that the interface provides little more than basic relational operations. <p> It is crucial that our compiler generate efficient data structure code. The compiler is responsible for generating only the code necessary for the declared operations. Unlike more traditional database systems <ref> [Kor91, Bat90, Bat93b] </ref>, NPT-generated code is not general. It is geared specifically for the type equation of a particular container, and incurs only the overhead for the mechanisms to support the primitive functions used in a given application. <p> However, without layering (i.e. vertical parameterization), we find templates insufficient to model the full range of data structures available with NPTs. 6.5 GenVoca systems Our NPT work is based on the GenVoca domain modelling approach [Bat92b]. The concepts for GenVoca are based on two independent projects; Genesis <ref> [Bat88, Bat90] </ref>, which is a generator of database systems, and Avoca [Oma90], which is a generator of network protocols. Despite the radically different domains for the two projects, it was observed that they approached the generation of software systems in a similar manner.
Reference: [Bat92a] <author> D. Batory, V. Singhal, and M. Sirkin. </author> <title> Implementing a domain model for data structures. </title> <journal> International Journal of Software Engineering and Knowledge Engineering, </journal> <volume> 2(3) </volume> <pages> 375-402, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Eliminating the drudgery of programming data structures is clearly an important, but still unsolved, problem. Our thesis is that a practical solution rests on a software component technology that integrates concepts of parameterized types, standardized interfaces, domain modelling, and compiler optimizations <ref> [Bat92a, Sir93, Pri91] </ref>. Integration of these concepts is both technically challenging and a fertile area of research. More importantly, it leads to a technology for assembling complex data structures from pre-written and standardized components.
Reference: [Bat92b] <author> D. Batory, and S. </author> <title> OMalley.The Design and Implementation of Hierarchical Software Systems Using Reusable Components. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <month> October </month> <year> 1992. </year>
Reference-contexts: Its key feature is that it exploits the maturity of domains by standardizing their fundamental abstractions, and then standardiz 7 ing the way in which software systems of the domain are built from these abstractions. We will discuss GenVoca at greater length in Section 3.1 <ref> [Bat92b] </ref>. The relevance of GenVoca became evident when we realized that data structures are hierarchical; they can be understood as compositions of plug-compatible layers. <p> He recognizes the importance of separating algorithms from the implementation of the data structures. However, without layering (i.e. vertical parameterization), we find templates insufficient to model the full range of data structures available with NPTs. 6.5 GenVoca systems Our NPT work is based on the GenVoca domain modelling approach <ref> [Bat92b] </ref>. The concepts for GenVoca are based on two independent projects; Genesis [Bat88, Bat90], which is a generator of database systems, and Avoca [Oma90], which is a generator of network protocols.
Reference: [Bat92c] <author> D. Batory, and J. Barnett. DaTE: </author> <title> The Genesis DBMS Software Layout Editor. In Conceptual Modeling, Databases, and CASE: An Integrated View of Information Systems Development, </title> <editor> P. Loucopoulos and R. Zicari, editors, </editor> <publisher> John Wiley & Sons, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: The compiler can then return the appropriate warning or error to inform the programmer of the mismatch. Attribute grammars appear to be a unifying formalism that can be used to define realms, their components, and design rules <ref> [Bat92c] </ref>. 3.1.3 Symmetry Recursion, in the form of symmetric components, is fundamental to GenVoca. Symmetric components have the unusual property that they can be composed in arbitrary ways. <p> Our approach allows for the substitution of implementations after a program is written. We envision a tool which would help programmers traverse the tree of possible implementations, and would assist in the selection of candidate type equations. A similar tool <ref> [Bat92c] </ref> has already been implemented for the Genesis system. Further validation. We believe that our effort must be further validated. Of particular interest is more productivity experiments, the results of which would help us refine our DS and LINK interfaces to better serve the needs of application programmers.
Reference: [Bat93a] <author> D. Batory, V. Singhal, M. Sirkin, and J. Thomas. </author> <title> Scalable Software Architectures. </title> <booktitle> In Proceedings of the ACM SIGSOFT 93: Symposium on the Foundations of Software Engineering, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: A methodology is required to allow the size of the component library to scale gracefully as new components are added 3 . The monolithic nature of 3. The problem of scalability is detailed further in <ref> [Bat93a] </ref>. 19 TPT components makes this a difficult goal to attain. 2.2.7 Code efficiency A standard method of implementing TPTs is to compile the code for each TPT component separately, with references and manipulations of generic objects performed via pointers [Ghe87]. <p> A discussion of one implementation of this combination strategy (with functional templates) is provided in the next chapter. An in-depth discussion of NPT scalability is given in <ref> [Bat93a] </ref>. 3.4.7 Code efficiency Efficiency is a key concern in this research. It is crucial that our compiler generate efficient data structure code. The compiler is responsible for generating only the code necessary for the declared operations. Unlike more traditional database systems [Kor91, Bat90, Bat93b], NPT-generated code is not general. <p> It is logical to ask, therefore, how Predator-generated code compares against that available in those libraries. This section reports on a benchmarking effort, which is reported in greater detail in <ref> [Bat93a] </ref>. A spell checker benchmark was written. When invoked, the program reads in a dictionary file of 25,000 words, in randomized order, which it places in a data structure. Next, a document is read in from standard input. <p> Specifically, the component interfaces are not consistent, the Booch model does not allow for arbitrary compositions, the performance (as seen in Section 5.3) is not competitive with other TPT libraries, and the library is not scalable <ref> [Bat93a] </ref>. libg++ is another C++-based component library [Lea88]. libg++ is a collection of classes and support tools that is part of the GNU 1 tools distribution. As such, it is freely available, and has been heavily used and tested. <p> Despite the radically different domains for the two projects, it was observed that they approached the generation of software systems in a similar manner. A number of subsequent projects have embraced the GenVoca approach. In the domain of data structures, both this work (Predator) and Predator-2 (P2) <ref> [Bat93a] </ref> address the generation of efficient data structure code. <p> Some of the more interesting layers we would like to investigate are hashing, concurrency, reference counting, assertions, and arbitrary graphs. A second-generation tool. Our research group is currently constructing a second-generation Predator (P2) <ref> [Bat93a] </ref>. P2 is designed to improve on many of the defects discussed in Chapter 7. P2 is also better structured to allow for easier writing of new layers. A formal model.
Reference: [Bat93b] <author> D. Batory and D. Vasavada. </author> <title> Software Components for Object-Oriented Database Systems. </title> <journal> International Journal of Software Engineering and Knowledge Engineering 3(2) </journal> <pages> 165-192, </pages> <year> 1993. </year>
Reference-contexts: It is crucial that our compiler generate efficient data structure code. The compiler is responsible for generating only the code necessary for the declared operations. Unlike more traditional database systems <ref> [Kor91, Bat90, Bat93b] </ref>, NPT-generated code is not general. It is geared specifically for the type equation of a particular container, and incurs only the overhead for the mechanisms to support the primitive functions used in a given application.
Reference: [Big89a] <author> T. Biggerstaff, and A. Perlis. </author> <title> Software Reusability. Vol I, Concepts and Models. </title> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: In this chapter, we highlight representative systems of those approaches, discuss their strengths, and explain how they differ from our work. In addition, we examine the problems of general software reuse <ref> [Big89a, Big89b] </ref>. There are many researchers in software reuse who are not addressing data structure reuse in particular, but whose insights are relevant to our work.
Reference: [Big89b] <author> T. Biggerstaff, and A. Perlis. </author> <title> Software Reusability. Vol II, Applications and Experience. </title> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: In this chapter, we highlight representative systems of those approaches, discuss their strengths, and explain how they differ from our work. In addition, we examine the problems of general software reuse <ref> [Big89a, Big89b] </ref>. There are many researchers in software reuse who are not addressing data structure reuse in particular, but whose insights are relevant to our work.
Reference: [Bla86] <author> A. Black, N. Hutchinson, E. Jul, and H. Levy. </author> <title> Object Structure in the Emerald System. </title> <booktitle> In Proceedings for the First ACM SIGPLAN Conference on Object Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 78-86, </pages> <month> October </month> <year> 1986. </year> <month> 133 </month>
Reference-contexts: He proposes a compositional model and prototype (the Jade programming language) based on the Emerald programming language <ref> [Bla86, Bla87] </ref>. His language advocates a Lego-block composition similar to that of GenVoca, by extending Emerald with constructs which allow for the declaration of compositional names and dependencies, and by including of parts of other components previously defined.
Reference: [Bla87] <author> A. Black, N. Hutchinson, E. Jul, H. Levy, and L. Carter. </author> <title> Distribution and Abstract Types in Emerald. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(1) </volume> <pages> 65-76, </pages> <month> Jan-uary </month> <year> 1987. </year>
Reference-contexts: He proposes a compositional model and prototype (the Jade programming language) based on the Emerald programming language <ref> [Bla86, Bla87] </ref>. His language advocates a Lego-block composition similar to that of GenVoca, by extending Emerald with constructs which allow for the declaration of compositional names and dependencies, and by including of parts of other components previously defined.
Reference: [Boo87] <author> G. Booch. </author> <title> Software Components with Ada. </title> <address> Benjamin/Cummings, Menlo Park, CA, </address> <year> 1987. </year>
Reference-contexts: Details such as implementation, extensibility and scalability may differ by category, but they all share components as their underlying basis. 1.4.1 Software component libraries Component libraries are perhaps the most common solution to data structure programming. Component libraries can be found almost everywhere today, from stand-alone libraries <ref> [Boo87, Boo90, Gor90] </ref> to libraries that are included with compilers [Bor92] and operating systems [Lea88]. In a component library, many different data structures are represented, each by its own component in the library. These components are atomic and are treated as indivisible units of computation. <p> In fact, if one looks at commercially available data structure programming aids <ref> [Boo87, Lea88, Boo90, Lam91] </ref>, no one approach seems to dominate over any other. The subject of software architectures is gaining importance [Gar93]. Software architectures deal with the scalability issues of programming-in-the-large. GenVoca is but one approach to create scalable domain-specific software architectures [Hei90, Hei91, Cam92, Wei90]. <p> We feel that components provided to a programmer must be able to be specialized easily and without much knowledge of the inner workings of the TPTs. 2.2.2 Complex compositions It is widely believed that TPTs are the appropriate abstraction for encapsulating primitive data structures <ref> [Boo87, McN86a, McN86b, Pal90] </ref>. More complex structures are assumed to be created through TPT compositions. This is the case for the data structure depicted in Many data structures that are used in practice are unlikely to be available in TPT libraries. <p> That is, simply macro expanding the code from them (in arbitrary order) would not be sufficient. Languages such as SELF [Cha89] provide more sophisticated inheritance mechanisms, but still suffer from lack of knowledge about the domain (necessary to create merged, efficient components). Mapping TPTs <ref> [Boo87] </ref> can be used to simulate (but not exactly match) the data structure shown in Figure 2.3, but glue code is still required, and the indirections from the mapping layer (s) incur additional (and possibly unacceptable) performance penalties. Elements stored within a data structure seldom exist in isolation. <p> All the power of relations (containers) remained, but a customized interface could be used in place of a relational interface. We, like many others <ref> [Boo87] </ref>, generalize ADT interfaces to generic ADT interfaces. Stacks and queues are examples of generic containers (TPTs) that have special operations (push, dequeue, etc.). These operations can be implemented in terms of container operations (INSERT, DELETE). Herein lies the key idea for eliminating the difficulty of specializing TPTs. <p> We feel it is crucial that our NPT design avoid the combinatorics problems presented by libraries such as <ref> [Boo87, Lea88, Boo90] </ref>. Our NPT layering structure has been specifically designed so that all of the NPT layers are effectively orthogonal to other layers within the same realm. <p> A large subset of available libraries implement data structure components. In this section we will discuss two of them. The Booch components are a set of monolithic data structure components. The original set of components <ref> [Boo87] </ref> were written in Ada. There are a large number of components in the library (more than 400), and the interfaces of these components are mature, high-level, and well-defined. Booch has defined an interface that includes such items as constructors, itera-tors, selectors, and exceptions.
Reference: [Boo90] <author> G. Booch, and M. Vilot. </author> <title> The Design of the C++ Booch Components. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming: Systems, Languages, and Applications 90, </booktitle> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: Details such as implementation, extensibility and scalability may differ by category, but they all share components as their underlying basis. 1.4.1 Software component libraries Component libraries are perhaps the most common solution to data structure programming. Component libraries can be found almost everywhere today, from stand-alone libraries <ref> [Boo87, Boo90, Gor90] </ref> to libraries that are included with compilers [Bor92] and operating systems [Lea88]. In a component library, many different data structures are represented, each by its own component in the library. These components are atomic and are treated as indivisible units of computation. <p> In fact, if one looks at commercially available data structure programming aids <ref> [Boo87, Lea88, Boo90, Lam91] </ref>, no one approach seems to dominate over any other. The subject of software architectures is gaining importance [Gar93]. Software architectures deal with the scalability issues of programming-in-the-large. GenVoca is but one approach to create scalable domain-specific software architectures [Hei90, Hei91, Cam92, Wei90]. <p> The Booch C++ Components <ref> [Boo90] </ref>, for example, implements over 400 distinct data structures such as stacks, lists, hash tables, queues, and trees. <p> We feel it is crucial that our NPT design avoid the combinatorics problems presented by libraries such as <ref> [Boo87, Lea88, Boo90] </ref>. Our NPT layering structure has been specifically designed so that all of the NPT layers are effectively orthogonal to other layers within the same realm. <p> Words which are not found are then printed out to standard output. Standard input and output routines were written, and used in each of the programs. Three different library systems (Booch components for C++ <ref> [Boo90] </ref>, libg++ [Lea88], and Pred 85 ator) were benchmarked. Each of the systems was benchmarked against unsorted and sorted arrays, unordered lists, and ordered binary trees. The Predator source of the array version can be found in Appendix D. <p> He also has defined a set of tools, such as sorting, character manipulations, numerics, and list operations. These tools are implemented across the family of components. He also has implemented components for concurrent and persistent data structures. Booch components are also available for C++ <ref> [Boo90] </ref>. The conversion to C++ takes advantage of object-oriented features of C++, and allowed Booch to dramatically reduce the size of 114 the components, while retaining the same interface and overall performance as the Ada version. The Booch components possess many of the limitations that we outlined in Chapter 2. <p> We also feel that our work has made contributions in the understanding of the scalability of component libraries. We estimate that it would take approximately 40 NPT components to provide equivalent functionality of component libraries <ref> [Boo90, Lea88] </ref> which contain 400 components, or more. Further, the vertical parameterization of NPTs would allow those 40 components to be composed into additional structures which do not exist in those other libraries.
Reference: [Bor92] <author> OWL Classes. </author> <title> Borland C++ Users Manual. </title> <publisher> Borland Inc, </publisher> <year> 1992. </year>
Reference-contexts: Component libraries can be found almost everywhere today, from stand-alone libraries [Boo87, Boo90, Gor90] to libraries that are included with compilers <ref> [Bor92] </ref> and operating systems [Lea88]. In a component library, many different data structures are represented, each by its own component in the library. These components are atomic and are treated as indivisible units of computation. Each component presents its interface to the outside world.
Reference: [Bra93a] <author> D. </author> <title> Brant. Inferencing on Large Data Sets. </title> <type> Ph.D. dissertation, </type> <institution> Department of Computer Sciences, University of Texas, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: Adding persistency to production systems produces two major benefits: 1. Significantly larger data sets can be processed in this manner. 2. A production system can be stopped in the middle of processing, and restarted at a later time. A persistent version of LEAPS, called DATEX <ref> [Bra93a, Bra93b] </ref>, already exists. DATEX programs are used to handle very large data sets, but cannot be stopped and restarted. A memory-mapped version of persistency was added to Predator as a layer.
Reference: [Bra93b] <author> D. Brant, and D. Miranker. </author> <title> Index support for rule activation. </title> <booktitle> In Proceedings of 1993 ACM SIGMOD, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: Adding persistency to production systems produces two major benefits: 1. Significantly larger data sets can be processed in this manner. 2. A production system can be stopped in the middle of processing, and restarted at a later time. A persistent version of LEAPS, called DATEX <ref> [Bra93a, Bra93b] </ref>, already exists. DATEX programs are used to handle very large data sets, but cannot be stopped and restarted. A memory-mapped version of persistency was added to Predator as a layer.
Reference: [Cam92] <author> R. Campbell, N. Islam, and P. Madany. </author> <title> Choices, frameworks and refinement. </title> <journal> Computing Systems, </journal> <volume> 5(3) </volume> <pages> 217-257, </pages> <year> 1992. </year>
Reference-contexts: The subject of software architectures is gaining importance [Gar93]. Software architectures deal with the scalability issues of programming-in-the-large. GenVoca is but one approach to create scalable domain-specific software architectures <ref> [Hei90, Hei91, Cam92, Wei90] </ref>. It is a model of hierarchical software construction that has been used in software generators for a variety of rather disparate domains (databases [Bat88, Bat90], network communication [Hut91, Oma90], and avionics [Cog93]).
Reference: [Cha89] <author> C. Chambers, D. Unger, and E. Lee. </author> <title> An Efficient Implementation of SELF, a Dynamically-Typed Object-Oriented Language Based on Prototypes. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming: Systems, Languages, and Applications 89, </booktitle> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: The code inherited from these two modules are interrelated. That is, simply macro expanding the code from them (in arbitrary order) would not be sufficient. Languages such as SELF <ref> [Cha89] </ref> provide more sophisticated inheritance mechanisms, but still suffer from lack of knowledge about the domain (necessary to create merged, efficient components). <p> Object-orientation offers many advantages; it provides a consistent abstraction (the object), allows for reuse via inheritance, and is a well-understood and appreciated paradigm. Many object-oriented systems and languages have been used for data structure programming and libraries. Some of these are Smalltalk [Gol83], C++ [Str91], Modula-3 [Har92], SELF <ref> [Cha89] </ref>, Eiffel [Mey88], and Meldc [Pop91]. All of these suffer from the limitation that they possess no native knowledge about specific problem domains. Thus, they cannot natively perform domain-specific optimizations. We have also detailed, in Chapter 2, the compositional difficulties object-oriented approaches possess when dealing with complex compositions.
Reference: [Cog93] <author> L. Coglianese, and R. Szymanski. </author> <title> DSSA-ADAGE: An Environment for Architecture-based Avionics Development. </title> <note> In Proceedings of AGARD 1993. Also Technical Report ADAGE-IBM-93-04, </note> <institution> IBM Owego, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: GenVoca is but one approach to create scalable domain-specific software architectures [Hei90, Hei91, Cam92, Wei90]. It is a model of hierarchical software construction that has been used in software generators for a variety of rather disparate domains (databases [Bat88, Bat90], network communication [Hut91, Oma90], and avionics <ref> [Cog93] </ref>). Its key feature is that it exploits the maturity of domains by standardizing their fundamental abstractions, and then standardiz 7 ing the way in which software systems of the domain are built from these abstractions. We will discuss GenVoca at greater length in Section 3.1 [Bat92b]. <p> P++ [Sin93] provides an extension of the C++ language which allows definition and combination of realms and components, based on the lessons learned from Predator. [Abb92] describes a protocol customization compiler which is based on the Avoca project and bears many similarities to the Predator system. ADAGE <ref> [Cog93] </ref> is a GenVoca-based system in the domain of avionics software. Finally, FICUS [Hei90, Hei91] provides a layered approach for customizing file systems which is based on concepts similar to those in GenVoca. 118 Evaluation This chapter presents an assessment of our research.
Reference: [Coh89] <author> D. Cohen. </author> <title> AP5 Training Manual. </title> <institution> USC Information Sciences Institute, </institution> <year> 1989. </year>
Reference-contexts: Transformation systems are characterized by the transformations they perform on components to create new components which are tailored to the data structure or environment desired. Examples of data structure transformation systems include <ref> [Sno89, Coh89, Coh93, Nov83, Nov92] </ref>. The chief feature which distinguishes transformation systems from library approaches is their ability to dynamically alter their components as needed. This exibility allows them, in principle, to be more task-specific, and hence more efficient. <p> As described previously, simple macro-expansion is not sufficient for some of the compositions we have encountered. Coupled with a domain-specific optimizer, NPTs have considerable expressibility. 3.4.3 Type transformations Our NPT model is a compiled transformation system, not unlike those of <ref> [Coh89, Coh93, Sno89] </ref>. Our type equations take an abstract description of a data structure schema and transform it (via our compiler technology) to a concrete realization of the schema. The abstract/concrete paradigm is followed rigorously as the type equation is being resolved. Each layer is responsible for an abstract-to-concrete transformation. <p> Also, GLISP supports both in-lining and optimizations. Further, GLISP provides the capability for operations to be side-effect free, which can improve program correctness. GLISP is unlike NPTs in that it does not support consistent, layered interfaces or attened data structures. Another LISP-based data structure transformation system is AP5 <ref> [Coh89, Coh93] </ref>. AP5 is a common-lisp derived system which augments the standard lisp syntax with constructs which are transformed into calls in a run-time library. Like our system, AP5 is relational and uses a high-level interface.
Reference: [Coh90] <author> S. Cohen. </author> <title> Ada 9X Project Report. </title> <year> 1990. </year>
Reference-contexts: A TPT is a data type that has been parametrically generalized to compactly represent a family of related types. A generic stack, for example, could be instantiated to form a stack of integers or a stack of strings. Generics in Ada <ref> [Ghe87, Coh90] </ref> and templates in C++ [Str91] are well-known implementations of TPTs. In this section, we examine the current uses and assumptions of TPTs. We then expose fundamental limitations in the design of TPTs, current implementations of TPTs, and in the concept of TPTs itself.
Reference: [Coh93] <author> D. Cohen, and N. Campbell. </author> <title> Automating relational operations on data structures. </title> <journal> IEEE Software, </journal> <volume> 10(3) </volume> <pages> 53-60, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Transformation systems are characterized by the transformations they perform on components to create new components which are tailored to the data structure or environment desired. Examples of data structure transformation systems include <ref> [Sno89, Coh89, Coh93, Nov83, Nov92] </ref>. The chief feature which distinguishes transformation systems from library approaches is their ability to dynamically alter their components as needed. This exibility allows them, in principle, to be more task-specific, and hence more efficient. <p> NPTs, therefore, deal with program transformations. Programmers write data-structure independent algorithms, and specify container implementations as compositions of components. The transformation of programs and data types are done automatically through the use of in-line expansion and partial evaluation. More details on transformational processes can be found in <ref> [Par83, Gri90, Bal85, Coh93] </ref>. Containers are first-class objects. Thus, the more traditional forms of composition, such as that in Figure 2.2 can easily be supported. That is, a list of trees would be represented as follows: a container, which is a binary tree of elements would first be declared. <p> As described previously, simple macro-expansion is not sufficient for some of the compositions we have encountered. Coupled with a domain-specific optimizer, NPTs have considerable expressibility. 3.4.3 Type transformations Our NPT model is a compiled transformation system, not unlike those of <ref> [Coh89, Coh93, Sno89] </ref>. Our type equations take an abstract description of a data structure schema and transform it (via our compiler technology) to a concrete realization of the schema. The abstract/concrete paradigm is followed rigorously as the type equation is being resolved. Each layer is responsible for an abstract-to-concrete transformation. <p> Also, GLISP supports both in-lining and optimizations. Further, GLISP provides the capability for operations to be side-effect free, which can improve program correctness. GLISP is unlike NPTs in that it does not support consistent, layered interfaces or attened data structures. Another LISP-based data structure transformation system is AP5 <ref> [Coh89, Coh93] </ref>. AP5 is a common-lisp derived system which augments the standard lisp syntax with constructs which are transformed into calls in a run-time library. Like our system, AP5 is relational and uses a high-level interface.
Reference: [Dat83] <author> C. Date. </author> <title> An Introduction to Database Systems. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass, </address> <year> 1983. </year>
Reference-contexts: While those concepts will be fully explored later in this dissertation, a few will be mentioned here: 1. We have included a consistent, high level interface often found in persistent object bases [Lam91] and databases <ref> [Acm91, Bat88, Bat90, Dat83] </ref>. 2. Our system relies heavily on compiler and transformation technology. Our components are always created dynamically to suit the particular data structures and operations needed. 3. Utilizing compiler technology also allows us to extensively explore the area of domain-specific optimizations.
Reference: [Dav92] <author> J. Davidson. </author> <title> Subprogram Inlining: A Study of its Effects on Program Execution Time. </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> February </month> <year> 1992. </year>
Reference-contexts: Predator templates (see Section 4.1.2) can therefore be implemented as Predator macros. Most of the code which implements Predator layers and function templates utilizes the macro facility, and is simple and high-level. This approach was taken because explicit layering in data structures often introduces unacceptable performance penalties. <ref> [Dav92] </ref> is but one work which demonstrates that in-lining (macro expansion) can be very beneficial in generating efficient code. Predator also exports its macro facility. Programmers may write their own macros and use them anywhere in their source text.
Reference: [Fon90] <author> M. Fontana, L. Oren, and M. Neath. </author> <title> COOL C++ object-oriented library. </title> <institution> Texas Instruments, </institution> <year> 1990. </year>
Reference-contexts: LEAPS offers many advantages for emulation: 1. It is a mature project with many performance results published. 2. It is a state-of-the-art system with results that compare favorably against other sys tems in its field [Mir90]. 5. In the near future we hope to add additional libraries <ref> [Gor87, Fon90] </ref> to our benchmark. 87 3. It contains a large number of data structure instances (containers) in its run-time library. 4. It uses many different data structures (schemas) including lists, stacks, predicate indexes, and links. 5. The code that implements LEAPS is very complicated.
Reference: [For81] <author> C. Forgy. </author> <title> OPS5 Users Manual. </title> <type> Technical Report CMU-CS-81-135, </type> <institution> Carnegie-Mel-lon University, </institution> <year> 1981. </year>
Reference-contexts: LEAPS is a University of Texas project. Technical assistance was available. Given all these advantages, we decided to take several LEAPS test cases (rule sets), emulate them with Predator equivalents, and study the results. 5.4.1 OPS5 OPS5 <ref> [For81] </ref> is a language for describing production (expert) systems. It is a mature system, which is used widely in the AI community. OPS5 is a mature language, and LEAPS is but one of many approaches [McD78a, McD78b] designed to evaluate OPS5 programs.
Reference: [Gar92] <author> D. Garlan, G. Kaiser, and D. Notkin. </author> <title> Composing Systems Using Tool Abstraction. </title> <booktitle> IEEE Computer, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: Our goal is to provide a standardized, high-level interface for our components to increase reuse and allows for simpler system evolution. In addition, we envision a mechanism to extend component interfaces to simplify program maintenance. This approach is orthogonal to that taken by others <ref> [Sno89, Gar92] </ref>, and allows us to add features, such as invariants and assertions, without affecting our overall model. <p> However, in the context of a specific application, it is often the case that additional operations, unforeseen by the TPT author, are needed <ref> [Gar92, Sul92] </ref>. As the following examples illustrate, the penalty for non-extensible TPT interfaces can be severe inefficiencies or abandoning the use of the TPT altogether. List header 13 Consider a queue with the interface: enqueue, dequeue, is_empty, is_full. <p> It is often the case that a programmers first working solution to a problem is also his last. 18 2.2.5 Evolution and maintenance TPTs by themselves do provide a small amount of support for program maintenance and system evolution <ref> [Gar92, Sul92] </ref>. Certainly, data hiding helps when maintaining a program, and having the ability to change the implementation of a module without having to rewrite the callers program allows systems to evolve over time. However, TPTs, by themselves, do not provide further support for these important problems. <p> For each limitation, we briey describe how the NPT features described above help overcome it. 3.4.1 Difficulty of specialization We raised the objection in Chapter 2 that TPT authors cannot envision all specializations in advance <ref> [Gar92, Sul92] </ref>. Even attempting to do so would yield overly large interfaces that would inhibit TPT use. We have observed that the container and link abstractions are remarkably durable. They were recognized in the early 1960s and are omnipresent today. The basic interfaces to these abstractions have been very robust.
Reference: [Gar93] <author> D. Garlan, and M. Shaw. </author> <title> An Introduction to Software Architecture. </title> <booktitle> In Advances in Software Engineering and Knowledge Engineering, </booktitle> <volume> Vol 1, </volume> <publisher> World Scientific Publishing Company, </publisher> <address> New York, </address> <year> 1993. </year> <month> 134 </month>
Reference-contexts: In fact, if one looks at commercially available data structure programming aids [Boo87, Lea88, Boo90, Lam91], no one approach seems to dominate over any other. The subject of software architectures is gaining importance <ref> [Gar93] </ref>. Software architectures deal with the scalability issues of programming-in-the-large. GenVoca is but one approach to create scalable domain-specific software architectures [Hei90, Hei91, Cam92, Wei90].
Reference: [Ghe87] <author> C. Ghezzi, and M. Jazayeri. </author> <title> Programming Language Concepts. </title> <publisher> John Wiley & Sons, </publisher> <address> New York, </address> <year> 1987. </year>
Reference-contexts: A TPT is a data type that has been parametrically generalized to compactly represent a family of related types. A generic stack, for example, could be instantiated to form a stack of integers or a stack of strings. Generics in Ada <ref> [Ghe87, Coh90] </ref> and templates in C++ [Str91] are well-known implementations of TPTs. In this section, we examine the current uses and assumptions of TPTs. We then expose fundamental limitations in the design of TPTs, current implementations of TPTs, and in the concept of TPTs itself. <p> The problem of scalability is detailed further in [Bat93a]. 19 TPT components makes this a difficult goal to attain. 2.2.7 Code efficiency A standard method of implementing TPTs is to compile the code for each TPT component separately, with references and manipulations of generic objects performed via pointers <ref> [Ghe87] </ref>. This introduces an additional run-time overhead for resolving inter-TPT references. Another method of implementation is macro expansion, which is not always sufficient to provide efficient code [Nov92]. We feel that these composition mechanisms, by themselves, do not generate sufficiently efficient code.
Reference: [Gog86] <author> J. Goguen. </author> <title> Reusing and Interconnecting Software Components. </title> <journal> IEEE Computer, </journal> <volume> 19(2) </volume> <pages> 16-28, </pages> <month> February </month> <year> 1986. </year>
Reference-contexts: Utilizing compiler technology also allows us to extensively explore the area of domain-specific optimizations. We feel that this is crucial for generating high-performance components. 4. We have extended the notion of component parameterization from classical work <ref> [Gog86] </ref> to allow components to be parameterized by fields, as well as the more stan dard constants, functions, and data types. 5. We have defined a series of specializations that allow us to customize components with new functions, and to add new functions without affecting existing components or application code. <p> Generics in Ada [Ghe87, Coh90] and templates in C++ [Str91] are well-known implementations of TPTs. In this section, we examine the current uses and assumptions of TPTs. We then expose fundamental limitations in the design of TPTs, current implementations of TPTs, and in the concept of TPTs itself. Goguen <ref> [Gog86] </ref> has proposed a model of parameterized programming in which two distinctly different forms of parameterization were identified: horizontal and vertical. Horizontal parameterization is equivalent to TPTs: the interface of the component is parameterized by other data types (as well as by constants). <p> We feel that a more powerful mechanism is required. Our proposed solution is outlined in the next chapter. 20 Nontraditional parameterized types A non-traditional parameterized type (NPT) is a generalization of the TPT. It is based on the GenVoca model (Section 3.1), and Goguens concept of vertical parameterization <ref> [Gog86] </ref>. Application writers use NPTs much as they use TPTs. Our NPTs provide a series of primitive functions (such as INSERT, DELETE, FOREACH...) which augment a high-level language (such as C). With NPTs, a programmer writes a program which consists of standard high-level code, as well as NPT function calls. <p> As mentioned in Section 1.5, GenVoca is derived from two independently-conceived software system generators, Genesis [Bat88, Bat90] and Avoca [Hut91, Oma90]. The foundation for GenVoca has its roots in Parnas families of systems [Par76], Habermanns FAMOS project [Hab76], and Goguens model of parameterized programming <ref> [Gog86, Tra93] </ref>. GenVoca is characterized by realms (or libraries) of plug-compatible components, symmetric components, and type equations. 3.1.1 Components and realms A hierarchical software system is defined by a series of progressively more abstract virtual machines. A component (or layer) is an implementation of a virtual machine. <p> Many of the concepts and techniques we use in this research have also appeared in other research projects. Parameterization is one example. The NPT model is based heavily on parameterization. Goguen has formalized aspects of component design in a model called parameterized programming <ref> [Gog86] </ref>. This model identifies two kinds of parameters: vertical parameters (which specify lower layer components) and horizontal parameters (which correspond to type and constant values).
Reference: [Gol83] <author> A. Goldberg, and D. Robson. </author> <title> Smalltalk-80 The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass, </address> <year> 1983. </year>
Reference-contexts: Object-orientation offers many advantages; it provides a consistent abstraction (the object), allows for reuse via inheritance, and is a well-understood and appreciated paradigm. Many object-oriented systems and languages have been used for data structure programming and libraries. Some of these are Smalltalk <ref> [Gol83] </ref>, C++ [Str91], Modula-3 [Har92], SELF [Cha89], Eiffel [Mey88], and Meldc [Pop91]. All of these suffer from the limitation that they possess no native knowledge about specific problem domains. Thus, they cannot natively perform domain-specific optimizations.
Reference: [Gor87] <author> K. Gorlen. </author> <title> An Object-Oriented Class Library for C++ Programs. </title> <booktitle> USENIX C++ Conference, </booktitle> <year> 1987. </year>
Reference-contexts: LEAPS offers many advantages for emulation: 1. It is a mature project with many performance results published. 2. It is a state-of-the-art system with results that compare favorably against other sys tems in its field [Mir90]. 5. In the near future we hope to add additional libraries <ref> [Gor87, Fon90] </ref> to our benchmark. 87 3. It contains a large number of data structure instances (containers) in its run-time library. 4. It uses many different data structures (schemas) including lists, stacks, predicate indexes, and links. 5. The code that implements LEAPS is very complicated. <p> As such, it is freely available, and has been heavily used and tested. Lea notes the distinctions of libraries (such as OOPS <ref> [Gor87] </ref>) which are based on a single, consistent hierarchy tree of classes; and libraries such as libg++, which are based on a forest of smaller trees of related classes.
Reference: [Gor90] <author> K. Gorlen, S. Orlow, and P. Plexico. </author> <title> Data Abstraction and Object-Oriented Programming in C++. </title> <publisher> John Wiley & Sons, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: Details such as implementation, extensibility and scalability may differ by category, but they all share components as their underlying basis. 1.4.1 Software component libraries Component libraries are perhaps the most common solution to data structure programming. Component libraries can be found almost everywhere today, from stand-alone libraries <ref> [Boo87, Boo90, Gor90] </ref> to libraries that are included with compilers [Bor92] and operating systems [Lea88]. In a component library, many different data structures are represented, each by its own component in the library. These components are atomic and are treated as indivisible units of computation.
Reference: [Gri90] <author> D. Gries, and D. Volpano. </author> <title> The Transform - a New Language Construct. Structured Programming, </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: NPTs, therefore, deal with program transformations. Programmers write data-structure independent algorithms, and specify container implementations as compositions of components. The transformation of programs and data types are done automatically through the use of in-line expansion and partial evaluation. More details on transformational processes can be found in <ref> [Par83, Gri90, Bal85, Coh93] </ref>. Containers are first-class objects. Thus, the more traditional forms of composition, such as that in Figure 2.2 can easily be supported. That is, a list of trees would be represented as follows: a container, which is a binary tree of elements would first be declared. <p> A survey of several early transformation research efforts can be found in [Par83]. Partsch and Seinbrggen describe many relevent research efforts, such as SETL [Sch79], Draco [Nei80, Nei84], and the Programmers Apprentice [Ric79, Ric90]. Gries <ref> [Gri90] </ref> also presents a good formal introduction to transforms as a language construct. The Interface Description Language (IDL) [Sno89] allows users to define a system as a pipeline of tools (or processes), each of which performs a specific task.
Reference: [Haa90] <author> L. Haas et al. </author> <title> Starburst Mid-Flight: As the Dust Clears. </title> <journal> IEEE Transactions of Knowledge and Data Engineering, </journal> <month> March </month> <year> 1990. </year>
Reference-contexts: The reader should not, therefore, infer from this that NPTs are in any way dependent on the C programming language. 21 3.1 The GenVoca model GenVoca is a domain-independent model for defining scalable families of hierarchical systems as compositions of reusable components. Other system generators <ref> [Hei90, Haa90] </ref> also possess organizations similar to GenVoca. As mentioned in Section 1.5, GenVoca is derived from two independently-conceived software system generators, Genesis [Bat88, Bat90] and Avoca [Hut91, Oma90].
Reference: [Hab76] <author> A. Habermann, L. Flon, and L. Cooprider. </author> <title> Modularization and Hierarchy in a Family of Operating Systems. </title> <journal> Communications of the ACM, </journal> <volume> 19(5), </volume> <month> May </month> <year> 1976. </year>
Reference-contexts: Other system generators [Hei90, Haa90] also possess organizations similar to GenVoca. As mentioned in Section 1.5, GenVoca is derived from two independently-conceived software system generators, Genesis [Bat88, Bat90] and Avoca [Hut91, Oma90]. The foundation for GenVoca has its roots in Parnas families of systems [Par76], Habermanns FAMOS project <ref> [Hab76] </ref>, and Goguens model of parameterized programming [Gog86, Tra93]. GenVoca is characterized by realms (or libraries) of plug-compatible components, symmetric components, and type equations. 3.1.1 Components and realms A hierarchical software system is defined by a series of progressively more abstract virtual machines.
Reference: [Har92] <author> S. Harbison. </author> <title> Modula-3. </title> <publisher> Prentice-Hall, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: Object-orientation offers many advantages; it provides a consistent abstraction (the object), allows for reuse via inheritance, and is a well-understood and appreciated paradigm. Many object-oriented systems and languages have been used for data structure programming and libraries. Some of these are Smalltalk [Gol83], C++ [Str91], Modula-3 <ref> [Har92] </ref>, SELF [Cha89], Eiffel [Mey88], and Meldc [Pop91]. All of these suffer from the limitation that they possess no native knowledge about specific problem domains. Thus, they cannot natively perform domain-specific optimizations. We have also detailed, in Chapter 2, the compositional difficulties object-oriented approaches possess when dealing with complex compositions.
Reference: [Hei90] <author> J. Heidemann, and G. Popek. </author> <title> An extensible, stackable method of file system development. </title> <type> Technical Report CSD-9000044, </type> <institution> University of California, </institution> <address> Los Angeles, </address> <month> December </month> <year> 1990. </year>
Reference-contexts: The subject of software architectures is gaining importance [Gar93]. Software architectures deal with the scalability issues of programming-in-the-large. GenVoca is but one approach to create scalable domain-specific software architectures <ref> [Hei90, Hei91, Cam92, Wei90] </ref>. It is a model of hierarchical software construction that has been used in software generators for a variety of rather disparate domains (databases [Bat88, Bat90], network communication [Hut91, Oma90], and avionics [Cog93]). <p> The reader should not, therefore, infer from this that NPTs are in any way dependent on the C programming language. 21 3.1 The GenVoca model GenVoca is a domain-independent model for defining scalable families of hierarchical systems as compositions of reusable components. Other system generators <ref> [Hei90, Haa90] </ref> also possess organizations similar to GenVoca. As mentioned in Section 1.5, GenVoca is derived from two independently-conceived software system generators, Genesis [Bat88, Bat90] and Avoca [Hut91, Oma90]. <p> ADAGE [Cog93] is a GenVoca-based system in the domain of avionics software. Finally, FICUS <ref> [Hei90, Hei91] </ref> provides a layered approach for customizing file systems which is based on concepts similar to those in GenVoca. 118 Evaluation This chapter presents an assessment of our research. As documented in Chapter 5, we feel that we have achieved our major goals.
Reference: [Hei91] <author> J. Heidemann, and G. Popek. </author> <title> A layered approach to file system development. </title> <type> Technical Report CSD-910007, </type> <institution> University of California, </institution> <address> Los Angeles, </address> <month> March </month> <year> 1991. </year>
Reference-contexts: The subject of software architectures is gaining importance [Gar93]. Software architectures deal with the scalability issues of programming-in-the-large. GenVoca is but one approach to create scalable domain-specific software architectures <ref> [Hei90, Hei91, Cam92, Wei90] </ref>. It is a model of hierarchical software construction that has been used in software generators for a variety of rather disparate domains (databases [Bat88, Bat90], network communication [Hut91, Oma90], and avionics [Cog93]). <p> ADAGE [Cog93] is a GenVoca-based system in the domain of avionics software. Finally, FICUS <ref> [Hei90, Hei91] </ref> provides a layered approach for customizing file systems which is based on concepts similar to those in GenVoca. 118 Evaluation This chapter presents an assessment of our research. As documented in Chapter 5, we feel that we have achieved our major goals. <p> Thus, existing components would not need to ever have any knowledge of these new functions; as the compiler and the layer would be responsible for generating the correct behavior. This dynamic extension of the realm interface is also the solution used in similar system generators for other domains <ref> [Hut91, Hei91, Pag90] </ref>. Self-referential links. In Chapter 5, we mentioned the lack of self-referential links. That is, the composite cursor declaration syntax we defined did not allow for more than one reference to be made to a particular cursor/container pair.
Reference: [Hor84] <author> E. Horowitz, and J. Munson. </author> <title> An Expansive View of Reusable Software. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(5):477-487, </volume> <month> September </month> <year> 1984. </year>
Reference-contexts: This makes it difficult to later modify the data structure and its code. (Modifications are often needed to add features and enhance performance). This is a problem of maintenance and evolution <ref> [Hor84] </ref>. Some projects [Sno89] have features which specifically aid program maintenance and evolution, but which also make other phases of programming more difficult. Our goal is to provide a standardized, high-level interface for our components to increase reuse and allows for simpler system evolution.
Reference: [Hut91] <author> N. Hutchinson, and L. Peterson. </author> <title> The x-kernel: an architecture for implementing network protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1), </volume> <month> January </month> <year> 1991. </year>
Reference-contexts: GenVoca is but one approach to create scalable domain-specific software architectures [Hei90, Hei91, Cam92, Wei90]. It is a model of hierarchical software construction that has been used in software generators for a variety of rather disparate domains (databases [Bat88, Bat90], network communication <ref> [Hut91, Oma90] </ref>, and avionics [Cog93]). Its key feature is that it exploits the maturity of domains by standardizing their fundamental abstractions, and then standardiz 7 ing the way in which software systems of the domain are built from these abstractions. <p> Other system generators [Hei90, Haa90] also possess organizations similar to GenVoca. As mentioned in Section 1.5, GenVoca is derived from two independently-conceived software system generators, Genesis [Bat88, Bat90] and Avoca <ref> [Hut91, Oma90] </ref>. The foundation for GenVoca has its roots in Parnas families of systems [Par76], Habermanns FAMOS project [Hab76], and Goguens model of parameterized programming [Gog86, Tra93]. <p> This makes TPT specialization significantly easier. 5. Evidence to support this statement also comes from network protocols where a simple and standardized interface has worked well for the x-Kernel <ref> [Pet90, Hut91, OMa90] </ref>. 41 As an example, a simple (push, pop) interface to a stack container is shown below: MACRO push (container, element) - INSERT (container, element, container.stack_head, AT_END); -; MACRO pop (container, element) - if (!is_empty (container)) - GETREC (element, container.stack_head)); DELETE (container.stack_head); REVERSE (container.stack_head); - It has been our <p> Thus, existing components would not need to ever have any knowledge of these new functions; as the compiler and the layer would be responsible for generating the correct behavior. This dynamic extension of the realm interface is also the solution used in similar system generators for other domains <ref> [Hut91, Hei91, Pag90] </ref>. Self-referential links. In Chapter 5, we mentioned the lack of self-referential links. That is, the composite cursor declaration syntax we defined did not allow for more than one reference to be made to a particular cursor/container pair.
Reference: [Kai89] <author> G. Kaiser, and D. Garlan. </author> <title> Synthesizing Programming Environments From Reusable Features. In Software Reusability, Vol II, Applications and Experience, </title> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: Elements stored within a data structure seldom exist in isolation. Real systems often have elements in one structure linked to elements in other data structures (e.g. via pointers). 1. The name resolution problem is unresolved, with several possible solutions <ref> [Kai89] </ref>. 2. This is particularly true in the case where the same component is inherited multiple times. Tree pointers List pointers Root of tree Head of list 16 is connected to the employees in that department via a link.
Reference: [Kic92] <author> G. Kiczales, and J. Lamping. </author> <title> Issues in the Design and Specification of Class Libraries. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming: Systems, Languages, and Applications 92, </booktitle> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: We do not support dynamic realm creation. 6.2 Software component libraries There are many software component libraries currently available, and creating a good component library is a complex task <ref> [Kic92] </ref>. A large subset of available libraries implement data structure components. In this section we will discuss two of them. The Booch components are a set of monolithic data structure components. The original set of components [Boo87] were written in Ada.
Reference: [Kor91] <author> H. Korth, and A. Silberschatz. </author> <title> Database System Concepts. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: Our interface for DS largely reects work performed in databases <ref> [Bat88, Bat90, Kor91] </ref> and persistent object bases [Lam91]. It is high-level, in that the interface provides little more than basic relational operations. <p> It is crucial that our compiler generate efficient data structure code. The compiler is responsible for generating only the code necessary for the declared operations. Unlike more traditional database systems <ref> [Kor91, Bat90, Bat93b] </ref>, NPT-generated code is not general. It is geared specifically for the type equation of a particular container, and incurs only the overhead for the mechanisms to support the primitive functions used in a given application. <p> Moreover, each container is adorned with a header field to another linked list, which identifies elements which participate in the join (This, in effect, implements a semijoin <ref> [Kor91] </ref> of that container with the other container). <p> AP5 also supports invariants through consistency rules, which are stated invariants coupled with repair actions to be taken if the invariant is violated. While the basis of AP5 is relational, the syntax is lisp-based and does not resemble classical relational database syntax <ref> [Kor91] </ref>. AP5 relies on the concept of the fact, which is a LISP list, where the car of the list is the relation name, and the cdr of the list is the data for the tuple.
Reference: [Kru92] <author> C. Krueger. </author> <title> Software Reuse. </title> <journal> ACM Computing Surveys, </journal> <volume> 24(2), </volume> <month> June </month> <year> 1992. </year>
Reference-contexts: Further, since this task is fairly general, many of the proposed solutions for automation have come from different research communities, such as reuse, software components, object orientation, transformation systems, and persistent object bases <ref> [Kru92, Par83, Lam91] </ref>. While many of the proposed solutions have merit, most have concentrated on one area of software engineering, thereby not including useful features from others. Eliminating the drudgery of programming data structures is clearly an important, but still unsolved, problem. <p> Every legal combination of features yields a distinct data structure. Because there are many possible combinations, it is not surprising that this library is large. Feature combinatorics are inherent to all libraries <ref> [Kru92] </ref>. Such libraries are inherently unscalable, simply because the number of features that programmers need is open-ended. Moreover, library components are typically written by hand, with occasional use of inheritance to minimize gross code replication. <p> Finally, we mention several projects which are related to ours in that they use the GenVoca domain modelling concepts. 6.1 Software reuse A comprehensive exploration of software reuse was made by Krueger <ref> [Kru92] </ref>. He proposes a taxonomy of five key attributes which are claimed to be common to all software reuse approaches: 1. The artifacts the approach uses. 2. How the artifacts are abstracted into usable features. 3. Selection defines how the software reuser can find usable artifacts to reuse. 4.
Reference: [Lam91] <author> C. Lamb, G. Landis, J. Orenstein, and D. Weinreb. </author> <title> The ObjectStore Database System. </title> <journal> Communications of the ACM, </journal> <month> October </month> <year> 1991. </year> <month> 135 </month>
Reference-contexts: Further, since this task is fairly general, many of the proposed solutions for automation have come from different research communities, such as reuse, software components, object orientation, transformation systems, and persistent object bases <ref> [Kru92, Par83, Lam91] </ref>. While many of the proposed solutions have merit, most have concentrated on one area of software engineering, thereby not including useful features from others. Eliminating the drudgery of programming data structures is clearly an important, but still unsolved, problem. <p> In fact, if one looks at commercially available data structure programming aids <ref> [Boo87, Lea88, Boo90, Lam91] </ref>, no one approach seems to dominate over any other. The subject of software architectures is gaining importance [Gar93]. Software architectures deal with the scalability issues of programming-in-the-large. GenVoca is but one approach to create scalable domain-specific software architectures [Hei90, Hei91, Cam92, Wei90]. <p> While those concepts will be fully explored later in this dissertation, a few will be mentioned here: 1. We have included a consistent, high level interface often found in persistent object bases <ref> [Lam91] </ref> and databases [Acm91, Bat88, Bat90, Dat83]. 2. Our system relies heavily on compiler and transformation technology. Our components are always created dynamically to suit the particular data structures and operations needed. 3. Utilizing compiler technology also allows us to extensively explore the area of domain-specific optimizations. <p> Our interface for DS largely reects work performed in databases [Bat88, Bat90, Kor91] and persistent object bases <ref> [Lam91] </ref>. It is high-level, in that the interface provides little more than basic relational operations. The following table lists the primary operations of the DS realm interface: Table 3.1: DS realm interface Function Call Meaning INSERT (k, o, c [, h]) Insert object o into container k.
Reference: [Lea88] <author> D. Lea. libg++, </author> <title> The GNU C++ Library. </title> <booktitle> USENIX C++ Conference, </booktitle> <year> 1988. </year>
Reference-contexts: Component libraries can be found almost everywhere today, from stand-alone libraries [Boo87, Boo90, Gor90] to libraries that are included with compilers [Bor92] and operating systems <ref> [Lea88] </ref>. In a component library, many different data structures are represented, each by its own component in the library. These components are atomic and are treated as indivisible units of computation. Each component presents its interface to the outside world. <p> In fact, if one looks at commercially available data structure programming aids <ref> [Boo87, Lea88, Boo90, Lam91] </ref>, no one approach seems to dominate over any other. The subject of software architectures is gaining importance [Gar93]. Software architectures deal with the scalability issues of programming-in-the-large. GenVoca is but one approach to create scalable domain-specific software architectures [Hei90, Hei91, Cam92, Wei90]. <p> We feel it is crucial that our NPT design avoid the combinatorics problems presented by libraries such as <ref> [Boo87, Lea88, Boo90] </ref>. Our NPT layering structure has been specifically designed so that all of the NPT layers are effectively orthogonal to other layers within the same realm. <p> Words which are not found are then printed out to standard output. Standard input and output routines were written, and used in each of the programs. Three different library systems (Booch components for C++ [Boo90], libg++ <ref> [Lea88] </ref>, and Pred 85 ator) were benchmarked. Each of the systems was benchmarked against unsorted and sorted arrays, unordered lists, and ordered binary trees. The Predator source of the array version can be found in Appendix D. <p> Specifically, the component interfaces are not consistent, the Booch model does not allow for arbitrary compositions, the performance (as seen in Section 5.3) is not competitive with other TPT libraries, and the library is not scalable [Bat93a]. libg++ is another C++-based component library <ref> [Lea88] </ref>. libg++ is a collection of classes and support tools that is part of the GNU 1 tools distribution. As such, it is freely available, and has been heavily used and tested. <p> We also feel that our work has made contributions in the understanding of the scalability of component libraries. We estimate that it would take approximately 40 NPT components to provide equivalent functionality of component libraries <ref> [Boo90, Lea88] </ref> which contain 400 components, or more. Further, the vertical parameterization of NPTs would allow those 40 components to be composed into additional structures which do not exist in those other libraries.
Reference: [McD78a] <author> J. McDermot, A. Newall, and J. Moore. </author> <title> The efficiency of Certain Production Systems. Pattern Directed Inference Systems, </title> <editor> Waterman, Hayes, Roth (ed), </editor> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: It is a mature system, which is used widely in the AI community. OPS5 is a mature language, and LEAPS is but one of many approaches <ref> [McD78a, McD78b] </ref> designed to evaluate OPS5 programs. OPS5 syntax is based on LISP, and OPS5 is a dynamically-typed language. This has serious ramifications which will be explained later. For now, we will only discuss statically-typed issues of OPS5.
Reference: [McD78b] <author> J. McDermott, and C. Forgy. </author> <title> Production System Conict Resolution Strategies. Pattern Directed Inference Systems, </title> <editor> Waterman, Hayes, Roth (ed), </editor> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: It is a mature system, which is used widely in the AI community. OPS5 is a mature language, and LEAPS is but one of many approaches <ref> [McD78a, McD78b] </ref> designed to evaluate OPS5 programs. OPS5 syntax is based on LISP, and OPS5 is a dynamically-typed language. This has serious ramifications which will be explained later. For now, we will only discuss statically-typed issues of OPS5.
Reference: [McN86a] <author> D. McNicoll, C. Palmer, et al. </author> <title> Common Ada Missile Packages (CAMP) Volume I: Overview and Commonality Study Results. </title> <address> AFATL-TR-85-93, </address> <month> May </month> <year> 1986. </year>
Reference-contexts: We feel that components provided to a programmer must be able to be specialized easily and without much knowledge of the inner workings of the TPTs. 2.2.2 Complex compositions It is widely believed that TPTs are the appropriate abstraction for encapsulating primitive data structures <ref> [Boo87, McN86a, McN86b, Pal90] </ref>. More complex structures are assumed to be created through TPT compositions. This is the case for the data structure depicted in Many data structures that are used in practice are unlikely to be available in TPT libraries.
Reference: [McN86b] <author> D. McNicoll, C. Palmer, et al. </author> <title> Common Ada Missile Packages (CAMP) Volume II: Software Parts Composition Study Results. </title> <address> AFATL-TR-85-93, </address> <month> May </month> <year> 1986. </year>
Reference-contexts: We feel that components provided to a programmer must be able to be specialized easily and without much knowledge of the inner workings of the TPTs. 2.2.2 Complex compositions It is widely believed that TPTs are the appropriate abstraction for encapsulating primitive data structures <ref> [Boo87, McN86a, McN86b, Pal90] </ref>. More complex structures are assumed to be created through TPT compositions. This is the case for the data structure depicted in Many data structures that are used in practice are unlikely to be available in TPT libraries.
Reference: [Mey88] <author> B. Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice-Hall, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: Many object-oriented systems and languages have been used for data structure programming and libraries. Some of these are Smalltalk [Gol83], C++ [Str91], Modula-3 [Har92], SELF [Cha89], Eiffel <ref> [Mey88] </ref>, and Meldc [Pop91]. All of these suffer from the limitation that they possess no native knowledge about specific problem domains. Thus, they cannot natively perform domain-specific optimizations. We have also detailed, in Chapter 2, the compositional difficulties object-oriented approaches possess when dealing with complex compositions.
Reference: [Mir90] <author> D. Miranker, D. Brant, B. Lofaso, and D. Gadbois. </author> <title> On the Performance of Lazy Matching in Production Systems. </title> <booktitle> In Proceedings of the 1990 National Conference on Artificial Intelligence, </booktitle> <pages> pages 685-692, </pages> <year> 1990. </year>
Reference-contexts: We selected the LEAPS production system compiler project. LEAPS <ref> [Mir90, Mir91] </ref> (Lazy Evaluation Algorithm for ExPert Systems) is a production systems compiler which converts OPS5 rule sets into a C-language program, which can then be compiled, linked, and run. <p> The executable can then be run against initial data sets. LEAPS offers many advantages for emulation: 1. It is a mature project with many performance results published. 2. It is a state-of-the-art system with results that compare favorably against other sys tems in its field <ref> [Mir90] </ref>. 5. In the near future we hope to add additional libraries [Gor87, Fon90] to our benchmark. 87 3. It contains a large number of data structure instances (containers) in its run-time library. 4. It uses many different data structures (schemas) including lists, stacks, predicate indexes, and links. 5.
Reference: [Mir91] <author> D. Miranker, and B. Lofaso. </author> <title> The Organization and Performance of a TREAT-Based Production System Compiler. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <pages> pages 42-48, </pages> <year> 1991. </year>
Reference-contexts: We selected the LEAPS production system compiler project. LEAPS <ref> [Mir90, Mir91] </ref> (Lazy Evaluation Algorithm for ExPert Systems) is a production systems compiler which converts OPS5 rule sets into a C-language program, which can then be compiled, linked, and run.
Reference: [Nei80] <author> J. Neighbors. </author> <title> Software Construction Using Components. </title> <type> Ph.D. dissertation, Technical Report 160, </type> <institution> University of California, Irvine, </institution> <year> 1980. </year>
Reference-contexts: There are many examples of transformation systems both within and without the data structure domain. A survey of several early transformation research efforts can be found in [Par83]. Partsch and Seinbrggen describe many relevent research efforts, such as SETL [Sch79], Draco <ref> [Nei80, Nei84] </ref>, and the Programmers Apprentice [Ric79, Ric90]. Gries [Gri90] also presents a good formal introduction to transforms as a language construct. The Interface Description Language (IDL) [Sno89] allows users to define a system as a pipeline of tools (or processes), each of which performs a specific task.
Reference: [Nei84] <author> J. Neighbors. </author> <title> The Draco Approach to Constructing Software from Reusable Components. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> WE-10(5): </volume> <pages> 564-574, </pages> <month> Sep-tember </month> <year> 1984. </year>
Reference-contexts: There are many examples of transformation systems both within and without the data structure domain. A survey of several early transformation research efforts can be found in [Par83]. Partsch and Seinbrggen describe many relevent research efforts, such as SETL [Sch79], Draco <ref> [Nei80, Nei84] </ref>, and the Programmers Apprentice [Ric79, Ric90]. Gries [Gri90] also presents a good formal introduction to transforms as a language construct. The Interface Description Language (IDL) [Sno89] allows users to define a system as a pipeline of tools (or processes), each of which performs a specific task.
Reference: [Nov83] <author> G. Novak. </author> <title> GLISP: A LISP-Based Programming System with Data Abstraction. </title> <journal> AI Magazine, </journal> <volume> 4(3): </volume> <pages> 37-47, </pages> <month> Fall </month> <year> 1983. </year>
Reference-contexts: Transformation systems are characterized by the transformations they perform on components to create new components which are tailored to the data structure or environment desired. Examples of data structure transformation systems include <ref> [Sno89, Coh89, Coh93, Nov83, Nov92] </ref>. The chief feature which distinguishes transformation systems from library approaches is their ability to dynamically alter their components as needed. This exibility allows them, in principle, to be more task-specific, and hence more efficient. <p> The assertion capability is also restricted to the IDL I/O data types; data cannot be asserted while it is being manipulated by a task, only after it has been output from one stage and before it is input to the next. GLISP <ref> [Nov83, Nov92] </ref> is a transformation system which allows generic procedures to be specialized through a concept known as view clusters. View clusters are similar to NPT type equation instantiations, except that view clusters are not layered.
Reference: [Nov92] <author> G. Novak. </author> <title> Software Reuse through View Type Clusters. </title> <booktitle> In Proceedings of the 7th Knowledge-Based Software Engineering Conference (KBSE-92), </booktitle> <year> 1992. </year>
Reference-contexts: Transformation systems are characterized by the transformations they perform on components to create new components which are tailored to the data structure or environment desired. Examples of data structure transformation systems include <ref> [Sno89, Coh89, Coh93, Nov83, Nov92] </ref>. The chief feature which distinguishes transformation systems from library approaches is their ability to dynamically alter their components as needed. This exibility allows them, in principle, to be more task-specific, and hence more efficient. <p> This means that the TPT interface for lists is (typically) different from that of arrays, binary trees, etc. When an application program is written using a specific TPT, it is often difficult to change the underlying data structure (TPT) without triggering a substantial rewrite <ref> [Nov92] </ref>. While changing from a static array to a dynamic linked list may not be too difficult, going to a more complex structure entails considerable effort. <p> This introduces an additional run-time overhead for resolving inter-TPT references. Another method of implementation is macro expansion, which is not always sufficient to provide efficient code <ref> [Nov92] </ref>. We feel that these composition mechanisms, by themselves, do not generate sufficiently efficient code. <p> The assertion capability is also restricted to the IDL I/O data types; data cannot be asserted while it is being manipulated by a task, only after it has been output from one stage and before it is input to the next. GLISP <ref> [Nov83, Nov92] </ref> is a transformation system which allows generic procedures to be specialized through a concept known as view clusters. View clusters are similar to NPT type equation instantiations, except that view clusters are not layered.
Reference: [OMa90] <author> S. OMalley, and L. Peterson. </author> <title> A new methodology for designing network software. </title> <type> Technical Report 90-29, </type> <institution> University of Arizona, </institution> <month> September </month> <year> 1990. </year>
Reference-contexts: GenVoca is but one approach to create scalable domain-specific software architectures [Hei90, Hei91, Cam92, Wei90]. It is a model of hierarchical software construction that has been used in software generators for a variety of rather disparate domains (databases [Bat88, Bat90], network communication <ref> [Hut91, Oma90] </ref>, and avionics [Cog93]). Its key feature is that it exploits the maturity of domains by standardizing their fundamental abstractions, and then standardiz 7 ing the way in which software systems of the domain are built from these abstractions. <p> Other system generators [Hei90, Haa90] also possess organizations similar to GenVoca. As mentioned in Section 1.5, GenVoca is derived from two independently-conceived software system generators, Genesis [Bat88, Bat90] and Avoca <ref> [Hut91, Oma90] </ref>. The foundation for GenVoca has its roots in Parnas families of systems [Par76], Habermanns FAMOS project [Hab76], and Goguens model of parameterized programming [Gog86, Tra93]. <p> This makes TPT specialization significantly easier. 5. Evidence to support this statement also comes from network protocols where a simple and standardized interface has worked well for the x-Kernel <ref> [Pet90, Hut91, OMa90] </ref>. 41 As an example, a simple (push, pop) interface to a stack container is shown below: MACRO push (container, element) - INSERT (container, element, container.stack_head, AT_END); -; MACRO pop (container, element) - if (!is_empty (container)) - GETREC (element, container.stack_head)); DELETE (container.stack_head); REVERSE (container.stack_head); - It has been our <p> The concepts for GenVoca are based on two independent projects; Genesis [Bat88, Bat90], which is a generator of database systems, and Avoca <ref> [Oma90] </ref>, which is a generator of network protocols. Despite the radically different domains for the two projects, it was observed that they approached the generation of software systems in a similar manner. A number of subsequent projects have embraced the GenVoca approach.
Reference: [Pag90] <author> T. Page, G. Popek, R. Guy, and J. Heidemann. </author> <title> The Ficus Distributed File System: Replication via Stackable Layers. </title> <type> Technical Report CSD-900009, </type> <institution> University of California, </institution> <address> Los Angeles, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: Thus, existing components would not need to ever have any knowledge of these new functions; as the compiler and the layer would be responsible for generating the correct behavior. This dynamic extension of the realm interface is also the solution used in similar system generators for other domains <ref> [Hut91, Hei91, Pag90] </ref>. Self-referential links. In Chapter 5, we mentioned the lack of self-referential links. That is, the composite cursor declaration syntax we defined did not allow for more than one reference to be made to a particular cursor/container pair.
Reference: [Pal90] <author> C. Palmer, and S. Cohen. </author> <title> Engineering and Applications of Reusable Software Resources. Aerospace Software Engineering: A Collection of Concepts, </title> <editor> ed. C. Anderson and M. Dorfman. </editor> <volume> Vol. 136, </volume> <booktitle> Progress in Astronautics and Aeronautics, </booktitle> <year> 1990. </year>
Reference-contexts: We feel that components provided to a programmer must be able to be specialized easily and without much knowledge of the inner workings of the TPTs. 2.2.2 Complex compositions It is widely believed that TPTs are the appropriate abstraction for encapsulating primitive data structures <ref> [Boo87, McN86a, McN86b, Pal90] </ref>. More complex structures are assumed to be created through TPT compositions. This is the case for the data structure depicted in Many data structures that are used in practice are unlikely to be available in TPT libraries.
Reference: [Par76] <author> D. Parnas. </author> <title> On the Design and Development of Program Families. </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> March </month> <year> 1976. </year> <month> 136 </month>
Reference-contexts: Other system generators [Hei90, Haa90] also possess organizations similar to GenVoca. As mentioned in Section 1.5, GenVoca is derived from two independently-conceived software system generators, Genesis [Bat88, Bat90] and Avoca [Hut91, Oma90]. The foundation for GenVoca has its roots in Parnas families of systems <ref> [Par76] </ref>, Habermanns FAMOS project [Hab76], and Goguens model of parameterized programming [Gog86, Tra93]. GenVoca is characterized by realms (or libraries) of plug-compatible components, symmetric components, and type equations. 3.1.1 Components and realms A hierarchical software system is defined by a series of progressively more abstract virtual machines.
Reference: [Par83] <author> H. Partsch, and R. Steinbrggen. </author> <title> Program Transformation Systems. </title> <journal> In ACM Computing Surveys, </journal> <volume> 15(3) </volume> <pages> 199-236, </pages> <year> 1983. </year>
Reference-contexts: Further, since this task is fairly general, many of the proposed solutions for automation have come from different research communities, such as reuse, software components, object orientation, transformation systems, and persistent object bases <ref> [Kru92, Par83, Lam91] </ref>. While many of the proposed solutions have merit, most have concentrated on one area of software engineering, thereby not including useful features from others. Eliminating the drudgery of programming data structures is clearly an important, but still unsolved, problem. <p> NPTs, therefore, deal with program transformations. Programmers write data-structure independent algorithms, and specify container implementations as compositions of components. The transformation of programs and data types are done automatically through the use of in-line expansion and partial evaluation. More details on transformational processes can be found in <ref> [Par83, Gri90, Bal85, Coh93] </ref>. Containers are first-class objects. Thus, the more traditional forms of composition, such as that in Figure 2.2 can easily be supported. That is, a list of trees would be represented as follows: a container, which is a binary tree of elements would first be declared. <p> There are many examples of transformation systems both within and without the data structure domain. A survey of several early transformation research efforts can be found in <ref> [Par83] </ref>. Partsch and Seinbrggen describe many relevent research efforts, such as SETL [Sch79], Draco [Nei80, Nei84], and the Programmers Apprentice [Ric79, Ric90]. Gries [Gri90] also presents a good formal introduction to transforms as a language construct.
Reference: [Pet90] <author> L. Peterson, N. Hutchinson, H. Rao, and S. OMalley. </author> <title> The x-kernel: A Platform for Accessing Internet Resources. </title> <journal> IEEE Computer (Special Issue on Operating Systems), </journal> <month> May </month> <year> 1990. </year>
Reference-contexts: This makes TPT specialization significantly easier. 5. Evidence to support this statement also comes from network protocols where a simple and standardized interface has worked well for the x-Kernel <ref> [Pet90, Hut91, OMa90] </ref>. 41 As an example, a simple (push, pop) interface to a stack container is shown below: MACRO push (container, element) - INSERT (container, element, container.stack_head, AT_END); -; MACRO pop (container, element) - if (!is_empty (container)) - GETREC (element, container.stack_head)); DELETE (container.stack_head); REVERSE (container.stack_head); - It has been our
Reference: [Pop91] <author> S. Popovich, S. Wu, and G. Kaiser. </author> <title> An Object-Based Approach to Implementing Distributed Concurrency Control. </title> <booktitle> In 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 65-72, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Many object-oriented systems and languages have been used for data structure programming and libraries. Some of these are Smalltalk [Gol83], C++ [Str91], Modula-3 [Har92], SELF [Cha89], Eiffel [Mey88], and Meldc <ref> [Pop91] </ref>. All of these suffer from the limitation that they possess no native knowledge about specific problem domains. Thus, they cannot natively perform domain-specific optimizations. We have also detailed, in Chapter 2, the compositional difficulties object-oriented approaches possess when dealing with complex compositions.
Reference: [Pri86] <author> R. Prieto-Daz, and J. Neighbors. </author> <title> Module interconnection languages. </title> <journal> Journal of Systems and Software, </journal> <volume> 6(4) </volume> <pages> 307-334, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: Thus, we feel there are limitations on scalability, complex compositions, and type transformations that it can perform. 6.4 Other approaches The fields of software reuse and data structure programming are vast. This section briey describes several other approaches researchers have investigated in these areas. Module Interconnection Languages <ref> [Pri86, Raj89] </ref> are another approach to the data structure programming problem. MILs concentrate on defining the interfaces of software components, how to import and export the interfaces, and how to interconnect the components together to form a new, higher-level component.
Reference: [Pri91] <author> R. Prieto-Daz, and G. Arango. </author> <title> Domain Analysis and Software Systems Modeling. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: Eliminating the drudgery of programming data structures is clearly an important, but still unsolved, problem. Our thesis is that a practical solution rests on a software component technology that integrates concepts of parameterized types, standardized interfaces, domain modelling, and compiler optimizations <ref> [Bat92a, Sir93, Pri91] </ref>. Integration of these concepts is both technically challenging and a fertile area of research. More importantly, it leads to a technology for assembling complex data structures from pre-written and standardized components.
Reference: [Raj89] <author> R. Raj, and H. Levy. </author> <title> A Compositional Model for Software Reuse. </title> <journal> The Computer Journal. </journal> <volume> 32(4), </volume> <month> August </month> <year> 1989. </year>
Reference-contexts: To a large degree, e this is borne out by Kruegers measurements which, overall, rank application generators, transformational systems, and software architectures as among the best approaches for minimizing cognitive distance. A slightly different, but also useful view of reuse can be found in <ref> [Raj89] </ref>. Raj concentrates on object-oriented languages and software reuse. His thesis is that inheritance-based schemes of software reuse are often inadequate. He advocates, instead, a compositional method of component creation for such systems. <p> Thus, we feel there are limitations on scalability, complex compositions, and type transformations that it can perform. 6.4 Other approaches The fields of software reuse and data structure programming are vast. This section briey describes several other approaches researchers have investigated in these areas. Module Interconnection Languages <ref> [Pri86, Raj89] </ref> are another approach to the data structure programming problem. MILs concentrate on defining the interfaces of software components, how to import and export the interfaces, and how to interconnect the components together to form a new, higher-level component.
Reference: [Ric79] <author> C. Rich, H. Shrobe, and R. Waters. </author> <title> Overview of the Programmers Apprentice. </title> <booktitle> In Proceedings of 6th International Joint Conference on Artificial Intelligence, </booktitle> <year> 1979. </year>
Reference-contexts: There are many examples of transformation systems both within and without the data structure domain. A survey of several early transformation research efforts can be found in [Par83]. Partsch and Seinbrggen describe many relevent research efforts, such as SETL [Sch79], Draco [Nei80, Nei84], and the Programmers Apprentice <ref> [Ric79, Ric90] </ref>. Gries [Gri90] also presents a good formal introduction to transforms as a language construct. The Interface Description Language (IDL) [Sno89] allows users to define a system as a pipeline of tools (or processes), each of which performs a specific task.
Reference: [Ric90] <author> C. Rich, and R. Waters. </author> <title> The Programmers Apprentice. </title> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: There are many examples of transformation systems both within and without the data structure domain. A survey of several early transformation research efforts can be found in [Par83]. Partsch and Seinbrggen describe many relevent research efforts, such as SETL [Sch79], Draco [Nei80, Nei84], and the Programmers Apprentice <ref> [Ric79, Ric90] </ref>. Gries [Gri90] also presents a good formal introduction to transforms as a language construct. The Interface Description Language (IDL) [Sno89] allows users to define a system as a pipeline of tools (or processes), each of which performs a specific task.
Reference: [Roy91] <author> J. Roy. </author> <title> Design and Use of the Jupiter File Management System. M.Sc. </title> <type> Thesis, </type> <institution> Department of Computer Sciences, University of Texas, </institution> <year> 1991. </year>
Reference-contexts: While this number is huge in comparison to the RL equivalent, it can mostly be dismissed. DATEX utilizes persistency via the JUPITER module of the GENESIS database system <ref> [Roy91] </ref>. JUPITER is a general purpose system, which is not particularly efficient. Thus, comparing it performance-wise to a simple memory-map is not particularly meaningful. It is interesting, however, to see how long it took to add persistency to both LEAPS and RL.
Reference: [Sch77] <author> J. Schmidt. </author> <title> Some High Level Language Constructs for Data of Type Relation. </title> <journal> ACM Transactions on Database Systems, </journal> <year> 1977. </year>
Reference-contexts: This can be performed with NPTs simply by placing a relatively thin veneer on top of a container. The programming language Pascal/R <ref> [Sch77] </ref>, for example, allowed users to customize the interface to relations by letting them place their own ADT interfaces on top of relations and to implement ADT operations as calls to relational operators.
Reference: [Sch79] <author> E. Schonberg, J. Schwartz, and M. Sharir. </author> <title> Automatic Data Structure Selection in SETL. </title> <booktitle> In Proceedings of 6th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 197-210, </pages> <year> 1979. </year>
Reference-contexts: There are many examples of transformation systems both within and without the data structure domain. A survey of several early transformation research efforts can be found in [Par83]. Partsch and Seinbrggen describe many relevent research efforts, such as SETL <ref> [Sch79] </ref>, Draco [Nei80, Nei84], and the Programmers Apprentice [Ric79, Ric90]. Gries [Gri90] also presents a good formal introduction to transforms as a language construct. The Interface Description Language (IDL) [Sno89] allows users to define a system as a pipeline of tools (or processes), each of which performs a specific task.
Reference: [Sin93] <author> V. Singhal, and D. Batory. </author> <title> P++: A Language for Software System Generators. </title> <type> Technical Report, </type> <institution> Department of Computer Sciences, University of Texas at Aus-tin, </institution> <month> September </month> <year> 1993. </year>
Reference-contexts: Thus, they cannot natively perform domain-specific optimizations. We have also detailed, in Chapter 2, the compositional difficulties object-oriented approaches possess when dealing with complex compositions. In recognition of these lacks, we are investigating a system which combines object-oriented programming and our NPTs <ref> [Sin93] </ref>. Many of the concepts and techniques we use in this research have also appeared in other research projects. Parameterization is one example. The NPT model is based heavily on parameterization. Goguen has formalized aspects of component design in a model called parameterized programming [Gog86]. <p> A number of subsequent projects have embraced the GenVoca approach. In the domain of data structures, both this work (Predator) and Predator-2 (P2) [Bat93a] address the generation of efficient data structure code. P++ <ref> [Sin93] </ref> provides an extension of the C++ language which allows definition and combination of realms and components, based on the lessons learned from Predator. [Abb92] describes a protocol customization compiler which is based on the Avoca project and bears many similarities to the Predator system. <p> We see our regular framework as a crucial base to allow NPT systems to be maintained and to evolve. A major achievement of our work has been to lay the foundation which is making P++ <ref> [Sin93] </ref> possible. P++ is a set of extensions to the C++ language, which should enable programmers to construct GenVoca system generators much more easily. In a sense, P++ will be a 131 generator of system generators. P++ borrows heavily on the lessons learned from this research.
Reference: [Sir93] <author> M. Sirkin, D. Batory, and V. Singhal. </author> <title> Software components in a data structure pre-compiler. </title> <booktitle> In Proceedings of the 15th International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: Eliminating the drudgery of programming data structures is clearly an important, but still unsolved, problem. Our thesis is that a practical solution rests on a software component technology that integrates concepts of parameterized types, standardized interfaces, domain modelling, and compiler optimizations <ref> [Bat92a, Sir93, Pri91] </ref>. Integration of these concepts is both technically challenging and a fertile area of research. More importantly, it leads to a technology for assembling complex data structures from pre-written and standardized components.
Reference: [Sno89] <author> R. Snodgrass. </author> <title> The Interface Description Language, 2nd edition. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass, </address> <year> 1989. </year>
Reference-contexts: This makes it difficult to later modify the data structure and its code. (Modifications are often needed to add features and enhance performance). This is a problem of maintenance and evolution [Hor84]. Some projects <ref> [Sno89] </ref> have features which specifically aid program maintenance and evolution, but which also make other phases of programming more difficult. Our goal is to provide a standardized, high-level interface for our components to increase reuse and allows for simpler system evolution. <p> Our goal is to provide a standardized, high-level interface for our components to increase reuse and allows for simpler system evolution. In addition, we envision a mechanism to extend component interfaces to simplify program maintenance. This approach is orthogonal to that taken by others <ref> [Sno89, Gar92] </ref>, and allows us to add features, such as invariants and assertions, without affecting our overall model. <p> Transformation systems are characterized by the transformations they perform on components to create new components which are tailored to the data structure or environment desired. Examples of data structure transformation systems include <ref> [Sno89, Coh89, Coh93, Nov83, Nov92] </ref>. The chief feature which distinguishes transformation systems from library approaches is their ability to dynamically alter their components as needed. This exibility allows them, in principle, to be more task-specific, and hence more efficient. <p> Programmers should have the ability to either declare that a relationship always be maintained by the TPT as an invariant, or (after manual insertions or deletions) to test by assertion a relationship with a TPT supplied interface. Although the latter functionality can be found in <ref> [Sno89] </ref> as part of the environment, the ability to declare and maintain invariants is generally absent from the TPT model. 2.2.6 Scalability Current TPT libraries are populated with components that represent a unique combination of features that the TPT author believes are necessary. <p> As described previously, simple macro-expansion is not sufficient for some of the compositions we have encountered. Coupled with a domain-specific optimizer, NPTs have considerable expressibility. 3.4.3 Type transformations Our NPT model is a compiled transformation system, not unlike those of <ref> [Coh89, Coh93, Sno89] </ref>. Our type equations take an abstract description of a data structure schema and transform it (via our compiler technology) to a concrete realization of the schema. The abstract/concrete paradigm is followed rigorously as the type equation is being resolved. Each layer is responsible for an abstract-to-concrete transformation. <p> Partsch and Seinbrggen describe many relevent research efforts, such as SETL [Sch79], Draco [Nei80, Nei84], and the Programmers Apprentice [Ric79, Ric90]. Gries [Gri90] also presents a good formal introduction to transforms as a language construct. The Interface Description Language (IDL) <ref> [Sno89] </ref> allows users to define a system as a pipeline of tools (or processes), each of which performs a specific task. The interface between these tasks is then specified in a rigorous way. The IDL compiler creates input and output routines for the different tasks.
Reference: [Str91] <author> B. Stroustrup. </author> <title> The C++ Programming Language, 2nd edition. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass, </address> <year> 1991. </year>
Reference-contexts: A TPT is a data type that has been parametrically generalized to compactly represent a family of related types. A generic stack, for example, could be instantiated to form a stack of integers or a stack of strings. Generics in Ada [Ghe87, Coh90] and templates in C++ <ref> [Str91] </ref> are well-known implementations of TPTs. In this section, we examine the current uses and assumptions of TPTs. We then expose fundamental limitations in the design of TPTs, current implementations of TPTs, and in the concept of TPTs itself. <p> Object-orientation offers many advantages; it provides a consistent abstraction (the object), allows for reuse via inheritance, and is a well-understood and appreciated paradigm. Many object-oriented systems and languages have been used for data structure programming and libraries. Some of these are Smalltalk [Gol83], C++ <ref> [Str91] </ref>, Modula-3 [Har92], SELF [Cha89], Eiffel [Mey88], and Meldc [Pop91]. All of these suffer from the limitation that they possess no native knowledge about specific problem domains. Thus, they cannot natively perform domain-specific optimizations.
Reference: [Sul92] <author> K. Sullivan, and D. Notkin. </author> <title> Reconciling Environment Integration and Software Evolution. </title> <journal> ACM TOSEM, </journal> <volume> 1(3), </volume> <month> July </month> <year> 1992. </year> <month> 137 </month>
Reference-contexts: However, in the context of a specific application, it is often the case that additional operations, unforeseen by the TPT author, are needed <ref> [Gar92, Sul92] </ref>. As the following examples illustrate, the penalty for non-extensible TPT interfaces can be severe inefficiencies or abandoning the use of the TPT altogether. List header 13 Consider a queue with the interface: enqueue, dequeue, is_empty, is_full. <p> It is often the case that a programmers first working solution to a problem is also his last. 18 2.2.5 Evolution and maintenance TPTs by themselves do provide a small amount of support for program maintenance and system evolution <ref> [Gar92, Sul92] </ref>. Certainly, data hiding helps when maintaining a program, and having the ability to change the implementation of a module without having to rewrite the callers program allows systems to evolve over time. However, TPTs, by themselves, do not provide further support for these important problems. <p> For each limitation, we briey describe how the NPT features described above help overcome it. 3.4.1 Difficulty of specialization We raised the objection in Chapter 2 that TPT authors cannot envision all specializations in advance <ref> [Gar92, Sul92] </ref>. Even attempting to do so would yield overly large interfaces that would inhibit TPT use. We have observed that the container and link abstractions are remarkably durable. They were recognized in the early 1960s and are omnipresent today. The basic interfaces to these abstractions have been very robust.
Reference: [Tan89] <author> D. Taenzer, M. Ganti, and S. Podar. </author> <title> Problems in Object-Oriented Software Reuse. </title> <booktitle> In Proceedings of the European Conference on Object-Oriented Programming 89, </booktitle> <year> 1989. </year>
Reference-contexts: Inheritance can be used to help reduce the specialization work required, but experience has shown that even this approach requires considerable additional programming work for customized applica tions <ref> [Tan89] </ref>. 3. Dont use TPTs. In production level code, many component libraries are shipped in object form only. It is up to the programmer to either live with the TPT interface pro vided, or to not use TPTs at all. None of these alternatives is satisfactory.
Reference: [Tra93] <author> W. Tracz. LILEANNA: </author> <title> A Parameterized Programming Language. </title> <booktitle> In Proceedings of the 2nd International Workshop on Software Reuse, </booktitle> <month> March </month> <year> 1993. </year>
Reference-contexts: As mentioned in Section 1.5, GenVoca is derived from two independently-conceived software system generators, Genesis [Bat88, Bat90] and Avoca [Hut91, Oma90]. The foundation for GenVoca has its roots in Parnas families of systems [Par76], Habermanns FAMOS project [Hab76], and Goguens model of parameterized programming <ref> [Gog86, Tra93] </ref>. GenVoca is characterized by realms (or libraries) of plug-compatible components, symmetric components, and type equations. 3.1.1 Components and realms A hierarchical software system is defined by a series of progressively more abstract virtual machines. A component (or layer) is an implementation of a virtual machine.
Reference: [Vol85] <author> D. Volpano, and R. Kieburtz. </author> <title> Software Templates. </title> <booktitle> In Proceedings of the 7th International Conference on Software Engineering, </booktitle> <year> 1985. </year>
Reference-contexts: This model identifies two kinds of parameters: vertical parameters (which specify lower layer components) and horizontal parameters (which correspond to type and constant values). Both horizontal and vertical parameterization are used in NPTs. 117 Software templates for NPTs were described in Section 4.1.2. <ref> [Vol85] </ref> describes a methodology for software templates. He recognizes the importance of separating algorithms from the implementation of the data structures.

References-found: 85

