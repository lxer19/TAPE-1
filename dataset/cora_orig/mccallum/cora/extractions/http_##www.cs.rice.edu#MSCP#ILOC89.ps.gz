URL: http://www.cs.rice.edu/MSCP/ILOC89.ps.gz
Refering-URL: http://www.cs.rice.edu/MSCP/iloc.html
Root-URL: 
Title: Experience with Low-Level Intermediate Representations  
Author: Preston Briggs Keith D. Cooper Linda Torczon 
Address: Houston, Texas 77251-1892  
Affiliation: Department of Computer Science Rice University  
Abstract: In this paper, we describe the intermediate languages used in the optimizing FORTRAN compiler built into the programming environment and the profound effect that they hav e had on both the form and function of the compiler.
Abstract-found: 1
Intro-found: 1
Reference: [AlCF 80] <author> F.E. Allen, J.L. Carter, J. Fabri, J. Ferrante, W.H. Harrison, P.G. Loewner, </author> <title> and L.H. Trevillyan. The experimental compiling system. </title> <journal> IBM Journal of Research and Development 24(6), </journal> <year> 1980. </year>
Reference-contexts: However, since these higher-level operations are not supported by the target machine, they must be expanded before code generation. Many of these expansions are relatively complicated, so it is worth re-optimizing to improve them. Of course, this strategy may be applied to many different levels of abstraction <ref> [AlCF 80] </ref>; we hav e chosen a fairly simple approach, guided by the availability of the FORTRAN intrinsics and the details of the target machine. 4.8. The Code Generator The choices made during the design of iloc have significant impact in the design and implementation of the code generator.
Reference: [AuHo 82] <author> M. Auslander and M. Hopkins. </author> <title> An overview of the PL.8 compiler. </title> <booktitle> Proceedings of the SIGPLAN `82 Symposium on Compiler Construction, SIGPLAN Notices 17(6), </booktitle> <month> June, </month> <year> 1982. </year>
Reference-contexts: The code generator schedules instructions twice, both before and after register allocation. We use a Chaitin-style, graph coloring register allocator for several reasons [ChAC 81, Chai 82]. The high quality code produced by the PL.8 compiler is a convincing argument by itself <ref> [AuHo 82] </ref>. Even more appealing is the conceptual elegance of the algorithm. After some experience with other, comparatively ad hoc methods of register allocation, graph coloring appeared wonderfully simple and clean. Our allocator uses an algorithm that is a no-cost improvement on Chaitin's algorithm [BCKKT 89].
Reference: [BoDe 86] <author> H.J. Boehm and A. Demers. </author> <title> Implementing Russell. </title> <booktitle> Proceedings of the ACM SIGPLAN `86 Symposium on Compiler Construction, SIGPLAN Notices 21(7), </booktitle> <month> July, </month> <year> 1986. </year>
Reference-contexts: As our work has matured, other researchers at Rice have begun to use our iloc-based tools in their research projects. (1) A compiler for the programming language Russell has been retargeted to use our iloc-based compiler back-end <ref> [BoDe 86] </ref>. Russell supports polymorphic procedures, types as first class objects, and provides full support for closures. This effort required no substantial additions to the original iloc design. <p> The code quality should continue to improve as additional transformations are added to the optimizer. The iloc optimizer is the focal point for several other compilers that will support research projects at Rice. A front-end that produces iloc from Russell already exists <ref> [BoDe 86] </ref>; a front end for OWL, the PRISM project's wide spectrum language, is planned. We are in the process of retargeting the code generator for the Intel 860. Finally, a scaled-down version of iloc has been used in the classroom.
Reference: [BrCT 87] <author> P. Briggs, K.D. Cooper, and L. Torczon. </author> <note> Iloc `87. Newsletter 44, </note> <institution> Department of Computer Science, Rice University, Houston, Tx., </institution> <month> September, </month> <year> 1987. </year>
Reference-contexts: Entries in the opcode table contain details about each possible iloc instruction, for example, its ASCII representation and the number and types of its operands. 6. Once and Future iloc Iloc has gone through several evolutionary incarnations. They are documented in a series of newsletters <ref> [LeFe 85, CoMT 86, BrCT 87] </ref>. The early designs reected our thinking about the design of low-level intermediate codes. Subsequent experience building mc has led us to reject many of our preconceived notions. 6.1. Block structure The original iloc had a block-oriented form rather than a linear form.
Reference: [CCHK 87] <author> A. Carle, K.D. Cooper, R.T. Hood, K. Kennedy, L. Torczon, and S.K. Warren. </author> <title> A practical envi- ronment for scientific programming. </title> <booktitle> IEEE Computer 20(11), </booktitle> <month> November, </month> <year> 1987. </year>
Reference-contexts: This paper describes our experience using a low-level intermediate representation in an optimizing compiler for FORTRAN. The decision to use a low-level intermediate code has had a strong effect on the form and function of the compiler. Our compiler, mc, is embedded in the programming environment for FORTRAN <ref> [CCHK 87] </ref>. is a suite of tools to help construct scientific programs in FORTRAN. It has a FORTRAN source editor that directly constructs an abstract syntax tree representation (AST) of a source module. It also includes two compilers.
Reference: [Chai 82] <author> G.J. Chaitin. </author> <title> Register allocation and spilling via graph coloring. </title> <booktitle> Proceedings of the SIGPLAN `82 Symposium on Compiler Construction, SIGPLAN Notices 17(6), </booktitle> <month> June, </month> <year> 1982. </year>
Reference-contexts: The scheduler is patterned after the work of Gibbons and Muchnick, extended slightly to schedule over extended basic blocks [GiMu 86]. The code generator schedules instructions twice, both before and after register allocation. We use a Chaitin-style, graph coloring register allocator for several reasons <ref> [ChAC 81, Chai 82] </ref>. The high quality code produced by the PL.8 compiler is a convincing argument by itself [AuHo 82]. Even more appealing is the conceptual elegance of the algorithm. After some experience with other, comparatively ad hoc methods of register allocation, graph coloring appeared wonderfully simple and clean.
Reference: [ChAC 81] <author> G.J. Chaitin, M.A. Auslander, A.K. Chandra, J. Cocke, M.E. Hopkins, and P.W. Markstein. </author> <title> Register allocation via coloring. </title> <booktitle> Computer Languages 6, </booktitle> <month> January, </month> <year> 1981. </year>
Reference-contexts: The scheduler is patterned after the work of Gibbons and Muchnick, extended slightly to schedule over extended basic blocks [GiMu 86]. The code generator schedules instructions twice, both before and after register allocation. We use a Chaitin-style, graph coloring register allocator for several reasons <ref> [ChAC 81, Chai 82] </ref>. The high quality code produced by the PL.8 compiler is a convincing argument by itself [AuHo 82]. Even more appealing is the conceptual elegance of the algorithm. After some experience with other, comparatively ad hoc methods of register allocation, graph coloring appeared wonderfully simple and clean.
Reference: [CoMT 86] <author> K.D. Cooper, K. Kinley, and L. Torczon. </author> <title> A revised iloc definition. </title> <type> Newsletter 35, </type> <institution> Department of Computer Science, Rice University, Houston, Tx., </institution> <month> October, </month> <year> 1986. </year>
Reference-contexts: Entries in the opcode table contain details about each possible iloc instruction, for example, its ASCII representation and the number and types of its operands. 6. Once and Future iloc Iloc has gone through several evolutionary incarnations. They are documented in a series of newsletters <ref> [LeFe 85, CoMT 86, BrCT 87] </ref>. The early designs reected our thinking about the design of low-level intermediate codes. Subsequent experience building mc has led us to reject many of our preconceived notions. 6.1. Block structure The original iloc had a block-oriented form rather than a linear form.
Reference: [DaFr 84] <author> J.W. Davidson and C.W. Fraser. </author> <title> Automatic generation of peephole optimizations. </title> <booktitle> Proceedings of the ACM SIGPLAN `84 Symposium on Compiler Construction, SIGPLAN Notices 19(6), </booktitle> <month> June, </month> <year> 1984. </year>
Reference-contexts: Therefore, code selection in mc is largely a process of combining several iloc instructions into 6 Instruction Selection Instruction Scheduling Register Allocation Insert Spill Code Instruction Scheduling iloc aliases asm code more complex assembly language instructions using peephole optimization. We use a table-driven scheme inspired by HOP <ref> [DaFr 84] </ref>. Since the RT/PC has such a simple integer instruction set, the table of legal peephole combinations is quite small (about 70 combinations); we created the complete set of patterns by hand.
Reference: [GiMu 86] <author> P.B. Gibbons and S.S. Muchnick. </author> <title> Efficient instruction scheduling for a pipelined architecture. </title> <booktitle> Proceedings of the ACM SIGPLAN `86 Symposium on Compiler Construction, SIGPLAN Notices 21(7), </booktitle> <month> July, </month> <year> 1986. </year>
Reference-contexts: Second, it finds instructions to be executed in the delay slot of the RT's ``branch and execute'' instructions. The scheduler is patterned after the work of Gibbons and Muchnick, extended slightly to schedule over extended basic blocks <ref> [GiMu 86] </ref>. The code generator schedules instructions twice, both before and after register allocation. We use a Chaitin-style, graph coloring register allocator for several reasons [ChAC 81, Chai 82]. The high quality code produced by the PL.8 compiler is a convincing argument by itself [AuHo 82].
Reference: [Kenn 75] <author> K.W. Kennedy. </author> <title> Use-definition chains with applications. </title> <type> Technical Report 476-039-9, </type> <institution> Depart ment of Mathematical Sciences, Rice University, Houston, Tx., </institution> <month> April, </month> <year> 1975. </year>
Reference-contexts: Some of the extensions are due to David Chase; the others were developed as the opti mizer evolved. (3) Dead code elimination opt uses a method due to Kennedy <ref> [Kenn 75] </ref>. It finds dead code by tracing through the procedure's def-use structure. (4) Value numbering is performed over strongly connected subcomponents of the control ow graph. During value numbering, opt also simplifies arithmetic expressions.
Reference: [LeFe 85] <author> W.N. LeFebvre. </author> <title> An intermediate language for an optimizing compiler. </title> <type> Newsletter 26, </type> <institution> Department of Computer Science, Rice University, Houston, Tx., </institution> <month> September, </month> <year> 1985. </year>
Reference-contexts: Similar instructions handle returned values. Ret associates a called routine register with an ordinal return value position while val associates an ordinal return value with a calling 3 Iloc is an acronym --- Intermediate Language for an Optimizing Compiler <ref> [LeFe 85] </ref>. Appendix A contains a table giving all the current iloc instructions, except for intrinsics and pseudo-operations. 2 routine register. 4 The remainder of iloc consists of instructions that implement FORTRAN intrinsics. <p> Entries in the opcode table contain details about each possible iloc instruction, for example, its ASCII representation and the number and types of its operands. 6. Once and Future iloc Iloc has gone through several evolutionary incarnations. They are documented in a series of newsletters <ref> [LeFe 85, CoMT 86, BrCT 87] </ref>. The early designs reected our thinking about the design of low-level intermediate codes. Subsequent experience building mc has led us to reject many of our preconceived notions. 6.1. Block structure The original iloc had a block-oriented form rather than a linear form.
References-found: 12

