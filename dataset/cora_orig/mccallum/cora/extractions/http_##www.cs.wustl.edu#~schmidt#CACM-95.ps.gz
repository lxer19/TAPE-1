URL: http://www.cs.wustl.edu/~schmidt/CACM-95.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/ACM-statement.html
Root-URL: 
Email: schmidt@cs.wustl.edu  
Phone: (TEL) 314-935-7538, (FAX) 314-935-7302  
Title: Experience Using Design Patterns to Develop Reuseable Object-Oriented Communication Software applying a design pattern-based reuse
Author: Douglas C. Schmidt 
Note: This article will appear in the Communications of the ACM Special Issue on Object-Oriented Experiences, Vol. 38, No. 10, October, 1995. Section 2 illustrates an example pattern description that is a synopsis of material from [1]. Section 3 is new material that summarizes the lessons learned while  
Address: St. Louis 63130  
Affiliation: Department of Computer Science Washington University,  
Web: http://www.cs.wustl.edu/~schmidt/  
Abstract: Design patterns help to enhance software quality by addressing fundamental challenges in large-scale system development. These challenges include communication of architectural knowledge among developers, accommodating new design paradigms or architectural styles, and avoiding development traps and pitfalls that are usually learned only by experience. This article describes lessons learned from applying a design pattern-based reuse strategy to develop object-oriented communication software frameworks for several production distributed systems. Design patterns are in danger of becoming yet another buzzword. This article attempts to replace the hype with insights and recommendations gained from several years of experience. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: See <ref> [1] </ref> for a complete example of the Reactor pattern. * threading may not be available on an OS platform. Often, a more convenient and portable way to develop event-driven servers is to use the Reactor pattern. <p> The Dispatcher is used to define an application's main event loop and to manage connections to one or more physical GUI displays. * The ADAPTIVE Service eXecutive (ASX) framework <ref> [1] </ref> uses the Reactor pattern as the central event de-multiplexer/dispatcher in an object-oriented toolkit for experimenting with high-performance parallel commu nication protocol stacks. * The Reactor pattern has been used in a number of commercial products. <p> The Motorola Iridium and Ericsson projects were among the first large-scale distributed system projects to adopt a software reuse strategy based on the concepts, notations, and techniques of design patterns. Patterns identified and applied in these projects have been described in <ref> [3, 4, 1, 9, 11, 12] </ref>. These projects have clarified many of the benefits and drawbacks of using design patterns to systematically capture and articulate communication software architectures. This section discusses the lessons learned and outlines workarounds for problems we encountered using design pattern-based reuse strategies in production software environments.
Reference: [2] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: In addition, it is often hard to directly reuse existing algorithms, detailed designs, interfaces, or implementations in these systems due to the growing heterogeneity of hardware/software architectures and diversity of operating system platforms. Design patterns <ref> [2] </ref> are a promising technique for achieving widespread reuse of software architectures. Design patterns capture the static and dynamic structures and collaborations of components in successful solutions to problems that arise when building software in domains like business data processing, telecommunications, graphical user interfaces, databases, and distributed communication software. <p> This pattern was identified while developing reusable event-driven communication software at Ericsson, Motorola, and BJC/WUSM. Portions of the material below was culled from documenta tion used on these projects. 1 Design patterns have been described using several formats <ref> [2, 6, 7] </ref>. <p> Portions of the material below was culled from documenta tion used on these projects. 1 Design patterns have been described using several formats [2, 6, 7]. The format used below is based on the work of Gamma et al. <ref> [2] </ref>; it contains the following parts: * The intent of the pattern * The design forces that motivate the pattern * The solution to these forces * The structure and roles of classes in the solution * The responsibilities and collaborations among classes * The positive and negative consequences of using <p> the Ericsson EOS family of telecommunication switch management applications [3], the network management portion of the Motorola Iridium global personal communications system [4], and in an enterprise medical image delivery system for BJC/WUSM [5]. 2.10 Related Patterns The Reactor pattern may be viewed as a variation on the Observer pattern <ref> [2] </ref>. In the Observer pattern, subscribers are updated automatically when a single subject changes. In the Reactor pattern, handlers are informed automatically when events from multiple sources occur. A Reactor provides a Facade [2] for event demultiplex-ing. <p> [5]. 2.10 Related Patterns The Reactor pattern may be viewed as a variation on the Observer pattern <ref> [2] </ref>. In the Observer pattern, subscribers are updated automatically when a single subject changes. In the Reactor pattern, handlers are informed automatically when events from multiple sources occur. A Reactor provides a Facade [2] for event demultiplex-ing. A Facade is an interface that shields applications from complex object relationships within a subsystem. The virtual methods provided by the Event Handler base class are Template Methods [2]. <p> A Reactor provides a Facade <ref> [2] </ref> for event demultiplex-ing. A Facade is an interface that shields applications from complex object relationships within a subsystem. The virtual methods provided by the Event Handler base class are Template Methods [2]. These template methods are used by the Reactor to trigger callbacks to the appropriate application-specific processing functions in response to events. <p> We found that patterns helped to elevate the level of discourse among team members. For example, once developers understood patterns like Factory Method <ref> [2] </ref> and the Reactor they could convey and justify their design and implementation decisions swiftly and clearly to other team members. In addition, patterns helped to bridge the communication gap that existed between software developers, managers, and non-technical team members in marketing and sales. <p> Although this was intellectually satisfying, 6 pattern overload became counter productive when it did not markedly improve software quality. * Focus on developing patterns that are strategic to the domain and reuse existing tactical patterns. Existing pattern catalogs <ref> [2, 7] </ref> do an excellent job of documenting many domain-independent, tactical patterns (such as Factory Method, Abstract Factory, and Singleton). Tactical patterns have a relatively localized impact on a software architecture. For instance, the Iterator pattern [2] allows elements in a collection to be accessed sequentially without violating data encapsulation. <p> Existing pattern catalogs [2, 7] do an excellent job of documenting many domain-independent, tactical patterns (such as Factory Method, Abstract Factory, and Singleton). Tactical patterns have a relatively localized impact on a software architecture. For instance, the Iterator pattern <ref> [2] </ref> allows elements in a collection to be accessed sequentially without violating data encapsulation. Although this pattern is widely applicable, the problem it addresses does not have sweeping architectural implications. In contrast, strategic design patterns have an extensive impact on the software architecture for solutions in a particular domain. <p> However, the projects at Eric-sson, Motorola, and BJC/WUSM are all new systems that have not yet entered the long-term maintenance phase. We are collecting additional information on how patterns affect maintenance over the software lifecycle. * Implementing patterns efficiently requires careful selection of language features. Existing patterns literature <ref> [2, 6, 7, 15] </ref> has focused primarily on software quality factors other than performance. This may be acceptable in domains where non-functional requirements are more important than efficiency. For example, graphical user interfaces are often judged more in terms of their usability, extensibility, and portability than their raw performance. <p> Ideally, systems of patterns and frameworks will be integrated with tools like on-line pattern browsers that contain hyper-text links to navigate quickly through multiple levels of abstraction. * Integration of design patterns to form systems of patterns most literature on patterns is currently organized as design pattern catalogs <ref> [2, 6, 7] </ref>. These catalogs present a collection of individual solutions to common design problems. As more experience is gained using these patterns, developers will integrate groups of related patterns to form pattern systems (also called pattern languages). <p> In the implementation and maintenance phases they help document the strategic properties of software systems at a level higher than source code and individual object models. This paper just scratches the surface of activities the patterns community is currently engaged in. A number of books <ref> [2, 6, 7, 15] </ref> have been published (or will soon be published) on these topics. The Pattern Languages of Programming conference [6] is an annual forum dedicated to improving the expression of patterns. There are also pattern workshops at on object-oriented conferences (such as OOPSLA, ECOOP, and USENIX COOTS).
Reference: [3] <author> D. C. Schmidt and P. Stephenson, </author> <title> Experiences Using Design Patterns to Evolve System Software Across Diverse OS Platforms, </title> <booktitle> in Proceedings of the 9 th European Conference on Object-Oriented Programming, </booktitle> <address> (Aarhus, Denmark), </address> <publisher> ACM, </publisher> <month> August </month> <year> 1995. </year>
Reference-contexts: Thus, patterns facilitate reuse of software architecture, even when other forms of reuse are infeasible (e.g., due to fundamental differences in operating system features <ref> [3] </ref>). This article describes how design patterns are being applied on a number of large-scale commercial distributed systems. Patterns have been used on these projects to enable widespread reuse of communication software architectures, developer expertise, and object-oriented framework components. <p> Patterns have been used on these projects to enable widespread reuse of communication software architectures, developer expertise, and object-oriented framework components. These systems include the system control segment for the Motorola Iridium global personal communications system [4]; a family of network monitoring applications for Ericsson telecommunication switches <ref> [3] </ref>; and a system for transporting multi-megabyte medical images over high-speed ATM networks [5] being developed at BJC health system and Washington University School of Medicine (BJC/WUSM). This article also presents ways to avoid common traps and pitfalls of applying design patterns in large-scale software development processes. <p> An application may subsequently use the WIN32 WaitForMultipleObjects system call to determine when its outstanding asynchronous I/O operations have completed. Variations in the I/O semantics of different operating systems may cause the class interfaces and class implementations of the Reactor pattern to vary across platforms. Schmidt and Stephenson <ref> [3] </ref> provide a detailed evaluation of how differences between proactive and reactive event demultiplexing affect implementations of the Reactor pattern on UNIX and Windows NT. 2.9 Known Uses The Reactor pattern has been used in many object-oriented frameworks and event-driven applications: 4 * The X windows toolkit uses a version of <p> These products include the Bellcore and Siemens Q.port ATM signaling software product, the Ericsson EOS family of telecommunication switch management applications <ref> [3] </ref>, the network management portion of the Motorola Iridium global personal communications system [4], and in an enterprise medical image delivery system for BJC/WUSM [5]. 2.10 Related Patterns The Reactor pattern may be viewed as a variation on the Observer pattern [2]. <p> (or in conjunction with) the Active Object pattern when threads are not available or when the overhead and complexity of managing large numbers of threads is undesirable. 3 Lessons Learned This section describes lessons learned from developing object-oriented communication frameworks based on design patterns at Motorola Iridium [4, 11], Ericsson <ref> [3] </ref>, and BJC/WUSM [5]. These large-scale distributed system projects have identified, documented, and applied dozens of new or existing design patterns. Patterns were used to leverage prior development expertise, as well as to reduce risk by reusing software architectures across diverse OS platforms and subsystems. <p> The Motorola Iridium and Ericsson projects were among the first large-scale distributed system projects to adopt a software reuse strategy based on the concepts, notations, and techniques of design patterns. Patterns identified and applied in these projects have been described in <ref> [3, 4, 1, 9, 11, 12] </ref>. These projects have clarified many of the benefits and drawbacks of using design patterns to systematically capture and articulate communication software architectures. This section discusses the lessons learned and outlines workarounds for problems we encountered using design pattern-based reuse strategies in production software environments. <p> The constraints of the underlying OS and hardware platform significantly affect design and implementation decisions. This is particularly problematic for communication software, where non-portable OS features are often used to enhance performance and functionality. The Ericsson telecommunication switch management project <ref> [3] </ref> illustrated the importance of patterns-based architectural reuse. This project underwent several major changes over three years. The original prototype was developed on UNIX using sockets, select, and TCP/IP as the communication mechanisms. <p> One downside to the intuitive nature of patterns is that developers may not fully appreciate the challenges associated with implementing a pattern. Simply knowing the structure and participants in a pattern (such as the Reactor pattern) is only the first step. As described in <ref> [3] </ref>, a significant development effort and commitment of time and resources may be necessary to implement a pattern correctly, efficiently, and portably in a particular context.
Reference: [4] <author> D. C. Schmidt, </author> <title> A System of Reusable Design Patterns for Communication Software, in The Theory and Practice of Object Systems (Special Issue on Patterns and Pattern Languages) (S. </title> <editor> P. Berczuk, ed.), </editor> <publisher> Wiley and Sons, </publisher> <year> 1995. </year>
Reference-contexts: Patterns have been used on these projects to enable widespread reuse of communication software architectures, developer expertise, and object-oriented framework components. These systems include the system control segment for the Motorola Iridium global personal communications system <ref> [4] </ref>; a family of network monitoring applications for Ericsson telecommunication switches [3]; and a system for transporting multi-megabyte medical images over high-speed ATM networks [5] being developed at BJC health system and Washington University School of Medicine (BJC/WUSM). <p> These products include the Bellcore and Siemens Q.port ATM signaling software product, the Ericsson EOS family of telecommunication switch management applications [3], the network management portion of the Motorola Iridium global personal communications system <ref> [4] </ref>, and in an enterprise medical image delivery system for BJC/WUSM [5]. 2.10 Related Patterns The Reactor pattern may be viewed as a variation on the Observer pattern [2]. In the Observer pattern, subscribers are updated automatically when a single subject changes. <p> in place of (or in conjunction with) the Active Object pattern when threads are not available or when the overhead and complexity of managing large numbers of threads is undesirable. 3 Lessons Learned This section describes lessons learned from developing object-oriented communication frameworks based on design patterns at Motorola Iridium <ref> [4, 11] </ref>, Ericsson [3], and BJC/WUSM [5]. These large-scale distributed system projects have identified, documented, and applied dozens of new or existing design patterns. Patterns were used to leverage prior development expertise, as well as to reduce risk by reusing software architectures across diverse OS platforms and subsystems. <p> The Motorola Iridium and Ericsson projects were among the first large-scale distributed system projects to adopt a software reuse strategy based on the concepts, notations, and techniques of design patterns. Patterns identified and applied in these projects have been described in <ref> [3, 4, 1, 9, 11, 12] </ref>. These projects have clarified many of the benefits and drawbacks of using design patterns to systematically capture and articulate communication software architectures. This section discusses the lessons learned and outlines workarounds for problems we encountered using design pattern-based reuse strategies in production software environments.
Reference: [5] <author> G. Blaine, M. Boyd, and S. Crider, </author> <title> Project Spectrum: Scalable Bandwidth for the BJC Health System, </title> <journal> HIMSS, Health Care Communications, </journal> <pages> pp. 71-81, </pages> <year> 1994. </year>
Reference-contexts: These systems include the system control segment for the Motorola Iridium global personal communications system [4]; a family of network monitoring applications for Ericsson telecommunication switches [3]; and a system for transporting multi-megabyte medical images over high-speed ATM networks <ref> [5] </ref> being developed at BJC health system and Washington University School of Medicine (BJC/WUSM). This article also presents ways to avoid common traps and pitfalls of applying design patterns in large-scale software development processes. <p> These products include the Bellcore and Siemens Q.port ATM signaling software product, the Ericsson EOS family of telecommunication switch management applications [3], the network management portion of the Motorola Iridium global personal communications system [4], and in an enterprise medical image delivery system for BJC/WUSM <ref> [5] </ref>. 2.10 Related Patterns The Reactor pattern may be viewed as a variation on the Observer pattern [2]. In the Observer pattern, subscribers are updated automatically when a single subject changes. In the Reactor pattern, handlers are informed automatically when events from multiple sources occur. <p> with) the Active Object pattern when threads are not available or when the overhead and complexity of managing large numbers of threads is undesirable. 3 Lessons Learned This section describes lessons learned from developing object-oriented communication frameworks based on design patterns at Motorola Iridium [4, 11], Ericsson [3], and BJC/WUSM <ref> [5] </ref>. These large-scale distributed system projects have identified, documented, and applied dozens of new or existing design patterns. Patterns were used to leverage prior development expertise, as well as to reduce risk by reusing software architectures across diverse OS platforms and subsystems.
Reference: [6] <editor> J. O. Coplien and D. C. Schmidt, eds., </editor> <booktitle> Pattern Languages of Program Design. </booktitle> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: This pattern was identified while developing reusable event-driven communication software at Ericsson, Motorola, and BJC/WUSM. Portions of the material below was culled from documenta tion used on these projects. 1 Design patterns have been described using several formats <ref> [2, 6, 7] </ref>. <p> However, the projects at Eric-sson, Motorola, and BJC/WUSM are all new systems that have not yet entered the long-term maintenance phase. We are collecting additional information on how patterns affect maintenance over the software lifecycle. * Implementing patterns efficiently requires careful selection of language features. Existing patterns literature <ref> [2, 6, 7, 15] </ref> has focused primarily on software quality factors other than performance. This may be acceptable in domains where non-functional requirements are more important than efficiency. For example, graphical user interfaces are often judged more in terms of their usability, extensibility, and portability than their raw performance. <p> Ideally, systems of patterns and frameworks will be integrated with tools like on-line pattern browsers that contain hyper-text links to navigate quickly through multiple levels of abstraction. * Integration of design patterns to form systems of patterns most literature on patterns is currently organized as design pattern catalogs <ref> [2, 6, 7] </ref>. These catalogs present a collection of individual solutions to common design problems. As more experience is gained using these patterns, developers will integrate groups of related patterns to form pattern systems (also called pattern languages). <p> In the implementation and maintenance phases they help document the strategic properties of software systems at a level higher than source code and individual object models. This paper just scratches the surface of activities the patterns community is currently engaged in. A number of books <ref> [2, 6, 7, 15] </ref> have been published (or will soon be published) on these topics. The Pattern Languages of Programming conference [6] is an annual forum dedicated to improving the expression of patterns. There are also pattern workshops at on object-oriented conferences (such as OOPSLA, ECOOP, and USENIX COOTS). <p> This paper just scratches the surface of activities the patterns community is currently engaged in. A number of books [2, 6, 7, 15] have been published (or will soon be published) on these topics. The Pattern Languages of Programming conference <ref> [6] </ref> is an annual forum dedicated to improving the expression of patterns. There are also pattern workshops at on object-oriented conferences (such as OOPSLA, ECOOP, and USENIX COOTS). The World Wide Web URL http://st-www.cs.uiuc.edu/users/patterns contains a comprehensive on-line reference to pattern-related material.
Reference: [7] <author> F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal, </author> <title> Pattern-Oriented Software Architecture A System of Patterns. </title> <journal> Wileys and Sons, </journal> <note> to appear 1996. </note>
Reference-contexts: This pattern was identified while developing reusable event-driven communication software at Ericsson, Motorola, and BJC/WUSM. Portions of the material below was culled from documenta tion used on these projects. 1 Design patterns have been described using several formats <ref> [2, 6, 7] </ref>. <p> Although this was intellectually satisfying, 6 pattern overload became counter productive when it did not markedly improve software quality. * Focus on developing patterns that are strategic to the domain and reuse existing tactical patterns. Existing pattern catalogs <ref> [2, 7] </ref> do an excellent job of documenting many domain-independent, tactical patterns (such as Factory Method, Abstract Factory, and Singleton). Tactical patterns have a relatively localized impact on a software architecture. For instance, the Iterator pattern [2] allows elements in a collection to be accessed sequentially without violating data encapsulation. <p> One sign that pattern overload is taking place is when developers start planning to invent patterns. * Patterns help ease the transition to object-oriented technology for developers who were trained in traditional design techniques. Many patterns in our communication frameworks (such as the pipes and filters architecture <ref> [7] </ref>) originated in non-object-oriented contexts such as operating systems and databases. <p> However, the projects at Eric-sson, Motorola, and BJC/WUSM are all new systems that have not yet entered the long-term maintenance phase. We are collecting additional information on how patterns affect maintenance over the software lifecycle. * Implementing patterns efficiently requires careful selection of language features. Existing patterns literature <ref> [2, 6, 7, 15] </ref> has focused primarily on software quality factors other than performance. This may be acceptable in domains where non-functional requirements are more important than efficiency. For example, graphical user interfaces are often judged more in terms of their usability, extensibility, and portability than their raw performance. <p> Ideally, systems of patterns and frameworks will be integrated with tools like on-line pattern browsers that contain hyper-text links to navigate quickly through multiple levels of abstraction. * Integration of design patterns to form systems of patterns most literature on patterns is currently organized as design pattern catalogs <ref> [2, 6, 7] </ref>. These catalogs present a collection of individual solutions to common design problems. As more experience is gained using these patterns, developers will integrate groups of related patterns to form pattern systems (also called pattern languages). <p> In the implementation and maintenance phases they help document the strategic properties of software systems at a level higher than source code and individual object models. This paper just scratches the surface of activities the patterns community is currently engaged in. A number of books <ref> [2, 6, 7, 15] </ref> have been published (or will soon be published) on these topics. The Pattern Languages of Programming conference [6] is an annual forum dedicated to improving the expression of patterns. There are also pattern workshops at on object-oriented conferences (such as OOPSLA, ECOOP, and USENIX COOTS).
Reference: [8] <author> G. Booch, </author> <title> Object Oriented Analysis and Design with Applications (2 nd Edition). </title> <address> Redwood City, California: Ben-jamin/Cummings, </address> <year> 1993. </year>
Reference-contexts: an OS platform; undesirable- due to poor performance on uni-processors or due to the need for overly complex concurrency control schemes; redundant- due to the use of multi-threading at higher levels of an application's architecture. 2.4 Structure The structure of the Reactor pattern is illustrated in the fol lowing Booch <ref> [8] </ref> class diagram: 2 In Booch notation dashed clouds indicate classes, an in-scribed A indicates an abstract class, directed edges indicate inheritance relationships between classes, and an undirected edge with a small bullet at one end indicates a composition relation between two classes. 2.5 Participants The participants in the Reactor pattern
Reference: [9] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Object Behavioral Pattern for Concurrent Programming, </title> <booktitle> in Proceedings of the 2 nd Annual Conference on the Pattern Languages of Programs, </booktitle> <address> (Monticello, </address> <publisher> Illinois), </publisher> <pages> pp. 1-7, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: Therefore, a handler should not perform blocking I/O on a Handle since this will significantly decrease the responsiveness to clients connected to other I/O handles. Therefore, for long-duration operations (such as transferring a multi-megabyte medical image) the Active Object pattern <ref> [9] </ref> (which uses multi-threading or multi-processing) may be more effective. * Applications written using the Reactor pattern can be hard to debug because their flow of control oscillates between the lower-level demultiplexing code (supplied by the framework) and the higher-level method call backs (supplied by application developers). 3 2.8 Implementation The <p> The virtual methods provided by the Event Handler base class are Template Methods [2]. These template methods are used by the Reactor to trigger callbacks to the appropriate application-specific processing functions in response to events. The Active Object pattern <ref> [9] </ref> decouples method execution from method invocation in order to simplify synchronized access to a shared resource by methods invoked in different threads of control. This pattern is often used in place of (or in conjunction with) the Reactor pattern when Event Handlers perform long-duration activities. <p> The Motorola Iridium and Ericsson projects were among the first large-scale distributed system projects to adopt a software reuse strategy based on the concepts, notations, and techniques of design patterns. Patterns identified and applied in these projects have been described in <ref> [3, 4, 1, 9, 11, 12] </ref>. These projects have clarified many of the benefits and drawbacks of using design patterns to systematically capture and articulate communication software architectures. This section discusses the lessons learned and outlines workarounds for problems we encountered using design pattern-based reuse strategies in production software environments. <p> For example, as described in the previous paragraph, the Reactor pattern can be an inefficient event demultiplexing mechanism on multiprocessor platforms because it serializes application concur-rency at a coarse-grained level <ref> [9] </ref>. If this caveat is not explicitly captured in a pattern description, developers may apply the pattern inappropriately.
Reference: [10] <author> M. A. Linton and P. R. Calder, </author> <booktitle> The Design and Implementation of InterViews, in Proceedings of the USENIX C++ Workshop, </booktitle> <month> November </month> <year> 1987. </year>
Reference-contexts: This implementation registers and dispatches function calls, rather than objects. * The InterViews window system distribution <ref> [10] </ref> implements the Reactor pattern in its Dispatcher class category.
Reference: [11] <author> D. C. Schmidt, </author> <title> Acceptor and Connector: Design Patterns for Active and Passive Establishment of Network Connections, </title> <booktitle> in Workshop on Pattern Languages of Object-Oriented Programs at ECOOP '95, </booktitle> <address> (Aarhus, Denmark), </address> <month> August </month> <year> 1995. </year>
Reference-contexts: in place of (or in conjunction with) the Active Object pattern when threads are not available or when the overhead and complexity of managing large numbers of threads is undesirable. 3 Lessons Learned This section describes lessons learned from developing object-oriented communication frameworks based on design patterns at Motorola Iridium <ref> [4, 11] </ref>, Ericsson [3], and BJC/WUSM [5]. These large-scale distributed system projects have identified, documented, and applied dozens of new or existing design patterns. Patterns were used to leverage prior development expertise, as well as to reduce risk by reusing software architectures across diverse OS platforms and subsystems. <p> The Motorola Iridium and Ericsson projects were among the first large-scale distributed system projects to adopt a software reuse strategy based on the concepts, notations, and techniques of design patterns. Patterns identified and applied in these projects have been described in <ref> [3, 4, 1, 9, 11, 12] </ref>. These projects have clarified many of the benefits and drawbacks of using design patterns to systematically capture and articulate communication software architectures. This section discusses the lessons learned and outlines workarounds for problems we encountered using design pattern-based reuse strategies in production software environments.
Reference: [12] <author> D. C. Schmidt and C. D. Cranor, Half-Sync/Half-Async: </author> <title> an Architectural Pattern for Efficient and Well-structured Concurrent I/O, </title> <booktitle> in Proceedings of the 2 nd Annual Conference on the Pattern Languages of Programs, </booktitle> <address> (Monticello, </address> <publisher> Illinois), </publisher> <pages> pp. 1-10, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: The Motorola Iridium and Ericsson projects were among the first large-scale distributed system projects to adopt a software reuse strategy based on the concepts, notations, and techniques of design patterns. Patterns identified and applied in these projects have been described in <ref> [3, 4, 1, 9, 11, 12] </ref>. These projects have clarified many of the benefits and drawbacks of using design patterns to systematically capture and articulate communication software architectures. This section discusses the lessons learned and outlines workarounds for problems we encountered using design pattern-based reuse strategies in production software environments. <p> Although this pattern is widely applicable, the problem it addresses does not have sweeping architectural implications. In contrast, strategic design patterns have an extensive impact on the software architecture for solutions in a particular domain. For example, the Half-Sync/Half-Async pattern <ref> [12] </ref> decouples synchronous I/O from asynchronous I/O in a system to simplify concurrent programming effort without degrading execution efficiency. This pattern greatly simplifies synchronization strategies in complex concurrent systems (such as BSD UNIX).
Reference: [13] <author> J. O. Coplien, </author> <title> A Development Process Generative Pattern Language, in Pattern Languages of Programs (J. </title> <editor> O. Coplien and D. C. Schmidt, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: They viewed this knowledge as a competitive advantage over other developers. These types of problems are indicative of deeper issues related to the reward structure in a corporate culture, which is often hard to change <ref> [13] </ref>. We addressed this problem to the extent possible by instituting incentives for developing useful pattern descriptions. These descriptions were counted as deliverables used to measure individual performance.
Reference: [14] <author> M. Fayad, W. Tsai, and M. Fulghum, </author> <title> Transition to Object-Oriented Software Development, </title> <journal> Communications of the ACM, </journal> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: Many patterns in our communication frameworks (such as the pipes and filters architecture [7]) originated in non-object-oriented contexts such as operating systems and databases. By explicitly recognizing and reward ing the experiential basis of useful patterns, we were able to leverage valuable developer expertise from earlier design paradigms <ref> [14] </ref>. * Patterns are validated by experience rather than by testing, in the traditional sense of unit testing or integration testing of software. This can be problematic because it is hard to determine when a pattern description is complete and correct. <p> These patterns were incorporated into the project following careful scrutiny in pattern reviews. * Integrating patterns into a software development process is a human-intensive activity. Like other software reuse technologies, reuse of patterns does not come for free <ref> [14] </ref>. Identifying and documenting useful patterns requires both concrete experience in a domain and the ability to abstract away from concrete details to capture the general properties of patterns. We found that relatively few individuals possess both these skills with equal proficiency.
Reference: [15] <author> W. Pree, </author> <title> Design Patterns for Object-Oriented Software Development. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: However, the projects at Eric-sson, Motorola, and BJC/WUSM are all new systems that have not yet entered the long-term maintenance phase. We are collecting additional information on how patterns affect maintenance over the software lifecycle. * Implementing patterns efficiently requires careful selection of language features. Existing patterns literature <ref> [2, 6, 7, 15] </ref> has focused primarily on software quality factors other than performance. This may be acceptable in domains where non-functional requirements are more important than efficiency. For example, graphical user interfaces are often judged more in terms of their usability, extensibility, and portability than their raw performance. <p> In the implementation and maintenance phases they help document the strategic properties of software systems at a level higher than source code and individual object models. This paper just scratches the surface of activities the patterns community is currently engaged in. A number of books <ref> [2, 6, 7, 15] </ref> have been published (or will soon be published) on these topics. The Pattern Languages of Programming conference [6] is an annual forum dedicated to improving the expression of patterns. There are also pattern workshops at on object-oriented conferences (such as OOPSLA, ECOOP, and USENIX COOTS).
Reference: [16] <author> R. Johnson, </author> <title> Documenting Frameworks Using Patterns, </title> <booktitle> in OOPLSA '92, </booktitle> <address> (Vancouver, British Columbia), </address> <pages> pp. 63-76, </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1992. </year> <month> 10 </month>
Reference-contexts: However, patterns and frameworks are highly synergistic concepts, with neither subordinate to the other. The next generation of object-oriented frameworks will explicitly embody dozens or hundreds of patterns and patterns will be widely used to document the form and contents of frameworks <ref> [16] </ref>.
References-found: 16

