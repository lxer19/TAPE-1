URL: http://c.gp.cs.cmu.edu:5103/afs/cs/project/able/ftp/salang-reqts-tr.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs/project/able/www/paper_abstracts/salang-reqts-tr.html
Root-URL: http://www.cs.cmu.edu
Title: Characteristics of Higher-level Languages for Software Architecture  
Author: Mary Shaw David Garlan 
Address: Pittsburgh, PA 15213  
Affiliation: Engineering Institute  School of Computer Science Carnegie Mellon University  
Note: CMU-CS-94-210 Also appears as CMU Software  c 1994 by David Garlan and Mary Shaw  
Date: December 1994  
Pubnum: Technical Report CMU/SEI-94-TR-23 ESC-TR-94-023  
Abstract: The research reported here was sponsored by the Wright Laboratory, Aeronautical Systems Center, Air Force Materiel Command, USAF, and the Advanced Research Projects Agency (ARPA) under grant F33615-93-1-1330; by National Science Foundation Grants CCR-9109469 and CCR-9112880; and by a grant from Siemens Corporate Research; this work was created in the performance of Federal Government Contract Number F19628-90-C-0003 with Carnegie Mellon University for the operation of the Software Engineering Institute, a Federally Funded Research and Development Center. The Government of the United States has a royalty-free government purpose license to use, duplicate or disclose the work, in whole or in part and in any manner, and to have or permit others to do so, for government purposes. Views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of Wright Laboratory, the US Department of Defense, the United States Government, the National Science Foundation, Siemens Corporation, or Carnegie Mellon University. The US Government is authorized to reproduce and distribute reprints for Government purposes, notwithstanding any copyright notation thereon. 
Abstract-found: 1
Intro-found: 1
Reference: [AG94a] <author> Robert Allen and David Garlan. </author> <title> Beyond definition/use: Architectural interconnection. </title> <booktitle> In Proceedings of the ACM Interface Definition Language Workshop, volume 29(8). SIGPLAN Notices, </booktitle> <month> August </month> <year> 1994. </year>
Reference-contexts: Event patterns can express richer aspects of module interaction than procedure call, and can also be used to define system communication topologies. UniCon [SDK + 95] provides an architectural description language in which both components and connectors are defined as first class compositional entities. Wright <ref> [AG94a, AG94b] </ref> is an architectural specification language that makes the notion of first-class connection precise by defining the semantics of connectors as formal protocols in a variant of CSP [Hoa85]. The Aesop System [GAO94] provides a general framework for defining many architectural languages, each specialized to a particular architectural style.
Reference: [AG94b] <author> Robert Allen and David Garlan. </author> <title> Formalizing architectural connection. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Software Engineering, </booktitle> <pages> pages 71-80, </pages> <address> Sorrento, Italy, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Event patterns can express richer aspects of module interaction than procedure call, and can also be used to define system communication topologies. UniCon [SDK + 95] provides an architectural description language in which both components and connectors are defined as first class compositional entities. Wright <ref> [AG94a, AG94b] </ref> is an architectural specification language that makes the notion of first-class connection precise by defining the semantics of connectors as formal protocols in a variant of CSP [Hoa85]. The Aesop System [GAO94] provides a general framework for defining many architectural languages, each specialized to a particular architectural style.
Reference: [Bac86] <author> Maurice J. Bach. </author> <title> The Design of the UNIX Operating System, </title> <booktitle> chapter 5.12, </booktitle> <pages> pages 111-119. </pages> <booktitle> Software Series. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: For example, Unix provides a shell language that supports direct definition of pipes as connectors <ref> [Bac86] </ref>. As another example, some systems support event broadcast by extending the facilities of a programming language [SN92, GS93a]. Ada supports intertask communication through rendezvous [DoD83].
Reference: [Bea92] <author> Brian W. </author> <title> Beach. Connecting software components with declarative glue. </title> <booktitle> In Proceedings of the Fourteenth International Conference on Software Engineering, </booktitle> <year> 1992. </year>
Reference-contexts: More recently, a number of component-based languages have been proposed and implemented. These languages describe systems as configurations of modules that interact in specific, predetermined ways (such as remote procedure call, messages, or events <ref> [Pur88, Kra90, Pou89, Mak92, Bea92] </ref>) or enforce specialized patterns of organization [D + 91, Ros85, L + 88]. <p> Hence, system builders must encode their intentions in terms of the specific primitives at hand. 4.5 Notations for Specialized Architectural Styles Recently, a number of systems have been developed to support specific abstract paradigms. Some of these were mentioned in the introduction <ref> [Pur88, Kra90, Pou89, Mak92, Bea92, MMHG92] </ref>. Each of these works through a specific architectural style in detail. Most provide good high-level support for the paradigm of interest. However, these languages typically assume a homogeneous universe, and live as isolated systems.
Reference: [D + 91] <editor> Doubleday et al. </editor> <title> Building distributed Ada applications from specifications and functional components. </title> <booktitle> In Proceedings of TRI-Ada'91, </booktitle> <pages> pages 143-154, </pages> <address> San Jose, CA, Oc-tober 1991. </address> <publisher> ACM Press. </publisher>
Reference-contexts: More recently, a number of component-based languages have been proposed and implemented. These languages describe systems as configurations of modules that interact in specific, predetermined ways (such as remote procedure call, messages, or events [Pur88, Kra90, Pou89, Mak92, Bea92]) or enforce specialized patterns of organization <ref> [D + 91, Ros85, L + 88] </ref>. While such languages provide new ways of describing interactions between components in a large system, they too are typically oriented around a small, fixed set of communication paradigms and programming-level descriptions or they enforce a very specialized single-purpose organization.
Reference: [DK76] <author> Frank DeRemer and Hans H. Kron. </author> <title> Programming-in-the-large versus programming-in-the-small. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-2(2):80-86, </volume> <month> June </month> <year> 1976. </year>
Reference-contexts: 1 Introduction As the size and complexity of software systems increase, the design and specification of overall system structure become a more significant issue than the choice of algorithms and data structures of computation <ref> [DK76, Sha89] </ref>. Structural issues include the gross organization of the system; the global control structure; the protocols for communication, synchronization, and data access; the assignment of functionality to design elements; the composition of design elements; scaling and performance; and selection among design alternatives. <p> These are sometimes called "module interconnection languages" (MILs) Representative examples of early language designs include MIL75 and Intercol <ref> [DK76, Tic79, PDN86] </ref>. A more recent example is the module description features of Standard ML (SML) [MTH90]. Module interconnection languages partially separate the description of a system configuration from the parts of the system that are being composed.
Reference: [DoD83] <institution> Reference manual for the Ada programming language, </institution> <month> January </month> <year> 1983. </year> <institution> United States Department of Defense. </institution>
Reference-contexts: For example, Unix provides a shell language that supports direct definition of pipes as connectors [Bac86]. As another example, some systems support event broadcast by extending the facilities of a programming language [SN92, GS93a]. Ada supports intertask communication through rendezvous <ref> [DoD83] </ref>. Unfortunately, while all of these make it easier to describe some high-level interactions, none provide a more general facility for describing new abstractions for interaction.
Reference: [Fel79] <author> Stuart I. Feldman. </author> <title> Make a program for maintaining computer programs. </title> <journal> Software| Practice and Experience, </journal> <volume> 9 </volume> <pages> 255-265, </pages> <month> Nov </month> <year> 1979. </year>
Reference-contexts: This makes it essentially impossible for a developer or maintainer to understand or analyze the structure as a whole. The problem is mildly alleviated if build files, such as those used by Make <ref> [Fel79] </ref>, are used to show dependencies.
Reference: [GAO94] <author> David Garlan, Robert Allen, and John Ockerbloom. </author> <title> Exploiting style in architectural design environments. </title> <booktitle> In Proceedings of SIGSOFT'94: Foundations of Software Engineering. </booktitle> <publisher> ACM Press, </publisher> <month> December </month> <year> 1994. </year>
Reference-contexts: Wright [AG94a, AG94b] is an architectural specification language that makes the notion of first-class connection precise by defining the semantics of connectors as formal protocols in a variant of CSP [Hoa85]. The Aesop System <ref> [GAO94] </ref> provides a general framework for defining many architectural languages, each specialized to a particular architectural style. The core of Aesop is a generic architectural description language called Acme, from which the other more specialized forms are developed.
Reference: [GD90] <author> David Garlan and Norman Delisle. </author> <title> Formal specifications as reusable frameworks. In VDM'90: VDM and Z Formal Methods in Software Development, </title> <address> Kiel, Germany, 1990. </address> <publisher> Springer-Verlag, LNCS 428. </publisher>
Reference-contexts: Examples: Rule-based systems, blackboard shell. Software developers would clearly benefit from having more precise definitions of these structures, including the forms in which they appear and the classes of functionality and interaction they provide. Initial steps toward this goal have recently appeared <ref> [GD90, GN91] </ref>.
Reference: [GKN88] <author> David Garlan, Gail E. Kaiser, and David Notkin. </author> <title> On the criteria to be used in composing tools into systems. </title> <type> Technical Report 88-08-09, </type> <institution> Department of Computer Science, University of Washington, </institution> <month> August </month> <year> 1988. </year> <month> 13 </month>
Reference-contexts: Some of the informal terms refer to common, or idiomatic, patterns used to organize the overall system. These are often widely used among software engineers in high-level descriptions of system designs. A number of the more pervasive patterns have been identified in descriptions of architectural idioms <ref> [GKN88, GS93b, Sha89, Sha91] </ref>, and material based on these patterns is beginning to appear in courses on architectural design of software [GSO + 92]. Among the more common architectural patterns are: Pipes and filters Graph of incremental stream transformers. Examples: Unix pipes, signal processing.
Reference: [GN91] <author> David Garlan and David Notkin. </author> <title> Formalizing design spaces: Implicit invocation mech-anisms. </title> <booktitle> In VDM'91: Formal Software Development Methods, </booktitle> <pages> pages 31-44. </pages> <publisher> Springer-Verlag, LNCS 551, </publisher> <month> October </month> <year> 1991. </year>
Reference-contexts: Examples: Rule-based systems, blackboard shell. Software developers would clearly benefit from having more precise definitions of these structures, including the forms in which they appear and the classes of functionality and interaction they provide. Initial steps toward this goal have recently appeared <ref> [GD90, GN91] </ref>.
Reference: [GS93a] <author> David Garlan and Curtis Scott. </author> <title> Adding implicit invocation to traditional programming languages. </title> <booktitle> In Proceedings of the Fifteenth International Conference on Software Engineering, </booktitle> <address> Baltimore, MD, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: For example, Unix provides a shell language that supports direct definition of pipes as connectors [Bac86]. As another example, some systems support event broadcast by extending the facilities of a programming language <ref> [SN92, GS93a] </ref>. Ada supports intertask communication through rendezvous [DoD83]. Unfortunately, while all of these make it easier to describe some high-level interactions, none provide a more general facility for describing new abstractions for interaction.
Reference: [GS93b] <author> David Garlan and Mary Shaw. </author> <title> An introduction to software architecture. </title> <editor> In V. Am-briola and G. Tortora, editors, </editor> <booktitle> Advances in Software Engineering and Knowledge Engineering, Volume I, </booktitle> <address> New Jersey, 1993. </address> <publisher> World Scientific Publishing Company. </publisher>
Reference-contexts: Structural issues include the gross organization of the system; the global control structure; the protocols for communication, synchronization, and data access; the assignment of functionality to design elements; the composition of design elements; scaling and performance; and selection among design alternatives. This is the software architecture level of design <ref> [GS93b, PW92] </ref>. Abstractly, software architecture involves the description of elements from which systems are built, interactions among those elements, patterns that guide their composition, and constraints on these patterns. In general, a particular system is defined in terms of a collection of components and interactions among those components. <p> Some of the informal terms refer to common, or idiomatic, patterns used to organize the overall system. These are often widely used among software engineers in high-level descriptions of system designs. A number of the more pervasive patterns have been identified in descriptions of architectural idioms <ref> [GKN88, GS93b, Sha89, Sha91] </ref>, and material based on these patterns is beginning to appear in courses on architectural design of software [GSO + 92]. Among the more common architectural patterns are: Pipes and filters Graph of incremental stream transformers. Examples: Unix pipes, signal processing.
Reference: [GSO + 92] <author> David Garlan, Mary Shaw, Chris Okasaki, Curtis Scott, and Roy Swonger. </author> <title> Experience with a course on architectures for software systems. </title> <booktitle> In Proceedings of the Sixth SEI Conference on Software Engineering Education. </booktitle> <publisher> Springer Verlag, LNCS 376, </publisher> <month> October </month> <year> 1992. </year>
Reference-contexts: A number of the more pervasive patterns have been identified in descriptions of architectural idioms [GKN88, GS93b, Sha89, Sha91], and material based on these patterns is beginning to appear in courses on architectural design of software <ref> [GSO + 92] </ref>. Among the more common architectural patterns are: Pipes and filters Graph of incremental stream transformers. Examples: Unix pipes, signal processing. Client-server Shared services provided by request to distributed clients. Examples: File servers, distributed databases. Hierarchical layers System partitioned into layers, which act as virtual machines.
Reference: [HL94] <author> Robert Harper and Peter Lee. </author> <title> Advanced languages for systems software : the fox project in 1994. </title> <type> Technical Report CMU-CS-94-104, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1994. </year>
Reference-contexts: Some also provide parameterization features for describing templates of system composition, by indicating how a set of module types can be combined to produce new module types. This has been shown to be effective in particular for defining layered systems, such as communication protocol stacks <ref> [HL94] </ref>. 11 In these respects MILs satisfy some of the properties of composition and configuration better than programming language modules alone. However, they, too, are primarily concerned with resolving name bindings between definitions and uses of low-level programming entities.
Reference: [Hoa85] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference-contexts: Wright [AG94a, AG94b] is an architectural specification language that makes the notion of first-class connection precise by defining the semantics of connectors as formal protocols in a variant of CSP <ref> [Hoa85] </ref>. The Aesop System [GAO94] provides a general framework for defining many architectural languages, each specialized to a particular architectural style. The core of Aesop is a generic architectural description language called Acme, from which the other more specialized forms are developed.
Reference: [Kra90] <author> Jeff Kramer. </author> <title> Configuration programming a framework for the development of distributable systems. </title> <booktitle> In Proceedings of the IEEE International Conference on Computer Systems and Software Engineering, </booktitle> <address> Israel, </address> <month> May </month> <year> 1990. </year> <note> IEEE. </note>
Reference-contexts: More recently, a number of component-based languages have been proposed and implemented. These languages describe systems as configurations of modules that interact in specific, predetermined ways (such as remote procedure call, messages, or events <ref> [Pur88, Kra90, Pou89, Mak92, Bea92] </ref>) or enforce specialized patterns of organization [D + 91, Ros85, L + 88]. <p> Hence, system builders must encode their intentions in terms of the specific primitives at hand. 4.5 Notations for Specialized Architectural Styles Recently, a number of systems have been developed to support specific abstract paradigms. Some of these were mentioned in the introduction <ref> [Pur88, Kra90, Pou89, Mak92, Bea92, MMHG92] </ref>. Each of these works through a specific architectural style in detail. Most provide good high-level support for the paradigm of interest. However, these languages typically assume a homogeneous universe, and live as isolated systems.
Reference: [L + 88] <author> K.J. Lee et al. </author> <title> An ood pardigm for flight simulators, 2nd edition. </title> <type> Technical Report CMU/SEI-88-TR-30, </type> <institution> Carnegie Mellon University, Software Engineering Institute, </institution> <month> September </month> <year> 1988. </year>
Reference-contexts: More recently, a number of component-based languages have been proposed and implemented. These languages describe systems as configurations of modules that interact in specific, predetermined ways (such as remote procedure call, messages, or events [Pur88, Kra90, Pou89, Mak92, Bea92]) or enforce specialized patterns of organization <ref> [D + 91, Ros85, L + 88] </ref>. While such languages provide new ways of describing interactions between components in a large system, they too are typically oriented around a small, fixed set of communication paradigms and programming-level descriptions or they enforce a very specialized single-purpose organization.
Reference: [LAK + 95] <author> David C Luckham, Lary M. Augustin, John J. Kenney, James Veera, Doug Bryan, and Walter Mann. </author> <title> Specification and analysis of system architecture using rapide. </title> <journal> IEEE Transactions on Software Engineering, </journal> <note> to appear, </note> <year> 1995. </year>
Reference-contexts: In recognition of this fact, several new languages have recently been proposed to address the needs of architectural description. Rapide <ref> [LAK + 95] </ref> provides a language whose interface model is based on SML augmented with events and event patterns. Event patterns can express richer aspects of module interaction than procedure call, and can also be used to define system communication topologies.
Reference: [Mak92] <author> Victor W. Mak. </author> <title> Connection: An inter-component communication paradigm for configurable distributed systems. </title> <booktitle> In Proceedings of the International Workshop on Configurable Distributed Systems, </booktitle> <address> London, UK, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: More recently, a number of component-based languages have been proposed and implemented. These languages describe systems as configurations of modules that interact in specific, predetermined ways (such as remote procedure call, messages, or events <ref> [Pur88, Kra90, Pou89, Mak92, Bea92] </ref>) or enforce specialized patterns of organization [D + 91, Ros85, L + 88]. <p> Hence, system builders must encode their intentions in terms of the specific primitives at hand. 4.5 Notations for Specialized Architectural Styles Recently, a number of systems have been developed to support specific abstract paradigms. Some of these were mentioned in the introduction <ref> [Pur88, Kra90, Pou89, Mak92, Bea92, MMHG92] </ref>. Each of these works through a specific architectural style in detail. Most provide good high-level support for the paradigm of interest. However, these languages typically assume a homogeneous universe, and live as isolated systems.
Reference: [MMHG92] <author> LTCC Erik Mettala and eds. Marc H. Graham. </author> <title> The domain-specific software architecture program. </title> <type> Technical Report CMU/SEI-92-SR-9, </type> <institution> Carnegie Mellon Software Engineering Institute, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: Hence, system builders must encode their intentions in terms of the specific primitives at hand. 4.5 Notations for Specialized Architectural Styles Recently, a number of systems have been developed to support specific abstract paradigms. Some of these were mentioned in the introduction <ref> [Pur88, Kra90, Pou89, Mak92, Bea92, MMHG92] </ref>. Each of these works through a specific architectural style in detail. Most provide good high-level support for the paradigm of interest. However, these languages typically assume a homogeneous universe, and live as isolated systems.
Reference: [MTH90] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: These are sometimes called "module interconnection languages" (MILs) Representative examples of early language designs include MIL75 and Intercol [DK76, Tic79, PDN86]. A more recent example is the module description features of Standard ML (SML) <ref> [MTH90] </ref>. Module interconnection languages partially separate the description of a system configuration from the parts of the system that are being composed. Some also provide parameterization features for describing templates of system composition, by indicating how a set of module types can be combined to produce new module types.
Reference: [PDN86] <author> Ruben Prieto-Diaz and James M. Neighbors. </author> <title> Module interconnection languages. </title> <journal> The Journal of Systems and Software, </journal> <volume> 6(4) </volume> <pages> 307-334, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: The problem of describing structural decompositions more precisely has traditionally been addressed by modularization facilities of programming languages and module interconnection languages <ref> [PDN86] </ref>. These notations typically allow an implementor to describe software system structure in terms of definition/use or import/export relationships between program units. This supports many features for programming-in-the-large, such as separate compilation, well-defined module interfaces, and module libraries. <p> These are sometimes called "module interconnection languages" (MILs) Representative examples of early language designs include MIL75 and Intercol <ref> [DK76, Tic79, PDN86] </ref>. A more recent example is the module description features of Standard ML (SML) [MTH90]. Module interconnection languages partially separate the description of a system configuration from the parts of the system that are being composed.
Reference: [Pou89] <author> D. Pountain. </author> <title> Occam II. </title> <journal> Byte, </journal> <volume> 14(10) </volume> <pages> 279-284, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: More recently, a number of component-based languages have been proposed and implemented. These languages describe systems as configurations of modules that interact in specific, predetermined ways (such as remote procedure call, messages, or events <ref> [Pur88, Kra90, Pou89, Mak92, Bea92] </ref>) or enforce specialized patterns of organization [D + 91, Ros85, L + 88]. <p> Hence, system builders must encode their intentions in terms of the specific primitives at hand. 4.5 Notations for Specialized Architectural Styles Recently, a number of systems have been developed to support specific abstract paradigms. Some of these were mentioned in the introduction <ref> [Pur88, Kra90, Pou89, Mak92, Bea92, MMHG92] </ref>. Each of these works through a specific architectural style in detail. Most provide good high-level support for the paradigm of interest. However, these languages typically assume a homogeneous universe, and live as isolated systems.
Reference: [Pur88] <author> James M. Purtilo. </author> <title> A software interconnection technology. </title> <type> Technical Report UMIACS-TR-88-83 CS-TR-2139, </type> <institution> University of Maryland, College Park, </institution> <month> November </month> <year> 1988. </year> <month> 14 </month>
Reference-contexts: More recently, a number of component-based languages have been proposed and implemented. These languages describe systems as configurations of modules that interact in specific, predetermined ways (such as remote procedure call, messages, or events <ref> [Pur88, Kra90, Pou89, Mak92, Bea92] </ref>) or enforce specialized patterns of organization [D + 91, Ros85, L + 88]. <p> Hence, system builders must encode their intentions in terms of the specific primitives at hand. 4.5 Notations for Specialized Architectural Styles Recently, a number of systems have been developed to support specific abstract paradigms. Some of these were mentioned in the introduction <ref> [Pur88, Kra90, Pou89, Mak92, Bea92, MMHG92] </ref>. Each of these works through a specific architectural style in detail. Most provide good high-level support for the paradigm of interest. However, these languages typically assume a homogeneous universe, and live as isolated systems.
Reference: [PW92] <author> Dewayne E. Perry and Alexander L. Wolf. </author> <title> Foundations for the study of software architecture. </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 17(4) </volume> <pages> 40-52, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Structural issues include the gross organization of the system; the global control structure; the protocols for communication, synchronization, and data access; the assignment of functionality to design elements; the composition of design elements; scaling and performance; and selection among design alternatives. This is the software architecture level of design <ref> [GS93b, PW92] </ref>. Abstractly, software architecture involves the description of elements from which systems are built, interactions among those elements, patterns that guide their composition, and constraints on these patterns. In general, a particular system is defined in terms of a collection of components and interactions among those components.
Reference: [Ros85] <author> Frederick Rosene. </author> <title> A software development environment called STEP. </title> <booktitle> In Proceedings of the ACM Conference on Software Tools, </booktitle> <month> April </month> <year> 1985. </year>
Reference-contexts: More recently, a number of component-based languages have been proposed and implemented. These languages describe systems as configurations of modules that interact in specific, predetermined ways (such as remote procedure call, messages, or events [Pur88, Kra90, Pou89, Mak92, Bea92]) or enforce specialized patterns of organization <ref> [D + 91, Ros85, L + 88] </ref>. While such languages provide new ways of describing interactions between components in a large system, they too are typically oriented around a small, fixed set of communication paradigms and programming-level descriptions or they enforce a very specialized single-purpose organization.
Reference: [SDK + 95] <author> Mary Shaw, Robert DeLine, Daniel V. Klein, Theodore L. Ross, David M. Young, and Gregory Zelesnik. </author> <title> Abstractions for software architecture and tools to support them. </title> <journal> IEEE Transactions on Software Engineering, </journal> <note> to appear, </note> <year> 1995. </year>
Reference-contexts: Rapide [LAK + 95] provides a language whose interface model is based on SML augmented with events and event patterns. Event patterns can express richer aspects of module interaction than procedure call, and can also be used to define system communication topologies. UniCon <ref> [SDK + 95] </ref> provides an architectural description language in which both components and connectors are defined as first class compositional entities.
Reference: [Sha89] <author> Mary Shaw. </author> <title> Larger scale systems require higher level abstractions. </title> <booktitle> Proceedings Fifth International Workshop on Software Specification and Design, IEEE Computer Society, Software Engineering Notes, </booktitle> <volume> 14(3) </volume> <pages> 143-146, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: 1 Introduction As the size and complexity of software systems increase, the design and specification of overall system structure become a more significant issue than the choice of algorithms and data structures of computation <ref> [DK76, Sha89] </ref>. Structural issues include the gross organization of the system; the global control structure; the protocols for communication, synchronization, and data access; the assignment of functionality to design elements; the composition of design elements; scaling and performance; and selection among design alternatives. <p> Some of the informal terms refer to common, or idiomatic, patterns used to organize the overall system. These are often widely used among software engineers in high-level descriptions of system designs. A number of the more pervasive patterns have been identified in descriptions of architectural idioms <ref> [GKN88, GS93b, Sha89, Sha91] </ref>, and material based on these patterns is beginning to appear in courses on architectural design of software [GSO + 92]. Among the more common architectural patterns are: Pipes and filters Graph of incremental stream transformers. Examples: Unix pipes, signal processing.
Reference: [Sha91] <author> Mary Shaw. </author> <title> Heterogeneous design idioms for software architecture. </title> <booktitle> In Proceedings of the Sixth International Workshop on Software Specification and Design, IEEE Computer Society, Software Engineering Notes, </booktitle> <pages> pages 158-165, </pages> <address> Como, Italy, </address> <month> October 25-26 </month> <year> 1991. </year>
Reference-contexts: Some of the informal terms refer to common, or idiomatic, patterns used to organize the overall system. These are often widely used among software engineers in high-level descriptions of system designs. A number of the more pervasive patterns have been identified in descriptions of architectural idioms <ref> [GKN88, GS93b, Sha89, Sha91] </ref>, and material based on these patterns is beginning to appear in courses on architectural design of software [GSO + 92]. Among the more common architectural patterns are: Pipes and filters Graph of incremental stream transformers. Examples: Unix pipes, signal processing.
Reference: [Sha93] <author> Mary Shaw. </author> <title> Procedure calls are the assembly language of system interconnection: Connectors deserve first-class status. </title> <booktitle> In Proceedings of the Workshop on Studies of Software Design, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: But the architectural level of design requires a diverse collection of abstractions to represent even the most common forms of component interconnection <ref> [Sha93] </ref>. Indeed, the interactions represented by lines in informal diagrams are drawn from a much richer and more abstract vocabulary than the language-supported mechanisms.
Reference: [SN92] <author> Kevin J. Sullivan and David Notkin. </author> <title> Reconciling environment integration and software evolution. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 1(3) </volume> <pages> 229-268, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: For example, Unix provides a shell language that supports direct definition of pipes as connectors [Bac86]. As another example, some systems support event broadcast by extending the facilities of a programming language <ref> [SN92, GS93a] </ref>. Ada supports intertask communication through rendezvous [DoD83]. Unfortunately, while all of these make it easier to describe some high-level interactions, none provide a more general facility for describing new abstractions for interaction.
Reference: [Tic79] <author> Walter F. Tichy. </author> <title> Software development control based on module interconnection. </title> <booktitle> In Proceedings of the Third International Conference on Software Engineering, </booktitle> <pages> pages 29-41. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1979. </year> <month> 15 </month>
Reference-contexts: These are sometimes called "module interconnection languages" (MILs) Representative examples of early language designs include MIL75 and Intercol <ref> [DK76, Tic79, PDN86] </ref>. A more recent example is the module description features of Standard ML (SML) [MTH90]. Module interconnection languages partially separate the description of a system configuration from the parts of the system that are being composed.
References-found: 34

