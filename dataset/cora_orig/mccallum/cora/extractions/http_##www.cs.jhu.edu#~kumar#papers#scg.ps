URL: http://www.cs.jhu.edu/~kumar/papers/scg.ps
Refering-URL: http://www.cs.jhu.edu/~kumar/
Root-URL: http://www.cs.jhu.edu
Email: E-mail: mja@cs.purdue.edu  E-mail: goodrich@cs.jhu.edu  E-mail: kumar@cs.jhu.edu  
Title: Biased Finger Trees and Three-Dimensional Layers of Maxima (Preliminary Version)  
Author: Mikhail J. Atallah Michael T. Goodrich Kumar Ramaiyer 
Address: W. Lafayette, IN 47907-1398, USA  Baltimore, MD 21218, USA  Baltimore, MD 21218, USA  
Affiliation: Department of Computer Sciences Purdue University  Department of Computer Science The Johns Hopkins University  Department of Computer Science The Johns Hopkins University  
Abstract: We present a method for maintaining biased search trees so as to support fast finger updates (i.e., updates in which one is given a pointer to the part of the tree being changed). We illustrate the power of such biased finger trees by showing how they can be used to derive an optimal O(n log n) algorithm for the 3-dimensional layers-of-maxima problem and also obtain an improved method for dynamic point location. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Agarwal, </author> <title> private communication, </title> <year> 1992. </year>
Reference-contexts: This is related to the well-known convex layers problem [7], and it appears that it can be solved for a 3-dimensional point set S in O (n log n log log n) time <ref> [1] </ref> using the dynamic fractional cascading technique of Mehlhorn and Naher [32]. We show how to solve the 3-dimensional layers-of-maxima problem in O (n log n) time, which is optimal 3 . <p> Incidentally, this is also the approach used by Chiang and Tamassia [8], albeit in a different way. Let us assume, for the time being, that the x-coordinates of the segment endpoints are integers in the range <ref> [1; n] </ref> (we will show later how to get around this restriction using the the BB [ff] tree). We define our structure recursively, following the general approach of Preparata [35]. <p> 2 n) time, however, since we now may have to perform O (log n) split operations (and their complexity, unfortunately, does not form a telescoping sum). 4.2 Rebalancing the Primary Structure In this section we show how to relax the constraint that the endpoints have x coordinates in the range <ref> [1; n] </ref>. We use a BB [ff]-tree as a primary tree for vertical cuts with biased finger tree as a secondary structure in each node. We briefly review the properties of BB [ff]-tree.
Reference: [2] <author> A. Aggarwal and J. Park, </author> <title> "Notes on searching in multidimensional monotone arrays," </title> <booktitle> in Proc. 29th IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1988, </year> <pages> 497-512. </pages>
Reference-contexts: Moreover, we provide an alternative proof that red-black trees support constant-time amortized finger updates (which is a fact known to folklore). We show the utility of the biased finger tree structure by giving an optimal O (n log n)-time space-sweeping algorithm for the well-known 3-dimensional layers-of-maxima problem <ref> [2, 7, 15, 27] </ref>. We also give improved methods for dynamic point location in a convex subdivision [35, 8], and present a method for dynamic point location in staircase subdivision with logarithmic query and update times.
Reference: [3] <author> A.V. Aho, J.E. Hopcroft, and J.D. Ullman, </author> <title> Data Structures and Algorithms, </title> <publisher> Addison-Wesley (Reading, </publisher> <address> Mass.: </address> <year> 1983). </year>
Reference-contexts: Another important variant concerns the case when each item i in the search tree is given a weight, w i . This weight is a positive integer that may be proportional to an access probability, as in an optimal binary search tree structure <ref> [3, 24] </ref>. Or it may represent the size of some auxiliary structure associated with item i, as in a link-cut structure [40] (which itself has many applications [12, 17, 18]) or in a point location structure built using the trapezoid method [8, 35, 38]. <p> Aho, Hopcroft, and Ullman <ref> [3] </ref> refer to these as the concaten-able queue operations. In this section we describe a new data structure that efficiently supports all of the these operations.
Reference: [4] <author> H. Baumgarten, H. Jung, and K. Mehlhorn, </author> <title> "Dynamic Point Location in General Subdivisions," </title> <booktitle> Proc. 3rd ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <year> 1992, </year> <pages> 250-258. </pages>
Reference-contexts: Type Queries Insert Delete Reference general O (log n log log n) O (log n log log n) O (log 2 n) Baumgarten et al. <ref> [4] </ref> connected O (log 2 n) O (log n) O (log n) Cheng-Janardan [11] 4 connected O (log n) O (log 3 n) O (log 3 n) Chiang et al. [10] monotone O (log n) O (log 2 n) O (log 2 n) Chiang-Tamassia [8] monotone O (log 2 n) O
Reference: [5] <author> S.W. Bent, D.D. Sleator, and R.E. Tarjan, </author> <title> "Biased search trees," </title> <journal> SIAM Journal of Computing, </journal> <volume> 14(3) </volume> <pages> 545-568, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: In cases with weighted items such as these one desires a search tree satisfying a bias property that the depth of each item i in the tree be inversely proportional to w i . Bent, Sleator and Tarjan <ref> [5] </ref> give a method for maintaining such a structure subject to update operations, such as insertions, deletions, joins, and splits, as well as predecessor query operations. <p> Moreover, we show that, while split operations will take O (log W=w i ) time (which is unavoidable), we can implement join operations in O (1) time. Our structure is topologically equivalent to that given by Bent, Sleator, and Tarjan <ref> [5] </ref>. In fact, if each item i has weight w i = 1, then our structure is topologically equivalent to a red-black tree [14, 21, 41]. <p> The items i 1 and i 2 need not be siblings, but should be adjacent in the total order. As mentioned above, our structure is topologically similar to the biased search tree 1 of Bent, Sleator and Tarjan <ref> [5] </ref>. Our methods for updating and analyzing these structures are significantly different, however, and achieve run times better than those of Bent et al. in most cases (see Table 1). <p> In addition, the root maintains pointers to the minimum and maximum leaf items. Every node x of the tree stores a non-negative integer rank r (x) that satisfies the natural extensions of red-black tree rank [41] to weighted sets <ref> [5] </ref>: 1. If x is a leaf, then r (x) = blog w i c, where i is the item x stores. 2. If node x has parent y, then r (x) r (y); if x is a leaf, then r (x) r (y) 1. <p> Update Operation Previous Biased Trees <ref> [5] </ref> Biased Finger Trees Search (i,T) O (log W=w i ) O (log W=w i ) Insert (i; w i ; p i ; T ) O min (w i +w i + ;w i ) O (j log w i Delete (i; T; p i ) O (log W=w i <p> If node x has grandparent y, then r (x) r (y)1. In addition to the above rank conditions, we also require that a node be minor if and only if its sibling or a child of its sibling is a major leaf <ref> [5] </ref>. We refer to this as the bias property. <p> With each node x of a biased finger tree we associate 2 a value, C (x), of "credits", with 0 C (x). Moreover, we partition these credits into three types|one type that is similar to those used in the analysis of Bent, Sleator, and Tarjan <ref> [5] </ref>, one type that assigns 1 credit to the nodes on the spine of the tree, and one type suggested by Kosaraju [26]. We omit details here. <p> Also, each operation adds at most two pairs of equal rank siblings to the tree. 2.2 Update Operations We now discuss the methods for various update operations. We begin with the join operation. We describe a "bottom-up" strategy, which, contrasts with the "top-down" approach of Bent, Sleator and Tarjan <ref> [5] </ref>. Join: Consider the join of two biased trees T x and T y . Let u and v be the rightmost leaf and the leftmost leaf of T x and T y respectively. Let w and l be the parent of u and v respectively (see Fig. 1). <p> Symmetrical to above case. Analysis: We show in the full version that the total number of credits needed to perform this update is O (1). This, and Lemma 2.1, establishes that the running time for a join is O (1). Split: We perform the split operation as in <ref> [5] </ref>. We show that with the same complexity we can preserve all three types of credits in the nodes of the resulting trees. Insertion: Consider the insertion of an item i with weight w i to a biased finger tree T . <p> Bent et al. <ref> [5] </ref> show that repeated single-node joins on the right hand side can construct a biased finger tree in O (n) worst-case time.
Reference: [6] <author> N. Blum and K. Mehlhorn, </author> <title> "On the Average Number of Rebalancing Operations in Weight-Balanced Trees," </title> <journal> Theoretical Computer Science, </journal> <volume> 11, </volume> <year> 1980, </year> <pages> 303-320. </pages>
Reference: [7] <author> B. Chazelle, </author> <title> "On the convex layers of a planar set," </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> IT-31 1985, </volume> <pages> 509-517. </pages>
Reference-contexts: Moreover, we provide an alternative proof that red-black trees support constant-time amortized finger updates (which is a fact known to folklore). We show the utility of the biased finger tree structure by giving an optimal O (n log n)-time space-sweeping algorithm for the well-known 3-dimensional layers-of-maxima problem <ref> [2, 7, 15, 27] </ref>. We also give improved methods for dynamic point location in a convex subdivision [35, 8], and present a method for dynamic point location in staircase subdivision with logarithmic query and update times. <p> The iteration number in which a point p is removed from S is called p's layer, and we denote it by l (p), and the layers-of-maxima problem is to determine the layer of each point p in S. This is related to the well-known convex layers problem <ref> [7] </ref>, and it appears that it can be solved for a 3-dimensional point set S in O (n log n log log n) time [1] using the dynamic fractional cascading technique of Mehlhorn and Naher [32].
Reference: [8] <author> Y.-J. Chiang and R. Tamassia, </author> <title> "Dynamization of the Trapezoid Method for Planar Point Location," </title> <booktitle> Proc. ACM Symp. on Computational Geometry, </booktitle> <year> 1991, </year> <pages> 61-70. </pages>
Reference-contexts: Or it may represent the size of some auxiliary structure associated with item i, as in a link-cut structure [40] (which itself has many applications [12, 17, 18]) or in a point location structure built using the trapezoid method <ref> [8, 35, 38] </ref>. In cases with weighted items such as these one desires a search tree satisfying a bias property that the depth of each item i in the tree be inversely proportional to w i . <p> We show the utility of the biased finger tree structure by giving an optimal O (n log n)-time space-sweeping algorithm for the well-known 3-dimensional layers-of-maxima problem [2, 7, 15, 27]. We also give improved methods for dynamic point location in a convex subdivision <ref> [35, 8] </ref>, and present a method for dynamic point location in staircase subdivision with logarithmic query and update times. <p> As mentioned above, our method for maintaining S is based upon a dynamic implementation of the "trapezoid method" of Preparata [35] for static point location. Incidentally, this is also the approach used by Chiang and Tamassia <ref> [8] </ref>, albeit in a different way. Let us assume, for the time being, that the x-coordinates of the segment endpoints are integers in the range [1; n] (we will show later how to get around this restriction using the the BB [ff] tree). <p> (log 2 n) Baumgarten et al. [4] connected O (log 2 n) O (log n) O (log n) Cheng-Janardan [11] 4 connected O (log n) O (log 3 n) O (log 3 n) Chiang et al. [10] monotone O (log n) O (log 2 n) O (log 2 n) Chiang-Tamassia <ref> [8] </ref> monotone O (log 2 n) O (log n) O (log n) Goodrich-Tamassia [18] rectilinear O (log n log log n) O (log n log log n) O (log n log log n) Mehlhorn-Naher [32] convex O (log n + log N ) O (log n log N ) O (log
Reference: [9] <author> Y.-J. Chiang and R. Tamassia, </author> <title> "Dynamic Algorithms in Computational Geometry," </title> <journal> Proc. of the IEEE, </journal> <volume> 80(9), </volume> <year> 1992. </year>
Reference-contexts: a monotone subdivision is one in which each face is monotone with respect to (say) the x-axis, a connected subdivision is one which forms a connected graph, and a general subdivision is one that may contain "holes." The interested reader is referred to the excellent survey by Chiang and Tamassia <ref> [9] </ref> for a discussion of these and other results in dynamic computational geometry. 4.1 Our Data Structure Suppose we are given a convex subdivision S that we would like to maintain dynamically subject to point location queries and edge and vertex insertions and deletions.
Reference: [10] <author> Y.-J. Chiang, F.P. Preparata, and R. </author> <title> Tamassia "A Unified Approach to Dynamic Point Location, Ray Shooting, and Shortest Paths in Planar Maps," </title> <booktitle> Proc. 4th ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <year> 1993, </year> <pages> 44-53. </pages>
Reference-contexts: general O (log n log log n) O (log n log log n) O (log 2 n) Baumgarten et al. [4] connected O (log 2 n) O (log n) O (log n) Cheng-Janardan [11] 4 connected O (log n) O (log 3 n) O (log 3 n) Chiang et al. <ref> [10] </ref> monotone O (log n) O (log 2 n) O (log 2 n) Chiang-Tamassia [8] monotone O (log 2 n) O (log n) O (log n) Goodrich-Tamassia [18] rectilinear O (log n log log n) O (log n log log n) O (log n log log n) Mehlhorn-Naher [32] convex O
Reference: [11] <author> S.W. Cheng and R. Janardan, </author> <title> "New Results on Dynamic Planar Point Location," </title> <booktitle> 31st IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> 96-105, </pages> <year> 1990. </year>
Reference-contexts: Type Queries Insert Delete Reference general O (log n log log n) O (log n log log n) O (log 2 n) Baumgarten et al. [4] connected O (log 2 n) O (log n) O (log n) Cheng-Janardan <ref> [11] </ref> 4 connected O (log n) O (log 3 n) O (log 3 n) Chiang et al. [10] monotone O (log n) O (log 2 n) O (log 2 n) Chiang-Tamassia [8] monotone O (log 2 n) O (log n) O (log n) Goodrich-Tamassia [18] rectilinear O (log n log log
Reference: [12] <author> R.F. Cohen and R. Tamassia, </author> <title> "Dynamic Expression Trees and their Applications," </title> <booktitle> Proc. 2nd ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <year> 1991, </year> <pages> 52-61. </pages>
Reference-contexts: This weight is a positive integer that may be proportional to an access probability, as in an optimal binary search tree structure [3, 24]. Or it may represent the size of some auxiliary structure associated with item i, as in a link-cut structure [40] (which itself has many applications <ref> [12, 17, 18] </ref>) or in a point location structure built using the trapezoid method [8, 35, 38].
Reference: [13] <author> R. Cole, </author> <title> "Searching and Storing Similar Lists," </title> <journal> J. of Algorithms, </journal> <volume> Vol. 7, </volume> <month> 202-220 </month> <year> (1986). </year>
Reference-contexts: The point location problem is to construct a data structure that allows one to determine for any query point p the name of the cell in S that contains p (see <ref> [13, 15, 16, 23, 28, 29, 35, 36, 39] </ref>). It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time [13, 16, 23, 39]. <p> It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time <ref> [13, 16, 23, 39] </ref>. These optimal data structures are static, however, in that they do not allow for any changes to S to occur after the data structure is constructed.
Reference: [14] <author> T.H. Cormen, C.E. Leiserson, and R.L. Rivest, </author> <title> Introduction to Algorithms, </title> <publisher> MIT Press (Cambridge, </publisher> <address> Mass.: </address> <year> 1990). </year>
Reference-contexts: 1 Introduction Binary search trees are one of the most useful data structures, and are ubiquitous throughout the design and analysis of efficient algorithms <ref> [14] </ref>. In some cases they serve as a stand-alone structure (e.g., implementing a dictionary or a heap), while in many cases they are used in tandem with other structures, either as primary or secondary structures (or both, as in the range tree [36]). <p> Our structure is topologically equivalent to that given by Bent, Sleator, and Tarjan [5]. In fact, if each item i has weight w i = 1, then our structure is topologically equivalent to a red-black tree <ref> [14, 21, 41] </ref>. It is our update methods and amortized analysis that are different, and this is what allows us to achieve running times that are significant improvements over those obtained by Bent, Sleator, and Tarjan, even if one ignores the search times in their update procedures.
Reference: [15] <author> H. Edelsbrunner, </author> <title> Algorithms in Combinatorial Geometry, </title> <publisher> Springer-Verlag, </publisher> <address> NY, </address> <year> 1987. </year>
Reference-contexts: Moreover, we provide an alternative proof that red-black trees support constant-time amortized finger updates (which is a fact known to folklore). We show the utility of the biased finger tree structure by giving an optimal O (n log n)-time space-sweeping algorithm for the well-known 3-dimensional layers-of-maxima problem <ref> [2, 7, 15, 27] </ref>. We also give improved methods for dynamic point location in a convex subdivision [35, 8], and present a method for dynamic point location in staircase subdivision with logarithmic query and update times. <p> The point location problem is to construct a data structure that allows one to determine for any query point p the name of the cell in S that contains p (see <ref> [13, 15, 16, 23, 28, 29, 35, 36, 39] </ref>). It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time [13, 16, 23, 39].
Reference: [16] <author> H. Edelsbrunner, L.J. Guibas, and J. Stolfi, </author> <title> "Optimal Point Location in a Monotone Subdivision," </title> <journal> SIAM J. Computing, </journal> <volume> Vol. 15, No. 2, </volume> <pages> 317-340, </pages> <year> 1986. </year>
Reference-contexts: The point location problem is to construct a data structure that allows one to determine for any query point p the name of the cell in S that contains p (see <ref> [13, 15, 16, 23, 28, 29, 35, 36, 39] </ref>). It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time [13, 16, 23, 39]. <p> It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time <ref> [13, 16, 23, 39] </ref>. These optimal data structures are static, however, in that they do not allow for any changes to S to occur after the data structure is constructed.
Reference: [17] <author> D. Eppstein, G.F. Italiano, R. Tamassia, R.E. Tarjan, J. Westbrook, and M. Yung, </author> <title> "Maintenance of a Minimum Spanning Forest in a Dynamic Planar Graph," </title> <journal> J. Algorithms, </journal> <volume> 13, </volume> <year> 1992, </year> <pages> 33-54. </pages>
Reference-contexts: This weight is a positive integer that may be proportional to an access probability, as in an optimal binary search tree structure [3, 24]. Or it may represent the size of some auxiliary structure associated with item i, as in a link-cut structure [40] (which itself has many applications <ref> [12, 17, 18] </ref>) or in a point location structure built using the trapezoid method [8, 35, 38].
Reference: [18] <author> M.T. Goodrich and R. Tamassia, </author> <title> "Dynamic Trees and Dynamic Point Location," </title> <booktitle> Proc. 23rd ACM Symp. on Theory of Computing, </booktitle> <year> 1991, </year> <pages> 523-533. </pages>
Reference-contexts: This weight is a positive integer that may be proportional to an access probability, as in an optimal binary search tree structure [3, 24]. Or it may represent the size of some auxiliary structure associated with item i, as in a link-cut structure [40] (which itself has many applications <ref> [12, 17, 18] </ref>) or in a point location structure built using the trapezoid method [8, 35, 38]. <p> (log n) O (log n) Cheng-Janardan [11] 4 connected O (log n) O (log 3 n) O (log 3 n) Chiang et al. [10] monotone O (log n) O (log 2 n) O (log 2 n) Chiang-Tamassia [8] monotone O (log 2 n) O (log n) O (log n) Goodrich-Tamassia <ref> [18] </ref> rectilinear O (log n log log n) O (log n log log n) O (log n log log n) Mehlhorn-Naher [32] convex O (log n + log N ) O (log n log N ) O (log n log N ) Preparata-Tamassia [38] convex 5 O (log n) O (log
Reference: [19] <author> M.T. Goodrich and R. Tamassia, </author> <title> "Dynamic Ray Shooting and Shortest Paths via Balanced Geodesic Triangulations," </title> <booktitle> Proc. 9th ACM Symp. on Computational Geometry, </booktitle> <year> 1993, </year> <pages> 318-327. </pages>
Reference-contexts: In many dynamic computational geometry algorithms they may even be found as tertiary structures, e.g., Goodrich and Tamassia <ref> [19] </ref>. fl This research supported by the NSF under Grant CCR-9202807. y This research supported by the NSF and DARPA under Grant CCR-8908092, by the NSF under Grants CCR-9003299, CDA-9015667, CCR-9300079, and IRI-9116843. z This research supported by the NSF and DARPA under Grant CCR-8908092 and by the NSF under Grant
Reference: [20] <author> L.J. Guibas, E.M. McCreight, M.F. Plass, and J.R. Roberts, </author> <title> "A New Representation for Linear Lists," </title> <booktitle> Proc. 9th ACM Symp. on Theory of Computing, </booktitle> <year> 1977, </year> <pages> 49-60. </pages>
Reference-contexts: This may not be appropriate when T is used in tandem with other structures, however, for one may be given, as part of the input to an update operation, pointers, or "fingers" <ref> [20, 25, 22] </ref>, directly into the part of T being changed. Such a pointer could come, for example, from a query in some auxiliary data structure.
Reference: [21] <author> L.J. Guibas and R. Sedgewick, </author> <title> "A Dichromatic Framework for Balanced Trees," </title> <booktitle> Proc. 19th IEEE Symp. on Foundations of Computer Science, </booktitle> <year> 1978, </year> <pages> 8-21. </pages>
Reference-contexts: Our structure is topologically equivalent to that given by Bent, Sleator, and Tarjan [5]. In fact, if each item i has weight w i = 1, then our structure is topologically equivalent to a red-black tree <ref> [14, 21, 41] </ref>. It is our update methods and amortized analysis that are different, and this is what allows us to achieve running times that are significant improvements over those obtained by Bent, Sleator, and Tarjan, even if one ignores the search times in their update procedures.
Reference: [22] <author> S. Huddleston and K. Mehlhorn, </author> <title> "A New Data Structure for Representing Sorted Lists," </title> <journal> Acta Informatica, </journal> <volume> 17, </volume> <year> 1982, </year> <pages> 157-184. </pages>
Reference-contexts: This may not be appropriate when T is used in tandem with other structures, however, for one may be given, as part of the input to an update operation, pointers, or "fingers" <ref> [20, 25, 22] </ref>, directly into the part of T being changed. Such a pointer could come, for example, from a query in some auxiliary data structure. <p> Such a pointer could come, for example, from a query in some auxiliary data structure. This may, in fact, have been a prime motivating factor behind the method of Huddleston and Mehlhorn <ref> [22] </ref> for designing a dynamic search tree that has an O (1) update time performance for insertions and deletions when the search time is not counted, where we use " O () time" to refer to a worst-case time bound that is amortized over a sequence of updates.
Reference: [23] <author> D. Kirkpatrick, </author> <title> "Optimal Search in Planar Subdivision," </title> <journal> SIAM Journal on Computing, </journal> <volume> Vol. 12, No. 1, </volume> <month> February </month> <year> 1983, </year> <pages> pp. 28-35. </pages>
Reference-contexts: The point location problem is to construct a data structure that allows one to determine for any query point p the name of the cell in S that contains p (see <ref> [13, 15, 16, 23, 28, 29, 35, 36, 39] </ref>). It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time [13, 16, 23, 39]. <p> It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time <ref> [13, 16, 23, 39] </ref>. These optimal data structures are static, however, in that they do not allow for any changes to S to occur after the data structure is constructed.
Reference: [24] <author> D.E. Knuth, </author> <title> Sorting and Searching, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1973. </year>
Reference-contexts: Another important variant concerns the case when each item i in the search tree is given a weight, w i . This weight is a positive integer that may be proportional to an access probability, as in an optimal binary search tree structure <ref> [3, 24] </ref>. Or it may represent the size of some auxiliary structure associated with item i, as in a link-cut structure [40] (which itself has many applications [12, 17, 18]) or in a point location structure built using the trapezoid method [8, 35, 38].
Reference: [25] <author> S.R. Kosaraju, </author> <title> "Localized Search in Sorted Lists," </title> <booktitle> in Proc. 13th Annual ACM Symp. on Theory of Computing, </booktitle> <year> 1981, </year> <pages> pp. 62-69. </pages>
Reference-contexts: This may not be appropriate when T is used in tandem with other structures, however, for one may be given, as part of the input to an update operation, pointers, or "fingers" <ref> [20, 25, 22] </ref>, directly into the part of T being changed. Such a pointer could come, for example, from a query in some auxiliary data structure.
Reference: [26] <author> S.R. Kosaraju, </author> <title> "An Optimal RAM Implementation of Catenable Min Double-ended Queues," </title> <booktitle> Proc. 5th ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <year> 1994, </year> <pages> 195-203. </pages>
Reference-contexts: Moreover, we partition these credits into three types|one type that is similar to those used in the analysis of Bent, Sleator, and Tarjan [5], one type that assigns 1 credit to the nodes on the spine of the tree, and one type suggested by Kosaraju <ref> [26] </ref>. We omit details here. After an update operation, we perform promote or demote operations on the ranks of some of the nodes of the biased finger tree, which increase or decrease the rank of the nodes, respectively.
Reference: [27] <author> H.T. Kung, F. Luccio, </author> <title> F.P. Preparata, "On Finding the Maxima of a Set of Vectors," </title> <journal> J. ACM, </journal> <volume> Vol. 22, No. 4, </volume> <year> 1975, </year> <pages> pp. 469-476. </pages>
Reference-contexts: Moreover, we provide an alternative proof that red-black trees support constant-time amortized finger updates (which is a fact known to folklore). We show the utility of the biased finger tree structure by giving an optimal O (n log n)-time space-sweeping algorithm for the well-known 3-dimensional layers-of-maxima problem <ref> [2, 7, 15, 27] </ref>. We also give improved methods for dynamic point location in a convex subdivision [35, 8], and present a method for dynamic point location in staircase subdivision with logarithmic query and update times. <p> We define the dominance region of a point p in &lt; 3 as a set D &lt; 3 such that p dominates every point q 2 D. The maxima set problem is to find all the maximum points in S. Kung, Luccio, and Preparata <ref> [27] </ref> showed that this problem can be solved in O (n log n) time. In the related layers-of-maxima problem, one imagines an iterative process, where one finds a maxima set M in S, removes all the points of M from S, and repeats this process until S is empty.
Reference: [28] <author> D.T. Lee and F.P. Preparata, </author> <title> "Location of a Point in a Planar Subdivision and its Applications," </title> <journal> SIAM J. Computing, </journal> <volume> Vol. 6, No. 3, </volume> <pages> 594-606, </pages> <year> 1977. </year>
Reference-contexts: The point location problem is to construct a data structure that allows one to determine for any query point p the name of the cell in S that contains p (see <ref> [13, 15, 16, 23, 28, 29, 35, 36, 39] </ref>). It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time [13, 16, 23, 39].
Reference: [29] <author> D.T. Lee and F.P. Preparata, </author> <title> "Computational Geometry|A Survey," </title> <journal> IEEE Trans. on Computers, </journal> <volume> C-33(12), </volume> <year> 1984, </year> <pages> 872-1101. </pages>
Reference-contexts: The point location problem is to construct a data structure that allows one to determine for any query point p the name of the cell in S that contains p (see <ref> [13, 15, 16, 23, 28, 29, 35, 36, 39] </ref>). It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time [13, 16, 23, 39].
Reference: [30] <author> K. Mehlhorn, </author> <title> Data Structures and Algorithms 1: Sorting and Searching, </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: Also, assume that we perform a sequence of n update operations, each an insertion or a deletion, into an initially empty BB [ff]-tree. Now, we have the following times for rebalancing <ref> [30] </ref>: * If f (l) = O (l log c l), with c 0, then the rebalancing time for an update operation is O (log c+1 n). * If f (l) = O (l a ), with a &lt; 1, then the rebalancing time for an update operation is O (1).
Reference: [31] <author> K. Mehlhorn, </author> <title> Data Structures and Algorithms 3: Multi-dimensional Searching and Computational Geometry, </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: The structure of T has the property that any face or edge covers at most O (log n) trapezoids and also each face or edge covers at most two nodes at any level of T . These properties follow easily from segment tree like arguments <ref> [31] </ref>. We now describe the point-location query algorithm for our data structure. Consider the operation query (t; x; y), where x and y represent the coordinates of the query point and t is a current trapezoid in the subdivision (which represents a node in our primary data structure).
Reference: [32] <author> K. Mehlhorn and S. Naher, </author> <title> "Dynamic Fractional Cascading," </title> <journal> Algorithmica, </journal> <volume> 5, </volume> <year> 1990, </year> <pages> 215-241. </pages>
Reference-contexts: This is related to the well-known convex layers problem [7], and it appears that it can be solved for a 3-dimensional point set S in O (n log n log log n) time [1] using the dynamic fractional cascading technique of Mehlhorn and Naher <ref> [32] </ref>. We show how to solve the 3-dimensional layers-of-maxima problem in O (n log n) time, which is optimal 3 . We solve this problem using a three-dimensional sweep, and a dynamic method for point location in a staircase subdivision. <p> et al. [10] monotone O (log n) O (log 2 n) O (log 2 n) Chiang-Tamassia [8] monotone O (log 2 n) O (log n) O (log n) Goodrich-Tamassia [18] rectilinear O (log n log log n) O (log n log log n) O (log n log log n) Mehlhorn-Naher <ref> [32] </ref> convex O (log n + log N ) O (log n log N ) O (log n log N ) Preparata-Tamassia [38] convex 5 O (log n) O (log n) O (log 2 n) this paper staircase O (log n) O (log n) O (log n) this paper Table 2:
Reference: [33] <author> I. Nievergelt and E.M. Reingold, </author> <title> "Binary Search Trees of Bounded Balance," </title> <journal> SIAM J. Comput., </journal> <volume> 2, </volume> <year> 1973, </year> <pages> 33-43. </pages>
Reference: [34] <author> M. Overmars, </author> <title> The Design of Dynamic Data Structures, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1983. </year>
Reference-contexts: Our structure is a rooted tree, T , each of whose nodes is associated with a trapezoid t whose parallel bound 4 Cheng and Janardan's update method is actually a de-amortization of an amortized scheme via the "rebuild-while-you-work" technique of Overmars <ref> [34] </ref>. 5 Our method can actually used for any dynamic point location environment satisfying a certain pseudo-edge property.
Reference: [35] <author> F.P. Preparata, </author> <title> "A New Approach to Planar Point Location," </title> <journal> SIAM J. Computing, </journal> <volume> Vol. 10, No. 3, </volume> <year> 1981, </year> <pages> 73-83. </pages>
Reference-contexts: Or it may represent the size of some auxiliary structure associated with item i, as in a link-cut structure [40] (which itself has many applications [12, 17, 18]) or in a point location structure built using the trapezoid method <ref> [8, 35, 38] </ref>. In cases with weighted items such as these one desires a search tree satisfying a bias property that the depth of each item i in the tree be inversely proportional to w i . <p> We show the utility of the biased finger tree structure by giving an optimal O (n log n)-time space-sweeping algorithm for the well-known 3-dimensional layers-of-maxima problem [2, 7, 15, 27]. We also give improved methods for dynamic point location in a convex subdivision <ref> [35, 8] </ref>, and present a method for dynamic point location in staircase subdivision with logarithmic query and update times. <p> The point location problem is to construct a data structure that allows one to determine for any query point p the name of the cell in S that contains p (see <ref> [13, 15, 16, 23, 28, 29, 35, 36, 39] </ref>). It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time [13, 16, 23, 39]. <p> As mentioned above, our method for maintaining S is based upon a dynamic implementation of the "trapezoid method" of Preparata <ref> [35] </ref> for static point location. Incidentally, this is also the approach used by Chiang and Tamassia [8], albeit in a different way. <p> Let us assume, for the time being, that the x-coordinates of the segment endpoints are integers in the range [1; n] (we will show later how to get around this restriction using the the BB [ff] tree). We define our structure recursively, following the general approach of Preparata <ref> [35] </ref>. <p> This is because the times to perform the biased merge tree queries down a path in T form a telescoping sum that is O (log w (r)). Noting that w (r) is O (n log n) <ref> [35] </ref> and depth (t ) is O (log n) (since our primary data structure is kept balanced) gives us the desired result that a point location query takes O (log n) time.
Reference: [36] <author> F.P. Preparata and M.I. Shamos, </author> <title> Computational Geometry: An Introduction, </title> <publisher> Springer-Verlag, </publisher> <address> NY, </address> <year> 1985. </year>
Reference-contexts: In some cases they serve as a stand-alone structure (e.g., implementing a dictionary or a heap), while in many cases they are used in tandem with other structures, either as primary or secondary structures (or both, as in the range tree <ref> [36] </ref>). <p> The point location problem is to construct a data structure that allows one to determine for any query point p the name of the cell in S that contains p (see <ref> [13, 15, 16, 23, 28, 29, 35, 36, 39] </ref>). It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time [13, 16, 23, 39].
Reference: [37] <author> F.P. Preparata and R. Tamassia, </author> <title> "Fully Dynamic Point Location in a Monotone Subdivision," </title> <journal> SIAM J. Computing, </journal> <volume> Vol. 18, No. 4, </volume> <pages> 811-830, </pages> <year> 1989. </year>
Reference: [38] <author> Preparata, F.P. and R. Tamassia, </author> <title> "Dynamic Planar Point Location with Optimal Query Time," </title> <journal> Theoretical Computer Science, </journal> <volume> Vol. 74, No. 1, </volume> <pages> 95-114, </pages> <year> 1990. </year>
Reference-contexts: Or it may represent the size of some auxiliary structure associated with item i, as in a link-cut structure [40] (which itself has many applications [12, 17, 18]) or in a point location structure built using the trapezoid method <ref> [8, 35, 38] </ref>. In cases with weighted items such as these one desires a search tree satisfying a bias property that the depth of each item i in the tree be inversely proportional to w i . <p> O (log n) O (log n) Goodrich-Tamassia [18] rectilinear O (log n log log n) O (log n log log n) O (log n log log n) Mehlhorn-Naher [32] convex O (log n + log N ) O (log n log N ) O (log n log N ) Preparata-Tamassia <ref> [38] </ref> convex 5 O (log n) O (log n) O (log 2 n) this paper staircase O (log n) O (log n) O (log n) this paper Table 2: Previous and New results in dynamic point location.
Reference: [39] <author> N. Sarnak and R.E. Tarjan, </author> <title> "Planar Point Location Using Persistent Search Trees," </title> <journal> Communications ACM, </journal> <volume> Vol. 29, No. 7, </volume> <pages> 669-679, </pages> <year> 1986. </year>
Reference-contexts: The point location problem is to construct a data structure that allows one to determine for any query point p the name of the cell in S that contains p (see <ref> [13, 15, 16, 23, 28, 29, 35, 36, 39] </ref>). It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time [13, 16, 23, 39]. <p> It is well-known that one can construct a linear-space data structure for answering such queries in O (log n) time <ref> [13, 16, 23, 39] </ref>. These optimal data structures are static, however, in that they do not allow for any changes to S to occur after the data structure is constructed.
Reference: [40] <author> D.D. Sleator and R.E. Tarjan, </author> <title> "A Data Structure for Dynamic Trees," </title> <journal> J. Comput. and Sys. Sci., </journal> <volume> 26, </volume> <pages> 362-391, </pages> <year> 1983. </year>
Reference-contexts: This weight is a positive integer that may be proportional to an access probability, as in an optimal binary search tree structure [3, 24]. Or it may represent the size of some auxiliary structure associated with item i, as in a link-cut structure <ref> [40] </ref> (which itself has many applications [12, 17, 18]) or in a point location structure built using the trapezoid method [8, 35, 38].
Reference: [41] <author> R.E. Tarjan, </author> <title> Data Structures and Network Algo--rithms, </title> <publisher> SIAM, </publisher> <address> Philadelphia, PA, </address> <year> 1983. </year>
Reference-contexts: Our structure is topologically equivalent to that given by Bent, Sleator, and Tarjan [5]. In fact, if each item i has weight w i = 1, then our structure is topologically equivalent to a red-black tree <ref> [14, 21, 41] </ref>. It is our update methods and amortized analysis that are different, and this is what allows us to achieve running times that are significant improvements over those obtained by Bent, Sleator, and Tarjan, even if one ignores the search times in their update procedures. <p> In addition, the root maintains pointers to the minimum and maximum leaf items. Every node x of the tree stores a non-negative integer rank r (x) that satisfies the natural extensions of red-black tree rank <ref> [41] </ref> to weighted sets [5]: 1. If x is a leaf, then r (x) = blog w i c, where i is the item x stores. 2. If node x has parent y, then r (x) r (y); if x is a leaf, then r (x) r (y) 1. <p> We show that the total complexity of promotion, demotion and rebalancing operations due to a single promote or demote operation is O (1). The structure of our case analysis follows closely that Tarjan <ref> [41] </ref> used 2 This credit notion is only used for analysis purposes. No actual credits are stored anywhere. for red-black trees.
Reference: [42] <author> R.E. Tarjan, </author> <title> "Amortized computational complexity," </title> <journal> SIAM J. Alg. Disc. Meth., </journal> <volume> 6(2) </volume> <pages> 306-318, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: We use the banker's view of amortization <ref> [42] </ref> to analyze the rebalancing and update operations. With each node x of a biased finger tree we associate 2 a value, C (x), of "credits", with 0 C (x).
References-found: 42

