URL: ftp://db.stanford.edu/pub/papers/view-aggr.ps
Refering-URL: http://www.cs.toronto.edu/~mendel/dwbib.html
Root-URL: 
Email: quass@cs.stanford.edu  
Title: Maintenance Expressions for Views with Aggregation  
Author: Dallan Quass 
Affiliation: Stanford University  
Abstract: Materialized views, especially views involving aggregation, are often used in environments such as data warehouses to speed up the evaluation of complex queries. Because the views can be quite complex, as changes are made to the underlying base data it is usually better to incrementally maintain a view by propagating changes to base data onto the view than to recompute the view from scratch. Griffin and Libkin [GL95] provide a framework for deriving incremental view maintenance expressions for a view with duplicate semantics, where the view can be defined using any number of select, project, join, bag union, and monus bag-algebra operators. However, aggregation was considered only in a limited sense; for example, aggregation with group-by attributes was not allowed. We extend the framework of [GL95] to include maintaining views with aggregation in the general case, where aggregation can include group-by attributes and a view can include several aggregate operators. 
Abstract-found: 1
Intro-found: 1
Reference: [CS94] <author> Surajit Chaudhuri and Kyuseok Shim. </author> <title> Including groupby in query optimization. </title> <editor> In Jorge Bocca, Matthias Jarke, and Carlo Zaniolo, editors, </editor> <booktitle> Proceedings of the 20 th International Conference on Very Large Databases, </booktitle> <pages> pages 354-366, </pages> <address> Santiago, Chile, </address> <month> September 12-15 </month> <year> 1994. </year>
Reference-contexts: Reasoning about aggregation is difficult because aggregate operators behave very differently than other relational- and bag-algebra operators. For example, while rules for optimizing queries with other operators have long been known, only recently have rules for optimizing queries with aggregate operators been given <ref> [CS94, GHQ95, YL95] </ref>. In this paper we extend the work of [GL95] in an important way by giving incremental view maintenance expressions for the general case of views with aggregation.
Reference: [GBLP95] <author> J. Gray, A. Bosworth, A. Layman, and H. Pira-hesh. </author> <title> Data cube: A relational aggregation operator generalizing group-by, cross-tab, and subtotals. </title> <type> Technical report no. </type> <institution> msr-tr-95-22, Mi-crosoft, </institution> <year> 1995. </year>
Reference-contexts: Materialized views involving aggregation are especially important in data warehouses because clients of the warehouse often want to summarize data in order to analyze trends <ref> [GBLP95, HRU96] </ref>.
Reference: [GHQ95] <author> A. Gupta, V. Harinarayan, and D. Quass. </author> <title> Generalized projections: A powerful approach to aggregation. </title> <editor> In Umeshwar Dayal, Peter M.D. Gray, and Shojiro Nishio, editors, </editor> <booktitle> Proceedings of the 21 st International Conference on Very Large Databases, </booktitle> <address> Zurich, Switzerland, </address> <month> September 11-15 </month> <year> 1995. </year>
Reference-contexts: Reasoning about aggregation is difficult because aggregate operators behave very differently than other relational- and bag-algebra operators. For example, while rules for optimizing queries with other operators have long been known, only recently have rules for optimizing queries with aggregate operators been given <ref> [CS94, GHQ95, YL95] </ref>. In this paper we extend the work of [GL95] in an important way by giving incremental view maintenance expressions for the general case of views with aggregation. <p> In this paper we extend the approach of [GL95] by defining change propagation equations and corresponding change propagation functions for aggregate operators. 3.2 Generalized projection We will use the generalized projection operator, denoted as A , from <ref> [GHQ95] </ref> to represent aggregation. The generalized projection operator is an extension of duplicate-eliminating projection, where the projected attributes A can include aggregate functions as well as regular attributes. The regular attributes become group-by attributes for the aggregate functions. <p> In a sense, we can "push" the join with A ffi (ffiR) down past the aggregate operator A (R) to reduce the number of tuples involved in the aggregation, which can reduce the overall cost of computation <ref> [GHQ95] </ref>. Furthermore, both A ffi (ffiR) 1 GB (A) A (R) and A ffi (ffiR) &gt;&lt; GB (A) A (R) can be evaluated simultaneously.
Reference: [GL95] <author> T. Griffin and L. Libkin. </author> <title> Incremental maintenance of views with duplicates. </title> <editor> In M. Carey and D. Schneider, editors, </editor> <booktitle> Proceedings of ACM SIG-MOD 1995 International Conference on Management of Data, </booktitle> <pages> pages 328-339, </pages> <address> San Jose, CA, </address> <month> May 23-25 </month> <year> 1995. </year>
Reference-contexts: Incrementally maintaining a view can be significantly cheaper than recomputing the view from scratch, especially if the size of the view is large compared to the size of the changes <ref> [GL95] </ref>. Materialized views involving aggregation are especially important in data warehouses because clients of the warehouse often want to summarize data in order to analyze trends [GBLP95, HRU96]. <p> Existing formulas for incremental view maintenance <ref> [GMS93, GL95] </ref> are not able to maintain views with aggregation in the general case. In particular, Griffin and Libkin [GL95] give an algebraic approach to incremental view maintenance that is based upon bag algebra, which allows maintaining views that have the SQL bag semantics. <p> Existing formulas for incremental view maintenance [GMS93, GL95] are not able to maintain views with aggregation in the general case. In particular, Griffin and Libkin <ref> [GL95] </ref> give an algebraic approach to incremental view maintenance that is based upon bag algebra, which allows maintaining views that have the SQL bag semantics. Changes to base data are propagated onto a view by propagating the changes up through each of the operators in the view definition. <p> For example, while rules for optimizing queries with other operators have long been known, only recently have rules for optimizing queries with aggregate operators been given [CS94, GHQ95, YL95]. In this paper we extend the work of <ref> [GL95] </ref> in an important way by giving incremental view maintenance expressions for the general case of views with aggregation. The view can include additional operators following the aggregate operator, including other aggregate operators, and the aggregate operator can include group-by attributes. <p> We present maintenance expressions for aggregate operators that return results as updates when possible. Paper Outline Related work is given in Section 2. Section 3 briefly explains the framework given in <ref> [GL95] </ref> for deriving view maintenance expressions and introduces the notation we will use for aggregation. Section 4 presents simple maintenance expressions for propagating insertions and for propagating deletions when the aggregate operator does not include min or max functions. <p> Section 6 gives maintenance expressions for aggregate operators that return results as updates when possible. Conclusions and areas of future work are given in Section 7. 2 Related Work As explained previously, Griffin and Libkin <ref> [GL95] </ref> present an algorithm for deriving incremental view maintenance expressions for views with duplicates. Their algorithm is based on functions that propagate deletions and insertions to base relations onto a materialized view by propagating them up through the operators in the view definition. <p> They give functions for propagating deletions and insertions up through select, duplicate-eliminating project, duplicate-preserving project, cartesian-product, bag union, and monus operators. Aggregation is considered in <ref> [GL95] </ref> but group-by attributes are not allowed. Further, the effect of deletions and insertions on the result of an aggregate function is handled outside the rest of their framework by updating an aggregate function result. <p> Also, they do not consider the problems associated with maintaining min and max aggregate functions in the presence of deletions. In a sense this paper expresses the formula for aggregation of [GMS93] within the algebraic framework of <ref> [GL95] </ref>. <p> Other work [GLT, QW91] has dealt with deriving maintenance expressions for views without duplicates (set semantics). Maintaining views that involve aggregation is not considered. 3 Preliminaries In Section 3.1 we briefly explain the framework given in <ref> [GL95] </ref> that we will extend for aggregation. We then present in Section 3.2 the notation we will use to represent aggregate operators. First we need some general notation. <p> For example, we could let 5 (t; V ) equal V and 4 (t; V ) equal pre (t; V ), but this is equivalent to recomputing the view from scratch. To guard against such wasteful definitions, <ref> [GL95] </ref> introduces the concept of "minimality" to ensure that no unnecessary tuples are produced. Functions are defined to be weakly minimal if 5 (t; V ) V = b , meaning that only tuples in V are deleted. <p> = b , meaning that tuples are not deleted and then reinserted. (The operator "min" takes the minimum intersection of two multisets by taking the minimum count of each distinct tuple in common between the two multisets.) In order to derive 5 (t; V ) and 4 (t; V ), <ref> [GL95] </ref> begins by giving change propagation equations that show how deletions and insertions are propagated up through each of the following operators: , fi, ], , , and duplicate-eliminating projection. For example, the following change propagation equations show how deletions and insertions are propagated up through and . <p> For example, the following functions from <ref> [GL95] </ref> propagate deletions and insertions to a bag-algebra expression S up through operators p (S) and A (S), and guarantee strong minimality. <p> In this paper we extend the approach of <ref> [GL95] </ref> by defining change propagation equations and corresponding change propagation functions for aggregate operators. 3.2 Generalized projection We will use the generalized projection operator, denoted as A , from [GHQ95] to represent aggregation.
Reference: [GLT] <author> Timothy Griffin, Leonid Libkin, and Howard Trickey. </author> <title> An improved algorithm for incremental recomputation of active relational expressions. </title> <note> to appear in IEEE Transactions on Knowledge and Data Engineering. </note>
Reference-contexts: Other work <ref> [GLT, QW91] </ref> has dealt with deriving maintenance expressions for views without duplicates (set semantics). Maintaining views that involve aggregation is not considered. 3 Preliminaries In Section 3.1 we briefly explain the framework given in [GL95] that we will extend for aggregation.
Reference: [GMS93] <author> A. Gupta, I. Mumick, and V. Subrahmanian. </author> <title> Maintaining views incrementally. </title> <booktitle> In Proceedings of ACM SIGMOD 1993 International Conference on Management of Data, </booktitle> <address> Washington, DC, </address> <month> May 26-28 </month> <year> 1993. </year>
Reference-contexts: Existing formulas for incremental view maintenance <ref> [GMS93, GL95] </ref> are not able to maintain views with aggregation in the general case. In particular, Griffin and Libkin [GL95] give an algebraic approach to incremental view maintenance that is based upon bag algebra, which allows maintaining views that have the SQL bag semantics. <p> Because aggregation is handled outside their framework, the aggregate operator is restricted to be the top-most operator in the view. Gupta et al. <ref> [GMS93] </ref> also present algorithms for incrementally maintaining views with duplicates. Their algorithms are applied in the context of datalog programs that produce multisets (bags). The multisets are represented by annotating each tuple with a count indicating the number of distinct derivations (i.e., the multiplicity) of the tuple in the multiset. <p> Tuples to be inserted or deleted are also annotated with counts indicating the number of times the tuple is to be inserted or deleted, with deletions represented by negative counts. Changes are propagated by following an algorithm that correctly propagates tuple counts. Aggregation is considered in <ref> [GMS93] </ref> and group-by attributes are allowed. But their formula does not include the cases where propagating insertions and deletions causes new tuples to be inserted into the result of the aggregate operator or tuples to be deleted from the result of the aggregate operator. <p> Also, they do not consider the problems associated with maintaining min and max aggregate functions in the presence of deletions. In a sense this paper expresses the formula for aggregation of <ref> [GMS93] </ref> within the algebraic framework of [GL95].
Reference: [HRU96] <author> V. Harinarayan, A. Rajaraman, and J.D. Ull-man. </author> <title> Implementing data cubes efficiently. </title> <booktitle> In Proceedings of ACM SIGMOD 1996 International Conference on Management of Data, </booktitle> <year> 1996. </year>
Reference-contexts: Materialized views involving aggregation are especially important in data warehouses because clients of the warehouse often want to summarize data in order to analyze trends <ref> [GBLP95, HRU96] </ref>.
Reference: [MS93] <author> J. Melton and A. Simon. </author> <title> Understanding the New SQL: A Complete Guide. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: Thus, a i computes the value of the aggregate function for tuples in 4 (t; R), and b i computes the value of the aggregate function for tuples in 5 (t; R). With regard to nulls in aggregation we assume the SQL-92 <ref> [MS93] </ref> semantics| that nulls are ignored when computing aggregate values. We are now ready to define the C i conditions used in the functions.
Reference: [QW91] <author> Xiaolei Qian and Gio Wiederhold. </author> <title> Incremental recomputation of active relational expressions. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <pages> pages 337-341, </pages> <year> 1991. </year>
Reference-contexts: Other work <ref> [GLT, QW91] </ref> has dealt with deriving maintenance expressions for views without duplicates (set semantics). Maintaining views that involve aggregation is not considered. 3 Preliminaries In Section 3.1 we briefly explain the framework given in [GL95] that we will extend for aggregation.
Reference: [YL95] <author> W. Yan and P. Larson. </author> <title> Eager aggregation and lazy aggregation. </title> <editor> In Umeshwar Dayal, Peter M.D. Gray, and Shojiro Nishio, editors, </editor> <booktitle> Proceedings of the 21 st International Conference on Very Large Databases, </booktitle> <pages> pages 345-357, </pages> <address> Zurich, Switzerland, </address> <month> September 11-15 </month> <year> 1995. </year> <month> 9 </month>
Reference-contexts: Reasoning about aggregation is difficult because aggregate operators behave very differently than other relational- and bag-algebra operators. For example, while rules for optimizing queries with other operators have long been known, only recently have rules for optimizing queries with aggregate operators been given <ref> [CS94, GHQ95, YL95] </ref>. In this paper we extend the work of [GL95] in an important way by giving incremental view maintenance expressions for the general case of views with aggregation.
References-found: 10

