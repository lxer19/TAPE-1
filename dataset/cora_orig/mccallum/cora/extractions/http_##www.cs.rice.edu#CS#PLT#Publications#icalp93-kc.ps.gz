URL: http://www.cs.rice.edu/CS/PLT/Publications/icalp93-kc.ps.gz
Refering-URL: http://www.cs.rice.edu/CS/PLT/Publications/
Root-URL: 
Title: What is a Universal Higher-Order Programming Language?  
Author: Ramarao Kanneganti and Robert Cartwright 
Address: Houston, TX 77251-1892  
Affiliation: Department of Computer Science Rice University  
Abstract: In this paper, we develop a theory of higher-order computability suitable for comparing the expressiveness of sequential, deterministic programming languages. The theory is based on the construction of a new universal domain T and corresponding universal language KL. The domain T is universal for observably sequential domains; KL can define all the computable elements of T, including the elements corresponding to computable observably sequential functions. In addition, domain embeddings in T preserve the maximality of finite elements|preserving the termination behavior of programs over the embedded domains.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> G. Berry and P-L. Curien. </author> <title> Sequential algorithms on concrete data structures. </title> <journal> Theor. Comput. Sci., </journal> <volume> 20 </volume> <pages> 265-321, </pages> <year> 1982. </year>
Reference-contexts: Our usage does not exactly match the technical meaning of the term sequential in the literature [11]. Sequential functions do not provide a satisfactory basis for defining a universal language because the sequential functions and corresponding domains do not form a cartesian closed category <ref> [1] </ref>. Sequential algorithms do form a cartesian closed category but they are intensional. of real programs faithfully. In particular, LAMBDA eliminates the distinction between terminating and non-terminating computations: the evaluation of an expression M in LAMBDA simply enumerates all finite approximations to the data object d denoted by M .
Reference: 2. <author> R. Cartwright. </author> <title> Recursive programs as definitions in first order logic. </title> <journal> SIAM Journal of Computing, </journal> <volume> 13 </volume> <pages> 374-408, </pages> <year> 1984. </year>
Reference-contexts: Thus, a function is defined by composition and application of other functions and recursion. The denotation of a function defined by a recursive definition is the least fixed point of corresponding functional <ref> [13, 2] </ref>. All the primitive operations and Apply over T are observably sequential. Since composition, application, and least fixed points preserve observable sequentiality, KL can only express the OS -functions. Apply (f; x). The operational semantics defined by these rewrite rules exactly match the mathematical semantics.
Reference: 3. <author> R. Cartwright and A. Demers. </author> <title> The topology of program termination. </title> <booktitle> In Proc. Symposium on Logic in Computer Science, </booktitle> <pages> pages 296-308, </pages> <year> 1988. </year>
Reference-contexts: In particular, LAMBDA eliminates the distinction between terminating and non-terminating computations: the evaluation of an expression M in LAMBDA simply enumerates all finite approximations to the data object d denoted by M . This enumeration process cannot terminate because no approximation in U is maximal. Cartwright and Demers <ref> [3] </ref> have developed a new formulation of domain theory that addresses the issue of program termination. They constructed a new universal domain r (pronounced "Grad") and metalanguage Cons that distinguish terminating and non-terminating computations. In contrast to previous universal domains, r includes finite maximal elements.
Reference: 4. <author> R. Cartwright and J. Donahue. </author> <title> The semantics of lazy (and industrious) evaluation. </title> <booktitle> In Proc. 1982 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 253-264, </pages> <year> 1982. </year>
Reference-contexts: Rewriting Rules for KL f1 + ; 1 ; left; right; cons; pair?; if0g. The combinators S and K are definable by recursive equations in KL, but the definitions are a bit tedious <ref> [4] </ref>. Since the set of OS -domains and OS -functions form a cartesian closed category [8], we know that S and K are OS -functions.
Reference: 5. <author> Robert Cartwright and Matthias Felleisen. </author> <title> Observable sequentiality and full abstraction. </title> <booktitle> In Conference Record of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 328-342, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: We recently developed a subspace of the continuous functions called the observably sequential functions that encompasses all of the functions definable in practical deterministic programming languages <ref> [5, 6, 12] </ref>. The observably sequential functions exclude continuous func tions that cannot be evaluated without multiple threads of control. In practice, non-sequential functions are unimportant in deterministic computation. <p> Every OS -function has a unique evaluation strategy manifest in its graph <ref> [5] </ref>.
Reference: 6. <author> R.S. Cartwright, P.-L. Curien, and M. Felleisen. </author> <title> Fully abstract models of observably sequential languages. </title> <journal> Information and Computation. </journal> <note> To appear. </note>
Reference-contexts: We recently developed a subspace of the continuous functions called the observably sequential functions that encompasses all of the functions definable in practical deterministic programming languages <ref> [5, 6, 12] </ref>. The observably sequential functions exclude continuous func tions that cannot be evaluated without multiple threads of control. In practice, non-sequential functions are unimportant in deterministic computation. <p> ) generates the OS -function domain T ! os T. 4 Otherwise, on the input extending a with error 1 at R and error 2 at R 0 the function has to generate the least upper bound of two inconsistent elements, error 1 and error 2 , at position Q <ref> [6] </ref>. 5.2 Embeddings that Preserve Maximality The universal domain T is universal for the class of OS -domains. That is, any OS -domain can be embedded in T by an OS -function such that the maximality of the finite elements is preserved.
Reference: 7. <author> Alonzo Church. </author> <title> An unsolvable problem of elementary number theory. </title> <journal> Americal Journal of Mathematics, </journal> <volume> 58 </volume> <pages> 345-363, </pages> <year> 1936. </year>
Reference-contexts: 1 Background and Motivation Classic recursion theory <ref> [7, 13, 18] </ref> asserts that all conventional programming languages are equally expressive because they can define all partial recursive functions over the natural numbers. This statement, however, is misleading because real programming languages support and enforce a more abstract view of data than bitstrings.
Reference: 8. <author> P.-L. Curien. </author> <title> Observable algorithms on concrete data structures. </title> <booktitle> In Proc 7th Symposium on Logic in Computer Science, </booktitle> <year> 1992. </year>
Reference-contexts: Rewriting Rules for KL f1 + ; 1 ; left; right; cons; pair?; if0g. The combinators S and K are definable by recursive equations in KL, but the definitions are a bit tedious [4]. Since the set of OS -domains and OS -functions form a cartesian closed category <ref> [8] </ref>, we know that S and K are OS -functions.
Reference: 9. <author> P.L. Curien. </author> <title> Categorical Combinators, Sequential Algorithms and Functional Programming. </title> <booktitle> Research Notes in Theoretical Computer Science. </booktitle> <publisher> Birkhauser, </publisher> <year> 1993. </year>
Reference-contexts: Roughly speaking, a Scott-domain (see Sect. 4) is "sequential" if its elements can be represented as lazy trees. The "sequential" domains correspond to "filiform concrete data structures" studied by Curien <ref> [9] </ref>, which are a restriction of "concrete domains" originally introduced by Kahn and Plotkin [11]. We show that the new universal domain T has two important properties: 1.
Reference: 10. <author> Martin Davis. </author> <title> Computable functionals of arbitrary finite type. </title> <editor> In A. Heyting, editor, Constructivity in Mathematics. </editor> <publisher> North Holland Publishing Company, </publisher> <address> Ams-terdam, </address> <year> 1959. </year>
Reference-contexts: Finite maximal elements are the denotations of terminating computations. 2 Previous Work On Universal Languages The issue of higher-order computation has previously been studied in two contexts: (i) the extension of classic recursion theory to computable functionals <ref> [10, 14] </ref> and (ii) domain theory [15, 17], the mathematical framework underlying denotational semantics. In the classic theory of computable functionals, functions are represented intensionally as strings of symbols.
Reference: 11. <author> G. Kahn and G. Plotkin. </author> <title> Concrete domains. In Fertschirift for C. </title> <type> Boehm, </type> <year> 1993. </year>
Reference-contexts: Roughly speaking, a Scott-domain (see Sect. 4) is "sequential" if its elements can be represented as lazy trees. The "sequential" domains correspond to "filiform concrete data structures" studied by Curien [9], which are a restriction of "concrete domains" originally introduced by Kahn and Plotkin <ref> [11] </ref>. We show that the new universal domain T has two important properties: 1. Every "sequential" domain D can be embedded by a "sequential" retraction as a subdomain D 0 of T such that the maximality of finite elements is preserved. 2. <p> Unfortunately, the model of computation underlying LAMBDA is too abstract to simulate the behavior 2 The quotation marks indicate that we are using this term informally. Our usage does not exactly match the technical meaning of the term sequential in the literature <ref> [11] </ref>. Sequential functions do not provide a satisfactory basis for defining a universal language because the sequential functions and corresponding domains do not form a cartesian closed category [1]. Sequential algorithms do form a cartesian closed category but they are intensional. of real programs faithfully.
Reference: 12. <author> R. Kanneganti, R. Cartwright, and M. Felleisen. Spcf: </author> <title> its model, calculus, and computational power. </title> <booktitle> In Proc. REX Workshop on Semantics and Concurrency. Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: We recently developed a subspace of the continuous functions called the observably sequential functions that encompasses all of the functions definable in practical deterministic programming languages <ref> [5, 6, 12] </ref>. The observably sequential functions exclude continuous func tions that cannot be evaluated without multiple threads of control. In practice, non-sequential functions are unimportant in deterministic computation. <p> Sect. 6, we prove that KL is universal by showing that every computable element of the domain T is expressible in KL. 4 OS -Domains In this section, we define the class of observably sequential domains (OS -domains); the construction is spelled out in greater detail in a previous report <ref> [12] </ref>. These domains have the structure required to support observably sequential computation. A Scott-domain (D; v) is the ideal completion of a Scott-basis (E; ), which is a partial order closed under least upper bounds for finite bounded subsets.
Reference: 13. <author> Stephen C. Kleene. </author> <title> General recursive functions of natural numbers. </title> <journal> Mathematis-che Annalen, </journal> <volume> 112 </volume> <pages> 727-742, </pages> <year> 1936. </year>
Reference-contexts: 1 Background and Motivation Classic recursion theory <ref> [7, 13, 18] </ref> asserts that all conventional programming languages are equally expressive because they can define all partial recursive functions over the natural numbers. This statement, however, is misleading because real programming languages support and enforce a more abstract view of data than bitstrings. <p> Thus, a function is defined by composition and application of other functions and recursion. The denotation of a function defined by a recursive definition is the least fixed point of corresponding functional <ref> [13, 2] </ref>. All the primitive operations and Apply over T are observably sequential. Since composition, application, and least fixed points preserve observable sequentiality, KL can only express the OS -functions. Apply (f; x). The operational semantics defined by these rewrite rules exactly match the mathematical semantics.
Reference: 14. <author> G. Kreisel, D. Lacombe, and J. R. Scoenfield. </author> <title> Partial recursive functionals and effective operations. </title> <editor> In A. Heyting, editor, Constructivity in Mathematics. </editor> <publisher> North Holland Publishing Company, </publisher> <address> Amsterdam, </address> <year> 1959. </year>
Reference-contexts: Finite maximal elements are the denotations of terminating computations. 2 Previous Work On Universal Languages The issue of higher-order computation has previously been studied in two contexts: (i) the extension of classic recursion theory to computable functionals <ref> [10, 14] </ref> and (ii) domain theory [15, 17], the mathematical framework underlying denotational semantics. In the classic theory of computable functionals, functions are represented intensionally as strings of symbols.
Reference: 15. <author> G.D. Plotkin. </author> <title> T ! as a universal domain. </title> <journal> J. Comput. Sci., </journal> <volume> 17 </volume> <pages> 209-236, </pages> <year> 1978. </year>
Reference-contexts: Finite maximal elements are the denotations of terminating computations. 2 Previous Work On Universal Languages The issue of higher-order computation has previously been studied in two contexts: (i) the extension of classic recursion theory to computable functionals [10, 14] and (ii) domain theory <ref> [15, 17] </ref>, the mathematical framework underlying denotational semantics. In the classic theory of computable functionals, functions are represented intensionally as strings of symbols. <p> Scott and Plotkin developed domain theory to address this issue. In domain theory, denotational definitions for programming languages are written in a met-alanguage LAMBDA corresponding to a universal domain U (either P! [17] or T ! <ref> [15] </ref>). In essence, a denotational definition of a programming language is a functional program written in LAMBDA that maps source program phrases into their meanings, which are data objects in the universal domain. <p> First, the continuous function space constructor ! c is contravariant in its first argument. As a result, the maximality information for a constructed space A ! c B cannot in general be computed from the maxi-mality information and effective presentations <ref> [15, 17] </ref> of A and B. Second, the ! c constructor introduces infinitely descending chains of elements in domain constructions. Both of these properties make it difficult to construct a universal domain and programming language based on continuous functions. <p> To satisfy this property, embeddings must preserve more structure than the embeddings used in classical domain theory <ref> [15, 17] </ref> which do not preserve finite maximality. To describe the embedding process and make it effective, we need to define what we mean by an effective presentation of a domain.
Reference: 16. <author> Hartley Rogers. </author> <title> Theory of Recursive Functions and Effective Computability. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1967. </year> <title> McGraw-Hill series in higher mathematics. </title>
Reference-contexts: Second, we must show that any element or OS -function that is computable on the domain T can be defined in KL. We show that the language KL is partially recursive by encoding an arbitrary partial recursive function in the language. It is well known <ref> [16] </ref> that any par tial recursive function can be expressed by the operations: 0; 1 + ; 1 , selection, composition, primitive recursion, and minimization. All these operations can be expressed in KL over the natural numbers.
Reference: 17. <author> D.S. Scott. </author> <title> Data types as lattices. </title> <journal> SIAM J. Computing, </journal> <volume> 5 </volume> <pages> 522-587, </pages> <year> 1976. </year>
Reference-contexts: Finite maximal elements are the denotations of terminating computations. 2 Previous Work On Universal Languages The issue of higher-order computation has previously been studied in two contexts: (i) the extension of classic recursion theory to computable functionals [10, 14] and (ii) domain theory <ref> [15, 17] </ref>, the mathematical framework underlying denotational semantics. In the classic theory of computable functionals, functions are represented intensionally as strings of symbols. <p> Scott and Plotkin developed domain theory to address this issue. In domain theory, denotational definitions for programming languages are written in a met-alanguage LAMBDA corresponding to a universal domain U (either P! <ref> [17] </ref> or T ! [15]). In essence, a denotational definition of a programming language is a functional program written in LAMBDA that maps source program phrases into their meanings, which are data objects in the universal domain. <p> First, the continuous function space constructor ! c is contravariant in its first argument. As a result, the maximality information for a constructed space A ! c B cannot in general be computed from the maxi-mality information and effective presentations <ref> [15, 17] </ref> of A and B. Second, the ! c constructor introduces infinitely descending chains of elements in domain constructions. Both of these properties make it difficult to construct a universal domain and programming language based on continuous functions. <p> To satisfy this property, embeddings must preserve more structure than the embeddings used in classical domain theory <ref> [15, 17] </ref> which do not preserve finite maximality. To describe the embedding process and make it effective, we need to define what we mean by an effective presentation of a domain.
Reference: 18. <author> Alan M. </author> <title> Turing. Computability and -definability. </title> <journal> The Jounal of Symbolic Logic, </journal> <volume> 2 </volume> <pages> 153-163, </pages> <year> 1937. </year>
Reference-contexts: 1 Background and Motivation Classic recursion theory <ref> [7, 13, 18] </ref> asserts that all conventional programming languages are equally expressive because they can define all partial recursive functions over the natural numbers. This statement, however, is misleading because real programming languages support and enforce a more abstract view of data than bitstrings.
References-found: 18

