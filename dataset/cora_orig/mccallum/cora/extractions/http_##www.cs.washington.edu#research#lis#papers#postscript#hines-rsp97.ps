URL: http://www.cs.washington.edu/research/lis/papers/postscript/hines-rsp97.ps
Refering-URL: http://www.cs.washington.edu/research/projects/lis/chinook/www/publications.html
Root-URL: 
Email: fhineskj,gaetanog@cs.washington.edu  
Title: Selective Focus as a Means of Improving Geographically Distributed Embedded System Co-simulation  
Author: Ken Hines and Gaetano Borriello 
Address: Box 352350  Seattle, WA 98195-2350  
Affiliation: Department of Computer Science Engineering,  University of Washington,  
Abstract: When dealing with communication-intensive systems, hardware/software co-simulation usually either requres the communication to be simulated with a uniformly low level of detail or it performs poorly. This problem manifests itself even more strongly when considering geographically distributed co-simulation where designers take advantage of proprietary component simulation models that are made available over the Internet. In such systems, much of the communication can potentially occur over the Internet, with even more expensive and slower communication primitives. This paper presents a technique, called "selective focus", and a Java based tool which allow communication to be represented at various levels of abstraction thus giving the designer the ability to dynamically optimize inter-module communications and improve the performance of the co-simulation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. Chou and G. Borriello. </author> <title> Software architecture synthesis for retargetable real-time embedded systems. </title> <booktitle> In Codes/CASHE '97. IEEE, ACM, </booktitle> <year> 1997. </year>
Reference-contexts: We are also working on integrating hardware (specifically a DEC 4-FPGA Pamette board) into our simulation environment. The Pia editor provides a rough user interface to the Chinook project <ref> [7, 1] </ref>. We are looking at ways of expanding this interface to support interactive partitioning and architecture synthesis. 6 Conclusion Internet-based Geographically distributed co-simulation has a great deal of potential in aiding the design and testing of embedded systems.
Reference: [2] <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java Language Specification. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: The current implementation is a Java application which allows components to be dynamically loaded. 3.1 Why Java? The Java language is designed for both platform independence and heterogeneous distributed computing <ref> [2] </ref>. It was originally designed as an embedded system language but has since targeted Internet applications. These things among others make Java an attractive choice for embedded system co-simulation.
Reference: [3] <author> K. Hines and G. Borriello. </author> <title> Dynamic communication models in embedded system co-simulation. </title> <booktitle> In Proceedings of the 34th Design Automation Conference. IEEE, ACM, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: A simulation may still have large quantities of visible communication even when the trivial communication between processors and the rest of hardware is hidden (e.g. instruction fetches and local data accesses). The Pia hardware-software co-simulator as described in <ref> [3] </ref> was designed to address this problem. <p> If we cannot statically determine such addresses, the simulator can make an optimistic assumption and treat all memory as safe. When the system detects a violation of this assumption it can dynamically mark the relevant addresses as synchronous, then rewind (using the checkpoint and restore facilities described in <ref> [3] </ref>). The above synchronization rules allow components to be distributed fairly easily. For example, one machine can maintain system time and each component can be placed somewhere else. In this scenario, several components can be running simultaneously, but each may have to block at synchronization points.
Reference: [4] <author> K. Hines and G. Borriello. </author> <title> Optimizing communication in hardware-software co-simulation. </title> <booktitle> In Codes/CASHE '97. IEEE, ACM, </booktitle> <year> 1997. </year>
Reference-contexts: The current version of Pia does not allow for computation speedups. 5 Concurrent and future work We are currently in the process of setting up experiments for the distributed version of Java Pia. We have done some work with simplifying the specification of time optimized communication methods <ref> [4] </ref> and Run Level Run Time (s) Hardware 375.2 Hardware abstraction 32.2 Library abstraction 22.4 Application level 13.72 Table 1: The time for transmitting 14 128 x 128 frames at various runlevels are working on additional tools that can automatically translate the effect of communication transactions into Pia transaction annotations.
Reference: [5] <author> K. Kim, Y. Kim, Y. Shin, and K. Choi. </author> <title> An integrated hardware-software cosimulation environment with automated interface generation. </title> <booktitle> In 7th International Workshop on Rapid Systems Prototyping, </booktitle> <month> June </month> <year> 1996. </year>
Reference-contexts: It has been shown that it is not hard to reach the point where other factors dominate simulation time <ref> [9, 5] </ref> and frequently the dominant factors involve communication and synchronization between different components. A simulation may still have large quantities of visible communication even when the trivial communication between processors and the rest of hardware is hidden (e.g. instruction fetches and local data accesses).
Reference: [6] <author> T. Lindholm and F. Yellin. </author> <title> The Java Virtual Machine Specification. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Unfortunately, in current implementations of Java there is a performance penalty but improved compilers and ease of distribution should make up for this in the near future. Java is an object oriented language which is normally compiled to byte code and then run on a stack based virtual machine <ref> [6] </ref>, often included in web browsers. This provides accessibility, and common user interfaces for geographic distribution. 3.2 The core simulator The Pia simulation core provides support for dynamic selection of communication methods during a simulation run, and attempts to minimize the amount of synchronization required to maintain consistency.
Reference: [7] <author> R. Ortega and G. Borriello. </author> <title> Communication synthesis for embedded systems with global considerations. </title> <booktitle> In Codes/CASHE '97. IEEE, ACM, </booktitle> <year> 1997. </year>
Reference-contexts: We are also working on integrating hardware (specifically a DEC 4-FPGA Pamette board) into our simulation environment. The Pia editor provides a rough user interface to the Chinook project <ref> [7, 1] </ref>. We are looking at ways of expanding this interface to support interactive partitioning and architecture synthesis. 6 Conclusion Internet-based Geographically distributed co-simulation has a great deal of potential in aiding the design and testing of embedded systems.
Reference: [8] <editor> J. Rowson. Hardware/software co-simulation. </editor> <booktitle> In Proceedings of the Design Automation Conference, </booktitle> <pages> pages 439-440, </pages> <year> 1994. </year>
Reference-contexts: This enables a distributed implementation of the co-simulator where detail in focus can be run locally, while other system elements necessary to generate the appropriate load can be remotely located. The conventional approaches to co-simulation as summarized by Rowson <ref> [8] </ref> represent a fairly broad spectrum of co-simulation techniques with static levels of detail. While these techniques can be quite useful it is apparent that to obtain a better tradeoff between accuracy and performance, it is important to allow the level of detail to vary over time.
Reference: [9] <author> D. E. Thomas and S. L. Coumeri. </author> <title> A simulation environment for hardware-software codesign. </title> <booktitle> In Proceedings, International Conference on Computer Design. </booktitle> <publisher> IEEE CS Press, </publisher> <month> October </month> <year> 1995. </year>
Reference-contexts: It has been shown that it is not hard to reach the point where other factors dominate simulation time <ref> [9, 5] </ref> and frequently the dominant factors involve communication and synchronization between different components. A simulation may still have large quantities of visible communication even when the trivial communication between processors and the rest of hardware is hidden (e.g. instruction fetches and local data accesses).
References-found: 9

