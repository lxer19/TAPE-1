URL: http://www.cs.utah.edu/~mecklen/monitoring/monitoring.ps
Refering-URL: http://www.cs.utah.edu/~mecklen/whatsnew.html
Root-URL: 
Email: E-mail: fdbo,mecklen,hoogen,lepreaug@cs.utah.edu  
Title: Dynamic Program Monitoring and Transformation Using the OMOS Object Server  
Author: Douglas B. Orr, Robert W. Mecklenburg, Peter J. Hoogenboom, and Jay Lepreau 
Address: Salt Lake City, UT 84112  
Affiliation: Department of Computer Science University of Utah  
Abstract: In traditional monolithic operating systems the constraints of working within the kernel have limited the sophistication of the schemes used to manage executable program images. By implementing an executable image loader as a persistent user-space program, we can extend system program loading capabilities. In this paper we present OMOS, an Object/Meta-Object Server which provides program loading facilities as a special case of generic object instantiation. We discuss the architecture of OMOS, the extensible nature of that architecture, and its application to the problem of dynamic program monitoring and optimization. We present several optimization strategies and the results of applying these strategies. 1 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Mike Accetta, Robert Baron, William Bolosky, David Golub, Richard Rashid, Avadis Tevanian, and Michael Young. </author> <title> Mach: A new kernel foundation for UNIX development. </title> <booktitle> In Proceedings of the Summer 1986 USENIX Conference, </booktitle> <pages> pages 93-112, </pages> <address> Atlanta, GA, June 9-13, 1986. </address> <publisher> Usenix Association. </publisher>
Reference-contexts: For example, given a meta-object for ls, OMOS can create an ls object for a client. Instantiating an object subsumes linking and loading a program in a more traditional environment. OMOS is designed to support clients running on a variety of operating systems, including microkernels such as Mach <ref> [1] </ref> or Chorus [12], or traditional monolithic kernels that have remote mapping and IPC facilities. Meta-objects contain a specification, known as a blueprint, which specifies the rules used to combine objects and other meta-objects to produce an instance of the meta-object.
Reference: [2] <author> Gilad Bracha and Gary Lindstrom. </author> <title> Modularity meets inheritance. </title> <booktitle> In Proc. International Conference on Computer Languages, </booktitle> <pages> pages 282-290, </pages> <address> San Francisco, CA, April 20-23 1992. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: These rules map into a graph of construction operations, the m-graph, with each node representing one operation. The nodes in the m-graph define operations used to generate and modify objects. These operations include module operations, as defined in Bracha and Lindstrom <ref> [2] </ref>. Conceptually, a module is a naming scope. Module operations operate on and modify the symbol bindings in modules; module operations take modules as input and generate modules as output. The modifications of these bindings define the inheritance relationships between the component objects.
Reference: [3] <author> L. W. Comeau. </author> <title> A study of the effect of user program optimization in a paging system. </title> <booktitle> In Proceedings of the ACM Symposium on Operating Systems Principles, </booktitle> <address> Gatlinburg, Tenn., </address> <month> October </month> <year> 1967. </year>
Reference-contexts: This anomaly reinforces the need to investigate the use of code duplication for frequently used procedures. 8 Related Work A variety of work has been done on the problem of automatically improving locality of reference within programs in overlay systems and early paging systems <ref> [3, 8, 6, 4] </ref>. Some of this work concentrates on instruction reference locality; other concentrates on data reference locality. More recent work focuses on the related problem of locality of reference within a cache [7].
Reference: [4] <author> Domenico Ferrari. </author> <title> Improving locality by critical working sets. </title> <journal> Communications of the ACM, </journal> <volume> 17(1) </volume> <pages> 614-620, </pages> <month> November </month> <year> 1974. </year>
Reference-contexts: Clearly, these problems are not significant when using relatively small programs and small numbers of carefully designed libraries. The issue of locality of reference has been given attention in the past, when system memory sizes were small and penalties for nonlocal references were high <ref> [8, 6, 4] </ref>. Even though typical machine memory sizes have been increasing, applications tend to grow to fill available memory. <p> This anomaly reinforces the need to investigate the use of code duplication for frequently used procedures. 8 Related Work A variety of work has been done on the problem of automatically improving locality of reference within programs in overlay systems and early paging systems <ref> [3, 8, 6, 4] </ref>. Some of this work concentrates on instruction reference locality; other concentrates on data reference locality. More recent work focuses on the related problem of locality of reference within a cache [7].
Reference: [5] <author> S. J. </author> <title> Hartley. Compile-time program restructuring in multiprogrammed virtual memory systems. </title> <journal> IEEE Trans on Software Engineering, </journal> <volume> SE-14(11):1640-1644, </volume> <year> 1988. </year>
Reference-contexts: To solve this, we cluster a number of the most frequently referenced procedures in the program by selecting a percentage of the total number of procedures. These procedures would also be prime candidates for cloning <ref> [5] </ref>, which is an enhancement we plan to investigate in the future. The fourth dynamic strategy involves ordering the call chain by frequency of reference, rather than in a simple first-called, depth-first fashion. This strategy has the advantage that it will place together procedures in the most heavily traveled paths. <p> Some of this work concentrates on instruction reference locality; other concentrates on data reference locality. More recent work focuses on the related problem of locality of reference within a cache [7]. Hartley <ref> [5] </ref> used procedure replication as a way to bound the locality of reference for a given point in the program.
Reference: [6] <author> D. J. Hatfield and J. Gerald. </author> <title> Program restructuring for virtual memory. </title> <journal> IBM Systems Journal, </journal> <volume> 10(3) </volume> <pages> 168-192, </pages> <year> 1971. </year>
Reference-contexts: Clearly, these problems are not significant when using relatively small programs and small numbers of carefully designed libraries. The issue of locality of reference has been given attention in the past, when system memory sizes were small and penalties for nonlocal references were high <ref> [8, 6, 4] </ref>. Even though typical machine memory sizes have been increasing, applications tend to grow to fill available memory. <p> This anomaly reinforces the need to investigate the use of code duplication for frequently used procedures. 8 Related Work A variety of work has been done on the problem of automatically improving locality of reference within programs in overlay systems and early paging systems <ref> [3, 8, 6, 4] </ref>. Some of this work concentrates on instruction reference locality; other concentrates on data reference locality. More recent work focuses on the related problem of locality of reference within a cache [7].
Reference: [7] <author> J. L. Hennessy and Thomas R. Gross. </author> <title> Post-pass code optimization of pipeline constraints. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(3):342, </volume> <month> July </month> <year> 1983. </year>
Reference-contexts: Some of this work concentrates on instruction reference locality; other concentrates on data reference locality. More recent work focuses on the related problem of locality of reference within a cache <ref> [7] </ref>. Hartley [5] used procedure replication as a way to bound the locality of reference for a given point in the program. <p> The extensible nature of OMOS, and its knowledge of everything from source file to execution traces, make it applicable to other kinds of optimizations re-quiring run-time data. OMOS could transparently implement the type of monitoring done by MIPS' pixie system, to optimize branch prediction <ref> [7] </ref>. Another direction is suggested by OMOS' natural connection with program development. OMOS could easily be used as the basis of a CASE tool, where its ability to feed back data from program execution, would be useful for both debugging and optimization.
Reference: [8] <author> T. C. Lowe. </author> <title> Automatic segmentation of cyclic program structures based on connectivity and processor timing. </title> <journal> Communications of the ACM, </journal> <volume> 13(1) </volume> <pages> 3-9, </pages> <month> January </month> <year> 1970. </year>
Reference-contexts: Clearly, these problems are not significant when using relatively small programs and small numbers of carefully designed libraries. The issue of locality of reference has been given attention in the past, when system memory sizes were small and penalties for nonlocal references were high <ref> [8, 6, 4] </ref>. Even though typical machine memory sizes have been increasing, applications tend to grow to fill available memory. <p> This anomaly reinforces the need to investigate the use of code duplication for frequently used procedures. 8 Related Work A variety of work has been done on the problem of automatically improving locality of reference within programs in overlay systems and early paging systems <ref> [3, 8, 6, 4] </ref>. Some of this work concentrates on instruction reference locality; other concentrates on data reference locality. More recent work focuses on the related problem of locality of reference within a cache [7].
Reference: [9] <author> D. Orr and R. Mecklenburg. </author> <title> OMOS | an object server for program execution. </title> <booktitle> In Proc. Second International Workshop on Object Orientation in Operating Systems, </booktitle> <address> Paris, France, Septem-ber 1992. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: Arguments can be the names of server objects, strings, or other module operations. M-graphs are composed of nodes which are graph operators, meta-objects and fragments. The complete set of graph operators defined in OMOS is described in <ref> [9] </ref>. The graph operators important to this discussion include: Merge: binds the symbol definitions found in one operand to the references found in another. Multiple definitions of a symbol constitutes an error. Override: merges two operands, resolving conflicting bindings (multiple defini tions) in favor of the second operand.
Reference: [10] <author> K. Pettis and R. C. Hansen. </author> <title> Profile guided code positioning. </title> <journal> SIGPLAN Notices, </journal> <volume> 25(6) </volume> <pages> 16-27, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: More recent work focuses on the related problem of locality of reference within a cache [7]. Hartley [5] used procedure replication as a way to bound the locality of reference for a given point in the program. Pettis and Hansen <ref> [10] </ref> did work Table 1: xmh Program Performance Data ( elapsed time in seconds page faults ) Strategy Available Memory 118 147 185 258 321 417 675 800 None 1 1052 673 305 249 183 96 43 1 8755 4680 1623 1056 597 160 120 Static ordering 1001 626 361 190
Reference: [11] <author> D. M. Ritchie and K. Thompson. </author> <title> The UNIX time-sharing system. </title> <journal> The Bell System Technical Journal, </journal> <volume> 57(6) </volume> <pages> 1905-1930, </pages> <month> July/August </month> <year> 1978. </year>
Reference-contexts: 1 Introduction Traditional program loading facilities, such as those found in Unix <ref> [11] </ref>, have simple semantics, often because they are implemented within the framework of a monolithic kernel where resources tend to be constrained. Similarly they tend to use simple external structures | executable files, libraries, etc. | to reduce kernel complexity.
Reference: [12] <author> M. Rozier, V. Abrossimov, F. Armand, I. Boule, M. Gien, M. Guillemont, F. Herrmann, C. Kaiser, S. Langlois, P. Leonard, and W. Neuhauser. </author> <title> The Chorus distributed operating system. </title> <journal> Computing Systems, </journal> <volume> 1(4) </volume> <pages> 287-338, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Instantiating an object subsumes linking and loading a program in a more traditional environment. OMOS is designed to support clients running on a variety of operating systems, including microkernels such as Mach [1] or Chorus <ref> [12] </ref>, or traditional monolithic kernels that have remote mapping and IPC facilities. Meta-objects contain a specification, known as a blueprint, which specifies the rules used to combine objects and other meta-objects to produce an instance of the meta-object.
References-found: 12

