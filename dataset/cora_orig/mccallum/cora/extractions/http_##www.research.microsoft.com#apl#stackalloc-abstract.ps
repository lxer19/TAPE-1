URL: http://www.research.microsoft.com/apl/stackalloc-abstract.ps
Refering-URL: http://www.research.microsoft.com/apl/
Root-URL: http://www.research.microsoft.com
Email: dgay@cs.berkeley.edu  rusa@microsoft.com  
Title: Stack Allocating Objects in Java (Extended Abstract)  
Author: David Gay Bjarne Steensgaard 
Address: Berkeley  
Affiliation: EECS Department University of California,  Microsoft Research  
Abstract: Allocating objects on the stack rather than the heap reduces the overhead of garbage collection and permits further optimizations. This paper presents a simple and fast algorithm for stack allocating a significant fraction of objects for Java programs. Our implementation in an optimizing batch Java compiler demonstrates the benefit of stack allocation by achieving speed improvements of up to 11% for medium-size programs. 
Abstract-found: 1
Intro-found: 1
Reference: [AFL95] <author> Alexander Aiken, Manuel Fahndrich, and Raph Levien. </author> <title> Better static memory management: improving region-based analysis of higher-order languages. </title> <booktitle> In Proceedings of the ACM SIGPLAN'95 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 174-185, </pages> <address> La Jolla, CA, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: The region inference system of Tofte and Talpin [TT94, TT97] infers a set of regions in which to place all allocated objects. The only way to free memory is to delete a region; the allocation and deallocation of regions must follow a stack discipline. That requirement was relaxed in <ref> [AFL95] </ref>. The regions are dynamically sized, but in the cases where a bound on their size can be computed they can be placed on the stack. This system is much more general than ours, but the analysis is also much more complex.
Reference: [Bar77] <author> Jeffrey M. Barth. </author> <title> Shifting garbage collection overhead to compile time. </title> <journal> Communications of the ACM, </journal> <volume> 20(7) </volume> <pages> 513-518, </pages> <month> July </month> <year> 1977. </year> <month> 9 </month>
Reference-contexts: To perform these modifications the programmer must understand the region inference process. Ruggieri and Murtagh [RM88] propose a similar but less general system. Alias and points-to analysis [CWZ90, Deu90, Hic93, JM81, SF96, VHU92] and other miscellaneous techniques <ref> [Bar77, BS93, JM90, JL89, Sch75] </ref> have also been considered for compile-time garbage collection. These analyses are mostly expensive and their effectiveness is unclear. McDowell instrumented a Java virtual machine to find the number of potentially stackable objects in a small collection of Java programs [McD98].
Reference: [Bla98] <author> Bruno Blanchet. </author> <title> Escape analysis: Correctness proof, implementation and experimental results. </title> <booktitle> In Conference Record of POPL '98: The 25th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 25-37, </pages> <address> San Diego, California, </address> <month> 19-21 January 98. </month>
Reference-contexts: Stack allocation is by no means new [Sch75] but most existing work has been performed for functional languages, e.g., [Deu97]. Our speedup is better than that observed for previous work on functional languages <ref> [Bla98] </ref>; this may be due to the different characteristics of functional and object-oriented languages. The simplicity of our system ensures its practicality on large programs. <p> The two major approaches are escape analysis and region inference. Stack allocation and compile-time garbage collection based on escape analysis have mostly been performed on functional languages like SML [MTH90] or Lisp <ref> [Bla98, Deu97, Hug92, ISY88, Moh95, PG92] </ref>. The precision of the escape analyses considered in these papers is much greater than ours. For instance, they can find that a function's result does not contain elements from the spine of its second argument (a list). <p> The only algorithm with a near-linear complexity is that of Alain Deutsch [Deu97] (the complexity is n log 2 n where n is the program's size). A study of the performance of this algorithm on some SML benchmarks was performed by Bruno Blanchet <ref> [Bla98] </ref>. On the only large program considered, this algorithm placed 25% of allocated bytes on the stack and gave a performance improvement of 3-4%. As in our system, the performance gains are only partially attributable to reduced garbage collection overhead.
Reference: [BS93] <author> E. Barendsen and S. Smetsers. </author> <title> Conventional and uniqueness typing in graph rewrite systems. </title> <editor> In Rudrapatna K. Shyamasundar, editor, </editor> <booktitle> Proceedings of Foundations of Software Technology and Theoretical Computer Science, volume 761 of LNCS, </booktitle> <pages> pages 41-51, </pages> <address> Bombay, India, </address> <month> December </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: To perform these modifications the programmer must understand the region inference process. Ruggieri and Murtagh [RM88] propose a similar but less general system. Alias and points-to analysis [CWZ90, Deu90, Hic93, JM81, SF96, VHU92] and other miscellaneous techniques <ref> [Bar77, BS93, JM90, JL89, Sch75] </ref> have also been considered for compile-time garbage collection. These analyses are mostly expensive and their effectiveness is unclear. McDowell instrumented a Java virtual machine to find the number of potentially stackable objects in a small collection of Java programs [McD98].
Reference: [BS96] <author> David F. Bacon and Peter F. Sweeney. </author> <title> Fast static analysis of C++ virtual function calls. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, volume 31, 10 of ACM SIGPLAN Notices, </booktitle> <pages> pages 324-341, </pages> <address> New York, October6-10 1996. </address> <publisher> ACM Press. </publisher>
Reference-contexts: We also distinguish direct method calls, where the compiler can determine the target method, from normal (virtual) method calls. Marmot uses an analysis similar to Rapid Type Analysis <ref> [BS96] </ref> augmented with local type propagation to determine direct calls. 2.1 Stack Allocation Framework To represent stack allocation, a new kind of statement is added: x = newStack T . There are several restrictions on the use of newStack in a method, f .
Reference: [CFR + 91] <author> Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> Efficiently Computing Static Single Assignment Form and the Control Dependence Graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: The analysis necessary for stack allocation provides extra type information that enables a number of further transformations, presented in Section 2.4. For the purposes of this paper we will assume that the Java program has been converted to Static Single Assignment (SSA) form <ref> [CFR + 91] </ref> and that intermediate values of expressions are eliminated by storing such values in extra local variables|we can thus identify expressions with the variable to which they are assigned.
Reference: [Cha88] <author> D. R. Chase. </author> <title> Safety considerations for storage allocation optimizations. </title> <editor> In David S. Wise, editor, </editor> <booktitle> Proceedings of the SIGPLAN '88 Conference on Programming Lanugage Design and Implementation (SIGPLAN '88), </booktitle> <pages> pages 1-10, </pages> <address> Atlanta, GE, USA, June 1988. </address> <publisher> ACM Press. </publisher>
Reference-contexts: There is no need for a frame pointer register in methods that perform stack allocation, as would be required with a more dynamic form of stack allocation. Chase <ref> [Cha88] </ref> outlined a safety criterion for stack allocation systems: essentially, stack allocation should not make a program that used to run successfully with garbage collection fail because of a lack of memory. A garbage collector can reclaim unreachable objects that a function creates before that function returns.
Reference: [CWZ90] <author> David R. Chase, Mark Wegman, and F. Kenneth Zadeck. </author> <title> Analysis of pointers and structures. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 25(6) </volume> <pages> 296-310, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: In addition, the programmer must sometimes modify the program to avoid leaking memory. To perform these modifications the programmer must understand the region inference process. Ruggieri and Murtagh [RM88] propose a similar but less general system. Alias and points-to analysis <ref> [CWZ90, Deu90, Hic93, JM81, SF96, VHU92] </ref> and other miscellaneous techniques [Bar77, BS93, JM90, JL89, Sch75] have also been considered for compile-time garbage collection. These analyses are mostly expensive and their effectiveness is unclear.
Reference: [Deu90] <author> Alan Deutsch. </author> <title> On determining lifetime and aliasing of dynamically allocated data in higher-order functional specifications. </title> <booktitle> In ACM-SIGPLAN ACM-SIGACT, editor, Conference Record of the 17th Annual ACM Symposium on Principles of Programming Languages (POPL '90), </booktitle> <pages> pages 157-168, </pages> <address> San Francisco, CA, USA, </address> <month> January </month> <year> 1990. </year> <note> ACM Press. </note>
Reference-contexts: In addition, the programmer must sometimes modify the program to avoid leaking memory. To perform these modifications the programmer must understand the region inference process. Ruggieri and Murtagh [RM88] propose a similar but less general system. Alias and points-to analysis <ref> [CWZ90, Deu90, Hic93, JM81, SF96, VHU92] </ref> and other miscellaneous techniques [Bar77, BS93, JM90, JL89, Sch75] have also been considered for compile-time garbage collection. These analyses are mostly expensive and their effectiveness is unclear.
Reference: [Deu97] <author> Alain Deutsch. </author> <title> On the complexity of escape analysis. </title> <booktitle> In Conference Record of POPL '97: The 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 358-371, </pages> <address> Paris, France, </address> <month> 15-17 January 97. </month>
Reference-contexts: Our system is simple but effective: for medium-size programs it typically places 10%-20% of all objects on the stack and gives speed improvements up to 11%. Stack allocation is by no means new [Sch75] but most existing work has been performed for functional languages, e.g., <ref> [Deu97] </ref>. Our speedup is better than that observed for previous work on functional languages [Bla98]; this may be due to the different characteristics of functional and object-oriented languages. The simplicity of our system ensures its practicality on large programs. <p> The two major approaches are escape analysis and region inference. Stack allocation and compile-time garbage collection based on escape analysis have mostly been performed on functional languages like SML [MTH90] or Lisp <ref> [Bla98, Deu97, Hug92, ISY88, Moh95, PG92] </ref>. The precision of the escape analyses considered in these papers is much greater than ours. For instance, they can find that a function's result does not contain elements from the spine of its second argument (a list). <p> For instance, they can find that a function's result does not contain elements from the spine of its second argument (a list). This extra precision appears to be necessary for effective stack allocation in these list-oriented languages. The only algorithm with a near-linear complexity is that of Alain Deutsch <ref> [Deu97] </ref> (the complexity is n log 2 n where n is the program's size). A study of the performance of this algorithm on some SML benchmarks was performed by Bruno Blanchet [Bla98].
Reference: [FKR + 98] <author> Robert Fitzgerald, Todd B. Knoblock, Erik Ruf, Bjarne Steensgaard, and David Tarditi. Marmot: </author> <title> an optimizing compiler for Java. </title> <note> In preparation. Submitted to PLDI'99, </note> <month> October </month> <year> 1998. </year>
Reference-contexts: The simplicity of our system ensures its practicality on large programs. Our stack allocation algorithm has a linear time and memory complexity in terms of the size of the program's text and a static approximation of its call graph. We implemented the stack allocation system in Marmot <ref> [FKR + 98] </ref>, a batch Java bytecode to native code compiler. Marmot applies most of the conventional optimizations of imperative and object-oriented compilers and its code quality is competitive with other available Java bytecode to native code compilers.
Reference: [GJS96] <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java Language Specification. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, USA, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: This transformation is safe if the compiler can show that the lifetimes of the objects are delimited by the lifetime of the stack frames. We present the first published stack allocation system for Java <ref> [GJS96] </ref>. Our system is simple but effective: for medium-size programs it typically places 10%-20% of all objects on the stack and gives speed improvements up to 11%. Stack allocation is by no means new [Sch75] but most existing work has been performed for functional languages, e.g., [Deu97].
Reference: [Hic93] <author> James Hicks. </author> <title> Experiences with compiler-directed storage reclamation. </title> <editor> In R. John M. Hughes, editor, </editor> <booktitle> Record of the 1993 Conference on Functional Programming and Computer Architecture, volume 523 of Lecture Notes in Computer Science, </booktitle> <address> Copenhagen, June 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In addition, the programmer must sometimes modify the program to avoid leaking memory. To perform these modifications the programmer must understand the region inference process. Ruggieri and Murtagh [RM88] propose a similar but less general system. Alias and points-to analysis <ref> [CWZ90, Deu90, Hic93, JM81, SF96, VHU92] </ref> and other miscellaneous techniques [Bar77, BS93, JM90, JL89, Sch75] have also been considered for compile-time garbage collection. These analyses are mostly expensive and their effectiveness is unclear.
Reference: [Hug92] <author> Simon Hughes. </author> <title> Compile-time garbage collection for higher-order functional languages. </title> <journal> Journal of Logic and Computation, </journal> <volume> 2(4) </volume> <pages> 483-509, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: The two major approaches are escape analysis and region inference. Stack allocation and compile-time garbage collection based on escape analysis have mostly been performed on functional languages like SML [MTH90] or Lisp <ref> [Bla98, Deu97, Hug92, ISY88, Moh95, PG92] </ref>. The precision of the escape analyses considered in these papers is much greater than ours. For instance, they can find that a function's result does not contain elements from the spine of its second argument (a list).
Reference: [ISY88] <author> Katsuro Inoue, Hiroyuki Seki, and Hikaru Yagi. </author> <title> Analysis of functional programs to detect run-time garbage cells. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(4) </volume> <pages> 555-578, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: The two major approaches are escape analysis and region inference. Stack allocation and compile-time garbage collection based on escape analysis have mostly been performed on functional languages like SML [MTH90] or Lisp <ref> [Bla98, Deu97, Hug92, ISY88, Moh95, PG92] </ref>. The precision of the escape analyses considered in these papers is much greater than ours. For instance, they can find that a function's result does not contain elements from the spine of its second argument (a list).
Reference: [JL89] <author> S. B. Jones and D. Le Metayer. </author> <title> Compile-time garbage collection by sharing analysis. </title> <booktitle> In Proceedings of the Conference on Functional Programming Languages and Computer Architecture '89, </booktitle> <institution> Imperial College, </institution> <address> London, </address> <pages> pages 54-74, </pages> <address> New York, NY, </address> <year> 1989. </year> <journal> ACM. </journal> <volume> 10 </volume>
Reference-contexts: To perform these modifications the programmer must understand the region inference process. Ruggieri and Murtagh [RM88] propose a similar but less general system. Alias and points-to analysis [CWZ90, Deu90, Hic93, JM81, SF96, VHU92] and other miscellaneous techniques <ref> [Bar77, BS93, JM90, JL89, Sch75] </ref> have also been considered for compile-time garbage collection. These analyses are mostly expensive and their effectiveness is unclear. McDowell instrumented a Java virtual machine to find the number of potentially stackable objects in a small collection of Java programs [McD98].
Reference: [JM81] <author> Neil D. Jones and Steven S. Muchnick. </author> <title> Flow analysis and optimization of Lisp-like structures. </title> <editor> In Steven S. Muchnick and Neil D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 102-131. </pages> <address> Englewood Cliffs, N.J.: </address> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: In addition, the programmer must sometimes modify the program to avoid leaking memory. To perform these modifications the programmer must understand the region inference process. Ruggieri and Murtagh [RM88] propose a similar but less general system. Alias and points-to analysis <ref> [CWZ90, Deu90, Hic93, JM81, SF96, VHU92] </ref> and other miscellaneous techniques [Bar77, BS93, JM90, JL89, Sch75] have also been considered for compile-time garbage collection. These analyses are mostly expensive and their effectiveness is unclear.
Reference: [JM90] <author> Thomas P. Jensen and Torben Mogensen. </author> <title> A backwards analysis for compile-time garbage collection. </title> <editor> In Neil D. Jones, editor, </editor> <booktitle> ESOP'90 3rd European Symposium on Programming, </booktitle> <address> Copenhagen, Denmark, </address> <month> May </month> <year> 1990. </year> <booktitle> (Lecture Notes in Computer Science, </booktitle> <volume> vol. 432), </volume> <pages> pages 227-239. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: To perform these modifications the programmer must understand the region inference process. Ruggieri and Murtagh [RM88] propose a similar but less general system. Alias and points-to analysis [CWZ90, Deu90, Hic93, JM81, SF96, VHU92] and other miscellaneous techniques <ref> [Bar77, BS93, JM90, JL89, Sch75] </ref> have also been considered for compile-time garbage collection. These analyses are mostly expensive and their effectiveness is unclear. McDowell instrumented a Java virtual machine to find the number of potentially stackable objects in a small collection of Java programs [McD98].
Reference: [LY97] <author> Tim Lindholm and Frank Yellin. </author> <title> The Java Virtual Machine Specification. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, USA, </address> <year> 1997. </year>
Reference-contexts: Object creation is performed in two steps (as in the Java Virtual Machine <ref> [LY97] </ref>): (1) memory allocation (x = new T ) and (2) object initialization (a call to a constructor for T ). We also distinguish direct method calls, where the compiler can determine the target method, from normal (virtual) method calls.
Reference: [McD98] <author> C.E. McDowell. </author> <title> Reducing garbage in Java. </title> <journal> SIGPLAN Notices, </journal> <volume> 33(9) </volume> <pages> 84-86, </pages> <month> September </month> <year> 1998. </year>
Reference-contexts: These analyses are mostly expensive and their effectiveness is unclear. McDowell instrumented a Java virtual machine to find the number of potentially stackable objects in a small collection of Java programs <ref> [McD98] </ref>.
Reference: [Moh95] <author> Markus Mohnen. </author> <title> Efficient compile-time garbage collection for arbitrary data structures. </title> <type> Technical Report 95-08, </type> <institution> RWTH Aachen, Department of Computer Science, </institution> <year> 1995. </year>
Reference-contexts: The two major approaches are escape analysis and region inference. Stack allocation and compile-time garbage collection based on escape analysis have mostly been performed on functional languages like SML [MTH90] or Lisp <ref> [Bla98, Deu97, Hug92, ISY88, Moh95, PG92] </ref>. The precision of the escape analyses considered in these papers is much greater than ours. For instance, they can find that a function's result does not contain elements from the spine of its second argument (a list).
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: The two major approaches are escape analysis and region inference. Stack allocation and compile-time garbage collection based on escape analysis have mostly been performed on functional languages like SML <ref> [MTH90] </ref> or Lisp [Bla98, Deu97, Hug92, ISY88, Moh95, PG92]. The precision of the escape analyses considered in these papers is much greater than ours. For instance, they can find that a function's result does not contain elements from the spine of its second argument (a list).
Reference: [PG92] <author> Young Gil Park and Benjamin Goldberg. </author> <title> Escape analysis on lists. </title> <booktitle> In Proceedings of the ACM SIGPLAN'92 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 116-127, </pages> <year> 1992. </year>
Reference-contexts: The two major approaches are escape analysis and region inference. Stack allocation and compile-time garbage collection based on escape analysis have mostly been performed on functional languages like SML [MTH90] or Lisp <ref> [Bla98, Deu97, Hug92, ISY88, Moh95, PG92] </ref>. The precision of the escape analyses considered in these papers is much greater than ours. For instance, they can find that a function's result does not contain elements from the spine of its second argument (a list).
Reference: [RM98] <author> Jakob Rehof and Torben . Mogensen. </author> <title> Tractable constraints in finite semilattices. </title> <booktitle> Science of Computer Programming, </booktitle> <year> 1998. </year> <note> to appear. </note>
Reference-contexts: If either condition is not satisfied, the following constraint is added: &gt; mfresh (method ) 3.3 Complexity Constraints of the form a b and a c b can be solved in linear time by using pending lists on a and c as long as all lattices are of constant height <ref> [RM98] </ref>.
Reference: [RM88] <author> Cristina Ruggieri and Thomas P. Murtagh. </author> <title> Lifetime analysis of dynamically allocated objects. </title> <booktitle> In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 285-293, </pages> <address> San Diego, California, </address> <month> January 88. </month>
Reference-contexts: This system is much more general than ours, but the analysis is also much more complex. In addition, the programmer must sometimes modify the program to avoid leaking memory. To perform these modifications the programmer must understand the region inference process. Ruggieri and Murtagh <ref> [RM88] </ref> propose a similar but less general system. Alias and points-to analysis [CWZ90, Deu90, Hic93, JM81, SF96, VHU92] and other miscellaneous techniques [Bar77, BS93, JM90, JL89, Sch75] have also been considered for compile-time garbage collection. These analyses are mostly expensive and their effectiveness is unclear.
Reference: [Sch75] <author> J. T. Schwartz. </author> <title> Optimization of very high level languages I. Value transmission and its corollaries. </title> <journal> Computer Languages, </journal> <volume> 1(2) </volume> <pages> 161-194, </pages> <year> 1975. </year>
Reference-contexts: We present the first published stack allocation system for Java [GJS96]. Our system is simple but effective: for medium-size programs it typically places 10%-20% of all objects on the stack and gives speed improvements up to 11%. Stack allocation is by no means new <ref> [Sch75] </ref> but most existing work has been performed for functional languages, e.g., [Deu97]. Our speedup is better than that observed for previous work on functional languages [Bla98]; this may be due to the different characteristics of functional and object-oriented languages. <p> To perform these modifications the programmer must understand the region inference process. Ruggieri and Murtagh [RM88] propose a similar but less general system. Alias and points-to analysis [CWZ90, Deu90, Hic93, JM81, SF96, VHU92] and other miscellaneous techniques <ref> [Bar77, BS93, JM90, JL89, Sch75] </ref> have also been considered for compile-time garbage collection. These analyses are mostly expensive and their effectiveness is unclear. McDowell instrumented a Java virtual machine to find the number of potentially stackable objects in a small collection of Java programs [McD98].
Reference: [SF96] <author> Manuel Serrano and Marc Feeley. </author> <title> Storage use analysis and its applications. </title> <booktitle> In Proceedings of the 1st International Conference on Functional Programming, </booktitle> <pages> page 12, </pages> <address> Philadelphie, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: In addition, the programmer must sometimes modify the program to avoid leaking memory. To perform these modifications the programmer must understand the region inference process. Ruggieri and Murtagh [RM88] propose a similar but less general system. Alias and points-to analysis <ref> [CWZ90, Deu90, Hic93, JM81, SF96, VHU92] </ref> and other miscellaneous techniques [Bar77, BS93, JM90, JL89, Sch75] have also been considered for compile-time garbage collection. These analyses are mostly expensive and their effectiveness is unclear.
Reference: [TT94] <author> Mads Tofte and Jean-Pierre Talpin. </author> <title> Implementation of the typed call-by-value lambda-calculus using a stack of regions. </title> <booktitle> In Conference Record of the Twenty-first Annual ACM Symposium on Principles of Programming Languages, ACM SIGPLAN Notices, </booktitle> <pages> pages 188-201. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1994. </year>
Reference-contexts: On the only large program considered, this algorithm placed 25% of allocated bytes on the stack and gave a performance improvement of 3-4%. As in our system, the performance gains are only partially attributable to reduced garbage collection overhead. The region inference system of Tofte and Talpin <ref> [TT94, TT97] </ref> infers a set of regions in which to place all allocated objects. The only way to free memory is to delete a region; the allocation and deallocation of regions must follow a stack discipline. That requirement was relaxed in [AFL95].
Reference: [TT97] <author> Mads Tofte and Jean-Pierre Talpin. </author> <title> Region-based memory management. </title> <journal> Information and Computation, </journal> <volume> 132(2) </volume> <pages> 109-176, </pages> <month> February </month> <year> 1997. </year>
Reference-contexts: On the only large program considered, this algorithm placed 25% of allocated bytes on the stack and gave a performance improvement of 3-4%. As in our system, the performance gains are only partially attributable to reduced garbage collection overhead. The region inference system of Tofte and Talpin <ref> [TT94, TT97] </ref> infers a set of regions in which to place all allocated objects. The only way to free memory is to delete a region; the allocation and deallocation of regions must follow a stack discipline. That requirement was relaxed in [AFL95].
Reference: [VHU92] <author> Jan Vitek, R. Nigel Horspool, and James Uhl. </author> <title> Compile-time analysis of object-oriented programs. </title> <booktitle> In Proceedings of the 4th Int. Conf. on Compiler Construction, CC'92, Paderborn, </booktitle> <address> Germany, 1992. </address> <publisher> Springer-Verlag. </publisher> <pages> 11 </pages>
Reference-contexts: In addition, the programmer must sometimes modify the program to avoid leaking memory. To perform these modifications the programmer must understand the region inference process. Ruggieri and Murtagh [RM88] propose a similar but less general system. Alias and points-to analysis <ref> [CWZ90, Deu90, Hic93, JM81, SF96, VHU92] </ref> and other miscellaneous techniques [Bar77, BS93, JM90, JL89, Sch75] have also been considered for compile-time garbage collection. These analyses are mostly expensive and their effectiveness is unclear.
References-found: 30

