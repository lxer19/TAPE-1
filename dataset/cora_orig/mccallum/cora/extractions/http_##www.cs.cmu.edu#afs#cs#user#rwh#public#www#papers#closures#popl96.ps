URL: http://www.cs.cmu.edu/afs/cs/user/rwh/public/www/papers/closures/popl96.ps
Refering-URL: http://www.cs.cmu.edu/afs/cs/user/rwh/public/www/papers.html
Root-URL: 
Email: nan@kurims.kyoto-u.ac.jp  jgmorris@cs.cmu.edu  rwh@cs.cmu.edu  
Title: Typed Closure Conversion  
Author: Yasuhiko Minamide Greg Morrisett Robert Harper 
Address: Kyoto 606-01, Japan  Pittsburgh, PA 15213-3891  Pittsburgh, PA 15213-3891  
Affiliation: Research Institute for Mathematical Sciences Kyoto University  School of Computer Science Carnegie Mellon University  School of Computer Science Carnegie Mellon University  
Abstract: We study the typing properties of closure conversion for simply-typed and polymorphic -calculi. Unlike most accounts of closure conversion, which only treat the untyped -calculus, we translate well-typed source programs to well-typed target programs. This allows later compiler phases to take advantage of types for representation analysis and tag-free garbage collection, and it facilitates correctness proofs. Our account of closure conversion for the simply-typed language takes advantage of a simple model of objects by mapping closures to existentials. Closure conversion for the polymorphic language requires additional type machinery, namely translucency in the style of Harper and Lillibridge's module calculus, to express the type of a closure. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi, L. Cardelli, P.-L. Curien, and J.-J.Levy. </author> <title> Explicit substitutions. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1990. </year>
Reference: [2] <author> A. W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction Closure conversion <ref> [30, 35, 6, 16, 15, 2, 38, 8] </ref> is a program transformation that achieves a separation between code and data. Functions with free variables are replaced by code abstracted on an extra environment parameter. Free variables in the body of the function are replaced by references to the environment. <p> To appear POPL '96. ronments and is thus exploited to good advantage by Shao and Appel [31] and Wand and Steckler [38]. Most accounts consider closure conversion as a transformation to untyped terms, irrespective of whether or not the source term is typed <ref> [35, 16, 2, 38] </ref>. This is adequate for compilers that make little or no use of types in the back end or at run time. <p> Due to a lack of space, the proofs of correctness are omitted here. However, full details are given in the companion technical report [22]. Closure conversion is discussed in descriptions of various functional language compilers <ref> [35, 16, 3, 2, 31] </ref>. It is closely related to -lifting [14] in that it eliminates free variables in the bodies of -abstractions but differs by making the representation of the environment explicit as a data structure. <p> The advantage of the FAM environment representation is that the cost of variable lookup is always constant and the representation is "safe for space" <ref> [2] </ref> according to Appel's definition. However, constructing the environment for a closure takes time proportional to the number of free variables in the function and closures cannot share portions of their environment. Clearly, there are a variety of other strategies for forming environments. <p> However, the definition of translation may become complicated because the type of the closure as well as the translation of abstraction depends on which free variables passed directly. In some implementation, a closure is represented by folding code pointer into the environment record <ref> [2] </ref>. Such representation may be formulated as abstract closure conversion with some modifications. However, closure representation for such closures seems to need more powerful type system. 7 Acknowledgements We would like to thank Andrzej Filinski, Mark Leone, Ben-jamin Pierce, and David Tarditi for their comments and suggestions.
Reference: [3] <author> A. W. Appel and T. Jim. </author> <title> Continuation-passing, closure passing style. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1989. </year>
Reference-contexts: Due to a lack of space, the proofs of correctness are omitted here. However, full details are given in the companion technical report [22]. Closure conversion is discussed in descriptions of various functional language compilers <ref> [35, 16, 3, 2, 31] </ref>. It is closely related to -lifting [14] in that it eliminates free variables in the bodies of -abstractions but differs by making the representation of the environment explicit as a data structure.
Reference: [4] <author> D. E. Britton. </author> <title> Heap storage management for the program ming language Pascal. </title> <type> Master's thesis, </type> <institution> University of Arizona, </institution> <year> 1975. </year>
Reference-contexts: Compilation strategies for polymorphic languages, such as those proposed by Morrison et al. [25] and Harper and Morrisett [13], rely on analyzing types at run time to support unboxed representations and non-parametric operators, including printing and structural equality. Tag-free garbage collection <ref> [4, 37, 24] </ref> for both monomorphic and polymorphic programming languages also relies upon types at run time to determine the size and the pointers of objects. To support any of these implementation strategies, it is necessary to propagate type information through closure conversion and into the generated code.
Reference: [5] <author> L. Cardelli. </author> <title> The functional abstract machine. </title> <journal> Polymorphism, </journal> <volume> 1(1), </volume> <year> 1983. </year>
Reference-contexts: The translation is described as a deductive system in which the representation of the environment may be chosen independently for each closure. In this way vari ous environment representations, such as those used by the CAM [6] and the FAM <ref> [5] </ref>, as well as hybrid strategies, such as those suggested by Shao and Appel [31] can be explained in a uniform framework. The second stage, closure representation, is a type-based translation in which the implementation of closures is determined. <p> However, in the worst case accessing values in the environment takes time proportional to the length of the environment. In contrast, the FAM <ref> [5] </ref> uses flat environments with no sharing. The closure conversion of Figure 2 accurately models the environment strategy of the FAM if we choose a specific strengthening strategy in the (abs) rule where only the free variables of the function are preserved in the resulting closure's environment.
Reference: [6] <editor> C. Cousineau, P.-L. Curien, and M. Mauny. </editor> <booktitle> The categorical abstract machine. In Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 50-64, </pages> <year> 1985. </year>
Reference-contexts: 1 Introduction Closure conversion <ref> [30, 35, 6, 16, 15, 2, 38, 8] </ref> is a program transformation that achieves a separation between code and data. Functions with free variables are replaced by code abstracted on an extra environment parameter. Free variables in the body of the function are replaced by references to the environment. <p> The translation is described as a deductive system in which the representation of the environment may be chosen independently for each closure. In this way vari ous environment representations, such as those used by the CAM <ref> [6] </ref> and the FAM [5], as well as hybrid strategies, such as those suggested by Shao and Appel [31] can be explained in a uniform framework. The second stage, closure representation, is a type-based translation in which the implementation of closures is determined. <p> Variable x is translated as a nested type assignment fx:t g by (var). Nested type assignments are flexible enough to represent various environment representations used in practice. For example, the Categorical Abstract Machine or CAM <ref> [6] </ref> uses linked lists to represent environments.
Reference: [7] <author> H. Friedman. </author> <title> Equality between functionals. </title> <editor> In R. Parikh, editor, </editor> <booktitle> Logic Colloquium '75. </booktitle> <address> Norh-Holland, </address> <year> 1975. </year>
Reference-contexts: In addition to the practical advantages of propagating type information through the stages of a compiler, type-directed translation also facilitates correctness proofs by defining the invariants of the transformation as a type-indexed family of logical relations <ref> [36, 7, 28, 33, 34] </ref>. We describe closure conversion in two stages. The first stage, abstract closure conversion, is a type-based translation from the source language into a target language with explicit closures.
Reference: [8] <author> J. Hannan. </author> <title> A type system for closure conversion. </title> <booktitle> In The Workshop on Types for Program Analysis, </booktitle> <year> 1995. </year>
Reference-contexts: 1 Introduction Closure conversion <ref> [30, 35, 6, 16, 15, 2, 38, 8] </ref> is a program transformation that achieves a separation between code and data. Functions with free variables are replaced by code abstracted on an extra environment parameter. Free variables in the body of the function are replaced by references to the environment. <p> Wand and Steckler [38] have consider two optimizations of the basic closure conversion strategy, called selective and lightweight closure conversion, and provide a correctness proof for each of these in an un-typed setting. Hannan <ref> [8] </ref> re-casts Wand's work into a typed setting, and provides correctness proofs for Wand's optimizations.
Reference: [9] <author> R. Harper and M. Lillibridge. </author> <title> Explicit polymorphism and CPS conversion. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1993. </year>
Reference-contexts: Each stage of the compiler is thus viewed as a type-preserving translation between typed intermediate languages. Examples of such translations are given by Leroy [18], Ohori [26], Harper and Lillibridge <ref> [9] </ref>, and Harper and Morrisett [13]. In addition to the practical advantages of propagating type information through the stages of a compiler, type-directed translation also facilitates correctness proofs by defining the invariants of the transformation as a type-indexed family of logical relations [36, 7, 28, 33, 34].
Reference: [10] <author> R. Harper and M. Lillibridge. </author> <title> A type-theoretic approach to higher-order modules. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 123-137, </pages> <year> 1994. </year>
Reference-contexts: This captures the critical "privacy" property of environment representations for closures. In the simply-typed case we make direct use of Pierce and Turner's model of objects. In the polymorphic case we must in addition exploit the notion of translucency <ref> [10] </ref> (or manifest types [19]) to express the type of a polymorphic closure. The correctness of both the abstract closure conversion and the closure representation stages are proved using the method of logical relations. <p> In short, we need a mixed-phase data structure that does not hide its type component. This same problem has been encountered in the study of the ML-like module systems [11, 20, 21]. Recent solutions are based on the idea of translucent sums <ref> [10] </ref> or manifest types [19], which provide the power of both existentials (weak sums), and transparent sums (strong sums). <p> As in the simply-typed case we have obtained an "object oriented" representation of polymorphic closures by exploiting a combination of the type systems proposed by Pierce and Turner [27] for objects and by Harper and Lil-libridge <ref> [10] </ref> for modules. 5 A Formal Account of Polymorphic Closure Conversion In this section, we present closure conversion for the predica-tive subset of the second order -calculus.
Reference: [11] <author> R. Harper, D. MacQueen, and R. Milner. </author> <title> Standard ML. </title> <type> Technical Report ECS-LFCS-86-2, </type> <institution> Laboratory for the Foundations of Computer Science, Edinburgh University, </institution> <month> Mar. </month> <year> 1986. </year>
Reference-contexts: In short, we need a mixed-phase data structure that does not hide its type component. This same problem has been encountered in the study of the ML-like module systems <ref> [11, 20, 21] </ref>. Recent solutions are based on the idea of translucent sums [10] or manifest types [19], which provide the power of both existentials (weak sums), and transparent sums (strong sums).

Reference: [13] <author> R. Harper and G. Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 130-141, </pages> <year> 1995. </year>
Reference-contexts: In current compilers, these phases must occur before closure conversion because the output of closure conversion is un-typed. Compilation strategies for polymorphic languages, such as those proposed by Morrison et al. [25] and Harper and Morrisett <ref> [13] </ref>, rely on analyzing types at run time to support unboxed representations and non-parametric operators, including printing and structural equality. Tag-free garbage collection [4, 37, 24] for both monomorphic and polymorphic programming languages also relies upon types at run time to determine the size and the pointers of objects. <p> Each stage of the compiler is thus viewed as a type-preserving translation between typed intermediate languages. Examples of such translations are given by Leroy [18], Ohori [26], Harper and Lillibridge [9], and Harper and Morrisett <ref> [13] </ref>. In addition to the practical advantages of propagating type information through the stages of a compiler, type-directed translation also facilitates correctness proofs by defining the invariants of the transformation as a type-indexed family of logical relations [36, 7, 28, 33, 34]. We describe closure conversion in two stages. <p> A typing judgement is derived from the standard typing rules of the second-order -calculus (see for example <ref> [12, 13] </ref>). 5.1 Abstract Closures As in the simply typed case, we break closure conversion into abstract closure conversion and closure representation stages 2 . The abstract closure conversion stage for 8 converts both -abstractions and fl-abstractions into abstract closures consisting of code, a type environment and a value environment.
Reference: [14] <author> T. Johnsson. </author> <title> Lambda lifting: Transforming programs to re cursive equations. </title> <booktitle> In Functional Programming Language and Computer Architecture, </booktitle> <volume> LNCS 201, </volume> <pages> pages 190-203. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Due to a lack of space, the proofs of correctness are omitted here. However, full details are given in the companion technical report [22]. Closure conversion is discussed in descriptions of various functional language compilers [35, 16, 3, 2, 31]. It is closely related to -lifting <ref> [14] </ref> in that it eliminates free variables in the bodies of -abstractions but differs by making the representation of the environment explicit as a data structure. Making the environment explicit is important because it exposes environment construction and variable lookup to an optimizer.
Reference: [15] <author> R. Kelsey and P. Hudak. </author> <title> Realistic compilation by program translation -detailed summary -. In ACM Symp. </title> <booktitle> on Principles of Programming Languages, </booktitle> <pages> pages 281-292, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction Closure conversion <ref> [30, 35, 6, 16, 15, 2, 38, 8] </ref> is a program transformation that achieves a separation between code and data. Functions with free variables are replaced by code abstracted on an extra environment parameter. Free variables in the body of the function are replaced by references to the environment.
Reference: [16] <author> D. Kranz et al. </author> <title> Orbit: An optimizing compiler for Scheme. </title> <booktitle> In Proc. of the SIGPLAN '86 Symp. on Compiler Construction, </booktitle> <year> 1986. </year>
Reference-contexts: 1 Introduction Closure conversion <ref> [30, 35, 6, 16, 15, 2, 38, 8] </ref> is a program transformation that achieves a separation between code and data. Functions with free variables are replaced by code abstracted on an extra environment parameter. Free variables in the body of the function are replaced by references to the environment. <p> To appear POPL '96. ronments and is thus exploited to good advantage by Shao and Appel [31] and Wand and Steckler [38]. Most accounts consider closure conversion as a transformation to untyped terms, irrespective of whether or not the source term is typed <ref> [35, 16, 2, 38] </ref>. This is adequate for compilers that make little or no use of types in the back end or at run time. <p> Due to a lack of space, the proofs of correctness are omitted here. However, full details are given in the companion technical report [22]. Closure conversion is discussed in descriptions of various functional language compilers <ref> [35, 16, 3, 2, 31] </ref>. It is closely related to -lifting [14] in that it eliminates free variables in the bodies of -abstractions but differs by making the representation of the environment explicit as a data structure.
Reference: [17] <author> P. Landin. </author> <title> The mechanical evaluation of expressions. </title> <journal> Com puter Journal, </journal> <volume> 6 </volume> <pages> 308-320, </pages> <year> 1964. </year>
Reference: [18] <author> X. Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1992. </year>
Reference-contexts: However, when compiling typed languages, it is often advantageous to propagate type information through each stage of the compiler, and to make use of types at link or even run time. For example, Leroy's representation analysis <ref> [18, 32] </ref> uses types to determine procedure calling conventions, and Ohori's record compilation [26] uses a representation of types at run time to access components of a record. In current compilers, these phases must occur before closure conversion because the output of closure conversion is un-typed. <p> Each stage of the compiler is thus viewed as a type-preserving translation between typed intermediate languages. Examples of such translations are given by Leroy <ref> [18] </ref>, Ohori [26], Harper and Lillibridge [9], and Harper and Morrisett [13]. <p> We have also found that typed closure conversion, along with our other type-preserving translations, made it possible to find and eliminate compiler bugs since we can automatically type-check the output of each compiler phase. Some compilers for ML based on representation analysis <ref> [18, 32] </ref> also propagate type information through closure conversion. However, their information is not enough to type-check the resulting programs because polymorphism is implemented by coercions and all polymorphic types are represented by a single type.
Reference: [19] <author> X. Leroy. </author> <title> Manifest types, modules, and separate compila tion. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 109-122, </pages> <year> 1994. </year>
Reference-contexts: This captures the critical "privacy" property of environment representations for closures. In the simply-typed case we make direct use of Pierce and Turner's model of objects. In the polymorphic case we must in addition exploit the notion of translucency [10] (or manifest types <ref> [19] </ref>) to express the type of a polymorphic closure. The correctness of both the abstract closure conversion and the closure representation stages are proved using the method of logical relations. <p> In short, we need a mixed-phase data structure that does not hide its type component. This same problem has been encountered in the study of the ML-like module systems [11, 20, 21]. Recent solutions are based on the idea of translucent sums [10] or manifest types <ref> [19] </ref>, which provide the power of both existentials (weak sums), and transparent sums (strong sums).
Reference: [20] <author> D. MacQueen. </author> <title> Modules for Standard ML. </title> <booktitle> In Proc. ACM Conf. Lisp and Functional Programming, </booktitle> <pages> pages 198-207, </pages> <year> 1984. </year> <note> Revised version appears in [11]. </note>
Reference-contexts: In short, we need a mixed-phase data structure that does not hide its type component. This same problem has been encountered in the study of the ML-like module systems <ref> [11, 20, 21] </ref>. Recent solutions are based on the idea of translucent sums [10] or manifest types [19], which provide the power of both existentials (weak sums), and transparent sums (strong sums).
Reference: [21] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Stan dard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: In short, we need a mixed-phase data structure that does not hide its type component. This same problem has been encountered in the study of the ML-like module systems <ref> [11, 20, 21] </ref>. Recent solutions are based on the idea of translucent sums [10] or manifest types [19], which provide the power of both existentials (weak sums), and transparent sums (strong sums).
Reference: [22] <author> Y. Minamide, G. Morrisett, and R. Harper. </author> <title> Typed closure conversion. </title> <type> Technical Report CMU-CS-95-171, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: Due to a lack of space, the proofs of correctness are omitted here. However, full details are given in the companion technical report <ref> [22] </ref>. Closure conversion is discussed in descriptions of various functional language compilers [35, 16, 3, 2, 31]. It is closely related to -lifting [14] in that it eliminates free variables in the bodies of -abstractions but differs by making the representation of the environment explicit as a data structure. <p> Operational correctness of the translation is proven using logical relations between cl and 9 expressions, cl and 9 values, and cl and 9 substitutions. The definition of relations and the proof of the operational correctness are found in the technical report <ref> [22] </ref>. 4 Overview of Polymorphic Closure Conversion Closure conversion for a language with ML-style (i.e., pred-icative [12]), explicit polymorphism follows a similar pattern to the simply-typed case, but with the additional complication that we must account for free type variables as well as free value variables in the code of an <p> The details of the typing rules are found in the technical report <ref> [22] </ref>. We define the closure representation stage as a type-directed translation from 8;cl to 8;9 . <p> However, the definition of the relations is more complicated because of the presence of polymorphic types and types of the form i () in the language 8;cl . The relations and the proof appear in the technical report <ref> [22] </ref>. 6 Summary and Conclusions We have presented a type-theoretic account of closure conversion for the simply-typed and polymorphic -calculi. Our translations are unique in that they map well-typed source terms to well-typed target terms.
Reference: [23] <author> J. C. Mitchell and G. D. Plotkin. </author> <title> Abstract types have exis tential type. </title> <journal> ACM Transaction on Programming Languages and Systems, </journal> <volume> 10(3), </volume> <year> 1988. </year>
Reference-contexts: In order to preserve types in the target language, the representation of the environment may be hidden using existential types <ref> [23] </ref>. Figure 1 gives the typing rules for exis-tentials. A pack operation pairs a type t with a value e as an existential, holding t abstract as a type variable, t. <p> In order to prevent the partial application of the code to its environment, we restrict applications to the form e 1 (e 2 ; e 3 ). The typing rules and evaluation of pack and open expressions are standard (see <ref> [23] </ref> and Figure 1).
Reference: [24] <author> G. Morrisett, M. Felleisen, and R. Harper. </author> <title> Abstract models of memory management. </title> <booktitle> In Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 66-77, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Compilation strategies for polymorphic languages, such as those proposed by Morrison et al. [25] and Harper and Morrisett [13], rely on analyzing types at run time to support unboxed representations and non-parametric operators, including printing and structural equality. Tag-free garbage collection <ref> [4, 37, 24] </ref> for both monomorphic and polymorphic programming languages also relies upon types at run time to determine the size and the pointers of objects. To support any of these implementation strategies, it is necessary to propagate type information through closure conversion and into the generated code.
Reference: [25] <author> R. Morrison, A. Dearle, R. Connor, and A. L. Brown. </author> <title> An ad hoc approach to the implementation of polymorphism. </title> <journal> ACM Transaction on Programming Languages and Systems, </journal> <volume> 13(3), </volume> <year> 1991. </year>
Reference-contexts: In current compilers, these phases must occur before closure conversion because the output of closure conversion is un-typed. Compilation strategies for polymorphic languages, such as those proposed by Morrison et al. <ref> [25] </ref> and Harper and Morrisett [13], rely on analyzing types at run time to support unboxed representations and non-parametric operators, including printing and structural equality.
Reference: [26] <author> A. Ohori. </author> <title> A compilation method for ML-style polymorphic record calculi. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1992. </year>
Reference-contexts: However, when compiling typed languages, it is often advantageous to propagate type information through each stage of the compiler, and to make use of types at link or even run time. For example, Leroy's representation analysis [18, 32] uses types to determine procedure calling conventions, and Ohori's record compilation <ref> [26] </ref> uses a representation of types at run time to access components of a record. In current compilers, these phases must occur before closure conversion because the output of closure conversion is un-typed. <p> Each stage of the compiler is thus viewed as a type-preserving translation between typed intermediate languages. Examples of such translations are given by Leroy [18], Ohori <ref> [26] </ref>, Harper and Lillibridge [9], and Harper and Morrisett [13].
Reference: [27] <author> B. C. Pierce and D. N. Turner. </author> <title> Simple type-theoretic foun dations for object-oriented programming. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 207-247, </pages> <month> Apr. </month> <year> 1994. </year> <note> A preliminary version appeared in Principles of Programming Languages, </note> <year> 1993, </year> <title> and as University of Edinburgh technical report ECS-LFCS-92-225, under the title "Object-Oriented Programming Without Recursive Types". </title>
Reference-contexts: The second stage, closure representation, is a type-based translation in which the implementation of closures is determined. The main idea is to represent closures as objects (in contrast to the proposed representation of objects as closures [29]). Following Pierce and Turner <ref> [27] </ref> we consider objects to be packages of existential type consisting of a single method (the code part of the closure) together with a single instance variable (the environment part) whose type (the environment representation) is held abstract. This captures the critical "privacy" property of environment representations for closures. <p> This representation of closures bears a striking resemblance to the model of objects suggested by Pierce and Turner <ref> [27] </ref>. In their model an object has a type of the form 9t:t fi t [t], where t is the type of the instance variable (s) and t [t] is the type of the method (s). <p> As in the simply-typed case we have obtained an "object oriented" representation of polymorphic closures by exploiting a combination of the type systems proposed by Pierce and Turner <ref> [27] </ref> for objects and by Harper and Lil-libridge [10] for modules. 5 A Formal Account of Polymorphic Closure Conversion In this section, we present closure conversion for the predica-tive subset of the second order -calculus.
Reference: [28] <author> G. D. Plotkin. </author> <title> Lambda-definability in the full type hierarchy. In To H.B.Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism. </title> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: In addition to the practical advantages of propagating type information through the stages of a compiler, type-directed translation also facilitates correctness proofs by defining the invariants of the transformation as a type-indexed family of logical relations <ref> [36, 7, 28, 33, 34] </ref>. We describe closure conversion in two stages. The first stage, abstract closure conversion, is a type-based translation from the source language into a target language with explicit closures.
Reference: [29] <author> U. S. Reddy. </author> <title> Objects as closures. </title> <booktitle> In Proc. ACM Conf. Lisp and Functional Programming, </booktitle> <year> 1988. </year>
Reference-contexts: The second stage, closure representation, is a type-based translation in which the implementation of closures is determined. The main idea is to represent closures as objects (in contrast to the proposed representation of objects as closures <ref> [29] </ref>). Following Pierce and Turner [27] we consider objects to be packages of existential type consisting of a single method (the code part of the closure) together with a single instance variable (the environment part) whose type (the environment representation) is held abstract.
Reference: [30] <author> J. C. Reynolds. </author> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> In Proceedings of the Annual ACM Conference, </booktitle> <pages> pages 717-740, </pages> <year> 1972. </year>
Reference-contexts: 1 Introduction Closure conversion <ref> [30, 35, 6, 16, 15, 2, 38, 8] </ref> is a program transformation that achieves a separation between code and data. Functions with free variables are replaced by code abstracted on an extra environment parameter. Free variables in the body of the function are replaced by references to the environment.
Reference: [31] <author> Z. Shao and A. W. Appel. </author> <title> Space-efficient closure represen tations. </title> <booktitle> In Proc. ACM Conf. Lisp and Functional Programming, </booktitle> <year> 1994. </year>
Reference-contexts: This decision is influenced by a desire to minimize closure creation time, the space consumed by an environment, and the time to access a given variable in an environment <ref> [38, 31] </ref>. An important property of closure conversion is that the representation of the environment is private to the closure, and is not visible from the outside. <p> This affords considerable flexibility in the representation of envi fl This research was performed while the author was visiting the Fox Project at Carnegie Mellon University. To appear POPL '96. ronments and is thus exploited to good advantage by Shao and Appel <ref> [31] </ref> and Wand and Steckler [38]. Most accounts consider closure conversion as a transformation to untyped terms, irrespective of whether or not the source term is typed [35, 16, 2, 38]. <p> In this way vari ous environment representations, such as those used by the CAM [6] and the FAM [5], as well as hybrid strategies, such as those suggested by Shao and Appel <ref> [31] </ref> can be explained in a uniform framework. The second stage, closure representation, is a type-based translation in which the implementation of closures is determined. The main idea is to represent closures as objects (in contrast to the proposed representation of objects as closures [29]). <p> Due to a lack of space, the proofs of correctness are omitted here. However, full details are given in the companion technical report [22]. Closure conversion is discussed in descriptions of various functional language compilers <ref> [35, 16, 3, 2, 31] </ref>. It is closely related to -lifting [14] in that it eliminates free variables in the bodies of -abstractions but differs by making the representation of the environment explicit as a data structure. <p> Making the environment explicit is important because it exposes environment construction and variable lookup to an optimizer. Furthermore, Shao and Appel show that not all environment representations are "safe for space" <ref> [31] </ref>, and thus choosing a good environment representation is an important part of compilation. Wand and Steckler [38] have consider two optimizations of the basic closure conversion strategy, called selective and lightweight closure conversion, and provide a correctness proof for each of these in an un-typed setting. <p> However, constructing the environment for a closure takes time proportional to the number of free variables in the function and closures cannot share portions of their environment. Clearly, there are a variety of other strategies for forming environments. For example, the shared closure strategy described by Appel and Shao <ref> [31] </ref> that is also safe for space can also be formulated in our framework.
Reference: [32] <author> Z. Shao and A. W. Appel. </author> <title> A type-based compiler for Stan dard ML. </title> <booktitle> In Programming Language Design and Its imple-menation, </booktitle> <pages> pages 116-129, </pages> <year> 1995. </year>
Reference-contexts: However, when compiling typed languages, it is often advantageous to propagate type information through each stage of the compiler, and to make use of types at link or even run time. For example, Leroy's representation analysis <ref> [18, 32] </ref> uses types to determine procedure calling conventions, and Ohori's record compilation [26] uses a representation of types at run time to access components of a record. In current compilers, these phases must occur before closure conversion because the output of closure conversion is un-typed. <p> We have also found that typed closure conversion, along with our other type-preserving translations, made it possible to find and eliminate compiler bugs since we can automatically type-check the output of each compiler phase. Some compilers for ML based on representation analysis <ref> [18, 32] </ref> also propagate type information through closure conversion. However, their information is not enough to type-check the resulting programs because polymorphism is implemented by coercions and all polymorphic types are represented by a single type.
Reference: [33] <author> R. Statman. </author> <title> Completeness, invariance, and lambda definability. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 47 </volume> <pages> 17-26, </pages> <year> 1982. </year>
Reference-contexts: In addition to the practical advantages of propagating type information through the stages of a compiler, type-directed translation also facilitates correctness proofs by defining the invariants of the transformation as a type-indexed family of logical relations <ref> [36, 7, 28, 33, 34] </ref>. We describe closure conversion in two stages. The first stage, abstract closure conversion, is a type-based translation from the source language into a target language with explicit closures.
Reference: [34] <author> R. Statman. </author> <title> Logical relations and the typed -calculus. In formation and Control, </title> <type> 65, </type> <year> 1985. </year>
Reference-contexts: In addition to the practical advantages of propagating type information through the stages of a compiler, type-directed translation also facilitates correctness proofs by defining the invariants of the transformation as a type-indexed family of logical relations <ref> [36, 7, 28, 33, 34] </ref>. We describe closure conversion in two stages. The first stage, abstract closure conversion, is a type-based translation from the source language into a target language with explicit closures.
Reference: [35] <author> G. L. Steele Jr. Rabbit: </author> <title> A compiler for Scheme. </title> <type> Master's thesis, </type> <institution> MIT, </institution> <year> 1978. </year>
Reference-contexts: 1 Introduction Closure conversion <ref> [30, 35, 6, 16, 15, 2, 38, 8] </ref> is a program transformation that achieves a separation between code and data. Functions with free variables are replaced by code abstracted on an extra environment parameter. Free variables in the body of the function are replaced by references to the environment. <p> To appear POPL '96. ronments and is thus exploited to good advantage by Shao and Appel [31] and Wand and Steckler [38]. Most accounts consider closure conversion as a transformation to untyped terms, irrespective of whether or not the source term is typed <ref> [35, 16, 2, 38] </ref>. This is adequate for compilers that make little or no use of types in the back end or at run time. <p> Due to a lack of space, the proofs of correctness are omitted here. However, full details are given in the companion technical report [22]. Closure conversion is discussed in descriptions of various functional language compilers <ref> [35, 16, 3, 2, 31] </ref>. It is closely related to -lifting [14] in that it eliminates free variables in the bodies of -abstractions but differs by making the representation of the environment explicit as a data structure.
Reference: [36] <author> W. W. Tait. </author> <title> Intensional interpretation of functionals of finite type. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 32(2), </volume> <year> 1967. </year>
Reference-contexts: In addition to the practical advantages of propagating type information through the stages of a compiler, type-directed translation also facilitates correctness proofs by defining the invariants of the transformation as a type-indexed family of logical relations <ref> [36, 7, 28, 33, 34] </ref>. We describe closure conversion in two stages. The first stage, abstract closure conversion, is a type-based translation from the source language into a target language with explicit closures.
Reference: [37] <author> A. Tolmach. </author> <title> Tag-free garbage collection using explicit type parameters. </title> <booktitle> In Proc. ACM Conf. Lisp and Functional Programming, </booktitle> <pages> pages 1-11, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Compilation strategies for polymorphic languages, such as those proposed by Morrison et al. [25] and Harper and Morrisett [13], rely on analyzing types at run time to support unboxed representations and non-parametric operators, including printing and structural equality. Tag-free garbage collection <ref> [4, 37, 24] </ref> for both monomorphic and polymorphic programming languages also relies upon types at run time to determine the size and the pointers of objects. To support any of these implementation strategies, it is necessary to propagate type information through closure conversion and into the generated code.
Reference: [38] <author> M. Wand and P. Steckler. </author> <title> Selective and lightweight closure conversion. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1994. </year> <month> 12 </month>
Reference-contexts: 1 Introduction Closure conversion <ref> [30, 35, 6, 16, 15, 2, 38, 8] </ref> is a program transformation that achieves a separation between code and data. Functions with free variables are replaced by code abstracted on an extra environment parameter. Free variables in the body of the function are replaced by references to the environment. <p> This decision is influenced by a desire to minimize closure creation time, the space consumed by an environment, and the time to access a given variable in an environment <ref> [38, 31] </ref>. An important property of closure conversion is that the representation of the environment is private to the closure, and is not visible from the outside. <p> This affords considerable flexibility in the representation of envi fl This research was performed while the author was visiting the Fox Project at Carnegie Mellon University. To appear POPL '96. ronments and is thus exploited to good advantage by Shao and Appel [31] and Wand and Steckler <ref> [38] </ref>. Most accounts consider closure conversion as a transformation to untyped terms, irrespective of whether or not the source term is typed [35, 16, 2, 38]. This is adequate for compilers that make little or no use of types in the back end or at run time. <p> To appear POPL '96. ronments and is thus exploited to good advantage by Shao and Appel [31] and Wand and Steckler [38]. Most accounts consider closure conversion as a transformation to untyped terms, irrespective of whether or not the source term is typed <ref> [35, 16, 2, 38] </ref>. This is adequate for compilers that make little or no use of types in the back end or at run time. <p> Making the environment explicit is important because it exposes environment construction and variable lookup to an optimizer. Furthermore, Shao and Appel show that not all environment representations are "safe for space" [31], and thus choosing a good environment representation is an important part of compilation. Wand and Steckler <ref> [38] </ref> have consider two optimizations of the basic closure conversion strategy, called selective and lightweight closure conversion, and provide a correctness proof for each of these in an un-typed setting. Hannan [8] re-casts Wand's work into a typed setting, and provides correctness proofs for Wand's optimizations. <p> For simplicity, the current implementations of our compilers use abstract closure conversion. As many compilers, our compilers avoid creation of closures for known-functions. Such optimization does not introduce any problem. Lightweight closure conversion proposed by Wand and Steckler <ref> [38] </ref> may also be formulated as type-preserving translation as our closure conversions. However, the definition of translation may become complicated because the type of the closure as well as the translation of abstraction depends on which free variables passed directly.
References-found: 37

