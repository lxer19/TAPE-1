URL: http://www.cs.princeton.edu/~psa/bypass-paper.ps
Refering-URL: http://www.cs.princeton.edu/~psa/resume.html
Root-URL: http://www.cs.princeton.edu
Email: amrg@cs.princeton.edu  
Title: The Performance Impact of Incomplete Bypassing in Processor Pipelines  
Author: Pritpal S. Ahuja Douglas W. Clark Anne Rogers fpsa, doug, 
Address: 35 Olden Street Princeton, New Jersey 08544-2087  
Affiliation: Department of Computer Science Princeton University  
Abstract: Pipelined processors employ hardware bypassing to eliminate certain pipeline hazards. Bypassing is logically simple but can be costly, especially in wide issue and deeply pipelined machines. In this paper bypassing is studied in detail, with an emphasis on designs in which the bypassing network is not complete. Cycle-level simulations of a model of integer and floating-point pipelines running some of the SPEC92 benchmarks show that at least half of the instructions executed used a bypassed register result from a previous instruction. Missing bypasses induce interlock stalls. The paper reports measurements of the performance inpact of a number of pipeline configurations with incomplete bypassing networks. This impact ranges from a slowdown of just a few percent for a configuration with one late bypass missing to a slowdown of almost a factor of two for the integer pipe with no bypassing at all. Two types of code alterations reduce the new interlock stalls. A simple code transformation, the interchange of operands in instructions that perform commutative operations, cuts the performance loss from interlock stalls in certain configurations between about 20 and 50 percent. The second transformation is to reschedule code within basic blocks to avoid any missing bypasses. In five individual experiments with a small number of configurations and two benchmarks, this rescheduling saved 25 to 50 percent of the interlock stalls. In certain configurations both transformations can be applied. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> SPEC Newsletter. </author> <title> Standard Performance Evaluation Corporation, </title> <month> September </month> <year> 1994. </year>
Reference-contexts: Load hits had a single delay slot in both pipes. Benchmarks We used four of the six SPEC92 integer benchmarks and four of the fourteen floating-point bench marks <ref> [1] </ref> for our experiments. Table 1 briefly describes them, including short descriptions of the concessions we made to the speed of the simulator.
Reference: [2] <author> A. Abnous and N. Bagherzadeh. </author> <title> Pipelining and Bypassing in a VLIW Processor. </title> <journal> IEEE Transactions on Parallel and Distributed Computing, </journal> <volume> 5(6) </volume> <pages> 658-664, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: In their model, a special move instruction is needed to transfer data from one VLIW "cluster" to another; they do not look at pipeline bypassing, nor at data communication within one cluster. Ab-nous and Bagherzadeh <ref> [2] </ref> analyze partial bypassing between VLIW functional units in their 4-integer-unit VIPER processor [11]. They conclude that full inter-unit bypassing is not the highest-performance interconnection, due to its modelled cost in extra cycle time.
Reference: [3] <author> P. Bannon and J. Keller. </author> <title> Internal Architecture of Alpha 21164 Microprocessor. </title> <booktitle> In Proceedings of the IEEE COMPCON '95 Conference, </booktitle> <pages> pages 79-87, </pages> <year> 1995. </year>
Reference-contexts: Different implementations are of course possible: the Digital Alpha 21064 [18, 8], for example, has a separate set of wires for each source pipestage and wide multiplexors physically near the execution units; the Alpha 21164 <ref> [3, 5] </ref>, on the other hand, has a single multi-driver bus for each of the two inputs of each functional unit, with physically distributed control. Simulator We performed our experiments using a modified version of CL-SPIM, a cycle-level extension to Larus's instruction-level MIPS simulator, SPIM [16].
Reference: [4] <author> E. </author> <title> Bloch. </title> <booktitle> The Engineering Design of the Stretch Computer. In Proc. Eastern Joint Computer Conference, </booktitle> <pages> pages 48-59, </pages> <year> 1959. </year>
Reference-contexts: Bypassing adds hardware datapaths and control so that an instruction's result is available as an input to subsequent instructions before it has been written to an architectural register. An old idea, bypassing was first described in Bloch's 1959 paper on the IBM Stretch <ref> [4] </ref>. Modern pipelined microprocessors use bypassing heavily in order to avoid hazard-induced stalls. Bypassing hardware is not logically complicated, but can be costly, depending on the details of the implementation technology.
Reference: [5] <author> W. Bowhill et al. </author> <title> A 300-MHz 64b Quad-Issue CMOS RISC Microprocessor. </title> <journal> IEEE J. of Solid-State Circuits, </journal> <note> 30(11):to appear, </note> <month> November </month> <year> 1995. </year>
Reference-contexts: Different implementations are of course possible: the Digital Alpha 21064 [18, 8], for example, has a separate set of wires for each source pipestage and wide multiplexors physically near the execution units; the Alpha 21164 <ref> [3, 5] </ref>, on the other hand, has a single multi-driver bus for each of the two inputs of each functional unit, with physically distributed control. Simulator We performed our experiments using a modified version of CL-SPIM, a cycle-level extension to Larus's instruction-level MIPS simulator, SPIM [16].
Reference: [6] <author> A. Capitanio, N. Dutt, and A. Nicolau. </author> <title> Partitioned Register Files for VLIWs: A Preliminary Analysis of Tradeoffs. </title> <booktitle> In The 25th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 292-300, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: They found that appropriate code scheduling could bring the performance of their model almost up to that of a fully-bypassed processor. Huang and Despain [14] propose a system for pipeline dependency classification, but touch only briefly on bypasses. Capitanio et al. <ref> [6] </ref> look at the related idea of partitioned register files in the context of VLIW machines. They consider "limited connectivity" among register files assigned to particular VLIW functional units, arguing that having fewer ports on a register file can lead to a faster cycle time.
Reference: [7] <author> R. Cohn, T. Gross, M. Lam, and P. S. Tseng. </author> <title> Architecture and Compiler Tradeoffs for a Long Instruction Word Microprocessor. </title> <booktitle> In The 3rd International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 2-14, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: What we are trying to do here is to maintain ILP while reducing hardware. This might be called an increase in ILP relative to some hardware cost. The bypassing technique, though widely used, has been little studied. The work closest to our own is that of Cohn, et al. <ref> [7] </ref>, which included a study of a single incompletely-bypassed configuration of the iWarp VLIW processor running floating-point kernels. They found that appropriate code scheduling could bring the performance of their model almost up to that of a fully-bypassed processor.
Reference: [8] <author> D. Dobberpuhl et al. </author> <title> A 200-MHz 64-b Dual-Issue CMOS Microprocessor. </title> <journal> IEEE J. of Solid-State Circuits, </journal> <volume> 27(11) </volume> <pages> 1555-1564, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: In this paper we treat a bypass as a logical connection from a pipestage result to the input of an execution unit. Different implementations are of course possible: the Digital Alpha 21064 <ref> [18, 8] </ref>, for example, has a separate set of wires for each source pipestage and wide multiplexors physically near the execution units; the Alpha 21164 [3, 5], on the other hand, has a single multi-driver bus for each of the two inputs of each functional unit, with physically distributed control.
Reference: [9] <author> J. A. Fisher. </author> <title> Trace Scheduling: A Technique for Global Microcode Compaction. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-30(7):478-490, </volume> <year> 1981. </year>
Reference-contexts: If a bypass connection is missing from both sides of the execution unit, then of course commutative swaps cannot compensate at all for the missing paths. The code-rescheduling recourse remains, however. While techniques such as trace scheduling <ref> [9, 17] </ref> would allow the compiler to look for swapping and scheduling opportunities across basic block boundaries, we will confine ourselves to simple basic-block methods. Code scheduling to avoid absent bypasses closely resembles scheduling to avoid register interlocks [12, 10].
Reference: [10] <author> P. B. Gibbons and S. S. Muchnick. </author> <title> Efficient instruction scheduling for a pipelined architecture. </title> <booktitle> In Proceedings of the SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pages 11-16, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: The code-rescheduling recourse remains, however. While techniques such as trace scheduling [9, 17] would allow the compiler to look for swapping and scheduling opportunities across basic block boundaries, we will confine ourselves to simple basic-block methods. Code scheduling to avoid absent bypasses closely resembles scheduling to avoid register interlocks <ref> [12, 10] </ref>. We adapted Gibbons and Muchnick's DAG-based scheduling algorithm [10] for our purposes. Our algorithm differs from the one described by Gibbons and Muchnick in two ways. First, we examine more of the previously scheduled instructions to determine if an instruction would cause a stall. <p> Code scheduling to avoid absent bypasses closely resembles scheduling to avoid register interlocks [12, 10]. We adapted Gibbons and Muchnick's DAG-based scheduling algorithm <ref> [10] </ref> for our purposes. Our algorithm differs from the one described by Gibbons and Muchnick in two ways. First, we examine more of the previously scheduled instructions to determine if an instruction would cause a stall.
Reference: [11] <author> J. Gray, A. Naylor, A. Abnous, and N. Bag-herzadeh. </author> <title> VIPER: A VLIW Integer Microprocessor. </title> <journal> IEEE Journal of Solid State Circuits, </journal> <volume> 28(12) </volume> <pages> 1377-1383, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: In their model, a special move instruction is needed to transfer data from one VLIW "cluster" to another; they do not look at pipeline bypassing, nor at data communication within one cluster. Ab-nous and Bagherzadeh [2] analyze partial bypassing between VLIW functional units in their 4-integer-unit VIPER processor <ref> [11] </ref>. They conclude that full inter-unit bypassing is not the highest-performance interconnection, due to its modelled cost in extra cycle time. The next section of this paper presents our processor model and describes the simulation methods and the benchmarks.
Reference: [12] <author> J. L. Hennessy and T. R. Gross. </author> <title> Postpass Code Optimization of Pipeline Constraints. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(3) </volume> <pages> 422-448, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: The code-rescheduling recourse remains, however. While techniques such as trace scheduling [9, 17] would allow the compiler to look for swapping and scheduling opportunities across basic block boundaries, we will confine ourselves to simple basic-block methods. Code scheduling to avoid absent bypasses closely resembles scheduling to avoid register interlocks <ref> [12, 10] </ref>. We adapted Gibbons and Muchnick's DAG-based scheduling algorithm [10] for our purposes. Our algorithm differs from the one described by Gibbons and Muchnick in two ways. First, we examine more of the previously scheduled instructions to determine if an instruction would cause a stall.
Reference: [13] <author> J. L. Hennessy and D. A. Patterson. </author> <title> Computer Architecture: A Quantitative Approach. </title> <publisher> Mor-gan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, CA, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction Bypassing, or forwarding, is a simple, powerful, widely-used method for eliminating certain data hazards in pipelined processors <ref> [13] </ref>. Bypassing adds hardware datapaths and control so that an instruction's result is available as an input to subsequent instructions before it has been written to an architectural register. An old idea, bypassing was first described in Bloch's 1959 paper on the IBM Stretch [4].
Reference: [14] <author> I.-J. Huang and A. M. Despain. </author> <title> An Extended Classification of Inter-instruction Dependency and Its Application in Automatic Synthesis of Pipelined Processors. </title> <booktitle> In The 26th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 236-246, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: They found that appropriate code scheduling could bring the performance of their model almost up to that of a fully-bypassed processor. Huang and Despain <ref> [14] </ref> propose a system for pipeline dependency classification, but touch only briefly on bypasses. Capitanio et al. [6] look at the related idea of partitioned register files in the context of VLIW machines.
Reference: [15] <author> G. Kane and J. Heinrich. </author> <title> MIPS RISC Architecture. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1992. </year>
Reference-contexts: Section 6 summarizes our results and suggests avenues for further work in this area. 2 Experimental Framework A simple example will illustrate bypassing and help us motivate the work described here. Consider a simple single-issue RISC integer pipeline <ref> [15, 19] </ref> with five stages: IF (Instruction Fetch), ID (Instruction Decode and register read), EX (EXecute), MEM (MEMory access), and WB (Write Back result). <p> And of course the floating-point pipeline would need some bypasses of its own. Models We modelled a single-issue MIPS design with separate integer and floating-point pipes, much like the MIPS R3000/R3100 <ref> [15] </ref>. <p> Thus, while a reduction of ILP-enhancing hardware|the bypass network|can be expected to reduce ILP, we have shown how that loss can be minimized. Eight of the SPEC92 benchmarks (four integer, four floating-point) were run in a cycle-level simulator of a model based on the MIPS R3000 design <ref> [15] </ref>, with instrumented bypasses. Patterns of bypass use in the benchmarks were measured. Removing combinations of bypass paths from one or both sides of the execution unit slowed down the benchmarks (assuming perfect caches) by from just a few percent to over 90 percent, depending on the configuration.
Reference: [16] <author> J. R. Larus. </author> <title> Assemblers, Linkers, and the SPIM Simulator. Appendix A of Computer Organization & Design: the Hardware/Software Interface, </title> <editor> D. A. Patterson and J. L. Hennessy, </editor> <publisher> Morgan Kaufmann, </publisher> <year> 1994. </year>
Reference-contexts: Simulator We performed our experiments using a modified version of CL-SPIM, a cycle-level extension to Larus's instruction-level MIPS simulator, SPIM <ref> [16] </ref>. The bypasses shown in Figures 1 and 2 were instrumented for our experiments. We modelled bypassing from the register write-back stages in both pipes as separate pairs of inputs to the multiplexors; in some designs this function could be implemented inside the register file itself.
Reference: [17] <author> P.G. Lowney, S.M. Freudenberger, T.J. Karzes, W.D. Lichtenstein, R.P. Nix, J.S. O'Donnel, and J.C. Ruttenberg. </author> <title> The Multiflow Trace Scheduling Compiler. </title> <journal> The Journal of Supercomputing, </journal> <volume> 7(1-2):51-142, </volume> <year> 1993. </year>
Reference-contexts: If a bypass connection is missing from both sides of the execution unit, then of course commutative swaps cannot compensate at all for the missing paths. The code-rescheduling recourse remains, however. While techniques such as trace scheduling <ref> [9, 17] </ref> would allow the compiler to look for swapping and scheduling opportunities across basic block boundaries, we will confine ourselves to simple basic-block methods. Code scheduling to avoid absent bypasses closely resembles scheduling to avoid register interlocks [12, 10].
Reference: [18] <author> E. McLellan. </author> <title> The Alpha AXP Architecture and 21064 Processor. </title> <journal> IEEE MICRO, </journal> <volume> 13(3) </volume> <pages> 36-47, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: If i instructions are simultaneously issued to identical 2-input functional units with s pipestages after the earliest answer-producing stage, then a fully bypassed design would require 2i 2 s separate logical bypass connections. One current machine, the Digital Alpha 21064, has 45 separate bypass paths <ref> [18] </ref>. <p> In this paper we treat a bypass as a logical connection from a pipestage result to the input of an execution unit. Different implementations are of course possible: the Digital Alpha 21064 <ref> [18, 8] </ref>, for example, has a separate set of wires for each source pipestage and wide multiplexors physically near the execution units; the Alpha 21164 [3, 5], on the other hand, has a single multi-driver bus for each of the two inputs of each functional unit, with physically distributed control.
Reference: [19] <author> D. A. Patterson and J. L. Hennessy. </author> <title> Computer Organization & Design: the Hardware/Software Interface. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, CA, </address> <year> 1994. </year>
Reference-contexts: Section 6 summarizes our results and suggests avenues for further work in this area. 2 Experimental Framework A simple example will illustrate bypassing and help us motivate the work described here. Consider a simple single-issue RISC integer pipeline <ref> [15, 19] </ref> with five stages: IF (Instruction Fetch), ID (Instruction Decode and register read), EX (EXecute), MEM (MEMory access), and WB (Write Back result).
References-found: 19

