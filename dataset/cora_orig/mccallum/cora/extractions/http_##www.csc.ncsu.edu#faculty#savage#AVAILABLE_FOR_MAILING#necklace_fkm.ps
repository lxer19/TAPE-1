URL: http://www.csc.ncsu.edu/faculty/savage/AVAILABLE_FOR_MAILING/necklace_fkm.ps
Refering-URL: http://www.csc.ncsu.edu/faculty/savage/papers.html
Root-URL: http://www.csc.ncsu.edu
Title: Generating Necklaces  
Author: Frank Ruskey Victoria, B. C. Carla Savage Terry MinYih Wang 
Note: Research supported by the Natural Sciences and Engineering Research Council of Canada under grant A3379. Research supported by the National Science Foundation Grant No. CCR8906500, the National Security Agency Grant No. MDA904-H-1025 and DIMACS (Center for Discrete Mathematics and Theoretical Computer Science), a National Science Foundation Science and Technology Center, NSF-STC 88-09648.  
Address: Victoria, P. O. Box 1700  V8W 2Y2 CANADA  Box 8206 Raleigh, NC 27612-8206  
Affiliation: Department of Computer Science University of  Department of Computer Science North Carolina State University,  
Abstract-found: 0
Intro-found: 1
Reference: [FrKe] <author> H. Fredricksen and I. J. Kessler, </author> <title> "An algorithm for generating necklaces of beads in two colors," </title> <note> Discrete Mathematics 61 (1986) 181-188. </note>
Reference-contexts: A necklace is thus identified with its representative. A simple and elegant algorithm was proposed in [FrMa] and <ref> [FrKe] </ref> to generate for each necklace the lexicographically smallest element. We will refer to this as the FKM algorithm. A disadvantage of the FKM algorithm is that there can be gaps in which as many as b (n 1)=2c non-necklaces are examined between any two necklaces generated. <p> We will refer to this as the FKM algorithm. A disadvantage of the FKM algorithm is that there can be gaps in which as many as b (n 1)=2c non-necklaces are examined between any two necklaces generated. For the case k = 2 the authors of <ref> [FrKe] </ref> prove an upper bound of b (n 1)=2cN (2; n) on the number of n-tuples generated and examined by the algorithm. The time spent generating and checking each element is O (n), giving an overall time for the algorithm of O (n 2 N (2; n)). <p> Figure 1 shows examples of lists F (k; n) where non-necklaces are indicated by bullets. Figure 2 illustrates how a gap of length b (9 1)=2c = 4 can occur between successive necklaces when k = 2 and n = 9. It is claimed in <ref> [FrKe] </ref> that succ (ff) is a necklace if and only if the `i' of Definition 2 is a divisor of n and we prove this in Lemma 3. Incorporating this test for necklace-checking, the entire algorithm can be summarized by the PASCAL code in Figure 3.
Reference: [FrMa] <author> H. Fredricksen and J. Maiorana, </author> <title> "Necklaces of beads in k colors and k-ary de Bruijn sequences," </title> <journal> Discrete Mathematics 23, </journal> <volume> No. </volume> <month> 3 </month> <year> (1978) </year> <month> 207-210. </month>
Reference-contexts: A necklace is thus identified with its representative. A simple and elegant algorithm was proposed in <ref> [FrMa] </ref> and [FrKe] to generate for each necklace the lexicographically smallest element. We will refer to this as the FKM algorithm. A disadvantage of the FKM algorithm is that there can be gaps in which as many as b (n 1)=2c non-necklaces are examined between any two necklaces generated. <p> It is shown in <ref> [FrMa] </ref> that no necklace can lie strictly between two elements of F (k; n), so that all necklaces appear on F (k; n). Thus, discarding non-necklaces of F (k; n) would result in a list of all necklaces in increasing order.
Reference: [Gi] <author> E. N. Gilbert, </author> <title> "Gray codes and paths on the n-cube," </title> <note> Bell Systems Technical Journal (1958) 815-826. </note>
Reference: [Jo] <author> S. M. Johnson, </author> <title> "Generation of permutations by adjacent transpositions," </title> <journal> Math. Comp. </journal> <month> 17 </month> <year> (1963) </year> <month> 282-285. </month>
Reference-contexts: We ask whether it is possible, by any strategy, to generate necklaces in worst case constant time? As a variation, is it possible to list necklaces in some Gray-code like order ([Gi], <ref> [Jo] </ref>, [Lu], [Ru], [Sa] )? Acknowledgement Thanks to Herb Wilf (for suggesting this problem and for help with the proof of Lemma 5) and Pete Winkler (for helpful discussions on the FKM algorithm.)
Reference: [Kn] <author> D. E. Knuth, </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> Vol. 1, </volume> <booktitle> Fundamental Algorithms, second edition, </booktitle> <publisher> Addison-Wesley (1973). </publisher>
Reference-contexts: ) and thus by the equality above, the left-hand side of (10) is equal to n1 X p 1 n n1 X p 1 1 n1 X p 1 j To prove the lemma observe that the first term on the right above converges to k p =(k1) p (see <ref> [Kn] </ref>, p.90), and we will show that the second term converges to zero.
Reference: [LiHiCa] <author> W. Liu, T. H. Hildebrandt, and R. Cavin III, </author> <title> "Hamiltonian cycles in the shu*e-exchange network," </title> <journal> IEEE Transactions on Computers C-38, </journal> <volume> No. </volume> <month> 5 </month> <year> (1989) </year> <month> 745-750. </month>
Reference-contexts: For simplicity, we focus on the case for two colors, but the generalization to k colors is described in detail in [WaSa]. Our idea for generating necklaces of two-color beads was inspired by a result in <ref> [LiHiCa] </ref> that a certain variation on the shu*e-exchange graph is hamiltonian. (The graph of [LiHiCa] is actually the deBruijn graph, which is known to be hamiltonian.) When k = 2, the n-tuples are bit strings which we regard as elements of f0; 1g n . <p> Our idea for generating necklaces of two-color beads was inspired by a result in <ref> [LiHiCa] </ref> that a certain variation on the shu*e-exchange graph is hamiltonian. (The graph of [LiHiCa] is actually the deBruijn graph, which is known to be hamiltonian.) When k = 2, the n-tuples are bit strings which we regard as elements of f0; 1g n .
Reference: [Lu] <author> J. Lucas, </author> <title> "The rotation graph of binary trees is Hamiltonian," </title> <note> Journal of Algorithms 8 (1987) 503-535. 19 </note>
Reference-contexts: We ask whether it is possible, by any strategy, to generate necklaces in worst case constant time? As a variation, is it possible to list necklaces in some Gray-code like order ([Gi], [Jo], <ref> [Lu] </ref>, [Ru], [Sa] )? Acknowledgement Thanks to Herb Wilf (for suggesting this problem and for help with the proof of Lemma 5) and Pete Winkler (for helpful discussions on the FKM algorithm.)
Reference: [Ma] <author> G. Mackiw, </author> <title> Applications of Abstract Algebra, </title> <publisher> John Wiley and Sons, </publisher> <address> New York (1985). </address>
Reference-contexts: Let N (k; n) denote the number of n-bead necklaces in k colors. It is known that N (k; n) = n djn 1 n X k gcd (i;n) : (1) (See, e.g., <ref> [Ma] </ref>) where OE is the Euler totient function, so that 1 (k n ) N (k; n) n So, in applications where every rotation of a given k-ary n-tuple represents the same phenomenon, it would be more efficient to work with only one representative of each necklace, rather than all k
Reference: [Ru] <author> F. Ruskey, </author> <title> "Adjacent interchange generation of combinations," </title> <note> Journal of Algorithms 9 (1988) 162-180. </note>
Reference-contexts: We ask whether it is possible, by any strategy, to generate necklaces in worst case constant time? As a variation, is it possible to list necklaces in some Gray-code like order ([Gi], [Jo], [Lu], <ref> [Ru] </ref>, [Sa] )? Acknowledgement Thanks to Herb Wilf (for suggesting this problem and for help with the proof of Lemma 5) and Pete Winkler (for helpful discussions on the FKM algorithm.)
Reference: [Sa] <author> C. Savage, </author> <title> "Gray code sequences of partitions," </title> <journal> Journal of Algorithms 10, </journal> <volume> No. </volume> <month> 4 </month> <year> (1989). </year>
Reference-contexts: We ask whether it is possible, by any strategy, to generate necklaces in worst case constant time? As a variation, is it possible to list necklaces in some Gray-code like order ([Gi], [Jo], [Lu], [Ru], <ref> [Sa] </ref> )? Acknowledgement Thanks to Herb Wilf (for suggesting this problem and for help with the proof of Lemma 5) and Pete Winkler (for helpful discussions on the FKM algorithm.)
Reference: [WaSa] <author> T. Wang and C. Savage, </author> <title> "A new algorithm for generating necklaces," </title> <type> Report TR-90-20, </type> <institution> Department of Computer Science, North Carolina State University (1990). Figure Captions: </institution> <month> 21 </month>
Reference-contexts: For simplicity, we focus on the case for two colors, but the generalization to k colors is described in detail in <ref> [WaSa] </ref>.
References-found: 11

