URL: http://www.cs.umn.edu/Users/dept/users/tripathi/Ecoop_paper.ps
Refering-URL: http://www.cs.umn.edu/Users/dept/users/tripathi/
Root-URL: http://www.cs.umn.edu
Title: Issues with Exception Handling in ObjectOriented Systems  
Author: Robert Miller and Anand Tripathi 
Address: Minneapolis, Minnesota 55455 USA  
Affiliation: Computer Science Department University of Minnesota  
Abstract: The goals of exception handling mechanisms are to make programs more reliable and robust. The integration of exception handling mechanisms with objectoriented languages raises some unique issues. The requirements of exception handling often conflict with some of the goals of objectoriented designs, such as supporting design evolution, functional specialization, and abstraction for implementation transparency. This paper demonstrates these conflicts, illustrates that the use of exception handling in objectoriented systems poses potential pitfalls, and suggests that their resolution is one of the first steps necessary to make exception handling robust in objectoriented designs and languages. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Booch, </author> <title> ObjectOriented Analysis and Design with Applications, </title> <type> 2 nd Ed, </type> <institution> Benjamin/Cummings, </institution> <year> 1994. </year>
Reference-contexts: Each element of Array has a field that is a pointer to another element of Array, so that the pointers form a doubly-linked list of Array elements. Suppose that Array [50] is to have its pointer field set to Array <ref> [1] </ref>, and vice versa. Assuming that Array is initialized in ascending index order, Array [1] will be pointing to Array [50] when an exception is signaled during the initialization of Array [50]. <p> Suppose that Array [50] is to have its pointer field set to Array <ref> [1] </ref>, and vice versa. Assuming that Array is initialized in ascending index order, Array [1] will be pointing to Array [50] when an exception is signaled during the initialization of Array [50]. The Array code masks the exception, and as part of the masking the pointer for Array [50] is set to a predefined value, NULL. <p> So, C may not be able to do any recovery since it cannot determine where the exception occurred. Second, it may be desired to undo the link that Array <ref> [1] </ref> has set pointing to Array [50]. Undoing of actions is normally considered an error recovery path and usually not a part of the normal execution path, hence Array [1] needs to have an exception signaled to it. It would be preferred if the exception is signaled to Array [1] before <p> Second, it may be desired to undo the link that Array <ref> [1] </ref> has set pointing to Array [50]. Undoing of actions is normally considered an error recovery path and usually not a part of the normal execution path, hence Array [1] needs to have an exception signaled to it. It would be preferred if the exception is signaled to Array [1] before signaling the exception to C so that C need not concern itself with invalid composition relationships. <p> Array <ref> [1] </ref> has set pointing to Array [50]. Undoing of actions is normally considered an error recovery path and usually not a part of the normal execution path, hence Array [1] needs to have an exception signaled to it. It would be preferred if the exception is signaled to Array [1] before signaling the exception to C so that C need not concern itself with invalid composition relationships. To accomplish this, the exception from Array [50] would need to be signaled to Array [1], then signaled to C. <p> It would be preferred if the exception is signaled to Array <ref> [1] </ref> before signaling the exception to C so that C need not concern itself with invalid composition relationships. To accomplish this, the exception from Array [50] would need to be signaled to Array [1], then signaled to C. As an aside, no known language propagates exceptions downward and upward in the fashion described here. When this situation arises in current languages, what may be done is to create a method that performs the undo.
Reference: [2] <author> A. Borgida, </author> <title> Exceptions in ObjectOriented Languages, </title> <journal> SIGPLAN Notices, </journal> <volume> vol. 21, no. 10, </volume> <pages> pp. 107-119, </pages> <month> Oct. </month> <year> 1986. </year>
Reference-contexts: This makes it difficult to prove the correctness of an interface by only examining the encapsulated implementation. In the modeling domain, a major concern is flexibility <ref> [2] </ref>. An example from [2] illustrates the use of exceptions in the modeling domain. A real estate database has fields for the address and price of each listed house. <p> This makes it difficult to prove the correctness of an interface by only examining the encapsulated implementation. In the modeling domain, a major concern is flexibility <ref> [2] </ref>. An example from [2] illustrates the use of exceptions in the modeling domain. A real estate database has fields for the address and price of each listed house.
Reference: [3] <author> T. Cargill, </author> <title> Exception Handling: A False Sense of Security, </title> <journal> C++ Report, </journal> <volume> vol. 6, no. 9, </volume> <pages> pp. 21-24, </pages> <address> Nov.-Dec. </address> <year> 1994. </year>
Reference-contexts: It is this paper's position that the differences are more like conflicts because exception handling can contradict the conventional objectoriented paradigm. As noted in Section 1, exception handling is often error handling, which is notoriously difficult to do. The conflicts can lead to a 'false sense of security' <ref> [3] </ref> that exception handling in objectoriented languages will automatically yield more robust programs. To the contrary, the conflicts may lead to a less robust program. To begin the discussion, it is necessary to see how exception handling may differ from objectorientation.
Reference: [4] <author> N.H. Cohen, </author> <title> Ada as a Second Language, 2 nd Ed, </title> <publisher> McGraw-Hill, </publisher> <year> 1996. </year>
Reference-contexts: One study [5] has shown that perhaps two-thirds of a program may be for error handling. The rising importance of exception handling is evident in object-oriented languages such as C++ [20], Java [18], Ada <ref> [4] </ref>, and Smalltalk [8]. By combining objectoriented design methods with exception handling techniques, it is hoped that more reliable error handling can occur within a program. However, exception handling often does not exactly fit into the objectoriented paradigm.
Reference: [5] <author> F. Cristian, </author> <title> Exception Handling, </title> <institution> IBM Research Report RJ5724, </institution> <year> 1987. </year>
Reference-contexts: The importance of exception handling is for program reliability and robustness, since many objectoriented languages consider an exception to be some kind of error. Recovering from errors has traditionally been error prone, and is itself a significant cause of program failures. One study <ref> [5] </ref> has shown that perhaps two-thirds of a program may be for error handling. The rising importance of exception handling is evident in object-oriented languages such as C++ [20], Java [18], Ada [4], and Smalltalk [8].
Reference: [6] <author> C. Dony, </author> <title> "An ObjectOriented Exception Handling System for an ObjectOriented Language", </title> <booktitle> in Proceedings of ECOOP'88, </booktitle> <pages> pp. 146-159, </pages> <year> 1991. </year>
Reference-contexts: In Beta [15], there is no explicit construct to represent exception conditions. When an abnormal condition is detected, an appropriate pattern, which is a Beta object, is invoked. This pattern defines the exception handler for the detected condition. Beta's approach is like building "fault tolerant encapsulations" <ref> [6] </ref> that try to handle abnormal conditions within the object at the points where they arise. The program or object's enclosing scope is terminated if the exception cannot be handled within the object. An exception condition is detected and handled as part of the normal flow of execution. <p> Suppose that this reliable disk system is implemented using two drives acting as a primary-backup pair. There are two opposite solutions to building such a fault-tolerant object <ref> [6] </ref>. One is to perform all recovery within the object in case of any exception and not propagate the exception to the objects users. The second approach is to mask exceptions within the object, and propagate only relevant exceptions to the objects users.
Reference: [7] <author> C. Dony, </author> <title> Exception Handling and ObjectOriented Programming: Towards a Synthesis, </title> <booktitle> in Proceedings OOPSLA 90, </booktitle> <pages> pp. 322-330, </pages> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: At one end, Beta [15] does not provide any special constructs or primitives to represent and handle exceptions. Instead, Beta uses its basic language constructs (such as virtual patterns). At the other end, some systems <ref> [7] </ref> use a special class of objects to represent exceptions that have certain predefined operations, such as signal or raise. In between are languages such as Guide [13] that represent exceptions as symbols, which can be organized according to some inheritance hierarchy.
Reference: [8] <author> A. Goldberg and D. Robson, </author> <title> Smalltalk-80: The Language, </title> <publisher> Addison-Wesley, </publisher> <year> 1989 </year>
Reference-contexts: One study [5] has shown that perhaps two-thirds of a program may be for error handling. The rising importance of exception handling is evident in object-oriented languages such as C++ [20], Java [18], Ada [4], and Smalltalk <ref> [8] </ref>. By combining objectoriented design methods with exception handling techniques, it is hoped that more reliable error handling can occur within a program. However, exception handling often does not exactly fit into the objectoriented paradigm.
Reference: [9] <author> J.B. Goodenough, </author> <title> Exception Handling: Issues and a Proposed Notation, </title> <journal> Communications of the ACM, </journal> <volume> vol. 18, no. 12, </volume> <pages> pp. 683-696, </pages> <month> Dec. </month> <year> 1975. </year>
Reference-contexts: Finally, a brief overview of the exception handling models of some of the most common objectoriented languages is presented. The scope of this discussion is limited to the concepts that are relevant from the viewpoint of the central theme of this paper. 2.1 Terminology and Exception Models Goodenough's work <ref> [9] </ref> forms the foundation of exception handling terminology and models. Over the past 20 years, there have been several further elaborations and extensions of these models. <p> There are two aspects of abstraction that are relevant here: Generalization of operations. Composition. 4.1.1 Generalized Operations A goal of exception handling mechanisms is to generalize operations of an object and make them usable in a wider range of conditions <ref> [9] </ref>. Often this may require exposing more implementation details, as a part of the abstraction, to the objects users. We observe here that the motivation for introducing exception handling may sometimes impose conflicting demands in regard to hiding implementation details. The following example illustrates this point.
Reference: [10] <author> J.D. Ichbiah, J.C. Heliard, O. Roubine, J.G.P. Barnes, B. Krieg-Brueckner, and B.A. Wichmann, </author> <title> Rationale for the Design of the Ada Programming Language, </title> <journal> SIGPLAN Notices, </journal> <volume> vol. 14, no. 6, Part B, </volume> <month> Jun. </month> <year> 1979. </year>
Reference: [11] <author> A.K. Jones, </author> <title> "The Object Model: A Conceptual Tool for Structuring Software," </title> <booktitle> i n Operating Systems and Advanced Course - Lecture Notes in Computer Science, </booktitle> <volume> Vol. 60, </volume> <pages> pp. 7-16, </pages> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: Towards the building of robust and reliable systems, object encapsulation mechanisms create natural domains for confining the effects of errors within an object and propagating such effects in a well-controlled fashion across the object boundaries <ref> [11] </ref>. The importance of exception handling is for program reliability and robustness, since many objectoriented languages consider an exception to be some kind of error. Recovering from errors has traditionally been error prone, and is itself a significant cause of program failures.
Reference: [12] <author> J.L. Knudsen, </author> <title> Better Exception-Handling in BlockStructured Systems, </title> <journal> IEEE Software, </journal> <volume> vol. 17, no. 2, </volume> <pages> pp. 40-49, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: Yemini and Berry [23] define an exception condition in an operation invocation as the occurrence of a state that does not satisfy the input assertion for the operation. Knudsen <ref> [12] </ref> defines an exception as a characterization of an unusual or abnormal condition that requires extraordinary computation. In many languages (e.g., C++, Java, Ada, Eiffel, and Smalltalk) an exception is normally viewed as an error. An exception is an abnormal computation state.
Reference: [13] <author> S. Lacourte, </author> <title> Exceptions in Guide, an ObjectOriented Language for Distributed Applications, </title> <booktitle> in Proceedings ECOOP 91, </booktitle> <pages> pp. 268-287, </pages> <year> 1991. </year>
Reference-contexts: The exception context may contain some data that is explicitly passed by the signaler, as in CLU and C++. Additionally, it may contain information implicitly passed by the language runtime; for example, the name of the method or the class that signaled the exception. Guide <ref> [13] </ref> allows a handler to distinguish between exceptions by additionally using the class and method names of the signaler. Exception propagation is the signaling of an exception to the target's invoker. There are two ways to propagate an exception: implicit (i.e., automatic), and explicit. In some languages, e.g. <p> The handler can return a value in place of the result expected from the signaler. The signaler's block is terminated and the result from the handler is returned to the signaler's invoker. Languages that allow a handler to replace a signalers result include Guide <ref> [13] </ref>. Lastly, it is not required that a language only support one exception model, though that is usually the case. <p> In <ref> [13] </ref>, arguments are made against resuming a signaler inside an encapsulation after the execution of some actions by a handler outside the encapsulation. This makes it difficult to prove the correctness of an interface by only examining the encapsulated implementation. In the modeling domain, a major concern is flexibility [2]. <p> Instead, Beta uses its basic language constructs (such as virtual patterns). At the other end, some systems [7] use a special class of objects to represent exceptions that have certain predefined operations, such as signal or raise. In between are languages such as Guide <ref> [13] </ref> that represent exceptions as symbols, which can be organized according to some inheritance hierarchy. Such an organization permits incremental specialization of exceptions and their handlers, and can provide default and generic support for exceptions defined at the higher levels of the inheritance hierarchy. <p> Representing exceptions as objects allows inclusion of context information that can be explicit (passed by the signaler) as well as implicit (passed by the runtime) to communicate to the handler the nature and cause of the exception. Guide <ref> [13] </ref> implicitly provides the handler with the names of the class and the method that signaled the exception. In C++, context-related information is explicitly passed to the handler with the object that is created when the exception is raised.
Reference: [14] <author> B. Liskov and A. Snyder, </author> <title> Exception Handling in CLU, </title> <journal> IEEE Transactions o n Software Engineering, </journal> <volume> vol. SE-5, no. 6, </volume> <pages> pp. 546-558, </pages> <month> Nov. </month> <year> 1979. </year>
Reference: [15] <author> O.L. Madsen, B. Moller-Pedersen, and K. Nygaard, </author> <title> ObjectOriented Programming i n the Beta Programming Language, </title> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: At one end, Beta <ref> [15] </ref> does not provide any special constructs or primitives to represent and handle exceptions. Instead, Beta uses its basic language constructs (such as virtual patterns). <p> Any termination of a method through the rescue clause results in the failure of the operation. Within a rescue clause, the exception can be determined by comparing a predefined variable called exception with an exception name. The exception names form a global name space. In Beta <ref> [15] </ref>, there is no explicit construct to represent exception conditions. When an abnormal condition is detected, an appropriate pattern, which is a Beta object, is invoked. This pattern defines the exception handler for the detected condition. <p> What is needed is exception nonconformance and the ability to add exception handlers to existing code without the need to recompile the code. Beta <ref> [15] </ref> supports this kind of augmentation of code, using its inner mechanism. 4.4 Inheritance The inheritance goal is to promote code reuse and conceptual specialization. The aspect to be considered here is the inheritance anomaly. <p> An inheritance anomaly occurs when a subclass method has to re-implement a parent class method to get the derived class's functionality [16]. The anomaly can occur when a subclass's exception handling replaces rather than augments the parent's handling of exceptions. Beta <ref> [15] </ref> is one of the few languages that supports augmentation of the parent class code by a subclass, rather than completely rewriting the method's code. Therefore, some of the problems mentioned here do not apply to Beta.
Reference: [16] <author> S. Matsuoka and A. Yonezawa, </author> <title> Analysis of Inheritance Anomaly in ObjectOriented Concurrent Programming Languages, Research Directions in Concurrent Object-Oriented Programming, chapter 4, </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: The aspect to be considered here is the inheritance anomaly. An inheritance anomaly occurs when a subclass method has to re-implement a parent class method to get the derived class's functionality <ref> [16] </ref>. The anomaly can occur when a subclass's exception handling replaces rather than augments the parent's handling of exceptions. Beta [15] is one of the few languages that supports augmentation of the parent class code by a subclass, rather than completely rewriting the method's code.
Reference: [17] <author> B. Meyer, </author> <title> Eiffel: </title> <booktitle> The Language, Prentice-Hall 1992. </booktitle>
Reference: [18] <author> T. Ritchey, </author> <title> Programming with Java!, </title> <publisher> New Riders, </publisher> <year> 1995. </year>
Reference-contexts: Recovering from errors has traditionally been error prone, and is itself a significant cause of program failures. One study [5] has shown that perhaps two-thirds of a program may be for error handling. The rising importance of exception handling is evident in object-oriented languages such as C++ [20], Java <ref> [18] </ref>, Ada [4], and Smalltalk [8]. By combining objectoriented design methods with exception handling techniques, it is hoped that more reliable error handling can occur within a program. However, exception handling often does not exactly fit into the objectoriented paradigm.
Reference: [19] <author> A.B. Romanovsky, L.V. Shturtz, and V.R. Vassilyev, </author> <title> Designing Fault-Tolerant Objects in ObjectOriented Programming, </title> <booktitle> in Proceedings 7th International Conference of Technology of Object Oriented Languages and Systems (TOOLS Europe 92), </booktitle> <pages> pp. 199-205, </pages> <year> 1992. </year>
Reference: [20] <author> B. Stroustrup, </author> <title> The C++ Programming Language, 2 nd Ed., </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: Recovering from errors has traditionally been error prone, and is itself a significant cause of program failures. One study [5] has shown that perhaps two-thirds of a program may be for error handling. The rising importance of exception handling is evident in object-oriented languages such as C++ <ref> [20] </ref>, Java [18], Ada [4], and Smalltalk [8]. By combining objectoriented design methods with exception handling techniques, it is hoped that more reliable error handling can occur within a program. However, exception handling often does not exactly fit into the objectoriented paradigm.
Reference: [21] <author> B. Stroustrup, </author> <title> The Design and Evolution of C++, </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Over the years, experience has indicated that (a variant of) the termination model is easier to use than the resumption model in the implementation domain <ref> [21] </ref>.
Reference: [22] <author> A. Taivalsaari, </author> <title> On the Notion of Inheritance, </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 28, no. 3, pp.438-479, </volume> <month> Sept. </month> <year> 1996. </year>
Reference-contexts: The main reasons for this restriction are ease of implementation and that one model can usually emulate the main characteristics of the other models (though it may be grossly inefficient). 2.2 Domains of Exception Handling There are two views (or domains) of inheritance <ref> [22] </ref>: modeling and implementation. The modeling domain is for conceptual inheritance, while the implementation domain is for code reuse. Subtyping is conceptual specialization, while subclassing is implementation reuse of code classes.
Reference: [23] <author> S. Yemini and D.M. Berry, </author> <title> A Modular Verifiable Exception-Handling Mechanism, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 7, no. 2, </volume> <pages> pp. 214-243, </pages> <month> Apr. </month> <year> 1985. </year>
Reference-contexts: Yemini and Berry <ref> [23] </ref> define an exception condition in an operation invocation as the occurrence of a state that does not satisfy the input assertion for the operation. Knudsen [12] defines an exception as a characterization of an unusual or abnormal condition that requires extraordinary computation. <p> In the resumption model, computation continues from the point where the exception was originally raised. The retry model is a combination of termination and resumption; when the exception is handled, the signaler's block is terminated and then is reinvoked (or retried). The replacement model <ref> [23] </ref> is a variant of termination. The handler can return a value in place of the result expected from the signaler. The signaler's block is terminated and the result from the handler is returned to the signaler's invoker.
References-found: 23

