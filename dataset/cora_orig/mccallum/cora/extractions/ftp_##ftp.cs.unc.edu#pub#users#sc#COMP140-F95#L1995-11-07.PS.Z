URL: ftp://ftp.cs.unc.edu/pub/users/sc/COMP140-F95/L1995-11-07.PS.Z
Refering-URL: http://www.cs.unc.edu/~sc/teaching/COMP140-F1995/lectures.html
Root-URL: http://www.cs.unc.edu
Title: COMP 140: Introduction to Translator Systems Code Generation (Lecture 5)  
Author: Siddhartha Chatterjee 
Keyword: .globl main .text main: top-level stuff j $L1# jump around subroutine declaration fib:  
Note: 2 Peculiarities of Turing--  
Date: 7 November 1995  
Abstract: Today we cover a few miscellaneous topics related to code generation: global variables, Turing- peculiarities, and a better code generation technique for expressions. On the MIPS architecture, the text segment begins at memory address 0x400000, the static data segment begins at address 0x10000000, and the stack segment begins at address 0x7fffffff and grows downward. The text segments contains the instructions for the program; the static data segment contains objects whose size is known to the compiler and whose lifetime is the program's entire execution. Turing-- global variables are stored in the static data segment of memory. Since the data segment begins far above the text segment, the load and store instructions cannot directly reference data objects in the data segment with their 16-bit offset fields. One solution to this problem would be to add another level of indirection and to load a base address into a GP register before each load. This would mean that loading and storing of global variables would require two instructions instead of one. To avoid this performance penalty, MIPS systems typically dedicate register $28 as a global pointer to the static data segment. This register contains the address 0x10008000, so load and store instructions can use their signed 16-bit offset fields to access the first 64kB of the static data segment. Of course, this only makes the addresses 0x10000000 through 0x10010000 accessible with a single instruction. Accessing locations outside this range still requires two instructions. At the top level, a Turing-- file can contain declarations and initializations of constants and variables, subroutine declarations, and statements, all interleaved with each other. The language definition requires that all the initializations and statements be executed in order. This requires some care to handle correctly, two statements at the top level may be separated by a subroutine declaration. The solution to this problem is to branch around the subroutine declaration in the code. Thus, the code for turing1 would have the following form. 
Abstract-found: 1
Intro-found: 1
References-found: 0

