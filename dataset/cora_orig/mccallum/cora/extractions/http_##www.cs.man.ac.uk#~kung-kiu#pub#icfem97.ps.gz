URL: http://www.cs.man.ac.uk/~kung-kiu/pub/icfem97.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~kung-kiu/pub/
Root-URL: http://www.cs.man.ac.uk
Email: kung-kiu@cs.man.ac.uk  ornaghi@dsi.unimi.it  alan@trireme.co  
Title: Frameworks in Catalysis: Pictorial Notation and Formal Semantics  
Author: Kung-Kiu Lau Mario Ornaghi Alan Wills 
Address: Manchester M13 9PL, UK  Via Comelico 39/41, 20135 Milano, Italy  24 Windsor Road, Manchester M19 2EB, UK  
Affiliation: Dept of Computer Science, University of Manchester  DSI, Universita' degli studi di Milano  Trireme International Ltd  
Abstract: In OO Design, it is widely recognised that the distribution of tasks between objects and the contracts between them are key to effective design. In composing designs from reusable parts, the parts are therefore frameworks, namely descriptions of the interactive relationships between objects which participate in the interactions. Designs are then built by composing these frameworks, and any object in the final design will play (various) roles from several frameworks. Practitioners of OO Design use pictorial notations for design. However, in order to reason formally about design, we need a sound (formal) semantics for the diagrams. In this paper, we show that frameworks can be formalised as many-sorted theories, and then present a pictorial representation of such theories, developed in the Catalysis project. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Bertoni, G. Mauri and P. Miglioli. </author> <title> On the power of model theory in specifying abstract data types and in capturing their recursiveness. </title> <journal> Fundamenta Informati-cae VI(2):127170, </journal> <year> 1983. </year>
Reference-contexts: However, isoinitial theories handle negation properly, whereas initial theories can only do so via so-called `final models'. Negation is an important property in reasoning about specifications and program correctness in general, e.g. in proving invariants. Therefore we have chosen isoinitial theories as frameworks (see <ref> [1] </ref> for a discussion of isoinitial theories). The syntax we will use for F is similar to that used in algebraic abstract data types (e.g. [9, 23, 21]).
Reference: [2] <author> C.C. Chang and H.J. Keisler. </author> <title> Model Theory. </title> <publisher> North-Holland, </publisher> <year> 1973. </year>
Reference-contexts: If ae (oe) = oe for every symbol oe, i.e. , we get the usual notion of reduct to a subsignature (see e.g. <ref> [2] </ref>). In this case, the reduct will also be denoted by ij.
Reference: [3] <author> D. Coleman et al. </author> <title> Object-Oriented Development: The Fusion Method. </title> <publisher> Prentice-Hall, </publisher> <year> 1994. </year>
Reference-contexts: The marriage of a `user-friendly' pictorial notation and a formal semantics is all the more critical for OO Design, where the task is made much more complex by the use of objects. Most of the existing formal OO Design methods such as Fusion <ref> [3, 5] </ref> and Syntropy [4] use classes or objects as the basic unit of design. However, it is increasingly recognised that classes are not the best focus for design (see e.g. [11, 18]).
Reference: [4] <author> S. Cook and J. Daniels. </author> <title> Designing Object Systems. </title> <publisher> Prentice-Hall, </publisher> <year> 1994. </year>
Reference-contexts: The marriage of a `user-friendly' pictorial notation and a formal semantics is all the more critical for OO Design, where the task is made much more complex by the use of objects. Most of the existing formal OO Design methods such as Fusion [3, 5] and Syntropy <ref> [4] </ref> use classes or objects as the basic unit of design. However, it is increasingly recognised that classes are not the best focus for design (see e.g. [11, 18]).
Reference: [5] <author> D.F. D'Souza and A.C. Wills. </author> <title> Extending Fusion: practical rigor and refinement. </title> <editor> In R. Malan et al, editors, </editor> <booktitle> Object-Oriented Development at Work. Prentice-Hall 1996. </booktitle>
Reference-contexts: The marriage of a `user-friendly' pictorial notation and a formal semantics is all the more critical for OO Design, where the task is made much more complex by the use of objects. Most of the existing formal OO Design methods such as Fusion <ref> [3, 5] </ref> and Syntropy [4] use classes or objects as the basic unit of design. However, it is increasingly recognised that classes are not the best focus for design (see e.g. [11, 18]).
Reference: [6] <author> D.F. D'Souza and A.C. Wills. </author> <title> Component-Based Development using Catalysis. </title> <note> Draft book. </note>
Reference-contexts: If we look at typical design artefacts, they are rarely just about one object, but about groups of objects and the way they interact. In the Catalysis project <ref> [6] </ref>, we use the term modelling frameworks, or just frameworks for short, for descriptions of groups of objects, their relationships, division of responsibilities, and interactions.
Reference: [7] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissades. </author> <title> Design Patterns Elements of Reusable Object-Oriented Design. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: In the Catalysis project [6], we use the term modelling frameworks, or just frameworks for short, for descriptions of groups of objects, their relationships, division of responsibilities, and interactions. Most of the design patterns discussed in books (e.g. <ref> [7] </ref>) and discussion groups are based around frameworks: for example, the `observer' pattern which keeps many views up to date with one subject; or `proxy', which provides a local representative of a remote object; or any of the more specialised design-ideas that are fitted together to make any system.
Reference: [8] <author> J.A. Goguen and R.M. Burstall. Institutions: </author> <title> Abstract model theory for specification and programming. </title> <journal> J. ACM 39(1):95146, </journal> <year> 1992. </year>
Reference-contexts: Signature and Theory Morphisms We recall that a framework is a (many-sorted) first-order theory, with a signature consisting of a set S of sort symbols, a set F of function symbols, and a set R of relation symbols. Now first-order theories are an institution <ref> [8] </ref>, so we need to introduce some properties of an institution, and some terminology. <p> In this case, the reduct will also be denoted by ij. It is immediate to extend a morphism ae : ) to a map ae : L ) L , where L and L are the languages generated by and respectively, and the following satisfaction condition (see <ref> [8] </ref>) can be easily proved: Theorem 5.1 For every closed -formula F and every - interpretation i, i j= ae (F ) , ijae j= F .
Reference: [9] <author> J.A. Goguen and J. Meseguer. </author> <title> Unifying functional, object-oriented and relational programming with logical semantics. </title> <editor> In B. Shriver and P. Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 417477. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Therefore we have chosen isoinitial theories as frameworks (see [1] for a discussion of isoinitial theories). The syntax we will use for F is similar to that used in algebraic abstract data types (e.g. <ref> [9, 23, 21] </ref>). However, whilst an algebraic abstract data type is an initial model ([10]) of its specification, the intended model of F , i.e. the abstract data type it axiomatises, is an isoinitial model. In general, the existence of an isoinitial model is of course not guaranteed.
Reference: [10] <author> J.A. Goguen, J.W. Thatcher, and E. Wagner. </author> <title> An initial algebra approach to specification, correctness and implementation. </title> <editor> In R. Yeh, editor, </editor> <booktitle> Current Trends in Programming Methodology, IV, </booktitle> <pages> pages 80-149. </pages> <publisher> Prentice-Hall, </publisher> <year> 1978. </year>
Reference-contexts: Both initial and isoinitial theories enjoy the so-called `no junk' and `no confusion' properties <ref> [10] </ref>. `No junk' means that the (initial or isoinitial) model is reachable (by ground terms), and `no confusion' means that two ground terms of the domain of the model are identical iff they are equal according to the axioms.
Reference: [11] <author> R. Helm, I.M. Holland, and D. Gangopadhay. </author> <title> Contracts Specifying behavioural compositions in OO systems. </title> <journal> Sigplan Notices 25(10) (Proc. </journal> <volume> ECOOP/OOPSLA 90). </volume>
Reference-contexts: Most of the existing formal OO Design methods such as Fusion [3, 5] and Syntropy [4] use classes or objects as the basic unit of design. However, it is increasingly recognised that classes are not the best focus for design (see e.g. <ref> [11, 18] </ref>). Typically, the work of creating a design has to be split up between the members of a team; and its artefacts not just the final code, but design documents too have to be stored, moved around, adapted, and hopefully incorporated into more than one end-product. <p> In a sense, the frameworks are the interesting pieces of design, and the objects are just where they are tied together in a particular system. This interesting perspective has been promoted by Helm et al <ref> [11] </ref>, Nierstrasz and Tsichritzis [19], Harrison et al [12], Reenskaug et al [20], and others, and is illustrated in Figure 2.
Reference: [12] <author> W. Harrison, H. Osher, and H. Mili. </author> <booktitle> Subjectivity in object-oriented systems. In workshop reports, </booktitle> <volume> OOP-SLA 94 & 95. </volume>
Reference-contexts: In a sense, the frameworks are the interesting pieces of design, and the objects are just where they are tied together in a particular system. This interesting perspective has been promoted by Helm et al [11], Nierstrasz and Tsichritzis [19], Harrison et al <ref> [12] </ref>, Reenskaug et al [20], and others, and is illustrated in Figure 2.
Reference: [13] <author> I. Jacobson et al. </author> <title> Object-Oriented Software Engineering. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: The idea is similar to transactions and to use-cases <ref> [13] </ref>. Both participants are named in the headers and referred to in the postcondition. The set of operations on the types involved need not be complete.
Reference: [14] <author> C. Kreitz, K.-K. Lau, and M. Ornaghi. </author> <title> Formal reasoning about modules, reuse and their correctness. In D.M. </title> <editor> Gabbay and H.J. Ohlbach, editors, </editor> <booktitle> Proc. Int. Conf. on Formal and Applied Practical Reasoning, LNAI 1085, </booktitle> <pages> pages 384399, </pages> <publisher> Springer-Verlag 1996. </publisher>
Reference-contexts: If F [ae; F 1 ] is defined, then F () ae F [ae; F 1 ]( 1 ) and F 1 ( 1 ) F [ae; F 1 ]( 1 ). These theorems can be used to introduce sound extension rules as compositions of a particular kind (see <ref> [14] </ref> for a discussion). Example 5.2 Continuing from Example 5.1, we can now complete the framework for Teaching Resource Allocation by composing the renamed instances RoomAllocation and InstructorAllocation of ResourceAllocation.
Reference: [15] <author> K.-K. Lau and M. Ornaghi. </author> <title> On specification frameworks and deductive synthesis of logic programs. </title> <editor> In L. Fribourg and F. Turini, editors, </editor> <booktitle> Proc. LOPSTR 94 and META 94, </booktitle> <volume> LNCS 883, </volume> <pages> pages 104121, </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Furthermore, it can be shown that if F is a (possibly infinite) recursively enumerable axiomatisation, then there exists an isoinitial model in which relation symbols are interpreted by decidable relations, and function symbols by total computable functions. In practice, we only ever construct and use such frameworks (see <ref> [15, 17] </ref> for a related discussion). A framework F typically defines a new abstract data type by using pre-defined types. Axioms for the old sorts are imported, and new ones are added to define new functions and relations on T . <p> Axioms for the old sorts are imported, and new ones are added to define new functions and relations on T . For lack of space, we cannot give the full syntax of frameworks here, but it can be found in e.g. <ref> [15] </ref> along with examples of commonly uses frameworks. 3.1 Closed and Open Frameworks We distinguish between closed and open frameworks, depending on the absence or presence of parameters. Whilst a closed framework has one intended (isoinitial) model, an open framework has a class of intended models.
Reference: [16] <author> K.-K. Lau and M. Ornaghi. </author> <title> Towards an object-oriented methodology for deductive synthesis of logic programs. </title> <editor> In M. Proietti, editor, </editor> <booktitle> Proc. </booktitle> <volume> LOPSTR 95, LNCS 1048, </volume> <pages> pages 152169, </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: For lack of space, we will not give full details of the pictorial notation, nor its formal semantics as a refinement of the abstract semantics of the previous section (a preliminary account can be found in <ref> [16] </ref>). 4.1 Closed Frameworks Example 4.1 As a first example, consider the following closed framework: Framework CAR; IMPORT: PERSON ; SORTS: C ar; P erson; FUNCTIONS: d river : ! P erson; RELATIONS: . . . ; AXIOMS: . . .
Reference: [17] <author> K.-K. Lau, C.D.M. Moss and M. Ornaghi. </author> <title> Formal development of correct classes in computational logic. Formal development of correct classes in computational logic. In D.J. Duke and A.S. </title> <editor> Evans, editors, </editor> <booktitle> Proc. BCS-FACS Northern Formal Methods Workshop, Electronic Workshops in Computing Series. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Furthermore, it can be shown that if F is a (possibly infinite) recursively enumerable axiomatisation, then there exists an isoinitial model in which relation symbols are interpreted by decidable relations, and function symbols by total computable functions. In practice, we only ever construct and use such frameworks (see <ref> [15, 17] </ref> for a related discussion). A framework F typically defines a new abstract data type by using pre-defined types. Axioms for the old sorts are imported, and new ones are added to define new functions and relations on T .
Reference: [18] <author> R. Mauth. </author> <title> A better foundation: development frameworks let you build an application with reusable objects. </title> <address> BYTE 21(9):40IS 10-13, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: Most of the existing formal OO Design methods such as Fusion [3, 5] and Syntropy [4] use classes or objects as the basic unit of design. However, it is increasingly recognised that classes are not the best focus for design (see e.g. <ref> [11, 18] </ref>). Typically, the work of creating a design has to be split up between the members of a team; and its artefacts not just the final code, but design documents too have to be stored, moved around, adapted, and hopefully incorporated into more than one end-product.
Reference: [19] <editor> O. Nierstrasz and D. Tsichritzis, editors, </editor> <booktitle> Object-Oriented Software Composition. Prentice-Hall International, </booktitle> <year> 1994. </year>
Reference-contexts: In a sense, the frameworks are the interesting pieces of design, and the objects are just where they are tied together in a particular system. This interesting perspective has been promoted by Helm et al [11], Nierstrasz and Tsichritzis <ref> [19] </ref>, Harrison et al [12], Reenskaug et al [20], and others, and is illustrated in Figure 2.
Reference: [20] <author> T. Reenskaug et al. </author> <title> Working with Objects. </title> <address> Manning/Prentice-Hall, </address> <year> 1995. </year>
Reference-contexts: In a sense, the frameworks are the interesting pieces of design, and the objects are just where they are tied together in a particular system. This interesting perspective has been promoted by Helm et al [11], Nierstrasz and Tsichritzis [19], Harrison et al [12], Reenskaug et al <ref> [20] </ref>, and others, and is illustrated in Figure 2.
Reference: [21] <author> D. Sannella and A. Tarlecki. </author> <title> Essential concepts of algebraic specification and program development. </title> <note> To appear in Formal Aspects of Computer Science. </note>
Reference-contexts: Therefore we have chosen isoinitial theories as frameworks (see [1] for a discussion of isoinitial theories). The syntax we will use for F is similar to that used in algebraic abstract data types (e.g. <ref> [9, 23, 21] </ref>). However, whilst an algebraic abstract data type is an initial model ([10]) of its specification, the intended model of F , i.e. the abstract data type it axiomatises, is an isoinitial model. In general, the existence of an isoinitial model is of course not guaranteed.
Reference: [22] <author> A. Wills. </author> <title> Frameworks. In Sun, Patel, and Sun, </title> <editor> editors, </editor> <booktitle> Proc. Int. Conf. OO Info. Syst. </booktitle> <year> 1996. </year>
Reference-contexts: Finally, we show how they can be represented using a pictorial notation for practical system development. 2. Frameworks in Catalysis In this section, we briefly describe the Catalysis view of frameworks. A more detailed account can be found in <ref> [22] </ref>. The traditional view of an object, as shown in Figure 1, regards an object as a closed entity with one fixed role. visible functions structure internal encapsulated This, however, does not reflect the nature of objects (and classes that describe them) in practical systems.
Reference: [23] <author> M. Wirsing. </author> <title> Algebraic specification. </title> <editor> In J. Van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 675788. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: Therefore we have chosen isoinitial theories as frameworks (see [1] for a discussion of isoinitial theories). The syntax we will use for F is similar to that used in algebraic abstract data types (e.g. <ref> [9, 23, 21] </ref>). However, whilst an algebraic abstract data type is an initial model ([10]) of its specification, the intended model of F , i.e. the abstract data type it axiomatises, is an isoinitial model. In general, the existence of an isoinitial model is of course not guaranteed.
References-found: 23

