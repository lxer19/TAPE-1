URL: ftp://ftp.csd.uu.se/pub/papers/reports/0136.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Phone: Phone: +481818 25 00 Fax: +461851 19 25  
Title: pragmatic approach to compilation of Erlang  
Author: Erik Johansson, Christer Jonsson, Thomas Lindgren Johan Bevemyr, H-akan Millroth 
Address: Box 311, S-751 05 Uppsala, Sweden  
Affiliation: Computing Science Department, Uppsala University  Computer Science Laboratories, Ericsson Telecom AB  
Note: A  
Abstract: UPMAIL Technical Report No. 136 February 7, 1997 (revised July 31, 1997) ISSN 1100-0686 Abstract Erlang is a functional language used in telecommunication products that may contain several hundred thousand lines of source code. In these real-world applications, high runtime performance must be combined with small object-code size and short compilation times. We solve this problem by extending a bytecode implementation of Erlang with a backend compiler that selectively compiles individual functions from their bytecode representation to native code. We discuss how stack-based bytecode is compiled to register code and how the byte-code and native code execution environments are integrated. We compare our compiler to a system that compiles Erlang to machine code via C, and show that our system runs twice as fast, yields smaller object code and requires shorter compilation times.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Armstrong, J.L., Dacker, B.O., Virding, S.R. and Williams, </author> <title> M.C., Implementing a functional language for highly parallel real-time applications, </title> <booktitle> in Proc. </booktitle> <institution> Software Engineering for Telecommunication Switching Systems, </institution> <year> 1992. </year>
Reference-contexts: 2 2 Backend compiler The compilation from bytecode to machine code is done in several stages, which are discussed below. 2.1 Translation The bytecode is translated into intermediate three-address code. 2.1.1 Translating stack code to register code We based our implementation on JAM, an existing bytecode emulator used by Ericsson <ref> [1] </ref>. The emulator instruction set is stack based. Our target architecture is SPARC, a register machine. Thus, it is desirable to use the emulator stack as little as possible when executing machine code. There are several possible solutions to this problem. <p> JAM uses a simple compiler than generate stack bytecodes; a bytecode emulator then executes the programs <ref> [1] </ref>. BEAM [8] is a register machine originally designed to be compiled to C. The current implementation supports a direct threaded emulator (BEAM/T) and compilation via C (BEAM/C). We used BEAM/C for our experiments.
Reference: [2] <author> Armstrong, J.L., Virding, S.R., Wikstrom, C., and Williams, </author> <title> M.C., Concurrent Programming in Erlang. </title> <publisher> Prentice Hall, </publisher> <address> second edition, </address> <year> 1996. </year>
Reference-contexts: The second approach has the opposite trade-offs: fast execution, but huge object codes and long compilation times. We have built a compiler for the functional language Erlang <ref> [2] </ref> that combines these two approaches. Programs are first compiled to a compact byte-code format that can be executed by a simple emulator. Selected functions are then further compiled to machine code that is executed directly. <p> Due to Erlang's code replacement semantics, there is no need to patch code addresses on the stack: old modules are purged explicitly by the programmer <ref> [2, Section 12.3] </ref>. 4 Performance evaluation We have compared our implementation with two Erlang implementations developed at Ericsson Telecom: JAM 4.3.1 and BEAM/C 4.3. JAM uses a simple compiler than generate stack bytecodes; a bytecode emulator then executes the programs [1].
Reference: [3] <author> Briggs, P., Cooper, K.D., and Torczon, L., </author> <title> Improvements to graph coloring register allocation, </title> <journal> ACM transactions on programming languages and systems 16, </journal> <month> 3 (May </month> <year> 1994), </year> <pages> pp. 428-455. </pages>
Reference-contexts: We do not do a state-of-the-art branch instruction scheduling, but only search the basic block preceding the branch for a suitable instruction [9]. 2.4 Register Allocation The registers in our intermediate code must be assigned to machine registers. We use pessimistic graph coloring register allocation <ref> [3, 4, 5] </ref>. Values are rarely spilled to the stack (it never happened in our benchmarks).
Reference: [4] <author> Chaitin, G.J., Auslander, M.A., Chandra, A.K., Cocke, J., Hopkins, M.E., and Markstein, P.W., </author> <title> Register allocation via coloring, </title> <booktitle> Computer Languages 6, </booktitle> <month> (January </month> <year> 1981), </year> <pages> pp. 47-57. </pages>
Reference-contexts: We do not do a state-of-the-art branch instruction scheduling, but only search the basic block preceding the branch for a suitable instruction [9]. 2.4 Register Allocation The registers in our intermediate code must be assigned to machine registers. We use pessimistic graph coloring register allocation <ref> [3, 4, 5] </ref>. Values are rarely spilled to the stack (it never happened in our benchmarks).
Reference: [5] <author> Chaitin, G.J., </author> <title> Register allocation and spilling via graph coloring, </title> <journal> SIG-PLAN Notices 17, </journal> <month> 6 (June </month> <year> 1982), </year> <pages> pp. 98-105. </pages> <booktitle> (Proceeding of the ACM SIGPLAN'82 Symposium on Compiler Construction.) </booktitle>
Reference-contexts: We do not do a state-of-the-art branch instruction scheduling, but only search the basic block preceding the branch for a suitable instruction [9]. 2.4 Register Allocation The registers in our intermediate code must be assigned to machine registers. We use pessimistic graph coloring register allocation <ref> [3, 4, 5] </ref>. Values are rarely spilled to the stack (it never happened in our benchmarks).
Reference: [6] <author> Chambers, C., Ungar, D., </author> <title> Making pure object-oriented languages practical, </title> <booktitle> in OOPSLA'91 Conference Proceedings, </booktitle> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: Other systems, such as SELF <ref> [6, 10] </ref> or some Java implementations, store programs compactly as bytecodes and translate the bytecodes into native code when a procedure is invoked. All code remains in native form once it has been called. This approach is not feasible in embedded systems product development where space is at a premium.
Reference: [7] <author> Ertl, M.A., </author> <title> A New Approach to Forth Native Code Generation, </title> <booktitle> proc. EuroForth '92, </booktitle> <pages> pp. 73-78. 10 </pages>
Reference-contexts: Thus, it is desirable to use the emulator stack as little as possible when executing machine code. There are several possible solutions to this problem. One approach would be to retain the emulator stack and keep the top stack positions in registers. We have chosen another approach. Adapting Ertl's <ref> [7] </ref> work on Forth, we transform all stack references to register references. The translator executes the bytecode symbolically, maintaining a virtual stack as if the code were interpreted. All stack items on this virtual stack are virtual register names.
Reference: [8] <author> Hausman, B., </author> <title> Turbo Erlang: Approaching the Speed of C, </title> <booktitle> Implemen--tations of Logic Programming Systems, </booktitle> <pages> pp. 119-135, </pages> <publisher> Kluwer Academic Publishers, </publisher> <year> 1994. </year>
Reference-contexts: JAM uses a simple compiler than generate stack bytecodes; a bytecode emulator then executes the programs [1]. BEAM <ref> [8] </ref> is a register machine originally designed to be compiled to C. The current implementation supports a direct threaded emulator (BEAM/T) and compilation via C (BEAM/C). We used BEAM/C for our experiments.
Reference: [9] <author> Hennessy, J.L., Patterson, D.A., </author> <title> Computer Architecture, a Quantitative Approach. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1990. </year>
Reference-contexts: There are considerable performance gains to make if these delay slots can be filled with useful instructions. We do not do a state-of-the-art branch instruction scheduling, but only search the basic block preceding the branch for a suitable instruction <ref> [9] </ref>. 2.4 Register Allocation The registers in our intermediate code must be assigned to machine registers. We use pessimistic graph coloring register allocation [3, 4, 5]. Values are rarely spilled to the stack (it never happened in our benchmarks).
Reference: [10] <author> Holzle, U., Ungar, D., </author> <title> A third-generation SELF implementation: reconciling responsiveness with performance. </title> <booktitle> In OOPSLA'94 Conference Proceedings, </booktitle> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: Other systems, such as SELF <ref> [6, 10] </ref> or some Java implementations, store programs compactly as bytecodes and translate the bytecodes into native code when a procedure is invoked. All code remains in native form once it has been called. This approach is not feasible in embedded systems product development where space is at a premium.
Reference: [11] <author> Smith, T.F., and Waterman, </author> <title> M.S., Identification of common molecular subsequences, </title> <journal> Journal of Molecular Biology 147, </journal> <year> 1981, </year> <pages> pp. 195-197. </pages>
Reference-contexts: Each benchmark runs for approximately 1-2 minutes and was run three times to eliminate measurement noise. The benchmarks were: 7 Huffman. A huffman encoder. Compresses and uncompresses a text file of 32 kilobytes. 138 lines. Smith-Waterman. The Smith-Waterman DNA sequence matching algorithm <ref> [11] </ref>. Matches a sequence of length 32 to 600 other sequences of length 32. 68 lines. Barnes-Hut. Simulates gravitational forces between 1000 bodies. 156 lines. Raytracer. A ray tracer. Traces a picture with spheres, planes and texture mapping. Approximately 1000 lines. Decode.

References-found: 11

