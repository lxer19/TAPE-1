URL: http://www.cl.cam.ac.uk/users/drs1004/java.ps
Refering-URL: http://www.cl.cam.ac.uk/users/drs1004/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Proving Java Type Soundness  
Author: Don Syme 
Note: No Institute Given  
Abstract-found: 0
Intro-found: 1
Reference: [CM92] <author> Juanito Camilleri and Tom Melham. </author> <title> Reasoning with inductively defined relations in the HOL theorem prover. </title> <type> Technical Report 265, </type> <institution> University of Cambridge Computer Laboratory, </institution> <address> Cambridge, CB2 3QG, U.K., </address> <month> August </month> <year> 1992. </year>
Reference: [DE97] <author> Sophia Drossopoulou and Susan Eisenbach. </author> <title> Is the Java type system sound? (version 2.01). </title> <type> Technical report, </type> <institution> Imperial College, University of London, </institution> <address> Cambridge, CB2 3QG, U.K., </address> <month> January </month> <year> 1997. </year> <title> This version was distributed on the Internet. Please contact the authors if a copy is required for reference. </title>
Reference-contexts: Most of this chapter should be clear to readers with a basic understanding of operational semantics, formal specification and the results presented in Chapter 3. Our main aim has not been to find errors. However, a significant error in the original formulation adopted by Drossopoulou and Eisenbach <ref> [DE97] </ref> was discovered during our work. We also independently rediscovered a significant error in the Java Language Specification [GJS96]. Both errors are described in Section 6. The first error resulted in an interesting collaboration between the three authors, and led to a deeper understanding of the problems involved. <p> Components of the Semantics and their Relationships Eisenbach in version 2.01 of their paper <ref> [DE97] </ref>. The main differences between our semantics and this version are outlined below. Some of these suggestions have been incorporated into the version presented in Chapter 3. <p> The reader should keep in mind that when this proof was begun, the only guide available was the rough proof outline in <ref> [DE97] </ref>, and this was based on a formulation of the problem that was subsequently found to contain errors.
Reference: [GJS96] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Our main aim has not been to find errors. However, a significant error in the original formulation adopted by Drossopoulou and Eisenbach [DE97] was discovered during our work. We also independently rediscovered a significant error in the Java Language Specification <ref> [GJS96] </ref>. Both errors are described in Section 6. The first error resulted in an interesting collaboration between the three authors, and led to a deeper understanding of the problems involved. <p> To illustrate, one aspect of type soundness is captured in the following statement that is taken directly from the Java Language Specification <ref> [GJS96] </ref>: The type [of a variable or expression] limits the possible values that the variable can hold or the expression can produce at runtime. <p> This process is described in detail in <ref> [GJS96] </ref>. 6 2.5 Runtime typechecking Java performs runtime typechecks at just two places: during array assignment, and when casting reference values. Runtime typechecking is needed for array assignment because of the well-known problem with a co-variant array typing rule. <p> Validity is harder: we have to measure this against the Java language standard <ref> [GJS96] </ref> and our own understanding of the meaning of constructs in the subset. We use two techniques to validate the specification: 1. Type checking of higher order logic; 2. Compiling to ML and running test cases. Here we concentrate on the second. <p> There is no analogue of the class Object for interfaces; that is, while every class is an extension of class Object, there is no single interface of which all interfaces are extensions. <ref> [GJS96] </ref>, pages 87 and 185 The error was detected when trying to prove the existence of compatible methods and fields as we move from a type to a subtype, in particular from the type Object to an interface type. 6.2 Runtime Typechecking, Array Assignments, and Exceptions In Drossopoulou and Eisenbach's original
Reference: [GM93] <author> M.J.C Gordon and T.F Melham. </author> <title> Introduction to HOL: A Theorem Proving Assistant for Higher Order Logic. </title> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference: [Har96] <author> John Harrison. </author> <title> HOL light: A tutorial introduction. </title> <editor> In Mandayam Srivas and Albert Camilleri, editors, </editor> <booktitle> Proceedings of the First International Conference on Formal Methods in Computer-Aided Design (FMCAD'96), volume 1166 of Lecture Notes in Computer Science, </booktitle> <pages> pages 265-269. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference: [Har97] <author> John R. Harrison. </author> <title> Proof Style. </title> <type> Technical Report 410, </type> <institution> University of Cam-bridge Computer Laboratory, </institution> <address> Cambridge, CB2 3QG, U.K., </address> <month> January </month> <year> 1997. </year>
Reference: [Lov68] <author> D. W. Loveland. </author> <title> Mechanical Theorem Proving by Model Elimination. </title> <journal> Journal of the ACM, </journal> <volume> 15 </volume> <pages> 236-251, </pages> <year> 1968. </year>
Reference: [ORR + 96] <author> S. Owre, S. Rajan, J.M. Rushby, N. Shankar, and M.K. Srivas. PVS: </author> <title> Combining specification, proof checking and model checking. </title> <editor> In Rajeev Alur and Thomas A. Henzinger, editors, </editor> <booktitle> Computer-Aided Verification, CAV '96, </booktitle> <volume> volume 1102, </volume> <pages> pages 411-414. </pages> <publisher> Springer-Verlag, </publisher> <month> July/August </month> <year> 1996. </year>
Reference-contexts: The most necessary features are the implementation of decision procedures for ground equational reasoning (as in PVS <ref> [ORR + 96] </ref>) and a small amount of `Computer Aided Proof Writing', as described briefly in [Sym97]. Acknowledgments I would like to thank Sophia Drossopoulou and Sarfraz Khurshid for an excellent day at Imperial spent discussing this work and its possible relevance to their project.
Reference: [Pau90] <author> L. C. Paulson. </author> <title> Isabelle: The next 700 theorem provers. </title> <editor> In P. Odifreddi, editor, </editor> <booktitle> Logic and Computer Science, </booktitle> <pages> pages 361-385. </pages> <publisher> Academic Press, </publisher> <year> 1990. </year>
Reference: [Pau94] <author> Lawrence C. Paulson. </author> <title> A Fixed Point Approach to Implementing (Co)inductive Definitions. </title> <booktitle> 18th International Conference on Automated Deduction, </booktitle> <pages> pages 148-161, </pages> <year> 1994. </year>
Reference: [PB97] <author> Roly Perera and Peter Bertelsen. </author> <title> The Unofficial Java Bug Report, </title> <month> June </month> <year> 1997. </year> <note> Published on the WWW at http://www2.vo.lu/homepages/gmid/java.htm. </note>
Reference-contexts: presentation of the type soundness proof. 6.1 An Error in the Java Language Specification In the process of finishing the proofs of the lemmas described in Section 3.2 we independently rediscovered a significant flaw in the Java language specification that had recently been found by developers of a Java implementation <ref> [PB97] </ref>. In theory the flaw does not break type soundness, but the authors of the language specification have confirmed that the specification needs alteration.
Reference: [Plo91] <author> Gordon D. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical report, </type> <institution> Computer Science Department, Aarhus University, </institution> <address> DK-8000 Aarhus C. Denmark, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: We now move onto the runtime model of execution. 2.3 The Runtime Semantics: Configurations, Runtime Terms and State Chapter 3 models execution by a transition semantics, i.e. a `small step' rewrite system <ref> [Plo91] </ref>. A configuration (s; t) of the runtime system has a state s and a runtime term (rterm) t. The rterm represents expressions yet to be evaluated and the partial results of terms evaluated so far. The configuration is progressively modified by making reductions.
Reference: [Qia97] <author> Zhenyu Qian. </author> <title> A Formal Specification of Java Virtual Machine Instructions. </title> <type> Technical report, </type> <institution> Universitat Bremen, FB3 Informatik, D-28334 Bremen, Germany, </institution> <month> November </month> <year> 1997. </year>
Reference-contexts: However, unlike many high-level/low-level language combinations (e.g. C++/assembler) the type systems of Java and the JVM are closely related, and a comprehensive study of the former is a useful precursor to the study of the latter (see also <ref> [Qia97] </ref>). Of course, even if an abstract model of Java and/or the JVM is verified, this does not guarantee the soundness of a particular implementation.
Reference: [Rud92] <author> P. Rudnicki. </author> <title> An Overview of the MIZAR Project, </title> <note> 1992. Unpublished; available by anonymous FTP from menaik.cs.ualberta.ca as pub/Mizar/Mizar Over.tar.Z. </note>
Reference: [Sym97] <author> Don Syme. DECLARE: </author> <title> A prototype declarative proof system for higher order logic. </title> <type> Technical Report 416, </type> <institution> University of Cambridge Computer Laboratory, </institution> <address> Cambridge, CB2 3QG, U.K., </address> <month> March </month> <year> 1997. </year>
Reference-contexts: Tools for Formal Methods: This work is a major case study in so-called `declarative' proof techniques. The tool we use, called DECLARE <ref> [Sym97] </ref>, has been developed by the author to demonstrate the utility of these tech niques. Formally Checked Properties of Languages: This work contributes a tool and a methodology for the general task of machine checking properties of languages. <p> The steps of the methodology are as follows: 1. Understand the Problem This first step is so obvious it should hardly need stating: we must develop a strong understanding of the problem before we proceed. Like all theorem provers, the tool we use, called DECLARE <ref> [Sym97] </ref>, should only be used when this has been achieved. 3 2. Develop a Machine Acceptable Model This involves developing a machine acceptable model of the system, in our case as a DECLARE specification. <p> The most necessary features are the implementation of decision procedures for ground equational reasoning (as in PVS [ORR + 96]) and a small amount of `Computer Aided Proof Writing', as described briefly in <ref> [Sym97] </ref>. Acknowledgments I would like to thank Sophia Drossopoulou and Sarfraz Khurshid for an excellent day at Imperial spent discussing this work and its possible relevance to their project.
References-found: 15

