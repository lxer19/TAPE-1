URL: ftp://ftp.cs.columbia.edu/reports/reports-1992/cucs-010-92.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1992.html
Root-URL: http://www.cs.columbia.edu
Email: hseush@cs.columbia.edu  
Phone: (212) 854-8123  
Title: MeldC Threads: Supporting Large-Scale Dynamic Parallelism  
Author: Wenwey Hseush James C. Lee Gail E. Kaiser Wenwey Hseush, James C. Lee and Gail E. Kaiser 
Date: March 1992  
Note: 24  Copyright 1992  
Address: 500 W. 120th Street New York, NY 10027  
Affiliation: Columbia University Department of Computer Science  
Abstract: Technical Report CUCS-010-92 Abstract We present a new thread model that supports large-scale dynamic parallelism, i.e., the number of coexisting threads is large and the life-time for each thread is short. We introduce the interleaving stack (IS), which melds the frames of multiple threads into one shared stack. The pure interleaving stack is not scalable due to severe internal fragmentation. We propose and evaluate an improvement, circular interleaving stack (CIS). Our simulation shows that in the domains of large-scale dynamic parallelism, CIS performs better than the traditional one-stack-per-thread (1SPT) mechanism with respect to memory utilization. The 1SPT mechanism gains better memory utilization as thread life-time increases. CIS and 1SPT show similar CPU utilization. Hseush is supported in part by the Center for Telecommunications Research. Lee is supported in part by the Center for Advanced Technology. Kaiser is supported by National Science Foundation grants CCR-9106368, CCR-9000930 and CCR-8858029, by grants from AT&T, BNR, DEC, IBM and SRA, by the New York State Center for Advanced Technology in Computers and Information Systems and by the NSF Engineering Research Center for Telecommunications Research. keywords: light-weight processes, object-oriented language, concurrency.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Gul Agha, Carl Hewitt, Peter Wegner and Akinori [2] Thomas E. Anderson, Edward D. Lazowska, and Yonezawa (editors). Henry M. Levy. </author> <title> ECOOP-OOPSLA Workshop on Object-Based The Performance Implications of Thread Concurrent Programming. Management Alternatives for Shared-Memory ACM Press, 1990. Multiprocessors. </title> <journal> Special issue of OOPS Messenger, 2(2), April IEEE Transactions on Computers 1991. </journal> <volume> 38(12) </volume> <pages> 1631-1643, </pages> <month> December, </month> <year> 1989. </year> <title> 9 Copyright (c) Free Software Foundation, </title> <publisher> Inc. </publisher> <pages> 18 </pages>
Reference-contexts: 1. Introduction Concurrent object-oriented programming models <ref> [1] </ref> promise the potential of expressing large-scale parallelism. In these models, each object is considered active and possesses its own thread (s) of control. Objects interact only by message passing.
Reference: [3] <author> Thomas E. Anderson, Brian N. Bershad, Edward [12] Daniel G. Bobrow and Ben Wegbreit. D. Lazowska, and Henry M. Levy. </author> <title> A Model and Stack Implementation of Multiple Scheduler Activations: Effective Kernel Support Environments. </title> <booktitle> for the User-Level Management of Communications of the ACM 16(10) </booktitle> <pages> 591-603, Parallelism. </pages> <year> 1973. </year> <journal> ACM Transactions on Computer Systems </journal>
Reference-contexts: A mechanism that interoperates both CIS and 1SPT is desirable. We are currently investigating this problem, but this is outside the scope of this paper. We also do not address issues concerning multiprocessors, which have been discussed in <ref> [2, 21, 14, 3, 8, 7] </ref>, and also limit our discussion to language-level light-weight processes [16, 4, 7, 13, 11, 9], which do not require support from the operating system (e.g., [8, 18, 19, 5, 21, 17, 10, 20]). 3 A full version of this paper, addressing survivability and garbage collection,
Reference: [13] <editor> Thomas W. Doeppner, Jr. </editor> <volume> 10(1) </volume> <pages> 53-79, </pages> <month> February, </month> <year> 1992. </year>
Reference-contexts: High survivability can be achieved by either avoiding stack overflow or recovering from a stack fault when it occurs. Without assuming any semantic information about the applications, it is almost impossible to recover from a stack overflow. This is the reason that most thread packages <ref> [13, 6, 16, 11, 9, 10] </ref> ``handle'' stack overflow by aborting computation partially or entirely. We have attacked this problem by studying the concept of thread mobility, which characterizes the capability of relocating frames. <p> We are currently investigating this problem, but this is outside the scope of this paper. We also do not address issues concerning multiprocessors, which have been discussed in [2, 21, 14, 3, 8, 7], and also limit our discussion to language-level light-weight processes <ref> [16, 4, 7, 13, 11, 9] </ref>, which do not require support from the operating system (e.g., [8, 18, 19, 5, 21, 17, 10, 20]). 3 A full version of this paper, addressing survivability and garbage collection, and also a range of scheduling policies for threads, is available from the authors. 3 <p> A new thread allocates its first frame on top of the shared stack. 6 4. Interleaving Stack We have investigated five resource models, 1SPT, IS, CIS, k-IS and the heap-based (HB) approach. Almost every thread package <ref> [13, 6, 16, 11, 9, 10] </ref> uses the 1STP approach except the SHARED tasks in the C++ task library [4], where tasks share a single stack (of some fixed size) and context-switching is done by copying the entire stack of the running task out to a save area and copying the
References-found: 3

