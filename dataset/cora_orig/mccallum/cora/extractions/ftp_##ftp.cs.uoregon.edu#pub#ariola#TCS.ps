URL: ftp://ftp.cs.uoregon.edu/pub/ariola/TCS.ps
Refering-URL: http://www.cs.uoregon.edu/~ariola/publications.html
Root-URL: http://www.cs.uoregon.edu
Title: Properties of a First-order Functional Language with Sharing  
Author: Zena M. Ariola Arvind 
Affiliation: Computer Information Science Department University of Oregon  Laboratory for Computer Science Massachusetts Institute of Technology  
Abstract: A calculus and a model for a first-order functional language with sharing is presented. In most implementations of functional languages, argument subexpressions in a function application are shared to avoid their repeated evaluation. Recursive functions are typically implemented using graphs with cycles. Compilers for these languages sometimes employ non-left-linear and left-cyclic rules for optimizations. A Graph Rewriting System (GRS) to address these concerns is developed. It is shown that a GRS without interfering rules is confluent. Along the lines of Levy's term model for the -calculus, a semantics of such a GRS is also presented. An application of the term model to compiler optimizations is discussed. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Z. Ariola. </author> <title> Relating Graph and Term Rewriting via Bohm Models. </title> <booktitle> In Proc. </booktitle> <address> RTA '93, Montreal, Canada, </address> <month> June, </month> <year> 1993. </year>
Reference-contexts: In particular, non-left-linear rules (which include left-cyclic rules) will have to be disallowed. Furthermore, sharing will have to be ignored from the observations as well. The reader may refer to <ref> [1] </ref>, where such a term model based on Bohm trees is presented. Surprisingly, the following algebraic rules: fl (x; 0) ! 0 are not partially correct according to our model.
Reference: 2. <author> Z. Ariola and Arvind. P-TAC: </author> <title> A Parallel Intermediate Language. </title> <booktitle> In Proc. ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> London, UK, </address> <month> September </month> <year> 1989. </year>
Reference-contexts: Definition 5.1. (Context) Let the definition of a GRS term (Definition 3.1) be extended to include a special symbol 2. A context is then a GRS term containing 2. Notation: We write C <ref> [2] </ref> for an arbitrary context, such as fx 1 = e 1 ; x n = e n ; z = 2; In xg, and C [M ] for the term fx 1 = e 1 ; x n = e n ; z = 2; In xg [z M ] <p> As in any replacement operation BV (M ) " BV (C <ref> [2] </ref>) = ;, for C [M ] to be a legal term. Observe that the free variables of a term M can get bound in C [M ]. For a compiler a useful equality must have the property M = N =) 8C [2]; C [M ] = C [N ]. <p> operation BV (M ) " BV (C <ref> [2] </ref>) = ;, for C [M ] to be a legal term. Observe that the free variables of a term M can get bound in C [M ]. For a compiler a useful equality must have the property M = N =) 8C [2]; C [M ] = C [N ]. This means that the equality has to be a congruence with respect to the formation rules of terms. An optimization will be considered correct if it preserves equality. An example of an equivalence relation is convertibility. <p> It is also interesting to analyze if M "less defined" then N implies that for all context C <ref> [2] </ref>, C [M ] is "less defined" than C [N ]? That is, is the equality induced by W fl a congruence? Later we will see that, in the Properties of a First-order Functional Language with Sharing 21 absence of interfering rules, the equality introduced by information content is also a <p> Suppose we compute the stable information of term M by applying the (incorrect) rule: x = F (y 1 ; y 2 ) ! x = . Then both !(M ) and !(N ) will be and as such they will be equated. Now consider the context C <ref> [2] </ref> ft 1 = G (t 2 ); t 2 = 2; In t 1 g. C [M ] produces 3 as a possible observation, while C [N ] does not. Thus, we erroneously equate terms which are not "extensionally equal". <p> It seems that we cannot discard any information that can be used to build terms. By treating !(M ) as we discard too much information as can be seen by the fact that by plugging the observations of M in C <ref> [2] </ref> we will not be able to observe 3. 5.2. !-reductions and its properties Definition 5.4. (!-redex) A !-redex in a GRS term M in canonical form is a pair (t; z) such that (i) t is a rule; (ii) z 2 BV (M ) and z is not bound to <p> The result then follows by induction. 2 This theorem leads to a simple but powerful result regarding the behavior of terms obtained by plugging terms related by sharing into any context. Corollary 5.28. Given GRS NI terms M and N , if M ! N then 8C <ref> [2] </ref>, C [M ] v g C [N ]: Proof. <p> i = Cons (1; t i1 ); In t i g, we have that !(N ) ! !(N 1 ) ! ! !(N i ) ! ! M: In fact, using induction on i we can show that N v g M , and one would correctly guess that 8C <ref> [2] </ref>; C [N ] v g C [M ]. However, this does not follow from Corollary 5.28. We need to show that v g is a congruence relation. Note that terms like M and N arise in the cyclic implementation of recursive rules, such as the Y-rule. <p> Note that terms like M and N arise in the cyclic implementation of recursive rules, such as the Y-rule. A way of assuring that v g is a congruence is to show that the behavior of C [M ], for any context C <ref> [2] </ref>, can be inferred from the observations about M , that is, 8C [2]; C [M ] g fC [P ] j P 2 W fl (M )g: In other words, the context should be a continuous operation with respect to our observations. (Notice that W fl ( fC [P ] <p> A way of assuring that v g is a congruence is to show that the behavior of C [M ], for any context C <ref> [2] </ref>, can be inferred from the observations about M , that is, 8C [2]; C [M ] g fC [P ] j P 2 W fl (M )g: In other words, the context should be a continuous operation with respect to our observations. (Notice that W fl ( fC [P ] j P 2 W fl (M )g) = fW fl (C [P ]) <p> (M )g: In other words, the context should be a continuous operation with respect to our observations. (Notice that W fl ( fC [P ] j P 2 W fl (M )g) = fW fl (C [P ]) j P 2 W fl (M )g.) We will first prove 8C <ref> [2] </ref>; fC [P ] j P 2 W fl (M )g v g C [M ] that is, by plugging the observations of M in the context we do not produce more information than the one contained in C [M ]. Lemma 5.29. <p> Lemma 5.29. Given a GRS NI term M and context C <ref> [2] </ref>, F Proof. <p> then 8P , P ! !(M 0 ) we have P ! M 0 C [P ] v g C [M 0 ] (by monotonicity of v g with respect to ! (Corollary 5.28)) g C [M ] (by soundness of g (Proposition 5.26)) : 2 The other direction 8C <ref> [2] </ref>; C [M ] v g fC [P ] j P 2 W fl (M )g Properties of a First-order Functional Language with Sharing 32 requires some more machinery. <p> From Proposition 5.15, !-reductions do not destroy redexes, therefore, 9N 1 ; N !! N 1 by reducing the descendants of redexes in Z. The result then follows from Proposition 5.18. 2 Lemma 5.33. Given GRS NI terms M and N , and context C <ref> [2] </ref>, if C [M ] %! &lt;(M) N then !(N ) v g C [!(M )]. Proof. <p> Pictorially we have C [M ] &lt;(M) N ? _ ? &gt; !(N ) ! Lemma 5.34. Given a GRS NI term M and context C <ref> [2] </ref>, C [M ] v g F Proof. <p> Given a GRS NI term M and context C <ref> [2] </ref>, C [M ] g F Proof. Follows from Lemma 5.29 and Lemma 5.34. 2 Theorem 5.36. (Congruence of g with respect to the context operation) Given GRS NI terms M and N , and context C [2], if M g N then C [M ] g C [N ]: Proof. <p> Given a GRS NI term M and context C <ref> [2] </ref>, C [M ] g F Proof. Follows from Lemma 5.29 and Lemma 5.34. 2 Theorem 5.36. (Congruence of g with respect to the context operation) Given GRS NI terms M and N , and context C [2], if M g N then C [M ] g C [N ]: Proof. <p> The compiler of Id is expressed as a series of translations into simpler and simpler languages. In our prior work we have introduced the Kid (Kernel id) language [3] and the P-TAC (Parallel Three Address Code) language <ref> [2] </ref>, and provided the translation of Id into Kid and of Kid into P-TAC [4]. We have formalized many optimizations in the Id compiler in terms of source-to-source transformations on these intermediate languages. Functional subset of P-TAC can be seen as an example of the GRS presented in this paper. <p> This will allow one to prove the correctness of compiler optimizations, such as the algebraic rules. Yet another direction would be to incorporate I-structures and M-structures in our GRS. Elsewhere, we have shown the confluence of a GRS with I-structures <ref> [2] </ref>. I-structures operations can be expressed using "multi-rooted rules". However, a term model for a GRS with I-structures would require a very different treatment of unconnected subterms and garbage collection. Acknowledgements This work was done at the Laboratory for Computer Science at MIT, and at the University of Oregon.
Reference: 3. <author> Z. Ariola and Arvind. </author> <title> A Syntactic Approach to Program Transformations. </title> <booktitle> In Proc. ACM SIGPLAN Symposium on Partial Evaluation and Semantics Based Program Manipulation, </booktitle> <address> New Haven, CT, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: In addition Id also contains logical variables in the form of I-structures and mutable variables in the form of M-structures. The compiler of Id is expressed as a series of translations into simpler and simpler languages. In our prior work we have introduced the Kid (Kernel id) language <ref> [3] </ref> and the P-TAC (Parallel Three Address Code) language [2], and provided the translation of Id into Kid and of Kid into P-TAC [4]. We have formalized many optimizations in the Id compiler in terms of source-to-source transformations on these intermediate languages.
Reference: 4. <author> Z. Ariola and Arvind. </author> <title> Compilation of Id. </title> <booktitle> In Proc. of the Fourth Workshop on Languages and Compilers for Parallel Computing, </booktitle> <address> Santa Clara, CA, </address> <publisher> Springer-Verlag LNCS 589, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: In our prior work we have introduced the Kid (Kernel id) language [3] and the P-TAC (Parallel Three Address Code) language [2], and provided the translation of Id into Kid and of Kid into P-TAC <ref> [4] </ref>. We have formalized many optimizations in the Id compiler in terms of source-to-source transformations on these intermediate languages. Functional subset of P-TAC can be seen as an example of the GRS presented in this paper.
Reference: 5. <author> Z. Ariola and J. W. Klop. </author> <title> Equational Term Graph Rewriting. </title> <type> Technical Report Draft, </type> <year> 1993. </year>
Reference-contexts: This is a generalization of the ordering on TRS terms introduced by Huet and Levy [11]. Proposition 3.16. The !-ordering is a partial order with as the least element. Proof. See <ref> [5] </ref>. 2 The following examples may enhance the reader's intuition about !-ordering.
Reference: 6. <author> H. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: However, by plugging both of them in the context fx = K; z = 2; In zg we can derive K = S. As shown in <ref> [6] </ref>, this will immediately lead to an inconsistent theory, and will cause all terms to be equated. The notion of head normal form (hnf) was introduced by Wadsworth to syntactically characterize the class of terms that cannot be equated.
Reference: 7. <author> H. Barendregt, T. Brus, M. van Eekelen, J. Glauert, J. Kennaway, M. van Leer, M. Plasmeijer, and M. R. Sleep. </author> <title> Towards an Intermediate Language based on Graph Rewriting. </title> <booktitle> In Proceedings of the PARLE Conference, </booktitle> <address> Eindhoven, The Netherlands, </address> <publisher> Springer-Verlag LNCS 259, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: Much of the past work on graph rewriting has been to prove its correctness with respect to either the -calculus [20] or Term Rewriting Systems <ref> [7, 8, 9, 16] </ref>. In contrast, this paper explores graph rewriting as a system in its own right, and makes no attempt to prove the correctness of a graph implementation with respect to a "tree (or unshared) view" of the computation.
Reference: 8. <author> H. Barendregt, M. van Eekelen, J. Glauert, J. Kennaway, M. Plasmeijer, and M. Sleep. </author> <title> Term Graph Rewriting. </title> <booktitle> In Proceedings of the PARLE Conference, </booktitle> <address> Eindhoven, The Netherlands, </address> <publisher> Springer-Verlag LNCS 259, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: Much of the past work on graph rewriting has been to prove its correctness with respect to either the -calculus [20] or Term Rewriting Systems <ref> [7, 8, 9, 16] </ref>. In contrast, this paper explores graph rewriting as a system in its own right, and makes no attempt to prove the correctness of a graph implementation with respect to a "tree (or unshared) view" of the computation. <p> Motivated by what we have observed in real implementations of functional languages, we explore syntactic and semantic properties of graphs with cycles, and rewriting rules that recognize or create cycles. In this respect our calculus goes farther than either [20] or <ref> [8] </ref> where only acyclic graphs are considered. Without cyclic graphs some important implementation ideas are ruled out. More recently, Klop et al. [15] have extended the Barendregt's graph rewriting system to deal with cycles. <p> Moreover, the result implies the partial correctness of the cyclic implementation of the Y-rule. The paper is organized as follows: In Section 2, we introduce graph rewriting taking combinatory logic as an example, and compare our notation with that of Barendregt's <ref> [8] </ref>. We formally describe GRSs, in Section 3. We introduce an ordering on terms based on sharing of subterms, and formulate the notion of a redex using this ordering. In Section 4, we introduce GRSs without interfering rules and prove their confluence. <p> Next we informally present the GRS for combinatory logic, and relate our GRS notation to Barendregt's <ref> [8] </ref>. Consider the S rule: Ap (Ap (Ap (S; x); y); z) ! Ap (Ap (x; z); Ap (y; z)) which is shown in Barendregt et al. graph notation in Figure 2.
Reference: 9. <author> T. Brus, M. van Eekelen, M. vam Leer, and M. Plasmeijer. </author> <title> Clean A language for Functional Graph Rewriting. </title> <booktitle> In Proc. ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Portland, OR, </address> <publisher> Springer-Verlag LNCS 274, </publisher> <year> 1987. </year>
Reference-contexts: Much of the past work on graph rewriting has been to prove its correctness with respect to either the -calculus [20] or Term Rewriting Systems <ref> [7, 8, 9, 16] </ref>. In contrast, this paper explores graph rewriting as a system in its own right, and makes no attempt to prove the correctness of a graph implementation with respect to a "tree (or unshared) view" of the computation.
Reference: 10. <author> M. Hennessy. </author> <title> Algebraic Theory of Processes. </title> <publisher> MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: However, !-graphs does not guarantee the existence of such a limit. Therefore, we apply the ideal completion method to turn !-graphs into a complete partial order <ref> [10] </ref>. Given a partial order (A; ), a subset D of A is an ideal iff (i) D is non-empty. (ii) 8a; b 2 D; 9c 2 D; a c and b c, (iii) 8c 2 D; if 9d 2 A; d c then d 2 D.
Reference: 11. <author> G. Huet and J.-J. Levy. </author> <title> Computations in orthogonal rewriting systems 1 and 2. </title> <booktitle> In Computational logic. Essays in Honor of Alan Robinson. </booktitle> <editor> Ed. J.-L. Lassez & G.D. Plotkin, </editor> <year> 1991. </year>
Reference-contexts: Intuitively, M ! N if N can be obtained from M by replacing with any other term or by increasing the sharing in M . This is a generalization of the ordering on TRS terms introduced by Huet and Levy <ref> [11] </ref>. Proposition 3.16. The !-ordering is a partial order with as the least element. Proof. See [5]. 2 The following examples may enhance the reader's intuition about !-ordering. <p> Confluence of a GRS without interfering rules Not all GRSs are confluent, however, we can show that for a restricted class, namely GRSs without interfering rules, confluence is guaranteed. We introduce the notion of compatible terms <ref> [11] </ref> which will be used, among other things, to define the notion of interference among rules. The idea is that terms which are not ordered, may still have a common upper bound. As we shall see later, such terms potentially interfere with each other. <p> Properties of a First-order Functional Language with Sharing 23 5.1.2. !-redex Non-left-linear rules constitute a problem for a GRS also. Since we want to include them in our analysis, we abandon the idea of generating !-rules, and instead introduce a new notion of redex, called !-redex <ref> [11] </ref>. A !-redex captures our intuition about why a term should be rewritten to . It consists of analyzing a term to see if it can become a redex by either replacing with some other term or by increasing the sharing in the term.
Reference: 12. <author> R. J. M. Hughes. Super-combinators. </author> <booktitle> In Proceedings of Lisp and Functional Programming, </booktitle> <address> Pittsburg, PA, </address> <year> 1982. </year>
Reference-contexts: The results of this paper are also relevant to compiling higher-order functional languages, because compilers of such languages often employ a technique known as "lambda-lifting" [13]. The program that results after lambda-lifting is in a "supercombinatory" form, and is treated as a first-order program <ref> [12] </ref>. A way to capture sharing is to represent the expression as a graph instead of a linear text string or tree. This allows sharing of identical terms through pointers, and avoids repeated evaluation of identical terms as it is commonly done in normal-order reduction.
Reference: 13. <author> T. Johnsson. </author> <title> Lambda Lifting: Transforming Programs to Recursive Equations. </title> <booktitle> In Proceedings of Functional Programming Languages and Computer Architecture, </booktitle> <address> Nancy, France, </address> <publisher> Springer-Verlag LNCS 201, </publisher> <month> September </month> <year> 1985. </year>
Reference-contexts: The results of this paper are also relevant to compiling higher-order functional languages, because compilers of such languages often employ a technique known as "lambda-lifting" <ref> [13] </ref>. The program that results after lambda-lifting is in a "supercombinatory" form, and is treated as a first-order program [12]. A way to capture sharing is to represent the expression as a graph instead of a linear text string or tree.
Reference: 14. <author> V. Kathail. </author> <title> Optimal Interpreters for Lambda-calculus Based Funtional Languages. </title> <type> PhD thesis, </type> <institution> Dept. of Electrical Engineering and Computer Science, MIT, </institution> <address> Cambridge, MA, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: As an aside, Wadsworth also showed that his graph reduction did not capture enough sharing to lead to an optimal interpreter. More Properties of a First-order Functional Language with Sharing 2 recently a new graph structure, which allows sharing of "contexts", has been proposed in <ref> [14, 17] </ref>. This latter technique leads to provably optimal interpreters for the -calculus [18]. In this paper, however, we are not concerned with optimality questions, and we restrict our attention to "argument sharing" in a language which is simpler than the -calculus.
Reference: 15. <author> J. Kennaway, J. Klop, M. Sleep, and F. de Vries. </author> <title> Transfinite Reductions in Orthogonal Term Rewriting Systems. </title> <booktitle> In Proc. RTA '91, </booktitle> <publisher> Springer-Verlag LNCS, </publisher> <year> 1991. </year>
Reference-contexts: In this respect our calculus goes farther than either [20] or [8] where only acyclic graphs are considered. Without cyclic graphs some important implementation ideas are ruled out. More recently, Klop et al. <ref> [15] </ref> have extended the Barendregt's graph rewriting system to deal with cycles. However, their approach is significantly different from ours in that they model cyclic graph rewriting as "transfinite reduction" of infinitary graph terms. In the following, we formally introduce a Graph Rewriting System (GRS). <p> Our GRS includes cyclic terms and permits both non-left-linear rules and left-cyclic rules. We prove that in the absence of interfering rules a GRS is confluent. This is a more general result than the confluence theorem in <ref> [15] </ref>. We think that our approach also leads to a simpler proof of confluence than in [15]. We also develop a term model for a GRS without interfering rules along the lines of Levy's term model for the -calculus. <p> We prove that in the absence of interfering rules a GRS is confluent. This is a more general result than the confluence theorem in <ref> [15] </ref>. We think that our approach also leads to a simpler proof of confluence than in [15]. We also develop a term model for a GRS without interfering rules along the lines of Levy's term model for the -calculus. We introduce the notion of "information content" associated to a term, and show that the information content defines a congruence on the set of terms. <p> M will have the following reduction: M @ M 1 fx = I (x); In xg M 2 fx = J (x); In xg @ fi Notice that if both M 1 and M 2 are not reduced to fi, the confluence property will be lost, as was observed in <ref> [15] </ref>. Barendregt's graph reduction system is not confluent precisely because of the absence of such a reduction. Hereafter, we will use the notation GRS C to denote a confluent GRS. Properties of a First-order Functional Language with Sharing 18 5.
Reference: 16. <author> R. Kennaway. </author> <title> Implementing Term Rewrite Languages in Dactl. </title> <journal> Theoretical Computer Science, </journal> <volume> Vol. 1, </volume> <year> 1990. </year>
Reference-contexts: Much of the past work on graph rewriting has been to prove its correctness with respect to either the -calculus [20] or Term Rewriting Systems <ref> [7, 8, 9, 16] </ref>. In contrast, this paper explores graph rewriting as a system in its own right, and makes no attempt to prove the correctness of a graph implementation with respect to a "tree (or unshared) view" of the computation.
Reference: 17. <author> J. Lamping. </author> <title> An algorithm for optimal lambda calculus reduction. </title> <booktitle> In Proc. ACM Conference on Principles of Programming Languages, </booktitle> <address> San Francisco, CA, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: As an aside, Wadsworth also showed that his graph reduction did not capture enough sharing to lead to an optimal interpreter. More Properties of a First-order Functional Language with Sharing 2 recently a new graph structure, which allows sharing of "contexts", has been proposed in <ref> [14, 17] </ref>. This latter technique leads to provably optimal interpreters for the -calculus [18]. In this paper, however, we are not concerned with optimality questions, and we restrict our attention to "argument sharing" in a language which is simpler than the -calculus.
Reference: 18. <author> J.-J. Levy. </author> <title> Reductions Correctes et Optimales dans le Lambda-Calcul. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, Paris, France, </institution> <month> October </month> <year> 1978. </year>
Reference-contexts: More Properties of a First-order Functional Language with Sharing 2 recently a new graph structure, which allows sharing of "contexts", has been proposed in [14, 17]. This latter technique leads to provably optimal interpreters for the -calculus <ref> [18] </ref>. In this paper, however, we are not concerned with optimality questions, and we restrict our attention to "argument sharing" in a language which is simpler than the -calculus. <p> The ! function captures what Levy has called the direct approximation of a -calculus term <ref> [18] </ref>, and Welch has called the instantaneous semantics of a term [21]. <p> This phenomena is called the upward creation of redexes. Reduction of a term in the -calculus can also result in the upward creation of redexes. To cope with this problem in the -calculus, Wadsworth [20] and Levy <ref> [18] </ref> had introduced the notion of an !-rule, which reduces any term that can become a redex (by upward creation) to . The !-rule for the -calculus is M ! : The !-rule associated to t 1 and t 2 will be F () ! .
Reference: 19. <author> R. S. Nikhil. </author> <title> Id (Version 90.0) Reference Manual. </title> <type> Technical Report CSG Memo 284-a, </type> <institution> Laboratory for Computer Science, MIT, </institution> <address> Cambridge, MA, USA, </address> <month> July </month> <year> 1990. </year>
Reference-contexts: The main advantage of our approach is its simplicity because it avoids infinitary terms and associated transfinite reduction. The motivation for this work came from a desire to formalize the compilation process of Id, an implicitly parallel language <ref> [19] </ref>. Id has a purely functional, higher-order, non-strict core. In addition Id also contains logical variables in the form of I-structures and mutable variables in the form of M-structures. The compiler of Id is expressed as a series of translations into simpler and simpler languages.
Reference: 20. <author> C. Wadsworth. </author> <title> Semantics And Pragmatics Of The Lambda-Calculus. </title> <type> PhD thesis, </type> <institution> University of Oxford, Oxford, UK, </institution> <month> September </month> <year> 1971. </year>
Reference-contexts: This allows sharing of identical terms through pointers, and avoids repeated evaluation of identical terms as it is commonly done in normal-order reduction. Graph reduction for the -calculus was proposed by Wadsworth in order to bring together the advantages of both the applicative and the normal order evaluation <ref> [20] </ref>. Wadsworth also formally proved the correctness of his graph reduction technique. As an aside, Wadsworth also showed that his graph reduction did not capture enough sharing to lead to an optimal interpreter. <p> In this paper, however, we are not concerned with optimality questions, and we restrict our attention to "argument sharing" in a language which is simpler than the -calculus. Much of the past work on graph rewriting has been to prove its correctness with respect to either the -calculus <ref> [20] </ref> or Term Rewriting Systems [7, 8, 9, 16]. In contrast, this paper explores graph rewriting as a system in its own right, and makes no attempt to prove the correctness of a graph implementation with respect to a "tree (or unshared) view" of the computation. <p> Motivated by what we have observed in real implementations of functional languages, we explore syntactic and semantic properties of graphs with cycles, and rewriting rules that recognize or create cycles. In this respect our calculus goes farther than either <ref> [20] </ref> or [8] where only acyclic graphs are considered. Without cyclic graphs some important implementation ideas are ruled out. More recently, Klop et al. [15] have extended the Barendregt's graph rewriting system to deal with cycles. <p> It follows that all optimization rules drawn from the set of rewriting rules will be automatically meaning preserving. However, as pointed out in <ref> [20] </ref>, convertibility makes too fine a distinction to be interesting; it does not capture the computational behavior of a term. <p> Yet from a computational point of view, we would like to consider them as producing no information. We may be tempted to extend convertibility by equating all terms without normal form. However, it has been shown by Wadsworth in <ref> [20] </ref> that this will lead to an inconsistent theory. <p> This phenomena is called the upward creation of redexes. Reduction of a term in the -calculus can also result in the upward creation of redexes. To cope with this problem in the -calculus, Wadsworth <ref> [20] </ref> and Levy [18] had introduced the notion of an !-rule, which reduces any term that can become a redex (by upward creation) to . The !-rule for the -calculus is M ! : The !-rule associated to t 1 and t 2 will be F () ! .

References-found: 20

