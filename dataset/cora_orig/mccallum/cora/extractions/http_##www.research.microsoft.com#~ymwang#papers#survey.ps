URL: http://www.research.microsoft.com/~ymwang/papers/survey.ps
Refering-URL: http://www.research.microsoft.com/~ymwang/papers/surveyCR.htm
Root-URL: http://www.research.microsoft.com
Title: A Survey of Rollback-Recovery Protocols in Message-Passing Systems  
Author: E.N. Elnozahy D.B. Johnson Y.M. Wang 
Keyword: Key words: distributed systems, fault tolerance, high availability, checkpointing, message logging, rollback, recovery  
Address: 600-700 Mountain Avenue Pittsburgh, PA 15213-3891 Pittsburgh, PA 15213-3891 Murray Hill, NJ 07974  
Affiliation: Dept. of Computer Science Dept. of Computer Science AT&T Laboratories-Research Carnegie Mellon University Carnegie Mellon University  
Abstract: The problem of rollback-recovery in message-passing systems has undergone extensive study. In this survey, we review rollback-recovery techniques that do not require special language constructs, and classify them into two primary categories. Checkpoint-based rollback-recovery relies solely on checkpointed states for system state restoration. Depending on when checkpoints are taken, existing approaches can be divided into uncoordinated checkpointing, coordinated checkpointing and communication-induced checkpointing. Log-based rollback-recovery uses checkpointing and message logging. The logs enable the recovery protocol to reconstruct the states that are not checkpointed. There are three different log-based approaches, namely, pessimistic logging, optimistic logging and causal logging. We identify a set of desirable properties of rollback-recovery protocols, and compare different approaches with respect to these properties. Log-based rollback-recovery protocols generally rely on the assumption of piecewise determinism and pay additional overhead to allow faster output commits and more localized recovery. We present research issues under each approach, and review existing solutions to address them. We also present implementation issues of checkpointing and message logging. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Acharya and B. R. Badrinath. </author> <title> Recording distributed snapshots based on causal order of message delivery. </title> <journal> Information Processing Letters, </journal> <volume> 44(6), </volume> <month> December </month> <year> 1992. </year>
Reference-contexts: Another issue in asynchronous recovery protocols is the possibility of exponential rollbacks: a single failure in the system may cause a process to roll back an exponential number of times [157]. incarnation of a process. Suppose P 0 fails and loses its interval <ref> [1; 2] </ref>. When P 0 's rollback announcement r 0 reaches P 1 , P 1 rolls back to interval [2; 3] and broadcast another rollback announcement r 1 . <p> Kim et al. addressed recovery problems in the Programmer-Transparent Coordination (PTC) scheme [95, 97, 98]. Orphan elimination problem in nested transaction systems has also been studied [69, 70, 113]. Theoretical aspects of distributed snapshots also have been studied outside the context of recovery <ref> [1, 5, 38, 43, 67, 101, 162, 180] </ref>. Several fundamental properties regarding consistent global states have been derived [13, 16, 120, 131, 184]. Vector timestamps [55, 121, 151, 155] and the context graph used in em Psync [133] bear similarities to the various dependency tracking techniques.
Reference: [2] <author> A. Acharya and B. R. Badrinath. </author> <title> Checkpointing distributed applications on mobile computers. </title> <booktitle> In Proc. the Third International Conference on Parallel and Distributed Information Systems, </booktitle> <pages> pages 73-80, </pages> <month> September </month> <year> 1994. </year> <month> 35 </month>
Reference-contexts: Such a model, called an MRS model, can be maintained by taking an additional checkpoint before every message-receiving event that is not separated from its previous message-sending event by a checkpoint <ref> [2, 184] </ref>. In the Programmer-Transparent Coordination (PTC) scheme [98], Kim et al. proved that the domino effect can be eliminated if each process takes an additional checkpoint before processing any message that will cause the process to depend on a checkpoint that it did not previously depend on. <p> Another issue in asynchronous recovery protocols is the possibility of exponential rollbacks: a single failure in the system may cause a process to roll back an exponential number of times [157]. incarnation of a process. Suppose P 0 fails and loses its interval <ref> [1; 2] </ref>. When P 0 's rollback announcement r 0 reaches P 1 , P 1 rolls back to interval [2; 3] and broadcast another rollback announcement r 1 . <p> Suppose P 0 fails and loses its interval [1; 2]. When P 0 's rollback announcement r 0 reaches P 1 , P 1 rolls back to interval <ref> [2; 3] </ref> and broadcast another rollback announcement r 1 . If r 1 reaches P 2 before r 0 does, P 2 will first roll back to [4; 5] in response to r 1 , and later roll 22 back again to [4; 4] upon receiving r 0 .
Reference: [3] <author> M. Ahamad and L. Lin. </author> <title> Using checkpoints to localize the effects of faults in distributed systems. </title> <booktitle> In Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 2-11, </pages> <year> 1989. </year>
Reference-contexts: Suppose P 0 fails and loses its interval [1; 2]. When P 0 's rollback announcement r 0 reaches P 1 , P 1 rolls back to interval <ref> [2; 3] </ref> and broadcast another rollback announcement r 1 . If r 1 reaches P 2 before r 0 does, P 2 will first roll back to [4; 5] in response to r 1 , and later roll 22 back again to [4; 4] upon receiving r 0 .
Reference: [4] <author> R. E. Ahmed, R. C. Frazier, and P. N. Marinos. </author> <title> Cache-aided rollback error recovery (carer) algorithms for shared-memory multiprocessor systems. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 82-88, </pages> <year> 1990. </year>
Reference-contexts: When P 0 's rollback announcement r 0 reaches P 1 , P 1 rolls back to interval [2; 3] and broadcast another rollback announcement r 1 . If r 1 reaches P 2 before r 0 does, P 2 will first roll back to <ref> [4; 5] </ref> in response to r 1 , and later roll 22 back again to [4; 4] upon receiving r 0 . <p> If r 1 reaches P 2 before r 0 does, P 2 will first roll back to [4; 5] in response to r 1 , and later roll 22 back again to <ref> [4; 4] </ref> upon receiving r 0 . By generalizing this example, we can construct scenarios in which process P i , i &gt; 0, rolls back 2 i1 times in response to P 0 's failure. <p> Although most rollback-recovery techniques were originally designed for tolerating hardware failures, they have also been applied to software and protocol error recovery [169, 184, 190, 193]. Rollback-recovery in shared-memory and distributed shared-memory systems has also been extensively studied <ref> [4, 20, 54, 75, 80-83, 109, 132, 170, 197, 198] </ref>. This survey has covered mostly rollback-recovery techniques which do not require or take advantage of special linguistic supports.
Reference: [5] <author> M. Ahuja. </author> <title> Repeated global snapshots in asynchronous distributed systems. </title> <type> Technical Report OSU-CISRC-8/89 TR40, </type> <institution> Ohio State University, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: When P 0 's rollback announcement r 0 reaches P 1 , P 1 rolls back to interval [2; 3] and broadcast another rollback announcement r 1 . If r 1 reaches P 2 before r 0 does, P 2 will first roll back to <ref> [4; 5] </ref> in response to r 1 , and later roll 22 back again to [4; 4] upon receiving r 0 . <p> Kim et al. addressed recovery problems in the Programmer-Transparent Coordination (PTC) scheme [95, 97, 98]. Orphan elimination problem in nested transaction systems has also been studied [69, 70, 113]. Theoretical aspects of distributed snapshots also have been studied outside the context of recovery <ref> [1, 5, 38, 43, 67, 101, 162, 180] </ref>. Several fundamental properties regarding consistent global states have been derived [13, 16, 120, 131, 184]. Vector timestamps [55, 121, 151, 155] and the context graph used in em Psync [133] bear similarities to the various dependency tracking techniques.
Reference: [6] <author> L. Alvisi, B. Hoppe, and K. Marzullo. </author> <title> Nonblocking and orphan-free message logging protocols. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 145-154, </pages> <year> 1993. </year>
Reference-contexts: This observation is the basis of Family Based Logging protocols (FBL) that are parameterized by the number of tolerated failures <ref> [6, 7] </ref>. The basis of these protocols is that to tolerate f process failures, it is sufficient to log each nondeterministic event in the volatile store of f + 1 different hosts. Sender-based logging is still used to support message replay during recovery. <p> Reducing access to stable storage in turn reduces performance overhead and implementation complexity. Applications pay only the overhead that corresponds to the number of failures they are willing to tolerate. An implementation for the protocol with f = 1 confirms that the performance overhead is very small <ref> [6] </ref>.
Reference: [7] <author> L. Alvisi and K. Marzullo. </author> <title> Message logging: Pessimistic, optimistic, and causal. </title> <booktitle> In Proc. IEEE Int. Conf. Distributed Comput. Syst., </booktitle> <pages> pages 229-236, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: This observation is the basis of Family Based Logging protocols (FBL) that are parameterized by the number of tolerated failures <ref> [6, 7] </ref>. The basis of these protocols is that to tolerate f process failures, it is sufficient to log each nondeterministic event in the volatile store of f + 1 different hosts. Sender-based logging is still used to support message replay during recovery. <p> Examples include calls that allocate memory or create processes. Ensuring that these calls return the same values and generate the same effect during reexecution can be very complex [48, 149]. 5.6.2 Asynchronous signals Different flavors of logging have been suggested with different performance and resilience characteristics <ref> [7] </ref>. These protocols, however, do not support general forms of nondeterminism that are found in practice. It is inefficient for example to track the nondeterminism resulting from software interrupts such as UNIX signals. Such signals must be applied at the same execution points during replay to reproduce the same result.
Reference: [8] <author> L. Alvisi and K. Marzullo. </author> <title> Trade-offs in implementing causal message logging protocols. </title> <booktitle> In ACM Annual Symp. on the Priciples of Distributed Computing, </booktitle> <pages> pages 58-67, </pages> <month> May </month> <year> 1996. </year>
Reference: [9] <author> A. W. Appel. </author> <title> A runtime system. </title> <type> Technical Report CS-TR-220-89, </type> <institution> Department of Computer Science, Princeton University, </institution> <year> 1989. </year>
Reference-contexts: The compiler may also be trained by running the application in an iterative manner and observing its behavior [108]. The observed behavior could help decide the execution points where it would be appropriate to insert checkpoints. Compiler support could also be simplified in languages that support automatic garbage collection <ref> [9] </ref>. The execution point after each major garbage collection provides a convenient place to take a checkpoint at a minimum cost. 5.2.4 Coordinated versus Uncoordinated Checkpointing Many checkpointing protocols were incepted at a time where the communication overhead far exceeded the overhead of accessing stable storage [26].
Reference: [10] <author> A. Arora and M. Gouda. </author> <title> Distributed reset. </title> <journal> IEEE Trans. Comput., </journal> <volume> 43(9) </volume> <pages> 1026-1038, </pages> <month> September </month> <year> 1994. </year>
Reference: [11] <author> O. Babaoglu. </author> <title> Fault-tolerant computing based on Mach. </title> <booktitle> In Proceedings of the Usenix Mach Workshop, </booktitle> <pages> pages 186-199, </pages> <month> October </month> <year> 1990. </year>
Reference: [12] <author> O. Babaoglu and W. Joy. </author> <title> Converting a swap-based system to do paging in an architecture lacking page-reference bits. </title> <booktitle> In Proceedings of the Symposium on Operating Systems Principles, </booktitle> <pages> pages 78-86, </pages> <year> 1981. </year>
Reference-contexts: Adding incremental checkpointing to concurrent checkpointing can further reduce the overhead [50]. Incremental checkpointing avoids rewriting portions of the process states that do not change between consecutive checkpoints. It can be implemented by using the dirty-bit of the memory protection hardware or by emulating a dirty-bit in software <ref> [12] </ref>. A public domain package implementing these techniques is available [136]. Incremental checkpointing can also be extended over several processes. In this technique, the system saves the computed parity or some function of the memory pages that are modified across several processes [137].
Reference: [13] <author> O. Babaoglu and K. Marzullo. </author> <title> Consistent global states of distributed systems: Fundamental concepts and mechanisms. In Distributed Systems, </title> <editor> Ed. S. </editor> <booktitle> Mullender, </booktitle> <pages> pages 55-96. </pages> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: Orphan elimination problem in nested transaction systems has also been studied [69, 70, 113]. Theoretical aspects of distributed snapshots also have been studied outside the context of recovery [1, 5, 38, 43, 67, 101, 162, 180]. Several fundamental properties regarding consistent global states have been derived <ref> [13, 16, 120, 131, 184] </ref>. Vector timestamps [55, 121, 151, 155] and the context graph used in em Psync [133] bear similarities to the various dependency tracking techniques. Check-pointing and message logging can also be used to facilitate the debugging of parallel and distributed programs [57, 63, 129, 130].
Reference: [14] <author> D. F. Bacon. </author> <title> File system measurements and their application to the design of efficient operation logging algorithms. </title> <booktitle> Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 21-30, </pages> <year> 1991. </year>
Reference: [15] <author> D. F. Bacon. </author> <title> Transparent recovery in distributed systems. </title> <journal> ACM Oper. Syst. Review, </journal> <pages> pages 91-94, </pages> <month> April </month> <year> 1991. </year>
Reference: [16] <author> R. Baldoni, J. M. Helary, A. Mostefaoui, and M. Raynal. </author> <title> Consistent checkpointing in message passing distributed systems. </title> <type> Technical Report No. 2564, </type> <institution> INRIA, France, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: The main advantage of the FDAS model is that it allows rollback dependency to be tracked on-line, a property that leads to many desirable features of the piecewise deterministic model. The ability to track rollback dependency is also preserved in the adaptive checkpointing algorithm of Baldoni et al. <ref> [16] </ref>. In their scheme, an additional boolean vector and another boolean matrix are piggybacked on each message. <p> Orphan elimination problem in nested transaction systems has also been studied [69, 70, 113]. Theoretical aspects of distributed snapshots also have been studied outside the context of recovery [1, 5, 38, 43, 67, 101, 162, 180]. Several fundamental properties regarding consistent global states have been derived <ref> [13, 16, 120, 131, 184] </ref>. Vector timestamps [55, 121, 151, 155] and the context graph used in em Psync [133] bear similarities to the various dependency tracking techniques. Check-pointing and message logging can also be used to facilitate the debugging of parallel and distributed programs [57, 63, 129, 130].
Reference: [17] <author> R. Baldoni, J. M. Helary, A. Mostefaoui, and M. Raynal. </author> <title> On modeling consistent checkpoints and the domino effect in distributed systems. </title> <type> Technical Report No. 2569, </type> <institution> INRIA, France, </institution> <month> June </month> <year> 1995. </year>
Reference: [18] <author> J. P. Ban^atre, M. Ban^atre, and G. Muller. </author> <title> Ensuring data security and integrity with a fast stable storage. </title> <booktitle> In Proceedings of the fourth Conference on Data Engineering, </booktitle> <pages> pages 285-293, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: This special hardware can take the form of a fast non-volatile semiconductor memory to implement stable storage <ref> [18, 163] </ref>. Synchronous logging in such an implementation would be orders of magnitude cheaper than with a traditional implementation of stable storage using magnetic disk devices. Therefore, performance is only slightly affected. <p> The package runs in conventional UNIX systems and bypasses the UNIX file system by accessing the disk in raw mode [146]. There have been also several attempts at implementing stable storage using nonvolatile semiconductor memory <ref> [18] </ref>. Such implementations do not have the performance problems associated with disks. The price and the small storage capacity remain two problems that limit their wide acceptance. 31 5.6 Support for Nondeterminism Nondeterminism occurs when the application program interacts with the operating system through system calls and upcalls.
Reference: [19] <author> J. P. Ban^atre, M. Ban^atre, and G. Muller. </author> <title> Architecture of fault-tolerant multiprocessor workstations. </title> <booktitle> In Workshop on Workstation Operating Systems, </booktitle> <pages> pages 20-24, </pages> <year> 1989. </year>
Reference: [20] <author> M. Banatre, A. Ge*aut, P. Joubert, P. Lee, and C. Morin. </author> <title> An architecture for tolerating processor failures in shared-memory multiprocessors. </title> <type> Technical Report 707, </type> <institution> IRISA, Rennes, France, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: Although most rollback-recovery techniques were originally designed for tolerating hardware failures, they have also been applied to software and protocol error recovery [169, 184, 190, 193]. Rollback-recovery in shared-memory and distributed shared-memory systems has also been extensively studied <ref> [4, 20, 54, 75, 80-83, 109, 132, 170, 197, 198] </ref>. This survey has covered mostly rollback-recovery techniques which do not require or take advantage of special linguistic supports.
Reference: [21] <author> G. Barigazzi and L. Strigini. </author> <title> Application-transparent setting of recovery points. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 48-55, </pages> <year> 1983. </year>
Reference-contexts: Only those processes that have communicated with the checkpoint initiator either directly or indirectly since the last checkpoint need to take new checkpoints <ref> [21, 100] </ref>. The following two-phase protocol is due to Koo and Toueg [100]. During the first phase, the checkpoint initiator sends a request to all processes with which it has communicated since the last checkpoint.
Reference: [22] <author> P.A. Barrett, A.M. Hilborne, P. Verissimo, L. Rodrigues, P.G. Bond, D.T. Seaton, and N.A. Speirs. </author> <title> The Delta-4 extra performance architecture XPA. </title> <booktitle> In Proceedings of the 20th International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 481-488, </pages> <month> June </month> <year> 1990. </year> <month> 36 </month>
Reference-contexts: Alternatively, the system may convert these asynchronous signals to synchronous messages such as in Targon/32 [29], or it may queue the signals until the application polls for them such as in Delta-4 <ref> [22, 39] </ref>. Both alternatives convert asynchronous event notifications into synchronous ones, which may not be suitable or efficient for many applications. Such solutions also require substantial modifications to the operating system or the application program.
Reference: [23] <author> J. F. Bartlett. </author> <title> A NonStop Kernel. </title> <booktitle> In Proc. 8th ACM Symp. on Operating Systems Principles, </booktitle> <pages> pages 22-29, </pages> <year> 1981. </year>
Reference-contexts: Log-based rollback-recovery does not have this problem and can interact more efficiently with the outside world. Log-based rollback-recovery protocols have been traditionally called "message logging protocols." The association of nondeterministic events with messages is rooted in the earliest systems that implemented this style of recovery <ref> [23, 28] </ref>. These systems translated nondeterministic events into messages according to the CSP model [71]. It is important however to emphasize that these protocols are not only limited to message-passing systems. <p> Such hardware support ensures that the log of one machine is automatically stored on a designated backup without blocking the execution of the application program. This scheme, however, requires that all nondeterministic events be converted into external messages <ref> [23, 29] </ref>. Some pessimistic logging systems reduce the overhead of synchronous logging without relying on hardware. For example, the sender-based message logging (SBML) protocol logs each message at the sender in volatile memory [88].
Reference: [24] <author> M. Beck, J. S. Plank, and G. Kingsley. </author> <title> Compiler-assisted checkpointing. </title> <type> Technical Report CS-94-269, </type> <institution> University of Tennessee at Knoxville, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: It is generally undecidable to find the point in program execution most suitable to take a checkpoint. 28 There are, however, several heuristics that can be used. The programmer could provide hints to the compiler about where checkpoints could be inserted or what data variables should be stored <ref> [24, 138, 152] </ref>. The compiler may also be trained by running the application in an iterative manner and observing its behavior [108]. The observed behavior could help decide the execution points where it would be appropriate to insert checkpoints.
Reference: [25] <author> B. Bhargava and S. R. Lian. </author> <title> Independent checkpointing and concurrent rollback for recovery An optimistic approach. </title> <booktitle> In Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 3-12, </pages> <year> 1988. </year>
Reference-contexts: During normal execution, the dependencies between checkpoints caused by message exchanges need to be recorded so that a consistent global checkpoint can be determined during recovery. The following direct dependency tracking technique is commonly used in uncoordinated checkpoint-ing <ref> [25, 178, 192] </ref>. <p> The first approach is based on a rollback-dependency graph <ref> [25, 35, 184] </ref> in which each node represents a checkpoint and a directed edge is drawn from c i;x to c j;y if (1) i 6= j, and a message m is sent from I i;x and received in I j;y or (2) i = j and y = x + <p> The rollback-dependency graph corresponding to the pattern in Figure 7 (a) is illustrated in Figure 7 (b). To calculate the recovery line, the graph nodes corresponding to the volatile checkpoints of the failed processes P 0 and P 1 are initially marked. A reachability analysis <ref> [25, 184] </ref> is performed by marking all the nodes reachable from any of the initially marked nodes. The last unmarked node of each process then forms the recovery line as shown in Figure 7 (b). 10 checkpoint graph. The second approach is based on a checkpoint graph [178, 183].
Reference: [26] <author> B. Bhargava, S.-R. Lian, and P.-J. Leu. </author> <title> Experimental evaluation of concurrent checkpointing and rollback recovery algorithms. </title> <booktitle> In Proc. Int. Conf. Data Eng., </booktitle> <pages> pages 182-189, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Many of these protocols have been incepted in the 1980's. During that era, processor 26 speed and network bandwidth were such that communication overhead was deemed too high, es-pecially when compared to the cost of stable storage access <ref> [26] </ref>. In such platforms, a protocol that requires multi-host coordination incurs a large overhead due to the necessary control messages that carry out the protocol. A protocol that does not require such communication overhead at the expense of more stable storage access would perform better in such platforms. <p> The execution point after each major garbage collection provides a convenient place to take a checkpoint at a minimum cost. 5.2.4 Coordinated versus Uncoordinated Checkpointing Many checkpointing protocols were incepted at a time where the communication overhead far exceeded the overhead of accessing stable storage <ref> [26] </ref>. Furthermore, the memory available to run processes tended to be small. These tradeoffs naturally favored uncoordinated checkpointing schemes over coordinated checkpointing schemes. Current technological trends however have reversed this tradeoff.
Reference: [27] <author> A. D. Birrell and B. J. Nelson. </author> <title> Implementing remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 39-59, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: Some protocols offer the abstraction of reliable communication channels such as connection-based protocols like TCP [139] or RPC-style communications <ref> [27] </ref>. Alternatively, other protocols offer the abstraction of an unreliable datagram service such as UDP [139].
Reference: [28] <author> A. Borg, J. Baumbach, and S. Glazer. </author> <title> A message system supporting fault-tolerance. </title> <booktitle> In Proc. 9th ACM Symp. on Operating Systems Principles, </booktitle> <pages> pages 90-99, </pages> <month> October </month> <year> 1983. </year>
Reference-contexts: Log-based rollback-recovery does not have this problem and can interact more efficiently with the outside world. Log-based rollback-recovery protocols have been traditionally called "message logging protocols." The association of nondeterministic events with messages is rooted in the earliest systems that implemented this style of recovery <ref> [23, 28] </ref>. These systems translated nondeterministic events into messages according to the CSP model [71]. It is important however to emphasize that these protocols are not only limited to message-passing systems.
Reference: [29] <author> A. Borg, W. Blau, W. Graetsch, F. Herrmann, and W. Oberle. </author> <title> Fault tolerance under UNIX. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 7(1) </volume> <pages> 1-24, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: Stable storage must ensure that the data stored will persist through the tolerated failure modes. Therefore, in a system that tolerates a single failure, stable storage may consist of the volatile memory of another process <ref> [29, 88] </ref>. A system that wishes to tolerate an arbitrary number of transient failures can implement stable storage by storing information on a reliable disk local to each host. <p> Therefore, performance is only slightly affected. Another form of hardware support is to use a special bus that guarantees atomic logging of all messages exchanged in the system <ref> [29, 140] </ref>. Such hardware support ensures that the log of one machine is automatically stored on a designated backup without blocking the execution of the application program. This scheme, however, requires that all nondeterministic events be converted into external messages [23, 29]. <p> Such hardware support ensures that the log of one machine is automatically stored on a designated backup without blocking the execution of the application program. This scheme, however, requires that all nondeterministic events be converted into external messages <ref> [23, 29] </ref>. Some pessimistic logging systems reduce the overhead of synchronous logging without relying on hardware. For example, the sender-based message logging (SBML) protocol logs each message at the sender in volatile memory [88]. <p> These studies also indicate that the main difficulty in implementing these protocols lies in the complexity of handling recovery [48]. It is interesting that all commercial implementations of message logging use pessimistic logging because it simplifies recovery <ref> [29, 74] </ref>. Several recent studies have also challenged some premises which many rollback-recovery protocols rely on. Many of these protocols have been incepted in the 1980's. <p> Systems that support this form of nondeterminism simply take a checkpoint after the occurrence of each signal, which can be very expensive [48]. Alternatively, the system may convert these asynchronous signals to synchronous messages such as in Targon/32 <ref> [29] </ref>, or it may queue the signals until the application polls for them such as in Delta-4 [22, 39]. Both alternatives convert asynchronous event notifications into synchronous ones, which may not be suitable or efficient for many applications.
Reference: [30] <author> N. S. Bowen and D. K. Pradhan. </author> <title> Survey of checkpoint and rollbak recovery techniques. </title> <type> Technical Report TR-91-CSE-17, </type> <institution> Dept. of Electrical and Computer Engineering, University of Massachusetts, Amherst, </institution> <month> July </month> <year> 1991. </year>
Reference: [31] <author> N. S. Bowen and D. K. Pradhan. </author> <title> Virtual checkpoints: Architecture and performance. </title> <journal> IEEE Trans. Comput., </journal> <volume> 41(5) </volume> <pages> 516-525, </pages> <month> May </month> <year> 1992. </year>
Reference: [32] <author> N. S. Bowen and D. K. Pradhan. </author> <title> Processor- and memory-based checkpoint and rollback recovery. </title> <journal> IEEE Computer Magazine, </journal> <pages> pages 22-31, </pages> <month> February </month> <year> 1993. </year>
Reference: [33] <author> D. Briatico, A. Ciuffoletti, and L. Simoncini. </author> <title> A distributed domino-effect free recovery algorithm. </title> <booktitle> In Proc. IEEE 4th Symp. on Reliability in Distributed Software and Database Systems, </booktitle> <pages> pages 207-215, </pages> <year> 1984. </year>
Reference-contexts: Upon receiving a message with piggybacked index greater than the local index, the receiver is forced to take a checkpoint before processing the message to avoid inconsistency at the last minute <ref> [33, 101] </ref>. The lazy coordination protocol described above has two disadvantages. First, the induced checkpoints push the checkpoint indices at some processes higher which may cause more induced checkpoints to be taken and, in the worst case, result in an excessive number of induced checkpoints.
Reference: [34] <author> R. H. Campbell and B. Randell. </author> <title> Error recovery in asynchronous systems. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> SE-12(8):811-826, </volume> <year> 1986. </year>
Reference-contexts: This survey has covered mostly rollback-recovery techniques which do not require or take advantage of special linguistic supports. A substantial amount of research efforts has also focused on coordinated recovery based on special language constructs such as recovery blocks and conversations <ref> [34, 65, 66, 79, 94, 96, 144, 145, 200] </ref>. Nett et al. addressed recovery problems in dynamic action models [126-128]. Kim et al. addressed recovery problems in the Programmer-Transparent Coordination (PTC) scheme [95, 97, 98]. Orphan elimination problem in nested transaction systems has also been studied [69, 70, 113].
Reference: [35] <author> J. Cao and K. C. Wang. </author> <title> An abstract model of rollback recovery control in distributed systems. </title> <journal> ACM Oper. Syst. Review, </journal> <pages> pages 62-76, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: The first approach is based on a rollback-dependency graph <ref> [25, 35, 184] </ref> in which each node represents a checkpoint and a directed edge is drawn from c i;x to c j;y if (1) i 6= j, and a message m is sent from I i;x and received in I j;y or (2) i = j and y = x +
Reference: [36] <author> T. Cargill and B. Locanthi. </author> <title> Cheap hardware support for software debugging and profiling. </title> <booktitle> Proceedings of the 2nd Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 82-83, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: Execution proceeds until an event of interest occurs, at which time the content of the counter is sampled, and the number of instructions executed since the time the counter was set is computed. The use of instruction counters has been suggested for debugging shared memory parallel programs <ref> [36, 122, 148] </ref>. Instruction counters can be used in rollback-recovery to track the number of instructions that occur between asynchronous interrupts. A replay system can use the instruction count to force the execution of the same number of instructions between asynchronous interrupts.
Reference: [37] <author> J. Carter, A. Cox, S. Dwarkadas, E. N. Elnozahy, D. B. Johnson, P. Keleher, S. Rodrigues, W. Yu, and W. Zwaenepoel. </author> <title> Network multicomputing using recoverable distributed shared memory. </title> <booktitle> In Proceedings of COMPCON'93, </booktitle> <pages> pages 515-523, </pages> <year> 1993. </year>
Reference-contexts: These systems translated nondeterministic events into messages according to the CSP model [71]. It is important however to emphasize that these protocols are not only limited to message-passing systems. They have found applications in other style of interprocess communication, such as in distributed shared memory systems <ref> [37, 170, 197] </ref>. Log-based rollback-recovery protocols come in three major variants: pessimistic logging, optimistic logging, and causal logging protocols.
Reference: [38] <author> K. M. Chandy and L. Lamport. </author> <title> Distributed snapshots: Determining global states of distributed systems. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: A more precise definition of a consistent system state is one in which every message that has been received is also shown to have been sent in the state of the sender <ref> [38] </ref>. <p> Under the assumption of FIFO channels, this problem can be solved by always generating a checkpoint request before sending any post-checkpoint messages, and forcing each process to take a checkpoint upon receiving the first checkpoint request, as illustrated in Figure 10 (b). Chandy and Lamport's distributed snapshot algorithm <ref> [38] </ref> provides such a nonblocking checkpoint coordination protocol. (The checkpoint request message is called a marker in their paper.) Note that, since we only need the checkpoint request to be processed before any post-checkpoint messages, checkpoint request can be piggybacked on every post-checkpoint message m and examined by the receiver before <p> Kim et al. addressed recovery problems in the Programmer-Transparent Coordination (PTC) scheme [95, 97, 98]. Orphan elimination problem in nested transaction systems has also been studied [69, 70, 113]. Theoretical aspects of distributed snapshots also have been studied outside the context of recovery <ref> [1, 5, 38, 43, 67, 101, 162, 180] </ref>. Several fundamental properties regarding consistent global states have been derived [13, 16, 120, 131, 184]. Vector timestamps [55, 121, 151, 155] and the context graph used in em Psync [133] bear similarities to the various dependency tracking techniques.
Reference: [39] <author> M. Chereque, D. Powell, P. Reynier, J-L. Richier, and J. Voiron. </author> <title> Active replication in Delta-4. </title> <booktitle> In Proceedings of the 22nd International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 28-37, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Alternatively, the system may convert these asynchronous signals to synchronous messages such as in Targon/32 [29], or it may queue the signals until the application polls for them such as in Delta-4 <ref> [22, 39] </ref>. Both alternatives convert asynchronous event notifications into synchronous ones, which may not be suitable or efficient for many applications. Such solutions also require substantial modifications to the operating system or the application program.
Reference: [40] <author> G.-M. Chiu and C.-R. Young. </author> <title> Efficient rollback-recovery technique in distributed computing systems. </title> <journal> IEEE Trans. Parallel and Distributed Syst., </journal> <volume> 7(6) </volume> <pages> 565-577, </pages> <month> June </month> <year> 1996. </year>
Reference: [41] <author> E. Cohen, Y. M. Wang, and G. Suri. </author> <title> When piecewise determinism is almost true. </title> <booktitle> In Proc. Pacific Rim International Symposium on Fault-Tolerant Systems, </booktitle> <pages> pages 66-71, </pages> <month> December </month> <year> 1995. </year> <month> 37 </month>
Reference-contexts: In practice, it is important to support systems consisting of both deterministic and nondeterministic processes [87, 90]. One challenge is to handle unreplayable nondeterministic events while still preserving the advantages of piecewise determinism <ref> [41, 184, 190] </ref>. Although most rollback-recovery techniques were originally designed for tolerating hardware failures, they have also been applied to software and protocol error recovery [169, 184, 190, 193].
Reference: [42] <author> F. Cristian and F. Jahanian. </author> <title> A timestamp-based checkpointing protocol for long-lived distributed computations. </title> <booktitle> In Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 12-20, </pages> <year> 1991. </year>
Reference-contexts: Log-based recovery has traditionally been called message logging, as earlier papers have assumed that nondeterministic events can be converted to messages. Also, "message logging" has sometimes been used in the literature to refer to the recording of in-transit messages <ref> [42, 187] </ref>. <p> This modification also allows non-FIFO channels. In practice, checkpoint indices can serve as the checkpoint request messages: a checkpoint is triggered when the receiver's local checkpoint index is lower than the piggybacked checkpoint index [50, 154]. 14 3.2.3 Synchronized Checkpoint Clocks Loosely synchronous clocks can facilitate checkpoint coordination <ref> [42, 143, 177] </ref>. More specifically, loosely-synchronized checkpoint clocks can trigger the local checkpointing actions of all participating processes at approximately the same time without the need of broadcasting the checkpoint request message by a coordinator.
Reference: [43] <author> C. Critchlow and K. Taylor. </author> <title> The inhibition spectrum and the achievement of causal consistency. </title> <type> Technical Report TR 90-1101, </type> <institution> Cornell University, </institution> <month> February </month> <year> 1990. </year>
Reference-contexts: The main disadvantage is the sacrifice of process autonomy in taking checkpoints. In addition, a coordination session needs to be initiated before committing any output, and checkpoint coordination generally incurs message overhead. A straightforward approach to coordinated checkpointing is to block interprocess communications until the checkpointing protocol executes <ref> [43, 174] </ref>. <p> Kim et al. addressed recovery problems in the Programmer-Transparent Coordination (PTC) scheme [95, 97, 98]. Orphan elimination problem in nested transaction systems has also been studied [69, 70, 113]. Theoretical aspects of distributed snapshots also have been studied outside the context of recovery <ref> [1, 5, 38, 43, 67, 101, 162, 180] </ref>. Several fundamental properties regarding consistent global states have been derived [13, 16, 120, 131, 184]. Vector timestamps [55, 121, 151, 155] and the context graph used in em Psync [133] bear similarities to the various dependency tracking techniques.
Reference: [44] <author> D. Cummings and L. Alkalaj. </author> <title> Checkpoint/rollback in a distributed system using coarse-grained dataflow. </title> <booktitle> In Proceedings of the Twenty Fourth Annual International Symposium on Fault-Tolerant Computing, FTCS-24, </booktitle> <pages> pages 424-433, </pages> <month> June </month> <year> 1994. </year>
Reference: [45] <author> O. P. Damani and V. K. Garg. </author> <title> How to recover efficiently and asynchronously when optimism fails. </title> <booktitle> In Proc. IEEE Int. Conf. Distributed Comput. Syst., </booktitle> <pages> pages 108-115, </pages> <year> 1996. </year>
Reference-contexts: The protocol by Lowry and Strom [117] piggybacks the original rollback announcement from the failed process on every subsequent rollback announcement that it triggers. For example, in Figure 13, process P 1 piggybacks r 0 on r 1 . Damani and Garg <ref> [45] </ref> reduced the number of rollback announcements based on the important observation that announcing only failures, rather than all rollbacks, suffices to detect orphans.
Reference: [46] <author> G. Deconinck, J. Vounckx, R. Cuyvers, and R. Lauwereins. </author> <title> Survey of checkpointing and rollback techniques. </title> <institution> Technical Report O3.1.8 and O3.1.12, ESAT-ACCA Laboratory, Katholieke Universiteit Leuven, Belgium, </institution> <month> June </month> <year> 1993. </year>
Reference: [47] <author> G. Deconinck, J. Vounckx, R. Lauwereins, and J. A. Peperstraete. </author> <title> Survey of backward error recovery techniques for multicomputers based on checkpointing and rollback. </title> <booktitle> In Proc. IASTED Int. Conf. on Modelling and Simulation, </booktitle> <pages> pages 262-265, </pages> <month> May </month> <year> 1993. </year>
Reference: [48] <author> E. N. Elnozahy. Manetho: </author> <title> Fault Tolerance in Distributed Systems Using Rollback-Recovery and Process Replication. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Rice University, </institution> <month> October </month> <year> 1993. </year> <note> Also available as Technical Report TR93-212. </note>
Reference-contexts: Process q already contains the information in these excluded portions, and therefore transmitting them serves no purpose. Other optimizations are also possible but depend on the semantics of the communication protocol <ref> [48] </ref>. An implementation of this technique shows that it has very low overhead in practice [48]. Further reduction of the overhead is possible if the system is willing to tolerate a number of failures that is less than the total number of processes in the system. <p> Process q already contains the information in these excluded portions, and therefore transmitting them serves no purpose. Other optimizations are also possible but depend on the semantics of the communication protocol <ref> [48] </ref>. An implementation of this technique shows that it has very low overhead in practice [48]. Further reduction of the overhead is possible if the system is willing to tolerate a number of failures that is less than the total number of processes in the system. <p> The few experimental studies available have shown that building rollback-recovery protocols with low failure-free overhead is feasible. These studies also indicate that the main difficulty in implementing these protocols lies in the complexity of handling recovery <ref> [48] </ref>. It is interesting that all commercial implementations of message logging use pessimistic logging because it simplifies recovery [29, 74]. Several recent studies have also challenged some premises which many rollback-recovery protocols rely on. Many of these protocols have been incepted in the 1980's. <p> The storage overhead of this method is very low, and it can be adjusted depending on how many failures the system is willing to tolerate [137]. 5.2.2 System-level versus User-level Implementations Support for checkpointing can be implemented in the kernel <ref> [48, 86, 135] </ref>, or it can be implemented by a library linked with the user program [62, 106, 136, 159, 165, 191]. Kernel-level implementations are more powerful because they can also capture kernel data structures that support the checkpointed process. However, these implementations are necessarily not portable. <p> An implementation of a stable storage abstraction on top of a conventional file system may not be the best choice, however. Such an implementation will not generally give the performance and reliability needed to implement stable storage <ref> [48] </ref>. The KitLog package offers a log abstraction on top of which support for checkpointing and message logging can be implemented. The package runs in conventional UNIX systems and bypasses the UNIX file system by accessing the disk in raw mode [146]. <p> These calls generally modify the environment and therefore they must be re-executed to re-establish the environment changes. Examples include calls that allocate memory or create processes. Ensuring that these calls return the same values and generate the same effect during reexecution can be very complex <ref> [48, 149] </ref>. 5.6.2 Asynchronous signals Different flavors of logging have been suggested with different performance and resilience characteristics [7]. These protocols, however, do not support general forms of nondeterminism that are found in practice. <p> Such signals must be applied at the same execution points during replay to reproduce the same result. Systems that support this form of nondeterminism simply take a checkpoint after the occurrence of each signal, which can be very expensive <ref> [48] </ref>. Alternatively, the system may convert these asynchronous signals to synchronous messages such as in Targon/32 [29], or it may queue the signals until the application polls for them such as in Delta-4 [22, 39]. <p> There are techniques for optimizing these forms of tracking by exploiting the semantics of the communication system and by piggybacking only incremental changes over application messages. Prototype implementations have shown that the overhead resulting from tracking is negligible compared to the overhead of checkpointing or logging <ref> [48] </ref>. 33 5.8 Recovery Handling execution restart and replay is a difficult part of implementing a rollback-recovery system [48, 104]. Implanting a process in a different environment during recovery can create difficulties if its state depends on the pre-failure environment. <p> Prototype implementations have shown that the overhead resulting from tracking is negligible compared to the overhead of checkpointing or logging [48]. 33 5.8 Recovery Handling execution restart and replay is a difficult part of implementing a rollback-recovery system <ref> [48, 104] </ref>. Implanting a process in a different environment during recovery can create difficulties if its state depends on the pre-failure environment. For example, the process may need to access files that exist on the local disk of the machine. <p> The simplest solution to this problem is to attempt to restart the program on the same host. If this is not feasible, then the system must insulate the process from environment-specific variables <ref> [48] </ref>. This can be done for instance by intercepting system calls that return environment-specific results and replace these results with abstract values under the control of the recovery system [149].
Reference: [49] <author> E. N. Elnozahy. </author> <title> Fault Tolerance for Clusters of Workstations, </title> <editor> M. Banatre and P. Lee (Editors), </editor> <booktitle> chapter 8. </booktitle> <publisher> Springer Verlag, </publisher> <month> August </month> <year> 1994. </year>
Reference: [50] <author> E. N. Elnozahy, D. B. Johnson, and W. Zwaenepoel. </author> <title> The performance of consistent checkpointing. </title> <booktitle> In Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 39-47, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: This modification also allows non-FIFO channels. In practice, checkpoint indices can serve as the checkpoint request messages: a checkpoint is triggered when the receiver's local checkpoint index is lower than the piggybacked checkpoint index <ref> [50, 154] </ref>. 14 3.2.3 Synchronized Checkpoint Clocks Loosely synchronous clocks can facilitate checkpoint coordination [42, 143, 177]. More specifically, loosely-synchronized checkpoint clocks can trigger the local checkpointing actions of all participating processes at approximately the same time without the need of broadcasting the checkpoint request message by a coordinator. <p> Some protocols that rely on the receiver to log the messages cannot retrieve these messages [77]. This problem does not occur in protocols that rely on sender logging or those that do not assume 20 reliable communication channels <ref> [50, 89] </ref>. 4.2 Optimistic Logging 4.2.1 Overview Unlike pessimistic logging protocols, optimistic logging protocols [87, 89, 91, 134, 157, 168] log messages asynchronously. These protocols make the optimistic assumption that logging will complete before a failure occurs. <p> The checkpointing system copies the page into a separate buffer from which it is saved on stable storage. The original page is unprotected and the application program is allowed to resume. Adding incremental checkpointing to concurrent checkpointing can further reduce the overhead <ref> [50] </ref>. Incremental checkpointing avoids rewriting portions of the process states that do not change between consecutive checkpoints. It can be implemented by using the dirty-bit of the memory protection hardware or by emulating a dirty-bit in software [12]. A public domain package implementing these techniques is available [136]. <p> Furthermore, the memory available to run processes tended to be small. These tradeoffs naturally favored uncoordinated checkpointing schemes over coordinated checkpointing schemes. Current technological trends however have reversed this tradeoff. In modern systems, the overhead of coordinating checkpoints is negligible compared to the overhead of saving the states <ref> [50, 125] </ref>. Using concurrent and incremental checkpointing, the overhead of either coordinated or uncoordinated checkpointing is essentially the same. Therefore, uncoordinated checkpointing is not likely to be an attractive technique in practice given the negligible performance gains.
Reference: [51] <author> E. N. Elnozahy and W. Zwaenepoel. Manetho: </author> <title> Transparent rollback-recovery with low overhead, limited rollback and fast output commit. </title> <journal> IEEE Trans. Comput., </journal> <volume> 41(5) </volume> <pages> 526-531, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: The above approaches rely solely on checkpoints, therefore the name checkpoint-based rollback-recovery. In contrast, log-based rollback-recovery uses checkpointing and message logging. 1 Log-based rollback-recovery relies on the assumptions underlied in a piecewise deterministic (PWD) execution model <ref> [51, 167] </ref>. Under the PWD model, each process execution consists of a sequence of deterministic state intervals, each starting with the occurrence of a nondeterministic event. By logging and replaying the nondeterministic events in their exact original order, a process can 1 Logging is not confined to messages only. <p> The number of tolerated process failures may vary from one to N , and the recovery protocol needs to be accordingly designed. Whether failures that occur during recovery need to be tolerated or not also affects the choice of recovery protocols <ref> [51, 157] </ref>. 2.2 Consistent System States The state of a message-passing system is the collection of the individual states of all participating processes and the states of the communication channels. Intuitively, a consistent system state is one that may occur in a legal execution of a distributed computation. <p> Additionally, log-based recovery generally is not susceptible to the domino effect, 6 allowing processes to use uncoordinated checkpointing if desired. 2 Log-based recovery relies on the assumptions underlied in a piecewise deterministic (PWD) execution model <ref> [51, 167] </ref> and employs an additional logging protocol. Under the PWD assumption, a process execution consists of a sequence of state intervals, each starting with a nondeterministic event such as a message receipt from another process. The execution within each state interval is deterministic. <p> It also allows the process to make its state recoverable by simply logging the information available locally. Thus, a process does not need to run a multi-host protocol to commit output. 24 4.3.2 Tracking Causality The Manetho protocol <ref> [51] </ref> propagates the causal information in an antecedence graph. The antecedence graph provides every process in the system with a complete history of the nondeterministic events that have causal effects on its state.
Reference: [52] <author> E. N. Elnozahy and W. Zwaenepoel. </author> <title> Replicated distributed processes in manetho. </title> <booktitle> In Proceedings of the Twenty Second Annual International Symposium on Fault-Tolerant Computing, FTCS-22, </booktitle> <pages> pages 18-27, </pages> <month> July </month> <year> 1992. </year>
Reference: [53] <author> E. N. Elnozahy and W. Zwaenepoel. </author> <title> On the use and implementation of message logging. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 298-307, </pages> <year> 1994. </year>
Reference-contexts: Recently, processor speed and network bandwidth have increased dramatically, while the speed of stable storage access has remained relatively the same. 3 This change in the equation suggests a fresh look at the premises of many rollback-recovery protocols. Specifically, recent results have shown that <ref> [53, 106, 135] </ref>: * Stable storage access is now the major source of overhead in checkpointing systems. Communication overhead is much lower in comparison. <p> Such changes favor coordinated checkpointing schemes over message logging or independent checkpointing systems, as they require less ac cess to stable storage and are simpler to implement. * The case for message logging has become the ability to interact with the outside world, instead of reducing the overhead <ref> [53] </ref>. Message logging systems can implement efficient protocols for committing output and logging input that are not possible in checkpoint-only systems. * Recent advances have shown that arbitrary forms of nondeterminism can be supported at a very low overhead in logging systems. <p> This scheme works well in systems where broadcast messages are implemented using several point-to-point messages. In this case, copy-on-write will allow the system to have one copy for identical messages and thus reduce the storage and performance overhead of logging. No similar optimization can be performed in receiver-based systems <ref> [53] </ref>. 5.4.1 Message Logging and Coordinated Checkpointing Message logging has been traditionally presented as a scheme that allows the system to use uncoordinated checkpointing with no domino effect. However, there is nothing that prevents the system from using coordinated checkpointing in a message logging system [53]. <p> be performed in receiver-based systems <ref> [53] </ref>. 5.4.1 Message Logging and Coordinated Checkpointing Message logging has been traditionally presented as a scheme that allows the system to use uncoordinated checkpointing with no domino effect. However, there is nothing that prevents the system from using coordinated checkpointing in a message logging system [53]. Such a scheme has many advantages with respect to performance and simplicity. It retains the ability to perform fast output commit as in log-based systems. It also retains the simplicity of recovery and garbage collection that comes from coordinated checkpointing. <p> Furthermore, it allows a sender-based logging system to avoid flushing the logs on stable storage, reducing the overhead and complexity of maintaining logs on stable storage. The combination of coordinated checkpointing and message logging has been shown to outperform one with uncoordinated checkpointing and message logging <ref> [53] </ref>. Therefore, the purpose of logging should no longer be the avoidance of taking uncoordinated checkpointing but the desire for enabling fast output commit. 5.5 Stable Storage Magnetic disks have been the medium of choice for implementing stable storage.
Reference: [54] <author> M. J. Feeley, J. S. Chase, V. Narasayya, and H. M. Levy. </author> <title> Integrating coherency and recovery in distributed systems. </title> <booktitle> In Proc. Symp. on Operating System Design and Implementation, </booktitle> <year> 1994. </year>
Reference-contexts: Although most rollback-recovery techniques were originally designed for tolerating hardware failures, they have also been applied to software and protocol error recovery [169, 184, 190, 193]. Rollback-recovery in shared-memory and distributed shared-memory systems has also been extensively studied <ref> [4, 20, 54, 75, 80-83, 109, 132, 170, 197, 198] </ref>. This survey has covered mostly rollback-recovery techniques which do not require or take advantage of special linguistic supports.
Reference: [55] <author> C. J. Fidge. </author> <title> Timestamps in message-passing systems that preserve the partial ordering. </title> <booktitle> In Proc. 11th Australian Computer Science Conference, </booktitle> <pages> pages 55-66, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: Theoretical aspects of distributed snapshots also have been studied outside the context of recovery [1, 5, 38, 43, 67, 101, 162, 180]. Several fundamental properties regarding consistent global states have been derived [13, 16, 120, 131, 184]. Vector timestamps <ref> [55, 121, 151, 155] </ref> and the context graph used in em Psync [133] bear similarities to the various dependency tracking techniques. Check-pointing and message logging can also be used to facilitate the debugging of parallel and distributed programs [57, 63, 129, 130].
Reference: [56] <author> M. J. Fischer, N. D. Griffeth, and N. A. Lynch. </author> <title> Global states of a distributed system. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> SE-8(3):198-202, </volume> <month> May </month> <year> 1982. </year>
Reference: [57] <author> J. Fowler and W. Zwaenepoel. </author> <title> Causal distributed breakpoints. </title> <booktitle> In Proc. IEEE Int. Conf. Distributed Comput. Syst., </booktitle> <pages> pages 134-141, </pages> <year> 1990. </year>
Reference-contexts: Vector timestamps [55, 121, 151, 155] and the context graph used in em Psync [133] bear similarities to the various dependency tracking techniques. Check-pointing and message logging can also be used to facilitate the debugging of parallel and distributed programs <ref> [57, 63, 129, 130] </ref>.
Reference: [58] <author> T. M. Frazier and Y. Tamir. </author> <title> Application-transparent error-recovery techniques for multicomputers. </title> <booktitle> In The Fourth Conferences on Hypercubes, Concurrent Computers, and Applications, </booktitle> <pages> pages 103-108, </pages> <month> March </month> <year> 1989. </year>
Reference: [59] <author> R. M. Fujimoto. </author> <title> Parallel discrete event simulation. </title> <journal> Commun. ACM, </journal> <volume> 33(10) </volume> <pages> 30-53, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: Check-pointing and message logging can also be used to facilitate the debugging of parallel and distributed programs [57, 63, 129, 130]. In the area of distributed discrete-event simulation <ref> [59, 124] </ref>, the Time Warp optimistic approach, which inspired the seminal work on optimistic message logging [168], 34 uses rollbacks to cancel erroneous computations due to the out-of-order arrivals of time-stamped event messages [59, 60, 85, 118, 141]. 7 Conclusions We have reviewed and compared different approaches to rollback-recovery with respect <p> In the area of distributed discrete-event simulation [59, 124], the Time Warp optimistic approach, which inspired the seminal work on optimistic message logging [168], 34 uses rollbacks to cancel erroneous computations due to the out-of-order arrivals of time-stamped event messages <ref> [59, 60, 85, 118, 141] </ref>. 7 Conclusions We have reviewed and compared different approaches to rollback-recovery with respect to a set of properties including the assumption of piecewise determinism, performance overhead, storage overhead, ease of output commit, ease of garbage collection, ease of recovery, freedom from domino effect, freedom from orphan
Reference: [60] <author> A. Gafni. </author> <title> Rollback mechanisms for optimistic distributed simulation systems. </title> <booktitle> In Proc. SCS Multicon-ference on Distributed Simulation, </booktitle> <pages> pages 61-67, </pages> <month> July </month> <year> 1988. </year> <month> 38 </month>
Reference-contexts: In the area of distributed discrete-event simulation [59, 124], the Time Warp optimistic approach, which inspired the seminal work on optimistic message logging [168], 34 uses rollbacks to cancel erroneous computations due to the out-of-order arrivals of time-stamped event messages <ref> [59, 60, 85, 118, 141] </ref>. 7 Conclusions We have reviewed and compared different approaches to rollback-recovery with respect to a set of properties including the assumption of piecewise determinism, performance overhead, storage overhead, ease of output commit, ease of garbage collection, ease of recovery, freedom from domino effect, freedom from orphan
Reference: [61] <author> V. K. Garg. </author> <title> Some optimal algorithms for decomposed partially ordered sets. </title> <journal> Information Processing Letters, </journal> <volume> 44 </volume> <pages> 39-43, </pages> <month> November </month> <year> 1992. </year>
Reference: [62] <author> A. P. Goldberg, A. Gopal, K. Li, R. E. Strom, and D. F. Bacon. </author> <title> Transparent recovery of Mach applications. </title> <booktitle> In First USENIX Mach Workshop, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: is very low, and it can be adjusted depending on how many failures the system is willing to tolerate [137]. 5.2.2 System-level versus User-level Implementations Support for checkpointing can be implemented in the kernel [48, 86, 135], or it can be implemented by a library linked with the user program <ref> [62, 106, 136, 159, 165, 191] </ref>. Kernel-level implementations are more powerful because they can also capture kernel data structures that support the checkpointed process. However, these implementations are necessarily not portable. Checkpointing can also be implemented in user level. <p> Checkpointing can also be implemented in user level. System calls that manipulate memory protection such as mprotect of UNIX can emulate concurrent and incremental checkpointing. The fork system call of UNIX can implement concurrent checkpointing if the operating system implements fork using copy-on-write protection <ref> [62] </ref>. User-level implementations however cannot access kernel's data structures that belong to the process such as open file descriptors and message buffers, but these data structures can be emulated at user level [149, 191]. 5.2.3 Compiler Support A compiler can be instrumented to generate code that supports checkpointing [108]. <p> Systems that support this form of nondeterminism supply their own sets of locking primitives, and 32 require applications to use them for protecting access to shared memory <ref> [62] </ref>. The primitives are instrumented to insert an entry in the log identifying the calling thread and the nature of the synchronization operation [62]. However, this technique has several problems. It makes shared memory access expensive, and may generate a large volume of data in the log. <p> Systems that support this form of nondeterminism supply their own sets of locking primitives, and 32 require applications to use them for protecting access to shared memory <ref> [62] </ref>. The primitives are instrumented to insert an entry in the log identifying the calling thread and the nature of the synchronization operation [62]. However, this technique has several problems. It makes shared memory access expensive, and may generate a large volume of data in the log. Furthermore, if the application does not adhere to the synchronization model (due to a programmer's error, for instance), execution replay may not be possible.
Reference: [63] <author> A. P. Goldberg, A. Gopal, A. Lowry, and R. E. Strom. </author> <title> Restoring consistent global states of distributed computations. </title> <booktitle> In Proc. ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <month> May </month> <year> 1991. </year>
Reference-contexts: Vector timestamps [55, 121, 151, 155] and the context graph used in em Psync [133] bear similarities to the various dependency tracking techniques. Check-pointing and message logging can also be used to facilitate the debugging of parallel and distributed programs <ref> [57, 63, 129, 130] </ref>.
Reference: [64] <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <address> San Mateo, CA: </address> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1993. </year>
Reference-contexts: Rollback-recovery techniques that rely on special language constructs such as recovery blocks [144] and transactions <ref> [64] </ref> are not covered in this survey. Also, we do not address the use of rollback-recovery to tolerate Byzantine failures. 2 Background and Definitions 2.1 System Model and Failure Model A message-passing system consists of a fixed number of processes that communicate only through messages.
Reference: [65] <author> S. T. Gregory and J. C. Knight. </author> <title> A new linguistic approach to backward error recovery. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 404-409, </pages> <year> 1985. </year>
Reference-contexts: This survey has covered mostly rollback-recovery techniques which do not require or take advantage of special linguistic supports. A substantial amount of research efforts has also focused on coordinated recovery based on special language constructs such as recovery blocks and conversations <ref> [34, 65, 66, 79, 94, 96, 144, 145, 200] </ref>. Nett et al. addressed recovery problems in dynamic action models [126-128]. Kim et al. addressed recovery problems in the Programmer-Transparent Coordination (PTC) scheme [95, 97, 98]. Orphan elimination problem in nested transaction systems has also been studied [69, 70, 113].
Reference: [66] <author> S. T. Gregory and J. C. Knight. </author> <title> On the provision of backward error recovery in production programming languages. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 506-511, </pages> <year> 1989. </year>
Reference-contexts: This survey has covered mostly rollback-recovery techniques which do not require or take advantage of special linguistic supports. A substantial amount of research efforts has also focused on coordinated recovery based on special language constructs such as recovery blocks and conversations <ref> [34, 65, 66, 79, 94, 96, 144, 145, 200] </ref>. Nett et al. addressed recovery problems in dynamic action models [126-128]. Kim et al. addressed recovery problems in the Programmer-Transparent Coordination (PTC) scheme [95, 97, 98]. Orphan elimination problem in nested transaction systems has also been studied [69, 70, 113].
Reference: [67] <author> B. Groselj. </author> <title> Bounded and minimum global snapshots. </title> <journal> IEEE Parallel and Distributed Technology, </journal> <volume> 1(4), </volume> <month> November </month> <year> 1993. </year>
Reference-contexts: Kim et al. addressed recovery problems in the Programmer-Transparent Coordination (PTC) scheme [95, 97, 98]. Orphan elimination problem in nested transaction systems has also been studied [69, 70, 113]. Theoretical aspects of distributed snapshots also have been studied outside the context of recovery <ref> [1, 5, 38, 43, 67, 101, 162, 180] </ref>. Several fundamental properties regarding consistent global states have been derived [13, 16, 120, 131, 184]. Vector timestamps [55, 121, 151, 155] and the context graph used in em Psync [133] bear similarities to the various dependency tracking techniques.
Reference: [68] <author> V. Hadzilacos. </author> <title> An algorithm for minimizing roll back cost. </title> <booktitle> In Proc. ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 93-97, </pages> <year> 1982. </year>
Reference: [69] <author> M. Herlihy, N. Lynch, M. Merritt, and W. Weihl. </author> <title> On the correctness of orphan management algorithms. </title> <journal> J. of ACM, </journal> <volume> 39(4) </volume> <pages> 881-930, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Nett et al. addressed recovery problems in dynamic action models [126-128]. Kim et al. addressed recovery problems in the Programmer-Transparent Coordination (PTC) scheme [95, 97, 98]. Orphan elimination problem in nested transaction systems has also been studied <ref> [69, 70, 113] </ref>. Theoretical aspects of distributed snapshots also have been studied outside the context of recovery [1, 5, 38, 43, 67, 101, 162, 180]. Several fundamental properties regarding consistent global states have been derived [13, 16, 120, 131, 184].
Reference: [70] <author> M. Herlihy and M. McKendry. </author> <title> Timestamp-based orphan elimination. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> 15(7) </volume> <pages> 825-831, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Nett et al. addressed recovery problems in dynamic action models [126-128]. Kim et al. addressed recovery problems in the Programmer-Transparent Coordination (PTC) scheme [95, 97, 98]. Orphan elimination problem in nested transaction systems has also been studied <ref> [69, 70, 113] </ref>. Theoretical aspects of distributed snapshots also have been studied outside the context of recovery [1, 5, 38, 43, 67, 101, 162, 180]. Several fundamental properties regarding consistent global states have been derived [13, 16, 120, 131, 184].
Reference: [71] <author> C. A. R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <month> August </month> <year> 1978. </year>
Reference-contexts: Log-based rollback-recovery protocols have been traditionally called "message logging protocols." The association of nondeterministic events with messages is rooted in the earliest systems that implemented this style of recovery [23, 28]. These systems translated nondeterministic events into messages according to the CSP model <ref> [71] </ref>. It is important however to emphasize that these protocols are not only limited to message-passing systems. They have found applications in other style of interprocess communication, such as in distributed shared memory systems [37, 170, 197].
Reference: [72] <author> Y. Huang and C. Kintala. </author> <title> Software implemented fault tolerance: Technologies and experience. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 2-9, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: pessimistic logging must therefore resort to special techniques to reduce the effects of synchronous logging on performance. 4.1.2 Techniques for Reducing Performance Overhead The simplest form of pessimistic logging is to locally save in stable storage information about each event as it occurs and before it affects the application program <ref> [72, 73] </ref>. This form of logging potentially has a high performance overhead but allows each host to recover independently which is desirable in practical systems [74]. 19 Special hardware that assists logging can lower the overhead.
Reference: [73] <author> Y. Huang and C. Kintala. </author> <title> A software fault tolerance platform. In Practical Reusable Software, </title> <editor> Ed. B. </editor> <booktitle> Krishnamurthy, </booktitle> <pages> pages 223-245. </pages> <publisher> John Wiley & Sons, </publisher> <year> 1995. </year>
Reference-contexts: pessimistic logging must therefore resort to special techniques to reduce the effects of synchronous logging on performance. 4.1.2 Techniques for Reducing Performance Overhead The simplest form of pessimistic logging is to locally save in stable storage information about each event as it occurs and before it affects the application program <ref> [72, 73] </ref>. This form of logging potentially has a high performance overhead but allows each host to recover independently which is desirable in practical systems [74]. 19 Special hardware that assists logging can lower the overhead.
Reference: [74] <author> Y. Huang and Y. M. Wang. </author> <title> Why optimistic message logging has not been used in telecommunications systems. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 459-463, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: This form of logging potentially has a high performance overhead but allows each host to recover independently which is desirable in practical systems <ref> [74] </ref>. 19 Special hardware that assists logging can lower the overhead. This special hardware can take the form of a fast non-volatile semiconductor memory to implement stable storage [18, 163]. <p> These studies also indicate that the main difficulty in implementing these protocols lies in the complexity of handling recovery [48]. It is interesting that all commercial implementations of message logging use pessimistic logging because it simplifies recovery <ref> [29, 74] </ref>. Several recent studies have also challenged some premises which many rollback-recovery protocols rely on. Many of these protocols have been incepted in the 1980's.
Reference: [75] <author> G. G. Richard III and M. Singhal. </author> <title> Using logging and asynchronous checkpointing to implement recoverable distributed shared memory. </title> <booktitle> In Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 58-67, </pages> <year> 1993. </year>
Reference-contexts: Although most rollback-recovery techniques were originally designed for tolerating hardware failures, they have also been applied to software and protocol error recovery [169, 184, 190, 193]. Rollback-recovery in shared-memory and distributed shared-memory systems has also been extensively studied <ref> [4, 20, 54, 75, 80-83, 109, 132, 170, 197, 198] </ref>. This survey has covered mostly rollback-recovery techniques which do not require or take advantage of special linguistic supports.
Reference: [76] <author> S. Israel and D. Morris. </author> <title> A non-intrusive checkpointing protocol. </title> <booktitle> In The Phoenix Conference on Communications and Computers, </booktitle> <pages> pages 413-421, </pages> <year> 1989. </year>
Reference: [77] <author> P. Jalote. </author> <title> Fault tolerant processes. </title> <journal> Distributed Computing, </journal> <volume> 3 </volume> <pages> 187-195, </pages> <year> 1989. </year>
Reference-contexts: to this technique can tolerate more than one failure in special network topologies [91]. 4.1.3 Relaxing Logging Atomicity The performance overhead of pessimistic logging can be reduced by delivering a message or an event and deferring its logging until the host communicates with another host or with the outside world <ref> [77, 88] </ref>. In the example of Figure 11, process P 0 may defer the logging of message m 4 and m 7 until it needs to communicate with another process or the outside world. <p> Assume process P 0 fails after delivering m 4 and m 7 but before logging them. Process P 0 must receive these messages during recovery to be consistent with process P 1 . Some protocols that rely on the receiver to log the messages cannot retrieve these messages <ref> [77] </ref>. This problem does not occur in protocols that rely on sender logging or those that do not assume 20 reliable communication channels [50, 89]. 4.2 Optimistic Logging 4.2.1 Overview Unlike pessimistic logging protocols, optimistic logging protocols [87, 89, 91, 134, 157, 168] log messages asynchronously.
Reference: [78] <author> P. Jalote. </author> <title> Fault Tolerance in Distributed Systems. </title> <address> Englewood Cliffs, New Jersey:Prentice-Hall, </address> <year> 1994. </year>
Reference: [79] <author> P. Jalote and R. H. Campbell. </author> <title> Atomic actions for fault-tolerance using CSP. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> SE-12(1):59-68, </volume> <year> 1986. </year>
Reference-contexts: This survey has covered mostly rollback-recovery techniques which do not require or take advantage of special linguistic supports. A substantial amount of research efforts has also focused on coordinated recovery based on special language constructs such as recovery blocks and conversations <ref> [34, 65, 66, 79, 94, 96, 144, 145, 200] </ref>. Nett et al. addressed recovery problems in dynamic action models [126-128]. Kim et al. addressed recovery problems in the Programmer-Transparent Coordination (PTC) scheme [95, 97, 98]. Orphan elimination problem in nested transaction systems has also been studied [69, 70, 113].
Reference: [80] <author> G. Janakiraman and Y. Tamir. </author> <title> Coordinated checkpointing-rollback error recovery for distributed shared memory multicomputers. </title> <booktitle> In Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 42-51, </pages> <month> October </month> <year> 1994. </year>
Reference: [81] <author> B. Janssens and W. K. Fuchs. </author> <title> Experimental evaluation of multiprocessor cache-based error recovery. </title> <booktitle> In Proc. Int. Conf. Parallel Processing, </booktitle> <pages> pages I-505-I-508, </pages> <year> 1991. </year> <month> 39 </month>
Reference-contexts: involved processes is not able or not willing to take a checkpoint, then the entire coordination session is aborted; Kim and Park [93] proposed an improved scheme that allows the new checkpoints in some subtrees to be committed while the others are aborted. 3.3 Communication-induced Checkpointing 3.3.1 Overview Communication-induced checkpointing <ref> [81] </ref> is another way to avoid the domino effect in uncoordinated checkpointing protocols. A system-wide constraint on the checkpoint and communication pattern is specified to guarantee recovery line progression. Sufficient information is piggybacked on each message so that the receiver can examine the information prior to processing the message.
Reference: [82] <author> B. Janssens and W. K. Fuchs. </author> <title> Relaxing consistency in recoverable distributed shared memory. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 155-163, </pages> <month> June </month> <year> 1993. </year>
Reference: [83] <author> B. Janssens and W. K. Fuchs. </author> <title> Reducing interprocessor dependence in recoverable distributed shared memory. </title> <booktitle> In Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 34-41, </pages> <month> October </month> <year> 1994. </year>
Reference: [84] <author> D. P. Jasper. </author> <title> A discussion of checkpoint restart. </title> <booktitle> Software Age, </booktitle> <month> October </month> <year> 1969. </year>
Reference: [85] <author> D. R. Jefferson. </author> <title> Virtual time. </title> <journal> Trans. on Programming Languages and Systems, </journal> <volume> 7(3) </volume> <pages> 404-425, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: In the area of distributed discrete-event simulation [59, 124], the Time Warp optimistic approach, which inspired the seminal work on optimistic message logging [168], 34 uses rollbacks to cancel erroneous computations due to the out-of-order arrivals of time-stamped event messages <ref> [59, 60, 85, 118, 141] </ref>. 7 Conclusions We have reviewed and compared different approaches to rollback-recovery with respect to a set of properties including the assumption of piecewise determinism, performance overhead, storage overhead, ease of output commit, ease of garbage collection, ease of recovery, freedom from domino effect, freedom from orphan
Reference: [86] <author> D. B. Johnson. </author> <title> Distributed system fault tolerance using message logging and checkpointing. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Rice University, </institution> <month> December </month> <year> 1989. </year>
Reference-contexts: The storage overhead of this method is very low, and it can be adjusted depending on how many failures the system is willing to tolerate [137]. 5.2.2 System-level versus User-level Implementations Support for checkpointing can be implemented in the kernel <ref> [48, 86, 135] </ref>, or it can be implemented by a library linked with the user program [62, 106, 136, 159, 165, 191]. Kernel-level implementations are more powerful because they can also capture kernel data structures that support the checkpointed process. However, these implementations are necessarily not portable. <p> The first is the simplest and consists of tagging the message with an index or a sequence number <ref> [86] </ref>. Dependency tracking also can take the form of piggybacking a vector or a graph on top of each message. There are techniques for optimizing these forms of tracking by exploiting the semantics of the communication system and by piggybacking only incremental changes over application messages.
Reference: [87] <author> D. B. Johnson. </author> <title> Efficient transparent optimistic rollback recovery for distributed application programs. </title> <booktitle> In Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 86-95, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: This problem does not occur in protocols that rely on sender logging or those that do not assume 20 reliable communication channels [50, 89]. 4.2 Optimistic Logging 4.2.1 Overview Unlike pessimistic logging protocols, optimistic logging protocols <ref> [87, 89, 91, 134, 157, 168] </ref> log messages asynchronously. These protocols make the optimistic assumption that logging will complete before a failure occurs. A volatile log contains information about the events to be logged, and is flushed to stable storage periodically. <p> Transitive dependency tracking generally incurs a higher failure-free overhead for piggybacking and maintaining the dependency vectors, but allows faster output commit and recovery <ref> [87] </ref>. In asynchronous recovery, a failed process restarts by sending a rollback announcement broadcast [160] (or recovery message [168]) to start a new incarnation. <p> In practice, it is important to support systems consisting of both deterministic and nondeterministic processes <ref> [87, 90] </ref>. One challenge is to handle unreplayable nondeterministic events while still preserving the advantages of piecewise determinism [41, 184, 190]. Although most rollback-recovery techniques were originally designed for tolerating hardware failures, they have also been applied to software and protocol error recovery [169, 184, 190, 193].
Reference: [88] <author> D. B. Johnson and W. Zwaenepoel. </author> <title> Sender-based message logging. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 14-19, </pages> <year> 1987. </year>
Reference-contexts: Stable storage must ensure that the data stored will persist through the tolerated failure modes. Therefore, in a system that tolerates a single failure, stable storage may consist of the volatile memory of another process <ref> [29, 88] </ref>. A system that wishes to tolerate an arbitrary number of transient failures can implement stable storage by storing information on a reliable disk local to each host. <p> This scheme, however, requires that all nondeterministic events be converted into external messages [23, 29]. Some pessimistic logging systems reduce the overhead of synchronous logging without relying on hardware. For example, the sender-based message logging (SBML) protocol logs each message at the sender in volatile memory <ref> [88] </ref>. A receiver of a message sends an acknowledgment to the sender including the order in which the message is received. The sender includes the receipt order in the log. The log thus contains the information necessary to help the receiver recover from future failures should they occur. <p> to this technique can tolerate more than one failure in special network topologies [91]. 4.1.3 Relaxing Logging Atomicity The performance overhead of pessimistic logging can be reduced by delivering a message or an event and deferring its logging until the host communicates with another host or with the outside world <ref> [77, 88] </ref>. In the example of Figure 11, process P 0 may defer the logging of message m 4 and m 7 until it needs to communicate with another process or the outside world.
Reference: [89] <author> D. B. Johnson and W. Zwaenepoel. </author> <title> Recovery in distributed systems using optimistic message logging and checkpointing. </title> <journal> J. Algorithms, </journal> <volume> 11 </volume> <pages> 462-491, </pages> <year> 1990. </year>
Reference-contexts: As a result, the surviving process P 0 becomes an orphan process and is forced to roll back as well. As indicated in Figure 5, process states X, Y and Z then form the maximum recoverable state <ref> [89] </ref>, i.e., the most recent recoverable consistent system state. Process P 0 (P 2 ) rolls back to checkpoint A (C) and replays message m 4 (m 2 ) to reach X (Z). <p> Some protocols that rely on the receiver to log the messages cannot retrieve these messages [77]. This problem does not occur in protocols that rely on sender logging or those that do not assume 20 reliable communication channels <ref> [50, 89] </ref>. 4.2 Optimistic Logging 4.2.1 Overview Unlike pessimistic logging protocols, optimistic logging protocols [87, 89, 91, 134, 157, 168] log messages asynchronously. These protocols make the optimistic assumption that logging will complete before a failure occurs. <p> This problem does not occur in protocols that rely on sender logging or those that do not assume 20 reliable communication channels [50, 89]. 4.2 Optimistic Logging 4.2.1 Overview Unlike pessimistic logging protocols, optimistic logging protocols <ref> [87, 89, 91, 134, 157, 168] </ref> log messages asynchronously. These protocols make the optimistic assumption that logging will complete before a failure occurs. A volatile log contains information about the events to be logged, and is flushed to stable storage periodically. <p> During failure-free execution, each process increments its state interval index at the beginning of each state interval. Dependency tracking can be either direct or transitive. In direct dependency tracking <ref> [89, 157] </ref>, the current index of a message sender is piggybacked on each outgoing message to allow the 21 receiver to record the dependency directly caused by the message. These direct dependencies can then be assembled at recovery time to obtain complete dependency information.
Reference: [90] <author> D. B. Johnson and W. Zwaenepoel. </author> <title> Transparent optimistic rollback recovery. </title> <journal> ACM Oper. Syst. Review, </journal> <pages> pages 99-102, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: In practice, it is important to support systems consisting of both deterministic and nondeterministic processes <ref> [87, 90] </ref>. One challenge is to handle unreplayable nondeterministic events while still preserving the advantages of piecewise determinism [41, 184, 190]. Although most rollback-recovery techniques were originally designed for tolerating hardware failures, they have also been applied to software and protocol error recovery [169, 184, 190, 193].
Reference: [91] <author> T. T-Y. Juang and S. Venkatesan. </author> <title> Crash recovery with little overhead. </title> <booktitle> In Proc. IEEE Int. Conf. Distributed Comput. Syst., </booktitle> <pages> pages 454-461, </pages> <year> 1991. </year>
Reference-contexts: It is based on the observation that piecewise determinism can be modeled as having a logical checkpoint <ref> [91, 179, 190] </ref> before every nondeterministic event. Therefore, checkpoint-based rollback recovery can mimic piecewise determinism by taking an actual checkpoint before every nondeterministic event. The main challenge is how to reduce the number of checkpoints while still preserving desirable properties. <p> This scheme avoids the overhead of accessing stable storage but it can tolerate only one failure and cannot accommodate nondeterministic events internal to a process. Extensions to this technique can tolerate more than one failure in special network topologies <ref> [91] </ref>. 4.1.3 Relaxing Logging Atomicity The performance overhead of pessimistic logging can be reduced by delivering a message or an event and deferring its logging until the host communicates with another host or with the outside world [77, 88]. <p> This problem does not occur in protocols that rely on sender logging or those that do not assume 20 reliable communication channels [50, 89]. 4.2 Optimistic Logging 4.2.1 Overview Unlike pessimistic logging protocols, optimistic logging protocols <ref> [87, 89, 91, 134, 157, 168] </ref> log messages asynchronously. These protocols make the optimistic assumption that logging will complete before a failure occurs. A volatile log contains information about the events to be logged, and is flushed to stable storage periodically.
Reference: [92] <author> M. F. Kaashoek, R. Michiels, H. E. Bal, and A. S. Tanenbaum. </author> <title> Transparent fault-tolerance in parallel Orca programs. </title> <type> Technical Report IR-258, </type> <institution> Vrije Universiteit, </institution> <address> Amsterdam, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: The simplest way to save the state of a process is to suspend it, save its address space on stable storage, and then resume it <ref> [92, 99, 106, 114, 159, 194] </ref>. This scheme can be costly for programs with large address spaces if stable storage is implemented using magnetic disks as it is the custom.
Reference: [93] <author> J. L. Kim and T. Park. </author> <title> An efficient protocol for checkpointing recovery in distributed systems. </title> <journal> IEEE Trans. Parallel and Distributed Syst., </journal> <volume> 4(8) </volume> <pages> 955-960, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: Interprocess communication has to be blocked during this protocol as explained before. In Koo and Toueg's original scheme, if any of the involved processes is not able or not willing to take a checkpoint, then the entire coordination session is aborted; Kim and Park <ref> [93] </ref> proposed an improved scheme that allows the new checkpoints in some subtrees to be committed while the others are aborted. 3.3 Communication-induced Checkpointing 3.3.1 Overview Communication-induced checkpointing [81] is another way to avoid the domino effect in uncoordinated checkpointing protocols.
Reference: [94] <author> K. H. Kim. </author> <title> Approaches to mechanization of the conversation scheme based on monitors. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> SE-8(3):189-197, </volume> <month> May </month> <year> 1982. </year>
Reference-contexts: This survey has covered mostly rollback-recovery techniques which do not require or take advantage of special linguistic supports. A substantial amount of research efforts has also focused on coordinated recovery based on special language constructs such as recovery blocks and conversations <ref> [34, 65, 66, 79, 94, 96, 144, 145, 200] </ref>. Nett et al. addressed recovery problems in dynamic action models [126-128]. Kim et al. addressed recovery problems in the Programmer-Transparent Coordination (PTC) scheme [95, 97, 98]. Orphan elimination problem in nested transaction systems has also been studied [69, 70, 113].
Reference: [95] <author> K. H. Kim. </author> <title> Programmer-transparent coordination of recovering concurrent processes: Philosophy and rules for efficient implementation. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> 14(6) </volume> <pages> 810-821, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Nett et al. addressed recovery problems in dynamic action models [126-128]. Kim et al. addressed recovery problems in the Programmer-Transparent Coordination (PTC) scheme <ref> [95, 97, 98] </ref>. Orphan elimination problem in nested transaction systems has also been studied [69, 70, 113]. Theoretical aspects of distributed snapshots also have been studied outside the context of recovery [1, 5, 38, 43, 67, 101, 162, 180].
Reference: [96] <author> K. H. Kim. </author> <title> The distributed recovery block scheme. In Software Fault Tolerance, </title> <editor> Ed. M. R. </editor> <booktitle> Lyu, </booktitle> <pages> pages 189-209. </pages> <publisher> John Wiley & Sons, </publisher> <year> 1995. </year>
Reference-contexts: This survey has covered mostly rollback-recovery techniques which do not require or take advantage of special linguistic supports. A substantial amount of research efforts has also focused on coordinated recovery based on special language constructs such as recovery blocks and conversations <ref> [34, 65, 66, 79, 94, 96, 144, 145, 200] </ref>. Nett et al. addressed recovery problems in dynamic action models [126-128]. Kim et al. addressed recovery problems in the Programmer-Transparent Coordination (PTC) scheme [95, 97, 98]. Orphan elimination problem in nested transaction systems has also been studied [69, 70, 113].
Reference: [97] <author> K. H. Kim and J. H. </author> <title> You. A highly decentralized implementation model for the Programmer-Transparent Coordination (PTC) scheme for cooperative recovery. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 282-289, </pages> <year> 1990. </year>
Reference-contexts: Nett et al. addressed recovery problems in dynamic action models [126-128]. Kim et al. addressed recovery problems in the Programmer-Transparent Coordination (PTC) scheme <ref> [95, 97, 98] </ref>. Orphan elimination problem in nested transaction systems has also been studied [69, 70, 113]. Theoretical aspects of distributed snapshots also have been studied outside the context of recovery [1, 5, 38, 43, 67, 101, 162, 180].
Reference: [98] <author> K. H. Kim, J. H. You, and A. Abouelnaga. </author> <title> A scheme for coordinated execution of independently designed recoverable distributed processes. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 130-135, </pages> <year> 1986. </year>
Reference-contexts: Such a model, called an MRS model, can be maintained by taking an additional checkpoint before every message-receiving event that is not separated from its previous message-sending event by a checkpoint [2, 184]. In the Programmer-Transparent Coordination (PTC) scheme <ref> [98] </ref>, Kim et al. proved that the domino effect can be eliminated if each process takes an additional checkpoint before processing any message that will cause the process to depend on a checkpoint that it did not previously depend on. <p> Nett et al. addressed recovery problems in dynamic action models [126-128]. Kim et al. addressed recovery problems in the Programmer-Transparent Coordination (PTC) scheme <ref> [95, 97, 98] </ref>. Orphan elimination problem in nested transaction systems has also been studied [69, 70, 113]. Theoretical aspects of distributed snapshots also have been studied outside the context of recovery [1, 5, 38, 43, 67, 101, 162, 180].
Reference: [99] <author> B. A. Kingsbury and J. T. Kline. </author> <title> Job and process recovery in a UNIX-based operating system. </title> <booktitle> In Usenix Association, Winter Conference Proceedings, </booktitle> <year> 1989, </year> <pages> pages 355-364, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: The simplest way to save the state of a process is to suspend it, save its address space on stable storage, and then resume it <ref> [92, 99, 106, 114, 159, 194] </ref>. This scheme can be costly for programs with large address spaces if stable storage is implemented using magnetic disks as it is the custom.
Reference: [100] <author> R. Koo and S. Toueg. </author> <title> Checkpointing and rollback-recovery for distributed systems. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> SE-13(1):23-31, </volume> <month> January </month> <year> 1987. </year>
Reference-contexts: When it is desirable to minimize the number of processes involved in a rollback, the general recovery line calculation algorithms based on dependency tracking (as describe in Section 3.1) can still be applied <ref> [100] </ref>. 3.2.2 Nonblocking Checkpoint Coordination Instead of blocking interprocess communications, an alternative is to shift the responsibility of maintaining checkpoint consistency from the sender side to the receiver side. <p> Only those processes that have communicated with the checkpoint initiator either directly or indirectly since the last checkpoint need to take new checkpoints <ref> [21, 100] </ref>. The following two-phase protocol is due to Koo and Toueg [100]. During the first phase, the checkpoint initiator sends a request to all processes with which it has communicated since the last checkpoint. <p> Only those processes that have communicated with the checkpoint initiator either directly or indirectly since the last checkpoint need to take new checkpoints [21, 100]. The following two-phase protocol is due to Koo and Toueg <ref> [100] </ref>. During the first phase, the checkpoint initiator sends a request to all processes with which it has communicated since the last checkpoint.
Reference: [101] <author> T. H. Lai and T. H. Yang. </author> <title> On distributed snapshots. </title> <journal> Information Processing Letters, </journal> <volume> 25 </volume> <pages> 153-158, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: nonblocking checkpoint coordination protocol. (The checkpoint request message is called a marker in their paper.) Note that, since we only need the checkpoint request to be processed before any post-checkpoint messages, checkpoint request can be piggybacked on every post-checkpoint message m and examined by the receiver before m is processed <ref> [101] </ref>, as shown in Figure 10 (c). This modification also allows non-FIFO channels. <p> Upon receiving a message with piggybacked index greater than the local index, the receiver is forced to take a checkpoint before processing the message to avoid inconsistency at the last minute <ref> [33, 101] </ref>. The lazy coordination protocol described above has two disadvantages. First, the induced checkpoints push the checkpoint indices at some processes higher which may cause more induced checkpoints to be taken and, in the worst case, result in an excessive number of induced checkpoints. <p> Kim et al. addressed recovery problems in the Programmer-Transparent Coordination (PTC) scheme [95, 97, 98]. Orphan elimination problem in nested transaction systems has also been studied [69, 70, 113]. Theoretical aspects of distributed snapshots also have been studied outside the context of recovery <ref> [1, 5, 38, 43, 67, 101, 162, 180] </ref>. Several fundamental properties regarding consistent global states have been derived [13, 16, 120, 131, 184]. Vector timestamps [55, 121, 151, 155] and the context graph used in em Psync [133] bear similarities to the various dependency tracking techniques.
Reference: [102] <author> L. Lamport. </author> <title> Time, clocks and the ordering of events in a distributed system. </title> <journal> Commun. ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: Consider the example in Figure 14 (a). While messages m 5 and m 6 may be lost upon the failure, process P 0 at state X would have information about the nondeterministic events that precede its state in causal order according to Lamport's happened-before relation <ref> [102] </ref>. These events consist of the receipts of messages m 0 , m 1 , m 2 , m 3 and m 4 . The information about each of these nondeterministic events is either logged on stable storage or is available locally to process P 0 .
Reference: [103] <author> B. W. Lampson and H. E. Sturgis. </author> <title> Crash recovery in a distributed data storage system. </title> <type> Technical report, </type> <institution> Xerox Palo Alto Research Center, </institution> <month> April </month> <year> 1979. </year>
Reference-contexts: And a system that tolerates non-transient failures must ensure that the recovery information related to a particular process is always stored on a persistent medium outside the host on which the process is running. A highly-available file system can be used in that case <ref> [103] </ref>. Independent of the technique that implements stable storage, we call an event or a message fully logged if it has been stored such that it would persist the tolerated failures in the system. 2.7 Garbage Collection Checkpoints and event logs consume storage resources.
Reference: [104] <author> T. J. LeBlanc and J. M. Mellor-Crummey. </author> <title> Debugging parallel programs with Instant Replay. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(4):471-482, </volume> <month> April </month> <year> 1987. </year>
Reference-contexts: Prototype implementations have shown that the overhead resulting from tracking is negligible compared to the overhead of checkpointing or logging [48]. 33 5.8 Recovery Handling execution restart and replay is a difficult part of implementing a rollback-recovery system <ref> [48, 104] </ref>. Implanting a process in a different environment during recovery can create difficulties if its state depends on the pre-failure environment. For example, the process may need to access files that exist on the local disk of the machine.
Reference: [105] <author> P. A. Lee and T. Anderson. </author> <title> Fault Tolerance Principles and Practice. </title> <publisher> Wien: Springer-Verlag, </publisher> <year> 1990. </year>
Reference: [106] <author> J. Leon, A. L. Fisher, and P. Steenkiste. </author> <title> Fail-safe PVM: A portable package for distributed programming with transparent recovery. </title> <type> Technical Report CMU-CS-93-124, </type> <institution> Department of Computer Science, Carnegie Mellon University, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Recently, processor speed and network bandwidth have increased dramatically, while the speed of stable storage access has remained relatively the same. 3 This change in the equation suggests a fresh look at the premises of many rollback-recovery protocols. Specifically, recent results have shown that <ref> [53, 106, 135] </ref>: * Stable storage access is now the major source of overhead in checkpointing systems. Communication overhead is much lower in comparison. <p> The simplest way to save the state of a process is to suspend it, save its address space on stable storage, and then resume it <ref> [92, 99, 106, 114, 159, 194] </ref>. This scheme can be costly for programs with large address spaces if stable storage is implemented using magnetic disks as it is the custom. <p> is very low, and it can be adjusted depending on how many failures the system is willing to tolerate [137]. 5.2.2 System-level versus User-level Implementations Support for checkpointing can be implemented in the kernel [48, 86, 135], or it can be implemented by a library linked with the user program <ref> [62, 106, 136, 159, 165, 191] </ref>. Kernel-level implementations are more powerful because they can also capture kernel data structures that support the checkpointed process. However, these implementations are necessarily not portable. Checkpointing can also be implemented in user level.
Reference: [107] <author> H. V. Leong and D. Agrawal. </author> <title> Using message semantics to reduce rollback in optimistic message logging recovery schemes. </title> <booktitle> In Proc. IEEE Int. Conf. Distributed Comput. Syst., </booktitle> <pages> pages 227-234, </pages> <year> 1994. </year>
Reference: [108] <author> C. C. Li and W. K. Fuchs. </author> <title> CATCH: Compiler-assisted techniques for checkpointing. </title> <booktitle> In Proceedings of the 20th International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 74-81, </pages> <year> 1990. </year>
Reference-contexts: User-level implementations however cannot access kernel's data structures that belong to the process such as open file descriptors and message buffers, but these data structures can be emulated at user level [149, 191]. 5.2.3 Compiler Support A compiler can be instrumented to generate code that supports checkpointing <ref> [108] </ref>. A compiled program would contain code that decides when and what to checkpoint. The advantage of this technique is that the compiler can decide on the variables that must be checkpointed, therefore avoiding saving unnecessary data. <p> The programmer could provide hints to the compiler about where checkpoints could be inserted or what data variables should be stored [24, 138, 152]. The compiler may also be trained by running the application in an iterative manner and observing its behavior <ref> [108] </ref>. The observed behavior could help decide the execution points where it would be appropriate to insert checkpoints. Compiler support could also be simplified in languages that support automatic garbage collection [9].
Reference: [109] <author> K. Li, J. F. Naughton, and J. S. Plank. </author> <title> Real-time, concurrent checkpointing for parallel programs. </title> <booktitle> In Proc. 2nd ACM SIGPLAN Symp. on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 79-88, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Although most rollback-recovery techniques were originally designed for tolerating hardware failures, they have also been applied to software and protocol error recovery [169, 184, 190, 193]. Rollback-recovery in shared-memory and distributed shared-memory systems has also been extensively studied <ref> [4, 20, 54, 75, 80-83, 109, 132, 170, 197, 198] </ref>. This survey has covered mostly rollback-recovery techniques which do not require or take advantage of special linguistic supports.
Reference: [110] <author> K. Li, J. F. Naughton, and J. S. Plank. </author> <title> Checkpointing multicomputer applications. </title> <booktitle> In Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 2-11, </pages> <year> 1991. </year>
Reference: [111] <author> K. Li, J. F. Naughton, and J. S. Plank. </author> <title> An efficient checkpointing method for multicomputers with wormhole routing. </title> <booktitle> Int. J. of Parallel Program., </booktitle> <volume> 20(3) </volume> <pages> 159-180, </pages> <month> June </month> <year> 1992. </year>
Reference: [112] <author> L. Lin and M. Ahamad. </author> <title> Checkpointing and rollback-recovery in distributed object based systems. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 97-104, </pages> <year> 1990. </year>
Reference: [113] <author> B. Liskov, R. Scheifler, E. Walker, and W. Weihl. </author> <title> Orphan detection. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 2-7, </pages> <year> 1987. </year>
Reference-contexts: Nett et al. addressed recovery problems in dynamic action models [126-128]. Kim et al. addressed recovery problems in the Programmer-Transparent Coordination (PTC) scheme [95, 97, 98]. Orphan elimination problem in nested transaction systems has also been studied <ref> [69, 70, 113] </ref>. Theoretical aspects of distributed snapshots also have been studied outside the context of recovery [1, 5, 38, 43, 67, 101, 162, 180]. Several fundamental properties regarding consistent global states have been derived [13, 16, 120, 131, 184].
Reference: [114] <author> M. Litzkow and M. Solomon. </author> <title> Supporting checkpointing and process migration outside the unix kernel. </title> <booktitle> In Usenix Winter 1992 Technical Conference, </booktitle> <pages> pages 283-290, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: The simplest way to save the state of a process is to suspend it, save its address space on stable storage, and then resume it <ref> [92, 99, 106, 114, 159, 194] </ref>. This scheme can be costly for programs with large address spaces if stable storage is implemented using magnetic disks as it is the custom.
Reference: [115] <author> J. Long, W. K. Fuchs, and J. A. Abraham. </author> <title> Compiler-assisted static checkpoint insertion. </title> <booktitle> In Proceedings of the Twenty Second Annual International Symposium on Fault-Tolerant Computing, FTCS-22, </booktitle> <pages> pages 58-65, </pages> <month> July </month> <year> 1992. </year>
Reference: [116] <author> A. Lowry, J. R. Russell, and A. P. Goldberg. </author> <title> Optimistic failure recovery for very large networks. </title> <booktitle> In Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 66-75, </pages> <year> 1991. </year>
Reference: [117] <author> A. Lowry and R. E. Strom. </author> <title> Some problems with optimistic recovery and their solutions. </title> <type> Personal communications, </type> <month> December </month> <year> 1992. </year>
Reference-contexts: It was pointed out that Strom and Yemini's original protocol suffers from the exponential rollbacks problem [157]. Three approaches have been proposed to eliminate the problem by ensuring that any process will roll back at most once in response to a single failure. The protocol by Lowry and Strom <ref> [117] </ref> piggybacks the original rollback announcement from the failed process on every subsequent rollback announcement that it triggers. For example, in Figure 13, process P 1 piggybacks r 0 on r 1 .
Reference: [118] <author> V. Madisetti, J. Walrand, and D. Messerschmitt. WOLF: </author> <title> A rollback algorithm for optimistic distributed simulation systems. </title> <booktitle> In Simulation Conference Proceedings, </booktitle> <pages> pages 296-305, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: In the area of distributed discrete-event simulation [59, 124], the Time Warp optimistic approach, which inspired the seminal work on optimistic message logging [168], 34 uses rollbacks to cancel erroneous computations due to the out-of-order arrivals of time-stamped event messages <ref> [59, 60, 85, 118, 141] </ref>. 7 Conclusions We have reviewed and compared different approaches to rollback-recovery with respect to a set of properties including the assumption of piecewise determinism, performance overhead, storage overhead, ease of output commit, ease of garbage collection, ease of recovery, freedom from domino effect, freedom from orphan
Reference: [119] <author> D. Manivannan and M. Singhal. </author> <title> A low-overhead recovery technique using quasi-synchronous check-pointing. </title> <booktitle> In Proc. IEEE Int. Conf. Distributed Comput. Syst., </booktitle> <pages> pages 100-107, </pages> <year> 1996. </year>
Reference-contexts: When a system specifies the laziness to be Z, only checkpoints with the same index which is a multiple of Z are required to be consistent. By increasing the laziness, additional checkpoint overhead can be reduced at the expense of a potentially larger rollback distance. Manivannan and Singhal <ref> [119] </ref> presented a quasi-synchronous checkpointing algorithm to reduce the number of forced checkpoints. Every process increments its next-to-be-assigned checkpoint index at the same regular time interval to keep the index of the latest checkpoint of each process close to each other.
Reference: [120] <author> D. Manivannan and M. Singhal. </author> <title> Quasi-synchronous checkpointing: Models, characterization, and classification. </title> <type> Tech. Rep. </type> <institution> No. OSU-CISRC-5/96-TR33, Dept. of Computer and Information Science, Ohio State University, </institution> <year> 1996. </year> <month> 41 </month>
Reference-contexts: Orphan elimination problem in nested transaction systems has also been studied [69, 70, 113]. Theoretical aspects of distributed snapshots also have been studied outside the context of recovery [1, 5, 38, 43, 67, 101, 162, 180]. Several fundamental properties regarding consistent global states have been derived <ref> [13, 16, 120, 131, 184] </ref>. Vector timestamps [55, 121, 151, 155] and the context graph used in em Psync [133] bear similarities to the various dependency tracking techniques. Check-pointing and message logging can also be used to facilitate the debugging of parallel and distributed programs [57, 63, 129, 130].
Reference: [121] <author> F. Mattern. </author> <title> Virtual time and global states of distributed systems. </title> <booktitle> In Proc. Workshop on Parallel and Distributed Algorithms, </booktitle> <pages> pages 215-226, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: Theoretical aspects of distributed snapshots also have been studied outside the context of recovery [1, 5, 38, 43, 67, 101, 162, 180]. Several fundamental properties regarding consistent global states have been derived [13, 16, 120, 131, 184]. Vector timestamps <ref> [55, 121, 151, 155] </ref> and the context graph used in em Psync [133] bear similarities to the various dependency tracking techniques. Check-pointing and message logging can also be used to facilitate the debugging of parallel and distributed programs [57, 63, 129, 130].
Reference: [122] <author> J. M. Mellor-Crummey and T. J. LeBlanc. </author> <title> A software instruction counter. </title> <booktitle> Proceedings of the 3rd Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 78-86, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Execution proceeds until an event of interest occurs, at which time the content of the counter is sampled, and the number of instructions executed since the time the counter was set is computed. The use of instruction counters has been suggested for debugging shared memory parallel programs <ref> [36, 122, 148] </ref>. Instruction counters can be used in rollback-recovery to track the number of instructions that occur between asynchronous interrupts. A replay system can use the instruction count to force the execution of the same number of instructions between asynchronous interrupts. <p> A replay system can use the instruction count to force the execution of the same number of instructions between asynchronous interrupts. An instruction counter can be implemented in hardware, such as in the PA-RISC precision architecture. It also can be emulated in software <ref> [122] </ref>. A recent implementation on a DEC 3000/400 workstation shows that the overhead of program instrumentation and tracking nondeterminism is less than 6% for a variety of user programs and synthetic benchmarks [158]. 5.7 Dependency Tracking There are three forms for implementing dependency tracking.
Reference: [123] <author> P. M. Merlin and B. Randell. </author> <title> State restoration in distributed systems. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 129-134, </pages> <month> June </month> <year> 1978. </year>
Reference: [124] <author> J. Misra. </author> <title> Distributed discrete-event simulation. </title> <journal> ACM Computing Surveys, </journal> <volume> 18(1) </volume> <pages> 39-65, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: Systems that decouple logging of an event from its delivery may be susceptible to losing the last messages that were delivered before a failure (an instance of the "last message problem" <ref> [124] </ref>). This problem occurs only in systems where the communication channels are assumed to be reliable. Consider the example in Figure 11. Assume process P 0 fails after delivering m 4 and m 7 but before logging them. <p> Check-pointing and message logging can also be used to facilitate the debugging of parallel and distributed programs [57, 63, 129, 130]. In the area of distributed discrete-event simulation <ref> [59, 124] </ref>, the Time Warp optimistic approach, which inspired the seminal work on optimistic message logging [168], 34 uses rollbacks to cancel erroneous computations due to the out-of-order arrivals of time-stamped event messages [59, 60, 85, 118, 141]. 7 Conclusions We have reviewed and compared different approaches to rollback-recovery with respect
Reference: [125] <author> G. Muller, M. Hue, and N. Peyrouz. </author> <title> Performance of consistent checkpointing in a modular operating system: Results of the FTM experiment. </title> <booktitle> Lecture Notes in Computer Science: Dependable Computing-EDCC-1, </booktitle> <pages> pages 491-508, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: Furthermore, the memory available to run processes tended to be small. These tradeoffs naturally favored uncoordinated checkpointing schemes over coordinated checkpointing schemes. Current technological trends however have reversed this tradeoff. In modern systems, the overhead of coordinating checkpoints is negligible compared to the overhead of saving the states <ref> [50, 125] </ref>. Using concurrent and incremental checkpointing, the overhead of either coordinated or uncoordinated checkpointing is essentially the same. Therefore, uncoordinated checkpointing is not likely to be an attractive technique in practice given the negligible performance gains.
Reference: [126] <author> E. Nett. </author> <title> The recovery problem in distributed systems. </title> <booktitle> In Proc. Workshop on the Future Trends of Distributed Computing Systems in the 1990's, </booktitle> <pages> pages 357-365, </pages> <year> 1988. </year>
Reference: [127] <author> E. Nett, R. Kroger, and J. Kaiser. </author> <title> Implementing a general error recovery mechanism in a distributed operating system. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 124-129, </pages> <year> 1986. </year>
Reference: [128] <author> E. Nett and B. Weiler. </author> <title> Nested dynamic actions How to solve the fault containment problem in a cooperative action model. </title> <booktitle> In Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 106-115, </pages> <year> 1994. </year>
Reference: [129] <author> R. H. B. Netzer and B. P. Miller. </author> <title> Optimal tracing and replay for debugging message-passing parallel programs. </title> <booktitle> In Proc. Supercomputing '92, </booktitle> <pages> pages 502-511, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Vector timestamps [55, 121, 151, 155] and the context graph used in em Psync [133] bear similarities to the various dependency tracking techniques. Check-pointing and message logging can also be used to facilitate the debugging of parallel and distributed programs <ref> [57, 63, 129, 130] </ref>.
Reference: [130] <author> R. H. B. Netzer and J. Xu. </author> <title> Adaptive message logging for incremental program replay. </title> <journal> IEEE Parallel and Distributed Technology, </journal> <volume> 1(4) </volume> <pages> 32-39, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: Vector timestamps [55, 121, 151, 155] and the context graph used in em Psync [133] bear similarities to the various dependency tracking techniques. Check-pointing and message logging can also be used to facilitate the debugging of parallel and distributed programs <ref> [57, 63, 129, 130] </ref>.
Reference: [131] <author> R. H. B. Netzer and J. Xu. </author> <title> Necessary and sufficient conditions for consistent global snapshots. </title> <journal> IEEE Trans. Parallel and Distributed Syst., </journal> <volume> 6(2) </volume> <pages> 165-169, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: Orphan elimination problem in nested transaction systems has also been studied [69, 70, 113]. Theoretical aspects of distributed snapshots also have been studied outside the context of recovery [1, 5, 38, 43, 67, 101, 162, 180]. Several fundamental properties regarding consistent global states have been derived <ref> [13, 16, 120, 131, 184] </ref>. Vector timestamps [55, 121, 151, 155] and the context graph used in em Psync [133] bear similarities to the various dependency tracking techniques. Check-pointing and message logging can also be used to facilitate the debugging of parallel and distributed programs [57, 63, 129, 130].
Reference: [132] <author> N. Neves, M. Castro, and P. Guedes. </author> <title> A checkpointing protocol for an entry consistent shared memory system. </title> <booktitle> In Proc. 13th ACM Symp. on Principles of Distr. Computing, </booktitle> <year> 1994. </year>
Reference-contexts: Although most rollback-recovery techniques were originally designed for tolerating hardware failures, they have also been applied to software and protocol error recovery [169, 184, 190, 193]. Rollback-recovery in shared-memory and distributed shared-memory systems has also been extensively studied <ref> [4, 20, 54, 75, 80-83, 109, 132, 170, 197, 198] </ref>. This survey has covered mostly rollback-recovery techniques which do not require or take advantage of special linguistic supports.
Reference: [133] <author> L. L. Peterson, N. C. Buchholz, and R. D. Schlichting. </author> <title> Preserving and using context information in interprocess communication. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 7(3) </volume> <pages> 217-246, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: Several fundamental properties regarding consistent global states have been derived [13, 16, 120, 131, 184]. Vector timestamps [55, 121, 151, 155] and the context graph used in em Psync <ref> [133] </ref> bear similarities to the various dependency tracking techniques. Check-pointing and message logging can also be used to facilitate the debugging of parallel and distributed programs [57, 63, 129, 130].
Reference: [134] <author> S. L. Peterson and P. Kearns. </author> <title> Rollback based on vector time. </title> <booktitle> In Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 68-77, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: This problem does not occur in protocols that rely on sender logging or those that do not assume 20 reliable communication channels [50, 89]. 4.2 Optimistic Logging 4.2.1 Overview Unlike pessimistic logging protocols, optimistic logging protocols <ref> [87, 89, 91, 134, 157, 168] </ref> log messages asynchronously. These protocols make the optimistic assumption that logging will complete before a failure occurs. A volatile log contains information about the events to be logged, and is flushed to stable storage periodically.
Reference: [135] <author> J. S. Plank. </author> <title> Efficient Checkpointing on MIMD Architectures. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Princeton University, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: Recently, processor speed and network bandwidth have increased dramatically, while the speed of stable storage access has remained relatively the same. 3 This change in the equation suggests a fresh look at the premises of many rollback-recovery protocols. Specifically, recent results have shown that <ref> [53, 106, 135] </ref>: * Stable storage access is now the major source of overhead in checkpointing systems. Communication overhead is much lower in comparison. <p> In the remainder of this section, we address these issues in some detail. 5.2 Checkpointing All available studies have shown that writing the state of a process to stable storage is an important contributor to the performance overhead <ref> [135] </ref>. The simplest way to save the state of a process is to suspend it, save its address space on stable storage, and then resume it [92, 99, 106, 114, 159, 194]. <p> The storage overhead of this method is very low, and it can be adjusted depending on how many failures the system is willing to tolerate [137]. 5.2.2 System-level versus User-level Implementations Support for checkpointing can be implemented in the kernel <ref> [48, 86, 135] </ref>, or it can be implemented by a library linked with the user program [62, 106, 136, 159, 165, 191]. Kernel-level implementations are more powerful because they can also capture kernel data structures that support the checkpointed process. However, these implementations are necessarily not portable.
Reference: [136] <author> J. S. Plank, M. Beck, G. Kingsley, and K. Li. Libckpt: </author> <title> Transparent checkpointing under Unix. </title> <booktitle> In Proc. Usenix Technical Conference, </booktitle> <pages> pages 213-224, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: Incremental checkpointing avoids rewriting portions of the process states that do not change between consecutive checkpoints. It can be implemented by using the dirty-bit of the memory protection hardware or by emulating a dirty-bit in software [12]. A public domain package implementing these techniques is available <ref> [136] </ref>. Incremental checkpointing can also be extended over several processes. In this technique, the system saves the computed parity or some function of the memory pages that are modified across several processes [137]. This technique is very similar to parity computation in RAID disk systems. <p> is very low, and it can be adjusted depending on how many failures the system is willing to tolerate [137]. 5.2.2 System-level versus User-level Implementations Support for checkpointing can be implemented in the kernel [48, 86, 135], or it can be implemented by a library linked with the user program <ref> [62, 106, 136, 159, 165, 191] </ref>. Kernel-level implementations are more powerful because they can also capture kernel data structures that support the checkpointed process. However, these implementations are necessarily not portable. Checkpointing can also be implemented in user level.
Reference: [137] <author> J. S. Plank and K. Li. </author> <title> Faster checkpointing with n + 1 parity. </title> <booktitle> In Proceedings of the Twenty Fourth Annual International Symposium on Fault-Tolerant Computing, FTCS-24, </booktitle> <pages> pages 288-297, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: A public domain package implementing these techniques is available [136]. Incremental checkpointing can also be extended over several processes. In this technique, the system saves the computed parity or some function of the memory pages that are modified across several processes <ref> [137] </ref>. This technique is very similar to parity computation in RAID disk systems. The parity pages can be saved in volatile memory of some other processes thereby avoiding the need to access stable storage. <p> The parity pages can be saved in volatile memory of some other processes thereby avoiding the need to access stable storage. The storage overhead of this method is very low, and it can be adjusted depending on how many failures the system is willing to tolerate <ref> [137] </ref>. 5.2.2 System-level versus User-level Implementations Support for checkpointing can be implemented in the kernel [48, 86, 135], or it can be implemented by a library linked with the user program [62, 106, 136, 159, 165, 191].
Reference: [138] <author> J.S. Plank, M. Beck, and G. Kingsley. </author> <title> Compiler-assisted memory exclusion for fast checkpointing. </title> <booktitle> IEEE Technical Committee on Operating Systems and Application Environments, </booktitle> <volume> 7(4) </volume> <pages> 10-14, </pages> <month> Winter </month> <year> 1995. </year>
Reference-contexts: It is generally undecidable to find the point in program execution most suitable to take a checkpoint. 28 There are, however, several heuristics that can be used. The programmer could provide hints to the compiler about where checkpoints could be inserted or what data variables should be stored <ref> [24, 138, 152] </ref>. The compiler may also be trained by running the application in an iterative manner and observing its behavior [108]. The observed behavior could help decide the execution points where it would be appropriate to insert checkpoints.
Reference: [139] <author> J. B. Postel. </author> <title> Internet Protocol. Internet Request For Comments RFC 791, </title> <month> September </month> <year> 1981. </year>
Reference-contexts: Some protocols offer the abstraction of reliable communication channels such as connection-based protocols like TCP <ref> [139] </ref> or RPC-style communications [27]. Alternatively, other protocols offer the abstraction of an unreliable datagram service such as UDP [139]. <p> Some protocols offer the abstraction of reliable communication channels such as connection-based protocols like TCP <ref> [139] </ref> or RPC-style communications [27]. Alternatively, other protocols offer the abstraction of an unreliable datagram service such as UDP [139]. Each type of abstraction requires additional support to operate properly across failures and recoveries. 5.3.1 Location-Independent Identities and Redirection For all communication protocols, a rollback-recovery system must mask the actual identity and location of a process or a remote port from the application program.
Reference: [140] <author> M. L. Powell and D. L. Presotto. </author> <title> Publishing: A reliable broadcast communication mechanism. </title> <booktitle> In Proc. 9th ACM Symp. Oper. Syst. Principles, </booktitle> <pages> pages 100-109, </pages> <month> October </month> <year> 1983. </year> <month> 42 </month>
Reference-contexts: Therefore, performance is only slightly affected. Another form of hardware support is to use a special bus that guarantees atomic logging of all messages exchanged in the system <ref> [29, 140] </ref>. Such hardware support ensures that the log of one machine is automatically stored on a designated backup without blocking the execution of the application program. This scheme, however, requires that all nondeterministic events be converted into external messages [23, 29].
Reference: [141] <author> A. Prakash and R. Subramanian. </author> <title> Filter: An algorithm for reducing cascaded rollbacks in optimistic distributed simulation. </title> <booktitle> In Proc. the 24th Annual Simulation Symposium, 1991 Simulation Multicon-ference, </booktitle> <pages> pages 123-132, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: In the area of distributed discrete-event simulation [59, 124], the Time Warp optimistic approach, which inspired the seminal work on optimistic message logging [168], 34 uses rollbacks to cancel erroneous computations due to the out-of-order arrivals of time-stamped event messages <ref> [59, 60, 85, 118, 141] </ref>. 7 Conclusions We have reviewed and compared different approaches to rollback-recovery with respect to a set of properties including the assumption of piecewise determinism, performance overhead, storage overhead, ease of output commit, ease of garbage collection, ease of recovery, freedom from domino effect, freedom from orphan
Reference: [142] <author> P. Ramanathan and K. G. Shin. </author> <title> Checkpointing and rollback recovery in a distributed system using common time base. </title> <booktitle> In Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 13-21, </pages> <year> 1988. </year>
Reference: [143] <author> P. Ramanathan and K. G. Shin. </author> <title> Use of common time base for checkpointing and rollback recovery in a distributed system. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> 19(6) </volume> <pages> 571-583, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: This modification also allows non-FIFO channels. In practice, checkpoint indices can serve as the checkpoint request messages: a checkpoint is triggered when the receiver's local checkpoint index is lower than the piggybacked checkpoint index [50, 154]. 14 3.2.3 Synchronized Checkpoint Clocks Loosely synchronous clocks can facilitate checkpoint coordination <ref> [42, 143, 177] </ref>. More specifically, loosely-synchronized checkpoint clocks can trigger the local checkpointing actions of all participating processes at approximately the same time without the need of broadcasting the checkpoint request message by a coordinator.
Reference: [144] <author> B. Randell. </author> <title> System structure for software fault tolerance. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> SE-1(2):220-232, </volume> <month> June </month> <year> 1975. </year>
Reference-contexts: Under some scenarios, cascading rollback propagation may force the system to restart from the initial state, losing all the work performed before a failure. This unbounded rollback is called the domino effect <ref> [144] </ref>. The possibility of the domino effect is highly undesirable because all checkpoints taken may turn out to be useless for protecting an application against losing all useful work upon a failure. <p> Rollback-recovery techniques that rely on special language constructs such as recovery blocks <ref> [144] </ref> and transactions [64] are not covered in this survey. Also, we do not address the use of rollback-recovery to tolerate Byzantine failures. 2 Background and Definitions 2.1 System Model and Failure Model A message-passing system consists of a fixed number of processes that communicate only through messages. <p> Any consistent global checkpoint can be used for system restoration upon a failure. To minimize the amount of lost work, the most recent consistent global checkpoint, called the recovery line <ref> [144] </ref>, is the best choice. without coordinating with each other. A black bar represents a checkpoint, and each process is assumed to start its execution with an initial checkpoint. Suppose process P 2 fails and rolls back to checkpoint C. <p> The rollback of P 2 thus propagates to P 1 , therefore the term rollback propagation. P 1 's rollback further "unsends" m 0 and forces P 0 to roll back as well. Such cascading rollback propagation can eventually lead to an unbounded rollback, called the domino effect <ref> [144] </ref>, as illustrated in Figure 4. The recovery line for the single failure of P 2 consists of the initial checkpoints. Thus, the system has to roll back to the beginning of its execution and loses all useful work in spite of all the checkpoints that have been taken. <p> nature of the recovery information they need to store on stable storage, and therefore differ in the complexity and invocation frequency of their garbage collection algorithms. 3 Checkpoint-Based Rollback-Recovery Upon a failure, checkpoint-based rollback-recovery restores the system state to the most recent consistent set of checkpoints, i.e., the recovery line <ref> [144] </ref>. It does not rely on piecewise determinism, and so does not need to detect, log, and replay nondeterministic events. Since there is no guarantee that pre-failure execution can be deterministically regenerated after a rollback, it is more suitable for applications that do not frequently interact with the outside world. <p> This survey has covered mostly rollback-recovery techniques which do not require or take advantage of special linguistic supports. A substantial amount of research efforts has also focused on coordinated recovery based on special language constructs such as recovery blocks and conversations <ref> [34, 65, 66, 79, 94, 96, 144, 145, 200] </ref>. Nett et al. addressed recovery problems in dynamic action models [126-128]. Kim et al. addressed recovery problems in the Programmer-Transparent Coordination (PTC) scheme [95, 97, 98]. Orphan elimination problem in nested transaction systems has also been studied [69, 70, 113].
Reference: [145] <author> B. Randell and J. Xu. </author> <title> The evolution of the recovery block concept. In Software Fault Tolerance, </title> <editor> Ed. M. R. </editor> <booktitle> Lyu, </booktitle> <pages> pages 1-21. </pages> <publisher> John Wiley & Sons, </publisher> <year> 1995. </year>
Reference-contexts: This survey has covered mostly rollback-recovery techniques which do not require or take advantage of special linguistic supports. A substantial amount of research efforts has also focused on coordinated recovery based on special language constructs such as recovery blocks and conversations <ref> [34, 65, 66, 79, 94, 96, 144, 145, 200] </ref>. Nett et al. addressed recovery problems in dynamic action models [126-128]. Kim et al. addressed recovery problems in the Programmer-Transparent Coordination (PTC) scheme [95, 97, 98]. Orphan elimination problem in nested transaction systems has also been studied [69, 70, 113].
Reference: [146] <author> M. Ruffin. Kitlog: </author> <title> A generic logging service. </title> <booktitle> In Proceedings of the 11th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 139-148, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: The KitLog package offers a log abstraction on top of which support for checkpointing and message logging can be implemented. The package runs in conventional UNIX systems and bypasses the UNIX file system by accessing the disk in raw mode <ref> [146] </ref>. There have been also several attempts at implementing stable storage using nonvolatile semiconductor memory [18]. Such implementations do not have the performance problems associated with disks.
Reference: [147] <author> D. L. Russell. </author> <title> State restoration in systems of communicating processes. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> SE-6(2):183-194, </volume> <month> March </month> <year> 1980. </year>
Reference-contexts: Russell <ref> [147] </ref> proved that if within every checkpoint interval all message-receiving events precede all message-sending events, then the system is domino effect-free.
Reference: [148] <author> M. Russinovich, B. Cogswell, and Z. Segall. </author> <title> Replay for concurrent nondeterministic shared memory applications. </title> <note> To appear in Proc. SIGPLAN '96. </note>
Reference-contexts: Execution proceeds until an event of interest occurs, at which time the content of the counter is sampled, and the number of instructions executed since the time the counter was set is computed. The use of instruction counters has been suggested for debugging shared memory parallel programs <ref> [36, 122, 148] </ref>. Instruction counters can be used in rollback-recovery to track the number of instructions that occur between asynchronous interrupts. A replay system can use the instruction count to force the execution of the same number of instructions between asynchronous interrupts.
Reference: [149] <author> M. Russinovich, Z. Segall, and D. P. Siewiorek. </author> <title> Application transparent fault management in fault-tolerant mach. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 10-19, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: User-level implementations however cannot access kernel's data structures that belong to the process such as open file descriptors and message buffers, but these data structures can be emulated at user level <ref> [149, 191] </ref>. 5.2.3 Compiler Support A compiler can be instrumented to generate code that supports checkpointing [108]. A compiled program would contain code that decides when and what to checkpoint. <p> These calls generally modify the environment and therefore they must be re-executed to re-establish the environment changes. Examples include calls that allocate memory or create processes. Ensuring that these calls return the same values and generate the same effect during reexecution can be very complex <ref> [48, 149] </ref>. 5.6.2 Asynchronous signals Different flavors of logging have been suggested with different performance and resilience characteristics [7]. These protocols, however, do not support general forms of nondeterminism that are found in practice. <p> If this is not feasible, then the system must insulate the process from environment-specific variables [48]. This can be done for instance by intercepting system calls that return environment-specific results and replace these results with abstract values under the control of the recovery system <ref> [149] </ref>. Also, file access could be made highly available by placing all files in network-wide highly available file servers or by using dual-ported disks.
Reference: [150] <author> R. D. Schlichting and F. B. Schneider. </author> <title> Fail-stop processors: An approach to designing fault-tolerant computing systems. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 1(3) </volume> <pages> 222-238, </pages> <month> August </month> <year> 1983. </year>
Reference-contexts: The two different assumptions lead to different treatments of in-transit messages, as will be described shortly. Their practical implications are discussed in Section 5. A process may fail, in which case it loses its volatile state and stops execution according to the fail-stop model <ref> [150] </ref>. Processes have access to a stable storage device that survives failures. State information saved to the device during failure-free execution then can be used for recovery. The number of tolerated process failures may vary from one to N , and the recovery protocol needs to be accordingly designed.
Reference: [151] <author> R. Schwarz and F. Mattern. </author> <title> Detecting causal relationships in distributed computations: in search of the holy grail. </title> <journal> Distributed Computing, </journal> <volume> 7 </volume> <pages> 149-174, </pages> <year> 1994. </year>
Reference-contexts: Theoretical aspects of distributed snapshots also have been studied outside the context of recovery [1, 5, 38, 43, 67, 101, 162, 180]. Several fundamental properties regarding consistent global states have been derived [13, 16, 120, 131, 184]. Vector timestamps <ref> [55, 121, 151, 155] </ref> and the context graph used in em Psync [133] bear similarities to the various dependency tracking techniques. Check-pointing and message logging can also be used to facilitate the debugging of parallel and distributed programs [57, 63, 129, 130].
Reference: [152] <author> E. Seligman and A. Beguelin. </author> <title> High-level fault tolerance in distributed programs. </title> <type> Technical Report CMU-CS-94-223, </type> <institution> Department of Computer Science, Carnegie Mellon University, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: It is generally undecidable to find the point in program execution most suitable to take a checkpoint. 28 There are, however, several heuristics that can be used. The programmer could provide hints to the compiler about where checkpoints could be inserted or what data variables should be stored <ref> [24, 138, 152] </ref>. The compiler may also be trained by running the application in an iterative manner and observing its behavior [108]. The observed behavior could help decide the execution points where it would be appropriate to insert checkpoints.
Reference: [153] <author> D. D. Sharma and D. K. Pradhan. </author> <title> An efficient coordinated checkpointing scheme for multicomputers. </title> <booktitle> In Proc. IEEE Workshop on Fault-Tolerant Parallel and Distributed Systems, </booktitle> <month> June </month> <year> 1994. </year>
Reference: [154] <author> L. M. Silva and J. G. Silva. </author> <title> Global checkpointing for distributed programs. </title> <booktitle> In Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 155-162, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: This modification also allows non-FIFO channels. In practice, checkpoint indices can serve as the checkpoint request messages: a checkpoint is triggered when the receiver's local checkpoint index is lower than the piggybacked checkpoint index <ref> [50, 154] </ref>. 14 3.2.3 Synchronized Checkpoint Clocks Loosely synchronous clocks can facilitate checkpoint coordination [42, 143, 177]. More specifically, loosely-synchronized checkpoint clocks can trigger the local checkpointing actions of all participating processes at approximately the same time without the need of broadcasting the checkpoint request message by a coordinator.
Reference: [155] <author> M. Singhal and A. Kshemkalyani. </author> <title> An efficient implementation of vector clocks. </title> <journal> Information Processing Letters, </journal> <volume> 43 </volume> <pages> 47-52, </pages> <year> 1992. </year>
Reference-contexts: Theoretical aspects of distributed snapshots also have been studied outside the context of recovery [1, 5, 38, 43, 67, 101, 162, 180]. Several fundamental properties regarding consistent global states have been derived [13, 16, 120, 131, 184]. Vector timestamps <ref> [55, 121, 151, 155] </ref> and the context graph used in em Psync [133] bear similarities to the various dependency tracking techniques. Check-pointing and message logging can also be used to facilitate the debugging of parallel and distributed programs [57, 63, 129, 130].
Reference: [156] <author> M. Singhal and N. G. Shivaratri. </author> <title> Advanced Concepts in Operating Systems. </title> <publisher> McGraw-Hill, </publisher> <year> 1994. </year>
Reference: [157] <author> A. P. Sistla and J. L. Welch. </author> <title> Efficient distributed recovery using message logging. </title> <booktitle> In Proc. 8th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 223-238, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: The number of tolerated process failures may vary from one to N , and the recovery protocol needs to be accordingly designed. Whether failures that occur during recovery need to be tolerated or not also affects the choice of recovery protocols <ref> [51, 157] </ref>. 2.2 Consistent System States The state of a message-passing system is the collection of the individual states of all participating processes and the states of the communication channels. Intuitively, a consistent system state is one that may occur in a legal execution of a distributed computation. <p> This problem does not occur in protocols that rely on sender logging or those that do not assume 20 reliable communication channels [50, 89]. 4.2 Optimistic Logging 4.2.1 Overview Unlike pessimistic logging protocols, optimistic logging protocols <ref> [87, 89, 91, 134, 157, 168] </ref> log messages asynchronously. These protocols make the optimistic assumption that logging will complete before a failure occurs. A volatile log contains information about the events to be logged, and is flushed to stable storage periodically. <p> Asynchronous Recovery Recovery in optimistic logging protocols can be either synchronous or asynchronous. In synchronous recovery <ref> [157] </ref>, all processes run a recovery protocol to compute the maximum recoverable system state based on dependency and logged information, and then perform the actual rollbacks. During failure-free execution, each process increments its state interval index at the beginning of each state interval. <p> During failure-free execution, each process increments its state interval index at the beginning of each state interval. Dependency tracking can be either direct or transitive. In direct dependency tracking <ref> [89, 157] </ref>, the current index of a message sender is piggybacked on each outgoing message to allow the 21 receiver to record the dependency directly caused by the message. These direct dependencies can then be assembled at recovery time to obtain complete dependency information. <p> These direct dependencies can then be assembled at recovery time to obtain complete dependency information. Alternatively, transitive dependency tracking <ref> [157] </ref> can be used: each process P i maintains a size-N vector T D i where T D i [i] is P i 's current state interval index, and T D i [j], j 6= i, records the highest index of any state interval of P j on which P i <p> The protocol was later improved to require piggybacking only a provably minimum amount of information [161]. Another issue in asynchronous recovery protocols is the possibility of exponential rollbacks: a single failure in the system may cause a process to roll back an exponential number of times <ref> [157] </ref>. incarnation of a process. Suppose P 0 fails and loses its interval [1; 2]. When P 0 's rollback announcement r 0 reaches P 1 , P 1 rolls back to interval [2; 3] and broadcast another rollback announcement r 1 . <p> By generalizing this example, we can construct scenarios in which process P i , i &gt; 0, rolls back 2 i1 times in response to P 0 's failure. It was pointed out that Strom and Yemini's original protocol suffers from the exponential rollbacks problem <ref> [157] </ref>. Three approaches have been proposed to eliminate the problem by ensuring that any process will roll back at most once in response to a single failure.
Reference: [158] <author> J. H. Slye and E. N. Elnozahy. </author> <title> Supporting nondeterministic execution in fault-tolerant systems. </title> <booktitle> In Proceedings of the 26th International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 250-259, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: It also can be emulated in software [122]. A recent implementation on a DEC 3000/400 workstation shows that the overhead of program instrumentation and tracking nondeterminism is less than 6% for a variety of user programs and synthetic benchmarks <ref> [158] </ref>. 5.7 Dependency Tracking There are three forms for implementing dependency tracking. The first is the simplest and consists of tagging the message with an index or a sequence number [86]. Dependency tracking also can take the form of piggybacking a vector or a graph on top of each message.
Reference: [159] <author> J. M. Smith and J. Ioannidis. </author> <title> Implementing remote fork() with checkpoint/restart. </title> <journal> IEEE Technical Committee on Operating Systems Newsletter, </journal> <pages> pages 12-16, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: The simplest way to save the state of a process is to suspend it, save its address space on stable storage, and then resume it <ref> [92, 99, 106, 114, 159, 194] </ref>. This scheme can be costly for programs with large address spaces if stable storage is implemented using magnetic disks as it is the custom. <p> is very low, and it can be adjusted depending on how many failures the system is willing to tolerate [137]. 5.2.2 System-level versus User-level Implementations Support for checkpointing can be implemented in the kernel [48, 86, 135], or it can be implemented by a library linked with the user program <ref> [62, 106, 136, 159, 165, 191] </ref>. Kernel-level implementations are more powerful because they can also capture kernel data structures that support the checkpointed process. However, these implementations are necessarily not portable. Checkpointing can also be implemented in user level.
Reference: [160] <author> S. W. Smith, D. B. Johnson, and J. D. Tygar. </author> <title> Completely asynchronous optimistic recovery with minimal rollbacks. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 361-370, </pages> <year> 1995. </year> <month> 43 </month>
Reference-contexts: Transitive dependency tracking generally incurs a higher failure-free overhead for piggybacking and maintaining the dependency vectors, but allows faster output commit and recovery [87]. In asynchronous recovery, a failed process restarts by sending a rollback announcement broadcast <ref> [160] </ref> (or recovery message [168]) to start a new incarnation. Upon receiving a rollback announcement, a process rolls back if it detects that it has become an orphan with respect to that announcement, and then broadcast its own rollback announcement. <p> To eliminate the blocking and achieve completely asynchronous recovery, the protocol by Smith et al. <ref> [160] </ref> piggybacks all rollback announcements known to a process on every outgoing message. The protocol was later improved to require piggybacking only a provably minimum amount of information [161]. <p> If rollback announcements are only generated by failed processes, messages like r 1 in Figure 13 no longer exist and so exponential rollbacks will not happen. The recovery protocol by Smith et al. <ref> [160, 161] </ref> also avoids exponential rollbacks because all rollback announcements are piggybacked on every application message and so always reach a process at the same time. 4.3 Causal Logging 4.3.1 Overview Causal logging has the failure-free performance advantages of optimistic logging without making optimistic assumptions.
Reference: [161] <author> S.W. Smith and D.B. Johnson. </author> <title> Minimizing timestamp size for completely asynchronous optimistic recovery with minimal rollback. </title> <booktitle> In Proceedings of the 15th Symposium on Reliable Distributed Systems, </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: To eliminate the blocking and achieve completely asynchronous recovery, the protocol by Smith et al. [160] piggybacks all rollback announcements known to a process on every outgoing message. The protocol was later improved to require piggybacking only a provably minimum amount of information <ref> [161] </ref>. Another issue in asynchronous recovery protocols is the possibility of exponential rollbacks: a single failure in the system may cause a process to roll back an exponential number of times [157]. incarnation of a process. Suppose P 0 fails and loses its interval [1; 2]. <p> If rollback announcements are only generated by failed processes, messages like r 1 in Figure 13 no longer exist and so exponential rollbacks will not happen. The recovery protocol by Smith et al. <ref> [160, 161] </ref> also avoids exponential rollbacks because all rollback announcements are piggybacked on every application message and so always reach a process at the same time. 4.3 Causal Logging 4.3.1 Overview Causal logging has the failure-free performance advantages of optimistic logging without making optimistic assumptions.
Reference: [162] <author> M. Spezialetti and P. Kearns. </author> <title> Efficient distributed snapshots. </title> <booktitle> In Proc. IEEE Int. Conf. Distributed Comput. Syst., </booktitle> <pages> pages 382-388, </pages> <year> 1986. </year>
Reference-contexts: Kim et al. addressed recovery problems in the Programmer-Transparent Coordination (PTC) scheme [95, 97, 98]. Orphan elimination problem in nested transaction systems has also been studied [69, 70, 113]. Theoretical aspects of distributed snapshots also have been studied outside the context of recovery <ref> [1, 5, 38, 43, 67, 101, 162, 180] </ref>. Several fundamental properties regarding consistent global states have been derived [13, 16, 120, 131, 184]. Vector timestamps [55, 121, 151, 155] and the context graph used in em Psync [133] bear similarities to the various dependency tracking techniques.
Reference: [163] <author> M. Staknis. </author> <title> Sheaved memory: Architectural support for state saving and restoration in paged systems. </title> <booktitle> In Proceedings of the 3rd Symposium on Architectural Support' for Programming Languages and Operating Systems, </booktitle> <pages> pages 96-102, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: This special hardware can take the form of a fast non-volatile semiconductor memory to implement stable storage <ref> [18, 163] </ref>. Synchronous logging in such an implementation would be orders of magnitude cheaper than with a traditional implementation of stable storage using magnetic disk devices. Therefore, performance is only slightly affected.
Reference: [164] <author> G. Stellner. </author> <title> Consistent checkpoints of PVM applications. </title> <booktitle> In First European PVM User Group Meeting, </booktitle> <year> 1994. </year>
Reference: [165] <author> G. Stellner. </author> <title> CoCheck: Checkpointing and process migration for MPI. </title> <booktitle> In 10th International Parallel Processing Symposium, </booktitle> <month> April </month> <year> 1996. </year>
Reference-contexts: is very low, and it can be adjusted depending on how many failures the system is willing to tolerate [137]. 5.2.2 System-level versus User-level Implementations Support for checkpointing can be implemented in the kernel [48, 86, 135], or it can be implemented by a library linked with the user program <ref> [62, 106, 136, 159, 165, 191] </ref>. Kernel-level implementations are more powerful because they can also capture kernel data structures that support the checkpointed process. However, these implementations are necessarily not portable. Checkpointing can also be implemented in user level.
Reference: [166] <author> R. E. Strom, , S. A. Yemini, and D. F. Bacon. </author> <title> A recoverable object store. </title> <booktitle> In Proc. Hawaii International Conference on System Sciences, </booktitle> <pages> pages II-215-II-221, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: For example, a printer cannot roll back the effects of printing a character; an automatic teller machine cannot recover the money that it dispensed to a customer; a deleted file cannot be recovered (unless its state is included as part of the checkpoint <ref> [166, 191] </ref>). It is therefore necessary to ensure that the outside world perceive a consistent behavior of the system despite failures. Thus, before sending output to the outside world, the system must ensure that the state from which the output is sent will be recovered despite any future failure.
Reference: [167] <author> R. E. Strom, D. F. Bacon, and S. A. Yemini. </author> <title> Volatile logging in n-fault-tolerant distributed systems. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 44-49, </pages> <year> 1988. </year>
Reference-contexts: The above approaches rely solely on checkpoints, therefore the name checkpoint-based rollback-recovery. In contrast, log-based rollback-recovery uses checkpointing and message logging. 1 Log-based rollback-recovery relies on the assumptions underlied in a piecewise deterministic (PWD) execution model <ref> [51, 167] </ref>. Under the PWD model, each process execution consists of a sequence of deterministic state intervals, each starting with the occurrence of a nondeterministic event. By logging and replaying the nondeterministic events in their exact original order, a process can 1 Logging is not confined to messages only. <p> Additionally, log-based recovery generally is not susceptible to the domino effect, 6 allowing processes to use uncoordinated checkpointing if desired. 2 Log-based recovery relies on the assumptions underlied in a piecewise deterministic (PWD) execution model <ref> [51, 167] </ref> and employs an additional logging protocol. Under the PWD assumption, a process execution consists of a sequence of state intervals, each starting with a nondeterministic event such as a message receipt from another process. The execution within each state interval is deterministic.
Reference: [168] <author> R. E. Strom and S. Yemini. </author> <title> Optimistic recovery in distributed systems. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 3(3) </volume> <pages> 204-226, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: This problem does not occur in protocols that rely on sender logging or those that do not assume 20 reliable communication channels [50, 89]. 4.2 Optimistic Logging 4.2.1 Overview Unlike pessimistic logging protocols, optimistic logging protocols <ref> [87, 89, 91, 134, 157, 168] </ref> log messages asynchronously. These protocols make the optimistic assumption that logging will complete before a failure occurs. A volatile log contains information about the events to be logged, and is flushed to stable storage periodically. <p> Transitive dependency tracking generally incurs a higher failure-free overhead for piggybacking and maintaining the dependency vectors, but allows faster output commit and recovery [87]. In asynchronous recovery, a failed process restarts by sending a rollback announcement broadcast [160] (or recovery message <ref> [168] </ref>) to start a new incarnation. Upon receiving a rollback announcement, a process rolls back if it detects that it has become an orphan with respect to that announcement, and then broadcast its own rollback announcement. <p> Since rollback announcements from multiple incarnations of the same process may coexist in the system, each process in general needs to track the dependency of its state on every incarnation of every other process to correctly detect orphaned states. Strom and Yemini <ref> [168] </ref> introduced the following blocking at some message receiving events to allow tracking dependency on only one incarnation of each process: before process P i receives any message carrying a dependency on an unknown incarnation of process P j , P i must first receive rollback announcements from P j to <p> Check-pointing and message logging can also be used to facilitate the debugging of parallel and distributed programs [57, 63, 129, 130]. In the area of distributed discrete-event simulation [59, 124], the Time Warp optimistic approach, which inspired the seminal work on optimistic message logging <ref> [168] </ref>, 34 uses rollbacks to cancel erroneous computations due to the out-of-order arrivals of time-stamped event messages [59, 60, 85, 118, 141]. 7 Conclusions We have reviewed and compared different approaches to rollback-recovery with respect to a set of properties including the assumption of piecewise determinism, performance overhead, storage overhead, ease
Reference: [169] <author> G. Suri, Y. Huang, Y. M. Wang, W. K. Fuchs, and C. Kintala. </author> <title> An implementation and performance measurement of the progressive retry technique. </title> <booktitle> In Proc. IEEE International Computer Performance and Dependability Symposium, </booktitle> <pages> pages 41-48, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: One challenge is to handle unreplayable nondeterministic events while still preserving the advantages of piecewise determinism [41, 184, 190]. Although most rollback-recovery techniques were originally designed for tolerating hardware failures, they have also been applied to software and protocol error recovery <ref> [169, 184, 190, 193] </ref>. Rollback-recovery in shared-memory and distributed shared-memory systems has also been extensively studied [4, 20, 54, 75, 80-83, 109, 132, 170, 197, 198]. This survey has covered mostly rollback-recovery techniques which do not require or take advantage of special linguistic supports.
Reference: [170] <author> G. Suri, B. Janssens, and W. K. Fuchs. </author> <title> Reduced overhead logging for rollback recovery in distributed shared memory. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 279-288, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: These systems translated nondeterministic events into messages according to the CSP model [71]. It is important however to emphasize that these protocols are not only limited to message-passing systems. They have found applications in other style of interprocess communication, such as in distributed shared memory systems <ref> [37, 170, 197] </ref>. Log-based rollback-recovery protocols come in three major variants: pessimistic logging, optimistic logging, and causal logging protocols. <p> Although most rollback-recovery techniques were originally designed for tolerating hardware failures, they have also been applied to software and protocol error recovery [169, 184, 190, 193]. Rollback-recovery in shared-memory and distributed shared-memory systems has also been extensively studied <ref> [4, 20, 54, 75, 80-83, 109, 132, 170, 197, 198] </ref>. This survey has covered mostly rollback-recovery techniques which do not require or take advantage of special linguistic supports.
Reference: [171] <author> V.-O. Tam and M. Hsu. </author> <title> Fast recovery in distributed shared virtual memory systems. </title> <booktitle> In The 10th International Conference On Distributed Computing Systems, </booktitle> <pages> pages 38-45, </pages> <month> May </month> <year> 1990. </year>
Reference: [172] <author> Y. Tamir and T. M. Frazier. </author> <title> Application-transparent process-level error recovery for multicomputers. </title> <booktitle> In Hawaii International Conferences on System Sciences-22, </booktitle> <pages> pages 296-305, </pages> <month> January </month> <year> 1989. </year>
Reference: [173] <author> Y. Tamir and T. M. Frazier. </author> <title> Error-recovery in multicomputers using asynchronous coordinated check-pointing. </title> <type> Technical Report CSD-910066, </type> <institution> University of California, </institution> <address> Los Angeles, </address> <month> September </month> <year> 1991. </year>
Reference: [174] <author> Y. Tamir and C. H. Sequin. </author> <title> Error recovery in multicomputers using global checkpoints. </title> <booktitle> In Proc. Int. Conf. Parallel Processing, </booktitle> <pages> pages 32-41, </pages> <year> 1984. </year>
Reference-contexts: The main disadvantage is the sacrifice of process autonomy in taking checkpoints. In addition, a coordination session needs to be initiated before committing any output, and checkpoint coordination generally incurs message overhead. A straightforward approach to coordinated checkpointing is to block interprocess communications until the checkpointing protocol executes <ref> [43, 174] </ref>.
Reference: [175] <author> D. J. Taylor and M. L. Wright. </author> <title> Backward error recovery in a UNIX environment. </title> <booktitle> In Proceedings of the 16th International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 118-123, </pages> <year> 1986. </year>
Reference: [176] <author> M. Theimer, K. Lantz, and D. R. Cheriton. </author> <title> Preemptable remote execution facilities in the V-system. </title> <booktitle> In Proceedings of the 10th SIGOPS Symposium on Operating Systems Principles, </booktitle> <pages> pages 2-12, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: Such a dependency would make it impossible to restart a process on a different machine after a failure. A solution to this problem is to assign a location-independent, logical identifier to each process in the system <ref> [176] </ref>. The system translates the logical identifier to the actual network 29 address of the process in an application-transparent manner.
Reference: [177] <author> Z. Tong, R. Y. Kain, and W. T. Tsai. </author> <title> Rollback recovery in distributed systems using loosely synchronized clocks. </title> <journal> IEEE Trans. Parallel and Distributed Syst., </journal> <volume> 3(2) </volume> <pages> 246-251, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: This modification also allows non-FIFO channels. In practice, checkpoint indices can serve as the checkpoint request messages: a checkpoint is triggered when the receiver's local checkpoint index is lower than the piggybacked checkpoint index [50, 154]. 14 3.2.3 Synchronized Checkpoint Clocks Loosely synchronous clocks can facilitate checkpoint coordination <ref> [42, 143, 177] </ref>. More specifically, loosely-synchronized checkpoint clocks can trigger the local checkpointing actions of all participating processes at approximately the same time without the need of broadcasting the checkpoint request message by a coordinator.
Reference: [178] <author> K. Tsuruoka, A. Kaneko, and Y. Nishihara. </author> <title> Dynamic recovery schemes for distributed processes. </title> <booktitle> In Proc. IEEE 2nd Symp. on Reliability in Distributed Software and Database Systems, </booktitle> <pages> pages 124-130, </pages> <year> 1981. </year>
Reference-contexts: During normal execution, the dependencies between checkpoints caused by message exchanges need to be recorded so that a consistent global checkpoint can be determined during recovery. The following direct dependency tracking technique is commonly used in uncoordinated checkpoint-ing <ref> [25, 178, 192] </ref>. <p> The last unmarked node of each process then forms the recovery line as shown in Figure 7 (b). 10 checkpoint graph. The second approach is based on a checkpoint graph <ref> [178, 183] </ref>. Checkpoint graphs are similar to rollback-dependency graphs except that, when a message is sent from I i;x and received in I j;y , a directed edge is drawn from c i;x1 (instead of c i;x ) to c j;y , as shown in Figure 7 (c). <p> The recovery line can be calculated by first removing the nodes corresponding to the volatile checkpoints of the failed processes, and then applying the following rollback propagation algorithm <ref> [178, 187] </ref> on the checkpoint graph: /* Initially, all checkpoints are unmarked */ include the last checkpoint of each process in a root set; mark all the checkpoints strictly reachable from any checkpoint in the root set; while (at least one checkpoint in the root set is marked) f replace each
Reference: [179] <author> N. H. Vaidya. </author> <title> Consistent logical checkpointing. </title> <type> Technical Report # 94-051, </type> <institution> Dept. of Computer Science, Texas A&M University, </institution> <month> July </month> <year> 1994. </year> <month> 44 </month>
Reference-contexts: It is based on the observation that piecewise determinism can be modeled as having a logical checkpoint <ref> [91, 179, 190] </ref> before every nondeterministic event. Therefore, checkpoint-based rollback recovery can mimic piecewise determinism by taking an actual checkpoint before every nondeterministic event. The main challenge is how to reduce the number of checkpoints while still preserving desirable properties.
Reference: [180] <author> S. Venkatesan. </author> <title> Message-optimal incremental snapshots. </title> <booktitle> In Proc. IEEE Int. Conf. Distributed Comput. Syst., </booktitle> <pages> pages 53-60, </pages> <year> 1989. </year>
Reference-contexts: Kim et al. addressed recovery problems in the Programmer-Transparent Coordination (PTC) scheme [95, 97, 98]. Orphan elimination problem in nested transaction systems has also been studied [69, 70, 113]. Theoretical aspects of distributed snapshots also have been studied outside the context of recovery <ref> [1, 5, 38, 43, 67, 101, 162, 180] </ref>. Several fundamental properties regarding consistent global states have been derived [13, 16, 120, 131, 184]. Vector timestamps [55, 121, 151, 155] and the context graph used in em Psync [133] bear similarities to the various dependency tracking techniques.
Reference: [181] <author> K. Venkatesh, T. Radhakrishnan, and H. F. Li. </author> <title> Optimal checkpointing and local recording for domino-free rollback recovery. </title> <journal> Information Processing Letters, </journal> <volume> 25 </volume> <pages> 295-303, </pages> <month> July </month> <year> 1987. </year>
Reference: [182] <author> Y. M. Wang. </author> <title> Consistent global checkpoints that contain a given set of local checkpoints. </title> <note> To appear in IEEE Trans. on Computers. </note>
Reference-contexts: Therefore, checkpoint-based rollback recovery can mimic piecewise determinism by taking an actual checkpoint before every nondeterministic event. The main challenge is how to reduce the number of checkpoints while still preserving desirable properties. It has been shown that <ref> [182] </ref> the three domino effect-free models described in the previous paragraph can all be viewed as special cases of a more general Fixed-Dependency-After-Send (FDAS) model: the receiving of any message that causes its receiver P j to causally depend on a checkpoint c i;x for the first time must precede any
Reference: [183] <author> Y. M. Wang. </author> <title> Space Reclamation for Uncoordinated Checkpointing in Message-Passing Systems. </title> <type> PhD thesis, </type> <institution> Department of Electrical and Computer Engineering, University of Illinois at Urbana-Champaign, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: The last unmarked node of each process then forms the recovery line as shown in Figure 7 (b). 10 checkpoint graph. The second approach is based on a checkpoint graph <ref> [178, 183] </ref>. Checkpoint graphs are similar to rollback-dependency graphs except that, when a message is sent from I i;x and received in I j;y , a directed edge is drawn from c i;x1 (instead of c i;x ) to c j;y , as shown in Figure 7 (c).
Reference: [184] <author> Y. M. Wang. </author> <title> The maximum and minimum consistent global checkpoints and their applications. </title> <booktitle> In Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 86-95, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: The first approach is based on a rollback-dependency graph <ref> [25, 35, 184] </ref> in which each node represents a checkpoint and a directed edge is drawn from c i;x to c j;y if (1) i 6= j, and a message m is sent from I i;x and received in I j;y or (2) i = j and y = x + <p> The rollback-dependency graph corresponding to the pattern in Figure 7 (a) is illustrated in Figure 7 (b). To calculate the recovery line, the graph nodes corresponding to the volatile checkpoints of the failed processes P 0 and P 1 are initially marked. A reachability analysis <ref> [25, 184] </ref> is performed by marking all the nodes reachable from any of the initially marked nodes. The last unmarked node of each process then forms the recovery line as shown in Figure 7 (b). 10 checkpoint graph. The second approach is based on a checkpoint graph [178, 183]. <p> Such a model, called an MRS model, can be maintained by taking an additional checkpoint before every message-receiving event that is not separated from its previous message-sending event by a checkpoint <ref> [2, 184] </ref>. In the Programmer-Transparent Coordination (PTC) scheme [98], Kim et al. proved that the domino effect can be eliminated if each process takes an additional checkpoint before processing any message that will cause the process to depend on a checkpoint that it did not previously depend on. <p> In practice, it is important to support systems consisting of both deterministic and nondeterministic processes [87, 90]. One challenge is to handle unreplayable nondeterministic events while still preserving the advantages of piecewise determinism <ref> [41, 184, 190] </ref>. Although most rollback-recovery techniques were originally designed for tolerating hardware failures, they have also been applied to software and protocol error recovery [169, 184, 190, 193]. <p> One challenge is to handle unreplayable nondeterministic events while still preserving the advantages of piecewise determinism [41, 184, 190]. Although most rollback-recovery techniques were originally designed for tolerating hardware failures, they have also been applied to software and protocol error recovery <ref> [169, 184, 190, 193] </ref>. Rollback-recovery in shared-memory and distributed shared-memory systems has also been extensively studied [4, 20, 54, 75, 80-83, 109, 132, 170, 197, 198]. This survey has covered mostly rollback-recovery techniques which do not require or take advantage of special linguistic supports. <p> Orphan elimination problem in nested transaction systems has also been studied [69, 70, 113]. Theoretical aspects of distributed snapshots also have been studied outside the context of recovery [1, 5, 38, 43, 67, 101, 162, 180]. Several fundamental properties regarding consistent global states have been derived <ref> [13, 16, 120, 131, 184] </ref>. Vector timestamps [55, 121, 151, 155] and the context graph used in em Psync [133] bear similarities to the various dependency tracking techniques. Check-pointing and message logging can also be used to facilitate the debugging of parallel and distributed programs [57, 63, 129, 130].
Reference: [185] <author> Y. M. Wang, P. Y. Chung, and W. K. Fuchs. </author> <title> Tight upper bound on useful distributed system checkpoints. </title> <type> Tech. Rep. </type> <institution> CRHC-95-16, Coordinated Science Laboratory, University of Illinois at Urbana-Champaign, </institution> <year> 1995. </year>
Reference-contexts: To reduce the number of retained checkpoints, Wang et al. derived the necessary and sufficient condition for a checkpoint to be useful for any future recovery <ref> [185, 186] </ref>. It was shown that there exists a set of N recovery lines, the union of which contains all useful checkpoints. Each of the N recovery lines is obtained by initially marking one volatile checkpoint in the nonvolatile rollback-dependency graph. <p> It was also proved that the number of useful checkpoints can never exceed N (N + 1)=2, and the bound is tight <ref> [185] </ref>. 3.2 Coordinated Checkpointing 3.2.1 Overview In consistent checkpointing, the processes coordinate their checkpoints to form a global consistent state. Consistent checkpointing is not susceptible to the domino effect, since the processes always restart from the most recent checkpoint.
Reference: [186] <author> Y. M. Wang, P. Y. Chung, I. J. Lin, and W. K. Fuchs. </author> <title> Checkpoint space reclamation for uncoordinated checkpointing in message-passing systems. </title> <journal> IEEE Trans. Parallel and Distributed Syst., </journal> <volume> 6(5) </volume> <pages> 546-554, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: To reduce the number of retained checkpoints, Wang et al. derived the necessary and sufficient condition for a checkpoint to be useful for any future recovery <ref> [185, 186] </ref>. It was shown that there exists a set of N recovery lines, the union of which contains all useful checkpoints. Each of the N recovery lines is obtained by initially marking one volatile checkpoint in the nonvolatile rollback-dependency graph. <p> The extent of any potential rollback determines the maximum number of checkpoints each process may need to retain. Uncoordinated checkpointing can have unbounded rollbacks, and a process may need to retain up to N checkpoints if the optimal garbage collection algorithm is used <ref> [186] </ref>. Several checkpoints may need to be kept under optimistic logging, depending on the logging progress. 5 Implementation Issues 5.1 Overview While there is a rich body of research on the algorithmic aspects of rollback-recovery protocols, reports on experimental prototypes or commercial implementations are relatively scarce.
Reference: [187] <author> Y. M. Wang and W. K. Fuchs. </author> <title> Optimistic message logging for independent checkpointing in message-passing systems. </title> <booktitle> In Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 147-154, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Log-based recovery has traditionally been called message logging, as earlier papers have assumed that nondeterministic events can be converted to messages. Also, "message logging" has sometimes been used in the literature to refer to the recording of in-transit messages <ref> [42, 187] </ref>. <p> The recovery line can be calculated by first removing the nodes corresponding to the volatile checkpoints of the failed processes, and then applying the following rollback propagation algorithm <ref> [178, 187] </ref> on the checkpoint graph: /* Initially, all checkpoints are unmarked */ include the last checkpoint of each process in a root set; mark all the checkpoints strictly reachable from any checkpoint in the root set; while (at least one checkpoint in the root set is marked) f replace each
Reference: [188] <author> Y. M. Wang and W. K. Fuchs. </author> <title> Scheduling message processing for reducing rollback propagation. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 204-211, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Wu and Fuchs [197, 198] proposed that taking a checkpoint immediately after every message-sending event can eliminate rollback propagation and therefore the domino effect. Some heuristics have also been developed to reduce rollback propagation <ref> [188, 199] </ref>, although they in general do not guarantee domino effect-free recovery. In addition to achieving domino effect-free recovery, another branch of research work aims at providing the benefits of piecewise determinism (such as efficient output commit and recovery) without requiring applications to satisfy the piecewise deterministic model.
Reference: [189] <author> Y. M. Wang and W. K. Fuchs. </author> <title> Lazy checkpoint coordination for bounding rollback propagation. </title> <booktitle> In Proc. IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 78-85, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Second, the additional checkpoint overhead is determined by the checkpoint and communication pattern and is not otherwise controllable. Wang and Fuchs <ref> [189] </ref> introduced the notion of laziness (a positive integer) to provide a tradeoff between the checkpoint overhead and rollback distance. When a system specifies the laziness to be Z, only checkpoints with the same index which is a multiple of Z are required to be consistent.
Reference: [190] <author> Y. M. Wang, Y. Huang, and W. K. Fuchs. </author> <title> Progressive retry for software error recovery in distributed systems. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 138-144, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: It is based on the observation that piecewise determinism can be modeled as having a logical checkpoint <ref> [91, 179, 190] </ref> before every nondeterministic event. Therefore, checkpoint-based rollback recovery can mimic piecewise determinism by taking an actual checkpoint before every nondeterministic event. The main challenge is how to reduce the number of checkpoints while still preserving desirable properties. <p> In practice, it is important to support systems consisting of both deterministic and nondeterministic processes [87, 90]. One challenge is to handle unreplayable nondeterministic events while still preserving the advantages of piecewise determinism <ref> [41, 184, 190] </ref>. Although most rollback-recovery techniques were originally designed for tolerating hardware failures, they have also been applied to software and protocol error recovery [169, 184, 190, 193]. <p> One challenge is to handle unreplayable nondeterministic events while still preserving the advantages of piecewise determinism [41, 184, 190]. Although most rollback-recovery techniques were originally designed for tolerating hardware failures, they have also been applied to software and protocol error recovery <ref> [169, 184, 190, 193] </ref>. Rollback-recovery in shared-memory and distributed shared-memory systems has also been extensively studied [4, 20, 54, 75, 80-83, 109, 132, 170, 197, 198]. This survey has covered mostly rollback-recovery techniques which do not require or take advantage of special linguistic supports.
Reference: [191] <author> Y. M. Wang, Y. Huang, K. P. Vo, P. Y. Chung, and C. Kintala. </author> <title> Checkpointing and its applications. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 22-31, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: For example, a printer cannot roll back the effects of printing a character; an automatic teller machine cannot recover the money that it dispensed to a customer; a deleted file cannot be recovered (unless its state is included as part of the checkpoint <ref> [166, 191] </ref>). It is therefore necessary to ensure that the outside world perceive a consistent behavior of the system despite failures. Thus, before sending output to the outside world, the system must ensure that the state from which the output is sent will be recovered despite any future failure. <p> is very low, and it can be adjusted depending on how many failures the system is willing to tolerate [137]. 5.2.2 System-level versus User-level Implementations Support for checkpointing can be implemented in the kernel [48, 86, 135], or it can be implemented by a library linked with the user program <ref> [62, 106, 136, 159, 165, 191] </ref>. Kernel-level implementations are more powerful because they can also capture kernel data structures that support the checkpointed process. However, these implementations are necessarily not portable. Checkpointing can also be implemented in user level. <p> User-level implementations however cannot access kernel's data structures that belong to the process such as open file descriptors and message buffers, but these data structures can be emulated at user level <ref> [149, 191] </ref>. 5.2.3 Compiler Support A compiler can be instrumented to generate code that supports checkpointing [108]. A compiled program would contain code that decides when and what to checkpoint.
Reference: [192] <author> Y. M. Wang, A. Lowry, and W. K. Fuchs. </author> <title> Consistent global checkpoints based on direct dependency tracking. </title> <journal> Information Processing Letters, </journal> <volume> 50(4) </volume> <pages> 223-230, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: During normal execution, the dependencies between checkpoints caused by message exchanges need to be recorded so that a consistent global checkpoint can be determined during recovery. The following direct dependency tracking technique is commonly used in uncoordinated checkpoint-ing <ref> [25, 178, 192] </ref>.
Reference: [193] <author> Y. M. Wang, Michael Merritt, and A. B. Romanovsky. </author> <title> Guaranteed deadlock recovery: Deadlock resolution with rollback propagation. </title> <booktitle> In Proc. Pacific Rim International Symposium on Fault-Tolerant Systems, </booktitle> <pages> pages 92-97, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: One challenge is to handle unreplayable nondeterministic events while still preserving the advantages of piecewise determinism [41, 184, 190]. Although most rollback-recovery techniques were originally designed for tolerating hardware failures, they have also been applied to software and protocol error recovery <ref> [169, 184, 190, 193] </ref>. Rollback-recovery in shared-memory and distributed shared-memory systems has also been extensively studied [4, 20, 54, 75, 80-83, 109, 132, 170, 197, 198]. This survey has covered mostly rollback-recovery techniques which do not require or take advantage of special linguistic supports.
Reference: [194] <author> Z. Wojcik and B. E. Wojcik. </author> <title> Fault tolerant distributed computing using atomic send receive checkpoints. </title> <booktitle> In Proceedings of the 2nd IEEE Symposium on Parallel and Distributed Processing, </booktitle> <pages> pages 215-222, </pages> <year> 1990. </year>
Reference-contexts: The simplest way to save the state of a process is to suspend it, save its address space on stable storage, and then resume it <ref> [92, 99, 106, 114, 159, 194] </ref>. This scheme can be costly for programs with large address spaces if stable storage is implemented using magnetic disks as it is the custom.
Reference: [195] <author> W. G. Wood. </author> <title> A decentralized recovery control protocol. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 159-164, </pages> <year> 1981. </year>
Reference: [196] <author> W. G. Wood. </author> <title> Recovery control of communicating processes in a distributed system. In Reliable Computer Systems, </title> <editor> Ed. S. K. </editor> <booktitle> Shrivastava, </booktitle> <pages> pages 448-473. </pages> <address> Berlin, Germany: </address> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference: [197] <author> K. L. Wu and W. K. Fuchs. </author> <title> Recoverable distributed shared virtual memory. </title> <journal> IEEE Trans. Comput., </journal> <volume> 39(4) </volume> <pages> 460-469, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: In the Programmer-Transparent Coordination (PTC) scheme [98], Kim et al. proved that the domino effect can be eliminated if each process takes an additional checkpoint before processing any message that will cause the process to depend on a checkpoint that it did not previously depend on. Wu and Fuchs <ref> [197, 198] </ref> proposed that taking a checkpoint immediately after every message-sending event can eliminate rollback propagation and therefore the domino effect. Some heuristics have also been developed to reduce rollback propagation [188, 199], although they in general do not guarantee domino effect-free recovery. <p> These systems translated nondeterministic events into messages according to the CSP model [71]. It is important however to emphasize that these protocols are not only limited to message-passing systems. They have found applications in other style of interprocess communication, such as in distributed shared memory systems <ref> [37, 170, 197] </ref>. Log-based rollback-recovery protocols come in three major variants: pessimistic logging, optimistic logging, and causal logging protocols. <p> Although most rollback-recovery techniques were originally designed for tolerating hardware failures, they have also been applied to software and protocol error recovery [169, 184, 190, 193]. Rollback-recovery in shared-memory and distributed shared-memory systems has also been extensively studied <ref> [4, 20, 54, 75, 80-83, 109, 132, 170, 197, 198] </ref>. This survey has covered mostly rollback-recovery techniques which do not require or take advantage of special linguistic supports.
Reference: [198] <author> K. L. Wu, W. K. Fuchs, and J. H. Patel. </author> <title> Error recovery in shared memory multiprocessors using private caches. </title> <journal> IEEE Trans. Parallel and Distributed Syst., </journal> <volume> 1(2) </volume> <pages> 231-240, </pages> <month> April </month> <year> 1990. </year> <month> 45 </month>
Reference-contexts: In the Programmer-Transparent Coordination (PTC) scheme [98], Kim et al. proved that the domino effect can be eliminated if each process takes an additional checkpoint before processing any message that will cause the process to depend on a checkpoint that it did not previously depend on. Wu and Fuchs <ref> [197, 198] </ref> proposed that taking a checkpoint immediately after every message-sending event can eliminate rollback propagation and therefore the domino effect. Some heuristics have also been developed to reduce rollback propagation [188, 199], although they in general do not guarantee domino effect-free recovery. <p> Although most rollback-recovery techniques were originally designed for tolerating hardware failures, they have also been applied to software and protocol error recovery [169, 184, 190, 193]. Rollback-recovery in shared-memory and distributed shared-memory systems has also been extensively studied <ref> [4, 20, 54, 75, 80-83, 109, 132, 170, 197, 198] </ref>. This survey has covered mostly rollback-recovery techniques which do not require or take advantage of special linguistic supports.
Reference: [199] <author> J. Xu and R. H. B. Netzer. </author> <title> Adaptive independent checkpointing for reducing rollback propagation. </title> <booktitle> In Proc. 5th IEEE Symp. on Parallel and Distributed Processing, </booktitle> <pages> pages 754-761, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Wu and Fuchs [197, 198] proposed that taking a checkpoint immediately after every message-sending event can eliminate rollback propagation and therefore the domino effect. Some heuristics have also been developed to reduce rollback propagation <ref> [188, 199] </ref>, although they in general do not guarantee domino effect-free recovery. In addition to achieving domino effect-free recovery, another branch of research work aims at providing the benefits of piecewise determinism (such as efficient output commit and recovery) without requiring applications to satisfy the piecewise deterministic model. <p> In their scheme, an additional boolean vector and another boolean matrix are piggybacked on each message. These data structure allow a receiver to determine if an additional checkpoint needs to be taken to prevent some other checkpoints from becoming useless, i.e., not belonging to any consistent global checkpoints <ref> [199] </ref>. 16 3.3.3 Index-based Coordination Checkpoint coordination can also be considered as a mechanism to be incorporated into an uncoordinated checkpointing protocol to eliminate the domino effect. A naive way to employ checkpoint coordination is to start a coordination session whenever a local checkpoint is taken.
Reference: [200] <author> J. Xu, B. Randell, A. Romanovsky, C. Rubira, R. Stroud, and Z. Wu. </author> <title> Fault tolerance in concurrent object-oriented software through coordinated error recovery. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 499-509, </pages> <year> 1995. </year> <month> 46 </month>
Reference-contexts: This survey has covered mostly rollback-recovery techniques which do not require or take advantage of special linguistic supports. A substantial amount of research efforts has also focused on coordinated recovery based on special language constructs such as recovery blocks and conversations <ref> [34, 65, 66, 79, 94, 96, 144, 145, 200] </ref>. Nett et al. addressed recovery problems in dynamic action models [126-128]. Kim et al. addressed recovery problems in the Programmer-Transparent Coordination (PTC) scheme [95, 97, 98]. Orphan elimination problem in nested transaction systems has also been studied [69, 70, 113].
References-found: 200

