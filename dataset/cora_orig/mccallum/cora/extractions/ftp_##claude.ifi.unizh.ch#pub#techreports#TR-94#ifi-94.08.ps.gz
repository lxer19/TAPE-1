URL: ftp://claude.ifi.unizh.ch/pub/techreports/TR-94/ifi-94.08.ps.gz
Refering-URL: http://www.cs.gatech.edu/people/home/jmankoff/collab-immers-env.html
Root-URL: 
Email: Email: fbaumann,faessler,kiser,oeztuerk,richterg@ifi.unizh.ch  
Phone: 8057  
Title: Semantics-based Reverse Engineering  
Author: Peter Baumann, Jurg Fassler, Markus Kiser, Zafer Ozturk, Lutz Richter 
Note: Jurg Fassler is supported by KWF (Schweizerische Komission zur Forderung der wissenschaftlichen Forschung), grant nr. 2326.1, Zafer Ozturk is supported by Swiss Life Insurance and Pension Company.  
Address: Winterthurerstr. 190  Switzerland  
Affiliation: Institut fur Informatik der Universitat Zurich  Zurich  
Abstract-found: 0
Intro-found: 1
Reference: [1] <editor> Samson Abramsky and Chris Hankin, editors. </editor> <title> Abstract Interpretation of Declarative Languages. Computers and Their Applications. </title> <publisher> Ellis Horwood, </publisher> <year> 1987. </year>
Reference-contexts: Hence, there already are numerous publications proposing and studying different kinds of program analysis methods in abstract interpretation style. Many of them can be found in conference records and journals on theoretical and implementational aspects of programming languages or in books such as [13]. There is also a book <ref> [1] </ref> on abstract interpretation. An up-to-date overview and readable introduction to abstract interpretation is [12].
Reference: [2] <author> Z. Ammarguellat. </author> <title> A control-flow normalization algorithm and its complexity. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(3) </volume> <pages> 237-251, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: The reason is that goto statements can induce loops which are difficult to recognize. The other solution is to first restructure programs and then to analyze the resulting programs. This is what we do. Fortunately, there exists a powerful restructuring technique presented in <ref> [2] </ref>. This technique starts from a continuation-style description of the flow of control of a program. Hence, it has the advantage that it fits very well within our general semantics-based approach. <p> Hence, it has the advantage that it fits very well within our general semantics-based approach. It is worth mentioning that the method was developed by researchers familiar with 19 semantics-based analysis techniques in advanced compiler technologies [7] and that this restructuring technique is more powerful than other methods <ref> [2] </ref>. 4 The architecture of AEMES After having presented the heart of our system and its theoretical basis, we give an overview of the ideas behind AEMES and its overall architecture.
Reference: [3] <author> P. Baumann, J. Fassler, M. Kiser, and Z. Ozturk. </author> <title> Beauty and the beast or A formal semantic description of the control constructs of COBOL and its implementation. </title> <type> Technical Report 93.39, </type> <institution> Institut fur Informatik der Universitat Zurich, </institution> <year> 1993. </year>
Reference-contexts: In general, different abstract interpretations for static program analysis follow similar patterns with respect to control constructs. We have also observed that different abstract interpretations for COBOL have similar structures. We developed a denotational semantics of the control constructs of COBOL-74 <ref> [3] </ref>. Since COBOL-74 contains goto statements we used a continuation-style denotational semantics. The task was not too difficult, as it is well-known how to model the control-flow of goto statements by continuations. <p> This is the case when control reaches a paragraph or section not through a PERFORM statement, but through sequential execution. These observations are the reason that we had to include a dynamic continuation management in our semantics. The details are fully explained in <ref> [3] </ref>, where we also provide an implementation of the semantics in the high-level functional programming language Standard ML. Let us come back to the observation that the patterns of different abstract interpretations and of the standard interpretation are very similar.
Reference: [4] <author> R. Cartwright and M. Felleisen. </author> <title> The semantics of program dependence. </title> <booktitle> In ACM SIGPLAN'89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 13-27, </pages> <year> 1989. </year>
Reference-contexts: There are also publications that investigate the relationship between graph-based and semantics-based static program analysis techniques <ref> [4, 21] </ref>. Especially, [21] is recommended as a thorough investigation of termination properties of different program analyses. Another fact worth emphasizing is that by using continuation-style abstract interpretations one gets MOP -solutions to program analysis problems for free as is shown in [22].
Reference: [5] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: a unified lattice model for static analysis of programs by construction and approximation of fixpoints. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <year> 1977. </year>
Reference-contexts: It started as early as in 1977 with the seminal paper of P. Cousot and R. Cousot <ref> [5] </ref>. Hence, there already are numerous publications proposing and studying different kinds of program analysis methods in abstract interpretation style. Many of them can be found in conference records and journals on theoretical and implementational aspects of programming languages or in books such as [13].
Reference: [6] <author> Carl A. Gunter. </author> <title> Semantics of Programming Languages, Structure and Techniques. </title> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: Scott and Ch. Strachey, give the meaning of statements or programs at a more abstract level. A semantics consists of a set of functions, defined inductively over the abstract syntax tree, that map language constructs to mathematical values in what are known as domains <ref> [20, 6, 26, 30] </ref>. One distinguishes between direct-style and continuation-style semantics. Direct-style semantics are perhaps easier to understand at the beginning but become more complicated as soon as the control constructs of a programming language become more involved (e.g. goto's, exceptions).
Reference: [7] <author> Williams Ludwell Harrison. </author> <title> The interprocedural analysis and automatic paralleliza-tion of scheme programs. LISP an Symbolic Computation: </title> <journal> An International Journal, </journal> 2(3/4):179-396, 1989. 
Reference-contexts: Hence, it has the advantage that it fits very well within our general semantics-based approach. It is worth mentioning that the method was developed by researchers familiar with 19 semantics-based analysis techniques in advanced compiler technologies <ref> [7] </ref> and that this restructuring technique is more powerful than other methods [2]. 4 The architecture of AEMES After having presented the heart of our system and its theoretical basis, we give an overview of the ideas behind AEMES and its overall architecture.
Reference: [8] <author> Ph. Hausler. </author> <title> Denotational program slicing. </title> <booktitle> In Proceedings of 22. Annual Hawaii International Conference on System Sciences, </booktitle> <pages> pages 486-494, </pages> <year> 1989. </year>
Reference-contexts: An up-to-date overview and readable introduction to abstract interpretation is [12]. With respect to the relevant analysis approaches for reverse engineering one can find examples of abstract interpretations for data-flow analysis [22], functional dependency analysis [23], conditional constant propagation [28], Def-Use-analysis [28] or program slices <ref> [8, 29] </ref>. There are also publications that investigate the relationship between graph-based and semantics-based static program analysis techniques [4, 21]. Especially, [21] is recommended as a thorough investigation of termination properties of different program analyses. <p> To give an idea of what an abstract interpretation may look like and how it can be applied, we present an abstract interpretation for constructing program slices of the MOVE statement and statement composition in COBOL-74. This example is inspired by <ref> [8] </ref>. ffi : Stm fi V arSet ! V arSet ffi ([[MOVE e TO x]]; V ) = ( V otherwise where V ar (e) represents the set of variables occuring in e ffi ([[c1:c2]]; V ) = ffi ([[c1]]; ffi ([[c2]]; V )) 17 First, we need an auxiliary function
Reference: [9] <author> C.A.R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-583, </pages> <month> October </month> <year> 1969. </year> <month> 25 </month>
Reference-contexts: In contrast, it is much easier to model the control flow of real programming languages with continuations. * Axiomatic semantics: Axiomatic semantics <ref> [9, 30] </ref> describe the meaning of a programming language construct indirectly through partial or total correctness assertions. These assertions provide a means to reason about properties of statements and expressions, but do not really say what the meaning of a construct is.
Reference: [10] <editor> G. Huet and G. Plotkin, editors. </editor> <title> Logical Frameworks. </title> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: The most prominent one is the definition of Standard ML [19]. There exist descriptions of program analysis techniques in operational terms. Unfortunately, to find efficient implementations of the logical rules of a formal operational semantics is not so easy and is the subject of ongoing research <ref> [10] </ref>. * Denotational semantics is used to provide formal semantics of many programming languages [26]. It is a very well understood method. Denotational semantics are also called standard interpretations. The reason for that is that they provide the intended meaning of programs.
Reference: [11] <author> Cliff B. Jones. </author> <title> The search for tractable ways of reasoning about programs. </title> <type> Technical Report UMCS-92-4-4, </type> <institution> Department of Computer Science, University of Manchester, </institution> <year> 1992. </year>
Reference-contexts: But it is somewhat surprising that apart from some specifically 10 designed languages such as Euclid it is only for Pascal that substantial parts have been described by Hoare triples. We are not alone with this observation. The following paragraph is a quotation from <ref> [11, page 13] </ref>: But time has shown, at least for languages which were designed without the explicit constraint that they should have an 'axiomatic semantics', the task of providing a complete axiomatization to be impractical.
Reference: [12] <author> N.D. Jones and F. Nielson. </author> <title> Abstract interpretation: a semantics-based tool for program analysis. </title> <address> Oxford Science Publishing. </address> <note> to appear in Handbook of Logic in Computer Science. </note>
Reference-contexts: Many of them can be found in conference records and journals on theoretical and implementational aspects of programming languages or in books such as [13]. There is also a book [1] on abstract interpretation. An up-to-date overview and readable introduction to abstract interpretation is <ref> [12] </ref>. With respect to the relevant analysis approaches for reverse engineering one can find examples of abstract interpretations for data-flow analysis [22], functional dependency analysis [23], conditional constant propagation [28], Def-Use-analysis [28] or program slices [8, 29].
Reference: [13] <author> Neil D. Jones, Carsten K. Gomard, and Peter Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: The most powerful techniques in use today to statically analyze programs can be found in modern optimizing compilers for high-level programming languages. In particular, techniques derived from denotational semantics, known as abstract interpretations, become more and more widely used <ref> [13] </ref>. In addition, the methods applied in reverse engineering should have a sound foundation, as the extraction of wrong information during maintenance tasks can lead to new errors in new versions of the programs and has to be avoided. <p> Cousot and R. Cousot [5]. Hence, there already are numerous publications proposing and studying different kinds of program analysis methods in abstract interpretation style. Many of them can be found in conference records and journals on theoretical and implementational aspects of programming languages or in books such as <ref> [13] </ref>. There is also a book [1] on abstract interpretation. An up-to-date overview and readable introduction to abstract interpretation is [12].
Reference: [14] <author> Gilles Kahn. </author> <title> Natural semantics. </title> <booktitle> In STACS, number 247 in LNCS, </booktitle> <pages> pages 22-39. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: The first formal operational semantics, called structural operational semantics, was introduced by G. Plotkin in [25]. A second one, named natural semantics, is derived from structural operational semantics and presented in <ref> [14] </ref>. Both approaches use inductively defined transition systems to formally describe the evaluation relation of programs, i.e. they describe how a program is executed. The difference between the two is that structural operational semantics formalizes single step execution and natural semantics defines evaluation relations for complete execution. <p> Formal operational semantics are closely related to natural deduction systems in mathematical logic in that the transition systems are given by axioms and inference rules as discussed in <ref> [14] </ref>. 8 * Denotational semantics: Denotational semantics, based on work of D. Scott and Ch. Strachey, give the meaning of statements or programs at a more abstract level.
Reference: [15] <author> M. Kiser. </author> <title> The wireable user interface of AEMES. </title> <type> Technical report, </type> <institution> Institut fur Informatik der Universitat Zurich. </institution> <note> to appear. </note>
Reference-contexts: We call the mechanism that we have proposed for tool integration "the wireable user interface". However, it is beyond the scope of this paper to go into more detail, here. Descriptions of the wireable user interface integration mechanism can be found elsewhere <ref> [15] </ref>. 4.3 Data storage It is not very convenient to have the source code form of a COBOL program as a basis of what the tools are working on.
Reference: [16] <author> D. Knuth. </author> <title> The remaining troublespots of ALGOL 60. </title> <journal> Communications of the ACM, </journal> <volume> 10(10) </volume> <pages> 611-617, </pages> <year> 1967. </year>
Reference-contexts: There are informal presentations of semantics, as can be found in programming language manuals. Such descriptions give a rough idea of the meaning of the constructs, but do not always explain the meaning in all possible application contexts. Just remember the famous example of ALGOL 60 <ref> [16] </ref>, where it took several years to detect numerous ambiguities. To have a detailed semantic understanding of the language constructs becomes even more significant in reverse engineering, where one often has to understand programs written by others with different programming styles.
Reference: [17] <author> W. Kozaczynski, J. Ning, and T. Sarver. </author> <title> Program concept recognition. </title> <booktitle> In 7th Knowledge-Based Software Engineering Conference, </booktitle> <address> McLean, Virginia, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: A similar situation arises with regard to the understanding of the functional concepts contained in programs. Such functional concepts are encoded by means of so-called plans. The recognition of such plans has often been performed by 5 means of knowledge based techniques <ref> [24, 17] </ref>. Returning to the main task of adapting and enhancing functionality in existing sources, there are several levels to achieve stepwise enriched knowledge and understanding for existing program sources. Several questions have to be answered in order to accomplish a well-defined change in functional requirements.
Reference: [18] <author> Peter Lee. </author> <title> Realistic Compiler Generation. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: Examples of abstract interpretations include control-flow and data-flow analyses. In addition, denotational semantics and abstract interpretations are easily implemented with the help of modern high-level functional programming languages such as Standard ML and Haskell, or logic programming languages such as Prolog <ref> [18, 27] </ref>. * The formalism named most often in the context of reasoning about program behavior is Hoare logic. But it is somewhat surprising that apart from some specifically 10 designed languages such as Euclid it is only for Pascal that substantial parts have been described by Hoare triples.
Reference: [19] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Having examined the various formal semantics with respect to these requirements, we came to the following conclusions: * Formal operational semantics are widely used nowadays to present formal semantics of real-world programming languages. The most prominent one is the definition of Standard ML <ref> [19] </ref>. There exist descriptions of program analysis techniques in operational terms.
Reference: [20] <author> Peter D. Mosses. </author> <title> Denotational Semantics, </title> <booktitle> volume B of Handbook of Theoretical Computer Science, chapter 11, </booktitle> <pages> pages 575 - 632. </pages> <publisher> The MIT Press / Elsevier, </publisher> <year> 1990. </year> <month> 26 </month>
Reference-contexts: Scott and Ch. Strachey, give the meaning of statements or programs at a more abstract level. A semantics consists of a set of functions, defined inductively over the abstract syntax tree, that map language constructs to mathematical values in what are known as domains <ref> [20, 6, 26, 30] </ref>. One distinguishes between direct-style and continuation-style semantics. Direct-style semantics are perhaps easier to understand at the beginning but become more complicated as soon as the control constructs of a programming language become more involved (e.g. goto's, exceptions).
Reference: [21] <author> F. Nielson and H. Nielson. </author> <title> Finiteness conditions for fixed point iterations. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 96-108, </pages> <year> 1992. </year>
Reference-contexts: There are also publications that investigate the relationship between graph-based and semantics-based static program analysis techniques <ref> [4, 21] </ref>. Especially, [21] is recommended as a thorough investigation of termination properties of different program analyses. Another fact worth emphasizing is that by using continuation-style abstract interpretations one gets MOP -solutions to program analysis problems for free as is shown in [22]. <p> There are also publications that investigate the relationship between graph-based and semantics-based static program analysis techniques [4, 21]. Especially, <ref> [21] </ref> is recommended as a thorough investigation of termination properties of different program analyses. Another fact worth emphasizing is that by using continuation-style abstract interpretations one gets MOP -solutions to program analysis problems for free as is shown in [22].
Reference: [22] <author> Flemming Nielson. </author> <title> A denotational framework for data flow analysis. </title> <journal> Acta Informat-ica, </journal> <pages> pages 265-287, </pages> <year> 1982. </year>
Reference-contexts: There is also a book [1] on abstract interpretation. An up-to-date overview and readable introduction to abstract interpretation is [12]. With respect to the relevant analysis approaches for reverse engineering one can find examples of abstract interpretations for data-flow analysis <ref> [22] </ref>, functional dependency analysis [23], conditional constant propagation [28], Def-Use-analysis [28] or program slices [8, 29]. There are also publications that investigate the relationship between graph-based and semantics-based static program analysis techniques [4, 21]. Especially, [21] is recommended as a thorough investigation of termination properties of different program analyses. <p> Especially, [21] is recommended as a thorough investigation of termination properties of different program analyses. Another fact worth emphasizing is that by using continuation-style abstract interpretations one gets MOP -solutions to program analysis problems for free as is shown in <ref> [22] </ref>. To give an idea of what an abstract interpretation may look like and how it can be applied, we present an abstract interpretation for constructing program slices of the MOVE statement and statement composition in COBOL-74.
Reference: [23] <author> Flemming Nielson and Hanne R. Nielson. </author> <title> Semantics with Applications. </title> <publisher> John Wiley & Sons, </publisher> <year> 1992. </year>
Reference-contexts: The example is taken from <ref> [23] </ref>. As already mentioned, it is not necessary to understand the details of this analysis here. It is only important to observe that this abstract interpretation follows the same pattern as the standard interpretation. <p> There is also a book [1] on abstract interpretation. An up-to-date overview and readable introduction to abstract interpretation is [12]. With respect to the relevant analysis approaches for reverse engineering one can find examples of abstract interpretations for data-flow analysis [22], functional dependency analysis <ref> [23] </ref>, conditional constant propagation [28], Def-Use-analysis [28] or program slices [8, 29]. There are also publications that investigate the relationship between graph-based and semantics-based static program analysis techniques [4, 21]. Especially, [21] is recommended as a thorough investigation of termination properties of different program analyses.
Reference: [24] <author> J. Ning. </author> <title> A Knowledge-Based Approach to Automatic Program Analysis. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> October </month> <year> 1989. </year>
Reference-contexts: A similar situation arises with regard to the understanding of the functional concepts contained in programs. Such functional concepts are encoded by means of so-called plans. The recognition of such plans has often been performed by 5 means of knowledge based techniques <ref> [24, 17] </ref>. Returning to the main task of adapting and enhancing functionality in existing sources, there are several levels to achieve stepwise enriched knowledge and understanding for existing program sources. Several questions have to be answered in order to accomplish a well-defined change in functional requirements.
Reference: [25] <author> Gordon D. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI FN-19, </type> <institution> Dep. of Computer Science, Aarhus University, </institution> <month> September </month> <year> 1981. </year>
Reference-contexts: It is beyond the scope of this paper to review all formal semantic theories and their varieties. Therefore, we concentrate on three standard formal semantics here: * Formal operational semantics: Before the seminal lecture notes of G. Plotkin <ref> [25] </ref> were written, operational semantics of programming languages were defined with the help of abstract machines. <p> The first formal operational semantics, called structural operational semantics, was introduced by G. Plotkin in <ref> [25] </ref>. A second one, named natural semantics, is derived from structural operational semantics and presented in [14]. Both approaches use inductively defined transition systems to formally describe the evaluation relation of programs, i.e. they describe how a program is executed.
Reference: [26] <author> David A. Schmidt. </author> <title> Denotational Semantics A Methodology for Language Development. WM. </title> <address> C. </address> <publisher> Brown Publishers, </publisher> <year> 1986. </year>
Reference-contexts: Scott and Ch. Strachey, give the meaning of statements or programs at a more abstract level. A semantics consists of a set of functions, defined inductively over the abstract syntax tree, that map language constructs to mathematical values in what are known as domains <ref> [20, 6, 26, 30] </ref>. One distinguishes between direct-style and continuation-style semantics. Direct-style semantics are perhaps easier to understand at the beginning but become more complicated as soon as the control constructs of a programming language become more involved (e.g. goto's, exceptions). <p> There exist descriptions of program analysis techniques in operational terms. Unfortunately, to find efficient implementations of the logical rules of a formal operational semantics is not so easy and is the subject of ongoing research [10]. * Denotational semantics is used to provide formal semantics of many programming languages <ref> [26] </ref>. It is a very well understood method. Denotational semantics are also called standard interpretations. The reason for that is that they provide the intended meaning of programs. An advantage of denotational semantics is that there exist abstract interpretations.
Reference: [27] <author> K. Slonneger. </author> <title> Executing continuation semantics: a comparison. </title> <journal> Software-Practice and Experience, </journal> <volume> 23(12) </volume> <pages> 1379-1398, </pages> <year> 1993. </year>
Reference-contexts: Examples of abstract interpretations include control-flow and data-flow analyses. In addition, denotational semantics and abstract interpretations are easily implemented with the help of modern high-level functional programming languages such as Standard ML and Haskell, or logic programming languages such as Prolog <ref> [18, 27] </ref>. * The formalism named most often in the context of reasoning about program behavior is Hoare logic. But it is somewhat surprising that apart from some specifically 10 designed languages such as Euclid it is only for Pascal that substantial parts have been described by Hoare triples.
Reference: [28] <author> G. Venkatesh. </author> <title> A framework for construction and evaluation of high-level specifications for program analysis tehcniques. </title> <booktitle> In ACM SIGPLAN'89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1-12, </pages> <year> 1989. </year>
Reference-contexts: There is also a book [1] on abstract interpretation. An up-to-date overview and readable introduction to abstract interpretation is [12]. With respect to the relevant analysis approaches for reverse engineering one can find examples of abstract interpretations for data-flow analysis [22], functional dependency analysis [23], conditional constant propagation <ref> [28] </ref>, Def-Use-analysis [28] or program slices [8, 29]. There are also publications that investigate the relationship between graph-based and semantics-based static program analysis techniques [4, 21]. Especially, [21] is recommended as a thorough investigation of termination properties of different program analyses. <p> An up-to-date overview and readable introduction to abstract interpretation is [12]. With respect to the relevant analysis approaches for reverse engineering one can find examples of abstract interpretations for data-flow analysis [22], functional dependency analysis [23], conditional constant propagation <ref> [28] </ref>, Def-Use-analysis [28] or program slices [8, 29]. There are also publications that investigate the relationship between graph-based and semantics-based static program analysis techniques [4, 21]. Especially, [21] is recommended as a thorough investigation of termination properties of different program analyses.
Reference: [29] <author> G. Venkatesh. </author> <title> The semantic approach to program slicing. </title> <booktitle> In ACM SIGPLAN'91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 107-119, </pages> <year> 1991. </year>
Reference-contexts: An up-to-date overview and readable introduction to abstract interpretation is [12]. With respect to the relevant analysis approaches for reverse engineering one can find examples of abstract interpretations for data-flow analysis [22], functional dependency analysis [23], conditional constant propagation [28], Def-Use-analysis [28] or program slices <ref> [8, 29] </ref>. There are also publications that investigate the relationship between graph-based and semantics-based static program analysis techniques [4, 21]. Especially, [21] is recommended as a thorough investigation of termination properties of different program analyses.
Reference: [30] <author> Glynn Winskel. </author> <title> The Formal Semantics of Programming Languages. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Scott and Ch. Strachey, give the meaning of statements or programs at a more abstract level. A semantics consists of a set of functions, defined inductively over the abstract syntax tree, that map language constructs to mathematical values in what are known as domains <ref> [20, 6, 26, 30] </ref>. One distinguishes between direct-style and continuation-style semantics. Direct-style semantics are perhaps easier to understand at the beginning but become more complicated as soon as the control constructs of a programming language become more involved (e.g. goto's, exceptions). <p> In contrast, it is much easier to model the control flow of real programming languages with continuations. * Axiomatic semantics: Axiomatic semantics <ref> [9, 30] </ref> describe the meaning of a programming language construct indirectly through partial or total correctness assertions. These assertions provide a means to reason about properties of statements and expressions, but do not really say what the meaning of a construct is.
Reference: [31] <author> H. Zuylen. </author> <title> The REDO Compendium of Reverse-Engineering. </title> <publisher> John Wiley & Sons, </publisher> <year> 1993. </year>
Reference-contexts: The only 23 other project we know of that tried to use some mathematical formalism was the REDO--Project <ref> [31] </ref>. But there, the goal was to employ the formal specification notation Z in order to model abstractions of program behavior. We are convinced that the sound formalisms be it formal programming language theory or formal methods belong to the most powerful techniques available today.
References-found: 31

