URL: http://www.cs.technion.ac.il/~shaulm/papers/naclp89.ps
Refering-URL: http://www.cs.technion.ac.il/~shaulm/research.html
Root-URL: 
Email: (shaul@eecs.umich.edu)  (paul@suna.cmi.com)  
Title: Automatic Ordering of Subgoals a Machine Learning Approach  
Author: Shaul Markovitch Paul D. Scott 
Address: 2001, Commonwealth Blvd., Ann Arbor, Michigan 48105  2001, Commonwealth Blvd., Ann Arbor, Michigan 48105  
Affiliation: EECS Dept., University of Michigan and Center for Machine Intelligence  Center for Machine Intelligence  
Date: (1989)]  
Note: [Appeared in the Proceedings of The North American Conference on Logic Programming Cleveland, Ohio: MIT Press.  
Abstract: This paper describes a learning system, LASSY 1 , which explores domains represented by Prolog databases, and use its acquired knowledge to increase the efficiency of a Prolog interpreter by reordering subgoals. The system creates a model of the tasks it faces and uses the model to generate informative training tasks. While performing the training tasks the system updates its inductive knowledge base which includes statistics about number of solutions and costs of various subgoals calling patterns. The collected averages are used by a subgoal ordering procedure to estimate the costs of subgoals sequences during its search for a good ordering. The paper contains a detailed analysis of the cost computation and a detailed account of the ordering procedure. Experiments done with LASSY show an improvement of performance by a factor of 10. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Brodie, M. L. and Mattias, J., </author> <title> On Integrating Logic Programming and Databases, </title> <editor> in: L. Kerschberg (eds.), </editor> <title> Expert Database Systems, </title> <publisher> The bengamin/Cummings Publishing Company, </publisher> <address> Menlo Park, California, </address> <year> 1986. </year>
Reference-contexts: One particular application of logic programming where the problem of having to specify the control is noticeable is for intelligent databases. Many researchers have suggested that logic programming languages such as Prolog can be an ideal tool for implementing intelligent databases <ref> [1, 4, 16, 22] </ref>. However the inefficient way in which Prolog processes queries [6, 7, 8] is a major obstacle to this approach. It is well known that it is possible to write efficient programs in Prolog, but usually only expert programmers can do so.
Reference: [2] <author> Clark, K. L. and McCabe, F., </author> <title> The Control Facilities of IC-Prolog, </title> <editor> in: D. Michie (eds.), </editor> <booktitle> Expert Systems in The Microelectronic Age., </booktitle> <institution> University of Edinburgh, </institution> <address> Scotland, </address> <year> 1979. </year>
Reference-contexts: The problem is that the programmer has no way of telling the system what parts of the program can be reordered by the system. Writing the program down implicitly specifies the control. POST-Prolog is different from other extensions of Prolog (like IC-Prolog <ref> [2] </ref> and MU-Prolog [13]).
Reference: [3] <author> Debray, S. K. and Warren, D. S., </author> <title> Automatic mode inference for logic programs, </title> <editor> J. </editor> <booktitle> Logic programming 5 </booktitle> <month> 207-229 </month> <year> (1988). </year>
Reference-contexts: Given a subgoal P i , instead of taking the mean over all the bindings generated by the previous subgoals, we will use the mean over a superset of P i . The superset will be the Calling Pattern for P i . The calling pattern is defined after <ref> [3] </ref> , but we use a binary domain, with the elements ground and nonground, while [3] uses a more sophisticated domain with four elements (empty, closed, free and don't know). <p> The superset will be the Calling Pattern for P i . The calling pattern is defined after <ref> [3] </ref> , but we use a binary domain, with the elements ground and nonground, while [3] uses a more sophisticated domain with four elements (empty, closed, free and don't know). <p> C (t i )=1 iff t i is a ground term under the current substitution. Thus, for example, the calling pattern of the goal parent (john,Y) is parent (1,0). As mentioned in <ref> [3] </ref>, the reason for using such patterns is to approximate the unbounded number of literals, that may appear while proving a query, by a finite set of equivalence classes.
Reference: [4] <editor> Gallaire, H. and Minker, J., </editor> <booktitle> Logic and Data Bases, </booktitle> <publisher> Plenum, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: One particular application of logic programming where the problem of having to specify the control is noticeable is for intelligent databases. Many researchers have suggested that logic programming languages such as Prolog can be an ideal tool for implementing intelligent databases <ref> [1, 4, 16, 22] </ref>. However the inefficient way in which Prolog processes queries [6, 7, 8] is a major obstacle to this approach. It is well known that it is possible to write efficient programs in Prolog, but usually only expert programmers can do so.
Reference: [5] <author> Genesereth, M. R. and Nilsson, N. J., </author> <booktitle> Logical foundations of artificial intelligence, </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> Palo Alto, California, </address> <year> 1988. </year>
Reference-contexts: The cost estimates used to evaluate an ordering should approximate as closely as possible the cost of executing the subgoals in the given order. In this section we will try to analyze the cost of executing a sequence of conjuncts. The analysis builds mainly on the work described in <ref> [5, 13, 19, 21] </ref>. <p> That prunes the number of states that can be expanded to 2 n in the worst case. Smith and Genesereth <ref> [5, 19] </ref> proved the Adjacency Theorem which reduces substantially the space of possible orderings that should be searched to find an optimal ordering. <p> The theorem was proved in the context of optimizing a conjunctive query in a database consisting entirely of positive ground literals (this type of problem is called "Sequential constraint satisfaction" in <ref> [5] </ref>). An interesting question is whether the Adjacency Theorem applies also in the case where an execution of a subgoal can carry an arbitrary cost. Unfortunately, the answer is no. To prove it we will show a counter example to one of the corollaries of the theorem. <p> Unfortunately, the answer is no. To prove it we will show a counter example to one of the corollaries of the theorem. The corollary says: Given a conjunct sequence of length two, the less expensive conjunct should always be done first <ref> [5] </ref>. The reader should note that "less expensive" in this context means "smaller number of solutions." Assume that we have a set of two conjuncts -P1,P2- that we want to order. For 9 simplicity, assume that P1 and P2 do not share variables.
Reference: [6] <author> Kowalski, R. A., </author> <title> Logic for Problem Solving, </title> <publisher> Elseveir North Holland, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: 1. Introduction Logic programming is a paradigm that was intended to make programming more declarative than traditional programming languages. The basic idea of logic programming <ref> [6, 7, 8] </ref> is that algorithms consist of two disjoint components; a logic component and a control component. Ideally, logic programming is always declarative, but, unfortunately, this goal can not be completely realized. Hence both types of logic programming are necessary [7]. <p> Many researchers have suggested that logic programming languages such as Prolog can be an ideal tool for implementing intelligent databases [1, 4, 16, 22]. However the inefficient way in which Prolog processes queries <ref> [6, 7, 8] </ref> is a major obstacle to this approach. It is well known that it is possible to write efficient programs in Prolog, but usually only expert programmers can do so.
Reference: [7] <author> Kowalski, R. A., </author> <title> Directions for Logic Programming, </title> <booktitle> in: Proceedings of IEEE Symposium On Logic Programming, </booktitle> <year> 1985. </year> <month> 14 </month>
Reference-contexts: 1. Introduction Logic programming is a paradigm that was intended to make programming more declarative than traditional programming languages. The basic idea of logic programming <ref> [6, 7, 8] </ref> is that algorithms consist of two disjoint components; a logic component and a control component. Ideally, logic programming is always declarative, but, unfortunately, this goal can not be completely realized. Hence both types of logic programming are necessary [7]. <p> The basic idea of logic programming [6, 7, 8] is that algorithms consist of two disjoint components; a logic component and a control component. Ideally, logic programming is always declarative, but, unfortunately, this goal can not be completely realized. Hence both types of logic programming are necessary <ref> [7] </ref>. One particular application of logic programming where the problem of having to specify the control is noticeable is for intelligent databases. Many researchers have suggested that logic programming languages such as Prolog can be an ideal tool for implementing intelligent databases [1, 4, 16, 22]. <p> Many researchers have suggested that logic programming languages such as Prolog can be an ideal tool for implementing intelligent databases [1, 4, 16, 22]. However the inefficient way in which Prolog processes queries <ref> [6, 7, 8] </ref> is a major obstacle to this approach. It is well known that it is possible to write efficient programs in Prolog, but usually only expert programmers can do so.
Reference: [8] <author> Lloyd, J. W., </author> <title> Foundations of Logic Programming, </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: 1. Introduction Logic programming is a paradigm that was intended to make programming more declarative than traditional programming languages. The basic idea of logic programming <ref> [6, 7, 8] </ref> is that algorithms consist of two disjoint components; a logic component and a control component. Ideally, logic programming is always declarative, but, unfortunately, this goal can not be completely realized. Hence both types of logic programming are necessary [7]. <p> Many researchers have suggested that logic programming languages such as Prolog can be an ideal tool for implementing intelligent databases [1, 4, 16, 22]. However the inefficient way in which Prolog processes queries <ref> [6, 7, 8] </ref> is a major obstacle to this approach. It is well known that it is possible to write efficient programs in Prolog, but usually only expert programmers can do so.
Reference: [9] <author> Markovitch, S. and Scott, P. D., </author> <title> Information filters and their implementation in the SYLLOG system, </title> <booktitle> in: Proceedings of The Sixth International Workshop on Machine Learning, </booktitle> <address> Ithaca, New York, </address> <year> 1989. </year>
Reference-contexts: Any learning system that faces a complex domain must be selective and filter out information that is harmful or irrelevant. In <ref> [9] </ref> we have identified five types of selection processes that a learning system can employ: selective experience, selective attention, selective acquisition, selective retention and selective utilization. Our solution to the problem falls under the class of selective experience. <p> The system has both a deductive learning component and an inductive learning component. The inductive component is described in this paper. The deductive learning component, the lemma learner, which is outside the scope of this paper, is described in <ref> [9, 11] </ref>. The design of the LASSY system assumes that the Prolog interpreter receives tasks (queries) from an external source, and that the main goal of the system is to improve the expected average speed with which the interpreter will execute future tasks. <p> This is the maximal cost that the ordering procedure can save. The ordering procedure subtract a fixed amount of resources from its given limit to account for the fixed overhead of using the procedure. This method is an example of selective utilization <ref> [9, 11] </ref>- the system uses a filter to reduce the probability of harmful usage of the acquired knowledge by the problem solver . 5.5.
Reference: [10] <author> Markovitch, S. and Scott, P. D., POST-prolog: </author> <title> Structured Partially Ordered prolog, </title> <type> TR CMI-89-018, </type> <institution> Center for Machine Intelligence, Ann Arbor, Michigan, </institution> <year> 1989. </year>
Reference-contexts: The next subsection describes the architecture of LASSY which was designed to satisfy the assumptions and solve the problems discussed above. This architecture can be generalized to many other learning systems that satisfy those assumptions. 4.1. System architecture The performance element of LASSY is a POST-Prolog interpreter <ref> [10] </ref>. POST-Prolog is a simple extension of Prolog that allows the programmer to specify which parts of programs should be executed in particular order and which parts can be executed in any order that the system wishes. POST-Prolog is described in the appendix. <p> A more detailed account of POST-Prolog is given in <ref> [10] </ref>. Acknowledgements The authors wish to thank Bob Kass, Marcial Losada and Kristina Fayyad for comments on earlier drafts of this paper. 1 The original name of the system was SYLLOG.
Reference: [11] <author> Markovitch, S. and Scott, P. D., </author> <title> Utilization Filtering: a method for reducing the inherent harmfulness of deductively learned knowledge, </title> <booktitle> in: Proceedings of The Eleventh International Joint Conference for Artificial Intelligence, </booktitle> <address> Detroit, Michigan, </address> <year> 1989. </year>
Reference-contexts: The system has both a deductive learning component and an inductive learning component. The inductive component is described in this paper. The deductive learning component, the lemma learner, which is outside the scope of this paper, is described in <ref> [9, 11] </ref>. The design of the LASSY system assumes that the Prolog interpreter receives tasks (queries) from an external source, and that the main goal of the system is to improve the expected average speed with which the interpreter will execute future tasks. <p> This is the maximal cost that the ordering procedure can save. The ordering procedure subtract a fixed amount of resources from its given limit to account for the fixed overhead of using the procedure. This method is an example of selective utilization <ref> [9, 11] </ref>- the system uses a filter to reduce the probability of harmful usage of the acquired knowledge by the problem solver . 5.5.
Reference: [12] <author> Mitchell, T. M., Utgoff, P. E. and Banerji, R., </author> <title> Learning by Experimentation: Acquiring and Refining ProblemSolving Heuristics, </title> <editor> in: R. S. Michalski, J. G. Carbonell and T. M. Mitchell (eds.), </editor> <booktitle> Machine Learning : An Artificial Intelligence Approach, </booktitle> <publisher> Tioga, </publisher> <address> Palo Alto, California, </address> <year> 1983. </year>
Reference-contexts: How is that information to be acquired? We have built a learning system called LASSY which uses a method called "Learning by Experimentation" <ref> [12] </ref>. The program acquires the needed knowledge by repeatedly performing tasks and collecting information while doing so. In our case the tasks are Prolog queries. Since the system can not depend on external sources (teachers) to supply practice problems, the system has to generate them by itself.
Reference: [13] <author> Naish, L., </author> <title> Automatic control for logic programs, </title> <editor> J. </editor> <booktitle> Logic programming 3 </booktitle> <month> 167-183 </month> <year> (1985). </year>
Reference-contexts: It is very likely that the queries submitted will require a substantial amount of computing resources. The main reason is that efficiency of a Prolog program depends strongly on the order in which subgoals are executed <ref> [13, 14, 20, 21] </ref>. Even expert programmers can have problems when ordering the subgoals in rules. A rule whose body contains 8 subgoals can be ordered in more then 40,000 different ways so it is quite likely that an expert programmer may order such a rule in a suboptimal way. <p> Several researchers have explored the possibility of using a program to reorder the subgoals (for example <ref> [13, 19, 21] </ref>). The most comprehensive work in the area of ordering conjuncts was done by Smith and Genesereth [19], and large part of the cost analysis and ordering procedure described here is based upon that work. These studies have several limitations. <p> The cost estimates used to evaluate an ordering should approximate as closely as possible the cost of executing the subgoals in the given order. In this section we will try to analyze the cost of executing a sequence of conjuncts. The analysis builds mainly on the work described in <ref> [5, 13, 19, 21] </ref>. <p> LASSY: a System that Learns domains represented by logic programs. The basic terms of the cost equations (and thus the ordering procedure) are the averages of costs and number of solutions for the various calling patterns. How may these averages be obtained? Naish <ref> [13] </ref> suggested collecting statistics to estimate the number of solutions to calls to database procedures "over some period of typical usage". But what is "typical usage"? This question is part of a set of problems that LASSY as well as many other learning systems have to face. <p> The problem is that the programmer has no way of telling the system what parts of the program can be reordered by the system. Writing the program down implicitly specifies the control. POST-Prolog is different from other extensions of Prolog (like IC-Prolog [2] and MU-Prolog <ref> [13] </ref>).
Reference: [14] <author> Naish, L., </author> <title> Prolog Control Rules, </title> <booktitle> in: Proceedings of IJCAI, </booktitle> <address> Los Angeles, </address> <year> 1985, </year> <pages> pp. 720-722. </pages>
Reference-contexts: It is very likely that the queries submitted will require a substantial amount of computing resources. The main reason is that efficiency of a Prolog program depends strongly on the order in which subgoals are executed <ref> [13, 14, 20, 21] </ref>. Even expert programmers can have problems when ordering the subgoals in rules. A rule whose body contains 8 subgoals can be ordered in more then 40,000 different ways so it is quite likely that an expert programmer may order such a rule in a suboptimal way.
Reference: [15] <author> Nilsson, N. J., </author> <booktitle> Principles of Artificial Intelligence, </booktitle> <publisher> Tioga, </publisher> <address> Palo Alto, CA, </address> <year> 1980. </year>
Reference-contexts: One could claim that this is an advantage, since A* is admissible when h gives an underestimate <ref> [15] </ref>. However, the size of the search space suggests that admissibility is less important than reducing search time. The problem with the function h defined above is that it is not a very "informed" one (Nilsson [15] defines the relation "more informed" between two heuristics functions function h1 is more informed <p> that this is an advantage, since A* is admissible when h gives an underestimate <ref> [15] </ref>. However, the size of the search space suggests that admissibility is less important than reducing search time. The problem with the function h defined above is that it is not a very "informed" one (Nilsson [15] defines the relation "more informed" between two heuristics functions function h1 is more informed than function h2 if h1 always gives better estimate than h2). However, even after relaxing the admissibility constraint, we could not develop a better heuristic. 5.4.
Reference: [16] <author> Parker, S. D., et al., </author> <title> Logic Programming and Databases, </title> <booktitle> in: Proceedings of Expert Database Systems - Proceedings From the First International Workshop, </booktitle> <year> 1986, </year> <pages> pp. 35-48. </pages>
Reference-contexts: One particular application of logic programming where the problem of having to specify the control is noticeable is for intelligent databases. Many researchers have suggested that logic programming languages such as Prolog can be an ideal tool for implementing intelligent databases <ref> [1, 4, 16, 22] </ref>. However the inefficient way in which Prolog processes queries [6, 7, 8] is a major obstacle to this approach. It is well known that it is possible to write efficient programs in Prolog, but usually only expert programmers can do so.
Reference: [17] <author> Pearl, J., </author> <title> Heuristics : intelligent search strategies for computer problem solving, </title> <publisher> Addison-Wesley, </publisher> <year> 1984. </year>
Reference-contexts: Using the obvious transformation to the Traveling Salesman Problem, each city will be mapped to a subgoal and the task of finding a path with minimal cost between the cities maps into the task of finding an ordering with minimal cost. Several heuristics have been developed for solving TSP <ref> [17] </ref>. However, there is one difference that makes the ordering problem "harder" than the TSP - the cost of getting from one "city" to another can only be known when visiting that "city", and it depends on the path that was used to get there.
Reference: [18] <author> Scott, P. D. and Markovitch, S., </author> <title> Uncertainty Based Selection of Learning Experiences, </title> <booktitle> in: Proceedings of The Sixth International Workshop on Machine Learning, </booktitle> <address> Ithaca, New York, </address> <year> 1989. </year>
Reference-contexts: During the performance of the test with random ordering, the execution of half of the queries was halted after 20000 unifications. Thus, the actual improvement in performance should be much higher than 10 times. 7. Future Research In <ref> [18] </ref> we have argued that one of the reasons for having the learning system generate its own experiences is that generation of informative experience requires knowledge of the 12 current state of the system's own representation (which is not available to an external agents).
Reference: [19] <author> Smith, D. E. and Genesereth, M. R., </author> <title> Ordering Conjunctive Queries, </title> <booktitle> Artificial Intelligence 26 </booktitle> <month> 171-215 </month> <year> (1985). </year>
Reference-contexts: Several researchers have explored the possibility of using a program to reorder the subgoals (for example <ref> [13, 19, 21] </ref>). The most comprehensive work in the area of ordering conjuncts was done by Smith and Genesereth [19], and large part of the cost analysis and ordering procedure described here is based upon that work. These studies have several limitations. <p> Several researchers have explored the possibility of using a program to reorder the subgoals (for example [13, 19, 21]). The most comprehensive work in the area of ordering conjuncts was done by Smith and Genesereth <ref> [19] </ref>, and large part of the cost analysis and ordering procedure described here is based upon that work. These studies have several limitations. Most of them dealt with reordering of conjunctive queries and did not handle bodies of rules. <p> Finally, the problem of ensuring that the cost of ordering will not outweigh the expected gain was not addressed appropriately. Section 2 will outline our basic approach to eliminating those problems. 2. The basic approach - using machine learning Our approach develops the basic method of Smith and Genesereth <ref> [19] </ref> to include rules as well as ground clauses. The problem is that the cost and number of solutions of subgoals must be obtained before ordering can be performed. <p> Section 4 describes the LASSY system. After deciding what knowledge the system needs to acquire and how to acquire it, we need to how to use that knowledge. We have followed Smith and Genesereth <ref> [19] </ref> in performing a search of the space of partial sequences in order to find the optimal one. The main problem with this approach is that exhaustive search is of exponential complexity, thus performing it may cause the costs of ordering to outweigh its benefits. <p> The cost estimates used to evaluate an ordering should approximate as closely as possible the cost of executing the subgoals in the given order. In this section we will try to analyze the cost of executing a sequence of conjuncts. The analysis builds mainly on the work described in <ref> [5, 13, 19, 21] </ref>. <p> Given a goal G and a rule P :- P 1 ,...,P n where P matches G, what is the cost of proving P' 1 ,...,P' n (where P' i is P i under the binding generated by unifying G and P)? For simplicity, we will follow Smith's <ref> [19] </ref> simplification of computing the cost for "all solutions" queries. Define COST (P i ) as the resources needed to compute the whole search tree of the subgoal P i . <p> That prunes the number of states that can be expanded to 2 n in the worst case. Smith and Genesereth <ref> [5, 19] </ref> proved the Adjacency Theorem which reduces substantially the space of possible orderings that should be searched to find an optimal ordering.
Reference: [20] <author> Sterling, L. and Shapiro, E., </author> <title> The Art of Prolog, </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1986. </year>
Reference-contexts: It is very likely that the queries submitted will require a substantial amount of computing resources. The main reason is that efficiency of a Prolog program depends strongly on the order in which subgoals are executed <ref> [13, 14, 20, 21] </ref>. Even expert programmers can have problems when ordering the subgoals in rules. A rule whose body contains 8 subgoals can be ordered in more then 40,000 different ways so it is quite likely that an expert programmer may order such a rule in a suboptimal way.
Reference: [21] <author> Warren, D. H. D., </author> <title> Efficient Processing of Interactive Relational Data Base Queries Expressed in Logic, </title> <booktitle> in: Proceedings of Seventh International Conference on Very Large Data Bases, </booktitle> <year> 1981. </year>
Reference-contexts: It is very likely that the queries submitted will require a substantial amount of computing resources. The main reason is that efficiency of a Prolog program depends strongly on the order in which subgoals are executed <ref> [13, 14, 20, 21] </ref>. Even expert programmers can have problems when ordering the subgoals in rules. A rule whose body contains 8 subgoals can be ordered in more then 40,000 different ways so it is quite likely that an expert programmer may order such a rule in a suboptimal way. <p> Several researchers have explored the possibility of using a program to reorder the subgoals (for example <ref> [13, 19, 21] </ref>). The most comprehensive work in the area of ordering conjuncts was done by Smith and Genesereth [19], and large part of the cost analysis and ordering procedure described here is based upon that work. These studies have several limitations. <p> The cost estimates used to evaluate an ordering should approximate as closely as possible the cost of executing the subgoals in the given order. In this section we will try to analyze the cost of executing a sequence of conjuncts. The analysis builds mainly on the work described in <ref> [5, 13, 19, 21] </ref>.
Reference: [22] <author> Zaniolo, C., </author> <title> Prolog: A Database Query Language for All Seasons, </title> <editor> in: L. Kerschberg (eds.), </editor> <title> Expert Database Systems, </title> <publisher> The bengamin/Cummings Publishing Company, </publisher> <address> Menlo Park, California, </address> <year> 1986. </year>
Reference-contexts: One particular application of logic programming where the problem of having to specify the control is noticeable is for intelligent databases. Many researchers have suggested that logic programming languages such as Prolog can be an ideal tool for implementing intelligent databases <ref> [1, 4, 16, 22] </ref>. However the inefficient way in which Prolog processes queries [6, 7, 8] is a major obstacle to this approach. It is well known that it is possible to write efficient programs in Prolog, but usually only expert programmers can do so.
References-found: 22

