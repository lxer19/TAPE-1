URL: http://www.cs.cornell.edu/Info/People/kreitz/PS-files/90-Represent-red.ps.gz
Refering-URL: http://www.cs.cornell.edu/Info/People/kreitz/papers.html
Root-URL: http://www.cs.cornell.edu
Title: The Representation of Program Synthesis in Higher Order Logic  
Author: Christoph Kreitz 
Address: Alexanderstr. 10, D-6100 Darmstadt  
Affiliation: FG Intellektik FB Informatik Technische Hochschule Darmstadt  
Abstract: Systems built for automated program construction aim at the formalization of the programming process in order to produce better software. Their implementations, however, suffer from problems similar to those they are intended to solve. Due to a lack of abstraction in the formalization of deductive mechanisms involved in programming reasoning tools for the development of program synthesizers are not yet available. For that, systems capable of formal reasoning about both programs and programming methods are needed. In this paper we develop principles of a formal theory on reasoning about programs and program construction within a unified higher order framework. By an exemplified formalization of principal approaches to program synthesis we will show that a higher degree of abstraction leads to clearer insights into the meta-mathematics of program construction. Ridding the representation of deductive methods from superfluous context also results in simpler, sometimes almost trivial, proofs. Simplicity is one of the most important features of the formal theory and quite valuable if one considers the wide range of intended applications. We present the theory in a highly formalized form built on top of Intuitionistic Type Theory. This allows us to straightforwardly implemented the concepts developed here with a proof system for Type Theory and derive verified implementations of deductive mechanisms from mechanically proven theorems.
Abstract-found: 1
Intro-found: 1
Reference: [And86] <author> Peter B. Andrews. </author> <title> An Introduction to mathematical logic and Type Theory: To Truth through Proof. </title> <publisher> Academic Press, </publisher> <address> London, Orlando, </address> <year> 1986. </year>
Reference: [BC85] <author> Joseph L. Bates and Robert L. Constable. </author> <title> Proofs as programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(1) </volume> <pages> 113-136, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: Since Type Theory is a comparably young formalism there are still various dialects of it each using a slightly different syntax. We will use the one of NuPRL <ref> [CAB + 86, BC85] </ref>, a descendent of Martin-Lof's Type Theory [ML82], because for this dialect an interactive proof development system, a tool to implement our theory, is already available. 2.3 NuPRL's proof calculus for Type Theory Types and members of types, as we already mentioned, are the basic objects of reasoning <p> It stays hidden up to completion of the proof. Thus sequents implicitely describe an algorithm constructing a member for the conclusion (a witness for its truth) from the assumptions. Consequently, algorithms can be specified in form of mathematical propositions implicitely asserting their existence. This so-called proofs-as-programs paradigm <ref> [BC85] </ref> is of particular importance for embedding a theory of program development into NuPRL. NuPRL's proof calculus supports a top-down development of this algorithm. Proof rules allow to refine a goal, obtaining subgoals such that an algorithm for the main goal can be constructed from partial solutions for the subgoals. <p> IC (spec)(x))body (p)(x)=fy:OUT (spec)|IOR (spec)(x,y)g M-SOLVABLE (spec) 9p:M-PROGRAMS. M-FULFILS (spec,p) 4.2 A formal investigation of approaches to program synthesis It has widely been held that there are essentially two different ideologies in program synthesis. * The so-called theorem proving or AE approaches <ref> [MW80, BC85, Fra85] </ref> arose from the idea that constructing a program and proving it logically correct should be done at the same time.
Reference: [BD77] <author> R. M. Burstall and J. Darlington. </author> <title> A transformation system for developing recursive programs. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 24(1) </volume> <pages> 44-67, </pages> <month> January </month> <year> 1977. </year>
Reference-contexts: bottom up by investigating properties of individual statements, loops, subprograms etc. a constructive proof for the (AE-) theorem 8x : IN:9y : OU T: IC (x))IOR (x; y) will be build and a program of a particular (functional) language will be extracted from it. * In the transformation based approaches <ref> [BD77, MW79, Bib80, Hog81, SL89] </ref> a new predicate P (x; y) represent ing a new program P with input x and output y is defined by 8x : IN:8y : OU T:IC (x))P (x; y),IOR (x; y) and the body for the program P is generated by transforming IOR (x; y)
Reference: [BH84] <author> Wolfgang Bibel and K. M. Hornig. </author> <title> LOPS a system based on a strategical approach to program synthesis. </title> <editor> In Alan W. Biermann, G. Guiho, and Y. Kodratoff, editors, </editor> <title> Automatic program construction techniques, </title> <booktitle> chapter 3, </booktitle> <pages> pages 69-89. </pages> <publisher> MacMillan, </publisher> <address> New York, </address> <year> 1984. </year>
Reference-contexts: Faithfulness becomes important only when embedding particular approaches to program synthesis into the framework is studied. As running example we chose the LOPS-system <ref> [Bib80, BH84] </ref> which may be briefly summarized as follows: Starting with a specification of the form "8i9y ( IC (i) )OC (i,y) )" where i and y represent input and output variable, IC some input condition, and OC the relation between input and output (output condition) the goal is to achieve
Reference: [Bib80] <author> Wolfgang Bibel. </author> <title> Syntax-directed, semantics-supported program synthesis. </title> <journal> Artificial Intelligence, </journal> <volume> 14(3) </volume> <pages> 243-261, </pages> <month> October </month> <year> 1980. </year>
Reference-contexts: Faithfulness becomes important only when embedding particular approaches to program synthesis into the framework is studied. As running example we chose the LOPS-system <ref> [Bib80, BH84] </ref> which may be briefly summarized as follows: Starting with a specification of the form "8i9y ( IC (i) )OC (i,y) )" where i and y represent input and output variable, IC some input condition, and OC the relation between input and output (output condition) the goal is to achieve <p> In order to meaningfully restrict the search for g by some domain condition dom (i; g) <ref> [Bib80] </ref> proposes to choose dom (i; g) from among the subsets of the conjuncts in OC (i; g) such that it will be possible to compute some g with dom (i; g). <p> A programming problem typically is described by specifying Input and Output-domain, a possible precondition IC on the input, and the relation IOR between input and output. Using a precondition instead of restricting the input domain is not used in all approaches but quite common (see e.g. <ref> [Bib80, SL89] </ref>). Obviously, the domains (IN; OU T ) should be first-order types and IC; IOR must be first-order formulae over the appropriate types. <p> bottom up by investigating properties of individual statements, loops, subprograms etc. a constructive proof for the (AE-) theorem 8x : IN:9y : OU T: IC (x))IOR (x; y) will be build and a program of a particular (functional) language will be extracted from it. * In the transformation based approaches <ref> [BD77, MW79, Bib80, Hog81, SL89] </ref> a new predicate P (x; y) represent ing a new program P with input x and output y is defined by 8x : IN:8y : OU T:IC (x))P (x; y),IOR (x; y) and the body for the program P is generated by transforming IOR (x; y) <p> Note that for this the position of predicates and quantifiers had to be changed resulting in a form equivalent to the one given in <ref> [Bib80] </ref>. (Essentially independent conditions have to be moved across quantifiers.) T guess (A,dom,t)(&lt;IN,OUT,IC,IOR&gt;) &lt;IN, OUT, IC, i,y.8g:A. dom (i,g) ) IOR (i,y) & (t (g,y)|:t (g,y))&gt; The following theorem which may be considerd a reformulation of Theorem 3.3 gives clearer insights into the deductive behaviour the GUESS transformation.
Reference: [CAB + 86] <author> Robert L. Constable, Stuart F. Allen, H. Mark Bromley, W. Rance Cleaveland, J. F. Cremer, Robert W. Harper, Douglas J. Howe, Todd B. Knoblock, Nax Paul Mendler, Prakash Panangaden, Jim T. Sasaki, and Scott F. Smith. </author> <title> Implementing Mathematics with the NuPRL proof development system. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1986. </year>
Reference-contexts: Since Type Theory is a comparably young formalism there are still various dialects of it each using a slightly different syntax. We will use the one of NuPRL <ref> [CAB + 86, BC85] </ref>, a descendent of Martin-Lof's Type Theory [ML82], because for this dialect an interactive proof development system, a tool to implement our theory, is already available. 2.3 NuPRL's proof calculus for Type Theory Types and members of types, as we already mentioned, are the basic objects of reasoning <p> A (sorted, constructive) predicate logic, though not part of the type system itself can be expressed using the propositions-as-types correspondence. Syntax and some details of the type system are listed in Figure 1. We refer the reader to <ref> [CAB + 86] </ref> for a full presentation of NuPRL's Type Theory. Statements are expressed in the form of sequents.
Reference: [Chu40] <author> Alonzo Church. </author> <title> A formulation of the simple theory of types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 5 </volume> <pages> 56-68, </pages> <year> 1940. </year>
Reference: [Der85] <author> Nachum Dershowitz. </author> <title> Synthesis by completion. </title> <editor> In A. Joshi, editor, </editor> <booktitle> IJCAI-85 | Proceedings of the 9 th International Joint Conference on Artificial Intelligence, </booktitle> <address> Los Angeles, </address> <month> August </month> <year> 1985, </year> <pages> pages 208-214, </pages> <year> 1985. </year>
Reference: [Dij76] <author> Edsger W. Dijkstra. </author> <title> A discipline of Programming. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1976. </year>
Reference: [Fra85] <author> Marta Franova. </author> <title> A methodology for automatic programming based on the constructive matching strategy. </title> <booktitle> In EUROCAL 85, </booktitle> <pages> pages 568-570. </pages> <publisher> Springer Verlag, </publisher> <year> 1985. </year>
Reference-contexts: IC (spec)(x))body (p)(x)=fy:OUT (spec)|IOR (spec)(x,y)g M-SOLVABLE (spec) 9p:M-PROGRAMS. M-FULFILS (spec,p) 4.2 A formal investigation of approaches to program synthesis It has widely been held that there are essentially two different ideologies in program synthesis. * The so-called theorem proving or AE approaches <ref> [MW80, BC85, Fra85] </ref> arose from the idea that constructing a program and proving it logically correct should be done at the same time.
Reference: [GMW79] <author> Michael J. Gordon, Robin Milner, and Christopher P. Wadsworth. </author> <title> Edinburgh LCF: A mechanized Logic of Computation. </title> <booktitle> Number 78 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1979. </year>
Reference-contexts: Besides a highly visual proof-editor for interactive development of proofs and extraction of their computational contents a definition mechanism allows to abstract from low-level type theoretical expressions and enhance readability of mechanical proofs. In addition to that a high-level programming language ML, originally developed for Edinburgh's LCF System <ref> [GMW79] </ref>, serves as the meta-language of NuPRL allowing a user to write meta-programs guiding the application of refinement rules. This is particularly interesting for creating new deduction rules on top of NuPRL by, for instance, applying higher-order theorems about programming methods to first-order problems.
Reference: [Gri81] <editor> David Gries. </editor> <booktitle> The science of programming. </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, Heidelberg, New-York, </address> <year> 1981. </year>
Reference: [Hog81] <author> C. J. </author> <title> Hogger. Derivation of logic programs. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 28(2) </volume> <pages> 372-392, </pages> <month> April </month> <year> 1981. </year>
Reference-contexts: bottom up by investigating properties of individual statements, loops, subprograms etc. a constructive proof for the (AE-) theorem 8x : IN:9y : OU T: IC (x))IOR (x; y) will be build and a program of a particular (functional) language will be extracted from it. * In the transformation based approaches <ref> [BD77, MW79, Bib80, Hog81, SL89] </ref> a new predicate P (x; y) represent ing a new program P with input x and output y is defined by 8x : IN:8y : OU T:IC (x))P (x; y),IOR (x; y) and the body for the program P is generated by transforming IOR (x; y)
Reference: [ML82] <author> Per Martin-Lof. </author> <title> Constructive mathematics and computer programming. </title> <booktitle> In 6-th International Congress for Logic, Methodology and Philosophy of Science, </booktitle> <year> 1979, </year> <pages> pages 153-175. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1982. </year>
Reference-contexts: Since Type Theory is a comparably young formalism there are still various dialects of it each using a slightly different syntax. We will use the one of NuPRL [CAB + 86, BC85], a descendent of Martin-Lof's Type Theory <ref> [ML82] </ref>, because for this dialect an interactive proof development system, a tool to implement our theory, is already available. 2.3 NuPRL's proof calculus for Type Theory Types and members of types, as we already mentioned, are the basic objects of reasoning in Type Theory. <p> Formally, a program is a function from input to output space, a view supported by <ref> [ML82, SL89] </ref> and constructive mathematicians. Including the domains as necessary information the type of all programs is represented by PROGRAMS IN:TYPES # OUT:TYPES # (IN ! OUT) Again, we denote the destructors of a program p=&lt;IN,OUT,body&gt; 2 PROGRAMS by the obvious names.
Reference: [MW79] <author> Zohar Manna and Richard J. Waldinger. </author> <title> Synthesis: Dreams ) programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-5(4):294-328, </volume> <month> July </month> <year> 1979. </year>
Reference-contexts: bottom up by investigating properties of individual statements, loops, subprograms etc. a constructive proof for the (AE-) theorem 8x : IN:9y : OU T: IC (x))IOR (x; y) will be build and a program of a particular (functional) language will be extracted from it. * In the transformation based approaches <ref> [BD77, MW79, Bib80, Hog81, SL89] </ref> a new predicate P (x; y) represent ing a new program P with input x and output y is defined by 8x : IN:8y : OU T:IC (x))P (x; y),IOR (x; y) and the body for the program P is generated by transforming IOR (x; y)
Reference: [MW80] <author> Zohar Manna and Richard J. Waldinger. </author> <title> A deductive approach to program synthesis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 2(1) </volume> <pages> 90-121, </pages> <year> 1980. </year>
Reference-contexts: IC (spec)(x))body (p)(x)=fy:OUT (spec)|IOR (spec)(x,y)g M-SOLVABLE (spec) 9p:M-PROGRAMS. M-FULFILS (spec,p) 4.2 A formal investigation of approaches to program synthesis It has widely been held that there are essentially two different ideologies in program synthesis. * The so-called theorem proving or AE approaches <ref> [MW80, BC85, Fra85] </ref> arose from the idea that constructing a program and proving it logically correct should be done at the same time.
Reference: [Pau87] <author> Lawrence C. Paulson. </author> <title> The representation of logics in higher-order logic. </title> <type> Technical Report 113, </type> <institution> University of Cambridge. Computer Laboratory, </institution> <month> August </month> <year> 1987. </year>
Reference-contexts: However, it lacks uniformity and formality and cannot say anything about the actual implementation. These gaps could be filled by a further formalization within our theory. Similar work by Paulson <ref> [Pau87] </ref> representing various logics by modelling their semantics in higher order logics (but not investigating proof calculi) indicates that our formalism is not restricted to the area of programming but can be generalized to reasoning about other deductive mechanisms like logical calculi as well.
Reference: [SL89] <author> Douglas R. Smith and Michael R. Lowry. </author> <title> Algorithm design and design tactics. </title> <editor> In L. van de Snepscheut, editor, </editor> <booktitle> Proceedings of the International Conference on the Mathematics of Program Construction, volume 375 of Lecture Notes in Computer Science, </booktitle> <pages> pages 379-398. </pages> <publisher> Springer Verlag, </publisher> <year> 1989. </year>
Reference-contexts: A programming problem typically is described by specifying Input and Output-domain, a possible precondition IC on the input, and the relation IOR between input and output. Using a precondition instead of restricting the input domain is not used in all approaches but quite common (see e.g. <ref> [Bib80, SL89] </ref>). Obviously, the domains (IN; OU T ) should be first-order types and IC; IOR must be first-order formulae over the appropriate types. <p> Formally, a program is a function from input to output space, a view supported by <ref> [ML82, SL89] </ref> and constructive mathematicians. Including the domains as necessary information the type of all programs is represented by PROGRAMS IN:TYPES # OUT:TYPES # (IN ! OUT) Again, we denote the destructors of a program p=&lt;IN,OUT,body&gt; 2 PROGRAMS by the obvious names. <p> bottom up by investigating properties of individual statements, loops, subprograms etc. a constructive proof for the (AE-) theorem 8x : IN:9y : OU T: IC (x))IOR (x; y) will be build and a program of a particular (functional) language will be extracted from it. * In the transformation based approaches <ref> [BD77, MW79, Bib80, Hog81, SL89] </ref> a new predicate P (x; y) represent ing a new program P with input x and output y is defined by 8x : IN:8y : OU T:IC (x))P (x; y),IOR (x; y) and the body for the program P is generated by transforming IOR (x; y) <p> A formal theorem that such a program can be constructed reads as follows 9p:M-PROGRAMS.8x:IN (p). IC (x)) body (p)(x)=fy:OUT (p)|IOR (x,y)g This form which is nearly the same as the one of <ref> [SL89] </ref> (probably the most mature of all the approaches so far) is absolutely identical to M-SOLVABLE (&lt;IN, OUT, IC, IOR&gt;), i.e. the synthesis problem for multivalued functions. <p> Another appealing path to be followed is embedding already existing approaches to program synthesis into our framework. There is, for instance, already a theory behind the KIDS system <ref> [SL89] </ref> which proves its program construction methods correct on some mathematical level. However, it lacks uniformity and formality and cannot say anything about the actual implementation. These gaps could be filled by a further formalization within our theory.
Reference: [Smi88] <author> Douglas R. Smith. </author> <title> KIDS | a knowledge-based software development system. </title> <editor> In M. R. Lowry, R. McCart-ney, and D. R. Smith, editors, </editor> <booktitle> Proceedings of the Workshop on Automating Software Design. AAAI-88, </booktitle> <address> St. Paul, MN, </address> <month> August 25, </month> <year> 1988, </year> <pages> pages 182-188, </pages> <year> 1988. </year>
References-found: 19

