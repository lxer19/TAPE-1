URL: http://www.cs.brown.edu/courses/cs252/graph/lin_planar_test.ps.Z
Refering-URL: http://www.cs.brown.edu/courses/cs252/graph/home.html
Root-URL: http://www.cs.brown.edu/
Author: C.S. Prof. Roberto Tamassia Scribe: George Wynne 
Keyword: Linear-Time Planarity Testing  
Date: September 15, 1993  
Note: Computational Geometry Sem. II, 1992-1993  Date:  
Abstract: The algorithm outlined by this paper determines in linear time if an arbitrary graph can be drawn such that no edges cross (i.e., the graph is planar). Edges do not necessarily have to be straight. The first main section of the paper, Definitions and Easy Preliminaries, was based on Hopcroft and Tarjan's algorithm [1] for determining planarity. The rest is based primarily on Cai, Han, and Tarjan's simplification [2] of Hopcroft and Tarjan's algorithm. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Hopcroft, J. and Tarjan, R. </author> <title> Efficient Planarity Testing. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> Vol. 21, No. 4, </volume> <month> October </month> <year> 1974, </year> <pages> pp. 549-568. </pages>
Reference-contexts: If a block B does not interlace with another, we pair it with an empty block: [;; B]. the back edge on the right. B 1 = <ref> [1] </ref>, and B 2 = [2; 3]. Because these blocks interlace, we make a pair [B 1 ; B 2 ]. When we have more than one pair of blocks, we order the pairs. <p> To merge blocks, and to keep them in the specified block order, we just concatenate them in the order in which they appear in P (e i ). For example, if P (e 4 ) = [[;; <ref> [1; 4] </ref>]; [;; [6; 7]]], then we would let B 4 = [1; 4; 6; 7]. Why do we do this? As Figure 12 demonstrates, a cycle is formed by the tree below e 1 and by the path from e 1 to low1 (e 1 ). <p> To merge blocks, and to keep them in the specified block order, we just concatenate them in the order in which they appear in P (e i ). For example, if P (e 4 ) = [[;; [1; 4]]; [;; [6; 7]]], then we would let B 4 = <ref> [1; 4; 6; 7] </ref>. Why do we do this? As Figure 12 demonstrates, a cycle is formed by the tree below e 1 and by the path from e 1 to low1 (e 1 ). <p> First, the back edges perform these functions. When e = <ref> [17; 1] </ref>, low1 (e) = 1 (e) = 2 Similarly, when e = [17; 2], low1 (e) = 2 (e) = 4 Then we "retreat" to [16; 17]. At this point, we sort the edges leaving the vertex numbered 17 into a list L (e) = [[17; 1]; [17; 2]]. <p> When e = [17; 1], low1 (e) = 1 (e) = 2 Similarly, when e = [17; 2], low1 (e) = 2 (e) = 4 Then we "retreat" to [16; 17]. At this point, we sort the edges leaving the vertex numbered 17 into a list L (e) = <ref> [[17; 1] </ref>; [17; 2]]. For e = [16; 17], we say that low1 (e) = low1 [17; 1] = 1 (e) = 2low1 (e) + 1 = 3 After the values for [16; 2] and [16; 3] are computed, we retreat once again to e = [10; 16]. <p> At this point, we sort the edges leaving the vertex numbered 17 into a list L (e) = [<ref> [17; 1] </ref>; [17; 2]]. For e = [16; 17], we say that low1 (e) = low1 [17; 1] = 1 (e) = 2low1 (e) + 1 = 3 After the values for [16; 2] and [16; 3] are computed, we retreat once again to e = [10; 16]. <p> Notice the properties of this function, as discussed in section 4. Step 2: There are no blocks in P (e 1 ) such that last (B) &gt; low1 (e 2 ), so we let B 1 = ;, and we put the pair [;; <ref> [1] </ref>] into the beginning of P (e). Step 3: Since B 1 = ;, we let CP = [;; B 2 ], and we put this at the end of P (e). P (e) = [[;; [1]]; [;; [2]]]. <p> ), so we let B 1 = ;, and we put the pair [;; <ref> [1] </ref>] into the beginning of P (e). Step 3: Since B 1 = ;, we let CP = [;; B 2 ], and we put this at the end of P (e). P (e) = [[;; [1]]; [;; [2]]]. Step 4: No action. * e = [10; 16]: e 2 = [16; 2]; P (e 2 ) = [[;; [2]]] Step 1: B 2 = [2], B 3 = [3]. <p> Step 2: Again, none of the blocks in P (e 1 ) have the property last (B) &gt; low1 (e 2 ), so we let B 1 = ;, and we put the pairs [;; <ref> [1] </ref>] and [;; [2]] into the beginning of P (e). Step 3: CP = [;; B 2 ] = [;; [2]]. Then we see that 3 = f irst (B 3 ) &gt; last (Y ) = 2, so those blocks do not interlace. <p> Then we see that 3 = f irst (B 3 ) &gt; last (Y ) = 2, so those blocks do not interlace. Therefore, we create the new pair [;; [3]], and we put it at the end of P (e). P (e) = [[;; <ref> [1] </ref>]; [;; [2]]; [;; [2]]; [;; [3]]]. <p> Also, if any of the pairs in P (e 2 ) contained two, nonempty, interlacing blocks, we would declare the graph to be nonplanar. Step 2: B 1 = ;, P (e) = [[;; <ref> [1] </ref>]]. Step 3: P (e) = [[;; [1]]; [;; [5; 9; 11]]]. Step 4: Remove the instance of 11. P (e) = [[;; [1]]; [;; [5; 9]]]. * e = [10; 11]: Steps 1-3: Again, we only have one edge leaving 11. P (e) = P (e 1 ). <p> Also, if any of the pairs in P (e 2 ) contained two, nonempty, interlacing blocks, we would declare the graph to be nonplanar. Step 2: B 1 = ;, P (e) = [[;; <ref> [1] </ref>]]. Step 3: P (e) = [[;; [1]]; [;; [5; 9; 11]]]. Step 4: Remove the instance of 11. P (e) = [[;; [1]]; [;; [5; 9]]]. * e = [10; 11]: Steps 1-3: Again, we only have one edge leaving 11. P (e) = P (e 1 ). <p> Step 2: B 1 = ;, P (e) = [[;; <ref> [1] </ref>]]. Step 3: P (e) = [[;; [1]]; [;; [5; 9; 11]]]. Step 4: Remove the instance of 11. P (e) = [[;; [1]]; [;; [5; 9]]]. * e = [10; 11]: Steps 1-3: Again, we only have one edge leaving 11. P (e) = P (e 1 ). <p> P (e) = P (e 1 ). Step 4: No action. 19 * e = [9; 10]: Because [10; 16] = [10; 11] = 3, e 1 could be either of those edges. Suppose that e 1 = [10; 11]; P (e 1 ) = [[;; <ref> [1] </ref>]; [;; [5; 9]]] Step 1: We merge the blocks in P (e 2 ), again checking for interlacing. B 2 = [1; 2; 3]. (Duplicate numbers can be omitted.) Step 2: B 1 = [5; 9], and P (e) = [;; [1]]. Step 3: CP = [;; [5; 9]]. <p> Suppose that e 1 = [10; 11]; P (e 1 ) = [[;; [1]]; [;; [5; 9]]] Step 1: We merge the blocks in P (e 2 ), again checking for interlacing. B 2 = <ref> [1; 2; 3] </ref>. (Duplicate numbers can be omitted.) Step 2: B 1 = [5; 9], and P (e) = [;; [1]]. Step 3: CP = [;; [5; 9]]. Because 1 = f irst (B 2 ) &lt; last (Y ) = 9, we let CP = [[1; 2; 3]; [5; 9]]. <p> [10; 11]; P (e 1 ) = [[;; <ref> [1] </ref>]; [;; [5; 9]]] Step 1: We merge the blocks in P (e 2 ), again checking for interlacing. B 2 = [1; 2; 3]. (Duplicate numbers can be omitted.) Step 2: B 1 = [5; 9], and P (e) = [;; [1]]. Step 3: CP = [;; [5; 9]]. Because 1 = f irst (B 2 ) &lt; last (Y ) = 9, we let CP = [[1; 2; 3]; [5; 9]]. P (e) = [[;; [1]]; [[1; 2; 3]; [5; 9]]]. Step 4: Remove 9: P (e) = [[;; [1]]; [[1; <p> can be omitted.) Step 2: B 1 = [5; 9], and P (e) = [;; <ref> [1] </ref>]. Step 3: CP = [;; [5; 9]]. Because 1 = f irst (B 2 ) &lt; last (Y ) = 9, we let CP = [[1; 2; 3]; [5; 9]]. P (e) = [[;; [1]]; [[1; 2; 3]; [5; 9]]]. Step 4: Remove 9: P (e) = [[;; [1]]; [[1; 2; 3]; [5]]]. [[;; [1]]; [[1; 2; 3]; [5; 9]]]. * e = [8; 9]: This is another trivial case: P (e) = P [9; 10]. * e = [7; 8]: e 2 = [8; <p> [;; <ref> [1] </ref>]. Step 3: CP = [;; [5; 9]]. Because 1 = f irst (B 2 ) &lt; last (Y ) = 9, we let CP = [[1; 2; 3]; [5; 9]]. P (e) = [[;; [1]]; [[1; 2; 3]; [5; 9]]]. Step 4: Remove 9: P (e) = [[;; [1]]; [[1; 2; 3]; [5]]]. [[;; [1]]; [[1; 2; 3]; [5; 9]]]. * e = [8; 9]: This is another trivial case: P (e) = P [9; 10]. * e = [7; 8]: e 2 = [8; 6]; P (e 2 ) = [[;; [6]] Step 1: B 2 = [6]. <p> Because 1 = f irst (B 2 ) &lt; last (Y ) = 9, we let CP = [[1; 2; 3]; [5; 9]]. P (e) = [[;; <ref> [1] </ref>]; [[1; 2; 3]; [5; 9]]]. Step 4: Remove 9: P (e) = [[;; [1]]; [[1; 2; 3]; [5]]]. [[;; [1]]; [[1; 2; 3]; [5; 9]]]. * e = [8; 9]: This is another trivial case: P (e) = P [9; 10]. * e = [7; 8]: e 2 = [8; 6]; P (e 2 ) = [[;; [6]] Step 1: B 2 = [6]. <p> Step 2: For all blocks B in P (e 1 ), last (B) low1 (e 2 ), so B 1 = ;, and P (e) = [[;; <ref> [1] </ref>]; [[1; 2; 3]; [5]]]. Step 3: P (e) = [[;; [1]]; [[1; 2; 3]; [5]]; [;; [6]]]. Step 4: No action. * e = [6; 7]: e 2 = [7; 4]; P (e 2 ) = [[;; [4]] Step 1: B 2 = [4]. <p> Step 2: For all blocks B in P (e 1 ), last (B) low1 (e 2 ), so B 1 = ;, and P (e) = [[;; <ref> [1] </ref>]; [[1; 2; 3]; [5]]]. Step 3: P (e) = [[;; [1]]; [[1; 2; 3]; [5]]; [;; [6]]]. Step 4: No action. * e = [6; 7]: e 2 = [7; 4]; P (e 2 ) = [[;; [4]] Step 1: B 2 = [4]. Step 2: last ([5]) &gt; 4, so we merge the blocks [5] and [6]. <p> Step 2: last ([5]) &gt; 4, so we merge the blocks [5] and [6]. B 1 = [5; 6]. Step 3: This is a special case, because the block in [5] was already interlacing with the block <ref> [1; 2; 3] </ref>. In this case, we let CP = [[1; 2; 3]; B 1 ]. B 2 interlaces with B 1 , because 4 = f irst (B 2 ) &lt; last (B 1 ) = 6. Therefore, we try to merge B 2 with [1; 2; 3]. <p> interlacing with the block <ref> [1; 2; 3] </ref>. In this case, we let CP = [[1; 2; 3]; B 1 ]. B 2 interlaces with B 1 , because 4 = f irst (B 2 ) &lt; last (B 1 ) = 6. Therefore, we try to merge B 2 with [1; 2; 3]. We can do this, because 4 3. (Remember, if we are not able to merge B 2 with [1; 2; 3], then the graph is nonplanar.) P (e) = [[;; [1]]; [[1; 2; 3; 4]; [5; 6]]]. <p> Therefore, we try to merge B 2 with <ref> [1; 2; 3] </ref>. We can do this, because 4 3. (Remember, if we are not able to merge B 2 with [1; 2; 3], then the graph is nonplanar.) P (e) = [[;; [1]]; [[1; 2; 3; 4]; [5; 6]]]. Step 4: P (e) = [[;; [1]]; [[1; 2; 3; 4]; [5]]]. The rest of the edges are trivial; they only remove back edges in step 4. <p> Therefore, we try to merge B 2 with [1; 2; 3]. We can do this, because 4 3. (Remember, if we are not able to merge B 2 with [1; 2; 3], then the graph is nonplanar.) P (e) = [[;; <ref> [1] </ref>]; [[1; 2; 3; 4]; [5; 6]]]. Step 4: P (e) = [[;; [1]]; [[1; 2; 3; 4]; [5]]]. The rest of the edges are trivial; they only remove back edges in step 4. After step 4 for e = [1; 2], we should have P (e) = [;]. <p> We can do this, because 4 3. (Remember, if we are not able to merge B 2 with [1; 2; 3], then the graph is nonplanar.) P (e) = [[;; <ref> [1] </ref>]; [[1; 2; 3; 4]; [5; 6]]]. Step 4: P (e) = [[;; [1]]; [[1; 2; 3; 4]; [5]]]. The rest of the edges are trivial; they only remove back edges in step 4. After step 4 for e = [1; 2], we should have P (e) = [;]. This tells us that the algorithm is complete and that the graph is planar. 21 <p> Step 4: P (e) = [[;; [1]]; [[1; 2; 3; 4]; [5]]]. The rest of the edges are trivial; they only remove back edges in step 4. After step 4 for e = <ref> [1; 2] </ref>, we should have P (e) = [;]. This tells us that the algorithm is complete and that the graph is planar. 21
Reference: 2. <author> Cai, J., Han, X., and Tarjan, R. </author> <title> New Solutions to Four Planar Graph Problems. </title> <type> 22 </type>
Reference-contexts: If a block B does not interlace with another, we pair it with an empty block: [;; B]. the back edge on the right. B 1 = [1], and B 2 = <ref> [2; 3] </ref>. Because these blocks interlace, we make a pair [B 1 ; B 2 ]. When we have more than one pair of blocks, we order the pairs. <p> First, the back edges perform these functions. When e = [17; 1], low1 (e) = 1 (e) = 2 Similarly, when e = <ref> [17; 2] </ref>, low1 (e) = 2 (e) = 4 Then we "retreat" to [16; 17]. At this point, we sort the edges leaving the vertex numbered 17 into a list L (e) = [[17; 1]; [17; 2]]. <p> e = [17; 1], low1 (e) = 1 (e) = 2 Similarly, when e = <ref> [17; 2] </ref>, low1 (e) = 2 (e) = 4 Then we "retreat" to [16; 17]. At this point, we sort the edges leaving the vertex numbered 17 into a list L (e) = [[17; 1]; [17; 2]]. For e = [16; 17], we say that low1 (e) = low1 [17; 1] = 1 (e) = 2low1 (e) + 1 = 3 After the values for [16; 2] and [16; 3] are computed, we retreat once again to e = [10; 16]. <p> For e = [16; 17], we say that low1 (e) = low1 [17; 1] = 1 (e) = 2low1 (e) + 1 = 3 After the values for <ref> [16; 2] </ref> and [16; 3] are computed, we retreat once again to e = [10; 16]. We sort the edges leaving vertex 16 by the function: L (e) = [[16; 17]; [16; 2]; [16; 3]]. <p> (e) = low1 [17; 1] = 1 (e) = 2low1 (e) + 1 = 3 After the values for <ref> [16; 2] </ref> and [16; 3] are computed, we retreat once again to e = [10; 16]. We sort the edges leaving vertex 16 by the function: L (e) = [[16; 17]; [16; 2]; [16; 3]]. <p> Again, this is done in the retreat stage of DFS. * e = [16; 17]: e 2 = <ref> [17; 2] </ref>; P (e 2 ) = [[;; [2]]] Step 1: P (e 2 ) has one block, so we form the block B 2 = [2]. 16 some of the edges. Notice the properties of this function, as discussed in section 4. <p> Again, this is done in the retreat stage of DFS. * e = [16; 17]: e 2 = [17; 2]; P (e 2 ) = [[;; <ref> [2] </ref>]] Step 1: P (e 2 ) has one block, so we form the block B 2 = [2]. 16 some of the edges. Notice the properties of this function, as discussed in section 4. <p> Again, this is done in the retreat stage of DFS. * e = [16; 17]: e 2 = [17; 2]; P (e 2 ) = [[;; <ref> [2] </ref>]] Step 1: P (e 2 ) has one block, so we form the block B 2 = [2]. 16 some of the edges. Notice the properties of this function, as discussed in section 4. <p> Step 3: Since B 1 = ;, we let CP = [;; B 2 ], and we put this at the end of P (e). P (e) = [[;; [1]]; [;; <ref> [2] </ref>]]. Step 4: No action. * e = [10; 16]: e 2 = [16; 2]; P (e 2 ) = [[;; [2]]] Step 1: B 2 = [2], B 3 = [3]. <p> Step 3: Since B 1 = ;, we let CP = [;; B 2 ], and we put this at the end of P (e). P (e) = [[;; [1]]; [;; [2]]]. Step 4: No action. * e = [10; 16]: e 2 = <ref> [16; 2] </ref>; P (e 2 ) = [[;; [2]]] Step 1: B 2 = [2], B 3 = [3]. <p> P (e) = [[;; [1]]; [;; <ref> [2] </ref>]]. Step 4: No action. * e = [10; 16]: e 2 = [16; 2]; P (e 2 ) = [[;; [2]]] Step 1: B 2 = [2], B 3 = [3]. Step 2: Again, none of the blocks in P (e 1 ) have the property last (B) &gt; low1 (e 2 ), so we let B 1 = ;, and we put the pairs [;; [1]] and [;; [2]] into <p> P (e) = [[;; [1]]; [;; <ref> [2] </ref>]]. Step 4: No action. * e = [10; 16]: e 2 = [16; 2]; P (e 2 ) = [[;; [2]]] Step 1: B 2 = [2], B 3 = [3]. Step 2: Again, none of the blocks in P (e 1 ) have the property last (B) &gt; low1 (e 2 ), so we let B 1 = ;, and we put the pairs [;; [1]] and [;; [2]] into the beginning of P (e). <p> [[;; <ref> [2] </ref>]] Step 1: B 2 = [2], B 3 = [3]. Step 2: Again, none of the blocks in P (e 1 ) have the property last (B) &gt; low1 (e 2 ), so we let B 1 = ;, and we put the pairs [;; [1]] and [;; [2]] into the beginning of P (e). Step 3: CP = [;; B 2 ] = [;; [2]]. Then we see that 3 = f irst (B 3 ) &gt; last (Y ) = 2, so those blocks do not interlace. <p> the blocks in P (e 1 ) have the property last (B) &gt; low1 (e 2 ), so we let B 1 = ;, and we put the pairs [;; [1]] and [;; <ref> [2] </ref>] into the beginning of P (e). Step 3: CP = [;; B 2 ] = [;; [2]]. Then we see that 3 = f irst (B 3 ) &gt; last (Y ) = 2, so those blocks do not interlace. Therefore, we create the new pair [;; [3]], and we put it at the end of P (e). P (e) = [[;; [1]]; [;; [2]]; [;; [2]]; <p> = [;; <ref> [2] </ref>]. Then we see that 3 = f irst (B 3 ) &gt; last (Y ) = 2, so those blocks do not interlace. Therefore, we create the new pair [;; [3]], and we put it at the end of P (e). P (e) = [[;; [1]]; [;; [2]]; [;; [2]]; [;; [3]]]. <p> <ref> [2] </ref>]. Then we see that 3 = f irst (B 3 ) &gt; last (Y ) = 2, so those blocks do not interlace. Therefore, we create the new pair [;; [3]], and we put it at the end of P (e). P (e) = [[;; [1]]; [;; [2]]; [;; [2]]; [;; [3]]]. Step 4: No action. 17 four back edges seen so far can be on either side of the tree. * e = [14; 15]: e 2 = [15; 9]; P (e 2 ) = [[;; [9]]] Step 1: B 2 = [9], B 3 = [13]. <p> Suppose that e 1 = [10; 11]; P (e 1 ) = [[;; [1]]; [;; [5; 9]]] Step 1: We merge the blocks in P (e 2 ), again checking for interlacing. B 2 = <ref> [1; 2; 3] </ref>. (Duplicate numbers can be omitted.) Step 2: B 1 = [5; 9], and P (e) = [;; [1]]. Step 3: CP = [;; [5; 9]]. Because 1 = f irst (B 2 ) &lt; last (Y ) = 9, we let CP = [[1; 2; 3]; [5; 9]]. <p> B 2 = [1; 2; 3]. (Duplicate numbers can be omitted.) Step 2: B 1 = [5; 9], and P (e) = [;; [1]]. Step 3: CP = [;; [5; 9]]. Because 1 = f irst (B 2 ) &lt; last (Y ) = 9, we let CP = <ref> [[1; 2; 3] </ref>; [5; 9]]. P (e) = [[;; [1]]; [[1; 2; 3]; [5; 9]]]. Step 4: Remove 9: P (e) = [[;; [1]]; [[1; 2; 3]; [5]]]. [[;; [1]]; [[1; 2; 3]; [5; 9]]]. * e = [8; 9]: This is another trivial case: P (e) = P [9; 10]. <p> Step 3: CP = [;; [5; 9]]. Because 1 = f irst (B 2 ) &lt; last (Y ) = 9, we let CP = <ref> [[1; 2; 3] </ref>; [5; 9]]. P (e) = [[;; [1]]; [[1; 2; 3]; [5; 9]]]. Step 4: Remove 9: P (e) = [[;; [1]]; [[1; 2; 3]; [5]]]. [[;; [1]]; [[1; 2; 3]; [5; 9]]]. * e = [8; 9]: This is another trivial case: P (e) = P [9; 10]. * e = [7; 8]: e 2 = [8; 6]; <p> Step 3: CP = [;; [5; 9]]. Because 1 = f irst (B 2 ) &lt; last (Y ) = 9, we let CP = <ref> [[1; 2; 3] </ref>; [5; 9]]. P (e) = [[;; [1]]; [[1; 2; 3]; [5; 9]]]. Step 4: Remove 9: P (e) = [[;; [1]]; [[1; 2; 3]; [5]]]. [[;; [1]]; [[1; 2; 3]; [5; 9]]]. * e = [8; 9]: This is another trivial case: P (e) = P [9; 10]. * e = [7; 8]: e 2 = [8; 6]; P (e 2 ) = [[;; [6]] Step 1: B 2 = [6]. <p> Because 1 = f irst (B 2 ) &lt; last (Y ) = 9, we let CP = <ref> [[1; 2; 3] </ref>; [5; 9]]. P (e) = [[;; [1]]; [[1; 2; 3]; [5; 9]]]. Step 4: Remove 9: P (e) = [[;; [1]]; [[1; 2; 3]; [5]]]. [[;; [1]]; [[1; 2; 3]; [5; 9]]]. * e = [8; 9]: This is another trivial case: P (e) = P [9; 10]. * e = [7; 8]: e 2 = [8; 6]; P (e 2 ) = [[;; [6]] Step 1: B 2 = [6]. <p> Step 2: For all blocks B in P (e 1 ), last (B) low1 (e 2 ), so B 1 = ;, and P (e) = [[;; [1]]; <ref> [[1; 2; 3] </ref>; [5]]]. Step 3: P (e) = [[;; [1]]; [[1; 2; 3]; [5]]; [;; [6]]]. Step 4: No action. * e = [6; 7]: e 2 = [7; 4]; P (e 2 ) = [[;; [4]] Step 1: B 2 = [4]. <p> Step 2: For all blocks B in P (e 1 ), last (B) low1 (e 2 ), so B 1 = ;, and P (e) = [[;; [1]]; <ref> [[1; 2; 3] </ref>; [5]]]. Step 3: P (e) = [[;; [1]]; [[1; 2; 3]; [5]]; [;; [6]]]. Step 4: No action. * e = [6; 7]: e 2 = [7; 4]; P (e 2 ) = [[;; [4]] Step 1: B 2 = [4]. Step 2: last ([5]) &gt; 4, so we merge the blocks [5] and [6]. <p> Step 2: last ([5]) &gt; 4, so we merge the blocks [5] and [6]. B 1 = [5; 6]. Step 3: This is a special case, because the block in [5] was already interlacing with the block <ref> [1; 2; 3] </ref>. In this case, we let CP = [[1; 2; 3]; B 1 ]. B 2 interlaces with B 1 , because 4 = f irst (B 2 ) &lt; last (B 1 ) = 6. Therefore, we try to merge B 2 with [1; 2; 3]. <p> Step 2: last ([5]) &gt; 4, so we merge the blocks [5] and [6]. B 1 = [5; 6]. Step 3: This is a special case, because the block in [5] was already interlacing with the block [1; 2; 3]. In this case, we let CP = <ref> [[1; 2; 3] </ref>; B 1 ]. B 2 interlaces with B 1 , because 4 = f irst (B 2 ) &lt; last (B 1 ) = 6. Therefore, we try to merge B 2 with [1; 2; 3]. <p> interlacing with the block <ref> [1; 2; 3] </ref>. In this case, we let CP = [[1; 2; 3]; B 1 ]. B 2 interlaces with B 1 , because 4 = f irst (B 2 ) &lt; last (B 1 ) = 6. Therefore, we try to merge B 2 with [1; 2; 3]. We can do this, because 4 3. (Remember, if we are not able to merge B 2 with [1; 2; 3], then the graph is nonplanar.) P (e) = [[;; [1]]; [[1; 2; 3; 4]; [5; 6]]]. <p> Therefore, we try to merge B 2 with <ref> [1; 2; 3] </ref>. We can do this, because 4 3. (Remember, if we are not able to merge B 2 with [1; 2; 3], then the graph is nonplanar.) P (e) = [[;; [1]]; [[1; 2; 3; 4]; [5; 6]]]. Step 4: P (e) = [[;; [1]]; [[1; 2; 3; 4]; [5]]]. The rest of the edges are trivial; they only remove back edges in step 4. <p> Therefore, we try to merge B 2 with [1; 2; 3]. We can do this, because 4 3. (Remember, if we are not able to merge B 2 with [1; 2; 3], then the graph is nonplanar.) P (e) = [[;; [1]]; <ref> [[1; 2; 3; 4] </ref>; [5; 6]]]. Step 4: P (e) = [[;; [1]]; [[1; 2; 3; 4]; [5]]]. The rest of the edges are trivial; they only remove back edges in step 4. After step 4 for e = [1; 2], we should have P (e) = [;]. <p> We can do this, because 4 3. (Remember, if we are not able to merge B 2 with [1; 2; 3], then the graph is nonplanar.) P (e) = [[;; [1]]; <ref> [[1; 2; 3; 4] </ref>; [5; 6]]]. Step 4: P (e) = [[;; [1]]; [[1; 2; 3; 4]; [5]]]. The rest of the edges are trivial; they only remove back edges in step 4. After step 4 for e = [1; 2], we should have P (e) = [;]. This tells us that the algorithm is complete and that the graph is planar. 21 <p> Step 4: P (e) = [[;; [1]]; [[1; 2; 3; 4]; [5]]]. The rest of the edges are trivial; they only remove back edges in step 4. After step 4 for e = <ref> [1; 2] </ref>, we should have P (e) = [;]. This tells us that the algorithm is complete and that the graph is planar. 21
References-found: 2

