URL: http://www.cs.berkeley.edu/~rmartin/iram_proj3/report.ps
Refering-URL: http://www.cs.berkeley.edu/~rmartin/classes/index.html
Root-URL: 
Email: rmartin@CS.Berkeley.EDU  
Title: A Vectorized Hash-Join  
Author: Rich Martin 
Date: May 11, 1996  
Address: Berkeley  
Affiliation: University of California at  
Abstract: A vector instruction set is a well known method for exposing bandwidth to applications. Although extensively studied in the scientific programming community, less work exists on vectorizing other kinds of applications. This work examines vectorizing a traditional database operation, a Grace hash-join. We how to vec-torize both the hash and join phases of the algorithm, and present performance results on a Cray C90 as well as traditional microprocessors. We concluded that vector scatter-gather and compress are essential to both this algorithm as well as to other non-scientific codes. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Chatterjee, S., Blelloch, G., Zagha, M. </author> <title> Scan Primitives for Vector Processors. </title> <booktitle> In Proceedings of Supercomputing 90, </booktitle> <pages> pages 666-675, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: Figure 6 shows the resulting linear ordering snake after the scan is completed. Notice how the last column of the 2-dimensional array buckets is the same single dimensional case. Vectorizing the scan operation is non-trivial and beyond the scope of this report. The reader is referred to <ref> [1] </ref> for the vectorized version of the scan. 3.2 Join A equijoin builds a set of keys which match on the = operator. We look to the vectorized quicksort [6] to find a method to quickly build this set. In the vectorized quicksort, the keys are partitioned into two sets.
Reference: 2. <author> DeWitt, D., Gerber, R. </author> <title> Multiprocessor Hash-Based Join Algorithms. </title> <booktitle> In Proceedings of VLDB 1985. </booktitle>
Reference: 3. <author> Dusseau, A., Ghormley, D., Keeton, K., </author> <title> Radix Sort: Squeezing Performance out of the Cray Y-MP. unpublished UC Berkeley CS-267 class project, </title> <month> April </month> <year> 1992. </year>
Reference-contexts: The pseudo-code below illustrates this operation: For each row in S do For each row in R do if (Ra.key == Sb.key) then concatenate Ra, Sb and place in result Q The pseudo-code shows how this algorithm is . The nested-loops join might be fine for small relations <ref> [3] </ref>, but for large relations, even ones that fit in memory, the cost is much too high. 2.2 Hash-Joins We define the join load as the number of keys which must be compared between the two relations.
Reference: 4. <author> Goodman, J., </author> <title> An Investigation of Mutiprocessor Structures and Algorithms for Database Management, </title> <type> Technical Report UCB/ERL M81/33, </type> <institution> University of California, Berkeley, </institution> <month> May, </month> <year> 1981. </year>
Reference-contexts: The lines represent the groupings of keys into buckets. In the nested-loops join, the number of comparisons is proportional to the entire area. In a hash-join algorithm, only those keys which hash to the same bucket (the shaded areas) need to be compared. 2.3 Grace Hash-Join The Grace hash-join <ref> [4] </ref> uses hashing to reduce join load on two levels. On one level, hashing is used to break up large relations that reside on disk into buckets small enough such that each O n 2 ( ) Keys from R Keys from S Bucket Si RiBucket FIGURE 2.
Reference: 5. <author> Harris, E., Ramamohanarao, K. </author> <title> Join Algorithm costs revisited. </title> <journal> The VLDB Journal, </journal> <volume> 5(1), </volume> <pages> pages 64-84, </pages> <year> 1996. </year>
Reference-contexts: This work examines vectorizing a traditional database operation, a Grace hash-join. The join operation is one of the most time-consuming and data-intensive operations performed in relational databases. The join operation is also a frequently executed relational operator <ref> [5] </ref>. Due to its high cost and frequency, hundreds of papers exist on a multitude of facets of the join operation. Most of the cost models presented attempt to minimize the number of disk accesses because disk accesses are the most expensive operation. <p> An attribute is a field type in the table row. This section presents a short review of the equijoin. In an equijoin, = is the operator used to compare attributes. Different kinds of joins use other comparison operators besides =. For a complete description of the join operator, see <ref> [5] </ref>. which have matching elements in the key attribute. For example, in Figure 1, the attribute cus Relation R Product Customer Ultra Dave Indy John Alpha Hank Relation S Customer ZIP John 94305 Hank 98195 Bill 02139 Relation Q Product Customer ZIP Indy John 94305 Alpha Hank 98195 FIGURE 1.
Reference: 6. <author> Levin, S. </author> <title> A Fully Vectorized Quicksort. </title> <booktitle> Parallel Computing, </booktitle> <month> December </month> <year> 1990. </year>
Reference-contexts: Recall that the main purpose of the building the hash table is to reduce join load, not to build a persistent hash table. The hash algorithm used in this paper is closely related to the radix sort first described in <ref> [6] </ref>. In the first pass of the radix sort, the keys to be sorted are moved into buckets based on a digit within the key. They idea carried over from radix sorting to hashing is that both move keys into buckets. <p> Vectorized Algorithm The vectorized algorithm follows the same steps as the sequential algorithm. The basic difference is the data structure used to build a hash table. Instead of a one-dimensional array buckets we expand the array to two dimensions. We use the two techniques first described in <ref> [6] </ref>: virtual processors and loop raking. 7 3.1 Vectorized Hash The vectorized hash relies heavily on the idea of virtual processors. Imagine trying to vectorize the sequential version of the histogram phase shown in Section 2.4.1 on page 3. <p> Vectorizing the scan operation is non-trivial and beyond the scope of this report. The reader is referred to [1] for the vectorized version of the scan. 3.2 Join A equijoin builds a set of keys which match on the = operator. We look to the vectorized quicksort <ref> [6] </ref> to find a method to quickly build this set. In the vectorized quicksort, the keys are partitioned into two sets. One is the set of keys greater than the comparison key and the other set is less than the comparison key.
Reference: 7. <author> Mishra, P., Eich, M. </author> <title> Join Processing in Relational Databases. </title> <journal> ACM Computing Surveys, </journal> <month> March </month> <year> 1992 </year>
Reference: 8. <author> Zagha M., Blelloch G. </author> <title> Radix Sort for Vector Multiprocessors. </title> <booktitle> In Proceedings of Supercomputing 91. </booktitle>
References-found: 8

