URL: http://actor.cs.vt.edu/~siva/diss.ps
Refering-URL: http://csgrad.cs.vt.edu/~siva/
Root-URL: http://www.cs.vt.edu
Title: Improving Polymorphism and Concurrency in Common Object Models  
Author: by Siva Prasadarao Challa Dennis G. Kafura, Chairman Marc Abrams Lenwood S. Heath James D. Arthur Scott F. Midkiff 
Degree: Dissertation submitted to the faculty of the  in partial fulfillment of the requirements for the degree of DOCTOR OF PHILOSOPHY in Computer Science and Applications c flSiva Prasadarao Challa and VPI SU 1998 APPROVED:  
Date: January, 1998  
Affiliation: Virginia Polytechnic Institute and State University  Blacksburg, Virginia  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Martin Abadi and Luca Cardelli. </author> <title> A Theory of Objects. </title> <publisher> Springer, </publisher> <address> New York, NY, </address> <year> 1996. </year>
Reference-contexts: The reason for this is that the statically typed object-oriented languages follow different semantics while considering co/contravariance of method arguments. The Simula family of languages support invariance of method arguments while overriding whereas the Eiffel family of languages support covariance of method arguments <ref> [1] </ref>. It will be interesting to see if there is a direct mapping of interface hierarchy of the ICOM model that uses covariant methods into a language that uses contravariant methods and vice versa. One of the object-oriented features not considered in this dissertation is `persistence'.
Reference: [2] <author> Martin Abadi, Luca Cardelli, and Pierre-Louis Curien. </author> <title> Formal Parametric Poly-morphism. </title> <type> Technical report, </type> <note> SRC, SRC Research Report 109, </note> <institution> Digital Equipment Corporation, </institution> <month> July </month> <year> 1993. </year>
Reference: [3] <author> Bruno Achauer. </author> <title> The DOWL Distributed Object-Oriented Language. </title> <journal> Communications of the ACM, </journal> <volume> 36(9) </volume> <pages> 48-55, </pages> <month> September </month> <year> 1993. </year>
Reference: [4] <author> Ole Agesen, Stephen N. Freund, and John C. Mitchell. </author> <title> Adding type parameterization to Java language. </title> <booktitle> In Proceedings OOPSLA '97, </booktitle> <pages> pages 49-65, </pages> <month> October </month> <year> 1997. </year>
Reference: [5] <author> Gul Agha. </author> <title> ACTORS: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1986. </year>
Reference-contexts: So, a distributed compiler makes this interaction possible by transferring IDL descriptions, and invoking IDL-to-native language translations at remote sites. 1.4.3 Software Tools and Design Criterion The software tools used to implement the ICOM object model, and the design criterion chosen are described in this section. The actor model <ref> [5] </ref>, with its asynchronous message passing, is an excellent tool for communication in distributed environments. It can be used as a basic framework for implementing the common object model. In this dissertation, the basic actor model is extended to support the concept of a `distributed actor'.
Reference: [6] <author> Gul Agha, Svend Frolund, and WooYoung Kim. </author> <title> Abstraction and Modularity Mechanisms for Concurrent Computing. </title> <booktitle> IEEE Parallel and Distributed Technology, </booktitle> <pages> pages 3-14, </pages> <month> May </month> <year> 1993. </year>
Reference: [7] <author> Gul Agha and Carl Hewitt. </author> <title> Concurrent Programming using Actors. </title> <editor> In Akinori Yonezawa and Mario Tokoro, editors, </editor> <booktitle> Object-Oriented Concurrent Programming, </booktitle> <pages> pages 37-53. </pages> <publisher> The MIT Press, </publisher> <year> 1993. </year>
Reference: [8] <editor> Gul Agha, Peter Wegner, and Akinori Yonezawa, editors. </editor> <booktitle> Research Directions in Concurrent Object-Oriented Programming. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1993. </year>
Reference: [9] <author> Pierre America. </author> <title> Inheritance and Subtyping in a Parallel Object-Oriented Language. </title> <booktitle> In Proceedings ECOOP '87, </booktitle> <pages> pages 234-242, </pages> <month> July </month> <year> 1987. </year> <note> 178 REFERENCES 179 </note>
Reference: [10] <author> Pierre America. </author> <title> A Parallel Object-Oriented Language with Inheritance and Subtyping. </title> <booktitle> In Proceedings OOPSLA '90, </booktitle> <pages> pages 161-168, </pages> <month> October </month> <year> 1990. </year>
Reference: [11] <author> Egin P. Andersen and Trygve Reenkaug. </author> <title> System Design by Composing Structures of Interacting Objects. </title> <booktitle> In Proceedings ECOOP '92, </booktitle> <pages> pages 133-152, </pages> <month> July </month> <year> 1992. </year>
Reference: [12] <author> Ken Arnold and James Gosling. </author> <title> The Java Programming Language. </title> <publisher> Addison Wesley, </publisher> <year> 1996. </year>
Reference-contexts: These differences force the existing code to be re-written in multiple languages. This duplication impedes software reusability and maintainability. So, there is a strong necessity for integration of software components written in multiple languages. Even though the Java <ref> [12] </ref> language is treated by some as a single universal language that can be used for software development, it is not a solution for the problems facing the software development in distributed and heterogeneous environments.
Reference: [13] <author> Colin Atkinson. </author> <title> Object-Oriented Reuse, Concurrency and Distribution: An Ada-based Approach. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1991. </year>
Reference: [14] <author> Guiseppe Attardi, Cinzia Bonini, Maria Rosaria Boscotrecase, Tito Flagella, and Mauro Gaspari. </author> <title> Metalevel programming in CLOS. </title> <booktitle> In Proceedings ECOOP '89, </booktitle> <pages> pages 243-256, </pages> <month> July </month> <year> 1989. </year>
Reference: [15] <author> Andrew Birrel, Greg Nelson, Susan Owicki, and Edward Wobber. </author> <title> Network Objects. </title> <booktitle> In SIGOPS '93, </booktitle> <pages> pages 217-230, </pages> <month> December </month> <year> 1993. </year>
Reference: [16] <author> Grady Booch. </author> <title> Object-Oriented Analysis and Design with Applications, Second Edition. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1994. </year>
Reference: [17] <author> Gilad Bracha and William Cook. </author> <title> Mixin-based Inheritance. </title> <booktitle> In Proceedings OOPSLA '90, </booktitle> <pages> pages 303-311, </pages> <month> October </month> <year> 1990. </year>
Reference: [18] <author> Jean-Pierre Briot. </author> <title> An Experiment in Classification and Specialization of Synchronization Schemes. </title> <booktitle> In Object Technologies for Advanced Software, Second JSSST International Symposium ISOTAS '96 Proceedings, </booktitle> <pages> pages 227-249, </pages> <month> March </month> <year> 1996. </year> <note> Printed in LNCS 1049. </note>
Reference: [19] <author> Jean-Pierre Briot and Akinori Yonezawa. </author> <title> Inheritance and synchronization in concurrent OOP. </title> <booktitle> In Proceedings ECOOP '87, </booktitle> <pages> pages 32-40, </pages> <month> July </month> <year> 1987. </year>
Reference: [20] <author> K. Brockschmidt. </author> <title> Inside OLE 2. </title> <publisher> Microsoft Press, </publisher> <address> Redmond, </address> <year> 1994. </year>
Reference-contexts: Integrating existing software components written in different programming languages is becoming a common practice in the software development process because it reduces code duplication and results in better reuse and maintenance of software. Many common object models <ref> [20, 60, 70, 110, 117] </ref> have been proposed to support interoperability of software components developed in multiple languages. The systems based on these models try to encapsulate the communication mechanisms used for the transfer of messages between objects in a distributed environment. <p> Several systems have mappings supporting both object-oriented and non object-oriented languages. 1.2 Problem statement Most of the common object models, including the popular industry standard models | the Common Object Request Broker Architecture (CORBA) [60] and the Component Object Model (COM) <ref> [20] </ref>| do not support certain useful and advanced features of `polymorphism' and `concurrency'. These models are limited in the object-oriented CHAPTER 1. INTRODUCTION 4 features supported by them. <p> Similarly the results are marshalled, sent, and subsequently unmarshalled. These protocol based non-object-oriented models were limited to using remote procedure calls. Higher abstractions over remote procedure calls are not possible in these models. Protocol based non-object-oriented systems are not discussed further. 2.3.2 Protocol Based Object-Oriented Systems Recently, several systems <ref> [20, 60, 70] </ref> following the protocol based object-oriented approach have been developed. Such systems are also called Distributed Object Systems. An interoperable system following a protocol based architecture is responsible for interactions between client and server objects. <p> Though these models were good initial solutions to the interoperability problem, they do not provide a satisfactory long-term solution, because the features that are initially not part of the model cannot be included in the model. Example systems include COM <ref> [20] </ref>, CORBA [60], and ILU [39]. The selective models that are extensible, consist of a "core object model" whose few basic features are specialized or combined using reflection techniques (or special translations) to incorporate other CHAPTER 2. INTEROPERABLE SYSTEMS 25 object-oriented features. <p> A simple form of garbage collection is provided for ILU objects. Exceptions are also a part of the ILU object model. The ILU system supports C, C++, Modula-3, Python, Perl5, Java, and Common LISP. 2.3.4.3 Component Object Model Microsoft's Object Linking and Embedding 2 (OLE 2) <ref> [20] </ref> is a second example of selective models similar to the ILU system. It defines the Component Object Model (COM) which specifies a programming language independent binary standard for object implementations. <p> Since the behavior of a base class can be modified in a subclass, an instance of a derived class cannot be substituted by an instance of a base class in all contexts [38]. This is opposite of the substitution given for interface inheritance. Existing distributed systems <ref> [20, 60, 70] </ref> support interface inheritance where only the specification is inherited from a parent interface. This means that an implementation supporting an interface child that inherits from another interface parent must provide implementation for the methods in both the interfaces, child and parent.
Reference: [21] <author> Gerald Brose. </author> <title> JacORB Design and Implementation of a Java ORB. </title> <booktitle> In Proceedings of the International Working Conference on Distributed Applications and Interoperable Systems, </booktitle> <address> DAIS'97, Cotbus, Germany, </address> <month> September </month> <year> 1997. </year>
Reference-contexts: It is not available on all platforms, and moreover, it is an enormous task to translate software developed in several popular languages into Java. So, integration of legacy components existing in other languages to work with Java components is currently under investigation <ref> [21, 60] </ref>. In summary, in order to reuse the existing software effectively, software modules built in multiple object-oriented languages need to interoperate with one another. CHAPTER 1.
Reference: [22] <author> Gerald Brose, Klaus-Peter Lohr, and Andre Spiegel. </author> <title> Java does not Distribute. </title> <booktitle> In Proceedings TOOLS Pacific '97, </booktitle> <address> Melbourne, Australia, </address> <month> November </month> <year> 1997. </year> <note> REFERENCES 180 </note>
Reference-contexts: Java supports communication between objects distributed in different address spaces, using Remote Method Invocation (RMI) [124]. But, RMI is specifically designed to operate only in the Java environment. It cannot be used effectively with other languages <ref> [22] </ref>. Java is still an evolving language, undergoing changes in the facilities it provides. It is not available on all platforms, and moreover, it is an enormous task to translate software developed in several popular languages into Java.
Reference: [23] <author> Peter Canning, William Cook, Walter Hill, Walter Olthoff, and John Mitchell. </author> <title> F-bounded Polymorphism for Object-Oriented Languages. </title> <booktitle> In The Fourth International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 273-280, </pages> <month> September </month> <year> 1989. </year>
Reference: [24] <author> Peter S. Canning, Willian R. Cook, Walter L. Hill, and Walter G. Olthoff. </author> <title> Interfaces for Strongly-Typed Object-Oriented Programming. </title> <booktitle> In Proceedings OOPSLA '89, </booktitle> <pages> pages 457-467, </pages> <month> October </month> <year> 1989. </year>
Reference: [25] <author> Luca Cardelli and Peter Wegner. </author> <title> On Understanding Types, Data Abstraction, and Polymorphism. </title> <journal> ACM Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 470-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: Similarly, a polymorphic method can accept different types of arguments and a polymorphic operator can operate on multiple types of operands. There are two general categories of polymorphism | ad hoc polymorphism and universal polymorphism <ref> [25] </ref>. Ad hoc polymorphism is achieved by type coercions, operator overloading, and method overloading. For example, consider the assignment of an integer value to a variable declared to hold a real (float or double) value. The integer value will be converted to a real number before the assignment takes place.
Reference: [26] <author> Eduardo Casais. </author> <title> An Incremental Class Reorganization Approach. </title> <booktitle> In Proceedings ECOOP '92, </booktitle> <pages> pages 114-132, </pages> <month> July </month> <year> 1992. </year>
Reference: [27] <author> Siva Challa. </author> <title> Towards an Interoperable Reflective Common Object Model. </title> <booktitle> In the Workshop on Multi-language object Models, OOPSLA '94, </booktitle> <address> Portland, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: main reasons why the existing common object models do not include the advanced features of polymorphism and concurrency is the fact that current object-oriented systems for interoperability and component-based reuse employ object models that are weakened by the attempt to provide accessibility from too broad a domain of programming languages <ref> [27] </ref>. These common denominator models are limited in their support for object-oriented features. They support only a subset of object oriented features because mapping of a more complete object model into a non-object oriented language is not manageable.
Reference: [28] <author> Siva Challa and Dennis Kafura. </author> <title> Using reflection for implementing ICOM, An Interoperable Common Object Model. </title> <type> Technical Report TR95-23, </type> <institution> Virginia Tech, Blacksburg, VA, </institution> <year> 1995. </year>
Reference-contexts: This is addressed in the next section. CHAPTER 4. BASIC POLYMORPHISM 71 4.2 Truly Distributed Objects in ICOM The framework of Interoperable Common Object Model <ref> [28] </ref> realizes a distributed object in its true sense by supporting inheritance of abstract methods across processes. The parts of a distributed object can exist in more than one process without losing the object's integrity. <p> In the ICOM framework the implementation inheritance is realized by using the keyword `reuse'. An implementor of a derived class can inherit the implementation of its base class and implement only the extended or overridden functionality in the derived class. The framework of Interoperable Common Object Model <ref> [28] </ref> realizes a truly distributed object by supporting abstract methods across processes. The parts of a distributed object can exist in more than one process without losing the object's integrity.
Reference: [29] <author> Craig Chambers. </author> <title> Object-oriented multi-methods in Cecil. </title> <booktitle> In Proceedings ECOOP '92, </booktitle> <pages> pages 33-56, </pages> <month> July </month> <year> 1992. </year>
Reference: [30] <author> Shigeru Chiba. </author> <title> Open C++ Release 1.2 Programmer's Guide. </title> <type> Technical report, </type> <institution> University of Tokyo, Department of Computer Science, </institution> <year> 1993. </year>
Reference: [31] <author> Shigeru Chiba and Takashi Masuda. </author> <title> Designing an Extensible Distributed Language with a Meta-Level Architecture. </title> <booktitle> In Proceedings ECOOP '93, </booktitle> <pages> pages 482-501, </pages> <month> July </month> <year> 1993. </year>
Reference: [32] <author> Andrew K. Chiu and Jay Parekh. </author> <title> Class: A collection of objects. </title> <journal> Journal of Object-Oriented Programming, </journal> <pages> pages 29-32, </pages> <month> May </month> <year> 1992. </year>
Reference: [33] <author> Randy Chow and Theodore Johnson. </author> <title> Distributed Operating Systems and Algorithms. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1997. </year>
Reference-contexts: Concurrency on a single processor can be achieved by interleaving multiple sequential processes as has been a common practice with `multiprogramming' used in operating systems <ref> [33] </ref>. For example, a process waiting for an input/output event to happen can relinquish control over the central processing unit (CPU) to another process waiting to use the CPU.
Reference: [34] <author> Alberto Coen-Porisini, Luigi Lavazza, and Roberto Zicari. </author> <title> Assuring Type Safety of Object-Oriented Languages. </title> <journal> Journal of Object-Oriented Programming, </journal> <pages> pages 25-30, </pages> <month> February </month> <year> 1994. </year> <note> REFERENCES 181 </note>
Reference: [35] <author> Pierre Cointe. </author> <title> Metaclasses are first class: the ObjVLisp model. </title> <booktitle> In Proceedings OOPSLA '87, </booktitle> <pages> pages 156-167, </pages> <month> October </month> <year> 1987. </year>
Reference: [36] <author> W. R. Cook. </author> <title> A proposal for making Eiffel type-safe. </title> <booktitle> In Proceedings ECOOP '89, </booktitle> <pages> pages 57-70, </pages> <month> July </month> <year> 1989. </year>
Reference: [37] <author> William Cook and Jens Palsberg. </author> <title> A Denotational Semantics of Inheritance and its Correctness. </title> <booktitle> In Proceedings OOPSLA '89, </booktitle> <pages> pages 433-443, </pages> <month> October </month> <year> 1989. </year> <journal> Printed in SIGPLAN Notices, </journal> <volume> 24(10), </volume> <month> October </month> <year> 1989. </year>
Reference: [38] <author> William R. Cook, Walter L. Hill, and Peter S. Canning. </author> <title> Inheritance is Not Sub-typing. </title> <booktitle> In Proceedings of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 125-135, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Since the behavior of a base class can be modified in a subclass, an instance of a derived class cannot be substituted by an instance of a base class in all contexts <ref> [38] </ref>. This is opposite of the substitution given for interface inheritance. Existing distributed systems [20, 60, 70] support interface inheritance where only the specification is inherited from a parent interface.
Reference: [39] <author> Doug Cutting, Bill Janssen, Mike Spreitzer, and Farrel Wymore. </author> <title> ILU Reference manual. </title> <type> Technical report, </type> <institution> Xerox Corporation, </institution> <address> Palo Alto, CA, </address> <year> 1993. </year>
Reference-contexts: Though these models were good initial solutions to the interoperability problem, they do not provide a satisfactory long-term solution, because the features that are initially not part of the model cannot be included in the model. Example systems include COM [20], CORBA [60], and ILU <ref> [39] </ref>. The selective models that are extensible, consist of a "core object model" whose few basic features are specialized or combined using reflection techniques (or special translations) to incorporate other CHAPTER 2. INTEROPERABLE SYSTEMS 25 object-oriented features. This core object model is mapped into non-object-oriented programming languages. <p> One of the drawbacks of the HERON system is that it does not support concur-rency and parameterized types. Also, an application developer needs to be aware of all participating distributed nodes for the application and maintain appropriate configuration files information. 2.3.4.2 Inter-Language Unification The Inter-Language Unification (ILU) system <ref> [39] </ref> from Xerox is an example of a common object model that follows an selective approach under broad domain, object-oriented protocol categories. The object model in the ILU system is non-extensible. The ILU system, working in a distributed, heterogeneous environment aims at smoothly integrating modules written in different languages.
Reference: [40] <author> Scott Danforth. </author> <title> A Bird's Eye View of SOM. </title> <journal> IBM Personal Systems Programming, </journal> <pages> pages 1-9, </pages> <month> September </month> <year> 1992. </year>
Reference: [41] <author> Scott Danforth and Chris Tomlinson. </author> <title> Type Theories and Object-Oriented Programming. </title> <journal> ACM Computing Surveys, </journal> <volume> 20(1) </volume> <pages> 29-72, </pages> <month> March </month> <year> 1988. </year>
Reference: [42] <author> Ph. Darondeau, P. Le Guernic, and M. Raynal. </author> <title> Types in a Mixed Language System. </title> <journal> BIT, </journal> <volume> 21 </volume> <pages> 246-254, </pages> <year> 1981. </year>
Reference-contexts: Finally, the `outline' section briefly described the contents of each chapter. Chapter 2 Interoperable Systems 2.1 Introduction Providing interoperability among programming languages has been a challenging problem for several years <ref> [42] </ref>. Earlier attempts to address interoperability were directed towards non-object-oriented languages [57, 65, 153, 185]. Several solutions exist for direct mapping between languages when only two languages are involved [46, 115].
Reference: [43] <author> Amitabh Dave, Mohlalefi Sefika, and Roy H. Campbell. </author> <title> Proxies, Application Interfaces, and Distributed Systems. </title> <type> Technical report, </type> <institution> UIUC, Illinois, </institution> <year> 1993. </year>
Reference: [44] <author> Stephen R. Davis. </author> <title> C++ Objects That Change Their Types. </title> <journal> Journal of Object-Oriented Programming, </journal> <pages> pages 27-32, </pages> <month> July-August </month> <year> 1992. </year>
Reference: [45] <author> Linda G. DeMichiel and Richard P. Gabriel. </author> <title> The Common Lisp Object System: An overview. </title> <booktitle> In Proceedings ECOOP '87, </booktitle> <pages> pages 151-170, </pages> <month> July </month> <year> 1987. </year>
Reference: [46] <author> Bo Einarsson. </author> <title> Mixed Language Programming. </title> <journal> Software-Practice and Experience, </journal> <volume> 14(4) </volume> <pages> 383-395, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: Chapter 2 Interoperable Systems 2.1 Introduction Providing interoperability among programming languages has been a challenging problem for several years [42]. Earlier attempts to address interoperability were directed towards non-object-oriented languages [57, 65, 153, 185]. Several solutions exist for direct mapping between languages when only two languages are involved <ref> [46, 115] </ref>. Though these solutions are adequate for two languages, they become very complex when the number of languages used is more than two. When N languages are involved, they require N*(N-1) translators, with every language requiring translators to every other language.
Reference: [47] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1994. </year> <note> REFERENCES 182 </note>
Reference: [48] <author> Jacques Ferber. </author> <title> Conceptual Reflection and Actor Languages. </title> <editor> In Pattie Maes and Daniele Nardi, editors, </editor> <booktitle> Meta-Level Architectures and Reflection, </booktitle> <pages> pages 177-193. </pages> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference: [49] <author> Jacques Ferber. </author> <title> Computational Reflection in Class Based Object-Oriented Languages. </title> <booktitle> In Proceedings OOPSLA '89, </booktitle> <pages> pages 317-326, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: Reflection is defined as the ability of a system to make structures representing (aspects of) itself the subject (or domain) of its computation in a causally connected way [102]. Reification is the representation of specific aspects of a program as data structures or classes within that program <ref> [49] </ref>. These aspects include method binding, inheri CHAPTER 3. INTEROPERABLE COMMON OBJECT MODEL (ICOM) 50 tance etc. The resulting objects are referred to as metaobjects. Invoking an operation on a metaobject is called reflective computation. There are three approaches to reflective computation: Metaclass, Metaobject, and MetaCommunication [49]. <p> classes within that program <ref> [49] </ref>. These aspects include method binding, inheri CHAPTER 3. INTEROPERABLE COMMON OBJECT MODEL (ICOM) 50 tance etc. The resulting objects are referred to as metaobjects. Invoking an operation on a metaobject is called reflective computation. There are three approaches to reflective computation: Metaclass, Metaobject, and MetaCommunication [49]. If a reflective computation modifies a metaobject, then it is called a reflective update and the process is called behavioral reflection. If a reflective computation does not modify a metaobject, then that process is called structural reflection. The operations defined for the metaobjects constitute a metaobject protocol [83]. <p> To change the default behavior of an object, the MetaObject can be specialized and assigned to the object. Since, each object has a metaobject, the number of objects in the system grows enormously. To control the number of metaobjects in the system, a lazy way of metaobject creation <ref> [49] </ref> can be followed where a metaobject is created only when needed. The advantage of this approach is that individual objects can be controlled in different ways even though they belong to the same class. MetaCommunication Approach This approach is based on the reification of the communication mechanism.
Reference: [50] <author> S. Finke, P. Jahn, O. Langmack, K. P. Lohr, I. Piens, and Th. Wolff. </author> <title> Distribution and inheritance in the HERON approach to heterogeneous computing. </title> <booktitle> In Thirteenth Internation Conference on Distributed Computing Systems, </booktitle> <address> Pitts-burgh, </address> <year> 1993. </year>
Reference-contexts: But, it revealed the drawbacks of trying to map the model to a non-object-oriented language. It was concluded that it is best to use only the features common to the Eiffel object model and the participating language's object model <ref> [50] </ref>. One of the drawbacks of the HERON system is that it does not support concur-rency and parameterized types.
Reference: [51] <author> International Organization for Standardization. </author> <title> Information Processing - Open Systems Interconnection Specification of Abstract Syntax Notation One(ASN.1). </title> <type> Technical Report ISO 8824/CCITT X.208, </type> <year> 1987. </year>
Reference-contexts: To provide representation for data that can be transferred between machines with CHAPTER 3. INTEROPERABLE COMMON OBJECT MODEL (ICOM) 57 different hardware architectures, Distributed Act++ supports a polymorphic object-oriented data specification framework (OODSF). This framework can be instantiated to support Abstract Syntax Notation 1 (ASN.1) <ref> [51] </ref> and the CORBA interface definition language (IDL) for data representation.
Reference: [52] <author> International Organization for Standardization. </author> <title> Information Processing Open Systems Interconnection Specification of Basic Encoding Rules for Abstract Syntax Notation One(ASN.1). </title> <type> Technical Report ISO 8825/CCITT X.209, </type> <year> 1987. </year>
Reference-contexts: This framework can be instantiated to support Abstract Syntax Notation 1 (ASN.1) [51] and the CORBA interface definition language (IDL) for data representation. The OODSF framework supports Basic Encoding Rules (BER) <ref> [52] </ref> and External Data Representation (XDR) [123] for transferring data between different nodes of the system. 3.4.2.5 Actor Messages used for Communication There are two ways to implement the communication between actors. First, dedicated actors can be created that can decide whether message is a constructor message, an CHAPTER 3.
Reference: [53] <author> Ira R. Forman, Scott Danforth, and Hari Madduri. </author> <title> Composition of Before/After metaclasses in SOM. </title> <booktitle> In Proceedings OOPSLA '94, </booktitle> <month> October </month> <year> 1994. </year>
Reference: [54] <author> Svend Frolund and Gul Agha. </author> <title> A Language Framework for Multi-Object Coordination. </title> <booktitle> In Proceedings ECOOP '93, </booktitle> <month> July </month> <year> 1993. </year>
Reference: [55] <author> Lucy Garnette. </author> <title> Wrapping objects. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 9(8), </volume> <year> 1993. </year>
Reference-contexts: Another aspect of object-oriented programming with reference to the legacy systems is that object-oriented wrappers can be built around 1 CHAPTER 1. INTRODUCTION 2 existing legacy system components. The wrappers allow the legacy components to be integrated with newly developed components or the legacy components in an application <ref> [55] </ref>. Thus, object-orientation is proving to be a useful programming paradigm for current software development and for legacy systems. Integration of software components written in several popular object-oriented languages is a recurring problem in the software development process.
Reference: [56] <author> Giorgio Ghelli. </author> <title> A Static Type System for Message Passing. </title> <booktitle> In Proceedings OOPSLA '91, </booktitle> <pages> pages 129-145, </pages> <month> October </month> <year> 1991. </year>
Reference: [57] <author> Phillip B. Gibbons. </author> <title> A Stub Generator for Multi-language RPC in Heterogeneous Environments. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(1) </volume> <pages> 77-87, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Finally, the `outline' section briefly described the contents of each chapter. Chapter 2 Interoperable Systems 2.1 Introduction Providing interoperability among programming languages has been a challenging problem for several years [42]. Earlier attempts to address interoperability were directed towards non-object-oriented languages <ref> [57, 65, 153, 185] </ref>. Several solutions exist for direct mapping between languages when only two languages are involved [46, 115]. Though these solutions are adequate for two languages, they become very complex when the number of languages used is more than two. <p> The early protocol based systems use non-object-oriented models. Most of the recent systems use object-oriented models. 2.3.1 Protocol Based Non-Object-Oriented Systems Protocol based non-object-oriented systems use remote procedure call abstraction. Systems supporting non-object-oriented models <ref> [57, 65, 76] </ref> provide a common interface definition language to describe a server's interface. The description is compiled to produce stubs for Marshalling and Unmarshalling needed during a remote call CHAPTER 2. INTEROPERABLE SYSTEMS 18 from a client and return from the server.
Reference: [58] <author> Ennio Grasso. </author> <title> Passing object by value in CORBA. </title> <booktitle> In Trends in Distributed Systems - CORBA and Beyond, </booktitle> <pages> pages 43-56, </pages> <month> October </month> <year> 1996. </year> <note> Printed in LNCS 1161. </note>
Reference: [59] <author> Nicolas Graube. </author> <title> Metaclass Compatibility. </title> <booktitle> In Proceedings OOPSLA '89, </booktitle> <pages> pages 305-315, </pages> <month> October </month> <year> 1989. </year> <note> REFERENCES 183 </note>
Reference: [60] <author> Object Management Group. </author> <title> Common Object Request Broker: Architecture and Specification. Technical Report OMG Document Number 97.9.1, </title> <journal> Rev. 2.1, </journal> <volume> OMG, </volume> <year> 1997. </year>
Reference-contexts: It is not available on all platforms, and moreover, it is an enormous task to translate software developed in several popular languages into Java. So, integration of legacy components existing in other languages to work with Java components is currently under investigation <ref> [21, 60] </ref>. In summary, in order to reuse the existing software effectively, software modules built in multiple object-oriented languages need to interoperate with one another. CHAPTER 1. <p> Integrating existing software components written in different programming languages is becoming a common practice in the software development process because it reduces code duplication and results in better reuse and maintenance of software. Many common object models <ref> [20, 60, 70, 110, 117] </ref> have been proposed to support interoperability of software components developed in multiple languages. The systems based on these models try to encapsulate the communication mechanisms used for the transfer of messages between objects in a distributed environment. <p> Several systems have mappings supporting both object-oriented and non object-oriented languages. 1.2 Problem statement Most of the common object models, including the popular industry standard models | the Common Object Request Broker Architecture (CORBA) <ref> [60] </ref> and the Component Object Model (COM) [20]| do not support certain useful and advanced features of `polymorphism' and `concurrency'. These models are limited in the object-oriented CHAPTER 1. INTRODUCTION 4 features supported by them. <p> They support only a subset of object oriented features because mapping of a more complete object model into a non-object oriented language is not manageable. For example, method overloading is not provided in Object Management Group's (OMG) Common Object Request Broker Architecture (CORBA) <ref> [60] </ref> object model, because dealing with CHAPTER 1. INTRODUCTION 8 overloaded names is too difficult or very awkward to handle in typical non-object oriented languages. Powerful features missing from this and many other models include: parametric polymorphism and concurrency. <p> Similarly the results are marshalled, sent, and subsequently unmarshalled. These protocol based non-object-oriented models were limited to using remote procedure calls. Higher abstractions over remote procedure calls are not possible in these models. Protocol based non-object-oriented systems are not discussed further. 2.3.2 Protocol Based Object-Oriented Systems Recently, several systems <ref> [20, 60, 70] </ref> following the protocol based object-oriented approach have been developed. Such systems are also called Distributed Object Systems. An interoperable system following a protocol based architecture is responsible for interactions between client and server objects. <p> Though these models were good initial solutions to the interoperability problem, they do not provide a satisfactory long-term solution, because the features that are initially not part of the model cannot be included in the model. Example systems include COM [20], CORBA <ref> [60] </ref>, and ILU [39]. The selective models that are extensible, consist of a "core object model" whose few basic features are specialized or combined using reflection techniques (or special translations) to incorporate other CHAPTER 2. INTEROPERABLE SYSTEMS 25 object-oriented features. This core object model is mapped into non-object-oriented programming languages. <p> Aggregation requires super to "know" that its interface is exposed for something other than itself, such that the QueryInterface function behaves as a user expects. 2.3.4.4 Common Object Request Broker Architecture Object Model The Common Object Request Broker Architecture (CORBA) <ref> [60] </ref> from the Object Management Group (OMG) is another example of common object models following the selective approach under broad domain, object-oriented protocol based categories. The CORBA object model is non-extensible. <p> Since the behavior of a base class can be modified in a subclass, an instance of a derived class cannot be substituted by an instance of a base class in all contexts [38]. This is opposite of the substitution given for interface inheritance. Existing distributed systems <ref> [20, 60, 70] </ref> support interface inheritance where only the specification is inherited from a parent interface. This means that an implementation supporting an interface child that inherits from another interface parent must provide implementation for the methods in both the interfaces, child and parent. <p> The syntax of the model is given by an Interface Definition Language (IDL) and the semantics are given by natural language descriptions and examples. The syntax of the IDL used in this model is an extension of the CORBA IDL <ref> [60] </ref>. Only the extensions made to the CORBA IDL and its object model are described here. The ICOM framework differs from the other distributed object systems in the way messages are communicated and the semantics of method invocations.
Reference: [61] <author> Sabine Habert and Laurence Mosseri. </author> <title> COOL: Kernel support for object-oriented environments. </title> <booktitle> In Proceedings OOPSLA '90, </booktitle> <pages> pages 269-277, </pages> <month> October </month> <year> 1990. </year>
Reference: [62] <author> Samuel P. Harbison, </author> <title> editor. Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1992. </year>
Reference: [63] <author> Franz J. Hauck. </author> <title> Inheritance Modeled with Explicit Bindings: An Approach to Typed Inheritance. </title> <booktitle> In Proceedings OOPSLA '93, </booktitle> <pages> pages 231-239, </pages> <month> October </month> <year> 1993. </year> <journal> Printed in SIGPLAN Notices, </journal> <volume> 28(10), </volume> <month> October </month> <year> 1993. </year>
Reference: [64] <author> Roger Hayes, Steve W. Manweiler, and Richard D. Schlichting. </author> <title> A Simple System for Constructing Distributed, Mixed-Language Programs. </title> <journal> Software-Practice and Experience, </journal> <volume> 18(7) </volume> <pages> 641-659, </pages> <month> July </month> <year> 1988. </year>
Reference: [65] <author> Roger Hayes and Richard D. Schlichting. </author> <title> Facilitating Mixed Language Programming in Distributed Systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(12) </volume> <pages> 1254-1264, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: Finally, the `outline' section briefly described the contents of each chapter. Chapter 2 Interoperable Systems 2.1 Introduction Providing interoperability among programming languages has been a challenging problem for several years [42]. Earlier attempts to address interoperability were directed towards non-object-oriented languages <ref> [57, 65, 153, 185] </ref>. Several solutions exist for direct mapping between languages when only two languages are involved [46, 115]. Though these solutions are adequate for two languages, they become very complex when the number of languages used is more than two. <p> The early protocol based systems use non-object-oriented models. Most of the recent systems use object-oriented models. 2.3.1 Protocol Based Non-Object-Oriented Systems Protocol based non-object-oriented systems use remote procedure call abstraction. Systems supporting non-object-oriented models <ref> [57, 65, 76] </ref> provide a common interface definition language to describe a server's interface. The description is compiled to produce stubs for Marshalling and Unmarshalling needed during a remote call CHAPTER 2. INTEROPERABLE SYSTEMS 18 from a client and return from the server.
Reference: [66] <author> Patrick Hellemans, Frank Steegmans, Hans Vanderstraeten, and Han Zuidweg. </author> <title> Implementation of Hidden Concurrency in CORBA Clients. </title> <booktitle> In Trends in Distributed Systems - CORBA and Beyond, </booktitle> <pages> pages 30-42, </pages> <month> October </month> <year> 1996. </year> <note> Printed in LNCS 1161. </note>
Reference: [67] <author> Robert Henderson and Benjamin Zorn. </author> <title> A Comparison of Object-Oriented Programming in Four Modern Languages. </title> <type> Technical Report CU-CS-641-93, </type> <institution> University of Colorado, Boulder, Department of Computer Science, </institution> <month> July </month> <year> 1993. </year>
Reference: [68] <author> Ian M. Holland. </author> <title> Specifying Reusable Components Using Contracts. </title> <booktitle> In Proceedings ECOOP '92, </booktitle> <pages> pages 287-308, </pages> <month> July </month> <year> 1992. </year>
Reference: [69] <author> Chris Horn. </author> <title> Conformance, Genericity, Inheritance and Enhancement. </title> <booktitle> In Proceedings ECOOP '87, </booktitle> <pages> pages 223-233, </pages> <month> July </month> <year> 1987. </year>
Reference: [70] <author> IBM. </author> <title> SOMObjects Developer Toolkit Technical Overview, Version 2.0. </title> <type> Technical report, </type> <institution> IBM, </institution> <address> New York, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: Integrating existing software components written in different programming languages is becoming a common practice in the software development process because it reduces code duplication and results in better reuse and maintenance of software. Many common object models <ref> [20, 60, 70, 110, 117] </ref> have been proposed to support interoperability of software components developed in multiple languages. The systems based on these models try to encapsulate the communication mechanisms used for the transfer of messages between objects in a distributed environment. <p> Similarly the results are marshalled, sent, and subsequently unmarshalled. These protocol based non-object-oriented models were limited to using remote procedure calls. Higher abstractions over remote procedure calls are not possible in these models. Protocol based non-object-oriented systems are not discussed further. 2.3.2 Protocol Based Object-Oriented Systems Recently, several systems <ref> [20, 60, 70] </ref> following the protocol based object-oriented approach have been developed. Such systems are also called Distributed Object Systems. An interoperable system following a protocol based architecture is responsible for interactions between client and server objects. <p> INTEROPERABLE SYSTEMS 25 object-oriented features. This core object model is mapped into non-object-oriented programming languages. Example systems include SOM <ref> [70] </ref> from IBM, and RISC [110] from GTE laboratories. Reflection techniques are discussed in the next chapter. The narrow domain approach considers only a subset of languages, in particular, object-oriented languages. <p> Second, they augment the basic CORBA object model by implementing support for richer object features. CORBA has mappings to C, C++, Java, COBOL, Smalltalk, and Ada 95 languages. 2.3.4.5 System Object Model System Object Model (SOM) <ref> [70] </ref> from IBM is an example for extensible systems under the selective approach following the broad domain, object-oriented protocol based categories. It allows languages to share class libraries independent of the language used to implement the class libraries. <p> Since the behavior of a base class can be modified in a subclass, an instance of a derived class cannot be substituted by an instance of a base class in all contexts [38]. This is opposite of the substitution given for interface inheritance. Existing distributed systems <ref> [20, 60, 70] </ref> support interface inheritance where only the specification is inherited from a parent interface. This means that an implementation supporting an interface child that inherits from another interface parent must provide implementation for the methods in both the interfaces, child and parent.
Reference: [71] <author> Harry H. Porter III. </author> <title> Separating the Subtype Hierarchy From the Inheritance of Implementation. </title> <journal> Journal of Object-Oriented Programming, </journal> <pages> pages 20-29, </pages> <address> Febru-ary 1992. REFERENCES 184 </address>
Reference: [72] <author> C. Jacquemot, P. Gautron, H. G. Baumgarten, F. Herrmann, J. Mukerji, H. Hartlage, and P. S. Jensen. </author> <title> COOL-IDL Extensions to C++ to Support Distributed Programming. </title> <type> Technical report, </type> <institution> Chorus Group, Esprit Project No 6603, </institution> <year> 1994. </year>
Reference-contexts: The language-specific run time maps a particular language object model to the generic run time model. Currently mappings to C++ are supported in COOL. Recently, there have been attempts to make COOL a CORBA compliant framework <ref> [72] </ref>. Though the common run time approach seems promising, it is not popular because of the existence of an additional run time layer and primitive (i.e., many object-oriented features are not supported) object models.
Reference: [73] <author> C. Jacquemot, P. Gautron, H. G. Baumgarten, F. Herrmann, J. Mukerji, H. Hartlage, and P. S. Jensen. </author> <title> COOL: The CHORUS CORBA Compliant Framework. </title> <type> Technical report, </type> <institution> Chorus Group, Esprit project No 6603, </institution> <year> 1994. </year>
Reference: [74] <author> Suresh Jagannathan and Gul Agha. </author> <title> A Reflective Model of Inheritance. </title> <booktitle> In Proceedings ECOOP '92, </booktitle> <pages> pages 350-371, </pages> <month> July </month> <year> 1992. </year>
Reference: [75] <author> Ralph E. Johnson and Jonathan M. Zweig. </author> <title> Delegation in C++. </title> <journal> Journal of Object-Oriented Programming, </journal> <pages> pages 31-34, </pages> <month> November/December </month> <year> 1991. </year>
Reference: [76] <author> Michael B. Jones, Richard F. Rashid, and Mary R. Thompson. Matchmaker: </author> <title> An interface specification language for distributed processing. </title> <booktitle> In Proceedings of the Twelfth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 225-235, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: The early protocol based systems use non-object-oriented models. Most of the recent systems use object-oriented models. 2.3.1 Protocol Based Non-Object-Oriented Systems Protocol based non-object-oriented systems use remote procedure call abstraction. Systems supporting non-object-oriented models <ref> [57, 65, 76] </ref> provide a common interface definition language to describe a server's interface. The description is compiled to produce stubs for Marshalling and Unmarshalling needed during a remote call CHAPTER 2. INTEROPERABLE SYSTEMS 18 from a client and return from the server.
Reference: [77] <author> D. G. Kafura and R. G. Lavender. </author> <title> Concurrent Object-Oriented Languages and Inheritance Anomaly. </title> <editor> In Thomas L. Casavant, Pavel Tvrdik, and Frantisek Plasil, editors, </editor> <booktitle> Parallel Computers: Theory and Practice, </booktitle> <pages> pages 221-264. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1996. </year>
Reference: [78] <author> Dennis Kafura, Siva Challa, and Greg Lavender. </author> <title> Workshop on Multi-Language Object Models. </title> <booktitle> In Addendum to Proceedings OOPSLA '94, </booktitle> <month> October </month> <year> 1994. </year>
Reference: [79] <author> Dennis Kafura, Manibrata Mukherji, and Greg Lavender. </author> <title> ACT++: A class library for concurrent programming in C++ using actors. </title> <journal> Journal of Object-Oriented Programming, </journal> <pages> pages 47-62, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: Depending on what type of behavior an actor currently has, the messages in the message queue may get processed right away or stay in the queue until a suitable replacement behavior is provided by an existing behavior. Concurrent object-oriented systems can be implemented using the actor model. Act++ <ref> [79] </ref> is a shared memory object-oriented programming environment based on actor model. It is implemented in C++. To facilitate synchronous communication, Act++ supports the concept of a `Cbox'. A Cbox is a future variable. A future variable blocks the calling process until its value is set.
Reference: [80] <author> Kenneth M. Kahn. </author> <title> Objects Afresh look. </title> <booktitle> In Proceedings ECOOP '89, </booktitle> <pages> pages 207-223, </pages> <month> July </month> <year> 1989. </year>
Reference: [81] <author> D. Katiyar, D. Luckham, and J. C. Mitchell. </author> <title> A type system for prototyping languages. </title> <booktitle> In Proceedings of the 21st ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1994. </year>
Reference: [82] <author> Arjun Khare. </author> <title> ACT++ 3.0 : Implementation of the Actor Model Using POSIX Threads. </title> <type> Master's thesis, </type> <institution> Virginia Tech, Blacksburg, VA, </institution> <year> 1994. </year> <note> REFERENCES 185 </note>
Reference-contexts: At this point the Cbox value is available to the invoking process and it can continue with its computation. 3.4.2.4 Distributed Actor model The Act++ system is extended to support distributed actors in Distributed Act++ <ref> [82] </ref> programming environment. In a Distributed Act++ environment every actor has a network-wide unique address. This address contains the node number which is a unique number assigned for a node in the system and a natural number that is unique for the actor at that node.
Reference: [83] <author> Gregor Kiczales, James des Rivieres, and Daniel G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: If a reflective computation modifies a metaobject, then it is called a reflective update and the process is called behavioral reflection. If a reflective computation does not modify a metaobject, then that process is called structural reflection. The operations defined for the metaobjects constitute a metaobject protocol <ref> [83] </ref>. Metaclass Approach In the Metaclass approach, the class of an object is considered as its metaobject. Metaclasses are metaobjects of classes. That is, a class is an instance of its metaclass. Metaclasses can have metaobjects for themselves, thus forming an infinite reflective tower [102].
Reference: [84] <author> Andrew Koenig. </author> <title> Templates as Interfaces. </title> <journal> Journal of Object-Oriented Programming, </journal> <pages> pages 51-55, </pages> <month> September </month> <year> 1991. </year>
Reference: [85] <author> Dimitri Konstantas. </author> <title> Object Oriented Interoperability. </title> <editor> In D. Tsichritzis, editor, </editor> <title> Visual Objects. </title> <institution> University of Geneva, </institution> <year> 1993. </year>
Reference: [86] <author> Kai Koskimies and Juha Vihavainen. </author> <title> The Problem of Unexpected Subclasses. </title> <journal> Journal of Object-Oriented Programming, </journal> <pages> pages 53-59, </pages> <month> October </month> <year> 1992. </year>
Reference: [87] <author> David Kranz, Kirk Johnson, and Anant Agarwal. </author> <title> Integrating message-passing and shared-memory: Early experience. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(7) </volume> <pages> 54-63, </pages> <month> July </month> <year> 1993. </year>
Reference: [88] <author> David Alex Lamb. </author> <title> IDL: Sharing intermediate representations. </title> <journal> ACM Transactions on Programming Languages, </journal> <volume> 9(3) </volume> <pages> 297-318, </pages> <month> July </month> <year> 1987. </year>
Reference: [89] <author> John Lamping. </author> <title> Typing the Specialization Interface. </title> <booktitle> In Proceedings OOP-SLA '93, </booktitle> <pages> pages 201-214, </pages> <month> October </month> <year> 1993. </year> <journal> Printed in SIGPLAN Notices, </journal> <volume> 28(10), </volume> <month> October </month> <year> 1993. </year>
Reference: [90] <author> Konstantin Laufer and Martin Odersky. </author> <title> Self-Interpretation and Reflection in a Statically Typed Language. </title> <booktitle> In OOPSLA '93 Workshop on Reflection and Metalevel Architectures in Object-Oriented Programming, </booktitle> <month> October </month> <year> 1993. </year>
Reference: [91] <author> Rodger Lea, Christian Jacquemot, and Eric Pillevesse. </author> <title> COOL: System support for distributed programming. </title> <journal> Communications of the ACM, </journal> <volume> 36(9) </volume> <pages> 37-47, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: 16 Table 2.2: Architectures (Common Run Time and Protocol Based) Versus Existing Models Architecture Existing Models PCR COOL Cronus ILU CORBA SOM COM RISC ODL HERON Common Run Time p p p Protocol Based p p p p p p p 2.2 Common Run Time Systems Common Run Time systems <ref> [91, 185] </ref> have a run time layer over existing operating systems. The run time layer provides services that can be used like operating system services. It acts as an intermediary between the interacting entities using down-calls and up-calls. <p> A down-call is a request from the client to the common run time and an up-call is a request from the common run time to the server. Both shared memory implementations [185] and distributed shared memory implementations <ref> [91] </ref> of the common run time systems are available. These systems support both object-oriented as well as non-object-oriented models. Portable Common Runtime (PCR) [185] from Xerox is an example of a non-object-oriented common runtime system. <p> Facilities provided in the PCR system are: a shared address space, symbol binding, light weight threads, and garbage collection. The PCR system implementation supports the languages C, Cedar, Scheme, and Common Lisp. The Chorus Object-Oriented Layer (COOL) <ref> [91] </ref> is an example of the common run time approach. COOL is an extension of the facilities provided by the Chorus CHAPTER 2. INTEROPERABLE SYSTEMS 17 distributed operating system. It provides a set of generic services that co-exist with an operating system's services.
Reference: [92] <author> Gary T. Leavens and William E. Weihl. </author> <title> Reasoning about Object-Oriented Programs that use Subtypes. </title> <booktitle> In Proceedings OOPSLA '90, </booktitle> <pages> pages 212-223, </pages> <month> October </month> <year> 1990. </year>
Reference: [93] <author> H J Lee and W T Tsai. </author> <title> A New Partial Inheritance Mechanism and Its Applications. </title> <journal> Journal of Object-Oriented Programming, </journal> <pages> pages 53-63, </pages> <month> July-August </month> <year> 1993. </year>
Reference: [94] <author> Donald Liib. </author> <title> A Note on Communicational Reflection. </title> <booktitle> In ECOOP '92 Workshop on Object-Oriented Reflection and Metalevel Architectures, </booktitle> <month> July </month> <year> 1992. </year> <note> REFERENCES 186 </note>
Reference: [95] <author> Barbara Liskov. </author> <title> Limitations of Synchronous Communication with Static Process Structure in Languages for Distributed Computing. </title> <booktitle> In Proceedings of the Thirteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 150-159, </pages> <month> January </month> <year> 1986. </year>
Reference: [96] <author> Barbara Liskov and Jeannette M. Wing. </author> <title> A New Definition of the Subtype Relation. </title> <booktitle> In Proceedings ECOOP '93, </booktitle> <pages> pages 118-141, </pages> <month> July </month> <year> 1993. </year>
Reference: [97] <author> Barbara Liskov and Jeannette M. Wing. </author> <title> Specifications and Their Use in Defining Subtypes. </title> <booktitle> In Proceedings OOPSLA '93, </booktitle> <pages> pages 16-28, </pages> <month> October </month> <year> 1993. </year> <journal> Printed in SIGPLAN Notices, </journal> <volume> 28(10), </volume> <month> October </month> <year> 1993. </year>
Reference: [98] <author> Ole Lehrmann Madsen. </author> <title> What Object-Oriented Programming May Be and What It Does Not Have To Be. </title> <booktitle> In Proceedings ECOOP '89, </booktitle> <pages> pages 1-20, </pages> <month> July </month> <year> 1989. </year>
Reference: [99] <author> Ole Lehrmann Madsen and Boris Magnusson. </author> <title> Strong Typing of Object-Oriented Languages Revisited. </title> <booktitle> In Proceedings OOPSLA '90, </booktitle> <pages> pages 140-149, </pages> <month> October </month> <year> 1990. </year>
Reference: [100] <author> Ole Lehrmann Madsen and Birger Moller-Pedersen. </author> <title> Virtual Classes: A Powerful Mechanism in Object-Oriented Programming. </title> <booktitle> In Proceedings OOPSLA '89, </booktitle> <pages> pages 397-406, </pages> <month> October </month> <year> 1989. </year>
Reference: [101] <author> Ole Lehrmann Madsen, Birger Moller-Pedersen, and Kristen Nygaard. </author> <title> Object-Oriented Programming in the BETA Programming Language. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1993. </year>
Reference: [102] <editor> Pattie Maes. </editor> <title> Concepts and Experiments in Computational Reflection. </title> <booktitle> In Proceedings OOPSLA '87, </booktitle> <pages> pages 147-155, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: A uniform framework for the proposed common object model, based on the actor model of communication is developed using reflection-like techniques <ref> [102] </ref>. This framework allows the addition of the advanced features mentioned in previous sections in a systematic manner. This framework can be translated into any statically typed object-oriented language that supports the common object model features directly. <p> A reflective object-oriented system is said to be causally connected to its domain, if one of them changes, it leads to a corresponding change in the other <ref> [102] </ref>. Reflection is defined as the ability of a system to make structures representing (aspects of) itself the subject (or domain) of its computation in a causally connected way [102]. Reification is the representation of specific aspects of a program as data structures or classes within that program [49]. <p> to be causally connected to its domain, if one of them changes, it leads to a corresponding change in the other <ref> [102] </ref>. Reflection is defined as the ability of a system to make structures representing (aspects of) itself the subject (or domain) of its computation in a causally connected way [102]. Reification is the representation of specific aspects of a program as data structures or classes within that program [49]. These aspects include method binding, inheri CHAPTER 3. INTEROPERABLE COMMON OBJECT MODEL (ICOM) 50 tance etc. The resulting objects are referred to as metaobjects. <p> Metaclass Approach In the Metaclass approach, the class of an object is considered as its metaobject. Metaclasses are metaobjects of classes. That is, a class is an instance of its metaclass. Metaclasses can have metaobjects for themselves, thus forming an infinite reflective tower <ref> [102] </ref>. This tower is normally terminated by defining a root metaclass which is a metaobject of itself [102]. <p> Metaclasses are metaobjects of classes. That is, a class is an instance of its metaclass. Metaclasses can have metaobjects for themselves, thus forming an infinite reflective tower <ref> [102] </ref>. This tower is normally terminated by defining a root metaclass which is a metaobject of itself [102]. A method invocation on an object can be described as follows: when an object receives a message, it is delegated to the object's metaobject, an object representing the class of the receiving object.
Reference: [103] <editor> Pattie Maes and Daniele Nardi, editors. </editor> <title> Meta-Level Architectures and Reflection. </title> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference: [104] <author> Silvano Maffeis. </author> <title> A Flexible System Design to Support Object-Groups and Object-Oriented Distributed Programming. </title> <booktitle> In Workshop on Object-Based Distributed Computing, ECOOP '93, </booktitle> <pages> pages 213-224, </pages> <month> July </month> <year> 1993. </year>
Reference: [105] <author> Silvano Maffeis. </author> <title> A Flexible System Design to Support Object-Groups and Object-Oriented Distributed Programming. </title> <type> Technical Report IFI TR 94.02, </type> <institution> University of Zurich, Dept of Computer Science, </institution> <year> 1994. </year> <note> to appear in LNCS. REFERENCES 187 </note>
Reference: [106] <author> Messac Makpangou, Yvon Gourhant, Jean-Pierre Le Narzul, and Marc Shapiro. </author> <title> Structuring Distributed Applications as Fragmented Objects. </title> <type> Technical Report INRIA 1404, </type> <institution> INRIA, France, </institution> <month> January </month> <year> 1991. </year>
Reference: [107] <author> Jawahar Malhotra. </author> <title> Dynamic Extensibility in a Statically-Compiled Object-Oriented Language. </title> <booktitle> In Object Technologies for Advanced Software, </booktitle> <pages> pages 297-314, </pages> <month> November </month> <year> 1993. </year> <note> Printed in LNCS 742. </note>
Reference: [108] <author> Frank Manola. </author> <title> X3H7 Object Model Features Matrix, </title> <month> May </month> <year> 1994. </year>
Reference: [109] <author> Frank Manola and Sandra Heiler. </author> <title> An Approach to Interoperable Object Models. </title>
Reference: [110] <author> Frank Manola and Sandra Heiler. </author> <title> A "RISC" Object Model for Object System Interoperation: Concepts and Applications. </title> <type> Technical Report TR-0231-08-93-165, </type> <institution> GTE Laboratories, </institution> <address> Waltham, MA, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: Integrating existing software components written in different programming languages is becoming a common practice in the software development process because it reduces code duplication and results in better reuse and maintenance of software. Many common object models <ref> [20, 60, 70, 110, 117] </ref> have been proposed to support interoperability of software components developed in multiple languages. The systems based on these models try to encapsulate the communication mechanisms used for the transfer of messages between objects in a distributed environment. <p> INTEROPERABLE SYSTEMS 25 object-oriented features. This core object model is mapped into non-object-oriented programming languages. Example systems include SOM [70] from IBM, and RISC <ref> [110] </ref> from GTE laboratories. Reflection techniques are discussed in the next chapter. The narrow domain approach considers only a subset of languages, in particular, object-oriented languages. A common object model is derived from the object models of these languages and all interoperating languages support this model. <p> The SOM system provides various class libraries including the ones for persistence and distribution. SOM supports mappings to C and C++. 2.3.4.6 Reduced Instruction Set Code Object Model The Reduced Instruction Set Code (RISC) object model <ref> [110] </ref> from GTE Laboratories is a second example under the extensible object models category of broad domain, object-oriented protocol based systems that follow the selective approach. It is an adaptable object model. The various features of the RISC model are given below.
Reference: [111] <author> Satoshi Matsuoka. </author> <title> Language Features for Reuse and Extensibility in Concurrent Object-Oriented Languages. </title> <type> PhD thesis, </type> <institution> University of Tokyo, </institution> <address> Tokyo, Japan, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: It has been pointed out that the synchronization code cannot be effectively inherited without non-trivial class redefinitions [113]. This problem is termed as the `inheritance anomaly' and has been studied extensively [113]. Three main reasons for inheritance anomaly have been identified in <ref> [111] </ref>. They are described below. Partitioning of acceptable states An object is said to be in one of several `states' at any time after its creation. These states can be divided into disjoint subsets based on its synchronization constraints.
Reference: [112] <author> Satoshi Matsuoka, Takuo Watanabe, and Akinori Yonezawa. </author> <title> Hybrid Group Reflective Architecture for Object-Oriented Concurrent Reflective Programming. </title> <booktitle> In Proceedings ECOOP '91, </booktitle> <pages> pages 231-250, </pages> <month> July </month> <year> 1991. </year>
Reference: [113] <author> Satoshi Matsuoka and Akinori Yonezawa. </author> <title> Analysis of Inheritance Anomaly in Object-Oriented Concurrent Programming Languages. </title> <editor> In Gul Agha, Peter Wegner, and Akinori Yonezawa, editors, </editor> <booktitle> Research Directions in Concurrent Object-Oriented Programming, </booktitle> <pages> pages 107-150. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1993. </year>
Reference-contexts: The synchronization feature allows for delaying of message processing, based on the state of the object and message contexts. The problem that arises by supporting inheritance of classes that use synchronization is known as the `inheritance anomaly' <ref> [113] </ref>. The inheritance anomaly problem is addressed in this dissertation. CHAPTER 1. INTRODUCTION 7 The feasibility of the model is shown by the development of an implementation framework. The framework supports the polymorphism and concurrency features considered above. <p> Some of them are: semaphores, guards, and reflection techniques. In a typical synchronization scheme, synchronization code is merged with the class implementation code. It has been pointed out that the synchronization code cannot be effectively inherited without non-trivial class redefinitions <ref> [113] </ref>. This problem is termed as the `inheritance anomaly' and has been studied extensively [113]. Three main reasons for inheritance anomaly have been identified in [111]. They are described below. <p> In a typical synchronization scheme, synchronization code is merged with the class implementation code. It has been pointed out that the synchronization code cannot be effectively inherited without non-trivial class redefinitions <ref> [113] </ref>. This problem is termed as the `inheritance anomaly' and has been studied extensively [113]. Three main reasons for inheritance anomaly have been identified in [111]. They are described below. Partitioning of acceptable states An object is said to be in one of several `states' at any time after its creation. These states can be divided into disjoint subsets based on its synchronization constraints. <p> The guard method approach, while not eliminating the anomaly, attempts to minimize the amount of rewriting. The approach uses two types of inheritance, one for inheriting synchronization constraints and the other for normal inheritance. It is possible to get confused with the two types of inheritance <ref> [113] </ref>. In this dissertation only one type of inheritance scheme is considered for both synchronization and normal inheritance.
Reference: [114] <author> Mark Maybee, , Dennis M. Heimbigner, and Leon J. Osterweil. </author> <title> Multilanguage interoperability in distributed systems: Experience Report. </title> <booktitle> In Proceedings of the 18th Internation Conference on Software Engineering, </booktitle> <month> March </month> <year> 1996. </year>
Reference: [115] <author> Mark Maybee, Leon J. Osterweil, and Stephen D. Sykes. </author> <title> Q: A multi-lingual interprocess communications system for software environment implementation. </title> <type> Technical Report CU-CS-46-90, </type> <institution> University of Colorado, Boulder, Dept. of Computer Science, </institution> <month> June </month> <year> 1990. </year>
Reference-contexts: Chapter 2 Interoperable Systems 2.1 Introduction Providing interoperability among programming languages has been a challenging problem for several years [42]. Earlier attempts to address interoperability were directed towards non-object-oriented languages [57, 65, 153, 185]. Several solutions exist for direct mapping between languages when only two languages are involved <ref> [46, 115] </ref>. Though these solutions are adequate for two languages, they become very complex when the number of languages used is more than two. When N languages are involved, they require N*(N-1) translators, with every language requiring translators to every other language.
Reference: [116] <author> Paul L. McCullough. </author> <title> Transparent Forwarding: First Steps. </title> <booktitle> In Proceedings OOPSLA '87Proceedings, </booktitle> <pages> pages 331-341, </pages> <month> October </month> <year> 1987. </year> <note> REFERENCES 188 </note>
Reference: [117] <author> Robert W. Mecklenburg. </author> <title> Towards a Language Independent Object System. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <address> Salt Lake City, Utah, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: Integrating existing software components written in different programming languages is becoming a common practice in the software development process because it reduces code duplication and results in better reuse and maintenance of software. Many common object models <ref> [20, 60, 70, 110, 117] </ref> have been proposed to support interoperability of software components developed in multiple languages. The systems based on these models try to encapsulate the communication mechanisms used for the transfer of messages between objects in a distributed environment. <p> The RISC model is planned to be implemented by the Distributed Object Management (DOM) 3.0 prototype. 2.3.4.7 Object Description Language The Object Description Language (ODL) <ref> [117] </ref>, developed at the University of Utah, is an example of a system that has a non-extensible object model under the narrow, object-oriented protocol based category. It consists of a common object model with features selected from the object-oriented languages C++, Objective-C, Smalltalk and CLOS.
Reference: [118] <author> Anurag Mendhekar and Daniel P. Friedman. </author> <title> Towards a Theory of Reflective Programming Languages. </title> <booktitle> In OOPSLA '93 Workshop on Reflection and Met-alevel Architectures in Object-Oriented Programming, </booktitle> <month> October </month> <year> 1993. </year>
Reference: [119] <author> Bertrand Meyer. </author> <title> Genericity versus Inheritance. </title> <booktitle> In Proceedings OOPSLA '86, </booktitle> <pages> pages 391-405, </pages> <month> September </month> <year> 1986. </year>
Reference: [120] <author> Bertrand Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice Hall, </publisher> <address> New York, NY, </address> <year> 1992. </year>
Reference: [121] <author> Josephine Micallef. </author> <title> Encapsulation, Reusability and Extensibility in Object-Oriented Programming Languages. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 1(1) </volume> <pages> 12-35, </pages> <month> april/may </month> <year> 1988. </year>
Reference: [122] <author> Sun Microsystems. </author> <note> NEO. http://www.sun.com/solaris/neo/solaris neo/. </note>
Reference-contexts: A second tabular representation showing various existing interoperable systems and the architectures supported by them is displayed in Table 2.2. Among these systems, SOM is a CORBA compliant system. Several other systems exist that are CORBA compliant <ref> [144, 122, 174] </ref>, but they are not shown here. CHAPTER 2.
Reference: [123] <author> Sun Microsystems. XDR: </author> <title> External Data Representation Standard(RFC 1014). </title> <type> Technical report, </type> <institution> Network Information Center, SRI International, </institution> <month> June </month> <year> 1987. </year>
Reference-contexts: This framework can be instantiated to support Abstract Syntax Notation 1 (ASN.1) [51] and the CORBA interface definition language (IDL) for data representation. The OODSF framework supports Basic Encoding Rules (BER) [52] and External Data Representation (XDR) <ref> [123] </ref> for transferring data between different nodes of the system. 3.4.2.5 Actor Messages used for Communication There are two ways to implement the communication between actors. First, dedicated actors can be created that can decide whether message is a constructor message, an CHAPTER 3.
Reference: [124] <author> Sun Microsystems. </author> <title> Java Remote Method Invocation Specification. </title> <type> Technical Report Revision 1.4, </type> <institution> Sun Microsystems, </institution> <address> Palo Alto, CA, </address> <month> February </month> <year> 1997. </year>
Reference-contexts: Java supports communication between objects distributed in different address spaces, using Remote Method Invocation (RMI) <ref> [124] </ref>. But, RMI is specifically designed to operate only in the Java environment. It cannot be used effectively with other languages [22]. Java is still an evolving language, undergoing changes in the facilities it provides.
Reference: [125] <author> John C. Mitchell. </author> <title> Toward a Typed Foundation for Method Specialization and Inheritance. </title> <booktitle> In Proceedings of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 109-124, </pages> <month> January </month> <year> 1990. </year>
Reference: [126] <author> R. Morrison, A. L. Brown, R. Carrick, R. C. H. Connor, A. Dearle, and M. P. Atkinson. </author> <title> Polymorphism, Persistence and Software Reuse in a Strongly Typed Object-Oriented Environment. </title> <journal> Software Engineering Journal, </journal> <pages> pages 199-205, </pages> <month> November </month> <year> 1987. </year>
Reference: [127] <author> Thomas J. Moubray and Ron Zahzvi. </author> <title> The Essential CORBA. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, NY, </address> <year> 1995. </year>
Reference: [128] <author> Patrick A. Muckelbauer and Vincent F. Russo. </author> <title> Building a Large-Scale Distributed Object System for a Multilingual Programming Environment. </title> <type> Technical Report CSD-TR-93-022, </type> <institution> Purdue University, Dept. of Computer Science, </institution> <month> April </month> <year> 1993. </year> <note> REFERENCES 189 </note>
Reference: [129] <author> Warwick B. Mugridge, John Hamer, and John G. Hosking. </author> <title> Multi-Methods in a Statically-Typed Programming Langugage. </title> <booktitle> In Proceedings ECOOP '91, </booktitle> <pages> pages 307-324, </pages> <month> July </month> <year> 1991. </year>
Reference: [130] <author> S. Muralidharan and Bruce W. Weide. </author> <booktitle> Should Data Abstraction be Violated to enhance Software Reuse? In 8th Annual National Conference on Ada Technology 1990, </booktitle> <pages> pages 515-524, </pages> <year> 1990. </year>
Reference: [131] <author> Andrew C. Myers, Joseph A. Bank, and Barbara Liskov. </author> <title> Parameterized types for Java. </title> <booktitle> In Proceedings of the 24th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 132-145, </pages> <month> January </month> <year> 1997. </year>
Reference: [132] <author> Colin Myers, Chris Clack, and Ellen Poon. </author> <title> Programming with Standard ML. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: Parametric types can be implemented in two ways. A separate implementation can be generated for each type instantiation, as in C++ [166], or a single implementation can be used for all type instantiations, as in ML <ref> [132] </ref>, depending on how the language semantics are defined. For example, `static' variables play different roles in these two types of implementations.
Reference: [133] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> En-glewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: INTRODUCTION 9 and server objects. This dissertation concentrates on statically typed object-oriented languages. The languages selected are C++ [166] and Modula-3 <ref> [133] </ref>.
Reference: [134] <author> John R. Nicol, C. Thomas Wilkes, and Frank A. Manola. </author> <title> Object Orientation in Heterogeneous Distributed Computing Systems. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 57-67, </pages> <month> June </month> <year> 1993. </year>
Reference: [135] <author> O. M. Nierstrasz. </author> <title> Active Objects in Hybrid. </title> <booktitle> In Proceedings OOPSLA '87, </booktitle> <pages> pages 243-253, </pages> <month> October </month> <year> 1987. </year>
Reference: [136] <author> Oscar Nierstrasz. </author> <title> A Survey of Object-Oriented Concepts. </title> <editor> In W. Kim and F. Lochovsky, editors, </editor> <booktitle> Object-Oriented Concepts, Databases and Applications, </booktitle> <pages> pages 3-21. </pages> <publisher> ACM Press and Addison Wesley, </publisher> <year> 1989. </year>
Reference: [137] <author> Oscar Nierstrasz. </author> <title> Regular types for Active Objects. </title> <booktitle> In Proceedings OOP-SLA '93, </booktitle> <pages> pages 1-15, </pages> <month> October </month> <year> 1993. </year> <journal> Printed in SIGPLAN Notices, </journal> <volume> 28(10), </volume> <month> October </month> <year> 1993. </year>
Reference: [138] <author> Martin Odersky and Philip Wadler. </author> <title> Pizza into Java: Translating Theory into Practice. </title> <booktitle> In Proceedings of the 24th ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1997. </year>
Reference: [139] <author> Atsushi Ohori and Peter Buneman. </author> <title> Static Type Inference for Parametric Classes. </title> <booktitle> In Proceedings OOPSLA '89, </booktitle> <pages> pages 445-456, </pages> <month> October </month> <year> 1989. </year>
Reference: [140] <author> Robert Orfali, Dan Harkey, and Jeri Edwards. </author> <title> The Essential Distributed Objects Survival Guide. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, NY, </address> <year> 1996. </year> <note> REFERENCES 190 </note>
Reference: [141] <author> International Standards Organization. </author> <title> Reference Model for Open Distributed Processing. </title> <type> Technical Report WG7 N. 885, </type> <institution> Open Distributed Processing, New South Wales, Australia, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: In inclusive models, an extensive set of object-oriented features (usually a union of the object-oriented features of all languages) is included in the model. The HERON system [188] and the Open Distributed Processing (ODP) <ref> [141] </ref> from International Standards Organization (ISO) and Consultative Committee on International Telephony and Telegraphy (CCITT) fall into this category. In selective models, a common denominator of all object-oriented features of the participating object-oriented programming languages is taken as the object model.
Reference: [142] <author> Harold Ossher and William Harrison. </author> <title> Combination of Inheritance Hierarchies. </title> <booktitle> In Proceedings OOPSLA '92, </booktitle> <pages> pages 25-40, </pages> <month> October </month> <year> 1992. </year>
Reference: [143] <author> Nicholas Oxhoj, Jens Palsberg, and Michael I. Schwartzbach. </author> <title> Making Type Inference Practical. </title> <booktitle> In Proceedings ECOOP '92, </booktitle> <pages> pages 329-349, </pages> <month> July </month> <year> 1992. </year>
Reference: [144] <institution> Hewlett Packard. </institution> <note> ORB Plus 2.0. http://www.hp.com/gsy/orbplus.html. </note>
Reference-contexts: A second tabular representation showing various existing interoperable systems and the architectures supported by them is displayed in Table 2.2. Among these systems, SOM is a CORBA compliant system. Several other systems exist that are CORBA compliant <ref> [144, 122, 174] </ref>, but they are not shown here. CHAPTER 2.
Reference: [145] <editor> Andreas Paepcke, editor. </editor> <title> Object-Oriented Programming: The CLOS Perspective. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1993. </year>
Reference: [146] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Type Substitution for Object-Oriented Programming. </title> <booktitle> In Proceedings OOPSLA '90, </booktitle> <pages> pages 151-160, </pages> <month> October </month> <year> 1990. </year>
Reference: [147] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Object-Oriented Type Inference. </title> <booktitle> In Proceedings OOPSLA '91, </booktitle> <pages> pages 146-161, </pages> <month> October </month> <year> 1991. </year>
Reference: [148] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <booktitle> What is Type-Safe Code Reuse? In Proceedings ECOOP '91, </booktitle> <pages> pages 325-341, </pages> <month> July </month> <year> 1991. </year>
Reference: [149] <author> M. Papathomas. </author> <title> Concurrency Issues in Object-Oriented Programming Languages. </title> <editor> In D. Tsichritzis, editor, </editor> <booktitle> Object-Oriented Development, </booktitle> <pages> pages 207-245. </pages> <institution> Center Universitaire D'informatique, </institution> <month> July </month> <year> 1989. </year>
Reference: [150] <author> Claus H. Pedersen. </author> <title> Extending Ordinary Inheritance Schemes to Include Generalization. </title> <booktitle> In Proceedings OOPSLA '89, </booktitle> <pages> pages 407-417, </pages> <month> October </month> <year> 1989. </year>
Reference: [151] <author> John Peterson and Mark Jones. </author> <title> Implementing Type Classes. </title> <booktitle> In SIGPLAN '93 Conference on Programming Language Design and Implementation, Albu-querque, </booktitle> <pages> pages 227-236, </pages> <month> June </month> <year> 1993. </year> <note> also appeared in ACM SIGPLAN Notices, 28,6, June '93. </note>
Reference: [152] <author> Ramana Rao. </author> <title> Implementational reflection in Silica. </title> <booktitle> In Proceedings ECOOP '91, </booktitle> <pages> pages 251-267, </pages> <month> July </month> <year> 1991. </year>
Reference: [153] <author> Ward Rosenberry, David Kenney, and Gerry Fisher. </author> <title> Understanding DCE. </title> <publisher> O'Reilly and Associates, </publisher> <address> Sebastopol, CA, </address> <year> 1993. </year> <note> REFERENCES 191 </note>
Reference-contexts: Finally, the `outline' section briefly described the contents of each chapter. Chapter 2 Interoperable Systems 2.1 Introduction Providing interoperability among programming languages has been a challenging problem for several years [42]. Earlier attempts to address interoperability were directed towards non-object-oriented languages <ref> [57, 65, 153, 185] </ref>. Several solutions exist for direct mapping between languages when only two languages are involved [46, 115]. Though these solutions are adequate for two languages, they become very complex when the number of languages used is more than two.
Reference: [154] <author> Francois Rousseau and Jacques Malenfant. </author> <title> Browsing in Explicit Metaclass Languages: An Essay in Reflective Programming Environments. </title> <booktitle> In OOPSLA '93 Workshop on Reflection and Metalevel Architectures in Object-Oriented Programming, </booktitle> <month> October </month> <year> 1993. </year>
Reference: [155] <author> M. Sakkinen. </author> <title> Disciplined Inheritance. </title> <booktitle> In Proceedings ECOOP '89, </booktitle> <pages> pages 39-56, </pages> <month> July </month> <year> 1989. </year>
Reference: [156] <author> John H. Saunders. </author> <title> A Survey of Object-Oriented Programming Languages. </title> <journal> Journal of Object-Oriented Programming, </journal> <pages> pages 5-11, </pages> <month> march-april </month> <year> 1989. </year>
Reference: [157] <author> Etsuya Shibayama. </author> <title> Reuse of Concurrent Object Descriptions. </title> <booktitle> In Proceedings of TOOLS 3, </booktitle> <address> Sydney, </address> <publisher> Australiz, </publisher> <pages> pages 254-266, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: In the gget method addition, it is required to add a new state as well as modify the existing states. There have been several proposals that addressed the inheritance anomaly. One such approach is guard methods used in <ref> [157] </ref>. A guard method is a boolean method that returns either `true' or `false' based on its arguments and the state of the object CHAPTER 6. CONCURRENCY 119 that contains the guard method.
Reference: [158] <author> Jon Siegel. </author> <title> CORBA Fundamentals and Programming. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, NY, </address> <year> 1996. </year>
Reference-contexts: The example presented in this section is used throughout this dissertation and is derived from the problem defined in <ref> [158] </ref>. An CHAPTER 3. INTEROPERABLE COMMON OBJECT MODEL (ICOM) 40 illustration of communications between different objects of this example is shown in " The problem domain is a national level financial agency that owns a nationwide chain of stores.
Reference: [159] <author> Pradeep K. Sinha. </author> <title> Distributed Operating Systems: Concepts and Design. </title> <publisher> IEEE Computer Society Press, </publisher> <address> New York, NY, </address> <year> 1997. </year>
Reference-contexts: CONCURRENCY 113 slicing' can be used where each process is allocated a fixed time during which it has control over the CPU <ref> [159] </ref>. Thus, with concurrency, the CPU can be better utilized and multiple processes can share the CPU for achieving a common goal in a shorter time compared to the sequential execution of these processes executing one after the other.
Reference: [160] <author> Brian C. Smith. </author> <title> Reflection and semantics in Lisp. </title> <booktitle> In Proceedings of the Tenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 23-35, </pages> <month> January </month> <year> 1983. </year>
Reference: [161] <author> Alan Snyder. </author> <title> Encapsulation and Inheritance in Object-Oriented Programming Languages. </title> <booktitle> In Proceedings OOPSLA '86, </booktitle> <pages> pages 38-45, </pages> <month> September </month> <year> 1986. </year>
Reference: [162] <author> Alan Snyder. </author> <title> Modeling the C++ Object Model: An Application of an Abstract Object Model. </title> <booktitle> In Proceedings ECOOP '91, </booktitle> <pages> pages 1-20, </pages> <month> July </month> <year> 1991. </year>
Reference: [163] <author> Richard Mark Soley and Christopher M. Stone, </author> <title> editors. Object Management Architecture Guide, Revision 3.0. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, NY, </address> <year> 1995. </year>
Reference: [164] <author> Bjarne Stroustrup. </author> <title> An overview of C++. </title> <journal> ACM SIGPLAN Notices, </journal> <pages> pages 7-18, </pages> <month> October </month> <year> 1986. </year>
Reference: [165] <author> Bjarne Stroustrup. </author> <booktitle> What is Object-Oriented Programming? IEEE Software, </booktitle> <pages> pages 10-20, </pages> <month> May </month> <year> 1988. </year>
Reference: [166] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language, 3rd Edition. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1997. </year> <note> REFERENCES 192 </note>
Reference-contexts: INTRODUCTION 9 and server objects. This dissertation concentrates on statically typed object-oriented languages. The languages selected are C++ <ref> [166] </ref> and Modula-3 [133]. <p> The C++ language supports inheritance of template parameter type, but other languages such as Modula-3 do not support it. Parametric types can be implemented in two ways. A separate implementation can be generated for each type instantiation, as in C++ <ref> [166] </ref>, or a single implementation can be used for all type instantiations, as in ML [132], depending on how the language semantics are defined. For example, `static' variables play different roles in these two types of implementations.
Reference: [167] <author> Ichiro Suzuki and Tadao Kasami. </author> <title> A Distributed Mutual Exclusion Algorithm. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(4) </volume> <pages> 344-349, </pages> <month> November </month> <year> 1985. </year>
Reference-contexts: The owner after receiving acknowledgments from all peers can start a new execution. CHAPTER 6. CONCURRENCY 133 Potentially, any distributed shared lock algorithm can be used for implementing a shared lock in a distributed environment. In this dissertation Suzuki and Kasami algorithm <ref> [167] </ref> is used for implementing atomic locks. A brief description of the algorithm is given below. 6.2.4 Suzuki and Kasami Algorithm The Suzuki and Kasami algorithm was originally designed to provide distributed mutual exclusion to critical sections among N nodes in a distributed network of computers.
Reference: [168] <institution> BBN Systems and Technologies. </institution> <note> Cronus technical summary, Release 2.0, </note> <month> March </month> <year> 1991. </year>
Reference: [169] <author> Clemens A. Szyperski. </author> <title> Import is not inheritance Why we need both: Modules and Classes. </title> <booktitle> In Proceedings ECOOP '92, </booktitle> <pages> pages 19-32, </pages> <month> July </month> <year> 1992. </year>
Reference: [170] <author> David Taenzer, Murthy Ganti, and Sunil Podar. </author> <title> Object-Oriented Software Reuse: The Yoyo Problem. </title> <journal> Journal of Object-Oriented Programming, </journal> <pages> pages 30-35, </pages> <month> September/October </month> <year> 1989. </year>
Reference: [171] <author> David Taenzer, Murthy Ganti, and Sunil Podar. </author> <title> Problems in Object-Oriented Software Reuse. </title> <booktitle> In Proceedings ECOOP '89, </booktitle> <pages> pages 25-38, </pages> <month> July </month> <year> 1989. </year>
Reference: [172] <author> S. Tucker Taft. </author> <title> Ada 9X: From abstraction-oriented to object-oriented. </title> <booktitle> In Proceedings OOPSLA '93, </booktitle> <pages> pages 127-136, </pages> <month> October </month> <year> 1993. </year> <journal> Printed in SIGPLAN Notices, </journal> <volume> 28(10), </volume> <month> October </month> <year> 1993. </year>
Reference: [173] <author> Antero Taivalsaari. </author> <title> On the Notion of Inheritance. </title> <journal> ACM Computing Surveys, </journal> <volume> 28(3) </volume> <pages> 438-479, </pages> <month> September </month> <year> 1996. </year>
Reference: [174] <institution> BBN Technologies. Corbus. </institution> <note> http://www.bbn.com/products/dpom/corbus.htm. </note>
Reference-contexts: A second tabular representation showing various existing interoperable systems and the architectures supported by them is displayed in Table 2.2. Among these systems, SOM is a CORBA compliant system. Several other systems exist that are CORBA compliant <ref> [144, 122, 174] </ref>, but they are not shown here. CHAPTER 2.
Reference: [175] <author> IONA Technologies. </author> <title> Orbix 2 Programming Guide. </title> <type> Technical report, </type> <address> IONA, Dublin, Ireland, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: A proxy is a surrogate object that represents a remote object at the local site. A client using a proxy can treat it as a real object. The CORBA compliant system, ORBIX, from IONA Technologies, supports inheritance using proxies <ref> [175] </ref>. But, this works only for split objects. Because, in the ORBIX system, inheritance of abstract methods is not possible across different address spaces. It is fair to say that the ORBIX system supports partial implementation inheritance. Objects in a distributed system can either be local or remote. <p> If the object is remote then the system packages the message, delivers it to the right object, and returns the results to the client. Since, existing models (except HERON [188] and to some extent ORBIX <ref> [175] </ref>) support interface inheritance only, the true power of object-oriented programming cannot be achieved in these systems.
Reference: [176] <author> Chris Tomlinson and Vineet Singh. </author> <title> Inheritance and synchronization with Enabled Sets. </title> <booktitle> In Proceedings OOPSLA '89, </booktitle> <pages> pages 103-112, </pages> <month> October </month> <year> 1989. </year>
Reference: [177] <author> Steve Vinoski. </author> <title> CORBA: Integrating Diverse Applications Within Distributed Heterogeneous Environments. </title> <journal> IEEE Communications Magazine, </journal> <volume> 14(2), </volume> <month> Febru-ary </month> <year> 1997. </year>
Reference: [178] <author> Mladen A. Vouk. </author> <title> On the Cost of Mixed Language Programming. </title> <journal> ACM SIG-PLAN Notices, </journal> 19(12) 54-60, December 1984. 
Reference: [179] <author> Mitchell Wand and Daniel P. Friedman. </author> <title> The Mystery of the Tower Revealed: A Non-Reflective Description of the Reflective Tower. </title> <editor> In Pattie Maes and Daniele Nardi, editors, </editor> <booktitle> Meta-Level Architectures and Reflection, </booktitle> <pages> pages 111-134. </pages> <publisher> North-Holland, </publisher> <year> 1988. </year> <note> REFERENCES 193 </note>
Reference: [180] <author> T. Watanabe and A. Yonezawa. </author> <title> An Actor-based Metalevel Architecture for Group-wide Reflection. </title> <booktitle> In Foundations of Object-Oriented Languages, </booktitle> <pages> pages 405-425, </pages> <note> may/june 1990. Printed in LNCS 489. </note>
Reference: [181] <author> Takuo Watanabe and Akinori Yonezawa. </author> <title> Reflection in an Object-Oriented Concurrent Language. </title> <booktitle> In Proceedings OOPSLA '88, </booktitle> <pages> pages 306-315, </pages> <month> September </month> <year> 1988. </year>
Reference: [182] <author> P. Wegner and S. B. Zdonik. </author> <title> Inheritance as an Incremental Modification Mechanism or What Like Is and Isn't Like. </title> <booktitle> In Proceedings ECOOP '88, </booktitle> <pages> pages 55-77, </pages> <month> July </month> <year> 1988. </year>
Reference: [183] <author> Peter Wegner. </author> <title> Dimensions of Object-Based Language Design. </title> <booktitle> In Proceedings OOPSLA '87, </booktitle> <pages> pages 168-182, </pages> <month> October </month> <year> 1987. </year>
Reference: [184] <author> Peter Wegner, William Scherlis, James Purtilo, David Luckham, and Ralph Johnson. </author> <title> Object-Oriented Megaprogramming. </title> <booktitle> In Proceedings OOPSLA '92, </booktitle> <pages> pages 392-396, </pages> <month> October </month> <year> 1992. </year>
Reference: [185] <author> Mark Weiser, Alan Demers, and Carl Hauser. </author> <title> The Portable Common Runtime Approach to Interoperability. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 114-122, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Finally, the `outline' section briefly described the contents of each chapter. Chapter 2 Interoperable Systems 2.1 Introduction Providing interoperability among programming languages has been a challenging problem for several years [42]. Earlier attempts to address interoperability were directed towards non-object-oriented languages <ref> [57, 65, 153, 185] </ref>. Several solutions exist for direct mapping between languages when only two languages are involved [46, 115]. Though these solutions are adequate for two languages, they become very complex when the number of languages used is more than two. <p> 16 Table 2.2: Architectures (Common Run Time and Protocol Based) Versus Existing Models Architecture Existing Models PCR COOL Cronus ILU CORBA SOM COM RISC ODL HERON Common Run Time p p p Protocol Based p p p p p p p 2.2 Common Run Time Systems Common Run Time systems <ref> [91, 185] </ref> have a run time layer over existing operating systems. The run time layer provides services that can be used like operating system services. It acts as an intermediary between the interacting entities using down-calls and up-calls. <p> It acts as an intermediary between the interacting entities using down-calls and up-calls. A down-call is a request from the client to the common run time and an up-call is a request from the common run time to the server. Both shared memory implementations <ref> [185] </ref> and distributed shared memory implementations [91] of the common run time systems are available. These systems support both object-oriented as well as non-object-oriented models. Portable Common Runtime (PCR) [185] from Xerox is an example of a non-object-oriented common runtime system. <p> Both shared memory implementations <ref> [185] </ref> and distributed shared memory implementations [91] of the common run time systems are available. These systems support both object-oriented as well as non-object-oriented models. Portable Common Runtime (PCR) [185] from Xerox is an example of a non-object-oriented common runtime system. The PCR system provides closely coupled interoperability between programs written in different languages in a shared memory environment.
Reference: [186] <author> Mario Wolczko. </author> <title> Encapsulation, Delegation and Inheritance in Object-Oriented Languages. </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 95-101, </pages> <month> March </month> <year> 1992. </year>
Reference: [187] <author> Th. Wolff and K. P. Lohr. </author> <title> Transparently Programming Heterogeneous Distributed Systems. </title> <editor> In Alexander Schill, Christian Mittasch, Otto Spaniol, and Claudia Popien, editors, </editor> <booktitle> Distributed Platforms, </booktitle> <pages> pages 399-411. </pages> <publisher> Chapman & Hill, </publisher> <year> 1996. </year>
Reference-contexts: Truly distributed objects form a subset of a more generic form of distributed objects, called split objects <ref> [187] </ref>. A split object is a distributed object whose components are arbitrarily placed in different processes. A new concept of distributed compilation is introduced to support `truly distributed objects'. A distributed compiler, when invoked on an IDL description involving truly distributed objects, transfers information among translators at different sites. <p> In the following subsections, a few relevant systems are briefly described. These systems are listed in Figure 2.1 2.3.4.1 HERON The HERON system <ref> [187, 188] </ref> from the Free University of Berlin focuses on the Eiffel programming language's object model as the common object model. In this system, the object model of Eiffel is treated as the most versatile object model that encompasses all object-oriented features.

References-found: 187

