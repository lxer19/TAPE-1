URL: http://www.ri.cmu.edu/afs/cs/user/fp/public/papers/CMU-CS-92-105.ps.gz
Refering-URL: http://www.ri.cmu.edu/afs/cs/user/fp/public/papers/
Root-URL: 
Title: On the Undecidability of Partial Polymorphic Type Reconstruction  
Author: Frank Pfenning 
Note: This research was sponsored by the Avionics Laboratory, Wright Research and Development Center, Aeronautical Systems Division (AFSC), U.S. Air Force, Wright-Patterson AFB, Ohio 45433-6543 under Contract F33615-90-C-1465, ARPA Order No. 7597. The views and conclusions contained in this document are those of the author and should not be interpreted as representing the official policies, either expressed or implied, of the U.S. government.  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: January 1992  
Pubnum: CMU-CS-92-105  
Abstract: We prove that partial type reconstruction for the pure polymorphic -calculus is undecidable by a reduction from the second-order unification problem, extending a previous result by H.-J. Boehm. We show further that partial type reconstruction remains undecidable even in a very small pred-icative fragment of the polymorphic -calculus, which implies undecidability of partial type reconstruction for ML as introduced by Harper, Mitchell, and Moggi. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Hans-J. Boehm. </author> <title> Partial polymorphic type inference is undecidable. </title> <booktitle> In 26th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 339-345. </pages> <publisher> IEEE, </publisher> <month> October </month> <year> 1985. </year>
Reference-contexts: This problem has been called partial type inference by H.-J. Boehm, who showed that, with certain minor additional assumptions, it is undecidable <ref> [1] </ref>. This result has been sharpened by the author in [19], where it is also argued that the problem can be solved effectively using higher-order unification. <p> If such an M exists, we call P valid in and write . P . We show in Theorem 23 that partial type reconstruction is undecidable. A similar, but technically weaker result was first reported by H.-J. Boehm <ref> [1] </ref> and anticipated by Mitchell [17]. Boehm's proof requires a fixpoint operator and an uninterpreted type constant in the language. In view of the undecidability result, restrictions on partially typed terms have been proposed which lead to a decidable type reconstruction problem (see [2, 11]).
Reference: [2] <author> Hans-J. Boehm. </author> <title> Type inference in the presence of type abstraction. </title> <booktitle> In Proceedings of the SIGPLAN'89 Conference on Programming Language Design and Implementation, Portland, Oregon, </booktitle> <pages> pages 192-206. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: We refer to (a variation of) Boehm's problem as partial type reconstruction and the other problem as full type reconstruction. We believe that partial type reconstruction is the practically more useful problem, and a number of implementations have been based on decidable subcases (see, for example, <ref> [2, 20, 11] </ref>). Further discussion can be found in [19]. In this paper we prove that partial type reconstruction for the pure polymorphic -calculus is undecidable. This proof is a slightly modified version of the one sketched in [19]. <p> Boehm [1] and anticipated by Mitchell [17]. Boehm's proof requires a fixpoint operator and an uninterpreted type constant in the language. In view of the undecidability result, restrictions on partially typed terms have been proposed which lead to a decidable type reconstruction problem (see <ref> [2, 11] </ref>). Our own view is to allow the full range of partially typed terms and use a variant of second-order unification to perform type reconstruction as suggested in [19]. More difficult to analyze than partial type reconstruction has been the problem of full type reconstruction.
Reference: [3] <author> Luis Damas and Robin Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Proceedings of the 9th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-212. </pages> <publisher> ACM SIGPLAN/SIGACT, </publisher> <year> 1982. </year>
Reference-contexts: Further discussion on this issue can be found in [19]. In particular, we indicate how it could be considered a natural generalization of type inference in the Damas-Milner calculus <ref> [3] </ref> which is the basis for type inference in the programming language ML. To illustrate the difference between partial and full type reconstruction, consider the preterm x: x [ ] x in the empty context.
Reference: [4] <author> Paolo Giannini and Simona Ronchi Della Rocca. </author> <title> Type inference in polymorphic type discipline. </title> <editor> In T. Ito and A. R. Meyer, editors, </editor> <booktitle> International Conference on Theoretical Aspects of Computer Software, Sendai, Japan, </booktitle> <pages> pages 18-37. </pages> <publisher> Springer-Verlag LNCS 526, </publisher> <month> September </month> <year> 1991. </year>
Reference-contexts: This problem has been called type inference, full type inference, and type reconstruction, and has resisted complete analysis, despite intensive efforts and some partial answers (see, for example, <ref> [14, 12, 4] </ref>). We refer to (a variation of) Boehm's problem as partial type reconstruction and the other problem as full type reconstruction. <p> The decidability of full type reconstruction is still open, despite intensive efforts and a number of partial results (see, for example, <ref> [12, 4] </ref>). Unfortunately, our undecidability results seems to bear no direct relationship to the full type reconstruction problem, nor do we see how our techniques could be applied.
Reference: [5] <author> Jean-Yves Girard. </author> <title> Une extension de l'interpretation de Godel a l'analyse, et son application a l'elimination des coupures dans l'analyse et la theorie des types. </title> <editor> In J. E. Fenstad, editor, </editor> <booktitle> Proceedings of the Second Scandinavian Logic Symposium, </booktitle> <pages> pages 63-92, </pages> <address> Amsterdam, London, 1971. </address> <publisher> North-Holland Publishing Co. </publisher>
Reference-contexts: In Section 5 we develop this reduction and undecidability proof for partial type reconstruction. In Section 6 we show how this result extends to a predicative fragment which is contained in ML [9]. 2 The Polymorphic -Calculus Variations of second-order polymorphic -calculus go back to Girard's system F <ref> [5, 6, 7] </ref> and Reynolds [21]. Here we treat the pure, type-theoretic core of the language, without recursion or existential types, for example.
Reference: [6] <author> Jean-Yves Girard. </author> <title> Interpretation fonctionelle et elimination des coupures de l'arithmetique d'ordre superieur. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: 1 Introduction The polymorphic -calculus, discovered independently by Girard <ref> [6] </ref> and Reynolds [21], has served as the basis for many investigations into the nature of polymorphism in programming languages. <p> In Section 5 we develop this reduction and undecidability proof for partial type reconstruction. In Section 6 we show how this result extends to a predicative fragment which is contained in ML [9]. 2 The Polymorphic -Calculus Variations of second-order polymorphic -calculus go back to Girard's system F <ref> [5, 6, 7] </ref> and Reynolds [21]. Here we treat the pure, type-theoretic core of the language, without recursion or existential types, for example.
Reference: [7] <author> Jean-Yves Girard, Yves Lafont, and Paul Taylor. </author> <title> Proofs and Types, </title> <booktitle> volume 7 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1989. </year>
Reference-contexts: In Section 5 we develop this reduction and undecidability proof for partial type reconstruction. In Section 6 we show how this result extends to a predicative fragment which is contained in ML [9]. 2 The Polymorphic -Calculus Variations of second-order polymorphic -calculus go back to Girard's system F <ref> [5, 6, 7] </ref> and Reynolds [21]. Here we treat the pure, type-theoretic core of the language, without recursion or existential types, for example. <p> is derivable" by "[a judgment]." For example, the judgment " ` M : t " might stand for the proposition " ` M : t is derivable." The polymorphic -calculus has a number of remarkable properties, such as the Church-Rosser property and strong normalization for valid terms (see, for example, <ref> [7] </ref>). We will need only a very limited set of properties of the calculus, which means that the main undecidability result also holds in extensions where the stronger properties fail, for example, in an extension by a fixpoint operator.
Reference: [8] <author> Warren D. Goldfarb. </author> <title> The undecidability of the second-order unification problem. </title> <journal> Theoretical Computer Science, </journal> <volume> 13 </volume> <pages> 225-230, </pages> <year> 1981. </year>
Reference-contexts: In Section 3 we define the partial and full type reconstruction problems for this calculus. In Section 4 we give a formulation of the second-order unification problem which has been shown to be undecidable by Goldfarb <ref> [8] </ref>, and which we reduce to partial type reconstruction. In Section 5 we develop this reduction and undecidability proof for partial type reconstruction. <p> This problem has been shown to be undecidable in the presence of at least one binary function constant by Goldfarb <ref> [8] </ref>. In order to simplify the reduction we define a variant of second-order unification which can easily be seen as a generalization of the standard formulation. A related formulation in terms of mixed prefixes is given by Miller [15]. <p> Then provability of F is undecidable even if F contains no occurrence of . 6 Proof: Goldfarb <ref> [8] </ref> showed that the second-order unification problem is undecidable in the pres-ence of at least one binary function constant.
Reference: [9] <author> Robert Harper, John Mitchell, and Eugenio Moggi. </author> <title> Higher order modules and the phase distinction. </title> <booktitle> In Conference Record of the 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 341-354. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1990. </year>
Reference-contexts: In Section 5 we develop this reduction and undecidability proof for partial type reconstruction. In Section 6 we show how this result extends to a predicative fragment which is contained in ML <ref> [9] </ref>. 2 The Polymorphic -Calculus Variations of second-order polymorphic -calculus go back to Girard's system F [5, 6, 7] and Reynolds [21]. Here we treat the pure, type-theoretic core of the language, without recursion or existential types, for example. <p> This can be seen by carefully examining the proofs showing the undecidability of partial type reconstruction in the polymorphic -calculus given in Section 5. 3 This means that partial type reconstruction for ML (see <ref> [18, 9] </ref>) is also undecidable. The polymorphic -calculus is impredicative in that the domain of quantification (by ) includes all possible types.
Reference: [10] <author> J. Roger Hindley. </author> <title> The principal type-scheme of an object in combinatory logic. </title> <journal> Transactions of the American Mathematical Society, </journal> <volume> 146 </volume> <pages> 29-60, </pages> <month> December </month> <year> 1969. </year>
Reference-contexts: 1 Introduction The polymorphic -calculus, discovered independently by Girard [6] and Reynolds [21], has served as the basis for many investigations into the nature of polymorphism in programming languages. While it was known that the simply-typed -calculus admits principal type schemes and its type inference problem is decidable <ref> [10, 16] </ref>, an analysis of type inference for the polymorphic -calculus has proved more difficult. There appear to be at least two different notions of type inference, both of which are decidable over the simply-typed fragment.
Reference: [11] <author> James W. O'Toole Jr. and David K. Gifford. </author> <title> Type reconstruction with first-class polymorphic values. </title> <booktitle> In Proceedings of the SIGPLAN'89 Conference on Programming Language Design and Implementation, Portland, Oregon, </booktitle> <pages> pages 207-217. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1989. </year> <month> 14 </month>
Reference-contexts: We refer to (a variation of) Boehm's problem as partial type reconstruction and the other problem as full type reconstruction. We believe that partial type reconstruction is the practically more useful problem, and a number of implementations have been based on decidable subcases (see, for example, <ref> [2, 20, 11] </ref>). Further discussion can be found in [19]. In this paper we prove that partial type reconstruction for the pure polymorphic -calculus is undecidable. This proof is a slightly modified version of the one sketched in [19]. <p> Boehm [1] and anticipated by Mitchell [17]. Boehm's proof requires a fixpoint operator and an uninterpreted type constant in the language. In view of the undecidability result, restrictions on partially typed terms have been proposed which lead to a decidable type reconstruction problem (see <ref> [2, 11] </ref>). Our own view is to allow the full range of partially typed terms and use a variant of second-order unification to perform type reconstruction as suggested in [19]. More difficult to analyze than partial type reconstruction has been the problem of full type reconstruction.
Reference: [12] <author> A. J. Kfoury and J. Tiuryn. </author> <title> Type reconstruction in finite-rank fragments of the polymorphic -calculus. </title> <journal> Information and Computation, </journal> <note> 199? To appear. </note>
Reference-contexts: This problem has been called type inference, full type inference, and type reconstruction, and has resisted complete analysis, despite intensive efforts and some partial answers (see, for example, <ref> [14, 12, 4] </ref>). We refer to (a variation of) Boehm's problem as partial type reconstruction and the other problem as full type reconstruction. <p> The decidability of full type reconstruction is still open, despite intensive efforts and a number of partial results (see, for example, <ref> [12, 4] </ref>). Unfortunately, our undecidability results seems to bear no direct relationship to the full type reconstruction problem, nor do we see how our techniques could be applied.
Reference: [13] <author> Daniel Leivant. </author> <title> Finitely stratified polymorphism. </title> <journal> Information and Computation, </journal> <note> 199? To appear. Available as Technical Report CMU-CS-90-160, </note> <institution> School of Computer Science, Carnegie Mellon University. </institution>
Reference-contexts: A hierarchy of universes of types can be defined in order to avoid the impredicativity (see, for example, <ref> [13] </ref>). Here, we will only use two universes: simple types s and polymorphic types t . The calculus is made predicative by insisting that the quantifier in polymorphic types ranges only over simple types. This can be enforced syntactically by restricting the application of a polymorphic function to simple types.
Reference: [14] <author> Nancy McCracken. </author> <title> The typechecking of programs with implicit type structure. </title> <editor> In G. Kahn, D.B. MacQueen, and G. Plotkin, editors, </editor> <booktitle> Semantics of Data Types, </booktitle> <pages> pages 301-315. </pages> <publisher> Springer-Verlag LNCS 173, </publisher> <year> 1984. </year>
Reference-contexts: This problem has been called type inference, full type inference, and type reconstruction, and has resisted complete analysis, despite intensive efforts and some partial answers (see, for example, <ref> [14, 12, 4] </ref>). We refer to (a variation of) Boehm's problem as partial type reconstruction and the other problem as full type reconstruction. <p> Another notion of partial inference has been considered by McCracken <ref> [14] </ref>. 3 Definition 3 (Partial Erasure) Let the judgment P M (read: P is a partial erasure of M ) be defined by the following inference rules. x x x:t: P x:t: M x: P x:t: M P 1 P 2 M 1 M 2 flff: P flff: M P M
Reference: [15] <author> Dale Miller. </author> <title> Unification under a mixed prefix. </title> <journal> Journal of Symbolic Computation, </journal> <note> 199? To appear. </note>
Reference-contexts: In order to simplify the reduction we define a variant of second-order unification which can easily be seen as a generalization of the standard formulation. A related formulation in terms of mixed prefixes is given by Miller <ref> [15] </ref>. The basic notion of the unification logic is that of a formula, and unifiability is replaced by provability of a formula, as defined below. The basic formulas are equations between types, including variables ranging over functions between types. <p> The reduction of this problem to the provability problem in the unification logic above is straightforward following the notes above and Miller <ref> [15] </ref>. "!" plays the role of the required binary function constant; is not required in order to attain undecidability. We also need a notion of type substitution in order to carry out the proofs in Section 3.
Reference: [16] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <month> August </month> <year> 1978. </year>
Reference-contexts: 1 Introduction The polymorphic -calculus, discovered independently by Girard [6] and Reynolds [21], has served as the basis for many investigations into the nature of polymorphism in programming languages. While it was known that the simply-typed -calculus admits principal type schemes and its type inference problem is decidable <ref> [10, 16] </ref>, an analysis of type inference for the polymorphic -calculus has proved more difficult. There appear to be at least two different notions of type inference, both of which are decidable over the simply-typed fragment.
Reference: [17] <author> John C. Mitchell. </author> <title> Second-order unification and types. </title> <booktitle> Unpublished notes, </booktitle> <month> June </month> <year> 1984. </year>
Reference-contexts: If such an M exists, we call P valid in and write . P . We show in Theorem 23 that partial type reconstruction is undecidable. A similar, but technically weaker result was first reported by H.-J. Boehm [1] and anticipated by Mitchell <ref> [17] </ref>. Boehm's proof requires a fixpoint operator and an uninterpreted type constant in the language. In view of the undecidability result, restrictions on partially typed terms have been proposed which lead to a decidable type reconstruction problem (see [2, 11]).
Reference: [18] <author> John C. Mitchell and Robert Harper. </author> <title> The essence of ML. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 28-46. </pages> <publisher> ACM SIGPLAN/SIGACT, </publisher> <year> 1988. </year>
Reference-contexts: This can be seen by carefully examining the proofs showing the undecidability of partial type reconstruction in the polymorphic -calculus given in Section 5. 3 This means that partial type reconstruction for ML (see <ref> [18, 9] </ref>) is also undecidable. The polymorphic -calculus is impredicative in that the domain of quantification (by ) includes all possible types.
Reference: [19] <author> Frank Pfenning. </author> <title> Partial polymorphic type inference and higher-order unification. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, Snowbird, Utah, </booktitle> <pages> pages 153-163. </pages> <publisher> ACM Press, </publisher> <month> July </month> <year> 1988. </year>
Reference-contexts: This problem has been called partial type inference by H.-J. Boehm, who showed that, with certain minor additional assumptions, it is undecidable [1]. This result has been sharpened by the author in <ref> [19] </ref>, where it is also argued that the problem can be solved effectively using higher-order unification. <p> We believe that partial type reconstruction is the practically more useful problem, and a number of implementations have been based on decidable subcases (see, for example, [2, 20, 11]). Further discussion can be found in <ref> [19] </ref>. In this paper we prove that partial type reconstruction for the pure polymorphic -calculus is undecidable. This proof is a slightly modified version of the one sketched in [19]. <p> Further discussion can be found in <ref> [19] </ref>. In this paper we prove that partial type reconstruction for the pure polymorphic -calculus is undecidable. This proof is a slightly modified version of the one sketched in [19]. Analysis of this proof reveals that the result can be sharpened further in two directions: (1) the problem remains undecidable even if we allow only type variables to occur in a partially typed term, and (2) the problem remains undecidable even in a very simple predicative fragment. <p> Our own view is to allow the full range of partially typed terms and use a variant of second-order unification to perform type reconstruction as suggested in <ref> [19] </ref>. More difficult to analyze than partial type reconstruction has been the problem of full type reconstruction. In our framework, this problem can be characterized if we introduce untyped terms. Untyped Terms U ::= x j x: U j U 1 U 2 The erasure relation now becomes simpler. <p> Further discussion on this issue can be found in <ref> [19] </ref>. In particular, we indicate how it could be considered a natural generalization of type inference in the Damas-Milner calculus [3] which is the basis for type inference in the programming language ML.
Reference: [20] <author> Frank Pfenning and Peter Lee. </author> <title> LEAP: A language with eval and polymorphism. </title> <booktitle> In TAPSOFT '89, Proceedings of the International Joint Conference on Theory and Practice in Software Development, Barcelona, Spain, </booktitle> <pages> pages 345-359. </pages> <publisher> Springer-Verlag LNCS 352, </publisher> <month> March </month> <year> 1989. </year>
Reference-contexts: We refer to (a variation of) Boehm's problem as partial type reconstruction and the other problem as full type reconstruction. We believe that partial type reconstruction is the practically more useful problem, and a number of implementations have been based on decidable subcases (see, for example, <ref> [2, 20, 11] </ref>). Further discussion can be found in [19]. In this paper we prove that partial type reconstruction for the pure polymorphic -calculus is undecidable. This proof is a slightly modified version of the one sketched in [19].
Reference: [21] <author> John Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Proc. Colloque sur la Programmation, </booktitle> <pages> pages 408-425. </pages> <publisher> Springer-Verlag LNCS 19, </publisher> <year> 1974. </year> <month> 15 </month>
Reference-contexts: 1 Introduction The polymorphic -calculus, discovered independently by Girard [6] and Reynolds <ref> [21] </ref>, has served as the basis for many investigations into the nature of polymorphism in programming languages. <p> In Section 6 we show how this result extends to a predicative fragment which is contained in ML [9]. 2 The Polymorphic -Calculus Variations of second-order polymorphic -calculus go back to Girard's system F [5, 6, 7] and Reynolds <ref> [21] </ref>. Here we treat the pure, type-theoretic core of the language, without recursion or existential types, for example. The undecidability result for this fragment also applies to conservative extensions of this language, that is, extensions which do not affect typability of the pure fragment presented here.
References-found: 21

