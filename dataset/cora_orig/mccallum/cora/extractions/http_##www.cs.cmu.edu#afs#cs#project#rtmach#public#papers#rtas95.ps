URL: http://www.cs.cmu.edu/afs/cs/project/rtmach/public/papers/rtas95.ps
Refering-URL: http://www.cs.umd.edu/~rich/courses/cmsc818G-s98/schedule.html
Root-URL: 
Email: cwm@cs.cmu.edu, rr@sei.cmu.edu  
Title: An Interactive Interface and RT-Mach Support for Monitoring and Controlling Resource Management  
Author: Clifford W. Mercer and Ragunathan Rajkumar 
Address: Pittsburgh PA 15213  
Affiliation: School of Computer Science Software Engineering Institute Carnegie Mellon University  
Abstract: Real-time applications in dynamic systems such as multimedia systems may change their timing characteristics on the y and may be created and terminated at any time. A priori resource allocation decisions may not hold throughout the lifetime of such applications because of changing user needs and interests. The ability to monitor and control system resources dynamically is fundamental to building exi-ble and dynamic multimedia systems. In this paper, we describe the mechanisms and tools we have built for monitoring and controlling operating system resource reserves in Real-Time Mach. The system supports a resource reservation abstraction called processor capacity reserves, and an interactive tool named rmon uses these mechanisms to display the processor usage for each reserved activity in the system and to allow the user to change the processor reservation dynamically; it can also coordinate the reservation change requests with a separate quality of service manager which makes policy decisions regarding which requests are granted. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> Apple Computer, Inc. </institution> <note> Macintosh Users Guide, </note> <year> 1991. </year>
Reference-contexts: For example, Apples MacOS on the Macintosh offers rudimentary Memory View and Memory Sizer commands which display the current memory allocation to resident tasks and also provide a way to set memory limits for specific applications <ref> [1] </ref>. In addition, MacOS has a few other resource management features for sizing the disk cache and enabling virtual memory. However, it offers no information about or control over other resources such as processor time, network bandwidth, or disk bandwidth. <p> Tools like xload [8] provide a very simple view of the cumulative processor load on a workstation. It does this on-line, but it lacks any element of control. Other tools like the Memory Sizer on the Macintosh <ref> [1] </ref> offer control over a system resource, but the resource information is very simple, and one cannot set the memory size of a program while it is running.
Reference: [2] <author> Digital Equipment Corporation. </author> <title> VAX Performance and Coverage Analyzer Users Reference Manual. </title>
Reference-contexts: At another end of the performance monitoring spectrum, many sophisticated tools are available for design-time program and system performance analysis, primarily used to identify and rectify application performance bottlenecks. For example, tools like gprof [3] and the Performance and Coverage Analyzer (PCA) for VAX/VMS <ref> [2] </ref> provide support for some very detailed performance analyses. They enable a programmer to learn a lot about where application time is being spent and how various system resources are being divided among active processes. <p> It is another example of an off-line analysis tool that can aid the design process but cannot provide on-line control over a running system. Performance analysis tools such as gprof [3] and PCA <ref> [2] </ref> use PC sampling techniques to characterize program runtime behavior and object code to determine the static structure. These tools do not exercise control over program behavior directly. 7.
Reference: [3] <author> S. L. Graham, P. B. Kessler, and M. K. McKusick. </author> <title> gprof: a Call Graph Execution Profiler. </title> <booktitle> In Proceedings of the SIGPLAN 82 Symposium on Compiler Construction, </booktitle> <pages> pages 120126, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: For example, the memory allocation to a program cannot be changed while it is running. At another end of the performance monitoring spectrum, many sophisticated tools are available for design-time program and system performance analysis, primarily used to identify and rectify application performance bottlenecks. For example, tools like gprof <ref> [3] </ref> and the Performance and Coverage Analyzer (PCA) for VAX/VMS [2] provide support for some very detailed performance analyses. They enable a programmer to learn a lot about where application time is being spent and how various system resources are being divided among active processes. <p> It is another example of an off-line analysis tool that can aid the design process but cannot provide on-line control over a running system. Performance analysis tools such as gprof <ref> [3] </ref> and PCA [2] use PC sampling techniques to characterize program runtime behavior and object code to determine the static structure. These tools do not exercise control over program behavior directly. 7.
Reference: [4] <author> J. P. Lehoczky, L. Sha, and Y. Ding. </author> <title> The Rate Monotonic Scheduling Algorithm: Exact Characterization and Average Case Behavior. </title> <booktitle> In Proceedings of the 10th IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 166171, </pages> <month> December </month> <year> 1989. </year>
Reference: [5] <author> C. L. Liu and J. W. Layland. </author> <title> Scheduling Algorithms for Multiprogramming in a Hard Real Time Environment. </title> <journal> JACM, </journal> <volume> 20(1):4661, </volume> <year> 1973. </year>
Reference-contexts: Critical zone analysis and/or a utilization bound is currently used for admitting processor reserves [4,5]. 3.3. Scheduling Algorithm The scheduling algorithm must ensure that the resource capacity that has been reserved is available to threads associated with that reserve. We currently use the rate monotonic scheduling algorithm <ref> [5] </ref> as a basis for our scheduler. The scheduler also plays a part in the enforcement of reservations and must determine when the thread or threads associated with a reserve have depleted the reserved capacity for a particular reservation period (not unlike aperiodic server algorithms [11]). 3.4.
Reference: [6] <author> C. W. Mercer and R. Rajkumar. </author> <title> Performance of an Interactive Interface for Monitoring and Controlling Resource Management in RT-Mach. </title> <type> Technical report, </type> <institution> ART Project, Carnegie Mellon University, </institution> <month> April </month> <year> 1995. </year>
Reference-contexts: System overhead is certainly involved with these added support features, but our measurements indicate that these overheads are acceptable <ref> [6] </ref>. Acknowledgements The authors would like to express their appreciation to Jim Zelenka for his contributions to RT-Mach, and to Brian Hixon, Manish Modh and Bill Nagy for their work on the ProactiveQOS server.
Reference: [7] <author> C. W. Mercer, S. Savage, and H. Tokuda. </author> <title> Processor Capacity Reserves: Operating System Support for Multimedia Applications. </title> <booktitle> In Proceedings of the IEEE International Conference on Multimedia Computing and Systems (ICMCS), </booktitle> <pages> pages 9099, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: In this section, we discuss the resource reservation approach we are experimenting with in Real-Time Mach which provides the basis for the monitoring and control tools we have built. The presentation of this background material is brief, and a more detailed exposition can be found elsewhere <ref> [7] </ref>. We have designed a resource capacity reservation system for RT-Mach which (a) allows applications to request and reserve resource capacity, (b) enforces resource reservations, and (c) provides moderately detailed information about resource usage.
Reference: [8] <institution> MIT. xload man page, </institution> <year> 1988. </year> <title> X11 Window System, </title> <type> Release 4, </type> <institution> Massachusetts Institute of Technology. </institution>
Reference-contexts: As shown in the figure, the recent history graphic occupies the top portion of the window. It shows the normalized usage of the reserve over the last several reservation periods, and it advances in real-time in a manner similar to that of xload <ref> [8] </ref>. For the reserved activity, Reserve_A, this usage is fairly constant over time. For the unreserved activity, Reserve_C, this usage varies from period to period. Each window also displays the reserved computation time and the reservation period. <p> Related Work Very few tools support on-line control of resource capacity allocation, much less dynamic on-line control as tasks using the resource are running. Tools like xload <ref> [8] </ref> provide a very simple view of the cumulative processor load on a workstation. It does this on-line, but it lacks any element of control.
Reference: [9] <author> K. Patel, B. C. Smith, and L. A. Rowe. </author> <title> Performance of a Software MPEG Video Decoder. </title> <booktitle> In Proceedings of the First ACM International Conference on Multimedia, </booktitle> <pages> pages 7582, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: The timing constraints of these programs make them particularly sensitive to the performance characteristics of the hardware and software computing environment on which they are executing. For example, in multimedia systems, the bit rates achieved for an MPEG video decoder vary with processor speed <ref> [9] </ref>. Likewise, the bit rates achievable for a decoder running in isolation are greater than for a decoder running concurrently with some other computation.
Reference: [10] <author> L. Sha, R. Rajkumar, and J. P. Lehoczky. </author> <title> Priority Inheritance Protocols: An Approach to Real-Time Synchronization. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39(9):11751185, </volume> <month> September </month> <year> 1990. </year>
Reference-contexts: A processor reservation might therefore be for 30 ms 1. The definition of reserve propagation given here may sound analogous to priority inheritance <ref> [10] </ref>. While the two notions are indeed similar, they are not strictly analogous. In priority inheritance, a server or a blocking task inherits the priority of the highest priority task that it blocks.
Reference: [11] <author> B. Sprunt, L. Sha, and J. P. Lehoczky. </author> <title> Aperiodic Task Scheduling for Hard Real-Time Systems. The Journal of Real-Time Systems, </title> <address> 1(1):2760, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: The scheduler also plays a part in the enforcement of reservations and must determine when the thread or threads associated with a reserve have depleted the reserved capacity for a particular reservation period (not unlike aperiodic server algorithms <ref> [11] </ref>). 3.4. Usage Measurement and Enforcement In order to inform the scheduler about whether the reserved capacity of a reserve has been depleted for a particular reservation period or not, the system must accurately measure resource usage on-line as it is being consumed.
Reference: [12] <author> H. Tokuda and M. Kotera. </author> <title> A Real-Time Tool Set for the ARTS Kernel. </title> <booktitle> In Proceedings of the 9th IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1988. </year>
Reference-contexts: Monitoring tools typically separate the functions of capturing performance data, analyzing the data, and having an effect on the system that was measured. The Advanced Real-Time Monitor (ARM) and Scheduler1-2-3 <ref> [12] </ref>, originally designed for the ARTS Kernel [13] and more recently updated for RT-Mach, take this approach. ARM displays a scheduling history based on events captured by the kernel, but again the element of control of the monitored process is missing.
Reference: [13] <author> H. Tokuda and C. W. Mercer. </author> <title> ARTS: A Distributed Real-Time Kernel. </title> <journal> ACM Operating Systems Review, </journal> <volume> 23(3):2953, </volume> <month> July </month> <year> 1989. </year>
Reference-contexts: Monitoring tools typically separate the functions of capturing performance data, analyzing the data, and having an effect on the system that was measured. The Advanced Real-Time Monitor (ARM) and Scheduler1-2-3 [12], originally designed for the ARTS Kernel <ref> [13] </ref> and more recently updated for RT-Mach, take this approach. ARM displays a scheduling history based on events captured by the kernel, but again the element of control of the monitored process is missing.
Reference: [14] <author> H. Tokuda, T. Nakajima, and P. Rao. </author> <title> Real-Time Mach: Toward a Predictable Real-Time System. </title> <booktitle> In Proceedings of USENIX Mach Workshop, </booktitle> <pages> pages 73 82, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: Mechanisms and tools for monitoring performance and controlling resource management can satisfy changing requirements as warranted by the programs behavior and the changing focus of the user. This paper describes the RT-Mach <ref> [14] </ref> framework to dynamically monitor and control resource usage and how it can be used. Section 2 provides some background on currently available tools for performance measurement and control, and Section 3 briey describes the support for resource monitoring and control that is currently supported in RT-Mach.
References-found: 14

