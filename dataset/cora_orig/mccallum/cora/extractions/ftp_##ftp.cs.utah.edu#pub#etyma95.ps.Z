URL: ftp://ftp.cs.utah.edu/pub/etyma95.ps.Z
Refering-URL: http://www.cs.utah.edu/~gary/home.html
Root-URL: 
Email: banavar@watson.ibm.com  lindstrom@cs.utah.edu  
Phone: Phone: +1-914-784-7755, fax: +1-914-784-7455.  
Title: An Application Framework for Module Composition Tools  
Author: Guruduth Banavar Gary Lindstrom 
Keyword: inheritance, modularity, module manipulation tools.  
Note: Primary contact.  
Address: 30 Saw Mill River Road Hawthorne, NY 10532 USA  Salt Lake City, UT 84112 USA  
Affiliation: IBM TJ Watson Research Center  Department of Computer Science University of Utah  
Abstract: This paper shows that class inheritance viewed as composition of recursive namespaces is a broadly applicable concept. We show that several kinds of software artifacts can be modeled as recursive namespaces, and software tools based on a model of composition of namespaces can effectively manage these artifacts. We describe four such tools: an interpreter for compositionally modular Scheme, a compositional linker for object files, a compositional interface definition language, and a compositional document processing tool. We show that these tools benefit significantly from incorporating inheritance-based reuse. The implementation of tools such as the above share much in common since they are based on the same underlying model. We describe a reusable OO framework for efficiently constructing such tools. Three of the above tools were built by directly reusing the application framework, and the fourth evolved in parallel with it. We provide reuse statistics and experiences with the development of our framework and its completions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Roberto M. Amadio and Luca Cardelli. </author> <title> Subtyping recursive types. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(4), </volume> <month> September </month> <year> 1993. </year> <month> 21 </month>
Reference-contexts: There is indeed a wide range of software artifacts that can be modeled as recursive namespaces. For instance, it is well known that recursive interface types can be viewed as self-referential namespaces <ref> [8, 1] </ref>. A traditional compiled object file can also be viewed as a self-referential namespace. Furthermore, structured document fragments can be modeled as self-referential namespaces. Even other artifacts, such as GUI components and file system directories can be regarded as recursive namespaces. <p> Furthermore, the notion of the recursive type selftype is implemented as the special framework class SelfType (a singleton pattern). Recursive type equality and subtyping methods of StdInterface, which implement the algorithms given in <ref> [1] </ref> can be reused directly in the IDLInterface class. Design and code reuse numbers for this completion prototype are given in Table 2. 4.2.3 An Interpreter for MT E X The STk-derived interpreter was used for MT E Xin a manner similar to CMS.
Reference: [2] <author> Joshua Auerbach and James Russell. </author> <title> The Concert signature representation: IDL as intermediate lan-guage. In Jeanette Wing, editor, </title> <booktitle> Proc. of Workshop on Interface Definition Languages, </booktitle> <pages> pages 1 - 12, </pages> <month> January </month> <year> 1994. </year> <note> Available as August 1994 issue of ACM SIGPLAN Notices. </note>
Reference-contexts: Thus, an interface can be modeled as a recursive namespace. Explicit specification and composition of interfaces, as embodied in interface definition languages 10 (IDLs), is becoming widespread in modern distributed systems <ref> [19, 2, 16] </ref>. It is useful to specify an interface by reusing, i.e., inheriting from, existing interfaces. Reuse facilitates the evolution of interfaces [15] by ensuring that inheriting interfaces evolve in step with the inherited interfaces. It also simplifies maintenance by reducing redundant code.
Reference: [3] <author> Guruduth Banavar. </author> <title> An Application Framework for Compositional Modularity. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <address> Salt Lake City, Utah, </address> <year> 1995. </year>
Reference-contexts: One characterization of class-based inheritance is that it is the combination of self-referential namespaces [11]. By carefully designing operations to manipulate such namespaces, a wide spectrum of effects of single and multiple inheritance can be obtained. Compositional modularity <ref> [3, 6] </ref> is such an inheritance model, in which self-referential namespaces, known as modules, can be adapted and composed in various ways to achieve implementation reuse. Compositional modularity supports a stronger and more flexible reuse model than traditional class-based inheritance. <p> can be copied under another name in order to achieve access to overridden methods, as follows (k r stands for record merging [9]): copy-as a b = g: s: let super = g (s) in super k r fb = super: r ag We further augment the above model in <ref> [3] </ref> to include a notion of hierarchical nesting as a composition operation, feeling that module nestability and separate development must co-exist in a modularity framework without compromising each other. <p> The above concept of closed generators, along with eight primary operations on them, merge, override, rename, copy-as, restrict, freeze, hide, and nest, within an imperative store-based framework with appropriate static typing rules, comprise the model of compositional modularity (or CM for short) <ref> [3] </ref>. The term composition is used here to mean implementation composition to achieve reuse akin to inheritance. The goal of CM is to get maximal reuse out of small, composable components. The composition constructs given above provide a powerful framework for building larger modules from smaller ones. <p> Composite Inheritance. With the above suite of primitives, several composite inheritance idioms including super-based and prefix-based single inheritance, as well as mixin-based and general forms of multiple inheritance with various types of conflict resolution and sharing strategies can be emulated; please see <ref> [3] </ref> for a detailed description. To give some insight, Figure 4 pictorially shows how super-based and prefix-based single inheritance can be emulated using CM primitives. Figure 4 (a) shows a "superclass" SUPER with a method METH and self-references to it.
Reference: [4] <author> Guruduth Banavar, Gary Lindstrom, and Douglas Orr. </author> <title> Type-safe composition of object modules. </title> <booktitle> In Computer Systems and Education, </booktitle> <pages> pages 188-200. </pages> <publisher> Tata McGraw Hill Publishing Company, Limited, </publisher> <address> New Delhi, India, </address> <month> June 22-25, </month> <year> 1994. </year> <note> ISBN 0-07-462044-4. Also available as Technical Report UUCS-94-001. </note>
Reference-contexts: The next incarnation of Etyma was used to build a typechecking mechanism for C language object modules, described in <ref> [4] </ref>. This experiment solidified many of the type classes of Etyma. However, at this point, Etyma was still primarily a set of concrete classes. The third incarnation was used to direct the reengineering of the programmable linker/loader OMOS described earlier.
Reference: [5] <author> Guruduth Banavar, Douglas Orr, and Gary Lindstrom. </author> <title> Layered, server-based support for object-oriented application development. </title> <editor> In Luis-Felipe Cabrera and Marvin Theimer, editors, </editor> <booktitle> Proceedings of the Fourth International Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 2-11, </pages> <institution> Lund, Sweden, </institution> <month> August 14 - 15 </month> <year> 1995. </year> <journal> IEEE Computer Society. </journal> <note> Also available as TR UUCS-95-007. </note>
Reference-contexts: In particular, facilities such as function interposition, management of incremental additions of functionality to compiled libraries, and namespace management can be made more principled and flexible, as shown below. Consequently, there is much to gain from incorporating CM into a programmable linking tool. A programmable linker. OMOS <ref> [20, 5] </ref> is a programmable linker that supports CM for C language object files. OMOS is programmed using a Scheme based scripting language similar to CMS above, except that the modules manipulated in this language are compiled object files (dot-o files) as opposed to Scheme modules. <p> The idioms given above are in fact the basis of inheritance in OO programming. Scheme macros that perform various kinds of single and multiple inheritance can be used within OMOS just as in CMS. In <ref> [5] </ref>, we describe an architecture for OO application development via programmed linkage using OMOS.
Reference: [6] <author> Gilad Bracha and Gary Lindstrom. </author> <title> Modularity meets inheritance. </title> <booktitle> In Proc. International Conference on Computer Languages, </booktitle> <pages> pages 282-290, </pages> <address> San Francisco, CA, </address> <month> April 20-23, </month> <year> 1992. </year> <journal> IEEE Computer Society. </journal> <note> Also available as Technical Report UUCS-91-017. </note>
Reference-contexts: One characterization of class-based inheritance is that it is the combination of self-referential namespaces [11]. By carefully designing operations to manipulate such namespaces, a wide spectrum of effects of single and multiple inheritance can be obtained. Compositional modularity <ref> [3, 6] </ref> is such an inheritance model, in which self-referential namespaces, known as modules, can be adapted and composed in various ways to achieve implementation reuse. Compositional modularity supports a stronger and more flexible reuse model than traditional class-based inheritance. <p> Based on Cook's work, Bracha and Lindstrom <ref> [6] </ref> developed a uniform and comprehensive suite of linguistic operations on modules, modeled as generators, that individually achieved effects of 2 rebinding, sharing, encapsulation, and static binding. In addition to making previously existing operators explicit linguistic constructs, they define three new operators: hide, freeze, and copy-as.
Reference: [7] <author> Kim B. Bruce. </author> <title> A paradigmatic object-oriented programming language: Design static typing and semantics. </title> <type> Technical Report CS-92-01, </type> <institution> Williams College, </institution> <month> January 31, </month> <year> 1992. </year>
Reference-contexts: However, ColorPointType shares the same structure as FloatPointType, hence it is known as an inherited type of FloatPointType <ref> [8, 7] </ref>. 11 An important point to note here is that the merge operation on interfaces generates types that correspond to the types of inherited module implementations generated via both the merge and override operations.
Reference: [8] <author> P. Canning, W. Cook, W. Hill, and W. Olthoff. </author> <title> Interfaces for strongly-typed object-oriented programming. </title> <editor> In Norman Meyrowitz, editor, </editor> <booktitle> Proceedings of the ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications, </booktitle> <pages> pages 457-467, </pages> <year> 1989. </year>
Reference-contexts: There is indeed a wide range of software artifacts that can be modeled as recursive namespaces. For instance, it is well known that recursive interface types can be viewed as self-referential namespaces <ref> [8, 1] </ref>. A traditional compiled object file can also be viewed as a self-referential namespace. Furthermore, structured document fragments can be modeled as self-referential namespaces. Even other artifacts, such as GUI components and file system directories can be regarded as recursive namespaces. <p> An interface is essentially a naming scope, with labels bound to types. In the case of recursive types, type constituents of the interface can recursively refer back to the interface itself <ref> [8, 9] </ref>. Thus, an interface can be modeled as a recursive namespace. Explicit specification and composition of interfaces, as embodied in interface definition languages 10 (IDLs), is becoming widespread in modern distributed systems [19, 2, 16]. It is useful to specify an interface by reusing, i.e., inheriting from, existing interfaces. <p> However, ColorPointType shares the same structure as FloatPointType, hence it is known as an inherited type of FloatPointType <ref> [8, 7] </ref>. 11 An important point to note here is that the merge operation on interfaces generates types that correspond to the types of inherited module implementations generated via both the merge and override operations.
Reference: [9] <author> Luca Cardelli and John C. Mitchell. </author> <title> Operations on records. </title> <type> Technical Report 48, </type> <institution> Digital Equipment Corporation Systems Research Center, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: In Section 3, we describe the four compositional tools mentioned above. We then describe the design of the Etyma framework and its completions in Section 4. 2 Background and Related Work Based on the notion of records and operations on them <ref> [9] </ref>, Cook and Palsberg [11] modeled a class as a self-referential record generating function, e.g., g = s: fa 1 = v 1 ; a 2 = v 2 ; : : :; a n = v n g, also known as a generator. <p> Taking the fixpoint of the generator binds the generator's self-references s:a x . The notion of inheritance is modeled as combination of generators, via operators such as merge and override. For instance, the notion of method overriding in generators is defined in terms of record overriding ( r <ref> [9] </ref>): override = g 1 : g 2 : s: g 1 (s) r g 2 (s) The crucial aspect of inheritance is that of self-reference manipulation; while combining classes during inheritance, a superclass' notion of self must be properly modified to include that of the subclass. <p> In addition to making previously existing operators explicit linguistic constructs, they define three new operators: hide, freeze, and copy-as. As an example, an attribute of a generator can be copied under another name in order to achieve access to overridden methods, as follows (k r stands for record merging <ref> [9] </ref>): copy-as a b = g: s: let super = g (s) in super k r fb = super: r ag We further augment the above model in [3] to include a notion of hierarchical nesting as a composition operation, feeling that module nestability and separate development must co-exist in a <p> An interface is essentially a naming scope, with labels bound to types. In the case of recursive types, type constituents of the interface can recursively refer back to the interface itself <ref> [8, 9] </ref>. Thus, an interface can be modeled as a recursive namespace. Explicit specification and composition of interfaces, as embodied in interface definition languages 10 (IDLs), is becoming widespread in modern distributed systems [19, 2, 16]. It is useful to specify an interface by reusing, i.e., inheriting from, existing interfaces.
Reference: [10] <author> William Cook, Walter Hill, and Peter Canning. </author> <title> Inheritance is not subtyping. </title> <editor> In Carl Gunter and John Mitchell, editors, </editor> <booktitle> Theoretical Aspects of Object-Oriented Programming, </booktitle> <pages> pages 497 - 517. </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Most importantly, an IDL should be able to express the types of components generated via implementation inheritance in module implementation languages. In fact, it has been shown that inheritance of interfaces generates exactly those types, known as inherited types, that correspond to the types of inherited objects <ref> [10] </ref>. These reasons point to a need for flexible interface inheritance (or composition) mechanisms in IDLs. A compositional IDL. We have developed a compositional IDL (CIDL) to demonstrate the concepts of compositionality of interfaces. The base type domain of the language consists of primitive types, function types, and record types.
Reference: [11] <author> William Cook and Jen Palsberg. </author> <title> A denotational semantics of inheritance and its correctness. </title> <booktitle> In Proc. ACM Conf. on Object-Oriented Programming: Systems, Languages and Applications, </booktitle> <pages> pages 433-444, </pages> <year> 1989. </year>
Reference-contexts: Inheritance is widely acknowledged to support reuse via incremental programming | one needs to only program how new classes differ from already existing ones. One characterization of class-based inheritance is that it is the combination of self-referential namespaces <ref> [11] </ref>. By carefully designing operations to manipulate such namespaces, a wide spectrum of effects of single and multiple inheritance can be obtained. Compositional modularity [3, 6] is such an inheritance model, in which self-referential namespaces, known as modules, can be adapted and composed in various ways to achieve implementation reuse. <p> In Section 3, we describe the four compositional tools mentioned above. We then describe the design of the Etyma framework and its completions in Section 4. 2 Background and Related Work Based on the notion of records and operations on them [9], Cook and Palsberg <ref> [11] </ref> modeled a class as a self-referential record generating function, e.g., g = s: fa 1 = v 1 ; a 2 = v 2 ; : : :; a n = v n g, also known as a generator.
Reference: [12] <author> Pavel Curtis and James Rauen. </author> <title> A module system for Scheme. </title> <booktitle> In Conference Record of the ACM Lisp and Functional Programming. ACM, </booktitle> <year> 1990. </year>
Reference-contexts: The actual importation can be effected via module combination, described below.) In this manner, a Scheme module may be modeled as a self-referential namespace. Several module systems for Scheme have been proposed previously <ref> [12, 23, 21] </ref>, but these systems mainly provide a facility for structuring programs via decomposition. However, the ability to recompose first-class modules can additionally support design and implementation reuse akin to inheritance in OO programming.
Reference: [13] <author> Erick Gallesio. </author> <note> STk reference manual. Version 2.1, 1993/94. </note>
Reference-contexts: The basic Scheme interpreter itself was derived from a publicly available scriptable windowing toolkit called STk <ref> [13] </ref>. The interpreter implementation exports many of the functions implementing Scheme semantics, thus making it easy to access its internals.
Reference: [14] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. Professional Computing Series. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <year> 1995. </year>
Reference-contexts: Only, the important classes in both layers, i.e., those corresponding to modules, instances, and methods, are described in more detail below. (For brevity, we omit classes corresponding to the type system.) We utilize the notion of design patterns <ref> [14] </ref> to elucidate the structure of the Etyma framework. Abstract classes. Figure 7 shows an overview of the abstract classes of Etyma diagrammed using the OO notation in [14]. <p> described in more detail below. (For brevity, we omit classes corresponding to the type system.) We utilize the notion of design patterns <ref> [14] </ref> to elucidate the structure of the Etyma framework. Abstract classes. Figure 7 shows an overview of the abstract classes of Etyma diagrammed using the OO notation in [14]. Class Etymon is the abstract base class of all classes in Etyma, and classes TypedValue and Type represent the domains of values and their types respectively. The abstract class Module captures the notion of a compositional module in its broadest con 15 ception.
Reference: [15] <author> Graham Hamilton and Sanjan Radia. </author> <title> Using interface inheritance to address problems in system software evolution. In Jeanette Wing, editor, </title> <booktitle> Proc. of Workshop on Interface Definition Languages, </booktitle> <pages> pages 119 - 128, </pages> <month> January </month> <year> 1994. </year> <note> Available as August 1994 issue of ACM SIGPLAN Notices. </note>
Reference-contexts: Explicit specification and composition of interfaces, as embodied in interface definition languages 10 (IDLs), is becoming widespread in modern distributed systems [19, 2, 16]. It is useful to specify an interface by reusing, i.e., inheriting from, existing interfaces. Reuse facilitates the evolution of interfaces <ref> [15] </ref> by ensuring that inheriting interfaces evolve in step with the inherited interfaces. It also simplifies maintenance by reducing redundant code. Most importantly, an IDL should be able to express the types of components generated via implementation inheritance in module implementation languages.
Reference: [16] <author> Dinesh Katiyar, David Luckham, and John Mitchell. </author> <title> A type system for prototyping languages. </title> <booktitle> In Proc. of the ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 138-150, </pages> <address> Portland, OR, </address> <month> January </month> <year> 1994. </year> <note> ACM. </note>
Reference-contexts: Thus, an interface can be modeled as a recursive namespace. Explicit specification and composition of interfaces, as embodied in interface definition languages 10 (IDLs), is becoming widespread in modern distributed systems <ref> [19, 2, 16] </ref>. It is useful to specify an interface by reusing, i.e., inheriting from, existing interfaces. Reuse facilitates the evolution of interfaces [15] by ensuring that inheriting interfaces evolve in step with the inherited interfaces. It also simplifies maintenance by reducing redundant code.
Reference: [17] <author> Bent Bruun Kristensen, Ole Lehrmann Madsen, Birger Moller-Pedersen, and Kristen Nygaard. </author> <title> The BETA programming language. </title> <booktitle> In Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 7 - 48. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: SUPER and DELTA can be combined to form the "subclass" SUB by using the sequence of operators (copy-override-hide) shown in the figure caption. Similarly, the BETA-style <ref> [17] </ref> prefixes SUPER and DELTA in Figure 4 (b) can be combined using a similar sequence of operations. The difference is that (an adapted version of) the superclass overrides the increment in the case of prefix-based inheritance, as opposed to the reverse for super-based inheritance.
Reference: [18] <author> Leslie Lamport. </author> <title> L a T E X, a Document Processing System. </title> <publisher> Addison Wesley Publishing Company, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: MT E X is a programmable facility that helps a document preparer to adapt and compose documents effectively. It is built on top of a restricted version of the L a T E X document preparation system <ref> [18] </ref>. An MT E X program is a script based on Scheme (as in CMS) that describes how L a T E X document modules should be constructed and composed.
Reference: [19] <author> Object Management Group. </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <booktitle> De--cember 1991. Revision 1.1. </booktitle>
Reference-contexts: Thus, an interface can be modeled as a recursive namespace. Explicit specification and composition of interfaces, as embodied in interface definition languages 10 (IDLs), is becoming widespread in modern distributed systems <ref> [19, 2, 16] </ref>. It is useful to specify an interface by reusing, i.e., inheriting from, existing interfaces. Reuse facilitates the evolution of interfaces [15] by ensuring that inheriting interfaces evolve in step with the inherited interfaces. It also simplifies maintenance by reducing redundant code.
Reference: [20] <author> Douglas B. Orr and Robert W. Mecklenburg. </author> <title> OMOS | An object server for program execution. </title> <booktitle> In Proc. International Workshop on Object Oriented Operating Systems, </booktitle> <pages> pages 200-209, </pages> <address> Paris, </address> <month> September </month> <year> 1992. </year> <journal> IEEE Computer Society. </journal> <note> Also available as technical report UUCS-92-033. </note>
Reference-contexts: In particular, facilities such as function interposition, management of incremental additions of functionality to compiled libraries, and namespace management can be made more principled and flexible, as shown below. Consequently, there is much to gain from incorporating CM into a programmable linking tool. A programmable linker. OMOS <ref> [20, 5] </ref> is a programmable linker that supports CM for C language object files. OMOS is programmed using a Scheme based scripting language similar to CMS above, except that the modules manipulated in this language are compiled object files (dot-o files) as opposed to Scheme modules.
Reference: [21] <author> Jonathan Rees. </author> <title> Another module system for Scheme. Included in the Scheme 48 distribution, </title> <year> 1993. </year>
Reference-contexts: The actual importation can be effected via module combination, described below.) In this manner, a Scheme module may be modeled as a self-referential namespace. Several module systems for Scheme have been proposed previously <ref> [12, 23, 21] </ref>, but these systems mainly provide a facility for structuring programs via decomposition. However, the ability to recompose first-class modules can additionally support design and implementation reuse akin to inheritance in OO programming.
Reference: [22] <author> Wayne Rossberg, Edward Smith, and Angelica Matinkhah. </author> <title> Structured text system. </title> <type> US Patent Number 5,341,469, </type> <month> August </month> <year> 1994. </year>
Reference-contexts: For example, a report, such as a user manual, can be composed from several document fragments, such as design documents. A specific scenario of modular document processing that motivated this application of CM was document generation and consumption in the activity of building construction such as that described in <ref> [22] </ref>. Building architects routinely extract and 12 maintain large bases of document fragments that they reuse, edit, and compose into architectural specifications for delivery to particular clients.
Reference: [23] <author> Sho-Huan Simon Tung. </author> <title> Interactive modular programming in Scheme. </title> <booktitle> In Proceedings of the ACM Lisp and Functional Programming Conference, </booktitle> <pages> pages pages 86 - 95. </pages> <publisher> ACM, </publisher> <year> 1992. </year> <month> 23 </month>
Reference-contexts: The actual importation can be effected via module combination, described below.) In this manner, a Scheme module may be modeled as a self-referential namespace. Several module systems for Scheme have been proposed previously <ref> [12, 23, 21] </ref>, but these systems mainly provide a facility for structuring programs via decomposition. However, the ability to recompose first-class modules can additionally support design and implementation reuse akin to inheritance in OO programming.
References-found: 23

