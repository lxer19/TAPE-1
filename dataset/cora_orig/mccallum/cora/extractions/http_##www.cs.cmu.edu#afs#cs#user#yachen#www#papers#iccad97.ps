URL: http://www.cs.cmu.edu/afs/cs/user/yachen/www/papers/iccad97.ps
Refering-URL: http://www.cs.cmu.edu/afs/cs/user/yachen/www/publication.html
Root-URL: 
Email: yachen@cs.cmu.edu Randy.Bryant@cs.cmu.edu  
Title: *PHDD: An Efficient Graph Representation for Floating Point Circuit Verification  
Author: Yirng-An Chen Randal E. Bryant 
Address: Pittsburgh, PA 15213  
Affiliation: Carnegie Mellon University,  
Abstract: Data structures such as *BMDs, HDDs, and K*BMDs provide compact representations for functions which map Boolean vectors into integer values, but not floating point values. In this paper, we propose a new data structure, called Multiplicative Power Hybrid Decision Diagrams (*PHDDs), to provide a compact representation for functions that map Boolean vectors into integer or floating point values. The size of the graph to represent the IEEE floating point encoding is linear with the word size. The complexity of floating point multiplication grows linearly with the word size. The complexity of floating point addition grows exponentially with the size of the exponent part, but linearly with the size of the mantissa part. We applied *PHDDs to verify integer multipliers and floating point multipliers before the rounding stage, based on a hierarchical verification approach. For integer multipliers, our results are at least 6 times faster than *BMDs. Previous attempts at verifying floating point multipliers required manual intervention. We verified floating point multipliers before the rounding stage automatically. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> BRACE, K., RUDELL, R., AND BRYANT, R. E. </author> <title> Efficient implementation of a BDD package. </title> <booktitle> In Proceedings of the 27th ACM/IEEE Design Automation Conference (June 1990), </booktitle> <pages> pp. 4045. </pages>
Reference-contexts: and only if the following holds: * The leaf nodes can only have odd integers or 0. * At most one branch has non-zero weight. * The edge weights are greater than or equal to 0, except the top one. 3.2 Negation Edge Negation edges are commonly used in BDDs <ref> [1] </ref> and KFDDs [11], but not in *BMDs, HDDs and K*BMDs. Since our edge weights extract powers-of-2 which are always positive, negation edges are added to *PHDDs to increase sharing among the diagrams. In *PHDDs, the negation edge of function f represents the negation of f .
Reference: [2] <author> BRYANT, R. E., AND CHEN, Y.-A. </author> <title> Verification of arithmetic functions with binary moment diagrams. </title> <type> Tech. Rep. </type> <institution> CMU-CS-94-160, School of Computer Science, Carnegie Mellon University, </institution> <year> 1994. </year>
Reference-contexts: None of these diagrams can represent functions which map Boolean vectors to floating point values, unless rational numbers are introduced into the representation <ref> [2] </ref>. But using rational numbers in the representation requires more space to store the numerator and denominator separately, and more computation to extract the rational numbers. <p> To normalize the edge weights, we chose to extract the minimum of the edge weight w0 and w1. This is a much simpler computation than the GCD of integer *BMDs or the reciprocal of rational *BMDs <ref> [2] </ref>. Figure 2 illustrates the manipulation of edge weights to maintain a canonical form. The first step is to extract the minimum of w0 and w1. Then, the new edge weights are adjusted by subtracting the minimum from w0 and w1 respectively.
Reference: [3] <author> BRYANT, R. E., AND CHEN, Y.-A. </author> <title> Verification of arithmetic circuits with binary moment diagrams. </title> <booktitle> In Proceedings of the 32nd ACM/IEEE Design Automation Conference (1995), </booktitle> <pages> pp. 535 541. </pages>
Reference-contexts: 1 Introduction Binary Moment Diagrams (BMDs) <ref> [3] </ref> have proved successful for representing and manipulating functions mapping Boolean vectors to integer values symbolically. They have been used in the verification of arithmetic circuits [4]. <p> For floating point addition, we show that the complexity grows linearly with the mantissa size, but exponentially with the exponent size. It is still practical for formats up to IEEE double precision. Based on a hierarchical verification methodology <ref> [3, 4] </ref>, we have applied *PHDDs to verify different sizes and types of integer multipliers. Compared with *BMDs, *PHDDs are consistently six times faster and use less memory. <p> Our next step is to look into the rounding stage and entire floating point adders. Earlier results using HDDs [6] show that the rounding stage itself can be handled. 2 BMDs, *BMDs and HDDs For expressing functions Boolean variables into integer values, BMDs <ref> [3] </ref> use the moment decomposition of a function: f = (1 x) f x + x f x = f x + x f ffix (1) where ,+ and denote multiplication, addition and subtraction, respectively.
Reference: [4] <author> CHEN, Y.-A., AND BRYANT, R. E. ACV: </author> <title> An arithmetic circuit verifier. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design (November 1996), </booktitle> <pages> pp. 361365. </pages>
Reference-contexts: 1 Introduction Binary Moment Diagrams (BMDs) [3] have proved successful for representing and manipulating functions mapping Boolean vectors to integer values symbolically. They have been used in the verification of arithmetic circuits <ref> [4] </ref>. Clarke, et al. [7] extended BMDs to a form they call Hybrid Decision Diagrams (HDDs), where a function may be decomposed with respect to each variable in one of six ways, but without edge weights. <p> Verification of floating point arithmetic circuits using any of these three diagrams requires the circuits to be divided into several sub-circuits for which specifications can be expressed in terms of integer functions and their operations <ref> [4, 6, 8] </ref>. The correctness of the overall circuit must be proved by users from the specifications of the verified sub-circuits. For instance, the floating point multiplier was divided into the circuits for the mantissa multiplication, the exponent addition, and the rounding in [6]. <p> For floating point addition, we show that the complexity grows linearly with the mantissa size, but exponentially with the exponent size. It is still practical for formats up to IEEE double precision. Based on a hierarchical verification methodology <ref> [3, 4] </ref>, we have applied *PHDDs to verify different sizes and types of integer multipliers. Compared with *BMDs, *PHDDs are consistently six times faster and use less memory.
Reference: [5] <author> CHEN, Y.-A., AND BRYANT, R. E. *PBHD: </author> <title> An efficient graph representation for floating point circuit verification. </title> <type> Tech. Rep. </type> <institution> CMU-CS-97-134, School of Computer Science, Carnegie Mel-lon University, </institution> <year> 1997. </year>
Reference-contexts: The first and third mantissa products share the common sub-function Y shown by the solid rectangles in Figure 6. The second and fourth products share the common sub-function 2 3 + Y shown by the dashed rectangles in Figure 6. In <ref> [5] </ref>, we have proved that the size of the resulting graph of floating point multiplication is 6 (n + m) + 3 with the variable ordering given in Figure 6, where n and m are the number combinations of mantissa sums. of bits in the exponent and mantissa parts. <p> For floating point addition, the size of the resulting graph grows exponentially with the size of the exponent part. In <ref> [5] </ref>, we have proved that the number of distinct mantissa sums of F X + F Y is 2 n+3 10, where n is the number of bits in the exponent part. <p> Since the number of distinct mantissa sums grows exponentially with the number of exponent bits, it can be shown that the total number of nodes grows exponentially with the size of exponent bits and grows linearly with the size of the mantissa part. Readers can refer to <ref> [5] </ref> for a detailed discussion of floating point addition. Floating point subtraction can be performed by the negation and addition operations. Therefore, it has the same complexity as addition.
Reference: [6] <author> CHEN, Y.-A., CLARKE, E. M., HO, P.-H., HOSKOTE, Y., KAM, T., KHAIRA, M., O'LEARY, J., AND ZHAO, X. </author> <title> Verification of all circuits in a floating-point unit using word-level model checking. </title> <booktitle> In Proceedings of the Formal Methods on Computer-Aided Design (November 1996), </booktitle> <pages> pp. </pages> <year> 1933. </year>
Reference-contexts: Verification of floating point arithmetic circuits using any of these three diagrams requires the circuits to be divided into several sub-circuits for which specifications can be expressed in terms of integer functions and their operations <ref> [4, 6, 8] </ref>. The correctness of the overall circuit must be proved by users from the specifications of the verified sub-circuits. For instance, the floating point multiplier was divided into the circuits for the mantissa multiplication, the exponent addition, and the rounding in [6]. <p> The correctness of the overall circuit must be proved by users from the specifications of the verified sub-circuits. For instance, the floating point multiplier was divided into the circuits for the mantissa multiplication, the exponent addition, and the rounding in <ref> [6] </ref>. The verification of these three sub-circuits was performed automatically by word-level SMV [8], but the correctness of the entire multiplier must be proved by users from the verified specifications of these three sub-circuits. <p> Our results show that the verification of floating point multipliers requires minimal effort beyond integer multipliers. Our next step is to look into the rounding stage and entire floating point adders. Earlier results using HDDs <ref> [6] </ref> show that the rounding stage itself can be handled. 2 BMDs, *BMDs and HDDs For expressing functions Boolean variables into integer values, BMDs [3] use the moment decomposition of a function: f = (1 x) f x + x f x = f x + x f ffix (1) where <p> Then, we will look into the rounding stage and entire floating-point adders. Earlier results <ref> [6] </ref> show that the rounding stage itself can be handled with HDDs and therefore with *PHDDs. To verify entire floating point adders, we need to develop some techniques to avoid the exponential growth.
Reference: [7] <author> CLARKE, E. M., FUJITA, M., AND ZHAO, X. </author> <title> Hybrid decision diagrams overcoming the limitations of MTBDDs and BMDs. </title> <booktitle> In Proceedings of the International Conference on Computer-Aided Design (November 1995), </booktitle> <pages> pp. 159163. </pages>
Reference-contexts: 1 Introduction Binary Moment Diagrams (BMDs) [3] have proved successful for representing and manipulating functions mapping Boolean vectors to integer values symbolically. They have been used in the verification of arithmetic circuits [4]. Clarke, et al. <ref> [7] </ref> extended BMDs to a form they call Hybrid Decision Diagrams (HDDs), where a function may be decomposed with respect to each variable in one of six ways, but without edge weights. <p> In this paper, we propose a new representation, called Multiplicative Power Hybrid Decision Diagrams (*PHDDs), which improves on previous diagrams in representing floating point functions. *PHDDs can represent functions having Boolean variables as arguments and floating point values as results. This structure is similar to that of HDDs <ref> [7] </ref>, except that they are based on powers-of-2 edge weights and complement edges for negation. We show that the size of floating point multiplication grows linearly with the word size. <p> Each vertex of a BMD describes a function in terms of its moment decomposition with respect to the variable labeling the vertex. The two outgoing arcs denote the constant and linear moments of the function with respect to the variable. Clarke, et al. <ref> [7] </ref> extended BMDs to a form they call Hybrid Decision Diagrams (HDDs), where a function may be decomposed with respect to each variable in one of six decomposition types. <p> Observe that w can be negative, i.e., we can represent rational numbers. The power edge weights enable us to represent functions mapping Boolean variables to floating point values without using rational numbers in our representation. In addition to the HDD reduction rules <ref> [7] </ref>, we apply several edge weight manipulating rules to maintain the canonical form of the resulting graph. Let w0 and w1 denote the weights at branch 0 and 1 respectively, and f 0 and f 1 denotes the functions represented by branch 0 and 1.
Reference: [8] <author> CLARKE, E. M., KHAIRA, M., AND ZHAO, X. </author> <title> Word level model checking Avoiding the Pentium FDIV error. </title> <booktitle> In Proceedings of the 33rd ACM/IEEE Design Automation Conference (June 1996), </booktitle> <pages> pp. 645648. </pages>
Reference-contexts: Verification of floating point arithmetic circuits using any of these three diagrams requires the circuits to be divided into several sub-circuits for which specifications can be expressed in terms of integer functions and their operations <ref> [4, 6, 8] </ref>. The correctness of the overall circuit must be proved by users from the specifications of the verified sub-circuits. For instance, the floating point multiplier was divided into the circuits for the mantissa multiplication, the exponent addition, and the rounding in [6]. <p> For instance, the floating point multiplier was divided into the circuits for the mantissa multiplication, the exponent addition, and the rounding in [6]. The verification of these three sub-circuits was performed automatically by word-level SMV <ref> [8] </ref>, but the correctness of the entire multiplier must be proved by users from the verified specifications of these three sub-circuits. <p> In order to verify IEEE extended precision addition, it is necessary to avoid the exponential growth of floating point addition. 6 Future Work To verify circuit designs automatically, we would like to integrate the *PHDD package into word-level SMV <ref> [8] </ref> and extend word-level SMV, if needed, to handle the floating point arithmetic circuits. Then, we will look into the rounding stage and entire floating-point adders. Earlier results [6] show that the rounding stage itself can be handled with HDDs and therefore with *PHDDs.
Reference: [9] <author> CLARKE, E. M., MCMILLAN, K., ZHAO, X., FUJITA, M., AND YANG, J. </author> <title> Spectral transforms for large boolean functions with applications to technology mapping. </title> <booktitle> In Proceedings of the 30th ACM/IEEE Design Automation Conference (June 1993), </booktitle> <pages> pp. 5460. </pages>
Reference-contexts: As an example, Figure 1 show an integer function f with Boolean variables x and y represented by a truth table, BMDs, *BMDs, and HDDs with Shannon decompositions (also called MTBDD <ref> [9] </ref>). In our drawing, the variables with Shannon and positive Davio decomposition types are drawn in vertices with thin and thick lines, respectively.
Reference: [10] <author> DRECHSLER, R., BECKER, B., AND RUPPERTZ, S. K*BMDs: </author> <title> a new data struction for verification. </title> <booktitle> In Proceedings of European Design and Test Conference (March 1996), </booktitle> <pages> pp. 28. </pages>
Reference-contexts: They have been used in the verification of arithmetic circuits [4]. Clarke, et al. [7] extended BMDs to a form they call Hybrid Decision Diagrams (HDDs), where a function may be decomposed with respect to each variable in one of six ways, but without edge weights. Drechsler, et al. <ref> [10] </ref> extended Multiplicative BMDs (*BMDs) to a form called K*BMDs, where a function may be decomposed with respect to each variable in one of three ways, and with both additive and multiplicative edge weights. <p> The negative cofactor f x will be termed the constant moment, i.e., it denotes the portion of function f that remains constant with respect to x. This decomposition is also called positive Davio in K*BMDs <ref> [10] </ref>. Each vertex of a BMD describes a function in terms of its moment decomposition with respect to the variable labeling the vertex. The two outgoing arcs denote the constant and linear moments of the function with respect to the variable.
Reference: [11] <author> DRECHSLER, R., SARABI, A., THEOBALD, M., BECKER, B., AND PERKOWSKI, M. A. </author> <title> Efficient representation and manipulation of switching functions based on ordered Kronecker functional decision diagrams. </title> <booktitle> In Proceedings of the 31st ACM/IEEE Design Automation Conference (June 1994), </booktitle> <pages> pp. 415419. </pages>
Reference-contexts: the following holds: * The leaf nodes can only have odd integers or 0. * At most one branch has non-zero weight. * The edge weights are greater than or equal to 0, except the top one. 3.2 Negation Edge Negation edges are commonly used in BDDs [1] and KFDDs <ref> [11] </ref>, but not in *BMDs, HDDs and K*BMDs. Since our edge weights extract powers-of-2 which are always positive, negation edges are added to *PHDDs to increase sharing among the diagrams. In *PHDDs, the negation edge of function f represents the negation of f . <p> In *PHDD data structure, we use the low order bit of the pointers to denote negation, as is done with the complement edge of BDDs. To maintain a canonical form, we must constrain the use of negation edges. Unlike KFDDs <ref> [11] </ref>, where Shannon decompositions use a different method from positive and negative Davio decompositions, *PHDDs use the same method for manipulating the negation edge for all three decomposition types. *PHDDs must follow these rules: the zero edge of every node must be a regular edge, the negation of leaf 0 is
References-found: 11

