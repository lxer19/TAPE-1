URL: http://www-cad.eecs.berkeley.edu/HomePages/sanghavi/publications/dac96Paper.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/HomePages/sanghavi/publications/publications.html
Root-URL: http://www.cs.berkeley.edu
Email: Email: fsanghavi,rajeev,brayton,albertog@eecs.berkeley.edu  
Title: High Performance BDD Package By Exploiting Memory Hierarchy  
Author: Jagesh V. Sanghavi Rajeev K. Ranjan Robert K. Brayton Alberto Sangiovanni-Vincentelli 
Address: Berkeley, CA 94720  
Affiliation: Department of Electrical Engineering and Computer Sciences University of California at  
Abstract: The success of binary decision diagram (BDD) based algorithms for verification depend on the availability of a high performance package to manipulate very large BDDs. State-of-the-art BDD packages, based on the conventional depth-first technique, limit the size of the BDDs due to a disorderly memory accesspatterns that results in unacceptably high elapsed time when the BDD size exceeds the main memory capacity. We present a high performance BDD package that enables manipulation of very large BDDs by using an iterative breadth-first technique directed towards localizing the memory accesses to exploit the memory system hierarchy. The new memory-oriented performance features of this package are 1) an architecture independent customized memory management scheme, 2) the ability to issue multiple independent BDD operations (super-scalarity), and 3) the ability to perform multiple BDD operations even when the operands of some BDD operations are the result of some other operations yet to be completed (pipelining). A comprehensive set of BDD manipulation algorithms are implemented using the above techniques. Unlike the breadth-first algorithms presented in the literature, the new package is faster than the state-of-the-art BDD package by a factor of upto 1.5, even for the BDD sizes that fit within the main memory. For BDD sizes that do not fit within the main memory, a performance improvement of up to a factor of 100 can be achieved. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Bryant, </author> <title> Graph-based Algorithms for Boolean Function Manipulation, </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. C-35, </volume> <pages> pp. 677-691, </pages> <month> Aug. </month> <year> 1986. </year>
Reference-contexts: 1 Introduction The manipulation of very large binary decision diagrams (BDDs) <ref> [1] </ref> (for BDD related terminology, please refer to [2]) is the key to success for BDD-based algorithms for simulation, synthesis, and verification of integrated circuits and systems [3].
Reference: [2] <author> K. S. Brace, R. L. Rudell, and R. E. Bryant, </author> <title> Efficient implementation of a BDD package, </title> <booktitle> in Proc. of the Design Automation Conf., </booktitle> <pages> pp. 40-45, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: 1 Introduction The manipulation of very large binary decision diagrams (BDDs) [1] (for BDD related terminology, please refer to <ref> [2] </ref>) is the key to success for BDD-based algorithms for simulation, synthesis, and verification of integrated circuits and systems [3]. Conventional BDD algorithms are based on a recursive formulation that leads to a depth-first traversal of the directed acyclic graphs representing the operand BDDs.
Reference: [3] <author> R. Bryant, </author> <title> A methodology for hardware verification based on logic simulation, </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> vol. 38, </volume> <pages> pp. 299-328, </pages> <month> Apr. </month> <year> 1991. </year>
Reference-contexts: 1 Introduction The manipulation of very large binary decision diagrams (BDDs) [1] (for BDD related terminology, please refer to [2]) is the key to success for BDD-based algorithms for simulation, synthesis, and verification of integrated circuits and systems <ref> [3] </ref>. Conventional BDD algorithms are based on a recursive formulation that leads to a depth-first traversal of the directed acyclic graphs representing the operand BDDs. A typical recursive depth-first BDD algorithm is shown in Figure 1. The depth-first traversal visits the nodes of the operand BDDs on a path-by-path basis.
Reference: [4] <author> J. L. Hennessy and D. A. Patterson, </author> <title> Computer Architecture: A Quantitative Approach. </title> <publisher> Morgan Kaufman, </publisher> <year> 1990. </year>
Reference-contexts: Therefore, the recursive depth-first traversal leads to an extremely disorderly memory access pattern. In a typical computer system, the memory is organized hierarchically with smaller, faster, and more expensive (per byte) memory closer to the processor <ref> [4] </ref>. A simplified memory hierarchy consists of processor registers, several levels of on- and off-chip caches (SRAM), main memory (DRAM), and a hard disk.
Reference: [5] <author> H. Ochi, K. Yasuoka, and S. Yajima, </author> <title> Breadth-First Manipulation of Very Large Binary-Decision Diagrams, </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 48-55, </pages> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: Section 4 briefly describes how superscalarity and pipelining are exploited to obtain efficient algorithms for common BDD operations. Experimental results are presented in Section 5 and conclusions in Section 6. 2 Breadth-First Technique for BDD Manipulation Originally proposed by Ochi et al. <ref> [5] </ref>, the iterative breadth-first technique for BDD manipulation attempts to fix the disorderly memory access behavior of the recursive depth-first technique. <p> In order to preserve the locality of references, it is important to determine the variable index of a BDD node without actually fetching it from memory. In particular, the routine bf apply called with index i should access BDD nodes only at index i. Ochi et al. <ref> [5] </ref> use Quasi-Reduced BDDs (QRBDDs) to solve this problem. Essentially, pad nodes are introduced along each path of the BDD so that consecutive nodes along a path differ in their indices by exactly one.
Reference: [6] <author> P. Ashar and M. Cheong, </author> <title> Efficient Breadth-First Manipulationof Binary Decision Diagrams, </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 622-627, </pages> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: However, it is observed that the QRBDD is several times larger than the corresponding BDD <ref> [6] </ref>, which makes this approach impractical for manipulating very large BDDs. Ashar et al. [6] use a BLOCK-INDEX table to determine the variable index from a BDD pointer by performing an associative lookup. <p> However, it is observed that the QRBDD is several times larger than the corresponding BDD <ref> [6] </ref>, which makes this approach impractical for manipulating very large BDDs. Ashar et al. [6] use a BLOCK-INDEX table to determine the variable index from a BDD pointer by performing an associative lookup. <p> The limitation of this approach is that it has a significant overhead (about a factor of 2.65) as compared to a depth-first based algorithm for manipulating BDDs which fit within the main memory <ref> [6] </ref>. struct Bdd f int bddIndex; /* 2 Bytes */ struct BddNode *bddNode; /* 4 Bytes */ g struct BddNode f struct BddNode *next; /* 4 Bytes */ struct Bdd thenBdd; /* 6 Bytes */ struct Bdd elseBdd; /* 6 Bytes */ g Our approach to handling variable index determination problem <p> Similarly, to compare the performance of QUANTIFICATION operation, we select one of the output BDDs randomly and also randomly select a set of variables to be quantified. Functions and the variables selected are the same for both the packages. We made black box comparison with best reported BFS algorithm <ref> [6] </ref> on Sun Sparc2 workstation with 40MB main memory. Our approach is faster by a factor of 4.4 (geometric mean) for creating output BDDs for C6288 subcircuits with one to seven million nodes. The performance improvement is mainly due to new implementation technique, superscalarity, and pipelining.
Reference: [7] <author> D. E. </author> <title> Long, ROBDD Package, </title> <institution> (Carnegie Mellon University, Pittsburgh), </institution> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: Table 1: Performance comparison for creating output BDDs: Long's BDD package (A) vs. our package (B) t.o:Process killed after 21.5 hours of elapsed time. of BDD nodes becomes too large to fit in the main memory, the number of page faults and the elapsed time increase drastically for Long's package <ref> [7] </ref>. In Figure 7, we show the number of page faults Example Size and the elapsed time as a function of example size. <p> A complete package consisting of the whole suite of BDD operations based on these techniques has been built. We demonstrate the performance of our package by 1) comparing with state-of-the-art BDD package <ref> [7] </ref>, and 2) performing a comprehensive set of experiments to substantiate the capability of our approach. We show that our package provides competitive performance on small examples and a performance ratio of more than 100 on large examples.
Reference: [8] <author> E. M. Sentovich, K. J. Singh, L. Lavagno, C. Moon, R. Murgai, A. Saldanha, H. Savoj, P. R. Stephan, R. K. Brayton, and A. L. Sangiovanni-Vincentelli, </author> <note> SIS: </note>
Reference-contexts: We employ superscalarity in finding the OR of the cofactor results for nodes belonging to a particular level. 5 Experimental Results We integrated our package with the synthesis tool SIS <ref> [8] </ref>. In addition to using standard ISCAS and MCNC benchmark examples for the set of experiments, we use a series of sub-networks of the MCNC benchmark C6288 in order to systematically analyze the performance of our algorithms as BDD size increases.
References-found: 8

