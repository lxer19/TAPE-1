URL: http://www.cs.arizona.edu/people/debray/papers/susp_analysis.ps
Refering-URL: http://www.cs.arizona.edu/jc/
Root-URL: http://www.cs.arizona.edu
Title: DETECTION AND OPTIMIZATION OF SUSPENSION-FREE LOGIC PROGRAMS  
Author: SAUMYA DEBRAY, DAVID GUDEMAN, AND PETER BIGOT 
Note: J. LOGIC PROGRAMMING 1993:12:1-199 1  
Abstract: fl In recent years, language mechanisms to suspend, or delay, the execution of goals until certain variables become bound have become increasingly popular in logic programming languages. While convenient, such mechanisms can make control flow within a program difficult to predict at compile time and therefore render many traditional compiler optimizations inapplicable. Unfortunately, this performance cost is also incurred by programs that do not use any delay primitives. In this paper we describe a simple dataflow analysis for detecting computations where suspension effects can be ignored, and discuss several low-level optimizations that rely on this information. Our algorithm has been implemented in the jc system. Optimizations based on information it produces result in significant performance improvements, resulting in speed comparable to or exceeding that of optimized C programs. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> P. Bigot, D. Gudeman, and S. K. Debray, </author> <title> "Output Value Placement in Moded Logic Programs", </title> <booktitle> Proc. Eleventh Int. Conf. on Logic Programming, </booktitle> <month> June </month> <year> 1994, </year> <pages> pp. 175-189. </pages> <publisher> MIT Press. </publisher>
Reference-contexts: For example, it has been shown that significant improvements in performance can be obtained by returning output values of procedures in registers instead of in memory <ref> [1, 21] </ref>, or with knowledge of lengths of dereference chains [17]. <p> This can become fairly complicated and incur performance penalties. A much simpler solution that works well in practice (see <ref> [1] </ref>) is to consider returning output values in registers only for procedures that can be guaranteed to be non-suspending. It turns out, however, that weak non-suspension is inadequate for this optimization. <p> This problem can be avoided if output values are returned in registers only for procedures that can be inferred to be strongly non-suspending. This optimization (returning output values in registers) has been implemented in jc: the interested reader is referred to <ref> [1] </ref>. Performance results for a number of benchmark programs on a Sparcstation-IPC (with garbage collection turned off) are shown in Table 2. 6.2.
Reference: 2. <author> P. A. Bigot and S. K. Debray, </author> <title> "A Simple Approach to Supporting Untagged Objects in Dynamically Typed Languages", </title> <booktitle> Proc. 1995 Int. Symp. on Logic Programming, </booktitle> <address> Dec. 1995. </address> <publisher> MIT Press. </publisher>
Reference-contexts: We therefore need (weak) non-suspension analysis to identify variables whose values can be guaranteed to have been computed at a particular program point. This optimization has been implemented in jc <ref> [2] </ref>. At this time, only numeric values, i.e., integers and floating point values, are considered for untagged and unboxed representation.
Reference: 3. <author> M. Carlsson and J. Widen, </author> <title> SICStus Prolog User's Manual, </title> <institution> Swedish Institute of Computer Science, </institution> <month> Oct. </month> <year> 1988. </year>
Reference-contexts: For example, SICStus Prolog usually schedules goals as soon as they are awakened, ahead of other ready goals, though the relative order of goals that are awakened at the same time is unspecified <ref> [3] </ref>; the default policy in jc is to schedule awakened goals after all previously ready goals have finished executing (the more common "schedule awakened goals immediately" behavior can be obtained via a compiler option). KL1 provides a system of priorities that must be respected when awakened goals are executed [5]. <p> An implementation that allows suspension at arbitrary program points has to deal with saving and restoring arbitrary amounts of local state, leading to implementation complications and runtime performance overheads. An alternative approach|taken, for example, by SICStus Prolog <ref> [3] </ref> and jc [13]|is to allow suspension to occur only at specific predetermined program points.
Reference: 4. <author> M. Carlsson, </author> <title> "The SICStus Prolog Emulator", </title> <type> Technical Report T91:15, </type> <institution> Swedish Institute of Computer Science, </institution> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: This performance overhead is especially serious in numerical computations, because implementations of logic programming languages very often represent floating 18 point numbers as boxed values (see, for example, <ref> [4] </ref>). This incurs a significant performance penalty, for a number of reasons. First of all, since floating point values are heap-allocated, numerical computations involving boxed floating point values fail to exploit hardware registers effectively, and generate a lot more memory traffic.
Reference: 5. <author> T. Chikayama, T. Fujise, and D. Sekita, </author> <title> "A Portable and Efficient Implementation of KL1", </title> <booktitle> Proc. Int. Symp. on Programming Language Implementation and Logic Programming, </booktitle> <month> Sept. </month> <year> 1994, </year> <pages> pp. 25-39 </pages>
Reference-contexts: KL1 provides a system of priorities that must be respected when awakened goals are executed <ref> [5] </ref>. <p> Because Janus programs are compiled to C code which is then processed by a C compiler, most of the overall time for translation to the object code is spent in I/O operations and in the C compiler (other systems that compile to C, e.g., KLIC <ref> [5] </ref>, report similar experiences). As a result, there is no perceptible decrease in the overall compile time when dataflow analysis and optimizations are switched off. 5.2. <p> Moreover, the details of such an approach become somewhat complicated under more elaborate scheduling policies, e.g., the priority-based system of KL1 <ref> [5] </ref>. Our approach, by contrast, makes no assumptions about how suspended goals might be scheduled after they are awakened.
Reference: 6. <author> M. Codish, M. Falaschi, and K. Marriott, </author> <title> "Suspension Analysis for Concurrent Logic Programs", </title> <booktitle> Proc. Eighth Int. Conf. on Logic Programming, </booktitle> <month> June </month> <year> 1991, </year> <pages> pp. 331-345. </pages> <publisher> MIT Press. </publisher>
Reference-contexts: However, the details can get quite complicated: for example, abstracting a sequence of goals into a sequence of abstract goals need not produce a Noetherian abstract domain, and an additional level of abstraction may be necessary to ensure termination. For example, the "star abstraction" of Codish et al. <ref> [6] </ref> allows at most one "abstract atom" with a particular predicate symbol, while Marriott et al. require bounds on the sizes of the multisets describing delayed goals [18]. <p> Also related is work on analysis of concurrent logic languages, e.g., the deadlock analyses described in <ref> [6, 7] </ref>.
Reference: 7. <author> C. Codognet, P. Codognet, and M. Corsini, </author> <title> "Abstract Interpretation of Concurrent Logic Languages", </title> <booktitle> Proc. 1990 North American Conf. on Logic Programming, </booktitle> <month> Nov. </month> <year> 1990, </year> <pages> pp. 215-232. </pages> <publisher> MIT Press. </publisher>
Reference-contexts: Also related is work on analysis of concurrent logic languages, e.g., the deadlock analyses described in <ref> [6, 7] </ref>.
Reference: 8. <author> P. Cousot and R. Cousot, </author> <title> "Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Apporoximation of Fixpoints", </title> <booktitle> Proc. Fourth ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1977, </year> <pages> pp. 238-252. </pages>
Reference-contexts: Correctness could then be inferred from the relationships between these objects and operations, using results of abstract interpretation <ref> [8] </ref>. However, the details can get quite complicated: for example, abstracting a sequence of goals into a sequence of abstract goals need not produce a Noetherian abstract domain, and an additional level of abstraction may be necessary to ensure termination.
Reference: 9. <author> S. K. Debray, P. Lopez Garca, M. Hermenegildo, and N.-W. Lin, </author> <title> "Lower Bound Cost Estimation for Logic Programs", </title> <type> manuscript, </type> <month> April </month> <year> 1994. </year>
Reference-contexts: made more precise by checking also whether it may be possible to guarantee that some clause for the called predicate will reduce, in which case the possible suspension of other clauses is moot: this can be done, in the presence of type information, using the notion of covering discussed in <ref> [9] </ref>. 9 initial query Q, (Q; id vars (Q) ; ") ; ? (p (u); ; Susp). Consider transitions from the state (p (u); ; ").
Reference: 10. <author> I. Foster and S. Taylor, "Strand: </author> <title> A Practical Parallel Programming Tool", </title> <booktitle> Proc. 1989 North American Conference on Logic Programming, </booktitle> <address> Cleveland, Ohio, </address> <month> Oct. </month> <year> 1989, </year> <pages> pp. 497-512. </pages> <publisher> MIT Press. </publisher>
Reference-contexts: Implementation 5.1. Background Janus is a committed-choice logic programming language that, in its present incarnation, closely resembles Strand <ref> [10] </ref>. The jc system is a sequential implementation where clause bodies are executed from left to right as in Prolog.
Reference: 11. <author> M. Garcia de la Banda, </author> <type> personal communication, </type> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: This additional precision comes at a price, however: experiences with a prototype implementation of the analysis of Marriott et al. indicate that large amounts of time and space may be needed to analyze programs of even modest size if there are many goals that can suspend <ref> [11] </ref>. Moreover, the details of such an approach become somewhat complicated under more elaborate scheduling policies, e.g., the priority-based system of KL1 [5]. Our approach, by contrast, makes no assumptions about how suspended goals might be scheduled after they are awakened.
Reference: 12. <author> D. Gudeman, </author> <title> "Representing Type Information in Dynamically Typed Languages", </title> <type> Technical Report TR 93-27, </type> <institution> Dept. of Computer Science The University of Arizona, </institution> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: The usual way to address the first problem is to attach a descriptor to each value, to specify how its bit pattern is to be interpreted: such descriptors are usually referred to as tags <ref> [12, 19] </ref>. The second problem is usually handled by making values of different sizes "look the same" by manipulating pointers to them rather than the values themselves: such an indirect representation is often referred to as a boxed representation.
Reference: 13. <author> D. Gudeman, K. De Bosschere, and S.K. Debray, </author> <title> "jc: An Efficient and Portable Sequential Implementation of Janus", </title> <booktitle> Proc. Joint Int. Conf. and Symp. on Logic Programming, </booktitle> <month> Nov. </month> <year> 1992, </year> <pages> pp. 399-413. </pages> <publisher> MIT Press. </publisher> <pages> 26 </pages>
Reference-contexts: The utility of this information is demonstrated by discussing a number of low-level compiler optimizations that rely on this information. We have implemented the analysis, and compiler optimizations based on it, in the jc system <ref> [13] </ref>: we present performance results to show that information about non-suspension is fundamental to a variety of low-level compiler optimizations that turn out to be very effective in producing significant performance improvements. <p> The jc compiler translates Janus programs to C and then uses a C compiler (the performance numbers in this paper correspond to gcc 2.6.3 invoked with -O2 -fomit-frame-pointer) to compile the resulting program to executable code. An early version of the system is described in <ref> [13] </ref>, and a prototype of the system, including the dataflow analyses and the optimizations based on this analysis that are discussed in Section 6, is available by anonymous FTP from ftp.cs.arizona.edu. As with many other committed-choice languages, Janus uses dataflow synchronization.
Reference: 14. <author> G. Janssens, </author> <title> Deriving run-time properties of logic programs by means of abstract interpretation, </title> <type> Ph. D. thesis, </type> <institution> Katholieke Universiteit Leuven, Belgium, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: Output Value Placement in Registers: Performance (jc on a Sparcstation-IPC) for example, <ref> [14, 20] </ref>), whether or not it is reasonable to expect this degree of precision from the underlying analysis depends on the kinds of programs one expects to encounter and perhaps also on the speed with which the compiler is expected to work (though our experience has been that the time taken
Reference: 15. <author> M. Hanus, </author> <title> "On the Completeness of Residuation", </title> <booktitle> Proc. Joint Int. Conf. and Symp. on Logic Programming, </booktitle> <month> Nov. </month> <year> 1992, </year> <pages> pp. 192-206. </pages> <publisher> MIT Press. </publisher>
Reference-contexts: Related Work The work most closely related to this is that of Marriott et al. [18], who also consider the analysis of sequential logic programs with delay primitives, and of Hanus, who considers the analysis of functional logic programs using residuation <ref> [15] </ref>. The main difference between their work and that reported here is that of focus.
Reference: 16. <author> B. Le Charlier and P. Van Hentenryck, </author> <title> "Reexecution in Abstract Interpretation of Prolog", </title> <booktitle> Proc. Joint Int. Conf. and Symp. on Logic Programming, </booktitle> <month> Nov. </month> <year> 1992, </year> <pages> pp. 750-764. </pages> <publisher> MIT Press. </publisher>
Reference-contexts: The ordering on this domain is ground v any . We use reexecution of primitive operations (see <ref> [16] </ref>) to improve the precision of the analysis. We have not yet implemented strong non-suspension analysis.
Reference: 17. <author> A. Marien, G. Janssens, A. Mulkers, and M. Bruynooghe, </author> <title> "The Impact of Abstract Interpretation: An Experiment in Code Generation", </title> <booktitle> Proc. Sixth Int. Conf. on Logic Programming, </booktitle> <month> June </month> <year> 1989, </year> <pages> pp. 33-47. </pages>
Reference-contexts: For example, it has been shown that significant improvements in performance can be obtained by returning output values of procedures in registers instead of in memory [1, 21], or with knowledge of lengths of dereference chains <ref> [17] </ref>. However, in a language with delay mechanisms, there is always the possibility that "normal" execution may be pre-empted by a newly awakened goal that may overwrite a register containing an output value or change the length of a dereference chain, thereby making these optimizations inapplicable. <p> General Prolog Optimizations In recent years there has been a great deal of work on optimization of (non-suspending) Prolog. For example, Marien et al. show that significant performance improvements are possible for Prolog programs if the lengths of dereference chains can be statically predicted <ref> [17] </ref>, while Van Roy shows that execution speed can be improved significantly if the initialization of variables can be avoided [21]. All of these optimizations become applicable for (strongly) non-suspending programs in logic programming languages with delay mechanisms. 7.
Reference: 18. <author> K. Marriott, M. Garcia de la Banda, and M. Hermenegildo, </author> <title> "Analyzing Logic Programs with Dynamic Scheduling", </title> <booktitle> Proc. 21st. ACM Symp. on Principles of Programming Languages, </booktitle> <month> Jan. </month> <year> 1994, </year> <pages> pp. 240-252. </pages>
Reference-contexts: Suspension of computations is also supported in concurrent logic programming languages, where a test in the guard of a clause suspends if the variables involved are not sufficiently instantiated. In order to abstract away from syntactic idiosyncracies of particular languages, we follow Marriott et al. <ref> [18] </ref> in assuming two (system-dependent) functions that specify the suspension/resumption behavior of goals: delay (A; C; ) is true for a goal A, clause C and substitution if and only if the execution of the goal (A) using clause C should be delayed; 1 and, given a sequence of (suspended) goals <p> Axioms specifying relationships between these functions are discussed in <ref> [18] </ref>. We assume that programs are moded, i.e., for each predicate p in a program its arguments are known to be "input" (if p uses the value of that argument) or "output" (if p defines that argument, i.e., binds it to a value). <p> A state consists of a sequence of "active" goals, a substitution, and a sequence of suspended goals: State = Atom fl fi Subst fi Atom fl . 1 The delay function we consider is actually slightly different from that of Marriott et al. <ref> [18] </ref>, in that theirs does not take a clause as a parameter. 4 For notational simplicity we say that a clause C is variable-disjoint from a state S = (Ready ; ; Susp) if vars (C)"(vars (Ready )[vars (Susp )[vars ()) = ;. <p> For example, the "star abstraction" of Codish et al. [6] allows at most one "abstract atom" with a particular predicate symbol, while Marriott et al. require bounds on the sizes of the multisets describing delayed goals <ref> [18] </ref>. Since our analysis algorithms are really quite straightforward, we felt that trying to formalize them as full-blown abstract interpretations would serve mainly to introduce a plethora of notation and to obscure, rather than illuminate, the essential underlying intuitions. <p> at any point, and about the scheduling policy for these awakened goals, it is very difficult to predict the behavior of the system under these circumstances (Marriott et al. show how a simple scheduling strategy, such as that used by SICStus Prolog, can be taken into account to some extent <ref> [18] </ref>; however, for more sophisticated strategies, e.g. involving multiple priority levels as in KL1, the task seems more difficult). It is for this reason that the statement of Theorem 4.1 assumed that the set of suspended goals is empty. <p> However, Marriott et al., using SICStus Prolog 2.1, report significant performance improvements from the removal of suspension tests <ref> [18] </ref>. 6.5. General Prolog Optimizations In recent years there has been a great deal of work on optimization of (non-suspending) Prolog. <p> We acknowledge, of course, that performance comparisons between different languages are fundamentally dubious and very often have a strongly religious flavor, and caution the reader against reading too much into these results. 24 8. Related Work The work most closely related to this is that of Marriott et al. <ref> [18] </ref>, who also consider the analysis of sequential logic programs with delay primitives, and of Hanus, who considers the analysis of functional logic programs using residuation [15]. The main difference between their work and that reported here is that of focus.
Reference: 19. <author> P. A. Steenkiste, </author> <title> "The Implementation of Tags and Run-Time Type Checking", </title> <booktitle> in Topics in Advanced Language Implementation, </booktitle> <editor> ed. P. </editor> <booktitle> Lee, </booktitle> <pages> pp. 3-24. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: The usual way to address the first problem is to attach a descriptor to each value, to specify how its bit pattern is to be interpreted: such descriptors are usually referred to as tags <ref> [12, 19] </ref>. The second problem is usually handled by making values of different sizes "look the same" by manipulating pointers to them rather than the values themselves: such an indirect representation is often referred to as a boxed representation.
Reference: 20. <author> P. Van Hentenryck, A. Cortesi, and B. Le Charlier, </author> <title> "Type Analysis of Prolog using Type Graphs", </title> <journal> J. Logic Programming vol. </journal> <volume> 22 no. 3, </volume> <month> March </month> <year> 1995, </year> <pages> pp. 179-209. </pages>
Reference-contexts: Output Value Placement in Registers: Performance (jc on a Sparcstation-IPC) for example, <ref> [14, 20] </ref>), whether or not it is reasonable to expect this degree of precision from the underlying analysis depends on the kinds of programs one expects to encounter and perhaps also on the speed with which the compiler is expected to work (though our experience has been that the time taken
Reference: 21. <author> P. Van Roy, </author> <title> Can Logic Programming Execute as Fast as Imperative Programming? PhD thesis, </title> <institution> University of California at Berkeley, </institution> <year> 1990. </year>
Reference-contexts: For example, it has been shown that significant improvements in performance can be obtained by returning output values of procedures in registers instead of in memory <ref> [1, 21] </ref>, or with knowledge of lengths of dereference chains [17]. <p> For example, Marien et al. show that significant performance improvements are possible for Prolog programs if the lengths of dereference chains can be statically predicted [17], while Van Roy shows that execution speed can be improved significantly if the initialization of variables can be avoided <ref> [21] </ref>. All of these optimizations become applicable for (strongly) non-suspending programs in logic programming languages with delay mechanisms. 7. Discussion While delay mechanisms can be very convenient for programming purposes, they make control flow difficult to predict and thereby render many low level compiler optimizations difficult or impossible.
Reference: 22. <author> W. </author> <title> Winsborough, </title> <type> personal communication, </type> <month> May </month> <year> 1994. </year>
Reference-contexts: Then, L.nosusp and p.nosusp are set to false by the analysis algorithm. Proof. Suppose that L p (u) is a literal in a program such that for some 4 W. Winsborough has pointed out <ref> [22] </ref> that this check can be made more precise by checking also whether it may be possible to guarantee that some clause for the called predicate will reduce, in which case the possible suspension of other clauses is moot: this can be done, in the presence of type information, using the
References-found: 22

