URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/transaction.logic/pods99-long.ps
Refering-URL: http://www.cs.toronto.edu/~bonner/papers.html
Root-URL: http://www.cs.toronto.edu
Email: email: bonner@db.toronto.edu  
Phone: phone: (416) 978-7441 fax: (416) 978-4765  
Title: Workflow, Transactions, and Datalog  
Author: Anthony J. Bonner 
Date: December 14, 1998  
Web: web: www.cs.toronto.edu/~bonner  
Address: Toronto, Ontario, Canada M5S 1A4  
Affiliation: University of Toronto Department of Computer Science  
Abstract: Transaction Datalog (abbreviated T D) is a concurrent programming language that provides process modeling, database access, and advanced transactions. This paper illustrates the use of T D for specifying and simulating workflows, with examples based on the needs of a high-throughput genome laboratory. In addition to database support, these needs include concurrent access to shared resources, synchronization of work, and networks of cooperating workflows. We also use T D to explore the computational complexity of workflows in data-intensive applications. We show, for instance, that workflows can be vastly more complex than database transactions, largely because concurrent processes can interact and communicate via the database (i:e:, one process can read what another process writes). We then investigate the sources of this complexity, focusing on features for data modeling and process modeling. We show that by carefully controlling these features, the complexity of workflows can be reduced substantially. Finally, we develop a sublanguage called fully bounded T D that provides a practical blend of modeling features while minimizing complexity. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul. </author> <title> Updates, a new frontier. </title> <booktitle> In Int'l Conference on Database Theory, </booktitle> <pages> pages 1-18, </pages> <year> 1988. </year>
Reference-contexts: The result is that T D achieves RE-completeness with a fixed data domain, and a fixed database schema, and thus with databases of polynomial size. This demonstrates a fundamental difference between T D and other safe transaction languages, which are typically PSPACE-complete <ref> [2, 3, 1, 29] </ref>. This encoding of Turing machines in T D has some resemblance to the encoding of Turing machines in process algebras such as CCS [74]. <p> Concurrency is essential to the power of T D. As Theorem 4.5 shows, when concurrent composition is removed, the data complexity of T D plummets from RE to EXPTIME. This version of the language, which we call sequential T D, is comparable to safe transaction languages <ref> [2, 3, 1, 29] </ref>. The main difference is that such languages are typically complete for PSPACE, not EXPTIME. The extra power of sequential T D comes froms an ability to simulate alternating PSPACE machines [30]. <p> Also, as usual in expressibility results of this kind, we assume that the constant symbols are uninterpreted. Formally, this means extending the notion of genericity from queries to transactions, as in <ref> [3, 1] </ref>. Details are given in Appendix E. 5 FULLY BOUNDED T D 14 Restrictions on recursive processes also have a dramatic effect on data complexity. As Theorem 4.7 shows, if we eliminate recursion altogether, then data complexity plummets from RE to less than PTIME.
Reference: [2] <author> S. Abiteboul and V. Vianu. </author> <title> Procedural languages for database queries and updates. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 41 </volume> <pages> 181-229, </pages> <year> 1990. </year>
Reference-contexts: In particular, it is a safe language that does not generate an unbounded number of tuples during transaction execution. In contrast, other transaction languages achieve RE-completeness by expanding the data domain during transaction execution <ref> [2, 3, 23] </ref>, or by expanding the database schema [28]. Typically, to prove RE-completeness, the tape of a Turing machine is encoded as a database, and the finite control is encoded as a database program. In such approaches, database queries simulate tape reads, and database updates simulate tape writes. <p> The result is that T D achieves RE-completeness with a fixed data domain, and a fixed database schema, and thus with databases of polynomial size. This demonstrates a fundamental difference between T D and other safe transaction languages, which are typically PSPACE-complete <ref> [2, 3, 1, 29] </ref>. This encoding of Turing machines in T D has some resemblance to the encoding of Turing machines in process algebras such as CCS [74]. <p> Concurrency is essential to the power of T D. As Theorem 4.5 shows, when concurrent composition is removed, the data complexity of T D plummets from RE to EXPTIME. This version of the language, which we call sequential T D, is comparable to safe transaction languages <ref> [2, 3, 1, 29] </ref>. The main difference is that such languages are typically complete for PSPACE, not EXPTIME. The extra power of sequential T D comes froms an ability to simulate alternating PSPACE machines [30].
Reference: [3] <author> S. Abiteboul and V. Vianu. </author> <title> Datalog extensions for database queries and updates. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43 </volume> <pages> 62-124, </pages> <year> 1991. </year>
Reference-contexts: Our results are based on a number of standard definitions, adapted from <ref> [3, 28] </ref>. A database schema is a finite set of base predicate symbols (with associated arities). A database with schema S is a finite set of ground atoms constructed from the predicate symbols in S. <p> In particular, it is a safe language that does not generate an unbounded number of tuples during transaction execution. In contrast, other transaction languages achieve RE-completeness by expanding the data domain during transaction execution <ref> [2, 3, 23] </ref>, or by expanding the database schema [28]. Typically, to prove RE-completeness, the tape of a Turing machine is encoded as a database, and the finite control is encoded as a database program. In such approaches, database queries simulate tape reads, and database updates simulate tape writes. <p> The result is that T D achieves RE-completeness with a fixed data domain, and a fixed database schema, and thus with databases of polynomial size. This demonstrates a fundamental difference between T D and other safe transaction languages, which are typically PSPACE-complete <ref> [2, 3, 1, 29] </ref>. This encoding of Turing machines in T D has some resemblance to the encoding of Turing machines in process algebras such as CCS [74]. <p> Concurrency is essential to the power of T D. As Theorem 4.5 shows, when concurrent composition is removed, the data complexity of T D plummets from RE to EXPTIME. This version of the language, which we call sequential T D, is comparable to safe transaction languages <ref> [2, 3, 1, 29] </ref>. The main difference is that such languages are typically complete for PSPACE, not EXPTIME. The extra power of sequential T D comes froms an ability to simulate alternating PSPACE machines [30]. <p> Also, as usual in expressibility results of this kind, we assume that the constant symbols are uninterpreted. Formally, this means extending the notion of genericity from queries to transactions, as in <ref> [3, 1] </ref>. Details are given in Appendix E. 5 FULLY BOUNDED T D 14 Restrictions on recursive processes also have a dramatic effect on data complexity. As Theorem 4.7 shows, if we eliminate recursion altogether, then data complexity plummets from RE to less than PTIME.
Reference: [4] <author> S. Abiteboul, V. Vianu, B. Fordham, and Y. Yesha. </author> <title> Relational transducers for electronic commerce. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 179-187, </pages> <address> Seattle, Washington, </address> <month> June </month> <year> 1998. </year>
Reference: [5] <author> N. Adam, V. Atluri, and W. Huang. </author> <title> Modeling and analysis of workflows using Petri nets. </title> <journal> Journal of Intelligent Information Systems, </journal> <volume> 10(2) </volume> <pages> 131-158, </pages> <month> March </month> <year> 1998. </year>
Reference: [6] <institution> Standard Guide for Laboratory Information Management Systems (LIMS). American Society for Testing and Materials, </institution> <address> 1916 Race St., Philadelphia PA 19103, U.S.A, </address> <year> 1993. </year> <note> REFERENCES 18 </note>
Reference-contexts: As such, well-known optimization techniques (such as magic sets or tabling) can be applied. Suppose we augment tuple testing with tuple insertion (but not deletion). This is a natural set of operations for many scientific workflows, where workflow activities are laboratory experiments that gather, store and analyze information <ref> [6] </ref>. This is certainly the case for workflows at the Whitehead Institute/MIT Center for Genome Research [25, 73], where experimental results are accumulated in the database, and queried by analysis programs, but never deleted or altered.
Reference: [7] <author> P. Attie, M. Singh, A. Sheth, and M. Rusinkiewicz. </author> <title> Specifying and enforcing intertask dependencies. </title> <booktitle> In Int'l Conference on Very Large Data Bases, </booktitle> <address> Dublin, Ireland, </address> <month> August </month> <year> 1993. </year>
Reference: [8] <author> J.C.M. Baeten and W.P. Weijland. </author> <title> Process Algebra. </title> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference: [9] <author> T. Baker, J. Gill, and R. Soloway. </author> <title> Relativizations of the P ? = NP question. </title> <journal> SIAM Journal of Computing, </journal> <volume> 4 </volume> <pages> 431-442, </pages> <year> 1975. </year>
Reference-contexts: As another example, the goal fi [p (b) del.p (b)] represents a transaction program with a precondition, p (b). This program first asks if p (b) is in the database, 3 Another approach would be to prove relativized complexity results <ref> [66, 9] </ref> with elementary operations modeled by a variation of oracle Turing machines. All of the results in this paper can be relativized in this way, although additional formal machinery is required.
Reference: [10] <author> J. Balcazar, J. Gabarro, and M. Santha. </author> <title> Deciding bisimilarity is P-complete. </title> <journal> Formal Aspects of Computing, </journal> <volume> 4(6) </volume> <pages> 638-648, </pages> <year> 1992. </year>
Reference: [11] <author> J.A. Bergstra and J.W. Klop. </author> <title> Algebra of communicating processes with abstraction. </title> <journal> Theoretical Computer Science, </journal> <volume> 37(1) </volume> <pages> 77-121, </pages> <year> 1985. </year>
Reference: [12] <author> P.A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Databases. </title> <publisher> Addison Wesley, </publisher> <year> 1987. </year>
Reference-contexts: Isolation is a fundamental property of database transactions <ref> [12, 44] </ref>, and is closely related to serial-izability. For instance, if t 1 , t 2 , ..., t n are database programs, then the goal fit 1 j fit 2 j j fit n executes them serializably.
Reference: [13] <author> A.J. Bonner. </author> <title> Concurrent transaction logic. </title> <booktitle> Presented at the Dagstuhl Seminar on Transactional Workflows, </booktitle> <month> July 15-19 </month> <year> 1996, </year> <booktitle> International Conference and Research Center for Computer Science, </booktitle> <address> Schloss Dagstuhl, Wadern, Germany. </address>
Reference-contexts: These issues are addressed in Concurrent Transaction Logic (abbreviated CT R), which we developed in previous work <ref> [20, 13] </ref>. CT R is an extension of classical logic that seamlessly integrates concurrency and communication with queries and updates. It has a purely logical semantics, including a natural model theory and a sound-and-complete proof theory.
Reference: [14] <author> A.J. Bonner. </author> <title> Hypothetical Datalog: Complexity and expressibility. </title> <journal> Theoretical Computer Science, </journal> <volume> 76 </volume> <pages> 3-51, </pages> <year> 1990. </year>
Reference: [15] <author> A.J. Bonner. </author> <title> Intuitionistic deductive databases and the polynomial time hierarchy. </title> <journal> Journal of Logic Programming, </journal> <volume> 33(1) </volume> <pages> 1-47, </pages> <month> October </month> <year> 1997. </year>
Reference: [16] <author> A.J. Bonner. </author> <title> A logical semantics for hypothetical rulebases with deletion. </title> <journal> Journal of Logic Programming, </journal> <volume> 32(2) </volume> <pages> 119-170, </pages> <month> August </month> <year> 1997. </year>
Reference: [17] <author> A.J. Bonner. </author> <title> Transaction Datalog: a compositional language for transaction programming. </title> <booktitle> In Proceedings of the International Workshop on Database Programming Languages, number 1369 in Lecture Notes in Computer Science, </booktitle> <pages> pages 373-395. </pages> <publisher> Springer-Verlag, </publisher> <year> 1998. </year> <title> Workshop held in Estes Park, </title> <address> Colorado, </address> <month> August </month> <year> 1997. </year> <note> Long version available at http://www.cs.toronto.edu/ ~bonner/papers.html#transaction-logic. </note>
Reference-contexts: Related work on T D and CT R, a prototype implementation, and the results of benchmark tests are available at: http://www.cs.toronto.edu/~bonner/transaction-logic.html 2 Overview of Transaction Datalog Like classical logic programs, T D programs have both a declarative semantics and a procedural interpretation. These have been published in detail elsewhere <ref> [17, 20, 18] </ref>, and are reviewed in detail in Appendices A, B and C. This section provides a brief introduction, defining the syntax of T D and outlining its procedural interpretation. In this discussion, and the rest of the paper, we adopt the terminology of deductive databases. <p> The formal semantics of these formulas is given in <ref> [20, 17] </ref>. Intuitively, the first two formulas are yes/no queries, and the last two formulas are updates. <p> For instance, the rule r (X) fi [p (X) del.p (X)] defines a transaction with name r and parameter X. Using b as the parameter value, r (b) commits if p (b) is in the database at the start of execution. Advanced Transactions. As shown in <ref> [17] </ref>, T D accounts for many basic properties of "advanced" transaction models [39], including nested transactions. These properties include subtrans-action hierarchies, non-vital subtransactions, relative commit, and partial rollback. <p> balance (Acct; Bal) fails (e:g:, if Acct is not a valid account) or if the test Bal &gt; Amt fails (i:e:, if the balance is too small). 2 Example 2.2 is a canonical example of nested transactions, one that brings out several limitations of the classical (or "flat") transaction model <ref> [43, 64, 44, 39, 17] </ref>. First, the withdraw and deposit transactions are not independent. In particular, the failure of one implies the failure of the other, even if the other has completed its execution and committed. Second, we now need serializability within transactions, not just between them. <p> These possibilities are not supported by the classical transaction model. Further discussion of nested transactions, along with examples specified in T D can be found in <ref> [17] </ref>. 3 Examples of Workflow This section illustrates the procedural interpretation of (non-isolated) T D programs through a series of examples on workflow. As in other formalisms, there are a number of ways to represent workflow in T D. <p> As in other formalisms, there are a number of ways to represent workflow in T D. This section illustrates an approach that is especially simple. (Another approach is illustrated in the long version of <ref> [17] </ref>.) Each example has been tested on our prototype implementation [55, 72], and performs exactly as described below. 5 The examples focus on so-called production workflow, which forms the core of a business or enterprise [42, 60]. Production workflows are typically complex, well defined, high volume, and mission critical. <p> fcdg j= (del.a del.b) j (ins.c ins.d) Likewise, if P contains the two rules p del.a del.b and q ins.c ins.d, then P; fabg f g j= p P; f g fcdg j= q P; fabg fcdg j= p j q The formal semantics of these expressions is given in <ref> [17, 20] </ref>, and is reviewed in detail in Appendix A. Our results are based on a number of standard definitions, adapted from [3, 28]. A database schema is a finite set of base predicate symbols (with associated arities).
Reference: [18] <author> A.J. Bonner and M. Kifer. </author> <title> Transaction logic programming. </title> <booktitle> In Int'l Conference on Logic Programming, </booktitle> <pages> pages 257-282, </pages> <address> Budapest, Hungary, June 1993. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Related work on T D and CT R, a prototype implementation, and the results of benchmark tests are available at: http://www.cs.toronto.edu/~bonner/transaction-logic.html 2 Overview of Transaction Datalog Like classical logic programs, T D programs have both a declarative semantics and a procedural interpretation. These have been published in detail elsewhere <ref> [17, 20, 18] </ref>, and are reviewed in detail in Appendices A, B and C. This section provides a brief introduction, defining the syntax of T D and outlining its procedural interpretation. In this discussion, and the rest of the paper, we adopt the terminology of deductive databases.
Reference: [19] <author> A.J. Bonner and M. Kifer. </author> <title> Transaction logic programming (or a logic of declarative and procedural knowledge). </title> <type> Technical Report CSRI-323, </type> <institution> University of Toronto, </institution> <month> November </month> <year> 1995. </year> <note> http://www.cs.toronto.edu/~bonner/transaction-logic.html. </note>
Reference: [20] <author> A.J. Bonner and M. Kifer. </author> <title> Concurrency and communication in transaction logic. </title> <booktitle> In Joint Int'l Conference and Symposium on Logic Programming, </booktitle> <pages> pages 142-156, </pages> <address> Bonn, Germany, September 1996. </address> <publisher> MIT Press. </publisher>
Reference-contexts: These issues are addressed in Concurrent Transaction Logic (abbreviated CT R), which we developed in previous work <ref> [20, 13] </ref>. CT R is an extension of classical logic that seamlessly integrates concurrency and communication with queries and updates. It has a purely logical semantics, including a natural model theory and a sound-and-complete proof theory. <p> This framework also provides T D with transactional capabilities (such as atomicity and isolation), which are completely missing from other logic programming languages. The differences between T D and CLP are elaborated in <ref> [20] </ref>. Recently, Davulcu, Kifer et al have used T D and CT R to specify and reason about work-flows [34]. This research was the first attempt to apply CT R to workflow. <p> Related work on T D and CT R, a prototype implementation, and the results of benchmark tests are available at: http://www.cs.toronto.edu/~bonner/transaction-logic.html 2 Overview of Transaction Datalog Like classical logic programs, T D programs have both a declarative semantics and a procedural interpretation. These have been published in detail elsewhere <ref> [17, 20, 18] </ref>, and are reviewed in detail in Appendices A, B and C. This section provides a brief introduction, defining the syntax of T D and outlining its procedural interpretation. In this discussion, and the rest of the paper, we adopt the terminology of deductive databases. <p> In general, an elementary operation can be any activity that accesses a database, including activities that require human intervention (as in many workflows). Examples include simple database updates, complex application programs, and legacy systems. Semantically, an elementary operation is treated as a black box. This idea is formalized in <ref> [20] </ref>. In general, the complexity of a T D program depends on its elementary operations. However, we would like to factor out these operations in order to focus on the complexity of T D itself. For this reason, we base our complexity analysis on a small set of simple operations. <p> The formal semantics of these formulas is given in <ref> [20, 17] </ref>. Intuitively, the first two formulas are yes/no queries, and the last two formulas are updates. <p> Intuitively, the predicate workf low (W ) represents the flow of work for a single work item, W . Likewise, the predicate subf low (W ) represents the sub-workflow, and the predicate task i (W ) represents a workflow task. 5 A version of Example 3.4 originally appeared in <ref> [20] </ref>. <p> fcdg j= (del.a del.b) j (ins.c ins.d) Likewise, if P contains the two rules p del.a del.b and q ins.c ins.d, then P; fabg f g j= p P; f g fcdg j= q P; fabg fcdg j= p j q The formal semantics of these expressions is given in <ref> [17, 20] </ref>, and is reviewed in detail in Appendix A. Our results are based on a number of standard definitions, adapted from [3, 28]. A database schema is a finite set of base predicate symbols (with associated arities).
Reference: [21] <author> A.J. Bonner and M. Kifer. </author> <title> Results on reasoning about updates in transaction logic. </title> <booktitle> In [41]. </booktitle> <year> 1998. </year>
Reference: [22] <author> A.J. Bonner, M. Kifer, and M. Consens. </author> <title> Database programming in transaction logic. </title> <editor> In A. Ohori C. Beeri and D.E. Shasha, editors, </editor> <booktitle> Proceedings of the International Workshop on Database Programming Languages, Workshops in Computing, </booktitle> <pages> pages 309-337. </pages> <publisher> Springer-Verlag, </publisher> <month> February </month> <year> 1994. </year> <booktitle> Workshop held on Aug 30-Sept 1, 1993, </booktitle> <address> New York City, NY. REFERENCES 19 </address>
Reference: [23] <author> A.J. Bonner, L.T. McCarty, and K. Vadaparty. </author> <title> Expressing Database Queries with Intuitionistic Logic. </title> <booktitle> In North American Conference on Logic Programming, </booktitle> <pages> pages 831-850, </pages> <address> Cleveland, Ohio, October 16-20 1989. </address> <publisher> MIT Press. </publisher>
Reference-contexts: In particular, it is a safe language that does not generate an unbounded number of tuples during transaction execution. In contrast, other transaction languages achieve RE-completeness by expanding the data domain during transaction execution <ref> [2, 3, 23] </ref>, or by expanding the database schema [28]. Typically, to prove RE-completeness, the tape of a Turing machine is encoded as a database, and the finite control is encoded as a database program. In such approaches, database queries simulate tape reads, and database updates simulate tape writes.
Reference: [24] <author> A.J. Bonner, A. Shrufi, and S. Rozen. </author> <title> Benchmarking object-oriented DBMSs for workflow management. In OOPSLA Workshop on Object Database Behavior, Benchmarks, and Performance, </title> <address> Austin, TX, </address> <month> October 15 </month> <year> 1995. </year>
Reference-contexts: The workflows at the Genome Center are data intensive. In fact, as laboratory automation increased, database performance became a bottleneck in workflow throughput, and we had to develop a workflow/database benchmark to evaluate new storage managers for their laboratory information system <ref> [26, 24, 25] </ref>. To make the examples in this paper more concrete, we shall sometimes describe them in terms of genome laboratory workflow. Example 3.1 (Workflow Specification) The rules below define a simple workflow made up of a collection of tasks and a sub-workflow.
Reference: [25] <author> A.J. Bonner, A. Shrufi, and S. Rozen. </author> <title> Database requirements for workflow management in a high-throughput genome laboratory. </title> <booktitle> In NSF Workshop on Workflow and Process Automation in Information Systems: State-of-the-Art and Future Directions, </booktitle> <pages> pages 119-125, </pages> <address> Athens, GA, </address> <month> May 8-10 </month> <year> 1996. </year>
Reference-contexts: Examples of work items include insurance claims, loan applications, and laboratory samples. Because they process large numbers of work items, production workflows are often data intensive. A concrete example is the laboratory workflows used at the Whitehead Institute/MIT Center for Genome Research <ref> [25, 26, 73] </ref>, which is engaged in several large-scale genome mapping and sequencing projects [33]. Each project involves the completion of tens of millions of experiments, organized into a network of factory-like production lines. <p> Coordinating the flow of materials through the production lines, and recording and querying the history of experimental steps and the results they produce are the main data and workflow management requirements <ref> [25] </ref>. The workflows at the Genome Center are data intensive. In fact, as laboratory automation increased, database performance became a bottleneck in workflow throughput, and we had to develop a workflow/database benchmark to evaluate new storage managers for their laboratory information system [26, 24, 25]. <p> The workflows at the Genome Center are data intensive. In fact, as laboratory automation increased, database performance became a bottleneck in workflow throughput, and we had to develop a workflow/database benchmark to evaluate new storage managers for their laboratory information system <ref> [26, 24, 25] </ref>. To make the examples in this paper more concrete, we shall sometimes describe them in terms of genome laboratory workflow. Example 3.1 (Workflow Specification) The rules below define a simple workflow made up of a collection of tasks and a sub-workflow. <p> This is a natural set of operations for many scientific workflows, where workflow activities are laboratory experiments that gather, store and analyze information [6]. This is certainly the case for workflows at the Whitehead Institute/MIT Center for Genome Research <ref> [25, 73] </ref>, where experimental results are accumulated in the database, and queried by analysis programs, but never deleted or altered.
Reference: [26] <author> A.J. Bonner, A. Shrufi, and S. Rozen. LabFlow-1: </author> <title> a database benchmark for high-throughput workflow management. </title> <booktitle> In Int'l Conference on Extending Database Technology, number 1057 in LNCS, </booktitle> <pages> pages 463-478, </pages> <address> Avignon, France, </address> <month> March 25-29 </month> <year> 1996. </year> <note> Springer-Verlag. Full technical report available at http://www-genome.wi.mit.edu/informatics/ informatics papers/bibliography.html. </note>
Reference-contexts: Examples of work items include insurance claims, loan applications, and laboratory samples. Because they process large numbers of work items, production workflows are often data intensive. A concrete example is the laboratory workflows used at the Whitehead Institute/MIT Center for Genome Research <ref> [25, 26, 73] </ref>, which is engaged in several large-scale genome mapping and sequencing projects [33]. Each project involves the completion of tens of millions of experiments, organized into a network of factory-like production lines. <p> The workflows at the Genome Center are data intensive. In fact, as laboratory automation increased, database performance became a bottleneck in workflow throughput, and we had to develop a workflow/database benchmark to evaluate new storage managers for their laboratory information system <ref> [26, 24, 25] </ref>. To make the examples in this paper more concrete, we shall sometimes describe them in terms of genome laboratory workflow. Example 3.1 (Workflow Specification) The rules below define a simple workflow made up of a collection of tasks and a sub-workflow. <p> The next example shows one way of doing this. The example also suggests how to keep track of work that has been performed. This allows for monitoring, tracking and querying the status of workflow activities, another important aspect of workflow management <ref> [36, 42, 26] </ref>. Example 3.3 (Shared Resources) The rules below refine the predicate task i (W ) used in Example 3.1, to account for the resources needed to execute the task. In this case, the resources are qualified agents. <p> Since the parts are related, the workflows may have dependencies between them. Typically, one workflow needs information produced by another workflow, and may have to wait for this information to become available before it can continue. This is the case, for instance, in the workflow described in <ref> [26] </ref>, in which the work items are DNA samples, and the purpose of the workflow is to construct a physical genome map. 7 7 This particular workflow consists of two concurrent sub-workflows that synchronize themselves at several points. <p> Tail recursion allows these workflows to be iterated. That is, they can be executed over-and-over again until some condition is satisfied. For instance, in a scientific laboratory, an experimental protocol may be repeated until a conclusive result is achieved. This is the case for the genome workflow described in <ref> [26] </ref>. Note that sequential tail recursion allows processes to be created and destroyed at runtime, but only inside . In particular, the number of processes does not grow with each recursive call, as in the simulation of Example 3.2.
Reference: [27] <author> O. Bukhres and E. Kueshn, Eds. </author> <title> Special issue on software support for workflow management. </title> <journal> Distributed and Parallel Databases|An International Journal, </journal> <volume> 3(2), </volume> <month> April </month> <year> 1995. </year>
Reference: [28] <author> A.K. Chandra and D. Harel. </author> <title> Computable queries for relational databases. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 21(2) </volume> <pages> 156-178, </pages> <year> 1980. </year>
Reference-contexts: Our results are based on a number of standard definitions, adapted from <ref> [3, 28] </ref>. A database schema is a finite set of base predicate symbols (with associated arities). A database with schema S is a finite set of ground atoms constructed from the predicate symbols in S. <p> In particular, it is a safe language that does not generate an unbounded number of tuples during transaction execution. In contrast, other transaction languages achieve RE-completeness by expanding the data domain during transaction execution [2, 3, 23], or by expanding the database schema <ref> [28] </ref>. Typically, to prove RE-completeness, the tape of a Turing machine is encoded as a database, and the finite control is encoded as a database program. In such approaches, database queries simulate tape reads, and database updates simulate tape writes.
Reference: [29] <author> A.K. Chandra and D. Harel. </author> <title> Structure and complexity of relational queries. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 25(1) </volume> <pages> 99-128, </pages> <year> 1982. </year>
Reference-contexts: The result is that T D achieves RE-completeness with a fixed data domain, and a fixed database schema, and thus with databases of polynomial size. This demonstrates a fundamental difference between T D and other safe transaction languages, which are typically PSPACE-complete <ref> [2, 3, 1, 29] </ref>. This encoding of Turing machines in T D has some resemblance to the encoding of Turing machines in process algebras such as CCS [74]. <p> Concurrency is essential to the power of T D. As Theorem 4.5 shows, when concurrent composition is removed, the data complexity of T D plummets from RE to EXPTIME. This version of the language, which we call sequential T D, is comparable to safe transaction languages <ref> [2, 3, 1, 29] </ref>. The main difference is that such languages are typically complete for PSPACE, not EXPTIME. The extra power of sequential T D comes froms an ability to simulate alternating PSPACE machines [30].
Reference: [30] <author> A.K. Chandra, D. Kozen, and L.J. Stockmeyer. </author> <title> Alternation. </title> <journal> Journal of ACM, </journal> <volume> 28 </volume> <pages> 114-133, </pages> <year> 1981. </year>
Reference-contexts: The main difference is that such languages are typically complete for PSPACE, not EXPTIME. The extra power of sequential T D comes froms an ability to simulate alternating PSPACE machines <ref> [30] </ref>. As shown in Appendix G, the ability to alternate comes from the combination of recursive subroutines and sequential compostion. Other transaction languages typically have one of these features, but not both. Theorem 4.5 Sequential T D is data complete for EXPTIME.
Reference: [31] <author> S. Christensen, Y. Hirshfeld, and F. Moller. </author> <title> Decidable subsets of CCS. </title> <journal> The Computer Journal, </journal> <volume> 37(4) </volume> <pages> 233-242, </pages> <year> 1994. </year> <note> Special issue on process algebra. </note>
Reference-contexts: This encoding of Turing machines in T D has some resemblance to the encoding of Turing machines in process algebras such as CCS [74]. However, in CCS, the simulation relies heavily on the restriction operator <ref> [74, 31] </ref>, which allows a CCS program to create an unbounded number of new (private) communication channels during execution. Since T D is built around databases, not communication channels, restriction is not a primitive operation in T D.
Reference: [32] <author> Edmund M. Clarke, E. Allen Emerson, and A. Prasad Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> In ACM Transactions on Programming Languages and Systems (TOPLAS), </journal> <pages> pages 244-263, </pages> <year> 1986. </year>
Reference: [33] <institution> Communications of ACM, </institution> <month> 34(11), November </month> <year> 1991. </year> <title> Special issue on the Human Genome Project. </title>
Reference-contexts: Because they process large numbers of work items, production workflows are often data intensive. A concrete example is the laboratory workflows used at the Whitehead Institute/MIT Center for Genome Research [25, 26, 73], which is engaged in several large-scale genome mapping and sequencing projects <ref> [33] </ref>. Each project involves the completion of tens of millions of experiments, organized into a network of factory-like production lines.
Reference: [34] <author> H. Davulcu, M. Kifer, C.R. Ramakrishnan, and I.V. Ramakrishnan. </author> <title> Logic based modeling and analysis of workflows. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 25-33, </pages> <address> Seattle, Washington, </address> <month> June </month> <year> 1998. </year>
Reference-contexts: The differences between T D and CLP are elaborated in [20]. Recently, Davulcu, Kifer et al have used T D and CT R to specify and reason about work-flows <ref> [34] </ref>. This research was the first attempt to apply CT R to workflow. It focussed on compiling global constraints (specified in CT R) into workflow graphs (specified in T D), and established results on consistency and verification.
Reference: [35] <author> U. Dayal and Q. Chen. </author> <title> From database programming to business process programming. </title> <booktitle> In Proceedings of the International Workshop on Database Programming Languages, </booktitle> <address> Gubbio, Umbria, Italy, </address> <month> September </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference: [36] <author> U. Dayal, H. Garcia-Molina, M. Hsu, B. Kao, and M.-C. Shan. </author> <title> Third generation TP monitors: A database challenge. </title> <booktitle> In ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 393-397, </pages> <address> Washington, DD, </address> <month> May </month> <year> 1993. </year> <note> REFERENCES 20 </note>
Reference-contexts: The next example shows one way of doing this. The example also suggests how to keep track of work that has been performed. This allows for monitoring, tracking and querying the status of workflow activities, another important aspect of workflow management <ref> [36, 42, 26] </ref>. Example 3.3 (Shared Resources) The rules below refine the predicate task i (W ) used in Example 3.1, to account for the resources needed to execute the task. In this case, the resources are qualified agents.
Reference: [37] <author> J. Desel. </author> <title> Free Choice Petri Nets. </title> <publisher> Cambridge University Press, </publisher> <year> 1995. </year>
Reference: [38] <author> D. Drusinsky and D. Harel. </author> <title> On the power of bounded concurrency i: Finite automata. </title> <journal> Journal of ACM, </journal> <volume> 41(3) </volume> <pages> 517-539, </pages> <year> 1994. </year>
Reference-contexts: 1 INTRODUCTION 3 element of workflow <ref> [38, 50, 61, 62, 51] </ref>. 2 In concurrent programming languages, cooperative concurrency is not a primitive modelling feature, but is the result of combining several more-basic features. In T D, this includes process-oriented features such as sequential and concurrent composition, as well as data-oriented features such as queries and updates.
Reference: [39] <editor> A.K. Elmagarmid, editor. </editor> <title> Database Transaction Models for Advanced Applications. </title> <publisher> Morgan-Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1992. </year>
Reference-contexts: Using b as the parameter value, r (b) commits if p (b) is in the database at the start of execution. Advanced Transactions. As shown in [17], T D accounts for many basic properties of "advanced" transaction models <ref> [39] </ref>, including nested transactions. These properties include subtrans-action hierarchies, non-vital subtransactions, relative commit, and partial rollback. <p> balance (Acct; Bal) fails (e:g:, if Acct is not a valid account) or if the test Bal &gt; Amt fails (i:e:, if the balance is too small). 2 Example 2.2 is a canonical example of nested transactions, one that brings out several limitations of the classical (or "flat") transaction model <ref> [43, 64, 44, 39, 17] </ref>. First, the withdraw and deposit transactions are not independent. In particular, the failure of one implies the failure of the other, even if the other has completed its execution and committed. Second, we now need serializability within transactions, not just between them.
Reference: [40] <author> E.A. Emerson. </author> <title> Temporal and modal logic. </title> <booktitle> In Handbook of Theoretical Computer Science, </booktitle> <pages> pages 997-1072. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference: [41] <author> B. Freitag, H. Decker, M. Kifer, and A. Voronkov, </author> <title> editors. Transactions and Change in Logic Databases. </title> <booktitle> Number 1472 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1998. </year> <note> In press. </note>
Reference: [42] <author> D. Georgakopoulos, M. Hornick, and A. Sheth. </author> <title> An overview of workflow management: From process modeling to infrastructure for automation. </title> <journal> Journal on Distributed and Parallel Database Systems, </journal> <volume> 3(2) </volume> <pages> 119-153, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: an approach that is especially simple. (Another approach is illustrated in the long version of [17].) Each example has been tested on our prototype implementation [55, 72], and performs exactly as described below. 5 The examples focus on so-called production workflow, which forms the core of a business or enterprise <ref> [42, 60] </ref>. Production workflows are typically complex, well defined, high volume, and mission critical. Many production workflows are organized around work items of some kind, which the workflow activities operate on. Examples of work items include insurance claims, loan applications, and laboratory samples. <p> Typically, each task in a workflow is performed by an "agent," (e:g:, a machine or a person), only a fixed number of agents is available, and only qualified agents can be assigned to each task <ref> [42] </ref>. In effect, the agents are resources that must be shared by the various workflow instances, thus limiting the number of instances that can be active at one time. For this reason, an important part of workflow specification is assigning agents to tasks [42]. <p> agents can be assigned to each task <ref> [42] </ref>. In effect, the agents are resources that must be shared by the various workflow instances, thus limiting the number of instances that can be active at one time. For this reason, an important part of workflow specification is assigning agents to tasks [42]. This is easily accomplished in a language like T D that integrates databases and processes, since we can record the status of agents in the database, and update them as the workflow progresses. The next example shows one way of doing this. <p> The next example shows one way of doing this. The example also suggests how to keep track of work that has been performed. This allows for monitoring, tracking and querying the status of workflow activities, another important aspect of workflow management <ref> [36, 42, 26] </ref>. Example 3.3 (Shared Resources) The rules below refine the predicate task i (W ) used in Example 3.1, to account for the resources needed to execute the task. In this case, the resources are qualified agents.
Reference: [43] <author> J. Gray. </author> <title> The transaction concept: Virtues and limitations. </title> <booktitle> In Int'l Conference on Very Large Data Bases, </booktitle> <pages> pages 144-154, </pages> <address> Cannes, France, </address> <month> September </month> <year> 1981. </year>
Reference-contexts: balance (Acct; Bal) fails (e:g:, if Acct is not a valid account) or if the test Bal &gt; Amt fails (i:e:, if the balance is too small). 2 Example 2.2 is a canonical example of nested transactions, one that brings out several limitations of the classical (or "flat") transaction model <ref> [43, 64, 44, 39, 17] </ref>. First, the withdraw and deposit transactions are not independent. In particular, the failure of one implies the failure of the other, even if the other has completed its execution and committed. Second, we now need serializability within transactions, not just between them.
Reference: [44] <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1993. </year>
Reference-contexts: Isolation is a fundamental property of database transactions <ref> [12, 44] </ref>, and is closely related to serial-izability. For instance, if t 1 , t 2 , ..., t n are database programs, then the goal fit 1 j fit 2 j j fit n executes them serializably. <p> balance (Acct; Bal) fails (e:g:, if Acct is not a valid account) or if the test Bal &gt; Amt fails (i:e:, if the balance is too small). 2 Example 2.2 is a canonical example of nested transactions, one that brings out several limitations of the classical (or "flat") transaction model <ref> [43, 64, 44, 39, 17] </ref>. First, the withdraw and deposit transactions are not independent. In particular, the failure of one implies the failure of the other, even if the other has completed its execution and committed. Second, we now need serializability within transactions, not just between them.
Reference: [45] <author> D. Harel. "StateCharts: </author> <title> A Visual Formalism for Complex Systems". </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 231-274, </pages> <year> 1987. </year>
Reference-contexts: In this light, our syntactic restrictions are very effective at keeping complexity down. Other Related Work: The database-theory community has recently begun to study business processes and workflow. For instance, Wodtke and Weikum have used state charts <ref> [45] </ref> to develop a formal foundation for workflow execution in a distributed environment [75]. The goal of this research is to partition a workflow (at compile time) into "orthogonal" components that can be executed on different servers in a distributed environment.
Reference: [46] <author> D. Harel. </author> <title> A thesis for bounded concurrency. </title> <booktitle> In Proceedings of the 14th Symposium on Mathematical Foundations of Computer Science, number 379 in Lecture Notes in Computer Science, </booktitle> <pages> pages 35-48. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: For instance, like T D, most process algebras can simulate arbitrary Turing machines [74]. Moreover, Harel has shown that cooperative concurrency increases the complexity of many problems by an exponential, even when the number of processes is carefully bounded <ref> [47, 48, 46] </ref>. Thus, since safe transaction languages are typically PSPACE-complete, one might expect that adding a bounded number of concurrent processes would increase their complexity to EXPSPACE. In this light, our syntactic restrictions are very effective at keeping complexity down.
Reference: [47] <author> D. Harel, O. Kupferman, and M.Y. Vardi. </author> <title> On the complexity of verifying concurrent transition systems. </title> <type> Technical Report CS97-01, </type> <institution> Faculty of Mathematical Sciences, The Weizmann Institute of Science, Rehovot, Israel, </institution> <year> 1997. </year>
Reference-contexts: For instance, like T D, most process algebras can simulate arbitrary Turing machines [74]. Moreover, Harel has shown that cooperative concurrency increases the complexity of many problems by an exponential, even when the number of processes is carefully bounded <ref> [47, 48, 46] </ref>. Thus, since safe transaction languages are typically PSPACE-complete, one might expect that adding a bounded number of concurrent processes would increase their complexity to EXPSPACE. In this light, our syntactic restrictions are very effective at keeping complexity down.
Reference: [48] <author> D. Harel, R. Rosner, and M. Vardi. </author> <title> On the power of bounded concurrency iii: Reasoning about programs. </title> <booktitle> In Int'l Symposium on Logic in Computer Science, </booktitle> <pages> pages 478-488. </pages> <publisher> IEEE Press, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: For instance, like T D, most process algebras can simulate arbitrary Turing machines [74]. Moreover, Harel has shown that cooperative concurrency increases the complexity of many problems by an exponential, even when the number of processes is carefully bounded <ref> [47, 48, 46] </ref>. Thus, since safe transaction languages are typically PSPACE-complete, one might expect that adding a bounded number of concurrent processes would increase their complexity to EXPSPACE. In this light, our syntactic restrictions are very effective at keeping complexity down.
Reference: [49] <author> M. Hennessy. </author> <title> An Algebraic Theory of Processes. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1988. </year>
Reference: [50] <author> T. Hirst and D. Harel. </author> <title> On the power of bounded concurrency ii: Pushdown automata. </title> <journal> Journal of ACM, </journal> <volume> 41(3) </volume> <pages> 540-554, </pages> <year> 1994. </year>
Reference-contexts: 1 INTRODUCTION 3 element of workflow <ref> [38, 50, 61, 62, 51] </ref>. 2 In concurrent programming languages, cooperative concurrency is not a primitive modelling feature, but is the result of combining several more-basic features. In T D, this includes process-oriented features such as sequential and concurrent composition, as well as data-oriented features such as queries and updates.
Reference: [51] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1985. </year>
Reference-contexts: 1 INTRODUCTION 3 element of workflow <ref> [38, 50, 61, 62, 51] </ref>. 2 In concurrent programming languages, cooperative concurrency is not a primitive modelling feature, but is the result of combining several more-basic features. In T D, this includes process-oriented features such as sequential and concurrent composition, as well as data-oriented features such as queries and updates. <p> In this case, the environment provides the workflow with new work items. As is commonly done in process algebras <ref> [62, 51] </ref>, we can treat the environment simply as another process (possibly nondeterministic). That is, instead of executing the goal simulate in Example 3.2, we can execute the goal simulate j environment, where environment is a process that inserts new work items into the database.
Reference: [52] <author> J.E. Hopcroft and J.D. Ullman. </author> <title> Introduction to Automata Theory, Languages and Computation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1979. </year>
Reference-contexts: This means that RE-completeness can be achieved by three sequential processes executing concurrently. In the proof, these three processes are used to simulate a 2-stack machine <ref> [52] </ref>, where two of the processes encode the stacks, and the third process encodes the finite control. We therefore have the following result. Corollary 4.6 T D programs with sequential rulebases are data complete for RE. 8 This is a common phenomenon in logical languages.
Reference: [53] <institution> Special issue on workflow and extended transaction systems. Bulletin of the Technical Committee on Data Engineering (IEEE Computer Society), </institution> <month> 16(2), June </month> <year> 1993. </year> <note> REFERENCES 21 </note>
Reference: [54] <institution> Special issue on workflow systems. Bulletin of the Technical Committee on Data Engineering (IEEE Computer Society), </institution> <month> 18(1), March </month> <year> 1995. </year>
Reference: [55] <author> Samuel Y.K. Hung. </author> <title> Implementation and Performance of Transaction Logic in Prolog. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Toronto, </institution> <year> 1996. </year>
Reference-contexts: As in other formalisms, there are a number of ways to represent workflow in T D. This section illustrates an approach that is especially simple. (Another approach is illustrated in the long version of [17].) Each example has been tested on our prototype implementation <ref> [55, 72] </ref>, and performs exactly as described below. 5 The examples focus on so-called production workflow, which forms the core of a business or enterprise [42, 60]. Production workflows are typically complex, well defined, high volume, and mission critical.
Reference: [56] <editor> S. Jajodia and L. Kerschberg, editors. </editor> <title> Advanced Transaction Models and Architectures. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1997. </year>
Reference: [57] <author> K. Jensen. </author> <title> Colored Petri Nets. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1996. </year>
Reference: [58] <author> K. Jensen and G. Rozenberg, </author> <title> editors. High Level Petri Nets. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference: [59] <author> N.D. Jones, L.H. Landweber, and Y.E. Lien. </author> <title> Complexity of some problems in Petri nets. </title> <journal> Theoretical Computer Science, </journal> <volume> 4 </volume> <pages> 277-299, </pages> <year> 1977. </year>
Reference: [60] <author> Setrag Khoshafian and Marek Buckiewicz. </author> <title> Introduction to Groupware, Workflow, and Workgroup Computing. </title> <publisher> John Wiley & Sons, Inc., </publisher> <year> 1995. </year>
Reference-contexts: an approach that is especially simple. (Another approach is illustrated in the long version of [17].) Each example has been tested on our prototype implementation [55, 72], and performs exactly as described below. 5 The examples focus on so-called production workflow, which forms the core of a business or enterprise <ref> [42, 60] </ref>. Production workflows are typically complex, well defined, high volume, and mission critical. Many production workflows are organized around work items of some kind, which the workflow activities operate on. Examples of work items include insurance claims, loan applications, and laboratory samples.
Reference: [61] <author> R.P. Kurshan. </author> <title> Computer Aided Verification of Coordinating Processes. </title> <publisher> Princeton University Press, </publisher> <year> 1994. </year>
Reference-contexts: 1 INTRODUCTION 3 element of workflow <ref> [38, 50, 61, 62, 51] </ref>. 2 In concurrent programming languages, cooperative concurrency is not a primitive modelling feature, but is the result of combining several more-basic features. In T D, this includes process-oriented features such as sequential and concurrent composition, as well as data-oriented features such as queries and updates.
Reference: [62] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: 1 INTRODUCTION 3 element of workflow <ref> [38, 50, 61, 62, 51] </ref>. 2 In concurrent programming languages, cooperative concurrency is not a primitive modelling feature, but is the result of combining several more-basic features. In T D, this includes process-oriented features such as sequential and concurrent composition, as well as data-oriented features such as queries and updates. <p> In this case, the environment provides the workflow with new work items. As is commonly done in process algebras <ref> [62, 51] </ref>, we can treat the environment simply as another process (possibly nondeterministic). That is, instead of executing the goal simulate in Example 3.2, we can execute the goal simulate j environment, where environment is a process that inserts new work items into the database.
Reference: [63] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes, I. </title> <journal> Information and Computation, </journal> <volume> 100(1) </volume> <pages> 1-40, </pages> <month> September </month> <year> 1992. </year>
Reference: [64] <author> J. E. B. Moss. </author> <title> Nested Transactions: An Approach to Reliable Distributed Computing. </title> <booktitle> Series in Information Systems. </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1985. </year>
Reference-contexts: balance (Acct; Bal) fails (e:g:, if Acct is not a valid account) or if the test Bal &gt; Amt fails (i:e:, if the balance is too small). 2 Example 2.2 is a canonical example of nested transactions, one that brings out several limitations of the classical (or "flat") transaction model <ref> [43, 64, 44, 39, 17] </ref>. First, the withdraw and deposit transactions are not independent. In particular, the failure of one implies the failure of the other, even if the other has completed its execution and committed. Second, we now need serializability within transactions, not just between them.
Reference: [65] <author> W.F. Ogden, W.E. Riddle, and W.C. </author> <title> Rounds. Complexity of expressions allowing concurrency. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 185-194, </pages> <year> 1978. </year>
Reference: [66] <author> C.H. Papadimitriou. </author> <title> Computational Complexity. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: As another example, the goal fi [p (b) del.p (b)] represents a transaction program with a precondition, p (b). This program first asks if p (b) is in the database, 3 Another approach would be to prove relativized complexity results <ref> [66, 9] </ref> with elementary operations modeled by a variation of oracle Turing machines. All of the results in this paper can be relativized in this way, although additional formal machinery is required.
Reference: [67] <author> W. Reisig. </author> <title> Petri Nets: An Introduction. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference: [68] <author> M. Rusinkiewicz and A. Sheth. </author> <title> Specification and execution of transactional workflows. </title> <editor> In W. Kim, editor, </editor> <title> Modern Database Systems: The Object Model, Interoperability, and Beyond. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference: [69] <author> K. Sagonas, T. Swift, and D.S. Warren. </author> <title> XSB as an efficient deductive database engine. </title> <booktitle> In ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 442-453, </pages> <address> New York, </address> <month> May </month> <year> 1994. </year> <note> ACM. </note>
Reference: [70] <author> E. Shapiro, </author> <title> editor. Concurrent Prolog, volume 1. </title> <publisher> MIT press, </publisher> <address> Cambridge, MA, </address> <year> 1987. </year>
Reference-contexts: Unlike most workflow languages, T D is a logical language with a least-fixpoint semantics in the tradition of classical Datalog. Because of its logical basis, T D has some similarity to languages for concurrent logic programming (CLP) <ref> [71, 70] </ref>. A key difference is that most process modeling in CLP is purely operational, and is not accounted for by the classical Horn semantics of logic programs. This is especially true for CLP programs with updates, for which the classical semantics is wholly inadequate.
Reference: [71] <author> E. Shapiro. </author> <title> A family of concurrent logic programming languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3), </volume> <year> 1989. </year>
Reference-contexts: Unlike most workflow languages, T D is a logical language with a least-fixpoint semantics in the tradition of classical Datalog. Because of its logical basis, T D has some similarity to languages for concurrent logic programming (CLP) <ref> [71, 70] </ref>. A key difference is that most process modeling in CLP is purely operational, and is not accounted for by the classical Horn semantics of logic programs. This is especially true for CLP programs with updates, for which the classical semantics is wholly inadequate.
Reference: [72] <author> Amalia Sleghel. </author> <title> Implementation of Concurrent Transaction Logic. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Toronto. </institution> <note> In preparation. REFERENCES 22 </note>
Reference-contexts: As in other formalisms, there are a number of ways to represent workflow in T D. This section illustrates an approach that is especially simple. (Another approach is illustrated in the long version of [17].) Each example has been tested on our prototype implementation <ref> [55, 72] </ref>, and performs exactly as described below. 5 The examples focus on so-called production workflow, which forms the core of a business or enterprise [42, 60]. Production workflows are typically complex, well defined, high volume, and mission critical.
Reference: [73] <author> L. Stein, S. Rozen, and N. Goodman. </author> <title> Managing laboratory workflow with LabBase. </title> <booktitle> In Proceedings of the 1994 Conference on Computers in Medicine (CompMed94). </booktitle> <publisher> World Scientific Publishing Company, </publisher> <year> 1995. </year>
Reference-contexts: Examples of work items include insurance claims, loan applications, and laboratory samples. Because they process large numbers of work items, production workflows are often data intensive. A concrete example is the laboratory workflows used at the Whitehead Institute/MIT Center for Genome Research <ref> [25, 26, 73] </ref>, which is engaged in several large-scale genome mapping and sequencing projects [33]. Each project involves the completion of tens of millions of experiments, organized into a network of factory-like production lines. <p> This is a natural set of operations for many scientific workflows, where workflow activities are laboratory experiments that gather, store and analyze information [6]. This is certainly the case for workflows at the Whitehead Institute/MIT Center for Genome Research <ref> [25, 73] </ref>, where experimental results are accumulated in the database, and queried by analysis programs, but never deleted or altered.
Reference: [74] <author> D. Taubner. </author> <title> Finite Representations of CCS and TCSP Programs by Automata and Petri Nets. </title> <booktitle> Number 369 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: In general, our complexity results are in line with and improve upon related work in the literature. For instance, like T D, most process algebras can simulate arbitrary Turing machines <ref> [74] </ref>. Moreover, Harel has shown that cooperative concurrency increases the complexity of many problems by an exponential, even when the number of processes is carefully bounded [47, 48, 46]. <p> This demonstrates a fundamental difference between T D and other safe transaction languages, which are typically PSPACE-complete [2, 3, 1, 29]. This encoding of Turing machines in T D has some resemblance to the encoding of Turing machines in process algebras such as CCS <ref> [74] </ref>. However, in CCS, the simulation relies heavily on the restriction operator [74, 31], which allows a CCS program to create an unbounded number of new (private) communication channels during execution. Since T D is built around databases, not communication channels, restriction is not a primitive operation in T D. <p> This encoding of Turing machines in T D has some resemblance to the encoding of Turing machines in process algebras such as CCS [74]. However, in CCS, the simulation relies heavily on the restriction operator <ref> [74, 31] </ref>, which allows a CCS program to create an unbounded number of new (private) communication channels during execution. Since T D is built around databases, not communication channels, restriction is not a primitive operation in T D.
Reference: [75] <author> Dirk Wodtke and Gerhard Weikum. </author> <title> A formal foundation for distributed workflow execution based on state charts. </title> <booktitle> In Int'l Conference on Database Theory, </booktitle> <pages> pages 230-246, </pages> <year> 1997. </year>
Reference-contexts: Other Related Work: The database-theory community has recently begun to study business processes and workflow. For instance, Wodtke and Weikum have used state charts [45] to develop a formal foundation for workflow execution in a distributed environment <ref> [75] </ref>. The goal of this research is to partition a workflow (at compile time) into "orthogonal" components that can be executed on different servers in a distributed environment. To simplify the problem, nested states (i:e:, sub-workflows) are not considered. This work is clearly orthogonal to our own.
Reference: [76] <author> D. Worah and A. Sheth. </author> <title> Transactions in transactional workflows. </title> <booktitle> In [56], chapter 1, </booktitle> <pages> pages 3-45. </pages> <publisher> Kluwer Academic Publishers, </publisher> <year> 1997. </year>
References-found: 76

