URL: ftp://ftp.csd.uu.se/pub/papers/reports/0098.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Email: e-mail: fbjornc,sammyg@csd.uu.se  
Phone: +46-18-18 25 00  
Title: A concurrent simulator for plan-driven troops Editors  Project managers:  
Author: Bjorn Carlson and Samuel Tronje Bjorn Carlson and Samuel Tronje Martin Argenius Calle Bergman Daniel Blomqvist Arne Boralv Alexander Bottema Hugo Calendar Massih Enayatollah Anna Erikson Pekka Hedqvist Gustaf Holmkvist Key Hyckenberg Magnus Ingelbo Anders Johansson Per Jonsson Niklas Kaltea Martin Klint Anders Lindgren Terje Lundin Par Mattsson Nils Meinhard Greger Ottosson Olle Pellijeff Kristina Sirhuber Johan Vestermark Martin Wikborg Herman -Agren Peter Ohman 
Address: Box 311, S-751 05 Uppsala, Sweden  
Affiliation: Computing Science Department, Uppsala University  
Note: Sim94  
Abstract: UPMAIL Technical Report 98 February 15, 1995 ISSN 0283-359X 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> DIS Operational Concept 2.3, </institution> <address> IST-93-25. Orlando, FL, </address> <year> 1993. </year>
Reference-contexts: In a war-gaming simulation there can be infantry-, tank- and artillery-agents, which differ mainly in fire power and movement. There can also be agents representing officers at different levels with different decision mechanisms. Integration with other simulators, e.g. a tank simulator communicating via a DIS (Distributed Interactive Simulation) <ref> [1] </ref> protocol, only needs a special type of agent as an advanced gateway for bidirectional information relay. <p> Their output values consist of their mapping values. See figure 4.7 for an example. The map file After parsing the conversion file the program parses the map file, given as output from grass (see Figure 4.1), and convert it. This is done by 37 terrain_type <ref> [1] </ref> = 3 terrain_type [2] = 2; terrain_type [3] = 1; terrain_type [4] = 0; terrain_type [5] = 4; terrain_type [6] = 2; a c-program for the first six rows of the file (since these will always look the same), then both by flex and c for the rest of the
Reference: [2] <institution> The GNU C Library Reerence Manual. </institution>
Reference-contexts: Their output values consist of their mapping values. See figure 4.7 for an example. The map file After parsing the conversion file the program parses the map file, given as output from grass (see Figure 4.1), and convert it. This is done by 37 terrain_type [1] = 3 terrain_type <ref> [2] </ref> = 2; terrain_type [3] = 1; terrain_type [4] = 0; terrain_type [5] = 4; terrain_type [6] = 2; a c-program for the first six rows of the file (since these will always look the same), then both by flex and c for the rest of the numbers (the actual map). <p> When the system has been initiated, it can be viewed as a server which players can connect and disconnect to as they like. All connections are made by the Master module via an UNIX socket <ref> [2] </ref>. During a running simulation, the Master performs requests from processes in the system, and from clients logged on. These requests are creation/deletion of processes, saving/loading of a simulation state and information about what the system looks like. <p> Distributed applications are often written using a library of network access functions, which access the network in a controlled manner. The Berkeley 4.2 BSD UNIX socket <ref> [2] </ref> interface is one example of such network functions. We used Erlang 's built-in socket interface for UNIX sockets. Logging on to the simulation means setting up a connection to the simulation servers' socket, over TCP/IP [13]. TCP provides a reliable flow- controlled, two-way transmission of data. <p> Authority check Clients that log on to the system are checked for authority. Clients can be of two types, either a Supervisor, or a player, named after his nationality in the simulation. One authority process monitors passwords for users trying to log in. The process uses the UNIX crypt <ref> [2] </ref> command to store the passwords (somewhat) secretly. The authority check consults a file containing encrypted pairs of name and password.
Reference: [3] <institution> Grona kartan 1:50 000, </institution> <note> version t5. Lantmateriet, GIS-centrum. </note>
Reference-contexts: terrain type in a square or a whole area, with or without removing all roads and waters. * Set or unset an area to be "forbidden". * Insert a road or water between two points. 34 4.4 Implementation outline Before the simulation we convert the original map, in t5 format <ref> [3] </ref>, into our internal representation. The conversion is done by first using grass and a file Initfile for converting the raster and vector files into ascii format. Then the terrain types in the ascii files are changed as to fit the terrain types that we use presently. <p> See figure 4.7 for an example. The map file After parsing the conversion file the program parses the map file, given as output from grass (see Figure 4.1), and convert it. This is done by 37 terrain_type [1] = 3 terrain_type [2] = 2; terrain_type <ref> [3] </ref> = 1; terrain_type [4] = 0; terrain_type [5] = 4; terrain_type [6] = 2; a c-program for the first six rows of the file (since these will always look the same), then both by flex and c for the rest of the numbers (the actual map).
Reference: [4] <institution> Specification, Simulation 1994 Project. </institution>
Reference-contexts: See figure 4.7 for an example. The map file After parsing the conversion file the program parses the map file, given as output from grass (see Figure 4.1), and convert it. This is done by 37 terrain_type [1] = 3 terrain_type [2] = 2; terrain_type [3] = 1; terrain_type <ref> [4] </ref> = 0; terrain_type [5] = 4; terrain_type [6] = 2; a c-program for the first six rows of the file (since these will always look the same), then both by flex and c for the rest of the numbers (the actual map). <p> All processes that are to be started by the Master module must be described by a Process Description, as specified in <ref> [4] </ref>. This Process Description says how the process is to be started, how it is to be logged and how to put 56 a new state to it. It also says if we are to register the process under a name.
Reference: [5] <author> Aho, Sethi, and Ullman. </author> <booktitle> Compilers, principles techniques and tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: The map file After parsing the conversion file the program parses the map file, given as output from grass (see Figure 4.1), and convert it. This is done by 37 terrain_type [1] = 3 terrain_type [2] = 2; terrain_type [3] = 1; terrain_type [4] = 0; terrain_type <ref> [5] </ref> = 4; terrain_type [6] = 2; a c-program for the first six rows of the file (since these will always look the same), then both by flex and c for the rest of the numbers (the actual map). <p> The tokenizer consists internally of two processes, one for requests from the client, one for answers from the simulation. The to- kenizer implements a specified communication protocol between the client and the simulation. Internally the tokenizer is a simple LR <ref> [5] </ref> parser. When the tokenizer receives requests from the user interface it translates them to corresponding Erlang messages. The tokenizer and the buffer also need means to break down Erlang messages to byte lists before the byte lists are sent to the socket and further to the "outside".
Reference: [6] <author> Peter Almquist and Bo Hagerf. On traccs. CelsiusTech IT, </author> <year> 1994. </year>
Reference-contexts: This is expensive and therefore simulation is needed. The present system TRACCS <ref> [6] </ref> is an attempt to solve some of these problems. TRACCS is a computer-aided system for training of battalion chiefs. The battalion chief is placed in his real environment, equipped with maps and radios. His troops are units controlled by operators in a control centre. <p> This is done by 37 terrain_type [1] = 3 terrain_type [2] = 2; terrain_type [3] = 1; terrain_type [4] = 0; terrain_type [5] = 4; terrain_type <ref> [6] </ref> = 2; a c-program for the first six rows of the file (since these will always look the same), then both by flex and c for the rest of the numbers (the actual map).
Reference: [7] <author> Joe Armstrong, Robert Virding, and Mike Williams. </author> <title> Concurrent Programming in Erlang. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: By implementing this simulator we try to answer two interesting questions: * Is a process-based implementation efficient enough for this kind of simulation? * Is it possible to implement such a large system in a short time by using high-level tools like the Erlang <ref> [7] </ref> programming language? 1.1.1 Background Traditionally, military leadership training have consisted of operations involving much personnel. This is expensive and therefore simulation is needed. The present system TRACCS [6] is an attempt to solve some of these problems. TRACCS is a computer-aided system for training of battalion chiefs. <p> The clients can connect to the simulation server to enable inspection and manipulation of the simulation. 2 1.2.1 The simulator The simulation is agent-based, an agent represents a troop and is implemented as an autonomous process in Erlang <ref> [7] </ref>. The agents are controlled by a set of rules and placed in a dynamic terrain where they interact with friendly and hostile troops/agents. <p> During an interval the agents autonomously simulate the actions they will carry out in the amount of time the interval represents. At the end of the interval each agent communicates its new state to the other agents. 1.3 Erlang The simulator is implemented in Erlang . Erlang <ref> [7] </ref> is a concurrent functional language with support for distribution. <p> The Master also shuts down the simulation in a controlled manner upon request to do so. 55 6.2 Preliminaries Erlang is a concurrent, functional language originally developed for AXE telephone-switches, by Ellemtel <ref> [7] </ref>. The Master module is entirely written in Erlang . For a detailed description of Erlang , (see Section 1.3). A process is a program state. Processes execute concurrently in Erlang , where communication and synchronisation are done by message-passing and matching. <p> The reason for this is that we want to have a uniform way of manipulating processes when loading a saved simulation, migrating processes or handling node failures. One process controls the socket communication. 58 All socket communication from within the Erlang system is done by the built-in socket interface <ref> [7] </ref> of Erlang 1 . Authority check Clients that log on to the system are checked for authority. Clients can be of two types, either a Supervisor, or a player, named after his nationality in the simulation. One authority process monitors passwords for users trying to log in. <p> Four different types of data is presented; Reductions/sec, Run queue, Unix load and Total load. Reductions/sec Whenever a function head is matched in Erlang , a reduction is performed. Therefore, the number of reductions is a measure of system performance <ref> [7] </ref>. Many reductions per second means a fast node, probably with low load, whereas very few reductions can indicate an overloaded node. As mentioned above, reductions is not a good measure if a fast node is in receive mode, i.e. waiting for a message. <p> But since certain processes has a significant startup-overhead, we chose to use this approach instead. 64 dying, since the Master process is linked <ref> [7] </ref> to all processes in the system. However, there is always a stand-by process on another node. In case of the Master process dying abnormally, the stand-by process will restart the simulation from the latest logged state. <p> The simulation consists of autonomous, communicating processes, implemented in the high-level language Erlang <ref> [7] </ref>. This article is devoted to the client part of the system. Clients connect to the simulation through a Unix port and are provided an interface to view the simulation map, troops and their movements, to send orders and to see battles as they happen.
Reference: [8] <author> Bjorn Bergstrom. En markstridsmodell for skytteforband. CelsiusTech, </author> <year> 1994. </year>
Reference-contexts: For this purpose there is a need for an objective judge, World. The battle judgement is done in a separate function executed when all agents have completed their simulation time interval ((see Figure 3.1)). The algorithms, described later, are specified in <ref> [8] </ref>. When an agent decides to attack another agent, the agent must make a request (to World) to perform the attack. When the agent makes the decision it is based on knowledge about the other agent's old status, i.e. the other agent's status when the current simulation time interval started. <p> These files are to be converted like raster-to-ascii and vector-to-ascii. To do that some of grass's convenient commands are used. 4.2.2 Erlang representation The specification suggested by CelsiusTech IT AB <ref> [8] </ref> had a hexagon representation with sides indicating roads and waters. Conceptually, roads lead from the center of the square to the middle of the side while waters run along the side. This is a model well-known in strategic games. <p> &lt;space&gt; + COM INT: )&lt;Digit&gt; INT FNAME: ) STR COM: ) STR STR: ) &lt;Letter&gt; STR Digit: ) 0..9 Letter: ) a..z j A..Z RASTER: topografi RESOLUTION_TERRAIN: 50 RESOLUTION_MAP: 75 VECTOR_ROAD: vag VECTOR_MAP: vag VECTOR_WATER: vatten 4.4.2 The Implementation of conversion In the simulation model suggested by CelsiusTech IT AB <ref> [8] </ref> the following terrain types were specified: 36 * Open terrain * Sparse forest * Dense forest * Urban area * Water * Forbidden In the original map there are many more terrain types than in the one used in the simulation model.
Reference: [9] <author> John R Corbin. </author> <title> The art of distributed programming, Programming tech-niques for RPC. </title> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The packer is basically the inverse of the parser in the tokenizer. The asynchronous communication from the simulator is based on events [10]. The events are generated from the simulator and handled by the buffer. All functions the tokenizer calls are implemented as Remote Procedure Calls (RPC <ref> [9] </ref>). Remote Procedure Calls are synchronous messages to other processes who syntactically looks like procedure calls. The result of the message is returned like in a normal procedure call and the sending (calling) process is halted until the answer is received.
Reference: [10] <author> Mario R Garzia. </author> <title> Discrete event simulation methodologies and for-malisms. </title> <booktitle> In Proceedings, Annual simulation symposium, </booktitle> <year> 1989. </year>
Reference-contexts: passive and active provision of information about the current state of the world. 3.2 The World Module Here we consider the World's part in the simulation and its possible problems and solutions. 3.2.1 Synchronisation The usual way of programming simulation systems is to use a time queue to achieve synchronisation <ref> [10] </ref>. Every simulating agent is simulated one at a time as a discrete event. <p> It uses a function, pack, also referred to as the packer. The packer is basically the inverse of the parser in the tokenizer. The asynchronous communication from the simulator is based on events <ref> [10] </ref>. The events are generated from the simulator and handled by the buffer. All functions the tokenizer calls are implemented as Remote Procedure Calls (RPC [9]). Remote Procedure Calls are synchronous messages to other processes who syntactically looks like procedure calls.
Reference: [11] <author> Brian Harvey and Mattehew Wright. </author> <title> Simply Scheme. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: The relay process uses 1 Clients do not need to be Erlang systems, however. In this system, the clients are written in STk <ref> [11, 16] </ref>. 59 the Process Identifier of the real process, which is global [17]. There is also a relay process on the node where the real process resides. This might seem unnecessary, but it depends on the implementation. <p> We emphasise that superusers are not simulation system administrators; they are the game supervisors and need no particular computer knowledge. System specific parts, such as process migration, are done in the master module. The user-interface is implemented in STk <ref> [11, 16] </ref> (Scheme TK). It is separated from the Erlang part and implemented as a client which communicates 71 with the simulation through a Unix port. Hence, users and superusers can be located anywhere where TCP/IP [13] networking is available. <p> In order to simplify and speed up development some extensions of the original STk source code were added. 7.2 Preliminaries In implementing the client module an extended version of STk were used for the user-interface. STk stands for Scheme <ref> [11] </ref> Tk [16]. Scheme is a functional (declarative) programming language highly inspired by LISP [15]. TK is an X [14] widget toolkit inspired in look and feel by Motif [12]. STk is a Scheme with TK highly integrated in the language.
Reference: [12] <author> Dan Heller. </author> <title> Motif Programming Manual. </title> <publisher> O'Reilly & Associates, Inc, </publisher> <year> 1992. </year>
Reference-contexts: STk stands for Scheme [11] Tk [16]. Scheme is a functional (declarative) programming language highly inspired by LISP [15]. TK is an X [14] widget toolkit inspired in look and feel by Motif <ref> [12] </ref>. STk is a Scheme with TK highly integrated in the language. The client communicates with the simulation through a Unix port. Ev- ery client has a corresponding tokenizer within the simulation to handle the communication.
Reference: [13] <author> Stephen J Kochan and Patrick M Wood. </author> <title> UNIX Networking. </title> <publisher> Hayden Books, </publisher> <year> 1989. </year>
Reference-contexts: The Berkeley 4.2 BSD UNIX socket [2] interface is one example of such network functions. We used Erlang 's built-in socket interface for UNIX sockets. Logging on to the simulation means setting up a connection to the simulation servers' socket, over TCP/IP <ref> [13] </ref>. TCP provides a reliable flow- controlled, two-way transmission of data. TCP constructs virtual circuits between peer entities. A virtual circuit consists of remote Internet addresses, remote ports, local Internet addresses and local ports. <p> The user-interface is implemented in STk [11, 16] (Scheme TK). It is separated from the Erlang part and implemented as a client which communicates 71 with the simulation through a Unix port. Hence, users and superusers can be located anywhere where TCP/IP <ref> [13] </ref> networking is available. Any number of clients can connect/disconnect to the simulation at any time. The simulation is not dependent on connected clients, and can, when properly setup, run without them.
Reference: [14] <author> Robert W Scheifler. </author> <title> X window system: C library and protocol reference. </title> <publisher> Digital Press, </publisher> <year> 1988. </year>
Reference-contexts: STk stands for Scheme [11] Tk [16]. Scheme is a functional (declarative) programming language highly inspired by LISP [15]. TK is an X <ref> [14] </ref> widget toolkit inspired in look and feel by Motif [12]. STk is a Scheme with TK highly integrated in the language. The client communicates with the simulation through a Unix port. Ev- ery client has a corresponding tokenizer within the simulation to handle the communication.
Reference: [15] <author> Clark Weissman. </author> <title> Lisp 1.5 primer, </title> <year> 1968. </year>
Reference-contexts: STk stands for Scheme [11] Tk [16]. Scheme is a functional (declarative) programming language highly inspired by LISP <ref> [15] </ref>. TK is an X [14] widget toolkit inspired in look and feel by Motif [12]. STk is a Scheme with TK highly integrated in the language. The client communicates with the simulation through a Unix port.
Reference: [16] <author> Brent Welch. </author> <title> Practical programming in tcl and tk. </title> <note> Draft; the book will be published by Prentice Hall, </note> <month> August </month> <year> 1994. </year>
Reference-contexts: The path is finally converted from our internal representation to the format specified by the Agent module, see section 5.2.2. 5.5 Test-bench In order to visualise the search, a test-bench was developed. The test-bench is written in Tcl-Tk <ref> [16] </ref> with an interface to Erlang [17]. The test-bench uses two windows, a preferences window and a supervisor window. 5.5.1 Preferences The preferences window, shown in figure 5.7, is used to set parameters used by the search. The weights are described in 5.4.2. <p> The relay process uses 1 Clients do not need to be Erlang systems, however. In this system, the clients are written in STk <ref> [11, 16] </ref>. 59 the Process Identifier of the real process, which is global [17]. There is also a relay process on the node where the real process resides. This might seem unnecessary, but it depends on the implementation. <p> resume simulation When an node failure has caused a restart, we apply the same procedure as when we load a saved simulation (except for that another file is used). 6.3.9 Graphical debugger As a help in developing the system, we wrote a graphical debugger consisting of three windows in Tcl/Tk <ref> [16] </ref>. The main debugging window displays written output from the processes (see Figure 6.4). Different system components can be observed simultaneously, or one by one (the components are the names in the toggle-buttons to the right in the figure). <p> We emphasise that superusers are not simulation system administrators; they are the game supervisors and need no particular computer knowledge. System specific parts, such as process migration, are done in the master module. The user-interface is implemented in STk <ref> [11, 16] </ref> (Scheme TK). It is separated from the Erlang part and implemented as a client which communicates 71 with the simulation through a Unix port. Hence, users and superusers can be located anywhere where TCP/IP [13] networking is available. <p> In order to simplify and speed up development some extensions of the original STk source code were added. 7.2 Preliminaries In implementing the client module an extended version of STk were used for the user-interface. STk stands for Scheme [11] Tk <ref> [16] </ref>. Scheme is a functional (declarative) programming language highly inspired by LISP [15]. TK is an X [14] widget toolkit inspired in look and feel by Motif [12]. STk is a Scheme with TK highly integrated in the language. The client communicates with the simulation through a Unix port.
Reference: [17] <author> Claes Wickstrom. </author> <title> Distributed programming in Erlang. Addendum to Concurrent Programming in Erlang, </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year> <month> 84 </month>
Reference-contexts: The path is finally converted from our internal representation to the format specified by the Agent module, see section 5.2.2. 5.5 Test-bench In order to visualise the search, a test-bench was developed. The test-bench is written in Tcl-Tk [16] with an interface to Erlang <ref> [17] </ref>. The test-bench uses two windows, a preferences window and a supervisor window. 5.5.1 Preferences The preferences window, shown in figure 5.7, is used to set parameters used by the search. The weights are described in 5.4.2. <p> Nationalities is registered when created, and a navigator is started for each nationality. The terrain process then passes on requests to the right navigator. 5.6.1 Distribution A navigator can be located at any node in Distributed Erlang <ref> [17] </ref>. The processes spawned by the navigator under a navigation request is local to the Erlang node. 5.6.2 Logging Both the terrain process and the navigator processes have internal states that need to be logged, if a simulation is to be resumed. <p> However, the number of error sources drastically increases compared to non-distributed applications. Nodes may fail, network connections can fail or their capacity might temporarily be degraded. With powerful tools such as distributed Erlang <ref> [17] </ref>, it is possible to write distributed applications almost as easy as writing non-distributed ones. Statistics, or load, is (for now) measured on a per-machine basis. <p> Initially, the game supervisor gives every nationality he creates a password. 6.3.4 Distribution of the system The system can be distributed on several hosts, which gives higher performance and better error recovery. Distribution is easily implemented in Distributed Erlang <ref> [17] </ref>, that offers a large variety of high-level commands concerning this topic. The important issues are how to make the system robust and how to design the process distribution in order to get as high performance as possible. <p> The relay process uses 1 Clients do not need to be Erlang systems, however. In this system, the clients are written in STk [11, 16]. 59 the Process Identifier of the real process, which is global <ref> [17] </ref>. There is also a relay process on the node where the real process resides. This might seem unnecessary, but it depends on the implementation. This solution makes it possible to treat all nodes in a uniform way. <p> This is a good measure of the future load of the node <ref> [17] </ref>. You should probably not migrate more processes to a node with a large queue. The Run queue is always checked right before reporting the data. UNIX load To complement the other data, the UNIX load of a certain node (i e its host) is also showed.
References-found: 17

