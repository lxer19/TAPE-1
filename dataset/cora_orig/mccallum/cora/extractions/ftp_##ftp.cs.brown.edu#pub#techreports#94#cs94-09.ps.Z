URL: ftp://ftp.cs.brown.edu/pub/techreports/94/cs94-09.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-94-09.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> R. Bayer and E. McCreight, </author> <title> "Organization of Large Ordered Indexes," </title> <journal> Acta Informatica 1 (1972), </journal> <pages> 173-189. </pages>
Reference: [2] <author> J. L. Bentley, </author> <title> "Algorithms for Klee's Rectangle Problems," </title> <institution> Dept. of Computer Science, Car-negie Mellon Univ. </institution> <note> unpublished notes, </note> <year> 1977. </year>
Reference-contexts: Other data structures like the Interval Tree [10,11], and Segment Tree <ref> [2] </ref> can also solve the interval management problem optimally in-core, with respect to the query time. Among these, the priority search tree does the best because it solves the interval management problem in optimal time and space, and provides an optimal worst-case update time as well.
Reference: [3] <author> J. L. Bentley, </author> <title> "Multidimensional divide and conquer," </title> <booktitle> CACM 23(6) (1980), </booktitle> <pages> 214-229. 37 </pages>
Reference-contexts: Amortized update I/O time for the semi-dynamic problem with inserts is O (log 2 c (log B n + (log B n) 2 =B)). 1.4 Related Research A large literature exists for in-core algorithms for 2-dimensional range searching. The range tree <ref> [3] </ref> can be used to solve the problem in O (n log 2 n) space and static worst-case query time O (log 2 n + t) .
Reference: [4] <author> G. Blankenagel and R. H. Guting, </author> <title> "External Segment Trees," </title> <address> FernUniversitat Hagen, Infor--matik-Bericht, </address> <year> 1990. </year>
Reference-contexts: There have been several pieces of work done by researchers to implement these data structures in secondary memory. These works include [16], [5], <ref> [4] </ref>. [16] contains a claimed optimal solution for implementing static priority search trees in secondary memory. Unfortunately, the [16] static solution has static query time O (log 2 n + t=B) instead of O (log B n + t=B) and the claimed optimal solution is incorrect.
Reference: [5] <author> G. Blankenagel and R. H. Guting, </author> <title> "XP-Trees External Priority Search Trees," </title> <journal> FernUniver-sitat Hagen, Informatik-Bericht Nr. </journal> <volume> 92, </volume> <year> 1990. </year>
Reference-contexts: There have been several pieces of work done by researchers to implement these data structures in secondary memory. These works include [16], <ref> [5] </ref>, [4]. [16] contains a claimed optimal solution for implementing static priority search trees in secondary memory. Unfortunately, the [16] static solution has static query time O (log 2 n + t=B) instead of O (log B n + t=B) and the claimed optimal solution is incorrect.
Reference: [6] <author> B. Chazelle, </author> <title> "Lower Bounds for Orthogonal Range Searching: I. The Reporting Case," </title> <editor> J. </editor> <booktitle> ACM 37(2) (1990), </booktitle> <pages> 200-212. </pages>
Reference-contexts: We show in Section 2.2 that it is impossible to achieve optimal query time for this problem (O (log B n + t=B) disk I/O's) with only one copy of each object in secondary storage. (For lower bounds on range searching in main memory, see [12] and <ref> [6] </ref>.) In Section 4, analyzing the hierarchy using the hierarchical decomposition of [33] and using techniques from the constraint indexing problem, we improve query I/O time to O (log B n + t=B + log 2 B) using space O ((n=B) log 2 c) pages.
Reference: [7] <author> Y.-J. Chiang and R. Tamassia, </author> <title> "Dynamic Algorithms in Computational Geometry," </title> <booktitle> Proceedings of IEEE, Special Issue on Computational Geometry 80(9) (1992), </booktitle> <pages> 362-381. </pages>
Reference-contexts: By using fractional cascading, we can achieve a worst-case dynamic query time O (log 2 n log 2 log 2 n + t) and update time O (log 2 n log 2 log 2 n) using the same space. We refer the reader to <ref> [7] </ref> for a detailed survey of the topic. The ideal worst-case I/O bounds would involve making all the above logarithms have base B and compacting the output term to t=B; any other improvements would of course imply improvements to the in-core bounds. <p> This paper also does not offer any worst-case analysis for range searching. Specifically, this method will not have optimal reporting time with our standard case, i.e., the uniform grid of points. Dynamic interval management has been examined extensively in the literature (see <ref> [7] </ref>). As mentioned before, the best in-core bounds have been achieved using the priority search tree of [24], yielding O (n) space, dynamic query time O (log 2 n + t) and update time O (log 2 n), which are all optimal. <p> Based on this structure we show that indexing classes is a special case of external dynamic 2-dimensional range searching on some attribute of the objects. We then use the idea of the 2-dimensional range tree (see <ref> [7] </ref>), with classes as the primary dimension and the object attribute as a secondary dimension to devise an efficient storage and query strategy. These ideas are formalized in the proposition and theorem to follow. Proposition 2.5 Indexing classes reduces to external dynamic 2-dimensional range searching with one dimension being static.
Reference: [8] <author> E. F. Codd, </author> <title> "A Relational Model for Large Shared Data Banks," </title> <booktitle> CACM 13(6) (1970), </booktitle> <pages> 377-387. </pages>
Reference-contexts: 1 Introduction 1.1 Motivation The successful realization of any data model requires supporting its language features with efficient secondary storage manipulation. For example, the relational data model <ref> [8] </ref> includes declarative fl Address: Dept. of Computer Science, Brown University, Box 1910, Providence, RI 02912. Email: pck@cs.brown.edu. Research supported by ONR Contract N00014-91-J-4052, ARPA Order 8225. y Address: Dept. of Computer Science, Brown University, Box 1910, Providence, RI 02912. Email: sr@cs.brown.edu.
Reference: [9] <author> D. Comer, </author> <title> "The Ubiquitous B-tree," </title> <booktitle> Computing Surveys 11(2) (1979), </booktitle> <pages> 121-137. </pages>
Reference: [10] <author> H. Edelsbrunner, </author> <title> "A new Approach to Rectangle Intersections, Part II," </title> <booktitle> Int. J. Computer Mathematics 13 (1983), </booktitle> <pages> 221-229. </pages>
Reference: [11] <author> H. Edelsbrunner, </author> <title> "A new Approach to Rectangle Intersections, Part I," </title> <booktitle> Int. J. Computer Mathematics 13 (1983), </booktitle> <pages> 209-219. </pages>
Reference: [12] <author> M. L. Fredman, </author> <title> "A Lower Bound on the Complexity of Orthogonal Range Queries," </title> <editor> J. </editor> <booktitle> ACM 28 (1981), </booktitle> <pages> 696-705. </pages>
Reference-contexts: We show in Section 2.2 that it is impossible to achieve optimal query time for this problem (O (log B n + t=B) disk I/O's) with only one copy of each object in secondary storage. (For lower bounds on range searching in main memory, see <ref> [12] </ref> and [6].) In Section 4, analyzing the hierarchy using the hierarchical decomposition of [33] and using techniques from the constraint indexing problem, we improve query I/O time to O (log B n + t=B + log 2 B) using space O ((n=B) log 2 c) pages.
Reference: [13] <author> M. T. Goodrich, J.-J. Tsay, D. E. Vengroff, and J. S. Vitter, </author> <title> "External-Memory Computational Geometry," </title> <booktitle> Proc. 34th Annual IEEE Symposium on Foundations of Computer Science (1993), </booktitle> <pages> 714-723. </pages>
Reference-contexts: Some progress has been made in the case where our goal is to handle a very large number of queries in a batch <ref> [13] </ref>. In this case, 2-dimensional queries can be answered in O ((n=B + k=B)(log M=B (n=B)) + t=B) I/Os where k is the number of queries being processed and M is the amount of main memory available.
Reference: [14] <author> O. Gunther, </author> <title> "The Design of the Cell Tree: An Object-Oriented Index Structure for Geometric Databases," </title> <booktitle> Proc. of the fifth Int. Conf. on Data Engineering (1989), </booktitle> <pages> 598-605. </pages>
Reference-contexts: That is, we would read O (t= p B) disk blocks to report t points on a straight line. Several data structures have been proposed in the literature to handle region data. These include the R-tree [15], the R + -tree [32], the cell tree <ref> [14] </ref> and many others. These data structures are not directly applicable to point data. However, they can deal with 1-dimensional range data and hence are relevant to our problem.
Reference: [15] <author> Antonin Guttman, "R-Trees: </author> <title> A Dynamic Index Structure for Spatial Searching," </title> <booktitle> Proc. 1984 ACM-SIGMOD Conference on Management of Data (1985), </booktitle> <pages> 47-57. </pages>
Reference-contexts: That is, we would read O (t= p B) disk blocks to report t points on a straight line. Several data structures have been proposed in the literature to handle region data. These include the R-tree <ref> [15] </ref>, the R + -tree [32], the cell tree [14] and many others. These data structures are not directly applicable to point data. However, they can deal with 1-dimensional range data and hence are relevant to our problem.
Reference: [16] <author> C. Icking, R. Klein, and T. Ottmann, </author> <title> Priority Search Trees in Secondary Memory (Extended Abstract), </title> <booktitle> Lecture Notes In Computer Science #314, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: There have been several pieces of work done by researchers to implement these data structures in secondary memory. These works include <ref> [16] </ref>, [5], [4]. [16] contains a claimed optimal solution for implementing static priority search trees in secondary memory. Unfortunately, the [16] static solution has static query time O (log 2 n + t=B) instead of O (log B n + t=B) and the claimed optimal solution is incorrect. <p> There have been several pieces of work done by researchers to implement these data structures in secondary memory. These works include <ref> [16] </ref>, [5], [4]. [16] contains a claimed optimal solution for implementing static priority search trees in secondary memory. Unfortunately, the [16] static solution has static query time O (log 2 n + t=B) instead of O (log B n + t=B) and the claimed optimal solution is incorrect. <p> There have been several pieces of work done by researchers to implement these data structures in secondary memory. These works include <ref> [16] </ref>, [5], [4]. [16] contains a claimed optimal solution for implementing static priority search trees in secondary memory. Unfortunately, the [16] static solution has static query time O (log 2 n + t=B) instead of O (log B n + t=B) and the claimed optimal solution is incorrect. <p> We give efficient solutions to the class indexing problem when the hierarchy is degenerate and when the hierarchy has constant depth. Combining these techniques, we give an efficient solution to the whole problem. Lemma 4.1 <ref> [16] </ref> There exists a data structure that can answer any 3-sided query on a set of n points on the plane in O (log 2 n + t=B) disk I/O's. This data structure occupies O (n=B) disk blocks and can be built in O ((n=B) log B n) disk I/O's. <p> This data structure occupies O (n=B) disk blocks and can be built in O ((n=B) log B n) disk I/O's. A data structure to achieve these bounds was presented in <ref> [16] </ref>. The data structure is essentially a priority search tree where each node contains B points. A simple recursive algorithm can build this tree in O ((n=B) log B n) disk I/O's. <p> Whether they can be asymptotically improved is an open question. The performance for the case of deletions is open. We should note that, using the techniques in this paper to dynamize the static structure of <ref> [16] </ref>, it is possible to achieve the following dynamic bounds: (1) indexing constraints in O (n=B) pages, dynamic query I/O time O (log 2 n + t=B) and amortized update time O (log 2 n + (log 2 2 n)=B), and (2) indexing classes in O (log 2 c (n=B)) pages,
Reference: [17] <author> J. Jaffar and J. L. Lassez, </author> <title> "Constraint Logic Programming," </title> <booktitle> Proc. 14th ACM POPL (1987), </booktitle> <pages> 111-119. </pages>
Reference-contexts: A general constraint programming framework for database query languages called Constraint Query Languages or CQLs was presented in [18]. This framework adapts ideas of Constraint Logic Programming, e.g., from <ref> [17] </ref>, to databases, provides a calculus and algebra, guarantees low data complexity, and is applicable to managing spatial data. It is, of course, important to index constraints and thus support these new language features with efficient secondary storage manipulation (see Section 2.1 for a detailed exposition of the problem).
Reference: [18] <author> P. C. Kanellakis, G. M. Kuper, and P. Z. Revesz, </author> <title> "Constraint Query Languages," </title> <booktitle> Proc. 9th ACM PODS (1990), </booktitle> <pages> 299-313, </pages> <note> Invited to the special issue of JCSS on Principles of Database Systems (to appear). A complete version of the paper appears in Technical Report 90-31, </note> <institution> Brown University. </institution>
Reference-contexts: In this paper, we examine new I/O-efficient data structures for special cases of the general problem of k-dimensional range searching. These special cases are important for supporting new language features, such as constraint query languages <ref> [18] </ref> and class hierarchies in object-oriented databases [20,36]. <p> A general constraint programming framework for database query languages called Constraint Query Languages or CQLs was presented in <ref> [18] </ref>. This framework adapts ideas of Constraint Logic Programming, e.g., from [17], to databases, provides a calculus and algebra, guarantees low data complexity, and is applicable to managing spatial data. <p> It is, of course, important to index constraints and thus support these new language features with efficient secondary storage manipulation (see Section 2.1 for a detailed exposition of the problem). Fortunately, it is possible to do this by combining CQLs with existing 2-dimensional range searching data structures <ref> [18] </ref>. The basis of this observation is a reduction of indexing constraints, for a fairly general class of constraints, to dynamic interval management on secondary storage. Given a set of input intervals, dynamic interval management involves being able to perform the following operations efficiently: (1) Answer interval intersection queries. <p> Section 5 has the conclusions and open problems. 2 The Problems and Initial Approaches 2.1 Indexing Constraints To illustrate indexing constraints in CQLs consider the domain of rational numbers and a language whose syntax consists of the theory of rational order with constants + the relational calculus. (See <ref> [18] </ref> for details.) In this context, a generalized k-tuple is a quantifier-free conjunction of constraints on k variables, which range over the domain (rational numbers). For example, in the relational database model R (3; 4) is a tuple of arity 2. <p> The same program can be used for intersecting triangles. This simplicity of expression can be combined with efficient evaluation techniques, even if quantification is over the infinite domain of rationals. For more examples and details, please see <ref> [18] </ref>. fl The CQL model for rational order + relational calculus has low data complexity, because every fixed query is evaluable in LOGSPACE. That alone is not enough to make it a suitable model for implementation.
Reference: [19] <author> W. Kim, K. C. Kim, and A. Dale, </author> <title> "Indexing Techniques for Object-Oriented Databases," in Object-Oriented Concepts, Databases, and Applications, </title> <editor> W. Kim and F. H. Lochovsky, eds., </editor> <publisher> Addison-Wesley, </publisher> <year> 1989, </year> <pages> 371-394. 38 </pages>
Reference-contexts: Together with the different problem of indexing nested objects, as in [23], it constitutes the basis for indexing in object-oriented databases. Indexing classes has been examined 3 in <ref> [19] </ref>, and more recently in [22], but the solutions offered there are largely heuristic with poor worst-case performance. In Section 2.2, we reduce indexing classes to a special case of external dynamic 2-dimensional range searching called 3-sided searching. 3-sided range queries are a special case of 2-dimensional range queries.
Reference: [20] <editor> W. Kim and F. H. Lochovsky, eds., </editor> <title> Object-Oriented Concepts, Databases, and Applications, </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference: [21] <author> D. B. Lomet and B. Salzberg, </author> <title> "The hB-Tree: A Multiattribute Indexing Method with Good Guaranteed Performance," </title> <booktitle> ACM Transactions on Database Systems 15(4) (1990), </booktitle> <pages> 625-658. </pages>
Reference-contexts: Many of them are based on a B-tree-like organization. We will consider several of them with reference to our problems. Two related data structures that have been proposed for multi-attribute indexing are the k-d B-tree [29] and the hB-tree <ref> [21] </ref>. k-d-B-trees combine properties of balanced k-d-trees in a B-tree-like organization. In the 2-dimensional case (these ideas generalize readily to higher dimensions), the k-d-B-tree works by subdividing space into rectangular regions. Such subdivisions are stored in the interior nodes of the k-d-B-tree.
Reference: [22] <author> C. C. Low, B. C. Ooi, and H. Lu, "H-trees: </author> <title> A Dynamic Associative Search Index for OODB," </title> <booktitle> Proc. ACM SIGMOD (1992), </booktitle> <pages> 134-143. </pages>
Reference-contexts: Together with the different problem of indexing nested objects, as in [23], it constitutes the basis for indexing in object-oriented databases. Indexing classes has been examined 3 in [19], and more recently in <ref> [22] </ref>, but the solutions offered there are largely heuristic with poor worst-case performance. In Section 2.2, we reduce indexing classes to a special case of external dynamic 2-dimensional range searching called 3-sided searching. 3-sided range queries are a special case of 2-dimensional range queries.
Reference: [23] <author> D. Maier and J. Stein, </author> <title> "Indexing in an Object-Oriented DBMS," </title> <booktitle> IEEE Proc. International Workshop on Object-Oriented Database Systems (1986), </booktitle> <pages> 171-182. </pages>
Reference-contexts: Together with the different problem of indexing nested objects, as in <ref> [23] </ref>, it constitutes the basis for indexing in object-oriented databases. Indexing classes has been examined 3 in [19], and more recently in [22], but the solutions offered there are largely heuristic with poor worst-case performance.
Reference: [24] <author> E. M. McCreight, </author> <title> "Priority Search Trees," </title> <journal> SIAM Journal of Computing 14(2) (1985), </journal> <pages> 257-276. </pages>
Reference-contexts: Dynamic interval management can be shown to be a special case of external dynamic 2-dimensional range searching. Dynamic interval management is interesting because it can be solved optimally in-core using the Priority Search Tree of Mccreight <ref> [24] </ref> in query time O (log 2 n + t), update time O (log 2 n), and space O (n), which are all optimal. Achieving analogous I/O bounds is much harder. <p> Specifically, this method will not have optimal reporting time with our standard case, i.e., the uniform grid of points. Dynamic interval management has been examined extensively in the literature (see [7]). As mentioned before, the best in-core bounds have been achieved using the priority search tree of <ref> [24] </ref>, yielding O (n) space, dynamic query time O (log 2 n + t) and update time O (log 2 n), which are all optimal.
Reference: [25] <author> J. Nievergelt, H. Hinterberger, and K. C. Sevcik, </author> <title> "The Grid File: An Adaptable, Symmetric Multikey File Structure," </title> <booktitle> ACM Transactions on Database Systems 9(1) (1984), </booktitle> <pages> 38-71. </pages>
Reference-contexts: They work by recursively subdividing each region into four equal pieces until the number of points in each region fits into a disk block. Because they do not adapt to the input data, they can have very bad worst-case times. The grid file <ref> [25] </ref> was proposed as a data structure that treats all dimensions symmetrically, unlike many other data structures like the inverted file which distinguish between primary and secondary keys. <p> The grid file works by dividing each dimension into ranges and maintaining a grid directory that provides a mapping between regions in the search space and disk blocks. The paper <ref> [25] </ref> does not provide analysis for worst-case query times. They do mention that range queries become very efficient when queries return "many" records.
Reference: [26] <author> J. A. Orenstein, </author> <title> "Spatial Query Processing in an Object-Oriented Database System," </title> <booktitle> Proc. ACM SIGMOD (1986), </booktitle> <pages> 326-336. </pages>
Reference-contexts: All of them are based on the recursive decomposition of space using heuristics and cannot offer the worst-case guarantees in space and time that we seek. An interesting idea based on the use of space-filling curves is proposed in <ref> [26] </ref>. This paper identifies a space-filling curve to order points in k-dimensional space. This curve has the desirable property that points that are close by in the input will, with high probability, be close by in the resulting ordering.
Reference: [27] <author> M. H. Overmars, M. H. M. Smid, M. T. de Berg, and M. J. van Kreveld, </author> <title> "Maintaining Range Trees in Secondary Memory: Part I: Partitions," </title> <journal> Acta Informatica 27 (1990), </journal> <pages> 423-452. </pages>
Reference: [28] <author> S. Ramaswamy and S. Subramanian, </author> <title> "Path Caching: A Technique for Optimal External Searching," </title> <booktitle> (to appear in the) Proc. 13th ACM PODS (1994). </booktitle>
Reference-contexts: In this case, 2-dimensional queries can be answered in O ((n=B + k=B)(log M=B (n=B)) + t=B) I/Os where k is the number of queries being processed and M is the amount of main memory available. Recently, a new technique called path caching was presented in <ref> [28] </ref> to convert many main-memory data structures like the priority search trees, segments trees, etc. into efficient secondary storage structures. For example, it is shown in [28] that it is possible to implement priority search trees in secondary memory so that 2-sided queries can be answered in optimal O (log B <p> Recently, a new technique called path caching was presented in <ref> [28] </ref> to convert many main-memory data structures like the priority search trees, segments trees, etc. into efficient secondary storage structures. For example, it is shown in [28] that it is possible to implement priority search trees in secondary memory so that 2-sided queries can be answered in optimal O (log B n + t=B) disk I/O's while using a storage of O ((n=B) log 2 log 2 B).
Reference: [29] <author> J. T. Robinson, </author> <title> "The K-D-B Tree: A Search Structure for Large Multidimensional Dynamic Indexes," </title> <booktitle> Proc. ACM SIGMOD (1984), </booktitle> <pages> 10-18. </pages>
Reference-contexts: Many of them are based on a B-tree-like organization. We will consider several of them with reference to our problems. Two related data structures that have been proposed for multi-attribute indexing are the k-d B-tree <ref> [29] </ref> and the hB-tree [21]. k-d-B-trees combine properties of balanced k-d-trees in a B-tree-like organization. In the 2-dimensional case (these ideas generalize readily to higher dimensions), the k-d-B-tree works by subdividing space into rectangular regions. Such subdivisions are stored in the interior nodes of the k-d-B-tree. <p> Insertion and deletion algorithms for the k-d-B-tree are also outlined in <ref> [29] </ref>. This work does not offer any worst-case analysis for range search. As mentioned before, the k-d-B-tree works by subdividing space into rectangular regions. With a uniform grid of points as input, we would read O (t= p B) disk blocks to report t points on a straight line.
Reference: [30] <author> H. Samet, </author> <title> Applications of Spatial Data Structures: Computer Graphics, Image Processing, </title> <publisher> and GIS , Addison-Wesley, </publisher> <year> 1989. </year>
Reference: [31] <author> H. Samet, </author> <title> The Design and Analysis of Spatial Data Structures, </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference: [32] <author> T. Sellis, N. Roussopoulos, and C. Faloutsos, </author> <title> "The R + -Tree: A Dynamic Index for MultiDimensional Objects," </title> <booktitle> Proc. 1987 VLDB Conference, </booktitle> <address> Brighton, England (1987). </address>
Reference-contexts: That is, we would read O (t= p B) disk blocks to report t points on a straight line. Several data structures have been proposed in the literature to handle region data. These include the R-tree [15], the R + -tree <ref> [32] </ref>, the cell tree [14] and many others. These data structures are not directly applicable to point data. However, they can deal with 1-dimensional range data and hence are relevant to our problem.
Reference: [33] <author> D. D. Sleator and R. E. Tarjan, </author> <title> "A Data Structure for Dynamic Trees," </title> <editor> J. </editor> <booktitle> Computer and System Sciences 24 (1983), </booktitle> <pages> 362-381. </pages>
Reference-contexts: to achieve optimal query time for this problem (O (log B n + t=B) disk I/O's) with only one copy of each object in secondary storage. (For lower bounds on range searching in main memory, see [12] and [6].) In Section 4, analyzing the hierarchy using the hierarchical decomposition of <ref> [33] </ref> and using techniques from the constraint indexing problem, we improve query I/O time to O (log B n + t=B + log 2 B) using space O ((n=B) log 2 c) pages. <p> The procedure trivially extends to forest hierarchies. Before that, we need an algorithm that enables us to decide which of the two lemmas to apply on which part of the hierarchy. The idea for the hierarchy tree labeling algorithm is from a dynamic tree algorithm of <ref> [33] </ref>. The following lemma is easily proven by induction. Lemma 4.5 Let the procedure label-edges shown in Figure 22 be applied to an arbitrary hierarchy tree of size c.
Reference: [34] <author> M. H. M. Smid and M. H. Overmars, </author> <title> "Maintaining Range Trees in Secondary Memory: Part II: Lower Bounds," </title> <journal> Acta Informatica 27 (1990), </journal> <pages> 453-480. </pages>
Reference: [35] <author> J. S. Vitter, </author> <title> "Efficient Memory Access in Large-Scale Computation," </title> <booktitle> 1991 Symposium on Theoretical Aspects of Computer Science (STACS), Lecture Notes in Computer Science, </booktitle> <year> (1991), </year> <type> invited paper. </type>
Reference-contexts: The I/O bounds will be expressed in terms of n; c; t and B, i.e., all constants will be independent of these four parameters. (For a survey of state of the art I/O complexity, see <ref> [35] </ref>.) We will first review B + -tree performance since we will use that as our point of reference. A B + -tree on attribute x of the n-tuple relation R uses O (n=B) pages of secondary storage.
Reference: [36] <author> S. Zdonik and D. Maier, </author> <title> Readings in Object-Oriented Database Systems, </title> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
References-found: 36

