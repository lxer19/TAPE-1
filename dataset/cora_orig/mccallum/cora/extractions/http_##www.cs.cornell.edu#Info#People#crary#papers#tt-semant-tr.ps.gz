URL: http://www.cs.cornell.edu/Info/People/crary/papers/tt-semant-tr.ps.gz
Refering-URL: http://www.cs.cornell.edu/Info/People/crary/papers/
Root-URL: 
Title: Programming Language Semantics in Foundational Type Theory  
Author: Karl Crary 
Date: February 28, 1998  
Affiliation: Cornell University  
Abstract: There are compelling benefits to using foundational type theory as a framework for programming language semantics. I give a semantics of an expressive programming calculus in the foundational type theory of Nuprl. Previous type-theoretic semantics have used less expressive type theories, or have sacrificed important programming constructs such as recursion and modules. The primary mechanisms of this semantics for the core calculus are partial types, for typing recursion, set types, for encoding power and singleton kinds, which are used for subtyping and module programming, and very dependent function types, for encoding signatures. I then extend the semantics to modules using phase-splitting.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Stuart Allen. </author> <title> A non-type-theoretic definition of Martin-Lof's types. </title> <booktitle> In Second IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 215-221, </pages> <address> Ithaca, New York, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: This semantics is also useful even if one ultimately desires a semantics in some framework other than type theory. Martin-Lof type theory is closely tied to a structured operational semantics and has denotational models in many frameworks including partial equivalence relations <ref> [1, 23] </ref>, set theory [33] and domain theory [49, 46, 45]. Thus, foundational type theory may be used as a "semantic intermediate language." The paper is organized as follows: Section 2 presents the paper's object language, K . <p> Most importantly, type theory provides structured data and an intrinsic notion of computation. Non-type-theoretic models of type theory can expose the "scaffolding" when one desires the details of how that structure may be implemented <ref> [1, 23, 17] </ref>. As a theory of structured data and computation, type theory is itself a very expressive programming language. Practical programming languages are less expressive, but offer properties that foundational type theory does not, such as decidable type checking.
Reference: [2] <author> Bruno Barras, Samuel Boutin, Cristina Cornes, Judicael Courant, Jean-Christophe Filli^atre, Eduardo Gimenez, Hugo Herbelin, Gerard Huet, Cesar Mu~noz, Chetan Murthy, Catherine Parent, Christine Paulin-Mohring, Amokrane Sabi, and Benjamin Werner. </author> <title> The Coq Proof Assistant Reference Manual. </title> <institution> INRIA-Rocquencourt, CNRS and ENS Lyon, </institution> <year> 1996. </year>
Reference-contexts: 1 Introduction Type theory has become a popular framework for formal reasoning in computer science [7, 38, 21] and has formed the basis for a number of automated deduction systems, including Automath, Nuprl, HOL and Coq <ref> [18, 5, 22, 2] </ref>, among others. In addition to formalizing mathematics, these systems are widely used for the analysis and verification of computer programs.
Reference: [3] <author> Lars Birkedal and Robert Harper. </author> <title> Relational interpretations of recursive types in an operational setting. </title> <booktitle> In Theoretical Aspects of Computer Software, </booktitle> <year> 1997. </year>
Reference-contexts: Type theory may express recursive types with only positive occurrences, but to allow negative occurrences is an open problem. 7 7 See Birkedal and Harper <ref> [3] </ref> for a promising approach that may lead to a solution of this problem. 19 The other main problem arising with a monadic interpretation of state has to do with predicativity.
Reference: [4] <author> Luca Cardelli. </author> <title> Phase distinctions in type theory. </title> <type> Manuscript, </type> <month> January </month> <year> 1988. </year>
Reference-contexts: Proof Not difficult, but outside the scope of this paper (see Crary [17]). Corollary 3 (Type Preservation) If ` K e : t and [[e]] 7! fl t then t 2 [[t ]]. Another consequence of the soundness theorem is that the phase distinction <ref> [4, 27] </ref> is respected in K : all type expressions converge and therefore types may be computed in a compile-time phase. This is expressed by Corollary 4: Corollary 4 (Phase Distinction) If ` K c : then there exists canonical t such that [[c]] 7! fl t.
Reference: [5] <author> R.L. Constable, S.F. Allen, H.M. Bromley, W.R. Cleaveland, J.F. Cremer, R.W. Harper, D.J. Howe, T.B. Knoblock, N.P. Mendler, P. Panangaden, J.T. Sasaki, and S.F. Smith. </author> <title> Implementing Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: 1 Introduction Type theory has become a popular framework for formal reasoning in computer science [7, 38, 21] and has formed the basis for a number of automated deduction systems, including Automath, Nuprl, HOL and Coq <ref> [18, 5, 22, 2] </ref>, among others. In addition to formalizing mathematics, these systems are widely used for the analysis and verification of computer programs. <p> The logic of types is obtained through the propositions-as-types isomorphism [31], but this will not be critical to our purposes. Detailed discussions of type theory, including the logic of types, appear in Martin-Lof [38, 39] and Constable [7, 8], and Nuprl specifically is discussed in Constable et al. <ref> [5] </ref>. As in the previous section, the discussion here assumes knowledge of several well-known programming constructs.
Reference: [6] <author> Robert L. Constable. </author> <title> Constructive mathematics as a programming logic I: Some principles of theory. </title> <booktitle> In Topics in the Theory of Computation, volume 24 of Annals of Discrete Mathematics, </booktitle> <pages> pages 21-37. </pages> <publisher> Elsevier, </publisher> <year> 1985. </year> <booktitle> Selected papers of the International Conference on Foundations of Computation Theory 1983. </booktitle>
Reference-contexts: The power kind P i (t ) contains only subtypes of t and the singleton kind S i (t ) contains only types that are equal to t ; other types must be left out. The mechanism for achieving this exclusion is the set type <ref> [6] </ref>. If S is a type and P [] is a predicate over S, then the set type fz : S j P [z]g contains all elements z of S such that P [z] is true.
Reference: [7] <author> Robert L. Constable. </author> <title> Type theory as a foundation for computer science. </title> <booktitle> In Theoretical Aspects of Computer Software 1991, volume 526 of Lecture Notes in Computer Science, </booktitle> <pages> pages 226-243, </pages> <address> Sendai, Japan, 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: 1 Introduction Type theory has become a popular framework for formal reasoning in computer science <ref> [7, 38, 21] </ref> and has formed the basis for a number of automated deduction systems, including Automath, Nuprl, HOL and Coq [18, 5, 22, 2], among others. In addition to formalizing mathematics, these systems are widely used for the analysis and verification of computer programs. <p> The logic of types is obtained through the propositions-as-types isomorphism [31], but this will not be critical to our purposes. Detailed discussions of type theory, including the logic of types, appear in Martin-Lof [38, 39] and Constable <ref> [7, 8] </ref>, and Nuprl specifically is discussed in Constable et al. [5]. As in the previous section, the discussion here assumes knowledge of several well-known programming constructs.
Reference: [8] <author> Robert L. Constable. </author> <title> Types in logic, mathematics and programming. In Sam Buss, editor, Handbook of Proof Theory, chapter 10. </title> <publisher> Elsevier Science, </publisher> <year> 1998. </year>
Reference-contexts: The logic of types is obtained through the propositions-as-types isomorphism [31], but this will not be critical to our purposes. Detailed discussions of type theory, including the logic of types, appear in Martin-Lof [38, 39] and Constable <ref> [7, 8] </ref>, and Nuprl specifically is discussed in Constable et al. [5]. As in the previous section, the discussion here assumes knowledge of several well-known programming constructs.
Reference: [9] <author> Robert L. Constable and Karl Crary. </author> <title> Computational complexity and induction for partial computable functions in type theory. </title> <type> Technical report, </type> <institution> Department of Computer Science, Cornell University, </institution> <year> 1997. </year>
Reference-contexts: It is clear, then, that fix cannot be used to define new members of the basic types. How then can recursive functions be typed? The solution is to add a new type constructor for partial types <ref> [10, 11, 51, 9, 17] </ref>. <p> For any type T , the partial type T is a supertype of T that contains all the elements of T and also all divergent terms. (A total type is one that contains only convergent terms.) The induction principles on T <ref> [51, 9] </ref> are different than those on T , so we can safely type fix with the rule: 2 H ` - e 2 T ! T H ` - T admissible H ` fix (e) 2 T We use partial types to interpret the possibly non-terminating computations of K .
Reference: [10] <author> Robert L. Constable and Scott Fraser Smith. </author> <title> Partial objects in constructive type theory. </title> <booktitle> In Second IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 183-193, </pages> <address> Ithaca, New York, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: It is clear, then, that fix cannot be used to define new members of the basic types. How then can recursive functions be typed? The solution is to add a new type constructor for partial types <ref> [10, 11, 51, 9, 17] </ref>.
Reference: [11] <author> Robert L. Constable and Scott Fraser Smith. </author> <title> Computational foundations of basic recursive function theory. </title> <booktitle> In Third IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 360-371, </pages> <address> Edinburgh, Scotland, </address> <month> July </month> <year> 1988. </year>
Reference-contexts: It is clear, then, that fix cannot be used to define new members of the basic types. How then can recursive functions be typed? The solution is to add a new type constructor for partial types <ref> [10, 11, 51, 9, 17] </ref>.
Reference: [12] <author> Thierry Coquand. </author> <title> An analysis of Girard's paradox. </title> <booktitle> In First IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 227-236, </pages> <address> Cambridge, Massachusetts, </address> <month> June </month> <year> 1986. </year>
Reference-contexts: To handle polymorphism we want to have functions that can take types as arguments. These can be typed with the dependent types discussed above if one adds a type of all types. Unfortunately, a single type of all types is known to make the theory inconsistent <ref> [20, 12, 41, 32] </ref>, so instead the type theory includes a predicative hierarchy of universes, U 1 ; U 2 ; U 3 ; etc.
Reference: [13] <author> Thierry Coquand. </author> <title> Metamathematical investigations of a calculus of constructions. </title> <editor> In P. Odifreddi, editor, </editor> <booktitle> Logic and Computer Science, volume 31 of The APIC Series, </booktitle> <pages> pages 91-122. </pages> <publisher> Academic Press, </publisher> <year> 1990. </year>
Reference-contexts: The type theory of Mendler [40] provides such impredicative features and is quite similar to Nuprl; I have not used that framework in this paper out of desire to use a simpler and more standard theory. The Calculus of Constructions <ref> [14, 13] </ref> also supplies impredicative features and could likely also support the semantics in this paper. 6 Conclusion I have shown how to give a type-theoretic semantics to an expressive programming calculus.
Reference: [14] <author> Thierry Coquand and Gerard Huet. </author> <title> The calculus of constructions. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 95-120, </pages> <year> 1988. </year>
Reference-contexts: The type theory of Mendler [40] provides such impredicative features and is quite similar to Nuprl; I have not used that framework in this paper out of desire to use a simpler and more standard theory. The Calculus of Constructions <ref> [14, 13] </ref> also supplies impredicative features and could likely also support the semantics in this paper. 6 Conclusion I have shown how to give a type-theoretic semantics to an expressive programming calculus.
Reference: [15] <author> Karl Crary. </author> <title> Foundations for the implementation of higher-order subtyping. </title> <booktitle> In 1997 ACM SIGPLAN International Conference on Functional Programming, </booktitle> <pages> pages 125-135, </pages> <address> Amsterdam, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: Formal reasoning aside, embedding programming languages into type theory allows a researcher to bring the full power of type theory to bear on a programming problem. For example, Crary <ref> [15] </ref> used a type-theoretic interpretation to expose the relation of power kinds to a nonconstructive set type. Adjusting this interpretation to make the power kind constructive resulted in a proof-passing technique used to implement higher-order coercive subtyping in KML.
Reference: [16] <author> Karl Crary. </author> <title> Admissibility of fixpoint induction over partial types. </title> <type> Technical report, </type> <institution> Department of Computer Science, Cornell University, </institution> <year> 1998. </year>
Reference-contexts: This condition is required because fixpoint induction can be derived from the recursive typing rule [51]. However, all the types used in the embedding in this paper are admissible, so I ignore the admissibility condition in this paper. Additional details appear in Smith [51] and Crary <ref> [16, 17] </ref>. 3 This terminology can be somewhat confusing. A total type is one that contains only convergent expressions.
Reference: [17] <author> Karl Crary. </author> <title> Type-Theoretic Methodology for Practical Programming Languages. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, New York, </address> <year> 1998. </year> <month> Forthcoming. </month>
Reference-contexts: Section 5 discusses promising directions for future work. Finally, Section 6 contains brief concluding remarks. 2 The Lambda-K Programming Calculus As a case study to illustrate my technique, I use a predicative variant of K , the high-level typed intermediate language in the KML compiler <ref> [17] </ref>. In this section I discuss K . In the interest of brevity, the discussion assumes knowledge of several well-known programming constructs. Further discussion of the design of K appears in Crary [17]. The syntax rules of K appear in Figure 1. <p> technique, I use a predicative variant of K , the high-level typed intermediate language in the KML compiler <ref> [17] </ref>. In this section I discuss K . In the interest of brevity, the discussion assumes knowledge of several well-known programming constructs. Further discussion of the design of K appears in Crary [17]. The syntax rules of K appear in Figure 1. <p> Often the proposition P will be an assertion of equality or membership in a type. The basic operators discussed above are summarized in Figure 3. The reader is referred to Crary <ref> [17] </ref> for the inference rules for the ` judgement. Note that the lambda abstractions of Nuprl are untyped, unlike those of K . In addition to the operators discussed here, the type theory contains some other less familiar type constructors: the partial type, set type and very dependent function type. <p> It is clear, then, that fix cannot be used to define new members of the basic types. How then can recursive functions be typed? The solution is to add a new type constructor for partial types <ref> [10, 11, 51, 9, 17] </ref>. <p> This condition is required because fixpoint induction can be derived from the recursive typing rule [51]. However, all the types used in the embedding in this paper are admissible, so I ignore the admissibility condition in this paper. Additional details appear in Smith [51] and Crary <ref> [16, 17] </ref>. 3 This terminology can be somewhat confusing. A total type is one that contains only convergent expressions. <p> Type preservation of K (Corollary 3) follows directly from soundness and type preservation of Nuprl (Proposition 2). Proposition 2 If ` - t 2 T and t 7! fl t 0 then t 0 2 T . Proof Not difficult, but outside the scope of this paper (see Crary <ref> [17] </ref>). Corollary 3 (Type Preservation) If ` K e : t and [[e]] 7! fl t then t 2 [[t ]]. <p> Most importantly, type theory provides structured data and an intrinsic notion of computation. Non-type-theoretic models of type theory can expose the "scaffolding" when one desires the details of how that structure may be implemented <ref> [1, 23, 17] </ref>. As a theory of structured data and computation, type theory is itself a very expressive programming language. Practical programming languages are less expressive, but offer properties that foundational type theory does not, such as decidable type checking.
Reference: [18] <author> N. G. de Bruijn. </author> <title> A survey of the project Automath. </title> <editor> In J. P. Seldin and J. R. Hindley, editors, </editor> <booktitle> To H.B. Curry: Essays on Combinatory Logic, Lambda-Calculus and Formalism, </booktitle> <pages> pages 579-606. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year> <month> 21 </month>
Reference-contexts: 1 Introduction Type theory has become a popular framework for formal reasoning in computer science [7, 38, 21] and has formed the basis for a number of automated deduction systems, including Automath, Nuprl, HOL and Coq <ref> [18, 5, 22, 2] </ref>, among others. In addition to formalizing mathematics, these systems are widely used for the analysis and verification of computer programs.
Reference: [19] <author> Jean-Yves Girard. </author> <title> Une extension de l'interpretation de Godel a l'analyse, et son application a l'elimination de coupures dans l'analyse et la theorie des types. </title> <editor> In J. E. Fenstad, editor, </editor> <booktitle> Proceedings of the Second Scandinavian Logic Symposium, </booktitle> <pages> pages 63-92. </pages> <publisher> North-Holland Publishing Co., </publisher> <year> 1971. </year>
Reference-contexts: Further discussion of the design of K appears in Crary [17]. The syntax rules of K appear in Figure 1. The overall structure of the core calculus (that is, K minus modules and signatures) is similar to the higher-order polymorphic lambda calculus <ref> [19, 20] </ref> augmented with records at the term and type constructor level (and their corresponding types and kinds), and a fixpoint operator at the term level.
Reference: [20] <author> Jean-Yves Girard. </author> <title> Interpretation fonctionelle et elimination des coupures de l'arithmetique d'ordre superieur. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: Further discussion of the design of K appears in Crary [17]. The syntax rules of K appear in Figure 1. The overall structure of the core calculus (that is, K minus modules and signatures) is similar to the higher-order polymorphic lambda calculus <ref> [19, 20] </ref> augmented with records at the term and type constructor level (and their corresponding types and kinds), and a fixpoint operator at the term level. <p> To handle polymorphism we want to have functions that can take types as arguments. These can be typed with the dependent types discussed above if one adds a type of all types. Unfortunately, a single type of all types is known to make the theory inconsistent <ref> [20, 12, 41, 32] </ref>, so instead the type theory includes a predicative hierarchy of universes, U 1 ; U 2 ; U 3 ; etc.
Reference: [21] <author> Jean-Yves Girard, Yves Lafont, and Paul Taylor. </author> <title> Proofs and Types. </title> <publisher> Cambridge University Press, </publisher> <year> 1988. </year>
Reference-contexts: 1 Introduction Type theory has become a popular framework for formal reasoning in computer science <ref> [7, 38, 21] </ref> and has formed the basis for a number of automated deduction systems, including Automath, Nuprl, HOL and Coq [18, 5, 22, 2], among others. In addition to formalizing mathematics, these systems are widely used for the analysis and verification of computer programs.
Reference: [22] <author> Michael J. C. Gordon and Tom F. Melham. </author> <title> Introduction to HOL: A Theorem Proving Environment for Higher-Order Logic. </title> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction Type theory has become a popular framework for formal reasoning in computer science [7, 38, 21] and has formed the basis for a number of automated deduction systems, including Automath, Nuprl, HOL and Coq <ref> [18, 5, 22, 2] </ref>, among others. In addition to formalizing mathematics, these systems are widely used for the analysis and verification of computer programs.
Reference: [23] <author> Robert Harper. </author> <title> Constructing type systems over an operational semantics. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 14 </volume> <pages> 71-84, </pages> <year> 1992. </year>
Reference-contexts: This semantics is also useful even if one ultimately desires a semantics in some framework other than type theory. Martin-Lof type theory is closely tied to a structured operational semantics and has denotational models in many frameworks including partial equivalence relations <ref> [1, 23] </ref>, set theory [33] and domain theory [49, 46, 45]. Thus, foundational type theory may be used as a "semantic intermediate language." The paper is organized as follows: Section 2 presents the paper's object language, K . <p> Most importantly, type theory provides structured data and an intrinsic notion of computation. Non-type-theoretic models of type theory can expose the "scaffolding" when one desires the details of how that structure may be implemented <ref> [1, 23, 17] </ref>. As a theory of structured data and computation, type theory is itself a very expressive programming language. Practical programming languages are less expressive, but offer properties that foundational type theory does not, such as decidable type checking.
Reference: [24] <author> Robert Harper and Mark Lillibridge. </author> <title> Explicit polymorphism and CPS conversion. </title> <booktitle> In Twentieth ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 206-219, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: If two languages are given type-theoretic semantics, then one may use type theory to show relationships between the two, and when the semantics are simple, those relationships need be no more complicated than the inherent differences between the two. This is particularly useful in the area of type-directed compilation <ref> [52, 43, 36, 24, 44] </ref>. The process of type-directed compilation consists (in part) of translations between various typed intermediate languages. Embedding each into a common foundational type theory provides an ideal framework for showing the invariance of program meaning throughout the compilation process.
Reference: [25] <author> Robert Harper and Mark Lillibridge. </author> <title> A type-theoretic approach to higher-order modules with sharing. </title> <booktitle> In Twenty-First ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 123-137, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: and the dependent record kind f` 1 . ff 1 : 1 ; : : : ; ` n . ff n : n g where each ` i is an external name (or label) and each ff i is an internal name (or binding occurrence; see Harper and Lillibridge <ref> [25] </ref> for discussion of internal and external names). Evaluation is intended to be call-by-value.
Reference: [26] <author> Robert Harper and John C. Mitchell. </author> <title> On the type structure of Standard ML. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(2) </volume> <pages> 211-252, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: Formal connections have been drawn in the work of Reynolds [48] and Harper and Mitchell <ref> [26] </ref>, each of whom sought to use type-theoretic analysis to explain an entire programming language. Reynolds gave a type-theoretic interpretation of Idealized Algol, and Harper and Mitchell did the same for a simplified fragment of Standard ML.
Reference: [27] <author> Robert Harper, John C. Mitchell, and Eugenio Moggi. </author> <title> Higher-order modules and the phase distinction. </title> <booktitle> In Seventeenth ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 341-354, </pages> <address> San Francisco, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: This is reflected in the type-theoretic semantics by an embedding that explicitly phase-splits modules into two parts. The technique used is derived from Harper, et al. <ref> [27] </ref>. The embeddings for modules and signatures are given by two syntax-directed mappings, [[ ]] c and [[ ]] r , one for the compile-time component of the given expression and one for the run time component. <p> Proof Not difficult, but outside the scope of this paper (see Crary [17]). Corollary 3 (Type Preservation) If ` K e : t and [[e]] 7! fl t then t 2 [[t ]]. Another consequence of the soundness theorem is that the phase distinction <ref> [4, 27] </ref> is respected in K : all type expressions converge and therefore types may be computed in a compile-time phase. This is expressed by Corollary 4: Corollary 4 (Phase Distinction) If ` K c : then there exists canonical t such that [[c]] 7! fl t.
Reference: [28] <author> Robert Harper and Chris Stone. </author> <title> An interpretation of Standard ML in type theory. </title> <type> Technical Report CMU-CS-97-147, </type> <institution> Carnegie Mellon University, School of Computer Science, </institution> <month> June </month> <year> 1997. </year>
Reference-contexts: This object language is a small programming calculus, not a practical programming language, so a formal elaborator must be invoked to relate these results to a full programming language. I do not present such an elaborator in this paper, but see Harper and Stone <ref> [29, 28] </ref> for a presentation of such an elaborator. Section 3 contains an overview of Nuprl, the foundational type theory I use in this paper. Section 4 contains the embedding that is the central technical contribution of the paper. Section 5 discusses promising directions for future work.
Reference: [29] <author> Robert Harper and Chris Stone. </author> <title> A type-theoretic interpretation of Standard ML. In Proof, Language and Interaction: Essays in Honour of Robin Milner. </title> <publisher> The MIT Press, </publisher> <year> 1998. </year> <note> To appear. </note>
Reference-contexts: Reynolds gave a type-theoretic interpretation of Idealized Algol, and Harper and Mitchell did the same for a simplified fragment of Standard ML. Recently, Harper and Stone <ref> [29] </ref> have given such an interpretation of full Standard ML (Revised) [42]. However, in each of these cases, the type theories used were not sufficiently rich to form a foundation for mathematical reasoning; for example, they were unable to express equality or induction principles. <p> This object language is a small programming calculus, not a practical programming language, so a formal elaborator must be invoked to relate these results to a full programming language. I do not present such an elaborator in this paper, but see Harper and Stone <ref> [29, 28] </ref> for a presentation of such an elaborator. Section 3 contains an overview of Nuprl, the foundational type theory I use in this paper. Section 4 contains the embedding that is the central technical contribution of the paper. Section 5 discusses promising directions for future work. <p> The constructor equality judgement ` K c 1 = c 2 : indicates that c 1 and c 2 are equal as members of kind . The typing judgement ` K e : c indicates that the term e has type c. Finally, the valuability judgement <ref> [29] </ref> ` K e # c indicates that the term e has type c and evaluates without computational effects (in this setting this means just that it terminates).
Reference: [30] <author> Jason J. Hickey. </author> <title> Formal objects in type theory using very dependent types. </title> <booktitle> In Foundations of Object Oriented Languages 3, </booktitle> <year> 1996. </year>
Reference-contexts: So we want a type of functions whose return type can depend not only upon their arguments but upon their own return values! The type I will use for this embedding is Hickey's very dependent function type <ref> [30] </ref>. This type is a generalization of the dependent function type (itself a generalization of the ordinary function type) and like it, the very dependent function type's members are just lambda abstractions. The difference is in the specification of a function's return type.
Reference: [31] <author> W. Howard. </author> <title> The formulas-as-types notion of construction. </title> <editor> In J. P. Seldin and J. R. Hindley, editors, </editor> <booktitle> To H.B. Curry: Essays on Combinatory Logic, Lambda-Calculus and Formalism, </booktitle> <pages> pages 479-490. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: It is primarily those programming features that I will use in the embedding. The logic of types is obtained through the propositions-as-types isomorphism <ref> [31] </ref>, but this will not be critical to our purposes. Detailed discussions of type theory, including the logic of types, appear in Martin-Lof [38, 39] and Constable [7, 8], and Nuprl specifically is discussed in Constable et al. [5].
Reference: [32] <author> Douglas J. Howe. </author> <title> The computational behaviour of Girard's paradox. </title> <booktitle> In Second IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 205-214, </pages> <address> Ithaca, New York, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: To handle polymorphism we want to have functions that can take types as arguments. These can be typed with the dependent types discussed above if one adds a type of all types. Unfortunately, a single type of all types is known to make the theory inconsistent <ref> [20, 12, 41, 32] </ref>, so instead the type theory includes a predicative hierarchy of universes, U 1 ; U 2 ; U 3 ; etc.
Reference: [33] <author> Douglas J. Howe. </author> <title> Semantic foundations for embedding HOL in Nuprl. </title> <type> Technical report, </type> <institution> Bell Labs, </institution> <year> 1996. </year>
Reference-contexts: This semantics is also useful even if one ultimately desires a semantics in some framework other than type theory. Martin-Lof type theory is closely tied to a structured operational semantics and has denotational models in many frameworks including partial equivalence relations [1, 23], set theory <ref> [33] </ref> and domain theory [49, 46, 45]. Thus, foundational type theory may be used as a "semantic intermediate language." The paper is organized as follows: Section 2 presents the paper's object language, K .
Reference: [34] <author> Christoph Kreitz. </author> <title> Formal reasoning about communications systems I. </title> <type> Technical report, </type> <institution> Department of Computer Science, Cornell University, </institution> <year> 1997. </year>
Reference-contexts: However, in each of these cases, the type theories used were not sufficiently rich to form a foundation for mathematical reasoning; for example, they were unable to express equality or induction principles. On the other hand, Kreitz <ref> [34] </ref> gave an embedding of a fragment of Objective CAML [37] into the foundational type theory of Nuprl.
Reference: [35] <author> John Launchbury and Simon L. Peyton Jones. </author> <title> State in Haskell. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 8(4) </volume> <pages> 293-341, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: One promising device for doing this is to encode stateful computations as monads <ref> [47, 35] </ref>, but this raises two difficulties. In order to encode references in monads, all expressions that may side-effect the store must take the store as an argument. The problem is how to assign a type to the store.
Reference: [36] <author> Xavier Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Nineteenth ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 177-188, </pages> <year> 1992. </year>
Reference-contexts: If two languages are given type-theoretic semantics, then one may use type theory to show relationships between the two, and when the semantics are simple, those relationships need be no more complicated than the inherent differences between the two. This is particularly useful in the area of type-directed compilation <ref> [52, 43, 36, 24, 44] </ref>. The process of type-directed compilation consists (in part) of translations between various typed intermediate languages. Embedding each into a common foundational type theory provides an ideal framework for showing the invariance of program meaning throughout the compilation process.
Reference: [37] <author> Xavier Leroy. </author> <title> The Objective Caml System, Release 1.00. </title> <institution> Institut National de Recherche en Informatique et Automatique (INRIA), </institution> <year> 1996. </year> <note> Available at http://pauillac.inria.fr/ocaml. </note>
Reference-contexts: However, in each of these cases, the type theories used were not sufficiently rich to form a foundation for mathematical reasoning; for example, they were unable to express equality or induction principles. On the other hand, Kreitz [34] gave an embedding of a fragment of Objective CAML <ref> [37] </ref> into the foundational type theory of Nuprl. However, this fragment omitted some important constructs, such as recursion and modules. fl This material is based on work supported in part by ARPA/AF grant F30602-95-1-0047, NSF grant CCR-9244739, and AASERT grant N00014-95-1-0985.
Reference: [38] <author> Per Martin-Lof. </author> <title> An intuitionistic theory of types: Predicative part. </title> <booktitle> In Proceedings of the Logic Colloquium, 1973, volume 80 of Studies in Logic and the Foundations of Mathematics, </booktitle> <pages> pages 73-118. </pages> <publisher> North-Holland, </publisher> <year> 1975. </year> <month> 22 </month>
Reference-contexts: 1 Introduction Type theory has become a popular framework for formal reasoning in computer science <ref> [7, 38, 21] </ref> and has formed the basis for a number of automated deduction systems, including Automath, Nuprl, HOL and Coq [18, 5, 22, 2], among others. In addition to formalizing mathematics, these systems are widely used for the analysis and verification of computer programs. <p> It is primarily those programming features that I will use in the embedding. The logic of types is obtained through the propositions-as-types isomorphism [31], but this will not be critical to our purposes. Detailed discussions of type theory, including the logic of types, appear in Martin-Lof <ref> [38, 39] </ref> and Constable [7, 8], and Nuprl specifically is discussed in Constable et al. [5]. As in the previous section, the discussion here assumes knowledge of several well-known programming constructs.
Reference: [39] <author> Per Martin-Lof. </author> <title> Constructive mathematics and computer programming. </title> <booktitle> In Sixth International Congress of Logic, Methodology and Philosophy of Science, volume 104 of Studies in Logic and the Foundations of Mathematics, </booktitle> <pages> pages 153-175. </pages> <publisher> North-Holland, </publisher> <year> 1982. </year>
Reference-contexts: It is primarily those programming features that I will use in the embedding. The logic of types is obtained through the propositions-as-types isomorphism [31], but this will not be critical to our purposes. Detailed discussions of type theory, including the logic of types, appear in Martin-Lof <ref> [38, 39] </ref> and Constable [7, 8], and Nuprl specifically is discussed in Constable et al. [5]. As in the previous section, the discussion here assumes knowledge of several well-known programming constructs.
Reference: [40] <author> Paul Francis Mendler. </author> <title> Inductive Definition in Type Theory. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, New York, </address> <month> September </month> <year> 1987. </year>
Reference-contexts: A more general solution would be to use a type theory with impredicative features. In addition to solving this problem, this would also eliminate the need for level annotations in the source calculus. The type theory of Mendler <ref> [40] </ref> provides such impredicative features and is quite similar to Nuprl; I have not used that framework in this paper out of desire to use a simpler and more standard theory.
Reference: [41] <author> Albert R. Meyer and Mark B. Reinhold. </author> <title> `Type' is not a type. </title> <booktitle> In Thirteenth ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 287-295, </pages> <address> St. Petersburg Beach, Florida, </address> <month> January </month> <year> 1986. </year>
Reference-contexts: To handle polymorphism we want to have functions that can take types as arguments. These can be typed with the dependent types discussed above if one adds a type of all types. Unfortunately, a single type of all types is known to make the theory inconsistent <ref> [20, 12, 41, 32] </ref>, so instead the type theory includes a predicative hierarchy of universes, U 1 ; U 2 ; U 3 ; etc.
Reference: [42] <author> Robin Milner, Mads Tofte, Robert Harper, and David MacQueen. </author> <title> The Definition of Standard ML (Revised). </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1997. </year>
Reference-contexts: Reynolds gave a type-theoretic interpretation of Idealized Algol, and Harper and Mitchell did the same for a simplified fragment of Standard ML. Recently, Harper and Stone [29] have given such an interpretation of full Standard ML (Revised) <ref> [42] </ref>. However, in each of these cases, the type theories used were not sufficiently rich to form a foundation for mathematical reasoning; for example, they were unable to express equality or induction principles.
Reference: [43] <author> Greg Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, School of Computer Science, Pittsburgh, Pennsylvania, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: If two languages are given type-theoretic semantics, then one may use type theory to show relationships between the two, and when the semantics are simple, those relationships need be no more complicated than the inherent differences between the two. This is particularly useful in the area of type-directed compilation <ref> [52, 43, 36, 24, 44] </ref>. The process of type-directed compilation consists (in part) of translations between various typed intermediate languages. Embedding each into a common foundational type theory provides an ideal framework for showing the invariance of program meaning throughout the compilation process.
Reference: [44] <author> Greg Morrisett, David Walker, Karl Crary, and Neal Glew. </author> <title> From System F to typed assembly language. </title> <booktitle> In Twenty-Fifth ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 85-97, </pages> <address> San Diego, </address> <month> January </month> <year> 1998. </year> <note> Extended version published as Cornell University technical report TR97-1651. </note>
Reference-contexts: If two languages are given type-theoretic semantics, then one may use type theory to show relationships between the two, and when the semantics are simple, those relationships need be no more complicated than the inherent differences between the two. This is particularly useful in the area of type-directed compilation <ref> [52, 43, 36, 24, 44] </ref>. The process of type-directed compilation consists (in part) of translations between various typed intermediate languages. Embedding each into a common foundational type theory provides an ideal framework for showing the invariance of program meaning throughout the compilation process.
Reference: [45] <author> Erik Palmgren. </author> <title> An information system interpretation of Martin-Lof's partial type theory with universes. </title> <journal> Information and Computation, </journal> <volume> 106 </volume> <pages> 26-60, </pages> <year> 1993. </year>
Reference-contexts: This semantics is also useful even if one ultimately desires a semantics in some framework other than type theory. Martin-Lof type theory is closely tied to a structured operational semantics and has denotational models in many frameworks including partial equivalence relations [1, 23], set theory [33] and domain theory <ref> [49, 46, 45] </ref>. Thus, foundational type theory may be used as a "semantic intermediate language." The paper is organized as follows: Section 2 presents the paper's object language, K .
Reference: [46] <author> Erik Palmgren and Viggo Stoltenberg-Hansen. </author> <title> Domain interpretations of intuitionistic type theory. U.U.D.M. </title> <type> Report 1989:1, </type> <institution> Uppsala University, Department of Mathematics, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: This semantics is also useful even if one ultimately desires a semantics in some framework other than type theory. Martin-Lof type theory is closely tied to a structured operational semantics and has denotational models in many frameworks including partial equivalence relations [1, 23], set theory [33] and domain theory <ref> [49, 46, 45] </ref>. Thus, foundational type theory may be used as a "semantic intermediate language." The paper is organized as follows: Section 2 presents the paper's object language, K .
Reference: [47] <editor> Simon L. Peyton Jones and Philip Wadler. </editor> <title> Imperative functional programming. </title> <booktitle> In Twentieth ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <address> Charleston, South Carolina, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: One promising device for doing this is to encode stateful computations as monads <ref> [47, 35] </ref>, but this raises two difficulties. In order to encode references in monads, all expressions that may side-effect the store must take the store as an argument. The problem is how to assign a type to the store.
Reference: [48] <author> John C. Reynolds. </author> <title> The essence of Algol. </title> <editor> In J. W. de Bakker and J. C. van Vliet, editors, </editor> <booktitle> Proceedings of the International Symposium on Algorithmic Languages, </booktitle> <pages> pages 345-372, </pages> <address> Amsterdam, October 1981. </address> <publisher> North-Holland. </publisher>
Reference-contexts: To do this, one must draw a connection between the programming language used and the language of type theory; however, these connections have typically been informal translations, diminishing the significance of the formal verification results. Formal connections have been drawn in the work of Reynolds <ref> [48] </ref> and Harper and Mitchell [26], each of whom sought to use type-theoretic analysis to explain an entire programming language. Reynolds gave a type-theoretic interpretation of Idealized Algol, and Harper and Mitchell did the same for a simplified fragment of Standard ML.
Reference: [49] <author> Adrian Rezus. </author> <title> Semantics of constructive type theory. </title> <type> Technical Report 70, </type> <institution> Informatics Department, Faculty of Science, Nijmegen, University, </institution> <address> The Netherlands, </address> <month> September </month> <year> 1985. </year>
Reference-contexts: This semantics is also useful even if one ultimately desires a semantics in some framework other than type theory. Martin-Lof type theory is closely tied to a structured operational semantics and has denotational models in many frameworks including partial equivalence relations [1, 23], set theory [33] and domain theory <ref> [49, 46, 45] </ref>. Thus, foundational type theory may be used as a "semantic intermediate language." The paper is organized as follows: Section 2 presents the paper's object language, K .
Reference: [50] <author> Dana Scott and Christopher Strachey. </author> <title> Toward a mathematical semantics for computer languages. </title> <booktitle> In Proceedings of the Symposium on Computers and Automata, volume 21 of Microwave Research Institute Symposia Series. </booktitle> <institution> Polytechnic Institute of Brooklyn, </institution> <year> 1971. </year>
Reference-contexts: Adjusting this interpretation to make the power kind constructive resulted in a proof-passing technique used to implement higher-order coercive subtyping in KML. Furthermore, the simplicity of the semantics makes it attractive to use as a mathematical model similar in spirit, if not in detail, to the Scott-Strachey program <ref> [50] </ref>. This semantics works out so neatly because type theory provides built-in structure well-suited for analysis of programming. Most importantly, type theory provides structured data and an intrinsic notion of computation.
Reference: [51] <author> Scott Fraser Smith. </author> <title> Partial Objects in Type Theory. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, New York, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: It is clear, then, that fix cannot be used to define new members of the basic types. How then can recursive functions be typed? The solution is to add a new type constructor for partial types <ref> [10, 11, 51, 9, 17] </ref>. <p> For any type T , the partial type T is a supertype of T that contains all the elements of T and also all divergent terms. (A total type is one that contains only convergent terms.) The induction principles on T <ref> [51, 9] </ref> are different than those on T , so we can safely type fix with the rule: 2 H ` - e 2 T ! T H ` - T admissible H ` fix (e) 2 T We use partial types to interpret the possibly non-terminating computations of K . <p> This condition is required because fixpoint induction can be derived from the recursive typing rule <ref> [51] </ref>. However, all the types used in the embedding in this paper are admissible, so I ignore the admissibility condition in this paper. Additional details appear in Smith [51] and Crary [16, 17]. 3 This terminology can be somewhat confusing. A total type is one that contains only convergent expressions. <p> This condition is required because fixpoint induction can be derived from the recursive typing rule <ref> [51] </ref>. However, all the types used in the embedding in this paper are admissible, so I ignore the admissibility condition in this paper. Additional details appear in Smith [51] and Crary [16, 17]. 3 This terminology can be somewhat confusing. A total type is one that contains only convergent expressions.
Reference: [52] <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In 1996 ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 181-192, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: If two languages are given type-theoretic semantics, then one may use type theory to show relationships between the two, and when the semantics are simple, those relationships need be no more complicated than the inherent differences between the two. This is particularly useful in the area of type-directed compilation <ref> [52, 43, 36, 24, 44] </ref>. The process of type-directed compilation consists (in part) of translations between various typed intermediate languages. Embedding each into a common foundational type theory provides an ideal framework for showing the invariance of program meaning throughout the compilation process.
Reference: [53] <author> Andrew K. Wright. </author> <title> Simple imperative polymorphism. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 8(4) </volume> <pages> 343-356, </pages> <month> December </month> <year> 1995. </year> <month> 23 </month>
Reference-contexts: As with the 1 Partial polymorphic functions could easily be added, but seem rarely to be useful in practice <ref> [53] </ref>. 3 sig tycon foo : type module S1 : sig tycon bar : type tycon baz = foo -&gt; bar val gnurf : baz end val blap : S1.bar end f foo . s foo : hTypei; S1 . s S1 : f bar . s bar : hType i;
References-found: 53

