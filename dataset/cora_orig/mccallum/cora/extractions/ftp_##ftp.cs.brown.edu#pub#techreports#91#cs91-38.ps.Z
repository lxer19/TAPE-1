URL: ftp://ftp.cs.brown.edu/pub/techreports/91/cs91-38.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-91-38.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> F. Bancilhon and W. Kim, </author> <title> "Object-Oriented Database Systems: In Transition," </title> <booktitle> SIGMOD Record, </booktitle> <volume> vol. 19, </volume> <pages> pp. 49-53, </pages> <month> Dec </month> <year> 1990. </year>
Reference-contexts: Lanzelotte et al. also explore object navigation [18]. They view path expressions as a series of join operations and apply rewrite rules to a tree of join operators. Optimization in the presence of encapsulation and methods is a recognized problem that has not been solved <ref> [1] </ref>. Graefe and Ward propose to statically generate query evaluation plans with alternatives [12]. Information available about objects is used at execution time to choose among the alternatives and generate a final evaluation plan.
Reference: [2] <author> J. Banerjee et al., </author> <title> "Data Model Issues for Object-Oriented Applications," </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> vol. 5, </volume> <pages> pp. 3-26, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: In this paper we will study the query optimization problem in the context of an object-oriented type system. Thus, we will use the ENCORE database system as our example. ENCORE, as well as most object-oriented databases <ref> [2, 19, 23, 24, 34] </ref>, supports (among other features) abstract data types, type inheritance, and object identity. It provides the ability to extend the data model through abstract data types and subtyping. The extensibility of a model like ENCORE raises interesting problems in optimization that we will discuss later.
Reference: [3] <author> C. Beeri and Y. Kornatzky, </author> <title> "Algebraic Optimization of Object-Oriented Query Languages," </title> <booktitle> in Proceedings ICDT, </booktitle> <address> (Paris, France), </address> <year> 1990. </year>
Reference-contexts: The Gemstone database, for example, focuses on indexing for processing of queries that select from a class based on a predicate [22]. A variety of proposals have been made for optimization based on algebraic transformation rules for query operations <ref> [3, 20, 25, 31, 33] </ref>. For example, Straube and Ozsu [30] propose a methodology for query optimization that includes calculus-based optimization, the transformation of calculus-based queries to algebraic form, type-checking of algebraic expressions, the application of algebraic transformation axioms, and the generation of access plans for the algebraic operations. <p> For example, Straube and Ozsu [30] propose a methodology for query optimization that includes calculus-based optimization, the transformation of calculus-based queries to algebraic form, type-checking of algebraic expressions, the application of algebraic transformation axioms, and the generation of access plans for the algebraic operations. Beeri and Kornatzky <ref> [3] </ref> assume there exists a rule-based optimizer and provide an extensive set of rules for bulk data types. Current research on optimization in Orion [14] is directed toward the adaptation of relational techniques to the object-oriented database. In particular they explore efficient alternatives to object navigation.
Reference: [4] <author> E. Bertino and W. Kim, </author> <title> "Indexing Techniques for Queries on Nested Objects," </title> <type> Tech. Rep. </type> <institution> ACT-OODS-132-89, MCC, </institution> <year> 1989. </year>
Reference-contexts: The exploration and creation of such structures can lead to the regular use of path expressions to navigate through a structure. Current research on the optimization of path expressions involves the definition of indices for an expression <ref> [4, 22] </ref> and the use of Join operations to effect path navigation [5, 14, 16, 18]. Such research leads to new techniques for the optimization of query expressions.
Reference: [5] <author> S. Cluet and C. Delobel, </author> <title> "Towards a Unification of Rewrite Based Optimization Techniques for Object-Oriented Queries," </title> <type> tech. rep., Alta ir, B.P. 105, 78153, </type> <institution> Rocquencourt France, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: The exploration and creation of such structures can lead to the regular use of path expressions to navigate through a structure. Current research on the optimization of path expressions involves the definition of indices for an expression [4, 22] and the use of Join operations to effect path navigation <ref> [5, 14, 16, 18] </ref>. Such research leads to new techniques for the optimization of query expressions. The exploration of complex structures also can lead to nested query expressions in which variables from outer expressions are referenced in nested expressions. <p> Current research on optimization in Orion [14] is directed toward the adaptation of relational techniques to the object-oriented database. In particular they explore efficient alternatives to object navigation. Research on optimization in O 2 <ref> [5] </ref> combines this work with techniques that include the factorization of common subexpressions, cost-based application of query rewrite rules, and the use of indexes and clustering to guide the query rewrite process and aid in determining access plans.
Reference: [6] <author> U. Dayal, </author> <title> "Of Nests and Trees: A Unified Approach to Processing Queries That Contain Nested Subqueries, Aggregates, and Quantifiers," </title> <booktitle> in Proceedings of the 13th VLDB Conference, </booktitle> <pages> pp. 197-208, </pages> <year> 1987. </year>
Reference: [7] <author> U. Dayal, </author> <title> "Queries and Views in an Object-Oriented Data Model," </title> <booktitle> in Proceedings of the 2nd International Workshop on Database Programming Languages, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: This form could support optimization techniques for join operations and is the basis for a region in our optimizer. We are exploring the similarities between this form and query representation in OODAPLEX <ref> [7] </ref> with the goal of using OODAPLEX transformation results in such a region.
Reference: [8] <author> J. C. Freytag, </author> <title> "A Rule-Based View of Query Optimization," </title> <booktitle> in SIGMOD Proceedings, </booktitle> <pages> pp. 173-180, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: Also, it seems at this point that the problems introduced by the complexities of the model will require multiple strategies for applying transformations. Current extensible optimizers have concentrated on accommodating extensibility of the data model, new algebraic operators, new transformation rules, and new data access strategies <ref> [8, 9, 13, 26] </ref>. They are generally based on rewrite rules for a set of operators defined on the bulk types. These rules are applied to a query expression to generate equivalent, but hopefully more efficient, forms of the expression.
Reference: [9] <author> G. Graefe, </author> <title> Rule-Based Query Optimization in Extensible Database Systems. </title> <type> PhD thesis, </type> <institution> Univ. of Wisconsin-Madison, </institution> <month> November </month> <year> 1987. </year>
Reference-contexts: Also, it seems at this point that the problems introduced by the complexities of the model will require multiple strategies for applying transformations. Current extensible optimizers have concentrated on accommodating extensibility of the data model, new algebraic operators, new transformation rules, and new data access strategies <ref> [8, 9, 13, 26] </ref>. They are generally based on rewrite rules for a set of operators defined on the bulk types. These rules are applied to a query expression to generate equivalent, but hopefully more efficient, forms of the expression. <p> The optimizer control might use a hill climbing or branch and bound strategy, stopping when the improvements drop below some threshold. This is the technique used by optimizers generated by the optimizer generator of <ref> [9] </ref>, and it might be used with the query form in Figure 1a. Yet other techniques might be specialized to particular data types (e.g., spatial data), to particular operations (e.g., outerjoins), or to particular computing environments (e.g., parallel machines or wide-area networks).
Reference: [10] <author> G. Graefe and D. J. DeWitt, </author> <title> "The EXODUS Optimizer Generator," </title> <booktitle> in SIGMOD Proceedings, </booktitle> <pages> pp. 160-172, </pages> <publisher> ACM, </publisher> <month> May </month> <year> 1987. </year> <month> 16 </month>
Reference-contexts: The revealed information is used to expand the nodes of a query tree with execution information. The query tree, when fully expanded, will be input to a rule-based optimizer such as an EXODUS optimizer <ref> [10] </ref>. Kemper, Kelger and Moerkotte explored the materialization of function results and the requirements for updating these results as an object base is modified [15]. They propose to incorporate the materialized functions into a rule-based optimizer.
Reference: [11] <author> G. Graefe and D. Maier, </author> <title> "Query Optimization in Object-Oriented Database Systems: A Prospectus," </title> <booktitle> in Advances in Object-Oriented Database Systems, </booktitle> <pages> pp. 358-363, </pages> <booktitle> International Workshop on Object-Oriented Database Systems, </booktitle> <month> September </month> <year> 1988. </year>
Reference-contexts: The extensibility of a model like ENCORE raises interesting problems in optimization that we will discuss later. The application of algebraic rewrite rules has formed the basis for the design of query optimizers for object-oriented databases <ref> [11, 25, 31] </ref>. A recognized difficulty in applying transformations is the problem of manipulating query expressions containing arbitrary methods. <p> Information available about objects is used at execution time to choose among the alternatives and generate a final evaluation plan. Graefe and Maier submitted a preliminary architecture for an optimizer that sends messages to methods to ask them to "reveal" information about their execution <ref> [11] </ref>. The revealed information is used to expand the nodes of a query tree with execution information. The query tree, when fully expanded, will be input to a rule-based optimizer such as an EXODUS optimizer [10].
Reference: [12] <author> G. Graefe and K. Ward, </author> <title> "Dynamic Query Evaluation Plans," </title> <booktitle> in SIGMOD Proceedings, </booktitle> <pages> pp. 358-366, </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: Optimization in the presence of encapsulation and methods is a recognized problem that has not been solved [1]. Graefe and Ward propose to statically generate query evaluation plans with alternatives <ref> [12] </ref>. Information available about objects is used at execution time to choose among the alternatives and generate a final evaluation plan. Graefe and Maier submitted a preliminary architecture for an optimizer that sends messages to methods to ask them to "reveal" information about their execution [11].
Reference: [13] <author> L. M. Haas et al., </author> <title> "Extensible Query Processing in Starburst," </title> <booktitle> in SIGMOD Proceedings, </booktitle> <pages> pp. 377-388, </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: Also, it seems at this point that the problems introduced by the complexities of the model will require multiple strategies for applying transformations. Current extensible optimizers have concentrated on accommodating extensibility of the data model, new algebraic operators, new transformation rules, and new data access strategies <ref> [8, 9, 13, 26] </ref>. They are generally based on rewrite rules for a set of operators defined on the bulk types. These rules are applied to a query expression to generate equivalent, but hopefully more efficient, forms of the expression.
Reference: [14] <author> B. P. Jenq et al., </author> <title> "Query Processing in Distributed ORION," </title> <booktitle> in EDBT, </booktitle> <pages> pp. 169-187, </pages> <year> 1990. </year>
Reference-contexts: The exploration and creation of such structures can lead to the regular use of path expressions to navigate through a structure. Current research on the optimization of path expressions involves the definition of indices for an expression [4, 22] and the use of Join operations to effect path navigation <ref> [5, 14, 16, 18] </ref>. Such research leads to new techniques for the optimization of query expressions. The exploration of complex structures also can lead to nested query expressions in which variables from outer expressions are referenced in nested expressions. <p> Beeri and Kornatzky [3] assume there exists a rule-based optimizer and provide an extensive set of rules for bulk data types. Current research on optimization in Orion <ref> [14] </ref> is directed toward the adaptation of relational techniques to the object-oriented database. In particular they explore efficient alternatives to object navigation.
Reference: [15] <author> A. Kemper, C. Kilger, and G. Moerkotte, </author> <title> "Function Materialization in Object Bases," </title> <booktitle> in SIGMOD Proceedings, </booktitle> <pages> pp. 258-267, </pages> <publisher> ACM, </publisher> <year> 1991. </year>
Reference-contexts: The query tree, when fully expanded, will be input to a rule-based optimizer such as an EXODUS optimizer [10]. Kemper, Kelger and Moerkotte explored the materialization of function results and the requirements for updating these results as an object base is modified <ref> [15] </ref>. They propose to incorporate the materialized functions into a rule-based optimizer. Each area of research attacks a specific problem in object-based query optimization and proposes a new technique for solving that problem.
Reference: [16] <author> A. Kemper and G. Moerkotte, </author> <title> "Access Support in Object Bases," </title> <booktitle> in SIGMOD Proceedings, </booktitle> <pages> pp. 364-374, </pages> <publisher> ACM, </publisher> <year> 1990. </year>
Reference-contexts: The exploration and creation of such structures can lead to the regular use of path expressions to navigate through a structure. Current research on the optimization of path expressions involves the definition of indices for an expression [4, 22] and the use of Join operations to effect path navigation <ref> [5, 14, 16, 18] </ref>. Such research leads to new techniques for the optimization of query expressions. The exploration of complex structures also can lead to nested query expressions in which variables from outer expressions are referenced in nested expressions.
Reference: [17] <author> R. S. B. Lanzelotte and P. Valduriez, </author> <title> "Extending the Search Strategy in a Query Optimizer," </title> <booktitle> in Proceedings of the 17th VLDB Conference, </booktitle> <pages> pp. 363 - 373, </pages> <year> 1991. </year>
Reference-contexts: Lanzelotte and Valduriez extend this idea by defining a number of search control strategies in the optimizer and choosing a strategy depending upon the query expression being optimized <ref> [17] </ref>. The architecture we present in this paper allows the definition of any number of control strategies in the optimizer and supports the use of possibly many different control strategies during the processing of a single input query. <p> Although we have not yet decided on a global control, the idea of such control is similar to that of searching for a transformation to apply to a query. Thus, current research in extensible search strategies may offer insights here <ref> [17, 26] </ref>. A query in our optimizer is represented as a tree which is annotated with information about the query operations and objects. The nodes of a tree are either objects (variables or constants) or methods on objects (functions).
Reference: [18] <author> R. S. B. Lanzelotte, P. Valduriez, M. Ziane, and J.-P. Cheiney, </author> <title> "Optimization of Nonrecursive Queries in OODBs," </title> <booktitle> in Proceedings of the Second International Conference on Deductive and Object-Oriented Databases, </booktitle> <month> December </month> <year> 1991. </year>
Reference-contexts: The exploration and creation of such structures can lead to the regular use of path expressions to navigate through a structure. Current research on the optimization of path expressions involves the definition of indices for an expression [4, 22] and the use of Join operations to effect path navigation <ref> [5, 14, 16, 18] </ref>. Such research leads to new techniques for the optimization of query expressions. The exploration of complex structures also can lead to nested query expressions in which variables from outer expressions are referenced in nested expressions. <p> These techniques are concerned, in particular, with accessing complex structures and the processing of nested query expressions. Lanzelotte et al. also explore object navigation <ref> [18] </ref>. They view path expressions as a series of join operations and apply rewrite rules to a tree of join operators. Optimization in the presence of encapsulation and methods is a recognized problem that has not been solved [1].
Reference: [19] <author> C. Lecluse, P. Richard, and F. Velez, </author> <title> "O 2 , an Object-Oriented Data Model," </title> <booktitle> in SIGMOD Proceedings, </booktitle> <pages> pp. 424-433, </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1988. </year>
Reference-contexts: In this paper we will study the query optimization problem in the context of an object-oriented type system. Thus, we will use the ENCORE database system as our example. ENCORE, as well as most object-oriented databases <ref> [2, 19, 23, 24, 34] </ref>, supports (among other features) abstract data types, type inheritance, and object identity. It provides the ability to extend the data model through abstract data types and subtyping. The extensibility of a model like ENCORE raises interesting problems in optimization that we will discuss later.
Reference: [20] <author> C. G. Legaria and R. Barrera, </author> <title> "A Rule-Based Query Optimizer," </title> <type> Tech. Rep. 92, </type> <institution> Centro de Investigacion y de Estudios Avanzados Del IPN, </institution> <year> 1989. </year>
Reference-contexts: The Gemstone database, for example, focuses on indexing for processing of queries that select from a class based on a predicate [22]. A variety of proposals have been made for optimization based on algebraic transformation rules for query operations <ref> [3, 20, 25, 31, 33] </ref>. For example, Straube and Ozsu [30] propose a methodology for query optimization that includes calculus-based optimization, the transformation of calculus-based queries to algebraic form, type-checking of algebraic expressions, the application of algebraic transformation axioms, and the generation of access plans for the algebraic operations.
Reference: [21] <author> B. Liskov et al., </author> <title> "Abstraction Mechanisms in CLU," </title> <journal> Communications of the ACM, </journal> <volume> vol. 20, </volume> <pages> pp. 564-576, </pages> <month> August </month> <year> 1977. </year>
Reference-contexts: This is not a full description of either ENCORE or EQUAL. More details can be found in [29] and [32]. ENCORE is based strongly on abstract data types <ref> [21] </ref>. All types are defined by their interface which is specified in terms of a set of method signatures. A signature for method M is a name plus an ordered list of types that correspond to the legal types for the arguments of M.
Reference: [22] <author> D. Maier and J. Stein, </author> <title> "Indexing in an Object-Oriented Database," </title> <booktitle> in International Workshop on Object-Oriented Database Systems, </booktitle> <pages> pp. 171-182, </pages> <year> 1986. </year>
Reference-contexts: The exploration and creation of such structures can lead to the regular use of path expressions to navigate through a structure. Current research on the optimization of path expressions involves the definition of indices for an expression <ref> [4, 22] </ref> and the use of Join operations to effect path navigation [5, 14, 16, 18]. Such research leads to new techniques for the optimization of query expressions. <p> The Gemstone database, for example, focuses on indexing for processing of queries that select from a class based on a predicate <ref> [22] </ref>. A variety of proposals have been made for optimization based on algebraic transformation rules for query operations [3, 20, 25, 31, 33].
Reference: [23] <author> D. Maier and J. Stein, </author> <title> "Development and Implementation of an Object-Oriented DBMS," </title> <booktitle> in Research Directions in Object-Oriented Programming (B. </booktitle> <editor> Shriver and P. Wegner, </editor> <booktitle> eds.), </booktitle> <pages> pp. 355-392, </pages> <address> Cambridge, MA: </address> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: In this paper we will study the query optimization problem in the context of an object-oriented type system. Thus, we will use the ENCORE database system as our example. ENCORE, as well as most object-oriented databases <ref> [2, 19, 23, 24, 34] </ref>, supports (among other features) abstract data types, type inheritance, and object identity. It provides the ability to extend the data model through abstract data types and subtyping. The extensibility of a model like ENCORE raises interesting problems in optimization that we will discuss later.
Reference: [24] <author> F. Manola and U. Dayal, "PDM: </author> <title> An Object-Oriented Data Model," in Readings in Object-Oriented Database Systems (S. </title> <editor> B. Zdonik and D. Maier, eds.), </editor> <address> San Mateo, CA: </address> <publisher> Morgan Kauf-mann, </publisher> <year> 1990. </year>
Reference-contexts: In this paper we will study the query optimization problem in the context of an object-oriented type system. Thus, we will use the ENCORE database system as our example. ENCORE, as well as most object-oriented databases <ref> [2, 19, 23, 24, 34] </ref>, supports (among other features) abstract data types, type inheritance, and object identity. It provides the ability to extend the data model through abstract data types and subtyping. The extensibility of a model like ENCORE raises interesting problems in optimization that we will discuss later.
Reference: [25] <author> S. L. Osborn, </author> <title> "Identity, Equality and Query Optimization," </title> <booktitle> in Advances in Object-Oriented Database Systems, </booktitle> <pages> pp. 346-351, </pages> <booktitle> International Workshop on Object-Oriented Database Systems, </booktitle> <month> September </month> <year> 1988. </year>
Reference-contexts: The extensibility of a model like ENCORE raises interesting problems in optimization that we will discuss later. The application of algebraic rewrite rules has formed the basis for the design of query optimizers for object-oriented databases <ref> [11, 25, 31] </ref>. A recognized difficulty in applying transformations is the problem of manipulating query expressions containing arbitrary methods. <p> The Gemstone database, for example, focuses on indexing for processing of queries that select from a class based on a predicate [22]. A variety of proposals have been made for optimization based on algebraic transformation rules for query operations <ref> [3, 20, 25, 31, 33] </ref>. For example, Straube and Ozsu [30] propose a methodology for query optimization that includes calculus-based optimization, the transformation of calculus-based queries to algebraic form, type-checking of algebraic expressions, the application of algebraic transformation axioms, and the generation of access plans for the algebraic operations.
Reference: [26] <author> E. Sciore and J. Sieg, Jr., </author> <title> "A Modular Query Optimizer Generator," </title> <booktitle> in Proceedings of the 6th International Conference on Data Engineering, </booktitle> <pages> pp. 146-153, </pages> <year> 1990. </year>
Reference-contexts: Also, it seems at this point that the problems introduced by the complexities of the model will require multiple strategies for applying transformations. Current extensible optimizers have concentrated on accommodating extensibility of the data model, new algebraic operators, new transformation rules, and new data access strategies <ref> [8, 9, 13, 26] </ref>. They are generally based on rewrite rules for a set of operators defined on the bulk types. These rules are applied to a query expression to generate equivalent, but hopefully more efficient, forms of the expression. <p> They are, therefore, impossible to extend or change without a major rewrite of the system. Optimizer generators can partially address this problem by allowing a control strategy to be defined for an optimizer at the time it is generated <ref> [26] </ref>. Lanzelotte and Valduriez extend this idea by defining a number of search control strategies in the optimizer and choosing a strategy depending upon the query expression being optimized [17]. <p> Although we have not yet decided on a global control, the idea of such control is similar to that of searching for a transformation to apply to a query. Thus, current research in extensible search strategies may offer insights here <ref> [17, 26] </ref>. A query in our optimizer is represented as a tree which is annotated with information about the query operations and objects. The nodes of a tree are either objects (variables or constants) or methods on objects (functions).
Reference: [27] <author> P. G. Selinger et al., </author> <title> "Access Path Selection in a Relational Database Management System," </title> <booktitle> in SIGMOD Proceedings, </booktitle> <pages> pp. 23-34, </pages> <publisher> ACM, </publisher> <year> 1979. </year> <month> 17 </month>
Reference-contexts: Join orders might be enumerated using dynamic programming, and their costs evaluated using a cost model. This is the optimization technique commonly used by relational optimizers <ref> [27] </ref>. This optimization technique might be used with the query form in A second technique might be to apply rewrite rules for a broad set of operations (not just joins, selections, and projections) to improve a query. <p> The canonical join query is sent to the join reordering region where the order of the join operations is modified and join methods are recommended. In this region, a dynamic programming strategy is used to search for good join orderings (similarly to the System R strategy <ref> [27] </ref>). The region eventually settles on the join ordering represented in the query of Figure 7 (note that annotations, including join method choices, are not shown in this figure).
Reference: [28] <author> G. M. Shaw and S. B. Zdonik, </author> <title> "Object-Oriented Queries: Equivalence and Optimization," </title> <booktitle> in Proceedings of the First International Conference on Deductive and Object-Oriented Databases, </booktitle> <pages> pp. 264-278, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: The costs associated with the application of methods need to be considered when manipulating query expressions to determine database access strategies. We have also found that manipulations involving objects with identity complicate the definition of the equivalence of two query expressions <ref> [28] </ref> thus complicating the application of transformation rules. Optimizers for persistent object systems must be extensible because the relevant optimization techniques vary significantly for the various extensions. Also, it seems at this point that the problems introduced by the complexities of the model will require multiple strategies for applying transformations.
Reference: [29] <author> G. M. Shaw and S. B. Zdonik, </author> <title> "A Query Algebra for Object-Oriented Databases," </title> <booktitle> in Proceedings of the 6th International Conference on Data Engineering, </booktitle> <pages> pp. 154-162, </pages> <publisher> IEEE, </publisher> <year> 1990. </year> <note> An early version of this paper appears as Brown University tech report CS-89-19. </note>
Reference-contexts: In this section we briefly describe those features of the model and algebra necessary to understand the discussion in the following sections. This is not a full description of either ENCORE or EQUAL. More details can be found in <ref> [29] </ref> and [32]. ENCORE is based strongly on abstract data types [21]. All types are defined by their interface which is specified in terms of a set of method signatures.
Reference: [30] <author> D. D. Straube, </author> <title> Queries and Query Processing in Object-Oriented Database Systems. </title> <type> PhD thesis, </type> <institution> Univ. of Alberta, </institution> <month> December </month> <year> 1990. </year>
Reference-contexts: The Gemstone database, for example, focuses on indexing for processing of queries that select from a class based on a predicate [22]. A variety of proposals have been made for optimization based on algebraic transformation rules for query operations [3, 20, 25, 31, 33]. For example, Straube and Ozsu <ref> [30] </ref> propose a methodology for query optimization that includes calculus-based optimization, the transformation of calculus-based queries to algebraic form, type-checking of algebraic expressions, the application of algebraic transformation axioms, and the generation of access plans for the algebraic operations.
Reference: [31] <author> D. D. Straube and M. Ozsu, </author> <title> "Query Transformation Rules for an Object Algebra," </title> <type> Tech. Rep. </type> <institution> CS-89-23, University of Alberta, </institution> <year> 1989. </year>
Reference-contexts: The extensibility of a model like ENCORE raises interesting problems in optimization that we will discuss later. The application of algebraic rewrite rules has formed the basis for the design of query optimizers for object-oriented databases <ref> [11, 25, 31] </ref>. A recognized difficulty in applying transformations is the problem of manipulating query expressions containing arbitrary methods. <p> The Gemstone database, for example, focuses on indexing for processing of queries that select from a class based on a predicate [22]. A variety of proposals have been made for optimization based on algebraic transformation rules for query operations <ref> [3, 20, 25, 31, 33] </ref>. For example, Straube and Ozsu [30] propose a methodology for query optimization that includes calculus-based optimization, the transformation of calculus-based queries to algebraic form, type-checking of algebraic expressions, the application of algebraic transformation axioms, and the generation of access plans for the algebraic operations.
Reference: [32] <author> S. Zdonik and G. Mitchell, "ENCORE: </author> <title> An Object-Oriented Approach to Database Modelling and Querying," </title> <journal> IEEE Data Engineering Bulletin, </journal> <volume> vol. 14, </volume> <month> June </month> <year> 1991. </year>
Reference-contexts: In this section we briefly describe those features of the model and algebra necessary to understand the discussion in the following sections. This is not a full description of either ENCORE or EQUAL. More details can be found in [29] and <ref> [32] </ref>. ENCORE is based strongly on abstract data types [21]. All types are defined by their interface which is specified in terms of a set of method signatures.
Reference: [33] <author> S. B. Zdonik, </author> <title> "Query Optimization in Object-Oriented Database Systems," </title> <booktitle> in Proceedings of the Hawaii International Conference on System Science, </booktitle> <month> January </month> <year> 1989. </year>
Reference-contexts: The Gemstone database, for example, focuses on indexing for processing of queries that select from a class based on a predicate [22]. A variety of proposals have been made for optimization based on algebraic transformation rules for query operations <ref> [3, 20, 25, 31, 33] </ref>. For example, Straube and Ozsu [30] propose a methodology for query optimization that includes calculus-based optimization, the transformation of calculus-based queries to algebraic form, type-checking of algebraic expressions, the application of algebraic transformation axioms, and the generation of access plans for the algebraic operations.
Reference: [34] <author> S. B. Zdonik and P. Wegner, </author> <title> "Language and Methodology for Object-Oriented Database Environments," </title> <booktitle> in Proceedings of the Hawaii International Conference on System Sciences, </booktitle> <month> January </month> <year> 1986. </year>
Reference-contexts: In this paper we will study the query optimization problem in the context of an object-oriented type system. Thus, we will use the ENCORE database system as our example. ENCORE, as well as most object-oriented databases <ref> [2, 19, 23, 24, 34] </ref>, supports (among other features) abstract data types, type inheritance, and object identity. It provides the ability to extend the data model through abstract data types and subtyping. The extensibility of a model like ENCORE raises interesting problems in optimization that we will discuss later.
References-found: 34

