URL: http://www.cs.ucsb.edu/~kienle/thesis.ps
Refering-URL: http://www.cs.ucsb.edu/~kienle/prj/prj.html
Root-URL: http://www.cs.ucsb.edu
Title: Exception-Handling Extension for the Open OODB A Research Project in  
Author: Holger M. Kienle Holger M. Kienle 
Degree: Computer Science by  Submitted in Partial Fulfillment of the Requirements for the Degree of Master of Science  
Date: June 1995  
Note: c 1995 by  
Affiliation: University of Massachusetts Dartmouth Graduate School Department of Computer Science  
Abstract-found: 0
Intro-found: 0
Reference: [ADF + 94] <author> Tom Atwood, J. Duhl, G. Ferran, M. Loomis, and D. Wade. </author> <title> The Object Database Standard, ODMG-93. </title> <publisher> Morgan Kaufmann Publisher, </publisher> <address> release 1.1 edition, </address> <year> 1994. </year>
Reference-contexts: . . . . . . . . . . . . . . . . 78 Bibliography 79 vi List of Figures 1.1 A student relation in tabular format . . . . . . . . . . . . . . 2 1.2 Comparison of database architectures <ref> [ADF + 94] </ref> . . . . . . . . 6 1.3 ODMG exception handling model . . . . . . . . . . . . . . . . 12 1.4 Open OODB requirements . . . . . . . . . . . . . <p> The declaration of a variable as being persistent does not automatically ensure that the referenced object is persistent. 1.2.1 ODMG Object Model This part gives a short overview of the components of the ODMG object model <ref> [ADF + 94] </ref>. The ODMG object model is an example of a concrete object-oriented model. It contains basically the components discussed in the previous part of this chapter. Additional components will be explained.
Reference: [ASU86] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: A general introduction including concepts like LALR and LL grammars, Backus-Naur form, symbol table, parse tree and attribute grammars can be found in various books, for example, [Lem92], [FL88], [SF85] (Lex & Yacc) and the "Dragon-book" <ref> [ASU86] </ref>. 56 the Open OODB meta-requirement of openness because the existing module can be easily modified or extended.
Reference: [Bar94] <author> J. G. P. Barnes. </author> <booktitle> Programming in Ada. Addsion-Wesley, fourth edition, </booktitle> <year> 1994. </year>
Reference-contexts: In the beginning, the development of exception handling systems was dedicated to procedural programming. For example, Ada <ref> [Bar94] </ref> [NS88] was the first widely used, high-order programming language which implemented exceptions. Exceptions have been basically included in Ada to promote the creation of robust, fault-tolerant real-time systems. After the object-oriented model was established, designers started thinking about how to extend object-oriented languages with exception handling.
Reference: [BDK92] <author> F. Bancilhon, C. Delobel, and P. Kanellakis. </author> <title> Building an Object-Oriented Database System the Story of O 2 . Morgan Kaufman Publishers, </title> <year> 1992. </year>
Reference-contexts: All books contain examples of existing systems, like GemStone, Ontos, ODE, ObjectStore and O 2 . <ref> [BDK92] </ref> provides an in-depth discussion of O 2 . 5 break down objects into artificial structures in order to map the design into the requirements of the database model. Figure 1.2 illustrates this point. All objects which share the same set of attributes and methods are grouped together in classes.
Reference: [Bis93a] <author> Kurt M. Bischoff. </author> <title> Ox: Tutorial Introduction, </title> <month> November </month> <year> 1993. </year>
Reference-contexts: For example, the format string in a printf-statements of the C programming language is a description of a text fragments. It specifies constant parts, and certain places where computed information can be inserted. Compiler generator tools, like Lex & Yacc [Joh78] [DS92], Eli [Gro], Ox <ref> [Bis93a] </ref> [Bis93b], and PCCTS [PCD93] [PCD91] exist which cover all or just parts of these modules. For example, Lex & Yacc allow a compiler writer to generate the structural analysis of linear text (scanner and parser) from simple specifications.
Reference: [Bis93b] <author> Kurt M. Bischoff. </author> <title> Ox: User Reference Manual, </title> <month> November </month> <year> 1993. </year>
Reference-contexts: For example, the format string in a printf-statements of the C programming language is a description of a text fragments. It specifies constant parts, and certain places where computed information can be inserted. Compiler generator tools, like Lex & Yacc [Joh78] [DS92], Eli [Gro], Ox [Bis93a] <ref> [Bis93b] </ref>, and PCCTS [PCD93] [PCD91] exist which cover all or just parts of these modules. For example, Lex & Yacc allow a compiler writer to generate the structural analysis of linear text (scanner and parser) from simple specifications.
Reference: [Bla93] <author> J. Blakeley. </author> <title> Open OODB OQL[C++] user guide. </title> <type> Technical report, </type> <institution> Texas Instruments Inc., </institution> <year> 1993. </year>
Reference-contexts: Open OODB uses a programming language independent approach by providing a programming language-neutral object model. The term OQL refers to the specific method of extending any programming language with associative query statements, while OQL [C++] 7 refers to the particular coupling 7 The manuals [BS91] and <ref> [Bla93] </ref> of the Open OODB system explain OQL [C++] in 24 of OQL with C++ which allows certain C++ expressions to be used in the formulation of queries. Different query languages have a different syntax and support different techniques for expressing queries. However [Bla93] proposes some requirements that contribute to defining <p> particular coupling 7 The manuals [BS91] and <ref> [Bla93] </ref> of the Open OODB system explain OQL [C++] in 24 of OQL with C++ which allows certain C++ expressions to be used in the formulation of queries. Different query languages have a different syntax and support different techniques for expressing queries. However [Bla93] proposes some requirements that contribute to defining a good query language integration: 1. The language type system should be equal to the object data model. Unifying the type system of the host language with the data model of the database solves the impedance mismatch problem. 2.
Reference: [BM93] <author> Elisa Bertino and Lorenzo Martino. </author> <title> Object-Oriented Database Systems. </title> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: For example, each real-world entity can be modeled as an object. The object-oriented model preserves the high-level presentation of the design throughout the implementation. However, traditional database models, including the relational one, tend to 2 Object-oriented design methods and techniques are discussed in [Mey88]. [Hug91], <ref> [BM93] </ref>, [KM94] and [Cat91] explain the object-oriented data model, query languages and general concepts in detail.
Reference: [BS91] <author> J. Blakekey and K. Srivastava. </author> <title> Implementation of the Object Query Language Module for Zeitgeist: Version 0.1.0. </title> <type> Technical report, </type> <institution> Texas Instruments Inc., </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: Open OODB uses a programming language independent approach by providing a programming language-neutral object model. The term OQL refers to the specific method of extending any programming language with associative query statements, while OQL [C++] 7 refers to the particular coupling 7 The manuals <ref> [BS91] </ref> and [Bla93] of the Open OODB system explain OQL [C++] in 24 of OQL with C++ which allows certain C++ expressions to be used in the formulation of queries. Different query languages have a different syntax and support different techniques for expressing queries.
Reference: [BTA91] <author> Jose A. Blakeley, Craig W. Thompson, and Abdallah Alashqur. </author> <title> Strawman reference model for Object Query Languages. </title> <journal> Computer Standards and Interfaces, </journal> <volume> 13 </volume> <pages> 185-199, </pages> <month> October </month> <year> 1991. </year> <month> 79 </month>
Reference-contexts: Constructs must provide space for optimizations. * application independent, so that it can be used on any database scheme. 6 The references about object-oriented database systems given in section 1.2 usually addresses query languages too. <ref> [BTA91] </ref> introduces a reference model for object-oriented query languages. 22 1.4.1 Language Environments As stated before, there is no general agreement upon an object data model in the sense of the relational model. Hence, the design can vary depending on the following three approaches: 1.
Reference: [BW90] <author> Alan Burns and Andrew Wellings. </author> <title> Real-Time Systems and their Programming Languages. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: This is practically not realizable because overhead is always involved. It can take the form 1 Exception handling is discussed in general in <ref> [BW90] </ref>, [NS88], [DPW92] and [Goo75]. The last reference is Goodenough's seminal paper and has influenced the majority of exception handling systems for procedural languages.
Reference: [Cat91] <author> R. G. G. Catell. </author> <title> Object Data Management. </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: For example, each real-world entity can be modeled as an object. The object-oriented model preserves the high-level presentation of the design throughout the implementation. However, traditional database models, including the relational one, tend to 2 Object-oriented design methods and techniques are discussed in [Mey88]. [Hug91], [BM93], [KM94] and <ref> [Cat91] </ref> explain the object-oriented data model, query languages and general concepts in detail.
Reference: [Dat94] <author> C. J. Date. </author> <title> A Guide to the SQL Standard. </title> <publisher> Addison-Wesley, </publisher> <address> third edition, </address> <month> Januar </month> <year> 1994. </year>
Reference-contexts: Since all these interfaces have a comparable functionality, we will representatively take a short look at the SQL embedding for the programming language C. Embedded SQL statements contain host language variables for two purposes: 1 A detailed explanation of SQL and the new SQL-92 standard can be found in <ref> [Dat94] </ref> and [MS93]. 1. To use the value of the variable as a constant in the WHERE clause for comparison predicates, and 2. To transfer attribute values retrieved from a database relation into the variables.
Reference: [DJL88] <author> P. Deransart, M. Jourdan, and B. Lorho. </author> <title> Attribute Grammars. </title> <booktitle> Number 323 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: Tree construction/computation: Any tree computation algorithm has three components: a set of computations done at each node, a traversal strategy, and a mechanism for managing intermediate storage. When the algorithm is written by hand, the programmer has to design and 57 implement all three components. Attribute grammars <ref> [DJL88] </ref> can be used as a specification of the dependency among computations at the nodes of a tree. Creation and output of structured text: We create structured text by pasting together text fragments. Each fragment can be created by invoking a routine that constructs the fragment from its component parts.
Reference: [DPW92] <author> C. Dony, J. Purchase, and R. Winder. </author> <title> Exception Handling in Object-Oriented Systems. </title> <journal> OOPS Messenger, </journal> <volume> 3(2) </volume> <pages> 17-30, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: This is practically not realizable because overhead is always involved. It can take the form 1 Exception handling is discussed in general in [BW90], [NS88], <ref> [DPW92] </ref> and [Goo75]. The last reference is Goodenough's seminal paper and has influenced the majority of exception handling systems for procedural languages.
Reference: [DS92] <author> Charles Donnelly and Richard Stallman. Bison: </author> <title> The YACC-compatible Parser Generator. Free Software Foundation, </title> <month> Decem-ber </month> <year> 1992. </year>
Reference-contexts: For example, the format string in a printf-statements of the C programming language is a description of a text fragments. It specifies constant parts, and certain places where computed information can be inserted. Compiler generator tools, like Lex & Yacc [Joh78] <ref> [DS92] </ref>, Eli [Gro], Ox [Bis93a] [Bis93b], and PCCTS [PCD93] [PCD91] exist which cover all or just parts of these modules. For example, Lex & Yacc allow a compiler writer to generate the structural analysis of linear text (scanner and parser) from simple specifications.
Reference: [ES90] <author> M. A. Ellis and B. Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Exceptions have been basically included in Ada to promote the creation of robust, fault-tolerant real-time systems. After the object-oriented model was established, designers started thinking about how to extend object-oriented languages with exception handling. Since then, several object-oriented languages, like C++ <ref> [ES90] </ref>, Eiffel [Mey92], CommonLisp (+CLOS) and Smalltalk, have introduced exception handling. For example, C++ introduced exceptions in 1990. The first implementations started appearing in 1992. [Str94] describes the assumptions that were made for the design. Exceptions are used primarily for error handling. <p> Because Ox requires a lex-file, this compiler generator tool can not be used. * The C++ grammar of the preprocessor is taken from <ref> [ES90] </ref>. The authors of this book note the this grammar is just a superset of the actual C++ language: "This summary of the C++ syntax is intended to be an aid to comprehension. <p> I decided to make the destructor of the exception handling class virtual. This assures that the appropriate destructor is called if the application programmer decides to derive subclasses from the exception handling class. For example, if a destructor is not virtual we have the following problem <ref> [ES90] </ref>: class Bf ~B (); class D: public Bf ~D (); . . . B *p= new D (); // create a D delete p; // delete a B! . . . <p> Yacc declaration The new tokens TRY, CATCH, THROW, LTRYBRACE, and RTRYBRACE have been defined. The last two tokens are used by the scanner only. 74 Grammar rules New grammar rules have been implemented that support the C++ exception handling syntax. The grammar rules are based on <ref> [ES90] </ref> and are slightly modified. Existing rules are modified in order to integrate the new rules. Because the preprocessor does not parse any statements the new grammar rules have no effect yet. They can be used if the parser will be extended.
Reference: [FL88] <author> Charles N. Fischer and Richard J. LeBlanc. </author> <title> Crafting a Compiler. </title> <publisher> Benjamin/Cummings Publishing Company, </publisher> <year> 1988. </year>
Reference-contexts: A general introduction including concepts like LALR and LL grammars, Backus-Naur form, symbol table, parse tree and attribute grammars can be found in various books, for example, [Lem92], <ref> [FL88] </ref>, [SF85] (Lex & Yacc) and the "Dragon-book" [ASU86]. 56 the Open OODB meta-requirement of openness because the existing module can be easily modified or extended.
Reference: [FWP] <author> P. J. Fortier, V. F. Wolfe, and J. J. Prichard. SQL/RT: </author> <title> Real-Time Database Extentions to the SQL2 Standard. </title>
Reference-contexts: Static transactions have to be declared in a transaction declaration 46 (refer to 2.1.1). This transaction declaration corresponds to a procedure in a procedural programming language. This means that the exception handler can be attached at the transaction declaration code. The following BNF-grammar fragment is based on <ref> [FWP] </ref> and realizes transaction declarations. The grammar has been extended in order to support exception handling: &lt;transaction&gt; ::= TRANSACTION &lt;ident&gt; ( &lt;parameters&gt; ) [&lt;local declarations&gt;] . . . BEGIN &lt;body&gt; EXCEPTION &lt;body&gt; END.
Reference: [Goo75] <author> John B. Goodenough. </author> <title> Exception Handling: Issues and a Proposed Notation. </title> <journal> Communications of the ACM, </journal> <volume> 18(12) </volume> <pages> 683-696, </pages> <month> December </month> <year> 1975. </year>
Reference-contexts: This is practically not realizable because overhead is always involved. It can take the form 1 Exception handling is discussed in general in [BW90], [NS88], [DPW92] and <ref> [Goo75] </ref>. The last reference is Goodenough's seminal paper and has influenced the majority of exception handling systems for procedural languages. <p> For example, in Ada the exception handler can be defined with the keyword exception at the end of a procedure. procedure FOO (parameters) is begin . . . normal code . . . exception . . . exception handling code 2 This point of view is contradictious to <ref> [Goo75] </ref>, who writes that exception handling mechanism are not needed just to deal with errors and that they are not necessarily rarely activated. 31 . . . A proposed notation for the new SQL standard [Sha94] uses exception handler declarations.
Reference: [Gro] <author> Compiler Tools Group. </author> <title> Guide for New Eli Users. </title> <institution> Department of ECE, University of Colorado Boulder, </institution> <address> 2.10 edition. </address>
Reference-contexts: For example, the format string in a printf-statements of the C programming language is a description of a text fragments. It specifies constant parts, and certain places where computed information can be inserted. Compiler generator tools, like Lex & Yacc [Joh78] [DS92], Eli <ref> [Gro] </ref>, Ox [Bis93a] [Bis93b], and PCCTS [PCD93] [PCD91] exist which cover all or just parts of these modules. For example, Lex & Yacc allow a compiler writer to generate the structural analysis of linear text (scanner and parser) from simple specifications.
Reference: [Hug91] <author> John G. Hughes. </author> <title> Object-Oriented Databases. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: For example, each real-world entity can be modeled as an object. The object-oriented model preserves the high-level presentation of the design throughout the implementation. However, traditional database models, including the relational one, tend to 2 Object-oriented design methods and techniques are discussed in [Mey88]. <ref> [Hug91] </ref>, [BM93], [KM94] and [Cat91] explain the object-oriented data model, query languages and general concepts in detail. <p> The lack of adequate support for persistence, especially at conventional systems, has been recognized as a serious shortcoming of programming languages. There are three basic approaches: * Persistence is an implicit characteristic of all instances of classes. For example, the Exodus <ref> [Hug91] </ref> system distinguishes persistent and non-persistent classes. The system provides a collection of built-in classes which are the persistent equivalence of the "normal" types. The creation of an instance of a persistent class has the effect of inserting the instance into the database. <p> For example, the SQL embedding for C does not provide a seamless integration because there is a clear-cut distinction between volatile and persistent objects. The programmer is fully responsible for the mapping between volatile memory and persistent store. <ref> [Hug91] </ref> points out that in many applications 30% or more additional code is needed for this mapping. A challenge in extended database system approach is achieving interoperability of applications written in multiple programming languages, each having a different type system.
Reference: [Joh78] <author> S. C. Johnson. </author> <title> Yacc yet another compiler compiler. </title> <type> Technical Report 32, </type> <institution> AT&T Bell Laboratories, </institution> <year> 1978. </year> <month> 80 </month>
Reference-contexts: For example, the format string in a printf-statements of the C programming language is a description of a text fragments. It specifies constant parts, and certain places where computed information can be inserted. Compiler generator tools, like Lex & Yacc <ref> [Joh78] </ref> [DS92], Eli [Gro], Ox [Bis93a] [Bis93b], and PCCTS [PCD93] [PCD91] exist which cover all or just parts of these modules. For example, Lex & Yacc allow a compiler writer to generate the structural analysis of linear text (scanner and parser) from simple specifications.
Reference: [KD93] <author> Helmut Kopka and Patrick W. Daly. </author> <title> A Guide to L A T E X. </title> <publisher> Addison--Wesley, </publisher> <year> 1993. </year>
Reference: [KM94] <author> Alfons Kemper and Guido Moerkotte. </author> <title> Object-Oriented Database Management. </title> <publisher> Prentice-Hall, </publisher> <year> 1994. </year>
Reference-contexts: For example, each real-world entity can be modeled as an object. The object-oriented model preserves the high-level presentation of the design throughout the implementation. However, traditional database models, including the relational one, tend to 2 Object-oriented design methods and techniques are discussed in [Mey88]. [Hug91], [BM93], <ref> [KM94] </ref> and [Cat91] explain the object-oriented data model, query languages and general concepts in detail.
Reference: [Lem92] <author> Karen E. Lemone. </author> <title> Design of Compilers. </title> <publisher> CRC Press, </publisher> <year> 1992. </year>
Reference-contexts: A general introduction including concepts like LALR and LL grammars, Backus-Naur form, symbol table, parse tree and attribute grammars can be found in various books, for example, <ref> [Lem92] </ref>, [FL88], [SF85] (Lex & Yacc) and the "Dragon-book" [ASU86]. 56 the Open OODB meta-requirement of openness because the existing module can be easily modified or extended.
Reference: [LS75] <author> B. H. Liskov and A. Snyder. </author> <title> Exception Handling in CLU. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 5(6) </volume> <pages> 546-558, </pages> <month> November </month> <year> 1975. </year>
Reference-contexts: Other programming languages, for example CLU <ref> [LS75] </ref>, allow exceptions to be handled at the statement level. This means that the domain is a single statement. Usually the domain is static. This means that the domain is known during compile time. However it is possible to define the domain dynamically, during run-time. <p> With this method one can think of "blind propagation". CLU supports single-level propagation. This means that the exception must be handled at the point of call. The authors of the exception handling facility write in <ref> [LS75] </ref> that they believe this decision was necessary to ensure well-structured exception handling because it is appropriate for the caller of a procedure to know about the exceptions raised by this procedure, but the caller should know nothing about the exceptions raised by procedures used in the implementation of the invoked
Reference: [Mey88] <author> Bertrand Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: For example, each real-world entity can be modeled as an object. The object-oriented model preserves the high-level presentation of the design throughout the implementation. However, traditional database models, including the relational one, tend to 2 Object-oriented design methods and techniques are discussed in <ref> [Mey88] </ref>. [Hug91], [BM93], [KM94] and [Cat91] explain the object-oriented data model, query languages and general concepts in detail. <p> Hence, inheritance can be viewed as specialization. Classes provide a good facility for data decomposition. However to achieve support for reusability and extensibility we need inheritance, since the definition of new classes can be based on existing ones. <ref> [Mey88] </ref> provides a definition of object-oriented design: Definition 3 (Object-Oriented Design) Object-oriented design is the construction of software systems as structured collections of abstract data type implementations. A more detailed classification of object-oriented systems is described in [Mey88]. <p> inheritance, since the definition of new classes can be based on existing ones. <ref> [Mey88] </ref> provides a definition of object-oriented design: Definition 3 (Object-Oriented Design) Object-oriented design is the construction of software systems as structured collections of abstract data type implementations. A more detailed classification of object-oriented systems is described in [Mey88]. The author distinguishes the following steps that lead to true object-orientedness: Level 1: Systems are modularized on the basis of their data structures. Level 2: Objects should be described as implementations of abstract data types. <p> Level 6: Support of polymorphism and dynamic binding. Level 7: It should be possible to declare a class as heir to more than one (multiple inheritance), and more than once to the same class (repeated inheritance). In the opinion of <ref> [Mey88] </ref>, only systems that reach the last step are true object-oriented systems. In that sense, C++ does not fulfill these criteria because it does not provide garbage collection. Another important issue for database systems is how they support persistence.
Reference: [Mey92] <author> Bertrand Meyer. </author> <title> EIFFEL: The Language. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: Exceptions have been basically included in Ada to promote the creation of robust, fault-tolerant real-time systems. After the object-oriented model was established, designers started thinking about how to extend object-oriented languages with exception handling. Since then, several object-oriented languages, like C++ [ES90], Eiffel <ref> [Mey92] </ref>, CommonLisp (+CLOS) and Smalltalk, have introduced exception handling. For example, C++ introduced exceptions in 1990. The first implementations started appearing in 1992. [Str94] describes the assumptions that were made for the design. Exceptions are used primarily for error handling. <p> name; char *class name; char *method name; // additional information about developer exception char *developer exception name; void *developer exception object; // raise exception virtual void raise (char *name= NULL, void *obj= NULL); g The exception handling class is closely related to the EXCEPTION class of the Eiffel programming language <ref> [Mey92] </ref>. 49 The OODB Excpt class distinguishes between an exception raised by the programmer (or developer) of a database application and an exception raised by the database itself. This kind of exceptions will be called developer exception and Open OODB exception, respectively.
Reference: [MS93] <author> Jim Melton and Alan R. Simon. </author> <title> Understanding the New SQL: A Complete Guide. </title> <publisher> Morgan Kaufman Publishers, </publisher> <year> 1993. </year>
Reference-contexts: Embedded SQL statements contain host language variables for two purposes: 1 A detailed explanation of SQL and the new SQL-92 standard can be found in [Dat94] and <ref> [MS93] </ref>. 1. To use the value of the variable as a constant in the WHERE clause for comparison predicates, and 2. To transfer attribute values retrieved from a database relation into the variables.
Reference: [NS88] <author> Kjell Nielsen and Ken Shumate. </author> <title> Designing Large Real-Time Systems with ADA. </title> <publisher> Intertext Publications and McGraw-Hill, </publisher> <year> 1988. </year>
Reference-contexts: This is practically not realizable because overhead is always involved. It can take the form 1 Exception handling is discussed in general in [BW90], <ref> [NS88] </ref>, [DPW92] and [Goo75]. The last reference is Goodenough's seminal paper and has influenced the majority of exception handling systems for procedural languages. <p> In the beginning, the development of exception handling systems was dedicated to procedural programming. For example, Ada [Bar94] <ref> [NS88] </ref> was the first widely used, high-order programming language which implemented exceptions. Exceptions have been basically included in Ada to promote the creation of robust, fault-tolerant real-time systems. After the object-oriented model was established, designers started thinking about how to extend object-oriented languages with exception handling.
Reference: [PCD91] <author> T. Parr, W. Cohen, and H. Dietz. </author> <title> PCCTS Reference Manual. </title> <institution> School of Electrical Engineering, Pudue University, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: It specifies constant parts, and certain places where computed information can be inserted. Compiler generator tools, like Lex & Yacc [Joh78] [DS92], Eli [Gro], Ox [Bis93a] [Bis93b], and PCCTS [PCD93] <ref> [PCD91] </ref> exist which cover all or just parts of these modules. For example, Lex & Yacc allow a compiler writer to generate the structural analysis of linear text (scanner and parser) from simple specifications.
Reference: [PCD93] <author> T. Parr, W. Cohen, and H. Dietz. </author> <title> PCCTS 1.xx Introductory Tutorial. </title> <institution> School of Electrical Engineering, Pudue University, </institution> <month> Fall </month> <year> 1993. </year>
Reference-contexts: For example, the format string in a printf-statements of the C programming language is a description of a text fragments. It specifies constant parts, and certain places where computed information can be inserted. Compiler generator tools, like Lex & Yacc [Joh78] [DS92], Eli [Gro], Ox [Bis93a] [Bis93b], and PCCTS <ref> [PCD93] </ref> [PCD91] exist which cover all or just parts of these modules. For example, Lex & Yacc allow a compiler writer to generate the structural analysis of linear text (scanner and parser) from simple specifications.
Reference: [PQ94] <author> Terence J. Patt and Russell W. Quong. </author> <title> ANTLR: A Predicate-LL(k) Parser Generator. </title> <month> June </month> <year> 1994. </year>
Reference-contexts: This tool * integrates the specification of lexical and syntactic analysis. * constructs human-readable recursive-descent parsers in C or C++ from pred-LL (k) grammars, namely LL (k) grammars, for k &gt; 1, that support 59 predicates <ref> [PQ94] </ref>. Predicates allow arbitrary semantic and syntactic context to direct the parse in a systematic way. As a result, ANTLR can generate parsers for may context-sensitive languages and many non-LL (k)/LR (k) context-free languages. ANTLR does not have a fixed lookahead.
Reference: [Ram93] <author> Joe Ramey. </author> <title> Open OODB C++ API User Manual Release 0.2 (Alpha). </title> <type> Technical report, </type> <institution> Texas Instruments Inc., </institution> <year> 1993. </year>
Reference-contexts: by a C++ class, called OODB. 5 The API of the Persistence PM, the Transaction PM and the database operations will be discussed shortly: * OODB::OODB ("host:port") These methods creates an instance of the OODB class and connects to the specified database server. 5 Additional information can be found in <ref> [Ram93] </ref>. 21 * int OODB::beginTransaction () or int OODB::beginT () This method starts a transaction. An OODB instance should have been created prior to starting a transaction. <p> &obj)- // store method name which caused the exception obj.method_name= method_name; // store class name (obtained from the data dictionary) obj.class_name= source-&gt;oodb_typeof ().Name (); // raise exception with provided exception object throw obj; - 5 Dynamic object extension and the adding of a PM to support extensions is explained in <ref> [Ram93, chapter 7] </ref>. 66 The following code handles the transaction management: class EH_PM - private: // linear list class scope_list public: scope_list () : pnext (NULL), cnt (0) - -; scope_list *pnext; // point to next list element int cnt; // # of active transactions -; public: ... void push_scope (void);
Reference: [SF85] <author> Axel T. Schreiner and H. Georg Friedman. </author> <title> Introduction to Compiler-Compiler Construction with UNIX. </title> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference-contexts: A general introduction including concepts like LALR and LL grammars, Backus-Naur form, symbol table, parse tree and attribute grammars can be found in various books, for example, [Lem92], [FL88], <ref> [SF85] </ref> (Lex & Yacc) and the "Dragon-book" [ASU86]. 56 the Open OODB meta-requirement of openness because the existing module can be easily modified or extended.
Reference: [Sha94] <author> Phil Shaw. </author> <title> Exceptions PSM (3&92) Change Proposal. ANSI X3H2-94-321R, </title> <month> September </month> <year> 1994. </year> <month> 81 </month>
Reference-contexts: A proposed notation for the new SQL standard <ref> [Sha94] </ref> uses exception handler declarations. These declarations can be specified in modules and in compound statements. It associates one or more exceptions with an SQL procedure.
Reference: [SR] <author> David Muir Sharnoff and Steven Allen Robenalt. </author> <title> Catalog of Free Compilers and Interpreters. </title> <journal> Newsgroup: comp.compilers, monthly. </journal>
Reference-contexts: But this is a rather limited approach because scanning and parsing account for only 15% of a typical compiler [Wai]. In order to overcome the limitations of Lex & Yacc, I looked at several compiler-compilers <ref> [SR] </ref> considering the following criteria: * Specification grammar (or meta-language) of the compiler-compiler. For example, Backus-Naur form (BNF) or extended Backus-Naur form (EBNF). * Parsing algorithm of the compiler-compiler. For example, LALR (k) or LL (k). * Tree construction and traversal.
Reference: [Ste] <author> Steve Ford, </author> <title> Texas Instruments Inc. Private e-mail communication at 4/30/95. </title>
Reference-contexts: Because various forms of transaction scheduling exists we can implement different policy performers. Transactions have been in troduced in 1.2.1. 4 Currently there is neither a specification nor an existing implementation of such a facility in the Open OODB <ref> [Ste] </ref>. 20 * Distribution is the ability of objects to reside in, and be manipulated from, separate objects spaces. The Distribution PM hides the physical address spaces and its differences. <p> The Open OODB has no exception handling model. [Wel93b] points out that "Open OODB will define a collection of exception classes and required handlers to provide traceability for exceptions signaled by hidden policies." But this proposed exception mechanism has not been further specified or implemented so far <ref> [Ste] </ref>. Because the ODMG and the Open OODB object model are very similar, I decided to support basically the ODMG exception model. This model has already been introduced in 1.2.1. Furthermore, I decided to use the existing C++ exception handling facility.
Reference: [Str94] <author> Bjarne Stroustrup. </author> <title> The Design and Evolution of C++. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Since then, several object-oriented languages, like C++ [ES90], Eiffel [Mey92], CommonLisp (+CLOS) and Smalltalk, have introduced exception handling. For example, C++ introduced exceptions in 1990. The first implementations started appearing in 1992. <ref> [Str94] </ref> describes the assumptions that were made for the design. Exceptions are used primarily for error handling. <p> One of these is the normal condition, while the others are exception conditions. A more detailed example of the control flow in the termination model has been described in 1.2.1 and in figure 1.3. C++ and Ada have the termination model of exception handling. 2.2.3 Resumption vs. Termination <ref> [Str94] </ref> summarized the arguments for resumption and for termination: 41 * Resumption: It is a more general and powerful mechanism than termination. The resumption model includes the termination model. It is not significant more complex/expensive to implement. <p> It leads to more manageable systems. It is powerful enough to deal with exceptions in an appropriate manner. Significant negative experience with resumption. The last point is backed up by several major systems that have been written using termination semantics. For example, the following sentences are quoted from <ref> [Str94] </ref>: "The key example was Cedar/Mesa: It was written by people who liked and used resumption, but after ten years of use, there was only one use of resumption left in the half million line system | and that was a context inquiry.
Reference: [Wai] <author> W. M. Waite. </author> <title> Beyond LEX and YACC: How to Generate the Whole Compiler. </title>
Reference-contexts: For example, Lex & Yacc allow a compiler writer to generate the structural analysis of linear text (scanner and parser) from simple specifications. But this is a rather limited approach because scanning and parsing account for only 15% of a typical compiler <ref> [Wai] </ref>. In order to overcome the limitations of Lex & Yacc, I looked at several compiler-compilers [SR] considering the following criteria: * Specification grammar (or meta-language) of the compiler-compiler. For example, Backus-Naur form (BNF) or extended Backus-Naur form (EBNF). * Parsing algorithm of the compiler-compiler.
Reference: [WBT92] <author> David L. Wells, Jose A. Blakeley, and Craig W. Thompson. </author> <title> Architecture of an Open Object-Oriented Database Management System. </title> <journal> Computer, </journal> <volume> 25(10), </volume> <year> 1992. </year>
Reference-contexts: This database is 3 The design and the architecture of the Open OODB is discussed in <ref> [WBT92] </ref>.
Reference: [Wel93a] <author> D. Wells. </author> <title> Open OODB Executive Summary. </title> <type> Technical report, </type> <institution> Texas Instruments Inc., </institution> <year> 1993. </year>
Reference-contexts: This database is 3 The design and the architecture of the Open OODB is discussed in [WBT92]. Further information are provided by the Open OODB manuals, namely [Wel93b] and <ref> [Wel93a] </ref>. 14 developed (and is still under development) by Texas Instruments and is an effort to build an open and extensible system which can serve as a platform for research. 1.3.1 Requirements The Open OODB designers grouped the requirements into a set of functional requirements, describing the capabilities the database must
Reference: [Wel93b] <author> D. Wells. </author> <title> Open OODB Technical Overview Release 0.2 (Alpha). </title> <type> Technical report, </type> <institution> Texas Instruments Inc., </institution> <year> 1993. </year>
Reference-contexts: exception handling model . . . . . . . . . . . . . . . . 12 1.4 Open OODB requirements . . . . . . . . . . . . . . . . . . . . 16 1.5 A universe of objects <ref> [Wel93b] </ref> . . . . . . . . . . . . . . . . . . 17 1.6 Open OODB architecture [Wel93b] . . . . . . . . . . . . . . . 19 2.1 The resumption model . . . . . . <p> . . . . . . . . . . . . . . . . . . . . 16 1.5 A universe of objects <ref> [Wel93b] </ref> . . . . . . . . . . . . . . . . . . 17 1.6 Open OODB architecture [Wel93b] . . . . . . . . . . . . . . . 19 2.1 The resumption model . . . . . . . . . . . . . . . . . . . . . . 40 2.2 The termination model . . . <p> This database is 3 The design and the architecture of the Open OODB is discussed in [WBT92]. Further information are provided by the Open OODB manuals, namely <ref> [Wel93b] </ref> and [Wel93a]. 14 developed (and is still under development) by Texas Instruments and is an effort to build an open and extensible system which can serve as a platform for research. 1.3.1 Requirements The Open OODB designers grouped the requirements into a set of functional requirements, describing the capabilities the <p> The Open OODB has no exception handling model. <ref> [Wel93b] </ref> points out that "Open OODB will define a collection of exception classes and required handlers to provide traceability for exceptions signaled by hidden policies." But this proposed exception mechanism has not been further specified or implemented so far [Ste].
Reference: [Wel94] <author> D. Wells. </author> <title> Open OODB Release Notes Release 0.2.1 (Alpha). </title> <type> Technical report, </type> <institution> Texas Instruments Inc., </institution> <year> 1994. </year> <title> 82 Curriculum Vitae Name Holger Michael Kienle Place of birth Brackenheim, Baden-Wurttemberg, Germany Date of birth September 25, </title> <institution> 1971 High school graduation 1991 Technisches Gymnasium, Bietigheim-Bissingen, Germany, Abitur Education 1991 - 1994 University of Stuttgart, Germany: Computer Science 1993 Vordiplom in Informatik 1994 - 1995 University of Massachusetts Dartmouth: Computer and Information Science </institution>
Reference-contexts: The Open OODB C++ API can be found in the directory O3DBROOT/src/PersistentC++/pasm/oodbPM. The file oodb.c in this directory contains the implementation of the OpenOODB class. This class provides the C++ API. Further information about the mapping of the Open OODB architecture into the directory structure can be found in <ref> [Wel94] </ref>. A.2.1 tryscope The files O3DBROOT/src/PersistentC++/include/tryscope.h and O3DBROOT /src/PersistentC++/pasm/oodbPM/tryscope.c contain the implementation of the class oodb tryscope. This class has already been introduced in 3.2.2. It is included via oodb.c.
References-found: 45

