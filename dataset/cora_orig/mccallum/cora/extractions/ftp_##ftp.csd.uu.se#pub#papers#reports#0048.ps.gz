URL: ftp://ftp.csd.uu.se/pub/papers/reports/0048.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Email: JONAS@AIDA.UU.SE, NILSH@AIDA.UU.SE, MALIKW@AIDA.UU.SE  
Phone: +46-18-18 25 00  
Title: Condition Graphs  
Author: Jonas Barklund, Nils Hagner and Malik Wafin 
Note: Electronic mail:  
Address: Box 520, S-751 20 Uppsala, Sweden  
Affiliation: Uppsala Programming Methodology and Artificial Intelligence Laboratory Computing Science Dept., Uppsala University  
Abstract: UPMAIL Technical Report No. 48 June 10, 1988 Abstract A connection graph represents resolvability in a set of clauses explicitly. The corresponding connection graph proof procedure has the deficiency that the graphs may grow, becoming impractical to handle. We present a novel proof procedure for condition graphs, which is a refinement of connection graphs. Our idea is to control the growth of the graph by recognizing tests in clauses and translating them to restrictions on the resolvability of links. A link is not selected for resolution unless all its associated tests have been determined to be true. The condition graph proof procedure exploits the inherent parallelism in logic programs. We present a parallel logic programming language with appealing theoretical properties, which is executed efficiently using the condition graph proof procedure. An abstract parallel machine for the language is defined. A realization of the machine on the Connection Machine, a massively parallel computer, is outlined. The research reported herein was supported by the National Swedish Board for Technical Development (STU). 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> J. Barklund, N. Hagner, M. Wafin, </author> <title> "KL1 in Condition Graphs on a Connection Machine," </title> <type> UPMAIL Technical Report 51 (Uppsala: </type> <institution> Uppsala University, Computing Science Dept., </institution> <month> May </month> <year> 1988). </year>
Reference-contexts: This means that no possible solutions are discarded. Another consequence is that we cannot assume that every attempt to communicate is made in a deterministic state. In particular, input/output is non-trivial <ref> [1] </ref>. For increasing efficiency, the tests of different clauses should be mutually exclusive when possible. The language has good properties for program transformations, such as partial evaluation. E.g., fold and unfold operations can always be done. <p> The instructions are issued by a host machine, to which the Connection Machine acts like an active memory or a co-processor. A brief overview of our mapping of CIM on CM follows, more details can be found elsewhere <ref> [1] </ref>. 4 Languages proposed for the Connection Machine include versions of Common Lisp and C [20] extended with data parallel primitives. We are unaware of any logic programming languages proposed for the Connection Machine, but DAP-Prolog [12] is a language for another SIMD machine. <p> We are also studying compilation of KL1 (a further development of FGHC) [13,21] to Condition Graphs, as an alternative to Uplog <ref> [1] </ref>. ACKNOWLEDGEMENTS The authors want to thank their colleagues at UPMAIL for providing a fine research environment, cakes, and table tennis games. Professors Sten -Ake Tarnlund and -Ake Hansson 5 gave many important comments on drafts of this paper. Marianne Ahrne improved the lan-guage significantly.
Reference: 2. <author> J. Barklund, H. Millroth, </author> <title> "Parallel Unification," </title> <type> UPMAIL Technical Report 46 (Upp-sala: </type> <institution> Uppsala University, Computing Science Dept., </institution> <month> June </month> <year> 1988). </year>
Reference-contexts: Execution The three phases in CIM are mapped to corresponding instruction sequences on the CM. An incremental garbage collection is provided by the reduction step of the cycle. Algorithms for parallel unification have been developed and are presented elsewhere <ref> [2] </ref>. 7. SUMMARY AND RELATED WORK Condition graphs are a novel extension to connection graphs, with a corresponding proof procedure. They are, due to explicitly relating resolvable clauses and preventing uncontrolled growth, well suited for use in parallel inference systems.
Reference: 3. <author> J. Barklund, H. Millroth, </author> <title> "Nova Prolog," </title> <type> UPMAIL Technical Report 52 (Uppsala: </type> <institution> Uppsala University, Computing Science Dept., </institution> <month> June </month> <year> 1988). </year>
Reference-contexts: P-Prolog [23] is a language which like Uplog allows don't-know non-determinism. Taylor's work on compilation of Concurrent Prolog to decision graphs [19] provided some inspiration for the work. A completely different approach to logic programming on Connection Machines is Nova Prolog by Barklund and Millroth <ref> [3] </ref>. Prolog is extended with a new parallel data structure and a matching control structure. 8.
Reference: 4. <author> N. Eisinger, </author> <title> "What You Always Wanted to Know about Clause Graph Resolution," </title> <booktitle> 8th Conference on Automated Deduction, </booktitle> <editor> ed. J. Siekmann, </editor> <booktitle> Lecture Notes in Computer Science 230 (Berlin: </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1986), </year> <pages> 316-36. </pages>
Reference-contexts: To benefit from the parallelism in logic programs, it is natural to look into selection and resolution upon several links in a connection graph simultaneously. Doing so, it is difficult to ensure that the refutation completeness and confluence properties will hold <ref> [4] </ref>. We can do that, provided that proper restrictions are made for the graphs and the selection of links. A Horn clause is a clause with exactly one atom in its left side and a goal clause is a clause with an empty left side. <p> Remove L from G and remove every link of B except L from G 0 . Select all unique active links. (This preserves confluence and justifies our use of an irrevocable control strategy <ref> [4] </ref>. If resources are scarce, not all goals with multiple links need to be `split'. In effect, when several alternative clauses for an atom remain after their tests are run, they will be executed in an or-parallel fashion, but the or-parallel goals will be started one by one.) 2. Resolve.
Reference: 5. <author> I. Foster, S. Taylor, </author> <title> "Flat Parlog: A Basis for Comparison," </title> <type> Report CS87-13 (Rehovot: </type> <institution> Weizmann Institute of Science, </institution> <year> 1987). </year>
Reference-contexts: THE UPLOG LANGUAGE The condition graph proof procedure could be used with several different languages. Let us, for example, study a particular language: Uplog, a Horn clause language. It is similar to Flat PARLOG <ref> [5] </ref> or Flat Guarded Horn Clauses (FGHC) [22] but there is no commit operator.
Reference: 6. <author> K. Furukawa, A. Okumura, M. Murakami, </author> <title> "Unfolding Rules for GHC Programs," Workshop on Partial Evaluation and Mixed Computation, </title> <editor> ed. D. </editor> <month> Bjtrner </month> <year> (1987). </year>
Reference-contexts: E.g., fold and unfold operations can always be done. In the example below, proofs including clauses 1 and 2 will succeed iff proofs including clause 3 succeed. This is not true for the corresponding program in a committed choice language <ref> [6] </ref>. P T 1 & Q ^ R (1) P T 1 ^ T 2 & S ^ R (3) 5.
Reference: 7. <author> Y. Futamura, </author> <title> "Partial Computation of Programs," </title> <booktitle> RIMS Symposia on Software Science and Engineering 1982, </booktitle> <editor> ed. E. Goto et al., </editor> <booktitle> Lecture notes in Computer Science 147 (Berlin: </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1983), </year> <pages> 1-35. </pages>
Reference-contexts: The optimizations require template goals to be included in the program, that is, a declaration of the entry points. These template goals are substituted at run-time by the actual goals. We have considered different methods for preprocessing, e.g.; removal of pure clauses and partial computation <ref> [7] </ref>. After the CIM compiler has produced an ICG, control is transferred to the run-time system. An instance of the goal is injected, replacing the template goal by the actual goal. The run-time system is based on a three-phase cycle, which repeatedly performs the following steps: 1. Select.
Reference: 8. <author> I. Futo, C. Percebois, I. Durand, C. Simon, B. Bonhoure, </author> <title> Simulation Results of a Multiprocessor Prolog Architecture Based on a Distributed AND/OR Graph (Toulouse: </title> <institution> Universite Paul Sabatier, Laboratoire Langages et Systemes Informatiques, </institution> <year> 1986). </year>
Reference-contexts: The Connection Machine is especially well suited to handle graph structure problems. This, in addition to the similarities in synchronization, makes CM a natural and powerful computer architecture for an implementation of CIM. COALA is an implementation of a parallel inference machine based on the CG proof procedure <ref> [8] </ref>. P-Prolog [23] is a language which like Uplog allows don't-know non-determinism. Taylor's work on compilation of Concurrent Prolog to decision graphs [19] provided some inspiration for the work. A completely different approach to logic programming on Connection Machines is Nova Prolog by Barklund and Millroth [3].
Reference: 9. <author> N. Hagner, M. Wafin, </author> <title> "Parallel Logic Programming using Condition Graphs," </title> <institution> UPMAIL Undergraduate Theses (Uppsala: Uppsala University, Computing Science Dept., </institution> <year> 1988). </year>
Reference: 10. <author> W. D. Hillis, </author> <title> The Connection Machine (Cambridge, </title> <address> Mass.: </address> <publisher> MIT Press, </publisher> <year> 1985). </year>
Reference: 11. <author> W. D. Hillis, G. L. Steele Jr., </author> <title> "Data Parallel Algorithm," </title> <booktitle> Communications of the ACM 29 (December 1986): </booktitle> <pages> 1170-1183. </pages>
Reference: 12. <author> P. Kacsuk, A. Bale, </author> <title> "DAP Prolog: A Set-oriented Approach to Prolog," </title> <note> Computer Journal 30 (October 1987): 393-403. </note>
Reference-contexts: We are unaware of any logic programming languages proposed for the Connection Machine, but DAP-Prolog <ref> [12] </ref> is a language for another SIMD machine. Representation of CIM The Connection Machine is a natural target machine for implementing the CIM, because the clauses, tests, and links in a condition graph can be conveniently mapped on Connection Machine processors.
Reference: 13. <author> Y. Kimura, T. Chikayama, </author> <title> "An Abstract KL1 Machine and Its Instruction Set," </title> <booktitle> 1987 Symposium on Logic Programming, </booktitle> <editor> ed. S. </editor> <address> Haridi (Washington, D.C.: </address> <publisher> IEEE Computer Society Press, </publisher> <year> 1987), </year> <pages> 468-77. </pages>
Reference: 14. <author> R. Kowalski, </author> <title> "A Proof Procedure Using Connection Graphs," </title> <journal> Journal of the ACM 22 (October 1975): </journal> <pages> 572-595. </pages>
Reference: 15. <author> R. Kowalski, </author> <title> Logic for Problem Solving (New York: </title> <publisher> North Holland, </publisher> <year> 1979). </year>
Reference: 16. <author> J. A. Robinson, </author> <title> "A Machine-Oriented Logic Based on the Resolution Principle," </title> <journal> Journal of the ACM 12 (January 1965): </journal> <pages> 23-41. </pages>
Reference-contexts: The links to the resolvent are completely determined by the links to the parent clauses and of the selected link (link inheritance). Clauses in the graph, containing an unlinked atom, can be deleted from the graph according to the purity principle <ref> [16] </ref>. Thus, redundant clauses are easily detected and deleted. For completeness, factoring must also be applied. The resolution cycle is repeated until one of the following conditions is met. If a resolvent is the empty clause, then a refutation has been found.
Reference: 17. <author> J. Siekmann, W. Stephan, </author> <title> "Completeness and Soundness of the Connection Graph Proof Procedure," </title> <type> Bericht 7/76 (Karlsruhe: </type> <institution> Fakultat Informatik, Universitat Karl-sruhe, </institution> <year> 1976). </year>
Reference: 18. <author> G. L. Steele Jr., W. D. Hillis, </author> <title> "Connection Machine Lisp: Fine-Grained Parallel Symbolic Processing," </title> <booktitle> 1986 ACM Conference on Lisp and Functional Programming, </booktitle> <editor> ed. W. L. Scherlis and J. H. </editor> <address> Williams (New York: </address> <institution> Association for Computing Machinery, </institution> <month> August </month> <year> 1986), </year> <pages> 279-97. 6 </pages>
Reference: 19. <author> S. Taylor, E. Shapiro, </author> <title> "Compiling Concurrent Logic Programs into Decision Graphs," </title> <type> Report CS87-12 (Rehovot: </type> <institution> Weizmann Institute of Science, </institution> <year> 1987). </year> <title> 20. "Introduction to Data Level Parallelism," </title> <type> Technical Report Series TR86-14 (Cam-bridge: </type> <institution> Thinking Machines Corp., </institution> <month> April </month> <year> 1986). </year>
Reference-contexts: COALA is an implementation of a parallel inference machine based on the CG proof procedure [8]. P-Prolog [23] is a language which like Uplog allows don't-know non-determinism. Taylor's work on compilation of Concurrent Prolog to decision graphs <ref> [19] </ref> provided some inspiration for the work. A completely different approach to logic programming on Connection Machines is Nova Prolog by Barklund and Millroth [3]. Prolog is extended with a new parallel data structure and a matching control structure. 8.
Reference: 21. <author> S. Uchida, </author> <title> "Inference Machines in FGCS Project," </title> <type> ICOT Technical Report TR-278 (Tokyo: </type> <institution> Institute for New Generation Computer Technology [ICOT], </institution> <year> 1987). </year>
Reference: 22. <author> K. Ueda, </author> <title> "Guarded Horn Clauses," </title> <type> ICOT Technical Report TR-103 (Tokyo: </type> <institution> Institute for New Generation Computer Technology [ICOT], </institution> <year> 1985). </year>
Reference-contexts: THE UPLOG LANGUAGE The condition graph proof procedure could be used with several different languages. Let us, for example, study a particular language: Uplog, a Horn clause language. It is similar to Flat PARLOG [5] or Flat Guarded Horn Clauses (FGHC) <ref> [22] </ref> but there is no commit operator. An Uplog clause has the form H T 1 ^ : : : ^ T m & B 1 ^ : : : ^ B n where H and B i are atoms, T j are primitive tests, and & is a fence.
Reference: 23. <author> R. Yang, H. Aiso, "P-Prolog: </author> <title> A Parallel Logic Language Based on Exclusive Relation," </title> <booktitle> Third International Conference on Logic Programming, </booktitle> <editor> ed. E. Shapiro, </editor> <booktitle> Lecture Notes in Computer Science 225 (Berlin: </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1986), </year> <pages> 255-269. 7 </pages>
Reference-contexts: This, in addition to the similarities in synchronization, makes CM a natural and powerful computer architecture for an implementation of CIM. COALA is an implementation of a parallel inference machine based on the CG proof procedure [8]. P-Prolog <ref> [23] </ref> is a language which like Uplog allows don't-know non-determinism. Taylor's work on compilation of Concurrent Prolog to decision graphs [19] provided some inspiration for the work. A completely different approach to logic programming on Connection Machines is Nova Prolog by Barklund and Millroth [3].
References-found: 22

