URL: ftp://ftp.cc.gatech.edu/pub/gvu/tr/1991/91-08.ps.Z
Refering-URL: http://www.cs.gatech.edu/gvu/reports/1991/
Root-URL: 
Title: distributed programming is intrinsically more difficult than sequential programming, yet few effective tools or methodologies
Author: William F. Appelbe John T. Stasko Eileen Kraemer bill j stasko 
Note: Parallel and  
Address: Atlanta, GA 30332-0280  
Affiliation: College of Computing Georgia Institute of Technology  
Pubnum: Technical Report GIT-CC 91/34  
Email: j eileen@cc.gatech.edu  
Date: October 16, 1993  
Abstract: Applying Program Visualization Techniques to Aid Parallel and Distributed Program Development (Work In Progress) Technical Report GIT-GVU-91-08 Abstract Program visualization, which relates a program's behavior to the programmer's model of the system's components and interactions, has been shown to be a novel and highly effective approach to program and algorithm comprehension. Extending and adapting program visualization to parallel programming can aid comprehension of the complex concurrent events and transitions that occur in parallel programs. We are defining a model for the capture and display of parallel program events and transitions, based upon the path-transition paradigm for animation, and partial ordering of events. Using this model, we are developing a prototype for visualizing parallel programs, and testing the model and prototype upon a suite of scientific parallel programs. 
Abstract-found: 1
Intro-found: 1
Reference: [AB + 88] <author> F. Allen, M. Burke, et al. </author> <title> An overview of the PTRAN analysis system. </title> <booktitle> In Proceedings of the 1987 International Conference on Supercomputing. </booktitle> <publisher> Springer Verlag, </publisher> <month> February </month> <year> 1988. </year>
Reference-contexts: Such tools fall into four classes: 1. Static analyzers and parallelizers, which analyze source code to determine which sections of code can be parallelized, transform source code into parallel forms, and determine if user-inserted parallel constructs and directives are erroneous <ref> [CKT86, AB + 88, ASM89] </ref>. 2.
Reference: [AB89] <author> Allen L. Ambler and Margaret M. Burnett. </author> <title> Influence of visual technology on the evolution of language environments. </title> <journal> Computer, </journal> <volume> 22(10) </volume> <pages> 9-22, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: Scientific visualizations, which display the program states in a format specifically designed to closely match the physical system being modeled (e.g., cloud and tornado formation over a plain, with the cloud displayed using shading and volumetric rendering)[DCH88, DBM89]. Due to successes in serial program development <ref> [AB89] </ref> and as evident by ongoing research in classes 2, 3, and 4 above, increasing attention has been directed toward visualization techniques in order to help developers understand the runtime behavior of their parallel programs.
Reference: [AG89] <author> Ziya Aral and Ilya Gertner. </author> <title> High-level debugging in Parasight. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(1) </volume> <pages> 151-162, </pages> <month> January </month> <year> 1989. </year> <booktitle> (Proceedings of the Workshop on Parallel and Distributed Debugging, </booktitle> <address> Madison, WI, </address> <month> May </month> <year> 1988). </year>
Reference-contexts: There are two different mechanisms for gathering event data: snooping, in which a monitor task running concurrently with the program monitors the state of the program by accessing global data, and tracing, in which the program makes explicit calls to generate events. Snooping is less intrusive <ref> [AG89] </ref>, but more complex to implement and unnecessary for posthumous animation. It is exceptionally difficult to acquire display events via snooping also [Bro88c]. Hence, we use event tracing for the implementation of our system, focusing on a flexible self-documenting trace format such as described in [ROA + 91].
Reference: [ASM89] <author> Bill Appelbe, Kevin Smith, and Charlie McDowell. START/PAT: </author> <title> A parallel programming toolkit. </title> <journal> IEEE Software, </journal> <volume> 6(4) </volume> <pages> 29-38, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Such tools fall into four classes: 1. Static analyzers and parallelizers, which analyze source code to determine which sections of code can be parallelized, transform source code into parallel forms, and determine if user-inserted parallel constructs and directives are erroneous <ref> [CKT86, AB + 88, ASM89] </ref>. 2. <p> However, these tools often cannot uncover subtle bugs in which a parallel program's output does not reflect the physics of the system being modeled. Examples of such difficult bugs have occurred often. For example, in a monte-carlo parallel simulation of gamma particles <ref> [ASM89] </ref> the original sequential algorithm had a bug whereby particles travelling very close to perpendicular caused invalid interparticle interactions. The bug took months to discover by traditional techniques, but an animation system with simple facilities for displaying particles would have rapidly isolated the bug. <p> We will adopt a simple prototype, in which the event log is generated by user-inserted calls for display events, and a modified library for generating task events. Later we intend to use our existing tools, PAT <ref> [ASM89, SAS90, ASS91a] </ref> and IOS [ASS91b], to help automate the insertion of code to generate display events. PAT is an interactive parallelizer for Fortran, developed by one of the authors at Georgia Tech over the past four years.
Reference: [ASS91a] <author> Bill Appelbe, Kevin Smith, and Kurt Stirewalt. </author> <title> PATCH anew algorithm for rapid incremental dependence analysis. </title> <booktitle> In Proceedings of the 1991 International Conference on Supercomputing, </booktitle> <address> Cologne, Germany, </address> <month> June </month> <year> 1991. </year> <note> To appear. </note>
Reference-contexts: We will adopt a simple prototype, in which the event log is generated by user-inserted calls for display events, and a modified library for generating task events. Later we intend to use our existing tools, PAT <ref> [ASM89, SAS90, ASS91a] </ref> and IOS [ASS91b], to help automate the insertion of code to generate display events. PAT is an interactive parallelizer for Fortran, developed by one of the authors at Georgia Tech over the past four years.
Reference: [ASS91b] <author> Bill Appelbe, Kevin Smith, and Kurt Stirewalt. </author> <title> Unbundling a compiler interfacing parallel programming tools together. </title> <note> Submitted to Supercomputing '91, </note> <year> 1991. </year>
Reference-contexts: We will adopt a simple prototype, in which the event log is generated by user-inserted calls for display events, and a modified library for generating task events. Later we intend to use our existing tools, PAT [ASM89, SAS90, ASS91a] and IOS <ref> [ASS91b] </ref>, to help automate the insertion of code to generate display events. PAT is an interactive parallelizer for Fortran, developed by one of the authors at Georgia Tech over the past four years.
Reference: [Bae69] <author> Ronald M. Baecker. </author> <title> Picture-driven animation. </title> <booktitle> In Spring Joint Computer Conference, </booktitle> <volume> volume 34, </volume> <pages> pages 273-288. </pages> <publisher> AFIPS Press, </publisher> <year> 1969. </year>
Reference-contexts: The notion of describing an action, such as movement or a change in size, by specifying an image and a control path is much more straightforward and easier to define than a series of "draw-erase" pairs with incremental calculations. This idea follows the pioneering p-curve work of Baecker <ref> [Bae69] </ref>. 2. The paradigm supports animation routines which are data-driven, that is, animations able to be encapsulated in procedures receiving parameters controlling the animation's format, the object to be moved, the destination location of an object's movement, the size that an object should grow to, etc.
Reference: [Bas85] <author> David B. Baskerville. </author> <title> Graphic presentation of data structures in the DBX debugger. </title> <type> Technical Report UCB/CSD 86/260, </type> <institution> University of California at Berkeley, Berkeley, </institution> <address> CA, </address> <month> October </month> <year> 1985. </year>
Reference-contexts: The vast majority of research on graphical display of programs has been for serial programming. These program visualization systems [Mye90] can be divided into two broad categories: data structure display and algorithm animation systems. Data structure display systems <ref> [Mye83, Bas85, ISO87, Moh88, RMD89] </ref> provide automatic, canonical views of a program's data structures. They utilize sophisticated screen layout algorithms to show program data while a user traces a program in a debugger.
Reference: [Bro88a] <author> Marc H. Brown. </author> <title> Algorithm Animation. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1988. </year>
Reference-contexts: They utilize sophisticated screen layout algorithms to show program data while a user traces a program in a debugger. These tools provide little in the way of application domain specific information, so they are not sufficient for our purposes. Algorithm animation systems <ref> [Bro88b, Bro88a, LD85, Dui86, Dui87, HHR89] </ref>, conversely, present dynamic graphical views of programmer-defined abstractions of the important data, operations, goals, and actions in programs. We shall adapt techniques developed in these serial algorithm animation systems in order to aid parallel program visualization and debugging.
Reference: [Bro88b] <author> Marc H. Brown. </author> <title> Exploring algorithms using Balsa-II. </title> <journal> Computer, </journal> <volume> 21(5) </volume> <pages> 14-36, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: His system creates a relational database of program execution information, and allows users to pose post-mortem queries against the database. His most high-level application data views are similar to those found in the sequential visualization system BALSA <ref> [Bro88b] </ref>. Our approach differs from the two previous systems in an increased emphasis on the resultant visualizations and animations. We want to support highly-semantic application views that exhibit smooth, gradual changes over time. <p> They utilize sophisticated screen layout algorithms to show program data while a user traces a program in a debugger. These tools provide little in the way of application domain specific information, so they are not sufficient for our purposes. Algorithm animation systems <ref> [Bro88b, Bro88a, LD85, Dui86, Dui87, HHR89] </ref>, conversely, present dynamic graphical views of programmer-defined abstractions of the important data, operations, goals, and actions in programs. We shall adapt techniques developed in these serial algorithm animation systems in order to aid parallel program visualization and debugging.
Reference: [Bro88c] <author> Marc H. Brown. </author> <title> Perspectives on algorithm animation. </title> <booktitle> In Proceedings of the ACM SIGCHI '88 Conference on Human Factors in Computing Systems, </booktitle> <pages> pages 33-38, </pages> <address> Washington D.C., </address> <month> May </month> <year> 1988. </year>
Reference-contexts: Snooping is less intrusive [AG89], but more complex to implement and unnecessary for posthumous animation. It is exceptionally difficult to acquire display events via snooping also <ref> [Bro88c] </ref>. Hence, we use event tracing for the implementation of our system, focusing on a flexible self-documenting trace format such as described in [ROA + 91]. To understand display events better, let us examine their role in sequential algorithm animations. <p> IOS provides operations to browse and find locations in the source code where events need to be inserted (e.g., after the first assignment to a program variable in a specific subroutine) then generate and insert code fragments. The insertion of display events cannot be fully automated <ref> [Bro88c] </ref>, but can be greatly simplified by IOS' capability to display the program structure (e.g., call graphs, flowgraphs, and source), and to insert code using templates. For example, if a programmer wishes to find references to a given variable, these can be browsed.
Reference: [BW83] <author> Peter Bates and Jack C. Wileden. </author> <title> An approach to high-level debugging of distributed systems. </title> <journal> SIGPLAN Notices, </journal> <volume> 18(8) </volume> <pages> 107-111, </pages> <month> August </month> <year> 1983. </year>
Reference-contexts: Data gathered consist of an event log, either input directly to the animation program or saved in a file for posthumous animation <ref> [BW83, LMC87] </ref>. Each event is usually times-tamped with the system clock time at which the event occurred, event parameters, and a task-id. In our model two types of program events are required: task events and display events.
Reference: [Cha87] <author> Shi-Kuo Chang. </author> <title> Visual languages: A tutorial and survey. </title> <journal> IEEE Software, </journal> <volume> 4(1) </volume> <pages> 29-39, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Hence, the tool should preserve objects throughout an entire animation design. Also, the tool should allow for features such as abstraction, indexing, and iteration in a more consistent manner. Fundamentally, the tool must become more of a visual programming system <ref> [Cha87, Shu88] </ref>.
Reference: [CKT86] <author> Keith Cooper, Ken Kennedy, and Linda Torczon. </author> <title> The impact of interproce-dural analysis and optimization in the r n programming environment. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(4) </volume> <pages> 491-523, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: Such tools fall into four classes: 1. Static analyzers and parallelizers, which analyze source code to determine which sections of code can be parallelized, transform source code into parallel forms, and determine if user-inserted parallel constructs and directives are erroneous <ref> [CKT86, AB + 88, ASM89] </ref>. 2.
Reference: [DBKF90] <author> Jack Dongarra, Orlie Brewer, James Arthur Kohl, and Samuel Fineberg. </author> <title> A tool to aid in the design, implementation, and understanding of matrix algorithms for parallel processors. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 9(2) </volume> <pages> 185-202, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Histograms, dials, gauges, and Kiviat diagrams reflect message traffic and processor actions. Similarly, Heath [Hea89] provides nine different performance views, including Feynman diagrams and Gantt charts among others, of programs running on message-passing multiprocessor architectures. The SHMAP <ref> [DBKF90] </ref> 3 tool provides views of memory access and utilization of parallel Fortan matrix algorithms. The system's designers note that a better understanding of processor memory usage can help to improve program performance and promote experimentation with alternate usage strategies. <p> The choreographer must "parse" program execution information and store it in a convenient form for later usage. Various strategies for the form's implementation range from databases [HC87, Sar90, KS91], to directed acyclic graphs [LMCF90], to program activity graphs [M + 90], to hierarchical structures <ref> [DBKF90] </ref>. We are examining all these approaches and determining if one is most useful for storing the information necessary to generate the highly application-semantic algorithm animations we display. Possibly, we will need to develop a new representation.
Reference: [DBM89] <author> Thomas A. DeFanti, Maxine D. Brown, and Bruce H. McCormick. </author> <title> Visualization: Expanding scientific and research opportunities. </title> <journal> Computer, </journal> <volume> 22(8) </volume> <pages> 12-25, </pages> <month> August </month> <year> 1989. </year>
Reference: [DCH88] <author> R. A. Drebin, L. Carpenter, and P. Hanrahan. </author> <title> Volume rendering. </title> <journal> Computer Graphics: </journal> <volume> SIGGRAPH '88, 22(4) </volume> <pages> 65-74, </pages> <month> August </month> <year> 1988. </year>
Reference: [Dui86] <author> Robert A. Duisberg. </author> <title> Animated graphical interfaces using temporal constraints. </title> <booktitle> In Proceedings of the ACM SIGCHI '86 Conference on Human Factors in Computing Systems, </booktitle> <pages> pages 131-136, </pages> <address> Boston, MA, </address> <month> April </month> <year> 1986. </year>
Reference-contexts: They utilize sophisticated screen layout algorithms to show program data while a user traces a program in a debugger. These tools provide little in the way of application domain specific information, so they are not sufficient for our purposes. Algorithm animation systems <ref> [Bro88b, Bro88a, LD85, Dui86, Dui87, HHR89] </ref>, conversely, present dynamic graphical views of programmer-defined abstractions of the important data, operations, goals, and actions in programs. We shall adapt techniques developed in these serial algorithm animation systems in order to aid parallel program visualization and debugging.
Reference: [Dui87] <author> Robert A. Duisberg. </author> <title> Visual programming of program visualizations. A gestural interface for animating algorithms. </title> <booktitle> In Proceedings of the 1987 IEEE Computer Society Workshop on Visual Languages, </booktitle> <pages> pages 55-66, </pages> <address> Linkoping, Sweden, </address> <month> August </month> <year> 1987. </year>
Reference-contexts: They utilize sophisticated screen layout algorithms to show program data while a user traces a program in a debugger. These tools provide little in the way of application domain specific information, so they are not sufficient for our purposes. Algorithm animation systems <ref> [Bro88b, Bro88a, LD85, Dui86, Dui87, HHR89] </ref>, conversely, present dynamic graphical views of programmer-defined abstractions of the important data, operations, goals, and actions in programs. We shall adapt techniques developed in these serial algorithm animation systems in order to aid parallel program visualization and debugging.
Reference: [FAJ91] <author> Joan Francioni, Larry Albright, and Jay Alan Jackson. </author> <title> Debugging parallel programs with sound. </title> <journal> SIGPLAN Notices, </journal> <volume> 26(12) </volume> <pages> 60-68, </pages> <month> December </month> <year> 1991. </year> <booktitle> (Proceedings of the ACM/ONR '91 Workshop on Parallel and Distributed Debugging). </booktitle>
Reference-contexts: This new model replaces the notion of composition of transitions in the path-transition paradigm, which was problematic in cases like the one of balls moving inside a chamber as described above. We also plan to explore how to incorporate sound information <ref> [FAJ91] </ref> into the animation design kit. The second level of the animation framework consists of a library of prototypical algorithm animation actions, the animation scenes noted earlier, available for use by designers.
Reference: [FLMC89] <author> Robert J. Fowler, Thomas J. LeBlanc, and John M. Mellor-Crummey. </author> <title> An integrated approach to parallel progam debugging and performance analysis on large-scale multiprocessors. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(1) </volume> <pages> 163-173, </pages> <month> January </month> <year> 1989. </year> <booktitle> (Proceedings of the Workshop on Parallel and Distributed Debugging, </booktitle> <address> Madison, WI, </address> <month> May </month> <year> 1988). </year>
Reference: [GJG + 89] <author> Vincent A. Guarna Jr., Dennis Gannon, et al. </author> <title> Faust: An integrated environment for parallel programming. </title> <journal> IEEE Software, </journal> <volume> 6(4) </volume> <pages> 20-27, </pages> <month> July </month> <year> 1989. </year>
Reference: [HC87] <author> Alfred A. Hough and Janice E. Cuny. Belvedere: </author> <title> Prototype of a pattern-oriented debugger for highly parallel computation. </title> <booktitle> In Proceedings of the 1987 International Conference on Parallel Processing, </booktitle> <pages> pages 735-738, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: The choreographer must "parse" program execution information and store it in a convenient form for later usage. Various strategies for the form's implementation range from databases <ref> [HC87, Sar90, KS91] </ref>, to directed acyclic graphs [LMCF90], to program activity graphs [M + 90], to hierarchical structures [DBKF90]. We are examining all these approaches and determining if one is most useful for storing the information necessary to generate the highly application-semantic algorithm animations we display.
Reference: [HC90] <author> Alfred A. Hough and Janice E. Cuny. </author> <title> Perspective views: A technique for enhancing parallel program visualization. </title> <type> Technical Report COINS 90-02, </type> <institution> Univ. of Massachusetts, </institution> <address> Amherst, MA, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: The system can determine race conditions and temporal orderings of task events. Our choreographer must handle these duties, as well as interpret display events, and coordinate this information with the animation component. Hough and Cuny have addressed the notion of the ordering of abstract events in parallel programs <ref> [HC90] </ref>. Their work on perspective views provides algorithms for reordering events into logical units that are more useful for developing program visualizations. These results and algorithms should be useful in developing our animation choreographer.
Reference: [Hea89] <author> Michael T. Heath. </author> <title> Visual animation of parallel algorithms for matrix computations. </title> <booktitle> In Proceedings of the Hypercube Conference, </booktitle> <pages> pages 735-738, </pages> <year> 1989. </year>
Reference-contexts: Malony, Reed, and others [MR88, MRA + 89] have created a number of flexible X-Windows based performance monitoring widgets. Histograms, dials, gauges, and Kiviat diagrams reflect message traffic and processor actions. Similarly, Heath <ref> [Hea89] </ref> provides nine different performance views, including Feynman diagrams and Gantt charts among others, of programs running on message-passing multiprocessor architectures. The SHMAP [DBKF90] 3 tool provides views of memory access and utilization of parallel Fortan matrix algorithms.
Reference: [HHK85] <author> Paul K. Harter, Dennis M. Heimbigner, and Roger King. IDD: </author> <title> An interactive distributed debugger. </title> <booktitle> In Proceedings of the Fifth International Conference on Distributed Computing Systems, </booktitle> <pages> pages 498-506, </pages> <month> May </month> <year> 1985. </year>
Reference: [HHR89] <author> Esa Helttula, Aulikki Hyrskykari, and Kari-Jouko Raiha. </author> <title> Graphical specification of algorithm animations with Aladdin. </title> <booktitle> In Proceedings of the 22nd Hawaii International Conference on System Sciences, </booktitle> <pages> pages 892-901, </pages> <address> Kailua-Kona, HI, </address> <month> January </month> <year> 1989. </year> <month> 19 </month>
Reference-contexts: They utilize sophisticated screen layout algorithms to show program data while a user traces a program in a debugger. These tools provide little in the way of application domain specific information, so they are not sufficient for our purposes. Algorithm animation systems <ref> [Bro88b, Bro88a, LD85, Dui86, Dui87, HHR89] </ref>, conversely, present dynamic graphical views of programmer-defined abstractions of the important data, operations, goals, and actions in programs. We shall adapt techniques developed in these serial algorithm animation systems in order to aid parallel program visualization and debugging.
Reference: [HMW90] <author> David P. Helmbold, Charlie E. McDowell, and Jian-Zhong Wang. Traceviewer: </author> <title> A graphical browser for trace analysis. </title> <type> Technical Report UCSC-CRL-90-59, </type> <institution> Univ. of California at Santa Cruz, </institution> <address> Santa Cruz, CA, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: Systems such as Instant Replay [LMC87] can recreate events within partial orderings according to the logical time [Lam78]. Others such as Bugnet [Wit89], designed for monitoring distributed systems, use periodic sampling methods to help reproduce the real-time ordering of processor events. Helmbold, McDowell, and Wang <ref> [HMW90] </ref> have created an interactive tool for analyzing trace information in parallel Fortran programs. The system can determine race conditions and temporal orderings of task events. Our choreographer must handle these duties, as well as interpret display events, and coordinate this information with the animation component.
Reference: [ISO87] <author> Sadahiro Isoda, Takao Shimomura, and Yuji Ono. </author> <title> VIPS: A visual debugger. </title> <journal> IEEE Software, </journal> <volume> 4(3) </volume> <pages> 8-19, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: The vast majority of research on graphical display of programs has been for serial programming. These program visualization systems [Mye90] can be divided into two broad categories: data structure display and algorithm animation systems. Data structure display systems <ref> [Mye83, Bas85, ISO87, Moh88, RMD89] </ref> provide automatic, canonical views of a program's data structures. They utilize sophisticated screen layout algorithms to show program data while a user traces a program in a debugger.
Reference: [KBI88] <author> A. H. Karp and R. G. Babb II. </author> <title> A comparison of 12 parallel Fortran dialects. </title> <journal> IEEE Software, </journal> <volume> 5(5) </volume> <pages> 52-67, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: Unfortunately, the process of parallel program development is extremely difficult in part because parallel program constructs have been grafted onto existing sequential languages such as Fortran in an extremely ad hoc, machine dependent manner <ref> [KBI88] </ref>. Erroneous use of these constructs often results in inefficient, or worse incorrect, programs. Also, few tools for parallel program development have been developed, and those that have, such as debuggers and performance monitors, are often poorly integrated and difficult to use.
Reference: [KS91] <author> Carol Kilpatrick and Karsten Schwan. </author> <title> ChaosMON-application-specific monitoring and display of performance information for parallel and distributed systems. </title> <journal> SIGPLAN Notices, </journal> <volume> 26(12) </volume> <pages> 57-67, </pages> <month> December </month> <year> 1991. </year> <booktitle> (Proceedings of the ACM/ONR '91 Workshop on Parallel and Distributed Debugging). </booktitle>
Reference-contexts: The SHMAP [DBKF90] 3 tool provides views of memory access and utilization of parallel Fortan matrix algorithms. The system's designers note that a better understanding of processor memory usage can help to improve program performance and promote experimentation with alternate usage strategies. ChaosMON <ref> [KS91] </ref> uses a program execution summary database and view specification "mini-languages" to allow viewers to rapidly specify the aspects of a program's performance of primary interest. <p> The choreographer must "parse" program execution information and store it in a convenient form for later usage. Various strategies for the form's implementation range from databases <ref> [HC87, Sar90, KS91] </ref>, to directed acyclic graphs [LMCF90], to program activity graphs [M + 90], to hierarchical structures [DBKF90]. We are examining all these approaches and determining if one is most useful for storing the information necessary to generate the highly application-semantic algorithm animations we display.
Reference: [L + 89] <author> Ted Lehr et al. </author> <title> Visualizing performance debugging. </title> <journal> Computer, </journal> <volume> 22(10) </volume> <pages> 38-51, </pages> <month> October </month> <year> 1989. </year>
Reference: [Lam78] <author> Leslie Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: Possibly, we will need to develop a new representation. The notion of reproducing event sequences is recognized as an important tool for parallel debugging. Systems such as Instant Replay [LMC87] can recreate events within partial orderings according to the logical time <ref> [Lam78] </ref>. Others such as Bugnet [Wit89], designed for monitoring distributed systems, use periodic sampling methods to help reproduce the real-time ordering of processor events. Helmbold, McDowell, and Wang [HMW90] have created an interactive tool for analyzing trace information in parallel Fortran programs.
Reference: [LD85] <author> Ralph L. London and Robert A. Duisberg. </author> <title> Animating programs using Smalltalk. </title> <journal> Computer, </journal> <volume> 18(8) </volume> <pages> 61-71, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: They utilize sophisticated screen layout algorithms to show program data while a user traces a program in a debugger. These tools provide little in the way of application domain specific information, so they are not sufficient for our purposes. Algorithm animation systems <ref> [Bro88b, Bro88a, LD85, Dui86, Dui87, HHR89] </ref>, conversely, present dynamic graphical views of programmer-defined abstractions of the important data, operations, goals, and actions in programs. We shall adapt techniques developed in these serial algorithm animation systems in order to aid parallel program visualization and debugging.
Reference: [LMC87] <author> Thomas J. LeBlanc and John M. Mellor-Crummey. </author> <title> Debugging parallel programs with Instant Replay. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(4):471-482, </volume> <month> April </month> <year> 1987. </year>
Reference-contexts: Data gathered consist of an event log, either input directly to the animation program or saved in a file for posthumous animation <ref> [BW83, LMC87] </ref>. Each event is usually times-tamped with the system clock time at which the event occurred, event parameters, and a task-id. In our model two types of program events are required: task events and display events. <p> Possibly, we will need to develop a new representation. The notion of reproducing event sequences is recognized as an important tool for parallel debugging. Systems such as Instant Replay <ref> [LMC87] </ref> can recreate events within partial orderings according to the logical time [Lam78]. Others such as Bugnet [Wit89], designed for monitoring distributed systems, use periodic sampling methods to help reproduce the real-time ordering of processor events.
Reference: [LMCF90] <author> Thomas J. LeBlanc, John M. Mellor-Crummey, and Robert J. Fowler. </author> <title> Analyzing parallel program execution using multiple views. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 9(2) </volume> <pages> 203-217, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Our system differs in that we seek to provide further support for the program-to-animation mapping, and to allow simplified direct manipulation creation of multiple program views with more continuous, smooth imagery changes. LeBlanc, Mellor-Crummey, and Fowler <ref> [LMCF90] </ref> have created an impressive system for gathering and visualizing execution information from parallel programs. Their approach provides a multiplicity of different program views, each chosen to best illustrate a particular aspect of the execution for debugging aid, together with a programmable interface based upon Common Lisp. <p> The choreographer must "parse" program execution information and store it in a convenient form for later usage. Various strategies for the form's implementation range from databases [HC87, Sar90, KS91], to directed acyclic graphs <ref> [LMCF90] </ref>, to program activity graphs [M + 90], to hierarchical structures [DBKF90]. We are examining all these approaches and determining if one is most useful for storing the information necessary to generate the highly application-semantic algorithm animations we display. Possibly, we will need to develop a new representation.
Reference: [LR85] <author> Richard J. LeBlanc and Arnold D. Robbins. </author> <title> Event-driven monitoring of distributed programs. </title> <booktitle> In Proceedings of the Fifth International Conference on Distributed Computing Systems, </booktitle> <pages> pages 515-522, </pages> <month> May </month> <year> 1985. </year>
Reference: [M + 90] <author> Bart Miller et al. IPS-2: </author> <title> The second generation of a parallel program measurement system. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(2) </volume> <pages> 206-217, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: The choreographer must "parse" program execution information and store it in a convenient form for later usage. Various strategies for the form's implementation range from databases [HC87, Sar90, KS91], to directed acyclic graphs [LMCF90], to program activity graphs <ref> [M + 90] </ref>, to hierarchical structures [DBKF90]. We are examining all these approaches and determining if one is most useful for storing the information necessary to generate the highly application-semantic algorithm animations we display. Possibly, we will need to develop a new representation.
Reference: [McD89] <author> Charles E. McDowell. </author> <title> A practical algorithm for static analysis of parallel programs. </title> <journal> Journal of Parallel and Distribted Computing, </journal> <month> July </month> <year> 1989. </year>
Reference: [MH89] <author> Charles E. McDowell and David P. Helmbold. </author> <title> Debugging concurrent programs. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(4) </volume> <pages> 593-622, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Our general framework, rather than the view library approach, will promote this type of flexibility. McDowell and Helmbold have characterized these two different parallel visualization domains as "time-process" displays and animations of programs and data, respectively <ref> [MH89] </ref>. They argue that both are needed in an ideal debugger for a concurrent system. Our focus is on the latter; it has received relatively little study to date.
Reference: [Moh88] <author> Thomas G. Moher. </author> <title> PROVIDE: A process visualization and debugging environment. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(6) </volume> <pages> 849-857, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: The vast majority of research on graphical display of programs has been for serial programming. These program visualization systems [Mye90] can be divided into two broad categories: data structure display and algorithm animation systems. Data structure display systems <ref> [Mye83, Bas85, ISO87, Moh88, RMD89] </ref> provide automatic, canonical views of a program's data structures. They utilize sophisticated screen layout algorithms to show program data while a user traces a program in a debugger.
Reference: [MR88] <author> Allen D. Malony and Daniel A. Reed. </author> <title> Visualizing parallel computer system performance. </title> <type> Technical Report UIUCDCS-R-88-1465, </type> <institution> Univ. of Illinois, Urbana, IL, </institution> <month> September </month> <year> 1988. </year> <month> 20 </month>
Reference-contexts: For the most part, these systems have focused on displaying views of the architecture, processor structure, parallel computation model, task structure, and processor state, in essence, the "machinery" of the parallel computation, making them performance monitors as in class 2 above. Malony, Reed, and others <ref> [MR88, MRA + 89] </ref> have created a number of flexible X-Windows based performance monitoring widgets. Histograms, dials, gauges, and Kiviat diagrams reflect message traffic and processor actions. Similarly, Heath [Hea89] provides nine different performance views, including Feynman diagrams and Gantt charts among others, of programs running on message-passing multiprocessor architectures.
Reference: [MRA + 89] <author> Allen D. Malony, Daniel A. Reed, James W. Arendt, Ruth A. Aydt, Dominique Grabas, and Brian K. Totty. </author> <title> An integrated performance data collection, analysis and visualization system. </title> <booktitle> In Proceedings of the Fourth Conference on Hypercube Concurrent Computers and Applications, </booktitle> <address> Monterey, CA, </address> <month> March </month> <year> 1989. </year>
Reference-contexts: For the most part, these systems have focused on displaying views of the architecture, processor structure, parallel computation model, task structure, and processor state, in essence, the "machinery" of the parallel computation, making them performance monitors as in class 2 above. Malony, Reed, and others <ref> [MR88, MRA + 89] </ref> have created a number of flexible X-Windows based performance monitoring widgets. Histograms, dials, gauges, and Kiviat diagrams reflect message traffic and processor actions. Similarly, Heath [Hea89] provides nine different performance views, including Feynman diagrams and Gantt charts among others, of programs running on message-passing multiprocessor architectures. <p> It will support direct manipulation of the task and display event-to-animation event mapping, e.g., using sliders to modify execution speed, etc. A good example of this is in the HyperView system <ref> [MRA + 89] </ref>, primarily used for displaying hardware performance of programs on a 10 Hypercube. Frames can be single-stepped or run through quickly, and they are controlled by buttons and sliders.
Reference: [Mye83] <author> Brad A. Myers. </author> <title> A system for displaying data structures. </title> <journal> Computer Graphics: </journal> <volume> SIGGRAPH '83, 17(3) </volume> <pages> 115-125, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: The vast majority of research on graphical display of programs has been for serial programming. These program visualization systems [Mye90] can be divided into two broad categories: data structure display and algorithm animation systems. Data structure display systems <ref> [Mye83, Bas85, ISO87, Moh88, RMD89] </ref> provide automatic, canonical views of a program's data structures. They utilize sophisticated screen layout algorithms to show program data while a user traces a program in a debugger.
Reference: [Mye90] <author> Brad A. Myers. </author> <title> Taxonomies of visual programming and program visualization. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 1(1) </volume> <pages> 97-123, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: An imperative animation specification is more desirable for animation-showing path motions and controlling relative transition speeds. The vast majority of research on graphical display of programs has been for serial programming. These program visualization systems <ref> [Mye90] </ref> can be divided into two broad categories: data structure display and algorithm animation systems. Data structure display systems [Mye83, Bas85, ISO87, Moh88, RMD89] provide automatic, canonical views of a program's data structures.
Reference: [NE88] <author> Kathleen M. Nichols and John T. Edmark. </author> <title> Modeling multicomputer systems with PARET. </title> <journal> Computer, </journal> <volume> 21(5) </volume> <pages> 39-48, </pages> <month> May </month> <year> 1988. </year>
Reference: [PU89] <author> Cherri M. Pancake and Sue Utter. </author> <title> Models for visualization in parallel debuggers. </title> <booktitle> In Proceedings of Supercomputing '89, </booktitle> <pages> pages 627-636, </pages> <address> Reno, NV, </address> <month> November </month> <year> 1989. </year>
Reference-contexts: By contrast, algorithm animation is relatively simple to instrument, yet offers critical insight into parallel algorithm behavior. 2.1 Related Work Recently, several systems for debugging parallel or distributed programs via some form of graphical aid have been developed (survey in <ref> [PU89] </ref>). For the most part, these systems have focused on displaying views of the architecture, processor structure, parallel computation model, task structure, and processor state, in essence, the "machinery" of the parallel computation, making them performance monitors as in class 2 above.
Reference: [RC89] <author> Gruia-Catalin Roman and Kenneth C. Cox. </author> <title> A declarative approach to visualizing concurrent computations. </title> <journal> Computer, </journal> <volume> 22(10) </volume> <pages> 25-36, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: Our work also seeks to identify the elements necessary to produce these visualizations and which are common across a variety of parallel and distributed programming models. Quite a different approach to visualizing parallel programs is taken by Roman and Cox <ref> [RC89] </ref> who utilize a declarative, rather than imperative, approach to the problem. To 4 create a visualization of a program, they define two parts: an abstraction function that maps program states to to objects, and a rendering function that maps objects to images.
Reference: [RMD89] <author> Steven P. Reiss, Scott Meyers, and Carolyn Duby. </author> <title> Using GELO to visualize software systems. </title> <booktitle> In Proceedings of the ACM '89 SIGGRAPH Symposium on User Interface Software and Technology, </booktitle> <pages> pages 149-157, </pages> <address> Williamsburg, VA, </address> <month> November </month> <year> 1989. </year>
Reference-contexts: The vast majority of research on graphical display of programs has been for serial programming. These program visualization systems [Mye90] can be divided into two broad categories: data structure display and algorithm animation systems. Data structure display systems <ref> [Mye83, Bas85, ISO87, Moh88, RMD89] </ref> provide automatic, canonical views of a program's data structures. They utilize sophisticated screen layout algorithms to show program data while a user traces a program in a debugger.
Reference: [ROA + 91] <author> Daniel A. Reed, Robert D. Olson, Ruth A. Aydt, Tara M. Madhyastha, Thomas Birkett, David W. Jensen, Bobby A. A. Nazief, and Brian K. Totty. </author> <title> Scalable performance environments for parallel systems. </title> <booktitle> In Proceedings of the Sixth Distributed Memory Computing Conference, </booktitle> <pages> pages 562-569, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: Snooping is less intrusive [AG89], but more complex to implement and unnecessary for posthumous animation. It is exceptionally difficult to acquire display events via snooping also [Bro88c]. Hence, we use event tracing for the implementation of our system, focusing on a flexible self-documenting trace format such as described in <ref> [ROA + 91] </ref>. To understand display events better, let us examine their role in sequential algorithm animations. There, display events are usually "important" events of special semantic significance to the program being animated. For example, a sorting program might contain input value, compare values, and exchange values events.
Reference: [RRZ89] <author> Robert V. Rubin, Larry Rudolph, and Dror Zernik. </author> <title> Debugging parallel programs in parallel. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(1) </volume> <pages> 216-225, </pages> <month> January </month> <year> 1989. </year> <booktitle> (Proceedings of the Workshop on Parallel and Distributed Debugging, </booktitle> <address> Madison, WI, </address> <month> May </month> <year> 1988). </year>
Reference: [SA89] <author> Kevin Smith and Bill Appelbe. </author> <title> Interactive conversion of sequential to multitasking FORTRAN. </title> <booktitle> In Proceedings of the 1989 International Conference on Supercomputing, </booktitle> <pages> pages 225-234, </pages> <address> Crete, Greece, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: PAT locates loops that can be parallelized and under user control performs source code transformations to remove dependences such as replication, alignment, peeling iterations, inserting LOCKs and EVENTs. PAT has been distributed to over 20 sites and has been used to parallelize a wide range of production Fortran programs <ref> [SA89] </ref>. Recently PAT has been recoded in C++, and the source code analysis and program data structures "unbundled"[ASS91b] so that they can be used by tools other than PAT. These analysis modules, referred to as IOS, can be incorporated into our proposed system.
Reference: [Sar90] <author> Sekhar R. Sarukkai. </author> <title> Performance visualization and prediction of parallel supercomputer programs: An interim report. </title> <type> Technical Report 318, </type> <institution> Indiana University, Bloomington, IN, </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: In their system, program execution is captured in a synchronization trace, and later converted into a graph representation. A user manipulates the graph representation to create and modify the different program views. These views fall into three main categories: process interactions, process states, and time. Sarukkai <ref> [Sar90] </ref> also is developing a system with an emphasis on many flexible views, ranging from low-level process monitors to high-level data structure animations. His system creates a relational database of program execution information, and allows users to pose post-mortem queries against the database. <p> The choreographer must "parse" program execution information and store it in a convenient form for later usage. Various strategies for the form's implementation range from databases <ref> [HC87, Sar90, KS91] </ref>, to directed acyclic graphs [LMCF90], to program activity graphs [M + 90], to hierarchical structures [DBKF90]. We are examining all these approaches and determining if one is most useful for storing the information necessary to generate the highly application-semantic algorithm animations we display.
Reference: [SAS90] <author> Kevin Smith, Bill Appelbe, and Kurt Stirewalt. </author> <title> Incremental dependence analysis for interactive parallelization. </title> <booktitle> In Proceedings of the 1990 International Conference on Supercomputing, </booktitle> <pages> pages 330-341, </pages> <address> Amsterdam, Netherlands, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: We will adopt a simple prototype, in which the event log is generated by user-inserted calls for display events, and a modified library for generating task events. Later we intend to use our existing tools, PAT <ref> [ASM89, SAS90, ASS91a] </ref> and IOS [ASS91b], to help automate the insertion of code to generate display events. PAT is an interactive parallelizer for Fortran, developed by one of the authors at Georgia Tech over the past four years.
Reference: [SBN89] <author> David Socha, Mary L. Bailey, and David Notkin. Voyeur: </author> <title> Graphical views of parallel programs. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(1) </volume> <pages> 206-215, </pages> <month> January </month> <year> 1989. </year> <booktitle> (Proceedings of the Workshop on Parallel and Distributed Debugging, </booktitle> <address> Madison, WI, </address> <month> May </month> <year> 1988). </year> <month> 21 </month>
Reference-contexts: Our focus is on the latter; it has received relatively little study to date. An existing system near to our work is Voyeur, which supports application-specific parallel program animation views primarily as an aid for debugging <ref> [SBN89] </ref>. Voyeur strives to simplify the creation of such types of views by programmers. The system separates the data gathering process from the animation display process. It provides a variety of program views ranging from text views of specific variables to more abstract graphical presentations of the program's state.
Reference: [Shu88] <author> Nancy C. Shu. </author> <title> Visual Programming. </title> <publisher> Van Nostrand Reinhold, </publisher> <address> New York, NY, </address> <year> 1988. </year>
Reference-contexts: Hence, the tool should preserve objects throughout an entire animation design. Also, the tool should allow for features such as abstraction, indexing, and iteration in a more consistent manner. Fundamentally, the tool must become more of a visual programming system <ref> [Cha87, Shu88] </ref>.
Reference: [SJ90] <author> William J. Selig and James D. Johannes. </author> <title> Reasoning visualization in expert systems: The applicability of algorithm animation techniques. </title> <booktitle> In Proceedings of the Third International Conference on Industrial and Engineering Applications of Artifical Intelligence and expert Systems, </booktitle> <address> Charleston, SC, </address> <month> July </month> <year> 1990. </year>
Reference-contexts: A variety of projects such as the Tango algorithm animation system [Sta90c], a system for context-sensitive animated help in user interfaces [Suk90], and a visualization system for examining the reasoning process of an expert system <ref> [SJ90] </ref> have already been developed using ideas from the path-transition paradigm.
Reference: [Sta90a] <author> John T. Stasko. </author> <title> The Path-Transition Paradigm: A practical methodology for adding animation to program interfaces. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 1(3) </volume> <pages> 213-236, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: We shall adapt techniques developed in these serial algorithm animation systems in order to aid parallel program visualization and debugging. In particular, we shall utilize a improved modification of the path-transition paradigm <ref> [Sta90a, Sta90b] </ref>. The paradigm supports a building-block style of color imagery (lines, circles, rectangles, text, etc.) along with smooth, visually pleasing animations such as changes in position, size, color, visibility, fill style, and so on. <p> To achieve these goals, we are utilizing a derivative of the path-transition animation paradigm <ref> [Sta90a, Sta90b] </ref>.
Reference: [Sta90b] <author> John T. Stasko. </author> <title> A practical animation language for software development. </title> <booktitle> In Proceedings of the 1990 IEEE International Conference on Computer Languages, </booktitle> <pages> pages 1-10, </pages> <address> New Orleans, LA, </address> <month> March </month> <year> 1990. </year>
Reference-contexts: We shall adapt techniques developed in these serial algorithm animation systems in order to aid parallel program visualization and debugging. In particular, we shall utilize a improved modification of the path-transition paradigm <ref> [Sta90a, Sta90b] </ref>. The paradigm supports a building-block style of color imagery (lines, circles, rectangles, text, etc.) along with smooth, visually pleasing animations such as changes in position, size, color, visibility, fill style, and so on. <p> To achieve these goals, we are utilizing a derivative of the path-transition animation paradigm <ref> [Sta90a, Sta90b] </ref>.
Reference: [Sta90c] <author> John T. Stasko. </author> <title> TANGO: A framework and system for algorithm animation. </title> <journal> Computer, </journal> <volume> 23(9) </volume> <pages> 27-39, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: This method is appropriate for our goals because it stresses ease of design and use by programmers, as well as clearly defined, rigorous semantics. A variety of projects such as the Tango algorithm animation system <ref> [Sta90c] </ref>, a system for context-sensitive animated help in user interfaces [Suk90], and a visualization system for examining the reasoning process of an expert system [SJ90] have already been developed using ideas from the path-transition paradigm.
Reference: [Sta91] <author> John T. Stasko. </author> <title> Using direct manipulation to build algorithm animations by demonstration. </title> <booktitle> In Proceedings of the ACM SIGCHI '91 Conference on Human Factors in Computing Systems, </booktitle> <pages> pages 307-314, </pages> <address> New Orleans, LA, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: The code should be directly compilable and loadable without further interaction. The intermediate code representation is advantageous, however, if a designer does wish to "tweak" the animation view. To implement the direct manipulation design tool, we shall use our earlier experiences with the Dance graphical editor <ref> [Sta91] </ref> for the Tango system as a foundation. Figure 2 includes a window dump of the Dance editor being used to develop an animation. In Dance, each abstract data type has a convenient graphical depiction as well as a "pickable" label denoting its variable name.
Reference: [Sto89] <author> Janice M. Stone. </author> <title> A graphical representation of concurrent processes. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(1) </volume> <pages> 226-235, </pages> <month> January </month> <year> 1989. </year> <booktitle> (Proceedings of the Workshop on Parallel and Distributed Debugging, </booktitle> <address> Madison, WI, </address> <month> May </month> <year> 1988). </year>
Reference: [Suk90] <author> Piyawadee Sukaviriya. </author> <title> Coupling a UI framework with automatic generation of context-sensitive animated help. </title> <booktitle> In Proceedings of the '90 ACM SIGGRAPH Symposium on User Interface Software and Technology, </booktitle> <pages> pages 152-166, </pages> <address> Snow-bird, Utah, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: This method is appropriate for our goals because it stresses ease of design and use by programmers, as well as clearly defined, rigorous semantics. A variety of projects such as the Tango algorithm animation system [Sta90c], a system for context-sensitive animated help in user interfaces <ref> [Suk90] </ref>, and a visualization system for examining the reasoning process of an expert system [SJ90] have already been developed using ideas from the path-transition paradigm.
Reference: [Wit89] <author> Larry D. Wittie. </author> <title> Debugging distributed C programs by real time replay. </title> <journal> SIG-PLAN Notices, </journal> <volume> 24(1) </volume> <pages> 57-67, </pages> <month> January </month> <year> 1989. </year> <booktitle> (Proceedings of the Workshop on Parallel and Distributed Debugging, </booktitle> <address> Madison, WI, </address> <month> May </month> <year> 1988). </year>
Reference-contexts: Possibly, we will need to develop a new representation. The notion of reproducing event sequences is recognized as an important tool for parallel debugging. Systems such as Instant Replay [LMC87] can recreate events within partial orderings according to the logical time [Lam78]. Others such as Bugnet <ref> [Wit89] </ref>, designed for monitoring distributed systems, use periodic sampling methods to help reproduce the real-time ordering of processor events. Helmbold, McDowell, and Wang [HMW90] have created an interactive tool for analyzing trace information in parallel Fortran programs. The system can determine race conditions and temporal orderings of task events.
Reference: [ZPS89] <author> M. Zimmerman, F. Perrenoud, and A. Schiper. </author> <title> Graphical animation of concurrent programs. </title> <booktitle> In Proceedings of the ACM/SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 342-344, </pages> <month> May </month> <year> 1989. </year> <month> 22 </month>
References-found: 65

