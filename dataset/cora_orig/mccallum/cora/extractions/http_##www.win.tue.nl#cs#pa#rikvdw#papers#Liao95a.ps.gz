URL: http://www.win.tue.nl/cs/pa/rikvdw/papers/Liao95a.ps.gz
Refering-URL: http://www.win.tue.nl/cs/pa/rikvdw/bibl.html
Root-URL: http://www.win.tue.nl
Title: Storage Assignment to Decrease Code Size  
Author: Stan Liao Srinivas Devadas Kurt Keutzer Steve Tjiang Albert Wang 
Address: Cambridge, MA 02139-4307 Mountain View, CA 94043-4033  
Affiliation: MIT Department of EECS Synopsys, Inc.  
Abstract: In this paper we present a formulation of the problem of optimal storage assignment such that explicit instructions for address arithmetic are minimized. We prove that for the case of a single address register the decision problem is NP-complete. We then generalize the problem to multiple address registers. For both cases heuristic algorithms are given. Our experimental results indicate an improvement of 3% to 20% in code size. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aho, J. Hopcroft, and J. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference-contexts: We will need to develop efficient heuristic algorithms to solve SOA and MWPC for large problems. For small problems, a branch-and-bound procedure is feasible. 3.6 A Heuristic Algorithm for SOA We describe a heuristic algorithm for SOA/MWPC that is similar to Kruskal's maximum spanning tree algorithm <ref> [1] </ref>. The algorithm is greedy in that at each step the edge with the largest weight is selected that does not yield a cycle and does not increase the degree of a node to more than two. The heuristic algorithm is shown in Figure 6.
Reference: [2] <author> A. Aho, R. Sethi, and J. Ullman. </author> <booktitle> Compilers Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: While optimizing compilers have proved effective for general purpose processors, the irregular datapaths and small number of registers found in embedded processors, especially fixed-point DSPs, remain a challenge to compilers. The direct application of conventional code optimization methods (e.g., <ref> [2] </ref>) has, so far, been unable to generate code that efficiently uses the features of fixed-point DSP microprocessors.
Reference: [3] <author> G. Araujo, S. Devadas, K. Keutzer, S. Liao, S. Ma-lik, A. Sudarsanam, S. Tjiang, and A. Wang. </author> <title> Challenges in code generation for embedded processors. </title> <editor> In P. Marwedel and G. Goossens, editors, </editor> <title> Code Generation for Embedded Processors. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1995. </year> <note> In press. </note>
Reference-contexts: solutions for the path-covering problem, and in the presense of control-flow the access-graph model does not exactly reflect the real cost, which depends on the actual offset assignment. 6 Our Compiler Framework The optimization techniques described in this paper are incorporated into our framework for developing compilers for embedded systems <ref> [3] </ref>. A diagram showing the stages of the compiler is shown in Figure 9. We use SUIF [12] as our front-end. Machine-independent optimizations such as global common subex-pression elimination is carried out in SUIF.
Reference: [4] <author> John R. Ellis. </author> <title> A Compiler for VLIW Architectures. </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: Previous work <ref> [4, 5, 7, 11] </ref> on VLIW machines, microcode generation and application-specific instruction processors has covered the topic of irregular data paths but restricted addressing and code density has never been their primary concern.
Reference: [5] <author> J. A. Fisher. </author> <title> Trace Scheduling: A Technique for Global Microcode Compaction. </title> <journal> IEEE Trnsactions on Computers, </journal> <volume> C-30(7):478-490, </volume> <year> 1981. </year>
Reference-contexts: Previous work <ref> [4, 5, 7, 11] </ref> on VLIW machines, microcode generation and application-specific instruction processors has covered the topic of irregular data paths but restricted addressing and code density has never been their primary concern.
Reference: [6] <author> J. G. Ganssle. </author> <title> The Art of Programming Embedded Systems. </title> <address> San Diego, CA: </address> <publisher> Academic Press, Inc., </publisher> <year> 1992. </year>
Reference-contexts: Moreover, designers often devote a significant amount of time to reduce code size so that the code will fit into available ROM; as exceeding on-chip ROM size could require expensive redesign of the entire IC <ref> [6, p. 18] </ref> and even of the whole system. The second trend increasing software and system complexitymandates the use of high-level languages (HLLs) in order to decrease development costs and time-to-market.
Reference: [7] <author> G. Goossens, J. Rabaey, F. Catthoor, J Vanhoof, R. Jain, H. De Man, and J. Vandewalle. </author> <title> A Computer-Aided Design Methodology for Mapping DSP Algorithms onto Custom Multiprocessor Architectures. </title> <booktitle> In Proceedings of IEEE International Symposium on Circuits and Systems, </booktitle> <pages> pages 924-925, </pages> <month> May </month> <year> 1986. </year>
Reference-contexts: Previous work <ref> [4, 5, 7, 11] </ref> on VLIW machines, microcode generation and application-specific instruction processors has covered the topic of irregular data paths but restricted addressing and code density has never been their primary concern.
Reference: [8] <author> S. Liao, S. Devadas, and K. Keutzer. </author> <title> Code Density Optimization for Embedded DSP Processors Using Data Compression Techniques. </title> <booktitle> In Proceedings of the Chapel Hill Conference on Advanced Research in VLSI, </booktitle> <month> March </month> <year> 1995. </year>
Reference-contexts: Scheduling and register allocation are problems we are bedded systems 193 currently investigating and will be implemented in the near future.) Object code is then finally obtained through the final phase of code generation and peephole optimization. Code compression on object code <ref> [8] </ref> proves to be effective in further increasing the code density. 7 Extensions 7.1 Offset Assignment for a Procedure The access graph model for offset assignment gives exact results for basic blocks. However, in the presence of control-flow, modeling the exact cost of offset assignment is more difficult.
Reference: [9] <author> S. Liao, S. Devadas, K. Keutzer, S. Tjiang, and A. Wang. </author> <title> Code Optimization Techniques for Embedded DSP Microprocessors. </title> <booktitle> In Proceedings of the 32nd Design Automation Conference, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: The SUIF intermediate form is then translated into another intermediate form called TWIF, which is parametrized according to the machine description. It is on this intermediate form that instruction scheduling, offset assignment, and register allocation are performed <ref> [9] </ref>, along with machine-specific dataflow analyses and related optimizations. (At the time of this writing we have only implemented the offset assignment procedure and the final code generation pass. <p> There are many avenues for further work in offset assignment as indicated in Section 7. We are also addressing several other code optimization problems that arise in irregular datapaths <ref> [9] </ref>. Conventional register allocation is not possible for some DSP processors since the number of general-purpose registers available could be very small. Minimizing the number of accumulator spills becomes a relevant optimization problem.
Reference: [10] <author> C. Liem, T. May, and P. Paulin. </author> <title> Instruction-Set Matching and Selection for DSP and ASIP Code Generation. </title> <booktitle> In Proceedings of European Design and Test Conference, </booktitle> <month> March </month> <year> 1994. </year>
Reference-contexts: Previous work [4, 5, 7, 11] on VLIW machines, microcode generation and application-specific instruction processors has covered the topic of irregular data paths but restricted addressing and code density has never been their primary concern. Liem et al. <ref> [10] </ref> presented techniques for generating compact code; however, the benchmark programs were quite small and it is not shown how their techniques perform on larger, more realistic programs. With the increasing use of embedded systems, code generation for them has become very important.
Reference: [11] <author> K. Rimey. </author> <title> A Compiler for Application-Specific signal Processors. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, </institution> <year> 1989. </year>
Reference-contexts: Previous work <ref> [4, 5, 7, 11] </ref> on VLIW machines, microcode generation and application-specific instruction processors has covered the topic of irregular data paths but restricted addressing and code density has never been their primary concern.
Reference: [12] <author> R. Wilson, R. French, C. Wilson, S. Amarasinghe, J. Anderson, S. Tjiang, S.-W. Liao, C.-W. Tseng, M. Hall, M. Lam, and J. Hennessy. </author> <title> SUIF: A Par-allelizing and Optimizing Research Compiler. </title> <type> Technical Report CSL-TR-94-620, </type> <institution> Stanford University, </institution> <month> May </month> <year> 1994. </year> <month> 195 </month>
Reference-contexts: A diagram showing the stages of the compiler is shown in Figure 9. We use SUIF <ref> [12] </ref> as our front-end. Machine-independent optimizations such as global common subex-pression elimination is carried out in SUIF. The SUIF intermediate form is then translated into another intermediate form called TWIF, which is parametrized according to the machine description.
References-found: 12

