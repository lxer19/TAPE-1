URL: http://www.cs.iastate.edu/tech-reports/TR96-17.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: BeCecil, A Core Object-Oriented Language with Block Structure and Multimethods: Semantics and Typing  
Author: Craig Chambers and Gary T. Leavens Craig Chambers and Gary T. Leavens, . 
Keyword: Multimethods, generic functions, object-oriented programming languages, encapsulation, information hiding, static typechecking, block structure, subtyping, inheritance, BeCecil language.  
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Note: Copyright  
Date: December 1996  
Pubnum: TR #96-17  
Abstract: This report, minus the appendices, will appear in the proceedings of the The Fourth International Workshop on Foundations of Object-Oriented Languages FOOL 4, Paris, France. The full report also appears as a technical report from the department of Computer Science and Engineering, University of Washington, Seattle, WA, numbered UW-CSE-96-12-02. 1994 CR Categories: D.3.1 [Programming Languages] Formal Definitions and Theory semantics; D.3.2 [Programming Languages] Language Classifications object-oriented languages; D.3.3 [Programming Languages] Language Constructs and Features abstract data types, control structures, procedures, functions, and subroutines; D.3.m [Programming Languages] Miscellaneous multimethods, generic functions, type systems; F.3.2 [Logics and Meanings of Programs] Semantics of Programming Languages operational semantics; F.3.3 [Logics and Meanings of Programs] Studies of Program Constructs control primitives, type structure. 
Abstract-found: 1
Intro-found: 1
Reference: [Abadi & Cardelli 95] <author> Martn Abadi and Luca Cardelli. </author> <title> An imperative object calculus. </title> <journal> Theory and Practice of Object Systems, </journal> <volume> 1(3) </volume> <pages> 151-166, </pages> <year> 1995. </year>
Reference-contexts: These sugars also give one some idea of the expressive power of BeCecil, and can be used to compare BeCecil to other core OO languages, such as the Abadi and Cardelli calculus <ref> [Abadi & Cardelli 95] </ref> or Castagnas l_object [Castagna 95b]. <p> Using this, it is even possible to regard sequence expressions as a syntactic sugar <ref> [Abadi & Cardelli 95] </ref>. However, because these are not local sugars (they do not operate on expressions in place), we have chosen to include sequence expressions directly in the syntax of BeCecil. <p> In both languages generic functions are not integrated with objects as they are in BeCecil. Both of these languages are also dynamically typed. 4.7 Abadi and Cardellis Imperative Object Calculus Abadi and Cardelli have defined an imperative object calculus, Imp <ref> [Abadi & Cardelli 95] </ref> [Abadi & Cardelli 96, chapters 10 and 11], that consists of objects, single-dispatch methods (as in Smalltalk [Goldberg & Robson 83] or Self [Ungar & Smith 87]), method update, object cloning, and local definitions [Abadi & Cardelli 95, page 1]. <p> Object Calculus Abadi and Cardelli have defined an imperative object calculus, Imp [Abadi & Cardelli 95] [Abadi & Cardelli 96, chapters 10 and 11], that consists of objects, single-dispatch methods (as in Smalltalk [Goldberg & Robson 83] or Self [Ungar & Smith 87]), method update, object cloning, and local definitions <ref> [Abadi & Cardelli 95, page 1] </ref>. They view method update as a tamed version of dynamic inheritance. See Section B.10 for why we use storage tables instead of method update in BeCecil.
Reference: [Abadi & Cardelli 96] <author> Martn Abadi and Luca Cardelli. </author> <title> A Theory of Objects. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1996. </year>
Reference-contexts: In both languages generic functions are not integrated with objects as they are in BeCecil. Both of these languages are also dynamically typed. 4.7 Abadi and Cardellis Imperative Object Calculus Abadi and Cardelli have defined an imperative object calculus, Imp [Abadi & Cardelli 95] <ref> [Abadi & Cardelli 96, chapters 10 and 11] </ref>, that consists of objects, single-dispatch methods (as in Smalltalk [Goldberg & Robson 83] or Self [Ungar & Smith 87]), method update, object cloning, and local definitions [Abadi & Cardelli 95, page 1].
Reference: [Ada 83] <author> American National Standards Institute. </author> <title> Reference Manual for the Ada Programming Language. </title> <address> ANSI/MIL-STD 1815A, </address> <month> February, </month> <year> 1983. </year>
Reference-contexts: Notice how the code, given below, resembles, say, a C++ class declaration, with a private part that comes before the public part. (Comments start with two hyphens, and continue to the end of that line, as in Ada <ref> [Ada 83] </ref> and Cecil. 8 BeCecil Chambers & Leavens We assume that declarations for generic functions intensity and paint, several generic functions to manipulate integers and oating point numbers, and a class Region_rep are given elsewhere.) object Grayscale_rep Grayscale_rep inherits Color_rep hide -- private declarations object scale scale inherits GenericFun_rep scale <p> The following are thus examples in singly-dispatched OO and procedural styles (respectively). single_oo_method has method (first@myClass, snd@any, thd@any) -...- proc_method has method (first@any, second@any, thd@any) -...- 21 BeCecil Chambers & Leavens As Cook points out [Cook 90], one characteristic of ADT languages, such as Ada 83 <ref> [Ada 83] </ref>, CLU [Liskov et al. 81], or Standard ML, is that they completely control the implementation of a particular type of object.
Reference: [Agrawal et al. 91] <author> Rakesh Agrawal, Linda G. DeMichiel, and Bruce G. Lindsay. </author> <title> Static Type Checking of Multi-Methods. </title> <editor> In Andreas Paepcke, editor, </editor> <booktitle> OOPSLA91 Conference Proceedings, </booktitle> <address> Phoenix, AZ, </address> <month> October, </month> <year> 1991, </year> <title> volume 26, </title> <journal> number 11 of ACM SIGPLAN Notices, </journal> <pages> pp. 113-128. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> November, </month> <year> 1991. </year>
Reference-contexts: example by declaring another method for f, such as the one below. f has method (y@foo:Bar): int - 4 - -- one way to fix the above example Another interesting aspect of the implementation-side checks is how they enforce a monotonicity [Reynolds 80], regularity [Goguen & Meseguer 87], or consistency <ref> [Agrawal et al. 91] </ref> condition on the types of the methods in a generic function. <p> BeCecil does not make a distinction between classes and instances. Since it is like the l&-calculus, l_object shares several other important differences from BeCecil. These include the distinction between two kinds of applications and the main points summarized above. 4.3 Polyglot Polyglot, a CLOS-like database type system <ref> [Agrawal et al. 91] </ref>, is the only other statically-typed language with multimethods and mutation of which we are aware.
Reference: [Birtwistle et al. 73] <author> Graham M. Birtwistle, Ole-Johan Dahl, Bjorn Myhrhaug, and Kristen Nygaard. </author> <title> SIMULA Begin. </title> <publisher> Auerbach Publishers, </publisher> <address> Philadelphia, Penn., </address> <year> 1973. </year>
Reference-contexts: However, C++ is designed to carefully avoid making static closures for methods. The main OO languages that allow the full use of block structure are Simula 67 <ref> [Birtwistle et al. 73] </ref> and Beta [Madsen et al. 93, Chapter 8]. In Beta there are fewer restrictions on the use of block structure than in Simula [Madsen et al. 93, page 139].
Reference: [Blascheck 94] <author> Gnther Blaschek. </author> <title> Object-Oriented Programming with Prototypes. </title> <publisher> Springer-Verlag, </publisher> <address> NY, </address> <year> 1994. </year>
Reference: [Bobrow, et al. 86] <author> Daniel G. Bobrow, Kenneth Kahn, George Kiczales, Larry Masinter, Mark Stefik, and Frank Zdybel. CommonLoops: </author> <title> Merging Lisp and Object-Oriented Programming. </title> <editor> In Norman Meyrowitz (editor), </editor> <booktitle> OOPSLA 86 Conference Proceedings, </booktitle> <address> Portland, Oregon, </address> <month> September </month> <year> 1986, </year> <title> volume 21, </title> <journal> number 11 of ACM SIGPLAN Notices, </journal> <pages> pp. 17-29. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> November, </month> <year> 1986. </year>
Reference: [Bruce et al. 95] <author> Kim Bruce, Luca Cardelli, Giuseppe Castagna, The Hopkins Object Group, Gary T. Leavens, and Benjamin Pierce. </author> <title> On Binary Methods. </title> <journal> Theory and Practice of Object Systems, </journal> <volume> 1(3) </volume> <pages> 221-242, </pages> <year> 1995. </year>
Reference-contexts: with only singly-dispatched methods, for the following reasons: dispatching on all arguments is more exible and symmetric than dispatching on only the first argument; multiple dispatching generalizes and unifies global procedures, singly-dispatched methods, and (statically) overloaded procedures; multiple dispatching resolves complications relating to co- versus contravariant redefinition and binary methods <ref> [Bruce et al. 95, Castagna 95] </ref>. Multimethods also lead to a style of language that permits objects to be extended at several points in a program. <p> The prevention of such imposters is discussed in Section 2.6 below. 9 BeCecil Chambers & Leavens 2.2.2 Multimethods and Inheritance of Methods Because BeCecil uses multiple-dispatch instead of single-dispatch, there is no trouble in programming binary methods <ref> [Bruce et al. 95] </ref> such as equal, as we have seen above. Moreover, the interaction of multimethods and inheritance is powerful, and avoids the need to write an exponential number of methods to deal with all the cases [Chambers 92, Castagna 95]. <p> These new mechanisms support new patterns that are not possible or feasible with single-dispatching. For example, multimethods solve part of the binary method problem <ref> [Bruce et al. 95] </ref> by giving efficient and direct access to multiple objects when processing a message.
Reference: [Cardelli 88] <author> Luca Cardelli. </author> <title> A Semantics of Multiple Inheritance. </title> <journal> Information and Computation, </journal> 76(2/3):138-164, February/March, 1988. An earlier version appeared in the 1984 Semantics of Data Types Symposium, LNCS <volume> 173, </volume> pp. <pages> 51-66, </pages> Springer-Verlag, 1984. 
Reference-contexts: To see how this is enforced, suppose that, for each i, S i is a subtype of T i . Then (T 1 ,...,T n )-&gt;T r is a subtype of (S 1 ,...,S n )-&gt;T r by the usual contravariant subtyping rule for function types <ref> [Cardelli 88] </ref>. Therefore, if an object conforms to (T 1 ,...,T n )-&gt;T r it must also conform to (S 1 ,...,S n )-&gt;T r .
Reference: [Castagna et al. 92] <author> Giuseppe Castagna, Giorgio Ghelli, and Giuseppe Longo. </author> <title> A Calculus for Overloaded Functions with Subtyping. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <address> San Francisco, </address> <month> June, </month> <year> 1992, </year> <pages> pp. 182-192, </pages> <booktitle> volume 5, number 1 of LISP Pointers. ACM, </booktitle> <address> New York, January-March, </address> <year> 1992. </year>
Reference-contexts: In concrete examples we freely use parentheses as well as separators such as commas between repeated phrases. 5 BeCecil Chambers & Leavens shared objects) that is, roughly, a superset of the l&-calculus <ref> [Ghelli 91, Castagna et al. 92, Castagna et al. 95] </ref>. 2.2 Brief Overview As a start towards understanding the semantics of BeCecil, we show how to program some standard OO mechanisms in BeCecil, and then describe how to program some other basic mechanisms. 2.2.1 How to Program Standard OO Mechanisms in <p> In the rest of this section we discuss the relation of BeCecil to other languages with multimethods, Abadi and Cardellis imperative object calculus, and to other OO languages with block structure. 4.1 The l&-Calculus With respect to work on multi-method semantics, the most closely-related work is the l&-calculus <ref> [Ghelli 91, Castagna et al. 92, Castagna et al. 95] </ref>. The l&-calculus is a statically-typed foundational calculus for multimethod languages, from which BeCecil draws several ideas. In some respects, the l&-calculus is simpler than BeCecil, while in other respects BeCecil is simpler.
Reference: [Castagna et al. 95] <author> G. Castagna, G. Ghelli, and G. Longo. </author> <title> A calculus for overloaded functions with subtyping. </title> <journal> Information and Computation, </journal> <volume> 117(2) </volume> <pages> 115-135. </pages> <publisher> Academic Press. </publisher> <month> February </month> <year> 1995. </year>
Reference-contexts: In concrete examples we freely use parentheses as well as separators such as commas between repeated phrases. 5 BeCecil Chambers & Leavens shared objects) that is, roughly, a superset of the l&-calculus <ref> [Ghelli 91, Castagna et al. 92, Castagna et al. 95] </ref>. 2.2 Brief Overview As a start towards understanding the semantics of BeCecil, we show how to program some standard OO mechanisms in BeCecil, and then describe how to program some other basic mechanisms. 2.2.1 How to Program Standard OO Mechanisms in <p> In the rest of this section we discuss the relation of BeCecil to other languages with multimethods, Abadi and Cardellis imperative object calculus, and to other OO languages with block structure. 4.1 The l&-Calculus With respect to work on multi-method semantics, the most closely-related work is the l&-calculus <ref> [Ghelli 91, Castagna et al. 92, Castagna et al. 95] </ref>. The l&-calculus is a statically-typed foundational calculus for multimethod languages, from which BeCecil draws several ideas. In some respects, the l&-calculus is simpler than BeCecil, while in other respects BeCecil is simpler.
Reference: [Castagna 95] <author> Giuseppe Castagna. </author> <title> Covariance and contravariance: conict without a cause. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(3) </volume> <pages> 431-447, </pages> <year> 1995. </year>
Reference-contexts: with only singly-dispatched methods, for the following reasons: dispatching on all arguments is more exible and symmetric than dispatching on only the first argument; multiple dispatching generalizes and unifies global procedures, singly-dispatched methods, and (statically) overloaded procedures; multiple dispatching resolves complications relating to co- versus contravariant redefinition and binary methods <ref> [Bruce et al. 95, Castagna 95] </ref>. Multimethods also lead to a style of language that permits objects to be extended at several points in a program. <p> Moreover, the interaction of multimethods and inheritance is powerful, and avoids the need to write an exponential number of methods to deal with all the cases <ref> [Chambers 92, Castagna 95] </ref>. To invoke an overridden method inherited from a superclass in BeCecil, one can use the directed form of actual arguments. In this form, one writes an expression followed by an at-sign (@), and a list of class names.
Reference: [Castagna 95b] <author> Giuseppe Castagna. </author> <title> A Meta-Language for Typed Object-Oriented Languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 151(2) </volume> <pages> 297-352. </pages> <publisher> Elsevier Science. </publisher> <month> November </month> <year> 1995. </year>
Reference-contexts: These sugars also give one some idea of the expressive power of BeCecil, and can be used to compare BeCecil to other core OO languages, such as the Abadi and Cardelli calculus [Abadi & Cardelli 95] or Castagnas l_object <ref> [Castagna 95b] </ref>. <p> BeCecil has encapsulation. BeCecil does not require that all objects and inheritance relationships be visible globally. 40 BeCecil Chambers & Leavens BeCecils dynamic semantics does not rely on its type system. BeCecil separates the concepts of types and classes, and subtypes and subclasses. 4.2 Castagnas l_object The language l_object <ref> [Castagna 95b] </ref> is a meta-language for reasoning about OO programs. In particular, l_object is used to describe the semantics of an (unnamed) toy OO language which is a mix of Objective-C and CLOS (page 2). <p> However, one can encode an Imp object as a generic function that has storage tables specialized on each label of the record, where labels are considered to be objects that do not inherit from each other <ref> [Castagna 95b, Section 4.3] </ref>. Each such storage table would contain a generic function that encodes the corresponding method. This translation could be formalized with the following sugars. (In the sugars, a and b are expressions, x is an identifier, and l is a label.
Reference: [Castagna 96] <author> Giuseppe Castagna. </author> <title> Integration of Parametric and ad hoc Second Order Polymorphism in a Calculus with Subtyping. </title> <journal> Formal Aspects of Computing, </journal> <volume> 8(3) </volume> <pages> 247-293, </pages> <year> 1996. </year>
Reference: [Castagna 96b] <author> Giuseppe Castagna. </author> <title> Instance variables specialization in object-oriented programming, </title> <note> 1996. Obtained from ftp://ftp.ens.fr/pub/dmi/users/castagna/attributes.ps.gz </note>
Reference-contexts: However, the semantics of the l&-calculus would have to change to allow for mutable storage. One way this could be done is shown in the l& := -calculus <ref> [Castagna 96b] </ref>. In this calculus there are locations, which have reference types (much as in ML). (The l& := - calculus also has conversion functions, which are used to create specializable locations; this permits the modeling of covariantly-specialized instance variables.
Reference: [Chambers 92] <author> Craig Chambers. </author> <title> Object-Oriented Multi-Methods in Cecil. </title> <editor> In O. Lehrmann-Madsen, editor, </editor> <booktitle> ECOOP 92 Conference Proceedings, </booktitle> <address> Utrecht, the Netherlands, June/July, </address> <year> 1992, </year> <booktitle> volume 615 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 33-56. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: 1 Introduction Object-oriented (OO) languages with multimethods <ref> [Bobrow et al. 86, Moon 86, Chambers 92] </ref> offer increased expressiveness over languages with only singly-dispatched methods, for the following reasons: dispatching on all arguments is more exible and symmetric than dispatching on only the first argument; multiple dispatching generalizes and unifies global procedures, singly-dispatched methods, and (statically) overloaded procedures; multiple <p> Thus the design of (statically typed) module systems that both allow interesting extensions (e.g., subclasses) and prevent encapsulation violations and clashes between independently-developed extensions remains an important problem [Cook 90]. We have been developing and experimenting with Cecil, an expressive and practical object-oriented language based on multimethods <ref> [Chambers 92, Chambers 95] </ref>. We have gained practical experience with programming in Cecil by writing an 80,000-line optimizing compiler, Vortex [Dean et al. 96]. We recently presented a static type system, efficient typechecking algorithm, and module system for Cecil [Chambers & Leavens 95]. <p> Moreover, the interaction of multimethods and inheritance is powerful, and avoids the need to write an exponential number of methods to deal with all the cases <ref> [Chambers 92, Castagna 95] </ref>. To invoke an overridden method inherited from a superclass in BeCecil, one can use the directed form of actual arguments. In this form, one writes an expression followed by an at-sign (@), and a list of class names. <p> - fun barnum (): void - type CircusElephant subtypes Elephant, CircusPerf object floppy inherits Elephant_rep, CircusPerf_rep floppy conforms CircusElephant object wagon inherits any conforms Top haul (floppy, wagon, space_for_act (floppy)) - barnum () 38 BeCecil Chambers & Leavens 4 Related Work BeCecil bears a great deal of similarity to Cecil <ref> [Chambers 92, Chambers 95] </ref>. However, there are several differences from Cecil that are worth pointing out. The major differences in the dynamic semantics are the presence, in BeCecil, of the hide declaration and block structure. A more minor difference is the first-class nature of generic functions in BeCecil.
Reference: [Chambers 93] <author> Craig Chambers. </author> <title> Predicate Classes. </title> <booktitle> In ECOOP 93 Conference Proceedings, </booktitle> <address> Kaiserslautern, Germany, </address> <month> July, </month> <year> 1993, </year> <booktitle> volume 707 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 268-296. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: A proof that our type system is sound with respect to the dynamic semantics is also current work. Although BeCecil is intended to be a core subset of Cecil, it does not model all of Cecil directly. In particular it does not model non-local returns, predicate classes <ref> [Chambers 93] </ref>, and parameterized types. The rest of this paper is organized as follows. The dynamic semantics is described in three sections. Section 2 gives an overview of language minus its typing aspects, including its syntax and various examples.
Reference: [Chambers 95] <author> Craig Chambers. </author> <title> The Cecil Language: Specification and Rationale: </title> <type> Version 2.0. </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> December, </month> <year> 1995. </year> <note> http://www.cs.washington.edu/ research/projects/cecil/www/Papers/cecil-spec.html </note>
Reference-contexts: Thus the design of (statically typed) module systems that both allow interesting extensions (e.g., subclasses) and prevent encapsulation violations and clashes between independently-developed extensions remains an important problem [Cook 90]. We have been developing and experimenting with Cecil, an expressive and practical object-oriented language based on multimethods <ref> [Chambers 92, Chambers 95] </ref>. We have gained practical experience with programming in Cecil by writing an 80,000-line optimizing compiler, Vortex [Dean et al. 96]. We recently presented a static type system, efficient typechecking algorithm, and module system for Cecil [Chambers & Leavens 95]. <p> For example, the type of the generic function if would be declared as follows, enabling the type system to check that it is implemented for all objects that conform to the type boolean. (Such conformance declarations are similar to the signature declarations in Cecil <ref> [Chambers 95, Chambers & Leavens 95] </ref>.) if conforms (boolean, ()-&gt;Top, ()->Top) -> Top As a complete example, we show the typed version of the Point example from Section 2.2 (without the use of any syntactic sugars). type Point Point subtypes Top object Point_rep Point_rep inherits any Point_rep conforms Point -- Point_rep <p> - fun barnum (): void - type CircusElephant subtypes Elephant, CircusPerf object floppy inherits Elephant_rep, CircusPerf_rep floppy conforms CircusElephant object wagon inherits any conforms Top haul (floppy, wagon, space_for_act (floppy)) - barnum () 38 BeCecil Chambers & Leavens 4 Related Work BeCecil bears a great deal of similarity to Cecil <ref> [Chambers 92, Chambers 95] </ref>. However, there are several differences from Cecil that are worth pointing out. The major differences in the dynamic semantics are the presence, in BeCecil, of the hide declaration and block structure. A more minor difference is the first-class nature of generic functions in BeCecil.
Reference: [Chambers & Leavens 94] <author> Craig Chambers and Gary T. Leavens. </author> <title> Typechecking and Modules for Multi-Methods. </title> <booktitle> In OOPSLA 94 Conference Proceedings, </booktitle> <address> Portland Oregon, </address> <month> October, </month> <year> 1994, </year> <title> volume 29, </title> <journal> number 10 of ACM SIGPLAN Notices, </journal> <pages> pp. 1-15. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: and a method follows Cecil, in which a field named f is accessed through two methods: f and set_f. (CLOS, Dylan, Self, and other languages also present instance variables to clients as methods.) The type system of BeCecil relies heavily on our previous work on type systems for multimethod languages <ref> [Chambers & Leavens 94, Chambers & Leavens 95] </ref>. The major extensions with respect to that work are the inclusion of block structure, hide declarations, and directed actual arguments (which allows inheritance of methods).
Reference: [Chambers & Leavens 95] <author> Craig Chambers and Gary T. Leavens. </author> <title> Typechecking and Modules for Multi-Methods. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(6) </volume> <pages> 805-843. </pages> <month> November, </month> <year> 1995. </year>
Reference-contexts: We have gained practical experience with programming in Cecil by writing an 80,000-line optimizing compiler, Vortex [Dean et al. 96]. We recently presented a static type system, efficient typechecking algorithm, and module system for Cecil <ref> [Chambers & Leavens 95] </ref>. As part of our efforts to formalize the module system and generalize the underlying object model, we are designing a core language, BeCecil, * that includes extensible generic functions, inheritance, and static type checking. <p> expressions. 3.2 Brief Overview A type error in BeCecil occurs when a program applies a generic function to a tuple of actual arguments, and the generic function either has no case that is applicable to the actuals, or has more than one applicable case, but not a unique, most-specific one <ref> [Chambers & Leavens 95] </ref>. If the first kind of error (message not understood) can occur, the generic function is incomplete. If the second kind of error (message ambiguous) can occur, the generic function is inconsistent. The BeCecil type system is designed to statically prevent such type errors. <p> For example, the type of the generic function if would be declared as follows, enabling the type system to check that it is implemented for all objects that conform to the type boolean. (Such conformance declarations are similar to the signature declarations in Cecil <ref> [Chambers 95, Chambers & Leavens 95] </ref>.) if conforms (boolean, ()-&gt;Top, ()->Top) -> Top As a complete example, we show the typed version of the Point example from Section 2.2 (without the use of any syntactic sugars). type Point Point subtypes Top object Point_rep Point_rep inherits any Point_rep conforms Point -- Point_rep <p> For example, one can write the following, even though any does not conform to int. object double double inherits GenericFun_rep double has method (x@any:int):int - plus (x, x) - 3.2.2 Client-side and Implementation-side Checks Type checking can be divided into two parts <ref> [Chambers & Leavens 95] </ref>: client-side checks and implementation-side checks. Client-side checks are principally that each generic function application (and assignment) is type-correct, by comparing the types of the actuals and the type of the generic function. <p> its f argument to conform to squarer. fun is_right_triangle (a@:int, b@:int, c@:int, f@GenericFun_rep:squarer): boolean - equal (plus (f (a), f (b)), f (c)) - For example, the following application would type check. is_right_triangle (3,4,5,square) 3.5 Some Details The type system of BeCecil deals with the following features not discussed in <ref> [Chambers & Leavens 95] </ref>: directed actual arguments, extensible generic functions, first-class generic functions, hide declarations, and nested contours with local inheritance, object, and extension declarations. Directed actual arguments are handled by requiring applications with directed actual arguments to be to statically-known generic functions. <p> and a method follows Cecil, in which a field named f is accessed through two methods: f and set_f. (CLOS, Dylan, Self, and other languages also present instance variables to clients as methods.) The type system of BeCecil relies heavily on our previous work on type systems for multimethod languages <ref> [Chambers & Leavens 94, Chambers & Leavens 95] </ref>. The major extensions with respect to that work are the inclusion of block structure, hide declarations, and directed actual arguments (which allows inheritance of methods). <p> of inheritance in nested blocks. 5.3 Current Work The most pressing current work is the proof that the type system of BeCecil is sound. 45 BeCecil Chambers & Leavens We are also working on a module system for BeCecil that will allow separate typechecking of modules and combining independently-developed modules <ref> [Chambers & Leavens 95] </ref>. This module system allows one module to import another module, or to extend it. Modules that extend some other module are called extension modules. Extension modules can, effectively, insert declarations into the same recursive declaration sequence as the modules they extend.
Reference: [Chambers & Leavens 96] <author> Craig Chambers and Gary T. Leavens. BeCecil, </author> <title> A Core Object-Oriented Language with Block Structure and Multimethods: Semantics and Typing. </title> <institution> Department of Computer Science and Engineering, University of Washington, UW-CSE-96-12-02, </institution> <month> December </month> <year> 1996. </year> <institution> Also Department of Computer Science, Iowa State University, </institution> <type> TR #96-17, </type> <month> December </month> <year> 1996. </year> <title> ftp://ftp.cs.iastate.edu/pub/techreports/TR96-17/TR.ps.Z; the appendix sections only are in ftp://ftp.cs.iastate.edu/pub/techreports/TR96-17/appendix.ps.Z. </title> <editor> 48 BeCecil Chambers & Leavens [Clinger & Rees 91]William Clinger and Jonathan Rees (Editors). </editor> <title> Revised 4 Report on the Algorithmic Language Scheme. </title> <month> November </month> <year> 1991. </year> <month> ftp://ftp.cs.indiana.edu/pub/scheme-repository/doc/standards/r4rs.ps.gz </month>
Reference-contexts: Finally, Section 4 discusses related work in some detail, and Section 5 offers more discussion and conclusions. * The appendix sections are available from the URL ftp://ftp.cs.iastate.edu/pub/techreports/TR96-17/appendix.ps.Z <ref> [Chambers & Leavens 96] </ref>. 4 BeCecil Chambers & Leavens 2 Syntax, Overview, Sugars, and Examples for the Untyped Subset of BeCecil In this section we present the untyped subset of BeCecil. <p> We hope that this material will give readers a feel for the language before the detailed dynamic semantics are presented in Appendix A <ref> [Chambers & Leavens 96] </ref>. 2.1 Syntax The abstract syntax of BeCecil appears in Figure 2-1 below, except for the syntax of the type system, which is explained in Section 3. <p> Finally we describe some subtle points of the type system. All this should give the reader a feel for the type system before the details are presented in Appendix C <ref> [Chambers & Leavens 96] </ref>. 3.1 Syntax The syntax of BeCecil with types is given in Figure 3-1. The syntax for generic function attributes has type annotations added to formal parameters and a type annotation for return types.
Reference: [Cook 90] <author> William Cook. </author> <title> Object-Oriented Programming versus Abstract Data Types. </title> <editor> In J.W. de Bakker, W.P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Foundations of Object-Oriented Languages, REX School/Workshop Proceedings, Noordwijkerhout, the Netherlands, May/June, 1990, volume 489 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 151-178. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: Thus the design of (statically typed) module systems that both allow interesting extensions (e.g., subclasses) and prevent encapsulation violations and clashes between independently-developed extensions remains an important problem <ref> [Cook 90] </ref>. We have been developing and experimenting with Cecil, an expressive and practical object-oriented language based on multimethods [Chambers 92, Chambers 95]. We have gained practical experience with programming in Cecil by writing an 80,000-line optimizing compiler, Vortex [Dean et al. 96]. <p> subclasses gf do -- to be implemented by subclasses fun length (c@collection_rep) - var res := 0 do (c, anon method (x) -res () := plus (res (), 1); nothing-); res () 2.4.11 list The following, and the next several examples below, give an implementation of lists, a la Cook <ref> [Cook 90] </ref>. That is, we use two abstract classes, list_rep and nonempty_rep, a concrete object, nil, and a concrete class cons_rep. <p> The following are thus examples in singly-dispatched OO and procedural styles (respectively). single_oo_method has method (first@myClass, snd@any, thd@any) -...- proc_method has method (first@any, second@any, thd@any) -...- 21 BeCecil Chambers & Leavens As Cook points out <ref> [Cook 90] </ref>, one characteristic of ADT languages, such as Ada 83 [Ada 83], CLU [Liskov et al. 81], or Standard ML, is that they completely control the implementation of a particular type of object. <p> Such examples are standard in the literature on OO programming; e.g., the Boolean example is taken from Smalltalk [Goldberg & Robson 83], and the list example is taken from Cooks paper comparing ADT and OO styles <ref> [Cook 90] </ref>. Such examples demonstrate that BeCecil qualifies as an OO programming language, despite using different mechanisms than Smalltalk or C++ for objects, instance variables, message passing, classes, and inheritance. These new mechanisms support new patterns that are not possible or feasible with single-dispatching. <p> As CLOS and Dylan also have mechanisms for information hiding, our contribution in this area is the simplicity of our mechanism, and the analysis of its semantics and programming properties. This analysis settles the problem of information hiding for languages with multimethods noted by Cook <ref> [Cook 90] </ref>. BeCecil also demonstrates how to achieve a high degree of extensibility in an OO language with multimethods. In BeCecil, generic functions can be extended with new methods, and objects can be extended with new inheritance relationships by adding new declarations.
Reference: [Dean et al. 96] <author> Jeffrey Dean, Greg DeFouw, David Grove, Vassily Litvinov, and Craig Chambers. </author> <title> Vortex: An Optimizing Compiler for Object-Oriented Languages. </title> <booktitle> In Proceedings of the 1996 ACM Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA 96), </booktitle> <pages> pp. 83-100, </pages> <address> San Jose, CA, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: We have been developing and experimenting with Cecil, an expressive and practical object-oriented language based on multimethods [Chambers 92, Chambers 95]. We have gained practical experience with programming in Cecil by writing an 80,000-line optimizing compiler, Vortex <ref> [Dean et al. 96] </ref>. We recently presented a static type system, efficient typechecking algorithm, and module system for Cecil [Chambers & Leavens 95].
Reference: [Feinberg et al. 97] <author> Neal Feinberg, Sonya E. Keene, Robert O. Mathews, and P. Tucker Withington. </author> <title> The Dylan Programming Book. </title> <publisher> Addison-Wesley Longman, </publisher> <address> Reading, Mass., </address> <year> 1997. </year>
Reference-contexts: For example, one could declare an instance, myPoint, of Point_rep as follows. object myPoint myPoint inherits Point_rep Objects in BeCecil can also act as generic functions. A generic function in BeCecil is, roughly, a collection of multimethods, as in CLOS [Steele 90, Paepcke 93], Cecil, or Dylan <ref> [Shalit 97, Feinberg et al. 97] </ref>. (Unlike CLOS or Dylan, however, the methods in a BeCecil generic function need not all take the same number of arguments.) For example to declare the generic function equal, one would write the following. <p> Like BeCecil, the languages dynamic semantics is specified separately from its type system. However, since there are no type declarations, there is no way to declare abstract or deferred methods. 4.6 CLOS and Dylan Both the Common Lisp Object System (CLOS) [Steele 90, Paepcke 93] and Dylan <ref> [Shalit 97, Feinberg et al. 97] </ref> are languages with generic functions and module systems. Unlike BeCecil, the generic functions in these languages must all have the same number of (required) arguments.
Reference: [Friedman et al. 92] <author> Daniel P. Friedman, Mitchell Wand, and Christopher T. Haynes. </author> <title> Essentials of Programming Languages. </title> <publisher> McGraw-Hill, </publisher> <address> New York, NY, </address> <year> 1992. </year>
Reference-contexts: BeCecil is a call-by-value language (based on an indirect <ref> [Friedman et al. 92] </ref> or P ::= Program RDS ; B prelude, followed by a block RDS ::= Recursive-Declaration-Sequence D* mutual recursion is allowed within D* B ::= Block RDS E the recursive declaration sequence provides context for E D ::= Declaration object I object: allocates a new object named I
Reference: [Ghelli 91] <author> Giorgio Ghelli. </author> <title> A Static Type System for Message Passing. </title> <editor> In Andreas Paepcke, editor, </editor> <booktitle> OOPSLA 91 Conference Proceedings, </booktitle> <address> Phoenix, AZ, </address> <month> October, </month> <year> 1991, </year> <title> volume 26, </title> <journal> number 11 of ACM SIGPLAN Notices, </journal> <pages> pp. 129-145. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> November, </month> <year> 1991. </year>
Reference-contexts: In concrete examples we freely use parentheses as well as separators such as commas between repeated phrases. 5 BeCecil Chambers & Leavens shared objects) that is, roughly, a superset of the l&-calculus <ref> [Ghelli 91, Castagna et al. 92, Castagna et al. 95] </ref>. 2.2 Brief Overview As a start towards understanding the semantics of BeCecil, we show how to program some standard OO mechanisms in BeCecil, and then describe how to program some other basic mechanisms. 2.2.1 How to Program Standard OO Mechanisms in <p> In the rest of this section we discuss the relation of BeCecil to other languages with multimethods, Abadi and Cardellis imperative object calculus, and to other OO languages with block structure. 4.1 The l&-Calculus With respect to work on multi-method semantics, the most closely-related work is the l&-calculus <ref> [Ghelli 91, Castagna et al. 92, Castagna et al. 95] </ref>. The l&-calculus is a statically-typed foundational calculus for multimethod languages, from which BeCecil draws several ideas. In some respects, the l&-calculus is simpler than BeCecil, while in other respects BeCecil is simpler.
Reference: [Goguen & Meseguer 87] <author> Joseph A. Goguen and Jose Meseguer. </author> <title> Order-Sorted Algebra Solves the Constructor-Selector, Multiple Representation and Coercion Problems. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <address> Ithaca, NY, </address> <pages> pp. 18-29. </pages> <publisher> IEEE Press, </publisher> <address> NY, </address> <month> June, </month> <year> 1987. </year>
Reference-contexts: Alternatively, one could fix the example by declaring another method for f, such as the one below. f has method (y@foo:Bar): int - 4 - -- one way to fix the above example Another interesting aspect of the implementation-side checks is how they enforce a monotonicity [Reynolds 80], regularity <ref> [Goguen & Meseguer 87] </ref>, or consistency [Agrawal et al. 91] condition on the types of the methods in a generic function. <p> impose a consistency condition on the return types of methods of a generic function, which says that more specific methods have more specific return types. (This condition is the same as that used in the category-sorted algebras of Reynolds [Reynolds 41 BeCecil Chambers & Leavens 80] and in order-sorted algebras <ref> [Goguen & Meseguer 87] </ref>.) The implementation-side checks also require that each set of methods that are confusable (i.e., that might handle the same call) is totally ordered by the programmer.
Reference: [Goldberg & Robson 83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1983. </year>
Reference-contexts: The formals have the form I@CN, where I is the name of the formal and CN is the name of the formals 6 BeCecil Chambers & Leavens specializer object. Note that there is a formal for each argument, unlike single-dispatch languages, such as Smalltalk <ref> [Goldberg & Robson 83] </ref> or C++ [Stroustrup 91], where there is a distinguished receiver (written self or this) that is not mentioned in the list of formals. The body of the method is written between the curly braces. <p> any object number_rep inherits any object int_rep inherits number_rep object float_rep inherits number_rep object 1 inherits int_rep -- numeric literals are considered to be identifiers object 2 inherits int_rep object 3 inherits int_rep ... object 4.7 inherits float_rep ... 2.4.9 Boolean The Booleans can be coded much as in Smalltalk <ref> [Goldberg & Robson 83] </ref>. In coding this example we adopt the position of only hiding storage tables for objects. <p> Both of these languages are also dynamically typed. 4.7 Abadi and Cardellis Imperative Object Calculus Abadi and Cardelli have defined an imperative object calculus, Imp [Abadi & Cardelli 95] [Abadi & Cardelli 96, chapters 10 and 11], that consists of objects, single-dispatch methods (as in Smalltalk <ref> [Goldberg & Robson 83] </ref> or Self [Ungar & Smith 87]), method update, object cloning, and local definitions [Abadi & Cardelli 95, page 1]. They view method update as a tamed version of dynamic inheritance. See Section B.10 for why we use storage tables instead of method update in BeCecil. <p> Such examples are standard in the literature on OO programming; e.g., the Boolean example is taken from Smalltalk <ref> [Goldberg & Robson 83] </ref>, and the list example is taken from Cooks paper comparing ADT and OO styles [Cook 90]. Such examples demonstrate that BeCecil qualifies as an OO programming language, despite using different mechanisms than Smalltalk or C++ for objects, instance variables, message passing, classes, and inheritance.
Reference: [Gosling et al. 96] <author> James Gosling, Bill Joy, Guy Steele, Guy L. Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1996. </year>
Reference-contexts: Thus one cannot guarantee that there are only two Boolean objects in a program, but allowing all classes to be subclassed is standard for OO languages; for example in Smalltalk one can make new subclasses of Boolean. (On the other hand, Java <ref> [Gosling et al. 96] </ref> and Dylan have mechanisms that can prevent subclassing.) This point of view has the advantage of allowing clients to specialize on true and false.
Reference: [Gunter 92] <author> Carl Gunter. </author> <title> Semantics of Programming Languages. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1992. </year>
Reference: [Harbison 92] <author> Samuel P. Harbison. </author> <title> Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1992. </year>
Reference-contexts: The pattern of object creation and initialization can be easily encapsulated in a generic function, which allows one to create new objects dynamically. In BeCecil, it is often convenient to program both an initializer (as in Modula-3 <ref> [Harbison 92, Nelson 91] </ref>; these are called constructors in C++) and a separate primitive constructor (similar to a class method in Smalltalk), so that the initializer can be inherited. object initialize initialize inherits GenericFun_rep initialize has method (p@Point_rep, i@int_rep, j@int_rep) - x (p) := i; p object mkPoint mkPoint inherits GenericFun_rep
Reference: [Harrison & Ossher 93] <author> William Harrison and Harold Ossher, </author> <title> Subject-Oriented Programming (A Critique of Pure Objects). </title> <editor> In Andreas Paepcke, editor, </editor> <booktitle> OOPSLA 93 Conference Proceedings, </booktitle> <address> Washington, DC, Sept.-October, </address> <year> 1993, </year> <title> volume 28, </title> <journal> number 10 of ACM SIGPLAN Notices, </journal> <pages> pp. 411-428. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> October, </month> <year> 1993. </year>
Reference: [Leavens 91] <author> Gary T. Leavens. </author> <title> Modular Specification and Verification of Object-Oriented Programs. </title> <booktitle> IEEE Software 8(4), </booktitle> <pages> pp. 72-80, </pages> <month> July, </month> <year> 1991. </year>
Reference: [Liskov et al. 81] <author> Barbara Liskov, Russell Atkinson, Toby Bloom, Eliot Moss, J. Craig Schaffert, Robert Scheier, and Alan Snyder. </author> <title> CLU Reference Manual. </title> <booktitle> Volume 114 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <address> NY, </address> <year> 1981. </year>
Reference-contexts: The following are thus examples in singly-dispatched OO and procedural styles (respectively). single_oo_method has method (first@myClass, snd@any, thd@any) -...- proc_method has method (first@any, second@any, thd@any) -...- 21 BeCecil Chambers & Leavens As Cook points out [Cook 90], one characteristic of ADT languages, such as Ada 83 [Ada 83], CLU <ref> [Liskov et al. 81] </ref>, or Standard ML, is that they completely control the implementation of a particular type of object. That is, they are able to guarantee behavioral properties of objects of a given type, because they control the ability to create and modify objects of that type. <p> A prime example of this is the hide declaration in BeCecil. The hide declaration can hide information, and can even prevent impersonation, without any help from the type system. In this respect it differs from CLU <ref> [Liskov et al. 81] </ref> (and from the abstype mechanism of Standard ML [Milner et al. 90]), which achieves information hiding primarily by a difference between the types of objects as seen by the ADT implementation and its clients.
Reference: [Madsen et al. 93] <author> Ole Lehrmann Madsen, Birger Mller-Pedersen, and Kristen Nygaard. </author> <title> Object-Oriented Programming in the Beta Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1993. </year>
Reference-contexts: However, C++ is designed to carefully avoid making static closures for methods. The main OO languages that allow the full use of block structure are Simula 67 [Birtwistle et al. 73] and Beta <ref> [Madsen et al. 93, Chapter 8] </ref>. In Beta there are fewer restrictions on the use of block structure than in Simula [Madsen et al. 93, page 139]. Beta allows one to define local procedures and classes inside the bodies of other definitions, including procedure and class definitions. <p> The main OO languages that allow the full use of block structure are Simula 67 [Birtwistle et al. 73] and Beta [Madsen et al. 93, Chapter 8]. In Beta there are fewer restrictions on the use of block structure than in Simula <ref> [Madsen et al. 93, page 139] </ref>. Beta allows one to define local procedures and classes inside the bodies of other definitions, including procedure and class definitions. We believe that BeCecil supports all the patterns of programming that can be accomplished in Beta in a fairly direct way.
Reference: [Meyer 88] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1998. </year>
Reference: [Meyer 92] <author> Bertrand Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1992. </year>
Reference: [Milner et al. 90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: To achieve information hiding, we chose to add just the capability to hide a recursive declaration sequence, as this gives one the ability to hide generic functions. This capability is found in BeCecils hide declaration. A hide declaration is similar to a local declaration in Standard ML <ref> [Milner et al. 90] </ref> in that the declarations in its recursive declaration sequence are only visible in the declaration sequence that follows the keyword in. (However, unlike Standard ML, the declarations are all mutually recursive by default.) As an example, consider the implementation of a gray-scale model of colors, in which <p> A prime example of this is the hide declaration in BeCecil. The hide declaration can hide information, and can even prevent impersonation, without any help from the type system. In this respect it differs from CLU [Liskov et al. 81] (and from the abstype mechanism of Standard ML <ref> [Milner et al. 90] </ref>), which achieves information hiding primarily by a difference between the types of objects as seen by the ADT implementation and its clients.
Reference: [Morris 73] <author> James H. Morris, Jr. </author> <title> Protection in Programming Languages. </title> <journal> Communications of the ACM, </journal> <volume> 16(1) </volume> <pages> 15-21, </pages> <month> January, </month> <year> 1973. </year>
Reference-contexts: The information hiding used in our previous (OO) examples always involved hiding generic functions (especially for storage tables). This allows one to change data structures at will, and also to enforce representation invariants. It thus gives information hiding, but does not prevent impersonation <ref> [Morris 73] </ref>, since a client can always create a subclass of a given class and override all the methods that it would otherwise inherit. To see this, consider the following code, which declares an object that inherits from Grayscale_rep (of Section 2.2.1).
Reference: [Moon 86] <author> David A. Moon. </author> <title> Object-Oriented Programming with Flavors. </title> <editor> In Norman Meyrowitz (editor), </editor> <booktitle> OOPSLA 86 Conference Proceedings, </booktitle> <address> Portland, Oregon, </address> <month> September </month> <year> 1986, </year> <title> volume 21, </title> <journal> number 11 of ACM SIGPLAN Notices, </journal> <pages> pp. 1-8. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> November, </month> <year> 1986. </year>
Reference-contexts: 1 Introduction Object-oriented (OO) languages with multimethods <ref> [Bobrow et al. 86, Moon 86, Chambers 92] </ref> offer increased expressiveness over languages with only singly-dispatched methods, for the following reasons: dispatching on all arguments is more exible and symmetric than dispatching on only the first argument; multiple dispatching generalizes and unifies global procedures, singly-dispatched methods, and (statically) overloaded procedures; multiple
Reference: [Mugridge et al. 91] <author> W. B. Mugridge, J. G. Hosking, and J. Hamer. </author> <title> Multi-Methods in a Statically-Typed Programming Language. </title> <type> Technical report #50, </type> <institution> Department of Computer Science, University of Auckland, </institution> <year> 1991. </year> <note> Also appears in Pierre America, </note> <editor> editor, </editor> <booktitle> ECOOP 91 Conference Proceedings, </booktitle> <address> Geneva, Switzerland, </address> <month> July, </month> <year> 1991, </year> <booktitle> volume 512 of Lecture Notes in Computer Science; Springer-Verlag, </booktitle> <address> New York, </address> <year> 1991. </year>
Reference-contexts: can use a specializer that is distinct from the formal argument type; because the specializer also does not have to conform to the argument type, one can use the specializer any, and thus effectively not specialize on that argument. 4.4 Kea Kea is a higher-order, polymorphic, purely-functional language supporting multimethods <ref> [Mugridge et al. 91] </ref>. Objects in Kea contain various properties, which can be thought of as fields, unlike BeCecil. Information hiding is based on a class mechanism; a class has a declared public interface, and only within a class can other properties of an object be accessed.
Reference: [Nelson 91] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: The pattern of object creation and initialization can be easily encapsulated in a generic function, which allows one to create new objects dynamically. In BeCecil, it is often convenient to program both an initializer (as in Modula-3 <ref> [Harbison 92, Nelson 91] </ref>; these are called constructors in C++) and a separate primitive constructor (similar to a class method in Smalltalk), so that the initializer can be inherited. object initialize initialize inherits GenericFun_rep initialize has method (p@Point_rep, i@int_rep, j@int_rep) - x (p) := i; p object mkPoint mkPoint inherits GenericFun_rep
Reference: [Ossher et al. 95] <author> Harold Ossher, Matthew Kaplan, William Harrison, Alexander Katz, and Vincent Kruskal. </author> <title> Subject-Oriented Composition Rules. </title> <booktitle> In OOPSLA95 Conference Proceedings, </booktitle> <pages> pages 235250, </pages> <address> Austin, TX, </address> <month> October </month> <year> 1995. </year>
Reference: [Paepcke 93] <author> Andreas Paepcke. </author> <title> Object-Oriented Programming: The CLOS Perspective. </title> <publisher> MIT Press, </publisher> <year> 1993. </year> <note> 49 BeCecil Chambers & Leavens </note>
Reference-contexts: Although CLOS <ref> [Steele 90, Paepcke 93] </ref> and Dylan [Shalit 97, Feinberg 97] are multimethod languages with module systems, their module systems, which have received little theoretical attention, either permit encapsulation violations or limit extensibility. <p> For example, one could declare an instance, myPoint, of Point_rep as follows. object myPoint myPoint inherits Point_rep Objects in BeCecil can also act as generic functions. A generic function in BeCecil is, roughly, a collection of multimethods, as in CLOS <ref> [Steele 90, Paepcke 93] </ref>, Cecil, or Dylan [Shalit 97, Feinberg et al. 97]. (Unlike CLOS or Dylan, however, the methods in a BeCecil generic function need not all take the same number of arguments.) For example to declare the generic function equal, one would write the following. <p> Like BeCecil, the languages dynamic semantics is specified separately from its type system. However, since there are no type declarations, there is no way to declare abstract or deferred methods. 4.6 CLOS and Dylan Both the Common Lisp Object System (CLOS) <ref> [Steele 90, Paepcke 93] </ref> and Dylan [Shalit 97, Feinberg et al. 97] are languages with generic functions and module systems. Unlike BeCecil, the generic functions in these languages must all have the same number of (required) arguments.
Reference: [Reenskaug & Anderson 92] <author> Trygve Reenskaug and Egil P. Anderson. </author> <title> System Design by Composing Structures of Interacting Objects. </title> <booktitle> In Proceedings of the 1992 European Conference on Object-Oriented Programming, </booktitle> <pages> pages 133152, </pages> <year> 1992. </year>
Reference: [Reynolds 80] <author> John C. Reynolds. </author> <title> Using Category Theory to Design Implicit Conversions and Generic Operators. </title> <editor> In Neil D. Jones (editor), </editor> <booktitle> Semantics-Directed Compiler Generation, Proceedings of a Workshop, Aarhus, Denmark, </booktitle> <pages> pp. 211-258. </pages> <booktitle> Volume 94 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <address> NY, </address> <year> 1980. </year>
Reference-contexts: Alternatively, one could fix the example by declaring another method for f, such as the one below. f has method (y@foo:Bar): int - 4 - -- one way to fix the above example Another interesting aspect of the implementation-side checks is how they enforce a monotonicity <ref> [Reynolds 80] </ref>, regularity [Goguen & Meseguer 87], or consistency [Agrawal et al. 91] condition on the types of the methods in a generic function.
Reference: [Rouaix 90] <author> Francois Rouaix. </author> <title> Safe Run-Time Overloading. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, CA, </address> <pages> pp. 355-366. </pages> <publisher> ACM, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: As with Polyglot, our contribution in the area of typechecking relative to Kea is that we typecheck several important language features not found in Kea, including mutable state, separate subtyping and inheritance graphs (which allow abstract classes), and block structure. 4.5 Rouaixs Work Rouaixs work <ref> [Rouaix 90] </ref> also describes a higher-order, polymorphic, purely-functional language. This language has no mutable state variables, and does not have information hiding or block structure. This work uses a type inference system that is quite different than the type system of BeCecil.
Reference: [Shalit 97] <author> Andrew Shalit. </author> <title> The Dylan Reference Manual: The Definitive Guide to the New Object-Oriented Dynamic Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1997. </year>
Reference-contexts: Although CLOS [Steele 90, Paepcke 93] and Dylan <ref> [Shalit 97, Feinberg 97] </ref> are multimethod languages with module systems, their module systems, which have received little theoretical attention, either permit encapsulation violations or limit extensibility. <p> For example, one could declare an instance, myPoint, of Point_rep as follows. object myPoint myPoint inherits Point_rep Objects in BeCecil can also act as generic functions. A generic function in BeCecil is, roughly, a collection of multimethods, as in CLOS [Steele 90, Paepcke 93], Cecil, or Dylan <ref> [Shalit 97, Feinberg et al. 97] </ref>. (Unlike CLOS or Dylan, however, the methods in a BeCecil generic function need not all take the same number of arguments.) For example to declare the generic function equal, one would write the following. <p> Like BeCecil, the languages dynamic semantics is specified separately from its type system. However, since there are no type declarations, there is no way to declare abstract or deferred methods. 4.6 CLOS and Dylan Both the Common Lisp Object System (CLOS) [Steele 90, Paepcke 93] and Dylan <ref> [Shalit 97, Feinberg et al. 97] </ref> are languages with generic functions and module systems. Unlike BeCecil, the generic functions in these languages must all have the same number of (required) arguments.
Reference: [Shilling & Sweeney 89] <author> John J. Shilling and Peter F. Sweeney. </author> <title> Three Steps to Views: Extending the Object-Oriented Paradigm. </title> <editor> In Norman Meyrowitz, editor, </editor> <booktitle> OOPSLA 89 Conference Proceedings, </booktitle> <address> New Orleans, Louisiana, </address> <month> October </month> <year> 1989, </year> <title> volume 24, </title> <journal> number 10 of ACM SIGPLAN Notices, </journal> <pages> pp. 353-361. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> October, </month> <year> 1989. </year>
Reference: [Snyder 86] <author> Alan Snyder. </author> <title> Encapsulation and Inheritance in Object-Oriented Programming Languages. </title> <editor> In Norman Meyrowitz (editor), </editor> <booktitle> OOPSLA 86 Conference Proceedings, </booktitle> <address> Portland, Oregon, </address> <month> September </month> <year> 1986, </year> <title> volume 21, </title> <journal> number 11 of ACM SIGPLAN Notices, </journal> <pages> pp. 38-45. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> November, </month> <year> 1986. </year>
Reference-contexts: Compared to BeCecil, however, their type system depends on a number of restrictive assumptions: The methods of a generic function must be totally ordered by the programmer within each confusable set. Graph-based method lookup semantics found in most object-oriented languages with multiple inheritance <ref> [Snyder 86] </ref>, where the method overriding relationship only forms a partial order, cannot be handled. BeCecil does not make any such assumption, but detects whether any ambiguously-defined messages are sent. <p> Inheritance and subtyping are synonymous in Polyglot. This makes code less exible, because it prevents a class from inheriting code from some other class without being required to be a subtype <ref> [Snyder 86] </ref>. It also means that one cannot distinguish the specializer of an argument from its type, and thus one must specialize on all arguments.
Reference: [Steele 90] <author> Guy L. Steele Jr. </author> <title> Common Lisp: The Language (second edition). </title> <publisher> Digital Press, </publisher> <address> Bedford, MA, </address> <year> 1990. </year>
Reference-contexts: Although CLOS <ref> [Steele 90, Paepcke 93] </ref> and Dylan [Shalit 97, Feinberg 97] are multimethod languages with module systems, their module systems, which have received little theoretical attention, either permit encapsulation violations or limit extensibility. <p> For example, one could declare an instance, myPoint, of Point_rep as follows. object myPoint myPoint inherits Point_rep Objects in BeCecil can also act as generic functions. A generic function in BeCecil is, roughly, a collection of multimethods, as in CLOS <ref> [Steele 90, Paepcke 93] </ref>, Cecil, or Dylan [Shalit 97, Feinberg et al. 97]. (Unlike CLOS or Dylan, however, the methods in a BeCecil generic function need not all take the same number of arguments.) For example to declare the generic function equal, one would write the following. <p> Like BeCecil, the languages dynamic semantics is specified separately from its type system. However, since there are no type declarations, there is no way to declare abstract or deferred methods. 4.6 CLOS and Dylan Both the Common Lisp Object System (CLOS) <ref> [Steele 90, Paepcke 93] </ref> and Dylan [Shalit 97, Feinberg et al. 97] are languages with generic functions and module systems. Unlike BeCecil, the generic functions in these languages must all have the same number of (required) arguments.
Reference: [Stroustrup 91] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language: Second Edition. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1991. </year>
Reference-contexts: Note that there is a formal for each argument, unlike single-dispatch languages, such as Smalltalk [Goldberg & Robson 83] or C++ <ref> [Stroustrup 91] </ref>, where there is a distinguished receiver (written self or this) that is not mentioned in the list of formals. The body of the method is written between the curly braces. <p> We know of no other statically typed OO languages with both multimethods and block structure. (Dylan allows one to define methods in nested blocks, but not classes or inheritance relationships. CLOS has lexical closures, but classes and inheritance relationships are global.) C++ <ref> [Stroustrup 91] </ref> has some amount of block structure, in that one can declare classes within blocks. However, C++ is designed to carefully avoid making static closures for methods.
Reference: [Ungar & Smith 87] <author> David Ungar and Randall B. Smith. </author> <title> Self: The Power of Simplicity. </title> <editor> In Norman Meyrowitz, editor, </editor> <booktitle> OOPSLA 87 Conference Proceedings, Orlando, FLorida, </booktitle> <volume> volume 22, number 12, </volume> <booktitle> of ACM SIGPLAN Notices, </booktitle> <pages> pp. 227-241. </pages> <publisher> ACM, </publisher> <address> New York, </address> <month> December, </month> <year> 1987. </year>
Reference-contexts: these languages are also dynamically typed. 4.7 Abadi and Cardellis Imperative Object Calculus Abadi and Cardelli have defined an imperative object calculus, Imp [Abadi & Cardelli 95] [Abadi & Cardelli 96, chapters 10 and 11], that consists of objects, single-dispatch methods (as in Smalltalk [Goldberg & Robson 83] or Self <ref> [Ungar & Smith 87] </ref>), method update, object cloning, and local definitions [Abadi & Cardelli 95, page 1]. They view method update as a tamed version of dynamic inheritance. See Section B.10 for why we use storage tables instead of method update in BeCecil.
Reference: [Van Hilst & Notkin 96] <author> Michael Van Hilst and David Notkin. </author> <title> Using C++ Templates to Implement Role-Based Designs. </title> <booktitle> In Proceedings of 2nd International Symposium on Object Technologies for Advanced Software, </booktitle> <month> March </month> <year> 1996. </year>
Reference: [Winskel 93] <editor> Glynn Winskel. </editor> <booktitle> The Formal Semantics of Programming Languages. Foundations of Computer Science Series, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1993. </year>
Reference: [Wirfs-Brock & Johnson 90] <author> Rebecca J. Wirfs-Brock and Ralph E. Johnson. </author> <title> A survey of current research in object-oriented design. </title> <journal> Communications of the ACM, </journal> <volume> 33(9):104124, </volume> <month> September </month> <year> 1990. </year> <note> 50 BeCecil Chambers & Leavens </note>
References-found: 56

