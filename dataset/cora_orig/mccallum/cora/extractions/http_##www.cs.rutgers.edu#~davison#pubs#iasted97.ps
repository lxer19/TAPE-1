URL: http://www.cs.rutgers.edu/~davison/pubs/iasted97.ps
Refering-URL: http://www.cs.rutgers.edu/~davison/pubs/iasted97.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: 5DWLRQDOfl&RQWUROflRIfl0XOWLOHYHOfl6WRFKDVWLFfl'HVLJQ  
Author: J. STORRS HALL, LOUIS STEINBERG, BRIAN D. DAVISON 
Address: New Brunswick, NJ  
Affiliation: Laboratory for Computer Science Research Rutgers University,  
Abstract: Search in a complex design space (e.g. in VLSI design) is only feasible when it is factored into smaller ones. A common and useful factoring is the hierarchy of abstraction. Such problems are then attacked by linking together stochastic search programs. At each point in the design process it is necessary to choose whether to continue looking for a better design at the current level, or working further on some design at a higher or lower level. We present a rational, i.e. utility-based, method for this choice, together with some experiments in the domain of VLSI placement and routing 1 . 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Hennessy, John, and Patterson, David: </author> <title> Computer Architecture: A Quantitative Approach , Morgan Kaufman, </title> <address> San Mateo CA, </address> <year> 1990 </year>
Reference-contexts: We can now apply the same algorithm to level 1 to find a value function V 2 , and so forth. For purposes of the algorithm, we will assume we have a root object o n+1 Algorithm W (waterfall, or standard top down design) <ref> [1] </ref> Set object x=o n+1 and distribution d=D n [2] Calculate g from d, c i i [3] Generate objects from d until one is found with a score higher than g. <p> We will use a vectors g [], h [], k [], p [], and d [] to hold the active values for each level. Algorithm S (multi-level design with sampling) <ref> [1] </ref> Set object p [n]=o n+1 and distribution d [n]=D n i=n, and bc =c .
Reference: 2. <author> Russell, Stuart and Norvig, Peter: </author> <title> Artificial Intelligence: A Modern Approach , Prentice Hall, </title> <address> Englewood Cliffs NJ, </address> <year> 1995 </year>
Reference-contexts: For purposes of the algorithm, we will assume we have a root object o n+1 Algorithm W (waterfall, or standard top down design) [1] Set object x=o n+1 and distribution d=D n <ref> [2] </ref> Calculate g from d, c i i [3] Generate objects from d until one is found with a score higher than g. <p> Algorithm S (multi-level design with sampling) [1] Set object p [n]=o n+1 and distribution d [n]=D n i=n, and bc =c . Set g [n+1] to minus infinity. <ref> [2] </ref> Generate an object from p [i]; call it x. [3] Calculate a new d [i] using the method of section 7. [4] Calculate g [ i] from d [ i], bc i i . <p> Repeat [4] and [5] until the new g [ i] is acceptably close to the previous one. [6] If V (g [i])&lt;V (g [i+1]), set i=i+1 and go to <ref> [2] </ref>. [7] If s (x)&lt;k [i] goto [2]. [8] If i is 0, we are done, and x is our result. [9] Otherwise, set i=i-1, p [ i] to x, d [ i] to SCD i to 2. Algorithm S ameliorates the inability of Algorithm W to handle object-contingent variability. <p> Repeat [4] and [5] until the new g [ i] is acceptably close to the previous one. [6] If V (g [i])&lt;V (g [i+1]), set i=i+1 and go to <ref> [2] </ref>. [7] If s (x)&lt;k [i] goto [2]. [8] If i is 0, we are done, and x is our result. [9] Otherwise, set i=i-1, p [ i] to x, d [ i] to SCD i to 2. Algorithm S ameliorates the inability of Algorithm W to handle object-contingent variability.
Reference: 3. <author> Russell, Stuart and Wefald, Eric: </author> <title> Do the Right Thing: Studies in Limited Rationality, </title> <publisher> MIT Press, </publisher> <address> Cambridge MA, </address> <year> 1991 </year>
Reference-contexts: For purposes of the algorithm, we will assume we have a root object o n+1 Algorithm W (waterfall, or standard top down design) [1] Set object x=o n+1 and distribution d=D n [2] Calculate g from d, c i i <ref> [3] </ref> Generate objects from d until one is found with a score higher than g. <p> Algorithm S (multi-level design with sampling) [1] Set object p [n]=o n+1 and distribution d [n]=D n i=n, and bc =c . Set g [n+1] to minus infinity. [2] Generate an object from p [i]; call it x. <ref> [3] </ref> Calculate a new d [i] using the method of section 7. [4] Calculate g [ i] from d [ i], bc i i .
Reference: 4. <author> Sherwani, Naveed: </author> <title> Algorithms for VLSI Physical Design Automation, </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1995 </year>
Reference-contexts: Set x to this object. <ref> [4] </ref> If i is 0, we are done, and x is our result. [5] Otherwise, set d to the contingent distribution at level i-1 defined by s (x). [6] Decrement i and go to step 2. <p> Set g [n+1] to minus infinity. [2] Generate an object from p [i]; call it x. [3] Calculate a new d [i] using the method of section 7. <ref> [4] </ref> Calculate g [ i] from d [ i], bc i i . Calculate h [ i] and k [i] using the method of section 5. (h=k=g if i=0.) [5] Calculate a new bc i using h and k in the method of section 6. Repeat [4] and [5] until the <p> method of section 7. <ref> [4] </ref> Calculate g [ i] from d [ i], bc i i . Calculate h [ i] and k [i] using the method of section 5. (h=k=g if i=0.) [5] Calculate a new bc i using h and k in the method of section 6. Repeat [4] and [5] until the new g [ i] is acceptably close to the previous one. [6] If V (g [i])&lt;V (g [i+1]), set i=i+1 and go to [2]. [7] If s (x)&lt;k [i] goto [2]. [8] If i is 0, we are done, and x is our result. [9] Otherwise,
References-found: 4

