URL: ftp://ftp.cs.brown.edu/pub/techreports/94/cs94-27.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-94-27.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [BaM] <author> R. Bayer and E. McCreight, </author> <title> "Organization of Large Ordered Indexes," </title> <journal> Acta Informatica 1 (1972), </journal> <pages> 173-189. </pages>
Reference-contexts: B-trees and their variants B + -trees <ref> [BaM, Com] </ref> are examples of such data structures. They have been an unqualified success in supporting external dynamic 1-dimensional range searching in relational database systems. The general data structure problem underlying efficient secondary storage manipulation for many data models is external dynamic k-dimensional range searching.
Reference: [Ben] <author> J. L. Bentley, </author> <title> "Algorithms for Klee's Rectangle Problems," </title> <institution> Dept. of Computer Science, Carnegie Mellon Univ. </institution> <note> unpublished notes, </note> <year> 1977. </year>
Reference-contexts: Given a set of input intervals, to answer a stabbing query for a point q we have to report all intervals that intersect q. Elegant solutions exist for this problem in main memory. The segment tree <ref> [Ben] </ref>, interval tree [Edea, Edeb], and the priority search tree [McC] can all solve this problem well. Of these, the priority search tree solves a slightly more general problem (3-sided queries) with optimal query and update times and uses optimal storage. <p> The segment tree is an elegant data structure that is used to answer stabbing queries on a collection of intervals. Before we discuss the use of path caching in this context we give a brief description of the segment tree; a more complete treatment can be found in <ref> [Ben] </ref>. For ease of exposition we will assume that none of the input intervals share any endpoints. To build a segment tree on a set of n intervals we first build a binary search tree T on the 2n endpoints of the intervals.
Reference: [BlGa] <author> G. Blankenagel and R. H. Guting, </author> <title> "XP-Trees External Priority Search Trees," </title> <journal> FernUniver-sitat Hagen, Informatik-Bericht Nr. </journal> <volume> 92, </volume> <year> 1990. </year>
Reference-contexts: Of these, the priority search tree solves a slightly more general problem (3-sided queries) with optimal query and update times and uses optimal storage. Many algorithms have been presented to solve this problem in secondary memory. These include <ref> [BlGa, BlGb, IKO] </ref>. The first I/O optimal solution for this problem appeared in [KRV]. [KRV] reduces dynamic interval management to stabbing queries, which in turn reduce to a special case of 2-dimensional range searching called diagonal corner queries (see Figure 1).
Reference: [BlGb] <author> G. Blankenagel and R. H. Guting, </author> <title> "External Segment Trees," </title> <address> FernUniversitat Hagen, Infor-matik-Bericht, </address> <year> 1990. </year>
Reference-contexts: Of these, the priority search tree solves a slightly more general problem (3-sided queries) with optimal query and update times and uses optimal storage. Many algorithms have been presented to solve this problem in secondary memory. These include <ref> [BlGa, BlGb, IKO] </ref>. The first I/O optimal solution for this problem appeared in [KRV]. [KRV] reduces dynamic interval management to stabbing queries, which in turn reduce to a special case of 2-dimensional range searching called diagonal corner queries (see Figure 1). <p> In addition to these data structures, path caching can also be applied to other main memory data structures to obtain optimal query times at the expense of small space overheads. By doing this, we improve on the bounds of <ref> [BlGb] </ref> for implementing segment trees in secondary memory. To summarize, we present a simple technique called path caching that can be used to transform many in-core data structures to efficient secondary storage structures.
Reference: [ChT] <author> Y.-J. Chiang and R. Tamassia, </author> <title> "Dynamic Algorithms in Computational Geometry," </title> <booktitle> Proceedings of IEEE, Special Issue on Computational Geometry 80(9) (1992), </booktitle> <pages> 362-381. </pages>
Reference-contexts: The problem of external dynamic k-dimensional range searching on relational database attributes x 1 ; : : :; x k generalizes 1-dimensional range searching to k attributes, with range searching on k-dimensional intervals. Many efficient algorithms exist for 2-dimensional range searching and its special cases (see <ref> [ChT] </ref> for a detailed survey). Most of these algorithms are not efficient when mapped to secondary storage.
Reference: [Cod] <author> E. F. Codd, </author> <title> "A Relational Model for Large Shared Data Banks," </title> <booktitle> CACM 13(6) (1970), </booktitle> <pages> 377-387. </pages>
Reference-contexts: 1 Introduction and motivation The successful realization of any data model in a large-scale database requires supporting its language features with efficient secondary storage manipulation. Consider the relational data model of <ref> [Cod] </ref>. While the fl Contact Author. Address: Dept. of Computer Science, Brown University, Box 1910, Providence, RI 02912. Tel: 401-863-7662. Fax: 401-863-7657. Research supported by ONR Contract N00014-91-J-4052, ARPA Order 8225. y Address: Dept. of Computer Science, Brown University, Box 1910, Providence, RI 02912. Tel: 401-863-7673. Fax: 401-863-7657.
Reference: [Com] <author> D. Comer, </author> <title> "The Ubiquitous B-tree," </title> <booktitle> Computing Surveys 11(2) (1979), </booktitle> <pages> 121-137. </pages>
Reference-contexts: B-trees and their variants B + -trees <ref> [BaM, Com] </ref> are examples of such data structures. They have been an unqualified success in supporting external dynamic 1-dimensional range searching in relational database systems. The general data structure problem underlying efficient secondary storage manipulation for many data models is external dynamic k-dimensional range searching.
Reference: [Edea] <author> H. Edelsbrunner, </author> <title> "A new Approach to Rectangle Intersections, Part I," </title> <booktitle> Int. J. Computer Mathematics 13 (1983), </booktitle> <pages> 209-219. </pages>
Reference-contexts: Given a set of input intervals, to answer a stabbing query for a point q we have to report all intervals that intersect q. Elegant solutions exist for this problem in main memory. The segment tree [Ben], interval tree <ref> [Edea, Edeb] </ref>, and the priority search tree [McC] can all solve this problem well. Of these, the priority search tree solves a slightly more general problem (3-sided queries) with optimal query and update times and uses optimal storage. Many algorithms have been presented to solve this problem in secondary memory.
Reference: [Edeb] <author> H. Edelsbrunner, </author> <title> "A new Approach to Rectangle Intersections, Part II," </title> <booktitle> Int. J. Computer Mathematics 13 (1983), </booktitle> <pages> 221-229. </pages>
Reference-contexts: Given a set of input intervals, to answer a stabbing query for a point q we have to report all intervals that intersect q. Elegant solutions exist for this problem in main memory. The segment tree [Ben], interval tree <ref> [Edea, Edeb] </ref>, and the priority search tree [McC] can all solve this problem well. Of these, the priority search tree solves a slightly more general problem (3-sided queries) with optimal query and update times and uses optimal storage. Many algorithms have been presented to solve this problem in secondary memory.
Reference: [Gun] <author> O. Gunther, </author> <title> "The Design of the Cell Tree: An Object-Oriented Index Structure for Geometric Databases," </title> <booktitle> Proc. of the fifth Int. Conf. on Data Engineering (1989), </booktitle> <pages> 598-605. </pages>
Reference-contexts: These includes the grid-file [NHS], various quad-trees [Sama, Samb], z-orders [Ore] and other space filling curves, k-d-B-trees [Rob], hB-trees [LoS], cell-trees <ref> [Gun] </ref>, and various R-trees [Gut, SRF]. For these external data structures there has been a lot of experimentation but relatively little algorithmic analysis.
Reference: [Gut] <author> Antonin Guttman, "R-Trees: </author> <title> A Dynamic Index Structure for Spatial Searching," </title> <booktitle> Proc. 1984 ACM-SIGMOD Conference on Management of Data (1985), </booktitle> <pages> 47-57. </pages>
Reference-contexts: These includes the grid-file [NHS], various quad-trees [Sama, Samb], z-orders [Ore] and other space filling curves, k-d-B-trees [Rob], hB-trees [LoS], cell-trees [Gun], and various R-trees <ref> [Gut, SRF] </ref>. For these external data structures there has been a lot of experimentation but relatively little algorithmic analysis. Their average-case performance (e.g., some achieve the desirable static query I/O time of O (log B n + t=B) on "average" inputs) is heuristic and usually validated through experimentation.
Reference: [IKO] <author> C. Icking, R. Klein, and T. Ottmann, </author> <title> Priority Search Trees in Secondary Memory (Extended Abstract), </title> <booktitle> Lecture Notes In Computer Science #314, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: Of these, the priority search tree solves a slightly more general problem (3-sided queries) with optimal query and update times and uses optimal storage. Many algorithms have been presented to solve this problem in secondary memory. These include <ref> [BlGa, BlGb, IKO] </ref>. The first I/O optimal solution for this problem appeared in [KRV]. [KRV] reduces dynamic interval management to stabbing queries, which in turn reduce to a special case of 2-dimensional range searching called diagonal corner queries (see Figure 1). <p> However, their algorithms are based on heuristics and cannot guarantee good worst-case performance. Previous attempts to answer 3-sided queries in secondary memory by implementing priority search trees in secondary memory <ref> [IKO, KRV] </ref> did not have optimal query times. [IKO] uses optimal storage but answers queries in O (log n + t=B) time. [KRV] improves on this, answering queries in O (log B n + log B + t=B) time using optimal storage. <p> However, their algorithms are based on heuristics and cannot guarantee good worst-case performance. Previous attempts to answer 3-sided queries in secondary memory by implementing priority search trees in secondary memory [IKO, KRV] did not have optimal query times. <ref> [IKO] </ref> uses optimal storage but answers queries in O (log n + t=B) time. [KRV] improves on this, answering queries in O (log B n + log B + t=B) time using optimal storage. Neither of them allow inserts and deletes from the data structure. <p> Let us consider the implementation of priority search trees in secondary memory for answering 2-sided queries. The input is a set of n points in the plane. The priority search tree is a combination of a heap and balanced bi 4 nary search tree. The solution proposed in <ref> [IKO] </ref> works as follows: Find the top B points (on the basis of their y values) in the input set, store them in a disk block and associate this disk block with the root of the search tree. <p> As illustrated in Figure 4, each node in the priority search tree defined above corresponds to a rectangular region in the plane that contains all the points stored in that node. Furthermore, the tree as a whole defines a hierarchical decomposition of the plane. As is shown in <ref> [IKO] </ref>, this organization has the following crucial property: A point in a node x can belong in a 2-sided query if (1) the region corresponding to x's parent is completely contained within the query or, (2) the region corresponding to x or the one corresponding to its parent is cut by
Reference: [KKR] <author> P. C. Kanellakis, G. M. Kuper, and P. Z. Revesz, </author> <title> "Constraint Query Languages," </title> <booktitle> Proc. 9th ACM PODS (1990), </booktitle> <pages> 299-313. </pages>
Reference-contexts: Using path caching, we study tradeoffs between time and space in secondary memory. Two special cases of 2-dimensional range searching have been studied extensively in the literature. The first one is dynamic interval management in secondary storage. This problem is crucial to indexing in constraint databases and temporal databases <ref> [KKR, KRV] </ref>. It is shown in [KRV] that the key component of dynamic interval management is answering stabbing queries. Given a set of input intervals, to answer a stabbing query for a point q we have to report all intervals that intersect q.
Reference: [KRV] <author> P. C. Kanellakis, S. Ramaswamy, D. E. Ven-groff, and J. S. Vitter, </author> <title> "Indexing for Data Models with Constraints and Classes," </title> <booktitle> Proc. 12th ACM PODS (1993), </booktitle> <pages> 233-243, </pages> <note> (A complete version of the paper appears in Technical Report 93-21, Brown University.). </note>
Reference-contexts: Moreover, their worst-case performance is much worse than the optimal bounds achievable for dynamic external 1-dimensional range searching using B + -trees (see <ref> [KRV] </ref> for a more complete reference on the field). In this paper, we are interested in obtaining algorithms with good worst-case performance. Using path caching, we study tradeoffs between time and space in secondary memory. Two special cases of 2-dimensional range searching have been studied extensively in the literature. <p> Using path caching, we study tradeoffs between time and space in secondary memory. Two special cases of 2-dimensional range searching have been studied extensively in the literature. The first one is dynamic interval management in secondary storage. This problem is crucial to indexing in constraint databases and temporal databases <ref> [KKR, KRV] </ref>. It is shown in [KRV] that the key component of dynamic interval management is answering stabbing queries. Given a set of input intervals, to answer a stabbing query for a point q we have to report all intervals that intersect q. <p> Two special cases of 2-dimensional range searching have been studied extensively in the literature. The first one is dynamic interval management in secondary storage. This problem is crucial to indexing in constraint databases and temporal databases [KKR, KRV]. It is shown in <ref> [KRV] </ref> that the key component of dynamic interval management is answering stabbing queries. Given a set of input intervals, to answer a stabbing query for a point q we have to report all intervals that intersect q. Elegant solutions exist for this problem in main memory. <p> Many algorithms have been presented to solve this problem in secondary memory. These include [BlGa, BlGb, IKO]. The first I/O optimal solution for this problem appeared in <ref> [KRV] </ref>. [KRV] reduces dynamic interval management to stabbing queries, which in turn reduce to a special case of 2-dimensional range searching called diagonal corner queries (see Figure 1). <p> Many algorithms have been presented to solve this problem in secondary memory. These include [BlGa, BlGb, IKO]. The first I/O optimal solution for this problem appeared in <ref> [KRV] </ref>. [KRV] reduces dynamic interval management to stabbing queries, which in turn reduce to a special case of 2-dimensional range searching called diagonal corner queries (see Figure 1). Diagonal corner queries can be answered in optimal time O (log B n + t=B) using optimal storage O ( n B ). <p> Diagonal corner queries can be answered in optimal time O (log B n + t=B) using optimal storage O ( n B ). The solution presented in <ref> [KRV] </ref> is fairly involved and does not support deletion of points. In this paper, we present a data structure for solving a more general version of this problem, namely 2-sided queries (see Figure 1). <p> The priority search tree can answer 3-sided queries in-core in time O (log n + t), using storage O (n). The update time is O (log n) in the worst-case. All these bounds are optimal. It is shown in <ref> [KRV] </ref> that answering 3-sided queries efficiently is key to solving the problem of indexing classes. <p> However, their algorithms are based on heuristics and cannot guarantee good worst-case performance. Previous attempts to answer 3-sided queries in secondary memory by implementing priority search trees in secondary memory <ref> [IKO, KRV] </ref> did not have optimal query times. [IKO] uses optimal storage but answers queries in O (log n + t=B) time. [KRV] improves on this, answering queries in O (log B n + log B + t=B) time using optimal storage. <p> Previous attempts to answer 3-sided queries in secondary memory by implementing priority search trees in secondary memory [IKO, KRV] did not have optimal query times. [IKO] uses optimal storage but answers queries in O (log n + t=B) time. <ref> [KRV] </ref> improves on this, answering queries in O (log B n + log B + t=B) time using optimal storage. Neither of them allow inserts and deletes from the data structure. <p> As of today, we have to rely on heuristics|that may or may not perform well at all times|to handle many of these problems. Specifically, the important problem of dynamic interval management that we highlighted in <ref> [KRV] </ref> remains open. Can we solve this problem optimally using O ( n B ) storage, answering queries in O (log B n + t=B) time, while being able to perform updates in O (log B n) worst-case time? Acknowledgments: We thank Paris Kanellakis for helpful discussions on this area.
Reference: [KKD] <author> W. Kim, K. C. Kim, and A. Dale, </author> <title> "Indexing Techniques for Object-Oriented Databases," in Object-Oriented Concepts, Databases, and Applications, </title> <editor> W. Kim and F. H. Lochovsky, eds., </editor> <publisher> Addison-Wesley, </publisher> <year> 1989, </year> <pages> 371-394. </pages>
Reference-contexts: Indexing classes is the natural generalization of indexing in the context of object-oriented databases and is very important to their good performance (see [KiL, ZdM] for more information on this area). <ref> [KKD, LOL] </ref> present solutions to the problem of indexing classes. However, their algorithms are based on heuristics and cannot guarantee good worst-case performance.
Reference: [KiL] <editor> W. Kim and F. H. Lochovsky, eds., </editor> <title> Object-Oriented Concepts, Databases, and Applications, </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: All these bounds are optimal. It is shown in [KRV] that answering 3-sided queries efficiently is key to solving the problem of indexing classes. Indexing classes is the natural generalization of indexing in the context of object-oriented databases and is very important to their good performance (see <ref> [KiL, ZdM] </ref> for more information on this area). [KKD, LOL] present solutions to the problem of indexing classes. However, their algorithms are based on heuristics and cannot guarantee good worst-case performance.
Reference: [LoS] <author> D. B. Lomet and B. Salzberg, </author> <title> "The hB-Tree: </title>
Reference-contexts: These includes the grid-file [NHS], various quad-trees [Sama, Samb], z-orders [Ore] and other space filling curves, k-d-B-trees [Rob], hB-trees <ref> [LoS] </ref>, cell-trees [Gun], and various R-trees [Gut, SRF]. For these external data structures there has been a lot of experimentation but relatively little algorithmic analysis.
References-found: 17

