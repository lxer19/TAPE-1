URL: http://www.ncc.up.pt/~amjorge/Learning_by_Refining_Algorithm_Sketches.ps.Z
Refering-URL: http://www.ncc.up.pt/~amjorge/publications.html
Root-URL: 
Title: Learning by Refining Algorithm Sketches  
Author: Pavel Brazdil and Alpio Jorge 
Note: 1994 P. Brazdil and A. Jorge ECAI 94. 11th European Conference on Artificial Intelligence Edited by A. Cohn Published in 1994 by John Wiley Sons, Ltd.  
Abstract: In this paper we suggest a mechanism that improves significantly the performance of a top-down inductive logic programming (ILP) learning system. This improvement is achieved at the cost of giving to the system extra information that is not difficult to formulate. This information appears in the form of an algorithm sketch: an incomplete and somewhat vague representation of the computation related to a particular example. We describe which sketches are admissible, give details of the learning algorithm that exploits the information contained in the sketch. The experiments carried out with the implemented system (SKIL) have demonstrated the usefulness of the method and its potential in future applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Biermann A.W. </author> <year> (1978): </year> <title> The Inference of Regular LISP Programs from Examples, </title> <institution> Duke University. </institution>
Reference-contexts: The solution of the first goal, for example, can be exemplified by: comp (A,B,C) :- A:= [2,1,0], B=:2, C:=[1,0]. (D2) The solution of the second literal in the body of D1 can be exemplified by: reverse (A,Z) :- comp (A,B,C), reverse (C,D), addelem (D,B,Z), A:= [1,0], B=:1, C:=[0], D:= <ref> [1] </ref>, Z:= [0,1]. (D3) Clause D3 contains three predicates in the clause body, all of which require a subderivation. As it is obvious how to continue, we omit further details. <p> The result of generalisation can be conveniently captured in the form of a sketch. Specialisation is achieved by sketch refinement. 6 DISCUSSION 6.1 Related Approaches Use of sketches is related to earlier work on learning from traces <ref> [1, 2, Error! Bookmark not defined. ] </ref>. Many of these early systems used the trace as the main source of information. This was later seen as a disadvantage, as providing the whole trace can be rather tedious. Sketches enable us to provide simply partial information about the execution.
Reference: [2] <author> Brazdil P. </author> <year> (1978): </year> <title> Experimental Learning Model, </title> <booktitle> Proceedings of AISB Summer Conference, </booktitle> <address> Hamburg. </address>
Reference-contexts: The result of generalisation can be conveniently captured in the form of a sketch. Specialisation is achieved by sketch refinement. 6 DISCUSSION 6.1 Related Approaches Use of sketches is related to earlier work on learning from traces <ref> [1, 2, Error! Bookmark not defined. ] </ref>. Many of these early systems used the trace as the main source of information. This was later seen as a disadvantage, as providing the whole trace can be rather tedious. Sketches enable us to provide simply partial information about the execution.
Reference: [3] <author> Brazdil P, Jorge A. </author> <year> (1992): </year> <title> Modular Approach to ILP: Learning from interaction between Modules. </title> <booktitle> ECAI 92, Logical Approaches to Machine Learning, Workshop notes. </booktitle>
Reference: [4] <author> Brazdil P, Jorge A. </author> <year> (1993): </year> <title> Exploiting Algorithm Sketches in ILP, </title> <booktitle> in Proc. of The Third International Workshop on Inductive Logic Programming (ILP'93), </booktitle> <editor> S. Muggleton (ed.), Bled, </editor> <publisher> Slovenia. </publisher>
Reference-contexts: Dependency graphs are also related to schemata used in METAXA [6] and in MOBAL, and also, to rule models of RDT [11]. 3 EXPLOITING SKETCHES IN INDUCTION In this section we describe a top-down inductive algorithm which exploits sketches. This algorithm represents an improved version of the previous system <ref> [4] </ref>. The main difference is that the process Machine Learning 429 P. Brazdil and A. Jorge of induction is effectively guided by a given sketch. If no sketch is given, the system just selects an example to substitute it.
Reference: [5] <author> De Raedt L. and Bruynooghe M. </author> <year> (1989): </year> <title> Explanation based Program Transformation. </title> <booktitle> Proceedings of Eleventh IJCAI, </booktitle> <volume> Volume 1, </volume> <editor> ed. </editor> <publisher> N.S.Sridharan. </publisher>
Reference: [6] <author> Emde W. </author> <year> (1987): </year> <note> Noncumulative Learning in METAXA.3, In Proceedings of IJCAI-87 , Morgan Kaufmann, Los Altos. </note>
Reference-contexts: Wirth and O'Rorke [ Error! Bookmark not defined. ] used a similar notion - argument dependency graph in system SIERES. Dependency graphs are more abstract than data-flow diagrams due to the fact that predicate names are not specified. Dependency graphs are also related to schemata used in METAXA <ref> [6] </ref> and in MOBAL, and also, to rule models of RDT [11]. 3 EXPLOITING SKETCHES IN INDUCTION In this section we describe a top-down inductive algorithm which exploits sketches. This algorithm represents an improved version of the previous system [4].
Reference: [7] <author> Feng C., Muggleton S. </author> <year> (1992): </year> <title> Towards Inductive Generalization in Higher Order Logic. </title> <booktitle> Proceedings of the Ninth International Workshop (ML92) . Edited by D. </booktitle> <editor> Sleeman and P. Edwards, </editor> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: The benefits of using ADG's would almost certainly be outweighed by the additional costs. Our method based on sketches is more focused. Sketches differ from both rule models [11] and higher order schemata <ref> [7] </ref> which represent higher order generalisations of clauses. The required clause is obtained from appropriate rule model by instantiating the predicate variables. This step can be compared to the process of sketch refinement. Rule models are however rather restrictive. Each predicate variable can be substituted by one predicate.
Reference: [8] <author> Gobble T. </author> <year> (1988): </year> <title> Structured Systems Analysis through Prolog, </title> <publisher> Prentice Hall. </publisher>
Reference-contexts: They are often used in the early stage of design. They show which data entities are relevant in a particular application and how the different data entities are related. The data-flow normally consist of external inputs and outputs, processes, data stores and data flows <ref> [8] </ref>. Although data-flow diagrams are quite common in many commercial applications, their meaning is not entirely clear. We have shown how such diagrams could be derived from the existing definite program and in that way clarified the issue of what sketches are.
Reference: [9] <author> Hogger C. </author> <year> (1990): </year> <note> Essentials of Logic Programming , Clarendon Press-Oxford. </note>
Reference-contexts: Sketches then represent a simplified representation of derivations. 2.1 Representing Derivations Suppose we have a definite program. In logic programming literature computations are usually represented using SLD-trees <ref> [9] </ref> and also derivation graphs. These are related to some particular example. Before presenting our representation of derivations, let us analyse an example.
Reference: [10] <author> Jouannaud J.P. & Kodratoff Y. </author> <year> (1978): </year> <title> Quelques Method Analytique de Synthse Automatic de Programmes a partir d'Examples, </title> <institution> Universit de Paris VI. </institution>
Reference: [11] <editor> Kietz J-U and Wrobel S (1992): </editor> <title> Controlling the Complexity of Learning in Logic, in Inductive Logic Programming , ed. </title> <editor> S. Muggleton, </editor> <publisher> Academic Press. </publisher>
Reference-contexts: Dependency graphs are more abstract than data-flow diagrams due to the fact that predicate names are not specified. Dependency graphs are also related to schemata used in METAXA [6] and in MOBAL, and also, to rule models of RDT <ref> [11] </ref>. 3 EXPLOITING SKETCHES IN INDUCTION In this section we describe a top-down inductive algorithm which exploits sketches. This algorithm represents an improved version of the previous system [4]. The main difference is that the process Machine Learning 429 P. Brazdil and A. <p> It does not make sense to try out all possible ADG's when attempting to generate one particular predicate definition. The benefits of using ADG's would almost certainly be outweighed by the additional costs. Our method based on sketches is more focused. Sketches differ from both rule models <ref> [11] </ref> and higher order schemata [7] which represent higher order generalisations of clauses. The required clause is obtained from appropriate rule model by instantiating the predicate variables. This step can be compared to the process of sketch refinement. Rule models are however rather restrictive.
Reference: [12] <author> Muggleton S. </author> <year> (1992): </year> <title> Inductive Logic Programming, in Inductive Logic Programming, </title> <editor> ed. S. Muggleton, </editor> <publisher> Academic Press. </publisher>
Reference: [13] <author> Quinlan J.R. </author> <year> (1990): </year> <title> Learning logical definitions from relations. </title> <note> Machine Learning 5 , 239-266. </note>
Reference-contexts: The task of the programmer is to fill in the missing parts of the sketch and turn it into a program. The purpose of this paper is to show how this can be done in an ILP system. We have redesigned the basic top-down covering algorithm based on FOIL <ref> [13] </ref>. Clauses are generated by refining an appropriate sketch. The experiments with the implemented system (SKIL) are promising. They indicate that sketches do indeed provide a powerful focusing mechanism that could be useful in future applications. The paper is organized as follows. <p> The system was wasting a lot of time, trying blindly various predicates (such as append (..) ) to the variables in the clause. In this respect, the system was suffering from a similar difficulty as FOIL <ref> [13] </ref>. Even a simple sketch such as the one used cuts down these rather blind attempts to only a few. In another experiment the system was given a more abstract sketch than the one in Fig.5. The references to qsort were eliminated and sketch variables introduced.
Reference: [14] <author> Smith D. </author> <year> (1990): </year> <title> KIDS: A Semiautomatic Program Development System, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 16, No. </volume> <pages> 9. </pages> <note> Machine Learning 432 P. </note> <editor> Brazdil and A. </editor> <publisher> Jorge </publisher>
Reference: [15] <author> Tausend B. </author> <year> (1992): </year> <title> Using and adapting Schemes for the Induction of Horn Clauses. </title> <booktitle> ECAI 92, Logical Approaches to Machine Learning, Workshop notes </booktitle> .

References-found: 15

