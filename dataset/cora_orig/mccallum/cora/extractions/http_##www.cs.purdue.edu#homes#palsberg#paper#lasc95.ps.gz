URL: http://www.cs.purdue.edu/homes/palsberg/paper/lasc95.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/palsberg/publications.html
Root-URL: http://www.cs.purdue.edu
Title: Lisp and Symbolic Computation  The Essence of Eta-Expansion in Partial Evaluation  
Author: OLIVIER DANVY, KAROLINE MALMKJR, AND JENS PALSBERG 
Keyword: 2-level -calculus, binding-time analysis, coercions.  
Address: Ny Munkegade, DK-8000 Aarhus C, Denmark  
Affiliation: Computer Science Department, Aarhus University,  
Note: c 1995 Kluwer Academic Publishers, Boston. Manufactured in The Netherlands.  
Pubnum: 1  
Email: fdanvy,karoline,palsbergg@daimi.aau.dk  
Date: 8(3), 209-227 (1995)  Received Revised  
Abstract: Editor: Peter Sestoft and Harald Stndergaard Abstract. Selective eta-expansion is a powerful "binding-time improvement", i.e., a source-program modification that makes a partial evaluator yield better results. But like most binding-time improvements, the exact problem it solves and the reason why have not been formalized and are only understood by few. In this paper, we describe the problem and the effect of eta-redexes in terms of monovariant binding-time propagation: eta-redexes preserve the static data flow of a source program by interfacing static higher-order values in dynamic contexts and dynamic higher-order values in static contexts. They contribute to two distinct binding-time improvements. We present two extensions of Gomard's monovariant binding-time analysis for the pure -calculus. Our extensions annotate and eta-expand -terms. The first one eta-expands static higher-order values in dynamic contexts. The second also eta-expands dynamic higher-order values in static contexts. As a significant application, we show that our first binding-time analysis suffices to reformulate the traditional formulation of a CPS transformation into a modern one-pass CPS transformer. This binding-time improvement is known, but it is still left unexplained in contemporary literature, e.g., about "cps-based" partial evaluation. We also outline the counterpart of eta-expansion for partially static data structures. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Henk Barendregt. </author> <title> The Lambda Calculus | Its Syntax and Semantics. </title> <publisher> North-Holland, </publisher> <year> 1984. </year>
Reference-contexts: In this setting, two sorts of expressible values coexist: static values and dynamic values (i.e., residual expressions); correspondingly two sorts of contexts coexist: static contexts and dynamic contexts. Recall that a context is an expression with one hole <ref> [1] </ref>. A higher-order (resp. partially static) context is an expression with a higher-order (resp. partially static) hole. A static (resp. dynamic) context is an expression with a static (resp. dynamic) hole. <p> Reminder: eta-expanding a higher-order expression e yields the expression v:e@v where v does not occur free in e <ref> [1] </ref>. 2.1. First-order static values in dynamic contexts The following expression is partially evaluated in a context with y dynamic. (x:(x + y) fi (x 1))@42 Assume that this fi-redex will be reduced. <p> Primitive operations are known as "delta rules" in the lambda-calculus <ref> [1] </ref>. 5.
Reference: 2. <author> Anders Bondorf. </author> <title> Automatic autoprojection of higher-order recursive equations. </title> <booktitle> Science of Computer Programming, 17(1-3):3-34, 1991. Special issue on ESOP'90, the Third European Symposium on Programming, </booktitle> <address> Copenhagen, </address> <month> May 15-18, </month> <year> 1990. </year>
Reference-contexts: The CPS transformation Let us now turn to the transformation of -terms into continuation-passing style (CPS). This example is significant because historically, the virtue of eta-redexes became apparent in connection with partial evaluation of CPS interpreters and with CPS transformers <ref> [2] </ref>, [11]. It also has practical interest since the pattern of construction and use of higher-order values in the CPS transform is prototypi cal. <p> Eta-expansion is specific to the -calculus. We are not aware of any counterpart in partial evaluation of logic programs. 5.1. Mix-style partial evaluation Mix-style partial evaluators developed at DIKU, such as Similix and Lambda-Mix <ref> [2] </ref>, [12], [15], process procedural programs. When the first-order version of Similix [4] was extended to process higher-order programs [2], it was observed that nave syntax reconstruction led to the occurrence of Scheme closures in residual programs. <p> We are not aware of any counterpart in partial evaluation of logic programs. 5.1. Mix-style partial evaluation Mix-style partial evaluators developed at DIKU, such as Similix and Lambda-Mix <ref> [2] </ref>, [12], [15], process procedural programs. When the first-order version of Similix [4] was extended to process higher-order programs [2], it was observed that nave syntax reconstruction led to the occurrence of Scheme closures in residual programs. Two solutions were possible: 223 * lifting closures into syntax to construct the residual program (at specialization time); and * dynamizing closures occurring in dynamic contexts (at binding-time analysis time).
Reference: 3. <author> Anders Bondorf. </author> <title> Improving binding times without explicit CPS-conversion. </title> <editor> In William Clinger, editor, </editor> <booktitle> Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, LISP Pointers, </booktitle> <volume> Vol. V, No. 1, </volume> <pages> pages 1-10, </pages> <address> San Francisco, California, June 1992. </address> <publisher> ACM Press. </publisher>
Reference-contexts: This solution has been consistently maintained in the later versions of Similix <ref> [3] </ref>, [5], and adopted in Lambda-Mix [12], [15]. It seems that this decision, together with the forward nature of binding-time analysis [9], have created the need for binding-time improvements: * Eta-expansion prevents the dynamization of higher-order values and contexts. Delta-expansion prevents the dynamization of partially static values and con texts.
Reference: 4. <author> Anders Bondorf and Olivier Danvy. </author> <title> Automatic autoprojection of recursive equations with global variables and abstract data types. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 16 </volume> <pages> 151-195, </pages> <year> 1991. </year>
Reference-contexts: Eta-expansion is specific to the -calculus. We are not aware of any counterpart in partial evaluation of logic programs. 5.1. Mix-style partial evaluation Mix-style partial evaluators developed at DIKU, such as Similix and Lambda-Mix [2], [12], [15], process procedural programs. When the first-order version of Similix <ref> [4] </ref> was extended to process higher-order programs [2], it was observed that nave syntax reconstruction led to the occurrence of Scheme closures in residual programs.
Reference: 5. <author> Anders Bondorf and Dirk Dussart. </author> <title> Improving CPS-based partial evaluation: Writing cogen by hand. </title> <editor> In Peter Sestoft and Harald Stndergaard, editors, </editor> <title> ACM SIGPLAN Workshop on Partial Evaluation and Semantics-Based Program Manipulation, </title> <type> Technical Report, </type> <institution> University of Melbourne, </institution> <address> Australia, </address> <pages> pages 1-10, </pages> <address> Orlando, Florida, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Thus the two-level -calculus proves particularly useful for specifying CPS transformations | something that was done so far by sheer insight [27] or by hand [11]. This mode of specification has direct applications to continuation-based program transformation <ref> [5] </ref>, [16], [17]. 220 3.3.3. Improved "cps-based" cogen Bondorf and Dussart's new work [5] relies on two key eta-expansions that are analogous to those of Section 3.3.2. These eta-expansions come for free with the binding-time analysis of Figure 2. 3.4. <p> This mode of specification has direct applications to continuation-based program transformation <ref> [5] </ref>, [16], [17]. 220 3.3.3. Improved "cps-based" cogen Bondorf and Dussart's new work [5] relies on two key eta-expansions that are analogous to those of Section 3.3.2. These eta-expansions come for free with the binding-time analysis of Figure 2. 3.4. Eta-expansion of dynamic values in static contexts of the binding-time analysis in Figure 2. <p> This solution has been consistently maintained in the later versions of Similix [3], <ref> [5] </ref>, and adopted in Lambda-Mix [12], [15]. It seems that this decision, together with the forward nature of binding-time analysis [9], have created the need for binding-time improvements: * Eta-expansion prevents the dynamization of higher-order values and contexts. Delta-expansion prevents the dynamization of partially static values and con texts.
Reference: 6. <author> Anders Bondorf and Jens Palsberg. </author> <title> Compiling actions by partial evaluation. </title> <editor> In Arvind, editor, </editor> <booktitle> Proceedings of the Sixth ACM Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pages 308-317, </pages> <address> Copenhagen, Denmark, June 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: As a corollary we get that even though eta-expansion allows more static reductions to take place, specialization will terminate since types are finite. In another setting, eta-expansion and generalization are used both to improve binding times and to ensure termination <ref> [6] </ref>, [19], [20]. Future work includes finding an efficient implementation of our binding-time anal ysis. 3.3. Examples 3.3.1. Higher-order static values in dynamic contexts We now demonstrate that the new binding-time analysis inserts the expected eta-redex in the example program (f:f @g@f )@a:a from Section 2.2.
Reference: 7. <author> Charles Consel. </author> <title> Polyvariant binding-time analysis for applicative languages. </title> <booktitle> In Schmidt [25], </booktitle> <pages> pages 66-77. 227 </pages>
Reference-contexts: The freeze operator acts like eta-expansion, and enables Schism to deal with higher-order and partially static values in dynamic contexts without dynamizing them. Independently, Schism's polyvariant binding-time analysis <ref> [7] </ref> deals with dynamic values in static contexts, though currently, higher-order parameters are treated in a monovariant way. Thus Schism's extra power makes it possible to interface partially static and higher-order values and contexts smoothly, without loss of static information.
Reference: 8. <author> Charles Consel. </author> <title> A tour of Schism: A partial evaluation system for higher-order applicative languages. </title> <booktitle> In Schmidt [25], </booktitle> <pages> pages 145-154. </pages>
Reference-contexts: Delta-expansion prevents the dynamization of partially static values and con texts. Thus they both improve the binding times of source programs. * Tail-recursive style in general (typically CPS) prevents the dynamization of in termediate results [9]. Thus it improves the static data flow of source programs. 5.2. Schism Schism <ref> [8] </ref> does not dynamize static values whenever they occur in dynamic contexts. Instead, it inserts a "freeze" annotation coercing their result to be dynamic.
Reference: 9. <author> Charles Consel and Olivier Danvy. </author> <title> For a better support of static data flow. </title> <booktitle> In Hughes [13], </booktitle> <pages> pages 496-519. </pages>
Reference-contexts: This solution has been consistently maintained in the later versions of Similix [3], [5], and adopted in Lambda-Mix [12], [15]. It seems that this decision, together with the forward nature of binding-time analysis <ref> [9] </ref>, have created the need for binding-time improvements: * Eta-expansion prevents the dynamization of higher-order values and contexts. Delta-expansion prevents the dynamization of partially static values and con texts. <p> Delta-expansion prevents the dynamization of partially static values and con texts. Thus they both improve the binding times of source programs. * Tail-recursive style in general (typically CPS) prevents the dynamization of in termediate results <ref> [9] </ref>. Thus it improves the static data flow of source programs. 5.2. Schism Schism [8] does not dynamize static values whenever they occur in dynamic contexts. Instead, it inserts a "freeze" annotation coercing their result to be dynamic.
Reference: 10. <author> Charles Consel and Olivier Danvy. </author> <title> Tutorial notes on partial evaluation. </title> <editor> In Susan L. Graham, editor, </editor> <booktitle> Proceedings of the Twentieth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 493-501, </pages> <address> Charleston, South Carolina, </address> <month> January </month> <year> 1993. </year> <note> ACM Press. </note>
Reference-contexts: 1. Introduction Partial evaluation is a program-transformation technique for specializing programs <ref> [10] </ref>, [15]. In the last decade it has been described using the notion of binding times [18]. Essentially the computations in a source program are divided into "static" or specialization-time computations (performed by the partial evaluator) and "dynamic" or run-time computations (to be performed in the specialized program).
Reference: 11. <author> Olivier Danvy and Andrzej Filinski. </author> <title> Representing control, a study of the CPS transformation. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 2(4) </volume> <pages> 361-391, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: The CPS transformation Let us now turn to the transformation of -terms into continuation-passing style (CPS). This example is significant because historically, the virtue of eta-redexes became apparent in connection with partial evaluation of CPS interpreters and with CPS transformers [2], <ref> [11] </ref>. It also has practical interest since the pattern of construction and use of higher-order values in the CPS transform is prototypi cal. <p> These beta-redexes can be avoided by inserting eta-redexes in the CPS transformation, allowing some beta-redexes in the transformation to become static. 3 for the CPS transformation of applications, and two for the CPS transformation of abstractions. As analyzed elsewhere <ref> [11] </ref>, the eta-redex k:[[e]]@k prevents the outer k:::: from being dynamized. The two other eta-redexes v:k@v and v 2 :k@v 2 enable k to be kept static. The types of the transformations (shown in the figures) summarize the binding-time improvement. <p> Thus the two-level -calculus proves particularly useful for specifying CPS transformations | something that was done so far by sheer insight [27] or by hand <ref> [11] </ref>. This mode of specification has direct applications to continuation-based program transformation [5], [16], [17]. 220 3.3.3. Improved "cps-based" cogen Bondorf and Dussart's new work [5] relies on two key eta-expansions that are analogous to those of Section 3.3.2. <p> In fact, in the particular case of the call-by-value CPS transformation, these static beta-redexes precisely coincide with Plotkin's administrative redexes <ref> [11] </ref>. However, this coincidence only happens for call-by-value and not, e.g., for the call-by-name CPS transformation | an observation independently made by John Hatcliff at Kansas State University and by Ray McDowell at the University of Pennsylvania in fall 1993 (personal communication to the first author). 4.
Reference: 12. <author> Carsten K. Gomard. </author> <title> Program Analysis Matters. </title> <type> PhD thesis, </type> <institution> DIKU, Computer Science Department, University of Copenhagen, Copenhagen, Denmark, </institution> <month> November </month> <year> 1990. </year> <type> DIKU Report 91-17. </type>
Reference-contexts: Overall, binding-time analysis yields the following two-level term. (x:(x+y)fi (x1))@42 (Consistently with Nielson and Nielson [21], overlined means static and underlined means dynamic.) We can summarize some of the binding-time information by giving the binding-time types of variables, as in Lambda-Mix <ref> [12] </ref>, [15]. Here, x has type s (static) and y has type d (dynamic). <p> To make our approach applicable to untyped languages, we will in the rest of the paper give dynamic entities the ground type d, as in Lambda-Mix <ref> [12] </ref>, [15], rather than a two-level type such as t 1 !t 2 . Information to guide the insertion of eta-redexes can not be obtained directly from the output of a binding-time analysis: at that point all conflicts have been resolved. <p> Automatic insertion of eta-redexes 3.1. Binding-time analysis for the pure -calculus Our starting point is the binding-time analysis in Figure 1. The analysis is that of Gomard <ref> [12] </ref>, restricted to the pure -calculus. Types are finite and generated from the following grammar. t ::= d j t 1 ! t 2 The type d denotes the type of dynamic entities. <p> Eta-expansion is specific to the -calculus. We are not aware of any counterpart in partial evaluation of logic programs. 5.1. Mix-style partial evaluation Mix-style partial evaluators developed at DIKU, such as Similix and Lambda-Mix [2], <ref> [12] </ref>, [15], process procedural programs. When the first-order version of Similix [4] was extended to process higher-order programs [2], it was observed that nave syntax reconstruction led to the occurrence of Scheme closures in residual programs. <p> This solution has been consistently maintained in the later versions of Similix [3], [5], and adopted in Lambda-Mix <ref> [12] </ref>, [15]. It seems that this decision, together with the forward nature of binding-time analysis [9], have created the need for binding-time improvements: * Eta-expansion prevents the dynamization of higher-order values and contexts. Delta-expansion prevents the dynamization of partially static values and con texts.
Reference: 13. <editor> John Hughes, editor. </editor> <booktitle> Proceedings of the Fifth ACM Conference on Functional Programming and Computer Architecture, number 523 in Lecture Notes in Computer Science, </booktitle> <address> Cambridge, Massachusetts, </address> <month> August </month> <year> 1991. </year>
Reference: 14. <author> Neil D. Jones. </author> <title> Automatic program specialization: A re-examination from basic principles. </title> <booktitle> In Partial Evaluation and Mixed Computation, </booktitle> <pages> pages 225-282. </pages> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: Thus a partial evaluator evaluates static expressions (i.e., expressions that only depend on partial-evaluation time data) and reconstructs dynamic expressions (i.e., expressions that depend on run-time data). For this to work, the binding-time 210 division must be congruent (also called consistent) <ref> [14] </ref>, [21], [22], i.e., no static computation may depend on the result of a dynamic computation. In this setting, two sorts of expressible values coexist: static values and dynamic values (i.e., residual expressions); correspondingly two sorts of contexts coexist: static contexts and dynamic contexts. <p> Notes 1. Also in Proc. PEPM'94, pages 11-20. 2. A binding-time analysis is "monovariant" if it associates one binding-time description to any source expression. (It is "polyvariant" if it may associate several binding-time descriptions to any expression.) For consistency <ref> [14] </ref>, [21], [22], in case of clash, a monovariant binding-time analysis approximates the clashing descriptions with an encompassing dynamic description, as illustrated in the following table. binding-time binding-time least encompassing description description dynamic description x y of x and y static dynamic dynamic dynamic dynamic ! dynamic dynamic (static; static) dynamic
Reference: 15. <author> Neil D. Jones, Carsten K. Gomard, and Peter Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1993. </year>
Reference-contexts: 1. Introduction Partial evaluation is a program-transformation technique for specializing programs [10], <ref> [15] </ref>. In the last decade it has been described using the notion of binding times [18]. Essentially the computations in a source program are divided into "static" or specialization-time computations (performed by the partial evaluator) and "dynamic" or run-time computations (to be performed in the specialized program). <p> A static (resp. dynamic) context is an expression with a static (resp. dynamic) hole. A hole is static (resp. higher-order, partially static, and dynamic) whenever the expression fitting this hole is static (resp. higher-order, partially static, and dynamic). To obtain consistency, Mix-style partial evaluators <ref> [15] </ref> coerce static values and contexts to be respectively dynamic values and dynamic contexts, when they encounter a clash. This is acceptable if source programs are first-order and values are either fully static or fully dynamic. However these coercions are excessive for higher-order programs with partially static values and contexts. <p> However these coercions are excessive for higher-order programs with partially static values and contexts. Lacking better interface between higher-order and dynamic, source programs must often be modified "to improve their binding times" and thus "to make them specialize better". In Section 12.4 of their textbook <ref> [15] </ref>, Jones, Gomard, and Sestoft list eta-expansion as an effective binding-time improvement but give only a brief idea of why it works. In the following section, we use the term dynamize, with the meaning "make dynamic", to characterize the effect of eta-expansion. <p> Overall, binding-time analysis yields the following two-level term. (x:(x+y)fi (x1))@42 (Consistently with Nielson and Nielson [21], overlined means static and underlined means dynamic.) We can summarize some of the binding-time information by giving the binding-time types of variables, as in Lambda-Mix [12], <ref> [15] </ref>. Here, x has type s (static) and y has type d (dynamic). <p> To make our approach applicable to untyped languages, we will in the rest of the paper give dynamic entities the ground type d, as in Lambda-Mix [12], <ref> [15] </ref>, rather than a two-level type such as t 1 !t 2 . Information to guide the insertion of eta-redexes can not be obtained directly from the output of a binding-time analysis: at that point all conflicts have been resolved. <p> Eta-expansion is specific to the -calculus. We are not aware of any counterpart in partial evaluation of logic programs. 5.1. Mix-style partial evaluation Mix-style partial evaluators developed at DIKU, such as Similix and Lambda-Mix [2], [12], <ref> [15] </ref>, process procedural programs. When the first-order version of Similix [4] was extended to process higher-order programs [2], it was observed that nave syntax reconstruction led to the occurrence of Scheme closures in residual programs. <p> and dynamic contexts, in case of binding-time clash | was chosen in Similix-2, to avoid potential code duplication. 5 Thus one is forced to state this code duplication explicitly by garnishing one's source programs with eta-redexes (see Section 10.1.4, Item (2) and Section 12.4 of Jones, Gomard, and Sestoft's textbook <ref> [15] </ref> for two separate explanations). This solution has been consistently maintained in the later versions of Similix [3], [5], and adopted in Lambda-Mix [12], [15]. <p> state this code duplication explicitly by garnishing one's source programs with eta-redexes (see Section 10.1.4, Item (2) and Section 12.4 of Jones, Gomard, and Sestoft's textbook <ref> [15] </ref> for two separate explanations). This solution has been consistently maintained in the later versions of Similix [3], [5], and adopted in Lambda-Mix [12], [15]. It seems that this decision, together with the forward nature of binding-time analysis [9], have created the need for binding-time improvements: * Eta-expansion prevents the dynamization of higher-order values and contexts. Delta-expansion prevents the dynamization of partially static values and con texts. <p> The converse situation can be handled in specializers that carry two representations of each closure. Such systems include FUSE and Schism. 6. Conclusion Inserting eta-redexes in source programs has until now been listed as black magic in the literature on Mix-style partial evaluation <ref> [15] </ref>. We have described the effect of eta-redexes in terms of binding-time coercions: eta-redexes offer a syntactic 225 representation of coercions and thus they prevent the binding-time analysis from approximating higher-order values and higher-order contexts to be dynamic.
Reference: 16. <author> Julia L. Lawall. </author> <title> Continuation Introduction and Elimination in Higher-Order Programming Languages. </title> <type> PhD thesis, </type> <institution> Computer Science Department, Indiana University, Bloomington, Indiana, USA, </institution> <month> July </month> <year> 1994. </year>
Reference-contexts: Thus the two-level -calculus proves particularly useful for specifying CPS transformations | something that was done so far by sheer insight [27] or by hand [11]. This mode of specification has direct applications to continuation-based program transformation [5], <ref> [16] </ref>, [17]. 220 3.3.3. Improved "cps-based" cogen Bondorf and Dussart's new work [5] relies on two key eta-expansions that are analogous to those of Section 3.3.2. These eta-expansions come for free with the binding-time analysis of Figure 2. 3.4.
Reference: 17. <author> Julia L. Lawall and Olivier Danvy. </author> <title> Continuation-based partial evaluation. </title> <editor> In Carolyn L. Talcott, editor, </editor> <booktitle> Proceedings of the 1994 ACM Conference on Lisp and Functional Programming, LISP Pointers, </booktitle> <volume> Vol. VII, No. 3, </volume> <pages> pages 227-238, </pages> <address> Orlando, Florida, June 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Thus the two-level -calculus proves particularly useful for specifying CPS transformations | something that was done so far by sheer insight [27] or by hand [11]. This mode of specification has direct applications to continuation-based program transformation [5], [16], <ref> [17] </ref>. 220 3.3.3. Improved "cps-based" cogen Bondorf and Dussart's new work [5] relies on two key eta-expansions that are analogous to those of Section 3.3.2. These eta-expansions come for free with the binding-time analysis of Figure 2. 3.4.
Reference: 18. <author> Torben . Mogensen. </author> <title> Binding Time Aspects of Partial Evaluation. </title> <type> PhD thesis, </type> <institution> DIKU, Computer Science Department, University of Copenhagen, Copenhagen, Denmark, </institution> <month> March </month> <year> 1989. </year>
Reference-contexts: 1. Introduction Partial evaluation is a program-transformation technique for specializing programs [10], [15]. In the last decade it has been described using the notion of binding times <ref> [18] </ref>. Essentially the computations in a source program are divided into "static" or specialization-time computations (performed by the partial evaluator) and "dynamic" or run-time computations (to be performed in the specialized program).
Reference: 19. <author> Torben . Mogensen. </author> <title> Constructor specialization. </title> <booktitle> In Schmidt [25], </booktitle> <pages> pages 22-32. </pages>
Reference-contexts: As a corollary we get that even though eta-expansion allows more static reductions to take place, specialization will terminate since types are finite. In another setting, eta-expansion and generalization are used both to improve binding times and to ensure termination [6], <ref> [19] </ref>, [20]. Future work includes finding an efficient implementation of our binding-time anal ysis. 3.3. Examples 3.3.1. Higher-order static values in dynamic contexts We now demonstrate that the new binding-time analysis inserts the expected eta-redex in the example program (f:f @g@f )@a:a from Section 2.2.
Reference: 20. <author> Christian Mossin. </author> <title> Partial evaluation of general parsers. </title> <booktitle> In Schmidt [25], </booktitle> <pages> pages 13-21. </pages>
Reference-contexts: As a corollary we get that even though eta-expansion allows more static reductions to take place, specialization will terminate since types are finite. In another setting, eta-expansion and generalization are used both to improve binding times and to ensure termination [6], [19], <ref> [20] </ref>. Future work includes finding an efficient implementation of our binding-time anal ysis. 3.3. Examples 3.3.1. Higher-order static values in dynamic contexts We now demonstrate that the new binding-time analysis inserts the expected eta-redex in the example program (f:f @g@f )@a:a from Section 2.2.
Reference: 21. <author> Flemming Nielson and Hanne Riis Nielson. </author> <title> Two-Level Functional Languages, </title> <booktitle> volume 34 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Thus a partial evaluator evaluates static expressions (i.e., expressions that only depend on partial-evaluation time data) and reconstructs dynamic expressions (i.e., expressions that depend on run-time data). For this to work, the binding-time 210 division must be congruent (also called consistent) [14], <ref> [21] </ref>, [22], i.e., no static computation may depend on the result of a dynamic computation. In this setting, two sorts of expressible values coexist: static values and dynamic values (i.e., residual expressions); correspondingly two sorts of contexts coexist: static contexts and dynamic contexts. <p> Both subtraction operands are static, so the subtraction can be performed (in other words, x occurs in a static context, [] 1). The multiplication should be reconstructed since its first operand is dynamic. Overall, binding-time analysis yields the following two-level term. (x:(x+y)fi (x1))@42 (Consistently with Nielson and Nielson <ref> [21] </ref>, overlined means static and underlined means dynamic.) We can summarize some of the binding-time information by giving the binding-time types of variables, as in Lambda-Mix [12], [15]. Here, x has type s (static) and y has type d (dynamic). <p> Eta-expanding a higher-order dynamic expression g (when it occurs in a potentially static context) into v:g@v creates a value that can be used for replacement. This prevents a potentially static context from being dynamized by g. Instead, the new application is dynamized. Informally, eta-expansion changes the two-level type <ref> [21] </ref> of a term as follows. Assume that f and g have type t 1 ! t 2 , where t 1 and t 2 are ground types. The first eta-expansion coerces the type t 1 !t 2 to be t 1 !t 2 . <p> Notes 1. Also in Proc. PEPM'94, pages 11-20. 2. A binding-time analysis is "monovariant" if it associates one binding-time description to any source expression. (It is "polyvariant" if it may associate several binding-time descriptions to any expression.) For consistency [14], <ref> [21] </ref>, [22], in case of clash, a monovariant binding-time analysis approximates the clashing descriptions with an encompassing dynamic description, as illustrated in the following table. binding-time binding-time least encompassing description description dynamic description x y of x and y static dynamic dynamic dynamic dynamic ! dynamic dynamic (static; static) dynamic dynamic
Reference: 22. <author> Jens Palsberg. </author> <title> Correctness of binding-time analysis. </title> <journal> Journal of Functional Programming, </journal> <volume> 3(32) </volume> <pages> 347-363, </pages> <year> 1993. </year>
Reference-contexts: Thus a partial evaluator evaluates static expressions (i.e., expressions that only depend on partial-evaluation time data) and reconstructs dynamic expressions (i.e., expressions that depend on run-time data). For this to work, the binding-time 210 division must be congruent (also called consistent) [14], [21], <ref> [22] </ref>, i.e., no static computation may depend on the result of a dynamic computation. In this setting, two sorts of expressible values coexist: static values and dynamic values (i.e., residual expressions); correspondingly two sorts of contexts coexist: static contexts and dynamic contexts. <p> If w is an annotated term, then bw denotes the underlying -term. If A old for some A and t, then w is said to be well-annotated. A well-annotated term has 217 a consistent binding-time division <ref> [22] </ref>. To prove that our analysis produces only well-annotated terms, we need the following lemma about Gomard's analysis. Lemma 1 Suppose z is the only free variable of e 2 . <p> Notes 1. Also in Proc. PEPM'94, pages 11-20. 2. A binding-time analysis is "monovariant" if it associates one binding-time description to any source expression. (It is "polyvariant" if it may associate several binding-time descriptions to any expression.) For consistency [14], [21], <ref> [22] </ref>, in case of clash, a monovariant binding-time analysis approximates the clashing descriptions with an encompassing dynamic description, as illustrated in the following table. binding-time binding-time least encompassing description description dynamic description x y of x and y static dynamic dynamic dynamic dynamic ! dynamic dynamic (static; static) dynamic dynamic (static;
Reference: 23. <author> Gordon D. Plotkin. </author> <title> Call-by-name, call-by-value and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: It also has practical interest since the pattern of construction and use of higher-order values in the CPS transform is prototypi cal. Figure 4 displays Plotkin's original CPS transformation for the call-by-value lambda-calculus <ref> [23] </ref>, written as a two-level term. [[:]] : syntax!CPSsyntax!CPSsyntax [[x]] = k:k@x [[e 0 @e 1 ]] = k:[[e 0 ]]@v 0 :[[e 1 ]]@v 1 :v 0 @v 1 @k [[e]] is the CPS counterpart of the expression e.
Reference: 24. <author> Erik Ruf. </author> <title> Topics in Online Partial Evaluation. </title> <type> PhD thesis, </type> <institution> Stanford University, Stanford, California, </institution> <month> February </month> <year> 1993. </year> <note> Technical report CSL-TR-93-563. </note>
Reference-contexts: In this example, polyvariance does not give the same effect as eta-expansion. This of course suggests to mix both | a future work. 5.4. Online partial evaluation An online partial evaluator such as FUSE [28] is inherently polyvariant over binding times <ref> [24] </ref> and thus meets no problem when dynamic values reach static contexts. The converse situation can be handled in specializers that carry two representations of each closure. Such systems include FUSE and Schism. 6.
Reference: 25. <editor> David A. Schmidt, editor. </editor> <booktitle> Proceedings of the Second ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <address> Copenhagen, Denmark, June 1993. </address> <publisher> ACM Press. </publisher>
Reference: 26. <author> Guy L. Steele Jr. Rabbit: </author> <title> A compiler for Scheme. </title> <type> Technical Report AI-TR-474, </type> <institution> Artificial Intelligence Laboratory, Massachusetts Institute of Technology, Cambridge, Massachusetts, </institution> <month> May </month> <year> 1978. </year>
Reference-contexts: But CPS terms resulting from this transformation contain redundant "administrative" beta-redexes, which have to be post-reduced <ref> [26] </ref>. These beta-redexes can be avoided by inserting eta-redexes in the CPS transformation, allowing some beta-redexes in the transformation to become static. 3 for the CPS transformation of applications, and two for the CPS transformation of abstractions.
Reference: 27. <author> Mitchell Wand. </author> <title> Correctness of procedure representations in higher-order assembly language. </title> <editor> In Stephen Brookes, Michael Main, Austin Melton, Michael Mislove, and David Schmidt, editors, </editor> <booktitle> Mathematical Foundations of Programming Semantics, volume 598 of Lecture Notes in Computer Science, </booktitle> <pages> pages 294-311, </pages> <address> Pittsburgh, Pennsylvania, </address> <month> March </month> <year> 1991. </year> <booktitle> 7th International Conference. </booktitle>
Reference-contexts: Thus the two-level -calculus proves particularly useful for specifying CPS transformations | something that was done so far by sheer insight <ref> [27] </ref> or by hand [11]. This mode of specification has direct applications to continuation-based program transformation [5], [16], [17]. 220 3.3.3. Improved "cps-based" cogen Bondorf and Dussart's new work [5] relies on two key eta-expansions that are analogous to those of Section 3.3.2.
Reference: 28. <author> Daniel Weise, Roland Conybeare, Erik Ruf, and Scott Seligman. </author> <title> Automatic online partial evaluation. </title> <booktitle> In Hughes [13], </booktitle> <pages> pages 165-191. </pages>
Reference-contexts: As testified by their types, the first variant approximates the second. In this example, polyvariance does not give the same effect as eta-expansion. This of course suggests to mix both | a future work. 5.4. Online partial evaluation An online partial evaluator such as FUSE <ref> [28] </ref> is inherently polyvariant over binding times [24] and thus meets no problem when dynamic values reach static contexts. The converse situation can be handled in specializers that carry two representations of each closure. Such systems include FUSE and Schism. 6.
References-found: 28

