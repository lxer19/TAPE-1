URL: ftp://ftp.cs.kun.nl/pub/SoftwEng.InfSyst/articles/SchemaMutat.ps.Z
Refering-URL: http://www.sci.kun.nl/afdis/publist.html
Root-URL: 
Title: A Randomised Schema Mutator for Evolutionary Database Optimisation  A Randomised Schema Mutator for Evolutionary Database Op  
Author: Patrick van Bommel P. van Bommel. 
Keyword: and phrases: global optimisation, evolutionary optimisation, adaptive search, randomised algorithms, conceptual data models, transformation of data models, database optimisation.  
Note: Published as:  timisation. The Australian Computer Journal,  
Date: July 7, 1993  25(2):61-69, May 1993.  
Abstract: In this paper we focus on randomised evolutionary optimisation. We introduce a general framework for the optimisation of data models, based on the concept of evolution. This evolution is guided by a randomised schema mutator. Although our approach is expressed in terms of database optimisation, our ideas are applicable to other fields of randomised evolutionary optimisation of computer models, especially when similar (graph structured) models are used. 
Abstract-found: 1
Intro-found: 1
Reference: [AB77] <author> H.D. Anderson and P.B. Berra. </author> <title> Minimum cost selection of secondary indexes for formatted files. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 2 </volume> <pages> 68-90, </pages> <year> 1977. </year>
Reference-contexts: It will be obvious that this fitness function expresses a measure for the performance of the internal representation at hand. An introduction into the necessary performance considerations can be found in e.g. [DPP88], [CG85], <ref> [AB77] </ref>, [Bla84] and [Wed87]. Let s 1 ; s 2 2 S be candidate internal representations.
Reference: [Ami85] <author> A. Amikam. </author> <title> On the automatic generation of optimal internal schemata. </title> <journal> Information Systems, </journal> <volume> 10(1) </volume> <pages> 37-45, </pages> <year> 1985. </year>
Reference: [BB87] <author> A.S. Bickel and R.W. Bickel. </author> <title> Tree structured rules in genetic algorithms. </title> <booktitle> In Proceedings of the 2nd International Conference on Genetic Algorithms and their Applications, </booktitle> <pages> pages 77-81, </pages> <year> 1987. </year>
Reference-contexts: This encoding has two purposes. 5 Firstly, we want to exploit the fact that the evolution of string individuals (e.g. [Gol89] and [Hol75]) has a more powerful theoretical basis than the evolution of hierarchical individuals (e.g. <ref> [BB87] </ref> and [Koz91]). The use of this theoretical basis for our encoding is discussed in section 4.6. Secondly, the manipulation of string individuals, resulting from our encoding, will be much simpler than the manipulation of the original tree representations. We illustrate this in section 4.1.
Reference: [BHW91] <author> P. van Bommel, A.H.M. ter Hofstede, and Th.P. van der Weide. </author> <title> Semantics and verification of object-role models. </title> <journal> Information Systems, </journal> <volume> 16(5), </volume> <month> October </month> <year> 1991. </year>
Reference-contexts: A more general definition allowing subtyping is found in <ref> [BHW91] </ref>. The fact type that corresponds with a predicator is obtained by the operator Fact : P ! F , defined by: Fact (p) = f , p 2 f. 3 3.2 Internal representations In this section we discuss a mechanism for the internal representation of conceptual data models.
Reference: [BKM92] <author> P. van Bommel, Gy. Kovacs, and A. Micsik. </author> <title> Transformation of Database Populations and Operations from the Conceptual to the Internal Level. </title> <type> Technical Report 92-27, </type> <institution> Department of Information Systems, University of Nijmegen, Nijmegen, </institution> <address> The Netherlands, </address> <month> November </month> <year> 1992. </year> <note> Submitted. </note>
Reference-contexts: Therefore the default target data model used for implementation will be the nested relational model. However, also other data models can be obtained from the internal representations. For example, a normalized relational model is obtained by flattening the corresponding nested tables. More details are found in [Bom93] and <ref> [BKM92] </ref>. The search for an optimal internal representation is established by a randomised mutator. This mutator enables us to navigate through the search space (solution space) of all possible internal representations. <p> For more details, we refer to [Dec90] and <ref> [BKM92] </ref>. 3.3 String encoding In this section we present an encoding mechanism for the description of tree representations as strings.
Reference: [Bla84] <author> H.M. Blanken. </author> <title> Performance aspects of database management systems. </title> <type> PhD thesis, </type> <institution> Technical University Twente, Enschede, </institution> <address> The Netherlands, </address> <year> 1984. </year>
Reference-contexts: It will be obvious that this fitness function expresses a measure for the performance of the internal representation at hand. An introduction into the necessary performance considerations can be found in e.g. [DPP88], [CG85], [AB77], <ref> [Bla84] </ref> and [Wed87]. Let s 1 ; s 2 2 S be candidate internal representations.
Reference: [BLW93] <author> P. van Bommel, C.B. Lucasius, and Th.P. van der Weide. </author> <title> Genetic Algorithms for Optimal Database Design. </title> <type> Technical Report 93-01, </type> <institution> Department of Information Systems, University of Nijmegen, Nijmegen, </institution> <address> The Netherlands, </address> <month> February </month> <year> 1993. </year> <note> Submitted. </note>
Reference-contexts: In [BW92b] the computation of the expected storage requirements was specified in terms of the expected population of the original conceptual data model. The computation of the expected average access time will be part of future research. More details are found in <ref> [BLW93] </ref>. For the generation of different elements of S, we use mutation operators. A mutation operator transforms an element of S into another element of S. In this way, navigation through the search space S becomes possible. Mutation operators form the basis for advanced evolution strategies. <p> In this section we will discuss the actual search process through the solution space at hand. More details are found in [BW92b], [Bom93], <ref> [BLW93] </ref>. We first introduce a simple construction routine for tree representations, to be used in the initialisation of the search process (section 4.1). Then, we introduce basic mutations (section 4.2), followed by a discussion on different ways for setting the context for the application of such mutations (section 4.3). <p> The computational complexity of the evolution process will profit by the intelligent string encoding we introduced. In order to further reduce this complexity, more advanced evolution strategies may be necessary. One could think of a crossover operator, that combines two internal representations into a new representation (see e.g. [BW92b], <ref> [BLW93] </ref>).
Reference: [Bom93] <author> P. van Bommel. </author> <title> Database Design Modifications based on Conceptual Modelling. In Information Modelling and Knowledge Bases V, </title> <address> Amsterdam, The Netherlands, 1993. </address> <publisher> IOS Press. In Press. </publisher>
Reference-contexts: Therefore the default target data model used for implementation will be the nested relational model. However, also other data models can be obtained from the internal representations. For example, a normalized relational model is obtained by flattening the corresponding nested tables. More details are found in <ref> [Bom93] </ref> and [BKM92]. The search for an optimal internal representation is established by a randomised mutator. This mutator enables us to navigate through the search space (solution space) of all possible internal representations. <p> In this section we will discuss the actual search process through the solution space at hand. More details are found in [BW92b], <ref> [Bom93] </ref>, [BLW93]. We first introduce a simple construction routine for tree representations, to be used in the initialisation of the search process (section 4.1). Then, we introduce basic mutations (section 4.2), followed by a discussion on different ways for setting the context for the application of such mutations (section 4.3). <p> This subset is said to evolve into a new subset ([BW92b], <ref> [Bom93] </ref>). In each randomised generation the following actions are performed: 9 1. In the first part a promotion is performed.
Reference: [BS91] <author> K.K. Benke and D.R. Skinner. </author> <title> A direct search algorithm for global optimisation of multivariate functions. </title> <journal> The Australian Computer Journal, </journal> <volume> 23(2) </volume> <pages> 73-85, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: These powerful evolutionary optimisation techniques are especially interesting for complex optimisation problems, with many local optima. For other global optimisation approaches we refer to <ref> [BS91] </ref> and [TZ89]. The organisation of the paper is as follows. In section 2 we shortly discuss the framework for our approach. Then we define the search space of the database optimisation problem in section 3. Next we consider the evolution process within this search space (section 4).
Reference: [BW92a] <author> P. van Bommel and Th.P. van der Weide. </author> <title> Reducing the Search Space for Conceptual Schema Transformation. </title> <journal> Data & Knowledge Engineering, </journal> <volume> 4(8) </volume> <pages> 269-292, </pages> <year> 1992. </year>
Reference-contexts: This (nested relational) representation and the generation of such representations was introduced in <ref> [BW92a] </ref> and [BW92b]. Intuitively, a tree representation is the result of lifting up certain object types of the information structure. The roles will hang and cause other object types to be lifted up. In order to remove cycles it may be necessary to cut certain connections. <p> This tree representation (forest) has root set R = fn 1 g. 4 The relation between nodes and edges is directly coupled to predicators. We introduce two main properties. The proof of these properties was given in <ref> [BW92a] </ref>. The properties describe the situation that edges are anchored to nodes by predicators. <p> Then, this representation is called an incomplete tree representation. Such representations may occur as intermediate results during the construction (see e.g. <ref> [BW92a] </ref>) or evolution (see e.g. [BW92b]) of tree representations. 6 4 Evolution In the previous section we discussed the search space (solution space) of alternative internal representations for a given conceptual data model. In this section we will discuss the actual search process through the solution space at hand. <p> As a consequence jRj = 0 in the initial stage and jRj jF j after termination. More details are found in <ref> [BW92a] </ref>. Example 4.1 The tree representation in figure 2 (and figure 5) may be constructed by the following sequence of nest applications: -(q; q); -(r; q); -(u; t). Note that other nest applications may lead to the same result. Example 4.2 In figure 6 we see another tree representation.
Reference: [BW92b] <author> P. van Bommel and Th.P. van der Weide. </author> <title> Towards Database Optimization by Evolution. </title> <booktitle> In Proceedings of the International Conference on Information Systems and Management of Data (CISMOD 92), </booktitle> <pages> pages 273-287, </pages> <address> Bangalore, India, </address> <month> July </month> <year> 1992. </year> <month> 13 </month>
Reference-contexts: This situation may occur when a large amount of information must be stored on a storage medium with a predefined size (e.g. CD-ROM). The exact computation of Stor and Time is outside the scope of this paper. In <ref> [BW92b] </ref> the computation of the expected storage requirements was specified in terms of the expected population of the original conceptual data model. The computation of the expected average access time will be part of future research. More details are found in [BLW93]. <p> This (nested relational) representation and the generation of such representations was introduced in [BW92a] and <ref> [BW92b] </ref>. Intuitively, a tree representation is the result of lifting up certain object types of the information structure. The roles will hang and cause other object types to be lifted up. In order to remove cycles it may be necessary to cut certain connections. <p> Then, this representation is called an incomplete tree representation. Such representations may occur as intermediate results during the construction (see e.g. [BW92a]) or evolution (see e.g. <ref> [BW92b] </ref>) of tree representations. 6 4 Evolution In the previous section we discussed the search space (solution space) of alternative internal representations for a given conceptual data model. In this section we will discuss the actual search process through the solution space at hand. More details are found in [BW92b], [Bom93], <p> e.g. <ref> [BW92b] </ref>) of tree representations. 6 4 Evolution In the previous section we discussed the search space (solution space) of alternative internal representations for a given conceptual data model. In this section we will discuss the actual search process through the solution space at hand. More details are found in [BW92b], [Bom93], [BLW93]. We first introduce a simple construction routine for tree representations, to be used in the initialisation of the search process (section 4.1). <p> These operators can be used for the definition of evolution strategies (see section 4.4), or for the definition of more advanced reproduction operators (e.g. crossover <ref> [BW92b] </ref>). The first operator we introduce is the glue operator fl . The result of fl (p; q) is the transportation of Fact (p) with all its descendants to Node (q). <p> The computational complexity of the evolution process will profit by the intelligent string encoding we introduced. In order to further reduce this complexity, more advanced evolution strategies may be necessary. One could think of a crossover operator, that combines two internal representations into a new representation (see e.g. <ref> [BW92b] </ref>, [BLW93]).
Reference: [CG85] <author> S. Ceri and G. Gottlob. </author> <title> Translating SQL into relational algebra: optimization, se-mantics and equivalence of SQL queries. </title> <journal> IEEE Transactions on software engineering, </journal> <volume> 11(4) </volume> <pages> 324-345, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: It will be obvious that this fitness function expresses a measure for the performance of the internal representation at hand. An introduction into the necessary performance considerations can be found in e.g. [DPP88], <ref> [CG85] </ref>, [AB77], [Bla84] and [Wed87]. Let s 1 ; s 2 2 S be candidate internal representations.
Reference: [Che76] <author> P.P. Chen. </author> <title> The entity-relationship model: toward a unified view of data. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 1(1) </volume> <pages> 9-36, </pages> <year> 1976. </year>
Reference-contexts: More general definitions can be found in [Raw91] and [TZ89]. The process of database design is usually preceded by the process of information analysis. The result of information analysis is a conceptual data model, specifying what kind of data must be stored in a system (see e.g. ER <ref> [Che76] </ref> and NIAM [NH89]). The process of database design is then initiated with this conceptual model. It results in an internal representation (database structure), specifying in what way the data is represented on a computer (see also [Gri82]). <p> We conclude with an encoding mechanism for the elements of the search space (3.3). 3.1 The conceptual model In this paper we restrict ourselves to (the broad class of) conceptual data modelling techniques with an underlying object-role structure (e.g. ER <ref> [Che76] </ref> and NIAM [LN88], [NH89]). The information structure in these models consist of the following basic components ([BHW91],[WHB92]): * A set O of object types. For example, in figure 1 we have A 2 O. * A set P of predicators. <p> These aspects will be expressed in terms of the tree representations, used in this paper. Obviously, this results in more complex mutation operators. 3. A further incorporation of conceptual aspects, such as constraints and specialisation / gen eralisation of object types (see e.g. [HW93], <ref> [Che76] </ref> and [NH89]). Acknowledgement I would like to thank Dr.Ir. Th.P. van der Weide, Prof. Dr.Ir. E.D. Falkenberg and the anonymous referee for their constructive discussions and comments on this research.
Reference: [Col90] <author> L.S. Colby. </author> <title> A recursive algebra for nested relations. </title> <journal> Information Systems, </journal> <volume> 15(5) </volume> <pages> 567-582, </pages> <year> 1990. </year>
Reference-contexts: For fact type f this unique predicator is as denoted Hook (f ). Our concept of nested representations of an information structure is very close to the concept of nested relations, as discussed in <ref> [Col90] </ref>, [RKS88], [SS86] and [TKSD91]. In order to demonstrate this, we show how tree representations are translated into nested tables. Suppose node m has descendants as depicted in figure 3. We then construct a table with a column for m-values, and for each fact type hooking to node m. <p> Construction will be performed by the nest operator, while destruction will be performed by the unnest operator. The concept of nesting and unnesting has been widely studied (see e.g. <ref> [Col90] </ref>, [RKS88], [SS86] and [TKSD91]). Usually the effect of these operators is expressed in a rather complex way (see e.g. [SS86]). In order to simplify our definitions, we express these operators in terms of encoded tree representations. First, we introduce the nest operator.
Reference: [Dav91] <author> L. Davis. </author> <title> Handbook of genetic algorithms. </title> <publisher> Van Nostrand Reinhold, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: This mutator enables us to navigate through the search space (solution space) of all possible internal representations. Recently such evolutionary optimisation has been applied in a number of fields, for instance network architectures, telecommunication networks, aircraft design and chemistry (see e.g. <ref> [Dav91] </ref>, [Gol89] and [Raw91]). These powerful evolutionary optimisation techniques are especially interesting for complex optimisation problems, with many local optima. For other global optimisation approaches we refer to [BS91] and [TZ89]. The organisation of the paper is as follows. In section 2 we shortly discuss the framework for our approach. <p> In this way, navigation through the search space S becomes possible. Mutation operators form the basis for advanced evolution strategies. An evolution strategy usually processes subsets of S, rather than individual elements of S. This increases the power of such strategies (see <ref> [Dav91] </ref>, [Gol89] and [Raw91]). 3 The search space In this section we define the search space for the optimisation of database models. We first discuss conceptual data models (3.1). Then, we define wellformedness conditions for the internal representation of such conceptual data models (3.2).
Reference: [Dec90] <author> R. Dechter. </author> <title> Decomposing a Relation into a Tree of Binary Relations. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 41 </volume> <pages> 2-24, </pages> <year> 1990. </year>
Reference-contexts: For more details, we refer to <ref> [Dec90] </ref> and [BKM92]. 3.3 String encoding In this section we present an encoding mechanism for the description of tree representations as strings.
Reference: [DPP88] <author> Prabuddha De, June S. Park, and Hasan Pirkul. </author> <title> An integrated model of record segmentation and access path selection for databases. </title> <journal> Information Systems, </journal> <volume> 13(1) </volume> <pages> 13-30, </pages> <year> 1988. </year>
Reference-contexts: It will be obvious that this fitness function expresses a measure for the performance of the internal representation at hand. An introduction into the necessary performance considerations can be found in e.g. <ref> [DPP88] </ref>, [CG85], [AB77], [Bla84] and [Wed87]. Let s 1 ; s 2 2 S be candidate internal representations.
Reference: [Gol89] <author> D.E. Goldberg. </author> <title> Genetic algorithms in search, optimization, and machine learning. </title> <publisher> Addison-Wesley Publishing Company, Inc., </publisher> <year> 1989. </year>
Reference-contexts: This mutator enables us to navigate through the search space (solution space) of all possible internal representations. Recently such evolutionary optimisation has been applied in a number of fields, for instance network architectures, telecommunication networks, aircraft design and chemistry (see e.g. [Dav91], <ref> [Gol89] </ref> and [Raw91]). These powerful evolutionary optimisation techniques are especially interesting for complex optimisation problems, with many local optima. For other global optimisation approaches we refer to [BS91] and [TZ89]. The organisation of the paper is as follows. In section 2 we shortly discuss the framework for our approach. <p> In this way, navigation through the search space S becomes possible. Mutation operators form the basis for advanced evolution strategies. An evolution strategy usually processes subsets of S, rather than individual elements of S. This increases the power of such strategies (see [Dav91], <ref> [Gol89] </ref> and [Raw91]). 3 The search space In this section we define the search space for the optimisation of database models. We first discuss conceptual data models (3.1). Then, we define wellformedness conditions for the internal representation of such conceptual data models (3.2). <p> For more details, we refer to [Dec90] and [BKM92]. 3.3 String encoding In this section we present an encoding mechanism for the description of tree representations as strings. This encoding has two purposes. 5 Firstly, we want to exploit the fact that the evolution of string individuals (e.g. <ref> [Gol89] </ref> and [Hol75]) has a more powerful theoretical basis than the evolution of hierarchical individuals (e.g. [BB87] and [Koz91]). The use of this theoretical basis for our encoding is discussed in section 4.6. <p> & % 6 Lemma 4.5 C (Promote (p)) = jNode (p)j + 1 jPj Lemma 4.6 C (Promote (p)) = C ( fl (p; q)) + jNode (p)j 4.3 Randomly setting the context for mutation Usually, a finite evolution process is modelled by N generations (N &gt; 0) (see e.g. <ref> [Gol89] </ref>, [Raw91]). The result of generation i is denoted as Gen (i). <p> The analysis of string-based evolution has been based on the concept of similarity templates (see <ref> [Gol89] </ref>, [Hol75] and [Raw91]). We will apply this concept to the encoding of our tree representations. A similarity template specifies a set of string individuals, with similarities at certain string positions ([Gol89], [Hol75]). For a formal definition the symbol * is used as don't care symbol.
Reference: [Gri82] <editor> J.J. van Griethuysen, editor. </editor> <title> Concepts and Terminology for the Conceptual Schema and the Information Base. </title> <publisher> Publ. nr. </publisher> <address> ISO/TC97/SC5-N695, </address> <year> 1982. </year>
Reference-contexts: introduction into the main concepts we refer to <ref> [Gri82] </ref>. fl Dept. of Information Systems, Faculty of Mathematics and Informatics, University of Nijmegen, Toernooiveld 1, 6525 ED Nijmegen, The Netherlands, E-mail: pvb@cs.kun.nl 1 The conceptual data models we use consist of so-called fact types between object types (see e.g. [NH89]). <p> ER [Che76] and NIAM [NH89]). The process of database design is then initiated with this conceptual model. It results in an internal representation (database structure), specifying in what way the data is represented on a computer (see also <ref> [Gri82] </ref>). For a given conceptual data model, the set S of all possible internal representations may be very large. This set S is usually called the search space (or solution space) of the optimisation problem under consideration. Some elements of S will result in an efficient system, others will not.
Reference: [Hal91] <author> T.A. Halpin. </author> <title> A Fact-Oriented Approach to Schema Transformation. </title> <editor> In B. Thalheim, J. Demetrovics, and H.-D. Gerhardt, editors, </editor> <booktitle> MFDBS 91, volume 495 of Lecture Notes in Computer Science, </booktitle> <pages> pages 342-356, </pages> <address> Rostock, Germany, 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: We do not consider constraints on fact types or subtyping of object types. For optimisation approaches that incorporate constraint transformation, see e.g. <ref> [Hal91] </ref>. The internal representation of conceptual data models is specified in terms of the conceptual model at hand. We show that our internal representations can be easily interpreted as nested tabels. Therefore the default target data model used for implementation will be the nested relational model.
Reference: [Hol75] <author> J.H. Holland. </author> <booktitle> Adaption in Natural and Artificial Systems. </booktitle> <publisher> University of Michigan Press, </publisher> <year> 1975. </year>
Reference-contexts: This encoding has two purposes. 5 Firstly, we want to exploit the fact that the evolution of string individuals (e.g. [Gol89] and <ref> [Hol75] </ref>) has a more powerful theoretical basis than the evolution of hierarchical individuals (e.g. [BB87] and [Koz91]). The use of this theoretical basis for our encoding is discussed in section 4.6. <p> The analysis of string-based evolution has been based on the concept of similarity templates (see [Gol89], <ref> [Hol75] </ref> and [Raw91]). We will apply this concept to the encoding of our tree representations. A similarity template specifies a set of string individuals, with similarities at certain string positions ([Gol89], [Hol75]). For a formal definition the symbol * is used as don't care symbol. <p> The analysis of string-based evolution has been based on the concept of similarity templates (see [Gol89], <ref> [Hol75] </ref> and [Raw91]). We will apply this concept to the encoding of our tree representations. A similarity template specifies a set of string individuals, with similarities at certain string positions ([Gol89], [Hol75]). For a formal definition the symbol * is used as don't care symbol. A similarity template t then is an extension of the anchor function introduced in section 3.3: t : P ! P [ fflg Let ff be an anchor function and let t be a similarity template.
Reference: [HW93] <author> A.H.M. ter Hofstede and Th.P. van der Weide. </author> <title> Expressiveness in conceptual data modelling. </title> <journal> Data & Knowledge Engineering, </journal> <volume> 10(1) </volume> <pages> 65-100, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: These aspects will be expressed in terms of the tree representations, used in this paper. Obviously, this results in more complex mutation operators. 3. A further incorporation of conceptual aspects, such as constraints and specialisation / gen eralisation of object types (see e.g. <ref> [HW93] </ref>, [Che76] and [NH89]). Acknowledgement I would like to thank Dr.Ir. Th.P. van der Weide, Prof. Dr.Ir. E.D. Falkenberg and the anonymous referee for their constructive discussions and comments on this research.
Reference: [ISR83] <author> M.Y.L. Ip, L.V. Saxton, and V.V. Raghavan. </author> <title> On the selection of an optimal set of indexes. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 9 </volume> <pages> 135-143, </pages> <year> 1983. </year>
Reference-contexts: A theoretical foundation to estimate the expected convergence of different evolution strate-gies. An important question will be the following: do more complex evolution strategies lead to a higher rate of convergence? 2. A further incorporation of database aspects, such as index structures (see e.g. <ref> [ISR83] </ref>) and the computation of access times. These aspects will be expressed in terms of the tree representations, used in this paper. Obviously, this results in more complex mutation operators. 3.
Reference: [Koz91] <author> J.R. Koza. </author> <title> A hierarchical approach to learning the boolean multiplexer function. </title> <booktitle> In Foundations of genetic algorithms, </booktitle> <pages> pages 171-192. </pages> <publisher> Morgan Kaufman Publishers, </publisher> <address> Cali-fornia, </address> <year> 1991. </year>
Reference-contexts: This encoding has two purposes. 5 Firstly, we want to exploit the fact that the evolution of string individuals (e.g. [Gol89] and [Hol75]) has a more powerful theoretical basis than the evolution of hierarchical individuals (e.g. [BB87] and <ref> [Koz91] </ref>). The use of this theoretical basis for our encoding is discussed in section 4.6. Secondly, the manipulation of string individuals, resulting from our encoding, will be much simpler than the manipulation of the original tree representations. We illustrate this in section 4.1.
Reference: [LN88] <author> C.M.R. Leung and G.M. Nijssen. </author> <title> Relational database design using the NIAM conceptual schema. </title> <journal> Information Systems, </journal> <volume> 13(2) </volume> <pages> 219-227, </pages> <year> 1988. </year>
Reference-contexts: We conclude with an encoding mechanism for the elements of the search space (3.3). 3.1 The conceptual model In this paper we restrict ourselves to (the broad class of) conceptual data modelling techniques with an underlying object-role structure (e.g. ER [Che76] and NIAM <ref> [LN88] </ref>, [NH89]). The information structure in these models consist of the following basic components ([BHW91],[WHB92]): * A set O of object types. For example, in figure 1 we have A 2 O. * A set P of predicators.
Reference: [NH89] <author> G.M. Nijssen and T.A. Halpin. </author> <title> Conceptual schema and Relational Database Design: A fact oriented approach. </title> <publisher> Prentice Hall of Australia Pty Ltd, </publisher> <year> 1989. </year>
Reference-contexts: introduction into the main concepts we refer to [Gri82]. fl Dept. of Information Systems, Faculty of Mathematics and Informatics, University of Nijmegen, Toernooiveld 1, 6525 ED Nijmegen, The Netherlands, E-mail: pvb@cs.kun.nl 1 The conceptual data models we use consist of so-called fact types between object types (see e.g. <ref> [NH89] </ref>). We do not consider constraints on fact types or subtyping of object types. For optimisation approaches that incorporate constraint transformation, see e.g. [Hal91]. The internal representation of conceptual data models is specified in terms of the conceptual model at hand. <p> The process of database design is usually preceded by the process of information analysis. The result of information analysis is a conceptual data model, specifying what kind of data must be stored in a system (see e.g. ER [Che76] and NIAM <ref> [NH89] </ref>). The process of database design is then initiated with this conceptual model. It results in an internal representation (database structure), specifying in what way the data is represented on a computer (see also [Gri82]). <p> We conclude with an encoding mechanism for the elements of the search space (3.3). 3.1 The conceptual model In this paper we restrict ourselves to (the broad class of) conceptual data modelling techniques with an underlying object-role structure (e.g. ER [Che76] and NIAM [LN88], <ref> [NH89] </ref>). The information structure in these models consist of the following basic components ([BHW91],[WHB92]): * A set O of object types. For example, in figure 1 we have A 2 O. * A set P of predicators. <p> These aspects will be expressed in terms of the tree representations, used in this paper. Obviously, this results in more complex mutation operators. 3. A further incorporation of conceptual aspects, such as constraints and specialisation / gen eralisation of object types (see e.g. [HW93], [Che76] and <ref> [NH89] </ref>). Acknowledgement I would like to thank Dr.Ir. Th.P. van der Weide, Prof. Dr.Ir. E.D. Falkenberg and the anonymous referee for their constructive discussions and comments on this research.
Reference: [Pra84] <author> N. Prabhakaran. </author> <title> Generation of Relational Database Schemata and its Applications. </title> <type> PhD thesis, </type> <institution> Department of Computer Science University of Queensland, Australia, </institution> <year> 1984. </year>
Reference: [Raw91] <editor> G.J.E. Rawlins. </editor> <booktitle> Foundations of genetic algorithms. </booktitle> <publisher> Morgan Kaufman Publishers, </publisher> <address> California, </address> <year> 1991. </year>
Reference-contexts: This mutator enables us to navigate through the search space (solution space) of all possible internal representations. Recently such evolutionary optimisation has been applied in a number of fields, for instance network architectures, telecommunication networks, aircraft design and chemistry (see e.g. [Dav91], [Gol89] and <ref> [Raw91] </ref>). These powerful evolutionary optimisation techniques are especially interesting for complex optimisation problems, with many local optima. For other global optimisation approaches we refer to [BS91] and [TZ89]. The organisation of the paper is as follows. In section 2 we shortly discuss the framework for our approach. <p> Next we consider the evolution process within this search space (section 4). Finally we discuss conclusions and directions for further research in section 5. 2 Framework In this section we introduce a framework for evolutionary optimisation of database models. More general definitions can be found in <ref> [Raw91] </ref> and [TZ89]. The process of database design is usually preceded by the process of information analysis. The result of information analysis is a conceptual data model, specifying what kind of data must be stored in a system (see e.g. ER [Che76] and NIAM [NH89]). <p> In this way, navigation through the search space S becomes possible. Mutation operators form the basis for advanced evolution strategies. An evolution strategy usually processes subsets of S, rather than individual elements of S. This increases the power of such strategies (see [Dav91], [Gol89] and <ref> [Raw91] </ref>). 3 The search space In this section we define the search space for the optimisation of database models. We first discuss conceptual data models (3.1). Then, we define wellformedness conditions for the internal representation of such conceptual data models (3.2). <p> % 6 Lemma 4.5 C (Promote (p)) = jNode (p)j + 1 jPj Lemma 4.6 C (Promote (p)) = C ( fl (p; q)) + jNode (p)j 4.3 Randomly setting the context for mutation Usually, a finite evolution process is modelled by N generations (N &gt; 0) (see e.g. [Gol89], <ref> [Raw91] </ref>). The result of generation i is denoted as Gen (i). <p> The analysis of string-based evolution has been based on the concept of similarity templates (see [Gol89], [Hol75] and <ref> [Raw91] </ref>). We will apply this concept to the encoding of our tree representations. A similarity template specifies a set of string individuals, with similarities at certain string positions ([Gol89], [Hol75]). For a formal definition the symbol * is used as don't care symbol.
Reference: [RKS88] <author> M.A. Roth, H.F. Korth, and A. Silberschatz. </author> <title> Extended algebra and calculus for nested relational databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(4) </volume> <pages> 389-417, </pages> <month> Decem-ber </month> <year> 1988. </year> <month> 14 </month>
Reference-contexts: For fact type f this unique predicator is as denoted Hook (f ). Our concept of nested representations of an information structure is very close to the concept of nested relations, as discussed in [Col90], <ref> [RKS88] </ref>, [SS86] and [TKSD91]. In order to demonstrate this, we show how tree representations are translated into nested tables. Suppose node m has descendants as depicted in figure 3. We then construct a table with a column for m-values, and for each fact type hooking to node m. <p> Construction will be performed by the nest operator, while destruction will be performed by the unnest operator. The concept of nesting and unnesting has been widely studied (see e.g. [Col90], <ref> [RKS88] </ref>, [SS86] and [TKSD91]). Usually the effect of these operators is expressed in a rather complex way (see e.g. [SS86]). In order to simplify our definitions, we express these operators in terms of encoded tree representations. First, we introduce the nest operator.
Reference: [SS86] <author> H.J. Schek and M.H. Scholl. </author> <title> The relational model with relation-valued attributes. </title> <journal> Information Systems, </journal> <volume> 11(2) </volume> <pages> 137-147, </pages> <year> 1986. </year>
Reference-contexts: For fact type f this unique predicator is as denoted Hook (f ). Our concept of nested representations of an information structure is very close to the concept of nested relations, as discussed in [Col90], [RKS88], <ref> [SS86] </ref> and [TKSD91]. In order to demonstrate this, we show how tree representations are translated into nested tables. Suppose node m has descendants as depicted in figure 3. We then construct a table with a column for m-values, and for each fact type hooking to node m. <p> Construction will be performed by the nest operator, while destruction will be performed by the unnest operator. The concept of nesting and unnesting has been widely studied (see e.g. [Col90], [RKS88], <ref> [SS86] </ref> and [TKSD91]). Usually the effect of these operators is expressed in a rather complex way (see e.g. [SS86]). In order to simplify our definitions, we express these operators in terms of encoded tree representations. First, we introduce the nest operator. <p> Construction will be performed by the nest operator, while destruction will be performed by the unnest operator. The concept of nesting and unnesting has been widely studied (see e.g. [Col90], [RKS88], <ref> [SS86] </ref> and [TKSD91]). Usually the effect of these operators is expressed in a rather complex way (see e.g. [SS86]). In order to simplify our definitions, we express these operators in terms of encoded tree representations. First, we introduce the nest operator.
Reference: [TKSD91] <author> J.A. Thom, A.J. Kent, and R. Sacks-Davis. Tql: </author> <title> a nested relational query language. </title> <journal> The Australian Computer Journal, </journal> <volume> 23(2) </volume> <pages> 53-65, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: For fact type f this unique predicator is as denoted Hook (f ). Our concept of nested representations of an information structure is very close to the concept of nested relations, as discussed in [Col90], [RKS88], [SS86] and <ref> [TKSD91] </ref>. In order to demonstrate this, we show how tree representations are translated into nested tables. Suppose node m has descendants as depicted in figure 3. We then construct a table with a column for m-values, and for each fact type hooking to node m. <p> Construction will be performed by the nest operator, while destruction will be performed by the unnest operator. The concept of nesting and unnesting has been widely studied (see e.g. [Col90], [RKS88], [SS86] and <ref> [TKSD91] </ref>). Usually the effect of these operators is expressed in a rather complex way (see e.g. [SS86]). In order to simplify our definitions, we express these operators in terms of encoded tree representations. First, we introduce the nest operator.
Reference: [TZ89] <author> A. Torn and A. Zilinskas. </author> <title> Global Optimization. </title> <publisher> Springer Verlag, </publisher> <year> 1989. </year>
Reference-contexts: These powerful evolutionary optimisation techniques are especially interesting for complex optimisation problems, with many local optima. For other global optimisation approaches we refer to [BS91] and <ref> [TZ89] </ref>. The organisation of the paper is as follows. In section 2 we shortly discuss the framework for our approach. Then we define the search space of the database optimisation problem in section 3. Next we consider the evolution process within this search space (section 4). <p> Next we consider the evolution process within this search space (section 4). Finally we discuss conclusions and directions for further research in section 5. 2 Framework In this section we introduce a framework for evolutionary optimisation of database models. More general definitions can be found in [Raw91] and <ref> [TZ89] </ref>. The process of database design is usually preceded by the process of information analysis. The result of information analysis is a conceptual data model, specifying what kind of data must be stored in a system (see e.g. ER [Che76] and NIAM [NH89]).
Reference: [Wed87] <author> G.E. Weddell. </author> <title> Physical design and query optimization for a semantic data model. </title> <type> PhD thesis, </type> <institution> University of Toronto, Canada, </institution> <year> 1987. </year>
Reference-contexts: It will be obvious that this fitness function expresses a measure for the performance of the internal representation at hand. An introduction into the necessary performance considerations can be found in e.g. [DPP88], [CG85], [AB77], [Bla84] and <ref> [Wed87] </ref>. Let s 1 ; s 2 2 S be candidate internal representations.
Reference: [WHB92] <author> Th.P. van der Weide, A.H.M. ter Hofstede, and P. van Bommel. Uniquest: </author> <title> Determining the Semantics of Complex Uniqueness Constraints. </title> <journal> The Computer Journal, </journal> <volume> 35(2) </volume> <pages> 148-156, </pages> <month> April </month> <year> 1992. </year> <month> 15 </month>
References-found: 34

