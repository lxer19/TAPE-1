URL: http://www.eecs.umich.edu/PPP/PLDI96.ps
Refering-URL: http://www.eecs.umich.edu/PPP/publist.html
Root-URL: http://www.cs.umich.edu
Email: alexe,davidson@eecs.umich.edu  
Title: A Reduced Multipipeline Machine Description that Preserves Scheduling Constraints  
Author: Alexandre E. Eichenberger and Edward S. Davidson 
Address: 1301 Beal Ave, Ann Arbor, MI 48109-2122  
Affiliation: Advanced Computer Architecture Laboratory EECS Department, University of Michigan  
Abstract: High performance compilers increasingly rely on accurate modeling of the machine resources to efficiently exploit the instruction level parallelism of an application. In this paper, we propose a reduced machine description that results in faster detection of resource contentions while preserving the scheduling constraints present in the original machine description. The proposed approach reduces a machine description in an automated, error-free, and efficient fashion. Moreover, it fully supports schedulers that backtrack and process operations in arbitrary order. Reduced descriptions for the DEC Alpha 21064, MIPS R3000/R3010, and Cydra 5 result in 4 to 7 times faster detection of resource contentions and require 22 to 90% of the memory storage used by the original machine descriptions. Precise measurement for the Cydra 5 indicates that reducing the machine description results in a 2.9 times faster contention query module. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. C. Dehnert and R. A. Towle. </author> <title> Compiling for the Cydra 5. </title> <journal> In The Journal of Supercomputing, </journal> <volume> volume 7, </volume> <pages> pages 181-227, </pages> <year> 1993. </year>
Reference-contexts: Unrestricted scheduling is essential to accommodate the elaborate scheduling techniques used by today's high performance compilers. The Cydra 5 compiler, for example, uses an operation-driven scheduler that reduces the schedule length of a basic block by scheduling operations along the critical path first <ref> [1] </ref>. Operation-driven schedulers consider operations in topological order, not in order of monotonically increasing (or decreasing) schedule time. Also, the Cydra 5 and IMPACT compilers, as well as others, use software pipelining techniques to achieve loop schedules with high throughput [1][2][10]. <p> The machine configuration investigated here has 7 functional units: 2 memory port, 2 address generation, 1 FP adder, 1 FP multiplier, and 1 branch unit. The original machine description used by the Cydra 5 Fortran77 compiler <ref> [1] </ref> was manually optimized, i.e. some physical resources were eliminated from the machine description as they did not introduce any new forbidden latencies [28]. This description models 56 resources and 152 distinct patterns of resource usages, resulting in 52 distinct operation classes with 10223 forbidden latencies. <p> We used a benchmark of loops obtained from the Perfect Club [25], SPEC-89 [26], and the Livermore Fortran Kernels [27] which consists exclusively of innermost loops with no early exits, no procedure calls, and fewer than 30 basic blocks, as compiled by the Cydra 5 Fortran77 compiler <ref> [1] </ref>. The input to the scheduling algorithms consists of the Fortran77 compiler intermediate representation after load-store elimination, recurrence back-substitution, and IF-conversion. The benchmark suite consists of the 1327 loops successfully modulo scheduled by the Cydra 5 Fortran77 compiler.
Reference: [2] <author> N. J. Warter, G. E. Haab, K. Subramanian, and J. W. Bock-haus. </author> <title> Enhanced Modulo Scheduling for loops with conditional branches. </title> <booktitle> Proc. of the 25th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 170-179, </pages> <month> Dec. </month> <year> 1992. </year>
Reference-contexts: 2.6 2.0 1.5 Table 2: Results for a subset of the Cydra 5: 12 operation classes, 166 forbidden latencies (all 21). as used in the Iterative Modulo Scheduler algorithm [3], or a field identifying the predicate under which the resource is reserved, as proposed in the Enhanced Modulo Scheduling scheme <ref> [2] </ref>. Because the number of entries tested to detect resource contentions is proportional to the number of resource usages over all reduced reservation tables, the primary objective of the selection heuristic is to minimize the number of resource usages in the reduced machine description.
Reference: [3] <author> B. R. Rau. </author> <title> Iterative Modulo Scheduling: An algorithm for software pipelining loops. </title> <booktitle> Proc. of the 27th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 63-74, </pages> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: Moreover, experimental results indicate that software pipelined loops can achieve higher throughput in less compilation time when some limited number of scheduling decisions can be reversed, as shown by Rau <ref> [3] </ref>, and used in numerous compilers [1][2][3][4][18]. The Multiflow 1 compiler also uses a backtracking mechanism to improve scalar code schedules [7]. The proposed approach also precisely handles basic block boundary conditions, i.e. the dangling resource requirements from predecessor basic blocks. <p> For example, this mechanism is a key component of the scheduling algorithm proposed by Rau to generate high performance software-pipelined loop schedules at a low level of computational complexity <ref> [3] </ref>. Using reservation tables, this mechanism can be easily implemented by keeping a mapping from each reserved resource to the scheduled operation that consumes it. <p> 9 9 9 9 average resource usages / operation 9.4 2.9 2.9 3.6 4.2 average word usages / operation 7.5 2.6 2.6 2.0 1.5 Table 2: Results for a subset of the Cydra 5: 12 operation classes, 166 forbidden latencies (all 21). as used in the Iterative Modulo Scheduler algorithm <ref> [3] </ref>, or a field identifying the predicate under which the resource is reserved, as proposed in the Enhanced Modulo Scheduling scheme [2]. <p> Assign&free. Unlike the previous function, the assign&free function first ensures that the resources consumed by operation X 7 are available. If any of the resources are already reserved by other operations, these operations (and possibly others <ref> [3] </ref>) will be unscheduled and their resources released. The function is implemented by adding a new field to each reserved table entry, identifying the operation that reserves the corresponding resource. The new field is used to determine which operation to unschedule, and is updated each time a resource is reserved. <p> We implemented a scheduler for software pipelined loops using the algorithm developed and described by Rau in <ref> [3] </ref>. This algorithm, referred to as the Iterative Modulo Scheduler, exploits the instruction level parallelism present in loop iterations by overlapping the execution of consecutiveiterations. <p> We see that in 95.6% of the loops, our implementation of the Iterative Modulo Scheduler produces a schedule with minimum initiation interval, i.e. achieving the maximum feasible steady-state throughput. This ratio is within 0.5% of that obtained in <ref> [3] </ref>. Measurements: min freq avg max number of operations 2.00 0.4% 17.54 161.00 initiation interval (II) 1.00 28.7% 11.52 165.00 II=M II 1.00 95.6% 1.01 1.50 sched. decisions / operation 1.00 78.7% 1.52 6.00 Table 5: Characteristics of the 1327 loop benchmark.
Reference: [4] <author> R. A. Huff. </author> <title> Lifetime-sensitive modulo scheduling. </title> <booktitle> Proc. of the ACM SIGPLAN'93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 258-267, </pages> <month> June </month> <year> 1993. </year>
Reference: [5] <author> J. R. Goodman and W.-C. Hsu. </author> <title> Code scheduling and register allocation in large basic blocs. </title> <booktitle> Proceedings of the International Conference on Supercomputing, </booktitle> <pages> pages 442-452, </pages> <year> 1988. </year>
Reference: [6] <author> K. Ebcioglu, R. D. Groves, K.-C. Kim, G. M. Silberman, and I. Ziv. </author> <title> VLIW compilation techniques in a superscalar environment. </title> <booktitle> In Proc. of the ACM SIGPLAN'94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 36-48. </pages> <year> 1994. </year>
Reference: [7] <author> G. P. Lowney et al. </author> <title> The Multiflow trace scheduling compiler. </title> <journal> In The Journal of Supercomputing, </journal> <volume> volume 7, </volume> <pages> pages 51-142, </pages> <year> 1993. </year>
Reference-contexts: The Multiflow 1 compiler also uses a backtracking mechanism to improve scalar code schedules <ref> [7] </ref>. The proposed approach also precisely handles basic block boundary conditions, i.e. the dangling resource requirements from predecessor basic blocks. In general, the resource requirements at the beginning of a basic block consist of the union of all the resource requirements dangling from predecessor basic blocks.
Reference: [8] <author> P. P. Chang, N. J. Warter, S. A. Mahlke, W. Y. Chen, and W. W. Hwu. </author> <title> Three architectural models for compiler-controlled speculative execution. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 44(4) </volume> <pages> 481-494, </pages> <month> April </month> <year> 1995. </year>
Reference: [9] <author> D. Bernstein and M. Rodeh. </author> <title> Global instruction scheduling for superscalar machines. </title> <booktitle> In Proc. of the ACM SIGPLAN'91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 241-255, </pages> <month> June </month> <year> 1991. </year>
Reference: [10] <author> S.-M. Moon and K. Ebcioglu. </author> <title> An efficient resource-constrained global scheduling technique for superscalar and VLIW processors. </title> <booktitle> Proc. of the 25th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 55-71, </pages> <month> Sept. </month> <year> 1992. </year>
Reference: [11] <author> P. P. Chang, S. A. Mahlke, W. Y. Chen, N. J. Warter, and W. W. Hwu. </author> <title> IMPACT: An architectural framework for multiple-instruction-issue processors. </title> <booktitle> In Proceedings of the Eighteenth Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 266-275, </pages> <month> May </month> <year> 1991. </year>
Reference: [12] <author> J. C. Gyllenhaal. </author> <title> A machine description language for compilation. </title> <type> Master's thesis, </type> <institution> Department of Electrical and Computer Engineering, University of Illinois, Urbana, IL, </institution> <year> 1994. </year>
Reference-contexts: in this cycle without resource contention? Typically, this functionality has been provided by a contention query module that processes the machine description of a target machine, generates an internal representation of the resource requirements, and provides for a querying mechanism [1][3][7][11]<ref> [12] </ref>[13]. The IMPACT compiler, for example, implemented such a module [12] to produce high performance schedules for a wide range of machines, from existing architectures such as X86, PA-RISC, and SPARC to research architectures such as PlayDoh [14].
Reference: [13] <author> J. A. Fisher. </author> <title> Trace scheduling: a technique for global microcode compaction. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 30(7) </volume> <pages> 478-490, </pages> <month> July </month> <year> 1981. </year>
Reference: [14] <author> V. Kathail, M. S. Schlansker, and B. R. Rau. </author> <title> HPL PlayDoh architecture specification: Version 1.0. </title> <type> Technical Report HPL-93-80, </type> <institution> HP Laboratories, </institution> <month> Feb. </month> <year> 1994. </year>
Reference-contexts: The IMPACT compiler, for example, implemented such a module [12] to produce high performance schedules for a wide range of machines, from existing architectures such as X86, PA-RISC, and SPARC to research architectures such as PlayDoh <ref> [14] </ref>. With the recent emphasis on exploiting instruction level parallelism, compile time is increasingly spent in the contention query module as several cycles of a schedule, possibly in several basic blocks [9][10], are queried per operation in order to achieve good schedules.
Reference: [15] <author> T. A. Proebsting and C. W. Fraser. </author> <title> Detecting pipeline structural hazards quickly. </title> <booktitle> Twenty-First Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 280-286, </pages> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: As a result, recent advances favor finite-state automata approaches. In this paper, however, we propose a reduced reservation table approach that eliminates much of the redundancy and does not suffer from the limitations of the automata approaches, as detailed below. Proebsting and Fraser <ref> [15] </ref> as well as Muller [16] proposed a contention query module using a finite-state automaton that recognizes all contention-free schedules. The technique proposed by Proebsting and Fraser directly results in minimal finite-state automata [15]. <p> Proebsting and Fraser <ref> [15] </ref> as well as Muller [16] proposed a contention query module using a finite-state automaton that recognizes all contention-free schedules. The technique proposed by Proebsting and Fraser directly results in minimal finite-state automata [15]. This approach was recently extended for unrestricted scheduling models by Bala and Rubin using a forward and reverse pair of automata [17]. In their approach, operations considered in order of monotonically increasing (or decreasing) schedule time are quickly scheduled using a forward automaton. <p> A potential problem of this approach, however, is the size of these automata. This issue is addressed in the literature in three ways. First, operations of a target machine can be combined into classes of operations that have compatible resource contentions <ref> [15] </ref>. Second, large automata can be factored into sets of smaller ones [16][17], reducing the size of the automata, but increasing the number of table lookups necessary to process a contention query. <p> Figure 1b illustrates this matrix computed for our example machine. While these sets are computed for each operation of the target machine, we need list these sets only for each operation class, as presented by Proebsting and Fraser <ref> [15] </ref>. In general, two operations belong to the same operation class if they have the same sets of forbidden latencies, i.e. operations X and Y belong to the same class if F X;Z = F Y;Z and F Z;X = F Z;Y for each operation Z of the target machine. <p> It is significantly larger than the machine descriptions used in previous studies, e.g. it has 3.5 times more operation classes and 2.4 times more forbidden latencies than the MIPS R3000/R3010 machine description used in <ref> [15] </ref>. Our algorithm reduced this original Cydra 5 machine description in less than 11 minutes on a SPARC-20. Table 1 presents data for four reduced machine descriptions and the original description of the Cydra 5. <p> Table 4 shows the results of our technique for the MIPS R3000/- R3010 [20] using the machine description presented by Proebsting and Fraser <ref> [15] </ref>. Comparing the original description to the specific 64 bit word bitvector reduction, the reduced machine description decreases the average word usage by a factor of 6.9. Proebsting and Fraser reported a (forward-only) finite-state automaton for this processor with 6175 states [15]. 7 Contention Query Module To evaluate the impact of <p> using the machine description presented by Proebsting and Fraser <ref> [15] </ref>. Comparing the original description to the specific 64 bit word bitvector reduction, the reduced machine description decreases the average word usage by a factor of 6.9. Proebsting and Fraser reported a (forward-only) finite-state automaton for this processor with 6175 states [15]. 7 Contention Query Module To evaluate the impact of reduced machine descriptions on the performance of contention queries, we implemented a contention query module for the two representations described in Section 5.
Reference: [16] <author> T. M uller. </author> <title> Employing finite automata for resource scheduling. </title> <booktitle> Proc. of the 26th Annual International Symposium on Mi-croarchitecture, </booktitle> <pages> pages 12-20, </pages> <year> 1993. </year>
Reference-contexts: As a result, recent advances favor finite-state automata approaches. In this paper, however, we propose a reduced reservation table approach that eliminates much of the redundancy and does not suffer from the limitations of the automata approaches, as detailed below. Proebsting and Fraser [15] as well as Muller <ref> [16] </ref> proposed a contention query module using a finite-state automaton that recognizes all contention-free schedules. The technique proposed by Proebsting and Fraser directly results in minimal finite-state automata [15].
Reference: [17] <author> V. Bala and N. Rubin. </author> <title> Efficient instruction scheduling using finite state automata. </title> <booktitle> Proc. of the 28th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 46-56, </pages> <month> Nov. </month> <year> 1995. </year>
Reference-contexts: The technique proposed by Proebsting and Fraser directly results in minimal finite-state automata [15]. This approach was recently extended for unrestricted scheduling models by Bala and Rubin using a forward and reverse pair of automata <ref> [17] </ref>. In their approach, operations considered in order of monotonically increasing (or decreasing) schedule time are quickly scheduled using a forward automaton. Additional operations are then inserted in the schedule in cycles recognized as contention-free by the forward and reverse automata. <p> Their approach also addresses the handling of basic block boundary conditions at the cost of potentially introducing up to O (s 2 ) new states in the automata, where s is the number of cycle-advancing states in the original automata <ref> [17] </ref>. The principal advantage of automaton-based approaches is that a single table lookup can determine the next contention-free cycle. A potential problem of this approach, however, is the size of these automata. This issue is addressed in the literature in three ways. <p> Second, large automata can be factored into sets of smaller ones [16]<ref> [17] </ref>, reducing the size of the automata, but increasing the number of table lookups necessary to process a contention query. Third, the number of additional states introduced in the automata to handle boundary conditions can be reduced [17], at the cost of making conservative approximations. However, new experimental evidence that was gathered by Bala and Rubin [23] for the Alpha, PA RISC, and MIPS families indicates that, in practice, no additional state is introduced to precisely handle boundary conditions, when minimal finite-state automata are constructed. <p> In addition to storing the descriptions of the two automata, two states per operation must be stored, which may result in a large memory overhead, especially for wide-issue machines. Supporting unrestricted scheduling models also requires the consistency of the stored state to be maintained when scheduling additional operations <ref> [17] </ref>, as inserted operations introduce additional resource requirements. Thus, handling unrestricted scheduling models introduces both memory and computation overhead that is similar to, or may exceed, the overhead incurred by the reservation table approach. A more detailed comparison is provided in Sections 6 and 8. <p> Table 3 shows the results of our technique for the DEC Alpha 21064 [19] using the machine description presented by Bala and Rubin <ref> [17] </ref>. Comparing the original description to the specific reduction for a 64 bit word bitvector representation, the average word usage is decreased by a factor of 5.8.
Reference: [18] <author> M. Lam. </author> <title> Software Pipelining: An effective scheduling technique for VLIW machines. </title> <booktitle> Proc. of the ACM SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 318-328, </pages> <month> June </month> <year> 1988. </year>
Reference: [19] <institution> Digital Equipment Corp., Maynard, </institution> <address> MA. </address> <note> DecChip 21064 Microprocessor Hardware Reference Manual EC-N0079-72. </note>
Reference-contexts: Using our approach, the resource requirements can be expressed in terms close to the actual hardware structure of the target machine and the reduced machine description used by the compiler is generated in an error-free and automated fashion. Experiments with the DEC Alpha 21064 <ref> [19] </ref>, MIPS R3000/- R3010 [20], and Cydra 5 [21] machines indicate 4 to 7 times faster contention queries and require 22 to 90% of the memory storage used by the original machine descriptions. <p> The reservation tables associated with the machine descriptions of the original model, the discrete reduction, and the 64 bit word bitvector reduction are shown, respectively, in Figures 4a, 4b, and 4c. Table 3 shows the results of our technique for the DEC Alpha 21064 <ref> [19] </ref> using the machine description presented by Bala and Rubin [17]. Comparing the original description to the specific reduction for a 64 bit word bitvector representation, the average word usage is decreased by a factor of 5.8.
Reference: [20] <author> G. Kane and J. Heinrich. </author> <title> MIPS RISC Architecture. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: Using our approach, the resource requirements can be expressed in terms close to the actual hardware structure of the target machine and the reduced machine description used by the compiler is generated in an error-free and automated fashion. Experiments with the DEC Alpha 21064 [19], MIPS R3000/- R3010 <ref> [20] </ref>, and Cydra 5 [21] machines indicate 4 to 7 times faster contention queries and require 22 to 90% of the memory storage used by the original machine descriptions. These improvements are obtained by using highly reduced machine descriptions instead of the original or manually optimized machine descriptions. <p> Table 4 shows the results of our technique for the MIPS R3000/- R3010 <ref> [20] </ref> using the machine description presented by Proebsting and Fraser [15]. Comparing the original description to the specific 64 bit word bitvector reduction, the reduced machine description decreases the average word usage by a factor of 6.9.
Reference: [21] <author> G. R. Beck, D. W. L. Yen, and T. L. Anderson. </author> <title> The Cydra 5 mini-supercomputer: Architecture and implementation. </title> <journal> In The Journal of Supercomputing, </journal> <volume> volume 7, </volume> <pages> pages 143-180, </pages> <year> 1993. </year>
Reference-contexts: Experiments with the DEC Alpha 21064 [19], MIPS R3000/- R3010 [20], and Cydra 5 <ref> [21] </ref> machines indicate 4 to 7 times faster contention queries and require 22 to 90% of the memory storage used by the original machine descriptions. These improvements are obtained by using highly reduced machine descriptions instead of the original or manually optimized machine descriptions. <p> A more detailed performance analysis of the contention query module is presented in Section 8. As a proof of concept, we investigated our technique on the Cy-dra 5 machine <ref> [21] </ref> which has the most complex resource requirements of the three machines. The machine configuration investigated here has 7 functional units: 2 memory port, 2 address generation, 1 FP adder, 1 FP multiplier, and 1 branch unit.
Reference: [22] <author> E. S. Davidson, L. E. Shar, A. T. Thomas, and J. H. Patel. </author> <title> Effective control for pipelined computers. </title> <booktitle> Spring COMPCON-75 digest of papers, </booktitle> <pages> pages 181-184, </pages> <month> Feb. </month> <year> 1975. </year>
Reference-contexts: We present our conclusions in Section 9. 2 Related Work Resource contention in multipipeline scheduling may be based directly on reservation tables, or on the forbidden latency sets or contention-recognizing state machines derived from them, as introduced by Davidson et al <ref> [22] </ref>. Traditionally, reservation tables contain much redundant information that consumes memory and increases query response time. As a result, recent advances favor finite-state automata approaches.
Reference: [23] <author> V. Bala. </author> <type> Personal communication. </type> <month> Feb. </month> <year> 1996. </year>
Reference-contexts: Third, the number of additional states introduced in the automata to handle boundary conditions can be reduced [17], at the cost of making conservative approximations. However, new experimental evidence that was gathered by Bala and Rubin <ref> [23] </ref> for the Alpha, PA RISC, and MIPS families indicates that, in practice, no additional state is introduced to precisely handle boundary conditions, when minimal finite-state automata are constructed.
Reference: [24] <author> J. H. Patel and E. S. Davidson. </author> <title> Improving the throughput of a pipeline by insertion of delays. </title> <booktitle> Proceedings of the Third Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 159-164, </pages> <year> 1976. </year>
Reference-contexts: Step 2. We build the generating set of maximal resources which is defined as a set of resources that contains all maximal resources 3 associated with the target machine <ref> [24] </ref>.
Reference: [25] <author> M. Berry et al. </author> <title> The Perfect Club Benchmarks: Effective performance evaluation of supercomputers. </title> <journal> The International Journal of Supercomputer Applications, </journal> <volume> 3(3) </volume> <pages> 5-40, </pages> <month> Fall </month> <year> 1989. </year>
Reference-contexts: For the Cydra 5 machine descriptions, we also verified that precisely the same schedules were produced regardless of the machine description used by the compiler when scheduling a benchmark suite of 1327 loops obtained from the Perfect Club <ref> [25] </ref>, SPEC-89 [26], and the Livermore Fortran Kernels [27]. <p> The algorithm satisfies the definition of the unrestricted scheduling model since it schedules operations in arbitrary order and may reverse scheduling decisions. We used a benchmark of loops obtained from the Perfect Club <ref> [25] </ref>, SPEC-89 [26], and the Livermore Fortran Kernels [27] which consists exclusively of innermost loops with no early exits, no procedure calls, and fewer than 30 basic blocks, as compiled by the Cydra 5 Fortran77 compiler [1].
Reference: [26] <author> J. Uniejewski. </author> <title> SPEC Benchmark Suite: Designed for today's advanced system. </title> <journal> SPEC Newsletter, </journal> <month> Fall </month> <year> 1989. </year>
Reference-contexts: For the Cydra 5 machine descriptions, we also verified that precisely the same schedules were produced regardless of the machine description used by the compiler when scheduling a benchmark suite of 1327 loops obtained from the Perfect Club [25], SPEC-89 <ref> [26] </ref>, and the Livermore Fortran Kernels [27]. <p> The algorithm satisfies the definition of the unrestricted scheduling model since it schedules operations in arbitrary order and may reverse scheduling decisions. We used a benchmark of loops obtained from the Perfect Club [25], SPEC-89 <ref> [26] </ref>, and the Livermore Fortran Kernels [27] which consists exclusively of innermost loops with no early exits, no procedure calls, and fewer than 30 basic blocks, as compiled by the Cydra 5 Fortran77 compiler [1].
Reference: [27] <author> F. H. McMahon. </author> <title> The Livermore Fortran Kernels: A computer test of the numerical performance range. </title> <type> Technical Report UCRL-53745, </type> <institution> Lawrence Livermore National Laboratory, Livermore, California, </institution> <year> 1986. </year>
Reference-contexts: For the Cydra 5 machine descriptions, we also verified that precisely the same schedules were produced regardless of the machine description used by the compiler when scheduling a benchmark suite of 1327 loops obtained from the Perfect Club [25], SPEC-89 [26], and the Livermore Fortran Kernels <ref> [27] </ref>. <p> The algorithm satisfies the definition of the unrestricted scheduling model since it schedules operations in arbitrary order and may reverse scheduling decisions. We used a benchmark of loops obtained from the Perfect Club [25], SPEC-89 [26], and the Livermore Fortran Kernels <ref> [27] </ref> which consists exclusively of innermost loops with no early exits, no procedure calls, and fewer than 30 basic blocks, as compiled by the Cydra 5 Fortran77 compiler [1]. The input to the scheduling algorithms consists of the Fortran77 compiler intermediate representation after load-store elimination, recurrence back-substitution, and IF-conversion.
Reference: [28] <author> M. S. Schlansker. </author> <type> Personal communication. </type> <month> June </month> <year> 1995. </year>
Reference-contexts: The original machine description used by the Cydra 5 Fortran77 compiler [1] was manually optimized, i.e. some physical resources were eliminated from the machine description as they did not introduce any new forbidden latencies <ref> [28] </ref>. This description models 56 resources and 152 distinct patterns of resource usages, resulting in 52 distinct operation classes with 10223 forbidden latencies.
Reference: [29] <author> P. Y. Hsu. </author> <title> Highly Concurrent Scalar Processing. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1986. </year> <pages> 10 11 </pages>
References-found: 29

