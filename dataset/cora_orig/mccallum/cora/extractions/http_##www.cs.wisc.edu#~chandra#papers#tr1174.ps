URL: http://www.cs.wisc.edu/~chandra/papers/tr1174.ps
Refering-URL: http://www.cs.wisc.edu/~chandra/pubs.html
Root-URL: 
Email: larus@cs.wisc.edu  
Title: Using Tracing and Dynamic Slicing to Tune Compilers  
Author: James R. Larus and Satish Chandra 
Note: This work was supported in part by the National Science Foundation under grant CCR-9101035 and by the Wisconsin Alumni Research Foundation.  
Date: August 26, 1993  
Address: 1210 West Dayton Street Madison, WI 53706, USA  
Affiliation: Computer Sciences Department University of Wisconsin-Madison  
Abstract: Performance tuning improves a compiler's performance by detecting errors and missed opportunities in its analysis, optimization, and code generation stages. Normally, a compiler's author tunes it by examining the generated code to find suboptimal code sequences. This paper describes a collection of tools, called compiler auditors, that assist a compiler writer by partially mechanizing the process of finding suboptimal code sequences. Although these code sequences do not always exhibit compiler bugs, they frequently illustrate problems in a compiler. Experiments show that auditors effectively find suboptimal code, even in a high-quality, commercial compiler. After writing a high-quality compiler, its authors improve it with the time-consuming and tedious process of examining generated assembly code to find inefficient code sequences that could run faster or consume less space. These sequences direct a compiler writer's attention to places in the compiler at which improved analysis, optimization, or code generation would result in better code. Typically a compiler writer finds this suboptimal code by reading assembly-language listings of compiled code (see, for example Briggs [6]). Performance tuning of this sort is unavoidable for two reasons. Compilers are large and complex programs that will contain bugs that affect the performance, but not correctness, of generated code. More fundamentally, compiler writing is an art in which the insight necessary for effective heuristics arise from identifying past mistakes. This paper describes a technique for partially automating the tedious process of detecting suboptimal code. In this approach, specialized programs, called compiler auditors, examine a complete instruction and data trace of a compiled test program and dynamically detect sequences of executed instructions that could have been compiled better. The auditor reports these sequences to the compiler writer, who still must examine the designated portions of the compiled program to determine if the code can be improved and how to modify the compiler. The advantage of compiler auditing is that auditors direct a compiler writer's attention to performance problems faster than a manual search and more reliably than intuition. Information and feedback from tools of this sort can reduce the time and effort required to produce a mature, fl University of Wisconsin Computer Sciences Department Technical Report #1174
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Hiralal Agrawal and Joseph R. Horgan. </author> <title> Dynamic Program Slicing. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 246-256, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: This process was expensive and required several person-months per benchmark [16]. Another alternative is to examine the stream of instructions when a program executes. An auditor can either use this stream to directly identify inefficient sequences or it can construct a dynamic program slice to find redundant computations <ref> [1] </ref>. This process has the advantages that it is cheaply and easily mechanizable, does not require sophisticated static analysis, and concentrates on frequently-executed traces in a program. On the other hand, this approach changes the definition of suboptimal.
Reference: [2] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1985. </year>
Reference-contexts: An operand of expression E may be a memory location. No general technique can determine if the location is modified in some execution of the loop. However, we can easily check if the code motion is profitable by testing whether PC1 dominates all loop exits <ref> [2] </ref>. 2.5 Tools for Validation The previous discussion shows that classification of auditor reports can only be partially automated. In the end, the compiler writer must examine the compiler's output at the points identified by an auditor.
Reference: [3] <author> Thomas Ball and James R. Larus. </author> <title> Optimally Profiling and Tracing Programs. </title> <booktitle> In Conference Record of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 59-70, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: On other paths through the program, the code sequence may be optimal. Consequently, a code sequences does not demonstrate a compiler bug, rather it illustrates a 2 shortcomings in the compiler that compiled the program. The trace is produced by the qpt tracing system <ref> [13, 3] </ref>. potential problem. However, the hypothesis of this work|justified by the evidence in Section 3| is that if a code sequence is suboptimal for one execution, it is likely to always be suboptimal. <p> Finally, Section 4 discusses related work. 1 Auditing Although different auditors operate differently, they function in the common framework shown in Figure 1. The compiler being audited compiles a test program (test-prog.c) into an executable file (test-prog). The qpt tracing system <ref> [3, 12, 13] </ref> instruments the executable file so it writes a highly-condensed trace file (test-prog.QTrace). qpt also produces a trace regeneration program (test-prog-regen.c) that reads the condensed trace and emits a stream of events: execution of an instruction (with its address and line number); basic block entry (with its address); read
Reference: [4] <author> William Blume and Rudolf Eigemann. </author> <title> Performance Analysis of Parallelizing Compilers on the Perfect Benchmarks Programs. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 3(6) </volume> <pages> 643-656, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Finally, when applied to a compiler's assembly output, this approach misses inefficiencies introduced at lower levels such as the assembler and linker. As an example, a group at CSRD examined the Cedar parallelizer to determine why it could not restructure the Perfect Club benchmarks <ref> [4, 10] </ref>. This process was expensive and required several person-months per benchmark [16]. Another alternative is to examine the stream of instructions when a program executes.
Reference: [5] <author> Mickey R. Boyd and David B. Whalley. </author> <title> Isolation and Analysis of Optimization Errors. </title> <booktitle> In Proceedings of the SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 26-35, </pages> <month> June </month> <year> 1993. </year> <month> 15 </month>
Reference-contexts: The most serious restriction|which had little effect since the compiler had a similar restriction|was that loops had to be data independent. Compiler auditing, on the other hand, works for any program. Boyd and Whalley <ref> [5] </ref> also developed a tool, vpoiso, for detecting errors in a compiler's optimizer. vpoiso automates a binary search for the optimization phase that performed a non-semantic-preserving transformation by selectively disabling optimizations and comparing the resulting program's output against the unoptimized program's output.
Reference: [6] <author> Preston Briggs, Keith D. Cooper, Ken Kennedy, and Linda Torczon. </author> <title> Coloring Heuristics for Register Alloca--tion. </title> <booktitle> In Proceedings of the SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 275-284, </pages> <month> June 89. </month>
Reference-contexts: These sequences direct a compiler writer's attention to places in the compiler at which improved analysis, optimization, or code generation would result in better code. Typically a compiler writer finds this suboptimal code by reading assembly-language listings of compiled code (see, for example Briggs <ref> [6] </ref>). Performance tuning of this sort is unavoidable for two reasons. Compilers are large and complex programs that will contain bugs that affect the performance, but not correctness, of generated code.
Reference: [7] <author> Fred C. Chow and John L. Hennessy. </author> <title> The Priority-Based Coloring Approach to Register Allocation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(4) </volume> <pages> 501-536, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: The MIPS compilers are generally regarded to be high-quality compilers that perform most standard optimizations including common subex-pression elimination, loop invariant code motion, and graph-coloring register allocation <ref> [7] </ref>. To test a high quality compiler (high), test programs were compiled at -O2, which performs all intraprocedural optimizations. To simulate a low quality compiler (low), the test programs were compiled at -O0, which performs no optimization. In all experiments, we did not audit library code to save time.
Reference: [8] <author> Jack W. Davidson and Christopher W. Fraser. </author> <title> Code Selection through Object Code Optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 6(4) </volume> <pages> 505-526, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: Suboptimal code can be detected either by statically examining generated instructions or by dynamically examining a program trace. The first alternative is the basis of many compilers, which operate by generating simple code and then improve it by identifying and replacing suboptimal code (e.g., <ref> [8, 18] </ref>). Compiler writers typically tune their compilers by applying the same process in a more intuitive and ad-hoc way on the compiled code.
Reference: [9] <author> Evelyn Duesterwald, Rajiv Gupta, and Mary Lou Soffa. </author> <title> A Practical Data Flow Framework for Array Reference Analysis and its Use in Optimization. </title> <booktitle> In Proceedings of the SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 68-77, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: An apparently redundant operation may be necessary along other, unexecuted paths or the redundancy may be impractical to detect statically. Nevertheless, redundancies can elucidate shortcomings in various parts of a compiler. For example, common subexpression elimination (CSE) should eliminate redundant loads. Dead-store elimination should remove unnecessary stores <ref> [9] </ref> and a register allocator need not store an unmodified, spilled value. A register spill while another register holds a dead value indicates that the register allocator unnecessarily spilled a value along at least one path.
Reference: [10] <author> Rudolf Eigenmann, Jay Hoeflinger, Zhiyuan Li, and David Padua. </author> <title> Experience in the Automatic Paralleliza-tion of Four Perfect-Benchmark Programs. </title> <editor> In Utpal Banerjee, David Gelernter, Alex Nicolau, and David Padua, editors, </editor> <booktitle> Proceedings of the Fourth Workshop on Languages and Compilers for Parallel Computing. </booktitle> <publisher> MIT Press, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: Finally, when applied to a compiler's assembly output, this approach misses inefficiencies introduced at lower levels such as the assembler and linker. As an example, a group at CSRD examined the Cedar parallelizer to determine why it could not restructure the Perfect Club benchmarks <ref> [4, 10] </ref>. This process was expensive and required several person-months per benchmark [16]. Another alternative is to examine the stream of instructions when a program executes.
Reference: [11] <author> Susan Horwitz, Jan Prins, and Thomas Reps. </author> <title> On the Adequacy of Program Dependence Graphs for Representing Programs. </title> <booktitle> In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 146-157, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: [d] e; On function entry: for i 0 to max reg no do if reg [i] is callee-saved then save reg [i]; else reg [i] null; On function exit: for i 0 to max reg no do if reg [i] is callee-saved then restore reg [i]; else reg [i] null; <ref> [11] </ref>. To detect loop-invariant code, each DAG node is labeled with the shallowest dynamic loop nesting depth at which it could be calculated. Loop invariant code has a nesting depth less than the current loop's nesting depth. new expression DAG from the expression DAGs of its operands.
Reference: [12] <author> James R. Larus. </author> <title> Abstract Execution: A Technique for Efficiently Tracing Programs. </title> <journal> Software Practice & Experience, </journal> 20(12) 1241-1258, December 1990. 
Reference-contexts: Finally, Section 4 discusses related work. 1 Auditing Although different auditors operate differently, they function in the common framework shown in Figure 1. The compiler being audited compiles a test program (test-prog.c) into an executable file (test-prog). The qpt tracing system <ref> [3, 12, 13] </ref> instruments the executable file so it writes a highly-condensed trace file (test-prog.QTrace). qpt also produces a trace regeneration program (test-prog-regen.c) that reads the condensed trace and emits a stream of events: execution of an instruction (with its address and line number); basic block entry (with its address); read
Reference: [13] <author> James R. Larus. </author> <title> Efficient Program Tracing. </title> <journal> IEEE Computer, </journal> <volume> 26(5) </volume> <pages> 52-61, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: On other paths through the program, the code sequence may be optimal. Consequently, a code sequences does not demonstrate a compiler bug, rather it illustrates a 2 shortcomings in the compiler that compiled the program. The trace is produced by the qpt tracing system <ref> [13, 3] </ref>. potential problem. However, the hypothesis of this work|justified by the evidence in Section 3| is that if a code sequence is suboptimal for one execution, it is likely to always be suboptimal. <p> Finally, Section 4 discusses related work. 1 Auditing Although different auditors operate differently, they function in the common framework shown in Figure 1. The compiler being audited compiles a test program (test-prog.c) into an executable file (test-prog). The qpt tracing system <ref> [3, 12, 13] </ref> instruments the executable file so it writes a highly-condensed trace file (test-prog.QTrace). qpt also produces a trace regeneration program (test-prog-regen.c) that reads the condensed trace and emits a stream of events: execution of an instruction (with its address and line number); basic block entry (with its address); read
Reference: [14] <author> Timothy S. McNerney. </author> <title> Verifying the Correctness of Compiler Transformations on Basic Blocks using Abstract Interpretation. </title> <booktitle> In Symposium on Partial Evaluation and Semantics-Based Program Manipulation (PEPM'91), </booktitle> <pages> pages 106-115, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Placing scalar variables first in a stack frame would correct the problem. 14 4 Related Work McNerney used an abstract interpretation to validate optimizations in a compiler for the Thinking Machines CM-2 <ref> [14] </ref>. He statically analyzed the compiler's intermediate form for a program to show equivalence between unoptimized and optimized code. Like this work, he did not prove properties about the compiler, but merely demonstrated the absence of errors for a particular input.
Reference: [15] <author> E. Morel and C. </author> <title> Renvoise. Global Optimization by Suppression of Partial Redundancies. </title> <journal> Communications of the ACM, </journal> <volume> 22(2) </volume> <pages> 96-103, </pages> <month> February </month> <year> 1979. </year>
Reference-contexts: Finding a dependence between the store and load instruction requires higher-level semantic information; for example, array indices from their respective statements [19]. Checking for partial redundancy <ref> [15] </ref> generalizes the validity test. PC1 may not dominate PC2, but r may hold the contents of M at PC2 along all paths from the entry point. This criteria also runs into a similar problem since any store instruction along a path to PC2 may modify M.
Reference: [16] <author> David Padua. </author> <title> email message. </title> <type> Personal Communication, </type> <month> November </month> <year> 1991. </year>
Reference-contexts: As an example, a group at CSRD examined the Cedar parallelizer to determine why it could not restructure the Perfect Club benchmarks [4, 10]. This process was expensive and required several person-months per benchmark <ref> [16] </ref>. Another alternative is to examine the stream of instructions when a program executes. An auditor can either use this stream to directly identify inefficient sequences or it can construct a dynamic program slice to find redundant computations [1].
Reference: [17] <author> Jay M. Spitzen, Karl N.Levitt, and Lawrence Robinson. </author> <title> An Example of Hierarchical Design and Proof. </title> <journal> Communications of the ACM, </journal> <volume> 21(12) </volume> <pages> 1064-1075, </pages> <month> December </month> <year> 1978. </year>
Reference-contexts: Only expressions for callee-saved registers are preserved across call boundaries. This process can be efficiently implemented with the techniques of hash consing and reference counting. Hash consing uses a hash table to map an operator-operand-operand triple to a unique DAG node <ref> [17] </ref>. 2 The benefit of uniquely representing nodes is that equality testing reduces to 2 Hash consing can canonicalize arguments to commutative and associative operators. The auditor used for Section 3 does not canonicalize operations. 7 pointer equality.
Reference: [18] <author> Richard M. Stallman. </author> <title> Using and Porting GNU CC. Free Software Foundation, </title> <month> September </month> <year> 1989. </year>
Reference-contexts: Suboptimal code can be detected either by statically examining generated instructions or by dynamically examining a program trace. The first alternative is the basis of many compilers, which operate by generating simple code and then improve it by identifying and replacing suboptimal code (e.g., <ref> [8, 18] </ref>). Compiler writers typically tune their compilers by applying the same process in a more intuitive and ad-hoc way on the compiled code.
Reference: [19] <author> Steven W.K. Tjiang, Michael E. Wolf, Monica S. Lam, Karen L. Pieper, and John L. Hennessy. </author> <title> Integrating Scalar Optimization and Parallelization. </title> <booktitle> In Proceedings of the Fourth Workshop on Languages and Compilers for Parallel Computing, pages C1-C16, </booktitle> <address> Santa Clara, California, </address> <month> August </month> <year> 1991. </year> <month> 16 </month>
Reference-contexts: Finally, we can make observations from the base-offset pairs in store instructions, but no general technique will 10 determine if a store instruction can modify M . Finding a dependence between the store and load instruction requires higher-level semantic information; for example, array indices from their respective statements <ref> [19] </ref>. Checking for partial redundancy [15] generalizes the validity test. PC1 may not dominate PC2, but r may hold the contents of M at PC2 along all paths from the entry point.
References-found: 19

