URL: http://www.cs.rice.edu:80/~sethi/lcpc96.ps.gz
Refering-URL: http://www.cs.rice.edu:80/~sethi/publications.html
Root-URL: 
Title: Resource-Based Communication Placement Analysis  
Author: Ken Kennedy and Ajay Sethi 
Address: 6100 Main Street, MS 41, Houston, TX 77005  
Affiliation: Center for Research on Parallel Computation Department of Computer Science, Rice University  
Abstract: Communication placement analysis is an important step in the compilation of data-parallel programs. However, to simplify the placement analysis, previous techniques ignored most machine-dependent resource constraints. This paper demonstrates the necessity of incorporating resource constraints in ensuring the correctness of the communication placement. It presents a new placement analysis technique that minimizes frequency of communication, eliminates redundant communication, and maximizes communication latency hiding while taking limited resources into account. The paper illustrates resource-based placement analysis in the context of placement of distributed-memory communication primitives and limited buffer size resource constraint. In addition, it shows the use of stripmining transformation in improving the efficacy of resource-based communication placement.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. V. Aho, R. Sethi, and J. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <note> second edition, </note> <year> 1986. </year>
Reference-contexts: This decreases the memory requirement by 196 KB and the resulting program fits in the memory. In Sections 4 - 7, we describe the placement analysis that handles the above-mentioned issues. 3 Interval-Flow Graph Our communication placement algorithm (Section 4) is based on interval analysis <ref> [1] </ref>. Interval analysis incorporates program structure into data-flow equations to enable their non-iterative and efficient solution. However, unlike classical interval analysis, we do not construct a sequence of interval graphs by recursively collapsing intervals into single nodes.
Reference: 2. <author> S. Amarasinghe and M. Lam. </author> <title> Communication optimization and code generation for distributed memory machines. </title> <booktitle> In Proceedings of the SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <address> Albuquerque, NM, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Under the assumption that O (E) is the same as the order of the program size [8], our algorithm has linear time complexity. 9 Related Work The problem of data-flow based communication generation and placement has been addressed by several researchers <ref> [5, 4, 2] </ref>. However, data-flow placement frameworks to eliminate partial redundancies across loop nests were developed only recently [8, 7]. To the best of our knowledge, ours is the first effort to take resource constraints into account during communication placement.
Reference: 3. <author> M. Garey and D. Johnson. </author> <title> Computers and Intractability, A Guide to the Theory of NP-Completeness. </title> <editor> W. H. </editor> <publisher> Freeman and Co., </publisher> <address> New York, NY, </address> <year> 1979. </year>
Reference-contexts: This problem is very similar to the ones encountered in scheduling and file allocation problems <ref> [3] </ref> and can be similarly shown to be NP-complete: the knapsack problem [3] can be reduced to the problem of optimally selecting the messages that should use the available buffer at any given node. <p> This problem is very similar to the ones encountered in scheduling and file allocation problems <ref> [3] </ref> and can be similarly shown to be NP-complete: the knapsack problem [3] can be reduced to the problem of optimally selecting the messages that should use the available buffer at any given node. The knapsack problem is a classical problem in operations research where a scarce resource (here, the non-local buffer) needs to be allocated among a number of competing users.
Reference: 4. <author> C. Gong, R. Gupta, and R. Melhem. </author> <title> Compilation techniques for optimizing communication on distributed-memory systems. </title> <booktitle> In Proceedings of the 1993 International Conference on Parallel Processing, </booktitle> <address> St. Charles, IL, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: The content of this paper does not necessarily reflect the position or the policy of the Government, and no official en dorsement should be inferred. be achieved by initiating communication as early as possible. This exposes op-portunities for overlapping communication with some intervening computation. There have been several efforts <ref> [5, 4, 7, 8] </ref> to use data-flow analysis to determine communication placement that minimizes communication overhead. However, to reduce the complexity of the problem being solved, previous frameworks ignored most machine-dependent resource constraints. This paper introduces a new framework for resource-based communication placement, which takes limited resources into account. <p> Under the assumption that O (E) is the same as the order of the program size [8], our algorithm has linear time complexity. 9 Related Work The problem of data-flow based communication generation and placement has been addressed by several researchers <ref> [5, 4, 2] </ref>. However, data-flow placement frameworks to eliminate partial redundancies across loop nests were developed only recently [8, 7]. To the best of our knowledge, ours is the first effort to take resource constraints into account during communication placement.
Reference: 5. <author> E. Granston and A. Veidenbaum. </author> <title> Detecting redundant accesses to array data. </title> <booktitle> In Proceedings of Supercomputing '91, </booktitle> <address> Albuquerque, NM, </address> <month> November </month> <year> 1991. </year>
Reference-contexts: The content of this paper does not necessarily reflect the position or the policy of the Government, and no official en dorsement should be inferred. be achieved by initiating communication as early as possible. This exposes op-portunities for overlapping communication with some intervening computation. There have been several efforts <ref> [5, 4, 7, 8] </ref> to use data-flow analysis to determine communication placement that minimizes communication overhead. However, to reduce the complexity of the problem being solved, previous frameworks ignored most machine-dependent resource constraints. This paper introduces a new framework for resource-based communication placement, which takes limited resources into account. <p> Under the assumption that O (E) is the same as the order of the program size [8], our algorithm has linear time complexity. 9 Related Work The problem of data-flow based communication generation and placement has been addressed by several researchers <ref> [5, 4, 2] </ref>. However, data-flow placement frameworks to eliminate partial redundancies across loop nests were developed only recently [8, 7]. To the best of our knowledge, ours is the first effort to take resource constraints into account during communication placement.
Reference: 6. <author> T. Gross and P. Steenkiste. </author> <title> Structured dataflow analysis for arrays and its use in an optimizing compiler. </title> <journal> Software|Practice and Experience, </journal> <volume> 20(2) </volume> <pages> 133-155, </pages> <month> Febru-ary </month> <year> 1990. </year>
Reference-contexts: Also, with each node n and descriptor d, we associate Used (n; d) and Transp (n; d) predicates. Used (n; d)/Transp (n; d) indicate whether the data section corresponding to d is used at/not modified at n. We use array section analysis <ref> [6] </ref> to compare data sections precisely. If the data section corresponding to d is used (not modified) at n, we initialize Used (n; d) (Transp (n; d)) to &gt;; and to ? otherwise. We use the semi-lattice L = f?; UNBAL; &gt;g.
Reference: 7. <author> M. Gupta, E. Schonberg, and H. Srinivasan. </author> <title> A unified data-flow framework for optimizing communication. </title> <booktitle> In Proceedings of the Seventh Workshop on Languages and Compilers for Parallel Computing, </booktitle> <address> Ithaca, NY, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: The content of this paper does not necessarily reflect the position or the policy of the Government, and no official en dorsement should be inferred. be achieved by initiating communication as early as possible. This exposes op-portunities for overlapping communication with some intervening computation. There have been several efforts <ref> [5, 4, 7, 8] </ref> to use data-flow analysis to determine communication placement that minimizes communication overhead. However, to reduce the complexity of the problem being solved, previous frameworks ignored most machine-dependent resource constraints. This paper introduces a new framework for resource-based communication placement, which takes limited resources into account. <p> However, data-flow placement frameworks to eliminate partial redundancies across loop nests were developed only recently <ref> [8, 7] </ref>. To the best of our knowledge, ours is the first effort to take resource constraints into account during communication placement. Our framework is based on Lazy Code Motion (LCM) technique [10]. Besides incorporating resources, we extended the LCM technique to determine non-atomic and balanced placement.
Reference: 8. <author> R. v. Hanxleden and K. Kennedy. </author> <title> Give-N-Take | A balanced code placement framework. </title> <booktitle> In Proceedings of the SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: The content of this paper does not necessarily reflect the position or the policy of the Government, and no official en dorsement should be inferred. be achieved by initiating communication as early as possible. This exposes op-portunities for overlapping communication with some intervening computation. There have been several efforts <ref> [5, 4, 7, 8] </ref> to use data-flow analysis to determine communication placement that minimizes communication overhead. However, to reduce the complexity of the problem being solved, previous frameworks ignored most machine-dependent resource constraints. This paper introduces a new framework for resource-based communication placement, which takes limited resources into account. <p> An interval is just a collection of nodes; it is defined formally below. While solving the data-flow equations, we summarize appropriate information for an interval and propagate it to the interval header. Our interval-flow graph is similar to that used by the Give-N-Take framework <ref> [8] </ref>; it differs in the way critical edges are eliminated (see below). The important properties of the interval-flow graph, G = (N; E), are as follows. First, G is reducible; that is, each loop has a unique header node. <p> Finally, for every non-empty interval T (h), there exists an unique g 2 T (h) such that (g; h) 2 E; that is, there is only one back edge out of T (h). This is achieved by adding a post-body node to T (h) <ref> [8] </ref>. We assume that N has s and e as unique start and end nodes. The graph shown in Figure 3 (a) is used to illustrate resource-based communication placement. <p> To facilitate this, and unlike previous frameworks, the Send and Recv placements are determined in two separate phases. In addition, our framework ensures that every program execution path contains matching Send and Recv pairs; that is, Sends and Recvs are balanced <ref> [8] </ref>. Before performing the placement analysis, we identify the references that cause remote accesses (that is, the non-local references). With each non-local reference, we associate a descriptor that is used to record information such as the placement of the corresponding communication primitives. <p> This phases uses the same data-flow equations for send placement as the resource-independent send placement phase with the only difference being the initialization of appropriate data-flow variables. Note that if sufficient resources are available, our framework determines the same placement as that determined by resource-independent frameworks <ref> [8] </ref>. Latest balanced receive placement: Finally, we use the resource-based send placement to determine the corresponding receive placement. We make two passes over the interval-flow graph. <p> Moreover, each of the four phases (Section 4) involved in the resource-based communication analysis make at most two uni-directional passes over G [9]. Therefore, the complexity of our algorithm is O (E). Under the assumption that O (E) is the same as the order of the program size <ref> [8] </ref>, our algorithm has linear time complexity. 9 Related Work The problem of data-flow based communication generation and placement has been addressed by several researchers [5, 4, 2]. However, data-flow placement frameworks to eliminate partial redundancies across loop nests were developed only recently [8, 7]. <p> However, data-flow placement frameworks to eliminate partial redundancies across loop nests were developed only recently <ref> [8, 7] </ref>. To the best of our knowledge, ours is the first effort to take resource constraints into account during communication placement. Our framework is based on Lazy Code Motion (LCM) technique [10]. Besides incorporating resources, we extended the LCM technique to determine non-atomic and balanced placement. <p> To the best of our knowledge, ours is the first effort to take resource constraints into account during communication placement. Our framework is based on Lazy Code Motion (LCM) technique [10]. Besides incorporating resources, we extended the LCM technique to determine non-atomic and balanced placement. Give-N-Take framework <ref> [8] </ref> is the only previous framework that maximizes latency hiding while ensuring balancedness. However, it uses a complex set of inter-dependent equations to determine Send and Recv placements at the same time. Unlike the Give-N-Take framework, we determine Send and Recv place-ments using two separate uni-directional analyses.
Reference: 9. <author> K. Kennedy and A. Sethi. </author> <title> A communication placement framework with unified dependence and data-flow analysis. </title> <booktitle> In Proceedings of the Third International Conference on High Performance Computing, </booktitle> <address> Trivandrum, </address> <month> December </month> <year> 1996. </year>
Reference-contexts: Details about the data-flow equations in the absence of resource constraints have been described elsewhere <ref> [9] </ref>. 5 Safety Criterion In our data-flow equations, we use SAFE (n; d) to indicate whether node n is a safe placement location for Send (d). <p> All the equations presented in in Section 6 inspect only a subset of incoming/outgoing edges. Also, as described above, the and operators can be implemented efficiently. Moreover, each of the four phases (Section 4) involved in the resource-based communication analysis make at most two uni-directional passes over G <ref> [9] </ref>. Therefore, the complexity of our algorithm is O (E).
Reference: 10. <author> J. Knoop, O. Ruthing, and B. Steffen. </author> <title> Optimal code motion: </title> <journal> Theory and practice. ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(4) </volume> <pages> 1117-1155, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: A Tarjan interval has a unique header node h, where h 62 T (h). Third, there are no critical edges. A critical edge connects a node with multiple successors to a node with multiple predecessors <ref> [10] </ref>. Critical edges are eliminated by splitting edges as follows: every edge leading to a node with more than one predecessor is split by inserting a synthetic node. <p> However, data-flow placement frameworks to eliminate partial redundancies across loop nests were developed only recently [8, 7]. To the best of our knowledge, ours is the first effort to take resource constraints into account during communication placement. Our framework is based on Lazy Code Motion (LCM) technique <ref> [10] </ref>. Besides incorporating resources, we extended the LCM technique to determine non-atomic and balanced placement. Give-N-Take framework [8] is the only previous framework that maximizes latency hiding while ensuring balancedness. However, it uses a complex set of inter-dependent equations to determine Send and Recv placements at the same time.
Reference: 11. <author> C. Koelbel, D. Loveman, R. Schreiber, G. Steele, Jr., and M. Zosel. </author> <title> The High Performance Fortran Handbook. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1994. </year>
Reference-contexts: Finally, it describes how the results of resource analysis, together with the stripmining transformation, can be used to improve the efficacy of the communication placement. The communication placement analysis presented here has been implemented in the Rice Fortran D95 compiler (a High Performance Fortran <ref> [11] </ref> compiler) where it is used to determine the placement of distributed-memory communication primi tives (Send and Recv). The rest of the paper is organized as follows. Section 2 motivates the need for resource-based communication placement with the help of benchmark programs.
Reference: 12. <author> T. Mowry, M. Lam, and A. Gupta. </author> <title> Design and evaluation of a compiler algorithm for prefetching. </title> <booktitle> In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-V), </booktitle> <pages> pages 62-73, </pages> <address> Boston, MA, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Precise computation of Loop, Buffer, and Buffer in variables require the compile-time knowledge of the loop bounds and the number of processors. In case these are unknown, the compiler can either assume that all messages fit in the buffer or that no message fits in the buffer <ref> [12] </ref>. 6.2 Resource Analysis Across Loop Nests As described before, besides increasing the size of non-local buffers, earlier placement of Sends also increases the range over which the non-local buffers need to be live and this further increase the total size of non-local buffers required.
Reference: 13. <author> R. E. Tarjan. </author> <title> Testing flow graph reducibility. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 9 </volume> <pages> 355-365, </pages> <year> 1974. </year>
Reference-contexts: First, G is reducible; that is, each loop has a unique header node. Moreover, in this paper we assume that G corresponds to a structured program; however, the placement framework can be extended to handle jumps out of loops. Second, G is based on Tarjan intervals <ref> [13] </ref>, where a Tarjan interval T (h) is a set of control-flow nodes that correspond to a loop body in the program text. A Tarjan interval has a unique header node h, where h 62 T (h). Third, there are no critical edges.
Reference: 14. <author> C.-W. Tseng. </author> <title> An Optimizing Fortran D Compiler for MIMD Distributed-Memory Machines. </title> <type> PhD thesis, </type> <institution> Dept. of Computer Science, Rice University, </institution> <month> January </month> <year> 1993. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: Since most parallel machines package memory with processors, accesses to remote memory are typically an order of magnitude slower than accesses to local memory. Thus, remote accesses add communication overhead to the total execution time and, as the number of processors increase, communication overhead can dominate the execution time <ref> [14] </ref>. Reducing communication overhead is a key goal of optimizing parallel programs. Communication overhead can be reduced in three ways: by reducing the frequency of communication, by eliminating redundant communication, and by hiding communication latency. Communication frequency can be reduced by hoisting communication to the outer-most program location. <p> This heuristic is based on the experiences with compilation for distributed-memory machines: it has been observed that reducing frequency of communication often yields more significant benefits than the latency hiding optimization <ref> [14] </ref>. Message buffers for communication blocked at a node are deallocated. This frees up buffers and allows communication to be hoisted to the outermost placement locations. The results of the resource analysis are used to implement the heuristic as follows.
References-found: 14

