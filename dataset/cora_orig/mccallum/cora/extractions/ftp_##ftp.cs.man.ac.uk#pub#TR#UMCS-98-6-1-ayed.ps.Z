URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1-ayed.ps.Z
Refering-URL: ftp://ftp.cs.man.ac.uk/pub/TR/UMCS-98-6-1.html
Root-URL: http://www.cs.man.ac.uk
Email: rbenayed@stardent.cck.tn  Jules.Desharnais@ift.ulaval.ca  marc.frappier@dmi.usherb.ca  amili@csee.wvu.edu  
Title: A Calculus of Program Transformations and Its Applications  
Author: Rahma Ben Ayed Jules Desharnais Marc Frappier Ali Mili 
Keyword: Formal specifications, Programming calculi, Program construction, Software merging, Software incrementation, Software adaptation.  
Date: June 27, 1998  
Address: Belvedere, 1002 Tunisia  Quebec City, PQ G1K 7P4, Canada  Sherbrooke, PQ J1K 2R1 Canada  1000 Technology Drive Fairmont, WV 26554 USA  
Affiliation: School of Engineering University of Tunis II  Department of Informatics Laval University,  Dept of Maths and Informatics University of Sherbrooke  The Institute for Software Research  
Abstract: Traditional programming calculi focus on transforming a specification into a program. With the advent of such recent paradigms as white box reuse, component based software development, and reengineering, and with the continued predominance of software maintenance, less and less software engineering activity nowadays deals with straightforward development. More and more, software products are derived by combining, merging, or adapting existing components. In this paper we present a calculus that models several aspects of these paradigms. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C.A.R. Hoare et al. </author> <title> Laws of programming. </title> <journal> Communications of the ACM, </journal> <volume> 30(8) </volume> <pages> 672-686, </pages> <year> 1987. </year>
Reference-contexts: Several authors have advocated that the join operator is useful in the refinement of complex specifications <ref> [2, 4, 1] </ref>. Hoare et al [1] identifies some basic properties of join, like idempotence, commutativity, associativity and absorption. They also mention distributivity over usual programming constructs like sequential composition, alternation, iteration and nondeterministic choice, but for a very limited case of join (directed set of subspecifications with bounded nondeterminacy). <p> Several authors have advocated that the join operator is useful in the refinement of complex specifications [2, 4, 1]. Hoare et al <ref> [1] </ref> identifies some basic properties of join, like idempotence, commutativity, associativity and absorption. They also mention distributivity over usual programming constructs like sequential composition, alternation, iteration and nondeterministic choice, but for a very limited case of join (directed set of subspecifications with bounded nondeterminacy). <p> Our work differs from Hehner's work by the representation of specifications (predicates vs. relations) and by their interpretations: termination is implicit in our specifications 8 whereas it is expressed as timing constraints in Hehner's. Our work differs from that of Hoare et al <ref> [1] </ref> by using partial relations and demonic operators, by not using a fictitious state to represent nontermination, and by providing rules to eliminate meets in a specification.
Reference: [2] <author> M. Frappier, J. Desharnais, and A. Mili. </author> <title> A calculus of program construction by parts. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 6 </volume> <pages> 237-254, </pages> <year> 1996. </year>
Reference-contexts: The refinement ordering has some lattice-like properties which, for the sake of parsimony, we present briefly without proof (details can be found in <ref> [2] </ref>). * Two relations R and R 0 have a join (denoted by R t R 0 ) if and only if they satisfy the condition RL " R 0 L = (R " R 0 )L: Under this condition, the join is given by R t R 0 = R <p> Due to space restrictions, we can only present a flavor of this method; details of this method can be found in <ref> [2] </ref>. 2.1 A Specification Notation Specifications are represented by structured relational expressions. <p> Our position is that this problem amounts to refining the specification C t F: Note that although C is a program, we can write it using our specification notation (we have rules for doing that, given in <ref> [2] </ref>). <p> Several authors have advocated that the join operator is useful in the refinement of complex specifications <ref> [2, 4, 1] </ref>. Hoare et al [1] identifies some basic properties of join, like idempotence, commutativity, associativity and absorption. They also mention distributivity over usual programming constructs like sequential composition, alternation, iteration and nondeterministic choice, but for a very limited case of join (directed set of subspecifications with bounded nondeterminacy). <p> We share with the work of Sekerinski [5] (and Z) the same specification model where the focus is on input-output pairs for which a program must terminate. Most importantly, the work presented in this paper differs from other programming calculi (including our own <ref> [2] </ref>) by the fact that it deals with new software development paradigms rather than traditional program construction.
Reference: [3] <author> P. Gardiner and C.C. Morgan. </author> <title> Data refinement of predicate transformers. </title> <journal> Theoretical Computer Science, </journal> <volume> 87 </volume> <pages> 143-162, </pages> <year> 1991. </year>
Reference-contexts: Recent work of Hehner [4] includes laws of refinement for join-structured specifications. In Hehner's calculus, specifications are predicates, termination is prescribed using a time variable, and join is logical conjunction. Morgan and Gardiner <ref> [3] </ref> use a join statement for data refinement and for the definition of logical constants. They do not use join as a specification structuring device nor do they study the refinement of join-structured specifications. Finally, the work of von Wright also mentions a join operator.
Reference: [4] <author> E.C.R. Hehner. </author> <title> A Practical Theory of Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Several authors have advocated that the join operator is useful in the refinement of complex specifications <ref> [2, 4, 1] </ref>. Hoare et al [1] identifies some basic properties of join, like idempotence, commutativity, associativity and absorption. They also mention distributivity over usual programming constructs like sequential composition, alternation, iteration and nondeterministic choice, but for a very limited case of join (directed set of subspecifications with bounded nondeterminacy). <p> They also mention distributivity over usual programming constructs like sequential composition, alternation, iteration and nondeterministic choice, but for a very limited case of join (directed set of subspecifications with bounded nondeterminacy). Recent work of Hehner <ref> [4] </ref> includes laws of refinement for join-structured specifications. In Hehner's calculus, specifications are predicates, termination is prescribed using a time variable, and join is logical conjunction. Morgan and Gardiner [3] use a join statement for data refinement and for the definition of logical constants.
Reference: [5] <author> E. Sekerinski. </author> <title> A calculus for predicative programming. In R.S. Bird, C.C. </title> <publisher> Morgan, </publisher> <editor> and J.C.P. Woodcock, editors, </editor> <booktitle> Mathematics of program construction : second international conference, number 669 in Lecture Notes in Computer Science, </booktitle> <address> Oxford, UK, 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Our work differs from the work of von Wright, Gardiner and Morgan by using a different semantics, by not allowing miraculous specifications, and by studying the transformation of join-structured specifications. We share with the work of Sekerinski <ref> [5] </ref> (and Z) the same specification model where the focus is on input-output pairs for which a program must terminate.
Reference: [6] <author> D.R. Skuce and A. Mili. </author> <title> Behavioral specifications in object oriented programming. </title> <journal> Journal of Object Oriented Programming, </journal> <pages> pages 41-49, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: As a specification, a relation contains all the (input, output) pairs that are considered correct. We have discussed in <ref> [6] </ref> how to use (heterogeneous) relations to represent specifications of objects, in the sense of object oriented programming.
Reference: [7] <author> J. Von Wright. </author> <title> A lattice theoretical basis for program refinement. </title> <type> Technical report, </type> <institution> Dept. of Computer Science, _ Abo Akademi, Finland, </institution> <year> 1990. </year> <month> 9 </month>
Reference-contexts: Morgan and Gardiner [3] use a join statement for data refinement and for the definition of logical constants. They do not use join as a specification structuring device nor do they study the refinement of join-structured specifications. Finally, the work of von Wright also mentions a join operator. In <ref> [7] </ref>, he reconstructs the refinement calculus of Back from elementary primitives. The emphasis of this work is more on the definition of a language than on the definition of a refinement calculus. The semantics of the language is given by predicate transformers, and miraculous specifications are allowed.
References-found: 7

