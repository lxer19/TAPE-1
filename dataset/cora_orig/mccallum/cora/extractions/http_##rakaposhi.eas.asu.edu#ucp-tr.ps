URL: http://rakaposhi.eas.asu.edu/ucp-tr.ps
Refering-URL: http://rakaposhi.eas.asu.edu/yochan.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: email: frao,biplavg@asu.edu  
Title: Unifying Classical Planning Approaches  
Author: Subbarao Kambhampati Biplav Srivastava 
Date: 96-006; July 1996  
Note: ASU CSE TR  
Web: WWW: http://rakaposhi.eas.asu.edu/yochan.html  
Address: Tempe AZ 85287-5406  
Affiliation: Department of Computer Science and Engineering Arizona State University,  
Abstract: State space and plan space planning approaches have traditionally been seen as fundamentally different and competing approaches to domain-independent planning. We present a plan representation and a generalized algorithm template, called UCP, for unifying these classical planning approaches within a single framework. UCP models planning as a process of refining a partial plan. The alternative approaches to planning are cast as complementary refinement strategies operating on the same partial plan representation. UCP is capable of arbitrarily and opportunistically interleaving plan-space and state-space refinements within a single planning episode, which allows it to reap the benefits of both. We discuss the coverage, completeness and systematicity of UCP. We also present some preliminary empirical results that demonstrate the utility of combining state-space and plan-space approaches. Next, we use the UCP framework to answer the question which refinement planner is best suited for solving a given population of problems efficiently? Our approach involves using subgoal interaction analysis. We provide a generalized account of subgoal interactions in terms of plan candidate sets, and use it to develop a set of guidelines for choosing among the instantiations of UCP. We also include some preliminary empirical validation of our guidelines. In a separate appendix, we also describe how the HTN planning approach can be integrated into the UCP framework. fl This research is supported in part by NSF research initiation award (RIA) IRI-9210997, NSF young investigator award (NYI) IRI-9457634 and ARPA/Rome Laboratory planning initiative grants F30602-93-C-0039 and F30602-95-C-0247. We thank Laurie Ihrig and Amol Dattatreya Mali for helpful comments. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J.A. Ambros-Ingerson and S. Steel. </author> <title> Integrating Planning, Execution and Monitoring. </title> <booktitle> In Proc. 7th AAAI, </booktitle> <year> 1988. </year>
Reference-contexts: Further more, among the head-fringe steps, we can prefer those that are not taking part in any conflicts currently <ref> [1] </ref>. This is to ensure that there is no reason to suspect that the step will move out of head-fringe after conflict resolution. The selection of refinement strategy can be done in many ways, and the tradeoffs offered by the various strategies is still an open question. <p> Definition 5 (Serialization Order [2]) Given a set of n subgoals g 1 ; g 2 : : : g n , a permutation on these subgoals is considered a serialization order (modulo a class of plans b P), if every plan for achieving <ref> [1] </ref> can be serially extended to [2] and any resulting plan can be serially extended to [3] and so on.
Reference: [2] <author> A. Barrett and D. Weld. </author> <title> Partial Order Planning: Evaluating Possible Efficiency Gains. </title> <journal> Artificial Intelligence, </journal> <volume> Vol. 67, No. 1, </volume> <year> 1994. </year>
Reference-contexts: 1 Introduction Domain independent classical planning techniques fall into two broad categories state space planners which search in the space of states, and plan space planners which search in the space of plans. By and large, these approaches have been seen as competing rather than complementary, and several research efforts <ref> [2, 35] </ref> have been focused on showing the relative superiority of one over the other. <p> The traditional question when should a plan-space planner be preferred over state space planners? <ref> [2, 35] </ref> can now be posed in a more sophisticated form: when should a plan-space refinement be preferred over a state-space refinement (or vice versa) within a single planning episode?. <p> Although subgoal and subplan interactions have been studied in the past <ref> [2, 24] </ref>, they have been couched in terms of the details of specific classical planners. We present a more generalized analysis based on candidate set of subplans for individual subgoals [22]. <p> The termination check can thus be 6 The so-called separation refinement <ref> [2] </ref> is subsumed under the confrontation option as one way of ensuring that s t does not negate p is to add non-codesignation constraints that prevent the effect of s t from unifying with p. 7 This splitting does not lead to loss of completeness since the candidates are all ground <p> The second domain, called 2 D m S 1 , is one of the domains designed by Barrett & Weld <ref> [2] </ref> to demonstrate the advantages of plan space planning over state space planning. In this domain, each top level goal G i can be achieved by either of two actions A 1 i or A 2 i . <p> In other words, even a domain that motivates pure plan-space planning over pure state space planning <ref> [2] </ref>, can benefit from a proper mix of the two types of refinements! Finally, Figure 13 compares the performance of pure and hybrid instantiations of UCP in the standard blocks world domain (which, unlike the three artificial domains, is a non-propositional domain). <p> Although considerable work has been done on understanding subgoal interactions <ref> [24, 2, 35, 14] </ref>, much of this has been done in terms of the specifics of state space [24] or plan-space planners [2]. <p> Although considerable work has been done on understanding subgoal interactions [24, 2, 35, 14], much of this has been done in terms of the specifics of state space [24] or plan-space planners <ref> [2] </ref>. It turns out that both subplan extension and merging could be understood cleanly in terms of the candidate set semantics of the partial plans developed in Section 3. In the following, we provide such an analysis. <p> When there are multiple subgoals, the chance of picking the correct goal order is low and thus serializability does not imply improvements in planning cost. Following Barrett and Weld <ref> [2] </ref>, we thus further extend the notion of serializability to consider trivial and laborious serializability. Definition 5 (Serialization Order [2]) Given a set of n subgoals g 1 ; g 2 : : : g n , a permutation on these subgoals is considered a serialization order (modulo a class of <p> When there are multiple subgoals, the chance of picking the correct goal order is low and thus serializability does not imply improvements in planning cost. Following Barrett and Weld <ref> [2] </ref>, we thus further extend the notion of serializability to consider trivial and laborious serializability. Definition 5 (Serialization Order [2]) Given a set of n subgoals g 1 ; g 2 : : : g n , a permutation on these subgoals is considered a serialization order (modulo a class of plans b P), if every plan for achieving [1] can be serially extended to [2] and any resulting plan <p> Definition 5 (Serialization Order <ref> [2] </ref>) Given a set of n subgoals g 1 ; g 2 : : : g n , a permutation on these subgoals is considered a serialization order (modulo a class of plans b P), if every plan for achieving [1] can be serially extended to [2] and any resulting plan can be serially extended to [3] and so on. The set of subgoals are considered trivially serializable if all the permutations correspond to serialization orders, and are considered laboriously serializable if a significant number of permutations ( &gt; 1 n ) correspond to non-serialization orderings. <p> 1 , with the IPC (P uton (B; C) On (B;C) t 1 ) is serially extensible with respect to On (B; C); although the plan t 0 fl P uton (B; C) t 1 , with the same IPC is not. 8.4.2 Barrett and Weld's Serializability Barett and Weld <ref> [2] </ref> extended Korf's [24] subgoal interaction analysis to plan space planners, and showed that problems like Sussman anomaly are serializable for the partial order planner SNLP. <p> This is not useful in and of itself if there is no (domain-independent) refinement planner that can generate exactly that class of plans. Consider, for example, the artificial domain shown below (originally described as the D fl S 1 C 2 domain by Barrett and Weld <ref> [2] </ref>): 35 D fl S 1 C 1 domain of Barrett and Weld Op Prec Add Del A 1 A 2 All problems have the initial state where all I i and G fl are true. <p> If we have to pick a plan for the first subgoal without knowing what the next subgoal is going to be, we are still better off in general picking a less constrained partial plan. The empirical results of Barrett and Weld <ref> [2] </ref> in domains that are laboriously serializable for all their planners, do support this view to some extent. Although less constrained plans are more likely to be serially extensible, more constrained plans do have their advantages. They are typically easier to handle in terms of consistency and terminations checks [19]. <p> Finally, our candidate set based subgoal interaction analysis builds on existing work on subgoal interaction analysis <ref> [24, 2, 35] </ref>. A detailed discussion of the relations can be found in Section 8.4. 11 Conclusion and Future Work In this paper, we presented a generalized algorithm template, called UCP, which allows plan-space and state-space refinements on a single partial plan representation.
Reference: [3] <author> A. Barrett and D. Weld. </author> <title> Schema Parsing: Hierarchical Planning for Expressive Languages. </title> <booktitle> In Proc. AAAI-94. </booktitle>
Reference-contexts: subgoals g 1 ; g 2 : : : g n , a permutation on these subgoals is considered a serialization order (modulo a class of plans b P), if every plan for achieving [1] can be serially extended to [2] and any resulting plan can be serially extended to <ref> [3] </ref> and so on. The set of subgoals are considered trivially serializable if all the permutations correspond to serialization orders, and are considered laboriously serializable if a significant number of permutations ( &gt; 1 n ) correspond to non-serialization orderings.
Reference: [4] <author> A. Barrett. </author> <title> Frugal Hierarchical Task-Network Planning. </title> <type> Ph.D. Thesis. </type> <institution> Department of Computer Science and Engineering. University of Washington. </institution> <year> 1996. </year>
Reference: [5] <author> A. Blum and M. Furst. </author> <title> Fast planning through planning graph analysis. </title> <booktitle> In Proc. IJCAI-95, </booktitle> <year> 1995. </year>
Reference-contexts: need for phantom reductions (which we argue are really an artifact of doing plan-space refinment in the presence of non-primitive tasks). 11.1 Future Work An interesting research direction involves using the UCP framework to unify and explain the relation between some of the newer refinement planning algorithms such as Graphplan <ref> [5] </ref> and Descartes [15]. Although these planners look very different from the conventional refinement planners that are covered by UCP, we believe that it is possible to extend UCP in such a way that conventional techniques as well as the newer planners become a special case of the extended framework.
Reference: [6] <author> D. Chapman. </author> <title> Planning for conjunctive goals. </title> <journal> Artificial Intelligence, </journal> <volume> 32:333377, </volume> <year> 1987. </year>
Reference-contexts: Point Truth Constraints: A point truth constraint (PTC) is specified as a 2-tuple: hp; ti. Syntactically, it demands that the condition p be necessarily true <ref> [6] </ref> in the situation before the step t. Semantically, it constrains all solutions of the partial plan to have p in the state in which the operator corresponding to t is executed. <p> In particular, in [19, 17, 18], we showed that the plan space refinement template, given in [25], and TWEAK <ref> [6] </ref>. What is more interesting, as shown in Section 4.5, is the fact that the UCP algorithm also allows hybrid planners that can opportunistically apply plan-space as well as state-space refinements within a single planning episode. <p> uton (C; T able)flP uton (B; C)flP uton (A; B) t 1 (which happens to be a non-minimal solution). 14 We note that the protected plans made by a causal link planner such as SNLP are more constrained than the unprotected plans made by non-causal link planners such as TWEAK <ref> [6] </ref> 14 On the other hand, the one way rocket problem is not serializable even without the protection restriction; the critical issue for this problem is the prefix plan requirement. <p> In particular, similar performance tradeoffs would be observed if the planners being compared were both state-space or both plan-space planners (e.g., one being TWEAK <ref> [6] </ref> and the other being SNLP), as long as one planner uses protections and the other doesn't. 9 Factors Influencing the Selection of a Refinement Planner Based on our characterization of subgoal interactions, a general method for selecting a particular refinement planner (instantiation of UCP) involves (a) delineating the class of
Reference: [7] <author> S. Chien. </author> <title> Static and Completion analysis for planning knowledge base development and verification. </title> <booktitle> In Proc. </booktitle> <address> AIPS-96, </address> <year> 1996. </year>
Reference: [8] <author> K. Erol, J. Hendler, D.S. Nau and R. Tsuneto. </author> <title> A critical look at critics in HTN planning. </title> <booktitle> In Proc. IJCAI-95, </booktitle> <year> 1995. </year>
Reference-contexts: Specifically, we have completed the theoretical formulation, but the implementation is pending. Appendix A provides the details of our formalization of HTN planning within UCP. Our approach differs from that advocated by Erol et. al. <ref> [8] </ref>, where HTN planning is seen as fundamentally different from STRIPS-action based planning. We take the view that HTN planning simply involves introducing non-primitive actions into the domain model.
Reference: [9] <author> R. Fikes and N. Nilsson. </author> <title> STRIPS: A new approach to the application of theorem proving to problem solving. In Readings in Planning. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: What is more interesting, as shown in Section 4.5, is the fact that the UCP algorithm also allows hybrid planners that can opportunistically apply plan-space as well as state-space refinements within a single planning episode. For example, the classical means-ends analysis planners such as STRIPS <ref> [9] </ref>, or their descendents such as PRODIGY [10] can be modeled by a pick-refinement strategy such as the following: If there is a step in the head-fringe of the plan that is applicable to the head-state, pick FSS or lazy FSS . Else, pick PS refinement.
Reference: [10] <author> E. Fink and M. Veloso. </author> <title> Formalizing the Prodigy Planning Algorithm. </title> <type> CMU CS Tech. Report, </type> <month> Fall </month> <year> 1994. </year>
Reference-contexts: Since all three refinement strategies operate on the same general partial plan representation, UCP also facilitates opportunistic interleaving of the plan-space and state-space refinements within a single planning episode. Such interleaving could produce a variety of hybrid planners (including the traditional means-ends analysis planners such as STRIPS and PRODIGY <ref> [10] </ref>), and can thus help us reap the benefits of both state-space and plan-space approaches in a principled manner. <p> For example, the classical means-ends analysis planners such as STRIPS [9], or their descendents such as PRODIGY <ref> [10] </ref> can be modeled by a pick-refinement strategy such as the following: If there is a step in the head-fringe of the plan that is applicable to the head-state, pick FSS or lazy FSS . Else, pick PS refinement. <p> Their main purpose is to partition the candidate set to make the plan handling cheaper. As such any set of mutually exclusive, and exhaustive constraints can form the basis of a non-progressive refinement. In contrast, we only have three basic types of progressive refinements. Fink and Veloso <ref> [10] </ref> describe the PRODIGY 4.0 planner which does an interesting combination of forward state space refinement combined with means-ends analysis. The partial plans maintained by PRODIGY 4.0 contain a header sequence, and many backward chaining subgoal-trees starting from the goal state (called the tail).
Reference: [11] <author> M. Ginsberg. </author> <title> Approximate Planning. </title> <journal> Artificial Intelligence, Special Issue on Planning, Scheduling and Control. </journal> <year> 1995. </year> <month> 41 </month>
Reference-contexts: Any feasible prefix plan will also have the property that the prefix steps can be executed from the initial state in sequence (as otherwise, their candidate sets cannot contain any executable operator sequences). For example, a prefix 3 In <ref> [11] </ref>, Ginsberg argues for an elimination of this separation saying that a good plan will have a large candidate set most of which will be able to achieve the goals of the problem. 9 On (B; C). Each plan class is identified with a descriptive name.
Reference: [12] <author> L. Ihrig and S. Kambhampati. </author> <title> On the Relative Utility of Plan-space vs. </title> <note> State-space planning in a case-based framework ASU CSE TR 94-006; Dec 1994. (Submitted for publication) </note>
Reference-contexts: C 1 domain Op Prec Add Del A 1 A 2 15 If we are considering case-based planning, rather than generative planning, then generating and storing partial plans with fewer constraints is more likely to be a win, as they can be reused and extended in more novel situations; see <ref> [12] </ref>. 36 These delete lists ensure that every solution for a problem involving the goals G i and G j (i &lt; j) will have the action achieving G i before the action achieving G j .
Reference: [13] <author> D. Joslin and M. Pollack. </author> <title> Least-cost flaw repair: A plan refinement strategy for partial order planning. </title> <booktitle> Proceedings of AAAI-94, </booktitle> <year> 1994. </year>
Reference-contexts: Else, pick PS refinement. Finally, it is also possible to use a more ambitious pick-refinement strategy: pick the refinement that has the least expected cost (see below) <ref> [13] </ref>. 5.2 Completeness To make matters simple, we will consider the completeness of UCP instantiations which use a solution extraction function that looks through the minimal candidates for a solution for the problem. <p> The third one, called UCP-LCFR, estimates the number of refinements generated by each of the three refinement strategies and selects the one that has the least number of refinements. This strategy is inspired by the least cost flaw refinement strategy, that was recently suggested in <ref> [13] </ref>. If a PS refinement is selected, UCP still faces the question of which goal to achieve first (each choice corresponds to a complete PS refinement with respect to that goal). <p> The time limit was increased to 300 seconds in the case of UCP-LCFR as our simple implementation estimates the branching factors of each refinement by actually simulating the refinement (other more efficient approximate estimation methods are of course possible; see <ref> [13] </ref>). 26 Domains and Results: We conducted experiments both in blocks world and in a variety of artificial domains designed by various researchers to illustrate the advantages of one planning approach over another.
Reference: [14] <author> D. Joslin and J. Roach. </author> <title> A Theoretical Analysis of Conjunctive Goal Problems. Research Note, </title> <journal> Artificial Intelligence, </journal> <volume> Vol. 41, </volume> <year> 1989/90. </year>
Reference-contexts: Although considerable work has been done on understanding subgoal interactions <ref> [24, 2, 35, 14] </ref>, much of this has been done in terms of the specifics of state space [24] or plan-space planners [2]. <p> Proposition 1 (Korf's Serializability) Two subgoals g 1 and g 2 are Korf-Serializable, if they are serializable with respect to the class of protected prefix plans. 12 Joslin and Roach <ref> [14] </ref> give a similar analysis of subgoal interactions in terms of the state space graph. In particular, they consider the state transition graph of the domain, and identify each subgoal with a subgraph of the transition graph (where all the states in that subgraph satisfy that goal).
Reference: [15] <author> D. Joslin and M. Pollack. </author> <title> Passive and active decision postponement in plan generation. </title> <booktitle> In Proc. 3rd European Workshop on Planning, </booktitle> <year> 1995. </year>
Reference-contexts: reductions (which we argue are really an artifact of doing plan-space refinment in the presence of non-primitive tasks). 11.1 Future Work An interesting research direction involves using the UCP framework to unify and explain the relation between some of the newer refinement planning algorithms such as Graphplan [5] and Descartes <ref> [15] </ref>. Although these planners look very different from the conventional refinement planners that are covered by UCP, we believe that it is possible to extend UCP in such a way that conventional techniques as well as the newer planners become a special case of the extended framework.
Reference: [16] <author> S. Kambhampati. </author> <title> Multi-Contributor Causal Structures for Planning: A Formalization and Evaluation. </title> <journal> Artificial Intelligence, </journal> <volume> Vol. 69, </volume> <year> 1994. </year> <pages> pp. 235-278. </pages>
Reference-contexts: Korf's original definition, both these problems are non-serializable, and thus indistinguishable, we note that by considering serializability in terms of classes of plans, we can make finer-grained distinctions among different problems. 34 and UA [28], or planners that use disjunctive protections (e.g. multi-contributor causal links) such as MP and MP-I <ref> [16] </ref>. Thus, there may be domains with subgoals that are not serializable with respect to SNLP but are serializable with respect to these latter planners. ART-MD-RD, first described in [16], and shown below, is one such domain: ART-MD-RD domain from [16] Op Prec Add Del A i (i even) I i <p> different problems. 34 and UA [28], or planners that use disjunctive protections (e.g. multi-contributor causal links) such as MP and MP-I <ref> [16] </ref>. Thus, there may be domains with subgoals that are not serializable with respect to SNLP but are serializable with respect to these latter planners. ART-MD-RD, first described in [16], and shown below, is one such domain: ART-MD-RD domain from [16] Op Prec Add Del A i (i even) I i ; he G i ; hf fI j jj &lt; ig [ fheg A i (i odd) I i ; hf G i ; he fI j jj &lt; <p> protections (e.g. multi-contributor causal links) such as MP and MP-I <ref> [16] </ref>. Thus, there may be domains with subgoals that are not serializable with respect to SNLP but are serializable with respect to these latter planners. ART-MD-RD, first described in [16], and shown below, is one such domain: ART-MD-RD domain from [16] Op Prec Add Del A i (i even) I i ; he G i ; hf fI j jj &lt; ig [ fheg A i (i odd) I i ; hf G i ; he fI j jj &lt; ig [ fhf g To see this, consider a problem where
Reference: [17] <author> S. Kambhampati. </author> <title> Refinement search as a unifying framework for analyzing planning algorithms. </title> <booktitle> In Proc. </booktitle> <address> KR-94, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: To this end, we develop a unified framework that encompasses both state-space and plan-space planning approaches. Previously, we have shown that viewing planning as a process of refinement search provides a powerful framework for unifying the large variety of plan-space planning approaches <ref> [19, 17, 18] </ref>. In this paper, we show that the same framework can be extended to unify state-space planning and plan-space planning approaches. In particular, we present UCP [21], a generalized algorithm for classical planning. <p> An action sequence (also referred to as ground operator sequence) S is said to be a solution for the planning problem, if S can be executed from I, and the resulting state of the world satisfies all the goals. Refinement planners <ref> [17, 18, 19] </ref> attempt to solve a planning problem by navigating the space of sets of potential solutions (ground operator sequences). <p> maps a partial plan P to a set of partial plans fP 0 i g such that the candidate sets of each of the child plans are subsets of the candidate set of P (i.e., 1 For a more formal development of the refinement search semantics of partial plans, see <ref> [17, 19] </ref> 4 8 P 0 i ii hhPii). A solution extraction function takes a partial plan and check to see if one of its candidates solves the problem at hand. <p> Readers who are familiar with the refinement search view of partial order planning developed in <ref> [19, 17, 18] </ref> may note that the only extension to the plan representation is the addition of the new type of auxiliary constraints called contiguity constraints. We will see here that this extension is enough to handle state space refinements. <p> The ordering constraints between steps are shown by arrows. The interval preservation constraints are shown by arcs, while the contiguity constraints are shown by thick dotted lines. The PTCs are used to specify the goals of the plan syntactic notion of safe ground linearization <ref> [19, 17] </ref>. Specifically, safe ground linearizations correspond to minimal length candidates of the partial plan [19]. If a partial plan has no safe ground linearizations, it has an empty candidate set. <p> In particular, in <ref> [19, 17, 18] </ref>, we showed that the plan space refinement template, given in [25], and TWEAK [6]. <p> are more committed than those of UCP-PS and less committed than those of UCP-FSS. 10 Related Work Earlier work on unifying classical planning approaches includes Rosenchien's work [31] on bigression planner, which combines a forward state space search and a backward state space search; and our own more recent work <ref> [19, 17, 18] </ref> unifying a variety of plan-space planning frameworks into one algorithm template. To our knowledge, this paper is the first to rationally place the plan-space and state-space refinements in one unifying framework.
Reference: [18] <author> S. Kambhampati. </author> <title> Design Tradeoffs in Partial Order (Plan Space) Planning. </title> <booktitle> In Proc. 2nd Intl. Conf. on AI Planning Systems (AIPS-94), </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: To this end, we develop a unified framework that encompasses both state-space and plan-space planning approaches. Previously, we have shown that viewing planning as a process of refinement search provides a powerful framework for unifying the large variety of plan-space planning approaches <ref> [19, 17, 18] </ref>. In this paper, we show that the same framework can be extended to unify state-space planning and plan-space planning approaches. In particular, we present UCP [21], a generalized algorithm for classical planning. <p> An action sequence (also referred to as ground operator sequence) S is said to be a solution for the planning problem, if S can be executed from I, and the resulting state of the world satisfies all the goals. Refinement planners <ref> [17, 18, 19] </ref> attempt to solve a planning problem by navigating the space of sets of potential solutions (ground operator sequences). <p> Readers who are familiar with the refinement search view of partial order planning developed in <ref> [19, 17, 18] </ref> may note that the only extension to the plan representation is the addition of the new type of auxiliary constraints called contiguity constraints. We will see here that this extension is enough to handle state space refinements. <p> In particular, in <ref> [19, 17, 18] </ref>, we showed that the plan space refinement template, given in [25], and TWEAK [6]. <p> are more committed than those of UCP-PS and less committed than those of UCP-FSS. 10 Related Work Earlier work on unifying classical planning approaches includes Rosenchien's work [31] on bigression planner, which combines a forward state space search and a backward state space search; and our own more recent work <ref> [19, 17, 18] </ref> unifying a variety of plan-space planning frameworks into one algorithm template. To our knowledge, this paper is the first to rationally place the plan-space and state-space refinements in one unifying framework.
Reference: [19] <author> S. Kambhampati, C. Knoblock and Q. Yang. </author> <title> Planning as Refinement Search: A Unified framework for evaluating design tradeoffs in partial order planning. </title> <journal> Artificial Intelligence special issue on Planning and Scheduling. </journal> <volume> Vol. 76. </volume> <year> 1995. </year>
Reference-contexts: To this end, we develop a unified framework that encompasses both state-space and plan-space planning approaches. Previously, we have shown that viewing planning as a process of refinement search provides a powerful framework for unifying the large variety of plan-space planning approaches <ref> [19, 17, 18] </ref>. In this paper, we show that the same framework can be extended to unify state-space planning and plan-space planning approaches. In particular, we present UCP [21], a generalized algorithm for classical planning. <p> An action sequence (also referred to as ground operator sequence) S is said to be a solution for the planning problem, if S can be executed from I, and the resulting state of the world satisfies all the goals. Refinement planners <ref> [17, 18, 19] </ref> attempt to solve a planning problem by navigating the space of sets of potential solutions (ground operator sequences). <p> maps a partial plan P to a set of partial plans fP 0 i g such that the candidate sets of each of the child plans are subsets of the candidate set of P (i.e., 1 For a more formal development of the refinement search semantics of partial plans, see <ref> [17, 19] </ref> 4 8 P 0 i ii hhPii). A solution extraction function takes a partial plan and check to see if one of its candidates solves the problem at hand. <p> Readers who are familiar with the refinement search view of partial order planning developed in <ref> [19, 17, 18] </ref> may note that the only extension to the plan representation is the addition of the new type of auxiliary constraints called contiguity constraints. We will see here that this extension is enough to handle state space refinements. <p> We will see here that this extension is enough to handle state space refinements. Safe Ground Linearizations: A ground linearization is said to be a safe ground linearization if it syntactically satisfies all the contiguity constraints, and the interval preservation constraints <ref> [19] </ref>. The semantic notion of the candidate set of the partial plan is tightly related to a 2 Note that a ground linearization is in terms of step names while a ground operator sequence is in terms of actions. <p> The ordering constraints between steps are shown by arrows. The interval preservation constraints are shown by arcs, while the contiguity constraints are shown by thick dotted lines. The PTCs are used to specify the goals of the plan syntactic notion of safe ground linearization <ref> [19, 17] </ref>. Specifically, safe ground linearizations correspond to minimal length candidates of the partial plan [19]. If a partial plan has no safe ground linearizations, it has an empty candidate set. <p> The PTCs are used to specify the goals of the plan syntactic notion of safe ground linearization [19, 17]. Specifically, safe ground linearizations correspond to minimal length candidates of the partial plan <ref> [19] </ref>. If a partial plan has no safe ground linearizations, it has an empty candidate set. <p> This calls for a type of refinement that reasons about the relevance of the operator, without fixing its position. The plan-space refinement (PS refinement for short), does this. PS refinement strategy comes in several varieties, and a comprehensive discussion of these can be found in <ref> [19] </ref>. Here, we will summarize the main points. 16 The heart of the PS refinement, given in Figure 7, is an establishment operation [19]. <p> The plan-space refinement (PS refinement for short), does this. PS refinement strategy comes in several varieties, and a comprehensive discussion of these can be found in <ref> [19] </ref>. Here, we will summarize the main points. 16 The heart of the PS refinement, given in Figure 7, is an establishment operation [19]. In the establishment phase, a precondition p of a step s is selected, and a sufficient number of step, ordering and binding constraints are added to ensure that the point truth constraint hp; si is satisfied (i.e., p will be necessarily true at s). <p> Additionally, if s 0 is a new step, its preconditions will have to be established later. See <ref> [19] </ref> for further details. The choice of which precondition to achieve does not have to be backtracked over, but all possible ways of establishing the selected precondition must be considered for completeness. <p> Non-progressive refinements are not required for termination if we have a solution extraction function that looks at all minimal candidates. However, they are motivated by the need to reduce the plan handling costs (specifically, the costs of solution extraction and consistency checking) <ref> [19] </ref>. Non-progressive refinements have thus been called tractability refinements [19] and critics [32]. There are essentially three types of non-progressive refinements used in refinement planning. <p> However, they are motivated by the need to reduce the plan handling costs (specifically, the costs of solution extraction and consistency checking) <ref> [19] </ref>. Non-progressive refinements have thus been called tractability refinements [19] and critics [32]. There are essentially three types of non-progressive refinements used in refinement planning. The first two, called pre-ordering and pre-positioning refinements constrain the relative order and position of a pair of steps in mutually exclusive and exhaustive ways in the different branches. <p> There may of course be more specialized realizations of the termination check that are more efficient for specific instantiations of UCP. For example, pure plan space planners using causal links can use a causal link based termination check used in SNLP <ref> [25, 19] </ref>, which continue to refine a plan until all preconditions of all steps have been considered for establishment, and none of the IPCs are violated. <p> In particular, in <ref> [19, 17, 18] </ref>, we showed that the plan space refinement template, given in [25], and TWEAK [6]. <p> In the case of PS 10 Strictly speaking, it also does depends on the specific termination criterion used by UCP. However, this dependency can be ignored as long as UCP uses a termination criterion that effectively checks if a minimal candidate corresponds to a solution (see <ref> [19] </ref>) 21 refinement, this follows readily, since the only constraint types that UCP plans have, and the plans used in pure plan-space planners do not [19] are the contiguity constraints. <p> this dependency can be ignored as long as UCP uses a termination criterion that effectively checks if a minimal candidate corresponds to a solution (see <ref> [19] </ref>) 21 refinement, this follows readily, since the only constraint types that UCP plans have, and the plans used in pure plan-space planners do not [19] are the contiguity constraints. However, since contiguity constraints are strictly stronger than precedence constraints (in that the former imply the latter), the completeness results will hold for UCP plans too. (This is why the PS refinement in UCP is identical to the one given in [19]). <p> plan-space planners do not <ref> [19] </ref> are the contiguity constraints. However, since contiguity constraints are strictly stronger than precedence constraints (in that the former imply the latter), the completeness results will hold for UCP plans too. (This is why the PS refinement in UCP is identical to the one given in [19]). The completeness of FSS and BSS refinements on UCP plans is not as obvious since the plans used by pure FSS and BSS planners do not contain precedence or IPC constraints. We will sketch how FSS continues to be complete even when applied to an arbitrary plan. <p> Recall that as pointed out by McAllester (see <ref> [25, 19] </ref>), PS refinement is systematic as long as the book-keeping step uses contributor protections (that is, whenever a precondition p of a step t is established through the effects of another step t 0 , two IPCs (t 0 p :p added to the list of auxiliary constraints of the <p> PS refinement is systematic as long as the book-keeping step uses contributor protections (that is, whenever a precondition p of a step t is established through the effects of another step t 0 , two IPCs (t 0 p :p added to the list of auxiliary constraints of the plan <ref> [19] </ref>). We sketch the proof of systematicity of any instantiation of UCP that uses a PS refinement with contributor protections. To make exposition simple, we will concentrate on the system-aticity of FSS refinement both in isolation, and in the presence of other refinements. <p> not already true in the head state, or give preference to satisfying the preconditions of operators on the head fringe that have least number of unsatisfied preconditions. 7 Empirical studies on the utility of interleaving refinements We have implemented the UCP algorithm on top of the Refine-Plan implementation described in <ref> [19] </ref>. Since UCP provides a framework to interleave the three different refinements within a single problem episode, we conducted several preliminary experiments to evaluate the advantages of such interleaving. Experimental Setup: We considered six different instantiations of UCP. <p> The other three, UCP-MEA, UCP-MBA and UCP-LCFR correspond to the three hybrid refinement strategies described in the previous section. Although the plan space refinement can have considerable variation <ref> [19] </ref> based on the protection and goal selection strategies used, in our experiments, we kept them constant. We used a simple LIFO strategy for selecting the open-condition to be established, contributor protections for bookkeeping, and conflict resolution for tractability refinements. <p> We used a simple LIFO strategy for selecting the open-condition to be established, contributor protections for bookkeeping, and conflict resolution for tractability refinements. This is equivalent to the refinement strategy used by SNLP <ref> [25, 19] </ref>. (In [19] we discuss the performance tradeoffs offered by the other ways of instantiating the plan-space refinement). <p> We used a simple LIFO strategy for selecting the open-condition to be established, contributor protections for bookkeeping, and conflict resolution for tractability refinements. This is equivalent to the refinement strategy used by SNLP [25, 19]. (In <ref> [19] </ref> we discuss the performance tradeoffs offered by the other ways of instantiating the plan-space refinement). <p> Although less constrained plans are more likely to be serially extensible, more constrained plans do have their advantages. They are typically easier to handle in terms of consistency and terminations checks <ref> [19] </ref>. Given a domain containing subgoals that are trivially serializ-able for two classes of plans b P 1 and b P 2 , it can be more efficient to do planning with the more constrained class of plans. <p> are more committed than those of UCP-PS and less committed than those of UCP-FSS. 10 Related Work Earlier work on unifying classical planning approaches includes Rosenchien's work [31] on bigression planner, which combines a forward state space search and a backward state space search; and our own more recent work <ref> [19, 17, 18] </ref> unifying a variety of plan-space planning frameworks into one algorithm template. To our knowledge, this paper is the first to rationally place the plan-space and state-space refinements in one unifying framework. <p> To our knowledge, this paper is the first to rationally place the plan-space and state-space refinements in one unifying framework. The semantic model of refinement planning used in this paper is mostly similar to the one 38 developed in our earlier work <ref> [19] </ref>. One key difference is the differentiation of progressive and non-progressive refinements that is introduced in this paper. In [19] the description of PS refinement is folded with the description of the non-progressive refinements, while in this paper they are separated. <p> The semantic model of refinement planning used in this paper is mostly similar to the one 38 developed in our earlier work <ref> [19] </ref>. One key difference is the differentiation of progressive and non-progressive refinements that is introduced in this paper. In [19] the description of PS refinement is folded with the description of the non-progressive refinements, while in this paper they are separated. As the discussion in this paper should show, non-progressive refinements do not help the refinement planner in progressing towards termination.
Reference: [20] <author> S. Kambhampati. </author> <title> A comparative analysis of partial-order planning and task reduction planning. </title> <journal> ACM SIGART Bulletin, Special Section on Evaluating Plans, Planners and Planning agents, </journal> <volume> Vol. 6., No. 1, </volume> <month> January, </month> <year> 1995. </year>
Reference: [21] <author> S. Kambhampati and B. Srivastava. </author> <title> Universal Classical Planner: An algorithm for unifying state space and plan space approaches. In New Trends in AI Planning: EWSP 95, </title> <publisher> IOS Press, </publisher> <year> 1995. </year>
Reference-contexts: In this paper, we show that the same framework can be extended to unify state-space planning and plan-space planning approaches. In particular, we present UCP <ref> [21] </ref>, a generalized algorithm for classical planning. UCP covers classical planning approaches through three complementary refinement strategies, corresponding respectively to the plan-space, forward state-space and backward state-space planning approaches. <p> Because he and hf conditions are deleted by many steps, the subplans for individual top-level goals will have many interactions, even though the overall plans are all serially extensible. We tested this domain on several instantiations of UCP <ref> [21] </ref> that generate different subclasses of plans, including prefix plans (UCP-FSS), protected elastic plans (UCP-PS) and blocked plans (UCP-BLK). The results are shown in the plot in Figure 14.
Reference: [22] <author> S. Kambhampati, L. Ihrig and B. Srivastava. </author> <title> A Candidate Set based analysis of Subgoal Interactions in conjunctive goal planning In Proc. </title> <address> AIPS-96, </address> <year> 1996. </year>
Reference-contexts: Although subgoal and subplan interactions have been studied in the past [2, 24], they have been couched in terms of the details of specific classical planners. We present a more generalized analysis based on candidate set of subplans for individual subgoals <ref> [22] </ref>. Since subgoals interact in terms of their subplans, we will start by characterizing two important ways in which partial plans may interact mergeability and serial extensibility.
Reference: [23] <author> S. Kambhampati and X. Yang. </author> <title> On the role of Disjunctive Representations and Constraint Propagation in Refinement Planning In Proc. </title> <address> KR-96, </address> <year> 1996. </year> <note> (In Press). </note>
Reference-contexts: We have initiated work in this direction. Specifically, in <ref> [23] </ref>, we show that algorithms like Graphplan fit into the UCP framework quite squarely, once we realize that a partial plan representation can involve disjunctive constraints.
Reference: [24] <author> R. Korf. </author> <title> Planning as Search: A Quantitative Approach. </title> <journal> Artificial Intelligence, </journal> <volume> Vol. 33, </volume> <year> 1987. </year>
Reference-contexts: Although subgoal and subplan interactions have been studied in the past <ref> [2, 24] </ref>, they have been couched in terms of the details of specific classical planners. We present a more generalized analysis based on candidate set of subplans for individual subgoals [22]. <p> Although considerable work has been done on understanding subgoal interactions <ref> [24, 2, 35, 14] </ref>, much of this has been done in terms of the specifics of state space [24] or plan-space planners [2]. <p> Although considerable work has been done on understanding subgoal interactions [24, 2, 35, 14], much of this has been done in terms of the specifics of state space <ref> [24] </ref> or plan-space planners [2]. It turns out that both subplan extension and merging could be understood cleanly in terms of the candidate set semantics of the partial plans developed in Section 3. In the following, we provide such an analysis. <p> This leads to the notion of optimal parallelizability. The optimality and efficiency restrictions on parallelizability can of course be combined. In fact, Korf's definition of subgoal independence <ref> [24] </ref>, implies optimal and trivial parallelizability of all subgoals. <p> In this section, we will explain how our characterization subsumes the existing work by identifying the specific classes of plans over which the existing characterizations of subgoal interactions are implicitly based. 8.4.1 Korf's Subgoal Interactions Korf <ref> [24] </ref> defines two subgoals to be serializable if there exists an ordering among the subgoals such that they can be planned for sequentially, such that once the first goal is achieved, the agent never passes through a state where the first goal is violated. 12 The Sussman anomaly has non-serializable subgoals <p> the IPC (P uton (B; C) On (B;C) t 1 ) is serially extensible with respect to On (B; C); although the plan t 0 fl P uton (B; C) t 1 , with the same IPC is not. 8.4.2 Barrett and Weld's Serializability Barett and Weld [2] extended Korf's <ref> [24] </ref> subgoal interaction analysis to plan space planners, and showed that problems like Sussman anomaly are serializable for the partial order planner SNLP. <p> Finally, our candidate set based subgoal interaction analysis builds on existing work on subgoal interaction analysis <ref> [24, 2, 35] </ref>. A detailed discussion of the relations can be found in Section 8.4. 11 Conclusion and Future Work In this paper, we presented a generalized algorithm template, called UCP, which allows plan-space and state-space refinements on a single partial plan representation.
Reference: [25] <author> D. McAllester and D. Rosenblitt. </author> <title> Systematic Nonlinear Planning. </title> <booktitle> In Proc. 9th AAAI, </booktitle> <year> 1991. </year>
Reference-contexts: Similarly, if all the refinement strategies are systematic, the search space of the planner will be systematic in that no ground operator sequence will belong to the candidate sets of plans in more than one branch of the search tree <ref> [25] </ref>. 3 Representation of partial plans in UCP In this section, we will develop a syntactic and semantic representation of partial plans that is adequate to support both state-space and plan-space refinements. <p> The optional bookkeeping step can add auxiliary (interval preservation) constraints to protect the establishment decisions. Specifically, when a precondition p of a step s is established using another step s 0 , PS adds an IPC (s 0 p s). Some planners, like SNLP <ref> [25] </ref> not only protect the condition p from being deleted, but also ensure that no other step intervening between s 0 and s will give p. <p> There may of course be more specialized realizations of the termination check that are more efficient for specific instantiations of UCP. For example, pure plan space planners using causal links can use a causal link based termination check used in SNLP <ref> [25, 19] </ref>, which continue to refine a plan until all preconditions of all steps have been considered for establishment, and none of the IPCs are violated. <p> In particular, in [19, 17, 18], we showed that the plan space refinement template, given in <ref> [25] </ref>, and TWEAK [6]. What is more interesting, as shown in Section 4.5, is the fact that the UCP algorithm also allows hybrid planners that can opportunistically apply plan-space as well as state-space refinements within a single planning episode. <p> Recall that as pointed out by McAllester (see <ref> [25, 19] </ref>), PS refinement is systematic as long as the book-keeping step uses contributor protections (that is, whenever a precondition p of a step t is established through the effects of another step t 0 , two IPCs (t 0 p :p added to the list of auxiliary constraints of the <p> We used a simple LIFO strategy for selecting the open-condition to be established, contributor protections for bookkeeping, and conflict resolution for tractability refinements. This is equivalent to the refinement strategy used by SNLP <ref> [25, 19] </ref>. (In [19] we discuss the performance tradeoffs offered by the other ways of instantiating the plan-space refinement).
Reference: [26] <author> D. McDermott. </author> <title> A heuristic estimator for means-ends analysis in planning. </title> <booktitle> In Proc. </booktitle> <address> AIPS-96, </address> <year> 1996. </year> <month> 42 </month>
Reference-contexts: This type of recursive analysis can be continued to find the set of relevant operators, and focus progression refinement. See <ref> [26] </ref> for an example of a FSS planner that uses this type of subgoaling trees to focus its attention. 4.1.2 Plan-space Refinements Both FSS and BSS refinements attempt to guess the relevance (i.e., is this step going to be part of a solution for this problem) and position (i.e., when, during
Reference: [27] <author> S. Minton. </author> <title> Learning Effective Search Control Knowledge: An Explanation-Based Ap--proach. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <address> Pittsburgh, PA, </address> <year> 1988. </year>
Reference-contexts: The problems were generated using the random blocks world problem generator described in <ref> [27] </ref>. Each data point represents the average over 10 random problems containing a specified number of blocks. The data points in the graph correspond to situations where all 10 random problems were solved by the specific instantiation of UCP.
Reference: [28] <author> S. Minton, J. Bresina and M. Drummond. </author> <title> Total Order and Partial Order Planning: a comparative analysis. </title> <note> Journal of Artificial Intelligence Research 2 (1994) 227-262. </note>
Reference-contexts: Since by Korf's original definition, both these problems are non-serializable, and thus indistinguishable, we note that by considering serializability in terms of classes of plans, we can make finer-grained distinctions among different problems. 34 and UA <ref> [28] </ref>, or planners that use disjunctive protections (e.g. multi-contributor causal links) such as MP and MP-I [16]. Thus, there may be domains with subgoals that are not serializable with respect to SNLP but are serializable with respect to these latter planners.
Reference: [29] <author> E.P.D. Pednault. </author> <title> Synthesizing Plans that contain actions with Context-Dependent Effects. </title> <journal> Computational Intelligence, </journal> <volume> Vol. 4, </volume> <month> 356-372 </month> <year> (1988). </year>
Reference-contexts: ST is a symbol table, which maps step names to actions. (Note that multiple steps can be mapped to the same action.) We will assume that actions are modeled in the familiar STRIPS/ADL representation <ref> [29] </ref> with precondition and effect (aka postcondition) lists. The special step t 0 is always mapped to the dummy operator start, and similarly t 1 is always mapped to finish. <p> The refinements consist of P + (s t s 1 ) _ s 2 s t ) and P + p s t @s t , where p s t denotes the preservation preconditions of s t with respect to p <ref> [29] </ref>.
Reference: [30] <author> E.P.D. Pednault. </author> <title> Generalizing nonlinear planning to handle complex goals and actions with context dependent effects. </title> <booktitle> In Proc. IJCAI-91, </booktitle> <year> 1991. </year>
Reference-contexts: Specifically, the FSS refinement considers all possible executable prefixes, and BSS refinement considers all possible suffixes that can end in a goal state. The completeness of PS refinement is somewhat more subtle, but follows from Pednault's work <ref> [30] </ref>. The next order of business is to convince ourselves that these refinements remain complete even when they are applied to an arbitrary plan in the UCP represenstation. In the case of PS 10 Strictly speaking, it also does depends on the specific termination criterion used by UCP.
Reference: [31] <author> S. Rosenchien. </author> <title> Plan Synthesis: A logical perspective. </title> <booktitle> Proc. IJCAI-81, </booktitle> <year> 1981. </year>
Reference-contexts: both UCP-PS which produces least committed plans, and UCP-FSS which produces most committed plans, are out performed by UCP-BLK which produces plans that are more committed than those of UCP-PS and less committed than those of UCP-FSS. 10 Related Work Earlier work on unifying classical planning approaches includes Rosenchien's work <ref> [31] </ref> on bigression planner, which combines a forward state space search and a backward state space search; and our own more recent work [19, 17, 18] unifying a variety of plan-space planning frameworks into one algorithm template.
Reference: [32] <author> E. Sacerdoti. </author> <title> The nonlinear nature of plans. </title> <booktitle> In Proc. IJCAI-75, </booktitle> <year> 1975. </year>
Reference-contexts: However, they are motivated by the need to reduce the plan handling costs (specifically, the costs of solution extraction and consistency checking) [19]. Non-progressive refinements have thus been called tractability refinements [19] and critics <ref> [32] </ref>. There are essentially three types of non-progressive refinements used in refinement planning. The first two, called pre-ordering and pre-positioning refinements constrain the relative order and position of a pair of steps in mutually exclusive and exhaustive ways in the different branches.
Reference: [33] <author> A. Tate. </author> <title> Generating Project Networks. </title> <booktitle> In Proceedings of IJCAI-77, </booktitle> <pages> pages 888893, </pages> <address> Boston, MA, </address> <year> 1977. </year>
Reference: [34] <author> D. Wilkins. </author> <title> Practical Planning. </title> <publisher> Morgan Kaufmann (1988). </publisher>
Reference: [35] <author> M. Veloso and J. Blythe. Linkability: </author> <title> Examining causal link commitments in partial-order planning. </title> <booktitle> Proceedings of AIps-94, </booktitle> <year> 1994. </year>
Reference-contexts: 1 Introduction Domain independent classical planning techniques fall into two broad categories state space planners which search in the space of states, and plan space planners which search in the space of plans. By and large, these approaches have been seen as competing rather than complementary, and several research efforts <ref> [2, 35] </ref> have been focused on showing the relative superiority of one over the other. <p> The traditional question when should a plan-space planner be preferred over state space planners? <ref> [2, 35] </ref> can now be posed in a more sophisticated form: when should a plan-space refinement be preferred over a state-space refinement (or vice versa) within a single planning episode?. <p> Our intent was to show that appropriate hybrid instantiations of UCP may do well in all such domains. The first domain, called link-chain domain, was designed by Veloso & Blythe <ref> [35] </ref> to showcase the advantages of state space means-ends analysis planners over plan-space planners. This domain contains ten actions A 1 to A 10 . <p> Although considerable work has been done on understanding subgoal interactions <ref> [24, 2, 35, 14] </ref>, much of this has been done in terms of the specifics of state space [24] or plan-space planners [2]. <p> This difficulty goes away when we restrict our attention to the class of unprotected elastic plans. In <ref> [35] </ref>, Veloso and Blythe also provide a range of domains where protection commitments become the critical issues with respect to serializability. <p> Finally, our candidate set based subgoal interaction analysis builds on existing work on subgoal interaction analysis <ref> [24, 2, 35] </ref>. A detailed discussion of the relations can be found in Section 8.4. 11 Conclusion and Future Work In this paper, we presented a generalized algorithm template, called UCP, which allows plan-space and state-space refinements on a single partial plan representation.
Reference: [36] <author> D. Weld. </author> <title> Introduction to Partial Order Planning. </title> <journal> AI Magazine, </journal> <volume> Vol. 15, No. 4, </volume> <year> 1994. </year>
Reference: [37] <author> Q. Yang, D. Nau and J. Hendler. </author> <title> Merging separately generated plans with restricted interactions. </title> <journal> Computational Intelligence, </journal> <volume> 8(2) </volume> <pages> 648-676, </pages> <month> February </month> <year> 1992 </year>
Reference-contexts: Simple mergeability essentially ensures that the plans can be merged without adding any new steps, or combining existing steps (thus bounding the amount of effort required in the merging phase). In contrast, the merging involving addition and combination of steps can be as costly as planning itself <ref> [37] </ref>. Even simple mergeability can lead to costly merging phases (as a possibly exponential number of combined linearizations of the two plans need to be considered). Trivial mergeability is the most restrictive as it requires that the merging operation only involve unioning the constraint sets of the two plans. <p> For parallelization to be a win, the cost of merging should be small. The cost depends upon the type of merging (trivial, simple or non-simple). While trivial mergeability takes constant time, and simple mergeability can be NP-hard <ref> [37] </ref>, merging involving the addition and deletion of actions can be as costly as planning itself.
Reference: [38] <author> E. Fink and Q. Yang. </author> <title> Planning with Primary Effects: Experiments and Analysis. </title> <booktitle> In Proc. IJCAI-95, </booktitle> <year> 1995. </year>
Reference: [39] <author> R.M. Young, M.E. Pollack and J.D. Moore. </author> <title> Decomposition and Causality in Partial-Order Planning. </title> <booktitle> In Proc. 2nd Intl. Conf. on AI Planning Systems, </booktitle> <year> 1994. </year>
References-found: 39

