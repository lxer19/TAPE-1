URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/user/boyland/www/promises.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/user/boyland/www/promises.html
Root-URL: 
Email: chance@cs.cmu.edu  John.Boyland@acm.org  scherlis@cs.cmu.edu  
Phone: +1 412 268 3076  +1 412 268 3738  +1 412 268 8741  
Title: Promises: Limited Specifications for Analysis and Manipulation  
Author: Edwin C. Chan John T. Boyland William L. Scherlis 
Keyword: Aliasing, effects, program restructuring, headers, implementation flexibility, limited references, effect regions, separate compilation, unique references  
Note: 0-8186-8368-6/98 $10.00 c 1998 IEEE  
Address: Pittsburgh, PA USA 15213  Pittsburgh, PA USA 15213  Pittsburgh, PA USA 15213  
Affiliation: Computer Science Department Carnegie Mellon University  Computer Science Department Carnegie Mellon University  Computer Science Department Carnegie Mellon University  
Abstract: Structural change in a large system is hindered when information is missing about portions of the system, as is often the case in a distributed development process. An annotation mechanism called promises is described for expressing properties that can enable many kinds of structural change in systems. Promises act as surrogates for an actual component, and thus are analogous to "header" files, but with more specific semantic information. Unlike formal specifications, however, promises are designed to be easily extracted from systems and managed by programmers using automatic analysis tools. Promises are described for effects, unique references, and use properties. By using promises, a component developer can offer additional opportunity for change (flexibility) to clients, but at a potential cost in flexibility for the component itself. This suggests the possibility of using promises as a means to allocate flexibility among the components of a system. fl This material is based upon work supported by the National Science Foundation under Grant No. CCR-9504339 and by the Defense Advanced Research Projects Agency and Rome Laboratory, Air Force Materiel Command, USAF, under agreement number F30602-97-2-0241. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright annotation thereon. The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of the Defense Advanced Research Projects Agency, Rome Laboratory, the National Science Foundation, or the U.S. Government. c fl1998 IEEE. Personal use of this material is permitted. However, permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works must be obtained from the IEEE. 20 th International Conference on Software Engineering (ICSE '98), April 19-25, Kyoto, Japan. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aiken, M. Fahndrich, and R. Levien. </author> <title> Better static memory management: Improving region-based analysis of higher-order languages. </title> <booktitle> In ACM SIGPLAN PLDI'95 Conference, </booktitle> <pages> pages 174-185, </pages> <address> New York, June 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The work was motivated by a desire to use stack allocation instead of heap allocation in mostly pure functional programs, and also to assist parallel code generation. The approach was demonstrated successful for the former purpose in later work <ref> [22, 1] </ref>. These researchers also make use of a concept of disjoint "regions" of mutable state, but these regions are global, as opposed to within objects. In the original FX system, effects can be verified and exploited in separately developed program components.
Reference: [2] <author> P. S. Almeida. </author> <title> Balloon types: Controlling sharing of state in data types. </title> <editor> In M. Ak~sit and S. Matsuoka, editors, </editor> <booktitle> ECOOP '97 | Object-Oriented Programming (11th European Conference), volume 1241 of Lecture Notes in Computer Science, </booktitle> <pages> pages 32-59, </pages> <address> Berlin, June 1997. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Baker's `use once' variables [4] show the fundamental rules that any such system should follow. Hogg [12] presented a notation for Smalltalk that enabled the identification of "islands," regions of objects accessible only through a single bridge point. This work has been made simpler and more powerful by Almeida <ref> [2] </ref>, where it is shown that a range of types: balloon types, opaque balloon types, and value types can be declared and checked in the context of an Algol-like language.
Reference: [3] <author> H. G. Baker. </author> <title> Lively linear Lisp | `Look Ma, no garbage!'. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(9) </volume> <pages> 89-98, </pages> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: One obvious way to achieve that situation is to never allow any aliases, but, in general, that restriction is impractical (but see Baker's Linear Lisp <ref> [3] </ref>). Still, these insights motivate the concepts behind unique parameters and return values. References (other than null) passed as such parameters or returned from methods or constructors so declared can thus be counted on to be distinct from any reference stored in another variable or returned by any method.
Reference: [4] <author> H. G. Baker. </author> <title> `Use-once' variables and linear objects: Storage management, reflection and multi-threading. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 30(1) </volume> <pages> 45-52, </pages> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: They are selectively applied (to parts of a Java program) and allow specification of effects on parts of an object. Adding notation for unique pointers was studied by 175 Minsky [16] in the context of Eiffel. Baker's `use once' variables <ref> [4] </ref> show the fundamental rules that any such system should follow. Hogg [12] presented a notation for Smalltalk that enabled the identification of "islands," regions of objects accessible only through a single bridge point.
Reference: [5] <author> D. L. Detlefs. </author> <title> An overview of the extended static checking system. </title> <booktitle> In First workshop on Formal Methods in Software Practice, </booktitle> <year> 1996. </year>
Reference-contexts: This project was carried out in the context of Larch [11], a formal specification and theorem proving system, which similarly used a variety of proof-supported resources for partially or fully specifying the behavior of separately developed entities. In particular, Larch supports mutability annotations. `Extended static checking' <ref> [5, 15] </ref>, which also uses a theorem prover, has been incorporated into experimental Modula-3 compilers. In particular, lock level annotations were successfully used in the Trestle window system to ensure the absence of deadlocks.
Reference: [6] <author> D. Evans. </author> <title> Static detection of dynamic memory errors. </title> <booktitle> In ACM SIGPLAN PLDI'96 Conference, </booktitle> <pages> pages 44-53, </pages> <address> New York, May 1996. </address> <publisher> ACM Press. </publisher>
Reference-contexts: They speculate that these signatures could be programmer-specified. Other researchers have used the technique of enhanced "header files" for breaking intractable global consistency issues into locally manageable statically checkable pieces. As noted above, LCLint <ref> [21, 6] </ref> used annotations on pointer types in C in order to statically check for dangling pointers and storage leakage.
Reference: [7] <author> D. Evans, J. Guttag, J. Horning, and Y. M. Tan. Lclint: </author> <title> A tool for using specifications to check code. </title> <booktitle> In 2nd ACM SIGSOFT Symposium on Foundations of Software Engineering, </booktitle> <pages> pages 87-96, </pages> <address> New Orleans, Louisiana, </address> <month> December 6-9 </month> <year> 1994. </year>
Reference-contexts: Promises are intended to be sufficiently easy to specify and validate that they can be used in routine design and programming activity, particularly program evolution using tool assistance. In this regard, promises are similar to the C-language annotations of tools such as LCLint <ref> [7] </ref>. The LCLint annotations focus on a different set of goals|specification of encapsulations and error-detection. For example, LCLint provides an annotation language for the explicit specification of programmer-intended abstract data type boundaries, which are not directly expressible in the C language.
Reference: [8] <author> C. Flanagan and M. Felleisen. </author> <title> Componential set-based analysis. </title> <booktitle> In ACM SIGPLAN PLDI'97 Conference, </booktitle> <pages> pages 235-248, </pages> <address> Las Vegas, Nevada, </address> <month> June 15-18, </month> <year> 1997. </year>
Reference-contexts: Unlike promises, however, these annotations are not interprocedural in nature and they are not supported by a system that permits verification options ranging from fully proved to simply trusted. Flanagan and Felleisen <ref> [8] </ref> describe a set-based dataflow analysis that integrates the results of separately analyzing components. As an aside, they propose summarizing the voluminous machine-generated set constraints with signatures that approximate the exact constraints. They speculate that these signatures could be programmer-specified.
Reference: [9] <author> D. K. Gifford, P. Jouvelot, J. M. Lucassen, and M. A. Sheldon. </author> <title> FX-87 reference manual. </title> <type> Technical Report MIT/LCS/TR-407, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> Sept. </month> <year> 1987. </year>
Reference-contexts: In his work, however, the specifications are necessary effects, in order to check for missing functionality; whereas in our system the specified effects must include all effects of a method. Effects were first studied in the FX system <ref> [9] </ref>, a higher-order functional language with reference cells. The burden of manual specification of effects is lifted through the use of effects inference as studied by Gifford, Jou-velot, and Taplin [14, 20].
Reference: [10] <author> W. G. Griswold and D. Notkin. </author> <title> Automated assistance for program restructuring. </title> <journal> ACM TOSEM, </journal> <volume> 2(3), </volume> <year> 1993. </year>
Reference-contexts: And tools can exploit promise information to help a software engineer carry out larger-scale structural change not otherwise feasible particularly on incomplete programs <ref> [10, 17, 19] </ref>. As with other kinds of specifications, however, there are costs|each promise must be identified and expressed. Nonetheless, we suggest that promises differ from full functional specifications in two important respects. First, the limited semantic content of promises makes them easier to state, validate, and exploit. <p> Promises additionally may be verified by external tools, or even by hand. This flexibility permits promises to be useful as soon as they are deployed rather than requiring an entire program to be annotated before it can be accepted. Griswold and Notkin <ref> [10] </ref> have a tool to perform meaning-preserving restructuring on Scheme programs and describe a number of basic transformation steps. They keep the source, a program dependence graph (PDG) and control-flow graph (CFG) up-to-date with parallel transformations. The transformations are shown to preserve meaning using whole-program analysis.
Reference: [11] <author> J. V. Guttag, J. J. Horning, S. J. Garland, K. D. Jones, A. Modet, and J. M. Wing. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, Hei-delberg, New York, </address> <year> 1993. </year>
Reference-contexts: As noted above, LCLint [21, 6] used annotations on pointer types in C in order to statically check for dangling pointers and storage leakage. This project was carried out in the context of Larch <ref> [11] </ref>, a formal specification and theorem proving system, which similarly used a variety of proof-supported resources for partially or fully specifying the behavior of separately developed entities.
Reference: [12] <author> J. Hogg. </author> <title> Islands: Aliasing protection in object-oriented languages. </title> <booktitle> In OOPSLA'91, </booktitle> <pages> pages 271-285, </pages> <address> New York, Nov. 1991. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Adding notation for unique pointers was studied by 175 Minsky [16] in the context of Eiffel. Baker's `use once' variables [4] show the fundamental rules that any such system should follow. Hogg <ref> [12] </ref> presented a notation for Smalltalk that enabled the identification of "islands," regions of objects accessible only through a single bridge point.
Reference: [13] <author> D. Jackson. </author> <title> Aspect: Detecting bugs with abstract dependencies. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 4(2) </volume> <pages> 109-145, </pages> <month> Apr. </month> <year> 1995. </year>
Reference-contexts: In particular, Larch supports mutability annotations. `Extended static checking' [5, 15], which also uses a theorem prover, has been incorporated into experimental Modula-3 compilers. In particular, lock level annotations were successfully used in the Trestle window system to ensure the absence of deadlocks. Jackson's Aspect system <ref> [13] </ref> uses a similar abstraction mechanism to our regions in order to specify the effects of routines on abstract data types. He uses specifications for each procedure in order to allow checking to proceed in a modular fashion.
Reference: [14] <author> P. Jouvelot and D. K. Gifford. </author> <title> Algebraic reconstruction on types and effects. </title> <booktitle> In 18th ACM POPL Conference, </booktitle> <pages> pages 303-310. </pages> <publisher> ACM Press, </publisher> <address> New York, </address> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: Effects were first studied in the FX system [9], a higher-order functional language with reference cells. The burden of manual specification of effects is lifted through the use of effects inference as studied by Gifford, Jou-velot, and Taplin <ref> [14, 20] </ref>. The work was motivated by a desire to use stack allocation instead of heap allocation in mostly pure functional programs, and also to assist parallel code generation. The approach was demonstrated successful for the former purpose in later work [22, 1].
Reference: [15] <author> K. R. M. Leino. </author> <title> Toward Reliable Modular Programs. </title> <type> PhD thesis, </type> <institution> California Institute of Technology, Pasadena, California, USA, </institution> <year> 1995. </year> <note> Available as Technical Report Caltech-CS-TR-95-03. </note>
Reference-contexts: This project was carried out in the context of Larch [11], a formal specification and theorem proving system, which similarly used a variety of proof-supported resources for partially or fully specifying the behavior of separately developed entities. In particular, Larch supports mutability annotations. `Extended static checking' <ref> [5, 15] </ref>, which also uses a theorem prover, has been incorporated into experimental Modula-3 compilers. In particular, lock level annotations were successfully used in the Trestle window system to ensure the absence of deadlocks.
Reference: [16] <author> N. Minsky. </author> <title> Towards alias-free pointers. </title> <editor> In P. Cointe, editor, </editor> <booktitle> ECOOP '96, volume 1098 of Lecture Notes in Computer Science, </booktitle> <pages> pages 189-209, </pages> <address> Berlin, Heidelberg, New York, July 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: They are selectively applied (to parts of a Java program) and allow specification of effects on parts of an object. Adding notation for unique pointers was studied by 175 Minsky <ref> [16] </ref> in the context of Eiffel. Baker's `use once' variables [4] show the fundamental rules that any such system should follow. Hogg [12] presented a notation for Smalltalk that enabled the identification of "islands," regions of objects accessible only through a single bridge point.
Reference: [17] <author> W. Opdyke. </author> <title> Refactoring Object-Oriented Frameworks. </title> <type> PhD thesis, </type> <institution> University of Illinois, </institution> <year> 1992. </year>
Reference-contexts: And tools can exploit promise information to help a software engineer carry out larger-scale structural change not otherwise feasible particularly on incomplete programs <ref> [10, 17, 19] </ref>. As with other kinds of specifications, however, there are costs|each promise must be identified and expressed. Nonetheless, we suggest that promises differ from full functional specifications in two important respects. First, the limited semantic content of promises makes them easier to state, validate, and exploit.
Reference: [18] <author> J. C. Reynolds. </author> <title> Syntactic control of interference. </title> <booktitle> In 5th Annual ACM POPL Symposium, </booktitle> <pages> pages 39-46, </pages> <month> January 23-25 </month> <year> 1978. </year>
Reference-contexts: These researchers also make use of a concept of disjoint "regions" of mutable state, but these regions are global, as opposed to within objects. In the original FX system, effects can be verified and exploited in separately developed program components. Reynolds <ref> [18] </ref> originated the idea of "syntactic control of interference." The intent was to develop an Algol-like programming language that used syntactic properties to eliminate "anonymous channels of interference." Region promises are similar in intent, but differ in realization.
Reference: [19] <author> W. L. Scherlis. </author> <title> Small-scale structural reengineering of software. </title> <booktitle> In ACM SIGSOFT 2nd International Workshop on Software Architecture, </booktitle> <pages> pages 116-120. </pages> <publisher> ACM Press, </publisher> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: And tools can exploit promise information to help a software engineer carry out larger-scale structural change not otherwise feasible particularly on incomplete programs <ref> [10, 17, 19] </ref>. As with other kinds of specifications, however, there are costs|each promise must be identified and expressed. Nonetheless, we suggest that promises differ from full functional specifications in two important respects. First, the limited semantic content of promises makes them easier to state, validate, and exploit.
Reference: [20] <author> J.-P. Talpin and P. Jouvelot. </author> <title> Polymorphic type, region and effect inference. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(3) </volume> <pages> 245-271, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Effects were first studied in the FX system [9], a higher-order functional language with reference cells. The burden of manual specification of effects is lifted through the use of effects inference as studied by Gifford, Jou-velot, and Taplin <ref> [14, 20] </ref>. The work was motivated by a desire to use stack allocation instead of heap allocation in mostly pure functional programs, and also to assist parallel code generation. The approach was demonstrated successful for the former purpose in later work [22, 1].
Reference: [21] <author> Y. M. Tan. </author> <title> Formal specification techniques for promoting software modularity, enhancing software documentation, and testing specifications. </title> <type> Technical Report MIT/LCS/TR-619, </type> <institution> MIT, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: They speculate that these signatures could be programmer-specified. Other researchers have used the technique of enhanced "header files" for breaking intractable global consistency issues into locally manageable statically checkable pieces. As noted above, LCLint <ref> [21, 6] </ref> used annotations on pointer types in C in order to statically check for dangling pointers and storage leakage.
Reference: [22] <author> M. Tofte and J.-P. Talpin. </author> <title> Implementation of the typed call-by-value -calculus using a stack of regions. </title> <booktitle> In 21st ACM POPL Conference, </booktitle> <pages> pages 188-201, </pages> <address> New York, Jan. 1994. </address> <publisher> ACM Press. </publisher> <pages> 176 </pages>
Reference-contexts: The work was motivated by a desire to use stack allocation instead of heap allocation in mostly pure functional programs, and also to assist parallel code generation. The approach was demonstrated successful for the former purpose in later work <ref> [22, 1] </ref>. These researchers also make use of a concept of disjoint "regions" of mutable state, but these regions are global, as opposed to within objects. In the original FX system, effects can be verified and exploited in separately developed program components.
References-found: 22

