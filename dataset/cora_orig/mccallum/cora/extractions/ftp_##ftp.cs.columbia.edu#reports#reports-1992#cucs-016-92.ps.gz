URL: ftp://ftp.cs.columbia.edu/reports/reports-1992/cucs-016-92.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1992.html
Root-URL: http://www.cs.columbia.edu
Title: A Bi-Level Language for Software Process Modeling  
Author: Gail E. Kaiser, Steven S. Popovich and Israel Z. Ben-Shaul Gail E. Kaiser, Steven S. Popovich and Israel Z. Ben-Shaul 
Keyword: multi-user environments, process-centered environments, process programming languages  
Note: Copyright 1992  
Address: 500 West 120th Street New York, NY 10027  
Affiliation: Columbia University Department of Computer Science  
Pubnum: CUCS-016-92  
Email: -kaiser,popovich,israel-@cs.columbia.edu  
Phone: 212-939-7000/fax: 212-666-0140  
Date: 14 September 1992  
Abstract: Most software process modeling formalisms are well-suited to one of two levels of specification, but not both. Some process languages concentrate on global control flow and synchronization; these languages make it easy to define the broad outline of a process, but harder (or even impossible) to refine the process by expressing constraints and policies on individual tools and data. Other process formalisms are inherently local: it is easy to define constraints, but far from straightforward to express control flow. We propose combining global and local formalisms to produce single but bi-level process modeling languages. We present our bi-level Activity Structures Language, which combines constrained expressions with rules, and its implementation on top of the MARVEL 3.0 multi-user environment. The Programming Systems Laboratory is supported by National Science Foundation grants CCR-9106368 and CCR-8858029, by grants and fellowships from AT&T, BNR, DEC, IBM and SRA, by the New York State Center for Advanced Technology in Computers and Information Systems and by the NSF Engineering Research Center for Telecommunications Research. 
Abstract-found: 1
Intro-found: 1
Reference: [Ambriola 90] <author> V. Ambriola, P. Ciancarini and [Bates 88] Peter Bates. </author> <title> Distributed Debugging C. Montangero. Software Process Enactment in Oikos. Tools for Heterogeneous Distributed Systems. </title> <editor> In 8th In Richard N. Taylor (editor), </editor> <booktitle> SIGSOFT '90 4th ACM International Conference on Distributed Computing SIGSOFT Symposium on Software Development Systems, </booktitle> <pages> pages 308-315. </pages> <booktitle> IEEE Computer Society, San Environments, </booktitle> <pages> pages 183-192. </pages> <address> Irvine CA, December, Jose CA, </address> <month> June, </month> <year> 1988. 1990. </year> <note> Special issue of Software Engineering Notes, </note>
Reference-contexts: This approach breaks down when a (sub)task fails to achieve its goal, but the authors propose an incremental replanning mechanism. Process enaction currently operates only in isolated single-user workspaces, but work is underway on facilities to support process-directed notifications and version merging across workspaces [Conradi 91]. Oikos <ref> [Ambriola 90] </ref> is implemented in Extended Shared Prolog, which combines Linda-like tuple spaces with a multi-process variant of Prolog. The top layer consists of a hierarchical structure of blackboards, which represent the work breakdown as mutually recursive process and environment blackboards.
Reference: [Belkhatir 91] <author> Noureddine Belkhatir, </author> <type> Jacky Estublier 15(6), </type> <month> December </month> <year> 1990. </year> <editor> and Walcelio L. </editor> <title> Melo. </title> <type> Adele 2: </type> <institution> A </institution>
Reference-contexts: Many PMLs are based to some extent on notational paradigms originally devised for other purposes. For example, APPL/A [Sutton 90a] extends Ada, Funsoft nets [Gruhn 91] are based on Petri nets, AP5 [Cohen 86] uses OPS5-like production rules, Darwin [Minsky 91a] employs Prolog-like logic rules, Adele <ref> [Belkhatir 91] </ref> follows database triggers, HFSP [Katayama 89] is similar to attribute grammars, etc. <p> Concurrency control operates through a ``checkout'' mechanism with change notification [Narayanaswamy 91], and data rendered inconsistent by importing from another user can be marked for later restoration of consistency [Balzer 91]. Adele 2's triggers <ref> [Belkhatir 91] </ref> are similar to AP5. PRE and POST triggers correspond to consistency rules, FAIL to repairs, and AFTER triggers to automation rules. Adele 2 employs hierarchical checkout [Belkhatir 92]. Darwin/1 laws [Minsky 91a] govern their own evolution as well as the process.
Reference: [Avrunin 86] <author> George S. Avrunin, Laura K. Dillon, </author> <title> Support to Large Software Development Process. </title> <editor> In Jack C. Wileden and William Mark Dowson (editor), </editor> <booktitle> 1st International Conference on E. </booktitle> <editor> Riddle. </editor> <title> Constrained Expressions: Adding Analysis the Software Process: Manufacturing Complex Systems, Capabilities to Design Methods for Concurrent Software pages 159-170. </title> <journal> IEEE Computer Society Press, Redondo Systems. IEEE Transactions on Software Engineering Beach CA, </journal> <month> October, </month> <year> 1991. </year> <month> SE-12(2):278-292, February, </month> <year> 1986. </year>
Reference-contexts: We present a working multi-user implementation of the former approach in this paper. We selected the MARVEL Strategy Language (MSL) [Kaiser 88] for local constraints, and a variant of constrained expressions <ref> [Avrunin 86] </ref> described by Riddle [Riddle 91] for the global control flow component. MSL provides planning system-style rules for specifying the local conditions and effects on the data parameters of each individual process step, as well as the arguments to be supplied to tools used in the step. <p> Funsoft nets attach conditions to transitions, restricting their application. There is no notion in either system, however, of attaching conditions to individual tools or data. Activity structures [Riddle 91] are an abstract process modeling formalism based on constrained expressions <ref> [Avrunin 86] </ref>. Each event models a process step. A shuffle operator specifies that its operand subexpressions are concurrent and their execution may be interleaved arbitrarily, except as explicitly restricted by send and receive primitives in the subexpressions.
Reference: [Belkhatir 92] <author> Noureddine Belkhatir, </author> <type> Jacky Estublier </type>
Reference-contexts: Adele 2's triggers [Belkhatir 91] are similar to AP5. PRE and POST triggers correspond to consistency rules, FAIL to repairs, and AFTER triggers to automation rules. Adele 2 employs hierarchical checkout <ref> [Belkhatir 92] </ref>. Darwin/1 laws [Minsky 91a] govern their own evolution as well as the process. Laws are syntactically and semantically identical to Prolog rules with unification and backtracking. Message passes among objects model process steps, with tools and users represented as active objects.
Reference: [Balzer 91] <author> Robert Balzer. Tolerating and Walcelio L. Melo. </author> <title> Cooperative Inconsistency. </title> <booktitle> In 13th International Conference on Work in Large-Scale Software Systems. Journal of Software Engineering, </booktitle> <pages> pages 158-165. </pages> <address> Austin TX, </address> <month> May, </month> <title> Software Maintenance: </title> <booktitle> Research and Practice , 1992. In 1991. </booktitle> <publisher> press. </publisher>
Reference-contexts: Process steps that imply violation of consistency constraints are either repaired or aborted, while automation rules are executed after commit. Concurrency control operates through a ``checkout'' mechanism with change notification [Narayanaswamy 91], and data rendered inconsistent by importing from another user can be marked for later restoration of consistency <ref> [Balzer 91] </ref>. Adele 2's triggers [Belkhatir 91] are similar to AP5. PRE and POST triggers correspond to consistency rules, FAIL to repairs, and AFTER triggers to automation rules. Adele 2 employs hierarchical checkout [Belkhatir 92]. Darwin/1 laws [Minsky 91a] govern their own evolution as well as the process.
Reference: [Barghouti 90] <author> Naser S. Barghouti and Gail E. Kaiser. [Ben-Shaul 92] Israel Z. Ben-Shaul, Gail E. </author> <title> Kaiser and Modeling Concurrency in Rule-Based Development George T. Heineman. An Architecture Environments. </title> <booktitle> IEEE Expert 5(6) </booktitle> <pages> 15-27, </pages> <month> December, </month> <title> 1990.for Multi-User Software Development Environments. </title> <booktitle> In 5th ACM SIGSOFT Symposium on Software Development </booktitle>
Reference-contexts: ASM interfaces to the process engine at three roughly corresponding points. When a user command is resolved to a list of possible rules according to the actual parameter types and MSL's overloading policy <ref> [Barghouti 90] </ref>, ASM automatically supplies the current AS object as an implicit parameter. A rather inefficient search finds the AS object whose clientID attribute, set by the Attach and Detach rules, matches the current client.
Reference: [Barghouti 92a] <author> Naser S. Barghouti and Gail E. Kaiser. </author> <title> Environments. </title> <address> Washington DC, </address> <month> December, </month> <year> 1992. </year> <title> In Scaling Up Rule-Based Development Environments. press. </title> <journal> International Journal on Software Engineering and Knowledge Engineering 2(1) </journal> <pages> 59-78, </pages> <month> March, </month> <year> 1992. </year> <note> [Brownston 85] Lee Brownston, </note> <author> Robert Farrell, Elaine Kant and Nancy Martin. </author> <note> Programming </note>
Reference-contexts: MARVEL backward chains in an attempt to satisfy the condition of the selected rule, whereas forward chains attempt to trigger the implications of the rule's effect. Mandatory chaining to maintain consistency is distinguished from automation chaining, which can be restricted by no_backward, no_forward or no_chain directives <ref> [Barghouti 92a] </ref>. Synchronization is implicit in data access, since MARVEL 3.0 enforces serializability among concurrent consistency chains and automation rules [Barghouti 92b]. Merlin [Schafer 92] is similar to MARVEL.
Reference: [Barghouti 92b] <author> Naser S. Barghouti. </author> <title> Supporting Expert Systems in OPS5. </title> <publisher> Addison-Wesley, </publisher> <address> Reading MA, </address> <booktitle> Cooperation in the MARVEL Process-Centered SDE. In 1985. Fifth ACM SIGSOFT Symposium on Software Development Environments. </booktitle> <address> Washington DC, </address> <note> December, </note> <author> [Bruegge 83] Bernd Bruegge and Peter Hibbard. </author> <year> 1992. </year> <title> In press. Generalized Path Expressions: A High-Level Debugging Mechanism. </title> <journal> The Journal of Systems and Software 3(4) </journal> <pages> 265-276, </pages> <month> December, </month> <year> 1983. </year>
Reference-contexts: Mandatory chaining to maintain consistency is distinguished from automation chaining, which can be restricted by no_backward, no_forward or no_chain directives [Barghouti 92a]. Synchronization is implicit in data access, since MARVEL 3.0 enforces serializability among concurrent consistency chains and automation rules <ref> [Barghouti 92b] </ref>. Merlin [Schafer 92] is similar to MARVEL. Backward chaining on logic programming rules establish which process steps are currently valid in the user's current role (s), and then forward chaining on planning system rules guide the user through an automated process sequence.
Reference: [CLF 88] <institution> CLF Project. CLF Manual USC Information Sciences Institute, </institution> <year> 1988. </year> <month> 19 </month>
Reference-contexts: Merlin [Schafer 92] is similar to MARVEL. Backward chaining on logic programming rules establish which process steps are currently valid in the user's current role (s), and then forward chaining on planning system rules guide the user through an automated process sequence. The Common Lisp Framework (CLF) <ref> [CLF 88] </ref> implements its process in AP5 rules with data-driven forward chaining [Cohen 86]. Separate rule bases specify consistency preservation and automation. Process steps that imply violation of consistency constraints are either repaired or aborted, while automation rules are executed after commit.
Reference: [Cohen 86] <author> Donald Cohen. Automatic [Heineman 91] George T. Heineman, Gail E. Kaiser, </author> <title> Compilation of Logical Specifications into Efficient Naser S. Barghouti and Israel Programs. </title> <booktitle> In 5th National Conference on Artificial Z. Ben-Shaul. Rule Chaining in MARVEL: Dynamic Intelligence, </booktitle> <pages> pages 20-25. </pages> <publisher> AAAI, </publisher> <address> Philadelphia, PA, </address> <booktitle> Binding of Parameters. In 6th Annual Knowledge-Based August, 1986. Software Engineering Conference, </booktitle> <pages> pages 215-222. </pages> <publisher> IEEE Computer Society Press, </publisher> <address> Syracuse NY, </address> <month> September, </month> <year> 1991. </year>
Reference-contexts: Enaction enforces and/or automates the desired process (see, e.g., [Thomas 91, Dowson 91]). Many PMLs are based to some extent on notational paradigms originally devised for other purposes. For example, APPL/A [Sutton 90a] extends Ada, Funsoft nets [Gruhn 91] are based on Petri nets, AP5 <ref> [Cohen 86] </ref> uses OPS5-like production rules, Darwin [Minsky 91a] employs Prolog-like logic rules, Adele [Belkhatir 91] follows database triggers, HFSP [Katayama 89] is similar to attribute grammars, etc. <p> The Common Lisp Framework (CLF) [CLF 88] implements its process in AP5 rules with data-driven forward chaining <ref> [Cohen 86] </ref>. Separate rule bases specify consistency preservation and automation. Process steps that imply violation of consistency constraints are either repaired or aborted, while automation rules are executed after commit.
Reference: [Conradi 91] <author> Reidar Conradi and Carl Chr. Malm. </author> <note> Cooperating Transactions and Workspaces in EPOS: [Iida 91] Hajimu Iida, </note> <author> Takeshi Ogihara, </author> <title> Katsuro Design and Preliminary Implementation. </title> <editor> In R. Andersen, Inoue and Koji Torii. Generating a J.A. Bubenko, Jr., and A. Solvberg (editors), </editor> <booktitle> Lecture Menu-Oriented Navigation System from Formal Notes in Computer Science. Number 498: Advanced Description of Software Development Activity Sequence. Information Systems Engineering: 3rd International In Mark Dowson (editor), 1st International Conference on Conference CAiSE '91, </booktitle> <pages> pages 375-392. </pages> <month> Springer-Verlag, </month> <title> the Software Process: Manufacturing Complex Systems, </title> <address> Trondheim, Norway, </address> <year> 1991. </year> <pages> pages 45-57. </pages> <publisher> IEEE Computer Society Press, </publisher> <address> Redondo Beach CA, </address> <month> October, </month> <year> 1991. </year>
Reference-contexts: This approach breaks down when a (sub)task fails to achieve its goal, but the authors propose an incremental replanning mechanism. Process enaction currently operates only in isolated single-user workspaces, but work is underway on facilities to support process-directed notifications and version merging across workspaces <ref> [Conradi 91] </ref>. Oikos [Ambriola 90] is implemented in Extended Shared Prolog, which combines Linda-like tuple spaces with a multi-process variant of Prolog. The top layer consists of a hierarchical structure of blackboards, which represent the work breakdown as mutually recursive process and environment blackboards.
Reference: [Deiters 90] <author> Wolfgang Deiters and Volker Gruhn. </author> <title> Managing Software Processes in the Environment [Inoue 89] Katsuro Inoue, </title> <editor> Takeshi Pgihara, Tohru MELMAC. In Richard N. Taylor (editor), </editor> <booktitle> SIGSOFT '90 Kikuno and Koji Torii. A Formal 4th ACM SIGSOFT Symposium on Software Development Adaptation Method for Process Descriptions. In 11th Environments, </booktitle> <pages> pages 193-205. </pages> <address> Irvine CA, </address> <month> December, </month> <booktitle> International Conference on Software Engineering, pages 1990. Special issue of Software Engineering Notes, </booktitle> <pages> 145-153. </pages> <publisher> IEEE Computer Science Press, </publisher> <address> Pittsburgh PA, 15(6), </address> <month> December </month> <year> 1990. </year> <month> May, </month> <year> 1989. </year>
Reference-contexts: Once a node enters the Done state, its successor nodes are enabled. A user has the freedom to choose among multiple enabled nodes and to switch back and forth among in-progress subgraphs. Multiple users may operate simultaneously, synchronizing implicitly through the precedence relations among subprocess nodes. Melmac <ref> [Deiters 90] </ref> operates similarly to the Articulator, with processes specified using a Petri net-like formalism called Funsoft nets [Gruhn 91]. Multiple transitions can be fired simultaneously to reflect simultaneous participants in the process. Funsoft nets attach conditions to transitions, restricting their application.
Reference: [Dowson 91] <author> Mark Dowson (editor). 1st [Kaiser 88] Gail E. Kaiser, Peter H. </author> <booktitle> Feiler and International Conference on the Software Process: </booktitle> <editor> Steven S. Popovich. </editor> <booktitle> Intelligent Manufacturing Complex Systems. IEEE Computer Assistance for Software Development and Maintenance. </booktitle> <publisher> Society Press, </publisher> <address> Redondo Beach CA, </address> <year> 1991. </year> <booktitle> IEEE Software 5(3) </booktitle> <pages> 40-49, </pages> <month> May, </month> <year> 1988. </year>
Reference-contexts: A dominant theme is the notion of a process-centered environment, which operates as an ``enaction'' engine for a specific process modeling language (PML). Enaction enforces and/or automates the desired process (see, e.g., <ref> [Thomas 91, Dowson 91] </ref>). Many PMLs are based to some extent on notational paradigms originally devised for other purposes.
Reference: [Gaede 91] <author> Steven L. Gaede, Brian Nejmeh and [Katayama 89] Takuya Katayama. A Hierarchical and William E. Riddle. </author> <title> Interim Report Functional Software Process Description and its Enaction. Process Management: Infrastructure Exploration Project. </title> <booktitle> In 11th International Conference on Software Technical Report 7-48-5, Software Design & Analysis, Engineering, </booktitle> <pages> pages 343-352. </pages> <institution> IEEE Computer Science March, </institution> <address> 1991. </address> <publisher> Press, </publisher> <address> Pittsburgh PA, </address> <month> May, </month> <year> 1989. </year>
Reference-contexts: Decisions at branch points might be made randomly, which might be appropriate for a process simulation, or by prompting the user, which might be useful for training. This style of enaction was in fact followed by Gaede <ref> [Gaede 91] </ref> in an earlier attempt to implement activity structures on top of the single-user MARVEL 2.6. The non-conventional (for us) ASL enaction model demonstrates the versatility of the MARVEL kernel. 10 6.1.
Reference: [Gisi 91] <author> Mark A. Gisi and Gail E. Kaiser. [Kellner 90] Marc I. Kellner and H. </author> <title> Dieter Extending A Tool Integration Language. In Mark Rombach. Session Summary: Comparisons of Software Dowson (editor), </title> <booktitle> 1st International Conference on the Process Descriptions. In Takuya Katayama (editor), 6th Software Process: Manufacturing Complex Systems, International Software Process Workshop: Support for pages 218-227. IEEE Computer Society Press, Redondo the Software Process, </booktitle> <pages> pages 7-18. </pages> <institution> IEEE Computer Beach CA, </institution> <month> October, </month> <title> 1991. </title> <publisher> Society Press, </publisher> <address> Hakodate, Japan, </address> <month> October, </month> <year> 1990. </year>
Reference-contexts: We defined a new PML called the Activity Structures Language (ASL). MSL is a proper subset of ASL. The rest of ASL consists of Riddle's constrained expressions extended with data parameters, whose types are defined by data modeling facilities already provided by MSL. MARVEL's envelope language <ref> [Gisi 91] </ref> was used ``as is'' for defining tool interfaces. ASL was implemented by translation of the extended constrained expressions into MSL, followed by normal enaction of MSL using the multi-user MARVEL 3.0 kernel [Ben-Shaul 92]. <p> CurrentUser and CurrentTime are built-in operations that return the current userid and timestamp, respectively, while CheckedOut is one of the enumerated values for the reserved_status attribute. The tool envelope invocation are given between braces "-...-"; the details of envelopes are outside the scope of this paper, see <ref> [Gisi 91] </ref>.
Reference: [Gruhn 91] <author> Volker Gruhn. Validatiuon and [Kellner 91] Marc I. Kellner, Peter H. Feiler, </author> <title> Verification of Software Process Models. </title> <type> PhD thesis, Anthony Finkelstein, </type> <institution> Takuya Forschungsberichte des Fachbereichs Informatik der Katayama, Leon J. Osterweil, Maria Universitat Dortmund, </institution> <year> 1991. </year> <note> Bericht Nr. 394/91. </note> <author> H. Penedo and H. Dieter Rombach. </author> <title> Software Process Modeling Example Problem. In Mark </title>
Reference-contexts: Enaction enforces and/or automates the desired process (see, e.g., [Thomas 91, Dowson 91]). Many PMLs are based to some extent on notational paradigms originally devised for other purposes. For example, APPL/A [Sutton 90a] extends Ada, Funsoft nets <ref> [Gruhn 91] </ref> are based on Petri nets, AP5 [Cohen 86] uses OPS5-like production rules, Darwin [Minsky 91a] employs Prolog-like logic rules, Adele [Belkhatir 91] follows database triggers, HFSP [Katayama 89] is similar to attribute grammars, etc. <p> Multiple users may operate simultaneously, synchronizing implicitly through the precedence relations among subprocess nodes. Melmac [Deiters 90] operates similarly to the Articulator, with processes specified using a Petri net-like formalism called Funsoft nets <ref> [Gruhn 91] </ref>. Multiple transitions can be fired simultaneously to reflect simultaneous participants in the process. Funsoft nets attach conditions to transitions, restricting their application. There is no notion in either system, however, of attaching conditions to individual tools or data.
Reference: [Heimbigner 91] <editor> Dennis Heimbigner and Marc Kellner. Dowson (editor), </editor> <booktitle> 1st International Conference on the Software Process Example for ISPW-7. Software Process: Manufacturing Complex Systems, </booktitle> <month> August, </month> <note> 1991 Available by anonymous ftp from pages 176-186. </note> <institution> IEEE Computer Society Press, </institution> <address> Redondo ftp.cs.colorado.edu. Beach CA, </address> <month> October, </month> <year> 1991. </year>
Reference-contexts: Many PMLs have successfully been used to model part or all of the ISPW6 [Kellner 91] or ISPW7 <ref> [Heimbigner 91] </ref> ``example problem'', but it is generally agreed that some language paradigms are better than others at expressing different aspects of software processes [Kellner 90]. One of the most important distinctions among different styles of PMLs is their affinities towards global control flow vs. local constraints.
Reference: [Heimbigner 92] <author> Dennis Heimbigner. The [Liu 91] Chunnian Liu. </author> <title> Software Process ProcessEngine: A Process State Server Approach to Planning and Execution: Coupling vs. Integration. In Process Programming. </title> <booktitle> In 5th ACM SIGSOFT Symposium R. </booktitle> <editor> Andersen, J.A. Bubenko, Jr., and A. Solvberg (editors), </editor> <booktitle> on Software Development Environments. Washington Lecture Notes in Computer Science. Number 498: </booktitle> <address> DC, </address> <month> December, </month> <year> 1992. </year> <title> In press. </title> <booktitle> Advanced Information Systems Engineering: 3rd International Conference CAiSE '91, </booktitle> <pages> pages 356-374. </pages> <publisher> Springer-Verlag, </publisher> <address> Trondheim, Norway, </address> <year> 1991. </year> <month> 20 </month>
Reference-contexts: There are then two basic approaches to developing a process-centered environment based on a bi-level PML: a common enaction engine with an internal process database, or separate enaction engines interoperating on a common but external process database. The latter has been conjectured by Heimbigner <ref> [Heimbigner 92] </ref>, but we know of no existing systems that support such interoperability among multiple process modeling formalisms. We present a working multi-user implementation of the former approach in this paper. <p> Leaving it in the rule template as a "sanity check" costs very little, while avoiding introduction of errors as the process evolves. 8. Related Work on Bi-Level PMLs Heimbigner's ProcessEngine <ref> [Heimbigner 92] </ref> is not a complete environment, but an environment component a process state server with a predefined representation for steps, called tasks, hierarchical breakdown of tasks and control flow among tasks.
Reference: [Mi 91] <author> Peiwei Mi and Walt Scacchi. [Sutton 90a] Stanley M. Sutton, Jr. APPL/A: </author> <title> A Articulation: Supporting Dynamic Evolution of Software Prototype Language for Software-Process Programming. Engineering Processes. In Ian Thomas (editor), </title> <type> 7th PhD thesis, </type> <institution> University of Colorado, </institution> <year> 1990. </year> <booktitle> International Software Process Workshop. IEEE </booktitle>
Reference-contexts: A node passes through a sequence of states, beginning with None and normally proceeding through Allocated, Ready and Active before finishing in the Done state. Other states may be reached under exceptional conditions, which require external repair to continue the process <ref> [Mi 91] </ref>. Once a node enters the Done state, its successor nodes are enabled. A user has the freedom to choose among multiple enabled nodes and to switch back and forth among in-progress subgraphs. Multiple users may operate simultaneously, synchronizing implicitly through the precedence relations among subprocess nodes.
Reference: [Sutton 90b] <author> Stanley M. Sutton, Jr. </author> <title> A Flexible Computer Society Press, </title> <address> Yountville CA, </address> <month> October, </month> <year> 1991. </year> <title> Consistency Model for Persistent Data in Software-Preprints. Process Programming Languages. </title> <editor> In Alan Dearle, </editor> <publisher> Gail </publisher>
Reference-contexts: Decision criteria are expressed as conditionals at branch points, and user choice can be incorporated through I/O statements. Subroutines minimize duplication of process segments and can encapsulate conditions together with tools and data operations. Consistency can be enforced or relaxed by transaction-like constructs <ref> [Sutton 90b] </ref>. APPL/A arguably includes both global and local facilities, but is discussed here rather than in Section 8 because it does not seem ``bi-level''. The Articulator environment [Mi 92] models processes as flow graphs in which each node represents a process step, and input/output dependencies can refine graph edges.
Reference: [Mi 92] <author> Peiwei Mi and Walt Scacchi. </author> <title> Process Shaw and Stan Zdonik (editor), Implementing Persistent Integration in CASE Environments. </title> <booktitle> IEEE Software Object Bases Principles and Practice: The 4th 9(2) </booktitle> <pages> 45-53, </pages> <month> March, </month> <year> 1992. </year> <booktitle> International Workshop on Persistent Object Systems, </booktitle> <pages> pages 297-310. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Martha's Vineyard </address>
Reference-contexts: Consistency can be enforced or relaxed by transaction-like constructs [Sutton 90b]. APPL/A arguably includes both global and local facilities, but is discussed here rather than in Section 8 because it does not seem ``bi-level''. The Articulator environment <ref> [Mi 92] </ref> models processes as flow graphs in which each node represents a process step, and input/output dependencies can refine graph edges. A node passes through a sequence of states, beginning with None and normally proceeding through Allocated, Ready and Active before finishing in the Done state.
Reference: [Minsky 90] <author> Naftaly H. Minsky and David MA, </author> <month> September, </month> <year> 1990. </year> <title> Rozenshtein. Configuration Management by Consensus: An Application of Law-Governed Systems. </title> <editor> In Richard [Thomas 91] Ian Thomas (editor). 7th International N. Taylor (editor), </editor> <booktitle> SIGSOFT '90 4th ACM SIGSOFT Software Process Workshop. IEEE Computer Society Symposium on Software Development Environments, </booktitle> <publisher> Press, </publisher> <address> Yountville CA, </address> <year> 1991. </year> <pages> Preprints. pages 44-55. </pages> <publisher> ACM Press, </publisher> <address> Irvine CA, </address> <month> December, </month> <year> 1990. </year>
Reference-contexts: The law can also replace the message contents and/or intended recipient of any message. Law-governed systems have been shown applicable to distributed protocols [Minsky 91b] and multi-user configuration management <ref> [Minsky 90] </ref>. Local PMLs are oriented towards modeling local constraints and policies. They all can state a condition that must be true (or derivable) before initiating a process step.
Reference: [Williams 88] <author> Lloyd G. </author> <title> Williams. </title> <journal> Software Process Special issue of Software Engineering Notes, </journal> <volume> 15(6), </volume> <booktitle> Modeling: A Behavioral Approach. In 10th International December 1990. Conference on Software Engineering, </booktitle> <pages> pages 174-186. </pages>
Reference-contexts: The only modification to this 85,000 line system was the addition of a 750 line module to the process engine. The idea of implementing constrained expressions in terms of MARVEL was first suggested by Williams <ref> [Williams 88] </ref>, but he did not mention the global vs. local dichotomy, which was the main purpose for our work. We motivate our approach by presenting a small process segment taken from the ISPW7 example problem that requires modeling of both control flow and constraints. <p> When the same activity occurs multiple times in an AS-def, its rule skeleton is cloned and then different such predicates and assignments are added separately for each occurrence. Williams proposed an alternative approach <ref> [Williams 88] </ref>, where conditions and effects as well as control flow are effectively specified separately for each occurrence of an activity; he did not address the problem of local variables. These implementation issues are explained in Section 9.1. 6.
Reference: [Minsky 91a] <editor> Naftaly H. Minsky. </editor> <address> Law-Governed Raffles City, Singapore, </address> <month> April, </month> <year> 1988. </year> <title> Systems. </title> <journal> Software Engineering Journal 6(5) </journal> <pages> 285-302, </pages> <month> September, </month> <year> 1991. </year>
Reference-contexts: Many PMLs are based to some extent on notational paradigms originally devised for other purposes. For example, APPL/A [Sutton 90a] extends Ada, Funsoft nets [Gruhn 91] are based on Petri nets, AP5 [Cohen 86] uses OPS5-like production rules, Darwin <ref> [Minsky 91a] </ref> employs Prolog-like logic rules, Adele [Belkhatir 91] follows database triggers, HFSP [Katayama 89] is similar to attribute grammars, etc. <p> Adele 2's triggers [Belkhatir 91] are similar to AP5. PRE and POST triggers correspond to consistency rules, FAIL to repairs, and AFTER triggers to automation rules. Adele 2 employs hierarchical checkout [Belkhatir 92]. Darwin/1 laws <ref> [Minsky 91a] </ref> govern their own evolution as well as the process. Laws are syntactically and semantically identical to Prolog rules with unification and backtracking. Message passes among objects model process steps, with tools and users represented as active objects.
Reference: [Minsky 91b] <author> Naftaly H. Minsky. </author> <title> The Imposition of Protocols Over Open Distributed Systems. </title> <journal> IEEE Transactions on Software Engineering 17(2) </journal> <pages> 183-195, </pages> <month> February, </month> <year> 1991. </year> <note> [Narayanaswamy 91] K. </note> <author> Narayanaswamy and Neil M. Goldman. </author> <title> Team Coordination: Information Sharing + Policies. </title> <editor> In Ian Thomas (editor), </editor> <booktitle> 7th International Software Process Workshop. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <address> Yountville CA, </address> <month> October, </month> <year> 1991. </year> <pages> Preprints. </pages>
Reference-contexts: The law can also replace the message contents and/or intended recipient of any message. Law-governed systems have been shown applicable to distributed protocols <ref> [Minsky 91b] </ref> and multi-user configuration management [Minsky 90]. Local PMLs are oriented towards modeling local constraints and policies. They all can state a condition that must be true (or derivable) before initiating a process step.
Reference: [Ponamgi 91] <author> M. Krish Ponamgi, Wenwey Hseush and Gail E. Kaiser. </author> <title> Debugging Multi-Threaded Programs with MPD. </title> <booktitle> IEEE Software 8(3) </booktitle> <pages> 37-43, </pages> <month> May, </month> <year> 1991. </year>
Reference-contexts: Constrained expressions were originally developed 2 for specifying event patterns in concurrent systems, and similar formalisms have been widely used in both sequential [Bruegge 83] and concurrent <ref> [Bates 88, Ponamgi 91] </ref> debuggers. We defined a new PML called the Activity Structures Language (ASL). MSL is a proper subset of ASL. The rest of ASL consists of Riddle's constrained expressions extended with data parameters, whose types are defined by data modeling facilities already provided by MSL.
Reference: [Riddle 91] <author> William E. Riddle. </author> <title> Activity Structure Definitions. </title> <type> Technical Report 7-52-3, </type> <institution> Software Design & Analysis, </institution> <month> March, </month> <year> 1991. </year>
Reference-contexts: We present a working multi-user implementation of the former approach in this paper. We selected the MARVEL Strategy Language (MSL) [Kaiser 88] for local constraints, and a variant of constrained expressions [Avrunin 86] described by Riddle <ref> [Riddle 91] </ref> for the global control flow component. MSL provides planning system-style rules for specifying the local conditions and effects on the data parameters of each individual process step, as well as the arguments to be supplied to tools used in the step. <p> Multiple transitions can be fired simultaneously to reflect simultaneous participants in the process. Funsoft nets attach conditions to transitions, restricting their application. There is no notion in either system, however, of attaching conditions to individual tools or data. Activity structures <ref> [Riddle 91] </ref> are an abstract process modeling formalism based on constrained expressions [Avrunin 86]. Each event models a process step. A shuffle operator specifies that its operand subexpressions are concurrent and their execution may be interleaved arbitrarily, except as explicitly restricted by send and receive primitives in the subexpressions.
Reference: [Schafer 92] <author> Wilhelm Schafer, Burkhard Peuschel and Stefan Wolf. </author> <title> A Knowledge-based Software Development Environment Supporting Cooperative Work. </title> <journal> International Journal on Software Engineering & Knowledge Engineering 2(1) </journal> <pages> 79-106, </pages> <month> March, </month> <year> 1992. </year>
Reference-contexts: Mandatory chaining to maintain consistency is distinguished from automation chaining, which can be restricted by no_backward, no_forward or no_chain directives [Barghouti 92a]. Synchronization is implicit in data access, since MARVEL 3.0 enforces serializability among concurrent consistency chains and automation rules [Barghouti 92b]. Merlin <ref> [Schafer 92] </ref> is similar to MARVEL. Backward chaining on logic programming rules establish which process steps are currently valid in the user's current role (s), and then forward chaining on planning system rules guide the user through an automated process sequence.
Reference: [Shinoda 89] <author> Yoichi Shinoda and Takuya Katayama. </author> <title> Towards Formal Description and Automatic Generation of Programming Environments. </title> <editor> In Fred Long (editor), </editor> <booktitle> Lecture Notes in Computer Science. Number 467: Software Engineering Environments International Workshop on Environments, </booktitle> <pages> pages 261-270. </pages> <publisher> Springer-Verlag, </publisher> <address> Chinon, France, </address> <year> 1989. </year>
Reference-contexts: However, the purely functional 15 nature of attribute grammars leads to convoluted mechanisms for expressing user interaction and requires expensive re-evaluation of all affected attributes throughout the tree after a local update. A related effort by the same group, Objective Attribute Grammars <ref> [Shinoda 89] </ref>, supports message passing and imperative computations on attributes treated as objects, with a distinction between propagated static attributes and non-propagated dynamic attributes.
References-found: 29

