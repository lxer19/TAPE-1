URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-91-1044/CS-TR-91-1044.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-91-1044/
Root-URL: http://www.cs.wisc.edu
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> N. </author> <type> Heintze, </type> <institution> et al, TThhee CCLLPP((RR)) PPrrooggrraammmmeerr''ss MMaannuuaall,, Dept. of Computer Science, Monash University, Clayton, </institution> <address> Victoria, Australia (1987). </address>
Reference-contexts: NMSL specifications are automatically evaluated for consistency. The automatic evaluation is done by mapping the NMSL statements and consistency rules onto a Prolog-like language, CLP (R) <ref> [1] </ref>. Details about the model, this mapping, and consistency evaluation are given in Chapter 5. 3.4. NMSL Operation Overview input and output of the NMSL system. The ovals represent active elements in the system. We divide the operation of this system into two aspects, the descriptive and the prescriptive aspects. <p> This is only a partial listing of the Extension Language input, the full listing is over 1000 lines long. 103 declhead ( 1 ) generic - error ("Unknown declaration ""%s"" at line %d"n", $decl <ref> [1] </ref>[1], $line); - end declhead. clause ((($1 [1] == "requests") || ($1 [1] == "modifies") || ($1 [1] == "traps")) && ($clause [1] == "queries")) generic - if (length ($*) != 1) error ("Invalid ""%s"" clause at line %d"n", $1 [1], $line); let i = 2; do - error ("extra comma at line %d"n", $line); let reqval [d] <p> This is only a partial listing of the Extension Language input, the full listing is over 1000 lines long. 103 declhead ( 1 ) generic - error ("Unknown declaration ""%s"" at line %d"n", $decl <ref> [1] </ref>[1], $line); - end declhead. clause ((($1 [1] == "requests") || ($1 [1] == "modifies") || ($1 [1] == "traps")) && ($clause [1] == "queries")) generic - if (length ($*) != 1) error ("Invalid ""%s"" clause at line %d"n", $1 [1], $line); let i = 2; do - error ("extra comma at line %d"n", $line); let reqval [d] = $1 [i]; let d <p> is only a partial listing of the Extension Language input, the full listing is over 1000 lines long. 103 declhead ( 1 ) generic - error ("Unknown declaration ""%s"" at line %d"n", $decl <ref> [1] </ref>[1], $line); - end declhead. clause ((($1 [1] == "requests") || ($1 [1] == "modifies") || ($1 [1] == "traps")) && ($clause [1] == "queries")) generic - if (length ($*) != 1) error ("Invalid ""%s"" clause at line %d"n", $1 [1], $line); let i = 2; do - error ("extra comma at line %d"n", $line); let reqval [d] = $1 [i]; let d = d + 1; if <p> of the Extension Language input, the full listing is over 1000 lines long. 103 declhead ( 1 ) generic - error ("Unknown declaration ""%s"" at line %d"n", $decl <ref> [1] </ref>[1], $line); - end declhead. clause ((($1 [1] == "requests") || ($1 [1] == "modifies") || ($1 [1] == "traps")) && ($clause [1] == "queries")) generic - if (length ($*) != 1) error ("Invalid ""%s"" clause at line %d"n", $1 [1], $line); let i = 2; do - error ("extra comma at line %d"n", $line); let reqval [d] = $1 [i]; let d = d + 1; if ((i &lt; length ($1)) && <p> generic - error ("Unknown declaration ""%s"" at line %d"n", $decl <ref> [1] </ref>[1], $line); - end declhead. clause ((($1 [1] == "requests") || ($1 [1] == "modifies") || ($1 [1] == "traps")) && ($clause [1] == "queries")) generic - if (length ($*) != 1) error ("Invalid ""%s"" clause at line %d"n", $1 [1], $line); let i = 2; do - error ("extra comma at line %d"n", $line); let reqval [d] = $1 [i]; let d = d + 1; if ((i &lt; length ($1)) && ($1 [i] != ",")) error ("missing comma at line %d"n", $line); let i = i + 1; if <p> ("extra comma at line %d"n", $line); let reqval [d] = $1 [i]; let d = d + 1; if ((i &lt; length ($1)) && ($1 [i] != ",")) error ("missing comma at line %d"n", $line); let i = i + 1; if (i &gt; length ($1)) break; - return ($1 <ref> [1] </ref>, reqval); - end clause. clause (($1 [1] == "process") && (($decl [1][1] == "system") || ($decl [1][1] == "domain"))) generic - if (length ($*) != 1) error ("Invalid ""process"" clause at line %d"n", $line); let curprop = getprop ("__tmpprops__", $1 [1]); let curprop [length (curprop)+1] = strip ($1 [2]); putprop <p> reqval [d] = $1 [i]; let d = d + 1; if ((i &lt; length ($1)) && ($1 [i] != ",")) error ("missing comma at line %d"n", $line); let i = i + 1; if (i &gt; length ($1)) break; - return ($1 <ref> [1] </ref>, reqval); - end clause. clause (($1 [1] == "process") && (($decl [1][1] == "system") || ($decl [1][1] == "domain"))) generic - if (length ($*) != 1) error ("Invalid ""process"" clause at line %d"n", $line); let curprop = getprop ("__tmpprops__", $1 [1]); let curprop [length (curprop)+1] = strip ($1 [2]); putprop ("__tmpprops__", $1 [1], curprop); if (length ($1) <p> if (i &gt; length ($1)) break; - return ($1 <ref> [1] </ref>, reqval); - end clause. clause (($1 [1] == "process") && (($decl [1][1] == "system") || ($decl [1][1] == "domain"))) generic - if (length ($*) != 1) error ("Invalid ""process"" clause at line %d"n", $line); let curprop = getprop ("__tmpprops__", $1 [1]); let curprop [length (curprop)+1] = strip ($1 [2]); putprop ("__tmpprops__", $1 [1], curprop); if (length ($1) == 2) return $1; if ((length ($1) == 5) && ($1 [3] == "(") && ($1 [5] == ")")) - return ($1 [1], $1 [2], $1 [4]); - error ("Invalid ""process"" clause at line <p> end clause. clause (($1 <ref> [1] </ref> == "process") && (($decl [1][1] == "system") || ($decl [1][1] == "domain"))) generic - if (length ($*) != 1) error ("Invalid ""process"" clause at line %d"n", $line); let curprop = getprop ("__tmpprops__", $1 [1]); let curprop [length (curprop)+1] = strip ($1 [2]); putprop ("__tmpprops__", $1 [1], curprop); if (length ($1) == 2) return $1; if ((length ($1) == 5) && ($1 [3] == "(") && ($1 [5] == ")")) - return ($1 [1], $1 [2], $1 [4]); - error ("Invalid ""process"" clause at line %d"n", $line); - consistency - let dst = strip ($decl [1][2]); let <p> clause at line %d"n", $line); let curprop = getprop ("__tmpprops__", $1 <ref> [1] </ref>); let curprop [length (curprop)+1] = strip ($1 [2]); putprop ("__tmpprops__", $1 [1], curprop); if (length ($1) == 2) return $1; if ((length ($1) == 5) && ($1 [3] == "(") && ($1 [5] == ")")) - return ($1 [1], $1 [2], $1 [4]); - error ("Invalid ""process"" clause at line %d"n", $line); - consistency - let dst = strip ($decl [1][2]); let dstid = sprintf ("['%s',%s]", dst, $2); printf ("instanD ('%s',process ('%s'),%s)."n", dst, $2, dstid); 104 /* check if this process had parameterized queries */ let procinfo = get <p> let dsthost = "S1"; else let dsthost = sprintf ("'%s'", x [7]); foreach y in x [5] do - let freq = y [2]; printf ("ref_eq (%s,Y1,readOnly,", dstid); if (isnumber (freq)) printf ("%d", freq); else printf ("%s", freq); printf (") :-"n"); let i = 1; if (i &gt; length (procinfo <ref> [1] </ref>)) error ("Help! internal queries error"n"); if (procinfo [1][i] == proc) break; - if (i &gt; length ($3)) error ( "Missing parameter to process ""%s"" at line %d"n", $2, $line); if ($3 [i] == "*") let pname = "P"; else let pname = sprintf ("'%s'", $3 [i]); printf (""tinstanD (%s,process (%s),P1),"n",
Reference: [2] <author> D. B. Berry, </author> <title> ``Towards a Formal Basis for the Formal Development Method and the Ina Jo Specification Language,'' </title> <journal> IIEEEEEE TTrraannssaaccttiioonnss oonn SSooffttwwaarree eennggiinneeeerriinngg SE-13(2) pp. </journal> <month> 184-201 (February </month> <year> 1987). </year>
Reference-contexts: Our interest in specification languages, however, is in their use as part of a larger tool, rather than in the correct way in which a specification language should be designed. A few of the better known program specification languages are Ina Jo <ref> [2] </ref>, PAISLey [39], and Larch [38]. We discuss the features of these languages that are important to designing our network management specification language. We also mention three other recent program specification languages, Gist [10], PLEASE [34], and Anna [26], that share features in common with our work. <p> A parameter is either a parsed token or an array of parameters. Some statements, like clauses, are made up of other statements, so parameters can be indexed. Thus, to refer to the second parameter of the third subclause of the current clause, one would use $3 <ref> [2] </ref>. 102 The Extension Language provides a small set of built-in functions. Functions may appear in expressions. <p> ($1 [1], reqval); - end clause. clause (($1 [1] == "process") && (($decl [1][1] == "system") || ($decl [1][1] == "domain"))) generic - if (length ($*) != 1) error ("Invalid ""process"" clause at line %d"n", $line); let curprop = getprop ("__tmpprops__", $1 [1]); let curprop [length (curprop)+1] = strip ($1 <ref> [2] </ref>); putprop ("__tmpprops__", $1 [1], curprop); if (length ($1) == 2) return $1; if ((length ($1) == 5) && ($1 [3] == "(") && ($1 [5] == ")")) - return ($1 [1], $1 [2], $1 [4]); - error ("Invalid ""process"" clause at line %d"n", $line); - consistency - let dst = <p> line %d"n", $line); let curprop = getprop ("__tmpprops__", $1 [1]); let curprop [length (curprop)+1] = strip ($1 <ref> [2] </ref>); putprop ("__tmpprops__", $1 [1], curprop); if (length ($1) == 2) return $1; if ((length ($1) == 5) && ($1 [3] == "(") && ($1 [5] == ")")) - return ($1 [1], $1 [2], $1 [4]); - error ("Invalid ""process"" clause at line %d"n", $line); - consistency - let dst = strip ($decl [1][2]); let dstid = sprintf ("['%s',%s]", dst, $2); printf ("instanD ('%s',process ('%s'),%s)."n", dst, $2, dstid); 104 /* check if this process had parameterized queries */ let procinfo = get ($2); if <p> line %d"n", $line); - consistency - let dst = strip ($decl [1]<ref> [2] </ref>); let dstid = sprintf ("['%s',%s]", dst, $2); printf ("instanD ('%s',process ('%s'),%s)."n", dst, $2, dstid); 104 /* check if this process had parameterized queries */ let procinfo = get ($2); if (procinfo != $null) - foreach x in procinfo [2] do - let proc = x [2]; /* already generated code for the constant case */ if (proc = """.*") break; if (x [7] == $null) let dsthost = "S1"; else let dsthost = sprintf ("'%s'", x [7]); foreach y in x [5] do - let freq = y [2]; <p> dst = strip ($decl [1]<ref> [2] </ref>); let dstid = sprintf ("['%s',%s]", dst, $2); printf ("instanD ('%s',process ('%s'),%s)."n", dst, $2, dstid); 104 /* check if this process had parameterized queries */ let procinfo = get ($2); if (procinfo != $null) - foreach x in procinfo [2] do - let proc = x [2]; /* already generated code for the constant case */ if (proc = """.*") break; if (x [7] == $null) let dsthost = "S1"; else let dsthost = sprintf ("'%s'", x [7]); foreach y in x [5] do - let freq = y [2]; printf ("ref_eq (%s,Y1,readOnly,", dstid); if (isnumber (freq)) <p> <ref> [2] </ref> do - let proc = x [2]; /* already generated code for the constant case */ if (proc = """.*") break; if (x [7] == $null) let dsthost = "S1"; else let dsthost = sprintf ("'%s'", x [7]); foreach y in x [5] do - let freq = y [2]; printf ("ref_eq (%s,Y1,readOnly,", dstid); if (isnumber (freq)) printf ("%d", freq); else printf ("%s", freq); printf (") :-"n"); let i = 1; if (i &gt; length (procinfo [1])) error ("Help! internal queries error"n"); if (procinfo [1][i] == proc) break; - if (i &gt; length ($3)) error ( "Missing parameter to process
Reference: [3] <author> K. P. Birman, </author> <title> ``Replication and Fault-Tolerance in the ISIS System,'' </title> <journal> PPrroocceeeeddiinnggss ooff tthhee TTeenntthh AACCMM SSyymmppoossiiuumm oonn OOppeerraattiinngg SSyysstteemmss PPrriinncciipplleess, </journal> <pages> pp. </pages> <address> 79-86 Orcas Island, Washington, </address> <month> (December </month> <year> 1985). </year>
Reference-contexts: We divide the calculations into two cases: a single client querying a single server, and a group of clients querying a single server. The case of a single client simultaneously querying a group of servers (multicast), while interesting from a reliability point of view <ref> [3] </ref>, is not used in current network management systems. The single client/single server case is easy to calculate. For example, consider the interactive client and server shown in Figure 5.2. The peak utilization is 20 qqppss, and the aggregate distribution is the same as the simple distribution. <p> "domain"))) generic - if (length ($*) != 1) error ("Invalid ""process"" clause at line %d"n", $line); let curprop = getprop ("__tmpprops__", $1 [1]); let curprop [length (curprop)+1] = strip ($1 [2]); putprop ("__tmpprops__", $1 [1], curprop); if (length ($1) == 2) return $1; if ((length ($1) == 5) && ($1 <ref> [3] </ref> == "(") && ($1 [5] == ")")) - return ($1 [1], $1 [2], $1 [4]); - error ("Invalid ""process"" clause at line %d"n", $line); - consistency - let dst = strip ($decl [1][2]); let dstid = sprintf ("['%s',%s]", dst, $2); printf ("instanD ('%s',process ('%s'),%s)."n", dst, $2, dstid); 104 /* check <p> proc) break; - if (i &gt; length ($3)) error ( "Missing parameter to process ""%s"" at line %d"n", $2, $line); if ($3 [i] == "*") let pname = "P"; else let pname = sprintf ("'%s'", $3 [i]); printf (""tinstanD (%s,process (%s),P1),"n", dsthost, pname); printf (""t ("n"); foreach r in x <ref> [3] </ref> do printf (""t instan (%s,[%s],Y1);"n", dsthost, r); printf (""t instan (%s,[%s],Y1))."n", dsthost, x [4]); - - end clause. 105
Reference: [4] <author> L. Bronner, </author> <title> ``Overview of the Capacity Planning Process for Production Data Processing,'' </title> <note> IIBBMM SSyysstteemmss JJoouurrnnaall 19(1) pp. </note> <month> 4-27 </month> <year> (1980). </year>
Reference-contexts: Capacity The goal of the capacity conditions are to determine, as quickly as possible, if each server has the capacity to provide the services needed specified by its clients. This is a form of the classic capacity planning problem <ref> [4] </ref>. Capacity planning provides a systematic approach to modeling and predicting the capacity of a system, in our case, a network management system. <p> $line); let curprop = getprop ("__tmpprops__", $1 [1]); let curprop [length (curprop)+1] = strip ($1 [2]); putprop ("__tmpprops__", $1 [1], curprop); if (length ($1) == 2) return $1; if ((length ($1) == 5) && ($1 [3] == "(") && ($1 [5] == ")")) - return ($1 [1], $1 [2], $1 <ref> [4] </ref>); - error ("Invalid ""process"" clause at line %d"n", $line); - consistency - let dst = strip ($decl [1][2]); let dstid = sprintf ("['%s',%s]", dst, $2); printf ("instanD ('%s',process ('%s'),%s)."n", dst, $2, dstid); 104 /* check if this process had parameterized queries */ let procinfo = get ($2); if (procinfo != <p> ""%s"" at line %d"n", $2, $line); if ($3 [i] == "*") let pname = "P"; else let pname = sprintf ("'%s'", $3 [i]); printf (""tinstanD (%s,process (%s),P1),"n", dsthost, pname); printf (""t ("n"); foreach r in x [3] do printf (""t instan (%s,[%s],Y1);"n", dsthost, r); printf (""t instan (%s,[%s],Y1))."n", dsthost, x <ref> [4] </ref>); - - end clause. 105
Reference: [5] <author> J. Case, M. Fedor, M. Schoffstall, and J. Davin, </author> <title> ``A Simple Network Management Protocol,'' </title> <type> RFC 1157, </type> <institution> IETF Network Working Group (May 1990). </institution>
Reference-contexts: These commands set individual configuration parameters necessary to achieve the global management goals. These control commands can be based on the network management standards such as the OSI organizational model [23], or the TCP/IP management framework <ref> [5] </ref>. g The language is high level, and relatively easy for non-experts to understand. This allows non-experts to write specifications. g We provide the administrator with a way to find errors in their network management system before such errors cause problems under normal operation. <p> These systems are precursors of the current management systems, and will not be mentioned further. Among the current systems that deal with administrative domains are network management systems for the TCP/IP Internet <ref> [5] </ref>, the OSI networks [23], AT&T's networking products [22], and IBM's SNA networking product [30]. The Internet and OSI network management systems are meant for use in large, distributed internets, 5 with no central administration. <p> LOTOS also does not support hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 1 The OSI network management architecture makes use of object-oriented paradigms [14, 23, 35] making LOTOS a good match. The SNMP architecture is not object-oriented <ref> [5, 28] </ref>, so LOTOS would not have any advantage here. 9 the possibility of timing or bandwidth constraints, although it does allow the specification of relative temporal ordering. Its access control function can be derived from the ability to hide CSP-style guards and encapsulation. <p> First, we present object descriptions. Next, we present process descriptions, and show their relationship to each other and to object descriptions. Third, we present network element descriptions. Last, we present administrative domain descriptions. Each description is accompanied by an example. In the examples, SNMP <ref> [5] </ref> and the IETF MIB [27] are used exclusively. For additional examples of the use of NMSL, see the full specification shown in Appendix B. 4.2.1. Object Descriptions The NMSL syntax for object descriptions is an encapsulated version of ISO Abstract Syntax Notation One (ASN.1)[19]. <p> PPrroottIInnccoonnssiisstteenntt and CCaappaacciittyyIInnccoonnssiisstteenntt correspond to inconsistent protection and capacity conditions, respectively. CCoonnfifiggIInnccoonnssiisstteenntt and CCoouunnttIInnccoonnssiisstteenntt correspond to inconsistent configuration conditions. In sections 5.1.1 through 5.1.3, we describe each of these consistency categories in more detail. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 4 Network management standards <ref> [5, 14] </ref> refer to these processes as mmaannaaggeerrss and aaggeennttss, respectively. We prefer to use the more general, distributed systems terms. 26 5.1.1. Protection The purpose of the protection conditions is to verify that all operations that a client requests of a server are permitted by that server. <p> ($*) != 1) error ("Invalid ""process"" clause at line %d"n", $line); let curprop = getprop ("__tmpprops__", $1 [1]); let curprop [length (curprop)+1] = strip ($1 [2]); putprop ("__tmpprops__", $1 [1], curprop); if (length ($1) == 2) return $1; if ((length ($1) == 5) && ($1 [3] == "(") && ($1 <ref> [5] </ref> == ")")) - return ($1 [1], $1 [2], $1 [4]); - error ("Invalid ""process"" clause at line %d"n", $line); - consistency - let dst = strip ($decl [1][2]); let dstid = sprintf ("['%s',%s]", dst, $2); printf ("instanD ('%s',process ('%s'),%s)."n", dst, $2, dstid); 104 /* check if this process had parameterized <p> != $null) - foreach x in procinfo [2] do - let proc = x [2]; /* already generated code for the constant case */ if (proc = """.*") break; if (x [7] == $null) let dsthost = "S1"; else let dsthost = sprintf ("'%s'", x [7]); foreach y in x <ref> [5] </ref> do - let freq = y [2]; printf ("ref_eq (%s,Y1,readOnly,", dstid); if (isnumber (freq)) printf ("%d", freq); else printf ("%s", freq); printf (") :-"n"); let i = 1; if (i &gt; length (procinfo [1])) error ("Help! internal queries error"n"); if (procinfo [1][i] == proc) break; - if (i &gt; length
Reference: [6] <author> C. E. Catlett, </author> <title> ``The NSFNET: </title> <institution> Beginnings of a National Research Internet,'' </institution> <note> AAccaaddeemmiicc CCoommppuuttiinngg 3(5) pp. </note> <month> 18-21 (January </month> <year> 1989). </year>
Reference-contexts: In both StarKeeper and NetView, multiple administrative domains are possible. However, the management is a centralized, extended to allow data sharing via delegation, where a central domain delegates control over part of their network to a subordinate domain. This structure does not match the way the present NSFNET <ref> [6] </ref> operates, for example, where control is distributed by default, and administrators that share data maintain control over their own data. The OSI architecture, while proposing a rich set of operations for the sharing of management data, does not include a proposal or policy for implementing these operations.
Reference: [7] <author> L. J. Cole, </author> <title> ``Network Management as Described in Systems Network Architecture,'' </title> <booktitle> IIEEEEEE IInnffooccoomm 8866, </booktitle> <pages> pp. </pages> <address> 364-376 Miami, FL, </address> <month> (April </month> <year> 1986). </year>
Reference-contexts: Some of these research projects also partially address the issue of administrative domains. We will discuss the administrative aspects of these research projects, especially multiple administrative domains and system configuration. Papers describing early network management systems <ref> [7, 29, 36] </ref> discuss problems relating to administrative domains, but do not offer any solutions. These systems are precursors of the current management systems, and will not be mentioned further. <p> $2, dstid); 104 /* check if this process had parameterized queries */ let procinfo = get ($2); if (procinfo != $null) - foreach x in procinfo [2] do - let proc = x [2]; /* already generated code for the constant case */ if (proc = """.*") break; if (x <ref> [7] </ref> == $null) let dsthost = "S1"; else let dsthost = sprintf ("'%s'", x [7]); foreach y in x [5] do - let freq = y [2]; printf ("ref_eq (%s,Y1,readOnly,", dstid); if (isnumber (freq)) printf ("%d", freq); else printf ("%s", freq); printf (") :-"n"); let i = 1; if (i &gt; <p> = get ($2); if (procinfo != $null) - foreach x in procinfo [2] do - let proc = x [2]; /* already generated code for the constant case */ if (proc = """.*") break; if (x <ref> [7] </ref> == $null) let dsthost = "S1"; else let dsthost = sprintf ("'%s'", x [7]); foreach y in x [5] do - let freq = y [2]; printf ("ref_eq (%s,Y1,readOnly,", dstid); if (isnumber (freq)) printf ("%d", freq); else printf ("%s", freq); printf (") :-"n"); let i = 1; if (i &gt; length (procinfo [1])) error ("Help! internal queries error"n"); if (procinfo [1][i] == proc) break;
Reference: [8] <author> S.W. Dietrich and D.S. Warren, </author> <title> ``Extension Tables: Memo Relations in Logic Programming,'' </title> <journal> PPrroocceeeeddiinnggss ooff tthhee SSyymmppoossiiuumm oonn LLooggiicc PPrrooggrraammmmiinngg, </journal> <pages> pp. </pages> <month> 264-272 </month> <year> (1987). </year>
Reference: [9] <author> D. L. Estrin, </author> <title> ``Inter-Organizational Networks: Stringing Wires Across Administrative Boundaries,'' </title> <note> CCoommppuutteerr NNeettwwoorrkkss aanndd IISSDDNN SSyysstteemmss 9 pp. </note> <month> 281-295 (January </month> <year> 1985). </year>
Reference-contexts: For example, these processes must be configured to perform the correct internal operations, to make queries at the correct time, to answer queries correctly, or to reject invalid queries. Additionally, an internet, and therefore, the network management system, is generally divided along the lines of aaddmmiinniissttrraattiivvee ddoommaaiinnss <ref> [9] </ref>. An administrative domain is a group of networks and attached equipment that is controlled by a single organization, such as a company or a university. Administrative domains can be hierarchical. For example, a company can be divided into divisions, and the divisions into departments.
Reference: [10] <author> M. S. Feather, </author> <title> ``Language Support for the Specification and Development of Composite Systems,'' </title> <note> AACCMM TTrraannssaaccttiioonnss oonn PPrrooggrraammmmiinngg LLaanngguuaaggeess aanndd SSyysstteemmss 9(2) pp. </note> <month> 198-243 (April </month> <year> 1987). </year>
Reference-contexts: A few of the better known program specification languages are Ina Jo [2], PAISLey [39], and Larch [38]. We discuss the features of these languages that are important to designing our network management specification language. We also mention three other recent program specification languages, Gist <ref> [10] </ref>, PLEASE [34], and Anna [26], that share features in common with our work. The protocol specification languages LOTOS [16], Estelle [15], and SDL [12] have been designed for specifying network management issues.
Reference: [11] <author> F. Fluckiger and C. Piney, </author> <title> ``Principles of Control in a Distributed Network,'' </title> <booktitle> NNeettwwoorrkkss 8800,, OOnnlliinnee, </booktitle> <pages> pp. </pages> <address> 159-171 London, England, </address> <month> (June </month> <year> 1980). </year> <title> [12] ``Functional Specification and Description Language (SDL),'' Blue book Fascicle X.1, Recommendation Z.100 and Annexes A,B,C and E, Recommendation Z.110, CCITT (1989). </title>
Reference-contexts: Other research on network management specifically addresses administrative and security issues, rather than overall system design. Once again, these issues have been addressed on a small scale and at the lowest level. In both CERNNET <ref> [11] </ref> and Wilbur's local area management model [37] administrative and organizational issues are addressed, but only within a small, local area environment. Both these papers concentrate on the mechanics and implementation of such a system. Interorganizational administrative requirements are mentioned, but not addressed by either paper.
Reference: [13] <author> C.A.R. Hoare, </author> <title> ``Communicating Sequential Processes,'' </title> <note> CCoommmmuunniiccaattiioonnss ooff tthhee AACCMM 21(8) pp. </note> <month> 666-677 (August </month> <year> 1978). </year> <month> 106 </month>
Reference-contexts: In this way, it is similar to Gist and PAISLey. Its use is primarily for describing protocols, not programs in general. It uses a notation similar to CSP <ref> [13] </ref> to describe the input and output behavior of processes. LOTOS can also be used to describe abstract data types, and the operations and transformations that data objects can undergo. LOTOS is designed to specify the messages exchanged by protocols.
Reference: [14] <author> Information Processing Systems Open Systems Interconnection, </author> <title> ``Basic Reference Model Part 4 - OSI Management Framework,'' ISO DIS 7498/4, International Organization for Standardization (1989). </title>
Reference-contexts: LOTOS also does not support hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 1 The OSI network management architecture makes use of object-oriented paradigms <ref> [14, 23, 35] </ref> making LOTOS a good match. The SNMP architecture is not object-oriented [5, 28], so LOTOS would not have any advantage here. 9 the possibility of timing or bandwidth constraints, although it does allow the specification of relative temporal ordering. <p> PPrroottIInnccoonnssiisstteenntt and CCaappaacciittyyIInnccoonnssiisstteenntt correspond to inconsistent protection and capacity conditions, respectively. CCoonnfifiggIInnccoonnssiisstteenntt and CCoouunnttIInnccoonnssiisstteenntt correspond to inconsistent configuration conditions. In sections 5.1.1 through 5.1.3, we describe each of these consistency categories in more detail. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 4 Network management standards <ref> [5, 14] </ref> refer to these processes as mmaannaaggeerrss and aaggeennttss, respectively. We prefer to use the more general, distributed systems terms. 26 5.1.1. Protection The purpose of the protection conditions is to verify that all operations that a client requests of a server are permitted by that server.
Reference: [15] <author> Information Processing Systems Open Systems Interconnection, </author> <title> ``ESTELLE A formal description technique based on an extended state transition model,'' ISO 9074, International Organization for Standardization (1989). </title>
Reference-contexts: We discuss the features of these languages that are important to designing our network management specification language. We also mention three other recent program specification languages, Gist [10], PLEASE [34], and Anna [26], that share features in common with our work. The protocol specification languages LOTOS [16], Estelle <ref> [15] </ref>, and SDL [12] have been designed for specifying network management issues. Their capabilities are similar to each other and, as we will show, address issues different from those addressed by this research. Ina Jo and PAISLey support specification of the interactions between multi-process programs.
Reference: [16] <author> Information Processing Systems Open Systems Interconnection, </author> <title> ``LOTOS (Formal description technique based on the temporal ordering of obervational behavior),'' ISO 8807, International Organization for Standardization (August 1987). </title>
Reference-contexts: We discuss the features of these languages that are important to designing our network management specification language. We also mention three other recent program specification languages, Gist [10], PLEASE [34], and Anna [26], that share features in common with our work. The protocol specification languages LOTOS <ref> [16] </ref>, Estelle [15], and SDL [12] have been designed for specifying network management issues. Their capabilities are similar to each other and, as we will show, address issues different from those addressed by this research. Ina Jo and PAISLey support specification of the interactions between multi-process programs.
Reference: [17] <institution> Information Processing Systems Open Systems Interconnection, ``Management Information Service Definition,'' </institution> <note> ISO DIS 9595/2, International Organization for Standardization (1988). </note>
Reference-contexts: This protection mechanism allows flexibility in deciding how a remote domain of administration, such as a community, can access data from a network element's database. The OSI network management architecture [23], and the International Standards CMIS and CMIP <ref> [17, 18] </ref> also include support for administrative domains in its current definition. The OSI organizational model assumes that management of the network will be distributed across different domains of administration. Each management domain communicates with other domains via ppoorrttss.
Reference: [18] <institution> Information Processing Systems Open Systems Interconnection, ``Management Information Protocol Definition,'' </institution> <note> ISO DIS 9596/2, International Organization for Standardization (1988). </note>
Reference-contexts: This protection mechanism allows flexibility in deciding how a remote domain of administration, such as a community, can access data from a network element's database. The OSI network management architecture [23], and the International Standards CMIS and CMIP <ref> [17, 18] </ref> also include support for administrative domains in its current definition. The OSI organizational model assumes that management of the network will be distributed across different domains of administration. Each management domain communicates with other domains via ppoorrttss.
Reference: [19] <author> Information Processing Systems Open Systems Interconnection, </author> <title> ``Specification of Abstract Syntax Notation One (ASN.1),'' ISO 8824, International Organization for Standardization (December 1987). </title>
Reference-contexts: The OBJECT-TYPE and OBJECT-CLASS ASN.1 macro descriptions, used by the IETF standards [28, 35] are supported. A NMSL object description is the keyword module, followed by a standard ASN.1 data module description, followed by a period. The full grammar and description for ASN.1 may be found in <ref> [19] </ref>. A module declaration ends with a period. Data may be imported from other type modules using the standard ASN.1 IMPORTS clause. As an example of the use of an object description, consider the ASN.1 specification of the IP Address Table that defines the IP Addresses for a given entity. <p> access interface of seconds avg K on speed bps max opsys supports count Mbps peer system cpu minutes process to domain mode provides traps 74 enclosing module qps type end modifies queries version exports net rate external objects requests hours octets requires In addition, the following keywords, defined by ASN.1 <ref> [19] </ref>, are reserved: ABSENT END NAMES SIZE ACCESS ENUMERATED NOTATION STATUS ANY EXPLICIT NULL STRING APPLICATION EXPORTS OBJECT SUPERIORS BEGIN FALSE OBJECT-CLASS SYNTAX BIT FROM OBJECT-TYPE TAGS BOOLEAN IDENTIFIER OCTET TRUE CHOICE IMPLICIT OF TYPE COMPONENT IMPORTS OPTIONAL UNIVERSAL COMPONENTS INCLUDES PRESENT VALUE CONTAINS INTEGER PRIVATE WITH DEFAULT MACRO REAL DEFINITIONS <p> More than one MIB may be present in a single specification. TTyyppeeDDeessccrriippttiioonn ::::== module AASSNN11ssyynnttaaxx . A type description starts with the module keyword. The body of a type description is an ASN.1 module. The ASN.1 module syntax is described in <ref> [19] </ref>. The OBJECT-TYPE and OBJECT-CLASS ASN.1 macros for the IETF standards [28, 35] are supported. In our implementation, new ASN.1 macros cannot be defined. A.6.2.
Reference: [20] <author> W. Joy, AAnn IInnttrroodduuccttiioonn ttoo tthhee CC sshheellll,, </author> <title> 4.3BSD UNIX Programming Manual, </title> <institution> University of California, Berkeley (1986). </institution>
Reference-contexts: The sub-procedures are made up of a list of statements. These statements, in general, should be familiar to any programmer familiar with the C programming language [21] and the csh command language <ref> [20] </ref>. The statements recognized are foreach, if, break, let, printf, put, putprop, delprop, error, return, do, and dumpit. Compound statement are also recognized and are surrounded by braces: -, -.
Reference: [21] <author> B. W. Kernighan and D. M. Ritchie, </author> <booktitle> TThhee CC PPrrooggrraammmmiinngg LLaanngguuaaggee,, </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ (1988). </address>
Reference-contexts: The NMSL Compiler The NMSL Compiler consists of three phases: preprocessing, parsing, and semantic analysis. The input to the first phase is a textual specification. Preprocessing is performed using the C preprocessor <ref> [21] </ref>. The second phase reads the preprocessed input, checks its syntax and reorders the descriptions in a way that simplifies semantic checks. This reordering causes network element and domain descriptions to be checked after data module and process descriptions. <p> A.2. Lexical Conventions A NMSL specification is stored in one or more files. Each file is made up of a sequence of ASCII characters. The files are first preprocessed using the C preprocessor <ref> [21] </ref>. The C preprocessor performs macro expansion. When the preprocessing phase is complete, the files have been reduced to a sequence of tokens. There are five classes of tokens: reserved keywords, identifiers, constants, operators, and other separators. Some tokens are prefixes of other tokens. <p> For example, consistency is used to generate consistency output; isode is used to generate configuration output for ISODE agent processes. The sub-procedures are made up of a list of statements. These statements, in general, should be familiar to any programmer familiar with the C programming language <ref> [21] </ref> and the csh command language [20]. The statements recognized are foreach, if, break, let, printf, put, putprop, delprop, error, return, do, and dumpit. Compound statement are also recognized and are surrounded by braces: -, -.
Reference: [22] <author> M. </author> <title> Kind, </title> <institution> SSttaarrKKeeeeppeerr NNeettwwoorrkk mmaannaaggeemmeenntt SSyysstteemm - OOvveerrvviieeww,, AT&T Bell Labs (January 1987). </institution> <note> Internal Memorandum. </note>
Reference-contexts: These systems are precursors of the current management systems, and will not be mentioned further. Among the current systems that deal with administrative domains are network management systems for the TCP/IP Internet [5], the OSI networks [23], AT&T's networking products <ref> [22] </ref>, and IBM's SNA networking product [30]. The Internet and OSI network management systems are meant for use in large, distributed internets, 5 with no central administration. <p> Configuring network managers based on the OSI model could be complex and error-prone, due to the model's generality. Providing a formal specification of the correct configuration could reduce these errors. StarKeeper <ref> [22] </ref> is a network management system for managing AT&T's Datakit virtual circuit networks. Its implementation is basically an extension to the existing administrative support available on each Datakit node; 6 as such, its protocol for accessing remote nodes is more complicated than SNMP.
Reference: [23] <author> S. M. Klerer, </author> <title> ``The OSI Management Architecture: an Overview,'' </title> <note> IIEEEEEE NNeettwwoorrkk 2(2) pp. </note> <month> 20-29 (March </month> <year> 1988). </year>
Reference-contexts: The specification can be translated into control commands that configure the various network management systems. These commands set individual configuration parameters necessary to achieve the global management goals. These control commands can be based on the network management standards such as the OSI organizational model <ref> [23] </ref>, or the TCP/IP management framework [5]. g The language is high level, and relatively easy for non-experts to understand. This allows non-experts to write specifications. g We provide the administrator with a way to find errors in their network management system before such errors cause problems under normal operation. <p> These systems are precursors of the current management systems, and will not be mentioned further. Among the current systems that deal with administrative domains are network management systems for the TCP/IP Internet [5], the OSI networks <ref> [23] </ref>, AT&T's networking products [22], and IBM's SNA networking product [30]. The Internet and OSI network management systems are meant for use in large, distributed internets, 5 with no central administration. <p> This protection mechanism allows flexibility in deciding how a remote domain of administration, such as a community, can access data from a network element's database. The OSI network management architecture <ref> [23] </ref>, and the International Standards CMIS and CMIP [17, 18] also include support for administrative domains in its current definition. The OSI organizational model assumes that management of the network will be distributed across different domains of administration. Each management domain communicates with other domains via ppoorrttss. <p> LOTOS also does not support hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 1 The OSI network management architecture makes use of object-oriented paradigms <ref> [14, 23, 35] </ref> making LOTOS a good match. The SNMP architecture is not object-oriented [5, 28], so LOTOS would not have any advantage here. 9 the possibility of timing or bandwidth constraints, although it does allow the specification of relative temporal ordering.
Reference: [24] <author> A. J. Kouyzer and A. K. van den Boogaart, </author> <title> ``The LOTOS framework for OSI Systems Management,'' </title> <journal> IIFFIIPP IInntteeggrraatteedd NNeettwwoorrkk MMaannaaggeemmeenntt,, </journal> <volume> IIII, </volume> <pages> pp. </pages> <address> 147-156 Washington, DC, </address> <month> (April </month> <year> 1991). </year>
Reference-contexts: One can also use LOTOS to specify features of the OSI management framework, such as scoping, filtering, and access control. Because of these strengths, it has been proposed as a formal technique for specifying OSI network management entities, such as CMIS <ref> [24] </ref>. While LOTOS can specify parts of the network management system, it has some major gaps. Its support for the instantiation of data types and processes does not include explicit requirement of the locations at which processes are instantiated, nor does it include the ability to instantiate data objects.
Reference: [25] <author> S. T. </author> <title> Leutenegger, IBM, Private correspondence. </title>
Reference-contexts: Response time could be included by using a queuing model, however given the large number of states in the model, we would not have the resources (time or memory) to solve the problem, given current performance modeling technology <ref> [25] </ref>. Finally, we also do not model the fine-grained operation of the message delivery protocols. We compare the capacity, in queries per second, of servers, with the load clients will place on those servers, and determine whether each server's capacity will be exceeded. The load can be measured several ways.
Reference: [26] <author> D. C. Luckham and F. W. Henke, </author> <title> ``An Overview of Anna, a Specification Language for Ada,'' </title> <note> IIEEEEEE SSooffttwwaarree 2(2) pp. </note> <month> 99-22 (March </month> <year> 1985). </year> <month> 107 </month>
Reference-contexts: We discuss the features of these languages that are important to designing our network management specification language. We also mention three other recent program specification languages, Gist [10], PLEASE [34], and Anna <ref> [26] </ref>, that share features in common with our work. The protocol specification languages LOTOS [16], Estelle [15], and SDL [12] have been designed for specifying network management issues. Their capabilities are similar to each other and, as we will show, address issues different from those addressed by this research.
Reference: [27] <author> K. McCloghrie and M. Rose, </author> <title> ``Management Information Base for Network Management of TCP/IP-based Internets,'' </title> <type> RFC 1156, </type> <institution> IETF Network Working Group (May 1990). </institution>
Reference-contexts: First, we present object descriptions. Next, we present process descriptions, and show their relationship to each other and to object descriptions. Third, we present network element descriptions. Last, we present administrative domain descriptions. Each description is accompanied by an example. In the examples, SNMP [5] and the IETF MIB <ref> [27] </ref> are used exclusively. For additional examples of the use of NMSL, see the full specification shown in Appendix B. 4.2.1. Object Descriptions The NMSL syntax for object descriptions is an encapsulated version of ISO Abstract Syntax Notation One (ASN.1)[19]. <p> As an example of the use of an object description, consider the ASN.1 specification of the IP Address Table that defines the IP Addresses for a given entity. This example, shown in Figure 4.1, is derived from the TCP/IP MIB <ref> [27] </ref>. The IpAddress and INTEGER tokens are ASN.1 type names. ipAdEntAddr, et al, are members of the IpAddrEntry sequence. <p> The initial part of the CLP (R) representation is for the MIB and has been abbreviated here. The representation of the process, network element and domain descriptions follow these object descriptions. The text of the MIB is not included in this appendix. The reader may refer to RFC1156 <ref> [27] </ref> for the full text of the MIB. B.1.
Reference: [28] <author> K. McCloghrie and M. Rose, </author> <title> ``Structure and Identification of Management Information for TCP/IP-based Internets,'' </title> <type> RFC 1155, </type> <institution> IETF Network Working Group (May 1990). </institution>
Reference-contexts: LOTOS also does not support hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 1 The OSI network management architecture makes use of object-oriented paradigms [14, 23, 35] making LOTOS a good match. The SNMP architecture is not object-oriented <ref> [5, 28] </ref>, so LOTOS would not have any advantage here. 9 the possibility of timing or bandwidth constraints, although it does allow the specification of relative temporal ordering. Its access control function can be derived from the ability to hide CSP-style guards and encapsulation. <p> The OBJECT-TYPE and OBJECT-CLASS ASN.1 macro descriptions, used by the IETF standards <ref> [28, 35] </ref> are supported. A NMSL object description is the keyword module, followed by a standard ASN.1 data module description, followed by a period. The full grammar and description for ASN.1 may be found in [19]. A module declaration ends with a period. <p> TTyyppeeDDeessccrriippttiioonn ::::== module AASSNN11ssyynnttaaxx . A type description starts with the module keyword. The body of a type description is an ASN.1 module. The ASN.1 module syntax is described in [19]. The OBJECT-TYPE and OBJECT-CLASS ASN.1 macros for the IETF standards <ref> [28, 35] </ref> are supported. In our implementation, new ASN.1 macros cannot be defined. A.6.2. Process Descriptions A process description is used to define the external behavior of a network management process. 81 PPrroocceessssDDeessccrriippttiioonn ::::== process SSttrriinngg PPaarraammSSppeecc ::= PPrrooccBBooddyy end process SSttrriinngg .
Reference: [29] <author> R. E. Moore, </author> <title> ``Problem Detection, Isolation, </title> <booktitle> and Notification in Systems Network Architecture,'' IIEEEEEE IInnffooccoomm 8866, </booktitle> <pages> pp. </pages> <address> 377-381 Miami, FL, </address> <month> (April </month> <year> 1986). </year> <title> [30] ``Network Management,'' </title> <note> IIBBMM SSyysstteemmss JJoouurrnnaall 27(1) pp. </note> <month> 1-85 </month> <year> (1988). </year>
Reference-contexts: Some of these research projects also partially address the issue of administrative domains. We will discuss the administrative aspects of these research projects, especially multiple administrative domains and system configuration. Papers describing early network management systems <ref> [7, 29, 36] </ref> discuss problems relating to administrative domains, but do not offer any solutions. These systems are precursors of the current management systems, and will not be mentioned further.
Reference: [31] <author> M. T. Rose, 44BBSSDD//IISSOODDEE SSNNMMPP RRooaaddmmaapp, </author> <title> Performance Systems International, </title> <publisher> Inc. </publisher>
Reference-contexts: Line 6 constrains Y1 to the object instance of mgmt.mib.system.sysUpTime found in process P1. 7.1.2. Configuration Output The other type of compiler output is a collection of configuration instructions. We have currently implemented Compiler output procedures that generate output to configure ISODE SNMP agent processes <ref> [31, 32] </ref>. The output is passed to a Configuration Installer to reconfigure the management system. The output is textual, and consists of configuration files for the agents. These configuration files include such data as export types and interface definitions. <p> Such choices are matters for future research. 7.3. The Configuration Installer We implemented a Configuration Installer for NMSL. It can install configurations into a running SNMP-based network management system. The system in which we use the Configuration Installer is based on the ISODE SNMP <ref> [31, 32] </ref> agent and trap handler and a NYSERNET [33] monitoring process. This system, the NMSLTEST system also used in specification tests, runs on a small group of computers in the University of Wisconsin Computer Sciences Department.
Reference: [32] <author> M. T. Rose, TThhee IISSOO DDeevveellooppmmeenntt EEnnvviirroonnmmeenntt:: UUsseerr''ss MMaannuuaall, </author> <title> Performance Systems International, </title> <publisher> Inc. </publisher>
Reference-contexts: Line 6 constrains Y1 to the object instance of mgmt.mib.system.sysUpTime found in process P1. 7.1.2. Configuration Output The other type of compiler output is a collection of configuration instructions. We have currently implemented Compiler output procedures that generate output to configure ISODE SNMP agent processes <ref> [31, 32] </ref>. The output is passed to a Configuration Installer to reconfigure the management system. The output is textual, and consists of configuration files for the agents. These configuration files include such data as export types and interface definitions. <p> Such choices are matters for future research. 7.3. The Configuration Installer We implemented a Configuration Installer for NMSL. It can install configurations into a running SNMP-based network management system. The system in which we use the Configuration Installer is based on the ISODE SNMP <ref> [31, 32] </ref> agent and trap handler and a NYSERNET [33] monitoring process. This system, the NMSLTEST system also used in specification tests, runs on a small group of computers in the University of Wisconsin Computer Sciences Department.
Reference: [33] <author> H. Tam, M. L. Schoffstall, W. Yeong, and M. S. Fedor, NNeettwwoorrkk MMaannaaggeemmeenntt SSttaattiioonn BBaanndd AAggeenntt IImmpplleemmeennttaattiioonn,, </author> <title> NYSERNet, </title> <publisher> Inc., </publisher> <address> Troy, NY (1989). </address>
Reference-contexts: The Configuration Installer We implemented a Configuration Installer for NMSL. It can install configurations into a running SNMP-based network management system. The system in which we use the Configuration Installer is based on the ISODE SNMP [31, 32] agent and trap handler and a NYSERNET <ref> [33] </ref> monitoring process. This system, the NMSLTEST system also used in specification tests, runs on a small group of computers in the University of Wisconsin Computer Sciences Department. To install the configuration into a running system, we use the SNMP protocol whenever possible.
Reference: [34] <author> R. B. Terwilliger and R. H. Campbell, </author> <title> ``PLEASE: Predicate Logic based ExecutAble SpEcifications,'' </title> <booktitle> PPrroocceeeeddiinnggss ooff tthhee 11998866 AACCMM CCoommppuutteerr SScciieennccee CCoonnffeerreennccee, </booktitle> <pages> pp. </pages> <address> 349-358 Cincinnati, OH, </address> <month> (February </month> <year> 1986). </year>
Reference-contexts: A few of the better known program specification languages are Ina Jo [2], PAISLey [39], and Larch [38]. We discuss the features of these languages that are important to designing our network management specification language. We also mention three other recent program specification languages, Gist [10], PLEASE <ref> [34] </ref>, and Anna [26], that share features in common with our work. The protocol specification languages LOTOS [16], Estelle [15], and SDL [12] have been designed for specifying network management issues.
Reference: [35] <author> U.S. Warrier, L. Besaw, L. LeBarre, and B.D. Handspicker, </author> <title> ``Common Management Information Services and Protocols for the Internet (CMOT) and (CMIP),'' RFC 1189, IETF Network Working Group (October 1990). </title>
Reference-contexts: LOTOS also does not support hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 1 The OSI network management architecture makes use of object-oriented paradigms <ref> [14, 23, 35] </ref> making LOTOS a good match. The SNMP architecture is not object-oriented [5, 28], so LOTOS would not have any advantage here. 9 the possibility of timing or bandwidth constraints, although it does allow the specification of relative temporal ordering. <p> The OBJECT-TYPE and OBJECT-CLASS ASN.1 macro descriptions, used by the IETF standards <ref> [28, 35] </ref> are supported. A NMSL object description is the keyword module, followed by a standard ASN.1 data module description, followed by a period. The full grammar and description for ASN.1 may be found in [19]. A module declaration ends with a period. <p> TTyyppeeDDeessccrriippttiioonn ::::== module AASSNN11ssyynnttaaxx . A type description starts with the module keyword. The body of a type description is an ASN.1 module. The ASN.1 module syntax is described in [19]. The OBJECT-TYPE and OBJECT-CLASS ASN.1 macros for the IETF standards <ref> [28, 35] </ref> are supported. In our implementation, new ASN.1 macros cannot be defined. A.6.2. Process Descriptions A process description is used to define the external behavior of a network management process. 81 PPrroocceessssDDeessccrriippttiioonn ::::== process SSttrriinngg PPaarraammSSppeecc ::= PPrrooccBBooddyy end process SSttrriinngg .
Reference: [36] <author> J. Westcott, J. Buress, and V. Begg, </author> <title> ``Automated Network Management,'' </title> <booktitle> IIEEEEEE IInnffooccoomm ''8855, </booktitle> <pages> pp. </pages> <address> 43-50 Washington, DC, </address> <month> (March </month> <year> 1985). </year>
Reference-contexts: Some of these research projects also partially address the issue of administrative domains. We will discuss the administrative aspects of these research projects, especially multiple administrative domains and system configuration. Papers describing early network management systems <ref> [7, 29, 36] </ref> discuss problems relating to administrative domains, but do not offer any solutions. These systems are precursors of the current management systems, and will not be mentioned further.
Reference: [37] <author> S. Wilbur, </author> <title> ``Local area network management for distributed applications,'' </title> <note> CCoommppuutteerr CCoommmmuunniiccaattiioonnss 9(2) pp. </note> <month> 100-104 (April </month> <year> 1986 </year> ). 
Reference-contexts: Other research on network management specifically addresses administrative and security issues, rather than overall system design. Once again, these issues have been addressed on a small scale and at the lowest level. In both CERNNET [11] and Wilbur's local area management model <ref> [37] </ref> administrative and organizational issues are addressed, but only within a small, local area environment. Both these papers concentrate on the mechanics and implementation of such a system. Interorganizational administrative requirements are mentioned, but not addressed by either paper.
Reference: [38] <author> J. M. Wing, </author> <title> ``Writing Larch Interface Language Specifications,'' </title> <note> AACCMM TTrraannssaaccttiioonnss oonn PPrrooggrraammmmiinngg LLaanngguuaaggeess aanndd SSyysstteemmss 9(1) pp. </note> <month> 1-24 (January </month> <year> 1987). </year>
Reference-contexts: Our interest in specification languages, however, is in their use as part of a larger tool, rather than in the correct way in which a specification language should be designed. A few of the better known program specification languages are Ina Jo [2], PAISLey [39], and Larch <ref> [38] </ref>. We discuss the features of these languages that are important to designing our network management specification language. We also mention three other recent program specification languages, Gist [10], PLEASE [34], and Anna [26], that share features in common with our work. <p> This separation allows the management information to be specified independent of its use. It also allows types of processes to be specified, and allows these process types to be instantiated in various locations. These separate specifications, as shown in Larch <ref> [38] </ref>, make them more generally useful. In the case of network management, the separation also mirrors the real world, where many network elements will store the same types of management data, and run network management software derived from the same source. 4.2.

References-found: 36

