URL: http://www.csl.sri.com/lucid/ISLIP94/Du.ps.Z
Refering-URL: http://www.csl.sri.com/lucid/ISLIP94/electronic-proceedings.html
Root-URL: 
Email: wdu@unb.ca  
Title: Object-oriented Implementation of Intensional Languages  
Author: Weichang Du 
Address: New Brunswick Saint John, N.B. Canada E2L 4L5  
Affiliation: Department of Mathematics and Computer Science University of  
Abstract: This paper presents an object-oriented implementation of Lucid. We implement each variable in a Lucid program as a class. An object of the class is the variable in a context. An object evaluates itself when it receives a demand for its value and stores the value. Evaluation of a program involves object self-evaluations and message passing of demands among objects. Some optimization issues are also discussed in the paper.
Abstract-found: 1
Intro-found: 1
Reference: [AFJ91] <author> E. A. Ashcroft, A. A. Faustini, and R Jagannathan. </author> <title> An intensional language for parallel applications programming. </title> <booktitle> In Parallel Functional Languages and Compilers, </booktitle> <pages> pages 11-50. </pages> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: At the implementation level, we may use object-oriented techniques to compile intensional programs to object-oriented programs. This is addressed in this paper. Intensional languages are implemented based on the eduction model. The operational semantics of the languages is defined on an abstract machine <ref> [AFJ91] </ref> [RW93]. The machine consists of a global stack machine, a global value warehouse, and a set of global context registers.
Reference: [DF94] <author> W. Du and A.A. Faustini. </author> <title> Objectflow adding object to glu. </title> <booktitle> In Submit to The 1994 International Symposium on Lucid and Intensional Programming, </booktitle> <month> September </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Object-oriented programming has become one of the main stream paradigms for software construction. We may consider to incorporate object-oriented technology in development of intensional languages at two levels. At the language extension level, we may add the concept of objects into intensional languages. [FB91] and <ref> [DF94] </ref> have addressed this issue. At the implementation level, we may use object-oriented techniques to compile intensional programs to object-oriented programs. This is addressed in this paper. Intensional languages are implemented based on the eduction model. The operational semantics of the languages is defined on an abstract machine [AFJ91] [RW93].
Reference: [FB91] <author> B. Freeman-Benson. Lobjcid: </author> <title> Objects in lucid. </title> <booktitle> In The 1991 International Symposium on Lucid and Intensional Programming, </booktitle> <pages> pages 80-87, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Object-oriented programming has become one of the main stream paradigms for software construction. We may consider to incorporate object-oriented technology in development of intensional languages at two levels. At the language extension level, we may add the concept of objects into intensional languages. <ref> [FB91] </ref> and [DF94] have addressed this issue. At the implementation level, we may use object-oriented techniques to compile intensional programs to object-oriented programs. This is addressed in this paper. Intensional languages are implemented based on the eduction model.
Reference: [Jon85] <author> T Jonsson. </author> <title> Lambda lifting: Transforming programs ro recursive equations. </title> <booktitle> In IFIP Conference on Functional Programming Languages and Computer Architectures, </booktitle> <pages> pages 190-203, </pages> <year> 1985. </year>
Reference-contexts: In section 3, we discuss some optimization issues. Section 4 is some concluding remarks. 2 Compiling Lucid to C++ Given a Lucid program, we can first transform it to 0-order using Yaghi's method [Yag84], and without nested where clauses using -lifting <ref> [Jon85] </ref>. In the following discussion, by a Lucid program we mean its flatten 0-order form. We compile each variable definition in a Lucid program into a C++ class definition, which we call a variable class, which has the same name as the variable.
Reference: [RW93] <author> P. Rondogiannis and W.W. Wadge. </author> <title> A dataflow implementation technique for lazy typed functional languages. </title> <booktitle> In The Sixth International Symposium on Lucid and Intensional Programming, </booktitle> <pages> pages 23-42, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: At the implementation level, we may use object-oriented techniques to compile intensional programs to object-oriented programs. This is addressed in this paper. Intensional languages are implemented based on the eduction model. The operational semantics of the languages is defined on an abstract machine [AFJ91] <ref> [RW93] </ref>. The machine consists of a global stack machine, a global value warehouse, and a set of global context registers.
Reference: [RW94] <author> P. Rondogiannis and W.W. Wadge. </author> <title> High-order dataflow and its implementation on stock hardware. </title> <booktitle> In the ACM Symposium on Applied Computing, </booktitle> <pages> pages 431-435. </pages> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: When an intensional program is compiled to a conventional program, such as C, the global data structures corresponding to the abstract machine are created, and the compiled code basically manipulates those global structures using eduction <ref> [RW94] </ref>. In the traditional implementation of intensional languages, we can think of that there is an implicit control process as the main thread of eduction.

References-found: 6

