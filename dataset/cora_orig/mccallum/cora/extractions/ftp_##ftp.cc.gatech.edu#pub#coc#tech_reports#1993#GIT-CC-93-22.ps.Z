URL: ftp://ftp.cc.gatech.edu/pub/coc/tech_reports/1993/GIT-CC-93-22.ps.Z
Refering-URL: http://www.cs.gatech.edu/tech_reports/index.93.html
Root-URL: 
Title: Parallel and Configurable Protocols: Experiences with a Prototype and an Architectural Framework  
Author: Bert Lindgren Bobby Krupczak Mostafa Ammar Karsten Schwan 
Address: Atlanta, Georgia 30332-0280  
Affiliation: College of Computing Georgia Institute of Technology  
Date: March 1993  
Pubnum: GIT-CC-93/22  
Abstract: As network speeds increase, a major concern regarding communication protocols is their limited throughput and latency due to processing overheads at network nodes. Furthermore, novel network applications and expanded network usage are leading to increased network requirements, particularly with respect to security and bandwidth. In this paper we consider the use of parallelism and configurabil-ity to increase throughput and reduce protocol processing latencies. We obtain experimental results of parallel protocol performance using a prototype implemented on a shared memory multiprocessor. The results demonstrate the utility of parallel protocol processing, and they indicate the further research necessary for constructing viable communication protocols for large-scale parallel machines. Based on these experiences, we present the design of an object-oriented framework for parallel protocol programming. This framework both facilitates parallel protocol development and helps maximize protocol performance on a wide variety of multiprocessors. 
Abstract-found: 1
Intro-found: 1
Reference: [Abbot-92] <author> Mark B. Abbot and Larry L. Peterson, </author> <title> "A Language-Based Approach to Protocol Implementation," </title> <booktitle> ACM SIGCOMM-92 Symposium, </booktitle> <address> Baltimore, MD, </address> <month> Oct. </month> <year> 1992, </year> <pages> pp. 27-38. </pages>
Reference: [Atwoo-91] <author> J.W. Atwood and W. Prager, </author> <title> "A STREAMS-based Communications Subsystem in Turing Plus for Protocol Development," </title> <journal> Software-Practice and Experience, </journal> <volume> Vol. </volume> <month> 21 (December </month> <year> 1991), </year> <pages> pp. 1365-1380. </pages>
Reference: [Bihar-92] <author> Thomas E. Bihari and Karsten Schwan, </author> <title> "Object-Oriented Real-Time Systems: Concepts and Examples," </title> <journal> IEEE Computer, </journal> <volume> Vol. </volume> <month> 25 (Dec. </month> <year> 1992), </year> <pages> pp. 25-32. </pages>
Reference-contexts: Objects communicate with each other by asynchronous invocations implemented as messages delivered via shared memory mailboxes, much like the implementation of object invocations in other 5 multiprocessor operating systems <ref> [Bihar-92, Chase-89] </ref>. Objects cooperate in the processing of protocol packets, and they may be composed to result in different communication protocol configurations in a manner more flexible than the layers of traditional protocol architectures allow.
Reference: [Bihar-91] <author> Thomas E. Bihari and Karsten Schwan, </author> <title> "Dynamic Adaptation of Real-Time Software," </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol. </volume> <month> 9 (May </month> <year> 1991), </year> <pages> pp. 143-174. </pages>
Reference: [Chase-89] <author> Jeffrey S. Chase, Franz G. Amador, et al., </author> <title> "The Amber System: Parallel Programming on a Network of Multiprocessors," </title> <booktitle> Twelfth ACM Symposium on Operating System Principles, SIGOPS Notices 23, </booktitle> <volume> 5, </volume> <year> 1989, </year> <pages> pp. 147-158. </pages>
Reference-contexts: Objects communicate with each other by asynchronous invocations implemented as messages delivered via shared memory mailboxes, much like the implementation of object invocations in other 5 multiprocessor operating systems <ref> [Bihar-92, Chase-89] </ref>. Objects cooperate in the processing of protocol packets, and they may be composed to result in different communication protocol configurations in a manner more flexible than the layers of traditional protocol architectures allow.
Reference: [Clark-89] <author> David Clark, Van Jacobson, et al., </author> <title> "An Analysis of TCP Processing Overhead," </title> <journal> IEEE Communications Magazine (June 1989), </journal> <pages> pp. 23-29. </pages>
Reference-contexts: Another effect of the increasing transmission capabilities and ubiquity of networks is the development of applications that make increasing use of data manipulation such as encryption for security and/or compression for image transmission. It has been argued that such data manipulation can become the bottleneck in protocol processing <ref> [Clark-89, Clark-90] </ref>.
Reference: [Clark-90] <author> David Clark and David Tennenhouse, </author> <title> "Architectural Considerations for a New Generation of Protocols," </title> <journal> ACM Computer Communications Review, </journal> <volume> Vol. </volume> <month> 20 (September </month> <year> 1990), </year> <pages> pp. 200-208. </pages>
Reference-contexts: Another effect of the increasing transmission capabilities and ubiquity of networks is the development of applications that make increasing use of data manipulation such as encryption for security and/or compression for image transmission. It has been argued that such data manipulation can become the bottleneck in protocol processing <ref> [Clark-89, Clark-90] </ref>. <p> that streamline the code that is executed when packets arrive correctly (see [Doeri-90] for a good survey), custom protocols written to support a specific application, and application level framing which gives the application access to misordered data, so that the application can process it immediately and, therefore, avoid falling behind <ref> [Clark-90] </ref>. Reference model changes involve modifications to the framework under which protocols are designed. Typically, this involves violating the layered model. For example, in the x-Kernel, a protocol is decomposed into "micro-protocols", which can be combined in 2 order to configure the protocol for each application's needs [Peter-90, Hutch-89b]. <p> Fur--thermore, Clark and Tennenhouse's "integrated layer processing" suggests that protocols be designed in layers, but then permit protocol programmers to merge such layers during implementation <ref> [Clark-90] </ref>. Haas' HOPS protocol and Zitterbart's Transputers are also functionally-decomposed protocols, but their functions can be performed in parallel [Haas-91, Zitte-91].
Reference: [Crow-85] <author> W. Crowther, J. Goodhue, et al., </author> <title> "The Butterfly Parallel Processor," </title> <journal> IEEE Computer Architecture Technical Committee Newsletter, </journal> <month> Dec. </month> <year> 1985, </year> <pages> pp. 18-45. </pages>
Reference-contexts: The resulting protocol offers sufficient functionality for our purposes: the experimentation with parallelism in communication protocols. 3.2 Parallel Protocol Performance All measurements reported below are attained on a 32-node GP1000 BBN Butterfly <ref> [Crow-85] </ref>. The Butterfly is a MIMD, shared memory parallel processor. Each processor node contains a 25Mhz Motorola MC68020 processor, a 68881 floating point processor, a 68851 Memory Management Unit (MMU), 4M bytes of RAM and a microcoded co-processor called the Processor Node Controller (PNC) which handles shared memory requests.
Reference: [Dean-90] <author> S.M. Dean, D.A. Kumpf, and H.M. Wenzel, </author> <title> "CONE: A Software Environment for Network Protocols," </title> <journal> Hewlett-Packard Journal (February 1990), </journal> <pages> pp. 18-28. </pages>
Reference: [Dinge-90] <author> J. Dinger, K. Rothermel, and K. Urbschat, "ECSE: </author> <title> An Efficient Environment for Layered Communication Protocols," </title> <booktitle> Second IEEE Workshop on Future Trends of Distributed Computer Systems, </booktitle> <address> Cairo, Egypt, </address> <year> 1990, </year> <pages> pp. 305-314. </pages>
Reference-contexts: Haas' HOPS protocol and Zitterbart's Transputers are also functionally-decomposed protocols, but their functions can be performed in parallel [Haas-91, Zitte-91]. Implementation improvements range from improving the operating system support for protocols <ref> [Hutch-89a, Dinge-90, Watso-87] </ref> to using parallelism to pipeline STREAMS layers [Preso-92, Garg-90]. 1 Our research builds on the work mentioned above, but differs in several respects.
Reference: [Doeri-90] <author> Willibald A. Doeringer, Doug Dykeman, </author> <title> em et al., "A Survey of Light-Weight Transport Protocols for High-Speed Networks," </title> <journal> IEEE Transactions on Communications, </journal> <volume> Vol. </volume> <month> 38 (November </month> <year> 1990), </year> <pages> pp. 2025-2039. 24 </pages>
Reference-contexts: Protocol adjustments include lightweight protocols that streamline the code that is executed when packets arrive correctly (see <ref> [Doeri-90] </ref> for a good survey), custom protocols written to support a specific application, and application level framing which gives the application access to misordered data, so that the application can process it immediately and, therefore, avoid falling behind [Clark-90].
Reference: [Garg-90] <author> Arun Garg, </author> <title> "Parallel STREAMS: a Multi-Processor Implementation," </title> <booktitle> USENIX (Winter 1990), </booktitle> <pages> pp. 163-176. </pages>
Reference-contexts: Haas' HOPS protocol and Zitterbart's Transputers are also functionally-decomposed protocols, but their functions can be performed in parallel [Haas-91, Zitte-91]. Implementation improvements range from improving the operating system support for protocols [Hutch-89a, Dinge-90, Watso-87] to using parallelism to pipeline STREAMS layers <ref> [Preso-92, Garg-90] </ref>. 1 Our research builds on the work mentioned above, but differs in several respects. First, we do not limit ourselves to the pipelined parallelism of the STREAMS protocol, or to the functionally decomposed parallelism in the work of Haas or Zitterbart.
Reference: [Gheit-92] <author> Ahmed Gheith and Karsten Schwan, </author> <title> "CHAOS: Kernel Support for Multi-Weight Objects, Invocations, and Atomicity in Real-Time Multiprocessor Applications" (unpublished Technical Report: </title> <institution> Georgia Institute of Technology, </institution> <year> 1992). </year>
Reference-contexts: Finally, some of the overheads in our current implementation of the raw protocol stem from our mailbox-based implementation of invocations. Alternative implementation approaches for objects and object invocations such as the `shepherding' done in the x-Kernel or the invocation primitives described in <ref> [Gheit-92] </ref> can further improve per formance. * Opportunities for parallelism are improved substantially when protocol and presentation-level processing are both performed in parallel. <p> Such overheads can be avoided by offering an alternative synchronous invocation that may be used by a single thread to `shepherd' a message through a short method of another object. 14 Additional invocation semantics, possibly involving priorities or deadlines, are necessary when extending our protocol to the real-time domain <ref> [Gheit-92] </ref>. "Done-with" Propagation. When a protocol object passes a copy of its packet or message fragment to another object, the space containing this copy cannot be reused until the target object completes its processing. <p> Multiple Invocation Semantics. With each method invocation, an additional `type' parameter specifies the method implementation as `synchronous' or `asynchronous', resulting in the execution of different invocation code. The efficient implementation of such alternative invocation primitives is described in detail in <ref> [Gheit-92] </ref>. Additional invocation semantics may be added as needed. Object and Connection Configuration. In order to custom-fit protocols to the application programmer's requirements and to the network's current status, objects and their connections may be configured at compile- or at runtime.
Reference: [Haas-91] <author> Zygmunt Haas, </author> <title> "A Protocol Structure for High-Speed Communication over Broadband ISDN," </title> <journal> IEEE Network Magazine (January 1991), </journal> <pages> pp. 64-70. </pages>
Reference-contexts: Fur--thermore, Clark and Tennenhouse's "integrated layer processing" suggests that protocols be designed in layers, but then permit protocol programmers to merge such layers during implementation [Clark-90]. Haas' HOPS protocol and Zitterbart's Transputers are also functionally-decomposed protocols, but their functions can be performed in parallel <ref> [Haas-91, Zitte-91] </ref>. Implementation improvements range from improving the operating system support for protocols [Hutch-89a, Dinge-90, Watso-87] to using parallelism to pipeline STREAMS layers [Preso-92, Garg-90]. 1 Our research builds on the work mentioned above, but differs in several respects.
Reference: [Hutch-89a] <author> N.C. Hutchinson, S. Mishra, et al., </author> <title> "Tools for Implementing Network Protocols," </title> <journal> Software-Practice and Experience, </journal> <volume> Vol. </volume> <month> 19 (September </month> <year> 1989), </year> <pages> pp. 895-916. </pages>
Reference-contexts: Haas' HOPS protocol and Zitterbart's Transputers are also functionally-decomposed protocols, but their functions can be performed in parallel [Haas-91, Zitte-91]. Implementation improvements range from improving the operating system support for protocols <ref> [Hutch-89a, Dinge-90, Watso-87] </ref> to using parallelism to pipeline STREAMS layers [Preso-92, Garg-90]. 1 Our research builds on the work mentioned above, but differs in several respects.
Reference: [Hutch-89b] <author> N.C. Hutchinson, L.L. Peterson, and Herman Rao, </author> <title> "The x-Kernel: An Open Operating System Design," </title> <booktitle> IEEE Proceedings of the Second Workshop on Workstation Operating Systems, </booktitle> <address> Pacific Grove, CA, </address> <month> September 27-29, </month> <year> 1989, </year> <pages> pp. 55-59. </pages>
Reference-contexts: Reference model changes involve modifications to the framework under which protocols are designed. Typically, this involves violating the layered model. For example, in the x-Kernel, a protocol is decomposed into "micro-protocols", which can be combined in 2 order to configure the protocol for each application's needs <ref> [Peter-90, Hutch-89b] </ref>. Fur--thermore, Clark and Tennenhouse's "integrated layer processing" suggests that protocols be designed in layers, but then permit protocol programmers to merge such layers during implementation [Clark-90]. Haas' HOPS protocol and Zitterbart's Transputers are also functionally-decomposed protocols, but their functions can be performed in parallel [Haas-91, Zitte-91].
Reference: [Hutch-89c] <author> N.C. Hutchinson, L.L. Peterson, et al., </author> <title> "RPC in the x-Kernel: Evaluating New Design Techniques," </title> <journal> Operating Systems Review, </journal> <volume> Vol. </volume> <booktitle> 23,5 (Proceedings of the 12th ACM Syposium on OS Principles, </booktitle> <month> Dec. </month> <pages> 3-6, </pages> <year> 1989), </year> <pages> pp. 91-101. </pages>
Reference: [Jain-90] <author> Niraj Jain, Mischa Schwartz and Theodore Bashkow, </author> <title> "Transport Protocol Processing at GBPS Rates," </title> <journal> ACM Computer Communications Review, </journal> <volume> Vol. </volume> <month> 20 (September </month> <year> 1990), </year> <pages> pp. 188-199. </pages>
Reference-contexts: Opportunities for Parallelism. The simple protocol described above offers the following opportunities for parallelism: * Jain et al. demonstrated conceptually that multiple packets in the transmission window can be processed independently to significantly increase throughput <ref> [Jain-90] </ref>. This can be done without significant changes to our current protocol implementation. * It is intuitive that multiple connections can be processed in parallel, since there are no direct dependencies between different connections.
Reference: [Kanak-88] <author> Hemant Kanakia and David R. Cheriton, </author> <title> "The VMP Network Adapter Board (NAB): High-Performance Network Communication for Multiprocessors," </title> <booktitle> ACM SIGCOMM '88 Symposium, </booktitle> <address> Stanford, CA, </address> <month> Aug. </month> <pages> 16-19, </pages> <year> 1988, </year> <pages> pp. 175-187. </pages>
Reference: [Krish-89] <author> A.S. Krishnakumar and Krishnan Sabnani, </author> <title> "VLSI Implementations of Communication Protocols-A Survey," </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> Vol. </volume> <month> 7 (September </month> <year> 1989), </year> <pages> pp. 1082-1090. </pages>
Reference: [Netra-90] <author> A.N. Netravali, W.D. Roome, and K. Sabnani, </author> <title> "Design and Implementation of a High-Speed Transport Protocol," </title> <journal> IEEE Transactions on Communications, </journal> <volume> Vol. </volume> <month> 38 (November </month> <year> 1990), </year> <pages> pp. 2010-2024. </pages>
Reference: [Peter-90] <author> L.L. Peterson, H.C. Hutchinson, et al., </author> <title> "The x-kernel: A Platform for Accessing Internet Resources," </title> <journal> IEEE Computer Magazine (May 1990), </journal> <pages> pp. 23-33. 25 </pages>
Reference-contexts: Reference model changes involve modifications to the framework under which protocols are designed. Typically, this involves violating the layered model. For example, in the x-Kernel, a protocol is decomposed into "micro-protocols", which can be combined in 2 order to configure the protocol for each application's needs <ref> [Peter-90, Hutch-89b] </ref>. Fur--thermore, Clark and Tennenhouse's "integrated layer processing" suggests that protocols be designed in layers, but then permit protocol programmers to merge such layers during implementation [Clark-90]. Haas' HOPS protocol and Zitterbart's Transputers are also functionally-decomposed protocols, but their functions can be performed in parallel [Haas-91, Zitte-91].
Reference: [Preso-92] <author> D.L. Presotto, </author> <title> "Multiprocessor Streams for Plan 9" (unpublished). </title>
Reference-contexts: Haas' HOPS protocol and Zitterbart's Transputers are also functionally-decomposed protocols, but their functions can be performed in parallel [Haas-91, Zitte-91]. Implementation improvements range from improving the operating system support for protocols [Hutch-89a, Dinge-90, Watso-87] to using parallelism to pipeline STREAMS layers <ref> [Preso-92, Garg-90] </ref>. 1 Our research builds on the work mentioned above, but differs in several respects. First, we do not limit ourselves to the pipelined parallelism of the STREAMS protocol, or to the functionally decomposed parallelism in the work of Haas or Zitterbart.
Reference: [Sabna-89] <author> K. Sabnani and A. Netravali, </author> <title> "A High Speed Transport Protocol for Data-gram/Virtual Circuit Networks," </title> <booktitle> ACM SIGCOMM '89 Symposium, </booktitle> <address> Austin, TX, </address> <month> September </month> <year> 1989, </year> <pages> pp. 146-157. </pages>
Reference: [Schwa-91] <author> Karsten Schwan, Harold Forbes, et al., </author> <title> "A C Thread Library for Multiprocessors," </title> <institution> Georgia Institute of Technology Tech Report GIT-ICS-91/02, </institution> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: For reference, a procedure call without parameters costs approximately 3 microseconds on the BBN Butterfly. The Mach operating system and a light-weight CThreads package developed by our group are being used <ref> [Schwa-91] </ref>. The protocol's implementation relies on a simple extension of CThreads with a mailbox communication facility.
Reference: [Watso-87] <author> R.W. Watson and S.A. Mamrak, </author> <title> "Gaining Efficiency in Transport Services by Appropriate Design and Implementation Choices," </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> Vol. </volume> <month> 5 (May </month> <year> 1987), </year> <pages> pp. 97-120. </pages>
Reference-contexts: Haas' HOPS protocol and Zitterbart's Transputers are also functionally-decomposed protocols, but their functions can be performed in parallel [Haas-91, Zitte-91]. Implementation improvements range from improving the operating system support for protocols <ref> [Hutch-89a, Dinge-90, Watso-87] </ref> to using parallelism to pipeline STREAMS layers [Preso-92, Garg-90]. 1 Our research builds on the work mentioned above, but differs in several respects.
Reference: [Zitte-91] <author> M. Zitterbart, </author> <title> "High-Speed Transport Components," </title> <journal> IEEE Network Magazine (January 1991), </journal> <pages> pp. 54-63. 26 </pages>
Reference-contexts: Fur--thermore, Clark and Tennenhouse's "integrated layer processing" suggests that protocols be designed in layers, but then permit protocol programmers to merge such layers during implementation [Clark-90]. Haas' HOPS protocol and Zitterbart's Transputers are also functionally-decomposed protocols, but their functions can be performed in parallel <ref> [Haas-91, Zitte-91] </ref>. Implementation improvements range from improving the operating system support for protocols [Hutch-89a, Dinge-90, Watso-87] to using parallelism to pipeline STREAMS layers [Preso-92, Garg-90]. 1 Our research builds on the work mentioned above, but differs in several respects.
References-found: 27

