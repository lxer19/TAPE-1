URL: http://simon.cs.cornell.edu/Info/Projects/Bernoulli/papers/pldi95.ps
Refering-URL: 
Root-URL: 
Title: APT A Data Structure for Optimal Control Dependence Computation  
Author: Keshav Pingali Gianfranco Bilardi 
Degree: Universit a di Padova, Padova,  
Date: 14853.  
Address: Ithaca, NY  
Affiliation: Department of Computer Science Dipartimento di Elettronica ed Informatica, Cornell University,  Italy.  
Abstract: The control dependence relation is used extensively in restructuring compilers. This relation is usually represented using the control dependence graph; unfortunately, the size of this data structure can be quadratic in the size of the program, even for some structured programs. In this paper, we introduce a data structure called the augmented post-dominator tree (APT ) which is constructed in space and time proportional to the size of the program, and which can answer control dependence queries in time proportional to the size of the output. Therefore, APT is an optimal representation of control dependence. We also show that using AP T , we can compute SSA graphs, as well as sparse dataflow evaluator graphs, in time proportional to the size of the program. Finally, we put AP T in perspective by showing that it can be viewed as a factored representation of the control dependence graph in which filtered search is used to answer queries. 
Abstract-found: 1
Intro-found: 1
Reference: [ABC + 88] <author> Frances Allen, Michael Burke, Ron Cytron, Jeanne Ferrante, Wilson Hsieh, and Vivek Sarkar. </author> <title> A framework for determining useful parallelism. </title> <booktitle> In Proceedings of the 1988 International Conference on Supercomputing, </booktitle> <pages> pages 207-215, </pages> <address> St. Malo, France, </address> <month> July 4-8, </month> <year> 1988. </year>
Reference-contexts: These sets are used in scheduling instructions across basic block boundaries for speculative or predicated execution [Fis81, BR91]. They are also useful in merging program versions [HPR87], and in automatic paralleliza-tion <ref> [ABC + 88] </ref>. Set cdequiv (w) contains the nodes that have the same control dependences as node w. This information is useful in code scheduling because basic blocks with the same control dependences can be treated as one large basic block, as is done in region scheduling [GS87].
Reference: [Bal93] <author> Thomas Ball. </author> <title> What's in a region? or computing control dependence regions in near-linear time for reducible control flow. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 2(1-4):1-16, </volume> <month> March-December </month> <year> 1993. </year>
Reference-contexts: Since this is a straight-forward representation of the full relation, the size of the CDG is (jEjjV j). There have been many efforts to construct more compact representations of the control dependence relation <ref> [FOW87, CFS90, Bal93, JP93, SGL94] </ref>, and the lack of success led Cytron, Ferrante and Sarkar to conjecture that any data structure that provided proportional time access to control dependence sets must use space that grows quadratically with program size [CFS90]. <p> Sreedhar and Gao investigated the conds problem using their DJ-graph representation, but this approach did not reduce the asymptotic complexity of conds computation [SGL94]. The cdequiv problem for reducible control flow graphs was solved by Ball <ref> [Bal93] </ref> who needed both dominator and postdominator information in his solution; subsequently, Podgurski gave a linear-time algorithm for forward control dependence equivalence, which is a special case of general control dependence equivalence [Pod93].
Reference: [BR91] <author> David Bernstein and Michael Rodeh. </author> <title> Global instruction scheduling for superscalar machines. </title> <booktitle> In Proceedings of the SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 241-255, </pages> <address> Toronto, Ontario, </address> <month> June 26-28, </month> <year> 1991. </year>
Reference-contexts: These sets are used in scheduling instructions across basic block boundaries for speculative or predicated execution <ref> [Fis81, BR91] </ref>. They are also useful in merging program versions [HPR87], and in automatic paralleliza-tion [ABC + 88]. Set cdequiv (w) contains the nodes that have the same control dependences as node w.
Reference: [CF93] <author> Ron Cytron and Jeanne Ferrante. </author> <title> Efficiently computing -nodes on-the-fly. </title> <booktitle> In Proceedings of the Sixth Workshop on Languages and Compilers for Parallel Computing, </booktitle> <pages> pages 461-476, </pages> <month> August </month> <year> 1993. </year> <note> Published as Lecture Notes in Computer Science, number 768. </note>
Reference-contexts: This is an improvement over the original algorithm of Cytron et al which has a worst-case time complexity that is quadratic in the size of the program [CFR + 91]. Cytron and Ferrante have used path compression to design another algorithm with O (jEjff (jEj)) complexity <ref> [CF93] </ref>, but this algorithm is rather complicated. Johnson and Pingali have designed an O (jEj) algorithm for -function placement [JP93], using the dependence flow graph [PBJ + 91].
Reference: [CFR + 91] <author> R. Cytron, J. Ferrante, B. K. Rosen, M. N. Wegman, and F. K. Zadeck. </author> <title> Efficiently computing static single assignment form and the control dependence graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Some experimental results on a model problem and on the SPEC benchmarks are reported Section 4. In Section 5, we discuss an application of these techniques: we show how to perform -function placement, the key step in SSA computation <ref> [CFR + 91] </ref>, in O (jEj) time. <p> AP T is a small fraction of the time to build the postdominator tree. 5 Applications The AP T data structure can be used to design an optimal algorithm for finding the dominance frontier of a node, which is the key step in conversion to Static Single Assignment (SSA) form <ref> [SS70, CFR + 91] </ref>. In conversion to SSA form, dummy assignments called -functions are introduced into the program in such a way that every use of a variable is reached by at most one real or dummy assignment. <p> This definition is similar to that of Cytron et al <ref> [CFR + 91] </ref>. Comparing this to Definition 3, it is clear that (v ! u) (a)Storage vs. Nesting Level (ff 1) (b) Storage vs. Nesting Level (ff 1) (c) Storage vs. ff (d) Query Time vs. ff (e) Preprocessing Time vs. <p> The running time of the algorithm is proportional to the size of the program. This is an improvement over the original algorithm of Cytron et al which has a worst-case time complexity that is quadratic in the size of the program <ref> [CFR + 91] </ref>. Cytron and Ferrante have used path compression to design another algorithm with O (jEjff (jEj)) complexity [CF93], but this algorithm is rather complicated. Johnson and Pingali have designed an O (jEj) algorithm for -function placement [JP93], using the dependence flow graph [PBJ + 91].
Reference: [CFS90] <author> Ron Cytron, Jeanne Ferrante, and Vivek Sarkar. </author> <title> Compact representations for control dependence. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 337-351, </pages> <address> White Plains, New York, </address> <month> June 20-22, </month> <year> 1990. </year>
Reference-contexts: Control dependence is used in many phases of modern compilers, such as dataflow analysis, loop transformations and code scheduling. An abstract view of these applications is that they require the computation of the following sets derived from C <ref> [CFS90] </ref>: * cd (e) = fw 2 V j (e; w) 2 Cg, * conds (w) = fe 2 Ej (e; w) 2 Cg, and * cdequiv (w) = fv 2 V jconds (v) = conds (w)g Set cd (e) is the set of nodes that are control dependent on edge <p> Since this is a straight-forward representation of the full relation, the size of the CDG is (jEjjV j). There have been many efforts to construct more compact representations of the control dependence relation <ref> [FOW87, CFS90, Bal93, JP93, SGL94] </ref>, and the lack of success led Cytron, Ferrante and Sarkar to conjecture that any data structure that provided proportional time access to control dependence sets must use space that grows quadratically with program size [CFS90]. <p> efforts to construct more compact representations of the control dependence relation [FOW87, CFS90, Bal93, JP93, SGL94], and the lack of success led Cytron, Ferrante and Sarkar to conjecture that any data structure that provided proportional time access to control dependence sets must use space that grows quadratically with program size <ref> [CFS90] </ref>. In this paper, we describe a data structure called the aug mented postdominator tree (AP T ) which requires O (jEj) space, is built in O (jEj) time 3 , and which is designed to provide proportional time access to conds sets. <p> 12: else break ; % exit from the loop 13: od ; 14: if VisitNode is not a boundary node 15: then 16: for each child C of VisitNode 17: do 18: if C is not marked 19: then VisitIncr (QueryNode,C); 20: od ; 21: endif ; g cdequiv queries <ref> [CFS90] </ref>. Sreedhar and Gao investigated the conds problem using their DJ-graph representation, but this approach did not reduce the asymptotic complexity of conds computation [SGL94]. <p> This permits us to get a grip on storage requirements, which is difficult to do with run time approaches. Finally, we note that there is a deep connection between AP T , and the use of factoring to reduce the size of the CDG <ref> [CFS90] </ref>. Factoring identifies nodes that have control dependences in common, and creates representations which permit control dependences to be shared by multiple nodes. The simplest kind of factoring exploits cdequiv sets.
Reference: [Cha86] <author> Bernard Chazelle. </author> <title> Filtering search: A new approach to query answering. </title> <journal> SIAM Journal of Computing, </journal> <volume> 15 </volume> <pages> 703-724, </pages> <year> 1986. </year>
Reference-contexts: Finally, in Section 6, we contrast our approach with dynamic techniques like memoization [Mic68]; we also show that our approach can be viewed as an example of Chazelle's filtered search <ref> [Cha86] </ref>. 2 The Roman Chariots Problem We reformulate the control dependence problem as a naturally stated graph problem called the Roman Chariots problem, using the fact that nodes that are control dependent on an edge e in the control flow graph form a simple path in the postdominator tree [FOW87]. <p> By permitting this slack in the query procedure, we are successful in reducing space and preprocessing time requirements without affecting asymptotic query time. More generally, the approach to conds described in this paper can be viewed as an example of Chazelle's filtered search <ref> [Cha86] </ref>, a technique used in computational geometry to solve range search problems. In these problems, a set of geometrical objects in R d is given. A query is made in the form a connected region in R d , and all objects intersecting this region must be enumerated.
Reference: [CicBC] <author> Marcus Tullius Cicero. Pro L. </author> <note> Cornelio Balbo Oratio 39. Published by Senate of Rome, Rome, 56 BC. </note>
Reference-contexts: Procedure ConstructRoman-Chariots in Figure 3 takes a control flow graph as input, and 5 A thorough literature search failed to turn up any historical evidence to support this statement, but it is a matter of record that all roads led to Rome <ref> [CicBC] </ref>, just as in a tree rooted at Rome! Procedure ConstructRomanChariots (G:CFG):Tree, RouteArray; f 1: % G is the control flow graph, 2: T := build-postdominator-tree (G); 3: A := [ ]; %Initialize to empty array 4: i := 0; 5: for each node u in T in top-down order do
Reference: [CLR92] <author> Thomas Cormen, Charles Leiserson, and Ronald Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1992. </year>
Reference-contexts: If N is given online, we cannot sort it before starting queries. However, as long as nodes are presented for querying in order of decreasing level number, the approach discussed above can be used. To accomplish this in our context, we maintain a priority queue <ref> [CLR92] </ref> of nodes that must be queried; the key for the priority queue is level number in the tree. Initially, this priority queue contains only the nodes in S. <p> The priority queue can be implemented using a heap, which gives O (log (k)) time per operation, where k, the number of keys, is the height of the tree <ref> [CLR92] </ref>; a more sophisticated data structure due to van Emde Boas et al gives O (log (log (k)) time per operation [VEBKZ77]. Priority queues are more general than what we need since we can guarantee that insertions always occur `behind' extractions.
Reference: [Fis81] <author> Josh Fisher. </author> <title> Trace scheduling: a technique for global microcode compaction. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 7(3) </volume> <pages> 478-490, </pages> <year> 1981. </year>
Reference-contexts: These sets are used in scheduling instructions across basic block boundaries for speculative or predicated execution <ref> [Fis81, BR91] </ref>. They are also useful in merging program versions [HPR87], and in automatic paralleliza-tion [ABC + 88]. Set cdequiv (w) contains the nodes that have the same control dependences as node w.
Reference: [FOW87] <author> J. Ferrante, K. J. Ottenstein, and J. D. Warren. </author> <title> The program dependency graph and its uses in optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 319-349, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: START has no predecessors and END has no successors. To simplify the discussion, we will follow standard practice and assume that there is an edge from START directly to END in the control flow graph <ref> [FOW87] </ref>. Definition 2 A node w is said to postdominate a node v if every path from v to END contains w. Note that a node v is always postdominated by END and by itself. <p> The postdominator tree of a program can be constructed in O (jEjff (jEj)) time using an algorithm due to Tarjan and Lengauer [LT79], or in O (jEj) time using a rather more complicated algorithm due to Harel [Har85]. Control dependence can be defined formally as follows <ref> [FOW87] </ref>: Definition 3 A node w is said to be control dependent on edge (u ! v) 2 E if 1. w postdominates v, and 2. if w 6= u, then w does not postdominate u. <p> of the control dependence relation which can be built in O (jEj) space and O (jEj) preprocessing time, and which will answer cd, conds and cdequiv queries in time proportional to the size of the output? The standard representation of the control dependence relation is the control dependence graph (CDG) <ref> [FOW87] </ref>, which is best viewed as a bipartite graph in which the two sets of nodes in the bipartite graph are V and E, and in which there is an undirected edge between node v and edge e if v is control dependent on e. <p> Since this is a straight-forward representation of the full relation, the size of the CDG is (jEjjV j). There have been many efforts to construct more compact representations of the control dependence relation <ref> [FOW87, CFS90, Bal93, JP93, SGL94] </ref>, and the lack of success led Cytron, Ferrante and Sarkar to conjecture that any data structure that provided proportional time access to control dependence sets must use space that grows quadratically with program size [CFS90]. <p> search [Cha86]. 2 The Roman Chariots Problem We reformulate the control dependence problem as a naturally stated graph problem called the Roman Chariots problem, using the fact that nodes that are control dependent on an edge e in the control flow graph form a simple path in the postdominator tree <ref> [FOW87] </ref>. First, we introduce some convenient notation. Definition 4 Let T =&lt; V; F &gt; be a tree. For v; w 2 V , the notation [v; w] represents the set of vertices on the simple path joining v and w in P . <p> The following key theorem is due to Ferrante, Ottenstein and Warren <ref> [FOW87] </ref>. Theorem 1 If (u ! v) is an edge of the control flow graph, then 1. parent (u) is an ancestor of v in the postdominator tree, and 2. cd (u ! v) = [v; parent (u)). <p> Walk up the tree T from node v to node w, and output all nodes encountered in this walk, other than node w. This takes time proportional to the size of the output. This algorithm is similar to one due to Ferrante et al <ref> [FOW87] </ref>. 3.2 conds queries One way to answer conds queries is to examine all routes in array A, and report every route whose bottom node is a descendant of the query node, and whose top node is a proper ancestor of the query node. <p> Is there an optimal algorithm for SSA construction? 6 Conclusions and Related Work Control dependence was first defined by Ferrante, Otten-stein and Warren <ref> [FOW87] </ref>. They also described the control dependence graph, and gave an optimal algorithm for cd queries, which used the postdominator tree to enumerate cd sets in proportional time.
Reference: [GPS90] <author> Rajiv Gupta, Lori Pollock, and Mary Lou Soffa. </author> <title> Par-allelizing data flow analysis. </title> <booktitle> In Proceedings of the Workshop on Parallel Compilation, </booktitle> <address> Kingston, On-tario, </address> <month> May 6-8, </month> <year> 1990. </year> <institution> Queen's University. </institution>
Reference-contexts: The relation cdequiv can also be used to decompose the control flow graph of a program into single-entry single-exit (SESE) regions, and this decomposition can be exploited to speed up dataflow analysis by combining structural and fix-point induction [JPP94, Joh94], and to perform dataflow analysis in parallel <ref> [JPP94, GPS90] </ref>. Figure 1 shows a small program and its control dependence relation. For any edge e, cd (e) is the set of marked nodes in the row corresponding to e. For any node w, conds (w) is the set of marked edges in the column corresponding to w.
Reference: [GS87] <author> Rajiv Gupta and Mary Lou Soffa. </author> <title> Region scheduling. </title> <booktitle> In 2nd International Conference on Supercomputing, </booktitle> <pages> pages 141-148, </pages> <year> 1987. </year>
Reference-contexts: Set cdequiv (w) contains the nodes that have the same control dependences as node w. This information is useful in code scheduling because basic blocks with the same control dependences can be treated as one large basic block, as is done in region scheduling <ref> [GS87] </ref>. The relation cdequiv can also be used to decompose the control flow graph of a program into single-entry single-exit (SESE) regions, and this decomposition can be exploited to speed up dataflow analysis by combining structural and fix-point induction [JPP94, Joh94], and to perform dataflow analysis in parallel [JPP94, GPS90].
Reference: [Har85] <author> D. Harel. </author> <title> A linear time algorithm for finding dominators in flowgraphs and related problems. </title> <booktitle> In Proceedings of the 17th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 185-194, </pages> <address> Providence, Rhode Island, </address> <month> May 6-8, </month> <year> 1985. </year>
Reference-contexts: The postdominator tree of a program can be constructed in O (jEjff (jEj)) time using an algorithm due to Tarjan and Lengauer [LT79], or in O (jEj) time using a rather more complicated algorithm due to Harel <ref> [Har85] </ref>. Control dependence can be defined formally as follows [FOW87]: Definition 3 A node w is said to be control dependent on edge (u ! v) 2 E if 1. w postdominates v, and 2. if w 6= u, then w does not postdominate u. <p> Note that the size of the postdominator relation grows quadratically with program size (consider a chain of n nodes), but this relation can be represented using the postdominator tree, which can be built in O (jEj) space <ref> [LT79, Har85] </ref>, and which provides proportional time access to the postdominators of a node. The explanation of the paradox is that postdominance is a transitive relation, and the postdominator tree, which is the transitive reduction of this relation, is a `factored', compact representation of postdominance. <p> Since dfs numbers are already assigned by postdominator tree construction algorithms <ref> [LT79, Har85] </ref>, this is convenient.
Reference: [HPR87] <author> Susan Horowitz, Jan Prins, and Thomas Reps. </author> <title> Integrating non-interfering versions of programs. </title> <booktitle> In Conference Record of the 14th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 133-145, </pages> <address> Munich, West Germany, </address> <month> January 21-23, </month> <year> 1987. </year>
Reference-contexts: These sets are used in scheduling instructions across basic block boundaries for speculative or predicated execution [Fis81, BR91]. They are also useful in merging program versions <ref> [HPR87] </ref>, and in automatic paralleliza-tion [ABC + 88]. Set cdequiv (w) contains the nodes that have the same control dependences as node w.
Reference: [Joh94] <author> Richard Johnson. </author> <title> Efficient Program Analysis using Dependence Flow Graphs. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <month> August </month> <year> 1994. </year>
Reference-contexts: The relation cdequiv can also be used to decompose the control flow graph of a program into single-entry single-exit (SESE) regions, and this decomposition can be exploited to speed up dataflow analysis by combining structural and fix-point induction <ref> [JPP94, Joh94] </ref>, and to perform dataflow analysis in parallel [JPP94, GPS90]. Figure 1 shows a small program and its control dependence relation. For any edge e, cd (e) is the set of marked nodes in the row corresponding to e.
Reference: [JP93] <author> Richard Johnson and Keshav Pingali. </author> <title> Dependence-based program analysis. </title> <booktitle> In Proceedings of the SIG-PLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 78-89, </pages> <address> Albu-querque, New Mexico, </address> <month> June 23-25, </month> <year> 1993. </year>
Reference-contexts: Since this is a straight-forward representation of the full relation, the size of the CDG is (jEjjV j). There have been many efforts to construct more compact representations of the control dependence relation <ref> [FOW87, CFS90, Bal93, JP93, SGL94] </ref>, and the lack of success led Cytron, Ferrante and Sarkar to conjecture that any data structure that provided proportional time access to control dependence sets must use space that grows quadratically with program size [CFS90]. <p> Cytron and Ferrante have used path compression to design another algorithm with O (jEjff (jEj)) complexity [CF93], but this algorithm is rather complicated. Johnson and Pingali have designed an O (jEj) algorithm for -function placement <ref> [JP93] </ref>, using the dependence flow graph [PBJ + 91]. Just as building the SSA form can be reduced to an iterated conds computation, building the dependence flow graph can be reduced to an iterated cdequiv computation, and can be done in O (jEj) time per variable.
Reference: [JPP94] <author> Richard Johnson, David Pearson, and Keshav Pin-gali. </author> <title> The program structure tree: Computing control regions in linear time. </title> <booktitle> In Proceedings of the SIG-PLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 171-185, </pages> <address> Or-lando, Florida, </address> <month> June 20-24, </month> <year> 1994. </year>
Reference-contexts: The relation cdequiv can also be used to decompose the control flow graph of a program into single-entry single-exit (SESE) regions, and this decomposition can be exploited to speed up dataflow analysis by combining structural and fix-point induction <ref> [JPP94, Joh94] </ref>, and to perform dataflow analysis in parallel [JPP94, GPS90]. Figure 1 shows a small program and its control dependence relation. For any edge e, cd (e) is the set of marked nodes in the row corresponding to e. <p> The relation cdequiv can also be used to decompose the control flow graph of a program into single-entry single-exit (SESE) regions, and this decomposition can be exploited to speed up dataflow analysis by combining structural and fix-point induction [JPP94, Joh94], and to perform dataflow analysis in parallel <ref> [JPP94, GPS90] </ref>. Figure 1 shows a small program and its control dependence relation. For any edge e, cd (e) is the set of marked nodes in the row corresponding to e. For any node w, conds (w) is the set of marked edges in the column corresponding to w. <p> be done in one top-down and one bottom-up walk of the postdominator tree, followed by one traversal of the route array. 3.3 cdequiv queries To solve the cdequiv problem efficiently, we exploit an algorithm of Johnson, Pearson and Pingali for identifying tree nodes contained in the same set of routes <ref> [JPP94, Section 3] </ref>. This algorithm requires O (jAj + jV j) time and space. During preprocessing, we execute this algorithm, and then chain nodes in each equivalence class into a cycle, using a field C at each node, which is made to point to the next node in the cycle. <p> 32: for i := 1 to jAj do 34: w := b; 35: while t is proper ancestor of w do 36: append i to end of list L [w]; 37: w := N xtBndry [w]; 38: od An interesting point to note is that the algorithm for cdequiv in <ref> [JPP94] </ref> uses the depth-first tree of the undi-rected version of the control-flow graph, in which the analogs of routes are back edges. <p> The general cdequiv problem was solved finally by Johnson, Pearson and Pingali who designed an optimal algorithm which required O (jEj) preprocessing time and space, and which enumerated cdequiv sets in proportional time <ref> [JPP94] </ref>. This algorithm requires neither dominator nor postdominator information, and permits the computation of the cdequiv relation in less time than it takes to compute the postdominance relation! There are many alternatives to the zone construction algorithm given here. <p> For example, we can use cdequiv information in answering conds queries. It can be shown that the nodes in a cdequiv equivalence class are ordered by the ancestor relation in the postdominator tree <ref> [JPP94] </ref>.
Reference: [LT79] <author> Thomas Lengauer and Robert Endre Tarjan. </author> <title> A fast algorithm for finding dominators in a flowgraph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 1(1) </volume> <pages> 121-141, </pages> <month> July </month> <year> 1979. </year>
Reference-contexts: The parent of a node in this tree is called the immediate postdominator of that node. The postdominator tree of a program can be constructed in O (jEjff (jEj)) time using an algorithm due to Tarjan and Lengauer <ref> [LT79] </ref>, or in O (jEj) time using a rather more complicated algorithm due to Harel [Har85]. <p> Note that the size of the postdominator relation grows quadratically with program size (consider a chain of n nodes), but this relation can be represented using the postdominator tree, which can be built in O (jEj) space <ref> [LT79, Har85] </ref>, and which provides proportional time access to the postdominators of a node. The explanation of the paradox is that postdominance is a transitive relation, and the postdominator tree, which is the transitive reduction of this relation, is a `factored', compact representation of postdominance. <p> Since dfs numbers are already assigned by postdominator tree construction algorithms <ref> [LT79, Har85] </ref>, this is convenient. <p> It is well-known that any algorithm computing the post-dominance relation can be used to compute the dominance relation by applying this algorithm to the reverse control flow graph, the control flow graph obtained by reversing all control flow edges and interchanging START and END <ref> [LT79] </ref>. Definition 8 The edge dominance frontier of a node w in a control flow graph is a set of edges, denoted by edf (w), such (v ! u) 2 edf (w) if 1. w dominates v, and 2. if w 6= u, then w does not dominate u.
Reference: [Mic68] <author> D. Michie. </author> <title> `Memo' functions and machine learning. </title> <journal> Nature, </journal> <volume> 218 </volume> <pages> 19-22, </pages> <month> April </month> <year> 1968. </year>
Reference-contexts: In Section 5, we discuss an application of these techniques: we show how to perform -function placement, the key step in SSA computation [CFR + 91], in O (jEj) time. Finally, in Section 6, we contrast our approach with dynamic techniques like memoization <ref> [Mic68] </ref>; we also show that our approach can be viewed as an example of Chazelle's filtered search [Cha86]. 2 The Roman Chariots Problem We reformulate the control dependence problem as a naturally stated graph problem called the Roman Chariots problem, using the fact that nodes that are control dependent on an <p> Although we have used the term caching to describe AP T , note that most caching techniques for search problems, such as memoization and related ideas used in the theorem proving community <ref> [Mic68, SS93] </ref>, perform caching at run time (query time). In contrast, caching in AP T is performed during preprocessing, and the data structure is not modified by query processing. This permits us to get a grip on storage requirements, which is difficult to do with run time approaches.
Reference: [PBJ + 91] <author> Keshav Pingali, Micah Beck, Richard Johnson, Mayan Moudgill, and Paul Stodghill. </author> <title> Dependence Flow Graphs: An algebraic approach to program dependencies. </title> <booktitle> In Conference Record of the 18th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 67-78, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Cytron and Ferrante have used path compression to design another algorithm with O (jEjff (jEj)) complexity [CF93], but this algorithm is rather complicated. Johnson and Pingali have designed an O (jEj) algorithm for -function placement [JP93], using the dependence flow graph <ref> [PBJ + 91] </ref>. Just as building the SSA form can be reduced to an iterated conds computation, building the dependence flow graph can be reduced to an iterated cdequiv computation, and can be done in O (jEj) time per variable.
Reference: [Pod93] <author> Andy Podgurski. </author> <title> Reordering-transformations that preserve control dependence. </title> <type> Technical Report CES-93-16, </type> <institution> Case Western Reserve University, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: The cdequiv problem for reducible control flow graphs was solved by Ball [Bal93] who needed both dominator and postdominator information in his solution; subsequently, Podgurski gave a linear-time algorithm for forward control dependence equivalence, which is a special case of general control dependence equivalence <ref> [Pod93] </ref>. The general cdequiv problem was solved finally by Johnson, Pearson and Pingali who designed an optimal algorithm which required O (jEj) preprocessing time and space, and which enumerated cdequiv sets in proportional time [JPP94].
Reference: [SG95] <author> Vugranam C. Sreedhar and Guang R. Gao. </author> <title> A linear time algorithm for placing -nodes. </title> <booktitle> In Conference Record of POPL '95: 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 62-73, </pages> <address> San Francisco, California, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: Priority queues are more general than what we need since we can guarantee that insertions always occur `behind' extractions. Sreedhar and Gao have pointed out that an array of size k suffices <ref> [SG95] </ref>; in this array, each element is a linked list of nodes, at the corresponding level, that must be queried.
Reference: [SGL94] <author> Vugranam C. Sreedhar, Guang R. Gao, and Yong-fong Lee. </author> <title> DJ-graphs and their applications to flow-graph analyses. </title> <type> Technical Report ACAPS Memo 70, </type> <institution> McGill University, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: Since this is a straight-forward representation of the full relation, the size of the CDG is (jEjjV j). There have been many efforts to construct more compact representations of the control dependence relation <ref> [FOW87, CFS90, Bal93, JP93, SGL94] </ref>, and the lack of success led Cytron, Ferrante and Sarkar to conjecture that any data structure that provided proportional time access to control dependence sets must use space that grows quadratically with program size [CFS90]. <p> Sreedhar and Gao investigated the conds problem using their DJ-graph representation, but this approach did not reduce the asymptotic complexity of conds computation <ref> [SGL94] </ref>. The cdequiv problem for reducible control flow graphs was solved by Ball [Bal93] who needed both dominator and postdominator information in his solution; subsequently, Podgurski gave a linear-time algorithm for forward control dependence equivalence, which is a special case of general control dependence equivalence [Pod93].
Reference: [SS70] <author> R. M. Shapiro and H. </author> <title> Saint. The representation of algorithms. </title> <type> Technical Report CA-7002-1432, </type> <institution> Mas-sachusetts Computer Associates, </institution> <month> February </month> <year> 1970. </year>
Reference-contexts: AP T is a small fraction of the time to build the postdominator tree. 5 Applications The AP T data structure can be used to design an optimal algorithm for finding the dominance frontier of a node, which is the key step in conversion to Static Single Assignment (SSA) form <ref> [SS70, CFR + 91] </ref>. In conversion to SSA form, dummy assignments called -functions are introduced into the program in such a way that every use of a variable is reached by at most one real or dummy assignment.
Reference: [SS93] <author> A. Segre and D. Scharstein. </author> <title> Bounded-overhead caching for definite-clause theorem proving. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 11 </volume> <pages> 83-113, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: Although we have used the term caching to describe AP T , note that most caching techniques for search problems, such as memoization and related ideas used in the theorem proving community <ref> [Mic68, SS93] </ref>, perform caching at run time (query time). In contrast, caching in AP T is performed during preprocessing, and the data structure is not modified by query processing. This permits us to get a grip on storage requirements, which is difficult to do with run time approaches.
Reference: [VEBKZ77] <author> P. Van Emde Boas, R. Kaas, and E. Zijlstra. </author> <title> Design and implementation of an efficient priority queue. </title> <journal> Mathemetical Systems Theory, </journal> <volume> 10 </volume> <pages> 99-127, </pages> <year> 1977. </year>
Reference-contexts: The priority queue can be implemented using a heap, which gives O (log (k)) time per operation, where k, the number of keys, is the height of the tree [CLR92]; a more sophisticated data structure due to van Emde Boas et al gives O (log (log (k)) time per operation <ref> [VEBKZ77] </ref>. Priority queues are more general than what we need since we can guarantee that insertions always occur `behind' extractions.
References-found: 27

