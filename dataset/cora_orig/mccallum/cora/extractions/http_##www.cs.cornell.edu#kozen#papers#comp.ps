URL: http://www.cs.cornell.edu/kozen/papers/comp.ps
Refering-URL: http://www.cs.cornell.edu/kozen/papers/papers.html
Root-URL: 
Title: NC Algorithms for Comparability Graphs, Interval Graphs, and Unique Perfect Matchings  
Author: Dexter C. Kozen Umesh V. Vazirani Vijay V. Vazirani 
Address: New Delhi  
Affiliation: Cornell University  University of California, Berkeley  Indian Institute of Technology,  
Abstract: Laszlo Lovasz recently posed the following problem: "Is there an NC algorithm for testing if a given graph has a unique perfect matching?" We present such an algorithm for bipartite graphs. We also give NC algorithms for obtaining a transitive orientation of a comparability graph, and an interval representation of an interval graph. These enable us to obtain an NC algorithm for finding a maximum matching in an incomparability graph.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Borodin, J. von zur Gathen, and J. Hopcroft. </author> <title> Fast parallel matrix and gcd computations. </title> <booktitle> In Proc. 23rd Symp. Theory of Computing, </booktitle> <pages> pages 65-71. </pages> <publisher> ACM, </publisher> <year> 1982. </year>
Reference-contexts: It remains open whether there is a deterministic NC algorithm for this problem. A first step might be to obtain an NC algorithm for testing if a graph has a perfect matching. An RNC algorithm for this problem exists, based on a method of Lovasz [13] (see <ref> [1] </ref>). Rabin and Vazirani [18] give an NC algorithm for obtaining perfect matchings in graphs having a unique perfect matching.
Reference: [2] <author> S. Even, A. Pnueli, and A. Lempel. </author> <title> Permutation graphs and transitive graphs. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 19 </volume> <pages> 400-410, </pages> <year> 1972. </year>
Reference-contexts: The first sequential algorithms for these problems were obtained by Gilmore and Hoffman [6] and Ghouila-Houri [5]. More efficient algorithms were obtained by Even, Pnueli, and Lempel <ref> [2, 17] </ref> and Golumbic [7]. The NC comparability graph algorithm, together with the NC two-processor scheduling algorithm of Helmbold and Mayr [8] give an NC algorithm for maximum matching in comparability graphs, a class of graphs containing all interval graphs.
Reference: [3] <author> M. Fujii, T. Kasami, and K. Ninomiya. </author> <title> Optimal sequencing of two equivalent processors. </title> <journal> SIAM J. Comp., </journal> <volume> 17 </volume> <pages> 784-789, </pages> <year> 1969. </year>
Reference-contexts: Two jobs which are scheduled in the same time unit on the two processors are said to be paired . The connection between this problem and the maximum matching problem is established by the following theorem: Theorem 33 (Fujii, Kasami, and Ninomiya <ref> [3] </ref>) Let G = (V; E) be a directed, acyclic graph, and let Gfl c be the complement of its transitive closure. Then the paired jobs in an optimal schedule for G form a maximum matching in Gfl c . This theorem enabled [3] to obtain a fast sequential algorithm for <p> theorem: Theorem 33 (Fujii, Kasami, and Ninomiya <ref> [3] </ref>) Let G = (V; E) be a directed, acyclic graph, and let Gfl c be the complement of its transitive closure. Then the paired jobs in an optimal schedule for G form a maximum matching in Gfl c . This theorem enabled [3] to obtain a fast sequential algorithm for two-processor scheduling, using a maximum matching algorithm as a subroutine. We will do the reverse. <p> Proof. Given an incomparability graph G, first obtain a transitive orientation of G c using Theorem 29. The resulting graph is then a transitively closed acyclic digraph; compute an optimal two-processor schedule for it using Theorem 33. By <ref> [3] </ref>, the list of paired jobs will be a maximum matching in G. fl Acknowledgements We are grateful to Ashok Chandra, Alan Hoffman, David Kelly, and Laszlo Lovasz for several inspiring and informative discussions. Dexter Kozen was supported by NSF grant DCR-8602663.
Reference: [4] <author> T. </author> <title> Gallai. </title> <journal> Transitiv orientierbare graphen. Acta Math. Acad. Sci. Hungar., </journal> <volume> 18 </volume> <pages> 25-66, </pages> <year> 1967. </year>
Reference-contexts: However, producing a transitive orientation in case one exists is a harder problem. We use a decomposition theorem that allows a graph to be decomposed according to its comparability structure, allowing separate parts of the graph to be oriented independently. This decomposition was first discovered by Gallai <ref> [4] </ref>; see Kelly [11] for an excellent account in English. Considerations of efficiency require us to be more careful in the development of the Gallai decomposition.
Reference: [5] <author> A. Ghouila-Houri. Caracterisation des graphes nonorientes dont on peut ori-enter les aretes de maniere a obtenir le graphe d'une relation d'ordre. C. R. </author> <title> Acad. </title> <journal> Sci. Paris, </journal> <volume> 254 </volume> <pages> 1370-1371, </pages> <year> 1962. </year>
Reference-contexts: We also give NC algorithms for obtaining a transitive orientation of a given comparability graph, and an interval representation for a given interval graph. The first sequential algorithms for these problems were obtained by Gilmore and Hoffman [6] and Ghouila-Houri <ref> [5] </ref>. More efficient algorithms were obtained by Even, Pnueli, and Lempel [2, 17] and Golumbic [7]. <p> Output: A transitive orientation of the edges, or indication that no such orientation exists. The first polynomial time algorithms for this problem were given independently by Gilmore and Hoffman [6] and Ghouila-Houri <ref> [5] </ref>. They proved: Theorem 3 ([6, 5]) A graph G is a comparability graph iff each odd cycle has a triangular chord. This property is easy to check in NC . However, producing a transitive orientation in case one exists is a harder problem.
Reference: [6] <author> P. C. Gilmore and A. J. Hoffman. </author> <title> A characterization of comparability graphs and of interval graphs. </title> <journal> Canad. J. Math., </journal> <volume> 16 </volume> <pages> 539-548, </pages> <year> 1964. </year>
Reference-contexts: We also give NC algorithms for obtaining a transitive orientation of a given comparability graph, and an interval representation for a given interval graph. The first sequential algorithms for these problems were obtained by Gilmore and Hoffman <ref> [6] </ref> and Ghouila-Houri [5]. More efficient algorithms were obtained by Even, Pnueli, and Lempel [2, 17] and Golumbic [7]. <p> In this section we give an NC algorithm for the following problem: Input: An undirected graph G = (V; E). Output: A transitive orientation of the edges, or indication that no such orientation exists. The first polynomial time algorithms for this problem were given independently by Gilmore and Hoffman <ref> [6] </ref> and Ghouila-Houri [5]. They proved: Theorem 3 ([6, 5]) A graph G is a comparability graph iff each odd cycle has a triangular chord. This property is easy to check in NC . However, producing a transitive orientation in case one exists is a harder problem. <p> Input: An undirected graph G = (V; E). Output: An interval graph representation of G, or an indication that no such representation exists. Definition 30 (Gilmore and Hoffmann <ref> [6] </ref>) Let be a linearly ordered finite set. An interval ff of is any set of contiguous elements of . Let I be a set of intervals on . <p> The following characterization immediately gives us an NC algorithm for checking if G is an interval graph: Theorem 31 (Gilmore and Hoffmann <ref> [6] </ref>) G is an interval graph iff (i) G is an incomparability graph, and (ii) every cycle of length four in G has a diagonal. Our NC algorithm for obtaining an interval representation for G is essentially a parallelization of the sequential algorithm of Gilmore and Hoffman [6], using the transitive <p> (Gilmore and Hoffmann <ref> [6] </ref>) G is an interval graph iff (i) G is an incomparability graph, and (ii) every cycle of length four in G has a diagonal. Our NC algorithm for obtaining an interval representation for G is essentially a parallelization of the sequential algorithm of Gilmore and Hoffman [6], using the transitive orientation algorithm of Section 3. We give below this sequential algorithm: 1. Transitively orient the edges of G c . 2. qFind a set of maximal cliques in G such that every vertex and every edge is in at least one such clique. <p> Moreover, if we define C 1 C 2 if these edges are directed from C 1 to C 2 , then this linearly orders <ref> [6] </ref>. 14 3. For any vertex v 2 G, let ff (v) be the set of maximal cliques to which v belongs. These cliques will be contiguous, and thus will form an interval of [6]. Let I be the set of all the intervals corresponding to the vertices of G. <p> if these edges are directed from C 1 to C 2 , then this linearly orders <ref> [6] </ref>. 14 3. For any vertex v 2 G, let ff (v) be the set of maximal cliques to which v belongs. These cliques will be contiguous, and thus will form an interval of [6]. Let I be the set of all the intervals corresponding to the vertices of G. Then (; I) is an interval representation of G. We will now parallelize this algorithm: 1. Transitively orient G c using Theorem 29. 2.
Reference: [7] <author> M. C. Golumbic. </author> <title> Comparability graphs and a new matroid. </title> <journal> J. Combinatorial Theory, </journal> <volume> 22(1) </volume> <pages> 68-90, </pages> <month> February </month> <year> 1977. </year>
Reference-contexts: The first sequential algorithms for these problems were obtained by Gilmore and Hoffman [6] and Ghouila-Houri [5]. More efficient algorithms were obtained by Even, Pnueli, and Lempel [2, 17] and Golumbic <ref> [7] </ref>. The NC comparability graph algorithm, together with the NC two-processor scheduling algorithm of Helmbold and Mayr [8] give an NC algorithm for maximum matching in comparability graphs, a class of graphs containing all interval graphs.
Reference: [8] <author> D. Helmbold and E. Mayr. </author> <title> Two processor scheduling is in NC . To appear. </title>
Reference-contexts: The first sequential algorithms for these problems were obtained by Gilmore and Hoffman [6] and Ghouila-Houri [5]. More efficient algorithms were obtained by Even, Pnueli, and Lempel [2, 17] and Golumbic [7]. The NC comparability graph algorithm, together with the NC two-processor scheduling algorithm of Helmbold and Mayr <ref> [8] </ref> give an NC algorithm for maximum matching in comparability graphs, a class of graphs containing all interval graphs. <p> This was the first non-trivial class of graphs for which maximum matchings could be obtained fast in parallel. It was subsumed by [9], who showed that the general matching problem was in NC . More recently, Helmbold and Mayr <ref> [8] </ref> have obtained an NC algorithm for two-processor scheduling. This allows us to dispense with randomization in the case of incomparability graphs. Theorem 34 There is an NC algorithm which, given an incomparability graph G = (V; E), obtains a maximum matching in it. Proof.
Reference: [9] <author> R. M. Karp, E. Upfal, and A. Wigderson. </author> <title> Finding a maximum matching is in random NC . In Proc. </title> <booktitle> 26th Symp. Theory of Computing, </booktitle> <pages> pages 22-32. </pages> <publisher> ACM, </publisher> <year> 1985. </year>
Reference-contexts: 1 Introduction Karp, Upfal and Wigderson <ref> [9] </ref> have recently shown that the maximum matching problem is in Random NC 3 (RNC 3 ). This result has since been improved to RNC 2 by Mulmuley, Vazirani, and Vazirani [16]. It remains open whether there is a deterministic NC algorithm for this problem. <p> We will do the reverse. Vazirani and Vazirani [19] gave a Random NC algorithm for the two-processor scheduling problem, using the RNC matching algorithm of Karp, Upfal, and Wigderson <ref> [9] </ref> as a subroutine. This gave a weaker version of Theorem 34 below which showed the maximum matching problem for interval graphs to be in RNC . This was the first non-trivial class of graphs for which maximum matchings could be obtained fast in parallel. It was subsumed by [9], who <p> Wigderson <ref> [9] </ref> as a subroutine. This gave a weaker version of Theorem 34 below which showed the maximum matching problem for interval graphs to be in RNC . This was the first non-trivial class of graphs for which maximum matchings could be obtained fast in parallel. It was subsumed by [9], who showed that the general matching problem was in NC . More recently, Helmbold and Mayr [8] have obtained an NC algorithm for two-processor scheduling. This allows us to dispense with randomization in the case of incomparability graphs.
Reference: [10] <author> R. M. Karp and A. Wigderson. </author> <title> A fast parallel algorithm for the maximal independent set problem. </title> <booktitle> In Proc. 25th Symp. Theory of Computing, </booktitle> <pages> pages 266-272. </pages> <publisher> ACM, </publisher> <year> 1984. </year>
Reference-contexts: This gives the linear order on . 5. Do in parallel for each vertex v 2 G: obtain the interval ff (v). This will yield the set of intervals I. To accomplish step 2, we can use the parallel maximal clique algorithm of Karp and Wigderson <ref> [10] </ref>, or the more efficient algorithm of Luby [14].
Reference: [11] <author> D. Kelly. </author> <title> Comparability graphs. </title> <editor> In I. Rival, editor, </editor> <title> Graphs and Order, </title> <booktitle> volume 147 of Nato ASI series C, </booktitle> <pages> pages 3-40. </pages> <address> D. </address> <publisher> Reidel, </publisher> <year> 1985. </year>
Reference-contexts: We use a decomposition theorem that allows a graph to be decomposed according to its comparability structure, allowing separate parts of the graph to be oriented independently. This decomposition was first discovered by Gallai [4]; see Kelly <ref> [11] </ref> for an excellent account in English. Considerations of efficiency require us to be more careful in the development of the Gallai decomposition. <p> This decomposition was first discovered by Gallai [4]; see Kelly [11] for an excellent account in English. Considerations of efficiency require us to be more careful in the development of the Gallai decomposition. Our development, which we give below in full, departs from the standard development <ref> [11, 15] </ref> in several technical respects, perhaps the most important of which is the inclusion of edges of the complementary graph in the definition of the relation ", the symmetry of G and G c , and the use of the relation "". Otherwise, basic notation and terminology follow [11, 15]. <p> development <ref> [11, 15] </ref> in several technical respects, perhaps the most important of which is the inclusion of edges of the complementary graph in the definition of the relation ", the symmetry of G and G c , and the use of the relation "". Otherwise, basic notation and terminology follow [11, 15]. Let G = (V; E) be an undirected graph without multiple edges or loops. We represent E as a set of ordered pairs such that E = E 1 = fuv j vu 2 Eg. <p> The " fl -class of uv is denoted [uv] and is called the implication class of uv. The set [uv] [ [vu] is called the color class of uv. The set of vertices touched by edges of [uv] is denoted V [uv]. fl Unlike <ref> [11] </ref>, " and " fl are defined on edges in E c as well as E, and on directed edges instead of undirected edges. Note, however, that [uv] = [u 0 v 0 ] iff [vu] = [v 0 u 0 ], thus [vu] = [uv] 1 . <p> A subset A V is called normal if for all u 62 A and v; v 0 2 A, [uv] = [uv 0 ]. fl The definition of normal set is related to the definition of autonomous set in <ref> [11, 15] </ref>. Our definition differs in that it involves edges in E c as well as E. Kernels and normal subsets are related by the following lemma. Lemma 13 A partition is a kernel iff every A 2 is normal. Every normal set A is contained in some kernel. Proof. <p> But then A = V [[uv]], otherwise was not maximal. fl 3.3 Classification of simple graphs The following theorem classifies all simple graphs into one of three types. It is a much simplified restatement of Theorems 1.2 and 1.8 of <ref> [11] </ref>. Theorem 28 A graph G is simple iff either: (i) G is a clique; (ii) G is totally disconnected (so that G c is a clique); (iii) G contains at least four vertices and has exactly two color classes, one each in E and E c . 11 Proof.
Reference: [12] <author> Dexter Kozen, Umesh Vazirani, and Vijay Vazirani. </author> <title> NC algorithms for comparability graphs, interval graphs, and unique perfect matching. </title> <editor> In Maheshwari, editor, </editor> <booktitle> Proc. 5th Conf. Found. Software Technology and Theor. Comput. Sci., volume 206 of Lect. Notes in Comput. Sci., </booktitle> <pages> pages 496-503. </pages> <publisher> Springer-Verlag, </publisher> <month> December </month> <year> 1985. </year>
Reference-contexts: Rabin and Vazirani [18] give an NC algorithm for obtaining perfect matchings in graphs having a unique perfect matching. Laszlo Lovasz recently posed the following problem: "Is there an NC algorithm for fl A preliminary version of this paper appeared as <ref> [12] </ref>. 1 testing if a given graph has a unique perfect matching?" We present such an algorithm for bipartite graphs. We also give NC algorithms for obtaining a transitive orientation of a given comparability graph, and an interval representation for a given interval graph.
Reference: [13] <author> L. Lovasz. </author> <title> On determinants, matchings, and random algorithms. </title> <note> To appear. </note>
Reference-contexts: It remains open whether there is a deterministic NC algorithm for this problem. A first step might be to obtain an NC algorithm for testing if a graph has a perfect matching. An RNC algorithm for this problem exists, based on a method of Lovasz <ref> [13] </ref> (see [1]). Rabin and Vazirani [18] give an NC algorithm for obtaining perfect matchings in graphs having a unique perfect matching.
Reference: [14] <author> M. Luby. </author> <title> A simple parallel algorithm for the maximal independent set problem. </title> <booktitle> In Proc. 26th Symp. Theory of Computing, </booktitle> <pages> pages 1-10. </pages> <publisher> ACM, </publisher> <year> 1985. </year>
Reference-contexts: Do in parallel for each vertex v 2 G: obtain the interval ff (v). This will yield the set of intervals I. To accomplish step 2, we can use the parallel maximal clique algorithm of Karp and Wigderson [10], or the more efficient algorithm of Luby <ref> [14] </ref>.
Reference: [15] <author> R. H. Mohring. </author> <title> Algorithmic aspects of comparability graphs and interval graphs. </title> <editor> In I. Rival, editor, </editor> <title> Graphs and Order, </title> <booktitle> volume 147 of Nato ASI series C, </booktitle> <pages> pages 41-102. </pages> <address> D. </address> <publisher> Reidel, </publisher> <year> 1985. </year>
Reference-contexts: This decomposition was first discovered by Gallai [4]; see Kelly [11] for an excellent account in English. Considerations of efficiency require us to be more careful in the development of the Gallai decomposition. Our development, which we give below in full, departs from the standard development <ref> [11, 15] </ref> in several technical respects, perhaps the most important of which is the inclusion of edges of the complementary graph in the definition of the relation ", the symmetry of G and G c , and the use of the relation "". Otherwise, basic notation and terminology follow [11, 15]. <p> development <ref> [11, 15] </ref> in several technical respects, perhaps the most important of which is the inclusion of edges of the complementary graph in the definition of the relation ", the symmetry of G and G c , and the use of the relation "". Otherwise, basic notation and terminology follow [11, 15]. Let G = (V; E) be an undirected graph without multiple edges or loops. We represent E as a set of ordered pairs such that E = E 1 = fuv j vu 2 Eg. <p> A subset A V is called normal if for all u 62 A and v; v 0 2 A, [uv] = [uv 0 ]. fl The definition of normal set is related to the definition of autonomous set in <ref> [11, 15] </ref>. Our definition differs in that it involves edges in E c as well as E. Kernels and normal subsets are related by the following lemma. Lemma 13 A partition is a kernel iff every A 2 is normal. Every normal set A is contained in some kernel. Proof.
Reference: [16] <author> K. Mulmuley, U. Vazirani, and V. </author> <note> Vazirani. </note>
Reference-contexts: 1 Introduction Karp, Upfal and Wigderson [9] have recently shown that the maximum matching problem is in Random NC 3 (RNC 3 ). This result has since been improved to RNC 2 by Mulmuley, Vazirani, and Vazirani <ref> [16] </ref>. It remains open whether there is a deterministic NC algorithm for this problem. A first step might be to obtain an NC algorithm for testing if a graph has a perfect matching. An RNC algorithm for this problem exists, based on a method of Lovasz [13] (see [1]).
Reference: [17] <author> A. Pnueli, A. Lempel, and S. </author> <title> Even. Transitive orientation of graphs and identification of permutation graphs. </title> <journal> Canad. J. Math., </journal> <volume> 23 </volume> <pages> 160-175, </pages> <year> 1971. </year>
Reference-contexts: The first sequential algorithms for these problems were obtained by Gilmore and Hoffman [6] and Ghouila-Houri [5]. More efficient algorithms were obtained by Even, Pnueli, and Lempel <ref> [2, 17] </ref> and Golumbic [7]. The NC comparability graph algorithm, together with the NC two-processor scheduling algorithm of Helmbold and Mayr [8] give an NC algorithm for maximum matching in comparability graphs, a class of graphs containing all interval graphs.
Reference: [18] <author> M. O. Rabin and V. V. Vazirani. </author> <title> Maximum matchings in general graphs through randomization. </title> <type> Technical Report TR15-84, </type> <institution> Center for Research in Computing Technology, </institution> <year> 1984. </year>
Reference-contexts: A first step might be to obtain an NC algorithm for testing if a graph has a perfect matching. An RNC algorithm for this problem exists, based on a method of Lovasz [13] (see [1]). Rabin and Vazirani <ref> [18] </ref> give an NC algorithm for obtaining perfect matchings in graphs having a unique perfect matching. <p> If G has a unique perfect matching M E, there is a simple NC algorithm for obtaining it <ref> [18] </ref>; however that algorithm does not check whether 2 M is in fact unique. If the edge xy is in M , then the graph G xy obtained from G by removing the edge xy will have no perfect matching. <p> The result is then obtained by taking P = S 1 and Q = RS. fl Thus, in order to check whether the matching M is unique, we first compute the matrix AR, which can be done by the method of <ref> [18] </ref> described above. Then the matching M in G will be unique iff the directed graph H described in the proof of Lemma 1 has no cycles. There are very simple NC algorithms to check this.
Reference: [19] <author> U. V. Vazirani and V. V. Vazirani. </author> <title> The two-processor scheduling problem is in random NC . In Proc. </title> <booktitle> 26th Symp. Theory of Computing, </booktitle> <pages> pages 11-21. </pages> <publisher> ACM, </publisher> <year> 1985. </year> <month> 18 </month>
Reference-contexts: Then the paired jobs in an optimal schedule for G form a maximum matching in Gfl c . This theorem enabled [3] to obtain a fast sequential algorithm for two-processor scheduling, using a maximum matching algorithm as a subroutine. We will do the reverse. Vazirani and Vazirani <ref> [19] </ref> gave a Random NC algorithm for the two-processor scheduling problem, using the RNC matching algorithm of Karp, Upfal, and Wigderson [9] as a subroutine. This gave a weaker version of Theorem 34 below which showed the maximum matching problem for interval graphs to be in RNC .
References-found: 19

