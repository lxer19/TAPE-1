URL: http://www.cs.wustl.edu/~schmidt/Atomic_Op-94.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/resume.html
Root-URL: http://www.cs.wustl.edu
Email: schmidt@cs.wustl.edu  
Title: Transparently Parameterizing Synchronization into a Concurrent Distributed Application A Case Study of C++ Design Evolution  
Author: Douglas C. Schmidt 
Address: St. Louis, 63130  
Affiliation: Department of Computer Science Washington University,  
Abstract: An earlier version of this paper appeared in the July/August 1994 issue of the C++ Report. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: This article focuses on the steps involved in generalizing from existing code by using templates and overloading to transparently parameterize synchronization mechanisms into a concurrent application. Some of the infrastructure code is based on components in the freely available ADAPTIVE Service eXecutive (ASX) framework described in <ref> [1, 2, 3, 4, 5] </ref>. 2 Motivation The following C++ code illustrates part of the main event-loop of a typical distributed application (such as an object location broker [6] or a multi-threaded network file server): Example 1 typedef unsigned long COUNTER; COUNTER request_count; // At file scope void * run_svc (void <p> At file scope void * run_svc (int iterations) - Thr_Cntl t (&thr_manager); for (int i = 0; i &lt; iterations; i++) 1 request_count++; // Count # of requests return t.exit ((void *) i); - main (int argc, char *argv []) - int n_threads = argc &gt; 1 ? atoi (argv <ref> [1] </ref>) : 4; int n_iterations = argc &gt; 2 ? atoi (argv [2]) : 1000000; // Divide iterations evenly among threads int iterations = n_iterations / n_threads; // Spawn off N threads to run in parallel thr_manager.spawn_n (n_threads, &run_svc, (void *) iterations, THR_BOUND | THR_SUSPENDED); // Start executing all the threads
Reference: [2] <author> D. C. Schmidt and P. Stephenson, </author> <title> An Object-Oriented Framework for Developing Network Server Daemons, </title> <booktitle> in Proceed ings of the 2 nd C++ World Conference, </booktitle> <address> (Dallas, Texas), SIGS, </address> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: This article focuses on the steps involved in generalizing from existing code by using templates and overloading to transparently parameterize synchronization mechanisms into a concurrent application. Some of the infrastructure code is based on components in the freely available ADAPTIVE Service eXecutive (ASX) framework described in <ref> [1, 2, 3, 4, 5] </ref>. 2 Motivation The following C++ code illustrates part of the main event-loop of a typical distributed application (such as an object location broker [6] or a multi-threaded network file server): Example 1 typedef unsigned long COUNTER; COUNTER request_count; // At file scope void * run_svc (void <p> for (int i = 0; i &lt; iterations; i++) 1 request_count++; // Count # of requests return t.exit ((void *) i); - main (int argc, char *argv []) - int n_threads = argc &gt; 1 ? atoi (argv [1]) : 4; int n_iterations = argc &gt; 2 ? atoi (argv <ref> [2] </ref>) : 1000000; // Divide iterations evenly among threads int iterations = n_iterations / n_threads; // Spawn off N threads to run in parallel thr_manager.spawn_n (n_threads, &run_svc, (void *) iterations, THR_BOUND | THR_SUSPENDED); // Start executing all the threads together thr_manager.resume_all (); // Wait for all the threads to exit thr_manager.wait
Reference: [3] <author> D. C. Schmidt, </author> <title> The Reactor: An Object-Oriented Interface for Event-Driven UNIX I/O Multiplexing (Part 1 of 2), </title> <journal> C++ Report, </journal> <volume> vol. 5, </volume> <month> February </month> <year> 1993. </year>
Reference-contexts: This article focuses on the steps involved in generalizing from existing code by using templates and overloading to transparently parameterize synchronization mechanisms into a concurrent application. Some of the infrastructure code is based on components in the freely available ADAPTIVE Service eXecutive (ASX) framework described in <ref> [1, 2, 3, 4, 5] </ref>. 2 Motivation The following C++ code illustrates part of the main event-loop of a typical distributed application (such as an object location broker [6] or a multi-threaded network file server): Example 1 typedef unsigned long COUNTER; COUNTER request_count; // At file scope void * run_svc (void <p> For example, if an Atomic Op counter is called by multiple nested function calls within the same thread, a recursive mutex will prevent deadlock from occurring. Recursive mutexes are particularly useful for callback-driven C++ frameworks <ref> [11, 3, 4] </ref>, where the framework event-loop performs a callback to arbitrary user-defined code. Since the user-defined code may subsequently re-enter framework code via a method entry point, recursive mutexes may be necessary to prevent deadlock from occurring on locks held within the framework during the callback.
Reference: [4] <author> D. C. Schmidt, </author> <title> The Object-Oriented Design and Implementation of the Reactor: A C++ Wrapper for UNIX I/O Multiplexing (Part 2 of 2), </title> <journal> C++ Report, </journal> <volume> vol. 5, </volume> <month> September </month> <year> 1993. </year>
Reference-contexts: This article focuses on the steps involved in generalizing from existing code by using templates and overloading to transparently parameterize synchronization mechanisms into a concurrent application. Some of the infrastructure code is based on components in the freely available ADAPTIVE Service eXecutive (ASX) framework described in <ref> [1, 2, 3, 4, 5] </ref>. 2 Motivation The following C++ code illustrates part of the main event-loop of a typical distributed application (such as an object location broker [6] or a multi-threaded network file server): Example 1 typedef unsigned long COUNTER; COUNTER request_count; // At file scope void * run_svc (void <p> For example, if an Atomic Op counter is called by multiple nested function calls within the same thread, a recursive mutex will prevent deadlock from occurring. Recursive mutexes are particularly useful for callback-driven C++ frameworks <ref> [11, 3, 4] </ref>, where the framework event-loop performs a callback to arbitrary user-defined code. Since the user-defined code may subsequently re-enter framework code via a method entry point, recursive mutexes may be necessary to prevent deadlock from occurring on locks held within the framework during the callback.
Reference: [5] <author> D. C. Schmidt, </author> <title> IPC SAP: An Object-Oriented Interface to Interprocess Communication Services, </title> <journal> C++ Report, </journal> <volume> vol. 4, </volume> <month> November/December </month> <year> 1992. </year>
Reference-contexts: This article focuses on the steps involved in generalizing from existing code by using templates and overloading to transparently parameterize synchronization mechanisms into a concurrent application. Some of the infrastructure code is based on components in the freely available ADAPTIVE Service eXecutive (ASX) framework described in <ref> [1, 2, 3, 4, 5] </ref>. 2 Motivation The following C++ code illustrates part of the main event-loop of a typical distributed application (such as an object location broker [6] or a multi-threaded network file server): Example 1 typedef unsigned long COUNTER; COUNTER request_count; // At file scope void * run_svc (void
Reference: [6] <author> Object Management Group, </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <editor> 1.2 ed., </editor> <year> 1993. </year>
Reference-contexts: Some of the infrastructure code is based on components in the freely available ADAPTIVE Service eXecutive (ASX) framework described in [1, 2, 3, 4, 5]. 2 Motivation The following C++ code illustrates part of the main event-loop of a typical distributed application (such as an object location broker <ref> [6] </ref> or a multi-threaded network file server): Example 1 typedef unsigned long COUNTER; COUNTER request_count; // At file scope void * run_svc (void *) - Message_Block *mb; while (get_next_request (mb) &gt; 0) - // Keep track of number of requests request_count++; // Identify request and // perform service processing here... -
Reference: [7] <author> J. Eykholt, S. Kleiman, S. Barton, R. Faulkner, A. Shivalin-giah, M. Smith, D. Stein, J. Voll, M. Weeks, and D. Williams, </author> <title> Beyond Multiprocessing... Multithreading the SunOS Kernel, </title> <booktitle> in Proceedings of the Summer USENIX Conference, </booktitle> <address> (San Antonio, Texas), </address> <month> June </month> <year> 1992. </year>
Reference-contexts: The remainder of this Section illustrates this phenomenon by executing the following C++ code example on a shared memory multi-processor running the SunOS 5.x operating system. SunOS 5.x is a version of UNIX that allows multiple threads of control to execute in parallel on a shared memory multi-processor <ref> [7] </ref>.
Reference: [8] <author> A. D. Birrell, </author> <title> An Introduction to Programming with Threads, </title> <type> Tech. Rep. </type> <institution> SRC-035, Digital Equipment Corporation, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: A common technique for enforcing a strong sequential order on a total store order or partial store order shared memory multi-processor is to protect the increment of the request count variable by using some type of synchronization mechanism, such as a mutex (short for mutual exclusion) <ref> [8] </ref>. Mutexes are used to protect the integrity of a shared resource that may be accessed concurrently by multiple threads of control. A mutex serializes the execution of multiple threads by defining a critical section where only one thread executes its code at a time.
Reference: [9] <author> H. Custer, </author> <title> Inside Windows NT. </title> <address> Redmond, Washington: </address> <publisher> Mi-crosoft Press, </publisher> <year> 1993. </year>
Reference-contexts: For example, the following code is an implementation of the Mutex class interface based on mechanisms in the Windows NT WIN32 API <ref> [9] </ref>: class Mutex - public: Mutex (void) - InitializeCriticalSection (&this-&gt;lock); - Mutex (void) - DeleteCriticalSection (&this-&gt;lock); - int acquire (void) - EnterCriticalSection (&this-&gt;lock); return 0; - int release (void) - LeaveCriticalSection (&this-&gt;lock); return 0; - private: // Win32 serialization mechanism CRITICAL_SECTION lock; -; The use of the Mutex C++ wrapper class
Reference: [10] <author> G. Booch and M. Vilot, </author> <title> Simplifying the Booch Components, </title> <journal> C++ Report, </journal> <volume> vol. 5, </volume> <month> June </month> <year> 1993. </year>
Reference-contexts: It employs a C++ idiom (described in <ref> [10] </ref>) that uses the constructor of a Guard class to acquire the lock on the Mutex object automatically when an object of the class is created. Likewise, the Guard class destructor auto matically unlocks the Mutex object when the object goes out of scope.
Reference: [11] <author> M. A. Linton and P. R. Calder, </author> <booktitle> The Design and Implementation of InterViews, in Proceedings of the USENIX C++ Workshop, </booktitle> <month> November </month> <year> 1987. </year> <month> 9 </month>
Reference-contexts: For example, if an Atomic Op counter is called by multiple nested function calls within the same thread, a recursive mutex will prevent deadlock from occurring. Recursive mutexes are particularly useful for callback-driven C++ frameworks <ref> [11, 3, 4] </ref>, where the framework event-loop performs a callback to arbitrary user-defined code. Since the user-defined code may subsequently re-enter framework code via a method entry point, recursive mutexes may be necessary to prevent deadlock from occurring on locks held within the framework during the callback.
Reference: [12] <author> D. C. Schmidt, </author> <title> The ADAPTIVE Communication Environ--ment: An Object-Oriented Network Programming Toolkit for Developing Communication Software, </title> <booktitle> in Proceedings of the 12 th Annual Sun Users Group Conference, </booktitle> <address> (San Jose, CA), </address> <pages> pp. 214-225, </pages> <address> SUG, </address> <month> Dec. </month> <year> 1993. </year> <month> 10 </month>
Reference-contexts: The Atomic Op class and Mutex-related classes are some of the components available in the ADAPTIVE Communication Environment (ACE), which is a freely available object-oriented toolkit designed to simplify the development of distributed applications on shared memory multi-processor platforms <ref> [12] </ref>. ACE may be obtained via anonymous ftp from ics.uci.edu in the file gnu/C++ wrappers.tar.Z and gnu/C++ wrappers doc.tar.Z. This distribution contains complete source code and documentation for the C++ components and examples described in this article.
References-found: 12

