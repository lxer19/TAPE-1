URL: http://www.eecs.umich.edu/Rio/papers/vista.ps
Refering-URL: http://www.eecs.umich.edu/Rio/papers.html
Root-URL: http://www.eecs.umich.edu
Abstract: 1 Abstract: Transactions and recoverable memories are powerful mechanisms for handling failures and manipulating persistent data. Unfortunately, standard recoverable memories incur an overhead of several milliseconds per transaction. This paper presents a system that improves transaction overhead by a factor of 2000 for working sets that fit in main memory. Of this factor of 2000, a factor of 20 is due to the Rio file cache, which absorbs synchronous writes to disk without losing data during system crashes. The remaining factor of 100 is due to Vista, a 720-line, recoverable-memory library tailored for Rio. Vista lowers transaction overhead to 5 msec by using no redo log, no system calls, and only one memory-to-memory copy. This drastic reduction in overhead leads to a overall speedup of 150-556x for benchmarks based on TPC-B and TPC-C. 
Abstract-found: 1
Intro-found: 1
Reference: [Anderson91] <author> Thomas E. Anderson, Henry M. Levy, Brian N. Bershad, and Edward D. Lazows-ka. </author> <title> The Interaction of Architecture and Operating System Design. </title> <booktitle> In Proceedings of the 1991 International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IV), </booktitle> <pages> pages 108120, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: We expect Vista performance to scale well with faster computers because its transactions use no disk I/Os, no system calls, and only one memory-to-memory copy factors that have been identified repeatedly as bottlenecks to scaling <ref> [Ousterhout90, Anderson91, Rosenblum95] </ref>. 2. Related Work Out of the vast literature on transaction processing, Vista is related most closely to RVM and a number of persistent stores. RVM is an important, widely referenced, user-level library that provides recoverable memory [Satyanarayanan93]. <p> RVM-Rio is slower than Vista because of the extra copies and system calls, while RVM is slower than Vista primarily because of synchronous disk I/Os. Many studies indicate that memory-to-memory copies, system calls, and disk I/Os will scale more slowly than clock speed <ref> [Ousterhout90, Anderson91, Rosenblum95] </ref>. 6. Uses for Vista Rio and Vista provide a very useful set of services: free persistent memory and nearly free transactions.
Reference: [APC96] <institution> The Power Protection Handbook. </institution> <type> Technical report, </type> <note> American Power Conversion, </note> <year> 1996. </year>
Reference-contexts: Rio seeks to protect this area of memory from its two common modes of failure: power loss and system crashes [Chen96]. While systems can protect against power loss in a straightforward manner (by using a $100 UPS, for example <ref> [APC96] </ref>), software errors are trickier. Rio uses virtual memory protection to prevent operating system errors such as wild stores from corrupting the file cache during a system crash. This protection does not significantly affect performance.
Reference: [Atkinson83] <author> Malcolm Atkinson, Ken Chisholm, Paul Cockshott, and Richard Marshall. </author> <title> Algorithms for a Persistent Heap. </title> <journal> Software Practice and Experience, </journal> <volume> 13(3):259271, </volume> <month> March </month> <year> 1983. </year>
Reference-contexts: Recoverable memory provides atomic updates and persistence for a region of virtual memory [Satyanarayanan93]. Recoverable memory allows programs to manipulate permanent data structures safely in their native, in-memory formprograms need not convert between persistent and non-persistent formats <ref> [Atkinson83] </ref>. Unfortunately, while transactions are useful in both kernel and application programming, their high overhead prevents them from being used ubiquitously to manipulate all persistent data. Committing a transaction has traditionally required at least one synchronous disk I/O. <p> Persistent heaps provide functionality similar to traditional file systems but have some unique advantages and disadvantages. Persistent heaps may be more exible than file systems, because programs can manipulate permanent data structures in their native formprograms need not convert between persistent and non-persistent formats <ref> [Atkinson83] </ref>. For example, programs can store native memory pointers in the persistent heap, as long as the system maps the heap in a fixed location. With the increased exibility of heaps comes increased danger, however.
Reference: [Bensoussan72] <editor> A. Bensoussan, C.T. Clingen, and R.C. Da-ley. </editor> <title> The Multics Virtual Memory: Concepts and Design. </title> <journal> Communications of the ACM, </journal> <volume> 15(5):308318, </volume> <month> May </month> <year> 1972. </year>
Reference-contexts: Log truncation adds at least one additional copy for each modified datum in the log. Persistent stores such as IBM 801 Storage [Chang88] and ObjectStore [Lamb91] provide a single-level storage interface to permanent data <ref> [Bensoussan72] </ref>. Like RVM, most persistent stores write data to a redo log to avoid forcing pages to the database for each transaction. RVM and persistent stores build and maintain an applications address space differently.
Reference: [Chang88] <author> Albert Chang and Mark F. Mergen. </author> <title> 801 Storage: Architecture and Programming. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1):2850, </volume> <month> February </month> <year> 1988. </year>
Reference-contexts: RVM performs two copies during the transaction: one to an in-memory undo log and one to an on-disk redo log. Log truncation adds at least one additional copy for each modified datum in the log. Persistent stores such as IBM 801 Storage <ref> [Chang88] </ref> and ObjectStore [Lamb91] provide a single-level storage interface to permanent data [Bensoussan72]. Like RVM, most persistent stores write data to a redo log to avoid forcing pages to the database for each transaction. RVM and persistent stores build and maintain an applications address space differently.
Reference: [Chen96] <author> Peter M. Chen, Wee Teck Ng, Subhachan-dra Chandra, Christopher M. Aycock, Gu-rushankar Rajamani, and David Lowell. </author> <title> The Rio File Cache: Surviving Operating System Crashes. </title> <booktitle> In Proceedings of the 1996 International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS), </booktitle> <pages> pages 7483, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: We believe the resulting 5 msec overhead makes transactions cheap enough that applications and kernels can use them to manipulate all persistent data. Two components, Rio and Vista, combine to enable this remarkable speedup. The Rio file cache is an area of main memory that survives operating system crashes <ref> [Chen96] </ref>. Combined with an uninterruptible power supply, Rio provides persistent memory to applications that can be used as a safe, in-memory buffer for file system data. Existing recoverable-memory libraries such as RVM [Satyanarayanan93] can run unchanged on Rio and gain a 20-fold increase in performance. <p> The Rio File Cache Like most file caches, Rio buffers file data in main memory to accelerate future accesses. Rio seeks to protect this area of memory from its two common modes of failure: power loss and system crashes <ref> [Chen96] </ref>. While systems can protect against power loss in a straightforward manner (by using a $100 UPS, for example [APC96]), software errors are trickier. Rio uses virtual memory protection to prevent operating system errors such as wild stores from corrupting the file cache during a system crash. <p> While other systems, such as Machs Unix server [Golub90], have mapped files into the application address space, we are aware of only two papers that quantify the increased risk <ref> [Chen96, Ng97] </ref>. Both papers indicate that (1) the risk of corruption increases only marginally when mapping persistent data into the address space and (2) memory protection can be used to further reduce this risk to below that of using a write interface. <p> The first study was done on the Rio file cache and is discussed earlier in this section. The second study compares the reliability of mmap and write in the Postgres database and finds little difference. Users can enhance reliability by applying virtual memory techniques to their address space <ref> [Sullivan91, Chen96] </ref>. They can also use transactions to reduce the risk of corrupting permanent data structures in the event of a crash. 4. The Vista Recoverable Memory The Rio file cache automatically intercepts writes that would otherwise need to be propagated synchronously to disk.
Reference: [DeWitt84] <author> D. J. DeWitt, R. H. Katz, F. Olken, L. D. Shapiro, M. R. Stonebraker, and D. Wood. </author> <title> Implementation Techniques for Main Memory Database Systems. </title> <booktitle> In Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 18, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: The result is two copies of the database: one in the processs address space and another in the Rio file cache. Most transaction processing systems amortize the redo log I/O across multiple concurrent transactions, a technique known as group commit <ref> [DeWitt84] </ref>. Systems that perform this optimization wait for a number of committing transactions to accumulate, then synchronously write to disk all commit records for this group in one I/O. We implement a simple form of group commit in RVM to measure how much it improves performance.
Reference: [GM92] <author> Hector Garcia-Molina and Kenneth Salem. </author> <title> Main Memory Database Systems: An Overview. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 4(6):509516, </volume> <month> De-cember </month> <year> 1992. </year>
Reference-contexts: Users are still responsible for their own errors and can corrupt their file data through erroneous write calls or store instructions. Because store instructions are much more common than calls to write, applications may damage the file cache more easily using mmap <ref> [GM92] </ref>. While other systems, such as Machs Unix server [Golub90], have mapped files into the application address space, we are aware of only two papers that quantify the increased risk [Chen96, Ng97].
Reference: [Golub90] <author> David Golub, Randall Dean, Allessandro 10 Forin, and Richard Rashid. </author> <title> Unix as an Application Program. </title> <booktitle> In Proceedings of the 1990 USENIX Summer Conference, </booktitle> <year> 1990. </year>
Reference-contexts: Because store instructions are much more common than calls to write, applications may damage the file cache more easily using mmap [GM92]. While other systems, such as Machs Unix server <ref> [Golub90] </ref>, have mapped files into the application address space, we are aware of only two papers that quantify the increased risk [Chen96, Ng97].
Reference: [Gray78] <author> J. N. Gray. </author> <title> Operating Systems: An Advanced Course. </title> <publisher> Springer-Verlag, </publisher> <year> 1978. </year> <booktitle> Notes on Database Operating Systems. </booktitle>
Reference-contexts: We are exploring a number of ways to take advantage of Vistas fast persistence and atomicity: Participants in two-phase commit <ref> [Gray78] </ref> can store commit records in Vista rather than on disk to accelerate an important technique for reliable, distributed comput ing. Fault-tolerant applications can buffer network messages in Vista, then atomically send these message as part of a local transaction.
Reference: [Gray93] <author> Jim Gray and Andreas Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1993. </year>
Reference-contexts: 1. Introduction Any application that modifies a file takes a riska crash during a series of updates can irreparably damage permanent data. Grouping a series of updates into an atomic transaction addresses this problem by ensuring that either all the updates are applied, or none are <ref> [Gray93] </ref>. Transactions are acclaimed widely as a powerful mechanism for handling failures. Transactions simplify programming by restricting the variety of states in which a crash can leave a system. Recoverable memory provides atomic updates and persistence for a region of virtual memory [Satyanarayanan93].
Reference: [Haerder83] <author> Theo Haerder and Andreas Reuter. </author> <title> Principles of Transaction-Oriented Database Recovery. </title> <journal> ACM Computing Surveys, </journal> <volume> 15(4):287317, </volume> <month> December </month> <year> 1983. </year>
Reference-contexts: Writing to the redo log in this manner is known as a no-force policy, because dirty database pages need not be forced synchronously to disk for every transaction <ref> [Haerder83] </ref>. This policy is used by nearly all transaction systems. Note from Figure 1 that RVM performs up to three copy operations for each transaction. RVM performs two copies during the transaction: one to an in-memory undo log and one to an on-disk redo log. <p> This enables Vista to eliminate the redo log and log truncation. Satyanarayanan, et al. report that the log truncation was the most difficult part of RVM to implement, so eliminating the redo log reduces com plexity significantly [Satyanarayanan93]. Recovery is simplified considerably without a redo log <ref> [Haerder83] </ref>. Checkpointing and recovery code are often extremely complex parts of transaction systems. In contrast, Vista does not need to checkpoint, and its recovery code is fewer than 20 lines. High-performance transaction-processing systems use optimizations such as group commit to amortize disk I/Os across multiple transactions.
Reference: [Lamb91] <author> Charles Lamb, Gordon Landis, Jack Oren-stein, and Dan Weinreb. </author> <title> The ObjectStore Database System. </title> <journal> Communications of the ACM, </journal> <volume> 34(10):5063, </volume> <month> October </month> <year> 1991. </year>
Reference-contexts: RVM performs two copies during the transaction: one to an in-memory undo log and one to an on-disk redo log. Log truncation adds at least one additional copy for each modified datum in the log. Persistent stores such as IBM 801 Storage [Chang88] and ObjectStore <ref> [Lamb91] </ref> provide a single-level storage interface to permanent data [Bensoussan72]. Like RVM, most persistent stores write data to a redo log to avoid forcing pages to the database for each transaction. RVM and persistent stores build and maintain an applications address space differently. <p> We insert these calls by hand, but they could also be inserted by a compiler [OToole93]. Vista also has an option to automatically generate the range of modifications on a page granularity by using the virtual memory system <ref> [Lamb91] </ref>; however this is much slower than calling vista_set_range explicitly. Vista saves a before-image of the data to be modified in an undo log. Like the main database, the undo log resides in mapped persistent memory provided by Rio.
Reference: [Lampson83] <author> Butler W. Lampson. </author> <title> Hints for Computer System Design. </title> <booktitle> In Proceedings of the 1983 Symposium on Operating System Principles, </booktitle> <pages> pages 3348, </pages> <year> 1983. </year>
Reference-contexts: RVM provides a simple, lightweight layer that handles atomicity and persistence. To keep the library simple and lightweight, the designers of RVM did not support other transactional properties, such as serializ-ability and nesting, arguing that these could be better pro vided as independent layers on top of RVM <ref> [Lampson83] </ref>. Free Transactions with Rio Vista David E. Lowell and Peter M. Chen Computer Science and Engineering Division Department of Electrical Engineering and Computer Science University of Michigan -dlowell,pmchen-@eecs.umich.edu http://www.eecs.umich.edu/Rio This research was supported in part by NSF grant MIP-9521386, Digital Equipment Corporation, and the University of Michigan.
Reference: [Ng97] <author> Wee Teck Ng and Peter M. Chen. </author> <title> Integrating Reliable Memory in Databases. </title> <booktitle> In Proceedings of the 1997 International Conference on Very Large Data Bases (VLDB), </booktitle> <month> August </month> <year> 1997. </year>
Reference-contexts: While other systems, such as Machs Unix server [Golub90], have mapped files into the application address space, we are aware of only two papers that quantify the increased risk <ref> [Chen96, Ng97] </ref>. Both papers indicate that (1) the risk of corruption increases only marginally when mapping persistent data into the address space and (2) memory protection can be used to further reduce this risk to below that of using a write interface.
Reference: [OToole93] <author> James OToole, Scott Nettles, and David Gifford. </author> <title> Concurrent Compacting Garbage Collection of a Persistent Heap. </title> <booktitle> In Proceedings of the 1993 Symposium on Operating Systems Principles, </booktitle> <pages> pages 161174, </pages> <month> Decem-ber </month> <year> 1993. </year>
Reference-contexts: As with RVM, applications call vista_set_range to declare which area of memory a transaction will modify. We insert these calls by hand, but they could also be inserted by a compiler <ref> [OToole93] </ref>. Vista also has an option to automatically generate the range of modifications on a page granularity by using the virtual memory system [Lamb91]; however this is much slower than calling vista_set_range explicitly. Vista saves a before-image of the data to be modified in an undo log.
Reference: [Ousterhout90] <author> John K. Ousterhout. </author> <title> Why arent operating systems getting faster as fast as hardware? In Proceedings USENIX Summer Conference, </title> <booktitle> pages 247256, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: We expect Vista performance to scale well with faster computers because its transactions use no disk I/Os, no system calls, and only one memory-to-memory copy factors that have been identified repeatedly as bottlenecks to scaling <ref> [Ousterhout90, Anderson91, Rosenblum95] </ref>. 2. Related Work Out of the vast literature on transaction processing, Vista is related most closely to RVM and a number of persistent stores. RVM is an important, widely referenced, user-level library that provides recoverable memory [Satyanarayanan93]. <p> RVM-Rio is slower than Vista because of the extra copies and system calls, while RVM is slower than Vista primarily because of synchronous disk I/Os. Many studies indicate that memory-to-memory copies, system calls, and disk I/Os will scale more slowly than clock speed <ref> [Ousterhout90, Anderson91, Rosenblum95] </ref>. 6. Uses for Vista Rio and Vista provide a very useful set of services: free persistent memory and nearly free transactions.
Reference: [Rosenblum95] <author> Mendel Rosenblum, Edouard Bugnion, Stephen Alan Herrod, Emmett Witchel, and Anoop Gupta. </author> <title> The Impact of Architectural Trends on Operating System Performance. </title> <booktitle> In Proceedings of the 1995 Symposium on Operating Systems Principles, </booktitle> <pages> pages 285 298, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: We expect Vista performance to scale well with faster computers because its transactions use no disk I/Os, no system calls, and only one memory-to-memory copy factors that have been identified repeatedly as bottlenecks to scaling <ref> [Ousterhout90, Anderson91, Rosenblum95] </ref>. 2. Related Work Out of the vast literature on transaction processing, Vista is related most closely to RVM and a number of persistent stores. RVM is an important, widely referenced, user-level library that provides recoverable memory [Satyanarayanan93]. <p> RVM-Rio is slower than Vista because of the extra copies and system calls, while RVM is slower than Vista primarily because of synchronous disk I/Os. Many studies indicate that memory-to-memory copies, system calls, and disk I/Os will scale more slowly than clock speed <ref> [Ousterhout90, Anderson91, Rosenblum95] </ref>. 6. Uses for Vista Rio and Vista provide a very useful set of services: free persistent memory and nearly free transactions.
Reference: [Satyanarayanan93] <author> M. Satyanarayanan, Henry H. Mash-burn, Puneet Kumar, David C. Steere, and James J. Kistler. </author> <title> Lightweight Recoverable Virtual Memory. </title> <booktitle> In Proceedings of the 1993 Symposium on Operating System Principles, </booktitle> <pages> pages 146160, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Transactions are acclaimed widely as a powerful mechanism for handling failures. Transactions simplify programming by restricting the variety of states in which a crash can leave a system. Recoverable memory provides atomic updates and persistence for a region of virtual memory <ref> [Satyanarayanan93] </ref>. Recoverable memory allows programs to manipulate permanent data structures safely in their native, in-memory formprograms need not convert between persistent and non-persistent formats [Atkinson83]. Unfortunately, while transactions are useful in both kernel and application programming, their high overhead prevents them from being used ubiquitously to manipulate all persistent data. <p> The Rio file cache is an area of main memory that survives operating system crashes [Chen96]. Combined with an uninterruptible power supply, Rio provides persistent memory to applications that can be used as a safe, in-memory buffer for file system data. Existing recoverable-memory libraries such as RVM <ref> [Satyanarayanan93] </ref> can run unchanged on Rio and gain a 20-fold increase in performance. Vista is a user-level, recoverable-memory library tailored to run on Rio. Because Vista assumes its memory is persistent, its logging and recovery mechanisms are fast and simple. <p> Related Work Out of the vast literature on transaction processing, Vista is related most closely to RVM and a number of persistent stores. RVM is an important, widely referenced, user-level library that provides recoverable memory <ref> [Satyanarayanan93] </ref>. RVM provides a simple, lightweight layer that handles atomicity and persistence. To keep the library simple and lightweight, the designers of RVM did not support other transactional properties, such as serializ-ability and nesting, arguing that these could be better pro vided as independent layers on top of RVM [Lampson83]. <p> This enables Vista to eliminate the redo log and log truncation. Satyanarayanan, et al. report that the log truncation was the most difficult part of RVM to implement, so eliminating the redo log reduces com plexity significantly <ref> [Satyanarayanan93] </ref>. Recovery is simplified considerably without a redo log [Haerder83]. Checkpointing and recovery code are often extremely complex parts of transaction systems. In contrast, Vista does not need to checkpoint, and its recovery code is fewer than 20 lines.
Reference: [Sullivan91] <author> M. Sullivan and M. Stonebraker. </author> <title> Using write protected data structures to improve software fault tolerance in highly available database management systems. </title> <booktitle> In Proceedings of the 1991 International Conference on Very Large Data Bases (VLDB), </booktitle> <pages> pages 171180, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: The first study was done on the Rio file cache and is discussed earlier in this section. The second study compares the reliability of mmap and write in the Postgres database and finds little difference. Users can enhance reliability by applying virtual memory techniques to their address space <ref> [Sullivan91, Chen96] </ref>. They can also use transactions to reduce the risk of corrupting permanent data structures in the event of a crash. 4. The Vista Recoverable Memory The Rio file cache automatically intercepts writes that would otherwise need to be propagated synchronously to disk.
Reference: [TPC90] <editor> TPC Benchmark B Standard Specification. </editor> <title> Technical report, Transaction Processing Performance Council, </title> <month> August </month> <year> 1990. </year>
Reference-contexts: Overhead per transaction is defined as the time per transaction of a given system minus the time per transaction of a system that does not provide atomic durability. Time per transaction is the running time divided by the number of transactions. TPC-B processes banking transactions <ref> [TPC90] </ref>. The database consists of a number of branches, tellers, and accounts. The accounts comprise over 99% of the database. Each transaction updates the balance in a random account and the balances in the corresponding branch and teller. Each transaction also appends a history record to an audit trail.
Reference: [TPC96] <editor> TPC Benchmark C Standard Specification, </editor> <title> Revision 3.2. </title> <type> Technical report, </type> <institution> Transaction Processing Performance Council, </institution> <month> August </month> <year> 1996. </year>
Reference-contexts: We limit the size of the audit trail to 2 MB to keep it in memory and better match our target applications. TPC-C models the activities of a wholesale supplier who receives orders, payments, and deliveries for items <ref> [TPC96] </ref>. The database consists of a number of warehouses, districts, customers, orders, and items. Our variant of the benchmark, which we call order-entry, uses three of the five transaction types specified in TPC-C: new-order, payment, and delivery.
Reference: [Wahbe93] <author> Robert Wahbe, Steven Lucco, Thomas E. Anderson, and Susan L. Graham. </author> <title> Efficient Software-Based Fault Isolation. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 203216, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: This is similar to the technique used in anonymous RPC [Yarvin93]. Other approaches to protecting the meta-data could also be used, such as software fault isolation and virtual memory protection <ref> [Wahbe93] </ref>. 5. Performance Evaluation Vistas main goal is to drastically lower the overhead of atomic, durable transactions. In order to evaluate how well Vista achieves this goal, we compare the performance of three systems: Vista, RVM, and RVM-Rio (RVM running on a Rio file system).
Reference: [Yarvin93] <author> Curtis Yarvin, Richard Bukowski, and Tho-mas Anderson. Anonymous RPC: </author> <title> Low Latency Protection in a 64-Bit Address Space. </title> <booktitle> In Proceedings of the Summer 1993 US-ENIX Conference, </booktitle> <year> 1993. </year>
Reference-contexts: Vista reduces the risk of inadvertent corruption by mapping each segments metadata into an isolated range of addresses (Figure 4). This is similar to the technique used in anonymous RPC <ref> [Yarvin93] </ref>. Other approaches to protecting the meta-data could also be used, such as software fault isolation and virtual memory protection [Wahbe93]. 5. Performance Evaluation Vistas main goal is to drastically lower the overhead of atomic, durable transactions.
References-found: 24

