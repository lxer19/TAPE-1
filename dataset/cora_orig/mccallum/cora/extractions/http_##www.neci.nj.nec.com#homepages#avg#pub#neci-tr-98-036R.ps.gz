URL: http://www.neci.nj.nec.com/homepages/avg/pub/neci-tr-98-036R.ps.gz
Refering-URL: http://www.neci.nj.nec.com/homepages/avg/webpub/node5.html
Root-URL: 
Email: cher@cher.msk.su  [avg,pmartin]@research.nj.nec.com  [setubal,stolfi]@dcc.unicamp.br  
Title: Augment or Push? A computational study of Bipartite Matching and Unit Capacity Flow Algorithms  
Author: Boris V. Cherkassky Andrew V. Goldberg Paul Martin Jo~ao C. Setubal Jorge Stolfi 
Date: 1998  
Note: March  Research was supported in part by CNPq (Brazilian Research Agency) grant number 301016/92-5  
Address: Krasikova St. 32, 117418, Moscow, Russia  4 Independence Way, Princeton, NJ 08540  SP 13083-970, Brazil  
Affiliation: Central Institute for Economics and Mathematics  NEC Research Institute  Institute of Computing, CP6176 University of Campinas, Campinas,  
Abstract: Technical report #98-036R NEC Research Institute, Inc. This TR is a revision of the TR #97-127. The original TR was based on implementations written in different languages, different style, and using somewhat different low-level data structures. After learning that in some cases this results in a non-trivial performance difference, we rewrote some of the codes. The new codes are written in a uniform way. We also provide more sanity checks and better machine-independent measure of performance with our data. Finally, we expanded some parts of the report. fl Research was supported in part by CNPq (Brazilian Research Agency) grant number 351056/95-5
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. K. Ahuja, T. L. Magnanti, and J. B. Orlin. </author> <title> Network Flows: Theory, Algorithms, </title> <booktitle> and Applica 16 tions. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1993. </year>
Reference-contexts: For the unit capacity case, Goldberg and Kennedy [16] showed that the lowest-level selection rule, in combination with the global relabeling heuristic, is theoretically efficient. We study the highest-level (hi), lowest-level (lo), and first-in, first-out (fifo) variants of the push-relabel method. We also study an augment-relabel algorithm (ar) <ref> [1] </ref> that finds augmenting paths using relabel operations. 2 The main contributions of this work are new insights into the computational performance of the algorithms and new instance generators for the problems considered. Our study includes more algorithms and more problem families than the previous studies. <p> Often, this is a small fraction of the graph size. A simple analysis shows that the dfs and bfs algorithms have complexity O (nm). 3.7 Augment-Relabel The augment-relabel algorithm <ref> [1] </ref> uses depth-first search in combination with the relabel operation to find augmenting paths. For the bipartite matching problem, Alt et al. [3] and Cheriyan and Mehlhorn [6] used a variant of the method in combination with certain word operations to obtain improved bounds for dense graphs. <p> A standard argument shows that the ar algorithm takes O (nm) time. (Note that there are O (n) global relabelings, each taking O (m) time.) As observed in <ref> [3, 1] </ref>, one can obtain better theoretical bounds by processing vertices with distance labels bounded by a parameter less than n and using the shortest augmenting path method to complete the computation.
Reference: [2] <author> R. K. Ahuja, J. B. Orlin, C. Stein, and R. E. Tarjan. </author> <title> Improved Algorithms for Bipartite Network Flow. </title> <journal> SIAM J. Comput., </journal> <volume> 23 </volume> <pages> 906-933, </pages> <year> 1994. </year>
Reference-contexts: For the special case of bipartite matching, we exploit the special structure of the problem in order to make the algorithms more efficient. We replace the push operation with a double-push operation <ref> [2, 17] </ref> where a unit of excess flow is pushed first from a vertex in X to a vertex in Y and then is either pushed to the sink or is pushed to a vertex in X.
Reference: [3] <author> H. Alt, N. Blum, K. Mehlhorn, and M. Paul. </author> <title> Computing a Maximum Cardinality Matching in a Bipartite Graph in time O(n 1:5 p m= log n). </title> <journal> Information Processing Let., </journal> <volume> 37 </volume> <pages> 237-240, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction Maximum unit capacity flow and bipartite matching are two closely related combinatorial problems that have been extensively studied from the point of view of theoretical analysis of algorithms <ref> [21, 22, 23, 13, 3, 6, 14] </ref>. <p> A simple analysis shows that the dfs and bfs algorithms have complexity O (nm). 3.7 Augment-Relabel The augment-relabel algorithm [1] uses depth-first search in combination with the relabel operation to find augmenting paths. For the bipartite matching problem, Alt et al. <ref> [3] </ref> and Cheriyan and Mehlhorn [6] used a variant of the method in combination with certain word operations to obtain improved bounds for dense graphs. <p> A standard argument shows that the ar algorithm takes O (nm) time. (Note that there are O (n) global relabelings, each taking O (m) time.) As observed in <ref> [3, 1] </ref>, one can obtain better theoretical bounds by processing vertices with distance labels bounded by a parameter less than n and using the shortest augmenting path method to complete the computation.
Reference: [4] <author> R. J. Anderson and J. C. Setubal. </author> <title> Goldberg's Algorithm for the Maximum Flow in Perspective: a Computational Study. </title> <editor> In D. S. Johnson and C. C. McGeoch, editors, </editor> <title> Network Flows and Matching: </title> <booktitle> First DIMACS Implementation Challenge, </booktitle> <pages> pages 1-18. </pages> <publisher> AMS, </publisher> <year> 1993. </year>
Reference-contexts: For the maximum flow problem with arbitrary capacities, several studies have shown that the push-relabel method is superior to other known methods in practice <ref> [4, 8, 10, 11, 26] </ref>. Push-relabel algorithms based on the highest-level selection rule appear to be the fastest. For the unit capacity case, Goldberg and Kennedy [16] showed that the lowest-level selection rule, in combination with the global relabeling heuristic, is theoretically efficient. <p> Our flow implementations maintain residual capacities instead of flows, because the algorithms need the capacities, not the flows, for internal operation. 3.3 Global Relabeling The global relabeling heuristic improves computational performance of the push-relabel method (see e.g. <ref> [4, 15, 26] </ref>). This heuristic uses breadth-first search to compute distances to the sink in the residual graph with unit arc lengths; the distance labels are set to these distances. Such a computation takes linear time. If global relabelings are performed too often, they dominate the running time.
Reference: [5] <author> S. F. Chang and S. T. McCormick. </author> <title> A Faster Implementation of a Bipartite Cardinality Matching Algorithm. </title> <type> Technical Report 90-MSC-005, </type> <institution> Faculty of Commerce and Buisiness Administration, University of British Columbia, </institution> <year> 1990. </year>
Reference-contexts: Here n is the number of vertices and m is the number of arcs. In this paper we study computational efficiency of bipartite matching and unit capacity flow algorithms. We are aware of three previous published computational studies of bipartite matching algorithms <ref> [9, 5, 27] </ref> and of no computational studies of unit capacity flow algorithms. Our study includes a refinement of a previous study by Setubal [28], which itself refined the results in [27] but has not been published in journal form. <p> The augmenting path algorithms we study find augmenting paths using depth-first search (dfs), breadth-first search (bfs), and a new label-directed depth-first search (lds). For the bipartite matching problem, Darby-Dowman [9] compared bfs and dfs and found that no implementation performed "consistently better" than the other. Chang and McCormick <ref> [5] </ref> studied different variants of the depth-first search algorithm. Setubal [27] showed that a push-relabel implementation for bipartite matching was significantly faster than an implementation based on Hopcroft-Karp's algorithm [21] (which is similar to Dinitz's maximum flow algorithm [12] applied to the bipartite matching problem). <p> See [16, 24] for more details. 3.5 Depth-First Search This implementation uses depth-first search to find augmenting paths. A search is attempted from each of the source's neighbors. It includes the following heuristics (due to Chang and McCormick <ref> [5] </ref>). The clean-up heuristic deletes all vertices visited during a search if the search fails. The look-ahead heuristic examines all neighbours of a vertex in X when this vertex is visited for the first time during a search. If a neighour is unmatched, the search terminates.
Reference: [6] <author> J. Cheriyan and K. Mehlhorn. </author> <title> Algorithms for dense graphs and networks on the random access computer. </title> <journal> Algorithmica, </journal> <volume> 15 </volume> <pages> 521-549, </pages> <year> 1996. </year>
Reference-contexts: 1 Introduction Maximum unit capacity flow and bipartite matching are two closely related combinatorial problems that have been extensively studied from the point of view of theoretical analysis of algorithms <ref> [21, 22, 23, 13, 3, 6, 14] </ref>. <p> The best bound for the former problem is O (m 1:5 ) [13, 22] and for the latter it is O ( p nm log (n 2 =m)= log n) [14] or, for dense graphs on a RAM with (n)-bit words, O (n 2:5 = log n) <ref> [6] </ref>. Here n is the number of vertices and m is the number of arcs. In this paper we study computational efficiency of bipartite matching and unit capacity flow algorithms. <p> A simple analysis shows that the dfs and bfs algorithms have complexity O (nm). 3.7 Augment-Relabel The augment-relabel algorithm [1] uses depth-first search in combination with the relabel operation to find augmenting paths. For the bipartite matching problem, Alt et al. [3] and Cheriyan and Mehlhorn <ref> [6] </ref> used a variant of the method in combination with certain word operations to obtain improved bounds for dense graphs.
Reference: [7] <author> B. V. Cherkassky. </author> <title> A Fast Algorithm for Computing Maximum Flow in a Network. </title> <editor> In A. V. Karzanov, editor, </editor> <booktitle> Collected Papers, </booktitle> <volume> Vol. 3: </volume> <booktitle> Combinatorial Methods for Flow Problems, </booktitle> <pages> pages 90-96. </pages> <institution> The Institute for Systems Studies, Moscow, </institution> <year> 1979. </year> <title> In Russian. </title> <journal> English translation appears in AMS Trans., </journal> <volume> Vol. 158, </volume> <pages> pp. 23-30, </pages> <year> 1994. </year>
Reference-contexts: However, for fifo we can use a simple queue to determine which vertex to scan next. The bucket data structure used for hi and lo allows us to implement the gap heuristic <ref> [7, 10] </ref> with little additional effort. The gap heuristic takes advantage of the fact that if there are no vertices with label d then we can ignore all vertices with label greater than d, since they cannot reach the sink.
Reference: [8] <author> B. V. Cherkassky and A. V. Goldberg. </author> <title> On Implementing Push-Relabel Method for the Maximum Flow Problem. </title> <type> Technical Report STAN-CS-94-1523, </type> <institution> Department of Computer Science, Stanford University, </institution> <year> 1994. </year>
Reference-contexts: For the maximum flow problem with arbitrary capacities, several studies have shown that the push-relabel method is superior to other known methods in practice <ref> [4, 8, 10, 11, 26] </ref>. Push-relabel algorithms based on the highest-level selection rule appear to be the fastest. For the unit capacity case, Goldberg and Kennedy [16] showed that the lowest-level selection rule, in combination with the global relabeling heuristic, is theoretically efficient.
Reference: [9] <author> K. Darby-Dowman. </author> <title> The Exploration of Sparsity in Large Scale Linear Programming Problems - Data Structures and Restructuring Algorithms. </title> <type> PhD thesis, </type> <institution> Brunel University, </institution> <year> 1980. </year>
Reference-contexts: Here n is the number of vertices and m is the number of arcs. In this paper we study computational efficiency of bipartite matching and unit capacity flow algorithms. We are aware of three previous published computational studies of bipartite matching algorithms <ref> [9, 5, 27] </ref> and of no computational studies of unit capacity flow algorithms. Our study includes a refinement of a previous study by Setubal [28], which itself refined the results in [27] but has not been published in journal form. <p> The algorithms we study include augmenting path algorithms, push-relabel algorithms, and an augment-relabel algorithm. The augmenting path algorithms we study find augmenting paths using depth-first search (dfs), breadth-first search (bfs), and a new label-directed depth-first search (lds). For the bipartite matching problem, Darby-Dowman <ref> [9] </ref> compared bfs and dfs and found that no implementation performed "consistently better" than the other. Chang and McCormick [5] studied different variants of the depth-first search algorithm.
Reference: [10] <author> U. Derigs and W. Meier. </author> <title> Implementing Goldberg's Max-Flow Algorithm | A Computational Investigation. </title> <journal> ZOR | Methods and Models of Operations Research, </journal> <volume> 33 </volume> <pages> 383-403, </pages> <year> 1989. </year>
Reference-contexts: For the maximum flow problem with arbitrary capacities, several studies have shown that the push-relabel method is superior to other known methods in practice <ref> [4, 8, 10, 11, 26] </ref>. Push-relabel algorithms based on the highest-level selection rule appear to be the fastest. For the unit capacity case, Goldberg and Kennedy [16] showed that the lowest-level selection rule, in combination with the global relabeling heuristic, is theoretically efficient. <p> However, for fifo we can use a simple queue to determine which vertex to scan next. The bucket data structure used for hi and lo allows us to implement the gap heuristic <ref> [7, 10] </ref> with little additional effort. The gap heuristic takes advantage of the fact that if there are no vertices with label d then we can ignore all vertices with label greater than d, since they cannot reach the sink.
Reference: [11] <author> U. Derigs and W. Meier. </author> <title> An Evaluation of Algorithmic Refinements and Proper Data-Structures for the Preflow-Push Approach for Maximum Flow. </title> <booktitle> In ASI Series on Computer and System Sciences, </booktitle> <volume> volume 8, </volume> <pages> pages 209-223. NATO, </pages> <year> 1992. </year>
Reference-contexts: For the maximum flow problem with arbitrary capacities, several studies have shown that the push-relabel method is superior to other known methods in practice <ref> [4, 8, 10, 11, 26] </ref>. Push-relabel algorithms based on the highest-level selection rule appear to be the fastest. For the unit capacity case, Goldberg and Kennedy [16] showed that the lowest-level selection rule, in combination with the global relabeling heuristic, is theoretically efficient.
Reference: [12] <author> E. A. Dinic. </author> <title> Algorithm for Solution of a Problem of Maximum Flow in Networks with Power Estimation. </title> <journal> Soviet Math. Dokl., </journal> <volume> 11 </volume> <pages> 1277-1280, </pages> <year> 1970. </year>
Reference-contexts: Chang and McCormick [5] studied different variants of the depth-first search algorithm. Setubal [27] showed that a push-relabel implementation for bipartite matching was significantly faster than an implementation based on Hopcroft-Karp's algorithm [21] (which is similar to Dinitz's maximum flow algorithm <ref> [12] </ref> applied to the bipartite matching problem). For the maximum flow problem with arbitrary capacities, several studies have shown that the push-relabel method is superior to other known methods in practice [4, 8, 10, 11, 26]. Push-relabel algorithms based on the highest-level selection rule appear to be the fastest.
Reference: [13] <author> S. Even and R. E. Tarjan. </author> <title> Network Flow and Testing Graph Connectivity. </title> <journal> SIAM J. Comput., </journal> <volume> 4 </volume> <pages> 507-518, </pages> <year> 1975. </year>
Reference-contexts: 1 Introduction Maximum unit capacity flow and bipartite matching are two closely related combinatorial problems that have been extensively studied from the point of view of theoretical analysis of algorithms <ref> [21, 22, 23, 13, 3, 6, 14] </ref>. <p> 1 Introduction Maximum unit capacity flow and bipartite matching are two closely related combinatorial problems that have been extensively studied from the point of view of theoretical analysis of algorithms [21, 22, 23, 13, 3, 6, 14]. The best bound for the former problem is O (m 1:5 ) <ref> [13, 22] </ref> and for the latter it is O ( p nm log (n 2 =m)= log n) [14] or, for dense graphs on a RAM with (n)-bit words, O (n 2:5 = log n) [6]. Here n is the number of vertices and m is the number of arcs. <p> Augmenting path algorithms work well when the number of augmentations is very small. When the number of augmentations is moderate or large, average time to find a path becomes critical. Results of <ref> [13] </ref> imply that for shortest path augmentation, the total length of augmenting paths is relatively small, especially in the bipartite matching case. If the augmenting paths are always short, breadth-first search tends to examine a small part of the graph for each search and is thus efficient.
Reference: [14] <author> T. Feder and R. Motwani. </author> <title> Clique Partitions, Graph Compression and Speeding-up Algorithms. </title> <booktitle> In Proc. 23rd Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 123-133, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction Maximum unit capacity flow and bipartite matching are two closely related combinatorial problems that have been extensively studied from the point of view of theoretical analysis of algorithms <ref> [21, 22, 23, 13, 3, 6, 14] </ref>. <p> The best bound for the former problem is O (m 1:5 ) [13, 22] and for the latter it is O ( p nm log (n 2 =m)= log n) <ref> [14] </ref> or, for dense graphs on a RAM with (n)-bit words, O (n 2:5 = log n) [6]. Here n is the number of vertices and m is the number of arcs. In this paper we study computational efficiency of bipartite matching and unit capacity flow algorithms.
Reference: [15] <author> A. V. Goldberg. </author> <title> Efficient Graph Algorithms for Sequential and Parallel Computers. </title> <type> PhD thesis, </type> <institution> M.I.T., </institution> <month> January </month> <year> 1987. </year> <note> (Also available as Technical Report TR-374, </note> <institution> Lab. for Computer Science, M.I.T., </institution> <year> 1987). </year>
Reference-contexts: Our flow implementations maintain residual capacities instead of flows, because the algorithms need the capacities, not the flows, for internal operation. 3.3 Global Relabeling The global relabeling heuristic improves computational performance of the push-relabel method (see e.g. <ref> [4, 15, 26] </ref>). This heuristic uses breadth-first search to compute distances to the sink in the residual graph with unit arc lengths; the distance labels are set to these distances. Such a computation takes linear time. If global relabelings are performed too often, they dominate the running time.
Reference: [16] <author> A. V. Goldberg and R. Kennedy. </author> <title> Global Price Updates Help. </title> <journal> SIAM J. Disc. Math., </journal> <volume> 10 </volume> <pages> 551-572, </pages> <year> 1997. </year>
Reference-contexts: Push-relabel algorithms based on the highest-level selection rule appear to be the fastest. For the unit capacity case, Goldberg and Kennedy <ref> [16] </ref> showed that the lowest-level selection rule, in combination with the global relabeling heuristic, is theoretically efficient. We study the highest-level (hi), lowest-level (lo), and first-in, first-out (fifo) variants of the push-relabel method. <p> A theoretically good strategy is to amortize the work of global relabelings over other operations of the algorithm. In particular, one can perform a new global relabeling after the algorithm performed fi (m) work since the last global relabeling <ref> [16] </ref>. Our implementations use a simplified version of this strategy, which seems to work well in practice: We perform a new global relabeling after the number of relabel operations since the last global relabeling is fi (n). 5 All our push-relabel implementations use the global relabeling heuristic. <p> Additionally since each vertex v 2 Y 6 has exactly one arc (v; w) directed out of it the label of v must be the label of w plus one. Therefore we do not need to explicitly represent labels for vertices of Y . See <ref> [16, 24] </ref> for more details. 3.5 Depth-First Search This implementation uses depth-first search to find augmenting paths. A search is attempted from each of the source's neighbors. It includes the following heuristics (due to Chang and McCormick [5]). <p> While residual flow value is large, the lowest-level and the first-in, first-out algorithms work mostly with low-labeled vertices and thus work well. When residual flow value becomes small, the use of global relabeling assures relatively quick termination. (See <ref> [16] </ref> for a theoretical analysis of the lowest-level algorithm.) The highest-level and the augment-relabel algorithms do a significant fraction of their work on vertices with high distance labels and do not perform so well. Another distinctive feature of the push-relabel method is as follows.
Reference: [17] <author> A. V. Goldberg, S. A. Plotkin, and P. M. Vaidya. </author> <title> Sublinear-Time Parallel Algorithms for Matching and Related Problems. </title> <journal> J. Algorithms, </journal> <volume> 14 </volume> <pages> 180-213, </pages> <year> 1993. </year>
Reference-contexts: For the special case of bipartite matching, we exploit the special structure of the problem in order to make the algorithms more efficient. We replace the push operation with a double-push operation <ref> [2, 17] </ref> where a unit of excess flow is pushed first from a vertex in X to a vertex in Y and then is either pushed to the sink or is pushed to a vertex in X.
Reference: [18] <author> A. V. Goldberg and R. E. Tarjan. </author> <title> A New Approach to the Maximum Flow Problem. </title> <booktitle> In Proc. 18th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 136-146, </pages> <year> 1986. </year>
Reference-contexts: When there are no active vertices, all that remains is to return excess flow to the source. We do this by finding a succession of paths and cycles along which we can remove flow <ref> [18] </ref>. In the case of bipartite matching this last step is unnecessary, since the only vertices that may have any excess flow are the source's neighbors. We examine three variants of push-relabel based on three criteria for selecting the active vertex: highest-level (hi), lowest-level (lo), and first-in, first-out (fifo).
Reference: [19] <author> A. V. Goldberg and R. E. Tarjan. </author> <title> A New Approach to the Maximum Flow Problem. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 35 </volume> <pages> 921-940, </pages> <year> 1988. </year>
Reference-contexts: Our augment--relabel and label-directed depth-first search use it as well. In all our tests, we performed a global relabeling after n relabels. 3.4 Push-Relabel We now briefly refine the description of the push-relabel algorithm given above (a full description can be found in <ref> [19] </ref>). The algorithm maintains for each vertex u a nonnegative integer label, which is a lower bound of the distance from u to the sink in the residual graph. The algorithm works by applying the push and relabel operations to active vertices. <p> The algorithm maintains vertex labels that do not have the distance label properties (labels may decrease, whereas in push-relabel or augment-relabel algorithms they never do <ref> [19] </ref>), but are nevertheless estimates on the distances to the sink in the residual graph. The algorithm builds an augmenting path starting from s. Vertices on the path are marked. Let v be the last vertex on the current path.
Reference: [20] <author> D. Goldfarb and M. D. Grigoriadis. </author> <title> A Computational Comparison of the Dinic and Network Simplex Methods for Maximum Flow. </title> <journal> Annals of Oper. Res., </journal> <volume> 13 </volume> <pages> 83-123, </pages> <year> 1988. </year> <month> 17 </month>
Reference-contexts: The karz family was generated by setting a = k 2 , ` = 10 and F = 10 for several values of the parameter k. 4.7 rmfuC, rmfuL, rmfuL The RMFU family is generated by a unit capacity version of the RMF generator due to Goldfarb and Grigoriadis <ref> [20] </ref>. This generator takes parameters a, b, and c. The graphs that it generates have b "frames" in addition to the source and the sink.
Reference: [21] <author> J. E. Hopcroft and R. M. Karp. </author> <title> An n 5=2 Algorithm for Maximum Matching in Bipartite Graphs. </title> <journal> SIAM J. Comput., </journal> <volume> 2 </volume> <pages> 225-231, </pages> <year> 1973. </year>
Reference-contexts: 1 Introduction Maximum unit capacity flow and bipartite matching are two closely related combinatorial problems that have been extensively studied from the point of view of theoretical analysis of algorithms <ref> [21, 22, 23, 13, 3, 6, 14] </ref>. <p> Chang and McCormick [5] studied different variants of the depth-first search algorithm. Setubal [27] showed that a push-relabel implementation for bipartite matching was significantly faster than an implementation based on Hopcroft-Karp's algorithm <ref> [21] </ref> (which is similar to Dinitz's maximum flow algorithm [12] applied to the bipartite matching problem). For the maximum flow problem with arbitrary capacities, several studies have shown that the push-relabel method is superior to other known methods in practice [4, 8, 10, 11, 26].
Reference: [22] <editor> A. V. Karzanov. O nakhozhdenii maksimal'nogo potoka v setyakh spetsial'nogo vida i nekotorykh prilozheniyakh. In Matematicheskie Voprosy Upravleniya Proizvodstvom, </editor> <volume> volume 5. </volume> <publisher> Moscow State University Press, </publisher> <address> Moscow, </address> <year> 1973. </year> <title> In Russian; title translation: On Finding Maximum Flows in Networks with Special Structure and Some Applications. </title>
Reference-contexts: 1 Introduction Maximum unit capacity flow and bipartite matching are two closely related combinatorial problems that have been extensively studied from the point of view of theoretical analysis of algorithms <ref> [21, 22, 23, 13, 3, 6, 14] </ref>. <p> 1 Introduction Maximum unit capacity flow and bipartite matching are two closely related combinatorial problems that have been extensively studied from the point of view of theoretical analysis of algorithms [21, 22, 23, 13, 3, 6, 14]. The best bound for the former problem is O (m 1:5 ) <ref> [13, 22] </ref> and for the latter it is O ( p nm log (n 2 =m)= log n) [14] or, for dense graphs on a RAM with (n)-bit words, O (n 2:5 = log n) [6]. Here n is the number of vertices and m is the number of arcs. <p> In our experiments we set d = 6 10 and the greedy matching paired between 62 and 69% of the vertices, while the maximum paired about 5% more vertices. 4.6 Karz The karz family of unit capacity flow problems is inspired by the worst-case problem family developed by Karzanov <ref> [22] </ref> for a bipartite matching algorithm. The family takes parameters k, a, `, F . The vertices of a generated graph are partitioned into several groups: the source s, the sink t, S, X, Y , and P .
Reference: [23] <editor> A. V. Karzanov. Tochnaya otzenka algoritma nakhojdeniya maksimalnogo potoka, primenennogo k zadache "o predstavitelyakh". </editor> <booktitle> In Problems in Cibernetics, </booktitle> <volume> volume 5, </volume> <pages> pages 66-70. </pages> <publisher> Nauka, </publisher> <address> Moscow, </address> <year> 1973. </year> <title> In Russian; title translation: The exact time bound for a maximum flow algorithm applied to the set representatives problem. </title>
Reference-contexts: 1 Introduction Maximum unit capacity flow and bipartite matching are two closely related combinatorial problems that have been extensively studied from the point of view of theoretical analysis of algorithms <ref> [21, 22, 23, 13, 3, 6, 14] </ref>.
Reference: [24] <author> R. Kennedy. </author> <title> Solving Unweighted and Weighted Bipartite Matching Problems. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1995. </year>
Reference-contexts: Additionally since each vertex v 2 Y 6 has exactly one arc (v; w) directed out of it the label of v must be the label of w plus one. Therefore we do not need to explicitly represent labels for vertices of Y . See <ref> [16, 24] </ref> for more details. 3.5 Depth-First Search This implementation uses depth-first search to find augmenting paths. A search is attempted from each of the source's neighbors. It includes the following heuristics (due to Chang and McCormick [5]). <p> This generator creates a graph with a unique perfect matching and has been motivated by a generator of Kennedy <ref> [24] </ref>. 9 Let G = (X [ Y; E) be a graph produced by this generator. This graph is defined by three parameters, `, k, and d. Vertices of X are partitioned into ` groups, each containing k vertices.
Reference: [25] <author> E. L. Lawler. </author> <title> Combinatorial Optimization: Networks and Matroids. </title> <publisher> Holt, Reinhart, and Winston, </publisher> <address> New York, NY., </address> <year> 1976. </year>
Reference-contexts: The cardinality of the matching is jM j. The bipartite matching problem is to find a maximum cardinality matching. The bipartite matching problem can be transformed into a unit capacity flow problem by the following simple transformation <ref> [25] </ref>: add a source s, and an arc from s to each vertex of X; add a sink t and an arc from each vertex of Y to t; and replace each arc (u; v), u 2 X; v 2 Y with an arc from u to v. 3 Implementations The
Reference: [26] <author> Q. C. Nguyen and V. Venkateswaran. </author> <title> Implementations of Goldberg-Tarjan Maximum Flow Algorithm. </title> <editor> In D. S. Johnson and C. C. McGeoch, editors, </editor> <title> Network Flows and Matching: </title> <booktitle> First DIMACS Implementation Challenge, </booktitle> <pages> pages 19-42. </pages> <publisher> AMS, </publisher> <year> 1993. </year>
Reference-contexts: For the maximum flow problem with arbitrary capacities, several studies have shown that the push-relabel method is superior to other known methods in practice <ref> [4, 8, 10, 11, 26] </ref>. Push-relabel algorithms based on the highest-level selection rule appear to be the fastest. For the unit capacity case, Goldberg and Kennedy [16] showed that the lowest-level selection rule, in combination with the global relabeling heuristic, is theoretically efficient. <p> Our flow implementations maintain residual capacities instead of flows, because the algorithms need the capacities, not the flows, for internal operation. 3.3 Global Relabeling The global relabeling heuristic improves computational performance of the push-relabel method (see e.g. <ref> [4, 15, 26] </ref>). This heuristic uses breadth-first search to compute distances to the sink in the residual graph with unit arc lengths; the distance labels are set to these distances. Such a computation takes linear time. If global relabelings are performed too often, they dominate the running time.
Reference: [27] <author> J. C. Setubal. </author> <title> New Experimental Results for Bipartite Matching. </title> <booktitle> In Proceedings of netflow93, </booktitle> <pages> pages 211-216. </pages> <institution> TR-21/93, Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1993. </year>
Reference-contexts: Here n is the number of vertices and m is the number of arcs. In this paper we study computational efficiency of bipartite matching and unit capacity flow algorithms. We are aware of three previous published computational studies of bipartite matching algorithms <ref> [9, 5, 27] </ref> and of no computational studies of unit capacity flow algorithms. Our study includes a refinement of a previous study by Setubal [28], which itself refined the results in [27] but has not been published in journal form. <p> We are aware of three previous published computational studies of bipartite matching algorithms [9, 5, 27] and of no computational studies of unit capacity flow algorithms. Our study includes a refinement of a previous study by Setubal [28], which itself refined the results in <ref> [27] </ref> but has not been published in journal form. It is well-known that the bipartite matching problem is a special case of the unit capacity flow problem. Hence any implementation that solves the latter can also solve the former. <p> For the bipartite matching problem, Darby-Dowman [9] compared bfs and dfs and found that no implementation performed "consistently better" than the other. Chang and McCormick [5] studied different variants of the depth-first search algorithm. Setubal <ref> [27] </ref> showed that a push-relabel implementation for bipartite matching was significantly faster than an implementation based on Hopcroft-Karp's algorithm [21] (which is similar to Dinitz's maximum flow algorithm [12] applied to the bipartite matching problem).
Reference: [28] <author> J. C. Setubal. </author> <title> Sequential and Parallel Experimental Results with Bipartite Matching Algorithms. </title> <type> Technical Report IC-96-09, </type> <institution> Institute of Computing, University of Campinas, Brazil, </institution> <year> 1996. </year> <month> 18 </month>
Reference-contexts: We are aware of three previous published computational studies of bipartite matching algorithms [9, 5, 27] and of no computational studies of unit capacity flow algorithms. Our study includes a refinement of a previous study by Setubal <ref> [28] </ref>, which itself refined the results in [27] but has not been published in journal form. It is well-known that the bipartite matching problem is a special case of the unit capacity flow problem. Hence any implementation that solves the latter can also solve the former.
References-found: 28

