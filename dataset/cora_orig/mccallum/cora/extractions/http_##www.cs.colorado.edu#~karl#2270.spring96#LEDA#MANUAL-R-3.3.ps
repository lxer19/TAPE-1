URL: http://www.cs.colorado.edu/~karl/2270.spring96/LEDA/MANUAL-R-3.3.ps
Refering-URL: http://www.cs.colorado.edu/~karl/2270.spring96/36.html
Root-URL: http://www.cs.colorado.edu
Title: The LEDA User Manual Version R 3.3  
Author: Stefan Naher Christian Uhrig 
Address: 06120 Halle, Germany  66123 Saarbrucken, Germany  
Affiliation: Fachbereich Mathematik und Informatik Martin-Luther Universitat Halle-Wittenberg  Max-Planck-Institut fur Informatik,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> C. Aragon, R. Seidel: </author> <title> "Randomized Search Trees", </title> <booktitle> Proc. 30th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> 540-545, </pages> <year> 1989 </year>
Reference-contexts: returns S. random source& S&gt;> int& x extracts an integer x of default pre cision or range and returns S. random source& S&gt;> unsigned int& x extracts an unsigned integer x of default precision or range and returns S. random source& S&gt;> double& x extracts a real number x in <ref> [0; 1] </ref>, i.e, u=(2 31 1) where u is a random integer in [0::2 31 1], and returns S. random source& S&gt;> bool& b extracts a random boolean value (true or false). unsigned S.get () returns an unsigned integer of maxi mal precision (31 bits). int S () returns an integer <p> Iteration forall (x; S) f "the elements of S are successively assigned to x" g 4. Implementation Sets are implemented by randomized search trees <ref> [1] </ref>. Operations insert, del, member take time O (log n), empty, size take time O (1), and clear takes time O (n), where n is the current size of the set. 54 CHAPTER 4. BASIC DATA TYPES 4.10 Integer Sets (int set) 1. <p> Precondition: it is an item in D. void D.clear () makes D the empty dictionary. int D.size () returns the size of D. bool D.empty () returns true if D is empty, false otherwise. 4. Implementation Dictionaries are implemented by randomized search trees <ref> [1] </ref>. Operations insert, lookup, del item, del take time O (log n), key, inf, empty, size, change inf take time O (1), and clear takes time O (n). Here n is the current size of the dictionary. The space requirement is O (n). 5. <p> Iteration forall defined (i; A) f "the elements from dom (A) are successively assigned to i" g forall (x; A) f "for all i 2 dom (A) the entries A [i] are successively assigned to x" g 4. Implementation Dictionary arrays are implemented by randomized search trees <ref> [1] </ref>. Access operations A [i] take time O (log dom (A)). The space requirement is O (dom (A)). 5. <p> [ff] tree dictionary, d array, sortseq [8] ch hashing hashing with chaining dictionary, d array [36] dp hashing dyn. perf. hashing h array [14], [51] pers tree persistent tree p dictionary [15] rb tree red-black tree dictionary, d array, sortseq [26] rs tree rand. search tree dictionary, d array, sortseq <ref> [1] </ref> skiplist skip lists dictionary, d array, sortseq [45] 13.1.2 Priority Queues f heap Fibonnacci heap priority queue [22] p heap pairing heap priority queue [48] k heap k-nary heap priority queue [36] m heap monotonic heap priority queue [36] eb tree Emde-Boas tree priority queue [18], [51] 185 186 CHAPTER
Reference: [2] <author> A.V. Aho, J.E. Hopcroft, J.D. Ullman: </author> <title> "Data Structures and Algorithms", </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1983 </year>
Reference: [3] <author> G.M. Adelson-Veslkii, Y.M. Landis: </author> <title> "An Algorithm for the Organization of Information", </title> <journal> Doklady Akademi Nauk, </journal> <volume> Vol. 146, </volume> <pages> 263-266, </pages> <year> 1962 </year>
Reference-contexts: Before using a data structures xyz the corresponding header file &lt;LEDA/impl/xyz.h&gt; has to be included (cf. section 1.2 for an example). 13.1.1 Dictionaries ab tree a-b tree dictionary, d array, sortseq [7] avl tree AVL tree dictionary, d array <ref> [3] </ref> bb tree BB [ff] tree dictionary, d array, sortseq [8] ch hashing hashing with chaining dictionary, d array [36] dp hashing dyn. perf. hashing h array [14], [51] pers tree persistent tree p dictionary [15] rb tree red-black tree dictionary, d array, sortseq [26] rs tree rand. search tree dictionary,
Reference: [4] <author> J.L. Bentley: </author> <title> "Decomposable Searching Problems", </title> <journal> Information Processing Letters, </journal> <volume> Vol. 8, </volume> <pages> 244-252, </pages> <year> 1979 </year>
Reference-contexts: IMPLEMENTATIONS 13.1.3 Geometry range tree range tree d2 dictionary, point set [52], [35] seg tree segment tree seg set <ref> [4] </ref>, [17] ps tree priority search tree | [38] iv tree interval tree interval set [37], [17] delaunay tree delaunay tree point set [12] 13.2.
Reference: [5] <author> R.E. Bellman: </author> <title> "On a Routing Problem", </title> <journal> Quart. Appl. Math. </journal> <volume> 16, </volume> <pages> 87-90, </pages> <year> 1958 </year>
Reference: [6] <author> J.L. Bentley, Th. Ottmann: </author> <title> "Algorithms for Reporting and Counting Geometric Intersections", </title> <journal> IEEE Trans. on Computers C 28, </journal> <pages> 643-647, </pages> <year> 1979 </year>
Reference: [7] <author> R. Bayer, E. McCreight: </author> <title> "Organizatino and Maintenance of Large Ordered Indizes", </title> <journal> Acta Informatica, </journal> <volume> Vol. 1, </volume> <pages> 173-189, </pages> <year> 1972 </year>
Reference-contexts: Before using a data structures xyz the corresponding header file &lt;LEDA/impl/xyz.h&gt; has to be included (cf. section 1.2 for an example). 13.1.1 Dictionaries ab tree a-b tree dictionary, d array, sortseq <ref> [7] </ref> avl tree AVL tree dictionary, d array [3] bb tree BB [ff] tree dictionary, d array, sortseq [8] ch hashing hashing with chaining dictionary, d array [36] dp hashing dyn. perf. hashing h array [14], [51] pers tree persistent tree p dictionary [15] rb tree red-black tree dictionary, d array,
Reference: [8] <author> N. Blum, K. Mehlhorn: </author> <title> "On the Average Number of Rebalancing Operations in Weight-Balanced Trees", </title> <booktitle> Theoretical Computer Science 11, </booktitle> <pages> 303-320, </pages> <year> 1980 </year>
Reference-contexts: Before using a data structures xyz the corresponding header file &lt;LEDA/impl/xyz.h&gt; has to be included (cf. section 1.2 for an example). 13.1.1 Dictionaries ab tree a-b tree dictionary, d array, sortseq [7] avl tree AVL tree dictionary, d array [3] bb tree BB [ff] tree dictionary, d array, sortseq <ref> [8] </ref> ch hashing hashing with chaining dictionary, d array [36] dp hashing dyn. perf. hashing h array [14], [51] pers tree persistent tree p dictionary [15] rb tree red-black tree dictionary, d array, sortseq [26] rs tree rand. search tree dictionary, d array, sortseq [1] skiplist skip lists dictionary, d array,
Reference: [9] <author> Ch. Burnikel, K. Mehlhorn, and St. Schirra. </author> <title> How to compute the Voronoi diagram of line segments: Theoretical and experimental results. </title> <booktitle> In LNCS, </booktitle> <volume> volume 855, </volume> <pages> pages 227-239. </pages> <publisher> Springer-Verlag Berlin/New York, </publisher> <year> 1994. </year> <booktitle> Proceedings of ESA'94. </booktitle>
Reference-contexts: Example We give two examples of the use of the data type real. The examples deal with the Voronoi diagram of line segments and the intersection of line segments, respectively. The following incircle test arises in the computation of Voronoi diagrams of line segments <ref> [9] </ref>. For i, 1 i 3, let l i : a i x + b i y + c i = 0 be a line in two-dimensional space and let p = (0; 0) be the origin. <p> We assume that all coefficients a i ; b i and c i , 1 i 3, are k bit integers, i.e., integers whose absolute value is bounded by 2 k 1. In <ref> [9] </ref> we showed: * if ~ D 6= 0 then j ~ Dj 2 24k50 , * if N is a square and ~ D 6= 0 then ~ D 2 8k18 where k 1 and k 2 are integer constants.
Reference: [10] <author> T.H. Cormen, C.E. Leiserson, R.L. Rivest: </author> <title> "Introduction to Algorithms", </title> <publisher> MIT Press/McGraw-Hill Book Company, </publisher> <year> 1990 </year>
Reference: [11] <author> D. Cheriton, R.E. Tarjan: </author> <title> "Finding Minimum Spanning Trees", </title> <journal> SIAM Journal of Computing, </journal> <volume> Vol. 5, </volume> <pages> 724-742, </pages> <year> 1976 </year>
Reference: [12] <author> O. Devillers: </author> <title> "Robust and Efficient Implementation of the Delaunay Tree", </title> <type> Technical Report, </type> <institution> INRIA, </institution> <year> 1992 </year>
Reference-contexts: IMPLEMENTATIONS 13.1.3 Geometry range tree range tree d2 dictionary, point set [52], [35] seg tree segment tree seg set [4], [17] ps tree priority search tree | [38] iv tree interval tree interval set [37], [17] delaunay tree delaunay tree point set <ref> [12] </ref> 13.2.
Reference: [13] <author> E.W. Dijkstra: </author> <title> "A Note on Two Problems in Connection With Graphs", </title> <journal> Num. Math., </journal> <volume> Vol. 1, </volume> <pages> 269-271, </pages> <year> 1959 </year>
Reference: [14] <author> M. Dietzfelbinger, A. Karlin, K.Mehlhorn, F. Meyer auf der Heide, H. Rohnert, R. Tarjan: </author> <title> "Upper and Lower Bounds for the Dictionary Problem", </title> <booktitle> Proc. of the 29th Annual IEEE Symposium on Foundations of Computer Science, 1988 195 196 BIBLIOGRAPHY </booktitle>
Reference-contexts: section 1.2 for an example). 13.1.1 Dictionaries ab tree a-b tree dictionary, d array, sortseq [7] avl tree AVL tree dictionary, d array [3] bb tree BB [ff] tree dictionary, d array, sortseq [8] ch hashing hashing with chaining dictionary, d array [36] dp hashing dyn. perf. hashing h array <ref> [14] </ref>, [51] pers tree persistent tree p dictionary [15] rb tree red-black tree dictionary, d array, sortseq [26] rs tree rand. search tree dictionary, d array, sortseq [1] skiplist skip lists dictionary, d array, sortseq [45] 13.1.2 Priority Queues f heap Fibonnacci heap priority queue [22] p heap pairing heap priority
Reference: [15] <author> J.R. Driscoll, N.Sarnak, D. Sleator, R.E. Tarjan: </author> <title> "Making Data Structures Persistent", </title> <booktitle> Proc. of the 18th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> 109-121, </pages> <year> 1986 </year>
Reference-contexts: I S.inf (f ace f ) returns the information of face f . f ace S.locate point (point p) returns the face containing point p. 4. Implementation Planar subdivisions are implemented by parameterized planar maps and an additional data structure for point location based on persistent search trees <ref> [15] </ref>. Operations position and inf take constant time, a locate point operation takes time O (log 2 n). Here n is the number of nodes. The space requirement and the initialization time is O (n 2 ). 144CHAPTER 9. <p> tree a-b tree dictionary, d array, sortseq [7] avl tree AVL tree dictionary, d array [3] bb tree BB [ff] tree dictionary, d array, sortseq [8] ch hashing hashing with chaining dictionary, d array [36] dp hashing dyn. perf. hashing h array [14], [51] pers tree persistent tree p dictionary <ref> [15] </ref> rb tree red-black tree dictionary, d array, sortseq [26] rs tree rand. search tree dictionary, d array, sortseq [1] skiplist skip lists dictionary, d array, sortseq [45] 13.1.2 Priority Queues f heap Fibonnacci heap priority queue [22] p heap pairing heap priority queue [48] k heap k-nary heap priority queue
Reference: [16] <author> J. Edmonds: </author> <title> "Paths, Trees, and Flowers", </title> <journal> Canad. J. Math., </journal> <volume> Vol. 17, </volume> <pages> 449-467, </pages> <year> 1965 </year>
Reference: [17] <author> H. Edelsbrunner: </author> <title> "Intersection Problems in Computational Geometry", </title> <type> Ph.D. thesis, </type> <institution> TU Graz, </institution> <year> 1982 </year>
Reference-contexts: IMPLEMENTATIONS 13.1.3 Geometry range tree range tree d2 dictionary, point set [52], [35] seg tree segment tree seg set [4], <ref> [17] </ref> ps tree priority search tree | [38] iv tree interval tree interval set [37], [17] delaunay tree delaunay tree point set [12] 13.2. <p> IMPLEMENTATIONS 13.1.3 Geometry range tree range tree d2 dictionary, point set [52], [35] seg tree segment tree seg set [4], <ref> [17] </ref> ps tree priority search tree | [38] iv tree interval tree interval set [37], [17] delaunay tree delaunay tree point set [12] 13.2.
Reference: [18] <author> P.v. Emde Boas, R. Kaas, E. Zijlstra: </author> <title> "Design and Implementation of an Efficient Priority Queue", </title> <journal> Math. Systems Theory, </journal> <volume> Vol. 10, </volume> <pages> 99-127, </pages> <year> 1977 </year>
Reference-contexts: dictionary, d array, sortseq [1] skiplist skip lists dictionary, d array, sortseq [45] 13.1.2 Priority Queues f heap Fibonnacci heap priority queue [22] p heap pairing heap priority queue [48] k heap k-nary heap priority queue [36] m heap monotonic heap priority queue [36] eb tree Emde-Boas tree priority queue <ref> [18] </ref>, [51] 185 186 CHAPTER 13. IMPLEMENTATIONS 13.1.3 Geometry range tree range tree d2 dictionary, point set [52], [35] seg tree segment tree seg set [4], [17] ps tree priority search tree | [38] iv tree interval tree interval set [37], [17] delaunay tree delaunay tree point set [12] 13.2.
Reference: [19] <author> I. Fary: </author> <title> "On Straight Line Representing of Planar Graphs", </title> <journal> Acta. Sci. Math. </journal> <volume> Vol. 11, </volume> <pages> 229-233, </pages> <year> 1948 </year>
Reference: [20] <author> F.W. Floyd: </author> <title> "Algorithm 97: Shortest Paths", </title> <journal> Communcication of the ACM, </journal> <volume> Vol. 5, </volume> <editor> p. </editor> <volume> 345, </volume> <year> 1962 </year>
Reference-contexts: It computes for each node pair (v; w) of G the distance dist (v; w) from v to w (cost of the least cost path from v to w). ALL PAIRS SHORTEST PATHS returns false if there is a negative cycle in G and true otherwise. The algorithm ([5], <ref> [20] </ref>) has running time O (jV j jEj + jV j 2 * Flow Algorithms int MAX FLOW (graph& G; node s; node t; edge array&lt;int&gt; cap; edge array&lt;int&gt;& f low) MAX FLOW takes as arguments a directed graph G (V; E), a source node s, a sink node t and
Reference: [21] <author> S. Fortune and C. van Wyk. </author> <title> Efficient exact arithmetic for computational geometry. </title> <booktitle> Proc. of the 9th Symp. on Computational Geometry, </booktitle> <pages> pages 163-171, </pages> <year> 1993. </year>
Reference-contexts: First, a double approximation is computed and then, if necessary, bigf loat approximations of increasing precision. In many cases, the double approximation already determines the sign. In this way, the user of the data type real gets the efficiency of a floating point filter <ref> [21, 43] </ref> without any work on his side. This is in marked contrast to [21, 43] and will be incorporated into [42]. Chapter 4 Basic Data Types 4.1 One Dimensional Arrays (array) 1. <p> In many cases, the double approximation already determines the sign. In this way, the user of the data type real gets the efficiency of a floating point filter <ref> [21, 43] </ref> without any work on his side. This is in marked contrast to [21, 43] and will be incorporated into [42]. Chapter 4 Basic Data Types 4.1 One Dimensional Arrays (array) 1.
Reference: [22] <author> M.L. Fredman, and R.E. Tarjan: </author> <title> "Fibonacci Heaps and Their Uses in Improved Network Optimization Algorithms", </title> <journal> Journal of the ACM, </journal> <volume> Vol. 34, </volume> <pages> 596-615, </pages> <year> 1987 </year>
Reference-contexts: Implementation Priority queues are implemented by Fibonacci heaps <ref> [22] </ref>. Operations insert, del item, del min take time O (log n), find min, decrease p, prio, inf, empty take time O (1) and clear takes time O (n), where n is the size of Q. The space requirement is O (n). 5. Example Dijkstra's Algorithm (cf. section 12.1) 6.2. <p> OLD-STYLE PRIORITY QUEUES (PRIORITY QUEUE) 75 4. Implementation Priority queues are implemented by Fibonacci heaps <ref> [22] </ref>. Operations insert, del item, del min take time O (log n), find min, decrease inf, key, inf, empty take time O (1) and clear takes time O (n), where n is the size of Q. The space requirement is O (n). 5. <p> It computes for each node v in G the distance dist [v] from s (cost of the least cost path from s to v) and the predecessor edge pred [v] in the shortest path tree. The algorithm ([13], <ref> [22] </ref>) has running time O (jEj + jV j log jV j). bool BELLMAN FORD (graph G; node s; edge array&lt;int&gt; cost; node array&lt;int&gt;& dist; node array&lt;edge&gt;& pred) 7.20. <p> dyn. perf. hashing h array [14], [51] pers tree persistent tree p dictionary [15] rb tree red-black tree dictionary, d array, sortseq [26] rs tree rand. search tree dictionary, d array, sortseq [1] skiplist skip lists dictionary, d array, sortseq [45] 13.1.2 Priority Queues f heap Fibonnacci heap priority queue <ref> [22] </ref> p heap pairing heap priority queue [48] k heap k-nary heap priority queue [36] m heap monotonic heap priority queue [36] eb tree Emde-Boas tree priority queue [18], [51] 185 186 CHAPTER 13.
Reference: [23] <author> H.N.Gabow: </author> <title> "Implementation of algorithms for maximum matching on nonbi-partite graphs", </title> <type> Ph.D. thesis, </type> <institution> Stanford Univ., Stanford, </institution> <address> CA, </address> <year> 1974 </year>
Reference-contexts: MAX WEIGHT MATCHING returns M as a list of edges. The algorithm ([16], <ref> [23] </ref>, [33]) has running time O (jV j 3 list&lt;edge&gt; MAX WEIGHT BIPARTITE MATCHING (graph& G; list&lt;node&gt;A; list&lt;node&gt;B; edge array &lt; int &gt;) MAX WEIGHT BIPARTITE MATCHING takes as arguments a directed graph G, two lists A and B of nodes and an edge array giving for each edge an integer
Reference: [24] <author> A. Goralcikova, V. Konbek: </author> <title> "A Reduct and Closure Algorithm for Graphs", </title> <booktitle> Mathematical Foundations of Computer Science, </booktitle> <volume> LNCS 74, </volume> <pages> 301-307, </pages> <year> 1979 </year>
Reference: [25] <author> K.E. Gorlen, </author> <title> S.M. Orlow, P.S. Plexico: "Data Abstraction and Object-Oriented Programming in C ++ ", John Wiley & Sons, </title> <year> 1990 </year>
Reference: [26] <author> L.J. Guibas, R. Sedgewick: </author> " <title> A Dichromatic Framework for Balanced Trees", </title> <booktitle> Proceedings of the 19th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> 8-21, </pages> <year> 1978 </year>
Reference-contexts: tree AVL tree dictionary, d array [3] bb tree BB [ff] tree dictionary, d array, sortseq [8] ch hashing hashing with chaining dictionary, d array [36] dp hashing dyn. perf. hashing h array [14], [51] pers tree persistent tree p dictionary [15] rb tree red-black tree dictionary, d array, sortseq <ref> [26] </ref> rs tree rand. search tree dictionary, d array, sortseq [1] skiplist skip lists dictionary, d array, sortseq [45] 13.1.2 Priority Queues f heap Fibonnacci heap priority queue [22] p heap pairing heap priority queue [48] k heap k-nary heap priority queue [36] m heap monotonic heap priority queue [36] eb
Reference: [27] <author> Goldberg, R.E.Tarjan: </author> <title> "A New Approach to the Maximum Flow Problem", </title> <journal> Journal of the ACM, </journal> <volume> Vol. 35, </volume> <pages> 921-940, </pages> <year> 1988 </year>
Reference: [28] <author> J.E. Hopcroft, R.M. Karp: </author> <title> "An O(n 2:5 ) Algorithm for Matching in Bipartite Graphs", </title> <journal> SIAM Journal of Computing, </journal> <volume> Vol. 4, </volume> <pages> 225-231, </pages> <year> 1975 </year>
Reference: [29] <author> J.E. Hopcroft, R.E. Tarjan: </author> <title> "Efficient Planarity Testing", </title> <journal> Journal of the ACM, </journal> <volume> Vol. 21, </volume> <pages> 549-568, </pages> <year> 1974 </year>
Reference: [30] <author> T. Hagerup, C. Uhrig: </author> <title> "Triangulating a Planar Map Without Introducing multiple Arcs", </title> <type> unpublished, </type> <year> 1989 </year>
Reference: [31] <author> A.B. Kahn: </author> <title> "Topological Sorting of Large Networks", </title> <journal> Communications of the ACM, </journal> <volume> Vol. 5, </volume> <pages> 558-562, </pages> <note> 1962 BIBLIOGRAPHY 197 </note>
Reference: [32] <author> J.B. Kruskal: </author> <title> "On the Shortest Spanning Subtree of a Graph and the Travelling Salesman Problem", </title> <journal> Proc. American Math. Society 7, </journal> <pages> 48-50, </pages> <year> 1956 </year>
Reference: [33] <author> E.L. Lawler: </author> <title> "Combinatorial Optimization: Networks and Matroids", </title> <publisher> Holt, Rine-hart and Winston, </publisher> <address> New York, </address> <year> 1976 </year>
Reference-contexts: MAX WEIGHT MATCHING returns M as a list of edges. The algorithm ([16], [23], <ref> [33] </ref>) has running time O (jV j 3 list&lt;edge&gt; MAX WEIGHT BIPARTITE MATCHING (graph& G; list&lt;node&gt;A; list&lt;node&gt;B; edge array &lt; int &gt;) MAX WEIGHT BIPARTITE MATCHING takes as arguments a directed graph G, two lists A and B of nodes and an edge array giving for each edge an integer (real)
Reference: [34] <author> S.B. Lippman: </author> <title> "C ++ Primer", </title> <publisher> Addison-Wesley, Publishing Company, </publisher> <year> 1989 </year>
Reference-contexts: Information on a commercial license is available from the author or leda@mpi-sb.mpg.de. This manual contains the specifications of all data types and algorithms currently available in LEDA. Users should be familiar with the C ++ programming language (see [47] or <ref> [34] </ref>). The manual is structured as follows: In chapter one, which is a prerequisite for all other chapters, we discuss the basic concepts and notations used in LEDA. The other chapters define the data types and algorithms available in LEDA and give examples of their use.
Reference: [35] <author> G.S. Luecker: </author> <title> "A Data Structure for Orthogonal Range Queries", </title> <booktitle> Proc. 19th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> 28-34, </pages> <year> 1978 </year>
Reference-contexts: Precondition: it is an item in D. void D.clear () makes D the empty d2 dictionary. bool D.empty () returns true if D is empty, false otherwise. int D.size () returns the size of D. 4. Implementation Two-dimensional dictionaries are implemented by dynamic two-dimensional range trees <ref> [52, 35] </ref> based on BB [ff] trees. <p> Implementation Point sets are implemented by a combination of two-dimensional range trees <ref> [52, 35] </ref> and Voronoi diagrams. Operations insert, lookup, del item, del take time O (log 2 n), key, inf, empty, size, change inf take time O (1), and clear takes time O (n log n). <p> ADVANCED DATA TYPES FOR TWO-DIMENSIONAL GEOMETRY 4. Implementation Interval sets are implemented by two-dimensional range trees <ref> [52, 35] </ref>. Operations insert, lookup, del item and del take time O (log 2 n), intersection takes time O (k+log 2 n), where k is the size of the returned list. Operations left, right, inf, empty, and size take time O (1), and clear O (n log n). <p> IMPLEMENTATIONS 13.1.3 Geometry range tree range tree d2 dictionary, point set [52], <ref> [35] </ref> seg tree segment tree seg set [4], [17] ps tree priority search tree | [38] iv tree interval tree interval set [37], [17] delaunay tree delaunay tree point set [12] 13.2.
Reference: [36] <author> K. Mehlhorn: </author> <booktitle> "Data Structures and Algorithms", </booktitle> <volume> Vol. </volume> <pages> 1-3, </pages> <publisher> Springer Publishing Company, </publisher> <year> 1984 </year>
Reference-contexts: header file &lt;LEDA/impl/xyz.h&gt; has to be included (cf. section 1.2 for an example). 13.1.1 Dictionaries ab tree a-b tree dictionary, d array, sortseq [7] avl tree AVL tree dictionary, d array [3] bb tree BB [ff] tree dictionary, d array, sortseq [8] ch hashing hashing with chaining dictionary, d array <ref> [36] </ref> dp hashing dyn. perf. hashing h array [14], [51] pers tree persistent tree p dictionary [15] rb tree red-black tree dictionary, d array, sortseq [26] rs tree rand. search tree dictionary, d array, sortseq [1] skiplist skip lists dictionary, d array, sortseq [45] 13.1.2 Priority Queues f heap Fibonnacci heap <p> rb tree red-black tree dictionary, d array, sortseq [26] rs tree rand. search tree dictionary, d array, sortseq [1] skiplist skip lists dictionary, d array, sortseq [45] 13.1.2 Priority Queues f heap Fibonnacci heap priority queue [22] p heap pairing heap priority queue [48] k heap k-nary heap priority queue <ref> [36] </ref> m heap monotonic heap priority queue [36] eb tree Emde-Boas tree priority queue [18], [51] 185 186 CHAPTER 13. <p> sortseq [26] rs tree rand. search tree dictionary, d array, sortseq [1] skiplist skip lists dictionary, d array, sortseq [45] 13.1.2 Priority Queues f heap Fibonnacci heap priority queue [22] p heap pairing heap priority queue [48] k heap k-nary heap priority queue <ref> [36] </ref> m heap monotonic heap priority queue [36] eb tree Emde-Boas tree priority queue [18], [51] 185 186 CHAPTER 13.
Reference: [37] <author> D.M. McCreight: </author> <title> "Efficient Algorithms for Enumerating Intersecting Intervals", </title> <note> Xerox Parc Report, CSL-80-09, </note> <year> 1980 </year>
Reference-contexts: IMPLEMENTATIONS 13.1.3 Geometry range tree range tree d2 dictionary, point set [52], [35] seg tree segment tree seg set [4], [17] ps tree priority search tree | [38] iv tree interval tree interval set <ref> [37] </ref>, [17] delaunay tree delaunay tree point set [12] 13.2.
Reference: [38] <author> D.M. McCreight: </author> <title> "Priority Search Trees", </title> <note> Xerox Parc Report, CSL-81-05, </note> <year> 1981 </year>
Reference-contexts: IMPLEMENTATIONS 13.1.3 Geometry range tree range tree d2 dictionary, point set [52], [35] seg tree segment tree seg set [4], [17] ps tree priority search tree | <ref> [38] </ref> iv tree interval tree interval set [37], [17] delaunay tree delaunay tree point set [12] 13.2.
Reference: [39] <author> M. Mignotte. </author> <title> Mathematics for Computer Algebra. </title> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference: [40] <author> K. Mehlhorn, S. Naher: " LEDA, </author> <title> a Library of Efficient Data Types and Algorithms", </title> <type> TR A 04/89, </type> <institution> FB10, Universitat des Saarlandes, Saarbrucken, </institution> <year> 1989 </year>
Reference: [41] <author> K. Mehlhorn, S. Naher: " LEDA, </author> <title> a Platform for Combinatorial and Geometric Computing", </title> <journal> Communications of the ACM, </journal> <volume> Vol. 38, No. 1, </volume> <pages> 96-102, </pages> <year> 1995 </year>
Reference: [42] <author> K. Mehlhorn and S. Naher. </author> <title> Implementation of a sweep line algorithm for the straight line segment intersection problem. </title> <type> Technical Report MPI-I-94-160, </type> <institution> Max-Planck-Institut fur Informatik, Saarbrucken, </institution> <year> 1994. </year>
Reference-contexts: Assume that all endpoints have k-bit integer homogeneous coordinates. This implies that the intersection points have homogeneous coordinates (X; Y; W ) where X; Y and W are (4 k + 3) bit integers. The Bentley-Ottmann plane sweep algorithm for segment intersection <ref> [42] </ref> needs to sort points by their x-coordinates, i.e., to compare fractions X 1 =W 1 and X 2 =W 2 where X 1 ; X 2 ; W 1 ; W 2 are as above. <p> In many cases, the double approximation already determines the sign. In this way, the user of the data type real gets the efficiency of a floating point filter [21, 43] without any work on his side. This is in marked contrast to [21, 43] and will be incorporated into <ref> [42] </ref>. Chapter 4 Basic Data Types 4.1 One Dimensional Arrays (array) 1.
Reference: [43] <author> K. Mehlhorn and St. Naher. </author> <title> The implementation of geometric algorithms. </title> <booktitle> In 13th World Computer Congress IFIP94, </booktitle> <volume> volume 1, </volume> <pages> pages 223-231. </pages> <publisher> Elsevier Science B.V. North-Holland, </publisher> <address> Amsterdam, </address> <year> 1994. </year>
Reference-contexts: First, a double approximation is computed and then, if necessary, bigf loat approximations of increasing precision. In many cases, the double approximation already determines the sign. In this way, the user of the data type real gets the efficiency of a floating point filter <ref> [21, 43] </ref> without any work on his side. This is in marked contrast to [21, 43] and will be incorporated into [42]. Chapter 4 Basic Data Types 4.1 One Dimensional Arrays (array) 1. <p> In many cases, the double approximation already determines the sign. In this way, the user of the data type real gets the efficiency of a floating point filter <ref> [21, 43] </ref> without any work on his side. This is in marked contrast to [21, 43] and will be incorporated into [42]. Chapter 4 Basic Data Types 4.1 One Dimensional Arrays (array) 1.
Reference: [44] <author> S. Naher: </author> <title> "LEDA2.0 User Manual", technischer Bericht A 17/90, </title> <institution> Fachbereich Informatik, Universitat des Saarlandes, Saarbrucken, </institution> <year> 1990 </year>
Reference: [45] <author> W. Pugh: </author> <title> "Skip Lists: A Probabilistic Alternative to Balanced Trees", </title> <journal> Communications of the ACM, </journal> <volume> Vol. 33, No. 6, </volume> <pages> 668-676, </pages> <year> 1990 </year>
Reference-contexts: hashing hashing with chaining dictionary, d array [36] dp hashing dyn. perf. hashing h array [14], [51] pers tree persistent tree p dictionary [15] rb tree red-black tree dictionary, d array, sortseq [26] rs tree rand. search tree dictionary, d array, sortseq [1] skiplist skip lists dictionary, d array, sortseq <ref> [45] </ref> 13.1.2 Priority Queues f heap Fibonnacci heap priority queue [22] p heap pairing heap priority queue [48] k heap k-nary heap priority queue [36] m heap monotonic heap priority queue [36] eb tree Emde-Boas tree priority queue [18], [51] 185 186 CHAPTER 13.
Reference: [46] <author> M. Stoer and F. Wagner: </author> <title> "A Simple Min Cut Algorithm", Algorithms - ESA '94, </title> <publisher> LNCS 855, </publisher> <address> 141- 147, </address> <year> 1994 </year>
Reference: [47] <author> B. Stroustrup: </author> <title> "The C ++ Programming Language, Second Edition", </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1991 </year>
Reference-contexts: Information on a commercial license is available from the author or leda@mpi-sb.mpg.de. This manual contains the specifications of all data types and algorithms currently available in LEDA. Users should be familiar with the C ++ programming language (see <ref> [47] </ref> or [34]). The manual is structured as follows: In chapter one, which is a prerequisite for all other chapters, we discuss the basic concepts and notations used in LEDA. The other chapters define the data types and algorithms available in LEDA and give examples of their use.
Reference: [48] <author> J.T. Stasko, J.S. Vitter: </author> <title> "Pairing Heaps: Experiments and Analysis", </title> <journal> Communications of the ACM, </journal> <volume> Vol. 30, </volume> <pages> 234-249, </pages> <year> 1987 </year>
Reference-contexts: pers tree persistent tree p dictionary [15] rb tree red-black tree dictionary, d array, sortseq [26] rs tree rand. search tree dictionary, d array, sortseq [1] skiplist skip lists dictionary, d array, sortseq [45] 13.1.2 Priority Queues f heap Fibonnacci heap priority queue [22] p heap pairing heap priority queue <ref> [48] </ref> k heap k-nary heap priority queue [36] m heap monotonic heap priority queue [36] eb tree Emde-Boas tree priority queue [18], [51] 185 186 CHAPTER 13.
Reference: [49] <author> R.E. Tarjan: </author> <title> "Depth First Search an Linear Graph Algorithms", </title> <journal> SIAM Journal of Computing, </journal> <volume> Vol. 1, </volume> <pages> 146-160, </pages> <note> 1972 198 BIBLIOGRAPHY </note>
Reference: [50] <author> R.E. Tarjan: </author> <title> "Data Structures and Network Algorithms", </title> <booktitle> CBMS-NSF Regional Conference Series in Applied Mathematics, </booktitle> <volume> Vol. 44, </volume> <year> 1983 </year>
Reference-contexts: Precondition: p and q are items in P . 4. Implementation Partitions are implemented by the union find algorithm with weighted union and path compression (cf. <ref> [50] </ref>). Any sequence of n make block and m n other operations takes time O (mff (m; n)). 5. Example Spanning Tree Algorithms (cf. section 7.20). 56 CHAPTER 4. BASIC DATA TYPES 4.12 Dynamic Collections of Trees (tree collection) 1. <p> Precondition: v is not a tree root. 4. Implementation Dynamic collections of trees are implemented by partitioning the trees into vertex disjoint paths and representing each path by a self-adjusting binary tree (see <ref> [50] </ref>). All operations take amortized time O (log n) where n is the number of maketree operations. Chapter 5 Dictionaries 5.1 Dictionaries (dictionary) 1. Definition An instance D of the parameterized data type dictionary&lt;K; I&gt; is a collection of items (dic item). <p> It returns M as a list of edges. The algorithm ([16], <ref> [50] </ref>) has running time O (jV j jEj ff (jEj)). list&lt;edge&gt; MAX CARD BIPARTITE MATCHING (graph& G; list&lt;node&gt; A; list&lt;node&gt; B) MAX CARD BIPARTITE MATCHING takes as arguments a directed graph G (V; E) and two lists A and B of nodes.
Reference: [51] <author> M. </author> <type> Wenzel: </type> <institution> "Worterbucher fur ein beschranktes Universum", Diplomarbeit, Fachbereich Informatik, Universitat des Saarlandes, </institution> <year> 1992 </year>
Reference-contexts: 1.2 for an example). 13.1.1 Dictionaries ab tree a-b tree dictionary, d array, sortseq [7] avl tree AVL tree dictionary, d array [3] bb tree BB [ff] tree dictionary, d array, sortseq [8] ch hashing hashing with chaining dictionary, d array [36] dp hashing dyn. perf. hashing h array [14], <ref> [51] </ref> pers tree persistent tree p dictionary [15] rb tree red-black tree dictionary, d array, sortseq [26] rs tree rand. search tree dictionary, d array, sortseq [1] skiplist skip lists dictionary, d array, sortseq [45] 13.1.2 Priority Queues f heap Fibonnacci heap priority queue [22] p heap pairing heap priority queue <p> d array, sortseq [1] skiplist skip lists dictionary, d array, sortseq [45] 13.1.2 Priority Queues f heap Fibonnacci heap priority queue [22] p heap pairing heap priority queue [48] k heap k-nary heap priority queue [36] m heap monotonic heap priority queue [36] eb tree Emde-Boas tree priority queue [18], <ref> [51] </ref> 185 186 CHAPTER 13. IMPLEMENTATIONS 13.1.3 Geometry range tree range tree d2 dictionary, point set [52], [35] seg tree segment tree seg set [4], [17] ps tree priority search tree | [38] iv tree interval tree interval set [37], [17] delaunay tree delaunay tree point set [12] 13.2.
Reference: [52] <author> D.E. Willard: </author> <title> "New Data Structures for Orthogonal Queries", </title> <journal> SIAM Journal of Computing, </journal> <pages> 232-253, </pages> <year> 1985 </year>
Reference-contexts: Precondition: it is an item in D. void D.clear () makes D the empty d2 dictionary. bool D.empty () returns true if D is empty, false otherwise. int D.size () returns the size of D. 4. Implementation Two-dimensional dictionaries are implemented by dynamic two-dimensional range trees <ref> [52, 35] </ref> based on BB [ff] trees. <p> Implementation Point sets are implemented by a combination of two-dimensional range trees <ref> [52, 35] </ref> and Voronoi diagrams. Operations insert, lookup, del item, del take time O (log 2 n), key, inf, empty, size, change inf take time O (1), and clear takes time O (n log n). <p> ADVANCED DATA TYPES FOR TWO-DIMENSIONAL GEOMETRY 4. Implementation Interval sets are implemented by two-dimensional range trees <ref> [52, 35] </ref>. Operations insert, lookup, del item and del take time O (log 2 n), intersection takes time O (k+log 2 n), where k is the size of the returned list. Operations left, right, inf, empty, and size take time O (1), and clear O (n log n). <p> IMPLEMENTATIONS 13.1.3 Geometry range tree range tree d2 dictionary, point set <ref> [52] </ref>, [35] seg tree segment tree seg set [4], [17] ps tree priority search tree | [38] iv tree interval tree interval set [37], [17] delaunay tree delaunay tree point set [12] 13.2.
References-found: 52

