URL: http://www-csag.cs.uiuc.edu/papers/dolby-masters-thesis.ps
Refering-URL: http://www-csag.cs.uiuc.edu/papers/index.html
Root-URL: http://www.cs.uiuc.edu
Title: PARASIGHT: A DEBUGGER FOR CONCURRENT OBJECT-ORIENTED PROGRAMS  
Author: BY JULIAN TIMOTHY DOLBY 
Degree: THESIS Submitted in partial fulfillment of the requirements for the degree of Master of Science in Computer Science in the Graduate College of the  
Date: 1992  
Address: Wisconsin Madison,  1996 Urbana, Illinois  
Affiliation: B.A., University of  University of Illinois at Urbana-Champaign,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> G. Agha. </author> <title> The relation between problems in large-scale concurrent systems and distributed databases. </title> <booktitle> In Proceedings of the International Symposium on Databases in Parallel and Distributed Systems, </booktitle> <pages> pages 2-12. </pages> <publisher> IEEE Computer Society, ACM SIGARCH, </publisher> <year> 1988. </year>
Reference-contexts: The program state consists of objects, which communicate by sending messages to one another; this is illustrated in Figure 2.1. There are many different concurrent object-oriented programming (COOP) models, and they take a wide variety of forms. One such model is the Actor <ref> [2, 1, 14] </ref> model, on which the Concert System is based; we now describe this COOP model in detail. <p> This is because there are relatively few threads, since the programmer must explicitly create and manage them. Process One send (p two, buf [0], id = 1) send (p two, buf <ref> [1] </ref>, id = 2) send (p two, buf [2], id = 3) Process Two receive (buf [0], id = 1) receive (buf [1], id = 2) receive (buf [2], id = 3) In contrast, concurrent object-oriented languages manage threads automatically, encouraging the exploitation of fine-grained parallelism. <p> Process One send (p two, buf [0], id = 1) send (p two, buf <ref> [1] </ref>, id = 2) send (p two, buf [2], id = 3) Process Two receive (buf [0], id = 1) receive (buf [1], id = 2) receive (buf [2], id = 3) In contrast, concurrent object-oriented languages manage threads automatically, encouraging the exploitation of fine-grained parallelism. In this style, there are often many messages to the same thread, with no fixed arrival order.
Reference: [2] <author> G. Agha and C. Hewitt. </author> <title> Object-Oriented Concurrent Programming, chapter on Actors: </title> <booktitle> A Conceptual Foundation for Concurrent Object-Oriented Programming, </booktitle> <pages> pages 49-74. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: The program state consists of objects, which communicate by sending messages to one another; this is illustrated in Figure 2.1. There are many different concurrent object-oriented programming (COOP) models, and they take a wide variety of forms. One such model is the Actor <ref> [2, 1, 14] </ref> model, on which the Concert System is based; we now describe this COOP model in detail. <p> We start with background on the Actor model itself, and then describe several actor-based programming systems. 4 2.1.1 The Actor Model The model we assume is based upon the Actor model <ref> [14, 3, 2] </ref>, which is summarized as follows: a program consists of a collection of objects called actors; each actor has a script which defines its behaviors in response to messages from other actors. Each actor also has certain acquaintances, which are other actors for which it has names. <p> This is because there are relatively few threads, since the programmer must explicitly create and manage them. Process One send (p two, buf [0], id = 1) send (p two, buf [1], id = 2) send (p two, buf <ref> [2] </ref>, id = 3) Process Two receive (buf [0], id = 1) receive (buf [1], id = 2) receive (buf [2], id = 3) In contrast, concurrent object-oriented languages manage threads automatically, encouraging the exploitation of fine-grained parallelism. <p> Process One send (p two, buf [0], id = 1) send (p two, buf [1], id = 2) send (p two, buf <ref> [2] </ref>, id = 3) Process Two receive (buf [0], id = 1) receive (buf [1], id = 2) receive (buf [2], id = 3) In contrast, concurrent object-oriented languages manage threads automatically, encouraging the exploitation of fine-grained parallelism. In this style, there are often many messages to the same thread, with no fixed arrival order.
Reference: [3] <author> Gul Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1986. </year>
Reference-contexts: We start with background on the Actor model itself, and then describe several actor-based programming systems. 4 2.1.1 The Actor Model The model we assume is based upon the Actor model <ref> [14, 3, 2] </ref>, which is summarized as follows: a program consists of a collection of objects called actors; each actor has a script which defines its behaviors in response to messages from other actors. Each actor also has certain acquaintances, which are other actors for which it has names.
Reference: [4] <author> Victor R. Basili, Richard W. Selby, and David H. Hutchens. </author> <title> Experimentation in software engineering. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 12(7) </volume> <pages> 733-743, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: We will consider these criteria when evaluating related experiments and describing our own experimental scenario. [18] builds upon the classic software experimentation paper by Basili, Selby and Hutchens <ref> [4] </ref>, in which the authors devise an overall framework for performing software experiments. They divide any experiment into four phases: definition, planning, operation and interpretation. Each of these phases in turn is broken into several pieces, which are enumerated in Table 2.2. <p> The study established several procedures that have been followed by most subsequent debugging studies, including our own evaluation of ParaSight. We discuss these in terms of the framework laid out in <ref> [4] </ref>. We analyze this experiment in some detail because it provided a methodology for evaluating ParaSight. Definition. The motivation was to assess the effectiveness of additional information in the debugging process. <p> The perspective is that of a scientist: do these forms of information help debugging? The domain of the study is experienced Fortran programmers, the three above mentioned forms of information, and three specific bug types: Assignment Bugs, Iteration Bugs and Array Bugs. The scope is termed blocked subject-project in <ref> [4] </ref>, meaning that multiple programmers each work on multiple programs. Planning. The design of the experiment consisted of choosing four small (30-50 line) programs, and adding each of the three types of bug to each program, yielding a total of 12 programs. <p> Thus, the evaluation described here is an evaluation solely of abstraction tracing and coherent printing, not of the entire ParaSight tool. In terms of <ref> [4] </ref>, the definition of our experiment follows. The purpose of the experiment is to determine whether abstraction tracing and coherent printing measurably aid program debugging, and the object of study is ParaSight both with and without the extensions. <p> This allows us to measure the total debugging time in terms of elapsed time. An advantage with this particular method of collecting data is that it is automated and unintrusive to the programmers using ParaSight. 6.2 Experimental Operation The operation of an experiment, according to the scheme of <ref> [4] </ref>, is broken into three parts: preparation, execution and analysis. The preparation for testing abstraction tracing and coherent printing was to recruit 10 volunteers to use ParaSight, and introduce them to it. The recruiting was done amongst people who were, for the most part, fairly familiar with the Concert System. <p> Some of them chose to do many programs one after the other in a marathon session; some did one at a time, doing things in between; some used a combination of these. In addition to the data collection described above, <ref> [4] </ref> also considers data validation to be part of the experimental operation. Since all data was collected by emacs interface, validation consists of making sure that people used the system as we expected. In particular, the measure of elapsed time is extremely sensitive to how people used the system.
Reference: [5] <author> Adam Beguelin, Erik Seligman, and Micheal Starkey. Dome: </author> <title> Distributed object migration environment. </title> <type> Technical Report CMU-CS-94-153, </type> <institution> School of Computer Science, Carnegie-Mellon University, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: There are the data-parallel languages that express parallelism as a method invocation on every element of an object collection, and there are control parallel languages in which multiple message sends are explicitly concurrent. Data-parallel object-oriented languages are generally called object parallel or object-based parallel programming systems; examples are Dome <ref> [5] </ref>, C** [28] and pC++ [30].
Reference: [6] <author> Jeffery Brown. </author> <title> User needs panel. </title> <booktitle> In Workshop notes from the Workshop on Debuggers for High-Performance Computers at Supercomputing '93. </booktitle> <publisher> ACM Press, SIGARCH, </publisher> <month> November </month> <year> 1993. </year>
Reference-contexts: Surveys <ref> [6] </ref> of parallel computer users report that ninety-five percent rely on print statements, and eighty percent have never tried to use any parallel debugger.
Reference: [7] <author> Brad Calder, Dirk Grunwald, and Benjamin Zorn. </author> <title> Quantifying differences between C and C++ programs. </title> <type> Technical Report CU-CS-698-94, </type> <institution> University of Colorado, Boulder, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: This reduces the size of functions com pared with imperative languages, as documented in <ref> [7] </ref>. The notion of method invocations upon objects also resembles the functional paradigm as much as the imperative one. This makes program debugging techniques widespread in applicative languages attractive. One such technique is tracing, in which function invocations are recorded as they appear.
Reference: [8] <author> K. Mani Chandy and Carl Kesselman. </author> <title> Compositional C++: Compositional parallel programming. </title> <booktitle> In Proceedings of the Fifth Workshop on Compilers and Languages for Parallel Computing, </booktitle> <address> New Haven, Connecticut, </address> <year> 1992. </year> <note> YALEU/DCS/RR-915, Springer-Verlag Lecture Notes in Computer Science, </note> <year> 1993. </year>
Reference-contexts: The objects in a parallel operation all execute these operations together and synchronize after each operation. Control parallel languages that are not restricted to data parallelism include ABCL [41], Charm++ [26], Concurrent Aggregates [13], Compositional C++ <ref> [8] </ref>; these languages can express arbitrary control, sometimes called task, parallelism. In this group also is our own Illinois Concert System [9, 12, 13]. These languages allow essentially arbitrary parallelism to expressed in a natural way as concurrent operations upon different objects.
Reference: [9] <author> A. Chien, V. Karamcheti, J. Plevyak, and D. Sahrawat. </author> <title> The concert system: Compiler and runtime technology for efficient concurrent object-oriented programming. </title> <booktitle> In Proceedings of the Computing in Aerospace 9 Conference, </booktitle> <address> San Diego, California, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: Synchronization errors are yet another kind of bug, but non-determinism makes all errors harder to locate, since they may only occur intermittently. 1 The Concurrent Systems Architecture Group has been developing the Illinois Concert Sys--tem <ref> [9, 11, 12] </ref>, a concurrent object oriented programming system to meet the challenges described above. The Illinois Concert System is a complete programming system, including an interactive programming environment, a compiler and runtime system. It extends the traditional object-oriented model with parallel object collections, first-class messages and first-class continuations. <p> Control parallel languages that are not restricted to data parallelism include ABCL [41], Charm++ [26], Concurrent Aggregates [13], Compositional C++ [8]; these languages can express arbitrary control, sometimes called task, parallelism. In this group also is our own Illinois Concert System <ref> [9, 12, 13] </ref>. These languages allow essentially arbitrary parallelism to expressed in a natural way as concurrent operations upon different objects.
Reference: [10] <author> A. A. Chien, M. Straka, J. Dolby, V. Karamcheti, J. Plevyak, and X. Zhang. </author> <title> A case study in irregular parallel programming. </title> <booktitle> In DIMACS Workshop on Specification of Parallel Algorithms, </booktitle> <month> May </month> <year> 1994. </year> <note> Also available as Springer-Verlag LNCS. 78 </note>
Reference-contexts: The Illinois Concert System is a complete programming system, including an interactive programming environment, a compiler and runtime system. It extends the traditional object-oriented model with parallel object collections, first-class messages and first-class continuations. It has been used to create substantial programs, including a distinct element method <ref> [10] </ref> and molecular dynamics code. ParaSight is the Concert System's source-level debugger. It provides a standard complement of debugger functionality: breakpoints, program interrupts, state examination and expression evaluation.
Reference: [11] <author> Andrew Chien, Vijay Karamcheti, and John Plevyak. </author> <title> The Concert system compiler and runtime support for efficient fine-grained concurrent object-oriented programs. </title> <type> Technical Report UIUCDCS-R-93-1815, </type> <institution> Department of Computer Science, University of Illinois, Urbana, Illinois, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: Synchronization errors are yet another kind of bug, but non-determinism makes all errors harder to locate, since they may only occur intermittently. 1 The Concurrent Systems Architecture Group has been developing the Illinois Concert Sys--tem <ref> [9, 11, 12] </ref>, a concurrent object oriented programming system to meet the challenges described above. The Illinois Concert System is a complete programming system, including an interactive programming environment, a compiler and runtime system. It extends the traditional object-oriented model with parallel object collections, first-class messages and first-class continuations.
Reference: [12] <author> Andrew A. Chien and Julian Dolby. </author> <title> The Illinois Concert system: A problem-solving environment for irregular applications. </title> <booktitle> In Proceedings of DAGS'94, The Symposium on Parallel Computation and Problem Solving Environments., </booktitle> <year> 1994. </year>
Reference-contexts: Synchronization errors are yet another kind of bug, but non-determinism makes all errors harder to locate, since they may only occur intermittently. 1 The Concurrent Systems Architecture Group has been developing the Illinois Concert Sys--tem <ref> [9, 11, 12] </ref>, a concurrent object oriented programming system to meet the challenges described above. The Illinois Concert System is a complete programming system, including an interactive programming environment, a compiler and runtime system. It extends the traditional object-oriented model with parallel object collections, first-class messages and first-class continuations. <p> Control parallel languages that are not restricted to data parallelism include ABCL [41], Charm++ [26], Concurrent Aggregates [13], Compositional C++ [8]; these languages can express arbitrary control, sometimes called task, parallelism. In this group also is our own Illinois Concert System <ref> [9, 12, 13] </ref>. These languages allow essentially arbitrary parallelism to expressed in a natural way as concurrent operations upon different objects. <p> The extensibility of the user-defined barrier is an advantage provided by first-class continuations. The Illinois Concert System presents a programming environment as well as a programming model <ref> [12] </ref>. The environment includes tools for incremental prototyping of programs, including incremental parallelization, in which parallelism is added in a step-wise fashion to an originally sequential program. Synchronization problems amongst parallel threads is a major cause of bugs in concurrent programs.
Reference: [13] <author> Andrew A. Chien, Vijay Karamcheti, John Plevyak, and Xingbin Zhang. </author> <title> Concurrent Aggregates language report 2.0. </title> <note> Available via anonymous ftp from cs.uiuc.edu in /pub/csag or from http://www-csag.cs.uiuc.edu/, September 1993. </note>
Reference-contexts: The objects in a parallel operation all execute these operations together and synchronize after each operation. Control parallel languages that are not restricted to data parallelism include ABCL [41], Charm++ [26], Concurrent Aggregates <ref> [13] </ref>, Compositional C++ [8]; these languages can express arbitrary control, sometimes called task, parallelism. In this group also is our own Illinois Concert System [9, 12, 13]. These languages allow essentially arbitrary parallelism to expressed in a natural way as concurrent operations upon different objects. <p> Control parallel languages that are not restricted to data parallelism include ABCL [41], Charm++ [26], Concurrent Aggregates [13], Compositional C++ [8]; these languages can express arbitrary control, sometimes called task, parallelism. In this group also is our own Illinois Concert System <ref> [9, 12, 13] </ref>. These languages allow essentially arbitrary parallelism to expressed in a natural way as concurrent operations upon different objects. <p> Concurrent Aggregates includes several extensions to the simple COOP model; we first describe how Concurrent Aggregates expresses the basic COOP model, and then its extensions will be explained. Concurrent 8 Aggregates has a LISP-like syntax. 2 More detail on Concurrent Aggregates can be found in <ref> [13] </ref>. The Concert System is described in [16]. A simple Concurrent Aggregates program that illustrates how objects are defined and meth ods invoked is shown in Figure 2.5. <p> They are written in Concurrent Aggregates, and more information can be found about this language in the Concurrent Aggregates Language Report <ref> [13] </ref> and the Concert Tutorial [16].
Reference: [14] <author> William D. Clinger. </author> <title> Foundations of actor semantics. </title> <type> Technical Report AI-TR-633, </type> <institution> MIT Artificial Intelligence Laboratory, </institution> <year> 1981. </year>
Reference-contexts: The program state consists of objects, which communicate by sending messages to one another; this is illustrated in Figure 2.1. There are many different concurrent object-oriented programming (COOP) models, and they take a wide variety of forms. One such model is the Actor <ref> [2, 1, 14] </ref> model, on which the Concert System is based; we now describe this COOP model in detail. <p> We start with background on the Actor model itself, and then describe several actor-based programming systems. 4 2.1.1 The Actor Model The model we assume is based upon the Actor model <ref> [14, 3, 2] </ref>, which is summarized as follows: a program consists of a collection of objects called actors; each actor has a script which defines its behaviors in response to messages from other actors. Each actor also has certain acquaintances, which are other actors for which it has names.
Reference: [15] <author> Robert Cohn, Steve Masticola, Robert Netzer, Douglas Pan, Emmi Schatz, Krishnan Su-vaganam, and Andrew Tolmach. </author> <title> Session summaries. </title> <editor> In Barton P. Miller and Charles McDowell, editors, </editor> <booktitle> Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, volume 26 of ACM SIGPLAN Notices, </booktitle> <pages> pages 1-14. </pages> <publisher> ACM Press, </publisher> <month> December </month> <year> 1991. </year>
Reference-contexts: Finally, ParaSight also allows print statements to be added dynamically to the program, avoiding recompilation. In the rest of this chapter, we first motivate and describe the interface for coherent printing and then detail how it is implemented. 47 5.1 The Coherent Interface In <ref> [15] </ref>, users asked for a multi-dimensional print mechanism to facilitate debugging. In static parallel models, multi-dimensional could mean one stream per node or per process, but in a COOP model the threads of computation are dynamic and ever-changing.
Reference: [16] <author> Julian Dolby, Vijay Karamcheti, John Plevyak, and Xingbin Zhang. </author> <title> Concert tutorial. CSA Group Memo, </title> <month> March </month> <year> 1994. </year>
Reference-contexts: Concurrent 8 Aggregates has a LISP-like syntax. 2 More detail on Concurrent Aggregates can be found in [13]. The Concert System is described in <ref> [16] </ref>. A simple Concurrent Aggregates program that illustrates how objects are defined and meth ods invoked is shown in Figure 2.5. It defines the tiny buffer class, which has two methods, get and put, which fetch and set the value of the buffer respectively. <p> They are written in Concurrent Aggregates, and more information can be found about this language in the Concurrent Aggregates Language Report [13] and the Concert Tutorial <ref> [16] </ref>.
Reference: [17] <author> Micheal B. Feldman and Melinda Moran. </author> <title> Validating a demonstration tool for graphics-assisted debugging of concurrent ada programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(3) </volume> <pages> 305-313, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: Interestingly, total login time was sharply higher for Enterprise users, which the authors attribute to, among other things, the slowness of Enterprise compiles and bugs in the Enterprise system. Concurrent Ada Feldman and Moran tested a graphics-assisted debugger for concurrent Ada programs <ref> [17] </ref>. In this experiment, students in an undergraduate operating systems class debugged four Ada program appropriately rigged with bugs. <p> This allowed us to recruit people with various experience levels. On the other hand, we depended upon genuine interest in the experiment amongst our sample, making it substantially smaller. There are other minor differences: our logging was more hands-off than <ref> [17] </ref>. They could get more detailed information, but having an observer present likely effects how the participants behaved. <p> The difference is likely also 58 due to the concurrent nature of Concert programs. Furthermore, the Concert compiler is fairy slow, potentially increasing compile times. We factored compilation time out of our debugging times, to see if it is a major portion; this allows a more direct comparison with <ref> [17] </ref> because they also excluded compilation time. The results are in Table 6.3. Compilation time is of very varied significance in our debugging times; it ranged from one fifth of the total debugging time to less than one tenth. <p> = normal debugger evaluation program 1 2 3 4 5 programmer 1 6 102 68 76 62 4 11 123 66 86 52 6 50 ? 60 115 50 Table 6.3: Debugging Minus Compilation (in Minutes) Almost all prior debugging studies are done with sequential languages; the one exception is <ref> [17] </ref> which used concurrent constructs in Ada. In this study, the debugging times are markedly higher then in [22], ranging between 27 and 85 minutes. We have times much higher than 85 minutes, but then Concert supports much more complex parallelism than the client-server model used in their programs.
Reference: [18] <author> Norman Fenton, Shari Lawrence Pfleeger, and Robert L. Glass. </author> <title> Science and substance: a challenge to software engineers. </title> <journal> IEEE Software, </journal> <pages> pages 86-95, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: Call tracing shows only the calls to and responses of a specific actor in the program. Abstraction tracing as implemented in ParaSight generalizes this to groups of objects encapsulated as an abstraction. This will be described in Chapter 4. 15 2.3 Software Experiments Fenton, Pfleeger and Glass <ref> [18] </ref> recently reviewed work in software experimentation; they enunciate five criteria for judging the validity of claims made about software research. <p> We will consider these criteria when evaluating related experiments and describing our own experimental scenario. <ref> [18] </ref> builds upon the classic software experimentation paper by Basili, Selby and Hutchens [4], in which the authors devise an overall framework for performing software experiments. They divide any experiment into four phases: definition, planning, operation and interpretation.
Reference: [19] <author> High Performance Fortran Forum. </author> <title> High performance Fortran language specification version 1.0. </title> <type> Technical Report CRPC-TR92225, </type> <institution> Rice University, </institution> <month> January </month> <year> 1993. </year>
Reference-contexts: interfere. 6 Actor Model Property Description acquaintances names of other actors a script message handling behaviors consisting of making simple decisions creating new actors sending messages to acquaintances specifying replacement behaviors Table 2.1: Actor Model Summary they extend do-all (such as found in Cedar Fortran [24] and High Performance Fortran <ref> [19] </ref>) operations from arrays of numbers to allow invoking an arbitrary method on each of an array of objects simultaneously. They generally also provide mechanisms for distributing object collections across processors. By permitting only one uniform parallel operation at a time, these languages preserve sequential semantics for parallel programs.
Reference: [20] <author> Message Passing Interface Forum. </author> <title> The MPI message passing interface standard. </title> <type> Technical report, </type> <institution> University of Tennessee, Knoxville, </institution> <month> April </month> <year> 1994. </year> <note> Available from http://www.mcs.anl.gov/mpi/mpi-report.ps. </note>
Reference-contexts: This is essentially what Instant Replay does, and 12 such a log is shown in Figure 2.9. Instant Replay makes logging practical for explicit message passing programming models, such as CSP [25], or any language used with message passing layers like MPI <ref> [20] </ref> and PVM [21]. This is because there are relatively few threads, since the programmer must explicitly create and manage them.
Reference: [21] <author> G. Geist and V. Sunderam. </author> <title> The pvm system: Supercomputer level concurrent computation on a heterogeneous network of workstations. </title> <booktitle> In Proceedings of the Sixth Distributed Memory Computers Conference, </booktitle> <pages> pages 258-61, </pages> <year> 1991. </year>
Reference-contexts: This is essentially what Instant Replay does, and 12 such a log is shown in Figure 2.9. Instant Replay makes logging practical for explicit message passing programming models, such as CSP [25], or any language used with message passing layers like MPI [20] and PVM <ref> [21] </ref>. This is because there are relatively few threads, since the programmer must explicitly create and manage them. <p> The Enterprise System Szafron and Schaeffer at the University of Alberta performed an experiment [40] to assess the usability of the Enterprise parallel programming system [37]. In 18 this experiment, students in a parallel programming class used either the Enterprise system or a PVM-like <ref> [21] </ref> message passing library called NMP [33] to compute a transitive closure problem over a graph. The Enterprise system embodies a novel approach to expressing parallelism: a business organization analogy where different parallel paradigms are associated with business structures.
Reference: [22] <author> John D. Gould and Paul Drongowski. </author> <title> An exploratory study of computer program debugging. </title> <booktitle> Human Factors, </booktitle> <volume> 16(3) </volume> <pages> 258-277, </pages> <month> May </month> <year> 1974. </year>
Reference-contexts: Therefore, we will utilize this framework when describing our own experiment and when discussing related debugging experiments. However, these guidelines are very general, and we now survey how they have been applied to debugging research specifically. 2.3.1 Experiments with Debugging The classic debugging study is <ref> [22] </ref>; in this study thirty experienced programmers debugged four small, synthetic programs multiple times looking for three different types of bugs. The study established several procedures that have been followed by most subsequent debugging studies, including our own evaluation of ParaSight. <p> The archetypical debugging experiment <ref> [22] </ref> reported an average time of 6 minutes, where our numbers are all much higher, often by an order of magnitude or more. <p> The study in <ref> [22] </ref> used one page Fortran programs, whereas ours ranged from one to three pages. Larger programs are presumably more difficult to debug, since localizing bugs is more effort. The difference is likely also 58 due to the concurrent nature of Concert programs. <p> In this study, the debugging times are markedly higher then in <ref> [22] </ref>, ranging between 27 and 85 minutes. We have times much higher than 85 minutes, but then Concert supports much more complex parallelism than the client-server model used in their programs.
Reference: [23] <institution> Concurrent Systems Architecture Group. </institution> <note> The ICC++ reference manual. </note> <institution> Concurrent Systems Architecture Group Memo, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: FULL) (concurrent (reply item) (set_buf self item) (set_full_flag self 1)))) ;; creates a single_buffer object, inserts, and then retrieves 5 (method osystem initial_message () (let ((buf (new tiny_buffer))) (sequential (put buf 5) (reply (get buf))))) 2 The Concert System will implement the C++ based language ICC++, which is described in <ref> [23] </ref>. 9 In addition to the standard objects described above, Concurrent Aggregates includes ho-mogeneous, parallel object collections called aggregates. These parallel collections have a single name, an aggregate name. Message sends to this aggregate name are mapped to an arbitrary member object, called a representative, of the aggregate.
Reference: [24] <author> M. D. Guzzi. </author> <title> Cedar fortran programmers handbook. </title> <type> Technical Report 601, </type> <institution> Center for Supercomputing Research and Development at the University of Illinois, Urbana, </institution> <year> 1987. </year> <month> 79 </month>
Reference-contexts: state so the messages cannot interfere. 6 Actor Model Property Description acquaintances names of other actors a script message handling behaviors consisting of making simple decisions creating new actors sending messages to acquaintances specifying replacement behaviors Table 2.1: Actor Model Summary they extend do-all (such as found in Cedar Fortran <ref> [24] </ref> and High Performance Fortran [19]) operations from arrays of numbers to allow invoking an arbitrary method on each of an array of objects simultaneously. They generally also provide mechanisms for distributing object collections across processors.
Reference: [25] <author> C. A. R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> Communications of the Association for Computing Machinery, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <year> 1978. </year>
Reference-contexts: This is essentially what Instant Replay does, and 12 such a log is shown in Figure 2.9. Instant Replay makes logging practical for explicit message passing programming models, such as CSP <ref> [25] </ref>, or any language used with message passing layers like MPI [20] and PVM [21]. This is because there are relatively few threads, since the programmer must explicitly create and manage them.
Reference: [26] <author> L.V. Kale and Sanjeev Krishnan. </author> <title> Charm++ : A portable concurrent object oriented system based on c++. </title> <booktitle> In Proceedings of the Conference on Object Oriented Programming Systems, Languages and Applications, </booktitle> <month> September </month> <year> 1993. </year>
Reference-contexts: Parallelism consists of simultaneous operations across 7 vectors, like the vector multiplication and the gsum reduction in the fragment. The objects in a parallel operation all execute these operations together and synchronize after each operation. Control parallel languages that are not restricted to data parallelism include ABCL [41], Charm++ <ref> [26] </ref>, Concurrent Aggregates [13], Compositional C++ [8]; these languages can express arbitrary control, sometimes called task, parallelism. In this group also is our own Illinois Concert System [9, 12, 13]. These languages allow essentially arbitrary parallelism to expressed in a natural way as concurrent operations upon different objects.
Reference: [27] <author> Vijay Karamcheti and Andrew Chien. </author> <title> Concert efficient runtime support for concurrent object-oriented programming languages on stock hardware. </title> <booktitle> In Proceedings of Supercomputing'93, </booktitle> <year> 1993. </year>
Reference-contexts: of concurrent execution all require special purpose extensions to gdb. gdb 4.8 ParaSight library instrumentation Concert runtime system Debugger Process Concert Program Process This support is provided in two places: in a ParaSight library that is linked to gdb and in instrumentation that is built into the Concert runtime system <ref> [27] </ref> which provides system services to the Concert programs. The library implements the Concert-specific commands provided by ParaSight and handles translations between Concurrent Aggregates and C++. It also creates the unified view of program execution. The runtime instrumentation provides provides a consistent parallel program state and implements method tracing.
Reference: [28] <author> James Larus. </author> <title> C**: a large-grain, object-oriented, </title> <booktitle> data parallel programming language. In Proceedings of the Fifth Workshop for Languages and Compilers for Parallel Machines, </booktitle> <pages> pages 326-341. </pages> <publisher> Springer-Verlag, </publisher> <month> August </month> <year> 1992. </year>
Reference-contexts: Data-parallel object-oriented languages are generally called object parallel or object-based parallel programming systems; examples are Dome [5], C** <ref> [28] </ref> and pC++ [30].
Reference: [29] <author> T. J. LeBlanc and J. M. Mellor-Crummey. </author> <title> Debugging parallel programs with Instant Replay. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 36(4) </volume> <pages> 471-482, </pages> <month> April </month> <year> 1987. </year>
Reference-contexts: In this section, we survey the relevant prior work in these two areas. 2.2.1 Event Logging Traditional debugging involves repeatedly running a program, gradually localizing each bug. Nondeterminism in parallel programs complicates this endeavor by potentially producing differing results for successive program executions. Event logging, such as Instant Replay <ref> [29] </ref> eliminates this difficulty by recording the events in a parallel program execution, allowing its exact execution to be reconstructed if needed. Instant Replay assumes that each parallel thread is deterministic, so only communication events, the sole source of nondeterminism, need to be logged.
Reference: [30] <author> J. Lee and D. Gannon. </author> <title> Object oriented parallel programming. </title> <booktitle> In Proceedings of the ACM/IEEE Conference on Supercomputing. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: Data-parallel object-oriented languages are generally called object parallel or object-based parallel programming systems; examples are Dome [5], C** [28] and pC++ <ref> [30] </ref>.
Reference: [31] <author> C. Manning. Traveler: </author> <title> The apiary observatory. </title> <booktitle> In Proceedings of the European Conference on Object-Oriented Programming, </booktitle> <year> 1987. </year>
Reference-contexts: return: 1 return: 2 call: fib (n = 3) call: fib (n = 1) return: 1 call: fib (n = 2) call: fib (n = 0) return: 1 call: fib (n = 1) return: 1 return: 2 return: 3 return: 5 14 The Actor Observatory [32], for the ACore language <ref> [31] </ref>, extends the sequential notion of tracing in two ways: to handle concurrency and to be object aware. Concurrency is handled by showing a trace graph (see Figure 2.13) rather than a sequence.
Reference: [32] <author> Carl R. Manning. Acore: </author> <title> The design of a core actor language and its compiler. </title> <type> Master's thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <month> August </month> <year> 1987. </year>
Reference-contexts: (p1 p1) (p2 p2))) ((:new-seed (the-new-seed)) (Ready (prior the-new-seed) (seed the-new-seed) (p1 p1) (p2 p2))) ((:random ()) (let ((rand (mod (* prior p1) p2))) (Ready (prior rand) (seed seed) (p1 p1) (p2 p2)) rand)))) An example program shown in Figure 2.2 illustrates the basic actor model as embodied in ACore <ref> [32] </ref>, a simple actor core language. The actor in the example implements a random 5 number generator. The actor's acquaintances are its seed, the prior generated number, and the various parameters the formula uses. Its behavior specifies how to generate a random number, reset itself and change its seed. <p> call: fib (n = 1) return: 1 return: 2 call: fib (n = 3) call: fib (n = 1) return: 1 call: fib (n = 2) call: fib (n = 0) return: 1 call: fib (n = 1) return: 1 return: 2 return: 3 return: 5 14 The Actor Observatory <ref> [32] </ref>, for the ACore language [31], extends the sequential notion of tracing in two ways: to handle concurrency and to be object aware. Concurrency is handled by showing a trace graph (see Figure 2.13) rather than a sequence.
Reference: [33] <author> T. Marsland, T. Breitkreutz, and S. Sutphen. </author> <title> A network multiprocessor for experiments in parallelism. </title> <journal> Concurrency: Practice and Experience, </journal> <volume> 3(1) </volume> <pages> 203-219, </pages> <year> 1991. </year>
Reference-contexts: In 18 this experiment, students in a parallel programming class used either the Enterprise system or a PVM-like [21] message passing library called NMP <ref> [33] </ref> to compute a transitive closure problem over a graph. The Enterprise system embodies a novel approach to expressing parallelism: a business organization analogy where different parallel paradigms are associated with business structures.
Reference: [34] <author> Mark Minas. </author> <title> Cyclic debugging in pSather, a parallel object-oriented language. </title> <editor> In Fillia Makedon, editor, </editor> <booktitle> Proceedings of the Third Annual Symposium on Parallel Computation and Problem Solving Environments, </booktitle> <pages> pages 167-177. </pages> <institution> Dartmouth Institute for Advanced Graduate Studies, </institution> <month> July </month> <year> 1994. </year>
Reference-contexts: Such nondeterminism requires logging to allow execution to be repeated, bloating logs to unmanageable proportions, making a direct adaptation of Instant Replay for such systems impossible. The pSather [35] system uses a variety of compression schemes <ref> [34] </ref>, the main one being collapsing blocks of accesses to one object by one thread into a single record, to alleviate this problem. This compression technique is illustrated in Figure 2.10; since there are only two processes, this compression technique is unusually effective.
Reference: [35] <author> Stephan Murer, Jerome A. Feldman, Chu-Cheow Lim, and Martina-Maria Seidel. pSather: </author> <title> Layered extensions to an object-oriented language for efficient parallel computation. </title> <type> Technical Report TR-93-028, </type> <institution> International Computer Science Institute, Berkeley, </institution> <address> CA, </address> <month> June </month> <year> 1993 </year> <month> November </month> <year> 1993. </year>
Reference-contexts: In this style, there are often many messages to the same thread, with no fixed arrival order. Such nondeterminism requires logging to allow execution to be repeated, bloating logs to unmanageable proportions, making a direct adaptation of Instant Replay for such systems impossible. The pSather <ref> [35] </ref> system uses a variety of compression schemes [34], the main one being collapsing blocks of accesses to one object by one thread into a single record, to alleviate this problem.
Reference: [36] <author> Robert Pizzi. </author> <title> GNU Debugger internal architecture. </title> <type> Technical Report UCRL-MA-115656, </type> <institution> University of California Davis, </institution> <year> 1993. </year>
Reference-contexts: The expression interpreter is also part of the runtime. This structure is illustrated in Figure 3.4. In the following sections, we describe these two components of ParaSight, and how they are implemented. Information on gdb is available in <ref> [36] </ref> and [39]. 25 3.3 The ParaSight Library The ParaSight library is an extension to gdb, as shown in Figure 3.4. It handles the Concurrent Aggregates source level operations, and the conversions required to implement them.
Reference: [37] <author> Jonathon Schaeffer, Duane Szafron, Greb Lobe, and Ian Parsons. </author> <title> The enterprise model for developing distributed applications. </title> <booktitle> IEEE Parallel and Distributed Technology, </booktitle> <pages> pages 85-96, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: Nonetheless, these few experiments provide interesting comparisons with our work. The Enterprise System Szafron and Schaeffer at the University of Alberta performed an experiment [40] to assess the usability of the Enterprise parallel programming system <ref> [37] </ref>. In 18 this experiment, students in a parallel programming class used either the Enterprise system or a PVM-like [21] message passing library called NMP [33] to compute a transitive closure problem over a graph.
Reference: [38] <author> Takao Shimomura and Sadahiro Isoda. </author> <title> Vips: A visual debugger for list structures. </title> <booktitle> In Proceedings of the 17th Computer Software and Applications Conference, </booktitle> <year> 1990. </year>
Reference-contexts: Overall time, in this context, means both compile time and debugging time. After all, if a debugging technique can reduce the number of compiles needed, that is a benefit. Some studies, such as <ref> [38, 40] </ref>, use measurements such as number of compiles and number of debugger commands as well as real time to measure debugging efficacy, but such measures seem to be flawed.
Reference: [39] <author> Richard M. Stallman and Roland H. Pesch. </author> <title> Debugging with GDB. Free Software Foundation, </title> <booktitle> 1992. </booktitle> <pages> 80 </pages>
Reference-contexts: The expression interpreter is also part of the runtime. This structure is illustrated in Figure 3.4. In the following sections, we describe these two components of ParaSight, and how they are implemented. Information on gdb is available in [36] and <ref> [39] </ref>. 25 3.3 The ParaSight Library The ParaSight library is an extension to gdb, as shown in Figure 3.4. It handles the Concurrent Aggregates source level operations, and the conversions required to implement them.
Reference: [40] <author> Duane Szafron and Jonathon Schaeffer. </author> <title> An experiment to measure the usability of parallel programming systems. </title> <type> Technical Report TR 94-03, </type> <institution> The University of Alberta, Department of Computing Science, </institution> <year> 1994. </year>
Reference-contexts: Nonetheless, these few experiments provide interesting comparisons with our work. The Enterprise System Szafron and Schaeffer at the University of Alberta performed an experiment <ref> [40] </ref> to assess the usability of the Enterprise parallel programming system [37]. In 18 this experiment, students in a parallel programming class used either the Enterprise system or a PVM-like [21] message passing library called NMP [33] to compute a transitive closure problem over a graph. <p> There are other minor differences: our logging was more hands-off than [17]. They could get more detailed information, but having an observer present likely effects how the participants behaved. We already noted how subjects of <ref> [40] </ref> used only one of enterprise and NMP; in our experiments, everybody used all versions of ParaSight being evaluated. 2.4 Summary COOP is an attractive model for large-scale parallel programming, because it brings the power of object-oriented programming to bear on the problems of concurrency specification and synchronization. <p> Overall time, in this context, means both compile time and debugging time. After all, if a debugging technique can reduce the number of compiles needed, that is a benefit. Some studies, such as <ref> [38, 40] </ref>, use measurements such as number of compiles and number of debugger commands as well as real time to measure debugging efficacy, but such measures seem to be flawed.
Reference: [41] <author> A. Yonezawa, E. Shibayama, T. Takada, and Y. Honda. </author> <title> Object-oriented concurrent programming - modelling and programming in an object-oriented concurrent language abcl/1. </title> <editor> In Aki Yonezawa and Mario Tokoro, editors, </editor> <booktitle> Object-Oriented Concurrent Programming, </booktitle> <pages> pages 55-89. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year> <month> 81 </month>
Reference-contexts: Parallelism consists of simultaneous operations across 7 vectors, like the vector multiplication and the gsum reduction in the fragment. The objects in a parallel operation all execute these operations together and synchronize after each operation. Control parallel languages that are not restricted to data parallelism include ABCL <ref> [41] </ref>, Charm++ [26], Concurrent Aggregates [13], Compositional C++ [8]; these languages can express arbitrary control, sometimes called task, parallelism. In this group also is our own Illinois Concert System [9, 12, 13]. These languages allow essentially arbitrary parallelism to expressed in a natural way as concurrent operations upon different objects.
References-found: 41

