URL: http://www.pmg.lcs.mit.edu/papers/javapt.ps.gz
Refering-URL: http://www.pmg.lcs.mit.edu/Thor-papers.html
Root-URL: 
Title: Parameterized Types and Java  
Author: Joseph A. Bank Barbara Liskov Andrew C. Myers (alphabetically) 
Note: This technical memorandum (TM) has been made available free of charge from the MIT Laboratory for Computer Science, at www.lcs.mit.edu.  
Date: May 1996  
Affiliation: Programming Methodology Group  
Pubnum: MIT LCS TM-553  
Abstract-found: 0
Intro-found: 1
Reference: [Car84] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. In Semantics of Data Types, </title> <publisher> LNCS 173, </publisher> <pages> pages 51-68. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: the result type of a provided method can be a subtype of what is stated in the where clause, and any exceptions thrown by the provided method must be subtypes of the exceptions given for that method in the where clause. (These are the standard contra/covariance rules for routine matching <ref> [Car84] </ref> except that we have extended them to work for Java exceptions.) For example, suppose BigNum is a class with method boolean lt (Num); where Num is a superclass of BigNum.
Reference: [DGLM95] <author> M. Day, R. Gruber, B. Liskov, and A. C. My-ers. </author> <title> Subtypes vs. where clauses: Constraining parametric polymorphism. </title> <booktitle> In Proceedings of OOPSLA '95, </booktitle> <address> Austin TX, </address> <month> October </month> <year> 1995. </year> <note> Also available at ftp://ftp.pmg.lcs.mit.edu/pub/thor/where-clauses.ps.gz. 18 </note>
Reference-contexts: Finally, we achieve performance improvements along with simpler Java code. For a simple collection class, avoiding the runtime casts from Object reduced run times by up to 16% in our prototype interpreter. We used the Theta mechanism <ref> [DGLM95, LCD + 94] </ref> as the basis of our language design. Theta was a good starting point because it uses declared rather than structural subtyping, as does Java, and because it supports complete inter-module type checking. <p> Theta was a good starting point because it uses declared rather than structural subtyping, as does Java, and because it supports complete inter-module type checking. We do not discuss in detail why this mechanism was chosen because this discussion has been presented elsewhere <ref> [DGLM95] </ref>. We rejected the C++ template mechanism [ES90] and Modula-3 [Nel91] generic module mechanism because they do not support our type-checking goal. These mechanisms do not support separate compilation because a generic module must be type-checked separately for every distinct use. <p> The parameterized definition states such requirements explicitly by giving where clauses, which identify methods and constructors that the actual parameter type must have, and also state their signatures. We will not discuss other mechanisms for constraining parameters, because the merits of where clauses are covered elsewhere <ref> [DGLM95] </ref>. Here are the above definitions with their where clauses: 1 It is possible to allow other kinds of parameters than types (for example this is done in CLU [LSAS77]), but we have found them to not be very important; in fact they just duplicate the ordinary parameter passing mechanism. <p> However, the ipool to use for the call is not necessarily the ipool of the receiver's class, since the method may be inherited from another class. An additional indirection is required to obtain the correct ipool, but this is not too expensive. Our implementation technique resembles an earlier approach <ref> [DGLM95] </ref>, but also provides support for static methods, static variables, and dynamic type discrimination. It is applicable to compiled machine code as well as the JVM bytecodes. 3.3.3 Primitive Types Primitive types such as integers can be used as parameter types under the implementation technique described here. <p> It would be possible to allow such subtyping if no methods of the supertype take arguments of the parameter type, but such types are rare. (A more complete discussion of these issues is available <ref> [DGLM95] </ref>.) Furthermore, covariant-parameter subtyping creates implementation difficulties for efficient dispatch mechanisms [Str87, Mye95]. We believe that it would be good if the Java rule for arrays were changed so that all parameterized types had the same rule.
Reference: [ES90] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Anno--tated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: We do not discuss in detail why this mechanism was chosen because this discussion has been presented elsewhere [DGLM95]. We rejected the C++ template mechanism <ref> [ES90] </ref> and Modula-3 [Nel91] generic module mechanism because they do not support our type-checking goal. These mechanisms do not support separate compilation because a generic module must be type-checked separately for every distinct use.
Reference: [LCD + 94] <author> Barbara Liskov, Dorothy Curtis, Mark Day, San-jay Ghemawat, Robert Gruber, Paul Johnson, and Andrew C. Myers. </author> <title> Theta Reference Manual. Programming Methodology Group Memo 88, </title> <institution> MIT Laboratory for Computer Science, </institution> <address> Cam-bridge, MA, </address> <month> February </month> <year> 1994. </year> <note> Also available at http://www.pmg.lcs.mit.edu/papers/thetaref/. </note>
Reference-contexts: Finally, we achieve performance improvements along with simpler Java code. For a simple collection class, avoiding the runtime casts from Object reduced run times by up to 16% in our prototype interpreter. We used the Theta mechanism <ref> [DGLM95, LCD + 94] </ref> as the basis of our language design. Theta was a good starting point because it uses declared rather than structural subtyping, as does Java, and because it supports complete inter-module type checking. <p> We largely ignore the issue of compiling the extended Java language described in Section 2, since there are many languages with parametric polymor-phism <ref> [MTH90, LCD + 94, SCW85] </ref>; compilers for languages with parametric polymorphism are reasonably well-understood and nothing new arises from the fact that the compiler generates bytecodes rather than machine instructions.
Reference: [LDH + 87] <author> Barbara Liskov, Mark Day, Maurice Herlihy, Paul Johnson, Gary Leavens, Robert Scheifler, and William Weihl. </author> <title> Argus Reference Manual. </title> <type> Technical Report 400, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> Novem-ber </month> <year> 1987. </year>
Reference-contexts: The reason for this requirement is that matching in where clauses is based on method names, and standard naming conventions make more matches possible. 4.2 Renaming More complicated instantiation mechanisms have been proposed that would eliminate the dependance on names discussed above. In Argus <ref> [LDH + 87] </ref> the instantiation can select the routine to bind to the where-routine, e.g., you could say SortedList [Numfp for ltg] to substitute some routine p for the lt method.
Reference: [LG86] <author> Barbara Liskov and John Guttag. </author> <title> Abstraction and Specification in Program Development. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: Enumeration over elements of collections can be provided using generators, as discussed in Section 4.4, but it is much more convenient to use iterators. Iterators were first introduced in CLU; they are routines similar to procedures, except that they yield a sequence of results, one at a time; see <ref> [LSAS77, LG86] </ref> for discussion and examples.
Reference: [LSAS77] <author> Barbara Liskov, Alan Snyder, Russell Atkinson, and Craig Schaffert. </author> <title> Abstraction mechanisms in CLU. </title> <journal> CACM, </journal> <volume> 20(8) </volume> <pages> 564-576, </pages> <month> August </month> <year> 1977. </year>
Reference-contexts: We will not discuss other mechanisms for constraining parameters, because the merits of where clauses are covered elsewhere [DGLM95]. Here are the above definitions with their where clauses: 1 It is possible to allow other kinds of parameters than types (for example this is done in CLU <ref> [LSAS77] </ref>), but we have found them to not be very important; in fact they just duplicate the ordinary parameter passing mechanism. <p> to attach where clauses directly to individual methods, a feature originally 6 interface SortedList [T] where T f boolean lt (T t); g f void output (OutputStream s) where T f void output (OutputStream s); g // effects: Send a textual representation of this to s. g provided by CLU <ref> [LSAS77] </ref>. Any where clause from the header of the class still applies, but additional methods can be required of the parameter type. <p> Enumeration over elements of collections can be provided using generators, as discussed in Section 4.4, but it is much more convenient to use iterators. Iterators were first introduced in CLU; they are routines similar to procedures, except that they yield a sequence of results, one at a time; see <ref> [LSAS77, LG86] </ref> for discussion and examples.
Reference: [LW94] <author> Barbara Liskov and Jeannette M. Wing. </author> <title> A behavioral notion of subtyping. </title> <journal> ACM TOPLAS, </journal> <volume> 16(6) </volume> <pages> 1811-1841, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Furthermore, the semantics of the Java approach are unfortunate from a methodological point of view. A subtype's objects ought to behave like those of the supertype so that people writing programs in terms of the supertype can reason about their behavior using the supertype specification <ref> [LW94] </ref>. Java arrays violate this rule. Therefore, we believe that for general parameterization of classes and interfaces it is better to not allow covariant-parameter subtyping.
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: We largely ignore the issue of compiling the extended Java language described in Section 2, since there are many languages with parametric polymor-phism <ref> [MTH90, LCD + 94, SCW85] </ref>; compilers for languages with parametric polymorphism are reasonably well-understood and nothing new arises from the fact that the compiler generates bytecodes rather than machine instructions. <p> This technique creates only a small one-time penalty for code that does not make use of parameterization, adding negligible overhead. The presence of subclasses makes ipools substantially more complicated than implementing parametric polymorphism for non-object-oriented languages like CLU or ML <ref> [MTH90] </ref>. Consider a method call: the compiler and dynamic linker cannot tell which piece of code is run, so they cannot determine the corresponding ipool to use, either. The proper ipool to use for the call 2 For some constants, storing the forwarding pointer requires an additional constant pool slot.
Reference: [Mye95] <author> Andrew C. Myers. </author> <title> Bidirectional object layout for separate compilation. </title> <booktitle> In OOPSLA '95 Conference Proceedings, </booktitle> <address> Austin, TX, </address> <month> October </month> <year> 1995. </year> <note> Also available at ftp://ftp.pmg/pub/thor/bidirectional.ps.gz. </note>
Reference-contexts: It would be possible to allow such subtyping if no methods of the supertype take arguments of the parameter type, but such types are rare. (A more complete discussion of these issues is available [DGLM95].) Furthermore, covariant-parameter subtyping creates implementation difficulties for efficient dispatch mechanisms <ref> [Str87, Mye95] </ref>. We believe that it would be good if the Java rule for arrays were changed so that all parameterized types had the same rule.
Reference: [Nel91] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: We do not discuss in detail why this mechanism was chosen because this discussion has been presented elsewhere [DGLM95]. We rejected the C++ template mechanism [ES90] and Modula-3 <ref> [Nel91] </ref> generic module mechanism because they do not support our type-checking goal. These mechanisms do not support separate compilation because a generic module must be type-checked separately for every distinct use.
Reference: [SCW85] <author> Craig Schaffert, Topher Cooper, and Carrie Wilpolt. </author> <title> Trellis Object-Based Environment, Language Reference Manual. </title> <type> Technical Report DEC-TR-372, </type> <institution> Digital Equipment Corporation, </institution> <month> November </month> <year> 1985. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: We largely ignore the issue of compiling the extended Java language described in Section 2, since there are many languages with parametric polymor-phism <ref> [MTH90, LCD + 94, SCW85] </ref>; compilers for languages with parametric polymorphism are reasonably well-understood and nothing new arises from the fact that the compiler generates bytecodes rather than machine instructions.
Reference: [Str87] <author> Bjarne Stroustrup. </author> <title> Multiple inheritance for C++. </title> <booktitle> In Proceedings of the Spring '87 European Unix Systems Users's Group Conference, </booktitle> <address> Helsinki, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: It would be possible to allow such subtyping if no methods of the supertype take arguments of the parameter type, but such types are rare. (A more complete discussion of these issues is available [DGLM95].) Furthermore, covariant-parameter subtyping creates implementation difficulties for efficient dispatch mechanisms <ref> [Str87, Mye95] </ref>. We believe that it would be good if the Java rule for arrays were changed so that all parameterized types had the same rule.
Reference: [Sun95a] <author> Sun Microsystems. </author> <title> Java Language Specification, </title> <note> version 1.0 beta edition, October 1995. Available at http://ftp.javasoft.com/docs/vmspec.ps.Z. </note>
Reference-contexts: 1 Introduction Java <ref> [Sun95a] </ref> is an interesting programming language because of its potential for WWW applications. It is additionally interesting because it is a type-safe object-oriented language. We believe that it would be extremely helpful to our profession if most programming were done in such a language. <p> We have not attempted to give a full syntax for Java, but rather we just focus on the parts that are affected by the addition of parameterization. Capitalized non-terminals are defined by the Java language grammar <ref> [Sun95a] </ref> and are not repeated here.
Reference: [Sun95b] <author> Sun Microsystems. </author> <title> The Java Virtual Machine Specification, release 1.0 beta edition, </title> <month> August </month> <year> 1995. </year> <note> Available at http://ftp.javasoft.com/docs/javaspec.ps.tar.Z. </note>
Reference-contexts: Because of the widespread interest in Java, its similarity to C and C++, and its industrial support, many organizations may switch to Java from their current language of choice for implementing most applications. Java is also interesting because of its heteroge-nous target architecture, the Java Virtual Machine (JVM) <ref> [Sun95b] </ref>. <p> The Java compiler generates .class files, containing code in a bytecode format, along with other information needed to interpret and verify the code. The format of a .class file is described by the JVM specification <ref> [Sun95b] </ref>. We extended the JVM in a backwards-compatible way, as described in Section 3.1. The extended virtual machine supports not only the extended Java described in Section 2, but also could be used as a target architecture for other languages with subtyping or parametric polymorphism. <p> there is exactly one class object for each instantiation being used in the running system. 3.3.2 Quick Instructions The Sun implementation of the JVM includes an optimization that dynamically modifies the code the first time an instruction is executed, replacing some ordinary bytecodes with quick equivalents that do less work <ref> [Sun95b] </ref>. These quick instructions are not part of the bytecode specification and are not visible outside of the implementation. The non-quick version of these instructions performs a one-time initialization, including dynamic type checking, and then turns itself into the quick version. <p> B JVM Extensions This appendix describes the extensions to the Java Virtual Machine that support parametric polymorphism. In the following specification, we include section numbers from the original JVM specification <ref> [Sun95b] </ref> to indicate where changes are being made. (1.4) Objects whose type is statically understood to be a parameter type are always stored as 32-bit quantities on the stack and in local variables. The types double and long cannot be used as type parameters at the VM level.
Reference: [Yel95] <author> Frank Yellin. </author> <title> Low-level security in Java, December 1995. </title> <booktitle> Presented at the Fourth International World Wide Web Conference, </booktitle> <month> Dec. </month> <year> 1995. </year> <month> 19 </month>
Reference-contexts: The popularity of Java and suitability for WWW use derives partly from the ability to statically type-check compiled code, and it is important that the extensions for parameterized types not remove this ability. The standard Java bytecode verifier works by verifying one class at a time <ref> [Yel95] </ref>. A call to a method of another class is checked using a declaration of the signature of that method, which is inserted in the .class file by the compiler. When the other class is loaded dynamically, these declarations are checked to ensure that they match the actual class signature.
References-found: 16

