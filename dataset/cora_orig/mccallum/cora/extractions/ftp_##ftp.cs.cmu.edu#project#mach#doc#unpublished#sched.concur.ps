URL: ftp://ftp.cs.cmu.edu/project/mach/doc/unpublished/sched.concur.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs/project/mach/public/www/doc/publications.html
Root-URL: 
Email: David.Black@cs.cmu.edu  
Phone: (412) 268-3041  
Title: Scheduling Support for Concurrency and Parallelism in the Mach Operating System incorporate processor allocation and
Author: David L. Black 
Note: This article describes work to  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: Changes in the use of multiprocessors are placing new demands on operating system schedulers. This article describes some of the new challenges posed by parallel and concurrent applications, and introduces techniques developed by the Mach project to meet these challenges. An overview of the techniques of timesharing scheduling and a description of the Mach scheduler are also included. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. F. Rashid, </author> <title> Threads of a New System, </title> <journal> Unix Review, </journal> <volume> vol. 4, </volume> <pages> pp. 37-49, </pages> <month> August </month> <year> 1986. </year> <note> 11 Concentrix is a trademark of Alliant Computer Systems. 15 </note>
Reference-contexts: For example, an application may be configured to require a fixed numbers of processors for efficient execution, and be unable to cope efficiently with less than that number. This article discusses new approaches to these areas developed as part of the Mach operating system <ref> [1] </ref> at Carnegie Mellon University. Mach is a new operating system for uniprocessors and multiprocessors that provides flexible memory management and sharing, multiple threads (locus of control, program counter, registers) within a single address space or task for concurrency and parallelism, and a network transparent communication subsystem (IPC).
Reference: [2] <author> S. J. Leffler, M. K. McKusick, M. J. Karels, and J. S. Quarterman, </author> <title> The Design and Implementation of the 4.3BSD Unix Operating System. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: The Mach kernel incorporates compatibility code derived from 4.3BSD Unix <ref> [2] </ref> that provides complete binary compatibility. <p> The 4.3BSD version of Unix solves this problem by making the aging rate depend on the load factor, so that aging is slower in the presence of higher load, keeping priorities in approximately the same range <ref> [2] </ref>. An alternative technique is to use an overload factor to alter the rate at which usage is accumulated. Under this technique the usage accumulated by the scheduler is the actual usage multiplied by a factor that reflects the increased load on the system. <p> Preemption occurs immediately on a uniprocessor where an AST is requested 9 The number used by 4.3BSD Unix depends on load. For the range from 0:5 to 1:0, it varies from 1=2 to 2=3 <ref> [2] </ref>. 5 Relationship Model MR = VP = PP Pure Parallelism MR VP = PP User Concurrency MR = VP PP System Concurrency MR VP PP Dual Concurrency Table 1: Programming Models for Parallel and Concurrent Programming as part of making the higher priority thread runnable, but it may take up
Reference: [3] <author> E. I. Organick, </author> <title> The Multics System: An Examination of Its Structure. </title> <address> Cambridge, MA: </address> <publisher> MIT Press, </publisher> <year> 1972. </year>
Reference-contexts: The simplest form of this is a decreasing priority scheduler where the priority of a process decreases continuously as it uses processor time, and the scheduler favors higher priority processes. Multics <ref> [3] </ref> used such a scheduler and discovered its major disadvantage, that on a heavily loaded system with significant numbers of short-lived jobs the priority of a lengthy job can decrease to a point where little or no further processor time is available to it.
Reference: [4] <author> L. J. Kenah and S. F. Bate, </author> <title> VAX/VMS Internals and Data Structures. </title> <address> Maynard, MA: </address> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: Users whose interactive work consumes large amounts of processor time may not do well under this methodology, and it may be necessary to retune the priority elevations in response to workload or hardware changes. The VAX/VMS 5 scheduler employs this elevation methodology <ref> [4] </ref>. The second priority elevation methodology is processor usage aging. A scheduler that uses this methodology elevates priorities by gradually forgetting about past processor usage, usually in an exponential fashion.
Reference: [5] <author> A. Langerman, J. Boykin, S. LoVerso, and S. Mangalat, </author> <title> A Highly-Parallelized Mach-based Vnode Filesystem, </title> <booktitle> in Proceedings of the Winter 1990 USENIX Conference, </booktitle> <month> January </month> <year> 1990. </year>
Reference-contexts: This mechanism is one example of a general technique called Handoff Scheduling that context switches directly to a new thread without searching for it on a run queue. 7 Most of this code has been parallelized, see <ref> [5] </ref> for details. 8 See [6] for an extensive study of this area 4 3.2. Priority Calculations Thread priorities consist of a base priority plus an offset derived from recent processor usage.
Reference: [6] <author> J. W. Wendorf, </author> <title> Operating System/Application Concurrency in Tightly-Coupled Multiple-Processor Systems. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, Department of Computer Science, </institution> <address> Pittsburgh, PA, </address> <year> 1987. </year> <note> Available as Technical Report CMU-CS-88-117. </note>
Reference-contexts: This mechanism is one example of a general technique called Handoff Scheduling that context switches directly to a new thread without searching for it on a run queue. 7 Most of this code has been parallelized, see [5] for details. 8 See <ref> [6] </ref> for an extensive study of this area 4 3.2. Priority Calculations Thread priorities consist of a base priority plus an offset derived from recent processor usage. <p> If an adequate hardware source of timestamps exists, such as a 32-bit microsecond counter, the scheduler can be configured to base usage calculations on timestamps from this counter. This eliminates the inaccuracies and distortions caused by statistical usage calculations (see <ref> [6] </ref> for details). Mach uses the overload factor technique for processor usage aging. The aging overhead is distributed by making each thread responsible for aging of its processor usage.
Reference: [7] <author> E. C. Cooper and R. P. Draves, </author> <title> C Threads, </title> <type> Tech. Rep. </type> <institution> CMU-CS-88-154, Computer Science Department, Carnegie Mellon University, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: This article refers to these entities as multiroutines; they may be thought of as multiprocessor generalizations of coroutines. Special cases of multiroutines include coroutines (only 1 VP), and the common programming notion of multiple threads (1 VP per multiroutine) as found the Mach Cthreads library <ref> [7] </ref>. Multiroutines and Virtual Processors can be identified in almost any parallel programming language implementation or environment. One example is that an Ada 10 runtime on Unix would use Unix processes as its virtual processors and Ada tasks as its multiroutines.
Reference: [8] <author> C. P. Thacker, L. C. Stewart, and J. Edwin H. Satterwaithe, Firefly, </author> <title> A Multiprocessor Workstation, </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. 8, </volume> <pages> pp. 909-920, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: The Mach IPC system is being redesigned to incorporate a bidirectional message primitive that can handoff in both directions. Similar functionality exists in other systems, such as the Topaz operating system developed at DEC SRC for the Firefly <ref> [8] </ref>. An alternative approach to this area is to combine the scheduling hints into higher level kernel synchronization primitives, such as semaphores or condition variables.
Reference: [9] <author> A. Tucker and A. Gupta, </author> <title> Process Control and Scheduling Issues for Multiprogrammed Shared Memory Multiprocessors, </title> <booktitle> in Proceedings of the Twelfth ACM Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1989. </year>
Reference-contexts: A server with this policy can notify applications to reconfigure when it changes the number of processors available. Researchers at Stanford are pursuing this approach and have implemented a server for this scheduling policy under Mach with good initial results <ref> [9] </ref>. 7. Related Work Previous work on policy mechanism separation has proposed separating the scheduler into two pieces: mechanisms implemented in the operating system, and policy decisions made by a user mode policy module. This work only considered the problem of scheduling within applications, but encountered two problems.
Reference: [10] <author> W. A. Wulf, R. Levin, and S. P. Harbison, Hydra/C.mmp: </author> <title> An Experimental Computer System. </title> <address> New York, NY: </address> <publisher> McGraw-Hill, </publisher> <year> 1981. </year>
Reference: [11] <author> E. F. Gehringer, D. P. Siewiorek, and Z. Segall, </author> <title> Parallel Processing: The Cm* Experience. </title> <address> Maynard, MA: </address> <publisher> Digital Press, </publisher> <year> 1987. </year>
Reference: [12] <author> H. Jacobs, </author> <title> A User-tunable Multiple Processor Scheduler, </title> <booktitle> in 1986 USENIX Winter Conference Proceedings, </booktitle> <month> January </month> <year> 1986. </year> <month> 16 </month>
Reference-contexts: In contrast, the uniform (UMA) shared memory machines that 14 are our primary interest do need short term load balancing and do not have synchronized clocks. The Alliant Concentrix 11 scheduler described by Jacobs <ref> [12] </ref> is an example of an alternative approach to processor allocation and control. This scheduler supports a fixed number of scheduling classes and uses a scheduling vector for each processor to indicate which classes should be searched for work in what order.
References-found: 12

