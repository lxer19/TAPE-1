URL: file://ftp.cis.ohio-state.edu/pub/tech-report/1996/TR33.ps.gz
Refering-URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/TRList.html
Root-URL: 
Email: (email: fmanivann,singhalg@cis.ohio-state.edu)  
Title: Quasi-Synchronous Checkpointing: Models, Characterization, and Classification  
Author: D. Manivannan Mukesh Singhal 
Keyword: Causality, distributed checkpointing, consistent global checkpoint, failure recov ery, fault-tolerance, zigzag paths.  
Address: Columbus, OH 43210  
Affiliation: Department of Computer and Information Science The Ohio State University  
Abstract: Checkpointing algorithms are classified as synchronous and asynchronous in the literature. In synchronous checkpointing, processes synchronize their checkpointing activities so that a globally consistent set of checkpoints is always maintained in the system. Synchronizing checkpointing activity involves message overhead and process execution may have to be suspended during the checkpointing coordination, resulting in performance degradation. In asynchronous checkpointing, processes take checkpoints without any coordination with others. Asynchronous checkpointing provides maximum autonomy for processes to take checkpoints; however, some of the checkpoints taken may not lie on any consistent global checkpoint, thus making the checkpointing efforts useless. Asynchronous checkpointing algorithms in the literature can reduce the number of useless checkpoints by making processes take communication induced checkpoints, besides asynchronous checkpoints. We call such algorithms, quasi-synchronous. Quasi-synchronous checkpointing algorithms are attractive because they improve the performance without introducing undesirable effects. In this paper, we present a theoretical framework for characterizing and classifying such algorithms. The theory not only helps to classify and characterize the quasi-synchronous checkpointing algorithms, but also helps analyzing the properties and limitations of the algorithms belonging to each class; it also provides guidelines for designing and evaluating such algorithms. This classification also sheds light on some open problems that remain to be solved. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Bhargava and S. R. Lian. </author> <title> "Independent Checkpointing and Concurrent Rollback for Recovery in Distributed Systems-An Optimistic Approach.". </title> <booktitle> In Proc. 7 th IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 3-12, </pages> <year> 1988. </year>
Reference-contexts: Major disadvantages of synchronous checkpointing are, (i) process execution may have to be suspended during the checkpointing coordination as in [5], resulting in performance degradation and (ii) it requires extra message overhead to synchronize the checkpointing activity. In asynchronous checkpointing <ref> [1, 7] </ref>, processes take local checkpoints periodically without any coordination with each other. This approach allows maximum process autonomy for taking checkpoints and has no message overhead for local checkpointing.
Reference: [2] <author> D. Briatico, Ciuffoletti, and L. Simoncini. </author> <title> "A Distributed Domino-Effect free Recovery Algorithm". </title> <booktitle> In Proc. of IEEE 4 th Symposium on Reliability in Distributed Software and Database Systems, </booktitle> <pages> pages 207-215. </pages> <publisher> IEEE, </publisher> <year> 1984. </year>
Reference-contexts: Next, we present some ZCF quasi-synchronous checkpointing algorithms and explain how they handle the problem of finding consistent global checkpoints. Relation to Existing Work Briatico et al.'s algorithm: The algorithm of Briatico et al. <ref> [2] </ref> forces the receiver of a message to take a checkpoint if the sender's checkpoint interval number tagged with the message 25 is higher than the current checkpoint interval number of the receiver. <p> So, this checkpointing method makes the system PZCF but not ZCF. From this observation, it also follows that for any positive integer n, checkpoints with sequence number nZ form a consistent global checkpoint. This checkpointing method will have less checkpointing overhead than that of Briatico et al. <ref> [2] </ref> since processes are forced to take a checkpoint only if the sequence number received in the message exceeds by at least Z from the sequence number of its latest checkpoint which has a sequence number of the form nZ. <p> However, the method for finding consistent global checkpoints will yield less number of consistent global checkpoints than the one proposed in <ref> [2] </ref> if Z &gt; 1 and there will be useless checkpoints. Xu and Netzer's Adaptive Checkpointing Algorithm: To our knowledge, Xu and Net-zer [20] attempted for the first time to design a checkpointing algorithm which tracks the Z-cycles on line and prevents them.
Reference: [3] <author> Luis Moura e Silva and Jouao Gabriel Silva. </author> <title> "Global Checkpointing for Distributed Programs". </title> <booktitle> In Proc. Symp. Reliable Distributed Systems, </booktitle> <pages> pages 155-162, </pages> <year> 1992. </year>
Reference-contexts: In the literature, several checkpointing schemes have been proposed for distributed systems. These schemes are generally classified into two categories synchronous and asynchronous. In synchronous checkpointing schemes, processes synchronize their checkpointing activities so that a globally consistent set of checkpoints is always maintained in the system <ref> [3, 5, 9] </ref>. The storage requirement for the checkpoints is minimum because each process keeps only one checkpoint in the stable storage at any given time.
Reference: [4] <author> T. T-Y. Juang and S. Venkatesan. </author> <title> "Crash Recovery with Little Overhead". </title> <booktitle> In Proc. of 11 th International Conf. on Distributed Comput. Syst., </booktitle> <pages> pages 454-461, </pages> <year> 1991. </year>
Reference: [5] <author> R. Koo and S. Toueg. </author> <title> "Checkpointing and Roll-back Recovery for Distributed Systems". </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> SE-13(1):23-31, </volume> <month> January </month> <year> 1987. </year>
Reference-contexts: In the literature, several checkpointing schemes have been proposed for distributed systems. These schemes are generally classified into two categories synchronous and asynchronous. In synchronous checkpointing schemes, processes synchronize their checkpointing activities so that a globally consistent set of checkpoints is always maintained in the system <ref> [3, 5, 9] </ref>. The storage requirement for the checkpoints is minimum because each process keeps only one checkpoint in the stable storage at any given time. <p> The storage requirement for the checkpoints is minimum because each process keeps only one checkpoint in the stable storage at any given time. Major disadvantages of synchronous checkpointing are, (i) process execution may have to be suspended during the checkpointing coordination as in <ref> [5] </ref>, resulting in performance degradation and (ii) it requires extra message overhead to synchronize the checkpointing activity. In asynchronous checkpointing [1, 7], processes take local checkpoints periodically without any coordination with each other. This approach allows maximum process autonomy for taking checkpoints and has no message overhead for local checkpointing.
Reference: [6] <author> Ajay D. Kshemkalyani, Michel Raynal, and Mukesh Singhal. </author> <title> "An Introduction to Snapshot Algorithms in Distributed Computing". </title> <journal> Distributed Systems Engineering Journal, </journal> <volume> 2(4) </volume> <pages> 224-233, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: A set of local checkpoints, one from each of the processes involved in a distributed computation, is called a consistent global checkpoint if none of them is causally dependent on any other checkpoint in the set. Determining consistent global checkpoints has applications in several areas of distributed system design <ref> [6] </ref>. Some areas of application are failure recovery, debugging distributed software, monitoring distributed events such as in industrial process control, setting distributed breakpoints, and protocol specification and verification. In the literature, several checkpointing schemes have been proposed for distributed systems.
Reference: [7] <author> K.Tsuruoka, A. Kaneko, and Y. Nishihara. </author> <title> "Dynamic Recovery Schemes for Distributed Process". </title> <booktitle> In Proceedings of IEEE 2nd Symp. on Reliability in Distributed Software and Database Systems, </booktitle> <pages> pages 124-130, </pages> <year> 1981. </year>
Reference-contexts: Major disadvantages of synchronous checkpointing are, (i) process execution may have to be suspended during the checkpointing coordination as in [5], resulting in performance degradation and (ii) it requires extra message overhead to synchronize the checkpointing activity. In asynchronous checkpointing <ref> [1, 7] </ref>, processes take local checkpoints periodically without any coordination with each other. This approach allows maximum process autonomy for taking checkpoints and has no message overhead for local checkpointing.
Reference: [8] <author> L. Lamport. </author> <title> "Time, Clocks and ordering of events in distributed systems". </title> <journal> Communications of the ACM., </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: 1 Introduction During the execution of a distributed computation, processes exchange information via messages. The message exchange establishes causal dependencies among states of processes 1 . The causal dependency among the states of processes is formally characterized by Lamport's "happened before" relation <ref> [8] </ref>. Informally, a state s q of a process P q is causally dependent on a state s p of another process P p if a message (or sequences of messages) sent by P p after state s p was received by P q before reaching state s q . <p> Communication channels are FIFO. Execution of a process is modeled by three types of events the send event of a message, the receive event of a message and an internal event. The states of processes depend on one another due to interprocess communication. Lamport's happened before relation <ref> [8] </ref> on events, hb !, is defined as the transitive closure of the union of two other relations: 4 hb xo m xo ! relation captures the order in which local events of a process are executed.
Reference: [9] <author> K. Li, J. F. Naughton, and J. S. Plank. </author> <title> "Checkpointing Multicomputer Applications". </title> <booktitle> In Proc. 10 th Symp. on Reliable Distributed Systems, </booktitle> <pages> pages 2-11, </pages> <year> 1991. </year> <month> 31 </month>
Reference-contexts: In the literature, several checkpointing schemes have been proposed for distributed systems. These schemes are generally classified into two categories synchronous and asynchronous. In synchronous checkpointing schemes, processes synchronize their checkpointing activities so that a globally consistent set of checkpoints is always maintained in the system <ref> [3, 5, 9] </ref>. The storage requirement for the checkpoints is minimum because each process keeps only one checkpoint in the stable storage at any given time.
Reference: [10] <author> D. Manivannan, Robert H. B. Netzer, and M. Singhal. </author> <title> "Finding Consistent Global Checkpoints in a Distributed Computation". </title> <type> Technical Report OSU-CISRC-3/96-TR16, </type> <institution> The Ohio State University, Department of Computer and Information Science, </institution> <note> 1996 (submitted to IEEE Transactions on Parallel and Distributed Systems). </note>
Reference-contexts: Formally, a Z-path between two checkpoints is defined <ref> [10, 13] </ref> as: Definition 2 A Z-path exists from C p;i to C q;j if 1. p = q and i &lt; j (i.e., the two checkpoints are from the same process and the former precedes the later) or 2. there exist messages m 1 ; m 2 ; ; m <p> Corollary 1 A checkpoint C can be part of a consistent global checkpoint if and only if it is not on a Z-cycle. Proof: Follows from Theorem 1 by taking S = fCg. 2 We first review some of the results in <ref> [10] </ref> to make the paper self contained. Given a set S of checkpoints such that S 6 zp ; S, those checkpoints that have no Z-paths from or to any of the checkpoints in S are possible candidates for extending S to a consistent global checkpoint. <p> The dotted lines in Figure 4 pass through the maximal and the minimal consistent global checkpoints containing the set S. Formally, these results are stated in Theorems 2 and 3, the proofs of which can be found in <ref> [10] </ref>. set S such that S 6 zp 9 Theorem 2 Let S be a set of checkpoints such that S 6 zp S max = fC q;j j (C q;j 2 Z-cone (S)) ^ (8 k &gt; j; C q;k 62 Z-cone (S))g: Then S max is the maximal consistent
Reference: [11] <author> D. Manivannan and M. Singhal. </author> <title> "A Low-overhead recovery Technique using Quasi-synchronous Checkpointing". </title> <booktitle> In Proceedings of the 16 th International Conference on Distributed Computing Systems (to appear), </booktitle> <address> Hong Kong, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: Note that none of the checkpoints taken is useful and all checkpointing effort is wasted. useful. The number of useless checkpoints taken by processes can be reduced by requiring processes to take communication induced checkpoints, in addition to checkpoints taken independently <ref> [11, 18, 20] </ref>. The checkpointing algorithms that require processes to take communication induced checkpoints are called quasi-synchronous checkpointing algorithms, because some checkpointing activity is triggered by the message pattern and knowledge gained about the dependency between checkpoints of processes. <p> Manivannan and Singhal's Algorithm: In the checkpointing algorithm of Manivannan and Singhal <ref> [11] </ref>, each message is piggybacked with the sequence number of the current checkpoint. <p> Since a message sent after a checkpoint with sequence number i is never received by any process before taking a checkpoint with sequence number i, the system is ZCF by Theorem 8. It is proved in <ref> [11] </ref> that given a checkpoint C p;i , the set S i = fC q;j j j is the smallest positive integer ig is a consistent global checkpoint containing C p;i .
Reference: [12] <author> F. Mattern. </author> <title> "Virtual Time and Global States of Distributed Systems". </title> <editor> In M. Cosnard et al., editor, </editor> <booktitle> Parallel and Distributed Algorithms, </booktitle> <pages> pages 215-226. </pages> <publisher> Elsevier Science, North Holland, </publisher> <year> 1989. </year>
Reference-contexts: construction of consistent global checkpoints incrementally and easily; this is because, in the absence of non-causal Z-paths, any set of checkpoints that are not pairwise causally related can be extended to a consistent global checkpoint by Theorem 1 and causality between checkpoints can be tracked on-line by using vector timestamps <ref> [12, 14] </ref> or similar mechanisms. 11 Thus, the primary issues involved in designing a quasi-synchronous checkpointing algo-rithm are (i) how to efficiently determine appropriate events for processes to take communication induced checkpoints so that non-causal Z-paths can be eliminated and (ii) how to minimize the number of communication induced checkpoints taken. <p> Thus, we can incrementally extend S to a consistent global checkpoint. Since causality (i.e., cp ; relation) can be tracked on-line using vector timestamps or similar other mechanisms <ref> [12, 14] </ref>, constructing consistent global checkpoints incrementally using this method is simple and practical. In a non-SZPF system however, it is not easy to construct consistent global checkpoints incrementally due to the presence of non-causal Z-paths because tracking non-causal Z-paths on-line is difficult.
Reference: [13] <author> Robert H. B. Netzer and Jian Xu. </author> <title> "Necessary and Sufficient Conditions for Consistent Global Snapshots". </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 6(2) </volume> <pages> 165-169, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: consistent global checkpoint 2 if for any message M and for any integer p; 1 p N : receive (M ) hb ! C p;m p =) send (M ) hb ! C q;m q for some q; 1 q N . 2.2 Z-paths and their Properties Netzer and Xu <ref> [13] </ref> gave a necessary and sufficient condition for a given set of checkpoints to be part of a consistent global checkpoint. They introduced the notion of zigzag path, which is a generalization of a causal path 3 induced by the Lamport's happened before relation. <p> Formally, a Z-path between two checkpoints is defined <ref> [10, 13] </ref> as: Definition 2 A Z-path exists from C p;i to C q;j if 1. p = q and i &lt; j (i.e., the two checkpoints are from the same process and the former precedes the later) or 2. there exist messages m 1 ; m 2 ; ; m <p> a causal path exists from A to some member of S, etc. 7 An important property of Z-paths is that it captures the precise requirement for a set of checkpoints to be a part of a consistent global checkpoint as stated in the following theorem due to Netzer and Xu <ref> [13] </ref>. Theorem 1 A set of checkpoints S can be extended to a consistent global checkpoint if and only if S 6 zp Proof: Proof can be found in [13]. 2 Theorem 1, presents the precise condition a set of checkpoints needs to satisfy in order to be part of a <p> checkpoints to be a part of a consistent global checkpoint as stated in the following theorem due to Netzer and Xu <ref> [13] </ref>. Theorem 1 A set of checkpoints S can be extended to a consistent global checkpoint if and only if S 6 zp Proof: Proof can be found in [13]. 2 Theorem 1, presents the precise condition a set of checkpoints needs to satisfy in order to be part of a consistent global checkpoint. The following corollary of Theorem 1 gives the precise condition for a single checkpoint to be part of a consistent global checkpoint.
Reference: [14] <author> Michel Raynal and Mukesh Singhal. </author> <title> "Logical Time: Capturing Causality in Distributed Systems". </title> <journal> Computer, </journal> <volume> 29(2) </volume> <pages> 49-56, </pages> <month> February </month> <year> 1996. </year>
Reference-contexts: construction of consistent global checkpoints incrementally and easily; this is because, in the absence of non-causal Z-paths, any set of checkpoints that are not pairwise causally related can be extended to a consistent global checkpoint by Theorem 1 and causality between checkpoints can be tracked on-line by using vector timestamps <ref> [12, 14] </ref> or similar mechanisms. 11 Thus, the primary issues involved in designing a quasi-synchronous checkpointing algo-rithm are (i) how to efficiently determine appropriate events for processes to take communication induced checkpoints so that non-causal Z-paths can be eliminated and (ii) how to minimize the number of communication induced checkpoints taken. <p> Thus, we can incrementally extend S to a consistent global checkpoint. Since causality (i.e., cp ; relation) can be tracked on-line using vector timestamps or similar other mechanisms <ref> [12, 14] </ref>, constructing consistent global checkpoints incrementally using this method is simple and practical. In a non-SZPF system however, it is not easy to construct consistent global checkpoints incrementally due to the presence of non-causal Z-paths because tracking non-causal Z-paths on-line is difficult.
Reference: [15] <author> S. Venkatesan. </author> <title> "Message-Optimal Incremental Snapshots". </title> <journal> J. Comput. Software Engineering, </journal> <volume> 1 </volume> <pages> 211-231, </pages> <year> 1993. </year>
Reference: [16] <author> S. Venkatesan and T. T-Y. Juang. </author> <title> "Efficient Algorithm for Crash Recovery in Distributed Systems". </title> <booktitle> In 10 th Conf. on Foundations on Software Technology and Theoretical Computer Science, </booktitle> <pages> pages 349-361, </pages> <year> 1990. </year>
Reference: [17] <author> K. Venkatesh, T. Radhakrishnan, and H. F. Li. </author> <title> "Optimal Checkpointing and Local Encoding for Domino-free Rollback Recovery". </title> <journal> Information Processing Letters, </journal> <volume> 25 </volume> <pages> 295-303, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Thus, a process is allowed to send and receive messages in a checkpoint interval as long as it will not change the dependency vector in that interval. Venkatesh et al.'s method: In the checkpointing algorithm of Venkatesh et al. <ref> [17] </ref>, processes are allowed to perform checkpointing independently based on their individual requirements. Checkpoints are assigned unique sequence numbers.
Reference: [18] <author> Y. M. Wang and W. K. Fuchs. </author> <title> "Lazy checkpoint Coordination for Bounding Rollback Propagation". </title> <type> Technical Report CRHC-92-26, </type> <institution> Coordinated Science Laboratory, University of Illinois at Urbana-Champaign, </institution> <year> 1992. </year>
Reference-contexts: Note that none of the checkpoints taken is useful and all checkpointing effort is wasted. useful. The number of useless checkpoints taken by processes can be reduced by requiring processes to take communication induced checkpoints, in addition to checkpoints taken independently <ref> [11, 18, 20] </ref>. The checkpointing algorithms that require processes to take communication induced checkpoints are called quasi-synchronous checkpointing algorithms, because some checkpointing activity is triggered by the message pattern and knowledge gained about the dependency between checkpoints of processes. <p> Wang et al.'s Lazy Checkpoint Coordination: Wang and Fuchs <ref> [18] </ref> proposed lazy checkpoint coordination in which each message is piggybacked with the sequence number of the current checkpoint interval. They define the laziness Z, a predefined system parameter which is a positive integer.
Reference: [19] <author> Yi-Min Wang. </author> <title> "Consistent Global Checkpoints that Contain a Given Set of Local Checkpoints". </title> <type> Technical report, </type> <institution> AT & T, </institution> <year> 1995. </year>
Reference-contexts: Relation to Existing Work The No-Receive-After-Send method: The No-Receive-After-Send (NRAS) checkpointing method <ref> [19] </ref> disallows any message to be received in any checkpoint interval once a message has been sent in that checkpoint interval. Thus, all message send events precede all message receive events in each checkpoint interval. Hence, it follows from Theorem 4 that the NRAS checkpointing method makes the system SZPF. <p> Hence, it follows from Theorem 4 that the NRAS checkpointing method makes the system SZPF. A distributed computation taking checkpoints using the NRAS checkpointing method is shown in Figure 7. 15 The Checkpoint-After-Send method: In Checkpoint-After-Send (CAS) method <ref> [19] </ref>, a checkpoint must be taken after every send event. Thus, any checkpoint interval can have at most one message-send event and it must appear at the end of the interval. Hence, CAS method of checkpointing makes the system SZPF by Theorem 4. <p> However, this property comes at the expense of high checkpointing overhead. For the distributed computation in Figure 7, the checkpoints taken using CAS method are shown in Figure 8. The Checkpoint-Before-Receive method: In Checkpoint-Before-Receive (CBR) method <ref> [19] </ref>, a checkpoint must be taken before every receive event. Thus, any checkpoint interval can have at most one message-receive event and it always appears at the beginning of the interval. Hence it makes the system SZPF by Theorem 4. <p> However, in the CBR method, the latest checkpoints of processes do not form a consistent global checkpoint. The Checkpoint-After-Send-Before-Receive method: In the Checkpoint-After-Send-Before-Receive (CASBR) method <ref> [19] </ref>, a checkpoint must be taken after every message-send event and before every message-receive event. <p> Equivalence of RD-trackable and ZPF systems We show that the Rollback Dependency Trackable System (RD-Trackable System) <ref> [19] </ref> is equivalent to the ZPF system. We define the RD-Trackable system using the terminology of Z-paths; this definition is equivalent to the original definition of [19]. Each process 20 P p maintains a vector D p of size N . <p> Equivalence of RD-trackable and ZPF systems We show that the Rollback Dependency Trackable System (RD-Trackable System) <ref> [19] </ref> is equivalent to the ZPF system. We define the RD-Trackable system using the terminology of Z-paths; this definition is equivalent to the original definition of [19]. Each process 20 P p maintains a vector D p of size N . <p> Thus, a system is RD-trackable if and only if for any two checkpoints C p;i and C q;j , C p;i zp cp ; C q;j . Thus proving the theorem. 2 Relation to Existing Work Fixed-Dependency-After-Send method: In Fixed-Dependency-After-Send (FDAS) method <ref> [19] </ref>, when a process P p sends a message, it piggybacks the current value of the dependency vector D p . <p> Thus, in each checkpoint interval, after the first send event, the dependency vector remains unchanged until the next checkpoint. Fixed-Dependency-Interval method: In Fixed-Dependency-Interval (FDI) method <ref> [19] </ref>, when a process P p sends a message, it piggybacks the current value of the dependency vector D p . <p> When a process P q receives a message M , P q processes the message if M:D [r] D q [r] 8r; otherwise, it first takes a checkpoint, sets D q [r] := M ax (D q [r]; M:D [r]) 8r, and then processes the message. Wang <ref> [19] </ref> showed that both the FDAS method and the FDI method are RD-trackable. Hence, from Theorem 7, both FDAS and FDI methods are ZPF. It is easy to see that Venkatesh et al.'s checkpointing method is the same as the FDI method described above and hence is ZPF.
Reference: [20] <author> Jian Xu and Robert H. B. Netzer. </author> <title> "Adaptive Independent Checkpointing for Reducing Rollback Propagation". </title> <booktitle> In 5 th IEEE Symposium on Parallel and Distributed Processing, </booktitle> <month> December </month> <year> 1993. </year> <month> 32 </month>
Reference-contexts: Note that none of the checkpoints taken is useful and all checkpointing effort is wasted. useful. The number of useless checkpoints taken by processes can be reduced by requiring processes to take communication induced checkpoints, in addition to checkpoints taken independently <ref> [11, 18, 20] </ref>. The checkpointing algorithms that require processes to take communication induced checkpoints are called quasi-synchronous checkpointing algorithms, because some checkpointing activity is triggered by the message pattern and knowledge gained about the dependency between checkpoints of processes. <p> However, the method for finding consistent global checkpoints will yield less number of consistent global checkpoints than the one proposed in [2] if Z &gt; 1 and there will be useless checkpoints. Xu and Netzer's Adaptive Checkpointing Algorithm: To our knowledge, Xu and Net-zer <ref> [20] </ref> attempted for the first time to design a checkpointing algorithm which tracks the Z-cycles on line and prevents them. In their method, each process P p maintains a dependency vector DV p of size N .
References-found: 20

