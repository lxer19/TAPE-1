URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/fp/public/elf-papers/rta95.ps.gz
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/fp/public/elf-papers/INDEX.html
Root-URL: http://www.cs.cmu.edu
Email: Wolfgang.Gehrke@risc.uni-linz.ac.at  
Title: Problems in Rewriting Applied to Categorical Concepts By the Example of a Computational Comonad  
Author: Wolfgang Gehrke 
Address: A 4040 Linz, AUSTRIA  
Affiliation: Research Institute for Symbolic Computation Johannes Kepler University  
Abstract: We present a canonical system for comonads which can be extended to the notion of a computational comonad [BG92] where the crucial point is to find an appropriate representation. These canonical systems are checked with the help of the Larch Prover [GG91] exploiting a method by G. Huet [Hue90a] to represent typing within an untyped rewriting system. The resulting decision procedures are implemented in the programming language Elf [Pfe89] since typing is directly supported by this language. Finally we outline an incomplete attempt to solve the problem which could be used as a benchmark for rewriting tools.
Abstract-found: 1
Intro-found: 1
Reference: [Bac91] <author> L. Bachmair. </author> <title> Canonical Equational Proofs. </title> <booktitle> Progress in Theoretical Computer Science. </booktitle> <publisher> Birkhauser, </publisher> <year> 1991. </year>
Reference-contexts: Working over this congruence results in finite congruence classes which can be computed and have a canonical representation when orienting both rules from left to right. Thus the reducibility of terms is decidable cf. <ref> [Bac91] </ref>. Furthermore it is easy to find a polynomial interpretation which is decreasing on the rules and remains constant for the congruence. The hard part here would be to show confluence.
Reference: [BG92] <author> S. Brookes and S. Geva. </author> <title> Computational Comonads and Intensional Semantics. In M.P. </title> <editor> Fourman and P.T. Johnstone and A.M. Pitts, editor, </editor> <booktitle> Categories in Computer Science, number 177 in London Mathematical Society Lecture Notes, </booktitle> <pages> pages 1-44. </pages> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: M fi M 1 fi ~ = ~ = 1 fi ? - M M associativity identity laws Fig. 1. laws of a monoid in form of diagrams But when doing the same for a comonad the resulting system could not be extended to the notion of a computational comonad <ref> [BG92] </ref> which is used to study the intensional semantics of programming languages. In this paper we describe a canonical system for computational comonads which is based on a different canonical system for comonads. <p> In the verification of the canonical system we will deal with types in the frame of the Larch Prover [GG91] as suggested in [Hue90a]. Finally the resulting decision procedures were implemented in the programming language Elf [Pfe89] which directly supports dependent types and they were applied to examples from <ref> [BG92] </ref>. At the end we will briefly describe another attempt to solve the same problem with the help of rewriting over a congruence. <p> At the end we conclude and suggest future work. 2 Definitions In this section the definition of a comonad [BW85] and a computational comonad <ref> [BG92] </ref> are given. Furthermore the notion of the Kleisli category is introduced. We assume throughout that the morphisms between two objects form a set. <p> It can easily be verified that this construction actually is a category cf. [BW85]. We present the Kleisli category since it will be useful for characterizing comonads in another way. Definition 4 (Computational Comonad <ref> [BG92] </ref>). Let C be a category and CM = (T; *; ffi) be a comonad on C. <p> Therefore we implemented the final decision procedures for comonads and computational comonads in the logic programming language Elf which supports dependent types directly. 5 Implementation in Elf and Application Here it is shown how the canonical system for computational comonads can be applied where examples are taken from <ref> [BG92] </ref>. The actual run of the test can be found in the appendix. Because of the difficulty to represent dependent types in a conventional rewriting tool like the Larch Prover we implemented the rewriting in the logic programming language Elf. <p> The dynamic part makes already use of the definitions in the static part so that only in a few cases the type has to be made more explicit. The sample queries which can be seen in the trace correspond to <ref> [BG92] </ref>. There a pair of functors is defined relating the category C and the Kleisli category K.
Reference: [Bun93] <author> R. Bundgen. </author> <title> Reduce the Redex ! ReDuX. </title> <editor> In C. Kirchner, editor, </editor> <booktitle> Rewriting Techniques and Applications, number 690 in Lecture Notes in Computer Science, </booktitle> <pages> pages 446-450. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Since the amount of rules was constantly growing we finally looked for a more appropriate formulation of the theory of a comonad although the structure of the rules for a computational comonad follow the same pattern. It is possible that a formalization with the ReDuX <ref> [Bun93] </ref> system which is able to handle inductive completion also in the presence of AC-operators may succeed.
Reference: [BW85] <author> M. Barr and C. Wells. </author> <title> Toposes, Triples and Theories. Number 278 in Grundlehren der mathematischen Wissenschaften. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: In [Geh94] we reduced the uniform word problem for monads to the uniform word problem for adjunctions exploiting theorems from category theory <ref> [BW85] </ref>. ? sponsored by the Austrian Science Foundation (FWF) under ESPRIT BRP 6471 MEDLAR II, and by the American National Science Foundation under Grant No. <p> At the end we conclude and suggest future work. 2 Definitions In this section the definition of a comonad <ref> [BW85] </ref> and a computational comonad [BG92] are given. Furthermore the notion of the Kleisli category is introduced. We assume throughout that the morphisms between two objects form a set. <p> It can easily be verified that this construction actually is a category cf. <ref> [BW85] </ref>. We present the Kleisli category since it will be useful for characterizing comonads in another way. Definition 4 (Computational Comonad [BG92]). Let C be a category and CM = (T; *; ffi) be a comonad on C.
Reference: [Fil94] <author> A. Filinski. </author> <title> Representing Monads. </title> <booktitle> In Proceedings of the 21st Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 446-457. </pages> <publisher> ACM, </publisher> <year> 1994. </year>
Reference: [FS90] <author> P.J. Freyd and A. Scedrov. </author> <title> Categories, </title> <publisher> Allegories. Elsevier Science Publishers, </publisher> <year> 1990. </year>
Reference-contexts: This would give the right frame to reason about certain monadic functional programs. In practice it would be very helpful to allow diagrams being a compact visual encoding of equations as input to the prover. The output could also be displayed in an appropriate form. In <ref> [FS90] </ref> one can already find a suitable graphical language used in the context of categories.
Reference: [Geh94] <author> W. Gehrke. </author> <title> Proof of the Decidability of the Uniform Word Problem for Mon-ads Assisted by Elf. </title> <type> Technical Report 94-66, </type> <institution> RISC, </institution> <year> 1994. </year>
Reference-contexts: A recent application of monads in computer science can be found in [Mog89] where they are exploited to structure the semantics of programming languages which later was used to structure purely functional programs as in [Wad93]. In <ref> [Geh94] </ref> we reduced the uniform word problem for monads to the uniform word problem for adjunctions exploiting theorems from category theory [BW85]. ? sponsored by the Austrian Science Foundation (FWF) under ESPRIT BRP 6471 MEDLAR II, and by the American National Science Foundation under Grant No.
Reference: [GG91] <author> S.J. Garland and J.V. Guttag. </author> <title> A Guide to LP, The Larch Prover. </title> <publisher> MIT, </publisher> <year> 1991. </year>
Reference-contexts: Morphisms in a category come together with a type depending on two objects source and target. These have to be taken into account when doing rewriting. In the verification of the canonical system we will deal with types in the frame of the Larch Prover <ref> [GG91] </ref> as suggested in [Hue90a]. Finally the resulting decision procedures were implemented in the programming language Elf [Pfe89] which directly supports dependent types and they were applied to examples from [BG92].
Reference: [Hue80] <author> G. Huet. </author> <title> Confluent Reductions. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 24(4) </volume> <pages> 797-821, </pages> <month> October </month> <year> 1980. </year>
Reference-contexts: Thus the reducibility of terms is decidable cf. [Bac91]. Furthermore it is easy to find a polynomial interpretation which is decreasing on the rules and remains constant for the congruence. The hard part here would be to show confluence. The left-linear rule method by Huet (cf. <ref> [Hue80] </ref>) was tried since all the rules are left-linear but this resulted in further critical pairs. Also the existence of a unification algorithm for a homomorphism described by 5 as given in [Vog78] but without associativity did not suffice to cover the entire congruence class.
Reference: [Hue90a] <author> G. Huet. </author> <title> Cartesian closed categories and lambda-calculus. </title> <booktitle> In [Hue90b], </booktitle> <pages> pages 7-23. </pages> <publisher> Addison Wesley, </publisher> <year> 1990. </year>
Reference-contexts: It seems that the main difficulty in handling these equational theories consists of an appropriate reformulation of the problem with the help of an equivalent theory where Cartesian closed categories are a well known instance <ref> [Hue90a] </ref>. In that case the decision problem is transferred from the language of a CCC into the language of a typed lambda calculus. Morphisms in a category come together with a type depending on two objects source and target. These have to be taken into account when doing rewriting. <p> Morphisms in a category come together with a type depending on two objects source and target. These have to be taken into account when doing rewriting. In the verification of the canonical system we will deal with types in the frame of the Larch Prover [GG91] as suggested in <ref> [Hue90a] </ref>. Finally the resulting decision procedures were implemented in the programming language Elf [Pfe89] which directly supports dependent types and they were applied to examples from [BG92]. At the end we will briefly describe another attempt to solve the same problem with the help of rewriting over a congruence. <p> This example could be used to test rewrite tools which allow the extension of the signature as in [KZ89] such that one can see to which extent this may be automated. 4 Encoding Types in LP Here the method due to G. Huet (cf. <ref> [Hue90a] </ref>) is demonstrated with the concrete example of a computational comonad. Remark. In a category it is important to check the compatibility of morphisms in order to compose them.
Reference: [Hue90b] <editor> G. Huet. </editor> <booktitle> Logical Foundations of Functional Programming. University of Texas at Austin Programming Series. </booktitle> <publisher> Addison Wesley, </publisher> <year> 1990. </year>
Reference: [KZ89] <author> D. Kapur and H. Zhang. RRL: </author> <title> Rewrite Rule Laboratory User's Manual, </title> <note> revised edition, </note> <month> May </month> <year> 1989. </year>
Reference-contexts: At this point it should be stressed that the choice of the representation for comonads was not obvious to us. The introduction of the auxiliary ? was necessary to succeed. This example could be used to test rewrite tools which allow the extension of the signature as in <ref> [KZ89] </ref> such that one can see to which extent this may be automated. 4 Encoding Types in LP Here the method due to G. Huet (cf. [Hue90a]) is demonstrated with the concrete example of a computational comonad. Remark.
Reference: [Lan79] <author> D.S. Lankford. </author> <title> On proving term rewriting systems are Noetherian. </title> <type> Technical report, </type> <institution> Louisiana Technical University, Ruston, LA, </institution> <year> 1979. </year>
Reference-contexts: The check of the critical pairs can be seen in the appendix. It was done twice: firstly without taking the typing of morphisms into account and secondly including the typing. Here we only give the termination argument with the help of a polynomial interpretation I (cf. <ref> [Lan79] </ref>) I (f) := (I 1 (f ); I 2 (f ); I 3 (f )): I 1 (id) = I 2 (id) = I 3 (id) = 1 I 2 (f ffi g) = 2 fl I 2 (f) fl I 2 (g) I 1 () = I 2 ()
Reference: [Man76] <author> E. Manes. </author> <title> Algebraic Theories. Number 26 in Graduate Texts in Mathematics. </title> <publisher> Springer-Verlag, </publisher> <year> 1976. </year>
Reference-contexts: A comonad can be completely characterized by (id; ffi; ; ? ) on the level of morphisms assuming it is known how T acts on objects. Proof cf. <ref> [Man76] </ref>. The other components can be expressed as: * A := A ; ffi A := id ? Remark. This gives a more compact way of presenting a comonad since it was previously described in terms of (id; ffi; T; *; ffi).
Reference: [ML71] <author> S. Mac Lane. </author> <title> Categories for the Working Mathematician. Number 5 in Graduate Texts in Mathematics. </title> <publisher> Springer-Verlag, </publisher> <year> 1971. </year>
Reference-contexts: Of course this is not always decidable. A monoid is a very useful mathematical notion which is described equationally and which has a decidable uniform word problem. The equations can be characterized by diagrams as in Fig. 1. A monad is the categorical generalization of the this concept <ref> [ML71] </ref>. This gives evidence that there can be a canonical system for monads, too. A recent application of monads in computer science can be found in [Mog89] where they are exploited to structure the semantics of programming languages which later was used to structure purely functional programs as in [Wad93].
Reference: [Mog89] <author> E. Moggi. </author> <title> Computational Lambda-calculus and Monads. </title> <booktitle> In Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 14-23. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: The equations can be characterized by diagrams as in Fig. 1. A monad is the categorical generalization of the this concept [ML71]. This gives evidence that there can be a canonical system for monads, too. A recent application of monads in computer science can be found in <ref> [Mog89] </ref> where they are exploited to structure the semantics of programming languages which later was used to structure purely functional programs as in [Wad93].
Reference: [Nip91] <author> T. Nipkow. </author> <title> Higher-Order Critical Pairs. </title> <booktitle> In Sixth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 342-349. </pages> <publisher> IEEE, </publisher> <month> July </month> <year> 1991. </year>
Reference-contexts: For future work we want to continue in two directions atheoretical and a practical. The notion of a monad as used in functional programming [Wad93] still has to be investigated. Since this requires the treatment of higher order rewriting <ref> [Nip91] </ref> Elf is still a suitable tool since it supports higher order types. This would give the right frame to reason about certain monadic functional programs. In practice it would be very helpful to allow diagrams being a compact visual encoding of equations as input to the prover.
Reference: [Pfe89] <author> F. Pfenning. </author> <title> Elf: a language for verified meta-programming. </title> <booktitle> In Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 313-322. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: These have to be taken into account when doing rewriting. In the verification of the canonical system we will deal with types in the frame of the Larch Prover [GG91] as suggested in [Hue90a]. Finally the resulting decision procedures were implemented in the programming language Elf <ref> [Pfe89] </ref> which directly supports dependent types and they were applied to examples from [BG92]. At the end we will briefly describe another attempt to solve the same problem with the help of rewriting over a congruence.
Reference: [Vog78] <author> E. Vogel. </author> <title> Unifikation von Morphismen (in German). </title> <address> Diplomarbeit, Uni-versitat Karlsruhe, </address> <year> 1978. </year>
Reference-contexts: The hard part here would be to show confluence. The left-linear rule method by Huet (cf. [Hue80]) was tried since all the rules are left-linear but this resulted in further critical pairs. Also the existence of a unification algorithm for a homomorphism described by 5 as given in <ref> [Vog78] </ref> but without associativity did not suffice to cover the entire congruence class. Nevertheless the structure of the rules is rather simple since the composition occurs there only once.
Reference: [Wad93] <author> P. Wadler. </author> <title> Monads for functional programming. </title> <editor> In M. Broy, editor, </editor> <booktitle> Program Design Calculi, volume 118 of NATO ASI Series F: Computer and System Sciences, </booktitle> <pages> pages 233-264. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: This gives evidence that there can be a canonical system for monads, too. A recent application of monads in computer science can be found in [Mog89] where they are exploited to structure the semantics of programming languages which later was used to structure purely functional programs as in <ref> [Wad93] </ref>. In [Geh94] we reduced the uniform word problem for monads to the uniform word problem for adjunctions exploiting theorems from category theory [BW85]. ? sponsored by the Austrian Science Foundation (FWF) under ESPRIT BRP 6471 MEDLAR II, and by the American National Science Foundation under Grant No. <p> Furthermore the user has direct influence on the strategy for rewriting. For future work we want to continue in two directions atheoretical and a practical. The notion of a monad as used in functional programming <ref> [Wad93] </ref> still has to be investigated. Since this requires the treatment of higher order rewriting [Nip91] Elf is still a suitable tool since it supports higher order types. This would give the right frame to reason about certain monadic functional programs.
References-found: 20

