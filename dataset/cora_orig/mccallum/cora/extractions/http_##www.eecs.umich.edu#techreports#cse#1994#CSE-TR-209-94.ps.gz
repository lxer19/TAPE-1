URL: http://www.eecs.umich.edu/techreports/cse/1994/CSE-TR-209-94.ps.gz
Refering-URL: http://www.eecs.umich.edu/home/techreports/cse94.html
Root-URL: http://www.eecs.umich.edu
Email: santanu@eecs.umich.edu, aprakash@eecs.umich.edu  
Title: Supporting Queries on Source Code: A Formal Framework  
Author: Santanu Paul Atul Prakash 
Keyword: Reverse engineering, source code query, query languages, algebra, generalized order-sorted algebra.  
Address: Ann Arbor, MI-48105  
Affiliation: Software Systems Research Laboratory Dept. of Electrical Engineering and Computer Science University of Michigan  
Abstract: Querying source code interactively for information is a critical task in reverse engineering of software. However, current source code query systems succeed in handling only small subsets of the wide range of queries possible on code, trading generality and expressive power for ease of implementation and practicality. We attribute this to the absence of clean formalisms for modeling and querying source code. In this paper, we present an algebraic framework (Source Code Algebra or SCA) for modeling and querying source code. The framework forms the basis of our query system for C source code. An analogy can be drawn with relational algebra, which forms the basis for relational databases. The benefits of using SCA include the integration of structural and flow information into a single source code data model, the ability to process high-level source code queries (command-line, graphical, relational, or pattern-based) by translating them into SCA expressions which can be evaluated using the SCA evaluator, the use of SCA itself as a powerful low-level source code query language, and opportunities for query optimization. We present the SCA's data model and operators and show that a variety of source code queries can be easily expressed using them. An algebraic model of source code addresses the issues of conceptual integrity, expressive power, and performance of a source code query system within a unified framework. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Al-Zoubi and A. Prakash. </author> <title> Software Change Analysis via Attributed Dependency Graphs. </title> <type> Technical Report CSE-TR-95-91, </type> <institution> Dept. of EECS, University of Michigan, </institution> <month> May </month> <year> 1991. </year> <note> Also in Software Maintenance, to appear. </note>
Reference-contexts: Unfortunately, one of the fundamental problems designers of source code querying systems face is the lack of good underlying models to represent source code information and to express queries. For example, in our previous work on building source code querying tools SCAN <ref> [1] </ref> and SCRUPLE [34], and earlier in our work on the Evolution Support Environment System (ESE) [35], we found that no satisfactory choice for the underlying model to represent program information was available.
Reference: [2] <author> J. Ambras and V. O'Day. </author> <title> Microscope: A Program Analysis System. </title> <booktitle> In Proc. of the 20th Hawaii International Conference on System Sciences, </booktitle> <pages> pages 460-468, </pages> <year> 1987. </year>
Reference-contexts: Another option would have been to use some other representation model such as graphs or abstract syntax trees, as used Rigi [30] and Microscope <ref> [2] </ref> or an object-based representation as used in REFINE [26] and in [27, 20]. However, the problem with those models would have been the lack of a query language with well-defined operators. Either option was somewhat unsatisfactory.
Reference: [3] <author> T. Biggerstaff, B.G. Mitbander, and D. Webster. </author> <title> The Concept Assignment Problem in Program Understanding. </title> <booktitle> In Proc. of the 15th International Conference on Software Engineering, </booktitle> <pages> pages 482-498, </pages> <year> 1993. </year>
Reference-contexts: The need for sophisticated querying tools for reverse engineering has been articulated by Biggerstaff in terms of a "conceptual grep" <ref> [3] </ref>, and also by Chikofsky [9]. The purpose of a source code querying tool is to help a human reverse engineer indulge in plausible reasoning [3] or domain bridging [5] | an iterative process of guesswork and verification that leads him or her to a better understanding of what the source <p> The need for sophisticated querying tools for reverse engineering has been articulated by Biggerstaff in terms of a "conceptual grep" <ref> [3] </ref>, and also by Chikofsky [9]. The purpose of a source code querying tool is to help a human reverse engineer indulge in plausible reasoning [3] or domain bridging [5] | an iterative process of guesswork and verification that leads him or her to a better understanding of what the source code is doing. Reverse engineers may need to make several types of queries.
Reference: [4] <author> G. Birkhoff and D. Lipson. </author> <title> Heterogeneous Algebras. </title> <journal> Journal of Combinatorial Theory, </journal> <volume> 8 </volume> <pages> 115-133, </pages> <year> 1970. </year>
Reference-contexts: The first condition can be satisfied if, instead of using the class of one-sorted algebras, we use the class of many-sorted algebras <ref> [4, 17] </ref> to model SCA. Unlike one-sorted algebras that model a single data type, many-sorted algebras can model a variety of atomic and composite data types and the operations on those types within a single algebraic framework.
Reference: [5] <author> R. Brooks. </author> <title> Towards a Theory of Comprehension of Computer Programs. </title> <journal> International Journal of Man Machine Studies, </journal> <volume> 18 </volume> <pages> 543-554, </pages> <year> 1983. </year>
Reference-contexts: The need for sophisticated querying tools for reverse engineering has been articulated by Biggerstaff in terms of a "conceptual grep" [3], and also by Chikofsky [9]. The purpose of a source code querying tool is to help a human reverse engineer indulge in plausible reasoning [3] or domain bridging <ref> [5] </ref> | an iterative process of guesswork and verification that leads him or her to a better understanding of what the source code is doing. Reverse engineers may need to make several types of queries.
Reference: [6] <author> K. Bruce and P. Wegner. </author> <title> Advances in Database Programming Languages, chapter An Algebraic Model of Subtype and Inheritance. </title> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: subtype of PROGRAM-OBJECT ...... type-spec:TYPENAME name:STRING parameters:PARAM-LIST body:COMPOUND-STMT calls:SET (FUNCTION) in-file:FILE inverse funcs ...... endtype type FILE subtype of PROGRAM-OBJECT ...... name:STRING funcs:SET (FUNCTION) inverse in-file decls:SET (DECLARATION) ...... endtype type STATEMENT subtype of PROGRAM-OBJECT ...... line-no:SET (FUNCTION) uses:SET (VARIABLE) inverse used-by defines:SET (VARIABLE) inverse defined-by ...... endtype ........... 9 <ref> [6] </ref>. Essentially, a sort is a subsort of another if the former is behaviorally compatible with (i.e., can be substituted for) the latter. A generalized order-sorted algebra is thus a many-sorted algebra with a partial order defined on its sorts.
Reference: [7] <author> P. Butterworth, A. Otis, and J. Stein. </author> <title> The Gemstone Object Database Management System. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 50-77, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: To further investigate design and implementation issues, a prototype of the current system is being built on top of Gemstone, an object-oriented database system <ref> [7] </ref>. Several key components such as parser and query processor for handling sequences have been built and were tested in the SCRUPLE system for pattern matching.
Reference: [8] <author> Y. Chen, M.Y. Nishimoto, </author> <title> and C.V. Ramamoorthy. The C Information Abstraction System. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(3) </volume> <pages> 325-334, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Support for extracting relevant information from source code has so far been left either to rudimentary, string searching tools like grep, awk, etc. (which are capable of handling only trivial queries), or to general-purpose database approaches that have limited querying power for the source code domain <ref> [8, 10, 28, 30] </ref>. The need for sophisticated querying tools for reverse engineering has been articulated by Biggerstaff in terms of a "conceptual grep" [3], and also by Chikofsky [9]. <p> One option for us was to use the relational model, as used in several systems such as OMEGA [28], CIA <ref> [8] </ref>, and CIA++ [18]. The advantage of that would have been the availability of a formal query language (based on relational algebra) | our work in developing a query language and a query processor would have been reduced.
Reference: [9] <author> E. Chikofsky. </author> <title> State-of-Art Talk on Reverse Engineering. </title> <booktitle> Invited Talk at the 15th International Conference on Software Engineering, </booktitle> <address> Baltimore, Maryland., </address> <month> May </month> <year> 1993. </year>
Reference-contexts: The need for sophisticated querying tools for reverse engineering has been articulated by Biggerstaff in terms of a "conceptual grep" [3], and also by Chikofsky <ref> [9] </ref>. The purpose of a source code querying tool is to help a human reverse engineer indulge in plausible reasoning [3] or domain bridging [5] | an iterative process of guesswork and verification that leads him or her to a better understanding of what the source code is doing.
Reference: [10] <author> L. Cleveland. </author> <title> A Program Understanding Support Environment. </title> <journal> IBM Systems Journal, </journal> <volume> 28(2) </volume> <pages> 324-344, </pages> <year> 1989. </year>
Reference-contexts: Support for extracting relevant information from source code has so far been left either to rudimentary, string searching tools like grep, awk, etc. (which are capable of handling only trivial queries), or to general-purpose database approaches that have limited querying power for the source code domain <ref> [8, 10, 28, 30] </ref>. The need for sophisticated querying tools for reverse engineering has been articulated by Biggerstaff in terms of a "conceptual grep" [3], and also by Chikofsky [9].
Reference: [11] <author> E.F. Codd. </author> <title> A relational model for large shared data banks. </title> <journal> Communications of the ACM, </journal> <volume> 13(6) </volume> <pages> 377-387, </pages> <year> 1970. </year>
Reference-contexts: An algebra defines a model for representing source code information and gives a well-defined set of operators that can be used to make queries on the information. The analogy is the use of relational algebra <ref> [11] </ref> as the foundation for relational database systems. Algebras have also been used in the design of general-purpose query languages for the relational data model [11], the nested relational model [21, 22, 23], the extended relational model [38], the object model [29, 31, 40, 41], and also in the design of <p> The analogy is the use of relational algebra <ref> [11] </ref> as the foundation for relational database systems. Algebras have also been used in the design of general-purpose query languages for the relational data model [11], the nested relational model [21, 22, 23], the extended relational model [38], the object model [29, 31, 40, 41], and also in the design of a domain-specific query language for structured office documents [19]. <p> The arguments in favor of building a formal query language are compelling. The constructs of a formal language have well-defined semantics. It has been observed in the context of query languages that formal frameworks such as relational algebra <ref> [11] </ref>, relational calculus [42], NST-Algebra [19], etc. have yielded powerful and expressive high-level query languages, and have been argued to be functionally complete within their respective data models. Well-defined semantics has led to clean implementations for query processors. <p> Relations are sets of tuples whose fields have atomic values such as integers, strings, etc. The primitive operators of the algebra are union ([), set difference (), select (oe c ), project ( a 1 ;a 2 ;:::; ), and cartesian product (fi) <ref> [11] </ref>. Join (1) is a derived operator of the algebra (composition of oe and fi). Each of these operators take relations as arguments, and produce new relations. <p> The signatures of the operators are shown in Table 1. Codd has shown that all information stored using relations can be accessed using the five primitive operators of relational algebra. In that sense, the relational algebra is query-complete <ref> [11] </ref>. Relational algebra has also been shown to be equivalent to relational calculus [42]. Relational algebra (or its equivalent relational calculus) forms the basis of a wide variety of relational database query languages such as SQL, QUEL, ISBL, and QBE [42].
Reference: [12] <author> T.A. Corbi. </author> <title> Program Understanding: Challenge for the 1990s. </title> <journal> IBM Systems Journal, </journal> <volume> 28(2) </volume> <pages> 294-306, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction Programmers have become part historian, part detective, and part clairvoyant. Tom Corbi, in Program Understanding: Challenge for the 1990s <ref> [12] </ref>. In the last few years, software reverse engineering, code re-engineering, and program understanding have emerged as the latest challenges in the field of software engineering. <p> One of the early conclusions in reverse engineering research is that a complete automation of the design recovery process is not feasible <ref> [12] </ref>. Given the current state-of-art in reverse engineering technology, it is felt that reverse engineering of real systems can at best be automated 50 percent, and the rest must be by human participation [44].
Reference: [13] <author> M. Atkinson et al. </author> <title> The Object-Oriented Database System Manifesto. </title> <type> Technical Report ALTAIR TR 30-89, </type> <institution> GIP ALTAIR, LeChesnay, France, </institution> <year> 1989. </year> <month> 18 </month>
Reference-contexts: Extracting and storing such information is the responsibility of flow analyzers. An attribute of an object can also be a method or a function that is computed on-the-fly. Methods are a standard feature of object-oriented data models <ref> [13] </ref>, and can be used to introduce complex and specialized algorithms into the data model.
Reference: [14] <author> M. Stonebraker et al. </author> <title> Third-generation database system manifesto. </title> <journal> ACM SIGMOD Record, </journal> <volume> 19(3), </volume> <year> 1990. </year>
Reference-contexts: In either case, there is no need for procedural descriptions of queries. In contrast, the lack of formal frameworks and the absence of non-procedural query languages in many object-oriented data models has led to problems in query processing and optimization <ref> [14] </ref>. 3 Our Approach: An Algebra for Source Code To facilitate queries on source code, we have developed a source code data model that captures the necessary structural and program flow information and designed a formal framework to query the model for such information.
Reference: [15] <author> S. Ginsburg and X. Wang. </author> <title> Pattern Matching by Rs-Operations: Towards a Unified Approach to Querying Sequenced Data. </title> <booktitle> In Proc. of the 11th ACM SIGACT/SIGMOD/SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 293-300, </pages> <year> 1992. </year>
Reference-contexts: SCA is essentially an algebra of objects. We have used and extended operators from pre-existing object algebras for set operations, generalizing them to operate on sequences wherever possible, and proposed appropriate operators for sequences. Operators for sequences have only recently begun to be proposed in literature <ref> [15, 37] </ref>. We have introduced seq extract, a powerful new operator for sequences which uses regular expressions as the basis for extracting subsequences. SCA offers a unified approach to querying collections, whether they be sets or sequences.
Reference: [16] <author> J. Goguen and J. Meseguer. </author> <title> Extensions and Foundations of Object-oriented Programming. </title> <type> Technical report, </type> <institution> SRI, </institution> <year> 1986. </year>
Reference-contexts: The issue of ordering the sorts of a many-sorted algebra was first addressed as a theoretical problem by Goguen and Meseguer <ref> [16] </ref> who proposed an order-sorted algebra based on the interpretation of subsorts (subtypes) as subsets.
Reference: [17] <author> J.A. Goguen, J.W. Thatcher, and E.G. Wagner. </author> <title> Current Trends in Programming Methodology, volume IV, chapter An Initial Algebra Approach to the specification, correctness, and implementation of abstract data types. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1978. </year>
Reference-contexts: The first condition can be satisfied if, instead of using the class of one-sorted algebras, we use the class of many-sorted algebras <ref> [4, 17] </ref> to model SCA. Unlike one-sorted algebras that model a single data type, many-sorted algebras can model a variety of atomic and composite data types and the operations on those types within a single algebraic framework.
Reference: [18] <author> J.E. Grass. </author> <title> Object-Oriented Design Archaeology with CIA++. </title> <journal> Computing Systems: The Journal of the USENIX Association, </journal> <volume> 5(1) </volume> <pages> 5-67, </pages> <month> Winter </month> <year> 1992. </year>
Reference-contexts: One option for us was to use the relational model, as used in several systems such as OMEGA [28], CIA [8], and CIA++ <ref> [18] </ref>. The advantage of that would have been the availability of a formal query language (based on relational algebra) | our work in developing a query language and a query processor would have been reduced.
Reference: [19] <author> R.H. Guting, R. Zicari, </author> <title> and D.M. Choy. An Algebra for Structured Office Documents. </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 7(4) </volume> <pages> 123-157, </pages> <year> 1989. </year>
Reference-contexts: have also been used in the design of general-purpose query languages for the relational data model [11], the nested relational model [21, 22, 23], the extended relational model [38], the object model [29, 31, 40, 41], and also in the design of a domain-specific query language for structured office documents <ref> [19] </ref>. The benefits of using an algebra as the basis for a query language include the ability to provide formal specifications for query language constructs, the ability to use the algebra itself as a low-level query language, and opportunities for query optimization. <p> The arguments in favor of building a formal query language are compelling. The constructs of a formal language have well-defined semantics. It has been observed in the context of query languages that formal frameworks such as relational algebra [11], relational calculus [42], NST-Algebra <ref> [19] </ref>, etc. have yielded powerful and expressive high-level query languages, and have been argued to be functionally complete within their respective data models. Well-defined semantics has led to clean implementations for query processors. <p> However, a major weakness of relational algebra is that it fails to include basic data types such as integers, strings, etc. as elements of the algebra itself. Consequently, many operations permitted in SQL (aggregate, sort, etc.) do not have well-defined semantics in terms of relational algebra <ref> [19] </ref>. Relational algebra also helps in query optimization by algebraic transformations. Consider the relational algebra expression oe c 1 (oe c 2 (R)). <p> This is equivalent to the operator in NST-Algebra <ref> [19] </ref>, and the extend operator in Schek and Scholl's extended relational algebra [39]. extend produces a subclass of the input class, since the resulting type is a subtype of the input type by specialization (as it has more attributes). syntax: extend &lt;attribute:=algebraic expression&gt; (&lt; objectcollection &gt;) 3.3.5 retrieve Given a collection <p> Schek and Scholl's algebra, 1990 5. Osborn's object algebra 6. Shaw and Zdonik's object algebra 7. PDM algebra 8. Straube and Ozsu's object algebra 9. NST-Algebra 10.Source Code Algebra (SCA) Unlike set algebras, the field of sequence algebras is in its infancy. The NST-algebra (Nested Sequence of Tuples) <ref> [19] </ref> is a many-sorted algebra used as a query language for structured office documents, a domain where nested sequences arise naturally. Documents are modeled as nested sequences of tuples (NST). However, there is no support for extracting subsequences in NST-algebra. and 3) fall within the larger class of set algebras.
Reference: [20] <author> K. Heisler, Y. Kasho, and W.T. Tsai. </author> <title> A Reverse Engineering Model for C Programs. </title> <journal> Information Sciences, </journal> <volume> 68 </volume> <pages> 155-193, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: Another option would have been to use some other representation model such as graphs or abstract syntax trees, as used Rigi [30] and Microscope [2] or an object-based representation as used in REFINE [26] and in <ref> [27, 20] </ref>. However, the problem with those models would have been the lack of a query language with well-defined operators. Either option was somewhat unsatisfactory. Current versions of SCRUPLE and SCAN ended up using an attributed syntax 2 tree representation whereas the ESE system used a relational representation.
Reference: [21] <author> G. Jaeschke. </author> <title> An Algebra of power set type relations. </title> <type> Technical Report TR 82.12.002, </type> <institution> IBM Heidelberg Scientific Center, </institution> <address> Heidelberg, Germany, </address> <year> 1982. </year>
Reference-contexts: The analogy is the use of relational algebra [11] as the foundation for relational database systems. Algebras have also been used in the design of general-purpose query languages for the relational data model [11], the nested relational model <ref> [21, 22, 23] </ref>, the extended relational model [38], the object model [29, 31, 40, 41], and also in the design of a domain-specific query language for structured office documents [19]. <p> For example, a while-statement object has two structural components, the condition (of type expression) and the body (of type statement). Singular objects are analogous to nested relations in the nested relational model <ref> [21, 22, 23] </ref>. Collective objects: These are collections of other objects. For example, the type statement-list represents a sequence of objects of type statement. <p> Query languages for the nested and extended relational models have also been developed by relaxing the first normal form restriction of relational algebra <ref> [21, 22, 23, 38] </ref>. The primary data type in these models is the relation, which is a set of tuples. Inspired by the relational model, some object-oriented database systems have attempted to develop object algebras to serve as a basis for their query languages.
Reference: [22] <author> G. Jaeschke. </author> <title> Nonrecursive Algebra for relations with relation-valued attributes. </title> <type> Technical Report TR 85.03.001, </type> <institution> IBM Heidelberg Scientific Center, </institution> <address> Heidelberg, Germany, </address> <year> 1985. </year>
Reference-contexts: The analogy is the use of relational algebra [11] as the foundation for relational database systems. Algebras have also been used in the design of general-purpose query languages for the relational data model [11], the nested relational model <ref> [21, 22, 23] </ref>, the extended relational model [38], the object model [29, 31, 40, 41], and also in the design of a domain-specific query language for structured office documents [19]. <p> For example, a while-statement object has two structural components, the condition (of type expression) and the body (of type statement). Singular objects are analogous to nested relations in the nested relational model <ref> [21, 22, 23] </ref>. Collective objects: These are collections of other objects. For example, the type statement-list represents a sequence of objects of type statement. <p> Query languages for the nested and extended relational models have also been developed by relaxing the first normal form restriction of relational algebra <ref> [21, 22, 23, 38] </ref>. The primary data type in these models is the relation, which is a set of tuples. Inspired by the relational model, some object-oriented database systems have attempted to develop object algebras to serve as a basis for their query languages.
Reference: [23] <author> G. Jaeschke. </author> <title> Recursive Algebra for relations with relation-valued attributes. </title> <type> Technical Report TR 85.03.002, </type> <institution> IBM Heidelberg Scientific Center, </institution> <address> Heidelberg, Germany, </address> <year> 1985. </year>
Reference-contexts: The analogy is the use of relational algebra [11] as the foundation for relational database systems. Algebras have also been used in the design of general-purpose query languages for the relational data model [11], the nested relational model <ref> [21, 22, 23] </ref>, the extended relational model [38], the object model [29, 31, 40, 41], and also in the design of a domain-specific query language for structured office documents [19]. <p> For example, a while-statement object has two structural components, the condition (of type expression) and the body (of type statement). Singular objects are analogous to nested relations in the nested relational model <ref> [21, 22, 23] </ref>. Collective objects: These are collections of other objects. For example, the type statement-list represents a sequence of objects of type statement. <p> Query languages for the nested and extended relational models have also been developed by relaxing the first normal form restriction of relational algebra <ref> [21, 22, 23, 38] </ref>. The primary data type in these models is the relation, which is a set of tuples. Inspired by the relational model, some object-oriented database systems have attempted to develop object algebras to serve as a basis for their query languages.
Reference: [24] <author> K. Kennedy. </author> <title> Program Flow Analysis: theory and applications, chapter 1. </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Methods are a standard feature of object-oriented data models [13], and can be used to introduce complex and specialized algorithms into the data model. For example, efficient algorithms for data flow analysis such as live variable analysis, available expression analysis, etc. <ref> [24] </ref> can be used to compute the attributes such as "live" (see STATEMENT in Figure 2), which computes the set of live variables for a given statement, and their respective next statements in the "uses" chain.
Reference: [25] <author> B.W. Kernighan and R. Pike. </author> <title> The UNIX Programming Environment. </title> <publisher> Prentice-Hall, </publisher> <year> 1984. </year>
Reference-contexts: Existing sequence manipulation languages provide little or no support for extracting subsequences based on sequence patterns. We have attempted to address this problem by introducing the seq extract operator. syntax: seq extract &lt;pattern&gt;:&lt;boolean expression&gt; (&lt; objectseq &gt;) The &lt; pattern &gt; is a regular expression <ref> [25] </ref>. An example of a pattern could be (while-statement,statement*,if-statement,statement*,while-statement) in which case it would return a subsequence of the input sequence which starts and ends with a while-statement, and has a if-statement somewhere in between.
Reference: [26] <author> G.B. Kotik and L.Z. Markosian. </author> <title> Automating Software Analysis and Testing Using a Program Transformation System. </title> <booktitle> In Proceedings of ACM SIGSOFT, </booktitle> <pages> pages 75-84, </pages> <year> 1989. </year>
Reference-contexts: Another option would have been to use some other representation model such as graphs or abstract syntax trees, as used Rigi [30] and Microscope [2] or an object-based representation as used in REFINE <ref> [26] </ref> and in [27, 20]. However, the problem with those models would have been the lack of a query language with well-defined operators. Either option was somewhat unsatisfactory.
Reference: [27] <author> W. Kozaczynsky, J. Ning, and A. Engberts. </author> <title> Program Concept Recognition and Transformation. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(12) </volume> <pages> 1065-1075, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: Another option would have been to use some other representation model such as graphs or abstract syntax trees, as used Rigi [30] and Microscope [2] or an object-based representation as used in REFINE [26] and in <ref> [27, 20] </ref>. However, the problem with those models would have been the lack of a query language with well-defined operators. Either option was somewhat unsatisfactory. Current versions of SCRUPLE and SCAN ended up using an attributed syntax 2 tree representation whereas the ESE system used a relational representation.
Reference: [28] <author> M.A. Linton. </author> <title> Implementing Relational Views of Programs. </title> <booktitle> In Proc. of ACM SIGSOFT/SIGPLAN Software Engineering Symposium, </booktitle> <month> May </month> <year> 1984. </year> <title> Practical Software Development Environment. </title>
Reference-contexts: Support for extracting relevant information from source code has so far been left either to rudimentary, string searching tools like grep, awk, etc. (which are capable of handling only trivial queries), or to general-purpose database approaches that have limited querying power for the source code domain <ref> [8, 10, 28, 30] </ref>. The need for sophisticated querying tools for reverse engineering has been articulated by Biggerstaff in terms of a "conceptual grep" [3], and also by Chikofsky [9]. <p> One option for us was to use the relational model, as used in several systems such as OMEGA <ref> [28] </ref>, CIA [8], and CIA++ [18]. The advantage of that would have been the availability of a formal query language (based on relational algebra) | our work in developing a query language and a query processor would have been reduced.
Reference: [29] <author> F. Manola and U. Dayal. PDM: </author> <title> an Object-oriented Data Model. </title> <booktitle> In Proc. of Intl. Workshop on Object-oriented Database Systems, </booktitle> <pages> pages 18-25, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: The analogy is the use of relational algebra [11] as the foundation for relational database systems. Algebras have also been used in the design of general-purpose query languages for the relational data model [11], the nested relational model [21, 22, 23], the extended relational model [38], the object model <ref> [29, 31, 40, 41] </ref>, and also in the design of a domain-specific query language for structured office documents [19]. <p> The primary data type in these models is the relation, which is a set of tuples. Inspired by the relational model, some object-oriented database systems have attempted to develop object algebras to serve as a basis for their query languages. Some of these algebras are the PDM algebra <ref> [29] </ref>, Osborn's algebra [31], Straube and Ozsu's algebra [41], and Shaw and Zdonik's algebra [40]. The object algebras treat all their data types as first class objects, and compared to relational algebra, permit considerably more orthogonality between objects and type constructors.
Reference: [30] <author> H.A. Muller, </author> <title> B.D. Corrie, and S.R. Tilley. Spatial and Visual Representations of Software Structures: A model for reverse engineering. </title> <type> Technical Report TR-74.086, </type> <institution> IBM Canada Ltd., </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: Support for extracting relevant information from source code has so far been left either to rudimentary, string searching tools like grep, awk, etc. (which are capable of handling only trivial queries), or to general-purpose database approaches that have limited querying power for the source code domain <ref> [8, 10, 28, 30] </ref>. The need for sophisticated querying tools for reverse engineering has been articulated by Biggerstaff in terms of a "conceptual grep" [3], and also by Chikofsky [9]. <p> Another option would have been to use some other representation model such as graphs or abstract syntax trees, as used Rigi <ref> [30] </ref> and Microscope [2] or an object-based representation as used in REFINE [26] and in [27, 20]. However, the problem with those models would have been the lack of a query language with well-defined operators. Either option was somewhat unsatisfactory.
Reference: [31] <author> S.L. Osborn. </author> <title> Identity, Equality and Query Optimization. </title> <booktitle> In 2nd Intl. Workshop on Object-oriented Database Systems, </booktitle> <pages> pages 346-351. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1988. </year>
Reference-contexts: The analogy is the use of relational algebra [11] as the foundation for relational database systems. Algebras have also been used in the design of general-purpose query languages for the relational data model [11], the nested relational model [21, 22, 23], the extended relational model [38], the object model <ref> [29, 31, 40, 41] </ref>, and also in the design of a domain-specific query language for structured office documents [19]. <p> Tools PARSER FLOW ANALZER STATIC ANALYZER Source Code Base Query Processor SCA EVALUATOR Reverse Engineer User Interface Graphical Query Relational Query SCA EXPRESSION Query Translators Query Optimizer SCA OPTIMIZER SCA DATA MODEL Pattern Query operators in SCA are extended from relational and extended relational algebras, for which optimizations already exist <ref> [31, 39] </ref>. Furthermore, many sequence operators introduced in SCA (such as seq-extract) can be implemented using efficient algorithms developed in our work on the SCRUPLE system. Obviously, the above is only an outline of the ideas required to incorporate the framework in a query system. <p> Inspired by the relational model, some object-oriented database systems have attempted to develop object algebras to serve as a basis for their query languages. Some of these algebras are the PDM algebra [29], Osborn's algebra <ref> [31] </ref>, Straube and Ozsu's algebra [41], and Shaw and Zdonik's algebra [40]. The object algebras treat all their data types as first class objects, and compared to relational algebra, permit considerably more orthogonality between objects and type constructors.
Reference: [32] <author> S. Paul. </author> <title> Theory and Design of Source Code Search Systems. </title> <type> PhD thesis, </type> <institution> University of Michigan, </institution> <year> 1994. </year> <note> In preparation. 19 </note>
Reference-contexts: A complete description of SCA operators can be found in <ref> [32] </ref>. 3.3.1 closure This computes the transitive closure, or reachability graph, given a attribute name.
Reference: [33] <author> S. Paul and A. Prakash. </author> <title> Source Code Retrieval Using Program Patterns. </title> <booktitle> In Proc. of the 5th International Conference on Computer Aided Software Engineering, </booktitle> <pages> pages 95-105, </pages> <year> 1992. </year>
Reference-contexts: Queries can also be based on statement-level structural information in the source code, e.g., looking for patterns (e.g., loops) that fit a programming plan or a cliche <ref> [33, 34, 36] </ref>. Queries may also be based on flow information derived by static analyses such as data-flow and control-flow analyses, e.g., to locate program slices [43], to find the variables whose values are affected by a particular statement, etc.
Reference: [34] <author> S. Paul and A. Prakash. </author> <title> A Framework for Source Code Search Using Program Patterns. </title> <journal> IEEE Transactions on Software Engineering, </journal> <note> 1994. Accepted for publication. </note>
Reference-contexts: Queries can also be based on statement-level structural information in the source code, e.g., looking for patterns (e.g., loops) that fit a programming plan or a cliche <ref> [33, 34, 36] </ref>. Queries may also be based on flow information derived by static analyses such as data-flow and control-flow analyses, e.g., to locate program slices [43], to find the variables whose values are affected by a particular statement, etc. <p> Unfortunately, one of the fundamental problems designers of source code querying systems face is the lack of good underlying models to represent source code information and to express queries. For example, in our previous work on building source code querying tools SCAN [1] and SCRUPLE <ref> [34] </ref>, and earlier in our work on the Evolution Support Environment System (ESE) [35], we found that no satisfactory choice for the underlying model to represent program information was available. <p> Several key components such as parser and query processor for handling sequences have been built and were tested in the SCRUPLE system for pattern matching. Performance results for operating on sequences were promising and are available in <ref> [34] </ref>. 6 Comparison of SCA with other Query Algebras The most well-known query algebra is the relational algebra. Query languages for the nested and extended relational models have also been developed by relaxing the first normal form restriction of relational algebra [21, 22, 23, 38].
Reference: [35] <author> C.V. Ramamoorthy, Y. Usuda, A. Prakash, and W.T. Tsai. </author> <title> The Evolution Support Environment System. </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 1225-1234, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: For example, in our previous work on building source code querying tools SCAN [1] and SCRUPLE [34], and earlier in our work on the Evolution Support Environment System (ESE) <ref> [35] </ref>, we found that no satisfactory choice for the underlying model to represent program information was available. One option for us was to use the relational model, as used in several systems such as OMEGA [28], CIA [8], and CIA++ [18].
Reference: [36] <author> C. Rich and R. Waters. </author> <title> The Programmer's Apprentice. </title> <publisher> Addison-Wesley, </publisher> <address> Baltimore, Maryland, </address> <year> 1990. </year>
Reference-contexts: Queries can also be based on statement-level structural information in the source code, e.g., looking for patterns (e.g., loops) that fit a programming plan or a cliche <ref> [33, 34, 36] </ref>. Queries may also be based on flow information derived by static analyses such as data-flow and control-flow analyses, e.g., to locate program slices [43], to find the variables whose values are affected by a particular statement, etc.
Reference: [37] <author> J. Richardson. </author> <title> Supporting Lists in a Data Model. </title> <booktitle> In Proc. of the 18th VLDB Conference, </booktitle> <pages> pages 127-138, </pages> <year> 1992. </year>
Reference-contexts: SCA is essentially an algebra of objects. We have used and extended operators from pre-existing object algebras for set operations, generalizing them to operate on sequences wherever possible, and proposed appropriate operators for sequences. Operators for sequences have only recently begun to be proposed in literature <ref> [15, 37] </ref>. We have introduced seq extract, a powerful new operator for sequences which uses regular expressions as the basis for extracting subsequences. SCA offers a unified approach to querying collections, whether they be sets or sequences. <p> evaluates to TRUE. syntax: exists &lt;boolean expression&gt; (&lt; objectcollection &gt;) This is a derived operator, whose semantics is equivalent to the truth of the expression: size of (select &lt;boolean expression&gt; (&lt; objectcollection &gt;)) 6= 0. 3.3.10 seq extract The choice of appropriate sequence operators is a topic of current research <ref> [37] </ref>. Existing sequence manipulation languages provide little or no support for extracting subsequences based on sequence patterns. We have attempted to address this problem by introducing the seq extract operator. syntax: seq extract &lt;pattern&gt;:&lt;boolean expression&gt; (&lt; objectseq &gt;) The &lt; pattern &gt; is a regular expression [25].
Reference: [38] <author> H.J. Schek and M.H. Scholl. </author> <title> An Algebra for the relational model with relation-valued attributes. </title> <journal> Information Systems, </journal> <volume> 11 </volume> <pages> 137-147, </pages> <year> 1986. </year>
Reference-contexts: The analogy is the use of relational algebra [11] as the foundation for relational database systems. Algebras have also been used in the design of general-purpose query languages for the relational data model [11], the nested relational model [21, 22, 23], the extended relational model <ref> [38] </ref>, the object model [29, 31, 40, 41], and also in the design of a domain-specific query language for structured office documents [19]. <p> Query languages for the nested and extended relational models have also been developed by relaxing the first normal form restriction of relational algebra <ref> [21, 22, 23, 38] </ref>. The primary data type in these models is the relation, which is a set of tuples. Inspired by the relational model, some object-oriented database systems have attempted to develop object algebras to serve as a basis for their query languages.
Reference: [39] <author> H.J. Schek and M.H. Scholl. </author> <title> A Relational Object Model. </title> <booktitle> In 3rd Intl. Conference on Database Theory, </booktitle> <pages> pages 89-105. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: This is equivalent to the operator in NST-Algebra [19], and the extend operator in Schek and Scholl's extended relational algebra <ref> [39] </ref>. extend produces a subclass of the input class, since the resulting type is a subtype of the input type by specialization (as it has more attributes). syntax: extend &lt;attribute:=algebraic expression&gt; (&lt; objectcollection &gt;) 3.3.5 retrieve Given a collection of objects, this operator retrieves the specified attribute (field) for each object. <p> Tools PARSER FLOW ANALZER STATIC ANALYZER Source Code Base Query Processor SCA EVALUATOR Reverse Engineer User Interface Graphical Query Relational Query SCA EXPRESSION Query Translators Query Optimizer SCA OPTIMIZER SCA DATA MODEL Pattern Query operators in SCA are extended from relational and extended relational algebras, for which optimizations already exist <ref> [31, 39] </ref>. Furthermore, many sequence operators introduced in SCA (such as seq-extract) can be implemented using efficient algorithms developed in our work on the SCRUPLE system. Obviously, the above is only an outline of the ideas required to incorporate the framework in a query system.
Reference: [40] <author> G.M. Shaw and S.B. Zdonik. </author> <title> An Object-oriented Query Algebra. </title> <journal> Bulletin of IEEE technical committee on Data Engineering, </journal> <volume> 12(3) </volume> <pages> 29-36, </pages> <year> 1989. </year>
Reference-contexts: The analogy is the use of relational algebra [11] as the foundation for relational database systems. Algebras have also been used in the design of general-purpose query languages for the relational data model [11], the nested relational model [21, 22, 23], the extended relational model [38], the object model <ref> [29, 31, 40, 41] </ref>, and also in the design of a domain-specific query language for structured office documents [19]. <p> Inspired by the relational model, some object-oriented database systems have attempted to develop object algebras to serve as a basis for their query languages. Some of these algebras are the PDM algebra [29], Osborn's algebra [31], Straube and Ozsu's algebra [41], and Shaw and Zdonik's algebra <ref> [40] </ref>. The object algebras treat all their data types as first class objects, and compared to relational algebra, permit considerably more orthogonality between objects and type constructors. Object algebras differ from one another in the range of their supported types and, more importantly, in their operators.
Reference: [41] <author> D.D. </author> <title> Straube and M.T. Ozsu. Queries and Query processing in Object-oriented Database Systems. </title> <journal> ACM Transactions on Information Systems, </journal> <volume> 8(4), </volume> <month> October </month> <year> 1990. </year>
Reference-contexts: The analogy is the use of relational algebra [11] as the foundation for relational database systems. Algebras have also been used in the design of general-purpose query languages for the relational data model [11], the nested relational model [21, 22, 23], the extended relational model [38], the object model <ref> [29, 31, 40, 41] </ref>, and also in the design of a domain-specific query language for structured office documents [19]. <p> Inspired by the relational model, some object-oriented database systems have attempted to develop object algebras to serve as a basis for their query languages. Some of these algebras are the PDM algebra [29], Osborn's algebra [31], Straube and Ozsu's algebra <ref> [41] </ref>, and Shaw and Zdonik's algebra [40]. The object algebras treat all their data types as first class objects, and compared to relational algebra, permit considerably more orthogonality between objects and type constructors.
Reference: [42] <author> J.D. Ullman. </author> <title> Principles of Database Systems. </title> <publisher> Computer Science Press International, </publisher> <address> Rockville, Mary-land, </address> <year> 1990. </year>
Reference-contexts: The arguments in favor of building a formal query language are compelling. The constructs of a formal language have well-defined semantics. It has been observed in the context of query languages that formal frameworks such as relational algebra [11], relational calculus <ref> [42] </ref>, NST-Algebra [19], etc. have yielded powerful and expressive high-level query languages, and have been argued to be functionally complete within their respective data models. Well-defined semantics has led to clean implementations for query processors. <p> Codd has shown that all information stored using relations can be accessed using the five primitive operators of relational algebra. In that sense, the relational algebra is query-complete [11]. Relational algebra has also been shown to be equivalent to relational calculus <ref> [42] </ref>. Relational algebra (or its equivalent relational calculus) forms the basis of a wide variety of relational database query languages such as SQL, QUEL, ISBL, and QBE [42]. <p> In that sense, the relational algebra is query-complete [11]. Relational algebra has also been shown to be equivalent to relational calculus <ref> [42] </ref>. Relational algebra (or its equivalent relational calculus) forms the basis of a wide variety of relational database query languages such as SQL, QUEL, ISBL, and QBE [42]. However, a major weakness of relational algebra is that it fails to include basic data types such as integers, strings, etc. as elements of the algebra itself. Consequently, many operations permitted in SQL (aggregate, sort, etc.) do not have well-defined semantics in terms of relational algebra [19]. <p> Many such identities that arise in relational algebra are used in practice to optimize queries <ref> [42] </ref>. 3.2 The Domain of Source Code 3.2.1 Many Data Types An obvious difference between relational algebra and an algebra for source code is that the latter must handle many different kinds of data types. We will concern ourselves with source code written in C. <p> In addition to attributes that are precomputed or computed on-the-fly using methods, new attributes can be added to objects during a query. Such relationships can be thought of as derived attributes, and their computation should be part of a view generation process <ref> [42] </ref>.
Reference: [43] <author> M. Weiser. </author> <title> Program Slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 10(4) </volume> <pages> 352-357, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: Queries may also be based on flow information derived by static analyses such as data-flow and control-flow analyses, e.g., to locate program slices <ref> [43] </ref>, to find the variables whose values are affected by a particular statement, etc. Finally, a reverse engineer may need to make queries that use both structural information as well as program flow information.
Reference: [44] <author> E. Yourdon. </author> <title> RE-3. </title> <journal> American Programmer, </journal> <volume> 2(4) </volume> <pages> 3-10, </pages> <month> April </month> <year> 1989. </year> <month> 20 </month>
Reference-contexts: Given the current state-of-art in reverse engineering technology, it is felt that reverse engineering of real systems can at best be automated 50 percent, and the rest must be by human participation <ref> [44] </ref>. This acceptance of the critical role that must be played by a human reverse engineer has led to research in software tools that can assist or support the human in this task.
References-found: 44

