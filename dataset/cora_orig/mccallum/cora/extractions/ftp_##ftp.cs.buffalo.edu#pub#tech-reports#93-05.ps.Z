URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/93-05.ps.Z
Refering-URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/README.html
Root-URL: 
Title: On Using Oracles That Compute Values  
Author: Stephen Fenner Steve Homer Mitsunori Ogiwara Alan L. Selman 
Date: February 17, 1993  
Abstract: This paper focuses on complexity classes of partial functions that are computed in polynomial time with oracles in NPMV, the class of all multivalued partial functions that are computable nondeterministically in polynomial time. Concerning deterministic polynomial-time reducibilities, it is shown that 
Abstract-found: 1
Intro-found: 1
Reference: [Bei88] <author> R. Beigel. </author> <title> NP-hard sets are P-superterse unless R = NP. </title> <type> Technical Report 88-04, </type> <institution> Department of Computer Science, The Johns Hopkins University, </institution> <year> 1988. </year>
Reference-contexts: To wit, the inverse of every polynomial time honest function belongs to NPMV, and the inverse of every one-one polynomial time honest function belongs to NPSV. The class of partial functions with oracles in NP, namely, PF NP has been well-studied <ref> [Kre88, Bei88] </ref>, as have been the corresponding class of partial functions that can be computed nonadaptively with oracles in NP, viz.
Reference: [Bei91] <author> R. Beigel. </author> <title> Bounded queries to SAT and the Boolean hierarchy. </title> <journal> Theor. Computer Science, </journal> <volume> 84(2) </volume> <pages> 199-223, </pages> <year> 1991. </year>
Reference-contexts: PF NP tt [Sel92], and the classes of partial functions that are obtained by limiting the number of queries to some value k 1, namely, PF NP [k] and PF NP [k] tt <ref> [Bei91] </ref>. A rich body of results is known about these classes. Here we raise the question, "What is the difference between computing with an oracle in NPMV versus an oracle in NP?" The answer is not obvious. <p> Thus, 2 c is identical to class containment and c is identical to class inclusion for the classes we have defined. Proposition 3 If F satifies property 2 and G satifies property 1, then F = sv G= sv $ F G. Beigel <ref> [Bei91] </ref> proved that for all k 1, PF NP [k] = sv PF NP [2 k 1] tt = sv . Using Proposi tion 3, it follows that PF NP [k] PF NP [2 k 1] tt . <p> This observation is explored by Chen and Toda [CT91] and by Wareham [War92]. 3 Bounded Query Classes General techniques developed in this section are reminiscent of the "mind-change" technique of <ref> [Bei91, WW85, BH88] </ref>. First we compare PF NPMV [k] and PF NPMV [m] tt . The following two propositions are useful. Proposition 4 Let t 2 PF. Let f be in PF NPMV be computed by a deterministic oracle Turing machine transducer M with g 2 NPMV as the oracle. <p> Theorem 3 For each k 1, NPMV ffi PF NP [k] = NPMV ffi PF NP [2 k 1] Proof. NPMV ffi PF NP [k] NPMV ffi PF NP [2 k 1] tt follows immediately from PF NP [k] PF tt <ref> [Bei91] </ref>. (Recall the comment that follows Proposition 3.) Now we show NPMV ffi PF NP [2 k 1] tt NPMV ffi PF NP [k] . Let f = g ffi h 2 NPMV ffi PF tt with g 2 NPMV and h 2 PF NP [2 k 1] tt .
Reference: [BH88] <author> S. Buss and L. Hay. </author> <title> On truth table reducibility to SAT and the difference hierarchy over NP. </title> <booktitle> In Procs. of the 3rd Annual Conference on Structure in Complexity Theory, </booktitle> <pages> pages 224-233. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1988. </year>
Reference-contexts: This observation is explored by Chen and Toda [CT91] and by Wareham [War92]. 3 Bounded Query Classes General techniques developed in this section are reminiscent of the "mind-change" technique of <ref> [Bei91, WW85, BH88] </ref>. First we compare PF NPMV [k] and PF NPMV [m] tt . The following two propositions are useful. Proposition 4 Let t 2 PF. Let f be in PF NPMV be computed by a deterministic oracle Turing machine transducer M with g 2 NPMV as the oracle. <p> A proof similar to that of Theorem 3 yields NPMV ffi PF NP [log] = NPMV ffi PF NP tt . Thus (1) holds. Inclusion (2) follows by a straightforward simulation, and (3) follows by adapting the proof of Theorem 2 (i). Using the technique of Buss and Hay <ref> [BH88] </ref>, for any set A, logarithmically many adaptive queries to A can be simulated by polynomially many nonadaptive queries to A, so PF NP [log] = sv PF NP tt = sv . Thus, NPMV ffi (PF NP [log] = sv ) NPMV ffi (PF NP tt = sv ).
Reference: [BLS84] <author> R. Book, T. Long, and A. Selman. </author> <title> Quantitative relativizations of complexity classes. </title> <journal> SIAM J. Comput., </journal> <volume> 13(3) </volume> <pages> 461-487, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: A function f belongs to NPMV if and only if it is polynomially length-bounded and graph (f ) belongs to NP. The domain of every function in NPMV belongs to NP. These definitions originate in <ref> [BLS84] </ref>. Now we describe oracle Turing machines with oracles that compute partial functions. For the moment, we assume that the oracle is a single-valued partial function. Let ? be a symbol not belonging to the finite alphabet .
Reference: [CGH + 88] <author> J. Cai, T. Gundermann, J. Hartmanis, L. Hemachandra, V. Sewelson, K. Wag-ner, and G. Wechsung. </author> <title> The boolean hierarchy I: Structural properties. </title> <journal> SIAM J. Comput., </journal> <volume> 17(6) </volume> <pages> 1232-1252, </pages> <year> 1988. </year>
Reference-contexts: Then we can easily construct a machine that computes f by making k queries to h and m queries to g. Therefore, f 2 PF NPMV [k+m] tt . This proves the lemma. 2 The Boolean hierarchy over NP is defined by [WW85] and has been studied extensively in <ref> [CGH + 88, CGH + 89, CH86, Kad88] </ref>. We denote the k-th level of the Boolean hierarchy as NP (k). By definition, 1. NP (1) = NP, and 2. for every k 2, NP (k) = NP NP (k 1).
Reference: [CGH + 89] <author> J. Cai, T. Gundermann, J. Hartmanis, L. Hemachandra, V. Sewelson, K. Wag-ner, and G. Wechsung. </author> <title> The boolean hierarchy II: </title> <journal> Applications. SIAM J. Comput., </journal> <volume> 18(1) </volume> <pages> 95-111, </pages> <year> 1989. </year>
Reference-contexts: Then we can easily construct a machine that computes f by making k queries to h and m queries to g. Therefore, f 2 PF NPMV [k+m] tt . This proves the lemma. 2 The Boolean hierarchy over NP is defined by [WW85] and has been studied extensively in <ref> [CGH + 88, CGH + 89, CH86, Kad88] </ref>. We denote the k-th level of the Boolean hierarchy as NP (k). By definition, 1. NP (1) = NP, and 2. for every k 2, NP (k) = NP NP (k 1).
Reference: [CH86] <author> J. Cai and L. Hemachandra. </author> <title> The Boolean hierarchy: Hardware over NP. In Structure in Complexity Theory, </title> <booktitle> Lecture Notes in Computer Science 223, </booktitle> <pages> pages 105-124, </pages> <address> Berlin, 1986. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Then we can easily construct a machine that computes f by making k queries to h and m queries to g. Therefore, f 2 PF NPMV [k+m] tt . This proves the lemma. 2 The Boolean hierarchy over NP is defined by [WW85] and has been studied extensively in <ref> [CGH + 88, CGH + 89, CH86, Kad88] </ref>. We denote the k-th level of the Boolean hierarchy as NP (k). By definition, 1. NP (1) = NP, and 2. for every k 2, NP (k) = NP NP (k 1).
Reference: [CT91] <author> Z. Chen and S. </author> <title> Toda. On the complexity of computing optimal solutions. </title> <journal> International Journal of Foundations of Computer Science, </journal> <volume> 2 </volume> <pages> 207-220, </pages> <year> 1991. </year>
Reference-contexts: We should note that several of the classes we investigate here seem to capture the complexity of finding witnesses to NP-optimization problems. This observation is explored by Chen and Toda <ref> [CT91] </ref> and by Wareham [War92]. 3 Bounded Query Classes General techniques developed in this section are reminiscent of the "mind-change" technique of [Bei91, WW85, BH88]. First we compare PF NPMV [k] and PF NPMV [m] tt . The following two propositions are useful. Proposition 4 Let t 2 PF.
Reference: [Kad88] <author> J. Kadin. </author> <title> The polynomial time hierarchy collapses if the Boolean hierarchy collapses. </title> <journal> SIAM Journal on Computing, </journal> <volume> 17(6) </volume> <pages> 1263-1282, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: Then we can easily construct a machine that computes f by making k queries to h and m queries to g. Therefore, f 2 PF NPMV [k+m] tt . This proves the lemma. 2 The Boolean hierarchy over NP is defined by [WW85] and has been studied extensively in <ref> [CGH + 88, CGH + 89, CH86, Kad88] </ref>. We denote the k-th level of the Boolean hierarchy as NP (k). By definition, 1. NP (1) = NP, and 2. for every k 2, NP (k) = NP NP (k 1). <p> By definition, 1. NP (1) = NP, and 2. for every k 2, NP (k) = NP NP (k 1). The Boolean hierarchy over NP, denoted by BH is the union of all NP (k), k 1. Kadin <ref> [Kad88] </ref> proved that the Boolean hierarchy collapses only if the polynomial-time hierarchy collapses. Theorem 7 Let k 1. If PF NPMV [k+1] = PF NPMV [k] , then BH collapses to its 2 k -th level. Proof. Suppose that PF NPMV [k+1] = PF NPMV [k] .
Reference: [Kre88] <author> M. Krentel. </author> <title> The complexity of optimization problems. </title> <journal> J. Computer Systems Sci., </journal> <volume> 36 </volume> <pages> 490-509, </pages> <year> 1988. </year> <month> 30 </month>
Reference-contexts: To wit, the inverse of every polynomial time honest function belongs to NPMV, and the inverse of every one-one polynomial time honest function belongs to NPSV. The class of partial functions with oracles in NP, namely, PF NP has been well-studied <ref> [Kre88, Bei88] </ref>, as have been the corresponding class of partial functions that can be computed nonadaptively with oracles in NP, viz. <p> Despite the similarity in appearance, the difference hierarchy over NPMV is probably much stronger than both the difference hierarchy over NP and the bounded query hierarchy over NPMV. For example, it is well-known that maxsat is complete for PF NP = PF NPMV <ref> [Kre88] </ref>. Nonetheless, we have the following: Proposition 6 maxsat 2 NPMV (2). Proof. Let f 2 NPMV be the function that maps x to y if and only if there is a z &gt; y such that z is a satisfying assignment for x. <p> Since P NP [k] NP (2 k ), BH collapses to its 2 k -th level. 2 Recall from the Introduction that it is not known whether sat belongs to PF NPSV [k] for any k. We know that maxsat is complete for PF NPMV <ref> [Kre88] </ref>. Thus, by Corollary 5, if, for any k 1, maxsat 2 PF NPSV [k] , then the Boolean and polynomial hierarchies collapse. Although PF NPMV [log] = PF NPMV tt (Theorem 9), we do not know whether PF NPSV [log] and PF NPSV tt are equal.
Reference: [KSW87] <author> J. Kobler, U. Schoning, and K. Wagner. </author> <title> The difference and truth-table hierar-chies for NP. </title> <journal> Theoretical Informatics and Applications (RAIRO), </journal> <volume> 21 </volume> <pages> 419-435, </pages> <year> 1987. </year>
Reference-contexts: Proof. Suppose that PF NPMV [k+1] = PF NPMV [k] . By Lemma 1 and Theorem 4, for every m &gt; k, PF NPMV [m] PF NPMV [k] = PF NPMV [2 k 1] tt . So, by Theorem 5 and results by Kobler, Schoning, and Wagner <ref> [KSW87] </ref>, we have, for every m &gt; k, P NP [m] = P NP [2 k 1] NP (2 k ). Thus, BH = NP (2 k ). 2 The following theorem is proved in a similar manner. Theorem 8 Let k 1. <p> Proof. Suppose that PF NPMV [k+1] tt = PF NPMV [k] tt . By Lemma 2, for every m &gt; k, PF NPMV [m] tt PF NPMV [k] tt . So, by Theorem 6 and results by Kobler, Schoning, and Wagner <ref> [KSW87] </ref>, we have, for every m &gt; k, P NP [m] NP [k] tt NP (k+1). Thus, BH = NP (k+1). 2 Analogous to the theorems stated so far, the following theorems hold for reduction classes that make logarithmic many queries to partial functions in NPMV.
Reference: [NOS93] <author> A. Naik, M. Ogiwara, and A. Selman. </author> <title> P-selective sets, and reducing search to decision vs. self-reducibility. </title> <booktitle> In Procs. of the 8th Annual Conference on Structure in Complexity Theory. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: that PF NPSV PF NP tt , and it is an open question whether sat 2 c NPSV or whether sat 2 c PF NP tt . (Watanabe and Toda [WT91] have shown that sat 2 c PF NP tt relative to a random oracle, and Naik, Ogiwara, and Selman <ref> [NOS93] </ref> have obtained an oracle relative to which sat 62 c PF NP tt .) We will consider classes of the form PF NPSV [k] and PF NPSV [k] tt , where k 1, and we will show that the adaptive and the nonadaptive classes form proper hierarchies unless the Boolean <p> After x is found, 3 Naik, Ogiwara, and Selman <ref> [NOS93] </ref> have recently proved that there is an oracle A relative to which NPMV 6 c PF NP tt .
Reference: [Sel92] <author> A. Selman. </author> <title> A taxonomy of complexity classes of functions. </title> <institution> J. Comput. Systems Sci., </institution> <year> 1992. </year> <note> In press. </note>
Reference-contexts: The class of partial functions with oracles in NP, namely, PF NP has been well-studied [Kre88, Bei88], as have been the corresponding class of partial functions that can be computed nonadaptively with oracles in NP, viz. PF NP tt <ref> [Sel92] </ref>, and the classes of partial functions that are obtained by limiting the number of queries to some value k 1, namely, PF NP [k] and PF NP [k] tt [Bei91]. A rich body of results is known about these classes. <p> It is well-known that sat 2 c PF if and only if NPMV c PF if and only if P = NP <ref> [Sel92] </ref>. Thus, one does not expect that sat 2 c PF. Is sat computable in some larger single-valued class of partial functions? It is shown in [Sel92] that PF NPSV PF NP tt , and it is an open question whether sat 2 c NPSV or whether sat 2 c PF <p> It is well-known that sat 2 c PF if and only if NPMV c PF if and only if P = NP <ref> [Sel92] </ref>. Thus, one does not expect that sat 2 c PF. Is sat computable in some larger single-valued class of partial functions? It is shown in [Sel92] that PF NPSV PF NP tt , and it is an open question whether sat 2 c NPSV or whether sat 2 c PF NP tt . (Watanabe and Toda [WT91] have shown that sat 2 c PF NP tt relative to a random oracle, and Naik, Ogiwara, and Selman <p> to g in polynomial time, f P T g, if for some deterministic oracle transducer M , for every single-valued refinement g 0 of g, M [g 0 ] is a single-valued refinement of f . 1 1 A notion of polynomial-time Turing reducibility between partial functions is defined in <ref> [Sel92] </ref>. It is important to note that the definition given here is different than the one in [Sel92]. Here the oracle 5 Proposition 1 Polynomial time Turing reducibility, P T , is a reflexive and transitive relation over the class of all partial multivalued functions. <p> for every single-valued refinement g 0 of g, M [g 0 ] is a single-valued refinement of f . 1 1 A notion of polynomial-time Turing reducibility between partial functions is defined in <ref> [Sel92] </ref>. It is important to note that the definition given here is different than the one in [Sel92]. Here the oracle 5 Proposition 1 Polynomial time Turing reducibility, P T , is a reflexive and transitive relation over the class of all partial multivalued functions. Let F be a class of partial multivalued functions. <p> Readers are free to interpret references to PF NP and PF NP tt with "knows" when a query is not in its domain. In the earlier definition, this is not the case. The authors recommend that the reducibility defined in <ref> [Sel92] </ref> should in the future be denoted as PP T , which is the common notation for reductions between promise problems. We make this recommendation because conceptually and technically this reducibility between functions is equivalent to a promise problem reduction. Also, we note that the reducibility defined in [Sel92] is not <p> defined in <ref> [Sel92] </ref> should in the future be denoted as PP T , which is the common notation for reductions between promise problems. We make this recommendation because conceptually and technically this reducibility between functions is equivalent to a promise problem reduction. Also, we note that the reducibility defined in [Sel92] is not useful for our purposes here. <p> In the latter case, f (x) maps to z by the definition of f 00 . In the former case, V (x; b (x)) must output 1z, and thus f (x) maps to z. 2 It is shown in <ref> [Sel92] </ref> that PF NP [log] 6= PF NP tt unless P = FewP and R = NP. 2 The next theorem is interesting because it implies that composing on the left with NPMV is enough to absorb the difference between the two reduction classes. <p> We see in these theorems a different behavior when computing partial multivalued functions with bounded queries to NPMV than when computing partial functions with bounded queries to NP. To wit, in contrast to the following results, <ref> [Sel92] </ref> shows that PF NP [log] = PF NP tt only if P = FewP and R = NP. <p> In particular, whereas, PF NPSV tt = PF NP tt (Proposition 9) is easy 29 to prove, apparently PF NPSV [log] and PF NP [log] are not equal, for NPSV PF NPSV [1] PF NPSV [log] , and it is shown in <ref> [Sel92] </ref> that NPSV PF NP [log] implies P = UP. Thus, PF NPSV [log] PF NP [log] implies P = UP. Similarly, it follows from [Sel92] that PF NPMV [1] PF NP [log] implies P = NP. <p> apparently PF NPSV [log] and PF NP [log] are not equal, for NPSV PF NPSV [1] PF NPSV [log] , and it is shown in <ref> [Sel92] </ref> that NPSV PF NP [log] implies P = UP. Thus, PF NPSV [log] PF NP [log] implies P = UP. Similarly, it follows from [Sel92] that PF NPMV [1] PF NP [log] implies P = NP.
Reference: [War92] <author> H. Wareham. </author> <title> On the comptutational complexity of inferring evolutionary trees. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, Memorial University of Newfoundland, </institution> <year> 1992. </year>
Reference-contexts: We should note that several of the classes we investigate here seem to capture the complexity of finding witnesses to NP-optimization problems. This observation is explored by Chen and Toda [CT91] and by Wareham <ref> [War92] </ref>. 3 Bounded Query Classes General techniques developed in this section are reminiscent of the "mind-change" technique of [Bei91, WW85, BH88]. First we compare PF NPMV [k] and PF NPMV [m] tt . The following two propositions are useful. Proposition 4 Let t 2 PF.
Reference: [WT91] <author> O. Watanabe and S. </author> <title> Toda. Structural analysis of the complexity of inverse functions. </title> <journal> Math. Systems Theory, </journal> <note> 1991. In Press. </note>
Reference-contexts: Is sat computable in some larger single-valued class of partial functions? It is shown in [Sel92] that PF NPSV PF NP tt , and it is an open question whether sat 2 c NPSV or whether sat 2 c PF NP tt . (Watanabe and Toda <ref> [WT91] </ref> have shown that sat 2 c PF NP tt relative to a random oracle, and Naik, Ogiwara, and Selman [NOS93] have obtained an oracle relative to which sat 62 c PF NP tt .) We will consider classes of the form PF NPSV [k] and PF NPSV [k] tt ,
Reference: [WW85] <author> G. Wechsung and K. Wagner. </author> <title> On the boolean closure of NP. </title> <booktitle> In Proc. International Conf. on Fundamentals of Computation Theory, Lecture Notes in Computer Science 199, </booktitle> <pages> pages 485-493. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year> <month> 31 </month>
Reference-contexts: This observation is explored by Chen and Toda [CT91] and by Wareham [War92]. 3 Bounded Query Classes General techniques developed in this section are reminiscent of the "mind-change" technique of <ref> [Bei91, WW85, BH88] </ref>. First we compare PF NPMV [k] and PF NPMV [m] tt . The following two propositions are useful. Proposition 4 Let t 2 PF. Let f be in PF NPMV be computed by a deterministic oracle Turing machine transducer M with g 2 NPMV as the oracle. <p> Then we can easily construct a machine that computes f by making k queries to h and m queries to g. Therefore, f 2 PF NPMV [k+m] tt . This proves the lemma. 2 The Boolean hierarchy over NP is defined by <ref> [WW85] </ref> and has been studied extensively in [CGH + 88, CGH + 89, CH86, Kad88]. We denote the k-th level of the Boolean hierarchy as NP (k). By definition, 1. NP (1) = NP, and 2. for every k 2, NP (k) = NP NP (k 1).
References-found: 16

