URL: ftp://ftp.cs.brown.edu/pub/techreports/92/cs92-06.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-92-06.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> S.W. Bent, D.D. Sleator, and R.E. Tarjan, </author> <title> "Biased Search Trees," </title> <journal> SIAM J. Computing, </journal> <volume> Vol. 14, </volume> <pages> 545-568, </pages> <year> 1985. </year>
Reference-contexts: We simulate by removing edge (b; d) and then inserting edge (a; c). Next, we remove the triangulation edges of S 0 with a sequence of O (n) removeedge operations. 2 In the following, we shall make use of biased binary trees <ref> [1] </ref>, which are binary search trees whose leaves store weighted items. Let w be the sum of all weights. <p> the depth of a leaf with weight w i is at most log (w=w i ) + 2, and each of the following update operations can be done in O (log w) time: change of the weight of an item, insertion/deletion of an item, and split/splice of two biased trees <ref> [1] </ref>. 3 3 Data Structure for a Fixed Set of Y-Coordinates In this section we study a restricted version of dynamic point location where all vertices of a monotone subdivision S lie on a fixed set L of N horizontal lines.
Reference: [2] <author> S.W. Cheng and R. Janardan, </author> <title> "New Results on Dynamic Planar Point Location," </title> <type> Technical Report TR 90-13, </type> <institution> Dept. of Computer Science, Univ. of Minnesota, </institution> <year> 1990. </year> <note> (Prelim. version: 31st FOCS, 96-105, </note> <year> 1990.) </year>
Reference-contexts: Finally, by setting b (n) = n * , we obtain O (log n) query time and O (n * log n) update time [22]. Cheng and Janardan <ref> [2] </ref> present two methods for dynamic planar point-location. Their first method achieves O (log 2 n) query time, O (log n) time for inserting/deleting a vertex, and O (k log n) time for inserting/deleting a chain of k edges. <p> The space requirement is O (n log n). This is the first fully dynamic point location data structure for monotone subdivisions that achieves optimal query time and polylogarithmic update time. To compare our result with previous ones, we note that * The fully dynamic data structures of Cheng-Janardan <ref> [2] </ref> and Goodrich-Tamassia [8] have slower query time but faster update time and less space requirement (both by a log n factor). * The fully dynamic data structure of Preparata-Tamassia [19] has the same performance bounds but is limited to convex subdivisions and to a fixed set of lines on which
Reference: [3] <author> Y.-J. Chiang and R. Tamassia, </author> <title> "Dynamic Algorithms in Computational Geometry," </title> <type> Technical Report CS 91-24, </type> <institution> Dept. of Computer Science, Brown Univ., </institution> <year> 1991. </year>
Reference-contexts: Research on dynamic algorithms for geometric problems has received increasing attention in the last years. A survey on the subject appears in <ref> [3] </ref>. Previous results on dynamic point location data structures, where queries are intermixed with update operations that insert or delete vertices and edges, are summarized below. In the following, we denote with n the current size of the subdivision. Also, time complexity bounds are worst-case unless otherwise stated.
Reference: [4] <author> H. Edelsbrunner, L.J. Guibas, and J. Stolfi, </author> <title> "Optimal Point Location in a Monotone Subdivision," </title> <journal> SIAM J. Computing, </journal> <volume> Vol. 15, </volume> <pages> 317-340, </pages> <year> 1986. </year>
Reference-contexts: In the static case, where S is fixed, there are optimal techniques that achieve O (log n) query time using O (n log n) preprocessing time and O (n) space <ref> [4, 9, 21] </ref>, where n is the size of S. Research on dynamic algorithms for geometric problems has received increasing attention in the last years. A survey on the subject appears in [3].
Reference: [5] <author> O. Fries, </author> <title> "Zerlegung einer planaren Unterteilung der Ebene und ihre Anwendungen," M.S. </title> <type> thesis, </type> <institution> Inst. Angew. Math. and Inform., Univ. Saarlandes, Saarbrcken, Germany, </institution> <year> 1985. </year>
Reference-contexts: The update operations supported are inserting and deleting edges and isolated vertices. This method uses O (n log n) space and has O (log 2 n) query and update times (amortized for vertex insertion/deletion). Fries, Mehlhorn, and Naeher <ref> [5, 6] </ref> present a data structure for general subdivisions with O (n) space, O (log 2 n) query time, and O (log 4 n) amortized update time, using an approach based on the static chain-method [10]. The update operations supported are inserting and deleting edges and isolated vertices.
Reference: [6] <author> O. Fries, K. Mehlhorn, and S. Naeher, </author> <title> "Dynamization of Geometric Data Structures," </title> <booktitle> Proc. (1st) ACM Symp. on Computational Geometry, </booktitle> <pages> 168-176, </pages> <year> 1985. </year>
Reference-contexts: The update operations supported are inserting and deleting edges and isolated vertices. This method uses O (n log n) space and has O (log 2 n) query and update times (amortized for vertex insertion/deletion). Fries, Mehlhorn, and Naeher <ref> [5, 6] </ref> present a data structure for general subdivisions with O (n) space, O (log 2 n) query time, and O (log 4 n) amortized update time, using an approach based on the static chain-method [10]. The update operations supported are inserting and deleting edges and isolated vertices.
Reference: [7] <author> M. Garey, D.S. Johnson, F.P. Preparata, and R. E. Tarjan, </author> <title> "Triangulating a Simple Polygon," </title> <journal> Information Processing Letters, </journal> <volume> Vol. 7, No. 4, </volume> <pages> 175-180, </pages> <year> 1978. </year>
Reference-contexts: Also, such a sequence can be computed from S in O (n) time. Proof: Let S 0 be a triangulation of S, which can be computed in O (n) time <ref> [7] </ref>.
Reference: [8] <author> M.T. Goodrich and R. Tamassia, </author> <title> "Dynamic Trees and Dynamic Point Location," </title> <booktitle> Proc. 23rd ACM Symp. on Theory of Computing, </booktitle> <pages> 523-533, </pages> <year> 1991. </year>
Reference-contexts: Both methods use O (n) space and are based on a search strategy derived from priority search trees [11]. As emphasized by the authors, such methods are mainly of theoretical interest, because they involve rather complex manipulations of data structures. Very recently, Goodrich and Tamassia <ref> [8] </ref> have shown how to dynamically maintain a monotone 1 subdivision so as to achieve O (n) space, O (log 2 n) query time, O (log n) time for vertex inser-tion/deletion, and O (log n + k) time for the insertion/deletion of a monotone chain of k edges. <p> This is the first fully dynamic point location data structure for monotone subdivisions that achieves optimal query time and polylogarithmic update time. To compare our result with previous ones, we note that * The fully dynamic data structures of Cheng-Janardan [2] and Goodrich-Tamassia <ref> [8] </ref> have slower query time but faster update time and less space requirement (both by a log n factor). * The fully dynamic data structure of Preparata-Tamassia [19] has the same performance bounds but is limited to convex subdivisions and to a fixed set of lines on which the ver tices <p> fixed set of lines on which the ver tices can be placed. * The fully dynamic data structure of Tamassia [22] achieves the same query time but is limited to triangulations and has a substantially higher (O (n * log n)) update time. * The semi-dynamic data structure of Goodrich-Tamassia <ref> [8] </ref> has the same query time and better insertion time, but is limited to insertions only. It is conceivable that in many practical applications point location queries are the most critical operations, so that our method is especially suitable for them.
Reference: [9] <author> D. Kirkpatrick, </author> <title> "Optimal Search in Planar Subdivision," </title> <journal> SIAM Journal on Computing, </journal> <volume> Vol. 12, </volume> <pages> 28-35, </pages> <year> 1983. </year>
Reference-contexts: In the static case, where S is fixed, there are optimal techniques that achieve O (log n) query time using O (n log n) preprocessing time and O (n) space <ref> [4, 9, 21] </ref>, where n is the size of S. Research on dynamic algorithms for geometric problems has received increasing attention in the last years. A survey on the subject appears in [3].
Reference: [10] <author> D.T. Lee and F.P. Preparata, </author> <title> "Location of a Point in a Planar Subdivision and its Applications," </title> <journal> SIAM J. Computing, </journal> <volume> Vol. 6, </volume> <pages> 594-606, </pages> <year> 1977. </year>
Reference-contexts: Fries, Mehlhorn, and Naeher [5, 6] present a data structure for general subdivisions with O (n) space, O (log 2 n) query time, and O (log 4 n) amortized update time, using an approach based on the static chain-method <ref> [10] </ref>. The update operations supported are inserting and deleting edges and isolated vertices. If only insertions are performed, the update time is reduced to O (log 2 n) amortized. Preparata and Tamassia give two dynamic techniques for monotone and convex subdivisions, respectively [18, 19].
Reference: [11] <author> E.M. McCreight, </author> <title> "Priority Search Trees," </title> <journal> SIAM J. on Comput., </journal> <volume> Vol. 14, </volume> <pages> 257-276, </pages> <year> 1985. </year>
Reference-contexts: Both methods use O (n) space and are based on a search strategy derived from priority search trees <ref> [11] </ref>. As emphasized by the authors, such methods are mainly of theoretical interest, because they involve rather complex manipulations of data structures.
Reference: [12] <author> K. Mehlhorn, </author> <title> Data Structure and Algorithms 1: Sorting and Searching, </title> <type> 189-199, </type> <year> 1984. </year>
Reference-contexts: Every update operation in the original subdivision S can be simulated with O (1) operations in the modified subdivision with bounded-degree vertices. 4.1 Y-Tree We make use of another type of binary search tree, called BB [ff]-tree <ref> [12] </ref>. Let ff be a fixed real, with 1 4 &lt; ff 1 2 2 . Some important properties of a BB [ff]-tree are listed below: 1. A BB [ff]-tree with n nodes has height O (log n). 15 2. Assume that we augment a BB [ff]-tree with secondary structures.
Reference: [13] <author> M. H. Overmars and J. van Leeuwen, </author> <title> "Maintenance of Configurations in the Plane," </title> <journal> J. Compt. and Syst. Sci., </journal> <volume> Vol. 23, </volume> <pages> 166-204, </pages> <year> 1981. </year>
Reference-contexts: We dynamically maintain the convex hull of the elementary chains of S using data structures called hull trees, which are a variation of the data structure of Overmars and van Leeuwen <ref> [13] </ref>. The hull trees are embedded as secondary structures in the trapezoid tree. Recall that each r-node of the trapezoid tree has two pointers lc and rc, and that corresponds to some trapezoid t . <p> Extending the results of <ref> [13] </ref>, each bridging/de-bridging can be performed in O (log n) time. 3.3 Query Point location for a query point q is performed by tracing down a path in T (S). Let be the node currently visited. 9 1. If is an "-node then we stop. 2.
Reference: [14] <author> M. Overmars, </author> <title> The Design of Dynamic Data Structures, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1983. </year> <month> 18 </month>
Reference-contexts: Tamassia [22] presents a technique for point location in triangulations which allows a tradeoff between query and update time. It is based on the dynamization methods for decomposable search problems <ref> [14] </ref>. The update operations are inserting a "star" (vertex and three edges) inside a region and swapping the diagonal of a convex quadrilateral formed by adjacent regions.
Reference: [15] <author> M. Overmars, </author> <title> "Range Searching in a Set of Line Segments," </title> <booktitle> Proc. (1st) ACM Symp. on Computational Geometry, </booktitle> <pages> 177-185, </pages> <year> 1985. </year>
Reference-contexts: In the following, we denote with n the current size of the subdivision. Also, time complexity bounds are worst-case unless otherwise stated. The technique of Overmars <ref> [15] </ref>, based on the segment-tree, deals with subdivisions whose regions have a bounded number of edges, such as triangulations. The update operations supported are inserting and deleting edges and isolated vertices.
Reference: [16] <author> F.P. Preparata, </author> <title> "A New Approach to Planar Point Location," </title> <journal> SIAM J. Computing, </journal> <volume> Vol. 10, </volume> <pages> 473-483, </pages> <year> 1981. </year>
Reference-contexts: All bounds are worst-case. The data structure for convex subdivisions [19] is based on the trapezoid method <ref> [16] </ref>. It further assumes that the vertices lie on a fixed set of N horizontal lines and achieves space O (N + n log N ), query time O (log n + log N ), and update time O (log n log N ) [19]. <p> In this paper we present a fully dynamic data structure for point location in a monotone subdivision, based on the trapezoid method <ref> [16] </ref>. The update operations supported are insertion and deletion of vertices and edges, and horizontal translation of vertices. Point location queries take O (log n) time, while updates take O (log 2 n) time (amortized for vertex insertion/deletion and worst-case for the others). <p> A slab is either an elementary slab or the union of two contiguous slabs. 3.1 Decomposing a Subdivision into Trapezoids Our point location method is based on a recursive decomposition of the subdivision S into trapezoids, which is an extention of <ref> [16] </ref>. A trapezoid t is a quadrilateral with two horizontal sides that lie on the lines of L. We use left (t ), right (t ), bot (t ), and top (t ) to denote the four sides of t . <p> The other types (and corresponding cuts) are: O-node (spanning edge), R-node (spanning tangent), and r-node (median line). In the figures, we use squares for "-nodes, circles for O-nodes and R-nodes, and triangles for r-nodes (the terminology and symbols follow <ref> [16] </ref>). The trapezoid tree T (t ) for a trapezoid t is recursively defined as follows (see Fig. 3 (b)): 1. If t is empty, then T (t ) consists of a single "-node. 2.
Reference: [17] <author> F.P. Preparata and M.I. Shamos, </author> <title> Computational Geometry: An Introduction, </title> <publisher> Springer-Verlag, </publisher> <address> NY, </address> <year> 1985. </year>
Reference-contexts: We allow unbounded region and vertices at infinity. A monotone subdivision S is a planar subdivision where each region is a monotone polygon. We assume that the edges of a 2 monotone subdivision are oriented from the lowest to the highest endpoint. For additional geometric definitions, see <ref> [17] </ref>. <p> Hence, a spanning tangent of a gap g is computed from such secondary structures in O (log n) time (see, e.g. <ref> [17] </ref>). 2 The dynamic operation of merging two right (left) convex hulls (corresponding to two consecutive left (right) subchains) into a single one is called bridging, and its inverse operation is called de-bridging.
Reference: [18] <author> F.P. Preparata and R. Tamassia, </author> <title> "Fully Dynamic Point Location in a Monotone Subdivision," </title> <journal> SIAM J. Computing, </journal> <volume> Vol. 18, </volume> <pages> 811-830, </pages> <year> 1989. </year>
Reference-contexts: The update operations supported are inserting and deleting edges and isolated vertices. If only insertions are performed, the update time is reduced to O (log 2 n) amortized. Preparata and Tamassia give two dynamic techniques for monotone and convex subdivisions, respectively <ref> [18, 19] </ref>. The data structure for monotone subdivisions [18] supports inserting vertices on edges, inserting monotone chains of edges, and their inverses. The space requirement is O (n). The query time is O (log 2 n). <p> The update operations supported are inserting and deleting edges and isolated vertices. If only insertions are performed, the update time is reduced to O (log 2 n) amortized. Preparata and Tamassia give two dynamic techniques for monotone and convex subdivisions, respectively [18, 19]. The data structure for monotone subdivisions <ref> [18] </ref> supports inserting vertices on edges, inserting monotone chains of edges, and their inverses. The space requirement is O (n). The query time is O (log 2 n). <p> Vertices can be inserted or deleted in time O (log n), and a monotone chain with k edges can be inserted or deleted in time O (log 2 n + k) (thus inserting or deleting a single edge takes O (log 2 n) time) <ref> [18] </ref>. All bounds are worst-case. The data structure for convex subdivisions [19] is based on the trapezoid method [16].
Reference: [19] <author> F.P. Preparata and R. Tamassia, </author> <title> "Dynamic Planar Point Location with Optimal Query Time," </title> <journal> Theoretical Computer Science, </journal> <volume> Vol. 74, </volume> <pages> 95-114, </pages> <year> 1990. </year>
Reference-contexts: The update operations supported are inserting and deleting edges and isolated vertices. If only insertions are performed, the update time is reduced to O (log 2 n) amortized. Preparata and Tamassia give two dynamic techniques for monotone and convex subdivisions, respectively <ref> [18, 19] </ref>. The data structure for monotone subdivisions [18] supports inserting vertices on edges, inserting monotone chains of edges, and their inverses. The space requirement is O (n). The query time is O (log 2 n). <p> All bounds are worst-case. The data structure for convex subdivisions <ref> [19] </ref> is based on the trapezoid method [16]. <p> It further assumes that the vertices lie on a fixed set of N horizontal lines and achieves space O (N + n log N ), query time O (log n + log N ), and update time O (log n log N ) <ref> [19] </ref>. Tamassia [22] presents a technique for point location in triangulations which allows a tradeoff between query and update time. It is based on the dynamization methods for decomposable search problems [14]. <p> To compare our result with previous ones, we note that * The fully dynamic data structures of Cheng-Janardan [2] and Goodrich-Tamassia [8] have slower query time but faster update time and less space requirement (both by a log n factor). * The fully dynamic data structure of Preparata-Tamassia <ref> [19] </ref> has the same performance bounds but is limited to convex subdivisions and to a fixed set of lines on which the ver tices can be placed. * The fully dynamic data structure of Tamassia [22] achieves the same query time but is limited to triangulations and has a substantially higher <p> Our technique extends to general monotone subdivisions the previous results of Preparata and Tamassia for convex subdivisions with vertices on a fixed set of N horizontal lines <ref> [19] </ref>. Several new ideas have been used to achieve such an extension. We leave as a challenging open problem the dynamization of the trapezoid method for point location in general (nonmonotone) subdivisions. The rest of this paper is organized as follows. Section 2 contains preliminary definitions and results.
Reference: [20] <author> D.D. Sleator and R.E. Tarjan, </author> <title> "A Data Structure for Dynamic Trees," </title> <journal> J. Computer Systems Sciences, </journal> <volume> Vol. 24, </volume> <pages> 362-381, </pages> <year> 1983. </year>
Reference-contexts: Their method is based on a new optimal static point-location data structure that uses two interlaced spanning trees, one for the subdivision and one for its graph-theoretic dual, to answer queries. The link-cut trees of Sleator and Tarjan <ref> [20] </ref> are used to dynamize the method, which is relatively easy to implement. A variation of this method supports updates in a semi-dynamic environment where only insertions are performed.
Reference: [21] <author> Sarnak, N. and R.E. Tarjan, </author> <title> "Planar Point Location Using Persistent Search Trees," </title> <journal> Communications ACM, </journal> <volume> Vol. 29, </volume> <pages> 669-679, </pages> <year> 1986. </year>
Reference-contexts: In the static case, where S is fixed, there are optimal techniques that achieve O (log n) query time using O (n log n) preprocessing time and O (n) space <ref> [4, 9, 21] </ref>, where n is the size of S. Research on dynamic algorithms for geometric problems has received increasing attention in the last years. A survey on the subject appears in [3].
Reference: [22] <author> R. Tamassia, </author> <title> "An Incremental Reconstruction Method for Dynamic Planar Point Location," </title> <journal> Information Processing Letters, </journal> <volume> Vol. 37, </volume> <pages> 79-83, </pages> <year> 1991. </year> <month> 19 </month>
Reference-contexts: It further assumes that the vertices lie on a fixed set of N horizontal lines and achieves space O (N + n log N ), query time O (log n + log N ), and update time O (log n log N ) [19]. Tamassia <ref> [22] </ref> presents a technique for point location in triangulations which allows a tradeoff between query and update time. It is based on the dynamization methods for decomposable search problems [14]. <p> It is shown that for any smooth nondecreasing integer function b (n) with 2 b (n) p n, there exists a dynamic point location data structure with O (n) space, O ((log 2 n)= log b (n)) query time, and O ((log 2 n)b (n)= log b (n)) update time <ref> [22] </ref>. By setting b (n) = 2, we obtain O (log 2 n) query and update times. By setting b (n) = log n, we obtain O ((log 2 n)= log log n) query time and O ((log 3 n)= log log n) update time. <p> Finally, by setting b (n) = n * , we obtain O (log n) query time and O (n * log n) update time <ref> [22] </ref>. Cheng and Janardan [2] present two methods for dynamic planar point-location. Their first method achieves O (log 2 n) query time, O (log n) time for inserting/deleting a vertex, and O (k log n) time for inserting/deleting a chain of k edges. <p> requirement (both by a log n factor). * The fully dynamic data structure of Preparata-Tamassia [19] has the same performance bounds but is limited to convex subdivisions and to a fixed set of lines on which the ver tices can be placed. * The fully dynamic data structure of Tamassia <ref> [22] </ref> achieves the same query time but is limited to triangulations and has a substantially higher (O (n * log n)) update time. * The semi-dynamic data structure of Goodrich-Tamassia [8] has the same query time and better insertion time, but is limited to insertions only. <p> Also, such a sequence can be computed from S in O (n) time. Proof: Let S 0 be a triangulation of S, which can be computed in O (n) time [7]. As shown in <ref> [22] </ref>, a triangulation with n vertices can be assembled/disassembled using a sequence of the following operations: insertstar (v; r; r 1 ; r 2 ; r 3 ): Add vertex v inside region r and edges between v and the three vertices of r, which is decomposed into new regions r
References-found: 22

