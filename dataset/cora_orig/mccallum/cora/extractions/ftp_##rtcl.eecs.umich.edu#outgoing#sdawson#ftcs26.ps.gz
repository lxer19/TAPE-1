URL: ftp://rtcl.eecs.umich.edu/outgoing/sdawson/ftcs26.ps.gz
Refering-URL: http://www.eecs.umich.edu/~farnam/papers/pubs.html
Root-URL: http://www.cs.umich.edu
Email: fsdawson,farnam,mitton,teckleeg@eecs.umich.edu  
Title: Testing of Fault-Tolerant and Real-Time Distributed Systems via Protocol Fault Injection  
Author: Scott Dawson, Farnam Jahanian, Todd Mitton, and Teck-Lee Tung 
Address: Ann Arbor, MI 48109-2122, USA  
Affiliation: Real-Time Computing Laboratory Electrical Engineering and Computer Science Department University of Michigan  
Abstract: As software for distributed systems becomes more complex, ensuring that a system meets its prescribed specification is a growing challenge that confronts software developers. This is particularly important for distributed applications with strict dependability and timeliness constraints. This paper reports on ORCHESTRA, a portable fault injection environment for testing implementations of distributed protocols. This tool is based on a simple yet powerful framework, called script-driven probing and fault injection, for the evaluation and validation of the fault-tolerance and timing characteristics of distributed protocols. The tool, which was initially developed on the Real-Time Mach operating system and later ported to other platforms including Solaris and SunOS, has been used to conduct extensive experiments on several protocol implementations. This paper describes the design and implementation of our fault injection tool, focusing on architectural features to support portability, minimizing intrusiveness on target protocols, and explicit support for testing real-time systems. The paper also describes the experimental evaluation of two protocol implementations: a real-time audio-conferencing application on Real-Time Mach, and a distributed group membership service on the Sun So-laris operating system. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Dawson and F. Jahanian, </author> <title> Deterministic fault injection of distributed systems, </title> <booktitle> in Lecture Notes in Computer Science # 938: Theory and Practice in Distributed Systems, </booktitle> <editor> K. B. et. al., </editor> <booktitle> editor, </booktitle> <pages> pp. 178-196. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1994. </year>
Reference-contexts: Office of Naval Research, N0014-95-1-0261, and a research grant from the National Science Foundation, CCR-9502341. a software fault injection tool, called ORCHESTRA, for testing dependability and timing properties of distributed protocols. ORCHESTRA is based on a simple yet powerful framework, called script-driven probing and fault injection, first reported in <ref> [1, 2] </ref>. The emphasis of this approach is on experimental techniques intended to identify specific problems in a protocol or its implementation rather than the evaluation of system dependability through statistical metrics such as fault coverage (e.g. [3]).
Reference: [2] <author> S. Dawson and F. Jahanian, </author> <title> Probing and fault injection of protocol implementations, </title> <booktitle> in Proc. Int. Conf. on Distributed Computer Systems, </booktitle> <pages> pp. 351-359, </pages> <address> Vancouver, B.C., </address> <month> May </month> <year> 1995. </year>
Reference-contexts: Office of Naval Research, N0014-95-1-0261, and a research grant from the National Science Foundation, CCR-9502341. a software fault injection tool, called ORCHESTRA, for testing dependability and timing properties of distributed protocols. ORCHESTRA is based on a simple yet powerful framework, called script-driven probing and fault injection, first reported in <ref> [1, 2] </ref>. The emphasis of this approach is on experimental techniques intended to identify specific problems in a protocol or its implementation rather than the evaluation of system dependability through statistical metrics such as fault coverage (e.g. [3]). <p> This node can be used to collect data about target participants by probing. As described in another paper <ref> [2] </ref>, this approach was used to test four commercial implementations of TCP without access to the source code. <p> A more detailed comparison on fault injection of the TCP protocol appears in <ref> [2] </ref>. (b) Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection (e.g. [17, 18]) and simulation approaches for injecting hardware failures (e.g. [19, 20]) have received much attention in the past. <p> Although our implementation of ORCHESTRA described in this paper is fixed at the socket layer, the protocol independent nature of the PFICore allows the PFI layer to be moved around the protocol stack fairly easily. In a previous paper <ref> [2] </ref> we describe an x-kernel layer implementation which can be placed anywhere in an x-kernel protocol stack. We should note that the work on the EFA project has recently concentrated on automatic generation of fault cases to be injected. <p> The ORCHESTRA tool (and an earlier prototype implementation) have been used to conduct extensive experi ments on several commercial and research systems includ-ing six implementations of the TCP communication protocol <ref> [2] </ref>, a primary-backup replication protocol [30], a distributed group membership service, and a real-time audio-conferencing application, as reported in this paper. These experiments revealed major design/implementation errors as well as subtle violations of the protocol specifications.
Reference: [3] <author> Jean Arlat and Martine Aguera and Yves Crouzet and Jean-Charles Fabre and Eliane Martins and David Powell, </author> <title> Experimental evaluation of the fault tolerance of an atomic multi-cast system, </title> <journal> IEEE Trans. Reliability, </journal> <volume> vol. 39, no. 4, </volume> <pages> pp. 455-467, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: The emphasis of this approach is on experimental techniques intended to identify specific problems in a protocol or its implementation rather than the evaluation of system dependability through statistical metrics such as fault coverage (e.g. <ref> [3] </ref>). Hence, the focus is on developing fault injection techniques that can be employed in studying three aspects of a target protocol: i) detecting design or implementation errors, ii) identifying violations of protocol specifications, and iii) obtaining insights into the design decisions made by the implementors. <p> Fault-injection and testing dependability of distributed systems has received more attention in recent years by several research projects [23, 24, 25, 26]. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. For example, the work reported in <ref> [3] </ref> calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol [27] in the presence of faults. Other work can be characterized as deterministic approaches to test generation [23, 25].
Reference: [4] <author> Seth A. Hutchinson and Avinash C. Kak, Spar: </author> <title> A Planner That Satisfies Operational and Geometric Goals in Uncertain Environmnents, </title> <journal> AI Magazine, </journal> <pages> pp. 30-61, </pages> <month> Spring </month> <year> 1990. </year>
Reference-contexts: In the model underlying script-driven probing and fault injection, a distributed protocol can be viewed as an ab straction through which a collection of participants com-municate by exchanging a set of messages, in the same spirit as the x-kernel <ref> [4] </ref>. Hence, no distinction is made between application-level protocols, communication protocols, or device layer protocols. In this approach, a protocol fault injection (PFI) layer is inserted below a target protocol to filter and manipulate the messages that are exchanged between participants.
Reference: [5] <author> Clifford W. Mercer and Jim Zelenka and Ragunathan Ra-jkumar, </author> <title> On Predictable Operating System Protocol Processing, </title> <type> Technical Report CMU-CS-94-165, </type> <institution> Carnegie Mellon University, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: For example, in the implementation of ORCHESTRA on Real-Time Mach, we exploit operating system support, such as sched-uler feedback and capacity reservation <ref> [5] </ref>, to quantify intrusiveness on a target protocol and to compensate for it whenever possible. The reminder of this paper is organized as follows: Section 2 presents an overview of the script-driven probing and fault injection technique. <p> For applications which are simply sending and receiving data, significant speedup (over the UX server implementation) has been achieved by using libsockets.a. In Real-Time Mach, user level sockets have been used in conjunction with processor reserves to achieve predictable protocol processing <ref> [5] </ref>. Protocol processing is made predictable by binding the protocol processing thread to a processor reserve so that sufficient time is set aside for communication. <p> In addition, these libraries are not installed over the system libraries, but instead are installed wherever the ORCHESTRA libraries are installed. Time Mach microkernel supports an abstraction called processor capacity reserve <ref> [5] </ref> which allows application threads to specify their CPU requirements in terms of their timing requirements. If the request is admitted by the kernel, the task is guaranteed to receive the requested CPU allocation. The kernel allows multiple threads to be bound to the same reserve.
Reference: [6] <author> N. C. Hutchinson and L. L. Peterson, </author> <title> The x-Kernel: An architecture for implementing network protocols, </title> <journal> IEEE TRansactions on Software Engineering, </journal> <volume> vol. 17, no. 1, </volume> <pages> pp. 1-13, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: protocol, and in particular, its impact of on timing correctness of a real-time protocols. 2.1 The basic framework In script-driven probing and fault injection, a distributed protocol can be viewed as an abstraction through which a collection of participants communicate by exchanging a set of messages, as in the x-kernel <ref> [6] </ref>. Each layer provides an abstract communication service to higher layers, and there is no distinction made between particular layers of the protocol stack.
Reference: [7] <author> F. Jahanian, R. Rajkumar, and S. Fakhouri, </author> <title> Processor group membership protocols: Specification, </title> <booktitle> design and implementation, in Proceedings of the 12th Symposium on Reliable Distributed Systems, </booktitle> <pages> pp. 2-11, </pages> <address> Princeton, New Jersey, </address> <month> Octo-ber </month> <year> 1993. </year>
Reference: [8] <author> F. Cristian, </author> <title> Reaching agreement on processor-group membership in synchronous distributed systems, </title> <journal> Distributed Computing, </journal> <volume> no. 4, </volume> <pages> pp. 175-187, </pages> <year> 1991. </year>
Reference: [9] <author> A. M. Ricciardi and K. P. Birman, </author> <title> Using process groups to implement failure detection in asynchronous environments, </title> <booktitle> in Proceedings of the 11th ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Montreal, Quebec, </address> <month> August </month> <year> 1991. </year>
Reference: [10] <author> S. Mishra, L. L. Peterson, and R. D. Schlichting, </author> <title> A membership protocol based on partial order, </title> <booktitle> in Second Working Conference on Dependable Computing for Critical Applications, </booktitle> <month> February </month> <year> 1990. </year>
Reference: [11] <author> Chen Lee and Ragunathan Rajkumar and Clifford W. Mercer, </author> <title> Experiences with processor reservation and dynamic qos in real-time mach, </title> <type> Technical Report Technical Report, </type> <institution> Carnegie Mellon University, </institution> <month> October </month> <year> 1995. </year>
Reference-contexts: A closely related objective was to illustrate that by measuring the intrusiveness of the fault injection layer, one can compensate for timing perturbation with significant accuracy. RT-Phone is a distributed teleconferencing application with a telephone-pad-like Motif-based graphical interface <ref> [11] </ref>. A caller and a callee can establish a 2-way audio connection across the network using this graphical user interface.
Reference: [12] <author> S. Dawson, F. Jahanian, T. Mitton, and T.-L. Tung, </author> <title> Testing of fault-tolerant and real-time distributed systems via protocol fault injection, </title> <type> Technical Report Technical Report, </type> <institution> University of Michigan, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: Due to limited space, only a brief explanation of the protocol and the types of experiments that can be performed are presented here. The full length explanation of the experiments can be found in <ref> [12] </ref>. 5.1 Fault injection of an asynchronous group membership protocol The objective of the experiments described in this subsection was to test the fault-tolerance capabilities of a prototype implementation of the strong group membership protocol ([7]) using the ORCHESTRA fault injection tool. <p> Due to space limitation, we list the types of experiments that we ran on the group membership only briefly here. Several subtle implementation errors were discovered during the course of these experiments. A recent technical report provides more details <ref> [12] </ref>. * Packet interruption: These experiments involved various types of packet interruption. The GMDs were tested for resiliency to delayed and dropped heartbeats, dropped ACKs of MEMBERSHIP CHANGE messages, and dropped COMMIT messages. <p> When the reservation period decreases (more frequent sampling and transmission of audio data), the end-to-end delay decreases proportionally and the CPU load increases non-linearly. Interested readers are referred to a recent technical report <ref> [12] </ref> for further details.
Reference: [13] <author> J. Mogul, R. Rashid, and M. Accetta, </author> <title> The packet filter: An efficient mechanism for user-level network code, </title> <booktitle> in Proc. ACM Symp. on Operating Systems Principles, </booktitle> <pages> pp. 39-51, </pages> <address> Austin, TX, </address> <month> November </month> <year> 1987, </year> <note> ACM. </note>
Reference-contexts: To minimize data copying across kernel/user-space protection boundaries, a kernel agent, called a packet filter, is often used to discard unwanted packets as early as possible. Past work on packet filters, including the pioneering work on the CMU/Stanford Packet Filter <ref> [13] </ref>, a more recent work on BSD Packet Filter (BPF) which uses a register-based filter evaluator [14], and the Mach Packet Filter (MPF) [15] which is an extension of the BPF, are related to the work presented in this paper.
Reference: [14] <author> Steven McCanne and Van Jacobson, </author> <title> The BSD Packet Filter: A New Architecture for User-level Packet Capture, </title> <booktitle> in Winter USENIX Conference, </booktitle> <pages> pp. 259-269, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Past work on packet filters, including the pioneering work on the CMU/Stanford Packet Filter [13], a more recent work on BSD Packet Filter (BPF) which uses a register-based filter evaluator <ref> [14] </ref>, and the Mach Packet Filter (MPF) [15] which is an extension of the BPF, are related to the work presented in this paper. In the same spirit as packet filtration methods for network monitoring, our approach inserts a filter to intercept messages that arrive from the network.
Reference: [15] <author> M. Yuhara, B. N. Bershad, C. Maeda, and J. E. B. Moss, </author> <title> Efficient packet demultiplexing for multiple endpoints and large messages, </title> <booktitle> in Winter USENIX Conference, </booktitle> <month> January </month> <year> 1994. </year> <note> Second Edition. </note>
Reference-contexts: Past work on packet filters, including the pioneering work on the CMU/Stanford Packet Filter [13], a more recent work on BSD Packet Filter (BPF) which uses a register-based filter evaluator [14], and the Mach Packet Filter (MPF) <ref> [15] </ref> which is an extension of the BPF, are related to the work presented in this paper. In the same spirit as packet filtration methods for network monitoring, our approach inserts a filter to intercept messages that arrive from the network.
Reference: [16] <author> D. E. Comer and J. C. Lin, </author> <title> Probing TCP implementations, </title> <booktitle> in Proc. Summer USENIX Conference, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: Furthermore, our approach requires that a filter be inserted at various levels in a protocol stack, unlike packet filters that are inserted on top of link-level device drivers and below the listening applications. Another closely related work is the active probing approach proposed by Comer and Lin <ref> [16] </ref> to study five TCP implementations. In addition to repeating TCP experiments similar to those reported in [16], our approach allows manipulation of messages as well as simulation of more complex failure models which are not possible with techniques that are based primarily on monitoring and gathering trace data. <p> Another closely related work is the active probing approach proposed by Comer and Lin <ref> [16] </ref> to study five TCP implementations. In addition to repeating TCP experiments similar to those reported in [16], our approach allows manipulation of messages as well as simulation of more complex failure models which are not possible with techniques that are based primarily on monitoring and gathering trace data.
Reference: [17] <author> K. G. Shin and Y. H. Lee, </author> <title> Measurement and application of fault latency, </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. C-35, no. 4, </volume> <pages> pp. 370-375, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: A more detailed comparison on fault injection of the TCP protocol appears in [2]. (b) Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection (e.g. <ref> [17, 18] </ref>) and simulation approaches for injecting hardware failures (e.g. [19, 20]) have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [21, 22].
Reference: [18] <author> J. Arlat, Y. Crouzet, and J.-C. Laprie, </author> <title> Fault injection for dependability validation of fault-tolerant computing systems., </title> <booktitle> in Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pp. 348-355, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: A more detailed comparison on fault injection of the TCP protocol appears in [2]. (b) Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection (e.g. <ref> [17, 18] </ref>) and simulation approaches for injecting hardware failures (e.g. [19, 20]) have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [21, 22].
Reference: [19] <author> K. Goswami and R. Iyer, </author> <title> Simulation of software behaviour under hardware faults, </title> <booktitle> in Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pp. 218-227. </pages> <publisher> IEEE, </publisher> <year> 1993. </year>
Reference-contexts: A more detailed comparison on fault injection of the TCP protocol appears in [2]. (b) Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection (e.g. [17, 18]) and simulation approaches for injecting hardware failures (e.g. <ref> [19, 20] </ref>) have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [21, 22]. Fault-injection and testing dependability of distributed systems has received more attention in recent years by several research projects [23, 24, 25, 26].
Reference: [20] <author> E. Czeck and D. Siewiorek, </author> <title> Effects of transient gate-level faults on program behaviour, </title> <booktitle> in Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pp. 236-243. </pages> <publisher> IEEE, </publisher> <year> 1990. </year>
Reference-contexts: A more detailed comparison on fault injection of the TCP protocol appears in [2]. (b) Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection (e.g. [17, 18]) and simulation approaches for injecting hardware failures (e.g. <ref> [19, 20] </ref>) have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [21, 22]. Fault-injection and testing dependability of distributed systems has received more attention in recent years by several research projects [23, 24, 25, 26].
Reference: [21] <author> R. Chillarege and N. S. Bowen, </author> <title> Understanding large system failures a fault injection experiment, </title> <booktitle> in Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pp. 356-363, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Hardware fault-injection (e.g. [17, 18]) and simulation approaches for injecting hardware failures (e.g. [19, 20]) have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors <ref> [21, 22] </ref>. Fault-injection and testing dependability of distributed systems has received more attention in recent years by several research projects [23, 24, 25, 26]. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics.
Reference: [22] <author> Z. Segall et al., </author> <title> Fiat fault injection based automated testing environment, </title> <booktitle> in FTCS-18, </booktitle> <pages> pp. 102-107, </pages> <year> 1988. </year>
Reference-contexts: Hardware fault-injection (e.g. [17, 18]) and simulation approaches for injecting hardware failures (e.g. [19, 20]) have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors <ref> [21, 22] </ref>. Fault-injection and testing dependability of distributed systems has received more attention in recent years by several research projects [23, 24, 25, 26]. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics.
Reference: [23] <author> K. Echtle and Y. Chen, </author> <title> Evaluation of deterministic fault injection for fault-tolerant protocol testing, </title> <booktitle> in Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pp. 418-425. </pages> <publisher> IEEE, </publisher> <year> 1991. </year>
Reference-contexts: Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [21, 22]. Fault-injection and testing dependability of distributed systems has received more attention in recent years by several research projects <ref> [23, 24, 25, 26] </ref>. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. <p> For example, the work reported in [3] calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol [27] in the presence of faults. Other work can be characterized as deterministic approaches to test generation <ref> [23, 25] </ref>. In [23], the evaluation of design fault coverage is based on a stochastic model. <p> For example, the work reported in [3] calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol [27] in the presence of faults. Other work can be characterized as deterministic approaches to test generation [23, 25]. In <ref> [23] </ref>, the evaluation of design fault coverage is based on a stochastic model. The work reported in [26] focuses on CPU and memory fault injection into a distributed real-time system; this approach also allows inducing communication faults with a given statistical distribution that is specified by the system implementor.
Reference: [24] <author> Klaus Echtle and Martin Leu, </author> <title> The EFA Fault Injector for Fault-Tolerant Distributed System Testing, </title> <booktitle> in Workshop on Fault-Tolerant Parallel and Distributed Systems, </booktitle> <pages> pp. 28-35. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [21, 22]. Fault-injection and testing dependability of distributed systems has received more attention in recent years by several research projects <ref> [23, 24, 25, 26] </ref>. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. <p> Hence, deterministic control on ordering of certain concurrent messages is a key to this approach. Finally, one significant distinguishing characteristic of our approach is the focus on real-time as well as fault tolerance characteristics of distributed systems. The Delayline tool and the EFA fault injection environment reported in <ref> [24] </ref> are closest to the approach described in this paper. The Delayline tool presented in [28] allows the user to introduce delays into user-level protocols.
Reference: [25] <author> D. Avresky, J. Arlat, J. Laprie, and Y. Crouzet, </author> <title> Fault injection for the formal testing of fault tolerance, </title> <booktitle> in Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pp. 345-354. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [21, 22]. Fault-injection and testing dependability of distributed systems has received more attention in recent years by several research projects <ref> [23, 24, 25, 26] </ref>. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. <p> For example, the work reported in [3] calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol [27] in the presence of faults. Other work can be characterized as deterministic approaches to test generation <ref> [23, 25] </ref>. In [23], the evaluation of design fault coverage is based on a stochastic model.
Reference: [26] <author> Seungjae Han and Harold A. Rosenberg and Kang G. Shin, DOCTOR: </author> <title> An integrateD SOftware fault injeCTiOn enviRonment, </title> <type> Technical report, </type> <institution> University of Michigan, </institution> <year> 1993. </year>
Reference-contexts: Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [21, 22]. Fault-injection and testing dependability of distributed systems has received more attention in recent years by several research projects <ref> [23, 24, 25, 26] </ref>. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. <p> Other work can be characterized as deterministic approaches to test generation [23, 25]. In [23], the evaluation of design fault coverage is based on a stochastic model. The work reported in <ref> [26] </ref> focuses on CPU and memory fault injection into a distributed real-time system; this approach also allows inducing communication faults with a given statistical distribution that is specified by the system implementor.
Reference: [27] <author> P. Verissimo, L. Rodrigues, and M. Batista, </author> <title> Amp: A highly parallel atomic multicast protocol, </title> <booktitle> in Proc. of ACM SIG-COMM, </booktitle> <pages> pp. 83-93, </pages> <address> Austin, TX, </address> <month> September </month> <year> 1990. </year>
Reference-contexts: Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. For example, the work reported in [3] calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol <ref> [27] </ref> in the presence of faults. Other work can be characterized as deterministic approaches to test generation [23, 25]. In [23], the evaluation of design fault coverage is based on a stochastic model.
Reference: [28] <author> David B. Ingham and Graham D. Parrington, Delayline: </author> <title> A Wide-Area Network Emulation Tool, </title> <journal> Computing Systems, </journal> <volume> vol. 7, no. 3, </volume> <pages> pp. 313-332, </pages> <month> Summer </month> <year> 1994. </year>
Reference-contexts: Finally, one significant distinguishing characteristic of our approach is the focus on real-time as well as fault tolerance characteristics of distributed systems. The Delayline tool and the EFA fault injection environment reported in [24] are closest to the approach described in this paper. The Delayline tool presented in <ref> [28] </ref> allows the user to introduce delays into user-level protocols. The tool is used mainly for emulating a wide-area network in a local network development environment and allows the user to specify delays on certain paths which the application is using.
Reference: [29] <author> Klaus Echtle and Martin Leu, </author> <title> Test of fault tolerant distributed systems by fault injection, IEEE Fault Tolerant Parallel and Distributed Systems, </title> <month> June </month> <year> 1995. </year>
Reference-contexts: An attributed Petri net model is used to derive the fault cases by a reachability analysis. This is a very promising research avenue which has been reported in <ref> [29] </ref>. This approach differs from the work reported in this paper in that fault injection scripts in ORCHESTRA are hand-crafted by the user and this process is facilitated by a state-transition-based graphical user interface. <p> Last, the implementation of ORCHESTRA on Real-Time Mach takes advantage of some Real-Time Mach features to attempt to compensate for intrusiveness of the fault injection layer for real-time applications. The Petri net model used in <ref> [29] </ref> does allow for specification of real-time protocols. However, to our knowledge, the EFA work does not attempt to quantify or compensate for intrusiveness of the fault injector. 7 Concluding remarks This paper presented the software architecture of OR CHESTRA, a fault injection environment for testing distributed dependable systems.
Reference: [30] <author> S. Dawson, F. Jahanian, and T. Mitton, </author> <title> A software fault-injection tool on real-time mach, </title> <booktitle> in IEEE Real-Time Systems Symposium, </booktitle> <address> Pisa, Italy, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: The ORCHESTRA tool (and an earlier prototype implementation) have been used to conduct extensive experi ments on several commercial and research systems includ-ing six implementations of the TCP communication protocol [2], a primary-backup replication protocol <ref> [30] </ref>, a distributed group membership service, and a real-time audio-conferencing application, as reported in this paper. These experiments revealed major design/implementation errors as well as subtle violations of the protocol specifications.
References-found: 30

