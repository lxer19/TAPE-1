URL: http://www.cs.indiana.edu/proglang/papers/mrvs.ps
Refering-URL: http://www.cs.indiana.edu/proglang/proglang.html
Root-URL: http://www.cs.indiana.edu
Email: fjashley,dybg@cs.indiana.edu  
Title: An Efficient Implementation of Multiple Return Values in Scheme  
Author: J. Michael Ashley R. Kent Dybvig 
Address: Lindley Hall 215 Bloomington, Indiana 47405  
Affiliation: Indiana University Computer Science Department  
Abstract: This paper describes an implementation of the new Scheme multiple values interface. The implementation handles multiple values efficiently, with no run-time overhead for normal calls and returns. Error checks are performed where necessary to insure that the expected number of values is returned in all situations. The implementation fits cleanly with our direct-style compiler and stack-based representation of control, but is equally well suited to continuation-passing style compilers and to heap-based run-time architectures. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> William Clinger and Jonathan A. Rees (Editors). </editor> <title> Revised 4 report on the algorithmic language Scheme. </title> <journal> Lisp Pointers, </journal> <volume> 4(3) </volume> <pages> 1-55, </pages> <year> 1991. </year>
Reference-contexts: Section 4 discusses the performance characteristics of our implementation. Section 5 discusses related work. Section 6 summarizes and concludes the paper. 2 Multiple Return Values A proposal to include a multiple values interface in the successor to the Revised 4 Report on Scheme <ref> [1] </ref> has been approved [10]. Two procedures, values and call-with-values, comprise the interface. (values v 1 : : : ) (call-with-values producer consumer ) The procedure values accepts any number of arguments and simply passes (returns) the arguments to its continuation.
Reference: [2] <author> Olivier Danvy and Julia L. Lawall. </author> <title> Back to direct style II: First-class continuations. </title> <booktitle> In Proceedings of the 1992 ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 299-310, </pages> <year> 1992. </year>
Reference-contexts: A compiler might perform a CPS conversion early in the compilation process to simplify subsequent processing, then convert back into direct style just prior to code generation. The reverse CPS transformation developed by Danvy and Lawall <ref> [2] </ref> to recognize transformed calls to call-with-current-continuation and reified continuations should be straightforward to extend to recognize transformed calls to call-with-values and values. Unoptimized multiple-value calls may require as many as two additional closures and four additional procedure calls.
Reference: [3] <author> R. Kent Dybvig, David Eby, and Carl Bruggeman. </author> <title> A segmented memory model for storage management in Scheme. </title> <type> Technical Report 400, </type> <institution> Indiana University Computer Science Department, Lindley Hall 215, Bloomington Indiana, </institution> <month> 47405, </month> <year> 1994. </year>
Reference-contexts: the remaining values are placed at the base of the callee's stack frame. (See Figure 1.) 3 Holes in the frame do not confuse the garbage collector since a live pointer mask is kept behind every return point to indicate which words of the frame must be traced during collection <ref> [3] </ref>. The code generated for an mv-call expression evaluates the consumer expression, saves the resulting value in a temporary stack location at the top of the frame, performs the producer call, and transfers control to the consumer.
Reference: [4] <author> R. Kent Dybvig and Robert Hieb. </author> <title> A new approach to procedures with variable arity. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 3(3) </volume> <pages> 229-244, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: This packaging can be performed out-of-line to reduce code size. Our implementation supports a multiple-arity procedure call interface with case-lambda <ref> [4, 12] </ref>. A case-lambda expression takes the following form: (case-lambda (idspec body ) : : : ) Each clause of a case-lambda expression specifies an interface to the procedure and the expression to be evaluated when the procedure is called through that interface.
Reference: [5] <author> Richard P. Gabriel. </author> <title> Performance and Evaluation of LISP Systems. </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: All occurrences of call-with-values are recognizable as mv-let forms internally. This resulted in a 20% improvement in the speed of the three passes. We also compared the performance of a set of benchmarks that do not use multiple values (Scheme versions of the Gabriel benchmarks <ref> [5] </ref>) before and after the multiple value interface was added to the system. As expected, we found that supporting multiple values has no run-time impact on code that does not use them, although the code generated is naturally slightly larger due to the addition of multiple-value return points.
Reference: [6] <author> Chris Hanson. </author> <title> MIT Scheme Reference Manual, </title> <note> Novem-ber 1991. Edition 1.1 for Scheme Release 7.1.3. </note>
Reference-contexts: As with case-lambda, the first clause that accepts the number of values provided is chosen as the consumer. The optional argument interfaces provided by Common Lisp [8] and by other Scheme systems, e.g., MIT Scheme <ref> [6] </ref>, can be handled in a similar manner. 3.6 Common Lisp multiple values interface Our strategy can be adapted to implement the Common Lisp multiple values interface efficiently. Common Lisp provides two basic interfaces for receiving multiple values: multiple-value-call and multiple-value-bind. <p> Comparing Tables 1 and 2, it also appears that programmers are better off, in terms of performance, using some other mechanism for returning multiple values unless the compiler can recognize the call-with-values application. 5 Related work Other implementations of Scheme, notably T [13] and MIT Scheme <ref> [6] </ref>, provide multiple values interfaces. We have experimented with T Version 3.1 on a Sparc processor and MIT Scheme Version 7.2 on an SGI MIPS processor.
Reference: [7] <author> Robert Hieb, R. Kent Dybvig, and Carl Bruggeman. </author> <title> Representing control in the presence of first-class continuations. </title> <booktitle> In Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 66-77, </pages> <year> 1990. </year>
Reference-contexts: The argument count in vc serves as the return value count in the latter case. 3.4 Multiple values and first-class continuations Our strategy fits cleanly with our implementation of first-class continuations <ref> [7] </ref>. When a continuation is captured, the current stack segment is split into two smaller segments. The first segment is the part of the stack in use when the continuation is captured, and the second segment is the unused portion of the stack. <p> Any lambda expression can be rewritten into a case-lambda expression with only one clause. handler is allowed to copy <ref> [7] </ref>. Our system allows case-lambda to be used to specify the consumer when using call-with-values. In order to allow the consumer to be a case-lambda expression, we must extend mv-let to handle multiple consumers.
Reference: [8] <author> Guy L. Steele Jr. </author> <title> Common Lisp. </title> <note> Digital Press, second edition, </note> <year> 1990. </year>
Reference-contexts: an error in such cases, but the text of the report does not appear to say whether passing the wrong number of arguments is an error, much less that an error must be signaled. received and to generate a special value when no values are received, as in Common Lisp <ref> [8] </ref>. Another approach is to ignore extra values but signal an error when no values are received. We feel that either approach tends to mask programming errors without adding significantly to the flexibility of the language. <p> The only difference is that a case dispatch on the number of values received must be performed to determine which clause to execute. As with case-lambda, the first clause that accepts the number of values provided is chosen as the consumer. The optional argument interfaces provided by Common Lisp <ref> [8] </ref> and by other Scheme systems, e.g., MIT Scheme [6], can be handled in a similar manner. 3.6 Common Lisp multiple values interface Our strategy can be adapted to implement the Common Lisp multiple values interface efficiently. Common Lisp provides two basic interfaces for receiving multiple values: multiple-value-call and multiple-value-bind.
Reference: [9] <author> Simon L. Peyton-Jones. </author> <title> Implementing lazy functional languages on stock hardware: </title> <journal> the Spineless Tagless G-machine. Journal of Functional Programming, </journal> <volume> 2(2), </volume> <month> April </month> <year> 1992. </year>
Reference-contexts: If it is, it copies the return value to the specified address. In either case, control returns to the instruction following the unimplemented instruction. A procedure returning a nonstructure value returns as usual, resulting in an unimplemented instruction trap. The Spineless Tagless G-machine <ref> [9] </ref> uses vectored returns to control closure updating. Control is returned to one point if the closure needs to be updated and to another return point if it does not.
Reference: [10] <author> Jonathan Rees. </author> <title> The Scheme of things: The June 1992 meeting. Lisp Pointers, </title> <type> 4(4), </type> <month> October-December </month> <year> 1992. </year>
Reference-contexts: Section 4 discusses the performance characteristics of our implementation. Section 5 discusses related work. Section 6 summarizes and concludes the paper. 2 Multiple Return Values A proposal to include a multiple values interface in the successor to the Revised 4 Report on Scheme [1] has been approved <ref> [10] </ref>. Two procedures, values and call-with-values, comprise the interface. (values v 1 : : : ) (call-with-values producer consumer ) The procedure values accepts any number of arguments and simply passes (returns) the arguments to its continuation.
Reference: [11] <author> System V Application Binary Interface, </author> <title> SPARC Processor Supplement, </title> <year> 1990. </year>
Reference-contexts: On Sparc-based computer systems, the prescribed method for communicating whether fixed-length structures are expected and returned in C and similar languages somewhat resembles the stack-based return count model described in Section 3.2.2 <ref> [11] </ref>. The return point for a call to a procedure expected to return a structure is flagged with a particular "unimplemented" instruction, and the address of a location into which to place the returned structure is passed as a special argument on the stack.
Reference: [12] <author> Cadence Research Systems. </author> <title> Chez Scheme System Manual. </title> <institution> Bloomington, Indiana, </institution> <month> February </month> <year> 1992. </year>
Reference-contexts: This packaging can be performed out-of-line to reduce code size. Our implementation supports a multiple-arity procedure call interface with case-lambda <ref> [4, 12] </ref>. A case-lambda expression takes the following form: (case-lambda (idspec body ) : : : ) Each clause of a case-lambda expression specifies an interface to the procedure and the expression to be evaluated when the procedure is called through that interface.
Reference: [13] <institution> T Version 3.0 Release Notes. </institution>
Reference-contexts: Comparing Tables 1 and 2, it also appears that programmers are better off, in terms of performance, using some other mechanism for returning multiple values unless the compiler can recognize the call-with-values application. 5 Related work Other implementations of Scheme, notably T <ref> [13] </ref> and MIT Scheme [6], provide multiple values interfaces. We have experimented with T Version 3.1 on a Sparc processor and MIT Scheme Version 7.2 on an SGI MIPS processor.
Reference: [14] <author> Tahchi Yuasa. </author> <title> Design and implementation of Kyoto Common Lisp. </title> <journal> Journal of Information Processing, </journal> <volume> 13(3) </volume> <pages> 284-295, </pages> <year> 1990. </year>
Reference-contexts: The model described in Section 3.2.1, with the modi-fication for zero-value returns mentioned in Section 3.6, is essentially the same as the model used by Kyoto Common Lisp <ref> [14] </ref>. Rather than intermix stack arguments with other control information on a single stack, however, they use multiple stacks with one stack reserved for passing and returning values to procedure calls.
References-found: 14

