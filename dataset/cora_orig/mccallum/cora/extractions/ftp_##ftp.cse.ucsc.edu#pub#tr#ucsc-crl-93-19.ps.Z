URL: ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-93-19.ps.Z
Refering-URL: ftp://ftp.cse.ucsc.edu/pub/tr/README.html
Root-URL: http://www.cse.ucsc.edu
Title: C++ Classes for the Efficient Manipulation and Storage of Hierarchical Objects  
Author: Dean R. E. Long 
Note: This work, particularly work on the START program, was supported in part by NSF grant CCR-9102635.  
Address: Santa Cruz, CA 95064 USA  
Affiliation: Baskin Center for Computer Engineering Information Sciences University of California, Santa Cruz  
Date: May 27, 1993  
Pubnum: UCSC-CRL-93-19  
Abstract: Many applications must efficiently store and manipulate complex objects. Often sub-objects or entire objects are identical. Memory use can be decreased by the use of object handles which point to shared objects in place of actual objects. If the objects are hierarchical, sub-objects can also be represented with handles, allowing many operations to manipulate handles instead of whole objects. The copy-on-write and object registration techniques presented here reduce the cost of storing, copying, modifying, and matching hierarchical objects. Using object registration, identical objects are detected and shared, allowing objects to be uniquely identified by their location in memory. Copy-on-write object semantics allows increased sharing and reduced copying, while hierarchical copy-on-write objects using handles allows copies to have deep-copy behavior but shallow-copy cost. 
Abstract-found: 1
Intro-found: 1
Reference: [Cooper, 1989] <author> M. C. Cooper. </author> <title> Formal hierarchical object models for fast template matching. </title> <journal> The Computer Journal, </journal> <volume> 32(4) </volume> <pages> 351-361, </pages> <year> 1989. </year>
Reference-contexts: M. C. Cooper defines a data structure called a Repnet that takes advantage of the repetitions in hierarchical objects <ref> [Cooper, 1989] </ref>. His paper describes the application of these objects to template matching in computer vision algorithms. While a Repnet is a pixel-based structure, generalizing pixels to arbitrary objects gives a structure virtually the same as that produced by the Handle class described here.
Reference: [Cormen et al., 1990] <author> Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest. </author> <title> Intoduction To Algorithms. </title> <publisher> MIT Press and McGraw-Hill, </publisher> <year> 1990. </year>
Reference-contexts: The pointer returned by findMatch can be passed to remove to delete the item from the list. 2. Registered Copy-On-Write Objects 11 2.3.4 HashTable&lt;T&gt; This is a simple hash table class that stores elements of type T. It supports enough functions to act as a dictionary data structure <ref> [Cormen et al., 1990] </ref>. It is similar to the list class in several ways. It has a findMatch function like the list class that requires operator == to be defined on the type T. This findMatch has a second parameter found that return whether the element was found.
Reference: [Helmbold and McDowell, 1990] <author> D. P. Helmbold and C. E. McDowell. </author> <title> Computing reachable states of parallel programs. </title> <type> Technical report, </type> <institution> U. of Calif. Santa Cruz, UCSC-CRL-90-58, </institution> <year> 1990. </year>
Reference-contexts: The application is called START, which stands for Static Anomaly Reporting Tool. The input to the program is a graph representing the flow of control between synchronization events in a parallel program. Given this Sync Graph, the application builds a Concurrency History Graph or CHG of the concurrency states <ref> [Helmbold and McDowell, 1990] </ref>. In the process of finding the states and building the CHG, it also detects deadlock states. After computing all the states, they are displayed using the X Window System. Each node in the CHG is called a Cstate. A Cstate is a compressed concurrency state.
Reference: [Hoare, 1978] <author> C. A. R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> CACM., </journal> <volume> 21(8) </volume> <pages> 666-77, </pages> <year> 1978. </year>
Reference: [Nelson and Ousterhout, 1988] <author> Michael Nelson and John Ousterhout. </author> <title> Copy-on-write for Sprite. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pages 187-201. </pages> <publisher> USENIX, </publisher> <year> 1988. </year>
Reference: [Pohl, 1971] <author> Ira Pohl. </author> <title> Bi-directional search. </title> <editor> In Bernard Meltzer and Donald Michie, editors, </editor> <booktitle> Machine Intelligence, chapter 9, </booktitle> <pages> pages 127-140. </pages> <publisher> American Elsevier, </publisher> <address> New York, </address> <year> 1971. </year>
Reference-contexts: For example, given a 4 by 3 matrix, swap cards (1,1) and (2,1) in the minimal number of moves. A program was written to solve this problem using bi-directional search <ref> [Pohl, 1971] </ref>. Queue and hash table template classes were used as well as the UCOW handle class already described. Given the starting configuration and the goal configuration, the algorithm uses a breadth-first search from both configurations and prints the solution if the frontiers of the two searches meet.
Reference: [Stroustrup and Ellis, 1991] <author> Bjarne Stroustrup and Margaret A. Ellis. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference: [White, 1991] <author> Ronald G. White. </author> <title> Copy-on-write objects for C++. The C Users Journal, </title> <month> August </month> <year> 1991. </year>
Reference-contexts: Finally, we conclude with possible ideas for future work. 1.1 Related Work Copy-on-write virtual memory is widely used in operating systems [Nelson and Ouster-hout, 1988]. Ronald White implemented copy-on-write C++ objects using base classes, inheritance, and virtual functions <ref> [White, 1991] </ref>. This is the method I would have had to use if a C++ compiler with templates was not available. While Mr. White's objects are copy-on-write, multiple copies of the same object can still exist in memory at the same time, 1 leaving opportunities for further memory sharing. <p> This way the user can do without the overhead of unique objects if they are not needed. It might also be interesting to see what the implementation would look like if it uses virtual function polymorphism instead of templates. As in the COW objects described in <ref> [White, 1991] </ref>, implementing UCOW objects without templates would require some sort of virtual dup function to copy objects. All the template implementation needs to do is use the copy constructor. At the time of this writing, template support in most C++ compilers is still being refined.
Reference: [Winston and Horn, 1981] <author> Patrick Henry Winston and Berthold Klaus Paul Horn. </author> <title> LISP. </title> <publisher> Addison-Wesley, </publisher> <year> 1981. </year>
Reference-contexts: Since the pointers are guaranteed to point to unique objects, the objects are different if the pointers are different. If the pointers are the same, the objects they point to are therefore the same. In LISP, two lists can be EQUAL but not EQ 1 <ref> [Winston and Horn, 1981] </ref>. With UCOW objects, the distinction between EQUAL and EQ goes away. If two UCOW objects are EQUAL they must also be EQ. 2.1.3 Modify To modify a COW object, a writable copy of the object needs to be constructed by the handle.
References-found: 9

