URL: ftp://ftp.csd.uu.se/pub/papers/reports/0140.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Email: e-mail: fthomasl,permg@csd.uu.se  
Phone: Phone: +481818 25 00 Fax: +461851 19 25  
Title: precision of a simple structure analyzer  
Author: Thomas Lindgren, Per Mildner 
Address: Uppsala University  Box 311, S-751 05 Uppsala, Sweden  
Affiliation: Computing Science Department  
Note: The  A note to the referees: the paper contains a long appendix with the detailed measurement data. If accepted, some of these measurements will be presented as graphs in the main paper instead.  
Abstract: UPMAIL Technical Report No. 140 April 7, 1997 ISSN 1100-0686 Abstract Static information on the recursive structure of predicate arguments provides valuable information to optimizing compilers. In this paper, we investigate the precision of a structure analysis based on a restriction of type graphs, type jungles.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Cortesi, B. Le Charlier, P. Van Hentenryck, </author> <title> Combinations of abstract domains for logic programming, </title> <booktitle> Proc. </booktitle> <address> POPL'94, </address> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: The simplest approach is to precisely track term structure to some depth k, where k can be decided statically [8] or dynamically <ref> [1] </ref>. Unfortunately, this approach is limited in that it cannot represent disjunctive information (e.g., variable X is either a cons cell or the empty list). Taylor [14] extended the depth-k domain to represent recursive lists (only). This can markedly improvement analysis precision since lists are common. <p> If L = H, this denotes an integer constant. Atom. The set of all atoms. Struct. The set of all compound terms. Any. The set of all terms. On top of type jungles, we use a pattern domain along the lines of Le Charlier and Van Hentenryck <ref> [1] </ref>. Our pattern domain tracks term structure within a clause only. Our type jungle domain does not distinguish free variables from unknown terms. Since uninitialized arguments are fairly frequent [16, 9], we may thus misclassify a considerable number of free arguments as unknown.
Reference: [2] <author> P. Cousot, R. Cousot, </author> <title> Abstract interpretation and application to logic pro grams, </title> <journal> Journal of Logic Programming, 1992:13:103-179. </journal>
Reference-contexts: The resulting type jungle is an upper approximation of the type graph. 3 3 Type jungle analysis in practice 3.1 Implementation and abstract domains We have developed a dataflow analyzer based on abstract interpretation <ref> [2, 3] </ref>. The analyzer processes Prolog programs to derive type jungle call and success patterns for every program predicate. The analyzer is monovariant, in that it retains only one call/success pair per predicate. The analysis combines three abstract domains: type jungles, uninitialized variables and a pattern domain.
Reference: [3] <author> S.K. Debray, </author> <title> Efficient dataflow analysis of logic programs, </title> <journal> Journal of the ACM, </journal> <volume> Vol 39, No. 4, </volume> <month> October </month> <year> 1992. </year>
Reference-contexts: The resulting type jungle is an upper approximation of the type graph. 3 3 Type jungle analysis in practice 3.1 Implementation and abstract domains We have developed a dataflow analyzer based on abstract interpretation <ref> [2, 3] </ref>. The analyzer processes Prolog programs to derive type jungle call and success patterns for every program predicate. The analyzer is monovariant, in that it retains only one call/success pair per predicate. The analysis combines three abstract domains: type jungles, uninitialized variables and a pattern domain.
Reference: [4] <author> S.K. Debray, </author> <title> Static inference of modes and data dependencies in logic pro grams, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 11, No. 3, </volume> <month> July </month> <year> 1989, </year> <pages> pp. 418-450. </pages>
Reference-contexts: Recursive structure information allows the compiler to omit needless type checks as well as signal type errors. For this and related reasons, compile-time analysis for Prolog and related languages has attracted considerable interest <ref> [16, 14, 13, 4] </ref>. At one end of the spectrum of such analyses are structure analyses which attempt to find descriptions of the recursive structure of terms. Unfortunately, general structure analyses tend to be extravagantly expensive in time and memory usage [15, 7, 11].
Reference: [5] <author> T.W. Getzinger. </author> <title> Abstract interpretation for the compile-time optimization of logic programs, </title> <type> Ph.D. Thesis, </type> <institution> University of South California, </institution> <type> Report 93/09, </type> <year> 1993. </year>
Reference: [6] <author> R. Jain, </author> <title> The Art of Computer Systems Performance Analysis, </title> <publisher> Wiley, </publisher> <year> 1994. </year>
Reference-contexts: Dynamic call modes are shown in parentheses. GM is geometric mean (sum = 1.007) 7 95% confidence interval and found that it included zero, so the static and dynamic results are not widely different <ref> [6] </ref>. For some programs, the results varied widely. For example, the fraction of static bound call arguments in browse is 0.571, but dynamic measurements yield only 0.013.
Reference: [7] <author> G. Janssens, M. Bruynooghe, </author> <title> Deriving descriptions of possible values of pro gram variables by means of abstract interpretation, </title> <journal> Journal of Logic Programming 1992:13:205-258. </journal> <volume> 12 </volume>
Reference-contexts: At one end of the spectrum of such analyses are structure analyses which attempt to find descriptions of the recursive structure of terms. Unfortunately, general structure analyses tend to be extravagantly expensive in time and memory usage <ref> [15, 7, 11] </ref>. This restricts the applicability of structure analyses; e.g., compiler writers hesitate to use such analyses in a practical setting [14, p. 43]. In this paper, we propose a simplifying restriction of general type graphs, which yields a fast and precise analysis. <p> Taylor [14] extended the depth-k domain to represent recursive lists (only). This can markedly improvement analysis precision since lists are common. For other terms, a depth-k bound is maintained. Type graphs <ref> [7] </ref> are rational trees where nodes describe functors or disjunctions and leaves are constants or the distinguished node any 2 Type graphs can precisely describe most natural recursive types (e.g., the Hindley-Milner types). Type graph analysis then dynamically discovers the actual recursive types used in the program. <p> The main reason for this is that type graphs constructed during analysis can grow quite large and so preclude practical analyses. Experiments in a companion paper [11] indicate that currently used upper bound and widening algorithms <ref> [7, 15] </ref> can cause an explosion in graph size when run on realistic programs. Indeed, there is a simple and frequently occurring class of programs that triggers this misbehavior. In contrast, type jungles admit a simple and efficient implementation. <p> This scheme allows us to classify predicate arguments as (i) bound arguments, (ii) uninitialized arguments, or (iii) truly unknown arguments. 4 Type taxonomy Evaluations of type graph analyzers have used two measures. Bruynooghe and Janssen <ref> [7] </ref> classified arguments into bound, free or unknown. Van Hentenryck, Cortesi and Le Charlier [15] instead classified predicate arguments into one of several classes depending on the possible top-level functors or constants of the arguments. That is, they ignore the recursive structure of the type graph in classifying it.
Reference: [8] <author> T. Kanamori, T. Kawamura, </author> <title> Analysing success patterns of logic programs by abstract hybrid interpretation. </title> <type> Technical report, </type> <institution> ICOT, </institution> <year> 1987. </year>
Reference-contexts: We evaluate its precision in several ways, some of them novel. 1 1.1 Related work Several analyses have been proposed that derive recursive descriptions of terms 1 . The simplest approach is to precisely track term structure to some depth k, where k can be decided statically <ref> [8] </ref> or dynamically [1]. Unfortunately, this approach is limited in that it cannot represent disjunctive information (e.g., variable X is either a cons cell or the empty list). Taylor [14] extended the depth-k domain to represent recursive lists (only). This can markedly improvement analysis precision since lists are common.
Reference: [9] <author> T. Lindgren, </author> <title> Polyvariant detection of uninitialized arguments of Prolog pred icates, </title> <journal> Journal of Logic Programming, </journal> <month> September </month> <year> 1997. </year>
Reference-contexts: On top of type jungles, we use a pattern domain along the lines of Le Charlier and Van Hentenryck [1]. Our pattern domain tracks term structure within a clause only. Our type jungle domain does not distinguish free variables from unknown terms. Since uninitialized arguments are fairly frequent <ref> [16, 9] </ref>, we may thus misclassify a considerable number of free arguments as unknown. For this reason we have paired the type jungle analyzer with a monovariant analysis that derives uninitialized predicate arguments [9]. <p> Since uninitialized arguments are fairly frequent [16, 9], we may thus misclassify a considerable number of free arguments as unknown. For this reason we have paired the type jungle analyzer with a monovariant analysis that derives uninitialized predicate arguments <ref> [9] </ref>. The uninit analysis runs prior to the type jungle analysis, and the two analyses do not influence each other.
Reference: [10] <author> T. Lindgren, </author> <title> The impact of structure analysis on Prolog compilation, </title> <type> Tech nical report 142, </type> <institution> Computing Science Department, Uppsala University, </institution> <month> April </month> <year> 1997. </year>
Reference-contexts: In particular, there is a need for a good categorization of the structure of a type graph, rather than just the toplevel functor. A promising method for such measurement is to consider the usefulness of the derived type information <ref> [10] </ref>. Also, the interplay between static and dynamic precision merits further work.
Reference: [11] <author> P. Mildner, T. Lindgren, </author> <title> Type graphs in practice, </title> <type> technical report 141, </type> <institution> Com puting Science Department, Uppsala University, </institution> <month> April </month> <year> 1997. </year>
Reference-contexts: At one end of the spectrum of such analyses are structure analyses which attempt to find descriptions of the recursive structure of terms. Unfortunately, general structure analyses tend to be extravagantly expensive in time and memory usage <ref> [15, 7, 11] </ref>. This restricts the applicability of structure analyses; e.g., compiler writers hesitate to use such analyses in a practical setting [14, p. 43]. In this paper, we propose a simplifying restriction of general type graphs, which yields a fast and precise analysis. <p> This restriction may appear a draconic limitation of the expressiveness of type jungles; however, it also naturally restricts the size of the type jungle. While type graphs admit precise descriptions, the algorithms that work on type graphs can lead to unacceptable running times <ref> [11] </ref>. The main reason for this is that type graphs constructed during analysis can grow quite large and so preclude practical analyses. Experiments in a companion paper [11] indicate that currently used upper bound and widening algorithms [7, 15] can cause an explosion in graph size when run on realistic programs. <p> While type graphs admit precise descriptions, the algorithms that work on type graphs can lead to unacceptable running times <ref> [11] </ref>. The main reason for this is that type graphs constructed during analysis can grow quite large and so preclude practical analyses. Experiments in a companion paper [11] indicate that currently used upper bound and widening algorithms [7, 15] can cause an explosion in graph size when run on realistic programs. Indeed, there is a simple and frequently occurring class of programs that triggers this misbehavior. In contrast, type jungles admit a simple and efficient implementation. <p> The remaining programs are nand and chat parser. Analysis of nand required half a minute, while analysis of chat parser needed approximately 5.5 minutes. We note that these results are quite promising, and refer to a companion paper for a comparison with conventional type graph analyzers <ref> [11] </ref>. 6 Conclusion Contributions. This paper contributes a number of important concepts. * We propose type jungles, a restriction of type graphs which elides a number of problems with previous type graph analyzers. * We measure the precision of the structure analysis, and show that the pre cision is excellent.
Reference: [12] <author> J. Tan, I.-P. Lin, </author> <title> Type synthesis for logic programs, </title> <booktitle> in Proc. 1996 Joint In ternational Conference and Symposium on Logic Programming, </booktitle> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: Type graph analysis then dynamically discovers the actual recursive types used in the program. We take type graphs as the starting point of this work, and discuss them further below. Tan <ref> [12] </ref> has proposed a graph-based method for detecting general recursive structures. The method is fast, but does not distinguish variable instantiations at different program points. This limits precision, since it cannot take advantage of tests, but has a low complexity (quadratic).
Reference: [13] <author> Zoltan Somogyi, Fergus Henderson, Thomas Conway. </author> <title> The execution algo rithm of Mercury: an efficient purely declarative logic programming language, </title> <journal> Journal of Logic Programming, </journal> <year> 1996. </year>
Reference-contexts: Recursive structure information allows the compiler to omit needless type checks as well as signal type errors. For this and related reasons, compile-time analysis for Prolog and related languages has attracted considerable interest <ref> [16, 14, 13, 4] </ref>. At one end of the spectrum of such analyses are structure analyses which attempt to find descriptions of the recursive structure of terms. Unfortunately, general structure analyses tend to be extravagantly expensive in time and memory usage [15, 7, 11]. <p> The method is fast, but does not distinguish variable instantiations at different program points. This limits precision, since it cannot take advantage of tests, but has a low complexity (quadratic). A number of proposals have been made for static type checking of logic programming languages (e.g., <ref> [13] </ref>). Here, the possible types are declared by the programmer, followed by the compiler inferring the types of all variables. Programs that do not adhere to the type discipline are rejected. Hindley-Milner type inference has been shown to be practical for a range of languages.
Reference: [14] <author> A. Taylor. </author> <title> High Performance Prolog Implementation, </title> <type> Ph.D. Thesis, </type> <institution> Basser Dept. of Comp.Sci., University of Sydney, </institution> <year> 1991. </year>
Reference-contexts: Recursive structure information allows the compiler to omit needless type checks as well as signal type errors. For this and related reasons, compile-time analysis for Prolog and related languages has attracted considerable interest <ref> [16, 14, 13, 4] </ref>. At one end of the spectrum of such analyses are structure analyses which attempt to find descriptions of the recursive structure of terms. Unfortunately, general structure analyses tend to be extravagantly expensive in time and memory usage [15, 7, 11]. <p> Unfortunately, general structure analyses tend to be extravagantly expensive in time and memory usage [15, 7, 11]. This restricts the applicability of structure analyses; e.g., compiler writers hesitate to use such analyses in a practical setting <ref> [14, p. 43] </ref>. In this paper, we propose a simplifying restriction of general type graphs, which yields a fast and precise analysis. We evaluate its precision in several ways, some of them novel. 1 1.1 Related work Several analyses have been proposed that derive recursive descriptions of terms 1 . <p> The simplest approach is to precisely track term structure to some depth k, where k can be decided statically [8] or dynamically [1]. Unfortunately, this approach is limited in that it cannot represent disjunctive information (e.g., variable X is either a cons cell or the empty list). Taylor <ref> [14] </ref> extended the depth-k domain to represent recursive lists (only). This can markedly improvement analysis precision since lists are common. For other terms, a depth-k bound is maintained.
Reference: [15] <author> P. Van Hentenryck, A. Cortesi, B. Le Charlier. </author> <title> Type Analysis of Prolog Using Type Graphs, </title> <journal> Journal of Logic Programming, </journal> <pages> pp. 179-209, </pages> <year> 1995. </year>
Reference-contexts: At one end of the spectrum of such analyses are structure analyses which attempt to find descriptions of the recursive structure of terms. Unfortunately, general structure analyses tend to be extravagantly expensive in time and memory usage <ref> [15, 7, 11] </ref>. This restricts the applicability of structure analyses; e.g., compiler writers hesitate to use such analyses in a practical setting [14, p. 43]. In this paper, we propose a simplifying restriction of general type graphs, which yields a fast and precise analysis. <p> The main reason for this is that type graphs constructed during analysis can grow quite large and so preclude practical analyses. Experiments in a companion paper [11] indicate that currently used upper bound and widening algorithms <ref> [7, 15] </ref> can cause an explosion in graph size when run on realistic programs. Indeed, there is a simple and frequently occurring class of programs that triggers this misbehavior. In contrast, type jungles admit a simple and efficient implementation. <p> This scheme allows us to classify predicate arguments as (i) bound arguments, (ii) uninitialized arguments, or (iii) truly unknown arguments. 4 Type taxonomy Evaluations of type graph analyzers have used two measures. Bruynooghe and Janssen [7] classified arguments into bound, free or unknown. Van Hentenryck, Cortesi and Le Charlier <ref> [15] </ref> instead classified predicate arguments into one of several classes depending on the possible top-level functors or constants of the arguments. That is, they ignore the recursive structure of the type graph in classifying it.

References-found: 15

