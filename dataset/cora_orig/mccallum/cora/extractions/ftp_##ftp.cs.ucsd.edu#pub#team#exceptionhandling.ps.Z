URL: ftp://ftp.cs.ucsd.edu/pub/team/exceptionhandling.ps.Z
Refering-URL: http://www.cs.ucsd.edu/users/flaviu/publications.html
Root-URL: http://www.cs.ucsd.edu
Title: Exception Handling  
Author: Flaviu Cristian 
Address: La Jolla, CA 920930114  
Affiliation: Computer Science and Engineering Department University of California, San Diego  
Abstract: The first part of this paper provides rigorous definitions for several basic concepts underlying the design of dependable programs, such as specification, program semantics, exception, program correctness, robustness, failure, fault, and error. The second part investigates what it means to handle exceptions in modular programs structured as hierarchies of data abstractions. The problems to be solved at each abstraction level, such as exception detection and propagation, consistent state recovery and masking are examined in detail. Both programmed exception handling and default exception handling (such as embodied for example in recovery blocks or database transactions) are considered. An assessment of the adequacy of backward recovery in providing tolerance of software design faults is made. An earlier version of this paper was published in "Dependability of Resilient Computers", T. Anderson, Editor, BSP Professional Books, Blackwell Scientific Publications, UK, 1989, pp. 68-97 
Abstract-found: 1
Intro-found: 1
Reference: [Anderson81] <author> T. Anderson and P. A. Lee, </author> <title> Fault-Tolerance: </title> <booktitle> Principles and Practice, </booktitle> <publisher> Prentice Hall, </publisher> <month> December </month> <year> 1981. </year>
Reference-contexts: Early discussions of the issue were often marred by misunderstandings arising from the lack of precise definitions and terminology, but by the end of the 70s [Cristian79a], [Liskov79] it became clear that all proposed exception mechanisms can be classified into two basic categories: termination mechanisms <ref> [Anderson81] </ref>, [Back79], [Best81a], [Bron76], [Cristian79a], [Cristian80], [Horning74], [Ichbiah79], [Liskov79], [Melliar77], [Wulf75] and resumption mechanisms [Goodenough75], [Lampson74], [Levin77], [Parnas72b], [Yemini82]. For some time it was not clear which kind of mechanism will gain acceptance from programmers.
Reference: [Anderson85] <author> T. Anderson, P. A. Barrett, D. N. Hallivell, M. R. </author> <title> Moulding, "An evaluation of Software Fault Tolerance in a Practical System", </title> <booktitle> in Proceedings 15th International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pp. 140-145, </pages> <address> Ann Arbor, Michigan, </address> <year> 1985. </year>
Reference-contexts: Clearly, the use of automatic backward recovery improves the chance that crucial data will remain consistent in the presence of failure detections, since it provides tolerance for all confined design faults. Experimental studies confirm this <ref> [Anderson85] </ref>. However, to acquire confidence that a recovery block is capable of tolerating all design faults that might be contained in its alternates and acceptance test is in fact as hard as proving that these alternates together with the acceptance test are partially correct. <p> Empirical investigations of the likelihood of this goal being achieved for actual programs can be found in <ref> [Anderson85] </ref>, [Eckhardt91]. The second part of the paper investigates what is exception handling in programs structured as hierarchies of data abstractions. The answer proposed is a simple one. At each level of abstraction, exception handling consists of: detection, attempt at masking, consistent state recovery, and propagation.
Reference: [Avizienis84] <author> A. Avizienis, J. P. Kelly: </author> <title> "Fault-Tolerance by Design Diversity", </title> <journal> IEEE Computer, </journal> <volume> Vol. 17, No. 8, </volume> <pages> pp. 67-80, </pages> <year> 1984. </year>
Reference-contexts: Design-fault tolerant programming techniques start from the premise that the failure domains associated with program designs are never empty, and attempt to mask component program failures by relying on the use of design diversity <ref> [Avizienis84] </ref>, [Horning74]. The intention is to construct several program versions for a single specification so that the failure domain of the resulting multi-version program is smaller than the failure domains of the individual program versions used.
Reference: [Back79] <author> R. J. R. </author> <title> Back, "Exception Handling with multi exit statements", </title> <type> Technical report IW125, </type> <institution> Math. Cent. </institution> <address> Amsterdam, </address> <month> November </month> <year> 1979. </year>
Reference-contexts: Early discussions of the issue were often marred by misunderstandings arising from the lack of precise definitions and terminology, but by the end of the 70s [Cristian79a], [Liskov79] it became clear that all proposed exception mechanisms can be classified into two basic categories: termination mechanisms [Anderson81], <ref> [Back79] </ref>, [Best81a], [Bron76], [Cristian79a], [Cristian80], [Horning74], [Ichbiah79], [Liskov79], [Melliar77], [Wulf75] and resumption mechanisms [Goodenough75], [Lampson74], [Levin77], [Parnas72b], [Yemini82]. For some time it was not clear which kind of mechanism will gain acceptance from programmers. <p> The interest in partially correct programs comes from the fact that such programs are safe: they never output erroneous results to their users. Methods for verifying that programs with exceptions are partially correct are described in <ref> [Back79] </ref>, [Bron76], [Luckham80].
Reference: [Bernstein87] <author> P.A. Bernstein, V. Hadzilacos, N. Goodman, </author> <title> Concurrency Control and Recovery in Database Systems, </title> <publisher> Addison-Wesley, </publisher> <month> February </month> <year> 1987. </year>
Reference-contexts: Remark: The adjective "atomic" is over-used in the programming community and one has 12 to carefully distinguish among the different meanings it takes in different contexts. In a multiprocessing context, it is used to qualify the interference-free or serializable execution of parallel operations <ref> [Bernstein87] </ref>, [Best81b]. In a context in which program interpreter crashes can occur, a command C is said to be atomic with respect to crashes if a crash occurrence during the execution of C either causes no stable state transition or causes the stable state transition specified for C [Cristian85]. <p> Note also that in the literature on database transactions <ref> [Bernstein87] </ref>, [Gray93] it is standard to assume that transactions are implemented by partially correct programs. The occurrence of program failures can be attributed to the existence of design faults. <p> Checkpointing techniques have long been used for recovering consistent system states. Later, it has been proposed <ref> [Bernstein87] </ref>, [Gray93], [Horning74], to leave the task of computing the inconsistency closures associated with the intermediate inconsistent states 20 i through which a system may pass to special mechanisms, called recovery caches or log managers. The (automatic) recovery of inconsistency closures or checkpoints is referred to as backward recovery [Randell78]. <p> It is interesting to note that the default exception handling strategy embodied in SESAME is very similar to the undo-log based strategy used to abort transaction executions that result in unanticipated exception detections or assertion violations <ref> [Bernstein87] </ref>, [Gray93]. Most database systems do not attempt to mask transaction aborts caused by exception detections to users. The recovery block mechanism, devised at the University of Newcastle upon Tyne [Horn-ing74], was designed to solve all the problems (1)-(3) mentioned above. <p> Several problems posed by default exception handling in programming languages which support data abstraction (such as Ada) are. Finally, an assessment of the adequacy of automatic backward recovery based default exception handling (such as embodied in recovery blocks [Horning74] or database transactions <ref> [Bernstein87] </ref>, [Gray93]) in providing design-fault tolerance was provided: automatic backward recovery guarantees tolerance of design faults only in partially correct programs. 29
Reference: [Best81a] <author> E. Best and F. Cristian, </author> <title> "Systematic Detection of Exception Occurrences", </title> <booktitle> in Science of Computer Programming, </booktitle> <volume> Vol. 1, No. 1, </volume> <pages> pp. 115-144, </pages> <year> 1981. </year>
Reference-contexts: Early discussions of the issue were often marred by misunderstandings arising from the lack of precise definitions and terminology, but by the end of the 70s [Cristian79a], [Liskov79] it became clear that all proposed exception mechanisms can be classified into two basic categories: termination mechanisms [Anderson81], [Back79], <ref> [Best81a] </ref>, [Bron76], [Cristian79a], [Cristian80], [Horning74], [Ichbiah79], [Liskov79], [Melliar77], [Wulf75] and resumption mechanisms [Goodenough75], [Lampson74], [Levin77], [Parnas72b], [Yemini82]. For some time it was not clear which kind of mechanism will gain acceptance from programmers. <p> In the latter case, the detection of e in P coincides with the propagation of the (lower level) exception d in P. The problem of systematic placement of Boolean expressions in programs so as to detect all possible exception occurrences is investigated in <ref> [Best81a] </ref>, [Staknis87]. The verification methods described in [Cristian84] can be used to prove that all exceptions, whether detected by Boolean expression evaluations or lower level exception propagation, are correctly detected in a program. <p> In practice, postconditions usually contain logical quantifiers and other expressions not directly available in a programming language. Thus, to program a Boolean (executable) expression at with the same truth value as post may turn out to be at least as difficult as programming an alternate. (In <ref> [Best81a] </ref>, a methodology for splitting such monolithic acceptance checks into sets of simpler assertions without quantifiers spread among the intermediate operations which compose operations like P 0 , P 1 is investigated, but pursuing such a verification-oriented approach leads naturally to a programmed, rather than default, exception handling style.) What can
Reference: [Best81b] <author> E. Best and B. Randell, </author> <title> "A formal model of atomicity in Asynchronous Systems", </title> <journal> in Acta Informatica, </journal> <volume> Vol. 16, </volume> <pages> pp. 93-124, </pages> <year> 1981. </year>
Reference-contexts: Remark: The adjective "atomic" is over-used in the programming community and one has 12 to carefully distinguish among the different meanings it takes in different contexts. In a multiprocessing context, it is used to qualify the interference-free or serializable execution of parallel operations [Bernstein87], <ref> [Best81b] </ref>. In a context in which program interpreter crashes can occur, a command C is said to be atomic with respect to crashes if a crash occurrence during the execution of C either causes no stable state transition or causes the stable state transition specified for C [Cristian85].
Reference: [Bron76] <author> C. Bron, M. M. Fokkinga, A. C. M. de Haas, </author> <title> "A Proposal for Dealing with Abnormal Termination of Programs", </title> <type> Memorandum Nr. 150, </type> <institution> Department of Applied Mathematics, Twente University of Technology, Netherlands, </institution> <year> 1976. </year>
Reference-contexts: Early discussions of the issue were often marred by misunderstandings arising from the lack of precise definitions and terminology, but by the end of the 70s [Cristian79a], [Liskov79] it became clear that all proposed exception mechanisms can be classified into two basic categories: termination mechanisms [Anderson81], [Back79], [Best81a], <ref> [Bron76] </ref>, [Cristian79a], [Cristian80], [Horning74], [Ichbiah79], [Liskov79], [Melliar77], [Wulf75] and resumption mechanisms [Goodenough75], [Lampson74], [Levin77], [Parnas72b], [Yemini82]. For some time it was not clear which kind of mechanism will gain acceptance from programmers. <p> The interest in partially correct programs comes from the fact that such programs are safe: they never output erroneous results to their users. Methods for verifying that programs with exceptions are partially correct are described in [Back79], <ref> [Bron76] </ref>, [Luckham80].
Reference: [Campbell86] <author> R. H. Campbell, B. Randell, </author> <title> "Error Recovery in Asynchronous Systems", </title> <journal> IEEE Transactions on Software Engineering Vol. </journal> <volume> SE-12, No.8, </volume> <pages> pp. 811-826, </pages> <year> 1986. </year>
Reference-contexts: The purpose of this paper is to present a synthesis of the termination exception handling paradigm. We only deal with sequential programs. Exception handling in parallel and distributed programs is still an evolving subject where no clear consensus exists <ref> [Campbell86] </ref>, [Cristian79b], [Jalote84], [Kim82], [Liskov82], [Randell75], [Schlichting87], [Shrivastava78], 2 [Wood81]. In our discussion we will only examine exceptions detected in programs, and will assume that the compilers, linkeditors and lower level hardware all work properly.
Reference: [Cheriton86] <author> D. Cheriton, </author> <title> "Making Exceptions Simplify the Rule (and Justify their Handling", </title> <booktitle> in Proc. IFIP Congress 86, </booktitle> <pages> pp. 27-33, </pages> <year> 1986. </year>
Reference-contexts: If the probability of invoking the program in its standard domain is in general greater than that of invoking it in its exceptional domain, this definition is consistent with the probabilistic point of view adopted in <ref> [Cheriton86] </ref>. However, unlike in [Cheriton86], we view exceptions purely as a specification and program structuring tool, and we refrain from discussing the criteria to be used when deciding on how to use exceptions to structure programs. Our definitions are general precisely because they are independent from any such criteria. <p> If the probability of invoking the program in its standard domain is in general greater than that of invoking it in its exceptional domain, this definition is consistent with the probabilistic point of view adopted in <ref> [Cheriton86] </ref>. However, unlike in [Cheriton86], we view exceptions purely as a specification and program structuring tool, and we refrain from discussing the criteria to be used when deciding on how to use exceptions to structure programs. Our definitions are general precisely because they are independent from any such criteria.
Reference: [Cristian79a] <author> F. Cristian, </author> <title> "Le Traitement des Exceptions dans les Programmes Modulaires", </title> <type> Ph.D. </type> <institution> Disertation, University of Grenoble, Grenoble, France, </institution> <year> 1979. </year>
Reference-contexts: The first papers entirely devoted to exception handling began to appear only in the 70s, e.g. [Goodenough75], [Horning74], [Parnas72b], [Wulf75]. Early discussions of the issue were often marred by misunderstandings arising from the lack of precise definitions and terminology, but by the end of the 70s <ref> [Cristian79a] </ref>, [Liskov79] it became clear that all proposed exception mechanisms can be classified into two basic categories: termination mechanisms [Anderson81], [Back79], [Best81a], [Bron76], [Cristian79a], [Cristian80], [Horning74], [Ichbiah79], [Liskov79], [Melliar77], [Wulf75] and resumption mechanisms [Goodenough75], [Lampson74], [Levin77], [Parnas72b], [Yemini82]. <p> Early discussions of the issue were often marred by misunderstandings arising from the lack of precise definitions and terminology, but by the end of the 70s <ref> [Cristian79a] </ref>, [Liskov79] it became clear that all proposed exception mechanisms can be classified into two basic categories: termination mechanisms [Anderson81], [Back79], [Best81a], [Bron76], [Cristian79a], [Cristian80], [Horning74], [Ichbiah79], [Liskov79], [Melliar77], [Wulf75] and resumption mechanisms [Goodenough75], [Lampson74], [Levin77], [Parnas72b], [Yemini82]. For some time it was not clear which kind of mechanism will gain acceptance from programmers. Convincing arguments that the termination paradigm is superior to the resumption paradigm are presented in [Cristian79a], [Liskov79] and will not <p> [Anderson81], [Back79], [Best81a], [Bron76], <ref> [Cristian79a] </ref>, [Cristian80], [Horning74], [Ichbiah79], [Liskov79], [Melliar77], [Wulf75] and resumption mechanisms [Goodenough75], [Lampson74], [Levin77], [Parnas72b], [Yemini82]. For some time it was not clear which kind of mechanism will gain acceptance from programmers. Convincing arguments that the termination paradigm is superior to the resumption paradigm are presented in [Cristian79a], [Liskov79] and will not be repeated here. Recent developments confirm the view that termination mechanisms are superior. Practical feedback from users of of the Mesa programming language [Mitchell79] incorporating the resumption mechanism of [Lampson74] indicates that the use of this type of mechanism can be quite fault-prone [Horning78], [Levin85]. <p> The symbol (which cannot be confused with an exception label) will be used to denote the standard exit point of a program. Since all examples to be given in this paper are phrased in terms of the simple exception mechanism defined in <ref> [Cristian79a] </ref>, [Cristian84], it is appropriate at this point to briefly recall its main characteristics. The designer of a procedure P indicates that P has an exceptional exit point "e" by declaring "e" in the header of P as follows: procedure P signals e. <p> This example illustrates two points. First, the "[DET:" symbol used previously in Figure 7 may sometimes be a sequence of "O [d:" detection symbols (this is frequently the case when dealing with exceptions due to transient input/output faults <ref> [Cristian79a] </ref>). Second, lower level exception propagations can be stopped by higher lever procedures. If a procedure Q can provide its standard service despite the fact that a lower level exception e is propagated in Q, we say that Q masks the propagation of e. <p> Thus, there is a danger that later invocations of M will lead to unpredictable results and to additional unanticipated exception propagations. A different approach to the problem of handling detectable failure occurrences is discussed in <ref> [Cristian79a] </ref>, and [Horning74], [Liskov79]. The basic idea is quite simple: associate a default handler DH, with any lower level (unanticipated) exception u propagated in a procedure exported by a module M. <p> Thus, one can regard the default exception handling strategy of CLU as being more oriented towards off-line debugging rather than towards the provision of on-line software-fault tolerance. The default exception handling strategy proposed for the SESAME programming language developed at the University of Grenoble <ref> [Cristian79a] </ref> was oriented towards solving the consistent state recovery (2) and propagation (3) problems. (The masking problem (1) can also be solved by using our mechanism, as will be shown later, but we have not dealt with this issue in [Cristian79a].) The solution proposed to problem (2) is based on the <p> the SESAME programming language developed at the University of Grenoble <ref> [Cristian79a] </ref> was oriented towards solving the consistent state recovery (2) and propagation (3) problems. (The masking problem (1) can also be solved by using our mechanism, as will be shown later, but we have not dealt with this issue in [Cristian79a].) The solution proposed to problem (2) is based on the fact that, for any exception which can be detected in a procedure M.P, there exists a recovery set, i.e., the inconsistency closure, which can be determined at run-time without having any knowledge about the semantics of M.P. <p> Most database systems do not attempt to mask transaction aborts caused by exception detections to users. The recovery block mechanism, devised at the University of Newcastle upon Tyne [Horn-ing74], was designed to solve all the problems (1)-(3) mentioned above. Unlike the mechanisms described in <ref> [Cristian79a] </ref> and [Liskov79] which support both explicit and default exception handling, the recovery block mechanism is a pure default exception handling mechanism based on automatic backward recovery.
Reference: [Cristian79b] <author> F. Cristian: </author> <title> "A Recovery Mechanism for Modular Software", </title> <booktitle> in Proc. 4th Int. Conf. on Software Eng, </booktitle> <address> Munich, </address> <year> 1979. </year>
Reference-contexts: The purpose of this paper is to present a synthesis of the termination exception handling paradigm. We only deal with sequential programs. Exception handling in parallel and distributed programs is still an evolving subject where no clear consensus exists [Campbell86], <ref> [Cristian79b] </ref>, [Jalote84], [Kim82], [Liskov82], [Randell75], [Schlichting87], [Shrivastava78], 2 [Wood81]. In our discussion we will only examine exceptions detected in programs, and will assume that the compilers, linkeditors and lower level hardware all work properly. <p> A recovery cache mechanism (more simple than that of [Horning74] because of the modular scope rules of SESAME) was designed for the automatic update of the inconsistency closures associated with all intermediate states through which a system may pass. A detailed description of this mechanism has already been published <ref> [Cristian79b] </ref>, so we will not repeat it here. To enable the automatic recovery of inconsistency closures, a reset primitive was made available in the SESAME language (as a compilation option). When invoked, reset recovers the "current" IC and returns normally.
Reference: [Cristian80] <author> F. Cristian, </author> <title> "Exception Handling and Software Fault-Tolerance", </title> <booktitle> in Proceedings 10th International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pp. 97-103, </pages> <year> 1980, </year> <journal> Kyoto; also in IEEE Transactions on Computers, </journal> <volume> Vol. C-31, No. 6, </volume> <pages> pp. 531-540, </pages> <year> 1982. </year>
Reference-contexts: Early discussions of the issue were often marred by misunderstandings arising from the lack of precise definitions and terminology, but by the end of the 70s [Cristian79a], [Liskov79] it became clear that all proposed exception mechanisms can be classified into two basic categories: termination mechanisms [Anderson81], [Back79], [Best81a], [Bron76], [Cristian79a], <ref> [Cristian80] </ref>, [Horning74], [Ichbiah79], [Liskov79], [Melliar77], [Wulf75] and resumption mechanisms [Goodenough75], [Lampson74], [Levin77], [Parnas72b], [Yemini82]. For some time it was not clear which kind of mechanism will gain acceptance from programmers.
Reference: [Cristian82] <author> F. Cristian, </author> <title> "Robust data types", </title> <journal> Acta Informatica, </journal> <volume> Vol. 17, </volume> <pages> pp. 365-397, </pages> <year> 1982. </year>
Reference-contexts: For an external observer, any invocation of such a program has an "all or nothing" effect: either the specified standard state transition is produced or an exception is signalled and the state remains unchanged. Methods for proving the correctness of data abstractions with atomic operations are discussed in <ref> [Cristian82] </ref>. Remark: The adjective "atomic" is over-used in the programming community and one has 12 to carefully distinguish among the different meanings it takes in different contexts. In a multiprocessing context, it is used to qualify the interference-free or serializable execution of parallel operations [Bernstein87], [Best81b]. <p> To keep the presentation short, we give fewer examples than in the first, more introductory, part. Detailed examples of the often tricky problems posed by exception handling in programs structured as hierarchies of abstract data types can be found in <ref> [Cristian82] </ref>. HIERARCHICAL PROGRAM STRUCTURE In the 70s, it became clear that data abstraction is a powerful mechanism for mastering the complexity of programs [Hoare72], [Liskov74], [Parnas72a], [Wulf76]. <p> We use the phrase "handler associated with" to state a syntactic fact and the phrase "handler of" to reflect a semantic knowledge. When an exception occurrence is detected in a module M, an intermediate inconsistent state outside the set I may exist. An example in <ref> [Cristian82] </ref> illustrates that further invocations of a module left in such a state (by some exception occurrence not appropriately handled) can lead to unpredictable (i.e., unspecified) results and to subsequent unanticipated exception occurrences. <p> Because of this minimality property, an IS can be regarded as being a characterization of that part of the state which is "effectively" inconsistent when the occurrence of e is detected. For nontrivial examples of inconsistency and recovery sets, the interested reader is referred to <ref> [Cristian82] </ref>. If the decision is taken that module operations should be atomic with respect to exceptions, then two other kinds of recovery sets may be of interest.
Reference: [Cristian84] <author> F. Cristian, </author> <title> "Correct and Robust Programs", </title> <journal> IEEE Trans. on Software. Eng., </journal> <volume> 30 Vol. SE-10, No. 2, </volume> <pages> pp. 163-174, </pages> <year> 1984. </year>
Reference-contexts: The characteristic predicate of the standard domain can be computed as being the weakest precondition for which P terminates normally in a final state satisfying G [Dijkstra76], <ref> [Cristian84] </ref>. EXCEPTIONAL PROGRAM SPECIFICATION AND SEMANTICS If a program P is invoked in an initial state which is outside the standard domain SD, the standard service G specified for P can not be provided by P. <p> The symbol (which cannot be confused with an exception label) will be used to denote the standard exit point of a program. Since all examples to be given in this paper are phrased in terms of the simple exception mechanism defined in [Cristian79a], <ref> [Cristian84] </ref>, it is appropriate at this point to briefly recall its main characteristics. The designer of a procedure P indicates that P has an exceptional exit point "e" by declaring "e" in the header of P as follows: procedure P signals e. <p> The problem of systematic placement of Boolean expressions in programs so as to detect all possible exception occurrences is investigated in [Best81a], [Staknis87]. The verification methods described in <ref> [Cristian84] </ref> can be used to prove that all exceptions, whether detected by Boolean expression evaluations or lower level exception propagation, are correctly detected in a program. <p> For example, P might terminate normally ((s,s')2 [P ] ) if invoked in initial states s for which the specification does not prescribe normal termination (s =2 dom (G )). Methods for proving the total correctness of programs with exceptions are discussed in <ref> [Cristian84] </ref>. For example, the program FE is totally correct with respect to the specification GF, but is incorrect with respect to the complete specification CGF. An example program RFE (Robust Factorial with Exceptions) that is totally correct with respect to the complete specification CGF is given in Figure 3. <p> Although the basic idea behind atomicity with respect to exceptions and atomicity with respect to crashes is the same, work on verifying atomicity with respect to crashes and atomicity with respect to exceptions shows that these are two fairly distinct concepts, usually implemented by distinct run-time mechanisms <ref> [Cristian84] </ref>, [Cristian85]. End of remark. If a program P is not totally correct with respect to a specification G, there exist (anticipated) input states s 2 AI for which P's behavior contradicts G. <p> The characteristic predicate of the AED domain can be computed as being the disjunction of the weakest preconditions for which P terminates at declared exit points e in final states satisfying the exceptional specifications G e <ref> [Cristian84] </ref>. As an example, observe that the failure domain of the program FE with respect to the specification CGF is the set of all positive integers with non machine representable factorials. <p> A goal of good software practice is to make sure that the FD and UI domains are empty. Methods for computing the domains SD, AED, FD for programs with exceptions are described in <ref> [Cristian84] </ref>. 13 A program failure occurs when a program is invoked in its failure domain FD. Thus, a program failure is synonymous with divergence between specified and actual program behavior.
Reference: [Cristian85] <author> F. Cristian, </author> <title> "A Rigorous Approach to Fault-Tolerant Programming", </title> <journal> IEEE Trans. on Software. Eng., </journal> <volume> Vol. SE-11, No. 1, </volume> <pages> pp. 23-31, </pages> <year> 1985. </year>
Reference-contexts: In a context in which program interpreter crashes can occur, a command C is said to be atomic with respect to crashes if a crash occurrence during the execution of C either causes no stable state transition or causes the stable state transition specified for C <ref> [Cristian85] </ref>. Clearly atomicity with respect to concurrency on one side and atomicity with respect to exceptions or crashes on the other side are fairly distinct, orthogonal concepts. <p> Although the basic idea behind atomicity with respect to exceptions and atomicity with respect to crashes is the same, work on verifying atomicity with respect to crashes and atomicity with respect to exceptions shows that these are two fairly distinct concepts, usually implemented by distinct run-time mechanisms [Cristian84], <ref> [Cristian85] </ref>. End of remark. If a program P is not totally correct with respect to a specification G, there exist (anticipated) input states s 2 AI for which P's behavior contradicts G.
Reference: [Cristian91] <author> F. Cristian, </author> <title> "Understanding Fault-Tolerant Systems", </title> <journal> Communications of the ACM, </journal> <volume> Vol. 34, No. 2, </volume> <month> Feb </month> <year> 1991, </year> <pages> pp. 56-78. </pages>
Reference-contexts: In our discussion we will only examine exceptions detected in programs, and will assume that the compilers, linkeditors and lower level hardware all work properly. For a text attempting to integrate software and hardware aspects of fault-tolerance, the interested reader is refered to <ref> [Cristian91] </ref>. PART 1: BASIC NOTIONS The goal of this part of the paper is to provide rigorous definitions for such basic concepts as program specification, program semantics, exception, program correctness and robustness, failure, fault and error.
Reference: [Dijkstra76] <author> E. W. Dikstra, </author> <title> "A Discipline of Programming", </title> <publisher> Prentice Hall, </publisher> <year> 1976. </year>
Reference-contexts: The characteristic predicate of the standard domain can be computed as being the weakest precondition for which P terminates normally in a final state satisfying G <ref> [Dijkstra76] </ref>, [Cristian84]. EXCEPTIONAL PROGRAM SPECIFICATION AND SEMANTICS If a program P is invoked in an initial state which is outside the standard domain SD, the standard service G specified for P can not be provided by P.
Reference: [R. Floyd67] <author> R. Floyd, </author> <title> "Assigning meaning to programs", </title> <booktitle> in Mathematical Aspects of Computer Science., </booktitle> <volume> Vol. 19, </volume> <publisher> American Mathematical Society, </publisher> <pages> pp. 19-31, </pages> <year> 1967. </year>
Reference: [Eckhardt91] <author> D. Eckhardt, A. Caglayan, J. Knight, L. Lee, D. McAllister, M. Vouk, J. Kelly, </author> <title> "An Experimental Evaluation of Software Redundancy as a Strategy for Improving Reliability", </title> <journal> IEEE Tr. on Software Engineering, </journal> <volume> Vol. 17, N0. 7, </volume> <month> July </month> <year> 1991, </year> <pages> pp. 692-701. </pages>
Reference-contexts: Empirical investigations of the likelihood of this goal being achieved for actual programs can be found in [Anderson85], <ref> [Eckhardt91] </ref>. The second part of the paper investigates what is exception handling in programs structured as hierarchies of data abstractions. The answer proposed is a simple one. At each level of abstraction, exception handling consists of: detection, attempt at masking, consistent state recovery, and propagation.
Reference: [Goodenough75] <author> J. Goodenough, </author> <title> "Exception Handling, Issues and a Proposed Notation", </title> <journal> Communications ACM., </journal> <volume> Vol. 18, No. 12, </volume> <pages> pp. 683-696, </pages> <year> 1975. </year>
Reference-contexts: In the early stages of programming methodology development in the 60s, research has mostly focused on mastering the complexity inherent in the usual or standard program behavior. The first papers entirely devoted to exception handling began to appear only in the 70s, e.g. <ref> [Goodenough75] </ref>, [Horning74], [Parnas72b], [Wulf75]. <p> misunderstandings arising from the lack of precise definitions and terminology, but by the end of the 70s [Cristian79a], [Liskov79] it became clear that all proposed exception mechanisms can be classified into two basic categories: termination mechanisms [Anderson81], [Back79], [Best81a], [Bron76], [Cristian79a], [Cristian80], [Horning74], [Ichbiah79], [Liskov79], [Melliar77], [Wulf75] and resumption mechanisms <ref> [Goodenough75] </ref>, [Lampson74], [Levin77], [Parnas72b], [Yemini82]. For some time it was not clear which kind of mechanism will gain acceptance from programmers. Convincing arguments that the termination paradigm is superior to the resumption paradigm are presented in [Cristian79a], [Liskov79] and will not be repeated here.
Reference: [Gray93] <author> J. Gray, A. </author> <title> Reuter "Transaction Processing: Concepts and Techniques", </title> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1993. </year>
Reference-contexts: Our notion of partial correctness is however such a natural extension of the classical notion that we feel it does not justify the introduction of a new term for it (in <ref> [Gray93] </ref> programs that are partially correct in the sense of having empty UI and UFD domains are termed "fail-fast"). The interest in partially correct programs comes from the fact that such programs are safe: they never output erroneous results to their users. <p> Note also that in the literature on database transactions [Bernstein87], <ref> [Gray93] </ref> it is standard to assume that transactions are implemented by partially correct programs. The occurrence of program failures can be attributed to the existence of design faults. <p> Checkpointing techniques have long been used for recovering consistent system states. Later, it has been proposed [Bernstein87], <ref> [Gray93] </ref>, [Horning74], to leave the task of computing the inconsistency closures associated with the intermediate inconsistent states 20 i through which a system may pass to special mechanisms, called recovery caches or log managers. The (automatic) recovery of inconsistency closures or checkpoints is referred to as backward recovery [Randell78]. <p> It is interesting to note that the default exception handling strategy embodied in SESAME is very similar to the undo-log based strategy used to abort transaction executions that result in unanticipated exception detections or assertion violations [Bernstein87], <ref> [Gray93] </ref>. Most database systems do not attempt to mask transaction aborts caused by exception detections to users. The recovery block mechanism, devised at the University of Newcastle upon Tyne [Horn-ing74], was designed to solve all the problems (1)-(3) mentioned above. <p> Several problems posed by default exception handling in programming languages which support data abstraction (such as Ada) are. Finally, an assessment of the adequacy of automatic backward recovery based default exception handling (such as embodied in recovery blocks [Horning74] or database transactions [Bernstein87], <ref> [Gray93] </ref>) in providing design-fault tolerance was provided: automatic backward recovery guarantees tolerance of design faults only in partially correct programs. 29
Reference: [Hoare69] <author> C. A. R. Hoare, </author> <title> "An axiomatic approach to Computer Programming", </title> <journal> Communications ACM, </journal> <volume> Vol. 12, No. 10, </volume> <pages> pp. 576-580, </pages> <year> 1969. </year>
Reference-contexts: In other terms, a partially correct program is one that has empty UI and UFD domains. This notion of partial correctness is somewhat different from the classical notion of partial correctness [Floyd67], <ref> [Hoare69] </ref>, where partial correctness is defined in term of a pre and postcondition. In this paper, when we talk about partial correctness we assume a constantly true precondiditon and a complete specification.
Reference: [Hoare72] <author> C. A. R. Hoare, </author> <title> "Proof of Correctness of Data Representations", </title> <journal> Acta Informat-ica, </journal> <volume> Vol. 1, No. 4, </volume> <pages> pp. 271-281, </pages> <year> 1972. </year>
Reference-contexts: Detailed examples of the often tricky problems posed by exception handling in programs structured as hierarchies of abstract data types can be found in [Cristian82]. HIERARCHICAL PROGRAM STRUCTURE In the 70s, it became clear that data abstraction is a powerful mechanism for mastering the complexity of programs <ref> [Hoare72] </ref>, [Liskov74], [Parnas72a], [Wulf76]. <p> The internal state of a module M is the aggregation of the abstract states of its state variables. The abstract state of M is the result of applying an abstraction function A to its internal state <ref> [Hoare72] </ref>, [Wulf76]. In general, A is a partial function defined only over a subset I S of the set of all possible internal states of the module. (In practice, this subset is defined by using an invariant predicate [Hoare72], [Wulf76].) The internal states in I are said to be consistent with <p> the result of applying an abstraction function A to its internal state <ref> [Hoare72] </ref>, [Wulf76]. In general, A is a partial function defined only over a subset I S of the set of all possible internal states of the module. (In practice, this subset is defined by using an invariant predicate [Hoare72], [Wulf76].) The internal states in I are said to be consistent with the abstraction that the module is intended to implement.
Reference: [Horning74] <author> J. J. Horning, H. C. Lauer, P. M. Melliar-Smith, and B. Randell, </author> <title> "A Program Structure for Error Detection and Recovery", </title> <booktitle> in Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 16 (Springer-Verlag) New York, </publisher> <year> 1974. </year>
Reference-contexts: In the early stages of programming methodology development in the 60s, research has mostly focused on mastering the complexity inherent in the usual or standard program behavior. The first papers entirely devoted to exception handling began to appear only in the 70s, e.g. [Goodenough75], <ref> [Horning74] </ref>, [Parnas72b], [Wulf75]. <p> discussions of the issue were often marred by misunderstandings arising from the lack of precise definitions and terminology, but by the end of the 70s [Cristian79a], [Liskov79] it became clear that all proposed exception mechanisms can be classified into two basic categories: termination mechanisms [Anderson81], [Back79], [Best81a], [Bron76], [Cristian79a], [Cristian80], <ref> [Horning74] </ref>, [Ichbiah79], [Liskov79], [Melliar77], [Wulf75] and resumption mechanisms [Goodenough75], [Lampson74], [Levin77], [Parnas72b], [Yemini82]. For some time it was not clear which kind of mechanism will gain acceptance from programmers. <p> Both programmed and default exception handling methods are considered. An assessment of the effectiveness of backward recovery based default exception handling (as embodied for example in the recovery block mechanism 16 <ref> [Horning74] </ref>) in providing effective tolerance of residual design faults is provided. The scope of this paper is limited to discussing tolerance of program design faults, not specification or interpreter faults, so we assume complete and consistent specifications and a fault-free program interpreter (e.g. compiler, hardware processor, operating system kernel). <p> Checkpointing techniques have long been used for recovering consistent system states. Later, it has been proposed [Bernstein87], [Gray93], <ref> [Horning74] </ref>, to leave the task of computing the inconsistency closures associated with the intermediate inconsistent states 20 i through which a system may pass to special mechanisms, called recovery caches or log managers. The (automatic) recovery of inconsistency closures or checkpoints is referred to as backward recovery [Randell78]. <p> Thus, there is a danger that later invocations of M will lead to unpredictable results and to additional unanticipated exception propagations. A different approach to the problem of handling detectable failure occurrences is discussed in [Cristian79a], and <ref> [Horning74] </ref>, [Liskov79]. The basic idea is quite simple: associate a default handler DH, with any lower level (unanticipated) exception u propagated in a procedure exported by a module M. <p> The exceptional service that such a handler attempts to provide can be identified by a language defined exception label "failure" [Cris-tian79b], [Liskov79], or "error" <ref> [Horning74] </ref>. The systematic addition of default handlers to all procedures exported by modules, written in a language in which the "failure" exception is predefined, has the following consequences. <p> A recovery cache mechanism (more simple than that of <ref> [Horning74] </ref> because of the modular scope rules of SESAME) was designed for the automatic update of the inconsistency closures associated with all intermediate states through which a system may pass. A detailed description of this mechanism has already been published [Cristian79b], so we will not repeat it here. <p> Design-fault tolerant programming techniques start from the premise that the failure domains associated with program designs are never empty, and attempt to mask component program failures by relying on the use of design diversity [Avizienis84], <ref> [Horning74] </ref>. The intention is to construct several program versions for a single specification so that the failure domain of the resulting multi-version program is smaller than the failure domains of the individual program versions used. <p> Several problems posed by default exception handling in programming languages which support data abstraction (such as Ada) are. Finally, an assessment of the adequacy of automatic backward recovery based default exception handling (such as embodied in recovery blocks <ref> [Horning74] </ref> or database transactions [Bernstein87], [Gray93]) in providing design-fault tolerance was provided: automatic backward recovery guarantees tolerance of design faults only in partially correct programs. 29
Reference: [Horning78] <author> J. J. Horning, </author> <title> "Language Features for Fault-Tolerance", </title> <booktitle> in Lecture Notes, Advanced Course on Computing Systems Reliability, </booktitle> <institution> University of Newcastle upon Tyne, </institution> <month> August, </month> <year> 1978. </year>
Reference-contexts: Recent developments confirm the view that termination mechanisms are superior. Practical feedback from users of of the Mesa programming language [Mitchell79] incorporating the resumption mechanism of [Lampson74] indicates that the use of this type of mechanism can be quite fault-prone <ref> [Horning78] </ref>, [Levin85]. Interestingly enough, some of the main proponents of the resumption philosophy (B. Lampson, R. Levin, J. Mitchell, D. Parnas) have abandoned it in favor of the termination philosophy [Levin85], [Mitchell93], [Parnas85]. Widely used programming languages such as Ada and C++ have termination exception handling mechanisms.
Reference: [Ichbiah79] <author> J. Ichbiah et al., </author> <title> "Rationale for the Design of the ADA Programming Language", </title> <journal> in SIGPLAN Notices, </journal> <volume> Vol. 14, No. 6, </volume> <year> 1979. </year>
Reference-contexts: of the issue were often marred by misunderstandings arising from the lack of precise definitions and terminology, but by the end of the 70s [Cristian79a], [Liskov79] it became clear that all proposed exception mechanisms can be classified into two basic categories: termination mechanisms [Anderson81], [Back79], [Best81a], [Bron76], [Cristian79a], [Cristian80], [Horning74], <ref> [Ichbiah79] </ref>, [Liskov79], [Melliar77], [Wulf75] and resumption mechanisms [Goodenough75], [Lampson74], [Levin77], [Parnas72b], [Yemini82]. For some time it was not clear which kind of mechanism will gain acceptance from programmers. <p> a failure of M.P remains undetected after a proper termination of M.P will be discussed later. 22 Now, what is a sensible reaction to such a situation? For example, what exceptional con-tinuation should be associated with the exception u propagated from a lower level? One possible solution (adopted in ADA <ref> [Ichbiah79] </ref>) is to continue the propagation of u in the higher level module N. Such free exception propagations across module boundaries may have dangerous consequences.
Reference: [Jalote84] <author> P. Jalote, R. H. Campbell, </author> <title> "Fault-tolerance using communicating sequential processes", </title> <booktitle> in Proc. 14th Int. Conf. on Fault-Tolerant Computing, </booktitle> <pages> pp. 347-352, </pages> <year> 1984. </year>
Reference-contexts: The purpose of this paper is to present a synthesis of the termination exception handling paradigm. We only deal with sequential programs. Exception handling in parallel and distributed programs is still an evolving subject where no clear consensus exists [Campbell86], [Cristian79b], <ref> [Jalote84] </ref>, [Kim82], [Liskov82], [Randell75], [Schlichting87], [Shrivastava78], 2 [Wood81]. In our discussion we will only examine exceptions detected in programs, and will assume that the compilers, linkeditors and lower level hardware all work properly.
Reference: [Kim82] <author> K. H. Kim, </author> <title> "Approaches to mechanization of the conversation scheme based on monitors", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-8, </volume> <pages> pp. 189-197, </pages> <month> May, </month> <year> 1982. </year>
Reference-contexts: The purpose of this paper is to present a synthesis of the termination exception handling paradigm. We only deal with sequential programs. Exception handling in parallel and distributed programs is still an evolving subject where no clear consensus exists [Campbell86], [Cristian79b], [Jalote84], <ref> [Kim82] </ref>, [Liskov82], [Randell75], [Schlichting87], [Shrivastava78], 2 [Wood81]. In our discussion we will only examine exceptions detected in programs, and will assume that the compilers, linkeditors and lower level hardware all work properly.
Reference: [Lampson74] <author> B. Lampson, J. Mitchell, E. Satterthwite, </author> <title> "On the Transfer of Control Between Contexts", </title> <booktitle> in Lecture Notes in Computer Science, </booktitle> <volume> Vol. 19, </volume> <pages> pp. 181-203, </pages> <year> 1974. </year>
Reference-contexts: arising from the lack of precise definitions and terminology, but by the end of the 70s [Cristian79a], [Liskov79] it became clear that all proposed exception mechanisms can be classified into two basic categories: termination mechanisms [Anderson81], [Back79], [Best81a], [Bron76], [Cristian79a], [Cristian80], [Horning74], [Ichbiah79], [Liskov79], [Melliar77], [Wulf75] and resumption mechanisms [Goodenough75], <ref> [Lampson74] </ref>, [Levin77], [Parnas72b], [Yemini82]. For some time it was not clear which kind of mechanism will gain acceptance from programmers. Convincing arguments that the termination paradigm is superior to the resumption paradigm are presented in [Cristian79a], [Liskov79] and will not be repeated here. <p> Convincing arguments that the termination paradigm is superior to the resumption paradigm are presented in [Cristian79a], [Liskov79] and will not be repeated here. Recent developments confirm the view that termination mechanisms are superior. Practical feedback from users of of the Mesa programming language [Mitchell79] incorporating the resumption mechanism of <ref> [Lampson74] </ref> indicates that the use of this type of mechanism can be quite fault-prone [Horning78], [Levin85]. Interestingly enough, some of the main proponents of the resumption philosophy (B. Lampson, R. Levin, J. Mitchell, D. Parnas) have abandoned it in favor of the termination philosophy [Levin85], [Mitchell93], [Parnas85].
Reference: [Levin77] <author> R. Levin, </author> <title> "Program Structures for Exceptional Condition Handling", </title> <type> PhD Dissertation, </type> <institution> Carnegie-Mellon University, </institution> <year> 1977. </year>
Reference-contexts: from the lack of precise definitions and terminology, but by the end of the 70s [Cristian79a], [Liskov79] it became clear that all proposed exception mechanisms can be classified into two basic categories: termination mechanisms [Anderson81], [Back79], [Best81a], [Bron76], [Cristian79a], [Cristian80], [Horning74], [Ichbiah79], [Liskov79], [Melliar77], [Wulf75] and resumption mechanisms [Goodenough75], [Lampson74], <ref> [Levin77] </ref>, [Parnas72b], [Yemini82]. For some time it was not clear which kind of mechanism will gain acceptance from programmers. Convincing arguments that the termination paradigm is superior to the resumption paradigm are presented in [Cristian79a], [Liskov79] and will not be repeated here.
Reference: [Levin85] <author> R. Levin, P. Rovner, J. Wick, </author> <title> "On Extending Modula-2 for Building Large Integrated Systems", (B. </title> <note> Lampson is acknowledged as making major design contributions to this extension) DEC Systems Research Center Technical Report No. 3, January 11, </note> <year> 1985. </year>
Reference-contexts: Recent developments confirm the view that termination mechanisms are superior. Practical feedback from users of of the Mesa programming language [Mitchell79] incorporating the resumption mechanism of [Lampson74] indicates that the use of this type of mechanism can be quite fault-prone [Horning78], <ref> [Levin85] </ref>. Interestingly enough, some of the main proponents of the resumption philosophy (B. Lampson, R. Levin, J. Mitchell, D. Parnas) have abandoned it in favor of the termination philosophy [Levin85], [Mitchell93], [Parnas85]. Widely used programming languages such as Ada and C++ have termination exception handling mechanisms. <p> [Mitchell79] incorporating the resumption mechanism of [Lampson74] indicates that the use of this type of mechanism can be quite fault-prone [Horning78], <ref> [Levin85] </ref>. Interestingly enough, some of the main proponents of the resumption philosophy (B. Lampson, R. Levin, J. Mitchell, D. Parnas) have abandoned it in favor of the termination philosophy [Levin85], [Mitchell93], [Parnas85]. Widely used programming languages such as Ada and C++ have termination exception handling mechanisms. The purpose of this paper is to present a synthesis of the termination exception handling paradigm. We only deal with sequential programs.
Reference: [Liskov74] <author> B. H. Liskov and S. Zilles, </author> <title> "Programming with Abstract Data Types", </title> <booktitle> in Proc. ACM SIGPLAN Conference on Very High Level Languages, SIGLAN Notices, </booktitle> <volume> Vol. 9, No. 4, </volume> <pages> pp. 50-59, </pages> <year> 1974. </year>
Reference-contexts: Detailed examples of the often tricky problems posed by exception handling in programs structured as hierarchies of abstract data types can be found in [Cristian82]. HIERARCHICAL PROGRAM STRUCTURE In the 70s, it became clear that data abstraction is a powerful mechanism for mastering the complexity of programs [Hoare72], <ref> [Liskov74] </ref>, [Parnas72a], [Wulf76].
Reference: [Liskov79] <author> B. H. Liskov and A. Snyder, </author> <title> "Exception Handling in CLU", </title> <journal> IEEE Trans. Software Eng., </journal> <volume> Vol. SE-5, </volume> <pages> pp. 546-558, </pages> <year> 1979. </year>
Reference-contexts: The first papers entirely devoted to exception handling began to appear only in the 70s, e.g. [Goodenough75], [Horning74], [Parnas72b], [Wulf75]. Early discussions of the issue were often marred by misunderstandings arising from the lack of precise definitions and terminology, but by the end of the 70s [Cristian79a], <ref> [Liskov79] </ref> it became clear that all proposed exception mechanisms can be classified into two basic categories: termination mechanisms [Anderson81], [Back79], [Best81a], [Bron76], [Cristian79a], [Cristian80], [Horning74], [Ichbiah79], [Liskov79], [Melliar77], [Wulf75] and resumption mechanisms [Goodenough75], [Lampson74], [Levin77], [Parnas72b], [Yemini82]. <p> the issue were often marred by misunderstandings arising from the lack of precise definitions and terminology, but by the end of the 70s [Cristian79a], <ref> [Liskov79] </ref> it became clear that all proposed exception mechanisms can be classified into two basic categories: termination mechanisms [Anderson81], [Back79], [Best81a], [Bron76], [Cristian79a], [Cristian80], [Horning74], [Ichbiah79], [Liskov79], [Melliar77], [Wulf75] and resumption mechanisms [Goodenough75], [Lampson74], [Levin77], [Parnas72b], [Yemini82]. For some time it was not clear which kind of mechanism will gain acceptance from programmers. Convincing arguments that the termination paradigm is superior to the resumption paradigm are presented in [Cristian79a], [Liskov79] and will not be repeated here. <p> [Back79], [Best81a], [Bron76], [Cristian79a], [Cristian80], [Horning74], [Ichbiah79], <ref> [Liskov79] </ref>, [Melliar77], [Wulf75] and resumption mechanisms [Goodenough75], [Lampson74], [Levin77], [Parnas72b], [Yemini82]. For some time it was not clear which kind of mechanism will gain acceptance from programmers. Convincing arguments that the termination paradigm is superior to the resumption paradigm are presented in [Cristian79a], [Liskov79] and will not be repeated here. Recent developments confirm the view that termination mechanisms are superior. Practical feedback from users of of the Mesa programming language [Mitchell79] incorporating the resumption mechanism of [Lampson74] indicates that the use of this type of mechanism can be quite fault-prone [Horning78], [Levin85]. <p> Thus, there is a danger that later invocations of M will lead to unpredictable results and to additional unanticipated exception propagations. A different approach to the problem of handling detectable failure occurrences is discussed in [Cristian79a], and [Horning74], <ref> [Liskov79] </ref>. The basic idea is quite simple: associate a default handler DH, with any lower level (unanticipated) exception u propagated in a procedure exported by a module M. <p> The exceptional service that such a handler attempts to provide can be identified by a language defined exception label "failure" [Cris-tian79b], <ref> [Liskov79] </ref>, or "error" [Horning74]. The systematic addition of default handlers to all procedures exported by modules, written in a language in which the "failure" exception is predefined, has the following consequences. <p> The default exception handling strategy embodied in the CLU programming language developed at MIT <ref> [Liskov79] </ref> is oriented towards solving problem (3), related to the (proper) propagation of "failure" exceptions across module boundaries, i.e., each default handler is of the form DH signal failure. <p> Most database systems do not attempt to mask transaction aborts caused by exception detections to users. The recovery block mechanism, devised at the University of Newcastle upon Tyne [Horn-ing74], was designed to solve all the problems (1)-(3) mentioned above. Unlike the mechanisms described in [Cristian79a] and <ref> [Liskov79] </ref> which support both explicit and default exception handling, the recovery block mechanism is a pure default exception handling mechanism based on automatic backward recovery.
Reference: [Liskov82] <author> B. H. Liskov, </author> <title> "On Linguistic Support for distributed programs", </title> <journal> IEEE Trans. Software Eng., </journal> <volume> Vol. SE-8, </volume> <pages> pp. 203-210, </pages> <year> 1982. </year>
Reference-contexts: The purpose of this paper is to present a synthesis of the termination exception handling paradigm. We only deal with sequential programs. Exception handling in parallel and distributed programs is still an evolving subject where no clear consensus exists [Campbell86], [Cristian79b], [Jalote84], [Kim82], <ref> [Liskov82] </ref>, [Randell75], [Schlichting87], [Shrivastava78], 2 [Wood81]. In our discussion we will only examine exceptions detected in programs, and will assume that the compilers, linkeditors and lower level hardware all work properly. For a text attempting to integrate software and hardware aspects of fault-tolerance, the interested reader is refered to [Cristian91].
Reference: [Luckham80] <author> D. Luckham and W. Polak, </author> <title> "ADA exception handling: an axiomatic approach", </title> <journal> ACM TOPLAS, </journal> <volume> Vol. 2, </volume> <year> 1980. </year>
Reference-contexts: The interest in partially correct programs comes from the fact that such programs are safe: they never output erroneous results to their users. Methods for verifying that programs with exceptions are partially correct are described in [Back79], [Bron76], <ref> [Luckham80] </ref>.
Reference: [Melliar77] <author> M. Melliar-Smith and B. Randell, </author> <title> "Software Reliability: the Role of Programmed Exception Handling", </title> <booktitle> in Proc. ACM Conf. on Lang. Design for Reliable Software; also in SIGPLAN Notices, </booktitle> <volume> Vol. 12, </volume> <pages> pp. 95-100, </pages> <year> 1977. </year>
Reference-contexts: issue were often marred by misunderstandings arising from the lack of precise definitions and terminology, but by the end of the 70s [Cristian79a], [Liskov79] it became clear that all proposed exception mechanisms can be classified into two basic categories: termination mechanisms [Anderson81], [Back79], [Best81a], [Bron76], [Cristian79a], [Cristian80], [Horning74], [Ichbiah79], [Liskov79], <ref> [Melliar77] </ref>, [Wulf75] and resumption mechanisms [Goodenough75], [Lampson74], [Levin77], [Parnas72b], [Yemini82]. For some time it was not clear which kind of mechanism will gain acceptance from programmers. Convincing arguments that the termination paradigm is superior to the resumption paradigm are presented in [Cristian79a], [Liskov79] and will not be repeated here. <p> In CLU, a suitable error message may be passed as a parameter to a signal failure sequencer to help in fixing off-line the cause of the failure detection. However, according to terminology introduced in <ref> [Melliar77] </ref> and [Randell78], tolerance of failure detections implies at least the resolution of problems (2) and (3). Thus, one can regard the default exception handling strategy of CLU as being more oriented towards off-line debugging rather than towards the provision of on-line software-fault tolerance.
Reference: [Mitchell79] <author> J. Mitchell et al., </author> <title> "Mesa Language Manual", </title> <note> Report CSL-79-3, Xerox PARC, </note> <institution> Palo Alto, California, </institution> <year> 1979. </year>
Reference-contexts: Convincing arguments that the termination paradigm is superior to the resumption paradigm are presented in [Cristian79a], [Liskov79] and will not be repeated here. Recent developments confirm the view that termination mechanisms are superior. Practical feedback from users of of the Mesa programming language <ref> [Mitchell79] </ref> incorporating the resumption mechanism of [Lampson74] indicates that the use of this type of mechanism can be quite fault-prone [Horning78], [Levin85]. Interestingly enough, some of the main proponents of the resumption philosophy (B. Lampson, R. Levin, J. Mitchell, D.
Reference: [Mitchell93] <author> J. Mitchell, </author> <title> Private Communication, </title> <year> 1993. </year>
Reference-contexts: Interestingly enough, some of the main proponents of the resumption philosophy (B. Lampson, R. Levin, J. Mitchell, D. Parnas) have abandoned it in favor of the termination philosophy [Levin85], <ref> [Mitchell93] </ref>, [Parnas85]. Widely used programming languages such as Ada and C++ have termination exception handling mechanisms. The purpose of this paper is to present a synthesis of the termination exception handling paradigm. We only deal with sequential programs.
Reference: [Parnas72a] <author> D. Parnas, </author> <title> "A Technique for Software Module Specification with Examples", </title> <journal> Communications fo the ACM, </journal> <volume> Vol. 15, No. 5, </volume> <pages> pp. 330-336, </pages> <year> 1972. </year>
Reference-contexts: Detailed examples of the often tricky problems posed by exception handling in programs structured as hierarchies of abstract data types can be found in [Cristian82]. HIERARCHICAL PROGRAM STRUCTURE In the 70s, it became clear that data abstraction is a powerful mechanism for mastering the complexity of programs [Hoare72], [Liskov74], <ref> [Parnas72a] </ref>, [Wulf76]. <p> The programming process would then continue until the problem of implementing all assumed abstract data types was solved only in terms of concrete types. The programming methodology outlined above leads to programs which are structured into a hierarchy of modules <ref> [Parnas72a] </ref>, [Parnas74], where each module implements some instance of an abstract data type. Visually, such a hierarchy may be represented by an acyclic graph as in Figure 6. Modules are represented by nodes. <p> Such free exception propagations across module boundaries may have dangerous consequences. First, according to the "information hiding principle" of modular programming <ref> [Parnas72a] </ref>, the designer of N is not supposed to know anything about the modules L used by M.
Reference: [Parnas72b] <author> D. Parnas, </author> <title> "Response to Detected Errors in Well-Structured Programs", </title> <type> Technical report, </type> <institution> Carnegie-Mellon University, Dept. of Computer Science, </institution> <year> 1972. </year>
Reference-contexts: In the early stages of programming methodology development in the 60s, research has mostly focused on mastering the complexity inherent in the usual or standard program behavior. The first papers entirely devoted to exception handling began to appear only in the 70s, e.g. [Goodenough75], [Horning74], <ref> [Parnas72b] </ref>, [Wulf75]. <p> the lack of precise definitions and terminology, but by the end of the 70s [Cristian79a], [Liskov79] it became clear that all proposed exception mechanisms can be classified into two basic categories: termination mechanisms [Anderson81], [Back79], [Best81a], [Bron76], [Cristian79a], [Cristian80], [Horning74], [Ichbiah79], [Liskov79], [Melliar77], [Wulf75] and resumption mechanisms [Goodenough75], [Lampson74], [Levin77], <ref> [Parnas72b] </ref>, [Yemini82]. For some time it was not clear which kind of mechanism will gain acceptance from programmers. Convincing arguments that the termination paradigm is superior to the resumption paradigm are presented in [Cristian79a], [Liskov79] and will not be repeated here.
Reference: [Parnas74] <author> D. Parnas, </author> <title> "On a Buzzword: Hierarchical Structure", </title> <booktitle> in Proceedings IFIP Congress 1974, </booktitle> <publisher> North Holland Publ. Co, </publisher> <year> 1974. </year>
Reference-contexts: The programming process would then continue until the problem of implementing all assumed abstract data types was solved only in terms of concrete types. The programming methodology outlined above leads to programs which are structured into a hierarchy of modules [Parnas72a], <ref> [Parnas74] </ref>, where each module implements some instance of an abstract data type. Visually, such a hierarchy may be represented by an acyclic graph as in Figure 6. Modules are represented by nodes.
Reference: [Parnas85] <author> D. Parnas, </author> <title> Private Communication, </title> <year> 1985. </year>
Reference-contexts: Interestingly enough, some of the main proponents of the resumption philosophy (B. Lampson, R. Levin, J. Mitchell, D. Parnas) have abandoned it in favor of the termination philosophy [Levin85], [Mitchell93], <ref> [Parnas85] </ref>. Widely used programming languages such as Ada and C++ have termination exception handling mechanisms. The purpose of this paper is to present a synthesis of the termination exception handling paradigm. We only deal with sequential programs.
Reference: [Randell75] <author> B. Randell, </author> <title> "System Structure for Software Fault-Tolerance", </title> <journal> IEEE Trans. on Software Eng. </journal> <volume> Vol. SE-1, No. 2, </volume> <year> 1975. </year>
Reference-contexts: The purpose of this paper is to present a synthesis of the termination exception handling paradigm. We only deal with sequential programs. Exception handling in parallel and distributed programs is still an evolving subject where no clear consensus exists [Campbell86], [Cristian79b], [Jalote84], [Kim82], [Liskov82], <ref> [Randell75] </ref>, [Schlichting87], [Shrivastava78], 2 [Wood81]. In our discussion we will only examine exceptions detected in programs, and will assume that the compilers, linkeditors and lower level hardware all work properly. For a text attempting to integrate software and hardware aspects of fault-tolerance, the interested reader is refered to [Cristian91].
Reference: [Randell78] <author> B. Randell, P. A. Lee, P. C. Treleaven, </author> <title> "Reliability issues in Computing Systems 32 Design", </title> <journal> Comput. Surveys Vol. </journal> <volume> 10, No. 2, </volume> <pages> pp. 123-165, </pages> <year> 1978. </year>
Reference-contexts: If the exceptional postcondition G e specified for the detected exception e is not the identity relation i.e., P is not intended to behave atomically with respect to exceptions, then the recovery action of H is said to be forward <ref> [Randell78] </ref>. From an internal point of view, the recovery of an RS is "forward" if the final state of at least one variable in RS is different from its state when P was invoked. <p> The (automatic) recovery of inconsistency closures or checkpoints is referred to as backward recovery <ref> [Randell78] </ref>. More generally, one can view the recovery of some RS as being "backward" if all the variables in RS recover their states prior to the invocation of P. <p> In CLU, a suitable error message may be passed as a parameter to a signal failure sequencer to help in fixing off-line the cause of the failure detection. However, according to terminology introduced in [Melliar77] and <ref> [Randell78] </ref>, tolerance of failure detections implies at least the resolution of problems (2) and (3). Thus, one can regard the default exception handling strategy of CLU as being more oriented towards off-line debugging rather than towards the provision of on-line software-fault tolerance.
Reference: [Schlichting] <author> R. Schlichting, F. Cristian, T. Purdin, </author> <title> "Mechanisms for failure handling in distributed programming Languages", </title> <booktitle> 1st International Working Conference on Dependable Computing for Critical Applications, </booktitle> <address> Santa Barbara, </address> <year> 1989. </year>
Reference: [Shrivastava] <author> S. K. Shrivastava, J. P. Banatre, </author> <title> "Reliable Resource Allocation between Unreliable Processes", </title> <journal> IEEE Trans. on Softw. Engineering, </journal> <volume> Vol. SE-4, </volume> <pages> pp. 230-241, </pages> <month> May, </month> <year> 1978. </year>
Reference: [Staknis87] <author> M. E. Staknis, </author> <title> "A theoretical Basis for Software Fault Tolerance", </title> <type> PhD. Thesis, </type> <institution> University of Virginia, Charlottesville, </institution> <note> CS Report RM-87-01, February 26, </note> <year> 1987. </year>
Reference-contexts: In the latter case, the detection of e in P coincides with the propagation of the (lower level) exception d in P. The problem of systematic placement of Boolean expressions in programs so as to detect all possible exception occurrences is investigated in [Best81a], <ref> [Staknis87] </ref>. The verification methods described in [Cristian84] can be used to prove that all exceptions, whether detected by Boolean expression evaluations or lower level exception propagation, are correctly detected in a program.
Reference: [Toy82] <author> W. N. </author> <title> Toy, "Fault-tolerant design of local ESS processors", in The theory and Practice of Reliable System Design, </title> <editor> D. P. Siewiorek and R. S. Swarz, Eds., </editor> <publisher> Digital Press, </publisher> <year> 1982. </year>
Reference-contexts: Most of the design faults existing in a system seem to be located in the code that handles exceptional situations. For instance, field experience with telephone switching systems <ref> [Toy82] </ref>, indicates that approximately two thirds of system failures are due to design faults in exception handling (or recovery) algorithms. In the early stages of programming methodology development in the 60s, research has mostly focused on mastering the complexity inherent in the usual or standard program behavior.
Reference: [Wood81] <author> W. G. Wood, </author> <title> "A decentralized recovery control protocol", </title> <booktitle> in Proc. 11th Int. Conf. on Fault-tolerant Computing, </booktitle> <pages> pp. 159-164, </pages> <year> 1981. </year>
Reference-contexts: The purpose of this paper is to present a synthesis of the termination exception handling paradigm. We only deal with sequential programs. Exception handling in parallel and distributed programs is still an evolving subject where no clear consensus exists [Campbell86], [Cristian79b], [Jalote84], [Kim82], [Liskov82], [Randell75], [Schlichting87], [Shrivastava78], 2 <ref> [Wood81] </ref>. In our discussion we will only examine exceptions detected in programs, and will assume that the compilers, linkeditors and lower level hardware all work properly. For a text attempting to integrate software and hardware aspects of fault-tolerance, the interested reader is refered to [Cristian91].
Reference: [Wulf75] <author> W. Wulf, </author> <booktitle> "Reliable Hardware-Software Architecture", in Proc. International Conf. on Reliable Software, SIGPLAN Notices, </booktitle> <volume> Vol. 10, No. 6, </volume> <pages> pp. 122-130, </pages> <year> 1975. </year>
Reference-contexts: In the early stages of programming methodology development in the 60s, research has mostly focused on mastering the complexity inherent in the usual or standard program behavior. The first papers entirely devoted to exception handling began to appear only in the 70s, e.g. [Goodenough75], [Horning74], [Parnas72b], <ref> [Wulf75] </ref>. <p> were often marred by misunderstandings arising from the lack of precise definitions and terminology, but by the end of the 70s [Cristian79a], [Liskov79] it became clear that all proposed exception mechanisms can be classified into two basic categories: termination mechanisms [Anderson81], [Back79], [Best81a], [Bron76], [Cristian79a], [Cristian80], [Horning74], [Ichbiah79], [Liskov79], [Melliar77], <ref> [Wulf75] </ref> and resumption mechanisms [Goodenough75], [Lampson74], [Levin77], [Parnas72b], [Yemini82]. For some time it was not clear which kind of mechanism will gain acceptance from programmers. Convincing arguments that the termination paradigm is superior to the resumption paradigm are presented in [Cristian79a], [Liskov79] and will not be repeated here.
Reference: [Wulf76] <author> W. Wulf, R. London, M. Shaw, </author> <title> "An Introduction to the construction and verification of Alphard programs", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-2, </volume> <pages> pp. 253-265, </pages> <month> July </month> <year> 1976. </year>
Reference-contexts: HIERARCHICAL PROGRAM STRUCTURE In the 70s, it became clear that data abstraction is a powerful mechanism for mastering the complexity of programs [Hoare72], [Liskov74], [Parnas72a], <ref> [Wulf76] </ref>. <p> The internal state of a module M is the aggregation of the abstract states of its state variables. The abstract state of M is the result of applying an abstraction function A to its internal state [Hoare72], <ref> [Wulf76] </ref>. In general, A is a partial function defined only over a subset I S of the set of all possible internal states of the module. (In practice, this subset is defined by using an invariant predicate [Hoare72], [Wulf76].) The internal states in I are said to be consistent with the <p> result of applying an abstraction function A to its internal state [Hoare72], <ref> [Wulf76] </ref>. In general, A is a partial function defined only over a subset I S of the set of all possible internal states of the module. (In practice, this subset is defined by using an invariant predicate [Hoare72], [Wulf76].) The internal states in I are said to be consistent with the abstraction that the module is intended to implement.
Reference: [Yemini82] <author> S. Yemini, </author> <title> "An Axiomatic Treatment of Exception Handling", </title> <booktitle> in Proc. 7th ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1982. </year> <month> 33 </month>
Reference-contexts: lack of precise definitions and terminology, but by the end of the 70s [Cristian79a], [Liskov79] it became clear that all proposed exception mechanisms can be classified into two basic categories: termination mechanisms [Anderson81], [Back79], [Best81a], [Bron76], [Cristian79a], [Cristian80], [Horning74], [Ichbiah79], [Liskov79], [Melliar77], [Wulf75] and resumption mechanisms [Goodenough75], [Lampson74], [Levin77], [Parnas72b], <ref> [Yemini82] </ref>. For some time it was not clear which kind of mechanism will gain acceptance from programmers. Convincing arguments that the termination paradigm is superior to the resumption paradigm are presented in [Cristian79a], [Liskov79] and will not be repeated here. Recent developments confirm the view that termination mechanisms are superior.
References-found: 53

