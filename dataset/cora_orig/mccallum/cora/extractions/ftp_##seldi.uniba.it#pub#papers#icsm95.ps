URL: ftp://seldi.uniba.it/pub/papers/icsm95.ps
Refering-URL: http://www.cs.umd.edu/~lanubile/public.html
Root-URL: 
Title: Iterative Reengineering to compensate for Quick-Fix Maintenance In the last few years, the contribution of
Author: Filippo Lanubile, Giuseppe Visaggio 
Note: 1: Introduction  research studies and industrial experiences have also been published  has been reengineered or simply reverse engineered. The full-reuse model promotes the development of  
Address: Italy  
Affiliation: Dipartimento di Informatica University of Bari,  
Abstract: In this paper, we propose an iterative reengineering model which can be run each time the maintainability and reliability of a software system degrade under a tolerance level. The reengineering process, applied after a number of modifications, can result in renovation of the current system or, simply, in realignment of the documentation. In this context, reengineering is no longer a oneshot process but becomes an ordinary process which runs concurrently with the quick-fix maintenance process. The results obtained with an industrial case study are presented and the lessons learned are discussed. Consider the three maintenance process models, proposed by Basili in [ 3 ] : quick-fix model, iterative-enhancement model, and full-reuse model. All three models assume that the existing system has a complete and consistent documentation from requirements to code. This assumption can be realistic if we consider the configuration of a system after that a reverse engineering process has been applied. The quick-fix model, shown in Figure 1, starts modifying the existing source code, and then test the new version and modify the system documentation. It represents an abstraction of the common approach to handling software maintenance where all changes stem directly from the implementation abstraction level. The iterative-enhancement model, shown in Figure 2, starts with an analysis of the existing systems documents. The highest level artifact which is affected by the request of change is then modified and the modification is propagated downward through the lower abstraction levels. At each step, the system is redeveloped based on the analysis of the existing system. The full-reuse model, shown in Figure 3, differ from the iterative-enhancement model, because it assumes that there exists a repository of software artifacts from the current and earlier versions of the subject system or similar systems. It starts with the analysis of the requirements for the new system and rebuilds the system by reusing whatever existing document or component is applicable, or developing them when necessary. 
Abstract-found: 1
Intro-found: 1
Reference: [ 1 ] <author> F. Abbattista, G. M. G. Fatone, F. Lanubile, G. Visaggio, </author> <title> Analyzing the application of a reverse engineering proxess to a real situation, </title> <booktitle> Proceedings of the 3rd Workshop on Program Comprehension , Washington, </booktitle> <address> D.C., </address> <month> November </month> <year> 1994, </year> <month> pp.62-71. </month>
Reference-contexts: Lower CASE tools and testing tools can be used to support these activities. 3. Experiencing the iterative reengineering model The experience was performed on a banking information system, more than fifteen years old, made up of COBOL programs which run on a mainframe. A previous reengineering project, described in <ref> [ 1 ] </ref> , had recovered lost requirements and design information, ending with a renovation of the degenerated parts. This second iteration of the reengineering process concerned four subsystems which had been under quick-fix maintenance for six months after the first reengineering.
Reference: [ 2 ] <editor> R. S. Arnold, </editor> <publisher> Software Reengineering , IEEE Computer Society Press, Los Alamitos, </publisher> <address> California, </address> <year> 1993. </year>
Reference-contexts: Many research studies and industrial experiences have also been published on reengineering old systems in a new form to decrease maintenance costs, reduce software errors, or upgrade to a new hardware <ref> [ 2 ] </ref> . However, very little has been written regarding what happens in the maintenance process after a software system has been reengineered or simply reverse engineered. Consider the three maintenance process models, proposed by Basili in [ 3 ] : quick-fix model, iterative-enhancement model, and full-reuse model.
Reference: [ 3 ] <author> V. R. Basili, </author> <title> Viewing maintenance as reuse oriented software development, </title> <note> IEEE Software , January 1990, pp.19-25. </note>
Reference-contexts: However, very little has been written regarding what happens in the maintenance process after a software system has been reengineered or simply reverse engineered. Consider the three maintenance process models, proposed by Basili in <ref> [ 3 ] </ref> : quick-fix model, iterative-enhancement model, and full-reuse model. All three models assume that the existing system has a complete and consistent documentation from requirements to code.
Reference: [ 4 ] <author> E. J. Byrne, </author> <title> A conceptual foundation for software reengineering, </title> <booktitle> Proceedings of the Conference on Software Maintenance , Orlando, </booktitle> <address> Florida, </address> <month> November </month> <year> 1992, </year> <month> pp.226-235. </month>
Reference-contexts: The model is decomposed in four stages: (1) reverse engineering, (2) tracking quality, (3) redesign/recode, and (4) forward engineering. The model is coherent with the rework strategy of software reengineering <ref> [ 4 ] </ref> which incorporates the principles of abstraction, alteration, and refinement. The first step, reverse engineering , is used to rebuild the system representation at the design level. Diagram generators create charts from code to describe the control and data flow, call hierarchies, and data structures.
Reference: [ 5 ] <author> E. J. Chikofsky, and J. H. Crossburn, </author> <title> Reverse engineering and design recovery: a taxonomy, </title> <note> IEEE Software , January 1990, pp.13-17. </note>
Reference-contexts: 1: Introduction In the last few years, the contribution of researchers and practitioners in the reverse engineering field has been very rich of proposals and applications in all the key objectives pointed out in <ref> [ 5 ] </ref> : coping with complexity, generating alternate views, recovering lost information, detecting side effects and analyzing quality, synthesizing higher abstractions, facilitating reuse, and populating a repository or knowledge base.
Reference: [ 6 ] <author> P. Fiore, F. Lanubile, and G. Visaggio, </author> <title> Analyzing empirical data from a reverse engineering project, </title> <booktitle> 2nd Working Conference on Reverse Engineering , Toronto, </booktitle> <address> Ontario, Canada, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: Table 3 reports effort and productivity data of this second iteration of the reengineering process. Data were collected from report forms which were filled and collected on a daily basis. The workday report form was the same used in <ref> [ 6 ] </ref> to analyze data of the first iteration. Effort is measured in person-hours with a precision of one half hour, while productivity is measured as the number of lines of code revised per programmer-hours of effort.
Reference: [ 7 ] <author> M. M. Lehman, </author> <title> Programs, life cycles, and laws of software evolution, </title> <booktitle> Proceedings of the IEEE , vol.68, </booktitle> <address> no.9, </address> <month> September </month> <year> 1980, </year> <month> pp.1060-1076. </month>
Reference-contexts: Both models differ from the quick-fix approach because the analysis and update of documentation is performed before the modification of the code. This allows maintainer programmers to have a control on the increasing entropy as the system evolve <ref> [ 7 ] </ref> .
Reference: [ 8 ] <author> N. F. Schneidewind, </author> <title> Methodology for validating software metrics, </title> <journal> IEEE Transactions on Software Engineering , vol.18, </journal> <volume> no.5, </volume> <month> May </month> <year> 1992, </year> <month> pp.410-422. </month>
Reference-contexts: The second step, quality control , is the evaluation of software components against predetermined critical values of metrics or the tracking of the quality of a component over successive versions <ref> [ 8 ] </ref> . For example, if the cyclomatic complexity of a module in the new system grows with respect to that of the previous version in the old system, it could indicate a degradation in quality and so determine where redesign/recode efforts should be concentrated.
Reference: [ 9 ] <author> H. M. Sneed, </author> <title> Economics of software re engineering, Software Maintenance: </title> <journal> Research and Practice , vol.3, </journal> <volume> no.3, </volume> <year> 1991, </year> <month> pp.163-182. </month>
Reference-contexts: Reconstructing software documentation accounts for less than one fourth of the overall reengineering costs: we need to improve the productivity of change phases using a common repository which integrates the multiple tools used for reverse and forward engineering. Econometric reengineering models <ref> [ 9 ] </ref> which decide whether to replace, redevelop, reengineer, or continuing maintenance, should take into account the realignment of documentation as a separate option, so that software managers can decide if altering the existing system, after having rebuilt documentation, can be worthwhile.
References-found: 9

