URL: file://ftp.di.unipi.it/pub/Papers/giacobazzi/popl93.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Email: codish@cs.kuleuven.ac.be.  debray@cs.arizona.edu.  giaco@di.unipi.it.  
Title: Compositional Analysis of Modular Logic Programs  
Author: Michael Codish Saumya K. Debray Roberto Giacobazzi 
Note: Supported in part by the National Science Foundation under grant number CCR-8901283.  Supported in part by the Esprit Basic Research Action 3012 Compulog. In proceedings of ACM POPL'93.  
Address: KU Leuven, Belgium.  Ari-zona, Tucson, AZ 85721, USA.  Pisa, Corso Italia 40, 56125 Pisa, Italy.  
Affiliation: Department of Computer Science,  Department of Computer Science, The University of  Dipartimento di Informatica, Universita di  
Abstract: This paper describes a semantic basis for a compositional approach to the analysis of logic programs. A logic program is viewed as consisting of a set of modules, each module defining a subset of the program's predicates. Analyses are constructed by considering abstract interpretations of a compositional semantics. The abstract meaning of a module corresponds to its analysis and composition of abstract meanings corresponds to composition of analyses. Such an approach is essential for large program development so that altering one module does not require re-analysis of the entire program. We claim that for a substantial class of programs, compositional analyses which are based on a notion of abstract unfolding provide the same precision as non-compositional analysis. A compositional analysis for ground dependencies is included to illustrate the approach. To the best of our knowledge this is the first account of a compositional framework for the analysis of logic programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. R. Apt, H. Blair, and A. Walker. </author> <title> Towards a Theory of Declarative Knowledge. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pp. 89-148. </pages> <publisher> Morgan Kauf-mann, </publisher> <address> Los Altos, Ca., </address> <year> 1988. </year>
Reference-contexts: To be more general, and in particular to allow predicates which are undefined in all modules, it is necessary to disallow certain combinations of recursion and calls to open predicates. Our approach draws on the notion of stratification (introduced in <ref> [1] </ref> to support a safe use of negation), identifying those programs where only negated relations whose meaning is fixed beforehand are allowed.
Reference: [2] <author> R. Barbuti, R. Giacobazzi, and G. Levi. </author> <title> A General Framework for Semantics-based Bottom-up Abstract Interpretation of Logic Programs. </title> <type> Technical Report TR 12/91, </type> <institution> Dipartimento di Infor-matica, Universita di Pisa, </institution> <year> 1991. </year> <note> To appear in ACM Transactions on Programming Languages and Systems. </note>
Reference-contexts: This semantics is attractive as a basis for abstraction as it resembles the semantics of [14] which provides the basis for abstract interpretation as described in <ref> [2] </ref> and [8]. <p> Example 11 Consider the following program, which generates the list of prime numbers up to N for any given natural number N : primes (N ; L) N &lt; 2; L = [ ]: primes (N ; L) N 2; intlist (N ; L1); primes 1 (L1; <ref> [2] </ref>; L): primes 1 ([ ]; L0; L1) reverse (L0; L1): primes 1 ([H jL]; L0; L1) divisible (L0; H ); primes 1 (L; L0; L1): primes 1 ([H jL]; L0; L1) not divisible (L0; H ); primes 1 (L; [H jL0]; L1): We omit the definitions of intlist/2, divisible/2, not
Reference: [3] <editor> BIM Prolog reference manual. B.I.M. </editor> <address> B - 3078, Everberg, Belgium. </address>
Reference-contexts: This is not a matter of purely theoretical interest: in most Prolog systems currently available, e.g., BIM and Sicstus Prologs <ref> [3, 6] </ref>, there are no a priori restrictions on the dependencies between the different modules in a program (a module A depends on a module B if a procedure defined in A calls a procedure defined in B), and it is entirely possible to have a set of modules mutually dependent
Reference: [4] <author> A. Bossi, M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> Contributions to the Semantics of Open Logic Programs. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems 1992, </booktitle> <pages> pp. 570-580, </pages> <year> 1992. </year>
Reference-contexts: The semantics we consider here as a basis for abstract interpretations is a simplification of that proposed in <ref> [4] </ref>. The essential idea is to treat modules as programs in which undefined predicates are considered open. <p> The semantics is an instance of the compositional bottom-up semantics of Bossi et al. <ref> [4] </ref>, specialized for the case of predicate disjoint modules. We propose two notions of composition which provide the basis for composition of analyses. The first, "symmetric composition", is that introduced in [4]. It is more general and applicable to the analysis of arbitrary modular logic programs. <p> The semantics is an instance of the compositional bottom-up semantics of Bossi et al. <ref> [4] </ref>, specialized for the case of predicate disjoint modules. We propose two notions of composition which provide the basis for composition of analyses. The first, "symmetric composition", is that introduced in [4]. It is more general and applicable to the analysis of arbitrary modular logic programs. However the second, "directed composition", provides for potentially more precise analyses when programs have a hierarchical structure. <p> The following formalizes a bottom-up semantics for open logic programs in terms of "iterated unfolding" | that is, repeatedly unfolding the clauses in a program until further unfolding produces no change: Definition 3.3 [fixpoint semantics <ref> [4] </ref>] : The fixpoint semantics of a program P is given by the function F : Int ! Int , defined as F (P ) = lfp (T C P ), where T C P : Int ! Int is defined as T C P (I ) = Several aspects of <p> Once we consider modular programs, however, this approach is too simplistic because if we wish to give a compositional semantics then open predicates, i.e., those imported from other modules, have no definition available. The solution to this problem proposed in <ref> [4] </ref> is to unfold only those predicates which have a definition, so that the meaning of a program becomes dependent (as intuitively it should) on the meaning of its open predicates. <p> When I consists of unit clauses (facts), the fixpoint operator in this case gives precisely the generalized (non-ground) fixpoint semantics of [14]. Proposition 3.4 [symmetric composition <ref> [4] </ref>] : Let P 1 and P 2 be modules, then F (P 1 [ P 2 ) = F (F (P 1 ) [ F (P 2 )). <p> This allows different modules to represent different views of the knowledge about a predicate. To substantiate our claim, we note that the compositional semantics defined in <ref> [4] </ref> (which is the basis for our framework) is not restricted to predicate disjoint modules. Instead, each module is conceptually accompanied by a declaration of its open predicates. The concrete fixpoint semantics is defined as before, by allowing tautological clauses in P for each open predicate. <p> These include Mancarella et al. [21], Gaifmann et al. [16] and Bossi et al. <ref> [4] </ref>. In [21] the compositional semantics is provided by composing the T P functions associated with program modules. Gaifmann et al. propose to adopt clauses as semantic objects in order to characterize partial computations (from the head to the body) and to enable different notions of composition. <p> These are typically based on various extensions to Horn logic: for example, Chen's treatment of modules [7] is based on second-order logic, while Miller's [22] uses implication goals in clause bodies. In either case, the semantics appears to be somewhat more complicated than that considered in <ref> [4] </ref>, and we conjecture that a formal treatment of abstract interpretation based on such semantics would require considerably more machinery than that given here.
Reference: [5] <author> M. Bruynooghe, G. Janssens, B. Demoen, and A. Callebaut. </author> <title> Abstract Interpretation: Towards the Global Optimization of Prolog Programs. </title> <booktitle> In Proc. Fourth IEEE Int'l Symp. on Logic Programming, </booktitle> <pages> pp. 192-204. </pages> <publisher> IEEE Comp. Soc. Press, </publisher> <year> 1987. </year>
Reference: [6] <author> M. Carlsson and J. Widen. </author> <title> SICStus Prolog Users Manual. </title> <type> SICS, </type> <institution> Sweden, </institution> <year> 1988. </year>
Reference-contexts: This is not a matter of purely theoretical interest: in most Prolog systems currently available, e.g., BIM and Sicstus Prologs <ref> [3, 6] </ref>, there are no a priori restrictions on the dependencies between the different modules in a program (a module A depends on a module B if a procedure defined in A calls a procedure defined in B), and it is entirely possible to have a set of modules mutually dependent
Reference: [7] <author> W. Chen. </author> <title> A Theory of Modules Based on Second-Order Logic. </title> <booktitle> In Proc. Fourth IEEE Int'l Symp. on Logic Programming, </booktitle> <pages> pp. 24-33. </pages> <publisher> IEEE Comp. Soc. Press, </publisher> <year> 1987. </year>
Reference-contexts: We demonstrate this approach by giving a compositional ground dependencies analysis for modular logic programs. Semantic treatments of modules in logic programs have been given by a number of authors (see, for example, <ref> [7, 22] </ref>), typically based on nontrivial extensions to Horn clause logic that lead to complex semantics; it appears to us that the development of abstract interpretations based on such semantics is not entirely straightforward. <p> Bossi et al. also consider clauses as semantic objects. They propose a bottom-up approach providing a semantics that resembles the non-ground T P operator of [14]. Logical semantics for modules in logic programs have been proposed by a number of authors <ref> [7, 22] </ref>. These are typically based on various extensions to Horn logic: for example, Chen's treatment of modules [7] is based on second-order logic, while Miller's [22] uses implication goals in clause bodies. <p> Logical semantics for modules in logic programs have been proposed by a number of authors [7, 22]. These are typically based on various extensions to Horn logic: for example, Chen's treatment of modules <ref> [7] </ref> is based on second-order logic, while Miller's [22] uses implication goals in clause bodies.
Reference: [8] <author> M. Codish, D. Dams, and E. Yardeni. </author> <title> Bottom-up Abstract Interpretation of Logic Programs. </title> <type> Technical report, </type> <institution> Dept. of Computer Science, The Weizmann Institute, Rehovot, </institution> <year> 1990. </year> <note> To appear in Theoretical Computer Science. </note>
Reference-contexts: This semantics is attractive as a basis for abstraction as it resembles the semantics of [14] which provides the basis for abstract interpretation as described in [2] and <ref> [8] </ref>.
Reference: [9] <author> M. Codish, M. Falaschi, and K. Marriott. </author> <title> Suspension Analysis for Concurrent Logic Programs. </title> <editor> In K. Furukawa, editor, </editor> <booktitle> Proc. Eighth Int'l Conf. on Logic Programming, </booktitle> <pages> pp. </pages> <address> 331- 345. </address> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference-contexts: gt from Example 1 is described by hgt (x 1 ; x 2 ) gt (x 3 ; x 4 ); fx 1 7! s (x 3 ); x 2 7! x 4 gi : As an example of a domain of abstract substitutions, consider the domain Dep adopted from <ref> [9] </ref>: Definition 5.1 [dependency relation] : A relation R over a lattice X is additive iff (x R x 0 ^ y R y 0 ) ) (x t y ) R (x 0 t y 0 ): A dependency relation R is an additive equivalence relation (reflexive, symmetric and transitive) <p> Example 6 The following is a safe abstract unification function for Dep similar to that introduced in <ref> [9] </ref>. mgu A n i=0 (fx g; vars (t)) fi where b = hb 1 ; : : : ; b n i. <p> In this case, since may be assumed to be finite, the new abstract domain, denoted AInt ? , becomes finite. This abstraction, called star abstraction and originally introduced in <ref> [9] </ref>, provides an appropriate framework to develop compositional analyses. We demonstrate this for the case of ground dependencies analysis. The basic idea is to collapse all occurrences of the same predicate in a body to one "canonical" atom, representing any possible sequence of atoms with that predicate symbol.
Reference: [10] <author> K.D. Cooper, K. Kennedy, and L. Torczon. </author> <title> In-terprocedural Optimization: Eliminating Unec-essary Recompilation. </title> <booktitle> In Proc. SIGPLAN '86 Symp. on Compiler Construction, </booktitle> <pages> pp. 58-67, </pages> <year> 1986. </year>
Reference-contexts: those modules that have changed: the abstract semantics computed for the other modules can be reused without any problems, and the new abstract semantics for the program computed simply by composing them with the (new) abstract semantics computed for the modules that have changed. (Contrast this to the work of <ref> [10, 24] </ref>, where it is necessary to reanalyze not only the modules that have changed, but (potentially) also any module that depends on a changed module.) In this section, we illustrate this reuse of abstract semantics with an example. <p> The problem of program analysis across module boundaries for imperative languages has been considered by a number of researchers: Cooper et al. <ref> [10] </ref> and Tichy et al. [24] are concerned primarily with low-level details of maintaining information to allow a compiler to determine whether a change to one program unit necessitates the recompilation of another, separately-compiled, unit, while Santhanam and Odnert [23] consider register allocation across module boundaries.
Reference: [11] <author> P. Cousot and R. Cousot. </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <booktitle> In Proc. Fourth ACM Symp. Principles of Programming Languages, </booktitle> <pages> pp. 238-252, </pages> <year> 1977. </year>
Reference-contexts: Section 7 discusses how some restrictions on modules, assumed in earlier sections, can be relaxed. Section 8 discusses related work, and Section 9 concludes. 2 Preliminaries In the following we assume familiarity with the standard definitions and notation for logic programs [20] and abstract interpretation <ref> [11, 12] </ref>. Throughout, we will assume a fixed set of function symbols , a fixed set of predicate symbols and a fixed denumerable set of variables Var. <p> In either case the result corresponds to the standard meaning as provided by the semantics of [14]. 4 Abstract semantics and com position We assume the standard framework of abstract interpretation as defined in <ref> [11] </ref> in terms of Galois inser 1 We illustrate the clauses added by successive iterations of unfolding. tions. <p> Proof. Assume the premise of the theorem and let P 1 ; P 2 2 Int . Recall that ff is continuous in any Galois insertion <ref> [11] </ref>. ff (F (P 1 [ P 2 )) = ff (F (F (P 1 ) [ F (P 2 ))) [ Proposition 3.4 ] v F A (ff (F (P 1 ) [ F (P 2 ))) [ safety ] = F A (ff (F (P 1 )) t ff
Reference: [12] <author> P. Cousot and R. Cousot. </author> <title> Systematic Design of Program Analysis Frameworks. </title> <booktitle> In Proc. Sixth ACM Symp. Principles of Programming Languages, </booktitle> <pages> pp. 269-282, </pages> <year> 1979. </year>
Reference-contexts: Section 7 discusses how some restrictions on modules, assumed in earlier sections, can be relaxed. Section 8 discusses related work, and Section 9 concludes. 2 Preliminaries In the following we assume familiarity with the standard definitions and notation for logic programs [20] and abstract interpretation <ref> [11, 12] </ref>. Throughout, we will assume a fixed set of function symbols , a fixed set of predicate symbols and a fixed denumerable set of variables Var. <p> Unfortunately ff and fl as defined above do not pro vide a Galois insertion as fl is not injective. This means that several distinct elements in (VClause ! ASub) describe the same set of clauses. However this is easily fixed, as suggested in <ref> [12] </ref>, by letting fl induce an equivalence relation on (VClause ! ASub): Example 5 If ASub = Dep, I a 1 = fhle (x ; y); fx ; yg $ ;ig and I a 2 = fhle (x ; y); fx ; y; z g $ ;ig. <p> which implies that an adjoint concretization mapping fl ? : AInt ? D ! AInt D does exist and is determined by fl ? (I ) = [ I 0 fi ff ? (I 0 ) = I : Since the composition of Galois insertions is also a Galois insertion <ref> [12] </ref>, (Int ; ff ? ffiff; AInt ? D ; flffifl ? ) provides a suitable basis for abstract interpretation.
Reference: [13] <author> P. Cousot and R. Cousot. </author> <title> Comparing the Galois Connection and Widening/Narrowing Approaches to Abstract Interpretation. </title> <editor> In M. Bruynooghe and M. Wirsing, editors, </editor> <booktitle> Proc. of PLILP'92, volume 631 of Lecture Notes in Computer Science, </booktitle> <pages> pages 269-295. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: This necessitates a second (and orthogonal) abstraction to deal with unbounded clause bodies in the abstract semantics. One proposal to deal with abstract domains containing infinite chains is to use some kind of widening/narrowing approach to restrict the analysis to a finite subspace of the entire domain <ref> [13] </ref>. Here we consider a somewhat simpler solution that can be formalized in the standard framework of abstract interpretations by restricting AInt to be a finite height lattice. We apply a further level of abstraction to provide finitary descriptions of (sets of) arbitrarily large abstract clauses.
Reference: [14] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative Modeling of the Operational Behavior of Logic Languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year>
Reference-contexts: This semantics is attractive as a basis for abstraction as it resembles the semantics of <ref> [14] </ref> which provides the basis for abstract interpretation as described in [2] and [8]. <p> When I consists of unit clauses (facts), the fixpoint operator in this case gives precisely the generalized (non-ground) fixpoint semantics of <ref> [14] </ref>. Proposition 3.4 [symmetric composition [4]] : Let P 1 and P 2 be modules, then F (P 1 [ P 2 ) = F (F (P 1 ) [ F (P 2 )). <p> Since open (P lg ) = ;, the result corresponds to the semantics of <ref> [14] </ref>: fgt (s (0),0), le (0,0), le (0,s (0)), gt (s (s (0)),s (0)), : : : g. The meaning of P sp [ P lg can be evaluated directly or by applying Proposition 3.4. <p> The meaning of P sp [ P lg can be evaluated directly or by applying Proposition 3.4. In either case the result corresponds to the standard meaning as provided by the semantics of <ref> [14] </ref>. 4 Abstract semantics and com position We assume the standard framework of abstract interpretation as defined in [11] in terms of Galois inser 1 We illustrate the clauses added by successive iterations of unfolding. tions. <p> Bossi et al. also consider clauses as semantic objects. They propose a bottom-up approach providing a semantics that resembles the non-ground T P operator of <ref> [14] </ref>. Logical semantics for modules in logic programs have been proposed by a number of authors [7, 22]. These are typically based on various extensions to Horn logic: for example, Chen's treatment of modules [7] is based on second-order logic, while Miller's [22] uses implication goals in clause bodies.
Reference: [15] <author> H. Gaifman, M. J. Maher, and E. Y. Shapiro. </author> <title> Reactive Behavior Semantics for Concurrent Constraint Logic Programs. </title> <editor> In E. Lusk and R. Over-beck, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'89, </booktitle> <pages> pp. 553-572. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: For simplicity of exposition, we will abuse notation and assume that a clause represents its equivalence class and write Clause rather than [Clause] ~ . We focus on logic programs which are constructed from predicate disjoint modules (considered also in <ref> [15, 17] </ref>). If P 1 ; : : : ; P n are logic program modules, then P = n i=1 P i is a modular logic program.
Reference: [16] <author> H. Gaifman and E. Shapiro. </author> <title> Fully abstract compositional semantics for logic programs. </title> <booktitle> In Proc. Sixteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pp. 134-142. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: These include Mancarella et al. [21], Gaifmann et al. <ref> [16] </ref> and Bossi et al. [4]. In [21] the compositional semantics is provided by composing the T P functions associated with program modules.
Reference: [17] <author> R. Gerth, M. Codish, Y. Lichtenstein, and E. Shapiro. </author> <title> Fully abstract denotational semantics for Concurrent Prolog. </title> <booktitle> In Proc. Third IEEE Symp. on Logic In Computer Science, </booktitle> <pages> pp. 320-335. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1988. </year>
Reference-contexts: For simplicity of exposition, we will abuse notation and assume that a clause represents its equivalence class and write Clause rather than [Clause] ~ . We focus on logic programs which are constructed from predicate disjoint modules (considered also in <ref> [15, 17] </ref>). If P 1 ; : : : ; P n are logic program modules, then P = n i=1 P i is a modular logic program.
Reference: [18] <author> J. E. Hopcroft and J. D. Ullman, </author> <title> Introduction to Automata Theory, Languages, and Computation, </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: Let N be the length of the longest string in L (G P ), then no clause in F (P ) can have more than N atoms in its body. The theorem follows. 2 Note that it is decidable whether the language of an arbitrary context-free grammar is finite <ref> [18] </ref>. Theorem 5.11 therefore gives a decidable sufficient condition for determining whether, for any given module P , the clauses in F (P ) are bounded. The following example illustrates the application of this approach.
Reference: [19] <author> G. Levi. </author> <title> Models, Unfolding Rules and Fixpoint Semantics. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pp. 1649-1665. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: This operator is of interest as it can be applied to formalize both top-down and bottom-up semantics for logic programs <ref> [19] </ref>.
Reference: [20] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year> <note> Second edition. </note>
Reference-contexts: Section 7 discusses how some restrictions on modules, assumed in earlier sections, can be relaxed. Section 8 discusses related work, and Section 9 concludes. 2 Preliminaries In the following we assume familiarity with the standard definitions and notation for logic programs <ref> [20] </ref> and abstract interpretation [11, 12]. Throughout, we will assume a fixed set of function symbols , a fixed set of predicate symbols and a fixed denumerable set of variables Var.
Reference: [21] <author> P. Mancarella and D. Pedreschi. </author> <title> An Algebra of Logic Programs. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pp. 1006-1023. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: These include Mancarella et al. <ref> [21] </ref>, Gaifmann et al. [16] and Bossi et al. [4]. In [21] the compositional semantics is provided by composing the T P functions associated with program modules. <p> These include Mancarella et al. <ref> [21] </ref>, Gaifmann et al. [16] and Bossi et al. [4]. In [21] the compositional semantics is provided by composing the T P functions associated with program modules. Gaifmann et al. propose to adopt clauses as semantic objects in order to characterize partial computations (from the head to the body) and to enable different notions of composition.
Reference: [22] <author> D. Miller. </author> <title> A Theory of Modules for Logic Programming. </title> <booktitle> In Proceedings IEEE Symposium on Logic Programming, </booktitle> <pages> pp. 106-114, </pages> <year> 1986. </year>
Reference-contexts: We demonstrate this approach by giving a compositional ground dependencies analysis for modular logic programs. Semantic treatments of modules in logic programs have been given by a number of authors (see, for example, <ref> [7, 22] </ref>), typically based on nontrivial extensions to Horn clause logic that lead to complex semantics; it appears to us that the development of abstract interpretations based on such semantics is not entirely straightforward. <p> Bossi et al. also consider clauses as semantic objects. They propose a bottom-up approach providing a semantics that resembles the non-ground T P operator of [14]. Logical semantics for modules in logic programs have been proposed by a number of authors <ref> [7, 22] </ref>. These are typically based on various extensions to Horn logic: for example, Chen's treatment of modules [7] is based on second-order logic, while Miller's [22] uses implication goals in clause bodies. <p> Logical semantics for modules in logic programs have been proposed by a number of authors [7, 22]. These are typically based on various extensions to Horn logic: for example, Chen's treatment of modules [7] is based on second-order logic, while Miller's <ref> [22] </ref> uses implication goals in clause bodies. In either case, the semantics appears to be somewhat more complicated than that considered in [4], and we conjecture that a formal treatment of abstract interpretation based on such semantics would require considerably more machinery than that given here.
Reference: [23] <author> V. Santhanam and D. Odnert, </author> <title> "Register Allocation across Procedure and Module Boundaries", </title> <booktitle> Proc. ACM SIGPLAN-90 Conference on Programming Language Design and Implementation, </booktitle> <address> White Plains, NY, </address> <month> June </month> <year> 1990, </year> <pages> pp. 28-39. </pages>
Reference-contexts: has been considered by a number of researchers: Cooper et al. [10] and Tichy et al. [24] are concerned primarily with low-level details of maintaining information to allow a compiler to determine whether a change to one program unit necessitates the recompilation of another, separately-compiled, unit, while Santhanam and Odnert <ref> [23] </ref> consider register allocation across module boundaries. While the motivation for their work is related to ours, the treatment is significantly different in that no attempt is made to give a formal semantic account of the problem or the proposed solutions.
Reference: [24] <author> W.F. Tichy and M.C. Baker. </author> <title> Smart Recompilation. </title> <booktitle> In Proc. Twelfth ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pp. 236-244. </pages> <publisher> ACM, </publisher> <year> 1985. </year>
Reference-contexts: those modules that have changed: the abstract semantics computed for the other modules can be reused without any problems, and the new abstract semantics for the program computed simply by composing them with the (new) abstract semantics computed for the modules that have changed. (Contrast this to the work of <ref> [10, 24] </ref>, where it is necessary to reanalyze not only the modules that have changed, but (potentially) also any module that depends on a changed module.) In this section, we illustrate this reuse of abstract semantics with an example. <p> The problem of program analysis across module boundaries for imperative languages has been considered by a number of researchers: Cooper et al. [10] and Tichy et al. <ref> [24] </ref> are concerned primarily with low-level details of maintaining information to allow a compiler to determine whether a change to one program unit necessitates the recompilation of another, separately-compiled, unit, while Santhanam and Odnert [23] consider register allocation across module boundaries.
References-found: 24

