URL: http://graphics.lcs.mit.edu/~seth/pubs/siggraph91.ps.Z
Refering-URL: http://graphics.lcs.mit.edu/~seth/pubs/pubs.html
Root-URL: 
Title: Visibility Preprocessing For Interactive Walkthroughs  
Author: Seth J. Teller Carlo H. Sequin 
Keyword: Tests on moderately complex 2-D and 3-D axial models reveal substantially reduced rendering loads. CR Categories and Subject Descriptors: [Computer Graphics]: I.3.5 Computational Geometry and Object Modeling geometric algorithms, languages, and systems; I.3.7 Three-Dimensional Graphics and Realism visible line/surface algorithms. Additional Key Words and Phrases: architectural simulation, linear programming, superset visibility.  
Address: Berkeley  Berkeley, CA 94720  
Affiliation: University of California at  Computer Science Department,  
Abstract: The number of polygons comprising interesting architectural models is many more than can be rendered at interactive frame rates. However, due to occlusion by opaque surfaces (e.g., walls), only a small fraction of a typical model is visible from most viewpoints. We describe a method of visibility preprocessing that is efficient and effective for axis-aligned or axial architectural models. A model is subdivided into rectangular cells whose boundaries coincide with major opaque surfaces. Non-opaque portals are identified on cell boundaries, and used to form an adjacency graph connecting the cells of the subdivision. Next, the cell-to-cell visibility is computed for each cell of the subdivision, by linking pairs of cells between which unobstructed sightlines exist. During an interactive walkthrough phase, an observer with a known position and view cone moves through the model. At each frame, the cell containing the observer is identified, and the contents of potentially visible cells are retrieved from storage. The set of potentially visible cells is further reduced by culling it against the observer's view cone, producing the eye-to-cell visibility. The contents of the remaining visible cells are then sent to a graphics pipeline for hidden-surface removal and rendering. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> John M. Airey. </author> <title> Increasing Update Rates in the Building Walk-through System with Automatic Model-Space Subdivision and Potentially Visible Set Calculations. </title> <type> PhD thesis, </type> <institution> UNC Chapel Hill, </institution> <year> 1990. </year>
Reference-contexts: Approximate visibility information can then be computed offline, and associated with each cell for later use in an interactive rendering phase. This approximate information must contain a superset of the polygons visible from any viewpoint in the cell. If this potentially visible set or PVS <ref> [1] </ref> excluded some visible polygon for an observer position, the interactive rendering phase would exhibit flashing or holes there, detracting from the simulation's accuracy and realism. 1.1 Visibility Precomputation Several researchers have proposed spatial subdivision techniques for rendering acceleration. <p> Another overestimation method involves finding portals, or non-opaque regions, in otherwise opaque model elements, and treating these as lineal (in 2-D) or areal (in 3-D) light sources <ref> [1] </ref>. Opaque polygons in the model then cause shadow volumes [6] to arise with respect to the light sources; those parts of the model inside the shadow volumes can be marked invisible for any observer on the originating portal. <p> This portal-polygon occlusion algorithm has not found use in practice due to implementation difficulties and high computational complexity <ref> [1, 2] </ref>. A third approach estimates visibility using discrete sampling, after spatial subdivision. Conceptually, rays are cast outward from a stochastic, finite point set on the boundary of each spatial cell. Polygons hit by the rays are included in the PVS for that cell [1]. <p> A third approach estimates visibility using discrete sampling, after spatial subdivision. Conceptually, rays are cast outward from a stochastic, finite point set on the boundary of each spatial cell. Polygons hit by the rays are included in the PVS for that cell <ref> [1] </ref>. This approach can underestimate the cell's PVS by failing to report visible polygons (Figure 2). In practice, an extremely large number of rays must be cast to overcome this problem. 1.2 Overview This paper describes a new approach to spatial subdivision and the visibility problem.
Reference: [2] <author> John M. Airey, John H. Rohlf, and Frederick P. Brooks, Jr. </author> <title> Towards image realism with interactive update rates in complex virtual building environments. </title> <booktitle> ACM Siggraph Special Issue on 1990 Symposium on Interactive 3D Graphics, </booktitle> <volume> 24(2) </volume> <pages> 41-50, </pages> <year> 1990. </year>
Reference-contexts: This portal-polygon occlusion algorithm has not found use in practice due to implementation difficulties and high computational complexity <ref> [1, 2] </ref>. A third approach estimates visibility using discrete sampling, after spatial subdivision. Conceptually, rays are cast outward from a stochastic, finite point set on the boundary of each spatial cell. Polygons hit by the rays are included in the PVS for that cell [1].
Reference: [3] <author> Kurt Akeley. </author> <title> The Silicon Graphics 4D/240GTX superwork-station. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 9(4) </volume> <pages> 71-83, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Fixed-grid and octree spatial subdivisions [9, 11] accelerate ray-traced rendering by efficiently answering queries about rays propagating through ordered sets of parallelepipedal cells. To our knowledge, these ray-propagation techniques have not been used in interactive display systems. Given the wide availability of fast polygon-rendering hardware <ref> [3, 14] </ref>, it seems reasonable to search for simpler, faster algorithms which may overestimate the set of visible polygons, computing a superset of the true answer. Graphics hardware can then solve the 1 hidden-surface problem for this polygon superset in screen-space.
Reference: [4] <author> J.L. Bentley. </author> <title> Multidimensional binary search trees used for associative searching. </title> <journal> Communications of the ACM, </journal> <volume> 18 </volume> <pages> 509-517, </pages> <year> 1975. </year>
Reference-contexts: We perform the spatial subdivision using a BSP tree [8] whose splitting planes con tain the major axial faces. For the special case of planar, axial data, the BSP tree becomes an instance of a k-D tree <ref> [4] </ref> with k = 2. Every node of a k-D tree is associated with a spatial cell bounded by k half-open extents [x 0;min ::: x 0;max ); :::; [x k1;min ::: x k1;max ).
Reference: [5] <author> B. Chazelle and L.J. Guibas. </author> <title> Visibility and intersection problems in plane geometry. </title> <booktitle> In Proc. 1 st ACM Symposium on Computational Geometry, </booktitle> <pages> pages 135-146, </pages> <year> 1985. </year>
Reference-contexts: We broadly refer to these methods as visibility precomputations, since by performing work offline they reduce the effort involved in solving the hidden-surface problem. Much attention has focused on computing exact visibility (e.g., <ref> [5, 12, 16, 19, 22] </ref>); that is, computing an exact description of the visible elements of the scene data for every qualitatively distinct region of viewpoints. Such complete descriptions may be combinato-rially complex and difficult to implement [16, 18], even for highly restricted viewpoint regions (e.g., viewpoints at infinity).
Reference: [6] <author> Frank C. Crow. </author> <title> Shadow algorithms for computer graphics. </title> <booktitle> Computer Graphics (Proc. Siggraph '77), </booktitle> <volume> 11(2) </volume> <pages> 242-248, </pages> <year> 1977. </year>
Reference-contexts: Another overestimation method involves finding portals, or non-opaque regions, in otherwise opaque model elements, and treating these as lineal (in 2-D) or areal (in 3-D) light sources [1]. Opaque polygons in the model then cause shadow volumes <ref> [6] </ref> to arise with respect to the light sources; those parts of the model inside the shadow volumes can be marked invisible for any observer on the originating portal. This portal-polygon occlusion algorithm has not found use in practice due to implementation difficulties and high computational complexity [1, 2].
Reference: [7] <author> David P. Dobkin and Diane L. Souvaine. </author> <title> Detecting the intersection of convex objects in the plane. </title> <type> Technical Report No. 89-9, </type> <institution> DIMACS, </institution> <year> 1989. </year>
Reference-contexts: To accomplish this, we have developed and implemented a novel algorithm that determines sightlines through rectangles [13]. Briefly, the algorithm operates in a dual space in which the problem reduces to performing a linear number of convex polygon-polygon intersections, each requiring logarithmic time <ref> [7] </ref>. The algorithm finds a stabbing line through n oriented, axis-aligned rectangles, or determines that no such stabbing line exists, in O (n lg n) time. Assuming a rectangular display for rendering, culling against a three-dimensional view pyramid is a direct extension of the planar culling methods described earlier.
Reference: [8] <author> H. Fuchs, Z. Kedem, and B. Naylor. </author> <title> On visible surface generation by a priori tree structures. </title> <journal> Computer Graphics (Proc. </journal> <volume> Sig-graph '80), 14(3) </volume> <pages> 124-133, </pages> <year> 1980. </year>
Reference-contexts: Such complete descriptions may be combinato-rially complex and difficult to implement [16, 18], even for highly restricted viewpoint regions (e.g., viewpoints at infinity). The binary space partition or BSP tree data structure <ref> [8] </ref> obviates the hidden-surface computation by producing a back-to-front ordering of polygons from any viewpoint. This technique has the drawback that, for an n-polygon scene, the splitting operations needed to construct the BSP tree may generate O (n 2 ) new polygons [17]. <p> Its effectiveness, however, depends on the more subjective criterion that cell boundaries in the subdivision be mostly opaque. 2.3 Subdivision Method The input or scene data consists of n axial faces. We perform the spatial subdivision using a BSP tree <ref> [8] </ref> whose splitting planes con tain the major axial faces. For the special case of planar, axial data, the BSP tree becomes an instance of a k-D tree [4] with k = 2.
Reference: [9] <author> Akira Fujimoto and Kansei Iwata. </author> <title> Accelerated ray tracing. </title> <booktitle> Computer Graphics: Visual Technology and Art (Proc. Computer Graphics Tokyo '85), </booktitle> <pages> pages 41-65, </pages> <year> 1985. </year>
Reference-contexts: This technique has the drawback that, for an n-polygon scene, the splitting operations needed to construct the BSP tree may generate O (n 2 ) new polygons [17]. Fixed-grid and octree spatial subdivisions <ref> [9, 11] </ref> accelerate ray-traced rendering by efficiently answering queries about rays propagating through ordered sets of parallelepipedal cells. To our knowledge, these ray-propagation techniques have not been used in interactive display systems.
Reference: [10] <author> Benjamin Garlick, Daniel R. Baum, and James M. Winget. </author> <title> Interactive viewing of large geometric databases using multiprocessor graphics workstations. Siggraph '90 Course Notes (Parallel Algorithms and Architectures for 3D Image Generation), </title> <year> 1990. </year>
Reference-contexts: Graphics hardware can then solve the 1 hidden-surface problem for this polygon superset in screen-space. One approach involves intersecting a view cone with an octree-based spatial subdivision of the input <ref> [10] </ref>. This method has the undesirable property that it can report as visible an arbitrarily large part of the scene when, in fact, only a tiny portion can be seen (Figure 1).
Reference: [11] <author> Andrew S. Glassner. </author> <title> Space subdivision for fast ray tracing. </title> <journal> IEEE Computer Graphics and Applications, </journal> <volume> 4(10) </volume> <pages> 15-22, </pages> <year> 1984. </year>
Reference-contexts: This technique has the drawback that, for an n-polygon scene, the splitting operations needed to construct the BSP tree may generate O (n 2 ) new polygons [17]. Fixed-grid and octree spatial subdivisions <ref> [9, 11] </ref> accelerate ray-traced rendering by efficiently answering queries about rays propagating through ordered sets of parallelepipedal cells. To our knowledge, these ray-propagation techniques have not been used in interactive display systems.
Reference: [12] <author> John E. Hershberger. </author> <title> Efficient Algorithms for Shortest Path and Visibility Problems. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1987. </year>
Reference-contexts: We broadly refer to these methods as visibility precomputations, since by performing work offline they reduce the effort involved in solving the hidden-surface problem. Much attention has focused on computing exact visibility (e.g., <ref> [5, 12, 16, 19, 22] </ref>); that is, computing an exact description of the visible elements of the scene data for every qualitatively distinct region of viewpoints. Such complete descriptions may be combinato-rially complex and difficult to implement [16, 18], even for highly restricted viewpoint regions (e.g., viewpoints at infinity).
Reference: [13] <author> Michael E. Hohmeyer and Seth Teller. </author> <title> Stabbing isothetic rectangles and boxes in O(n lg n) time. </title> <type> Technical Report UCB/CSD 91/634, </type> <institution> CS Department, UC Berkeley, </institution> <year> 1991. </year>
Reference-contexts: In either event, sightlines are found by stabbing oriented rectangle sequences (Figure 12), in analogy to the two-dimensional case. To accomplish this, we have developed and implemented a novel algorithm that determines sightlines through rectangles <ref> [13] </ref>. Briefly, the algorithm operates in a dual space in which the problem reduces to performing a linear number of convex polygon-polygon intersections, each requiring logarithmic time [7].
Reference: [14] <author> David Kirk and Douglas Voorhies. </author> <booktitle> The rendering architecture of the DN10000VS. Computer Graphics (Proc. Siggraph '90), </booktitle> <volume> 24(4) </volume> <pages> 299-307, </pages> <year> 1990. </year>
Reference-contexts: Fixed-grid and octree spatial subdivisions [9, 11] accelerate ray-traced rendering by efficiently answering queries about rays propagating through ordered sets of parallelepipedal cells. To our knowledge, these ray-propagation techniques have not been used in interactive display systems. Given the wide availability of fast polygon-rendering hardware <ref> [3, 14] </ref>, it seems reasonable to search for simpler, faster algorithms which may overestimate the set of visible polygons, computing a superset of the true answer. Graphics hardware can then solve the 1 hidden-surface problem for this polygon superset in screen-space.
Reference: [15] <author> N. Megiddo. </author> <title> Linear-time algorithms for linear programming in R 3 and related problems. </title> <journal> SIAM Journal Computing, </journal> <volume> 12 </volume> <pages> 759-776, </pages> <year> 1983. </year>
Reference-contexts: Both deterministic <ref> [15] </ref> and randomized [20] algorithms exist to solve this linear program (i.e., find a line stabbing the portal sequence) in linear time; that is, time O (m).
Reference: [16] <author> Joseph O'Rourke. </author> <title> Art Gallery Theorems and Algorithms. </title> <publisher> Oxford University Press, </publisher> <year> 1987. </year>
Reference-contexts: We broadly refer to these methods as visibility precomputations, since by performing work offline they reduce the effort involved in solving the hidden-surface problem. Much attention has focused on computing exact visibility (e.g., <ref> [5, 12, 16, 19, 22] </ref>); that is, computing an exact description of the visible elements of the scene data for every qualitatively distinct region of viewpoints. Such complete descriptions may be combinato-rially complex and difficult to implement [16, 18], even for highly restricted viewpoint regions (e.g., viewpoints at infinity). <p> Much attention has focused on computing exact visibility (e.g., [5, 12, 16, 19, 22]); that is, computing an exact description of the visible elements of the scene data for every qualitatively distinct region of viewpoints. Such complete descriptions may be combinato-rially complex and difficult to implement <ref> [16, 18] </ref>, even for highly restricted viewpoint regions (e.g., viewpoints at infinity). The binary space partition or BSP tree data structure [8] obviates the hidden-surface computation by producing a back-to-front ordering of polygons from any viewpoint.
Reference: [17] <author> Michael S. Paterson and F. Frances Yao. </author> <title> Efficient binary space partitions for hidden-surface removal and solid modeling. </title> <journal> Discrete and Computational Geometry, </journal> <volume> 5(5) </volume> <pages> 485-503, </pages> <year> 1990. </year>
Reference-contexts: This technique has the drawback that, for an n-polygon scene, the splitting operations needed to construct the BSP tree may generate O (n 2 ) new polygons <ref> [17] </ref>. Fixed-grid and octree spatial subdivisions [9, 11] accelerate ray-traced rendering by efficiently answering queries about rays propagating through ordered sets of parallelepipedal cells. To our knowledge, these ray-propagation techniques have not been used in interactive display systems.
Reference: [18] <author> W.H. Plantinga and C.R. Dyer. </author> <title> An algorithm for constructing the aspect graph. </title> <booktitle> In Proc. 27 th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 123-131, </pages> <year> 1986. </year>
Reference-contexts: Much attention has focused on computing exact visibility (e.g., [5, 12, 16, 19, 22]); that is, computing an exact description of the visible elements of the scene data for every qualitatively distinct region of viewpoints. Such complete descriptions may be combinato-rially complex and difficult to implement <ref> [16, 18] </ref>, even for highly restricted viewpoint regions (e.g., viewpoints at infinity). The binary space partition or BSP tree data structure [8] obviates the hidden-surface computation by producing a back-to-front ordering of polygons from any viewpoint.
Reference: [19] <author> Franco P. Preparata and Michael Ian Shamos. </author> <title> Computational Geometry: an Introduction. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: We broadly refer to these methods as visibility precomputations, since by performing work offline they reduce the effort involved in solving the hidden-surface problem. Much attention has focused on computing exact visibility (e.g., <ref> [5, 12, 16, 19, 22] </ref>); that is, computing an exact description of the visible elements of the scene data for every qualitatively distinct region of viewpoints. Such complete descriptions may be combinato-rially complex and difficult to implement [16, 18], even for highly restricted viewpoint regions (e.g., viewpoints at infinity).
Reference: [20] <author> Raimund Seidel. </author> <title> Linear programming and convex hulls made easy. </title> <booktitle> In Proc. 6 th ACM Symposium on Computational Geometry, </booktitle> <pages> pages 211-215, </pages> <year> 1990. </year>
Reference-contexts: Both deterministic [15] and randomized <ref> [20] </ref> algorithms exist to solve this linear program (i.e., find a line stabbing the portal sequence) in linear time; that is, time O (m).
Reference: [21] <author> Seth Teller and Michael E. Hohmeyer. </author> <title> Stabbing oriented convex polygons in randomized O(n 2 ) time. </title> <type> Technical Report UCB/CSD 91/669, </type> <institution> CS Department, UC Berkeley, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: Second, efficient algorithms are needed for stabbing portal sequences comprised of general polygons in three dimensions. We have made some headway against the latter problem by developing a randomized O (n 2 ) algorithm that stabs sequences of n oriented convex polygons <ref> [21] </ref>. 6.2 Discussion The methods described here are particularly appropriate for input with somewhat restricted true visibility, such as that occurring in many architectural models. However, adversarially chosen input can produce unbalanced spatial subdivision trees under our naive criteria, slowing basic operations on the subdivision.
Reference: [22] <author> Gert Vegter. </author> <title> The visibility diagram: a data structure for visibility problems and motion planning. </title> <booktitle> In Proc. 2 nd Scandinavian Workshop on Algorithm Theory, </booktitle> <pages> pages 97-110, </pages> <year> 1990. </year>
Reference-contexts: We broadly refer to these methods as visibility precomputations, since by performing work offline they reduce the effort involved in solving the hidden-surface problem. Much attention has focused on computing exact visibility (e.g., <ref> [5, 12, 16, 19, 22] </ref>); that is, computing an exact description of the visible elements of the scene data for every qualitatively distinct region of viewpoints. Such complete descriptions may be combinato-rially complex and difficult to implement [16, 18], even for highly restricted viewpoint regions (e.g., viewpoints at infinity).
References-found: 22

