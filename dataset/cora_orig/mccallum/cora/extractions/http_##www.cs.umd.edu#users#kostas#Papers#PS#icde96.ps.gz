URL: http://www.cs.umd.edu/users/kostas/Papers/PS/icde96.ps.gz
Refering-URL: http://www.cs.umd.edu/users/kostas/Papers/icde96.html
Root-URL: 
Email: fkostas,skelley,nickg@cs.umd.edu, baras@isr.umd.edu  
Title: Consistency and Performance of Concurrent Interactive Database Applications  
Author: Konstantinos Stathatos Stephen Kelley Nick Roussopoulos yz John S. Baras 
Address: College Park, MD, 20742  
Affiliation: Institute for Systems Research, University of Maryland,  
Date: February 1996  
Note: Appeared in the Proceedings of the 12th International Confer- ence on Data Engineering, New Orleans, LA,  
Abstract: In many modern database applications, there is an emerging need for interactive environments where users directly manipulate the contents of the database. Graphical user interfaces (GUIs) display images of the database which must reflect a consistent up-to-date state of the data with minimum perceivable delay to the user. Moreover, the possibility of several applications concurrently displaying different views of the same database increases the overall system complexity. In this paper, we show how design, performance and concurrency issues can be addressed by adapting existing database techniques. We propose the use of suitable display schemas whose instances compose active views of the database, an extended client caching scheme which is expected to yield significant performance benefits and a locking mechanism that maintains consistency between the GUIs and the database. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Jayant R. Haritsa, Nick Roussopoulos, Michael O. Ball, Anindya Datta, and John S. Baras, "MANDATE: </author> <title> MAnaging Networks using DAtabase TEchnology", </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> vol. 11, no. 9, </volume> <pages> pp. 1360-1372, </pages> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: An example of such an application, which was the motivation for this work, is an advanced network management system (NMS) that relies on an object- oriented DBMS for storing and managing all the necessary data <ref> [1] </ref>. This application builds graphical displays that represent the current state of part of the managed network. Through this display, the network operator can perform a number of management functions (e.g. monitor network activity, change configuration parameters) in order to ensure the expected network operation.
Reference: [2] <author> Ben Shneiderman, </author> <title> Designing the User Interface: Strategies for Effective Human-Computer Interaction, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <note> second edition, </note> <year> 1992. </year>
Reference-contexts: Designers and developers of interactive applications put a lot of effort in building user interfaces appealing to the users both in terms of appearance and functionality. The specific goals they set include a system that <ref> [2] </ref>: * accurately reflects the database contents on the screen, and * responds to user actions without lengthy and un <br>- predictable delays. The importance of the first goal lies on the fact that users take decisions and act based on the perception of the database offered by the interface. <p> Lengthy response times are usually detrimental to productivity, increasing user error rates and decreasing satisfaction <ref> [2] </ref>. Also, users tend to establish expectations of the time required to complete a given task based on past experiences. Unexpected delays usually trouble or frustrate the users. Therefore, high variability in the response time of the user interface should be prevented.
Reference: [3] <author> Michael J. Franklin, </author> <title> "Exploiting Client Resources Through Caching", </title> <booktitle> in Proceedings of the 5th International Workshop on High Performance Transaction Processing, Asilomar, </booktitle> <address> CA, </address> <month> Sept. </month> <year> 1993. </year>
Reference-contexts: The more a client depends on a server to perform a task the less it can use its local resources. A widely used method for minimizing this coupling is client data caching <ref> [3] </ref>. This method allows data to be located close to where they are needed, reducing the client-server communication overhead. As a result, there is a big performance benefit from reduced transaction latency and server workload.
Reference: [4] <author> Jim Gray and Andreas Reuter, </author> <title> Transaction Processing: Concepts and Techniques, </title> <publisher> Morgan Kaufmann, </publisher> <address> San Francisco, CA, </address> <year> 1994. </year>
Reference-contexts: DBMSs preserve client cache coherency as well as transaction semantics by enforcing some kind of con- currency control protocol. Transactions that read and/or update data must satisfy the ACID properties <ref> [4] </ref>. Among those, isolation is usually guaranteed by a data locking mechanism. Under such mechanism, a transaction must obtain exclusive (write) locks for data it wants to update, and shared (read) locks for reading data. <p> The obvious drawback is that most of the lock management functions are replicated at the agent, but on the other hand, there is a potential performance benefit by relieving the database server from additional overhead 5 . 4 For more details look chapter 8 in <ref> [4] </ref> 5 The database server and display lock manager may run on different machines The DLM has two-way communication capability with the clients. It receives messages for holding or releasing display locks as well as update notifications and propagates notifications to clients as necessary.
Reference: [5] <author> Michael J. Franklin, Michael J. Carey, and Miron Livny, </author> <title> "Local Disk Caching for Client-Server Database Systems", </title> <booktitle> in Proceedings of the 19th International Conference on Very Large Data Bases, </booktitle> <address> Dublin, Ireland, </address> <month> Aug. </month> <year> 1993, </year> <pages> pp. 641-655. </pages>
Reference-contexts: Its utilization (i.e., color, width etc) would depend on the utilization of all these database objects (e.g. maximum or average utilization). 3.2 Display caching The various memory spaces found within a client- server database system form a memory hierarchy according to the data access latency associated with each of them <ref> [5] </ref>. Usually, it is a three level hierarchy consisting of the server's disk, the server's main memory and the clients' main memory 2 .
Reference: [6] <author> Michael J. Franklin, </author> <title> Caching and Memory Management in Client-Server Database Systems, </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Wisconsin - Madison, </institution> <year> 1993. </year>
Reference-contexts: It must make sure that all user accessible copies of the same data in any level of the memory hierarchy are consistent, so that a user never accesses stale information. Generally, there are two major classes of protocols: detection-based and avoidance- based protocols <ref> [6] </ref>. Detection-based protocols allow stale data to reside in a client's main memory but require that transactions validate any cached data before they commit. On the other hand, under avoidance-based schemes, cached data are guaranteed to be valid at any time.
Reference: [7] <editor> John S. Baras et al., </editor> <booktitle> "Next Generation Network Management Technology", in AIP Conference Proceedings 325, Conference on NASA Centers for Commercial Development of Space, </booktitle> <address> Albuquerque, NM, </address> <month> Jan </month> <year> 1995, </year> <pages> pp. 75-82. </pages>
Reference-contexts: Also, in every case the database consistency is ultimately guaranteed by the existing concurrency control algorithm. 4 Implementation In order to demonstrate the concepts presented and investigate any potential implementation problems, we designed and implemented a multiple user, limited functionality version of a network configuration management application <ref> [7] </ref>. This application employs two different visualization techniques, the Tree-Map [8] and the PDQ Tree-browser [9], to display complex hardware hierarchies. ObjectStore [10], a commercial object-oriented database system, was used to store the network database. The implementation included three major tasks: 5 1.
Reference: [8] <author> Brian Johnson and Ben Shneiderman, "TreeMaps: </author> <title> A Space-Filling Approach to the Visualization of Hierachical Information Structures", </title> <booktitle> in Proceedings of IEEE Visualization Conference, </booktitle> <address> San Diego, CA, </address> <month> Oct. </month> <year> 1991, </year> <pages> pp. 284-291. </pages>
Reference-contexts: This application employs two different visualization techniques, the Tree-Map <ref> [8] </ref> and the PDQ Tree-browser [9], to display complex hardware hierarchies. ObjectStore [10], a commercial object-oriented database system, was used to store the network database. The implementation included three major tasks: 5 1. Extend the database server with display locking capabilities, 2.
Reference: [9] <author> Harsha P. Kumar, Catherine Plaisant, and Ben Shneiderman, </author> <title> "Browsing Hierarchical Data with Multi-Level Dynamic Queries and Pruning", </title> <type> Technical Report 95-53, </type> <institution> Institute for Systems Research, University of Maryland, College Park, MD, </institution> <month> Mar. </month> <year> 1995. </year>
Reference-contexts: This application employs two different visualization techniques, the Tree-Map [8] and the PDQ Tree-browser <ref> [9] </ref>, to display complex hardware hierarchies. ObjectStore [10], a commercial object-oriented database system, was used to store the network database. The implementation included three major tasks: 5 1. Extend the database server with display locking capabilities, 2.
Reference: [10] <author> Charles Lamb, Gordon Landis, Jack Orenstein, and Dan Weinreb, </author> <title> "The ObjectStore Database System", </title> <journal> Communications of the ACM, </journal> <volume> vol. 34, no. 10, </volume> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: This application employs two different visualization techniques, the Tree-Map [8] and the PDQ Tree-browser [9], to display complex hardware hierarchies. ObjectStore <ref> [10] </ref>, a commercial object-oriented database system, was used to store the network database. The implementation included three major tasks: 5 1. Extend the database server with display locking capabilities, 2. Enhance the client applications structural design to incorporate the display locking mechanism, and 3.
Reference: [11] <author> Michael Stonebraker, Rakesh Agrawal, Umeshwar Dayal, Erich J. Neuhold, and Andreas Reuter, </author> <title> "DBMS Research at a Crossroads: The Vienna Update", </title> <booktitle> in Proceedings of the 19th International Conference on Very Large Data Bases, </booktitle> <address> Dublin, Ireland, </address> <month> Aug. </month> <year> 1993, </year> <pages> pp. 688-692. </pages>
Reference-contexts: systems whose sophisticated displays are often required to accommodate a very larger number of (possibly bigger) objects. 5 Related work To the best of our knowledge, not much emphasis has been given by the database research community on user interfaces even though it has been recognized as an important area <ref> [11] </ref>. User interfaces are usually considered external to a database system and communication is limited to pure data exchange. Views in the context of object-oriented databases [12] are similar to the display schemas that we propose. As in relational databases, views provide external schemas for user convenience and data protection.
Reference: [12] <author> Sandra Heiler and Stanley Zdonik, </author> <title> "Object Views: Extending the Vision", </title> <booktitle> in Proceedings of the 6th International Conference on Data Engineering, </booktitle> <address> Los Angeles, CA, </address> <month> Feb. </month> <year> 1990, </year> <pages> pp. 86-93. </pages>
Reference-contexts: User interfaces are usually considered external to a database system and communication is limited to pure data exchange. Views in the context of object-oriented databases <ref> [12] </ref> are similar to the display schemas that we propose. As in relational databases, views provide external schemas for user convenience and data protection. They allow dynamic definition of classes, sets of objects, multiple interpretations of objects and can facilitate schema evolution [13].
Reference: [13] <author> Elisa Bertino, </author> <title> "A View Mechanism for ObjectOriented Databases", </title> <booktitle> in Proceedings of the International Conference on Extending Database Technology, </booktitle> <address> Vienna, Austria, </address> <month> Mar. </month> <year> 1992, </year> <pages> pp. 136151. </pages>
Reference-contexts: Views in the context of object-oriented databases [12] are similar to the display schemas that we propose. As in relational databases, views provide external schemas for user convenience and data protection. They allow dynamic definition of classes, sets of objects, multiple interpretations of objects and can facilitate schema evolution <ref> [13] </ref>. Work on this area has mainly concentrated on view definition mechanisms and query languages, as in [14] where a query language is proposed to define virtual classes which are populated either with database or with imaginary objects. Performance and consistency issues have been largely ignored.
Reference: [14] <author> Serge Abiteboul and Anthony Bonner, </author> <title> "Objects and Views", </title> <booktitle> in Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <address> Denver, CO, </address> <month> May </month> <year> 1991, </year> <pages> pp. 238-247. </pages>
Reference-contexts: As in relational databases, views provide external schemas for user convenience and data protection. They allow dynamic definition of classes, sets of objects, multiple interpretations of objects and can facilitate schema evolution [13]. Work on this area has mainly concentrated on view definition mechanisms and query languages, as in <ref> [14] </ref> where a query language is proposed to define virtual classes which are populated either with database or with imaginary objects. Performance and consistency issues have been largely ignored. However, it would be interesting to investigate the applicability of these view definition techniques for dynamic user interface specification.
Reference: [15] <author> Catherine Hamon and Arthur M. Keller, </author> <title> "TwoLevel Caching of Composite Object Views of Relational Databases", </title> <booktitle> in Proceedings of the 11th International Conference on Data Engineering, </booktitle> <address> Taipei, Taiwan, </address> <month> Mar. </month> <year> 1995, </year> <pages> pp. 428-437. </pages>
Reference-contexts: Performance and consistency issues have been largely ignored. However, it would be interesting to investigate the applicability of these view definition techniques for dynamic user interface specification. A two-level client caching architecture has been also proposed in <ref> [15] </ref>. Their approach uses the top cache level for realizing application specific schemas. However, the focus of this work was on exploiting this architecture to efficiently implement object-views over a relational database as well as reuse local data for answering subsequent queries.
Reference: [16] <author> Kevin Wilkinson and Marie-Anne Neimat, </author> <title> "Maintaining Consistency of Client-Cached Data", </title> <booktitle> in Proceedings of the 16th International Conference on Very Large Data Bases, </booktitle> <address> Brisbane, Queensland, Australia, </address> <month> Aug. </month> <year> 1990, </year> <pages> pp. 122-133. </pages>
Reference-contexts: However, the focus of this work was on exploiting this architecture to efficiently implement object-views over a relational database as well as reuse local data for answering subsequent queries. Last, display locks are similar to the notify locks presented in <ref> [16] </ref>. Their difference is that the notify lock algorithms were designed to provide strict transaction concurrency control. However, it seems that the rich set of locks and communication modes offered by ObServer [17] for cooperative transactions, can be used to implement display locks.
Reference: [17] <author> Mark F. Hornick and Stanley B. Zdonik, </author> <title> "A Shared, Segmented Memory System for an Object-Oriented Database", </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> vol. 5, no. 1, </volume> <year> 1987. </year>
Reference-contexts: Last, display locks are similar to the notify locks presented in [16]. Their difference is that the notify lock algorithms were designed to provide strict transaction concurrency control. However, it seems that the rich set of locks and communication modes offered by ObServer <ref> [17] </ref> for cooperative transactions, can be used to implement display locks. Non-restrictive read (NR-READ) locks allow a transaction to read an object without prohibiting write privileges to other transactions.
References-found: 17

