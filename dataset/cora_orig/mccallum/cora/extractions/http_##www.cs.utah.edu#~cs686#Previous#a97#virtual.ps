URL: http://www.cs.utah.edu/~cs686/Previous/a97/virtual.ps
Refering-URL: http://www.cs.utah.edu/~cs686/Previous/a97/
Root-URL: 
Title: Eliminating Virtual Function Calls in C++ Programs  
Author: Gerald Aigner Urs Hlzle 
Note: ECOOP 96 Conference Proceedings, Springer Verlag LNCS 1098, pp. 142-166  
Abstract: We have designed and implemented an optimizing source-to-source C++ compiler that reduces the frequency of virtual function calls. Our prototype implementation demonstrates the value of OO-specific optimization for C++. Despite some limitations of our system, and despite the low frequency of virtual function calls in some of the programs, optimization improves the performance of a suite of large C++ applications totalling over 90,000 lines of code by a median of 18% over the original programs and reduces the number of virtual function calls by a median factor of five. For more call-intensive versions of the same programs, performance improved by a median of 26% and the number of virtual calls dropped by a factor of 17.5. Our measurements indicate that inlining barely increases code size, and that for most programs, the instruction cache miss ratio does not increase significantly.
Abstract-found: 1
Intro-found: 1
Reference: [Age95] <author> Ole Agesen. </author> <title> The Cartesian Product Algorithm: Simple and Precise Type Inference of Parametric Polymorphism. </title> <booktitle> In ECOOP95, Ninth European Conference on Object-Oriented Programming, p. </booktitle> <pages> 2-26, </pages> <address> rhus, Denmark, </address> <month> August </month> <year> 1995. </year> <note> Springer-Verlag LNCS 952. </note>
Reference-contexts: For lcom (the only large benchmark measured) Bernstein et al. report a speedup of 4% whereas our system improves performance by 24% over the original program and by 9% over the baseline (see section 6). More ambitious analyses such as concrete type inference systems (e.g., <ref> [Age95, PR94, PC94] </ref>) can determine the concrete receiver types of message sends. Compared to type feedback, a type inferencer may provide more precise information since it may be able to prove that only a single receiver type is possible at a given call site.
Reference: [AH95] <author> Ole Agesen and Urs Hlzle. </author> <title> Type Feedback vs. Concrete Type Inference: A Comparison of Optimization Techniques for Object-Oriented Languages. </title> <booktitle> In OOPSLA95, Object-Oriented Programming Systems, Languages and Applications, p. </booktitle> <pages> 91-107, </pages> <address> Austin, TX, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: CHA is simple to implement and has been shown to be effective for other systems [DGC95, Fer95], and thus we included it in our prototype compiler. Another benefit of combining a static optimization like CHA with a profile-based optimization like type feedback is that they are complementary optimizations <ref> [AH95] </ref>: each of them may improve performance over the other. CHA may provide better performance because it can inline or statically bind sends with zero overhead. Since CHA can prove that a call can invoke only a single target method in all possible executions, any dispatch overhead is completely eliminated. <p> However, its information may also be less precise since it may include types that could occur in theory but never happen in practice. (In other words, the information lacks frequency data.) For SELF, concrete type inference removed more dispatches than type feedback for most programs <ref> [AH95] </ref>.
Reference: [App88] <institution> Apple Computer, Inc. </institution> <note> Object Pascal Users Manual. Cupertino, </note> <year> 1988. </year>
Reference-contexts: In contrast, a system using static compilation (like the present C++ compiler) gathers profile information off-line during a separate program run. 2.2 Static Optimization: Class Hierarchy Analysis We also implemented a static optimization technique, class hierarchy analysis (CHA) <ref> [App88, DGC95, Fer95] </ref>, which can statically bind some virtual function calls given the applications complete class hierarchy. <p> Profile-driven customization (procedure cloning) resulted in an additional improvement of 1-5%. Several systems use whole-program or link-time analysis to optimize object-oriented programs, starting with the Apple Object Pascal linker <ref> [App88] </ref> which turned dynamically-dispatched calls into statically-bound calls if a type had exactly one implementation (e.g., the system contained only a CartesianPoint class and no PolarPoint class). To our knowledge, this system was the first to statically bind dynamically-dispatched calls, although it did not perform any inlining.
Reference: [B+96] <author> David Bernstein, Yaroslav Fedorov, Sara Porat, Joseph Rodrigue, and Eran Yahav. </author> <title> Compiler Optimization of C++ Virtual Function Calls. </title> <booktitle> 2nd Conference on Object-Oriented Technologies and Systems, </booktitle> <address> Toronto, Canada, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: In both studies, the analysis impact on virtual call frequency was significantly higher than in our system, as discussed in section 6.1. Srivastava and Wall [SW92] perform more extensive link-time optimization but do not optimize calls. Bernstein et al. <ref> [B+96] </ref> describe a C++ compiler (apparently developed concurrently with ours) that also inlines virtual function calls using class hierarchy analysis and type feedback. <p> Furthermore, the compiler does not specialize inlined virtual functions (so that nested calls to this cannot be inlined), and cannot optimize calls involving virtual base classes. Although the experimental data presented in <ref> [B+96] </ref> is sketchy and mostly based on microbenchmarks, it appears that the systems limitations significantly impact performance.
Reference: [CGZ94] <author> Brad Calder, Dirk Grunwald, and Benjamin Zorn. </author> <title> Quantifying Behavioral Differences Between C and C++ Programs. </title> <journal> Journal of Programming Languages 2 </journal> <pages> 313-351, </pages> <year> 1994. </year>
Reference-contexts: Finally, we will continue to look for other C++ applications that can be used for benchmarking. Although we are already using large programs totalling over 90,000 lines of code, we feel that currently available benchmarks (including those used in other studies <ref> [CGZ94] </ref>) do not represent the entire spectrum of program characteristics. In particular, programs using large class libraries and frameworks are underrepresented.
Reference: [CG94] <author> Brad Calder and Dirk Grunwald. </author> <title> Reducing Indirect Function Call Overhead in C++ Programs. </title> <booktitle> In 21st Annual ACM Symposium on Principles of Programming Languages, p. </booktitle> <pages> 397-408, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Until now, few profile-based techniques have been applied to hybrid, statically-typed languages like Modula-3 or C++. Based on measurements of C++ programs, Calder and Grunwald <ref> [CG94] </ref> argued that type feedback would be beneficial for C++ and proposed (but did not implement) a weaker form of class hierarchy analysis to improve efficiency.
Reference: [CUL89] <author> Craig Chambers, David Ungar, and Elgin Lee. </author> <title> An Efficient Implementation of SELF, a Dynamically-Typed Object-Oriented Language Based on Prototypes. </title> <booktitle> In OOPSLA 89, Object-Oriented Programming Systems, Languages and Applications, p. </booktitle> <pages> 49-70, </pages> <address> New Orleans, LA, </address> <month> October </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(10), </note> <month> October </month> <year> 1989. </year>
Reference-contexts: So far, much of the research on such optimizations has concentrated on pure object-oriented languages because the frequency of dynamic dispatch is especially high in such languages. Several studies (e.g., <ref> [CUL89, HU94a, G+95] </ref>) have demonstrated that optimization can greatly reduce the frequency of dynamic dispatch in pure object-oriented languages and significantly improve performance. <p> Second, the inline function may be specialized since its receiver type is precisely known to be a B (and only a B). Thus, implicit self calls within the method can be statically bound <ref> [CUL89] </ref>. 4.6 Inlining Strategies Some calls should not be inlined; for example, if a call has 20 different receiver types, each of which occurs 5% of the time, inlining is unlikely to improve performance: inlining just one case improves only 5% of the call sites executions but slows down the 11
Reference: [CU90] <author> Craig Chambers and David Ungar. </author> <title> Iterative Type Analysis and Extended Message Splitting: Optimizing Dynamically-Typed Object-Oriented Programs. </title> <booktitle> In Proceedings of the SIGPLAN 90 Conference on Programming Language Design and Implementation, p. </booktitle> <pages> 150-164, </pages> <address> White Plains, NY, </address> <month> June </month> <year> 1990. </year> <note> Published as SIGPLAN Notices 25(6), </note> <month> June </month> <year> 1990. </year>
Reference-contexts: Third, type feedback could be complemented with additional optimizations to improve performance further. In particular, profile-based customization and some form of splitting <ref> [CU90] </ref> are attractive candidates, although the latter might not be needed if the back-end C++ compiler did a better job of alias analysis. Finally, some of our benchmarks just dont execute that many virtual function calls to start with.
Reference: [CM+92] <author> Pohua P. Chang, Scott A. Mahlke, William Y. Chen, and Wen-Mei W. Hwu. </author> <title> Profile-guided automatic inline expansion for C programs. </title> <booktitle> SoftwarePractice and Experience 22 (5): </booktitle> <pages> 349-369, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: can also better determine whether the send is actually worth optimizing (i.e., executed often enough). 4 3 Related Work Profile information has been used for optimization in many systems; as usual, Knuth [Knu70] was the first to suggest profile-based optimization, and today it is part of many research systems (e.g., <ref> [CM+92, Hl94, G+95] </ref>) as well as production compilers. Studies of inlining for procedural languages like C or Fortran have found that it often does not significantly increase execution speed but tends to significantly increase code size (e.g., [DH88, HwC89, CHT91, CM+92, Hall91]). <p> Studies of inlining for procedural languages like C or Fortran have found that it often does not significantly increase execution speed but tends to significantly increase code size (e.g., <ref> [DH88, HwC89, CHT91, CM+92, Hall91] </ref>). Our results indicate that these previous results do not apply to C++ programs. In implementations of dynamic or object-oriented languages, profiling information has often been used to identify (and optimize for) common cases.
Reference: [CHT91] <author> K. D. Cooper, M. W. Hall, and L. Torczon. </author> <title> An experiment with inline substitution. </title> <booktitle> SoftwarePractice and Experience 21 (6): </booktitle> <pages> 581-601, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Studies of inlining for procedural languages like C or Fortran have found that it often does not significantly increase execution speed but tends to significantly increase code size (e.g., <ref> [DH88, HwC89, CHT91, CM+92, Hall91] </ref>). Our results indicate that these previous results do not apply to C++ programs. In implementations of dynamic or object-oriented languages, profiling information has often been used to identify (and optimize for) common cases.
Reference: [DH88] <author> Jack W. Davidson and Anne M. Holler. </author> <title> A study of a C function inliner. </title> <journal> Software Practice and Experience 18(8): </journal> <pages> 775-90, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: Studies of inlining for procedural languages like C or Fortran have found that it often does not significantly increase execution speed but tends to significantly increase code size (e.g., <ref> [DH88, HwC89, CHT91, CM+92, Hall91] </ref>). Our results indicate that these previous results do not apply to C++ programs. In implementations of dynamic or object-oriented languages, profiling information has often been used to identify (and optimize for) common cases.
Reference: [DC94] <author> Jeffrey Dean and Craig Chambers. </author> <title> Towards Better Inlining Decisions using Inlining Trials. </title> <booktitle> In Proceedings of the ACM Symposium on Lisp and Functional Programming Languages (LFP 94), </booktitle> <address> Orlando, FL, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: The compilers inlining strategies could also be improved. Inlining should probably take into account the size of the inlinee [Hl94], and the compiler should estimate how much the inlinees code can be simplified (i.e., because of constant arguments <ref> [DC94] </ref>). Furthermore, type feedback could be extended with profile-driven customization to further improve performance [DCG95]. Profiling could be extended to use k-CCP profiles (i.e., take call chains into account), although the improvement from the additional precision may be small [G+95].
Reference: [DCG95] <author> Jeffrey Dean, Craig Chambers, and David Grove. </author> <title> Identifying Profitable Specialization in Object-Oriented Languages. </title> <booktitle> In Proceedings of the SIGPLAN 95 Conference on Programming Language Design and Implementation, </booktitle> <address> La Jolla, CA June 1995. </address>
Reference-contexts: Inlining should probably take into account the size of the inlinee [Hl94], and the compiler should estimate how much the inlinees code can be simplified (i.e., because of constant arguments [DC94]). Furthermore, type feedback could be extended with profile-driven customization to further improve performance <ref> [DCG95] </ref>. Profiling could be extended to use k-CCP profiles (i.e., take call chains into account), although the improvement from the additional precision may be small [G+95]. Also, a more detailed investigation of the interaction of optimization with superscalar architectures is needed.
Reference: [DGC95] <author> Jeffrey Dean, David Grove, and Craig Chambers. </author> <title> Optimization of Object-Oriented Programs Using Static Class Hierarchy Analysis. </title> <booktitle> In ECOOP 95, Ninth European Conference on Object-Oriented Programming, rhus, 1995. </booktitle> <publisher> Springer-Verlag LNCS 952. </publisher>
Reference-contexts: In contrast, a system using static compilation (like the present C++ compiler) gathers profile information off-line during a separate program run. 2.2 Static Optimization: Class Hierarchy Analysis We also implemented a static optimization technique, class hierarchy analysis (CHA) <ref> [App88, DGC95, Fer95] </ref>, which can statically bind some virtual function calls given the applications complete class hierarchy. <p> The optimization is based on a simple observation: if a is an instance of class A (or any subclass), the call a-&gt;f () can be statically bound if none of As subclasses overrides f. CHA is simple to implement and has been shown to be effective for other systems <ref> [DGC95, Fer95] </ref>, and thus we included it in our prototype compiler. Another benefit of combining a static optimization like CHA with a profile-based optimization like type feedback is that they are complementary optimizations [AH95]: each of them may improve performance over the other. <p> To our knowledge, this system was the first to statically bind dynamically-dispatched calls, although it did not perform any inlining. As mentioned above, Fernandez [Fer95] used class hierarchy analysis for Modula-3, and Dean et al. 5 <ref> [DGC95] </ref> describe its use for Cecil. In both studies, the analysis impact on virtual call frequency was significantly higher than in our system, as discussed in section 6.1. Srivastava and Wall [SW92] perform more extensive link-time optimization but do not optimize calls. <p> Class hierarchy analysis is much less successful: for many of the large programs, it fails to reduce the number of virtual calls appreciably, removing only a median of 4% of the calls (mean: 23%). 3 This poor performance surprised us since others have reported very good results for CHA <ref> [DGC95, Fer95] </ref>; at first, we suspected an implementation bug. However, many of our programs simply do not have enough monomorphic calls that could be optimized. <p> original programs (but not on the all-virtuals programs, we found that class hierarchy analysis was ineffective in removing virtual function calls (removing a median of 4% and an average of 23% of the calls), contrary to the results previously published for Modula-3 programs [Fer95] or the pure object-oriented language Cecil <ref> [DGC95] </ref>. 23 Inlining does not significantly increase code size. On average, optimized programs only expand by 9%. Moreover, this code expansion does not impact performance much; for most programs, the instruction cache miss ratio does not increase significantly, and for some programs it even decreases.
Reference: [Dea95] <author> Jeffrey Dean. </author> <title> Corrected Cecil performance numbers. </title> <type> Private communication, </type> <month> May </month> <year> 1995. </year>
Reference: [Dec95] <institution> Declarative Systems. The C++ Auditor. Palo Alto, </institution> <year> 1995. </year> <month> (auditor@declarative.com) </month>
Reference-contexts: To implement this pre-pass, and for the actual optimizing compiler, we used a commercial tool, the CCAuditor C++ parser from Declarative Systems <ref> [Dec95] </ref>. CCAuditor contains an empty attribute grammar for C++ which can be extended to implement arbitrary analyses or transformations. We used CCAuditor to build a simplified parse tree of the program which is then traversed and transformed by a C++ program.
Reference: [DHV95] <author> Karel Driesen, Urs Hlzle, and Jan Vitek. </author> <title> Message Dispatch On Pipelined Processors. </title> <booktitle> ECOOP 95 Conference Proceedings, </booktitle> <address> Aarhus, Denmark, </address> <month> August </month> <year> 1995. </year> <booktitle> Published as Springer Verlag Lecture Notes in Computer Science 952, </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1995. </year> <month> 25 </month>
Reference-contexts: In particular, more aggressively pipelined superscalar CPUs are likely to benefit more from virtual call elimination since the cost of indirect calls tends to increase on such architectures <ref> [DHV95] </ref>. In fact, this trend is already visible on the SuperSPARC: whereas type feedback reduces the number of instructions executed by a median of only 17 5%, it reduces execution time by 16%. Clearly, optimization improves the effectiveness of superscalar issue and pipelining.
Reference: [DS84] <author> L. Peter Deutsch and Alan Schiffman. </author> <title> Efficient Implementation of the Smalltalk-80 System. </title> <booktitle> In Conference Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages, p. </booktitle> <pages> 297-302, </pages> <address> Salt Lake City, UT, </address> <month> January </month> <year> 1984. </year>
Reference-contexts: For example, Lisp systems usually inline the integer case of generic arithmetic and handle all other type combinations with a call to a routine in the run-time system. The Deutsch-Schiffman Smalltalk compiler was the first object-oriented system to predict integer receivers for common message names such as + <ref> [DS84] </ref>. All these systems do not use application-specific profiles. The SELF system pioneered the use of profile information for optimizing object-oriented languages. An experimental proof-of-concept system [HCU91] was the first one to use type feedback (then called PIC-based inlining) for optimization purposes.
Reference: [Deu83] <author> L. Peter Deutsch. </author> <title> Reusability in the Smalltalk-80 system. </title> <booktitle> Workshop On Reusability In Programming, </booktitle> <address> Newport, RI, </address> <year> 1983. </year>
Reference-contexts: Unfortunately, object-oriented programs are harder to optimize than programs written in languages like C or Fortran. There are two main reasons for this. First, object-oriented programming encourages code factoring and differential programming <ref> [Deu83] </ref>; as a result, procedures are smaller and procedure calls more frequent. Second, it is hard to optimize calls in object-oriented programs because they use dynamic dispatch: the procedure invoked by the call is not known until run-time since it depends on the dynamic type of the receiver.
Reference: [ES90] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: VPROF inserts a non-virtual call to a run-time routine before each virtual call, passing in all information needed to identify the call site (e.g., file name, line number, and call number within the line). Additionally, the run-time routine receives a pointer to the receivers dispatch table (vtable <ref> [ES90] </ref>) and the index of the vtable entry being used to dispatch the call. In order to obtain the class name of receiver and the method name, the compiler enhances the vtable with one extra element per entry containing the necessary information.
Reference: [Fer95] <author> M. F. Fernandez. </author> <title> Simple and effective link-time optimization of Modula-3 programs. </title> <booktitle> In Proceedings of the SIGPLAN 95 Conference on Programming Language Design and Implementation, p. </booktitle> <pages> 103-115, </pages> <address> La Jolla, CA, </address> <month> June </month> <year> 1995. </year> <note> Published as SIGPLAN Notices 30(6), </note> <month> June </month> <year> 1995. </year>
Reference-contexts: In contrast, a system using static compilation (like the present C++ compiler) gathers profile information off-line during a separate program run. 2.2 Static Optimization: Class Hierarchy Analysis We also implemented a static optimization technique, class hierarchy analysis (CHA) <ref> [App88, DGC95, Fer95] </ref>, which can statically bind some virtual function calls given the applications complete class hierarchy. <p> The optimization is based on a simple observation: if a is an instance of class A (or any subclass), the call a-&gt;f () can be statically bound if none of As subclasses overrides f. CHA is simple to implement and has been shown to be effective for other systems <ref> [DGC95, Fer95] </ref>, and thus we included it in our prototype compiler. Another benefit of combining a static optimization like CHA with a profile-based optimization like type feedback is that they are complementary optimizations [AH95]: each of them may improve performance over the other. <p> Their estimate of the performance benefits of this optimization (2-24% improvements, excluding benefits from inlining) exceeds the improvements measured in our system, partially because they assume a more aggressively pipelined CPU (DEC Alpha) which benefits more from reduced pipeline stalls than the SuperSPARC system we used. Fernandez <ref> [Fer95] </ref> applied link-time optimization to Modula-3 programs and found that class hierarchy analysis eliminated between 2% and 79% of the virtual calls in the Modula-3 applications measured, reducing the number of instructions executed by 3-11%. Profile-driven customization (procedure cloning) resulted in an additional improvement of 1-5%. <p> To our knowledge, this system was the first to statically bind dynamically-dispatched calls, although it did not perform any inlining. As mentioned above, Fernandez <ref> [Fer95] </ref> used class hierarchy analysis for Modula-3, and Dean et al. 5 [DGC95] describe its use for Cecil. In both studies, the analysis impact on virtual call frequency was significantly higher than in our system, as discussed in section 6.1. <p> Class hierarchy analysis is much less successful: for many of the large programs, it fails to reduce the number of virtual calls appreciably, removing only a median of 4% of the calls (mean: 23%). 3 This poor performance surprised us since others have reported very good results for CHA <ref> [DGC95, Fer95] </ref>; at first, we suspected an implementation bug. However, many of our programs simply do not have enough monomorphic calls that could be optimized. <p> measurements produced some surprising results: On the original programs (but not on the all-virtuals programs, we found that class hierarchy analysis was ineffective in removing virtual function calls (removing a median of 4% and an average of 23% of the calls), contrary to the results previously published for Modula-3 programs <ref> [Fer95] </ref> or the pure object-oriented language Cecil [DGC95]. 23 Inlining does not significantly increase code size. On average, optimized programs only expand by 9%.
Reference: [G+95] <author> David Grove, Jeffrey Dean, Charles D. Garrett, and Craig Chambers. </author> <title> Profile-Guided Receiver Class Prediction. </title> <booktitle> In OOPSLA 95, Object-Oriented Programming Systems, Languages and Applications, p. </booktitle> <pages> 108-123, </pages> <address> Austin, TX, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: So far, much of the research on such optimizations has concentrated on pure object-oriented languages because the frequency of dynamic dispatch is especially high in such languages. Several studies (e.g., <ref> [CUL89, HU94a, G+95] </ref>) have demonstrated that optimization can greatly reduce the frequency of dynamic dispatch in pure object-oriented languages and significantly improve performance. <p> can also better determine whether the send is actually worth optimizing (i.e., executed often enough). 4 3 Related Work Profile information has been used for optimization in many systems; as usual, Knuth [Knu70] was the first to suggest profile-based optimization, and today it is part of many research systems (e.g., <ref> [CM+92, Hl94, G+95] </ref>) as well as production compilers. Studies of inlining for procedural languages like C or Fortran have found that it often does not significantly increase execution speed but tends to significantly increase code size (e.g., [DH88, HwC89, CHT91, CM+92, Hall91]). <p> An experimental proof-of-concept system [HCU91] was the first one to use type feedback (then called PIC-based inlining) for optimization purposes. The SELF-93 system [HU94a] used on-line profile information to select frequently executed methods for optimization and to determine receiver types via type feedback. Similarly, the Cecil compiler <ref> [G+95] </ref> uses off-line profiling for optimization and inlining. Grove et al. [G+95] also examined the cross-input stability of receiver class profiled in C++ and Cecil and found it good enough to be used for optimization. <p> The SELF-93 system [HU94a] used on-line profile information to select frequently executed methods for optimization and to determine receiver types via type feedback. Similarly, the Cecil compiler <ref> [G+95] </ref> uses off-line profiling for optimization and inlining. Grove et al. [G+95] also examined the cross-input stability of receiver class profiled in C++ and Cecil and found it good enough to be used for optimization. Until now, few profile-based techniques have been applied to hybrid, statically-typed languages like Modula-3 or C++. <p> The resulting executable is then used to obtain receiver class distribution information for each call site. At the end of the program run, a small run-time library collects and outputs the data collected; this output is later used by the optimizing compiler. In Groves terminology <ref> [G+95] </ref>, VPROF produces 1-CCP profiles, i.e., individual receiver class distributions for each call site. 4.5 The Optimizing Compiler The main optimization step in our system consists of a source-to-source optimizing compiler that eliminates virtual function calls using either the profile information, knowledge of the complete class hierarchy, or both. <p> Unfortunately, the choice of publicly available C++ programs which compile with current C++ compilers on current operating system versions (Solaris 2.5 and AIX 4.1) is still limited. Two of the benchmarks (deltablue and richards) are much smaller than the others; they are included for comparison with earlier studies (e.g., <ref> [HU94a, G+95] </ref>). Richards is the only artificial benchmark in our suite (i.e., the program was never used to solve any real problem). Table 3 lists the benchmarks and their sizes. <p> Furthermore, type feedback could be extended with profile-driven customization to further improve performance [DCG95]. Profiling could be extended to use k-CCP profiles (i.e., take call chains into account), although the improvement from the additional precision may be small <ref> [G+95] </ref>. Also, a more detailed investigation of the interaction of optimization with superscalar architectures is needed. Modern processors are increasingly deeply pipelined, contain multiple execution units, and can execute instructions out-of-order or speculatively.
Reference: [Hall91] <author> Mary Wolcott Hall. </author> <title> Managing Interprocedural Optimization. </title> <type> Technical Report COMP TR91-157 (Ph.D. Thesis), </type> <institution> Computer Science Department, Rice University, </institution> <month> April </month> <year> 1991. </year>
Reference-contexts: Studies of inlining for procedural languages like C or Fortran have found that it often does not significantly increase execution speed but tends to significantly increase code size (e.g., <ref> [DH88, HwC89, CHT91, CM+92, Hall91] </ref>). Our results indicate that these previous results do not apply to C++ programs. In implementations of dynamic or object-oriented languages, profiling information has often been used to identify (and optimize for) common cases.
Reference: [HCU91] <author> Urs Hlzle, Craig Chambers, and David Ungar. </author> <title> Optimizing Dynamically-Typed Object-Oriented Languages with Polymorphic Inline Caches. </title> <booktitle> In ECOOP 91, Fourth European Conference on Object-Oriented Programming, p. </booktitle> <pages> 21-38, </pages> <address> Geneva, </address> <month> July </month> <year> 1991. </year> <note> Springer-Verlag LNCS 512. </note>
Reference-contexts: The Deutsch-Schiffman Smalltalk compiler was the first object-oriented system to predict integer receivers for common message names such as + [DS84]. All these systems do not use application-specific profiles. The SELF system pioneered the use of profile information for optimizing object-oriented languages. An experimental proof-of-concept system <ref> [HCU91] </ref> was the first one to use type feedback (then called PIC-based inlining) for optimization purposes. The SELF-93 system [HU94a] used on-line profile information to select frequently executed methods for optimization and to determine receiver types via type feedback.
Reference: [Hl94] <author> Urs Hlzle. </author> <title> Adaptive Optimization for SELF: Reconciling High Performance with Exploratory Programming. </title> <type> Ph.D. Thesis, </type> <institution> Department of Computer Science, Stanford University, </institution> <month> August </month> <year> 1994. </year> <note> (Available via http://www.cs.ucsb.edu/~urs.) </note>
Reference-contexts: can also better determine whether the send is actually worth optimizing (i.e., executed often enough). 4 3 Related Work Profile information has been used for optimization in many systems; as usual, Knuth [Knu70] was the first to suggest profile-based optimization, and today it is part of many research systems (e.g., <ref> [CM+92, Hl94, G+95] </ref>) as well as production compilers. Studies of inlining for procedural languages like C or Fortran have found that it often does not significantly increase execution speed but tends to significantly increase code size (e.g., [DH88, HwC89, CHT91, CM+92, Hall91]). <p> The compilers inlining strategies could also be improved. Inlining should probably take into account the size of the inlinee <ref> [Hl94] </ref>, and the compiler should estimate how much the inlinees code can be simplified (i.e., because of constant arguments [DC94]). Furthermore, type feedback could be extended with profile-driven customization to further improve performance [DCG95].
Reference: [HU94a] <author> Urs Hlzle and David Ungar. </author> <title> Optimizing Dynamically-Dispatched Calls with Run-Time Type Feedback. </title> <booktitle> In Proceedings of the SIGPLAN 94 Conference on Programming Language Design and Implementation, p. </booktitle> <pages> 326-336. </pages> <note> Published as SIGPLAN Notices 29(6), </note> <month> June </month> <year> 1994. </year>
Reference-contexts: So far, much of the research on such optimizations has concentrated on pure object-oriented languages because the frequency of dynamic dispatch is especially high in such languages. Several studies (e.g., <ref> [CUL89, HU94a, G+95] </ref>) have demonstrated that optimization can greatly reduce the frequency of dynamic dispatch in pure object-oriented languages and significantly improve performance. <p> In this section, we briey review these optimizations before describing our C++-specific implementation in the next section. 2.1 Profile-Based Optimization: Type Feedback Type feedback <ref> [HU94a] </ref> is an optimization technique originally developed for the SELF language. Its main idea is to use profile information gathered at run-time to eliminate dynamic dispatches. <p> All these systems do not use application-specific profiles. The SELF system pioneered the use of profile information for optimizing object-oriented languages. An experimental proof-of-concept system [HCU91] was the first one to use type feedback (then called PIC-based inlining) for optimization purposes. The SELF-93 system <ref> [HU94a] </ref> used on-line profile information to select frequently executed methods for optimization and to determine receiver types via type feedback. Similarly, the Cecil compiler [G+95] uses off-line profiling for optimization and inlining. <p> Unfortunately, the choice of publicly available C++ programs which compile with current C++ compilers on current operating system versions (Solaris 2.5 and AIX 4.1) is still limited. Two of the benchmarks (deltablue and richards) are much smaller than the others; they are included for comparison with earlier studies (e.g., <ref> [HU94a, G+95] </ref>). Richards is the only artificial benchmark in our suite (i.e., the program was never used to solve any real problem). Table 3 lists the benchmarks and their sizes.
Reference: [HwC89] <author> W. W. Hwu and P. P. Chang. </author> <title> Inline function expansion for compiling C programs. </title> <booktitle> In Proceedings of the SIGPLAN 89 Conference on Programming Language Design and Implementation, p. </booktitle> <pages> 246-57, </pages> <address> Portland, OR, </address> <month> June </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(7), </note> <month> July </month> <year> 1989. </year>
Reference-contexts: Studies of inlining for procedural languages like C or Fortran have found that it often does not significantly increase execution speed but tends to significantly increase code size (e.g., <ref> [DH88, HwC89, CHT91, CM+92, Hall91] </ref>). Our results indicate that these previous results do not apply to C++ programs. In implementations of dynamic or object-oriented languages, profiling information has often been used to identify (and optimize for) common cases.
Reference: [Knu70] <author> Donald Knuth. </author> <title> An empirical study of FORTRAN programs. </title> <type> Technical Report CS-186, </type> <institution> Department of Computer Science, Stanford University, </institution> <year> 1970. </year>
Reference-contexts: Furthermore, being profile-based, it can also better determine whether the send is actually worth optimizing (i.e., executed often enough). 4 3 Related Work Profile information has been used for optimization in many systems; as usual, Knuth <ref> [Knu70] </ref> was the first to suggest profile-based optimization, and today it is part of many research systems (e.g., [CM+92, Hl94, G+95]) as well as production compilers.
Reference: [Lea90] <editor> Douglas Lea. Customization in C++. </editor> <booktitle> In Proceedings of the 1990 Usenix C++ Conference, p. </booktitle> <pages> 301-314, </pages> <address> San Francisco, CA, </address> <month> April, </month> <year> 1990. </year>
Reference: [PR94] <author> Hemant D. Pande and Barbara G. Ryder. </author> <title> Static Type Determination and Aliasing for C++. </title> <type> Technical Report LCSR-TR-236, </type> <institution> Rutgers University, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: For lcom (the only large benchmark measured) Bernstein et al. report a speedup of 4% whereas our system improves performance by 24% over the original program and by 9% over the baseline (see section 6). More ambitious analyses such as concrete type inference systems (e.g., <ref> [Age95, PR94, PC94] </ref>) can determine the concrete receiver types of message sends. Compared to type feedback, a type inferencer may provide more precise information since it may be able to prove that only a single receiver type is possible at a given call site.
Reference: [PC94] <author> John B. Plevyak and Andrew A. Chien. </author> <title> Precise Concrete Type Inference for Object-Oriented Languages. </title> <booktitle> OOPSLA 94, Object-Oriented Programming Systems, Languages and Applications, p. </booktitle> <pages> 324-340, </pages> <address> Portland, OR, </address> <month> October </month> <year> 1994. </year> <note> Published as SIGPLAN Notices 29(10), </note> <month> October </month> <year> 1994. </year>
Reference-contexts: For lcom (the only large benchmark measured) Bernstein et al. report a speedup of 4% whereas our system improves performance by 24% over the original program and by 9% over the baseline (see section 6). More ambitious analyses such as concrete type inference systems (e.g., <ref> [Age95, PR94, PC94] </ref>) can determine the concrete receiver types of message sends. Compared to type feedback, a type inferencer may provide more precise information since it may be able to prove that only a single receiver type is possible at a given call site.
Reference: [Ser95] <author> Mauricio Serrano. </author> <title> Virtual function call frequencies in C++ programs. </title> <type> Private communication, </type> <year> 1995. </year>
Reference-contexts: For example, the Taligent CommonPoint frameworks provide all functionality through virtual functions, and thus programs using CommonPoint (or similar frameworks) will exhibit much higher virtual function call frequencies <ref> [Ser95] </ref>. Lacking real, large, freely available examples of this programming style, we created the all virtual programs to provide some indication of how optimization would impact such programs.
Reference: [SW92] <author> Amitabh Srivastava and David Wall. </author> <title> A Practical System for Intermodule Code Optimization at Link- Time. </title> <note> DEC WRL Research Report 92/6, </note> <month> December </month> <year> 1992. </year>
Reference-contexts: As mentioned above, Fernandez [Fer95] used class hierarchy analysis for Modula-3, and Dean et al. 5 [DGC95] describe its use for Cecil. In both studies, the analysis impact on virtual call frequency was significantly higher than in our system, as discussed in section 6.1. Srivastava and Wall <ref> [SW92] </ref> perform more extensive link-time optimization but do not optimize calls. Bernstein et al. [B+96] describe a C++ compiler (apparently developed concurrently with ours) that also inlines virtual function calls using class hierarchy analysis and type feedback.
Reference: [US87] <author> David Ungar and Randall B. Smith. </author> <title> SELF: The Power of Simplicity. </title> <booktitle> In OOPSLA 87, Object-Oriented Programming Systems, Languages and Applications, p. </booktitle> <pages> 227-241, </pages> <address> Orlando, FL, </address> <month> October </month> <year> 1987. </year> <note> Published as SIGPLAN Notices 22(12), </note> <month> December </month> <year> 1987. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June </month> <year> 1991. </year>
Reference: [Wall91] <author> David Wall. </author> <title> Predicting Program Behavior Using Real or Estimated Profiles. </title> <booktitle> In Proceedings of the SIGPLAN 91 Conference on Programming Language Design and Implementation, p. </booktitle> <pages> 59-70, </pages> <address> Toronto, Canada, </address> <month> June </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(6), </note> <month> June </month> <year> 1991. </year>
References-found: 35

