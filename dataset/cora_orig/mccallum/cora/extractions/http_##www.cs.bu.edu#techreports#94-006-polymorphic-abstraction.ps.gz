URL: http://www.cs.bu.edu/techreports/94-006-polymorphic-abstraction.ps.gz
Refering-URL: http://cs-www.bu.edu/techreports/Home.html
Root-URL: 
Email: kfoury@cs.bu.edu  jbw@cs.bu.edu  
Title: Adding Polymorphic Abstraction to ML (Detailed Abstract)  
Author: A. J. Kfoury J. B. Wells 
Note: 2 Removing the Monomorphic-Abstraction Restriction  
Date: March 16, 1994 1 Synopsis  
Address: Boston University  
Affiliation: Dept. of Computer Science Boston University  Dept. of Computer Science  
Abstract: The ML programming language restricts type polymorphism to occur only in the "let-in" construct and requires every occurrence of a formal parameter of a function (a -abstraction) to have the same type. Milner in 1978 [Mil78] refers to this restriction, which was adopted to help ML achieve automatic type inference, as a serious limitation. We show that this restriction can be relaxed enough to allow universal polymorphic abstraction without losing automatic type inference. In other words, the language may allow occurrences of a formal parameter to have types that are substitution instances of a generic type. This extension is equivalent to the rank-2 fragment of system F. We precisely characterize the additional program phrases (-terms) that can be typed with this extension and we describe typing anomalies both before and after the extension. We discuss how macros may be used to gain some of the power of rank-3 types without losing automatic type inference. We also discuss user-interface problems in how to inform the programmer of the possible types a program phrase (-term) may have. We now present Core-ML, a fragment of ML containing the essential parts for our analysis. Core-ML is a -calculus augmented with the let-in construct and a set of type inference rules. The usual constants of ML, including the fixpoint operator which introduces recursion, are omitted from the language at both the term and type level. We assume the reader is familiar with some notation for typed -calculi. The set T of Core-ML terms is defined by the grammar T ::= V j (T T ) j (V:T ) j (let V = T in T ) where V is the set of term variables. The term (let x = M in N ) is operationally equivalent to ((x:N )M ) although it is typed more permissively. Letting V be the set of type variables, the allowed set of types is the set U defined in Figure 1. The set O of open (monomorphic) types and the set U of universal (polymorphic) types, are called "types" and "type-schemes", respectively, in the ML literature. When t; t 0 are types and ~ff = fff 1 ; : : : ; ff n g is a set of variables, we write 8~ff:t t 0 whenever there exist types t 1 ; : : : ; t n such that t 0 = t [ff 1 := t 1 ; : : : ; ff n := t n ]. We present the inference rules of Core-ML in Figure 2. Although these are not the standard inference rules for ML, these rules type the same set of terms and differ only in that the final derived type for a term must be monomorphic [CDDK86]. Observe the restrictions in the rules that the types t and t 0 must be quantifier-free and can not be polymorphic. Type polymorphism in ML is only allowed for the bound variable of the let-in construct. Previous research has shown that type polymorphism can not be allowed for the bound variable of the letrec-in construct (which we have omitted from our Core-ML) without losing automatic type inference [KTU93]. However, we show that type polymorphism in the form of universal types may safely be allowed for the bound variable of ordinary -abstractions. fl This work is partly supported by NSF grant CCR-9113196.
Abstract-found: 1
Intro-found: 1
Reference: [CDDK86] <author> D. Clement, J. Despeyroux, T. Despeyroux, and G. Kahn. </author> <title> A simple applicative language: </title> <booktitle> Mini-ML. In Proc. ACM Conf. LISP Funct. Program., </booktitle> <pages> pp. 13-27, </pages> <year> 1986. </year>
Reference-contexts: We present the inference rules of Core-ML in Figure 2. Although these are not the standard inference rules for ML, these rules type the same set of terms and differ only in that the final derived type for a term must be monomorphic <ref> [CDDK86] </ref>. Observe the restrictions in the rules that the types t and t 0 must be quantifier-free and can not be polymorphic. Type polymorphism in ML is only allowed for the bound variable of the let-in construct.
Reference: [DM82] <author> L. Damas and R. Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Conf. Rec. 9th Ann. ACM Symp. Princ. Program. Lang., </booktitle> <pages> pp. 207-212, </pages> <year> 1982. </year>
Reference: [KTU93] <author> A. J. Kfoury, J. Tiuryn, and P. Urzyczyn. </author> <title> Type reconstruction in the presence of polymorphic recursion. </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> 15(2) </volume> <pages> 290-311, </pages> <month> Apr. </month> <year> 1993. </year>
Reference-contexts: Type polymorphism in ML is only allowed for the bound variable of the let-in construct. Previous research has shown that type polymorphism can not be allowed for the bound variable of the letrec-in construct (which we have omitted from our Core-ML) without losing automatic type inference <ref> [KTU93] </ref>.
Reference: [KW93] <author> A. J. Kfoury and J. B. Wells. </author> <title> A direct algorithm for type inference in the rank-2 fragment of the second-order -calculus. </title> <type> Tech. Rep. 93-017, </type> <institution> Comput. Sci. Dept., Boston Univ., </institution> <year> 1993. </year>
Reference-contexts: The side conditions of the rules in the figure on the types t and t 0 are simple consequences of the restrictions just stated and could be omitted from the figure. The depicted system is exactly equivalent to the system fl ;fl 2 defined in <ref> [KW93] </ref>, which is equivalent in typing power (but not in derived types) to the system fl 2 , the rank-2 fragment of the second-order -calculus (system F). <p> Theorem 2.1 is easy for the reader to check. Theorem 2.2 is a result of other recent research <ref> [KW93] </ref>. At this point, it is reasonable to ask whether the restriction can be lifted any further so that types assigned to variables may be rank-2 or higher types. Unfortunately, it is the case that type inference is undecidable for system fl k where k 3 [KW93], making it seem unlikely <p> of other recent research <ref> [KW93] </ref>. At this point, it is reasonable to ask whether the restriction can be lifted any further so that types assigned to variables may be rank-2 or higher types. Unfortunately, it is the case that type inference is undecidable for system fl k where k 3 [KW93], making it seem unlikely that Core-ML+UPA can be extended with more powerful polymorphism. 2 VAR A ` x : 8~ff: A (x) ; 2 O; ~ff =2 FTV (A) A ` M : t ! t 0 ; A ` N : t ABS A ` (x:M ) : 8~ff:(t <p> We intend to research this problem further. Fortunately, the additional terms typable in Core-ML+UPA but not in Core-ML can be characterized in a precise and simple way. The transformation 4 from <ref> [KW93] </ref> transforms a term of the form ((x:(y:N ))P ) to (y:((x:N )P )) (some restrictions in [KW93] are ignored here). The transformation 4 can be treated as a reduction relation. It can be easily checked that 4 -reduction preserves fi-equivalence and terminates quickly. <p> We intend to research this problem further. Fortunately, the additional terms typable in Core-ML+UPA but not in Core-ML can be characterized in a precise and simple way. The transformation 4 from <ref> [KW93] </ref> transforms a term of the form ((x:(y:N ))P ) to (y:((x:N )P )) (some restrictions in [KW93] are ignored here). The transformation 4 can be treated as a reduction relation. It can be easily checked that 4 -reduction preserves fi-equivalence and terminates quickly.
Reference: [Mil78] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> J. Comput. Syst. Sci., </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: 1 Synopsis The ML programming language restricts type polymorphism to occur only in the "let-in" construct and requires every occurrence of a formal parameter of a function (a -abstraction) to have the same type. Milner in 1978 <ref> [Mil78] </ref> refers to this restriction, which was adopted to help ML achieve automatic type inference, as a serious limitation. We show that this restriction can be relaxed enough to allow universal polymorphic abstraction without losing automatic type inference. <p> Consider the following example (slightly adjusted) given by Milner in 1978 to illustrate what he calls "the main limitation" of ML typing <ref> [Mil78, p. 356] </ref>.
References-found: 5

