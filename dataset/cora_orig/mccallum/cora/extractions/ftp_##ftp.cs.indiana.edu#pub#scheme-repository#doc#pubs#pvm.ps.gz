URL: ftp://ftp.cs.indiana.edu/pub/scheme-repository/doc/pubs/pvm.ps.gz
Refering-URL: http://www.cs.indiana.edu/scheme-repository/doc.publications.html
Root-URL: http://www.cs.indiana.edu
Title: A Parallel Virtual Machine for Efficient Scheme Compilation similar to many real computer architectures and
Author: Marc Feeley and James S. Miller 
Note: PVM is  
Address: Waltham, MA 02254-9110  
Affiliation: Brandeis University  
Abstract: Programs compiled by Gambit, our Scheme compiler, achieve performance as much as twice that of the fastest available Scheme compilers. Gambit is easily ported, while retaining its high performance, through the use of a simple virtual machine (PVM). PVM allows a wide variety of machine-independent optimizations and it supports parallel computation based on the future construct. PVM conveys high-level information bidirectionally between the machine-independent front end of the compiler and the machine-dependent back end, making it easy to implement a number of common back end optimizations that are difficult to achieve for other virtual machines. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Harold Abelson, Gerald Jay Sussman, and Julie Suss-man. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: We are familiar with three intermediate languages designed specifically for this purpose, however: MIT's RTL (register transfer language), LeLisp's LLM3 [5], and PSL's c-macros [7]. MIT's RTL is an ad hoc language evolved from the machine description language in <ref> [1] </ref>, through a version used in an early compiler [17], and now part of the Liar compiler.
Reference: [2] <author> Joel Bartlett. </author> <title> Scheme-&gt;C a portable Scheme-to-C compiler. </title> <type> Technical Report 89/1, </type> <institution> Digital Equipment Corp. Western Research Lab., </institution> <year> 1989. </year>
Reference-contexts: This implementation also includes an option for efficiently gathering dynamic usage statistics, as discussed in Appendix B. In addition, we have a preliminary version of a Scheme to C compiler, inspired by the work of Bartlett <ref> [2] </ref>. This back end generates portable C code with good performance characteristics, but is not yet capable of producing separately compilable modules.
Reference: [3] <author> John Batali, Edmund Goodhue, Chris Hanson, Howie Shrobe, Richard M. Stallman, and Gerald Jay Suss-man. </author> <title> The Scheme-81 architecture system and chip. </title> <editor> In Paul Penfield Jr., editor, </editor> <booktitle> Proc. of the MIT Conference on Advanced Research in VLSI, </booktitle> <address> Dedham, Mass., 1982. </address> <publisher> Artech House. </publisher>
Reference-contexts: On the one hand, there are virtual machines (like MIT's scode <ref> [3] </ref>, or the code objects of UMB Scheme [4]) that are so close to the source language that the machine independent front end of the compiler is unable to express important optimizations in the virtual machine's instruction set.
Reference: [4] <author> William Campbell. </author> <title> A C interpreter for Scheme | an exercise in object-oriented design. </title> <journal> Submitted to the Software Engineering journal of the British Computer Society, </journal> <year> 1989. </year>
Reference-contexts: On the one hand, there are virtual machines (like MIT's scode [3], or the code objects of UMB Scheme <ref> [4] </ref>) that are so close to the source language that the machine independent front end of the compiler is unable to express important optimizations in the virtual machine's instruction set. <p> This approach is taken in MIT's CScheme scode [12] (derived from the actual instruction set of the Scheme '79 VLSI chip [10]) and the University Mas-sachusetts Boston UMB Scheme system <ref> [4] </ref>. The type code of each node in the tree is derived from the syntactic expression (special form or combination) it represents in the program. The leaves of the tree are constants and variable references.
Reference: [5] <author> Jerome Chailloux. </author> <title> La machine LLM3. </title> <institution> Rapport interne du projet vlsi, INRIA, </institution> <month> May </month> <year> 1984. </year> <note> Corresponds to LeLisp version 15. </note>
Reference-contexts: We are familiar with three intermediate languages designed specifically for this purpose, however: MIT's RTL (register transfer language), LeLisp's LLM3 <ref> [5] </ref>, and PSL's c-macros [7]. MIT's RTL is an ad hoc language evolved from the machine description language in [1], through a version used in an early compiler [17], and now part of the Liar compiler.
Reference: [6] <author> Richard P. Gabriel. </author> <title> Performance and Evaluation of LISP Systems. </title> <booktitle> Research Reports and Notes, Computer Systems Series. </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1985. </year>
Reference: [7] <author> Martin L. Griss and Anthony C. Hearn. </author> <title> A portable LISP compiler. </title> <journal> Software Practice and Experience, </journal> <volume> 11 </volume> <pages> 541-605, </pages> <year> 1981. </year>
Reference-contexts: We are familiar with three intermediate languages designed specifically for this purpose, however: MIT's RTL (register transfer language), LeLisp's LLM3 [5], and PSL's c-macros <ref> [7] </ref>. MIT's RTL is an ad hoc language evolved from the machine description language in [1], through a version used in an early compiler [17], and now part of the Liar compiler.
Reference: [8] <author> R. Halstead. </author> <title> Multilisp: A language for concurrent symbolic computation. </title> <journal> In ACM Trans. on Prog. Languages and Systems, </journal> <pages> pages 501-538, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: This places a major burden on the back end, which becomes responsible for analysis of the virtual machine code a task very nearly as difficult as the original compilation task. On the other hand, there are virtual machines (like Multilisp's mcode <ref> [8] </ref> or Scheme 311's byte code) that match neither the actual target machine nor the source language. The result is either a complex back end that again attempts to recover data and control flow information from the virtual machine, or a simple back end that produces poor code.
Reference: [9] <author> Robert H. Halstead, David A. Kranz, and Eric Mohr. Mul-T: </author> <title> A high-performance parallel Lisp. </title> <booktitle> In SIGPLAN 89 Symposium on Porgramming Language Design and Implementation, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: In this mechanism, a parent spawns a child task and uses a placeholder [14] to allow the parent task to refer to the value being computed by the child. In earlier systems supporting futures ([8], <ref> [9] </ref>, [13]) there is a major cost associated with spawning a task, arising from the need to create a separate thread of control and a placeholder at the time the child task is spawned. PVM has three additional instructions and one operand type to make future-based parallel computation efficient. <p> PVM has three additional instructions and one operand type to make future-based parallel computation efficient. Our model is inspired by conversations with Halstead based on a brief mention in <ref> [9] </ref>. LABEL (t, size, TASK, w) Define a task label, t that marks the beginning of a task. A task label can be used in place of a simple label.
Reference: [10] <author> Jack Holloway, Guy Lewis Steele Jr., Gerald Jay Suss-man, and Alan Bell. </author> <title> The Scheme-79 chip. </title> <type> Technical Report AI Memo 559, </type> <institution> Mass. Inst. of Technology, Artificial Intelligence Laboratory, </institution> <year> 1980. </year>
Reference-contexts: An appealing alternative is to represent a program as a syntax tree, whose components are very similar to the pairs and vectors of standard Scheme. This approach is taken in MIT's CScheme scode [12] (derived from the actual instruction set of the Scheme '79 VLSI chip <ref> [10] </ref>) and the University Mas-sachusetts Boston UMB Scheme system [4]. The type code of each node in the tree is derived from the syntactic expression (special form or combination) it represents in the program. The leaves of the tree are constants and variable references.
Reference: [11] <author> D. A. Kranz et al. </author> <title> Orbit: An optimizing compiler for Scheme. </title> <booktitle> In Symposium on Compiler Construction, </booktitle> <pages> pages 219-233. </pages> <booktitle> ACM SIGPLAN, </booktitle> <month> June </month> <year> 1986. </year>
Reference-contexts: Marc Feeley is on study leave from the Universite de Montreal. Architecture (HPPA), MIPS R2000, Motorola 88K, BBN Monarch). For our purposes it was important that retargetting the compiler be simple and yet still yield a high performance system. We rejected existing compiler-based Scheme systems (T with Orbit <ref> [11] </ref>, CScheme with Liar [12]) mainly because of the difficulty of retargetting and modifying the compilation strategy of these large systems. 2. High performance of output programs. We are not concerned with program development features.
Reference: [12] <institution> Mass. Inst. of Technology, </institution> <address> Cambridge, MA. </address> <note> MIT Scheme Reference, Scheme Release 7, </note> <year> 1988. </year>
Reference-contexts: Architecture (HPPA), MIPS R2000, Motorola 88K, BBN Monarch). For our purposes it was important that retargetting the compiler be simple and yet still yield a high performance system. We rejected existing compiler-based Scheme systems (T with Orbit [11], CScheme with Liar <ref> [12] </ref>) mainly because of the difficulty of retargetting and modifying the compilation strategy of these large systems. 2. High performance of output programs. We are not concerned with program development features. <p> An appealing alternative is to represent a program as a syntax tree, whose components are very similar to the pairs and vectors of standard Scheme. This approach is taken in MIT's CScheme scode <ref> [12] </ref> (derived from the actual instruction set of the Scheme '79 VLSI chip [10]) and the University Mas-sachusetts Boston UMB Scheme system [4]. The type code of each node in the tree is derived from the syntactic expression (special form or combination) it represents in the program.
Reference: [13] <author> James Miller. MultiScheme: </author> <title> A Parallel Processing System Based on MIT Scheme. </title> <type> PhD thesis, </type> <institution> Mass. Inst. of Technology, </institution> <month> August </month> <year> 1987. </year> <note> Available as MIT LCS/TR/402. </note>
Reference-contexts: In this mechanism, a parent spawns a child task and uses a placeholder [14] to allow the parent task to refer to the value being computed by the child. In earlier systems supporting futures ([8], [9], <ref> [13] </ref>) there is a major cost associated with spawning a task, arising from the need to create a separate thread of control and a placeholder at the time the child task is spawned. PVM has three additional instructions and one operand type to make future-based parallel computation efficient.
Reference: [14] <author> James Miller. </author> <title> Implementing a Scheme-based parallel processing system. </title> <journal> International Journal of Parallel Processing, </journal> <volume> 17(5), </volume> <month> October </month> <year> 1988. </year>
Reference-contexts: One of our major goals, however, is to efficiently support the future mechanism for parallel computing. In this mechanism, a parent spawns a child task and uses a placeholder <ref> [14] </ref> to allow the parent task to refer to the value being computed by the child.
Reference: [15] <author> James Miller and Christopher Hanson. </author> <title> IEEE Draft Standard for the Programming Language Scheme. </title> <publisher> IEEE. forthcoming. </publisher>
Reference: [16] <author> James Miller and Guillermo Rozas. </author> <title> Free variables and first-class environments. </title> <journal> Journal of Lisp and Symbolic Computation, </journal> <note> to appear. </note>
Reference: [17] <author> Guillermo Rozas. </author> <title> Liar, an Algol-like compiler for Scheme. </title> <type> Bachelor's thesis, </type> <institution> Mass. Inst. of Technology, </institution> <year> 1984. </year>
Reference-contexts: We are familiar with three intermediate languages designed specifically for this purpose, however: MIT's RTL (register transfer language), LeLisp's LLM3 [5], and PSL's c-macros [7]. MIT's RTL is an ad hoc language evolved from the machine description language in [1], through a version used in an early compiler <ref> [17] </ref>, and now part of the Liar compiler.
Reference: [18] <author> Guy Lewis Steele Jr. Rabbit: </author> <title> A compiler for Scheme. </title> <type> Master's thesis, </type> <institution> Mass. Inst. of Technology, </institution> <year> 1978. </year>
References-found: 18

