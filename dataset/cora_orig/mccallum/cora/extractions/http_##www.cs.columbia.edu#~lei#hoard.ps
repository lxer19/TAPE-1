URL: http://www.cs.columbia.edu/~lei/hoard.ps
Refering-URL: http://www.cs.columbia.edu/~lei/publications.html
Root-URL: http://www.cs.columbia.edu
Email: tait@watson.ibm.com  lei@cs.columbia.edu  sa@cs.brown.edu  hychang@watson.ibm.com  
Title: Intelligent File Hoarding for Mobile Computers  
Author: Carl Tait P. O. Box Hui Lei Swarup Acharya Henry Chang P. O. Box 
Address: Heights, NY 10598  New York, NY 10027  Providence, RI 02912  Heights, NY 10598  
Affiliation: IBM T. J. Watson Research Center  Yorktown  Computer Science Department Columbia University  Computer Science Department Brown University  IBM T. J. Watson Research Center  Yorktown  
Date: November 1995  
Note: Appears in 1 st ACM Conference on Mobile Computing and Networking (Mobicom '95), Berkeley, CA,  
Abstract: Mobile computing adds a new wrinkle to the age-old problem of caching. Today's wireless links are both slow and expensive, and are not always available to a user. Therefore, when a mobile user is disconnected, a cache miss means (at best) a substantial cost in time and money, or (at worst) a complete halt to work if critical information has not been cached. Existing solutions to this problem rely on some combination of explicit hoard profiles and spying on a user's file accesses. Neither of these approaches is ideal in terms of reliability or user-friendliness. Our solution might be called transparent analytical spying. Instead of simply recording a list of file accesses, we analyze program executions and tie them to specific files. By observing multiple executions of a program, we are able to build sets of files associated with each program, and can heuristically separate application files from user files. We can then present a high-level view to the user that is similar to loading a briefcase. We have an implementation of our hoarding tool running under OS/2. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Chang, F. Novak, C. Tait, and P. Hortensius. SFS: </author> <title> A Universal File System Cache for Disconnected FS Operations. </title> <booktitle> In Joint Conference on Information Sciences, </booktitle> <month> November </month> <year> 1994. </year>
Reference-contexts: This is also true in the case of internal functions: if a user enters type myfile 2 The hoarding code was originally built on top of the Shadow File System <ref> [1] </ref>, a prototype mobile file system developed at IBM Research. 3 fsctl is similar to UNIX ioctl. (where the given file is on a remote file server), all the trace will show is an isolated reference to myfile by an unidentified process.
Reference: [2] <author> R. G. Guy, J. S. Heidemann, W. Mak, T. W. Page Jr., G. J. Popek, and D. Rothmeier. </author> <title> Implementation of the Ficus Replicated File System. </title> <booktitle> In Proc. 1990 USENIX Summer Conf., </booktitle> <pages> pages 63-71, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: system installed as an IFS must implement a standard set of internal file system operation APIs. (This is similar to the vnode layer in UNIX.) The mobile file system underpinning our efforts is IBM's Mobile File Sync (MFS) [11], a caching IFS similar in spirit to Coda [9] and Ficus <ref> [2] </ref> 2 . MFS presents a single file system image regardless of whether the user is currently connected to the relevant file server. A conflict detection mechanism is provided to cope with the potential problems of optimistic replication.
Reference: [3] <author> J. S. Heidemann, T. W. Page, R. G. Guy, and G. J. Popek. </author> <title> Primarily Disconnected Operation: Experiences with Ficus. </title> <booktitle> In Proc. Second Workshop on the Management of Replicated Data, </booktitle> <pages> pages 2-5. </pages> <publisher> IEEE, </publisher> <month> November </month> <year> 1992. </year>
Reference-contexts: In fact, it could be argued that this characteristic is central to the whole notion of "mobile computing": clients can be viewed as primarily disconnected entities that periodically connect to and disconnect from servers at the clients' discretion <ref> [3] </ref>. This offbeat manifestation of the client-server model forces a rethinking of standard cache management policies. Even assuming the existence of an anytime, anywhere, on-demand wireless communication service, a cache miss while disconnected is an expensive proposition, due to the cost and inconvenience of re-establishing communications with the server.
Reference: [4] <author> L. B. Huston and P. Honeyman. </author> <title> Disconnected Operation for AFS. </title> <booktitle> In Proc. First USENIX Symposium on Mobile and Location-Independent Computing, </booktitle> <pages> pages 1-10, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: Do Nothing. In their implementation of disconnected AFS <ref> [4] </ref> and their extensions for partially connected operation [5], Huston and Honeyman have not provided any special mechanisms for hoarding. Prior to disconnection, the user simply "runs the applications she intends to use while traveling," thus filling the local disk cache appropriately.
Reference: [5] <author> L. B. Huston and P. Honeyman. </author> <title> Partially Connected Operation. </title> <booktitle> In Proc. Second USENIX Symposium on Mobile and Location-Independent Computing, </booktitle> <pages> pages 91-97, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Do Nothing. In their implementation of disconnected AFS [4] and their extensions for partially connected operation <ref> [5] </ref>, Huston and Honeyman have not provided any special mechanisms for hoarding. Prior to disconnection, the user simply "runs the applications she intends to use while traveling," thus filling the local disk cache appropriately.
Reference: [6] <author> J. J. Kistler and M. Satyanarayanan. </author> <title> Disconnected Operation in the Coda File System. </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> 10(1) </volume> <pages> 3-25, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: No single execution will reveal the full gamut of an application's file accesses. User-Provided Information. A user might specify precisely which files and directories should be hoarded in a hoard profile, as is done in Coda <ref> [6, 9] </ref>. This is a straightforward approach, but can be both burdensome and unreliable. The burden can be eased by distributing common hoard profiles to naive users, but creating an accurate hoard profile in the first place is not at all trivial.
Reference: [7] <author> G. H. Kuenning. </author> <title> The Design of the Seer Predictive Caching System. </title> <booktitle> In IEEE Workshop on Mobile Computing Systems and Applications, </booktitle> <month> Decem-ber </month> <year> 1994. </year>
Reference-contexts: Furthermore, traditional spying is not program-based; it simply produces a named collection of accessed files. Semantic Distance. Kuenning's Seer system <ref> [7] </ref> uses a method for transparent hoarding ("predictive caching") that is based on the notion of semantic distance between files. There are several ways such distance could be measured; Kuenning has chosen to analyze the sequence of file accesses (open and close operations).
Reference: [8] <author> H. Lei and D. Duchamp. </author> <title> Transparent File Prefetching. In preparation, </title> <institution> Columbia University, </institution> <year> 1995. </year>
Reference-contexts: It is not yet clear how effective this method will be. One known restriction is the inability to separate file accesses performed by concurrently executing processes. 2 Our Approach Our approach is based on two of the authors' previous work in file prefetching <ref> [13, 12, 8] </ref>. Both hoarding and prefetching involve anticipatory file fetches: bringing files from a remote server into a local cache before they are needed. The goals of these two techniques are quite different, however.
Reference: [9] <author> M. Satyanarayanan, J. J. Kistler, P. Kumar, M. E. Okasaki, E. H. Siegel, and D. C. Steere. </author> <note> Coda: </note>
Reference-contexts: No single execution will reveal the full gamut of an application's file accesses. User-Provided Information. A user might specify precisely which files and directories should be hoarded in a hoard profile, as is done in Coda <ref> [6, 9] </ref>. This is a straightforward approach, but can be both burdensome and unreliable. The burden can be eased by distributing common hoard profiles to naive users, but creating an accurate hoard profile in the first place is not at all trivial. <p> Any specific file system installed as an IFS must implement a standard set of internal file system operation APIs. (This is similar to the vnode layer in UNIX.) The mobile file system underpinning our efforts is IBM's Mobile File Sync (MFS) [11], a caching IFS similar in spirit to Coda <ref> [9] </ref> and Ficus [2] 2 . MFS presents a single file system image regardless of whether the user is currently connected to the relevant file server. A conflict detection mechanism is provided to cope with the potential problems of optimistic replication.
References-found: 9

