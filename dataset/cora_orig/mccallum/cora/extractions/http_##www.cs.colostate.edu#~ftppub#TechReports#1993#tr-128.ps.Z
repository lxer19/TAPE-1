URL: http://www.cs.colostate.edu/~ftppub/TechReports/1993/tr-128.ps.Z
Refering-URL: http://www.cs.colostate.edu/~ftppub/
Root-URL: 
Title: Efficient Declarative Programs: Experience in Implementing NAS Benchmark FT  
Affiliation: Department of Computer Science  Colorado State University  
Abstract: S. Sur and W. Bohm Technical Report CS-93-128 October 21, 1993 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Arvind, Nikhil R.S., and Pingali, K.K., </author> <title> "I-structures: </title> <journal> Data Structures for Parallel Computing" ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol 11, No 4, </volume> <month> October </month> <year> 1989, </year> <pages> pp 589-632. </pages>
Reference-contexts: This frees the programmer from this level of complexity in the design of parallel programs. The declarative programming language Id has a functional kernel. Arrays in this functional kernel are created using monolithic array constructors called array comprehensions. In <ref> [1] </ref>, Arvind and others argue, that these array comprehensions lack expressiveness, and that for certain problems a lower level of constructs manipulating the elements of I-structures is necessary. An I-structure is a single assignment array with element-level synchronization for reads and writes.
Reference: [2] <author> Barth, Paul S., R. S. Nikhil and Arvind, "M-structures: </author> <title> Extending a parallel, non-strict, functional language with state," </title> <booktitle> Proc. Functional Prog Languages and Comp Arch, </booktitle> <address> Cambridge, MA, </address> <month> Aug </month> <year> 1991. </year>
Reference-contexts: An I-structure is a single assignment array with element-level synchronization for reads and writes. Because of their single assignment nature, Id programs with I-structures are deterministic, even though pure functional referential transparency has been lost. In <ref> [2] </ref> it is shown that for certain problems I-structures are again not powerful enough and that the more expressive M-structures are needed. M-structures are also arrays with element-level synchronisation, but do not have the single assignment property anymore. <p> The I-structure implementation of this benchmark is the closest to the problem definition. Also almost nowhere were we forced to over-specify intermediate array details introduced by the purely functional style. This makes the I-structure approach more declarative than the purely functional approach <ref> [2] </ref>. Array elements are now defined in loop constructs and nothing prevents us from defining more than one element in one loop body, thus avoiding the sharing problem of array comprehensions. Also we can use loop carried dependencies to avoid the creation of unnecessary intermediate structures.
Reference: [3] <author> Hicks, James, D. Chiou, B. S. Ang and Arvind, </author> <title> "Performance studies of Id on the Monsoon dataflow system," </title> <journal> Journal of Parallel and Distributed Computing no. </journal> <volume> 18, </volume> <pages> pp 273-300, </pages> <year> 1993. </year>
Reference-contexts: We measure the space complexity of our programs by determining the maximal problem size that fits in our one node Monsoon machine <ref> [3] </ref>, which has a 4 Megaword data memory. The goal of this project is to run a 64 fi 64 fi 64 problem on a one node monsoon machine, where one 3-D object contains half a Megaword of point numbers.
Reference: [4] <author> Bohm, A. P. W. </author> <title> and Hiromoto R.E.,"Dataflow Time and Space Complexity of FFTs", </title> <journal> Journal of Parallel and Distributed Computing no. </journal> <volume> 18, </volume> <pages> pp , 1993. </pages>
Reference-contexts: It also makes resource management simpler as pointers and objects are not interchanged. We use iterative FFTs instead of recursive ones, because in the iterative codes all the intermediate arrays can be deallocated immediately after they are no longer required. Details about this can also be found in <ref> [4] </ref>. 3 Implementation 3.1 Data Representation The first choice for the data representation that comes to mind is a 3-D array of complex numbers represented by tuples of two real numbers. However, Id does not treat, for instance, a 1-D sub-array of such an array (e.g. <p> Moreover, deallocating an array of tuples can cause complications, if the array elements are sometimes copies (in which case only a new pointer is created) and sometimes new values (in which case a new tuple and a new pointer is created) <ref> [4] </ref>. We therefore opt for the simplest data representation possible: a linear array of 2n 1 n 2 n 3 floating point numbers.
Reference: [5] <author> Bailey, D., et. al., </author> <title> "The NAS Parallel Benchmarks", </title> <type> Report RNR-91-002 revision 2, </type> <institution> NASA Ames Research Center, </institution> <year> 1991. </year>
Reference-contexts: 1 Introduction In this paper we study the design of efficient declarative programs by implementing the NAS three dimensional FFT PDE benchmark FT <ref> [5] </ref> in Id [6]. This study is part of a larger project where we try to assess which declarative language features are of importance to write efficient scientific codes.
Reference: [6] <author> R.S. Nikhil, </author> <note> Id (version 90.0) Reference Manual. TR CSG Memo 284-1, MIT LCS 1990. 15 </note>
Reference-contexts: 1 Introduction In this paper we study the design of efficient declarative programs by implementing the NAS three dimensional FFT PDE benchmark FT [5] in Id <ref> [6] </ref>. This study is part of a larger project where we try to assess which declarative language features are of importance to write efficient scientific codes. A declarative programming language allows expressing what is to be done, without specifying too much of how it is to be done.
References-found: 6

