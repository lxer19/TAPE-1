URL: http://www.research.att.com/library/trs/TRs/97/97.8/97.8.1.body.ps
Refering-URL: http://www.research.att.com/library/trs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Phone: 2  
Title: Quantum Error Correction Via Codes Over GF (4)  
Author: A. R. Calderbank, E. M. Rains, P. W. Shor, and N. J. A. Sloane 
Date: July 26, 1996  
Address: Murray Hill, New Jersey 07974  Princeton, New Jersey 08540  
Affiliation: 1 AT&T Research,  Institute for Defense Analyses,  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. H. Bennett, G. Brassard, C. Crepeau, R. Jozsa, A. Peres and W. K. Wooters, </author> <title> "Tele-porting an unknown quantum state via dual classical and EPR channels," </title> <journal> Phys. Rev. Lett., </journal> <volume> 70, </volume> <pages> pp. </pages> <month> 1895-1898 </month> <year> (1993). </year>
Reference-contexts: At around the same time, Bennett et al. [2] discovered that two experimenters each holding one component of many noisy Einstein-Podolsky-Rosen (EPR) pairs could purify them, yielding fewer nearly perfect EPR pairs. The resulting pairs can then be used to teleport quantum information from one experimenter to the other <ref> [1] </ref>. These two discoveries turned out to be different ways of looking at the same phenomenon. A purification protocol that uses only one-way classical communication between the experimenters can be converted into a quantum-error-correcting code, and vice versa [3]. <p> Words of weight d in C ? beginning with 1 become words of weight d 1, so the minimal distance in general is reduced by 1. The proof of (e) is left to the reader. 2 To illustrate Part (a) of the theorem, from the <ref> [[5; 1; 3] </ref>] Hamming code (see Section 5) we obtain a degenerate [[6; 1; 3]] code. On the other hand exhaustive search (or integer programming, see Section 7) shows that no nondegenerate [[6; 1; 3]] exists. <p> The proof of (e) is left to the reader. 2 To illustrate Part (a) of the theorem, from the [[5; 1; 3]] Hamming code (see Section 5) we obtain a degenerate <ref> [[6; 1; 3] </ref>] code. On the other hand exhaustive search (or integer programming, see Section 7) shows that no nondegenerate [[6; 1; 3]] exists. This is the first occasion when a degenerate code exists but a nondegenerate one does not. A second [[6; 1; 3]] code, also degenerate not equivalent to <p> proof of (e) is left to the reader. 2 To illustrate Part (a) of the theorem, from the [[5; 1; 3]] Hamming code (see Section 5) we obtain a degenerate <ref> [[6; 1; 3] </ref>] code. On the other hand exhaustive search (or integer programming, see Section 7) shows that no nondegenerate [[6; 1; 3]] exists. This is the first occasion when a degenerate code exists but a nondegenerate one does not. A second [[6; 1; 3]] code, also degenerate not equivalent to the first, is generated by 000011, 011110, 0!!!!!, 101!!!, !0!!10. Up to equivalence, there are no other [[6; 1; 3]] <p> code (see Section 5) we obtain a degenerate <ref> [[6; 1; 3] </ref>] code. On the other hand exhaustive search (or integer programming, see Section 7) shows that no nondegenerate [[6; 1; 3]] exists. This is the first occasion when a degenerate code exists but a nondegenerate one does not. A second [[6; 1; 3]] code, also degenerate not equivalent to the first, is generated by 000011, 011110, 0!!!!!, 101!!!, !0!!10. Up to equivalence, there are no other [[6; 1; 3]] codes. <p> no nondegenerate <ref> [[6; 1; 3] </ref>] exists. This is the first occasion when a degenerate code exists but a nondegenerate one does not. A second [[6; 1; 3]] code, also degenerate not equivalent to the first, is generated by 000011, 011110, 0!!!!!, 101!!!, !0!!10. Up to equivalence, there are no other [[6; 1; 3]] codes. If we have additional information about C ? then there is a more powerful technique (than 10 that in Theorem 6 (d)) for shortening a code. Lemma 1. Let C be a linear self-orthogonal code over GF (4). <p> From Theorem 7 we may deduce the existence of <ref> [[9; 1; 3] </ref>], [[10; 2; 3]]; : : :; [[80; 72; 3]] codes (see the entries labeled S in the main table in Section 8). There is an analogue of Theorem 7 for additive codes, but the construction of the corresponding binary code is somewhat more complicated. <p> If (v) = 0, and uv 6= 0, wt (u) d 1 . 2 Different choices for may produce inequivalent codes. For example, if the second code is the <ref> [[1; 0; 1] </ref>] code corresponding to C 2 = D 2 = f0; 1g, the new code has parameters [[n 1 + 1; k 1 ; d 1 ]], as in Theorem 6 (a). Theorem 8 can be used to produce an analogue of concatenated codes in the quantum setting. <p> A particularly interesting example is obtained by concatenating the <ref> [[5; 1; 3] </ref>] Hamming code (see Section 5) with itself. We take Q 1 = Q 2 , and let the associated linear (5; 2 4 ) code have generator matrix 1 0 1 ! ! . <p> We take Q 1 = Q 2 , and let the associated linear (5; 2 4 ) code have generator matrix 1 0 1 ! ! . Then we obtain a <ref> [[25; 1; 9] </ref>] code for which the associated (25; 2 24 ) and (25; 2 26 ) linear codes have the generator matrices shown in Fig. 1. Although the Hamming code is nondegenerate, the concatenated code is not. linear code (all rows), corresponding to a [[25; 1; 9]] quantum code. 2 <p> Then we obtain a <ref> [[25; 1; 9] </ref>] code for which the associated (25; 2 24 ) and (25; 2 26 ) linear codes have the generator matrices shown in Fig. 1. Although the Hamming code is nondegenerate, the concatenated code is not. linear code (all rows), corresponding to a [[25; 1; 9]] quantum code. 2 6 6 6 6 6 6 6 6 6 6 6 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 ! ! 0 0 0 0 0 0 0 0 <p> The corresponding (n; 2 m+2 ) additive code C (say) has weight enumerator x n + (2 m+2 1)x n2 m (m even) or y 2 m We take C 2 and C 3 to be the additive codes corresponding to the <ref> [[5; 1; 3] </ref>] and [[8; 3; 3]] codes already mentioned. For m &gt; 3, let G m be as in Theorem 10, and let G 0 m be the subcode consisting of the weight 2 m codewords in G m . <p> We end this section by listing some trivial codes. An <ref> [[n; k; 1] </ref>] code exists for all 0 k n, n 1. An [[n; k; 2]] code exists provided 0 k n 2, if n 2 is even, or provided 0 k n 3 if n 3 is odd. 5. <p> These codes meet the sphere-packing bound (18) with equality. The smallest Hamming code, a <ref> [[5; 1; 3] </ref>] code, was independently discovered in the present context by [3] and [26]. See also [11]. Hamming codes correct single errors. In the classical theory the generalizations of Hamming codes that correct multiple errors are known as BCH codes [30]. A similar generalization yields multiple-error correcting quantum codes. <p> We handle (30) by running the problem twice, once for each choice of the right-hand side. For example, using Theorem 21 we find that there are no <ref> [[n; 1; 5] </ref>] codes of length n 10 for which C has A 1 = 0. From Theorem 6 we conclude that no [[n; 1; 5]] code of any type exists with n 10. On the other hand an [[11; 1; 5]] code does exist | see the following section. <p> For example, using Theorem 21 we find that there are no <ref> [[n; 1; 5] </ref>] codes of length n 10 for which C has A 1 = 0. From Theorem 6 we conclude that no [[n; 1; 5]] code of any type exists with n 10. On the other hand an [[11; 1; 5]] code does exist | see the following section. <p> From Theorem 6 we conclude that no [[n; 1; 5]] code of any type exists with n 10. On the other hand an <ref> [[11; 1; 5] </ref>] code does exist | see the following section. Additional constraints can be included in Theorem 21 to reflect special knowledge about particular codes, or to attempt to narrow the range of a particular A i . <p> Chapter 11 of [30]). Since the results are somewhat disappointing we simply state the answer and omit the rather lengthy proof. Theorem 23. A nondegenerate [[n; n 2d + 2; d]] code has parameters <ref> [[n; n; 1] </ref>] (n 1), [[n; n 2; 2]] (n even 2), [[5; 1; 3]] or [[6; 0; 4]]. Up to equivalence there is a unique code in each case. Even allowing k = n 2d + 1 does not appear to lead to any new codes. <p> Chapter 11 of [30]). Since the results are somewhat disappointing we simply state the answer and omit the rather lengthy proof. Theorem 23. A nondegenerate [[n; n 2d + 2; d]] code has parameters [[n; n; 1]] (n 1), [[n; n 2; 2]] (n even 2), <ref> [[5; 1; 3] </ref>] or [[6; 0; 4]]. Up to equivalence there is a unique code in each case. Even allowing k = n 2d + 1 does not appear to lead to any new codes. <p> Up to equivalence there is a unique code in each case. Even allowing k = n 2d + 1 does not appear to lead to any new codes. Further analysis shows that any nondegenerate [[n; n 2d + 1; d]] code has parameters <ref> [[n; n 1; 1] </ref>] (n 1), [[n; n 3; 2]] (n 3), [[5; 0; 3]] or [[8; 3; 3]]. 8. <p> Note in particular that, except in the k = 0 column, once a particular value of d has been achieved, the same value holds for all lower entries in the same column using Theorem 6 (a). a. Exact value found by exhaustive search. b. No <ref> [[6; 1; 3] </ref>] exists, by exhaustive search, hence no [[7; 0; 4]] exists. c. Special upper bounds given in Section 7. Most of the following lower bounds are specified by giving the associated (n; 2 nk ) additive code. A. <p> Aut (h 6 ) = 3:S 6 , of order 2160. B. A classical self-dual code over GF (4) | see [29], [14]. C. A cyclic code, see Table I. D. A <ref> [[25; 1; 9] </ref>] code obtained by concatenating the [[5; 1; 3]] Hamming code with itself (Fig. 1 of Section 4). E. The code p 12 given in Section 6. F. An [[8; 3; 3]] code, discovered independently in [11], [22] and [36]. <p> Aut (h 6 ) = 3:S 6 , of order 2160. B. A classical self-dual code over GF (4) | see [29], [14]. C. A cyclic code, see Table I. D. A [[25; 1; 9]] code obtained by concatenating the <ref> [[5; 1; 3] </ref>] Hamming code with itself (Fig. 1 of Section 4). E. The code p 12 given in Section 6. F. An [[8; 3; 3]] code, discovered independently in [11], [22] and [36].
Reference: [2] <author> C. H. Bennett, G. Brassard, S. Popescu, B. Schumacher, J. A. Smolin and W. K. Wooters, </author> <title> "Purification of noisy entanglement and faithful teleportation via noisy channels," </title> <journal> Phys. Rev. Lett., </journal> <volume> 76, </volume> <pages> pp. </pages> <month> 722-725 </month> <year> (1996). </year>
Reference-contexts: That quantum-error-correcting codes could indeed exist was recently shown by one of us [32]. At around the same time, Bennett et al. <ref> [2] </ref> discovered that two experimenters each holding one component of many noisy Einstein-Podolsky-Rosen (EPR) pairs could purify them, yielding fewer nearly perfect EPR pairs. The resulting pairs can then be used to teleport quantum information from one experimenter to the other [1]. <p> From Theorem 7 we may deduce the existence of [[9; 1; 3]], <ref> [[10; 2; 3] </ref>]; : : :; [[80; 72; 3]] codes (see the entries labeled S in the main table in Section 8). There is an analogue of Theorem 7 for additive codes, but the construction of the corresponding binary code is somewhat more complicated. <p> We end this section by listing some trivial codes. An [[n; k; 1]] code exists for all 0 k n, n 1. An <ref> [[n; k; 2] </ref>] code exists provided 0 k n 2, if n 2 is even, or provided 0 k n 3 if n 3 is odd. 5. <p> Chapter 11 of [30]). Since the results are somewhat disappointing we simply state the answer and omit the rather lengthy proof. Theorem 23. A nondegenerate [[n; n 2d + 2; d]] code has parameters [[n; n; 1]] (n 1), <ref> [[n; n 2; 2] </ref>] (n even 2), [[5; 1; 3]] or [[6; 0; 4]]. Up to equivalence there is a unique code in each case. Even allowing k = n 2d + 1 does not appear to lead to any new codes. <p> Up to equivalence there is a unique code in each case. Even allowing k = n 2d + 1 does not appear to lead to any new codes. Further analysis shows that any nondegenerate [[n; n 2d + 1; d]] code has parameters [[n; n 1; 1]] (n 1), <ref> [[n; n 3; 2] </ref>] (n 3), [[5; 0; 3]] or [[8; 3; 3]]. 8.
Reference: [3] <author> C. H. Bennett, D. DiVincenzo, J. A. Smolin and W. K. Wooters, </author> <title> "Mixed state entaan-glement and quantum error correction," </title> <journal> Phys. </journal> <note> Rev. A, submitted; also LANL e-print quant-ph/9604024. </note>
Reference-contexts: These two discoveries turned out to be different ways of looking at the same phenomenon. A purification protocol that uses only one-way classical communication between the experimenters can be converted into a quantum-error-correcting code, and vice versa <ref> [3] </ref>. After these discoveries, a number of improved quantum codes were soon found by various researchers. The setting in which quantum-error-correcting codes exist is the quantum state space of n qubits (quantum bits, or two-state quantum systems). <p> For the purposes of quantum error correction, we need consider only the three types of errors x , z and x z , since any error-correcting code which corrects t of these errors will be able to correct arbitrary errors in t qubits <ref> [3] </ref>, [20]. Our codes will thus be tailored for the error model in which each qubit undergoes independent errors, and the three errors x , z and x z are all equally likely. The results of [3], [20] show that any code which corrects these types of quantum errors will be <p> t of these errors will be able to correct arbitrary errors in t qubits <ref> [3] </ref>, [20]. Our codes will thus be tailored for the error model in which each qubit undergoes independent errors, and the three errors x , z and x z are all equally likely. The results of [3], [20] show that any code which corrects these types of quantum errors will be able to correct errors in arbitrary error models, assuming the errors are not correlated among large numbers of qubits and that the error rate is small. <p> Words of weight d in C ? beginning with 1 become words of weight d 1, so the minimal distance in general is reduced by 1. The proof of (e) is left to the reader. 2 To illustrate Part (a) of the theorem, from the <ref> [[5; 1; 3] </ref>] Hamming code (see Section 5) we obtain a degenerate [[6; 1; 3]] code. On the other hand exhaustive search (or integer programming, see Section 7) shows that no nondegenerate [[6; 1; 3]] exists. <p> The proof of (e) is left to the reader. 2 To illustrate Part (a) of the theorem, from the [[5; 1; 3]] Hamming code (see Section 5) we obtain a degenerate <ref> [[6; 1; 3] </ref>] code. On the other hand exhaustive search (or integer programming, see Section 7) shows that no nondegenerate [[6; 1; 3]] exists. This is the first occasion when a degenerate code exists but a nondegenerate one does not. A second [[6; 1; 3]] code, also degenerate not equivalent to <p> proof of (e) is left to the reader. 2 To illustrate Part (a) of the theorem, from the [[5; 1; 3]] Hamming code (see Section 5) we obtain a degenerate <ref> [[6; 1; 3] </ref>] code. On the other hand exhaustive search (or integer programming, see Section 7) shows that no nondegenerate [[6; 1; 3]] exists. This is the first occasion when a degenerate code exists but a nondegenerate one does not. A second [[6; 1; 3]] code, also degenerate not equivalent to the first, is generated by 000011, 011110, 0!!!!!, 101!!!, !0!!10. Up to equivalence, there are no other [[6; 1; 3]] <p> code (see Section 5) we obtain a degenerate <ref> [[6; 1; 3] </ref>] code. On the other hand exhaustive search (or integer programming, see Section 7) shows that no nondegenerate [[6; 1; 3]] exists. This is the first occasion when a degenerate code exists but a nondegenerate one does not. A second [[6; 1; 3]] code, also degenerate not equivalent to the first, is generated by 000011, 011110, 0!!!!!, 101!!!, !0!!10. Up to equivalence, there are no other [[6; 1; 3]] codes. <p> no nondegenerate <ref> [[6; 1; 3] </ref>] exists. This is the first occasion when a degenerate code exists but a nondegenerate one does not. A second [[6; 1; 3]] code, also degenerate not equivalent to the first, is generated by 000011, 011110, 0!!!!!, 101!!!, !0!!10. Up to equivalence, there are no other [[6; 1; 3]] codes. If we have additional information about C ? then there is a more powerful technique (than 10 that in Theorem 6 (d)) for shortening a code. Lemma 1. Let C be a linear self-orthogonal code over GF (4). <p> Proof. Let S be the support of such a word of weight m. Then S satisfies the conditions of the Lemma, and deleting these coordinates gives the desired code. 2 For example, consider the <ref> [[85; 77; 3] </ref>] Hamming code given in the following section. <p> From Theorem 7 we may deduce the existence of <ref> [[9; 1; 3] </ref>], [[10; 2; 3]]; : : :; [[80; 72; 3]] codes (see the entries labeled S in the main table in Section 8). There is an analogue of Theorem 7 for additive codes, but the construction of the corresponding binary code is somewhat more complicated. <p> From Theorem 7 we may deduce the existence of [[9; 1; 3]], <ref> [[10; 2; 3] </ref>]; : : :; [[80; 72; 3]] codes (see the entries labeled S in the main table in Section 8). There is an analogue of Theorem 7 for additive codes, but the construction of the corresponding binary code is somewhat more complicated. <p> From Theorem 7 we may deduce the existence of [[9; 1; 3]], [[10; 2; 3]]; : : :; <ref> [[80; 72; 3] </ref>] codes (see the entries labeled S in the main table in Section 8). There is an analogue of Theorem 7 for additive codes, but the construction of the corresponding binary code is somewhat more complicated. The direct sum construction used inTheorem 6 (a) can be generalized. <p> A particularly interesting example is obtained by concatenating the <ref> [[5; 1; 3] </ref>] Hamming code (see Section 5) with itself. We take Q 1 = Q 2 , and let the associated linear (5; 2 4 ) code have generator matrix 1 0 1 ! ! . <p> This yields a <ref> [[2 m ; 2 m m 2; 3] </ref>] quantum code. We omit the proof. The parameters of the first few examples are [[8; 3; 3]], [[16; 10; 3]], [[32; 25; 3]], the latter being Gottesman's code [22]. <p> This yields a [[2 m ; 2 m m 2; 3]] quantum code. We omit the proof. The parameters of the first few examples are <ref> [[8; 3; 3] </ref>], [[16; 10; 3]], [[32; 25; 3]], the latter being Gottesman's code [22]. G m has weight enumerator x 2 m y 3:2 m2 : The vectors of weight 2 m generate a subcode of dimension 2. The codes in Theorem 10 can be extended. Theorem 11. <p> This yields a [[2 m ; 2 m m 2; 3]] quantum code. We omit the proof. The parameters of the first few examples are [[8; 3; 3]], <ref> [[16; 10; 3] </ref>], [[32; 25; 3]], the latter being Gottesman's code [22]. G m has weight enumerator x 2 m y 3:2 m2 : The vectors of weight 2 m generate a subcode of dimension 2. The codes in Theorem 10 can be extended. Theorem 11. <p> This yields a [[2 m ; 2 m m 2; 3]] quantum code. We omit the proof. The parameters of the first few examples are [[8; 3; 3]], [[16; 10; 3]], <ref> [[32; 25; 3] </ref>], the latter being Gottesman's code [22]. G m has weight enumerator x 2 m y 3:2 m2 : The vectors of weight 2 m generate a subcode of dimension 2. The codes in Theorem 10 can be extended. Theorem 11. <p> G m has weight enumerator x 2 m y 3:2 m2 : The vectors of weight 2 m generate a subcode of dimension 2. The codes in Theorem 10 can be extended. Theorem 11. For m 2, there exists an <ref> [[n; n m 2; 3] </ref>] code, where n is m=2 X 2 2i (m even); (m1)=2 X 2 2i+1 (m odd) : Sketch of proof. <p> The corresponding (n; 2 m+2 ) additive code C (say) has weight enumerator x n + (2 m+2 1)x n2 m (m even) or y 2 m We take C 2 and C 3 to be the additive codes corresponding to the <ref> [[5; 1; 3] </ref>] and [[8; 3; 3]] codes already mentioned. For m &gt; 3, let G m be as in Theorem 10, and let G 0 m be the subcode consisting of the weight 2 m codewords in G m . <p> The corresponding (n; 2 m+2 ) additive code C (say) has weight enumerator x n + (2 m+2 1)x n2 m (m even) or y 2 m We take C 2 and C 3 to be the additive codes corresponding to the [[5; 1; 3]] and <ref> [[8; 3; 3] </ref>] codes already mentioned. For m &gt; 3, let G m be as in Theorem 10, and let G 0 m be the subcode consisting of the weight 2 m codewords in G m . <p> For even m we obtain the Hamming codes of Section 5 as well as nonlinear codes with the same parameters. For odd m we obtain <ref> [[8; 3; 3] </ref>], [[40; 33; 3]], [[168; 159; 3]], : : : codes. <p> For even m we obtain the Hamming codes of Section 5 as well as nonlinear codes with the same parameters. For odd m we obtain [[8; 3; 3]], <ref> [[40; 33; 3] </ref>], [[168; 159; 3]], : : : codes. A generator matrix for the (40; 2 7 ) additive code corresponding to a [[40; 33; 3]] code is shown in Fig. 2. 2 6 6 6 6 6 0 0 0 0 0 0 0 0 1 1 1 1 <p> For even m we obtain the Hamming codes of Section 5 as well as nonlinear codes with the same parameters. For odd m we obtain [[8; 3; 3]], [[40; 33; 3]], <ref> [[168; 159; 3] </ref>], : : : codes. <p> For odd m we obtain [[8; 3; 3]], <ref> [[40; 33; 3] </ref>], [[168; 159; 3]], : : : codes. A generator matrix for the (40; 2 7 ) additive code corresponding to a [[40; 33; 3]] code is shown in Fig. 2. 2 6 6 6 6 6 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 <p> Then C ? = fuju + v : u 2 C ? 1 ; v 2 C 2 g has minimal distance minf2d 1 ; ffig, by Theorem 33 of [30], Chapter 1. 2 For example, by combining the <ref> [[14; 8; 3] </ref>] and [[14; 0; 6]] codes shown in Table II of the next section we obtain a [[28; 8; 6]] code. Concerning the structure of additive but nonlinear codes, it is pointless to simply add one generator to a linear code. <p> Example. The classical Hamming code H over GF (4) has length n = (4 m 1)=3, contains 4 nm codewords and has minimal distance 3, for m 1 [30], [28]. The dual code C = H ? is a self-orthogonal linear code, and the corresponding quantum code has parameters <ref> [[n; n2m; 3] </ref>], where n = (4 m 1)=3. C and H are cyclic if m is even, constacyclic if m is odd. <p> These codes meet the sphere-packing bound (18) with equality. The smallest Hamming code, a <ref> [[5; 1; 3] </ref>] code, was independently discovered in the present context by [3] and [26]. See also [11]. Hamming codes correct single errors. In the classical theory the generalizations of Hamming codes that correct multiple errors are known as BCH codes [30]. A similar generalization yields multiple-error correcting quantum codes. <p> These codes meet the sphere-packing bound (18) with equality. The smallest Hamming code, a [[5; 1; 3]] code, was independently discovered in the present context by <ref> [3] </ref> and [26]. See also [11]. Hamming codes correct single errors. In the classical theory the generalizations of Hamming codes that correct multiple errors are known as BCH codes [30]. A similar generalization yields multiple-error correcting quantum codes. <p> In the special case when n = (4 m 1)=3, most of the q j have degree m, and we obtain a sequence of cyclic or constacyclic codes which provided m is at least 4, begins <ref> [[n; n 2m; 3] </ref>]; [[n; n 4m; 4]]; [[n; n 6m; 5]]; [[n; n 8m; 7]]; : : : : For example when m = 4 we obtain [[85; 77; 3]], [[85; 69; 4]], [[85; 61; 5]] and [[85; 53; 7]] codes. <p> j have degree m, and we obtain a sequence of cyclic or constacyclic codes which provided m is at least 4, begins [[n; n 2m; 3]]; [[n; n 4m; 4]]; [[n; n 6m; 5]]; [[n; n 8m; 7]]; : : : : For example when m = 4 we obtain <ref> [[85; 77; 3] </ref>], [[85; 69; 4]], [[85; 61; 5]] and [[85; 53; 7]] codes. We now discuss additive (but not necessarily linear) codes. Note that an additive consta-cyclic code (with = ! or !) is necessarily linear. <p> The resulting congruence implies A 5 1 (mod 2). In particular A 5 6= 0, and so d = 5. (ii) No <ref> [[18; 12; 3] </ref>] code exists. Consider the (18; 2 6 ) additive code C. Linear programming shows that C must contain a vector of weight 12, which without loss of generality we may take to be u 0 = 0 6 1 12 . <p> Adding these constraints to the refined weight enumerator again produces a problem with no feasible solution. (iii) Similar arguments eliminate the parameters [[15; 4; 5]], [[15; 7; 4]], [[16; 8; 4]], <ref> [[19; 3; 3] </ref>], [[22; 14; 4]] and [[25; 0; 10]]. In the remainder of this section we briefly discuss another version of the Singleton bound (cf. (19)): Theorem 22. If a nondegenerate [[n; k; d]] code exists then k n 2d + 2. Proof. <p> Chapter 11 of [30]). Since the results are somewhat disappointing we simply state the answer and omit the rather lengthy proof. Theorem 23. A nondegenerate [[n; n 2d + 2; d]] code has parameters [[n; n; 1]] (n 1), [[n; n 2; 2]] (n even 2), <ref> [[5; 1; 3] </ref>] or [[6; 0; 4]]. Up to equivalence there is a unique code in each case. Even allowing k = n 2d + 1 does not appear to lead to any new codes. <p> Even allowing k = n 2d + 1 does not appear to lead to any new codes. Further analysis shows that any nondegenerate [[n; n 2d + 1; d]] code has parameters [[n; n 1; 1]] (n 1), [[n; n 3; 2]] (n 3), <ref> [[5; 0; 3] </ref>] or [[8; 3; 3]]. 8. <p> Even allowing k = n 2d + 1 does not appear to lead to any new codes. Further analysis shows that any nondegenerate [[n; n 2d + 1; d]] code has parameters [[n; n 1; 1]] (n 1), [[n; n 3; 2]] (n 3), [[5; 0; 3]] or <ref> [[8; 3; 3] </ref>]. 8. A table of quantum-error-correcting codes Table III, obtained by combining the best upper and lower bounds given in the previous sections, shows our present state of knowledge about the highest minimal distance d in any [[n; k; d]] code of length n 30. <p> Note in particular that, except in the k = 0 column, once a particular value of d has been achieved, the same value holds for all lower entries in the same column using Theorem 6 (a). a. Exact value found by exhaustive search. b. No <ref> [[6; 1; 3] </ref>] exists, by exhaustive search, hence no [[7; 0; 4]] exists. c. Special upper bounds given in Section 7. Most of the following lower bounds are specified by giving the associated (n; 2 nk ) additive code. A. <p> Aut (h 6 ) = 3:S 6 , of order 2160. B. A classical self-dual code over GF (4) | see [29], [14]. C. A cyclic code, see Table I. D. A [[25; 1; 9]] code obtained by concatenating the <ref> [[5; 1; 3] </ref>] Hamming code with itself (Fig. 1 of Section 4). E. The code p 12 given in Section 6. F. An [[8; 3; 3]] code, discovered independently in [11], [22] and [36]. <p> C. A cyclic code, see Table I. D. A [[25; 1; 9]] code obtained by concatenating the [[5; 1; 3]] Hamming code with itself (Fig. 1 of Section 4). E. The code p 12 given in Section 6. F. An <ref> [[8; 3; 3] </ref>] code, discovered independently in [11], [22] and [36]. The (8; 2 5 ) additive code may be generated by vectors ((01!!!1!))0, 11111111, !!!!!!!! (where the double parentheses mean that all cyclic shifts of the enclosed string are to be used). <p> The weight distribution of C is A 0 = 1, A 12 = 204, A 16 = 51, and its automorphism group has order 48960. S. By shortening one of the following codes using Theorem 7 or its additive analogue: the <ref> [[21; 5; 3] </ref>] or [[85; 77; 3]] Hamming codes (see Section 5), the [[32; 25; 3]] Gottesman code (Theorem 10), the [[40; 30; 4]] code given in Table II or [[40; 33; 3]] code shown in Fig. 2. U. From the uju + v construction (see Theorem 12). V. <p> The weight distribution of C is A 0 = 1, A 12 = 204, A 16 = 51, and its automorphism group has order 48960. S. By shortening one of the following codes using Theorem 7 or its additive analogue: the [[21; 5; 3]] or <ref> [[85; 77; 3] </ref>] Hamming codes (see Section 5), the [[32; 25; 3]] Gottesman code (Theorem 10), the [[40; 30; 4]] code given in Table II or [[40; 33; 3]] code shown in Fig. 2. U. From the uju + v construction (see Theorem 12). V. <p> S. By shortening one of the following codes using Theorem 7 or its additive analogue: the [[21; 5; 3]] or [[85; 77; 3]] Hamming codes (see Section 5), the <ref> [[32; 25; 3] </ref>] Gottesman code (Theorem 10), the [[40; 30; 4]] code given in Table II or [[40; 33; 3]] code shown in Fig. 2. U. From the uju + v construction (see Theorem 12). V. <p> S. By shortening one of the following codes using Theorem 7 or its additive analogue: the [[21; 5; 3]] or [[85; 77; 3]] Hamming codes (see Section 5), the [[32; 25; 3]] Gottesman code (Theorem 10), the [[40; 30; 4]] code given in Table II or <ref> [[40; 33; 3] </ref>] code shown in Fig. 2. U. From the uju + v construction (see Theorem 12). V.
Reference: [4] <author> W. Bosma and J. Cannon, </author> <title> Handbook of Magma Functions, </title> <address> Sydney, </address> <month> May 22, </month> <year> 1995. </year>
Reference-contexts: Let denote the (n; 2 2n ) code containing 8 all vectors, and form fi (). Using a program such as MAGMA <ref> [4] </ref>, [5], [6] we compute the automorphism groups of the binary linear code fi (C) and fi (); their intersection is Aut (C). <p> In the special case when n = (4 m 1)=3, most of the q j have degree m, and we obtain a sequence of cyclic or constacyclic codes which provided m is at least 4, begins [[n; n 2m; 3]]; <ref> [[n; n 4m; 4] </ref>]; [[n; n 6m; 5]]; [[n; n 8m; 7]]; : : : : For example when m = 4 we obtain [[85; 77; 3]], [[85; 69; 4]], [[85; 61; 5]] and [[85; 53; 7]] codes. We now discuss additive (but not necessarily linear) codes. <p> m, and we obtain a sequence of cyclic or constacyclic codes which provided m is at least 4, begins [[n; n 2m; 3]]; [[n; n 4m; 4]]; [[n; n 6m; 5]]; [[n; n 8m; 7]]; : : : : For example when m = 4 we obtain [[85; 77; 3]], <ref> [[85; 69; 4] </ref>], [[85; 61; 5]] and [[85; 53; 7]] codes. We now discuss additive (but not necessarily linear) codes. Note that an additive consta-cyclic code (with = ! or !) is necessarily linear. <p> The last five examples in Table II were found by him. Double parentheses indicate the permutation to be applied. Table II: Linear quasicyclic codes. Parameters Generator [[14; 0; 6]] ((1000000)) ((!1!!00!)) <ref> [[15; 5; 4] </ref>] ((10000)) ((11!00)) ((11!!0)) [[20; 10; 4]] ((10000)) ((1!100)) ((1111!)) ((11!!!)) [[28; 14; 5]] ((!!!1000)) ((!0!1000)) ((1!!1!!0)) ((!!!!!000)) [[40; 30; 4]] ((001!!)) ((011!1)) ((0010!)) ((001!1)) (00101) ((1!1!!)) ((111!!)) ((01!1!)) 6. <p> The last five examples in Table II were found by him. Double parentheses indicate the permutation to be applied. Table II: Linear quasicyclic codes. Parameters Generator [[14; 0; 6]] ((1000000)) ((!1!!00!)) [[15; 5; 4]] ((10000)) ((11!00)) ((11!!0)) <ref> [[20; 10; 4] </ref>] ((10000)) ((1!100)) ((1111!)) ((11!!!)) [[28; 14; 5]] ((!!!1000)) ((!0!1000)) ((1!!1!!0)) ((!!!!!000)) [[40; 30; 4]] ((001!!)) ((011!1)) ((0010!)) ((001!1)) (00101) ((1!1!!)) ((111!!)) ((01!1!)) 6. Self-dual codes In this section we study [[n; 0; d]] quantum-error-correcting codes and their associated (n; 2 n ) self-dual codes C. <p> Double parentheses indicate the permutation to be applied. Table II: Linear quasicyclic codes. Parameters Generator [[14; 0; 6]] ((1000000)) ((!1!!00!)) [[15; 5; 4]] ((10000)) ((11!00)) ((11!!0)) [[20; 10; 4]] ((10000)) ((1!100)) ((1111!)) ((11!!!)) [[28; 14; 5]] ((!!!1000)) ((!0!1000)) ((1!!1!!0)) ((!!!!!000)) <ref> [[40; 30; 4] </ref>] ((001!!)) ((011!1)) ((0010!)) ((001!1)) (00101) ((1!1!!)) ((111!!)) ((01!1!)) 6. Self-dual codes In this section we study [[n; 0; d]] quantum-error-correcting codes and their associated (n; 2 n ) self-dual codes C. <p> Adding these constraints to the refined weight enumerator again produces a problem with no feasible solution. (iii) Similar arguments eliminate the parameters <ref> [[15; 4; 5] </ref>], [[15; 7; 4]], [[16; 8; 4]], [[19; 3; 3]], [[22; 14; 4]] and [[25; 0; 10]]. In the remainder of this section we briefly discuss another version of the Singleton bound (cf. (19)): Theorem 22. <p> Adding these constraints to the refined weight enumerator again produces a problem with no feasible solution. (iii) Similar arguments eliminate the parameters [[15; 4; 5]], <ref> [[15; 7; 4] </ref>], [[16; 8; 4]], [[19; 3; 3]], [[22; 14; 4]] and [[25; 0; 10]]. In the remainder of this section we briefly discuss another version of the Singleton bound (cf. (19)): Theorem 22. If a nondegenerate [[n; k; d]] code exists then k n 2d + 2. Proof. <p> Adding these constraints to the refined weight enumerator again produces a problem with no feasible solution. (iii) Similar arguments eliminate the parameters [[15; 4; 5]], [[15; 7; 4]], <ref> [[16; 8; 4] </ref>], [[19; 3; 3]], [[22; 14; 4]] and [[25; 0; 10]]. In the remainder of this section we briefly discuss another version of the Singleton bound (cf. (19)): Theorem 22. If a nondegenerate [[n; k; d]] code exists then k n 2d + 2. Proof. <p> Adding these constraints to the refined weight enumerator again produces a problem with no feasible solution. (iii) Similar arguments eliminate the parameters [[15; 4; 5]], [[15; 7; 4]], [[16; 8; 4]], [[19; 3; 3]], <ref> [[22; 14; 4] </ref>] and [[25; 0; 10]]. In the remainder of this section we briefly discuss another version of the Singleton bound (cf. (19)): Theorem 22. If a nondegenerate [[n; k; d]] code exists then k n 2d + 2. Proof. <p> Since the results are somewhat disappointing we simply state the answer and omit the rather lengthy proof. Theorem 23. A nondegenerate [[n; n 2d + 2; d]] code has parameters [[n; n; 1]] (n 1), [[n; n 2; 2]] (n even 2), [[5; 1; 3]] or <ref> [[6; 0; 4] </ref>]. Up to equivalence there is a unique code in each case. Even allowing k = n 2d + 1 does not appear to lead to any new codes. <p> Exact value found by exhaustive search. b. No [[6; 1; 3]] exists, by exhaustive search, hence no <ref> [[7; 0; 4] </ref>] exists. c. Special upper bounds given in Section 7. Most of the following lower bounds are specified by giving the associated (n; 2 nk ) additive code. A. <p> Their automorphism groups have orders 720 and 8064, and both act tran sitively on the coordinates. J. A <ref> [[17; 9; 4] </ref>] code, for which the corresponding (17; 2 8 ) d = 12 code C is a well-known linear code, a two-weight code of class TF3 [9]. The columns of the generator matrix of C represent the 17 points of an ovoid in P G (3; 4). <p> S. By shortening one of the following codes using Theorem 7 or its additive analogue: the [[21; 5; 3]] or [[85; 77; 3]] Hamming codes (see Section 5), the [[32; 25; 3]] Gottesman code (Theorem 10), the <ref> [[40; 30; 4] </ref>] code given in Table II or [[40; 33; 3]] code shown in Fig. 2. U. From the uju + v construction (see Theorem 12). V.
Reference: [5] <author> W. Bosma, J. J Cannon and G. Mathews, </author> <title> Programming with algebraic structures: Design of the Magma language, </title> <editor> In: M. Giesbrecht (ed.), </editor> <booktitle> Proceedings of the 1994 International Symposium on Symbolic and Algebraic Computation, </booktitle> <address> Oxford, </address> <month> July 20-22, </month> <year> 1994. </year> <institution> Association for Computing Machinery, </institution> <year> 1994, </year> <pages> 52-57. </pages>
Reference-contexts: Let denote the (n; 2 2n ) code containing 8 all vectors, and form fi (). Using a program such as MAGMA [4], <ref> [5] </ref>, [6] we compute the automorphism groups of the binary linear code fi (C) and fi (); their intersection is Aut (C). <p> In the special case when n = (4 m 1)=3, most of the q j have degree m, and we obtain a sequence of cyclic or constacyclic codes which provided m is at least 4, begins [[n; n 2m; 3]]; [[n; n 4m; 4]]; <ref> [[n; n 6m; 5] </ref>]; [[n; n 8m; 7]]; : : : : For example when m = 4 we obtain [[85; 77; 3]], [[85; 69; 4]], [[85; 61; 5]] and [[85; 53; 7]] codes. We now discuss additive (but not necessarily linear) codes. <p> obtain a sequence of cyclic or constacyclic codes which provided m is at least 4, begins [[n; n 2m; 3]]; [[n; n 4m; 4]]; [[n; n 6m; 5]]; [[n; n 8m; 7]]; : : : : For example when m = 4 we obtain [[85; 77; 3]], [[85; 69; 4]], <ref> [[85; 61; 5] </ref>] and [[85; 53; 7]] codes. We now discuss additive (but not necessarily linear) codes. Note that an additive consta-cyclic code (with = ! or !) is necessarily linear. <p> The last five examples in Table II were found by him. Double parentheses indicate the permutation to be applied. Table II: Linear quasicyclic codes. Parameters Generator [[14; 0; 6]] ((1000000)) ((!1!!00!)) <ref> [[15; 5; 4] </ref>] ((10000)) ((11!00)) ((11!!0)) [[20; 10; 4]] ((10000)) ((1!100)) ((1111!)) ((11!!!)) [[28; 14; 5]] ((!!!1000)) ((!0!1000)) ((1!!1!!0)) ((!!!!!000)) [[40; 30; 4]] ((001!!)) ((011!1)) ((0010!)) ((001!1)) (00101) ((1!1!!)) ((111!!)) ((01!1!)) 6. <p> The last five examples in Table II were found by him. Double parentheses indicate the permutation to be applied. Table II: Linear quasicyclic codes. Parameters Generator [[14; 0; 6]] ((1000000)) ((!1!!00!)) [[15; 5; 4]] ((10000)) ((11!00)) ((11!!0)) [[20; 10; 4]] ((10000)) ((1!100)) ((1111!)) ((11!!!)) <ref> [[28; 14; 5] </ref>] ((!!!1000)) ((!0!1000)) ((1!!1!!0)) ((!!!!!000)) [[40; 30; 4]] ((001!!)) ((011!1)) ((0010!)) ((001!1)) (00101) ((1!1!!)) ((111!!)) ((01!1!)) 6. Self-dual codes In this section we study [[n; 0; d]] quantum-error-correcting codes and their associated (n; 2 n ) self-dual codes C. <p> We handle (30) by running the problem twice, once for each choice of the right-hand side. For example, using Theorem 21 we find that there are no <ref> [[n; 1; 5] </ref>] codes of length n 10 for which C has A 1 = 0. From Theorem 6 we conclude that no [[n; 1; 5]] code of any type exists with n 10. On the other hand an [[11; 1; 5]] code does exist | see the following section. <p> For example, using Theorem 21 we find that there are no <ref> [[n; 1; 5] </ref>] codes of length n 10 for which C has A 1 = 0. From Theorem 6 we conclude that no [[n; 1; 5]] code of any type exists with n 10. On the other hand an [[11; 1; 5]] code does exist | see the following section. <p> From Theorem 6 we conclude that no [[n; 1; 5]] code of any type exists with n 10. On the other hand an <ref> [[11; 1; 5] </ref>] code does exist | see the following section. Additional constraints can be included in Theorem 21 to reflect special knowledge about particular codes, or to attempt to narrow the range of a particular A i . <p> Adding these constraints to the refined weight enumerator again produces a problem with no feasible solution. (iii) Similar arguments eliminate the parameters <ref> [[15; 4; 5] </ref>], [[15; 7; 4]], [[16; 8; 4]], [[19; 3; 3]], [[22; 14; 4]] and [[25; 0; 10]]. In the remainder of this section we briefly discuss another version of the Singleton bound (cf. (19)): Theorem 22. <p> The weight distribution of C is A 0 = 1, A 12 = 204, A 16 = 51, and its automorphism group has order 48960. S. By shortening one of the following codes using Theorem 7 or its additive analogue: the <ref> [[21; 5; 3] </ref>] or [[85; 77; 3]] Hamming codes (see Section 5), the [[32; 25; 3]] Gottesman code (Theorem 10), the [[40; 30; 4]] code given in Table II or [[40; 33; 3]] code shown in Fig. 2. U. From the uju + v construction (see Theorem 12). V.
Reference: [6] <author> W. Bosma, J. Cannon and C. Playoust, </author> <title> The Magma algebra system I: The user language, </title> <journal> J. Symb. Comp., </journal> <note> to appear, </note> <year> 1996. </year>
Reference-contexts: Let denote the (n; 2 2n ) code containing 8 all vectors, and form fi (). Using a program such as MAGMA [4], [5], <ref> [6] </ref> we compute the automorphism groups of the binary linear code fi (C) and fi (); their intersection is Aut (C). <p> Then C ? = fuju + v : u 2 C ? 1 ; v 2 C 2 g has minimal distance minf2d 1 ; ffig, by Theorem 33 of [30], Chapter 1. 2 For example, by combining the [[14; 8; 3]] and <ref> [[14; 0; 6] </ref>] codes shown in Table II of the next section we obtain a [[28; 8; 6]] code. Concerning the structure of additive but nonlinear codes, it is pointless to simply add one generator to a linear code. <p> u 2 C ? 1 ; v 2 C 2 g has minimal distance minf2d 1 ; ffig, by Theorem 33 of [30], Chapter 1. 2 For example, by combining the [[14; 8; 3]] and [[14; 0; 6]] codes shown in Table II of the next section we obtain a <ref> [[28; 8; 6] </ref>] code. Concerning the structure of additive but nonlinear codes, it is pointless to simply add one generator to a linear code. <p> Then C 0 is a binary cyclic code of length 2n, which is self-orthogonal if and only if C is self-orthogonal. 17 Table I: Cyclic codes. Parameters Generators for additive code <ref> [[15; 0; 6] </ref>] ! 1 1 0 101 00101011 [[23; 0; 8]] ! 0 1 0 111 1000000001111010 [[25; 0; 8]] 1 1 1 0 10! 010111000000000000 We omit the proof. <p> T. A. Gulliver of Carleton University (Canada) and the University of Canterbury (New Zealand) has extensively studied quasicyclic codes over small fields [23]. The last five examples in Table II were found by him. Double parentheses indicate the permutation to be applied. Table II: Linear quasicyclic codes. Parameters Generator <ref> [[14; 0; 6] </ref>] ((1000000)) ((!1!!00!)) [[15; 5; 4]] ((10000)) ((11!00)) ((11!!0)) [[20; 10; 4]] ((10000)) ((1!100)) ((1111!)) ((11!!!)) [[28; 14; 5]] ((!!!1000)) ((!0!1000)) ((1!!1!!0)) ((!!!!!000)) [[40; 30; 4]] ((001!!)) ((011!1)) ((0010!)) ((001!1)) (00101) ((1!1!!)) ((111!!)) ((01!1!)) 6. <p> Additional constraints can be included in Theorem 21 to reflect special knowledge about particular codes, or to attempt to narrow the range of a particular A i . Many variations are the basic argument are possible, as illustrated in the following examples. (i) No <ref> [[13; 0; 6] </ref>] code exists. Let C be a (13; 2 13 ) additive code with d 5, and let C 0 be its even subcode. The linear constraints in Theorem 21 enable us to express all the unknowns in terms of A 5 and A 6 . <p> For example, classical linear [30; 18; 8] codes over GF (4) certainly exist. If such a code can be found which contains its dual, we would obtain a <ref> [[30; 6; 8] </ref>] quantum code. Acknowledgements We thank Aaron Gulliver for finding the quasi-cyclic codes mentioned in Section 5. 27 Table III: Highest achievable minimal distance d in any [[n; k; d]] quantum-error-correcting code.
Reference: [7] <author> A. E. Brouwer and N. J. A. Sloane, </author> <title> Tables of codes over GF (3) and GF (4), in Handbook of Coding Theory, </title> <editor> ed. V. Pless et al., in preparation, </editor> <year> 1996. </year>
Reference-contexts: In the special case when n = (4 m 1)=3, most of the q j have degree m, and we obtain a sequence of cyclic or constacyclic codes which provided m is at least 4, begins [[n; n 2m; 3]]; [[n; n 4m; 4]]; [[n; n 6m; 5]]; <ref> [[n; n 8m; 7] </ref>]; : : : : For example when m = 4 we obtain [[85; 77; 3]], [[85; 69; 4]], [[85; 61; 5]] and [[85; 53; 7]] codes. We now discuss additive (but not necessarily linear) codes. <p> cyclic or constacyclic codes which provided m is at least 4, begins [[n; n 2m; 3]]; [[n; n 4m; 4]]; [[n; n 6m; 5]]; [[n; n 8m; 7]]; : : : : For example when m = 4 we obtain [[85; 77; 3]], [[85; 69; 4]], [[85; 61; 5]] and <ref> [[85; 53; 7] </ref>] codes. We now discuss additive (but not necessarily linear) codes. Note that an additive consta-cyclic code (with = ! or !) is necessarily linear. <p> Adding these constraints to the refined weight enumerator again produces a problem with no feasible solution. (iii) Similar arguments eliminate the parameters [[15; 4; 5]], <ref> [[15; 7; 4] </ref>], [[16; 8; 4]], [[19; 3; 3]], [[22; 14; 4]] and [[25; 0; 10]]. In the remainder of this section we briefly discuss another version of the Singleton bound (cf. (19)): Theorem 22. If a nondegenerate [[n; k; d]] code exists then k n 2d + 2. Proof. <p> trivial automorphism group found by random search: 2 6 6 6 4 0 0! 1 0! 0!!! 1 1!!! 1 1 0! 0!! 0! 1! 1!!! 1!! 1 ! 0 0 1!!! 0! 0! 1 0 1 1!! 7 7 7 7 Comparison of the table with the existing tables <ref> [7] </ref> of classical codes over GF (4) reveals a number of entries where it may be possible to improve the lower bound by the use of linear codes. For example, classical linear [30; 18; 8] codes over GF (4) certainly exist.
Reference: [8] <author> A. R. Calderbank, P. J. Cameron, W. M. Kantor and J. J. Seidel, </author> <title> "Z 4 Kerdock codes, orthogonal spreads, and extremal Euclidean line-sets," </title> <journal> Proc. London Math. Soc. </journal> <note> (to appear). </note>
Reference-contexts: The normalizer L of E 0 in U (2 n ) acts on E 0 by conjugation, fixing the center ffi (E 0 ), so that there is a well-defined action of L on E that preserves the symplectic inner product (see <ref> [8] </ref> for details). The group-theoretic construction of quantum-error-correcting codes given in [11] starts by choosing a commutative subgroup S of E 0 that intersects the center ffi (E 0 ) in hIi. <p> For more details see Section 4 of <ref> [8] </ref>. <p> Then C ? = fuju + v : u 2 C ? 1 ; v 2 C 2 g has minimal distance minf2d 1 ; ffig, by Theorem 33 of [30], Chapter 1. 2 For example, by combining the <ref> [[14; 8; 3] </ref>] and [[14; 0; 6]] codes shown in Table II of the next section we obtain a [[28; 8; 6]] code. Concerning the structure of additive but nonlinear codes, it is pointless to simply add one generator to a linear code. <p> u 2 C ? 1 ; v 2 C 2 g has minimal distance minf2d 1 ; ffig, by Theorem 33 of [30], Chapter 1. 2 For example, by combining the [[14; 8; 3]] and [[14; 0; 6]] codes shown in Table II of the next section we obtain a <ref> [[28; 8; 6] </ref>] code. Concerning the structure of additive but nonlinear codes, it is pointless to simply add one generator to a linear code. <p> Then C 0 is a binary cyclic code of length 2n, which is self-orthogonal if and only if C is self-orthogonal. 17 Table I: Cyclic codes. Parameters Generators for additive code [[15; 0; 6]] ! 1 1 0 101 00101011 <ref> [[23; 0; 8] </ref>] ! 0 1 0 111 1000000001111010 [[25; 0; 8]] 1 1 1 0 10! 010111000000000000 We omit the proof. Note that C 0 determines C, since !Tr (!u) + !Tr (!u) = u : Theorem 15 makes it possible to search for codes of this type. <p> Then C 0 is a binary cyclic code of length 2n, which is self-orthogonal if and only if C is self-orthogonal. 17 Table I: Cyclic codes. Parameters Generators for additive code [[15; 0; 6]] ! 1 1 0 101 00101011 [[23; 0; 8]] ! 0 1 0 111 1000000001111010 <ref> [[25; 0; 8] </ref>] 1 1 1 0 10! 010111000000000000 We omit the proof. Note that C 0 determines C, since !Tr (!u) + !Tr (!u) = u : Theorem 15 makes it possible to search for codes of this type. So far no record codes have been found. <p> Adding these constraints to the refined weight enumerator again produces a problem with no feasible solution. (iii) Similar arguments eliminate the parameters [[15; 4; 5]], [[15; 7; 4]], <ref> [[16; 8; 4] </ref>], [[19; 3; 3]], [[22; 14; 4]] and [[25; 0; 10]]. In the remainder of this section we briefly discuss another version of the Singleton bound (cf. (19)): Theorem 22. If a nondegenerate [[n; k; d]] code exists then k n 2d + 2. Proof. <p> For example, classical linear <ref> [30; 18; 8] </ref> codes over GF (4) certainly exist. If such a code can be found which contains its dual, we would obtain a [[30; 6; 8]] quantum code. <p> For example, classical linear [30; 18; 8] codes over GF (4) certainly exist. If such a code can be found which contains its dual, we would obtain a <ref> [[30; 6; 8] </ref>] quantum code. Acknowledgements We thank Aaron Gulliver for finding the quasi-cyclic codes mentioned in Section 5. 27 Table III: Highest achievable minimal distance d in any [[n; k; d]] quantum-error-correcting code.
Reference: [9] <author> A. R. Calderbank and W. M. Kantor, </author> <title> "The geometry of two-weight codes," </title> <journal> Bull. London Math. Soc., </journal> <volume> 118, </volume> <pages> pp. </pages> <month> 97-122 </month> <year> (1986). </year>
Reference-contexts: We take Q 1 = Q 2 , and let the associated linear (5; 2 4 ) code have generator matrix 1 0 1 ! ! . Then we obtain a <ref> [[25; 1; 9] </ref>] code for which the associated (25; 2 24 ) and (25; 2 26 ) linear codes have the generator matrices shown in Fig. 1. Although the Hamming code is nondegenerate, the concatenated code is not. linear code (all rows), corresponding to a [[25; 1; 9]] quantum code. 2 <p> Then we obtain a <ref> [[25; 1; 9] </ref>] code for which the associated (25; 2 24 ) and (25; 2 26 ) linear codes have the generator matrices shown in Fig. 1. Although the Hamming code is nondegenerate, the concatenated code is not. linear code (all rows), corresponding to a [[25; 1; 9]] quantum code. 2 6 6 6 6 6 6 6 6 6 6 6 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 ! ! 0 0 0 0 0 0 0 0 <p> Aut (h 6 ) = 3:S 6 , of order 2160. B. A classical self-dual code over GF (4) | see [29], [14]. C. A cyclic code, see Table I. D. A <ref> [[25; 1; 9] </ref>] code obtained by concatenating the [[5; 1; 3]] Hamming code with itself (Fig. 1 of Section 4). E. The code p 12 given in Section 6. F. An [[8; 3; 3]] code, discovered independently in [11], [22] and [36]. <p> Their automorphism groups have orders 720 and 8064, and both act tran sitively on the coordinates. J. A <ref> [[17; 9; 4] </ref>] code, for which the corresponding (17; 2 8 ) d = 12 code C is a well-known linear code, a two-weight code of class TF3 [9]. The columns of the generator matrix of C represent the 17 points of an ovoid in P G (3; 4). <p> Their automorphism groups have orders 720 and 8064, and both act tran sitively on the coordinates. J. A [[17; 9; 4]] code, for which the corresponding (17; 2 8 ) d = 12 code C is a well-known linear code, a two-weight code of class TF3 <ref> [9] </ref>. The columns of the generator matrix of C represent the 17 points of an ovoid in P G (3; 4). Both C and C ? are cyclic, a generator for C ? being 1!1!10 12 .
Reference: [10] <author> A. R. Calderbank, W.-C. W. Li and B. Poonen, </author> <title> "A 2-adic approach to the analysis of cyclic codes," </title> <type> preprint, </type> <year> 1995. </year>
Reference-contexts: This yields a [[2 m ; 2 m m 2; 3]] quantum code. We omit the proof. The parameters of the first few examples are [[8; 3; 3]], <ref> [[16; 10; 3] </ref>], [[32; 25; 3]], the latter being Gottesman's code [22]. G m has weight enumerator x 2 m y 3:2 m2 : The vectors of weight 2 m generate a subcode of dimension 2. The codes in Theorem 10 can be extended. Theorem 11. <p> A linear cyclic or constacyclic code with generator polynomial g (x) is self-orthogonal if and only if g (x)g y (x) 0 (mod x n ) ; where if g (x) = P n1 g y (x) = g 0 + j=1 We omit the elementary proof (cf. <ref> [10] </ref>). <p> The last five examples in Table II were found by him. Double parentheses indicate the permutation to be applied. Table II: Linear quasicyclic codes. Parameters Generator [[14; 0; 6]] ((1000000)) ((!1!!00!)) [[15; 5; 4]] ((10000)) ((11!00)) ((11!!0)) <ref> [[20; 10; 4] </ref>] ((10000)) ((1!100)) ((1111!)) ((11!!!)) [[28; 14; 5]] ((!!!1000)) ((!0!1000)) ((1!!1!!0)) ((!!!!!000)) [[40; 30; 4]] ((001!!)) ((011!1)) ((0010!)) ((001!1)) (00101) ((1!1!!)) ((111!!)) ((01!1!)) 6. Self-dual codes In this section we study [[n; 0; d]] quantum-error-correcting codes and their associated (n; 2 n ) self-dual codes C. <p> Adding these constraints to the refined weight enumerator again produces a problem with no feasible solution. (iii) Similar arguments eliminate the parameters [[15; 4; 5]], [[15; 7; 4]], [[16; 8; 4]], [[19; 3; 3]], [[22; 14; 4]] and <ref> [[25; 0; 10] </ref>]. In the remainder of this section we briefly discuss another version of the Singleton bound (cf. (19)): Theorem 22. If a nondegenerate [[n; k; d]] code exists then k n 2d + 2. Proof.
Reference: [11] <author> A. R. Calderbank, E. M. Rains, P. W. Shor and N. J. A. Sloane, </author> <title> "Quantum error correc-tionand orthogonal geometry," </title> <journal> Phys. Rev. Lett., </journal> <note> submitted. 31 </note>
Reference-contexts: Investigation of the connection between this group and existing quantum codes led to a general construction for such codes which allowed us to generate many new examples. The initial results of this study were reported in <ref> [11] </ref>, and the work is continued in the present paper. The paper is arranged as follows. Section 2 transforms the problem into one of constructing a particular type of binary space (Theorem 1). <p> The group-theoretic construction of quantum-error-correcting codes given in <ref> [11] </ref> starts by choosing a commutative subgroup S of E 0 that intersects the center ffi (E 0 ) in hIi. <p> The distance between two elements (ajb), (a 0 jb 0 ) 2 E is defined to be the weight of their difference. Then we have the following theorem, which is an immediate consequence of Theorem 1 of <ref> [11] </ref>. Theorem 1. Suppose S is a k-dimensional linear subspace of E which is contained in its dual S (with respect to the inner product (2)), and is such that there are no vectors of weight d 1 in S n S. <p> These codes meet the sphere-packing bound (18) with equality. The smallest Hamming code, a [[5; 1; 3]] code, was independently discovered in the present context by [3] and [26]. See also <ref> [11] </ref>. Hamming codes correct single errors. In the classical theory the generalizations of Hamming codes that correct multiple errors are known as BCH codes [30]. A similar generalization yields multiple-error correcting quantum codes. <p> C. A cyclic code, see Table I. D. A [[25; 1; 9]] code obtained by concatenating the [[5; 1; 3]] Hamming code with itself (Fig. 1 of Section 4). E. The code p 12 given in Section 6. F. An [[8; 3; 3]] code, discovered independently in <ref> [11] </ref>, [22] and [36]. The (8; 2 5 ) additive code may be generated by vectors ((01!!!1!))0, 11111111, !!!!!!!! (where the double parentheses mean that all cyclic shifts of the enclosed string are to be used). Exhaustive search shows that this code is unique.
Reference: [12] <author> A. R. Calderbank and P. W. Shor, </author> <title> "Good quantum error-correcting codes exist," </title> <journal> Phys. </journal> <note> Rev. A, (to appear); also LANL e-print quant-ph/9512032. </note>
Reference-contexts: This group contains all the transformations necessary for encoding and decoding quantum codes. It is also the group generated by fault-tolerant bitwise operations performed on qubits that are encoded by certain quantum codes <ref> [12] </ref>, [33], [12], [35]. Investigation of the connection between this group and existing quantum codes led to a general construction for such codes which allowed us to generate many new examples. The initial results of this study were reported in [11], and the work is continued in the present paper. <p> This group contains all the transformations necessary for encoding and decoding quantum codes. It is also the group generated by fault-tolerant bitwise operations performed on qubits that are encoded by certain quantum codes <ref> [12] </ref>, [33], [12], [35]. Investigation of the connection between this group and existing quantum codes led to a general construction for such codes which allowed us to generate many new examples. The initial results of this study were reported in [11], and the work is continued in the present paper. <p> 0 0 0 0 0 0 0 1 ! ! 0 0 0 0 0 0 0 1 ! ! 0 0 ! 1 ! 0 0 ! ! 1 3 7 7 7 7 7 7 7 7 7 7 7 5 The construction of quantum codes used in <ref> [12] </ref> can be restated in the present terminology (and slightly generalized): Theorem 9. Let C 1 C 2 be binary linear codes. <p> The resulting congruence implies A 5 1 (mod 2). In particular A 5 6= 0, and so d = 5. (ii) No <ref> [[18; 12; 3] </ref>] code exists. Consider the (18; 2 6 ) additive code C. Linear programming shows that C must contain a vector of weight 12, which without loss of generality we may take to be u 0 = 0 6 1 12 .
Reference: [13] <author> B. W. Char et al., </author> <title> Maple V Library Reference Manual Springer-Verlag, </title> <address> NY, </address> <year> 1991. </year>
Reference-contexts: Unfortunately, for values of n around 30, the coefficients may grow too large for the problems to be handled using double precision arithmetic, and the results cannot be trusted. 1 (ii) Alternatively, using a symbolic manipulation program such as MAPLE <ref> [13] </ref>, we may ask directly if there is a feasible solution to (24)-(30). Since the calculations are performed in exact arithmetic, the answers are (presumably) completely reliable.
Reference: [14] <author> J. H. Conway, V. Pless, and N. J. A. Sloane, </author> <title> "Self-dual codes over GF (3) and GF (4) of length not exceeding 16," </title> <journal> IEEE Trans. Information Theory, </journal> <volume> 25, </volume> <pages> pp. </pages> <month> 312-322 </month> <year> (1979). </year>
Reference-contexts: The last five examples in Table II were found by him. Double parentheses indicate the permutation to be applied. Table II: Linear quasicyclic codes. Parameters Generator [[14; 0; 6]] ((1000000)) ((!1!!00!)) [[15; 5; 4]] ((10000)) ((11!00)) ((11!!0)) [[20; 10; 4]] ((10000)) ((1!100)) ((1111!)) ((11!!!)) <ref> [[28; 14; 5] </ref>] ((!!!1000)) ((!0!1000)) ((1!!1!!0)) ((!!!!!000)) [[40; 30; 4]] ((001!!)) ((011!1)) ((0010!)) ((001!1)) (00101) ((1!1!!)) ((111!!)) ((01!1!)) 6. Self-dual codes In this section we study [[n; 0; d]] quantum-error-correcting codes and their associated (n; 2 n ) self-dual codes C. <p> Proof. The proof of the Gleason-Prange theorem for classical self-dual codes as given in [34] applies unchanged. 2 It is possible to give a complete enumeration of all self-dual codes of modest length, following the methods of [29] and <ref> [14] </ref>. <p> If C is a self-orthogonal additive code generated by words of weight 2, then C is equivalent to a direct sum d i d j d k : : : . Proof. Analogous to that of Theorem 4 of <ref> [14] </ref>. 2 With the help of Theorems 19 and 20 we find that the numbers t n (respectively i n ) of inequivalent (respectively inequivalent indecomposable) self-dual codes of length n for n 5 are t n 1 2 3 6 11 This enumeration could be extended to larger values of <p> In all but one of those cases the code can be taken to be a classical self-dual linear code over GF (4). The exception is at length 12, where although no classical self-dual codes exists with minimal distance 6 <ref> [14] </ref>, there is an additive code. <p> Adding these constraints to the refined weight enumerator again produces a problem with no feasible solution. (iii) Similar arguments eliminate the parameters [[15; 4; 5]], [[15; 7; 4]], [[16; 8; 4]], [[19; 3; 3]], <ref> [[22; 14; 4] </ref>] and [[25; 0; 10]]. In the remainder of this section we briefly discuss another version of the Singleton bound (cf. (19)): Theorem 22. If a nondegenerate [[n; k; d]] code exists then k n 2d + 2. Proof. <p> Aut (h 6 ) = 3:S 6 , of order 2160. B. A classical self-dual code over GF (4) | see [29], <ref> [14] </ref>. C. A cyclic code, see Table I. D. A [[25; 1; 9]] code obtained by concatenating the [[5; 1; 3]] Hamming code with itself (Fig. 1 of Section 4). E. The code p 12 given in Section 6. F.
Reference: [15] <author> J. H. Conway and N. J. A. Sloane, </author> <title> Sphere Packings, Lattices and Groups, </title> <publisher> Springer-Verlag, NY, </publisher> <editor> 2nd. ed., </editor> <year> 1993. </year>
Reference-contexts: Most of the following lower bounds are specified by giving the associated (n; 2 nk ) additive code. A. The hexacode, a (6; 2 6 ) d = 4 classical code that can be taken to be the GF (4) span of h001111; 0101!!; 1001!!i (see Chapter 3 of <ref> [15] </ref>). Aut (h 6 ) = 3:S 6 , of order 2160. B. A classical self-dual code over GF (4) | see [29], [14]. C. A cyclic code, see Table I. D.
Reference: [16] <institution> CPLEX Manual, CPLEX Organization Inc., </institution> <address> Incline Village, Nevada, </address> <year> 1991. </year>
Reference-contexts: The other constraints are clear. 2 We have implemented Theorem 21 on the computer in two different ways. (i) We attempt to minimize A 1 + + A d1 subject to (24)-(30) using an optimization program such as CPLEX <ref> [16] </ref> or CONOPT [19]. The AMPL language [21] makes it easy to formulate such problems and to switch from one package to another.
Reference: [17] <author> P. Delsarte, </author> <title> "Bounds for unrestricted codes, by linear programming," </title> <journal> Philips Res. Reports, </journal> <volume> 27, </volume> <pages> pp. </pages> <month> 272-289 </month> <year> (1972). </year>
Reference-contexts: Proof. This result, analogous to the MacWilliams identity for linear codes, follows from the general theory of additive codes developed by Delsarte <ref> [17] </ref>, since our trace inner product is a special case of the symmetric inner products used in [17]. 2 9 4. General constructions In this section we describe some general methods for modifying and combining additive codes over GF (4). <p> Proof. This result, analogous to the MacWilliams identity for linear codes, follows from the general theory of additive codes developed by Delsarte <ref> [17] </ref>, since our trace inner product is a special case of the symmetric inner products used in [17]. 2 9 4. General constructions In this section we describe some general methods for modifying and combining additive codes over GF (4). The direct sum of two additive codes is defined in the natural way: C C 0 = fuv : u 2 C; v 2 C 0 g. <p> If a nondegenerate [[n; k; d]] code exists then k n 2d + 2. Proof. The associated code C ? is then an additive (n; 2 n+k ) code with minimal distance d. From Theorem 15 of <ref> [17] </ref>, we have 2 n+k 4 nd+1 ; which implies k n 2d + 2. 2 If d is odd this coincides with the Knill and Laflamme bound (19), but is slightly stronger if d is even.
Reference: [18] <author> D. Dieks, </author> <title> "Communication by EPR devices," </title> <journal> Phys. Lett. A, </journal> <volume> 92, </volume> <editor> p. </editor> <month> 271 </month> <year> (1982). </year>
Reference-contexts: While there are many similarities, there are also substantial differences between the two. Classical information cannot travel faster than light, while quantum information appears to in some circumstances. Classical information can be duplicated, while quantum information cannot <ref> [18] </ref>, [37]. It is well known that classical information can be protected from degradation by the use of classical error-correcting codes [30]. <p> For example, classical linear <ref> [30; 18; 8] </ref> codes over GF (4) certainly exist. If such a code can be found which contains its dual, we would obtain a [[30; 6; 8]] quantum code.
Reference: [19] <author> A. S. Drud, </author> <title> "CONOPT | A large scale GRG code," </title> <journal> ORSA J. Computing, </journal> <volume> 6, </volume> <pages> pp. </pages> <month> 207-218 </month> <year> (1994). </year>
Reference-contexts: The other constraints are clear. 2 We have implemented Theorem 21 on the computer in two different ways. (i) We attempt to minimize A 1 + + A d1 subject to (24)-(30) using an optimization program such as CPLEX [16] or CONOPT <ref> [19] </ref>. The AMPL language [21] makes it easy to formulate such problems and to switch from one package to another.
Reference: [20] <author> A. Ekert and C. Macchiavello, </author> <title> "Error correction in quantum communication," </title> <address> LANL e-print quant-ph/9602022. </address>
Reference-contexts: For the purposes of quantum error correction, we need consider only the three types of errors x , z and x z , since any error-correcting code which corrects t of these errors will be able to correct arbitrary errors in t qubits [3], <ref> [20] </ref>. Our codes will thus be tailored for the error model in which each qubit undergoes independent errors, and the three errors x , z and x z are all equally likely. The results of [3], [20] show that any code which corrects these types of quantum errors will be able <p> of these errors will be able to correct arbitrary errors in t qubits [3], <ref> [20] </ref>. Our codes will thus be tailored for the error model in which each qubit undergoes independent errors, and the three errors x , z and x z are all equally likely. The results of [3], [20] show that any code which corrects these types of quantum errors will be able to correct errors in arbitrary error models, assuming the errors are not correlated among large numbers of qubits and that the error rate is small.
Reference: [21] <author> R. Fourer, D. M. Gay and B. W. Kernighan, AMPL: </author> <title> A Modeling Language for Mathematical Programming, </title> <publisher> Scientific Press, </publisher> <address> San Francisco, </address> <year> 1993. </year>
Reference-contexts: The other constraints are clear. 2 We have implemented Theorem 21 on the computer in two different ways. (i) We attempt to minimize A 1 + + A d1 subject to (24)-(30) using an optimization program such as CPLEX [16] or CONOPT [19]. The AMPL language <ref> [21] </ref> makes it easy to formulate such problems and to switch from one package to another.
Reference: [22] <author> D. Gottesman, </author> <title> "A class of quantum error-correcting codes saturating the quantum Hamming bound," </title> <address> LANL e-print quant-ph/9604038. </address>
Reference-contexts: It is easily verified that C is additive and that C C ? = !C ? 1 + C 2 . 2 Another construction based on binary codes due to Gottesman <ref> [22] </ref> can be generalized as follows. Theorem 10. Let S m be the classical binary simplex code of length n = 2 m 1, dimension m and minimal distance 2 m1 (Chapter 14 of [30]). <p> This yields a [[2 m ; 2 m m 2; 3]] quantum code. We omit the proof. The parameters of the first few examples are [[8; 3; 3]], [[16; 10; 3]], [[32; 25; 3]], the latter being Gottesman's code <ref> [22] </ref>. G m has weight enumerator x 2 m y 3:2 m2 : The vectors of weight 2 m generate a subcode of dimension 2. The codes in Theorem 10 can be extended. Theorem 11. <p> Linear programming shows that if such a code exists then it must be even. However, all our attempts so far to construct this code have failed, so it may not exist. 7. Linear programming and other bounds Gottesman <ref> [22] </ref> showed that any nondegenerate [[n; k; 2t + 1]] code must satisfy the sphere packing bound t X 3 j n ! and that if t = 1 this bound applies to all (degenerate or nondegenerate) codes. <p> C. A cyclic code, see Table I. D. A [[25; 1; 9]] code obtained by concatenating the [[5; 1; 3]] Hamming code with itself (Fig. 1 of Section 4). E. The code p 12 given in Section 6. F. An [[8; 3; 3]] code, discovered independently in [11], <ref> [22] </ref> and [36]. The (8; 2 5 ) additive code may be generated by vectors ((01!!!1!))0, 11111111, !!!!!!!! (where the double parentheses mean that all cyclic shifts of the enclosed string are to be used). Exhaustive search shows that this code is unique. Another version is obtained from Theorem 10.
Reference: [23] <author> T. A. Gulliver and V. K. Bhargava, </author> <title> "Some best rate 1=p and rate (p 1)=p systematic quasi-cyclic codes over GF (3) and GF (4)," </title> <journal> IEEE Trans. Information Theory, </journal> <volume> 38, </volume> <pages> pp. </pages> <month> 1369-1374 </month> <year> (1992). </year>
Reference-contexts: A quasicyclic code is a code of length n = ab on which the group acts as a cycles of length b. T. A. Gulliver of Carleton University (Canada) and the University of Canterbury (New Zealand) has extensively studied quasicyclic codes over small fields <ref> [23] </ref>. The last five examples in Table II were found by him. Double parentheses indicate the permutation to be applied. Table II: Linear quasicyclic codes.
Reference: [24] <author> E. Knill and R. Laflamme, </author> <title> "A Theory of Quantum Error-Correcting Codes," </title> <address> LANL e-print quant-ph/9604034. </address>
Reference-contexts: Linear programming and other bounds Gottesman [22] showed that any nondegenerate [[n; k; 2t + 1]] code must satisfy the sphere packing bound t X 3 j n ! and that if t = 1 this bound applies to all (degenerate or nondegenerate) codes. Knill and Laflamme <ref> [24] </ref> have shown that any (degenerate or nondegenerate) code must satisfy the fol lowing version of the Singleton bound (cf. [30]): n 4e + k; (19) where e = b (d 1)=2c is the number of errors correctable by the code.
Reference: [25] <author> F. R. Kschischang and S. Pasupathy, </author> <title> "Some ternary and quaternary codes and associated sphere packings," </title> <journal> IEEE Trans. Information Theory, </journal> <volume> 38, </volume> <pages> pp. </pages> <month> 227-246 </month> <year> (1992). </year> <month> 32 </month>
Reference-contexts: This yields a [[2 m ; 2 m m 2; 3]] quantum code. We omit the proof. The parameters of the first few examples are [[8; 3; 3]], [[16; 10; 3]], <ref> [[32; 25; 3] </ref>], the latter being Gottesman's code [22]. G m has weight enumerator x 2 m y 3:2 m2 : The vectors of weight 2 m generate a subcode of dimension 2. The codes in Theorem 10 can be extended. Theorem 11. <p> We begin with linear codes. If vectors are represented by polynomials in the natural way, a linear constacyclic code is represented by an ideal in the ring of polynomials modulo x n ([30], <ref> [25] </ref>). The latter is a principal ideal ring, so the code consists simply of all multiples of a single generator polynomial g (x), which must divide x n . Theorem 13. <p> S. By shortening one of the following codes using Theorem 7 or its additive analogue: the [[21; 5; 3]] or [[85; 77; 3]] Hamming codes (see Section 5), the <ref> [[32; 25; 3] </ref>] Gottesman code (Theorem 10), the [[40; 30; 4]] code given in Table II or [[40; 33; 3]] code shown in Fig. 2. U. From the uju + v construction (see Theorem 12). V.
Reference: [26] <author> R. Laflamme, C. Miquel, J. P. Paz and W. H. Zurek, </author> <title> "Perfect quantum error correction codes," </title> <journal> Phys. Rev. Lett. </journal> <note> (to appear); also LANL e-print quant-ph/9602019. </note>
Reference-contexts: These codes meet the sphere-packing bound (18) with equality. The smallest Hamming code, a [[5; 1; 3]] code, was independently discovered in the present context by [3] and <ref> [26] </ref>. See also [11]. Hamming codes correct single errors. In the classical theory the generalizations of Hamming codes that correct multiple errors are known as BCH codes [30]. A similar generalization yields multiple-error correcting quantum codes.
Reference: [27] <author> C. W. H. Lam and V. Pless, </author> <title> "There is no (24; 12; 10) self-dual quaternary code," </title> <journal> IEEE Trans. Information Theory, </journal> <volume> 36, </volume> <pages> pp. </pages> <month> 1153-1156 </month> <year> (1990). </year>
Reference-contexts: There exists a (24; 2 24 ) d = 8 classical code over GF (2), the Golay code, and at least two (24; 3 12 ) d = 9 classical codes over GF (3), all meeting the analogous bounds to Theorem 17 (b) [30]. It is known <ref> [27] </ref> that there is no (24; 4 12 ) d = 10 classical code over GF (4), but the possibility of a (24; 2 24 ) d = 10 additive self-dual code remains open. Linear programming shows that if such a code exists then it must be even.
Reference: [28] <author> J. H. van Lint, </author> <title> Introduction to Coding Theory, </title> <publisher> Springer-Verlag, </publisher> <address> NY, </address> <year> 1982. </year>
Reference-contexts: Example. The classical Hamming code H over GF (4) has length n = (4 m 1)=3, contains 4 nm codewords and has minimal distance 3, for m 1 [30], <ref> [28] </ref>. The dual code C = H ? is a self-orthogonal linear code, and the corresponding quantum code has parameters [[n; n2m; 3]], where n = (4 m 1)=3. C and H are cyclic if m is even, constacyclic if m is odd.
Reference: [29] <author> F. J. MacWilliams, A. M. Odlyzko, N. J. A. Sloane, and H. N. Ward, </author> <title> "Self-dual codes over GF (4)," </title> <journal> J. Combinatorial Theory, Series A, </journal> <volume> 25, </volume> <pages> pp. </pages> <month> 288-318 </month> <year> (1978). </year>
Reference-contexts: Proof. (a) (17) follows from Theorem 5, and the proof of the second assertion is parallel to that of Theorem 13 of <ref> [29] </ref>. (b) Parallel to the proof of Corollary 3 of [31]. 2 Theorem 17. (a) The weight enumerator of an even self-dual code is a polynomial in x 2 +3y 2 and y 2 (x 2 y 2 ) 2 . (b) The minimal distance of an even self-dual code of <p> Proof. (a) This is an immediate consequence of Theorem 13 of <ref> [29] </ref>. (b) From Corollary 15 of [29]. 2 In view of the importance of doubly-even self-dual codes in binary coding theory, we also note the following result. Theorem 18. <p> Proof. (a) This is an immediate consequence of Theorem 13 of <ref> [29] </ref>. (b) From Corollary 15 of [29]. 2 In view of the importance of doubly-even self-dual codes in binary coding theory, we also note the following result. Theorem 18. <p> Proof. The proof of the Gleason-Prange theorem for classical self-dual codes as given in [34] applies unchanged. 2 It is possible to give a complete enumeration of all self-dual codes of modest length, following the methods of <ref> [29] </ref> and [14]. <p> Theorem 19. (a) The total number of self-dual codes of length n is Q n (b) jAut (C)j = j=1 (2 j + 1) ; where the sum is over all inequivalent self-dual codes C of length n. 19 Proof. (a) Parallel to that of Theorem 19 of <ref> [29] </ref>. (b) From (a) and (11). 2 Let d n be the (n; 2 n1 ) code spanned by all even-weight binary vectors of length n, and let d + Theorem 20. <p> Aut (h 6 ) = 3:S 6 , of order 2160. B. A classical self-dual code over GF (4) | see <ref> [29] </ref>, [14]. C. A cyclic code, see Table I. D. A [[25; 1; 9]] code obtained by concatenating the [[5; 1; 3]] Hamming code with itself (Fig. 1 of Section 4). E. The code p 12 given in Section 6. F.
Reference: [30] <author> F. J. MacWilliams and N. J. A. Sloane, </author> <title> The Theory of Error-Correcting Codes, </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1977. </year>
Reference-contexts: Classical information cannot travel faster than light, while quantum information appears to in some circumstances. Classical information can be duplicated, while quantum information cannot [18], [37]. It is well known that classical information can be protected from degradation by the use of classical error-correcting codes <ref> [30] </ref>. Classical error-correcting codes appear to protect classical information by duplicating it, so because of the theorem that a quantum bit cannot be cloned, it was widely believed that these techniques could not be applied to quantum information. <p> We will describe such a quantum-error-correcting code by saying it has parameters [[n; n k; d]]. All quantum-error-correcting codes known at the present time can be constructed in this way. 3. From binary spaces to codes over GF (4) As is customary (cf. <ref> [30] </ref>) we take the Galois field GF (4) to consist of the elements f0; 1; !; !g, with ! = ! 2 = ! + 1, ! 3 = 1; the trace map Tr : GF (4) ! Z 2 takes x 2 GF (4) to 6 x + x 2 <p> The polynomial W (x; y) = P n is the weight enumerator of C (cf. <ref> [30] </ref>). Theorem 5. If C is an (n; 2 k ) additive code with weight enumerator W (x; y), the weight enumerator of the dual code C ? is given by 2 k W (x + 3y; x y). Proof. <p> The resulting [[n + 1; k; d]] code is degenerate (which is why the construction fails for k = 0). (b) Puncture C ? (cf. <ref> [30] </ref>) by deleting the last coordinate, obtaining an (n 1; 2 n+k ) code B ? (say) with minimal distance at least d 1. <p> Theorem 10. Let S m be the classical binary simplex code of length n = 2 m 1, dimension m and minimal distance 2 m1 (Chapter 14 of <ref> [30] </ref>). <p> Then C ? = fuju + v : u 2 C ? 1 ; v 2 C 2 g has minimal distance minf2d 1 ; ffig, by Theorem 33 of <ref> [30] </ref>, Chapter 1. 2 For example, by combining the [[14; 8; 3]] and [[14; 0; 6]] codes shown in Table II of the next section we obtain a [[28; 8; 6]] code. <p> Example. The classical Hamming code H over GF (4) has length n = (4 m 1)=3, contains 4 nm codewords and has minimal distance 3, for m 1 <ref> [30] </ref>, [28]. The dual code C = H ? is a self-orthogonal linear code, and the corresponding quantum code has parameters [[n; n2m; 3]], where n = (4 m 1)=3. C and H are cyclic if m is even, constacyclic if m is odd. <p> The smallest Hamming code, a [[5; 1; 3]] code, was independently discovered in the present context by [3] and [26]. See also [11]. Hamming codes correct single errors. In the classical theory the generalizations of Hamming codes that correct multiple errors are known as BCH codes <ref> [30] </ref>. A similar generalization yields multiple-error correcting quantum codes. Rather than giving a complete analysis of these codes, which involves a number of messy details, we simply outline the construction and give some examples. These quantum BCH codes may be cyclic or constacyclic. <p> case we let ~ be a primitive n-th root of unity in some extension field of GF (4), and write each factor q j in (15) as q j (x) = Q s2S j (x ~ s ), the zero set S j begin a cyclotomic coset modulo n (see <ref> [30] </ref>, Chap. 7). The zero set associated with q y j is then 2S j . <p> Double parentheses indicate the permutation to be applied. Table II: Linear quasicyclic codes. Parameters Generator [[14; 0; 6]] ((1000000)) ((!1!!00!)) [[15; 5; 4]] ((10000)) ((11!00)) ((11!!0)) [[20; 10; 4]] ((10000)) ((1!100)) ((1111!)) ((11!!!)) [[28; 14; 5]] ((!!!1000)) ((!0!1000)) ((1!!1!!0)) ((!!!!!000)) <ref> [[40; 30; 4] </ref>] ((001!!)) ((011!1)) ((0010!)) ((001!1)) (00101) ((1!1!!)) ((111!!)) ((01!1!)) 6. Self-dual codes In this section we study [[n; 0; d]] quantum-error-correcting codes and their associated (n; 2 n ) self-dual codes C. <p> There exists a (24; 2 24 ) d = 8 classical code over GF (2), the Golay code, and at least two (24; 3 12 ) d = 9 classical codes over GF (3), all meeting the analogous bounds to Theorem 17 (b) <ref> [30] </ref>. It is known [27] that there is no (24; 4 12 ) d = 10 classical code over GF (4), but the possibility of a (24; 2 24 ) d = 10 additive self-dual code remains open. <p> Knill and Laflamme [24] have shown that any (degenerate or nondegenerate) code must satisfy the fol lowing version of the Singleton bound (cf. <ref> [30] </ref>): n 4e + k; (19) where e = b (d 1)=2c is the number of errors correctable by the code. To the best of our knowledge no other general bounds are known for degenerate codes. <p> The Krawtchouk polynomials appropriate for studying a code of length n over GF (4) will be denoted by P j (x; n) = s=0 s n x ! for j = 0; : : : ; n (see Chapter 6 of <ref> [30] </ref>). Theorem 21. <p> We have determined all codes that meet this bound | these are analogues of the classical MDS codes (cf. Chapter 11 of <ref> [30] </ref>). Since the results are somewhat disappointing we simply state the answer and omit the rather lengthy proof. Theorem 23. A nondegenerate [[n; n 2d + 2; d]] code has parameters [[n; n; 1]] (n 1), [[n; n 2; 2]] (n even 2), [[5; 1; 3]] or [[6; 0; 4]]. <p> S. By shortening one of the following codes using Theorem 7 or its additive analogue: the [[21; 5; 3]] or [[85; 77; 3]] Hamming codes (see Section 5), the [[32; 25; 3]] Gottesman code (Theorem 10), the <ref> [[40; 30; 4] </ref>] code given in Table II or [[40; 33; 3]] code shown in Fig. 2. U. From the uju + v construction (see Theorem 12). V. <p> For example, classical linear <ref> [30; 18; 8] </ref> codes over GF (4) certainly exist. If such a code can be found which contains its dual, we would obtain a [[30; 6; 8]] quantum code.
Reference: [31] <author> C. L. Mallows and N. J. A. Sloane, </author> <title> "An upper bound for self-dual codes," </title> <journal> Information and Control, </journal> <volume> 22, </volume> <pages> pp. </pages> <month> 188-200 </month> <year> (1973) </year>
Reference-contexts: Proof. (a) (17) follows from Theorem 5, and the proof of the second assertion is parallel to that of Theorem 13 of [29]. (b) Parallel to the proof of Corollary 3 of <ref> [31] </ref>. 2 Theorem 17. (a) The weight enumerator of an even self-dual code is a polynomial in x 2 +3y 2 and y 2 (x 2 y 2 ) 2 . (b) The minimal distance of an even self-dual code of length n is 2 [n=6]+2.
Reference: [32] <author> P. W. Shor, </author> <title> "Scheme for reducing decoherence in quantum memory," </title> <journal> Phys. Rev. A, </journal> <volume> 52, </volume> <editor> p. </editor> <month> 2493 </month> <year> (1995). </year>
Reference-contexts: That quantum-error-correcting codes could indeed exist was recently shown by one of us <ref> [32] </ref>. At around the same time, Bennett et al. [2] discovered that two experimenters each holding one component of many noisy Einstein-Podolsky-Rosen (EPR) pairs could purify them, yielding fewer nearly perfect EPR pairs.
Reference: [33] <author> P. Shor, </author> <title> "Fault-tolerant quantum computation," </title> <booktitle> Proc. 37th Sympos. Foundations of Computer Science, </booktitle> <year> 1996, </year> <note> to appear. </note>
Reference-contexts: This group contains all the transformations necessary for encoding and decoding quantum codes. It is also the group generated by fault-tolerant bitwise operations performed on qubits that are encoded by certain quantum codes [12], <ref> [33] </ref>, [12], [35]. Investigation of the connection between this group and existing quantum codes led to a general construction for such codes which allowed us to generate many new examples. The initial results of this study were reported in [11], and the work is continued in the present paper. <p> For even m we obtain the Hamming codes of Section 5 as well as nonlinear codes with the same parameters. For odd m we obtain [[8; 3; 3]], <ref> [[40; 33; 3] </ref>], [[168; 159; 3]], : : : codes. A generator matrix for the (40; 2 7 ) additive code corresponding to a [[40; 33; 3]] code is shown in Fig. 2. 2 6 6 6 6 6 0 0 0 0 0 0 0 0 1 1 1 1 <p> For odd m we obtain [[8; 3; 3]], <ref> [[40; 33; 3] </ref>], [[168; 159; 3]], : : : codes. A generator matrix for the (40; 2 7 ) additive code corresponding to a [[40; 33; 3]] code is shown in Fig. 2. 2 6 6 6 6 6 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 <p> S. By shortening one of the following codes using Theorem 7 or its additive analogue: the [[21; 5; 3]] or [[85; 77; 3]] Hamming codes (see Section 5), the [[32; 25; 3]] Gottesman code (Theorem 10), the [[40; 30; 4]] code given in Table II or <ref> [[40; 33; 3] </ref>] code shown in Fig. 2. U. From the uju + v construction (see Theorem 12). V.
Reference: [34] <author> N. J. A. Sloane, </author> <title> "Self-dual codes and lattices," in Relations Between Combinatorics and Other Parts of Mathematics, </title> <journal> Proc. Symp. Pure Math., </journal> <volume> Vol. 34, </volume> <publisher> American Mathematical Society, </publisher> <address> Providence, RI, </address> <year> 1979, </year> <pages> pp. 273-308. </pages>
Reference-contexts: Theorem 18. If there is an integer constant c &gt; 1 such that the weight of every vector in a self-dual code is divisible by c, then c = 2. Proof. The proof of the Gleason-Prange theorem for classical self-dual codes as given in <ref> [34] </ref> applies unchanged. 2 It is possible to give a complete enumeration of all self-dual codes of modest length, following the methods of [29] and [14].
Reference: [35] <author> A. M. Steane, </author> <title> "Multiple particle interference and quantum error correction," </title> <journal> Proc. Roy. Soc. London A, </journal> <note> submitted; LANL e-print quant-ph/9601029. </note>
Reference-contexts: This group contains all the transformations necessary for encoding and decoding quantum codes. It is also the group generated by fault-tolerant bitwise operations performed on qubits that are encoded by certain quantum codes [12], [33], [12], <ref> [35] </ref>. Investigation of the connection between this group and existing quantum codes led to a general construction for such codes which allowed us to generate many new examples. The initial results of this study were reported in [11], and the work is continued in the present paper.
Reference: [36] <author> A. M. Steane, </author> <title> "Simple quantum error correcting codes," </title> <type> preprint, </type> <year> 1996. </year>
Reference-contexts: A cyclic code, see Table I. D. A [[25; 1; 9]] code obtained by concatenating the [[5; 1; 3]] Hamming code with itself (Fig. 1 of Section 4). E. The code p 12 given in Section 6. F. An [[8; 3; 3]] code, discovered independently in [11], [22] and <ref> [36] </ref>. The (8; 2 5 ) additive code may be generated by vectors ((01!!!1!))0, 11111111, !!!!!!!! (where the double parentheses mean that all cyclic shifts of the enclosed string are to be used). Exhaustive search shows that this code is unique. Another version is obtained from Theorem 10.
Reference: [37] <author> W. K. Wooters and W. H. Zurek, </author> <title> "A single quantum cannot be cloned," </title> <journal> Nature, </journal> <volume> 299, </volume> <editor> p. </editor> <month> 802 </month> <year> (1982). </year>
Reference-contexts: While there are many similarities, there are also substantial differences between the two. Classical information cannot travel faster than light, while quantum information appears to in some circumstances. Classical information can be duplicated, while quantum information cannot [18], <ref> [37] </ref>. It is well known that classical information can be protected from degradation by the use of classical error-correcting codes [30].
References-found: 37

