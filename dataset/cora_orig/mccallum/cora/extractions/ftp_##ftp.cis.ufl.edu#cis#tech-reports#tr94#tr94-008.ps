URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr94/tr94-008.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr94-abstracts.html
Root-URL: http://www.cis.ufl.edu
Note: Contents  
Abstract-found: 0
Intro-found: 1
Reference: [ACL87] <author> Rakesh Agrawal, Michael J. Carey, and Miron Livny. </author> <title> Concurrency control performance modeling: Alternatives and implications. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 12(4) </volume> <pages> 609-654, </pages> <year> 1987. </year>
Reference-contexts: After completing deferred updates a transaction releases all its locks. The values of parameters used for this experiment are shown in Table 3. The values of cpu time and i/o time are chosen to balance the utilization of CPU and disk <ref> [ACL87, AGM92, TSG85] </ref>. With this parameter assignments the system is slightly I/O bound. <p> Thus the priority-based restarts of the active transactions that are blocked waiting for resources increases very rapidly. The increase in the restart ratio means that a longer fraction of disk time is spent doing work that will be redone later <ref> [ACL87] </ref>. Wasted resource time due to priority-based restart causes high resource utilization and easily makes bottleneck resource saturation that induces longer I/O wait time. With the longer I/O wait time more transactions are scheduled and that makes the I/O wait time longer and longer.
Reference: [AD85] <author> Rakesh Agrawal and D. DeWitt. </author> <title> Integrated concurrency control and recovery mechanism: Design and performance evaluation. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 10(4) </volume> <pages> 529-564, </pages> <year> 1985. </year>
Reference-contexts: However, if a transaction is aborted during its I/O access it is not deleted until it releases the disk. We used deferred update rather than immediate update for fast rollback <ref> [AD85] </ref>. Thus we assume that transaction rollback and restart do not require any disk access. After completing deferred updates a transaction releases all its locks. The values of parameters used for this experiment are shown in Table 3.
Reference: [AGM88a] <author> Robert Abbott and Hector Garcia-Molina. </author> <title> Scheduling real-time transactions. </title> <booktitle> SIGMOD RECORD, </booktitle> <volume> 17(1) </volume> <pages> 71-81, </pages> <year> 1988. </year>
Reference-contexts: Broadly, the approaches can be categorized into priority assignment (for real-time systems) and concurrency control (for real-time databases) based approaches. Concurrency control based real-time database (time-critical database) scheduling algorithms combine various properties of time-critical schedulers with properties of concurrency control algorithms <ref> [AGM88a, AGM92, BMH89, C + 89, HLC91, Sha88, SRSC91, SZ88, HSRT91] </ref>. Priority scheduling without knowing the data access pattern is presented as a representative of algorithms with incomplete knowledge of resource requirements. The scheduling policies presented in [AGM92, HSRT91, HLC91, SZ88] fall into this category. <p> In order to solve the problem of too many transaction aborts of EDF-HP, EDF-WP (EDF Wait Promote conflict resolution method [AGM89]) has been proposed. However, EDF-WP causes too much waiting due to its nonabortive conflict resolution method. Several hybrid methods that use combinations of abortive and nonabortive methods <ref> [AGM88a, SZ88] </ref> make decisions about transaction blocking and rollback using additional information, such as effective service time, slack time based on an estimated execution time. <p> We apply different scheduling disciplines to different resources as there effect on transaction execution is different. Data conflict If there is a data conflict between two transactions, a priority-based wound-wait strategy [BMH89] is the simplest to implement. The Conditional Restart algorithm with an estimated execution time <ref> [AGM88a] </ref> has been proposed to avoid needless aborts and rollback. The idea of HP [AGM88b, AGM89], which is the same as the priority-based wound wait strategy [BMH89], is to resolve a conflict in favor of the transaction with the higher priority. <p> Thus, fewer transactions are preempted and there are fewer opportunities for restarts <ref> [AGM88a] </ref>. In order to observe the correlation between the maximum capacity, arrival rate, and the behavior of the performance metrics, we performed an experiment by doubling the capacity.
Reference: [AGM88b] <author> Robert Abbott and Hector Garcia-Molina. </author> <title> Scheduling real-time transactions: a performance evaluation. </title> <booktitle> In Proceedings of the 14th VLDB, </booktitle> <pages> pages 1-12. </pages> <publisher> ACM, </publisher> <year> 1988. </year>
Reference-contexts: Section 5 describes the dynamic cost used in the scheduling policy and describes the scheduling algorithm that uses the dynamic priority assignment policy. Sections 6, through simulation, compares our approach to EDF-HP (EDF priority assignment policy with High Priority conflict resolution method <ref> [AGM88b] </ref>) and EDF-CR (EDF priority assignment policy with conditional restart) for main memory and disk resident database for both soft and firm cases. Section 7 contains conclusion and future research. 2 Previous work have been proposed in the literature. <p> Sometimes we would like to avoid aborting a transaction as we lose all the service time that it has received. The idea behind CR (conditional restart) conflict resolution method <ref> [AGM88b] </ref> is to estimate whether a transaction T H which is holding the lock requested by the transaction T R can be finished within the amount of time that T R can afford to wait. <p> The system might use different priority assignment policies for different resource types. Whenever a resource conflict occurs, a priority is used to resolve the conflict. In <ref> [AGM88b, SZ88] </ref> different priority assignment policies are used for CPU and data conflicts. However, the use of different priority assignment policies for different resource types might lead to more instances of priority reversal leading to deadlocks [BMH89]. <p> Data conflict If there is a data conflict between two transactions, a priority-based wound-wait strategy [BMH89] is the simplest to implement. The Conditional Restart algorithm with an estimated execution time [AGM88a] has been proposed to avoid needless aborts and rollback. The idea of HP <ref> [AGM88b, AGM89] </ref>, which is the same as the priority-based wound wait strategy [BMH89], is to resolve a conflict in favor of the transaction with the higher priority. In our approach, we apply HP conflict resolution method for data conflicts.
Reference: [AGM89] <author> Robert Abbott and Hector Garcia-Molina. </author> <title> Scheduling real-time transactions with disk resident data. </title> <booktitle> In Proceedings of the 15th VLDB, </booktitle> <pages> pages 385-396. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: Furthermore, the time spent on transaction aborts delays the start of other transactions. In order to solve the problem of too many transaction aborts of EDF-HP, EDF-WP (EDF Wait Promote conflict resolution method <ref> [AGM89] </ref>) has been proposed. However, EDF-WP causes too much waiting due to its nonabortive conflict resolution method. <p> In order to get better results one has to use the available knowledge appropriately. Below, we broadly classify the knowledge and the corresponding 2-phase locking based approaches that have been proposed: Type 0 No a priori knowledge. Only available timing information is deadline (EDF-HP <ref> [AGM89] </ref>). Type 1 Deadline and data access pattern are available (CCA [HJC93]). Type 2 Deadline and estimated execution time are available (EDF-CR, LSF-CR [AGM89]). Type 3 Data access pattern and static transaction priorities are available (Priority Ceiling [SRL90]). <p> Only available timing information is deadline (EDF-HP <ref> [AGM89] </ref>). Type 1 Deadline and data access pattern are available (CCA [HJC93]). Type 2 Deadline and estimated execution time are available (EDF-CR, LSF-CR [AGM89]). Type 3 Data access pattern and static transaction priorities are available (Priority Ceiling [SRL90]). EDF priority assignment policy minimizes the number of late transactions when the system is lightly loaded. The performance, however, quickly degrades in overloaded systems. <p> The performance, however, quickly degrades in overloaded systems. There have been several approaches to overcome this shortcoming and we can group them into two general approaches. 1. Use overload detection and management [HLC91]. 2. Delay the build up of overload <ref> [AGM89, HJC93] </ref>. Overload detection mechanisms for real-time tasks are quite easy because we assume that we know all required information such as arrival time, execution time, resource requirement and deadline [DLT85]. For database applications knowledge about transactions are usually not available or not correct due to database characteristics. <p> AED (Adaptive Earliest Deadline) [HLC91] priority assignment for firm deadline uses feedback mechanism that detects overload conditions and modifies transaction priority assignment policy accordingly. AED uses past history (that has been gathered dynamically) rather than a priori knowledge to detect overload. Another group of approaches <ref> [AGM89, HJC93] </ref> uses additional information to improve EDF-HP further. Even though these approaches do not have a specific overload management mechanism their methods improve the performance by delaying overload condition. The idea here is to save valuable system resources by not aborting partly executed conflicting transactions blindly. <p> Data conflict If there is a data conflict between two transactions, a priority-based wound-wait strategy [BMH89] is the simplest to implement. The Conditional Restart algorithm with an estimated execution time [AGM88a] has been proposed to avoid needless aborts and rollback. The idea of HP <ref> [AGM88b, AGM89] </ref>, which is the same as the priority-based wound wait strategy [BMH89], is to resolve a conflict in favor of the transaction with the higher priority. In our approach, we apply HP conflict resolution method for data conflicts. <p> I/O conflict If the real-time database contains disk resident data, a transaction might perform many I/O waits during its execution. Several real-time I/O scheduling methods have been proposed <ref> [AGM89, C + 89] </ref> in order to reduce I/O wait. In our approach we use FCFS I/O scheduling method. Disk I/O introduces new problems in real-time transaction scheduling. There are several choices when I/O wait occurs and we have considered the following 3 choices: 1.
Reference: [AGM92] <author> Robert Abbott and Hector Garcia-Molina. </author> <title> Scheduling real-time transaction: Performance evaluation. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 17(3) </volume> <pages> 513-560, </pages> <year> 1992. </year>
Reference-contexts: Broadly, the approaches can be categorized into priority assignment (for real-time systems) and concurrency control (for real-time databases) based approaches. Concurrency control based real-time database (time-critical database) scheduling algorithms combine various properties of time-critical schedulers with properties of concurrency control algorithms <ref> [AGM88a, AGM92, BMH89, C + 89, HLC91, Sha88, SRSC91, SZ88, HSRT91] </ref>. Priority scheduling without knowing the data access pattern is presented as a representative of algorithms with incomplete knowledge of resource requirements. The scheduling policies presented in [AGM92, HSRT91, HLC91, SZ88] fall into this category. <p> Priority scheduling without knowing the data access pattern is presented as a representative of algorithms with incomplete knowledge of resource requirements. The scheduling policies presented in <ref> [AGM92, HSRT91, HLC91, SZ88] </ref> fall into this category. These algorithms combine priority scheduling either with 2 phase locking or optimistic concurrency control (OCC) algorithms. <p> We can drop the transaction that already missed its deadline after its deadline (observant approach) or the transaction that will miss its deadline before its deadline (predictive approach) from the firm real-time systems <ref> [AGM92] </ref>. In this paper we only consider a observant approach that drops a transaction immediately when its deadline is reached. <p> Dropping transactions that cannot finish within their deadlines as early as possible improves the performance of firm real-time transaction systems, not only by not wasting system resources <ref> [AGM92] </ref> but also by reducing wasted restarts. 5.1.5 Properties of CCA CCA uses a dynamic priority assignment with continuous evaluation method in order to adapt to the changes of systems load effectively. However a dynamic priority assignment with continuous evaluation method might have two potential problems: deadlock and circular abort. <p> 1.32 4.28 7.72 14.22 20.09 Miss Percent (Class 0) 0.49 2.03 5.14 10.97 17.76 0.74 2.28 4.16 8.70 15.44 Class 2 / Class 0 5.3 3.36 2.24 1.67 1.40 1.78 1.87 1.85 1.63 1.3 26 that already consumed a lot of resource time. 6.1.3 Comparison with EDF-CR (soft deadline) EDF-CR <ref> [AGM92] </ref> uses estimated execution time as an additional information to improve EDF-HP. The most difficult part of EDF-CR is in computing good estimates of execution time of transactions as it is largely dependent on the system load. <p> After completing deferred updates a transaction releases all its locks. The values of parameters used for this experiment are shown in Table 3. The values of cpu time and i/o time are chosen to balance the utilization of CPU and disk <ref> [ACL87, AGM92, TSG85] </ref>. With this parameter assignments the system is slightly I/O bound.
Reference: [BHG87] <author> P.A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: OCC schemes display better performance for firm real-time transactions [HCL90a]. Lin and Son [LS90] have proposed a new concurrency control algorithm which is based on mixed integrated CC <ref> [BHG87] </ref> to adjust the serialization order dynamically. Priority scheduling with transaction pre-analysis is introduced as another approach with more knowledge of resource requirements [BMH89, Sha88, SRSC91].
Reference: [BMH89] <author> A. Buchmann, D.R. McCarthy, and M. Hsu. </author> <title> Time-critical database scheduling: A framework for integrating real-time scheduling and concurrency control. </title> <booktitle> In Proceedings of the Fifth Conference on Data Engineering, </booktitle> <pages> pages 470-480, </pages> <month> Feb </month> <year> 1989. </year>
Reference-contexts: Broadly, the approaches can be categorized into priority assignment (for real-time systems) and concurrency control (for real-time databases) based approaches. Concurrency control based real-time database (time-critical database) scheduling algorithms combine various properties of time-critical schedulers with properties of concurrency control algorithms <ref> [AGM88a, AGM92, BMH89, C + 89, HLC91, Sha88, SRSC91, SZ88, HSRT91] </ref>. Priority scheduling without knowing the data access pattern is presented as a representative of algorithms with incomplete knowledge of resource requirements. The scheduling policies presented in [AGM92, HSRT91, HLC91, SZ88] fall into this category. <p> Lin and Son [LS90] have proposed a new concurrency control algorithm which is based on mixed integrated CC [BHG87] to adjust the serialization order dynamically. Priority scheduling with transaction pre-analysis is introduced as another approach with more knowledge of resource requirements <ref> [BMH89, Sha88, SRSC91] </ref>. Conflict avoiding nonpreemptive method and Hybrid algorithms which use conflict avoiding scheme in the non-overload case and Conditional Restart conflict resolution method in the overload case have been proposed in [BMH89]. <p> Priority scheduling with transaction pre-analysis is introduced as another approach with more knowledge of resource requirements [BMH89, Sha88, SRSC91]. Conflict avoiding nonpreemptive method and Hybrid algorithms which use conflict avoiding scheme in the non-overload case and Conditional Restart conflict resolution method in the overload case have been proposed in <ref> [BMH89] </ref>. Static priority assignment based Priority Ceiling Protocol (PCP) using priority inheritance with exclusive lock and read/write PCP have been proposed in [Sha88, SRSC91]. 2.1 Discussion Some of the approaches such as EDF-HP and LSF-HP are straightforward combinations of earlier approaches. <p> In [AGM88b, SZ88] different priority assignment policies are used for CPU and data conflicts. However, the use of different priority assignment policies for different resource types might lead to more instances of priority reversal leading to deadlocks <ref> [BMH89] </ref>. <p> We apply different scheduling disciplines to different resources as there effect on transaction execution is different. Data conflict If there is a data conflict between two transactions, a priority-based wound-wait strategy <ref> [BMH89] </ref> is the simplest to implement. The Conditional Restart algorithm with an estimated execution time [AGM88a] has been proposed to avoid needless aborts and rollback. The idea of HP [AGM88b, AGM89], which is the same as the priority-based wound wait strategy [BMH89], is to resolve a conflict in favor of the <p> data conflict between two transactions, a priority-based wound-wait strategy <ref> [BMH89] </ref> is the simplest to implement. The Conditional Restart algorithm with an estimated execution time [AGM88a] has been proposed to avoid needless aborts and rollback. The idea of HP [AGM88b, AGM89], which is the same as the priority-based wound wait strategy [BMH89], is to resolve a conflict in favor of the transaction with the higher priority. In our approach, we apply HP conflict resolution method for data conflicts. CPU conflict Even in a single CPU system, there are many opportunities for CPU scheduling. <p> Although we discussed only lock-based protocols, the approach presented in this paper can be meaningful for optimistic [HCL90a] or even conflict avoiding approaches proposed in the literature <ref> [BMH89] </ref>. For optimistic approaches, decision to abort can be based on not only the priority information but also on the dynamic costs, such as how many restarts will occur and their effective service times.
Reference: [C + 89] <author> S. Chakravarthy et al. HiPAC: </author> <title> A Research Project in Active, Time-Constrained Database Management, </title> <type> Final Report. Technical Report XAIT-89-02, </type> <institution> Xerox Advanced Information Technology, </institution> <address> Cambridge, MA, </address> <month> Aug. </month> <year> 1989. </year> <month> 35 </month>
Reference-contexts: Broadly, the approaches can be categorized into priority assignment (for real-time systems) and concurrency control (for real-time databases) based approaches. Concurrency control based real-time database (time-critical database) scheduling algorithms combine various properties of time-critical schedulers with properties of concurrency control algorithms <ref> [AGM88a, AGM92, BMH89, C + 89, HLC91, Sha88, SRSC91, SZ88, HSRT91] </ref>. Priority scheduling without knowing the data access pattern is presented as a representative of algorithms with incomplete knowledge of resource requirements. The scheduling policies presented in [AGM92, HSRT91, HLC91, SZ88] fall into this category. <p> I/O conflict If the real-time database contains disk resident data, a transaction might perform many I/O waits during its execution. Several real-time I/O scheduling methods have been proposed <ref> [AGM89, C + 89] </ref> in order to reduce I/O wait. In our approach we use FCFS I/O scheduling method. Disk I/O introduces new problems in real-time transaction scheduling. There are several choices when I/O wait occurs and we have considered the following 3 choices: 1.
Reference: [DLT85] <author> Jensen E. Douglas, C. Douglass Locke, and Hideyuki Tokuda. </author> <title> A time-driven sched--uler for real-time operating systems. </title> <booktitle> In Proceedings of the IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 112-122. </pages> <publisher> IEEE, </publisher> <year> 1985. </year>
Reference-contexts: Use overload detection and management [HLC91]. 2. Delay the build up of overload [AGM89, HJC93]. Overload detection mechanisms for real-time tasks are quite easy because we assume that we know all required information such as arrival time, execution time, resource requirement and deadline <ref> [DLT85] </ref>. For database applications knowledge about transactions are usually not available or not correct due to database characteristics. AED (Adaptive Earliest Deadline) [HLC91] priority assignment for firm deadline uses feedback mechanism that detects overload conditions and modifies transaction priority assignment policy accordingly.
Reference: [FF91] <author> Borko Furht and Borivoje Furht. </author> <title> Real-time UNIX systems: design and application guide. </title> <publisher> Kluwer Academic, </publisher> <address> Boston, </address> <year> 1991. </year>
Reference-contexts: CPU conflict Even in a single CPU system, there are many opportunities for CPU scheduling. Whenever a new transaction arrives or a running transaction finishes, the scheduler is invoked. If the scheduler cannot be invoked for any reason (e.g., Real-time UNIX <ref> [FF91] </ref>), the highest priority transaction can be selected from among transactions that are in the ready queue or are currently running. When an executing transaction finishes, all transactions blocked by the resources that is held by the currently running transaction wake up and move to the ready queue.
Reference: [Fis92] <author> Paul A. Fishwick. </author> <title> SIMPACK:C-based Simulation Tool Package Version 2. </title> <institution> University of Florida, </institution> <year> 1992. </year>
Reference-contexts: Thus from Theorem 1, there is no priority reversal and an abort occurs between conflicting transactions only. 6 Performance Evaluation In order to evaluate the performance of the CCA algorithm described in this paper, two simulations of a real-time transaction scheduler were implemented using C language and SIMPACK simulation package <ref> [Fis92] </ref> for main memory resident databases and disk resident databases. The parameters used in the simulations are shown in Table 1.
Reference: [HCL90a] <author> Jayant R. Haritsa, Michael J. Carey, and Miron Livny. </author> <title> Dynamic real-time optimistic concurrency control. </title> <booktitle> In Proceedings of Real-Time System Symposium, </booktitle> <pages> pages 94-103. </pages> <publisher> IEEE, </publisher> <year> 1990. </year>
Reference-contexts: OCC schemes display better performance for firm real-time transactions <ref> [HCL90a] </ref>. Lin and Son [LS90] have proposed a new concurrency control algorithm which is based on mixed integrated CC [BHG87] to adjust the serialization order dynamically. Priority scheduling with transaction pre-analysis is introduced as another approach with more knowledge of resource requirements [BMH89, Sha88, SRSC91]. <p> Although we discussed only lock-based protocols, the approach presented in this paper can be meaningful for optimistic <ref> [HCL90a] </ref> or even conflict avoiding approaches proposed in the literature [BMH89]. For optimistic approaches, decision to abort can be based on not only the priority information but also on the dynamic costs, such as how many restarts will occur and their effective service times.
Reference: [HCL90b] <author> Jayant R. Haritsa, Michael J. Carey, and Miron Livny. </author> <title> On being optimistic about real-time constraints. </title> <booktitle> ACM PODS, </booktitle> <year> 1990. </year>
Reference-contexts: It is likely that the same behavior cannot be obtained for non-firm deadline transactions with the OCC and the simulation results in <ref> [HCL90b, HSRT91] </ref> show superiority of lock-based algorithms for soft deadlines.
Reference: [HJC93] <author> D. Hong, T. Johnson, and S. Chakravarthy. </author> <title> Real-time transaction scheduling: A cost-conscious approach. </title> <booktitle> In Proceedings of the 1993 ACM SIGMOD Int'l Conference on Management of Data, </booktitle> <pages> pages 197-206. </pages> <publisher> ACM, </publisher> <year> 1993. </year>
Reference-contexts: Below, we broadly classify the knowledge and the corresponding 2-phase locking based approaches that have been proposed: Type 0 No a priori knowledge. Only available timing information is deadline (EDF-HP [AGM89]). Type 1 Deadline and data access pattern are available (CCA <ref> [HJC93] </ref>). Type 2 Deadline and estimated execution time are available (EDF-CR, LSF-CR [AGM89]). Type 3 Data access pattern and static transaction priorities are available (Priority Ceiling [SRL90]). EDF priority assignment policy minimizes the number of late transactions when the system is lightly loaded. <p> The performance, however, quickly degrades in overloaded systems. There have been several approaches to overcome this shortcoming and we can group them into two general approaches. 1. Use overload detection and management [HLC91]. 2. Delay the build up of overload <ref> [AGM89, HJC93] </ref>. Overload detection mechanisms for real-time tasks are quite easy because we assume that we know all required information such as arrival time, execution time, resource requirement and deadline [DLT85]. For database applications knowledge about transactions are usually not available or not correct due to database characteristics. <p> AED (Adaptive Earliest Deadline) [HLC91] priority assignment for firm deadline uses feedback mechanism that detects overload conditions and modifies transaction priority assignment policy accordingly. AED uses past history (that has been gathered dynamically) rather than a priori knowledge to detect overload. Another group of approaches <ref> [AGM89, HJC93] </ref> uses additional information to improve EDF-HP further. Even though these approaches do not have a specific overload management mechanism their methods improve the performance by delaying overload condition. The idea here is to save valuable system resources by not aborting partly executed conflicting transactions blindly. <p> That is the reason why their experiment shows more discrimination against long running transactions. Also, the formula used for priority computation currently does not distinguish between transaction classes. This can be easily included in the formula that computes penalty of conflict. According to our previous experiments <ref> [HJC93] </ref>, CCA show much better performance especially when there are high variances of execution time among transactions by not aborting transactions 24 (a) Miss percent of EDF-HP,CCA (b) Restart rate (c) Mean Lateness 25 EDF-HP CCA Arrival Rate (trs/sec) 0.6 0.8 1.0 1.2 1.4 0.6 0.8 1.0 1.2 1.4 Miss Percent
Reference: [HLC91] <author> Jayant R. Haritsa, Miron Livny, and Michael J. Carey. </author> <title> Earliest deadline scheduling for real-time database systems. </title> <booktitle> In Proceedings of Real-Time System Symposium, </booktitle> <pages> pages 232-242. </pages> <publisher> IEEE, </publisher> <year> 1991. </year>
Reference-contexts: Broadly, the approaches can be categorized into priority assignment (for real-time systems) and concurrency control (for real-time databases) based approaches. Concurrency control based real-time database (time-critical database) scheduling algorithms combine various properties of time-critical schedulers with properties of concurrency control algorithms <ref> [AGM88a, AGM92, BMH89, C + 89, HLC91, Sha88, SRSC91, SZ88, HSRT91] </ref>. Priority scheduling without knowing the data access pattern is presented as a representative of algorithms with incomplete knowledge of resource requirements. The scheduling policies presented in [AGM92, HSRT91, HLC91, SZ88] fall into this category. <p> Priority scheduling without knowing the data access pattern is presented as a representative of algorithms with incomplete knowledge of resource requirements. The scheduling policies presented in <ref> [AGM92, HSRT91, HLC91, SZ88] </ref> fall into this category. These algorithms combine priority scheduling either with 2 phase locking or optimistic concurrency control (OCC) algorithms. <p> These algorithms combine priority scheduling either with 2 phase locking or optimistic concurrency control (OCC) algorithms. EDF-HP (Earliest Deadline First with High Priority), LSF-HP (Least Slack First with HP), EDF-WP (EDF with Wait Promote), EDF-CR (EDF with Conditional Restart), AEDF-HP (Adaptive EDF with HP) <ref> [HLC91] </ref>, Virtual Clock and Pairwise Value Function [SZ88] are combined with 2 phase locking. As a variation of single version 2 phase locking real-time multiversion CC (Concurrency Control) [KS91] has been introduced to increase concurrency by adjusting serialization order dynamically. <p> An OCC scheme with a deadline and transaction length based priority assignment scheme is presented in [HSRT91]. An OCC with adaptive EDF has also been proposed in <ref> [HLC91] </ref>. With OCC approach, a policy is needed to resolve the access conflicts during the validation phase. <p> Under high level of resource and data contention, EDF-HP causes more transactions to miss their deadlines since they receive high priority only when they are close to missing their deadline <ref> [HLC91] </ref>. Also, EDF-HP causes many transaction aborts. If a higher priority transaction always aborts lower priority transactions, the performance is primarily sensitive to data contention. Furthermore, the time spent on transaction aborts delays the start of other transactions. <p> EDF priority assignment policy minimizes the number of late transactions when the system is lightly loaded. The performance, however, quickly degrades in overloaded systems. There have been several approaches to overcome this shortcoming and we can group them into two general approaches. 1. Use overload detection and management <ref> [HLC91] </ref>. 2. Delay the build up of overload [AGM89, HJC93]. Overload detection mechanisms for real-time tasks are quite easy because we assume that we know all required information such as arrival time, execution time, resource requirement and deadline [DLT85]. <p> For database applications knowledge about transactions are usually not available or not correct due to database characteristics. AED (Adaptive Earliest Deadline) <ref> [HLC91] </ref> priority assignment for firm deadline uses feedback mechanism that detects overload conditions and modifies transaction priority assignment policy accordingly. AED uses past history (that has been gathered dynamically) rather than a priori knowledge to detect overload. Another group of approaches [AGM89, HJC93] uses additional information to improve EDF-HP further.
Reference: [HSRT91] <author> Jiandong Hyang, John A. Stankovic, Krithi Ramamritham, and Don Towsley. </author> <title> Experimental evaluation of real-time optimistic concurrency control schemes. </title> <booktitle> In Proceedings of the 17th VLDB, </booktitle> <pages> pages 35-46. </pages> <publisher> ACM, </publisher> <year> 1991. </year>
Reference-contexts: Broadly, the approaches can be categorized into priority assignment (for real-time systems) and concurrency control (for real-time databases) based approaches. Concurrency control based real-time database (time-critical database) scheduling algorithms combine various properties of time-critical schedulers with properties of concurrency control algorithms <ref> [AGM88a, AGM92, BMH89, C + 89, HLC91, Sha88, SRSC91, SZ88, HSRT91] </ref>. Priority scheduling without knowing the data access pattern is presented as a representative of algorithms with incomplete knowledge of resource requirements. The scheduling policies presented in [AGM92, HSRT91, HLC91, SZ88] fall into this category. <p> Priority scheduling without knowing the data access pattern is presented as a representative of algorithms with incomplete knowledge of resource requirements. The scheduling policies presented in <ref> [AGM92, HSRT91, HLC91, SZ88] </ref> fall into this category. These algorithms combine priority scheduling either with 2 phase locking or optimistic concurrency control (OCC) algorithms. <p> As a variation of single version 2 phase locking real-time multiversion CC (Concurrency Control) [KS91] has been introduced to increase concurrency by adjusting serialization order dynamically. An OCC scheme with a deadline and transaction length based priority assignment scheme is presented in <ref> [HSRT91] </ref>. An OCC with adaptive EDF has also been proposed in [HLC91]. With OCC approach, a policy is needed to resolve the access conflicts during the validation phase. <p> It is likely that the same behavior cannot be obtained for non-firm deadline transactions with the OCC and the simulation results in <ref> [HCL90b, HSRT91] </ref> show superiority of lock-based algorithms for soft deadlines.
Reference: [KS91] <author> Woosaeng Kim and Jaideep Srivastava. </author> <title> Enhancing real-time dbms performance with multiversion data and priority based disk scheduling. </title> <booktitle> In Proceedings of Real-Time Systems Symposium, </booktitle> <pages> pages 222-231. </pages> <publisher> IEEE, </publisher> <year> 1991. </year>
Reference-contexts: As a variation of single version 2 phase locking real-time multiversion CC (Concurrency Control) <ref> [KS91] </ref> has been introduced to increase concurrency by adjusting serialization order dynamically. An OCC scheme with a deadline and transaction length based priority assignment scheme is presented in [HSRT91]. An OCC with adaptive EDF has also been proposed in [HLC91].
Reference: [LS90] <author> Yi Lin and Sang H. Son. </author> <title> Concurrency control in real-time databases by dynamic adjustment of serialization order. </title> <booktitle> In Proceedings of Real-Time Systems Symposium, </booktitle> <pages> pages 104-112. </pages> <publisher> IEEE, </publisher> <year> 1990. </year>
Reference-contexts: OCC schemes display better performance for firm real-time transactions [HCL90a]. Lin and Son <ref> [LS90] </ref> have proposed a new concurrency control algorithm which is based on mixed integrated CC [BHG87] to adjust the serialization order dynamically. Priority scheduling with transaction pre-analysis is introduced as another approach with more knowledge of resource requirements [BMH89, Sha88, SRSC91].
Reference: [PLJ92] <author> Hweeehwa Pang, Miron Livny, and Michael J.Carey. </author> <title> Transaction scheduling in mul-ticlass real-time database systems. </title> <booktitle> In Proceedings of Real-Time System Symposium, </booktitle> <pages> pages 23-34. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: We expected that there would be less discrimination against long running transactions in CCA than EDF-HP because CCA implicitly considers the effective service time of a transaction as we can see it in Figure 11. Discrimination against long running transactions in RTDBS is discussed in <ref> [PLJ92] </ref>. In their experiment each class requires different ranges of object number. Thus each class has different level of data contention and resource time. In our experiment, however, each class only has different level of resource contention.
Reference: [Ram93] <author> K. Ramamritham. </author> <title> Real-time databases. Distributed and Parallel Databases, </title> <year> 1993. </year>
Reference-contexts: As a result, scheduling algorithms [ZRS87b, ZRS87a] used in current real-time systems assume a priori knowledge of tasks, such as arrival time, deadline, resource requirement, and worst case (cpu) execution time. For database applications, on the other hand, the following sources of unpredictability exist <ref> [Ram93] </ref> which makes it difficult to predict some of the resource requirements for transactions that need to meet time constraints: 1. Resource conflicts (e.g., wait for disk I/O) 2. Data dependence (e.g., execution path based on the database state) 3. <p> It is evident from the above that the accuracy of the heuristic is important for computing various relations defined above. Another approach proposed for gathering the necessary information is by using the two-phase (or pre-fetch) execution suggested by <ref> [Ram93] </ref>. A transaction is run primarily for determining the computational demands of that transaction.
Reference: [Sha88] <author> Lui Sha. </author> <title> Concurrency control for distributed real-time databases. </title> <booktitle> SIGMOD RECORD, </booktitle> <volume> 17(1) </volume> <pages> 82-98, </pages> <year> 1988. </year>
Reference-contexts: Broadly, the approaches can be categorized into priority assignment (for real-time systems) and concurrency control (for real-time databases) based approaches. Concurrency control based real-time database (time-critical database) scheduling algorithms combine various properties of time-critical schedulers with properties of concurrency control algorithms <ref> [AGM88a, AGM92, BMH89, C + 89, HLC91, Sha88, SRSC91, SZ88, HSRT91] </ref>. Priority scheduling without knowing the data access pattern is presented as a representative of algorithms with incomplete knowledge of resource requirements. The scheduling policies presented in [AGM92, HSRT91, HLC91, SZ88] fall into this category. <p> Lin and Son [LS90] have proposed a new concurrency control algorithm which is based on mixed integrated CC [BHG87] to adjust the serialization order dynamically. Priority scheduling with transaction pre-analysis is introduced as another approach with more knowledge of resource requirements <ref> [BMH89, Sha88, SRSC91] </ref>. Conflict avoiding nonpreemptive method and Hybrid algorithms which use conflict avoiding scheme in the non-overload case and Conditional Restart conflict resolution method in the overload case have been proposed in [BMH89]. <p> Static priority assignment based Priority Ceiling Protocol (PCP) using priority inheritance with exclusive lock and read/write PCP have been proposed in <ref> [Sha88, SRSC91] </ref>. 2.1 Discussion Some of the approaches such as EDF-HP and LSF-HP are straightforward combinations of earlier approaches. As all transactions are considered equal in traditional databases, priorities were assigned based on deadline for the purpose of abort in case of conflict.
Reference: [SRL90] <author> Lui Sha, Ragunathan Rajkumar, and J.P. Lehoczky. </author> <title> Priority inheritance protocols: An approach to real-time synchronization. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39 </volume> <pages> 1175-1185, </pages> <year> 1990. </year>
Reference-contexts: Only available timing information is deadline (EDF-HP [AGM89]). Type 1 Deadline and data access pattern are available (CCA [HJC93]). Type 2 Deadline and estimated execution time are available (EDF-CR, LSF-CR [AGM89]). Type 3 Data access pattern and static transaction priorities are available (Priority Ceiling <ref> [SRL90] </ref>). EDF priority assignment policy minimizes the number of late transactions when the system is lightly loaded. The performance, however, quickly degrades in overloaded systems. There have been several approaches to overcome this shortcoming and we can group them into two general approaches. 1.
Reference: [SRSC91] <author> Lui Sha, Ragunathan Rajkumar, Sang Hyuk Son, and Chun-Hyun Chang. </author> <title> A real-time locking protocol. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 40(7) </volume> <pages> 793-800, </pages> <year> 1991. </year> <month> 36 </month>
Reference-contexts: Broadly, the approaches can be categorized into priority assignment (for real-time systems) and concurrency control (for real-time databases) based approaches. Concurrency control based real-time database (time-critical database) scheduling algorithms combine various properties of time-critical schedulers with properties of concurrency control algorithms <ref> [AGM88a, AGM92, BMH89, C + 89, HLC91, Sha88, SRSC91, SZ88, HSRT91] </ref>. Priority scheduling without knowing the data access pattern is presented as a representative of algorithms with incomplete knowledge of resource requirements. The scheduling policies presented in [AGM92, HSRT91, HLC91, SZ88] fall into this category. <p> Lin and Son [LS90] have proposed a new concurrency control algorithm which is based on mixed integrated CC [BHG87] to adjust the serialization order dynamically. Priority scheduling with transaction pre-analysis is introduced as another approach with more knowledge of resource requirements <ref> [BMH89, Sha88, SRSC91] </ref>. Conflict avoiding nonpreemptive method and Hybrid algorithms which use conflict avoiding scheme in the non-overload case and Conditional Restart conflict resolution method in the overload case have been proposed in [BMH89]. <p> Static priority assignment based Priority Ceiling Protocol (PCP) using priority inheritance with exclusive lock and read/write PCP have been proposed in <ref> [Sha88, SRSC91] </ref>. 2.1 Discussion Some of the approaches such as EDF-HP and LSF-HP are straightforward combinations of earlier approaches. As all transactions are considered equal in traditional databases, priorities were assigned based on deadline for the purpose of abort in case of conflict.
Reference: [SZ88] <author> John A. Stankovic and Wei Zhao. </author> <title> On real-time transactions. </title> <booktitle> SIGMOD RECORD, </booktitle> <volume> 17(1) </volume> <pages> 4-18, </pages> <year> 1988. </year>
Reference-contexts: Broadly, the approaches can be categorized into priority assignment (for real-time systems) and concurrency control (for real-time databases) based approaches. Concurrency control based real-time database (time-critical database) scheduling algorithms combine various properties of time-critical schedulers with properties of concurrency control algorithms <ref> [AGM88a, AGM92, BMH89, C + 89, HLC91, Sha88, SRSC91, SZ88, HSRT91] </ref>. Priority scheduling without knowing the data access pattern is presented as a representative of algorithms with incomplete knowledge of resource requirements. The scheduling policies presented in [AGM92, HSRT91, HLC91, SZ88] fall into this category. <p> Priority scheduling without knowing the data access pattern is presented as a representative of algorithms with incomplete knowledge of resource requirements. The scheduling policies presented in <ref> [AGM92, HSRT91, HLC91, SZ88] </ref> fall into this category. These algorithms combine priority scheduling either with 2 phase locking or optimistic concurrency control (OCC) algorithms. <p> EDF-HP (Earliest Deadline First with High Priority), LSF-HP (Least Slack First with HP), EDF-WP (EDF with Wait Promote), EDF-CR (EDF with Conditional Restart), AEDF-HP (Adaptive EDF with HP) [HLC91], Virtual Clock and Pairwise Value Function <ref> [SZ88] </ref> are combined with 2 phase locking. As a variation of single version 2 phase locking real-time multiversion CC (Concurrency Control) [KS91] has been introduced to increase concurrency by adjusting serialization order dynamically. An OCC scheme with a deadline and transaction length based priority assignment scheme is presented in [HSRT91]. <p> In order to solve the problem of too many transaction aborts of EDF-HP, EDF-WP (EDF Wait Promote conflict resolution method [AGM89]) has been proposed. However, EDF-WP causes too much waiting due to its nonabortive conflict resolution method. Several hybrid methods that use combinations of abortive and nonabortive methods <ref> [AGM88a, SZ88] </ref> make decisions about transaction blocking and rollback using additional information, such as effective service time, slack time based on an estimated execution time. <p> The system might use different priority assignment policies for different resource types. Whenever a resource conflict occurs, a priority is used to resolve the conflict. In <ref> [AGM88b, SZ88] </ref> different priority assignment policies are used for CPU and data conflicts. However, the use of different priority assignment policies for different resource types might lead to more instances of priority reversal leading to deadlocks [BMH89].
Reference: [Tay92] <author> Y.C. Tay. </author> <title> A behavioral analysis of scheduling by earliest deadline. </title> <type> Technical Report No. 532, </type> <institution> Department of Mathematics, National University of Singapore, </institution> <year> 1992. </year>
Reference-contexts: Figure 8 (b), it is usually the case that the currently running transaction arrived a long time ago, but could not get system services due to the heavy load on the system (most of the dynamic factors in heavily loaded situation are arrival blockings rather than preemption blockings and aborts <ref> [Tay92] </ref>). Thus, fewer transactions are preempted and there are fewer opportunities for restarts [AGM88a]. In order to observe the correlation between the maximum capacity, arrival rate, and the behavior of the performance metrics, we performed an experiment by doubling the capacity.
Reference: [TSG85] <author> Y.C. Tay, R. Suri, and N. Goodman. </author> <title> Locking performance in centralized databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 10(4) </volume> <pages> 415-462, </pages> <year> 1985. </year>
Reference-contexts: After completing deferred updates a transaction releases all its locks. The values of parameters used for this experiment are shown in Table 3. The values of cpu time and i/o time are chosen to balance the utilization of CPU and disk <ref> [ACL87, AGM92, TSG85] </ref>. With this parameter assignments the system is slightly I/O bound.
Reference: [XP90] <author> Jia Xu and David R. Parnas. </author> <title> Scheduling processes with release times, deadlines, precedence, and exclusion relations. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(3) </volume> <pages> 360-369, </pages> <year> 1990. </year>
Reference-contexts: In this paper we only use type 1 knowledge but we are investigating a method that can combine type 1 and type 2 together with proper load detection mechanisms. In order to motivate the applicability of CCA, we apply it to an example drawn from <ref> [XP90] </ref> (Figure 2). For this example, we assume that all data are memory resident, transactions have soft deadlines, data conflict occurs at the beginning of transactions, and all possible valid schedules were made based on strict 2-phase locking.
Reference: [ZRS87a] <author> Wei Zhao, Krithi Ramamritham, and John A. Stankovic. </author> <title> Preemptive scheduling under time and resource constraints. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 36(8) </volume> <pages> 949-960, </pages> <year> 1987. </year>
Reference-contexts: Even when they share data, the consistency of shared data is not managed by the system but by the application program. For the assumptions used in real-time systems, it is possible to predict some of the characteristics of tasks needed for the scheduling algorithms. As a result, scheduling algorithms <ref> [ZRS87b, ZRS87a] </ref> used in current real-time systems assume a priori knowledge of tasks, such as arrival time, deadline, resource requirement, and worst case (cpu) execution time.
Reference: [ZRS87b] <author> Wei Zhao, Krithi Ramamritham, and John A. Stankovic. </author> <title> Scheduling tasks with requirement in hard real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(5) </volume> <pages> 225-236, </pages> <year> 1987. </year>
Reference-contexts: Even when they share data, the consistency of shared data is not managed by the system but by the application program. For the assumptions used in real-time systems, it is possible to predict some of the characteristics of tasks needed for the scheduling algorithms. As a result, scheduling algorithms <ref> [ZRS87b, ZRS87a] </ref> used in current real-time systems assume a priori knowledge of tasks, such as arrival time, deadline, resource requirement, and worst case (cpu) execution time.
References-found: 30

