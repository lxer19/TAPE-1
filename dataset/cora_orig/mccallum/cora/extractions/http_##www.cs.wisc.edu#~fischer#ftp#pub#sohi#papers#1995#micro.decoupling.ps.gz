URL: http://www.cs.wisc.edu/~fischer/ftp/pub/sohi/papers/1995/micro.decoupling.ps.gz
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/sohi/papers/1995/
Root-URL: http://www.cs.wisc.edu
Email: subbarao@cs.wisc.edu  jes@ece.wisc.edu  
Title: Decoupling Integer Execution in Superscalar Processors  
Author: Subbarao Palacharla J. E. Smith 
Address: Madison, WI 53706  Madison, WI 53706  
Affiliation: Computer Sciences Department University of Wisconsin-Madison  Department of Electrical and Computer Engineering University of Wisconsin-Madison  
Abstract: We propose that processor hardware can be used more effectively if floating-point units are augmented to perform simple integer operations. Existing floating-point registers and datapaths are used to support these integer operations. Some integer instructions, those not used for computing addresses and accessing memory, can then be off-loaded to the floating-point units. Consequently, these integer instructions are decoupled from memory accessing, and additional instruction bandwidth is available for integer programs. This paper reports the results of a preliminary study of integer benchmark programs compiled for the SPARC architecture. The results indicate that between 10% and 39% of the instructions in the integer benchmarks can be executed in the augmented floating-point units. Furthermore, these instructions are all simple add, subtract and logical instructions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Linley Gwennap. </author> <title> MIPS R10000 Uses Decoupled Architecture. </title> <type> Microprocessor Report, 8(14), </type> <month> October </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Over the past few years processor microarchitectures have converged to a decoupled implementation style. Figure 1 shows the microarchitecture of a typical superscalar processor <ref> [1, 5, 2] </ref> using this decoupled style. It comprises a fetch unit that feeds instructions to integer and floating-point subsystems. The integer subsystem is made up of a number of load/store, branch and ALU units operating out of the integer register file.
Reference: [2] <author> Linley Gwennap. </author> <title> Ultrasparc Unleashes SPARC Performance. </title> <type> Microprocessor Report, 8(13), </type> <month> October </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Over the past few years processor microarchitectures have converged to a decoupled implementation style. Figure 1 shows the microarchitecture of a typical superscalar processor <ref> [1, 5, 2] </ref> using this decoupled style. It comprises a fetch unit that feeds instructions to integer and floating-point subsystems. The integer subsystem is made up of a number of load/store, branch and ALU units operating out of the integer register file.
Reference: [3] <author> A.R. Pleszkun and E.S. Davidson. </author> <title> Structured Memory Access Architecture. </title> <booktitle> In International Conference on Parallel Processing, </booktitle> <pages> pages 461-471, </pages> <year> 1983. </year>
Reference-contexts: Buffers, in the form of reservation stations or queues, are used to decouple the instruction streams going to the functional units. This implementation style was identified and discussed in the Decoupled Access/Execute work described in <ref> [7, 3, 6] </ref>. At least in part, this work had its roots in the early Control Data Corporation and Cray Research style of architectures where one set of functional units and registers is used for addressing and another set is used for scalar computation, both integer and floating point.
Reference: [4] <author> Richard. M. Russell. </author> <title> The CRAY-1 Computer System. </title> <journal> Communications of the ACM, </journal> <volume> 21(1) </volume> <pages> 63-72, </pages> <month> January </month> <year> 1978. </year>
Reference-contexts: For example, the CRAY-1 This figure presents the typical microarchitecture employed by most current microprocessors. The floating-point (FP) units are idle while the processor is executing integer-intensive portions of a program. <ref> [4] </ref> uses A registers for address computation and S registers for scalar computation, both integer and floating point. Although many modern microprocessors have these general characteristics, their evolution has been slightly different.
Reference: [5] <author> Michael Slater. </author> <title> AMD's K5 Designed to Outrun Pentium. </title> <type> Microprocessor Report, 8(14), </type> <month> October </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Over the past few years processor microarchitectures have converged to a decoupled implementation style. Figure 1 shows the microarchitecture of a typical superscalar processor <ref> [1, 5, 2] </ref> using this decoupled style. It comprises a fetch unit that feeds instructions to integer and floating-point subsystems. The integer subsystem is made up of a number of load/store, branch and ALU units operating out of the integer register file.
Reference: [6] <author> J.E. Smith. </author> <title> Decoupled Access/Execute Computer Architecture. </title> <booktitle> In The 9th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 112-119, </pages> <month> April </month> <year> 1982. </year>
Reference-contexts: Buffers, in the form of reservation stations or queues, are used to decouple the instruction streams going to the functional units. This implementation style was identified and discussed in the Decoupled Access/Execute work described in <ref> [7, 3, 6] </ref>. At least in part, this work had its roots in the early Control Data Corporation and Cray Research style of architectures where one set of functional units and registers is used for addressing and another set is used for scalar computation, both integer and floating point.
Reference: [7] <author> J.E. Smith and et. al. </author> <title> The ZS-1 Central Processor. </title> <booktitle> In The 2nd International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 199-204, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: Buffers, in the form of reservation stations or queues, are used to decouple the instruction streams going to the functional units. This implementation style was identified and discussed in the Decoupled Access/Execute work described in <ref> [7, 3, 6] </ref>. At least in part, this work had its roots in the early Control Data Corporation and Cray Research style of architectures where one set of functional units and registers is used for addressing and another set is used for scalar computation, both integer and floating point.
Reference: [8] <institution> SPEC. </institution> <note> (entire issue). SPEC Newsletter, 3(4), </note> <month> December </month> <year> 1991. </year>
Reference-contexts: We used Shade to generate dynamic instruction traces. Shade [9] is an evaluation tool developed at Sun Microsys-tems that aids instruction set simulation. We used five integer benchmarks from the SPEC suite <ref> [8] </ref>. All the benchmarks were compiled using gcc (version 2.5.8) with the -O3 option. We analyzed complete program runs.
Reference: [9] <institution> Sun Microsystems Laboratories, Inc. </institution> <note> Introduction to Shade, </note> <month> April </month> <year> 1993. </year>
Reference-contexts: The number of instructions executed by the slice is computed by adding the dynamic count of all the instructions in the slice. We used Shade to generate dynamic instruction traces. Shade <ref> [9] </ref> is an evaluation tool developed at Sun Microsys-tems that aids instruction set simulation. We used five integer benchmarks from the SPEC suite [8]. All the benchmarks were compiled using gcc (version 2.5.8) with the -O3 option. We analyzed complete program runs.
Reference: [10] <author> Mark Weiser. </author> <title> Program Slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 10(4) </volume> <pages> 352-357, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: Memory and store value dependencies are depicted using special (dotted) edges. 2 Methodology The analysis performed in this paper involves constructing various slices of a program. A slice <ref> [10] </ref> of a program with respect to a value v, denoted by Slice (P,v), is defined to be the subset of the program that computes the value v.
References-found: 10

