URL: ftp://rtcl.eecs.umich.edu/outgoing/atri/rtoss92.ps.Z
Refering-URL: http://www.eecs.umich.edu/~atri/
Root-URL: http://www.cs.umich.edu
Email: kandlur@watson.ibm.com fatri,kgshing@eecs.umich.edu  
Title: Real-Time Communication in Point-to-Point Networks  
Author: Atri Indiresan, Kang G. Shin Dilip D. Kandlur 
Address: Yorktown Heights, NY 10598 Ann Arbor, Michigan 48109-2122.  
Affiliation: Real-time Computing Laboratory IBM Research Division Dept. of Elec. Engr. and Comp. Sci. T. J. Watson Research Center The University of Michigan  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> D. D. Kandlur and K. G. Shin, </author> <title> "Design of a communication subsystem for HARTS," </title> <type> Technical Report CSE-TR-109-91, </type> <institution> CSE Division, Department of EECS, The University of Michigan, </institution> <month> October </month> <year> 1991. </year>
Reference-contexts: A theoretical model for real-time communication in a point-to-point network is described in <ref> [1] </ref> using a communication abstraction called a real-time channel as its basis. A real-time channel, or simply channel, is characterized by its source and destination, its performance requirements and traffic patterns, and resources including network bandwidth, buffer space and message processing bandwidth need to be reserved for it. <p> The route and the worst-case delay for each link on the route are recorded in data structures which are used to set deadlines at each node along the channel for messages belonging to real-time channels. While details of the channel establishment procedure may be found in <ref> [1, 2] </ref>, we briefly discuss the scheduling aspect. There are several approaches to scheduling these messages, which can be categorized as fixed priority or dynamic priority algorithms. For example, Earliest Due Date (EDD) scheduling [3] is a dynamic priority algorithm, whereas rate monotonic scheduling [4] is a fixed priority algorithm. <p> The details of this scheme for analysis can be found in <ref> [1] </ref>. 2 3 Implementation There are three main steps in the implementation of real-time channels: (i) the computation of a (feasible) route and required resources, (ii) the establishment of the route with the reservation of resources and bandwidth, and (iii) run-time support for routing and scheduling a mix of real-time and <p> We implement real-time channels as a set of protocol objects (using x-kernel terminology). The Real-Time Channel Protocol (RTCP) <ref> [1] </ref> is the protocol in the x-kernel protocol stack that implements the interface for the real-time channel communication scheme. The clients of this protocol are processes running on the Application Processors (APs). Channel establishment has been dealt with elsewhere [1]. <p> The Real-Time Channel Protocol (RTCP) <ref> [1] </ref> is the protocol in the x-kernel protocol stack that implements the interface for the real-time channel communication scheme. The clients of this protocol are processes running on the Application Processors (APs). Channel establishment has been dealt with elsewhere [1]. In brief, a separate protocol module called a Network Manager (NM) performs this service. Since requests to this server are serialized, data consistency for different channel establishment requests is assured. A request to the RTCP to establish a channel is passed on to the NM. <p> This would involve making predictions of expected usage, and allocate fewer resources for each channel. Since guarantees are no longer strict, it would be necessary to monitor the system, and notify users when latency bounds are (consistently) violated. Further, the current version of the real-time channel <ref> [1] </ref> provides guarantees in the absence of failures. In the event of failures, rerouting messages around the faulty links and nodes may cause the messages to miss their deadline. An alternative is the concept of group channels, where we send replicated messages.
Reference: [2] <author> D. D. Kandlur, K. G. Shin, and D. Ferrari, </author> <title> "Real-time communication in multi-hop networks," </title> <booktitle> in Proc. Int. Conf. on Distributed Computer Systems, </booktitle> <pages> pp. 300-307, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: The route and the worst-case delay for each link on the route are recorded in data structures which are used to set deadlines at each node along the channel for messages belonging to real-time channels. While details of the channel establishment procedure may be found in <ref> [1, 2] </ref>, we briefly discuss the scheduling aspect. There are several approaches to scheduling these messages, which can be categorized as fixed priority or dynamic priority algorithms. For example, Earliest Due Date (EDD) scheduling [3] is a dynamic priority algorithm, whereas rate monotonic scheduling [4] is a fixed priority algorithm.
Reference: [3] <author> M. L. Dertouzos, </author> <title> "Control robotics: The procedural control of physical processes," </title> <booktitle> in Proceedings IFIP Congress, </booktitle> <pages> pp. 807-813, </pages> <year> 1974. </year>
Reference-contexts: While details of the channel establishment procedure may be found in [1, 2], we briefly discuss the scheduling aspect. There are several approaches to scheduling these messages, which can be categorized as fixed priority or dynamic priority algorithms. For example, Earliest Due Date (EDD) scheduling <ref> [3] </ref> is a dynamic priority algorithm, whereas rate monotonic scheduling [4] is a fixed priority algorithm.
Reference: [4] <author> C. L. Liu and J. W. Layland, </author> <title> "Scheduling algorithms for multiprogramming in a hard real-time environment," </title> <journal> Journal of the ACM, </journal> <volume> vol. 20, no. 1, </volume> <pages> pp. 46-61, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: There are several approaches to scheduling these messages, which can be categorized as fixed priority or dynamic priority algorithms. For example, Earliest Due Date (EDD) scheduling [3] is a dynamic priority algorithm, whereas rate monotonic scheduling <ref> [4] </ref> is a fixed priority algorithm. Liu and Layland [4] have shown that EDD is optimal for preemptive scheduling of periodic tasks when the task deadline is equal to the beginning of its next period, and that a feasible schedule exists whenever the total utilization is less than one. <p> There are several approaches to scheduling these messages, which can be categorized as fixed priority or dynamic priority algorithms. For example, Earliest Due Date (EDD) scheduling [3] is a dynamic priority algorithm, whereas rate monotonic scheduling <ref> [4] </ref> is a fixed priority algorithm. Liu and Layland [4] have shown that EDD is optimal for preemptive scheduling of periodic tasks when the task deadline is equal to the beginning of its next period, and that a feasible schedule exists whenever the total utilization is less than one. <p> This is done by computing the worst-case response time for each message using a critical time zone analysis similar to the one used in <ref> [4] </ref>, and verifying that the worst-case response time is less than the delay assigned to that channel.
Reference: [5] <author> N. C. Hutchinson and L. L. Peterson, </author> <title> "The x-Kernel: An architecture for implementing network protocols," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. 17, no. 1, </volume> <pages> pp. 1-13, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: We now show how these can be achieved using the x-kernel <ref> [5] </ref> on the Network Processor (NP) of HARTS [6]. The x-kernel is designed for distributed system support, and provides facilities for implementing protocols like a uniform protocol interface, libraries to efficiently manipulate messages, and tools to configure and test different protocol stacks.
Reference: [6] <author> K. G. Shin, </author> <title> "HARTS: A distributed real-time architecture," </title> <journal> IEEE Computer, </journal> <volume> vol. 24, no. 5, </volume> <pages> pp. 25-36, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: We now show how these can be achieved using the x-kernel [5] on the Network Processor (NP) of HARTS <ref> [6] </ref>. The x-kernel is designed for distributed system support, and provides facilities for implementing protocols like a uniform protocol interface, libraries to efficiently manipulate messages, and tools to configure and test different protocol stacks. We implement real-time channels as a set of protocol objects (using x-kernel terminology).
Reference: [7] <author> D. W. Jones, </author> <title> "An empirical study of priority-queue and event-set implementations," </title> <journal> Communications of the ACM, </journal> <volume> vol. 29, no. 4, </volume> <pages> pp. 300-311, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: The most common, and most efficient way, to implement EDD scheduling is by using a priority queue, ordered by message deadlines. Using a heap, we may insert a message in fi (log n) time, and remove the next message to be transmitted in constant time <ref> [7] </ref>. When a message arrives, if it is a best-effort message, simply insert it into the second queue. If it is an early real-time message, insert it into the third queue, and if it is an "on-time" message, insert it into the first queue.
Reference: [8] <author> A. Indiresan and Q. Zheng, </author> <title> "Design and evaluation of a fast deadline scheduling switch for multicomputers," RTCL working document, </title> <month> December </month> <year> 1991. </year> <month> 5 </month>
Reference-contexts: Keeping such an eventuality in mind, we propose a hardware priority queue that will insert a message in a priority queue in a small constant number of clock cycles <ref> [8] </ref>. This design has a large shift register containing message deadlines, and when a new message arrives, its deadline is compared to those of the messages in the shift register, allowing it to be inserted in the appropriate place.
References-found: 8

