URL: ftp://ftp.cs.unc.edu/pub/users/jeffay/papers/RTSS-95.ps.Z
Refering-URL: http://www.cs.unc.edu/Research/real-time.html
Root-URL: http://www.cs.unc.edu
Title: Real-Time Computing with Lock-Free Shared Objects  
Author: James H. Anderson Srikanth Ramamurthy Kevin Jeffay 
Address: Chapel Hill, NC 27599-3175  
Affiliation: Department of Computer Science, University of North Carolina,  
Abstract: This paper considers the use of lock-free shared objects within hard real-time systems. As the name suggests, lock-free shared objects are distinguished by the fact that they are not locked. As such, they do not give rise to priority inversions, a key advantage over conventional, lock-based object-sharing approaches. Despite this advantage, it is not immediately apparent that lock-free shared objects can be employed if tasks must adhere to strict timing constraints. In particular, lock-free object implementations permit concurrent operations to interfere with each other, and repeated interferences can cause a given operation to take an arbitrarily long time to complete. The main contribution of this paper is to show that such interferences can be bounded by judicious scheduling. This work pertains to periodic, hard real-time tasks that share lock-free objects on a uniprocessor. In the first part of the paper, scheduling conditions are derived for such tasks, for both static and dynamic priority schemes. Based on these conditions, it is formally shown that lock-free object-sharing approaches can be expected to incur much less overhead than approaches based on wait-free objects or lock-based schemes. In the last part of the paper, this conclusion is validated experimentally through work involving a real-time desktop videoconferencing system. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Anderson and M. Moir, </author> <title> "Universal Constructions for Multi-Object Operations", </title> <booktitle> to appear in the Proceedings of the 14th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <year> 1995. </year>
Reference-contexts: It might be useful, for example, to nest two critical sections to transfer the contents of one shared buffer to another. Recently, Anderson and Moir presented algorithms for implementing multi-object operations that allow similar functionality in lock-free (and wait-free) implementations <ref> [1] </ref>. Using these algorithms, a buffer transfer can be accomplished in a lock-free (or wait-free) manner by simultaneously accessing both buffers.
Reference: [2] <author> J. Anderson, S. Ramamurthy and K. Jeffay, </author> <title> "Real-Time Computing Using Lock-free Shared Objects", </title> <type> Technical Report TR95-021, </type> <institution> Department of Computer Science, University of North Carolina, </institution> <note> June 1995 (URL: http://www.cs.unc.edu/~anderson/ papers/rtss95.ps.Z). </note>
Reference-contexts: Although such loops could be long in principle, as shown in [16], many common objects, including most that would be of use in a real-time system, can be implemented with very short retry loops, such as that depicted in Figure 1 (see <ref> [2] </ref> for a detailed discussion of this issue). The overriding conclusion to be drawn from our work is that, for all but certain pathological objects that require costly retry loops, lock-free objects are likely to require substantially less overhead than lock-based objects implemented using the PCP or other approaches. <p> In [15], it is shown that for independent tasks, the longest response time of a task occurs at a critical instant of time, at which jobs of that task and all higher-priority tasks are released. However, this is not necessarily the case if tasks synchronize using lock-free objects (see <ref> [2] </ref> for examples showing why this is not so). Instead of defining the critical instant or giving the worst-case phasing of the tasks, we introduce the notion of a busy point . <p> Hence, 0 b i (k) r i (k). (For the RM scheme, it is possible to prove a tighter bound of (r i (k 1); r i (k)] on the range of b i (k). See <ref> [2] </ref> for details.) In the formal proofs of our scheduling conditions, we inductively count the number of failed updates over intervals of time. <p> We now state two lemmas that bound the number of failed updates in a given interval, under the RM and EDF schemes. Full proofs of these lemmas can be found in <ref> [2] </ref>. <p> In contrast, no media samples were lost when lock-free objects were used. This result is predicted by the formal analysis of the system, the details of which can be found in <ref> [2] </ref>. The analysis shows that under the PCP the task Packetize 2 is not schedulable. This task copies compressed media sample buffers to the network adapter. When Packetize 2 does not meet its deadline, the sender drops (never transmits) some of the media samples. <p> Our experiments showed that the set of tasks in the system is schedulable under both schemes. This result is predicted by the formal analysis of the system. For brevity, the formal analysis is not presented here (refer to <ref> [2] </ref> for details). In order to more precisely compare lock-free objects with objects implemented under the EDF/DDM scheme, we introduced a dummy task to increase the processor utilization of the system. This dummy task consists of a bounded loop.
Reference: [3] <author> B. Bershad, </author> <title> "Practical Considerations for Non-Blocking Concurrent Objects", </title> <booktitle> Proceedings of the 13th international Conference on Distributed Computing Systems, </booktitle> <month> May </month> <year> 1993, </year> <pages> pp. pages 264-274. </pages>
Reference-contexts: Although the PCP provides a general framework for real-time synchronization, this generality comes at a price, specifically operating system overhead that is sometimes excessive. In this paper, we consider interprocess communication in object-based, hard real-time systems. Our main contribution is to show that lock-free shared objects <ref> [3, 7, 16] </ref> | i.e., objects that are not critical-section-based | are a viable alternative to lock-based schemes such as the PCP in such systems. We establish this through a combination of formal analysis and experimentation. <p> Such context switching is unnecessary when lock-free objects are used. Lock-free operations are usually implemented using "retry loops" <ref> [3, 6, 7, 11, 16] </ref>. Figure 1 depicts an example of such an operation, an enqueue taken from a shared queue implementation given in [16].
Reference: [4] <author> M. I. Chen and K. J. Lin, </author> <title> "Dynamic Priority Ceiling: A Concurrency Control Protocol for Real Time Systems", </title> <journal> Real-Time Systems Journal , Vol. </journal> <volume> 2, No. 1, </volume> <year> 1990, </year> <pages> pp. 325-346. </pages>
Reference-contexts: In reality, a preempted task need not be accessing a shared object, and hence may not necessarily have a failed update as we have assumed. 5.2 Dynamic-Priority Scheduling We now compare the overhead of lock-free objects with two dynamic-priority schemes that use semaphore-based objects: the dynamic priority ceiling protocol (DPCP) <ref> [4] </ref>, and the dynamic deadline modification (DDM) scheme under EDF scheduling (EDF/DDM) [8]. Based on the analysis in [4], a sufficient condition for the schedulability of a set of periodic tasks under the DPCP, sched DPCP, can be defined as follows. sched DPCP P N (c j +block j ) p <p> a failed update as we have assumed. 5.2 Dynamic-Priority Scheduling We now compare the overhead of lock-free objects with two dynamic-priority schemes that use semaphore-based objects: the dynamic priority ceiling protocol (DPCP) <ref> [4] </ref>, and the dynamic deadline modification (DDM) scheme under EDF scheduling (EDF/DDM) [8]. Based on the analysis in [4], a sufficient condition for the schedulability of a set of periodic tasks under the DPCP, sched DPCP, can be defined as follows. sched DPCP P N (c j +block j ) p j In the above condition, block j is the maximum time for which task T j can be
Reference: [5] <author> B. O. Gallmeister and C. Lanier, </author> <title> "Early Experience With POSIX 1003.4 and POSIX 1003.4A", </title> <booktitle> Proceedings of the 12th IEEE Real-Time Systems Symposium, </booktitle> <year> 1991, </year> <pages> pp. 190-198. </pages>
Reference-contexts: As explained below, recent studies that evaluate the performance of lock-free objects [16] and lock-based objects <ref> [5] </ref> indicate that s is likely to be much smaller than r. This is confirmed by the experimental results presented in Section 6. 5.1 Static-Priority Scheduling We begin by comparing the overhead of lock-free synchronization under RM scheduling with the overhead of the lock-based priority ceiling protocol (PCP) [17]. <p> Massalin's conclusions are based on experiments run on a 25 MHz, one-wait-state memory, cold-cache 68030 CPU. In contrast, lock-based implementations fared much worse in a recent performance comparison of commercial real-time operating systems run on a 25 MHz, zero-wait-state memory 80386 CPU <ref> [5] </ref>. In this comparison, the implementation of semaphores on LynxOS took 154.4 microseconds to lock and unlock a semaphore in the worst case. The corresponding figure for POSIX mutex-style semaphores was 243.6 microseconds.
Reference: [6] <author> M. Herlihy, </author> <title> "Wait-Free Synchronization", </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 13, No. 1, </volume> <year> 1991, </year> <pages> pp. 124-149. </pages>
Reference-contexts: Such context switching is unnecessary when lock-free objects are used. Lock-free operations are usually implemented using "retry loops" <ref> [3, 6, 7, 11, 16] </ref>. Figure 1 depicts an example of such an operation, an enqueue taken from a shared queue implementation given in [16]. <p> Wait-free objects guarantee a strong form of lock-freedom that precludes all waiting dependencies among tasks <ref> [6, 7, 19] </ref> (including potentially unbounded retry loops). 2 Although one motivation for work on wait-free objects has been their potential use in real-time systems, our results show that lock-free objects are usually superior for real-time computing on uniprocessors. <p> Most wait-free algorithms ensure termination by requiring each task to "help" every other task to complete any pending object access <ref> [6, 7] </ref>. However, on a uniprocessor, lower-priority tasks cannot help higher-priority tasks because a higher-priority task does not release the processor until its demand has been fulfilled. Thus, each task only helps lower-priority tasks. Hence, the greater the task priority, the larger the access time.
Reference: [7] <author> M. Herlihy, </author> <title> "A Methodology for Implementing Highly Concurrent Data Objects", </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 15, No. 5, </volume> <year> 1993, </year> <pages> pp. 745-770. </pages>
Reference-contexts: Although the PCP provides a general framework for real-time synchronization, this generality comes at a price, specifically operating system overhead that is sometimes excessive. In this paper, we consider interprocess communication in object-based, hard real-time systems. Our main contribution is to show that lock-free shared objects <ref> [3, 7, 16] </ref> | i.e., objects that are not critical-section-based | are a viable alternative to lock-based schemes such as the PCP in such systems. We establish this through a combination of formal analysis and experimentation. <p> Such context switching is unnecessary when lock-free objects are used. Lock-free operations are usually implemented using "retry loops" <ref> [3, 6, 7, 11, 16] </ref>. Figure 1 depicts an example of such an operation, an enqueue taken from a shared queue implementation given in [16]. <p> Wait-free objects guarantee a strong form of lock-freedom that precludes all waiting dependencies among tasks <ref> [6, 7, 19] </ref> (including potentially unbounded retry loops). 2 Although one motivation for work on wait-free objects has been their potential use in real-time systems, our results show that lock-free objects are usually superior for real-time computing on uniprocessors. <p> Most wait-free algorithms ensure termination by requiring each task to "help" every other task to complete any pending object access <ref> [6, 7] </ref>. However, on a uniprocessor, lower-priority tasks cannot help higher-priority tasks because a higher-priority task does not release the processor until its demand has been fulfilled. Thus, each task only helps lower-priority tasks. Hence, the greater the task priority, the larger the access time. <p> We evaluated the performance of the system when the shared queues were implemented using lock-free algorithms, wait-free algorithms, and lock-based techniques. We implemented lock-free queues by using the shared queue implementation given by Massalin in [16], and wait-free queues by using the wait-free universal construction given by Herlihy in <ref> [7] </ref>. Massalin's queue implementation requires CAS (needed for the dequeue operation) and CAS2 (needed for the enqueue operation), and Herlihy's construction requires load-linked and store-conditional . We implemented these primitives by short kernel calls; interrupts were disabled for the duration of these calls.
Reference: [8] <author> K. Jeffay, </author> <title> "Scheduling Sporadic Tasks with Shared Resources in Hard Real-Time Systems", </title> <booktitle> Proceedings of the 13 th IEEE Symposium on Real-Time Systems, </booktitle> <address> Phoenix, AZ, </address> <year> 1992, </year> <pages> pp. 89-99. </pages>
Reference-contexts: and hence may not necessarily have a failed update as we have assumed. 5.2 Dynamic-Priority Scheduling We now compare the overhead of lock-free objects with two dynamic-priority schemes that use semaphore-based objects: the dynamic priority ceiling protocol (DPCP) [4], and the dynamic deadline modification (DDM) scheme under EDF scheduling (EDF/DDM) <ref> [8] </ref>. <p> Thus, there are task sets that can be scheduled when lock-free objects are used but not when DPCP is used. We now turn our attention to the EDF/DDM scheme presented in <ref> [8] </ref>. Under this scheme, tasks are divided into one or more phases. During each phase, a task accesses at most one shared resource. <p> Upon completing the shared object access, T i 's deadline is restored to its original value. In our comparison, we assume that phases in which some shared object is accessed are r units in length. Based on the analysis of <ref> [8] </ref>, a sufficient condition for the schedulability of a set of periodic tasks under the EDF/DDM scheme, sched DDM , can be defined as follows. sched DDM ( P N u j +m j r h8i; t : P i &lt; t &lt; p i : r + j=1 t1 k
Reference: [9] <author> K. Jeffay and D. Stone, </author> <title> "Accounting for Interrupt Handling Costs in Dynamic Priority Task Systems", </title> <booktitle> Proceedings of the 14 th IEEE Symposium on Real-Time Systems, </booktitle> <address> Durham, NC, </address> <year> 1993, </year> <pages> pp. 212-221. </pages>
Reference: [10] <author> K. Jeffay, D.L. Stone, and F.D. Smith, </author> <title> "Kernel Support for Live Digital Audio and Video", </title> <journal> Computer Communications, </journal> <volume> Vol. 15, No. 6, </volume> <month> July/August </month> <year> 1992, </year> <pages> pp. 388-395. </pages>
Reference-contexts: This evidence comes from a set of experimental comparisons performed using a real-time desktop videocon-ferencing system implemented at UNC <ref> [10] </ref>. We modified this system to support lock-free shared objects implemented under both DM and EDF scheduling, semaphores implemented using the PCP under DM scheduling, and semaphores implemented under EDF/DDM scheduling. We also considered wait-free shared objects implemented under both DM and EDF scheduling.
Reference: [11] <author> T. Johnson and K. Harathi, </author> <title> "Interruptible Critical Sections", </title> <type> Technical Report TR94-007, </type> <institution> Department of Computer Science, University of Florida, </institution> <year> 1994. </year>
Reference-contexts: Such context switching is unnecessary when lock-free objects are used. Lock-free operations are usually implemented using "retry loops" <ref> [3, 6, 7, 11, 16] </ref>. Figure 1 depicts an example of such an operation, an enqueue taken from a shared queue implementation given in [16]. <p> Unfortunately, the thread of research on wait-free and lock-free communication begun by Sorenson and Hamacher was lost in the real-time systems commu nity for many years. Recently, however, this thread of research resurfaced in work presented by Kopetz and Reisinger in [12] and by Johnson and Harathi in <ref> [11] </ref>. In the former paper, a simple lock-free, one-writer, read/write buffer is presented, and scheduling conditions are given for tasks sharing the buffer. In the latter paper, the primary focus is implementations of lock-free algorithms rather than scheduling.
Reference: [12] <author> H. Kopetz and J. Reisinger, </author> <title> "The Non-Blocking Write Protocol NBW: A Solution to a Real-Time Synchronization Problem", </title> <booktitle> Proceedings of the IEEE Real-Time Systems Symposium, </booktitle> <year> 1993, </year> <pages> pp. 131-137. </pages>
Reference-contexts: Unfortunately, the thread of research on wait-free and lock-free communication begun by Sorenson and Hamacher was lost in the real-time systems commu nity for many years. Recently, however, this thread of research resurfaced in work presented by Kopetz and Reisinger in <ref> [12] </ref> and by Johnson and Harathi in [11]. In the former paper, a simple lock-free, one-writer, read/write buffer is presented, and scheduling conditions are given for tasks sharing the buffer. In the latter paper, the primary focus is implementations of lock-free algorithms rather than scheduling.
Reference: [13] <author> J. Lehoczky, L. Sha, and Y. Ding, </author> <title> "The Rate Monotonic Scheduling Algorithm: Exact Characterization and Average Case Behavior", </title> <booktitle> Proceedings of the Tenth IEEE Real-Time Systems Symposium, </booktitle> <address> Santa Monica, CA, </address> <year> 1989, </year> <pages> pp. 166-171. </pages>
Reference: [14] <author> J.Y.T. Leung and J. Whitehead, </author> <title> "On the Complexity of Fixed-Priority Scheduling of Periodic, Real-Time Tasks", </title> <journal> Performance Evaluation, </journal> <volume> Vol. 2, No. 4, </volume> <year> 1982, </year> <pages> pp. 237-250. </pages>
Reference-contexts: For simplicity, we assume that tasks are indexed in nondecreasing order by relative deadline. With this change to our model, it is possible to prove the following static scheduling condition. This condition assumes that priority is assigned by the DM scheme <ref> [14] </ref>, in which tasks with smaller relative deadlines have higher priorities. The two summation terms in the stated expression below give the computational demand of T i and higher-priority tasks, and the additional computation required due to failed updates, respectively, in an interval of length t. <p> In both cases scheduling was performed using a DM scheduling algorithm <ref> [14] </ref>. Qualitatively, when queue synchronization was achieved using semaphores, approximately seven media samples were lost in the pipeline every second due to buffer overflow. In contrast, no media samples were lost when lock-free objects were used.
Reference: [15] <author> C. Liu and J. Layland, </author> <title> "Scheduling Algorithms for multiprogramming in a Hard Real-Time Environment", </title> <journal> Journal of the ACM , Vol 30., </journal> <month> Jan. </month> <year> 1973, </year> <pages> pp. 46-61. </pages>
Reference-contexts: We establish this through a combination of formal analysis and experimentation. We begin by establishing scheduling conditions for hard real-time, periodic tasks that share lock-free objects on a uniprocessor under either rate-monotonic (RM) or earliest-deadline-first (EDF) scheduling <ref> [15] </ref>. We then compare lock-free and lock-based approaches, both formally, based on our scheduling conditions, and experimentally, based on work involving a real-time desktop videoconferencing facility. Our formal analysis and experimental work both lead to the same conclusion: lock-free objects often require less overhead than conventional lock-based object-sharing approaches. <p> This approach is pessimistic because the preempted job may not, in fact, be accessing any shared object when preempted. Before we present our scheduling conditions, we define the concept of a "busy point" and then state two lemmas used in the proofs of these conditions. In <ref> [15] </ref>, it is shown that for independent tasks, the longest response time of a task occurs at a critical instant of time, at which jobs of that task and all higher-priority tasks are released.
Reference: [16] <author> H. Massalin, </author> <title> Synthesis: An Efficient Implementation of Fundamental Operating System Services, </title> <type> Ph.D. Dissertation, </type> <institution> Columbia University, </institution> <year> 1992. </year>
Reference-contexts: Although the PCP provides a general framework for real-time synchronization, this generality comes at a price, specifically operating system overhead that is sometimes excessive. In this paper, we consider interprocess communication in object-based, hard real-time systems. Our main contribution is to show that lock-free shared objects <ref> [3, 7, 16] </ref> | i.e., objects that are not critical-section-based | are a viable alternative to lock-based schemes such as the PCP in such systems. We establish this through a combination of formal analysis and experimentation. <p> Such context switching is unnecessary when lock-free objects are used. Lock-free operations are usually implemented using "retry loops" <ref> [3, 6, 7, 11, 16] </ref>. Figure 1 depicts an example of such an operation, an enqueue taken from a shared queue implementation given in [16]. <p> Such context switching is unnecessary when lock-free objects are used. Lock-free operations are usually implemented using "retry loops" [3, 6, 7, 11, 16]. Figure 1 depicts an example of such an operation, an enqueue taken from a shared queue implementation given in <ref> [16] </ref>. <p> An important question, then, is how costly lock-free retry loops are likely to be. Although such loops could be long in principle, as shown in <ref> [16] </ref>, many common objects, including most that would be of use in a real-time system, can be implemented with very short retry loops, such as that depicted in Figure 1 (see [2] for a detailed discussion of this issue). <p> As explained below, recent studies that evaluate the performance of lock-free objects <ref> [16] </ref> and lock-based objects [5] indicate that s is likely to be much smaller than r. <p> This also implies that there are certain task sets that are schedulable when lock-free objects are used, but not under the PCP. What are typical values of s and r? A performance comparison of various lock-free objects is given by Massalin in <ref> [16] </ref>. Massalin reports that, given hardware support for primitives like compare-and-swap, s varies from 1.3 microseconds for a counter to 3.3 microseconds for a circular queue. In the absence of hardware support, such primitives can be simulated by a trap, adding an additional 4.2 microseconds. <p> We evaluated the performance of the system when the shared queues were implemented using lock-free algorithms, wait-free algorithms, and lock-based techniques. We implemented lock-free queues by using the shared queue implementation given by Massalin in <ref> [16] </ref>, and wait-free queues by using the wait-free universal construction given by Herlihy in [7]. Massalin's queue implementation requires CAS (needed for the dequeue operation) and CAS2 (needed for the enqueue operation), and Herlihy's construction requires load-linked and store-conditional .
Reference: [17] <author> Raghunathan Rajkumar, </author> <title> Synchronization In Real-Time Systems APriority Inheritance Approach, </title> <publisher> Kluwer Academic Publications, </publisher> <year> 1991. </year>
Reference-contexts: The third author was supported by grants from Intel and IBM. Email: fanderson, ramamurt, jeffayg@cs.unc.edu. In Proceedings of the 16 th IEEE Real-Time Systems Symposium, Pisa, Italy, 1995, pp. 28-37. of lower priority to unlock a semaphore. Mechanisms such as the priority ceiling protocol (PCP) <ref> [17, 18] </ref> are used to solve this problem. The PCP requires the operating system to identify those tasks that may lock a semaphore. <p> This is confirmed by the experimental results presented in Section 6. 5.1 Static-Priority Scheduling We begin by comparing the overhead of lock-free synchronization under RM scheduling with the overhead of the lock-based priority ceiling protocol (PCP) <ref> [17] </ref>. When tasks synchronize by locking, a higher-priority job can be blocked by a lower-priority job that accesses a common object; the maximum blocking time is called the blocking factor . Under the PCP, the worst-case blocking time equals the time required to execute the longest critical section. <p> Since we do not consider nested critical sections, the blocking factor equals r, the time to execute a single critical section. We denote the schedulability condition for periodic tasks using the PCP by the predicate sched PCP , which on the basis of the analysis in <ref> [17] </ref>, is defined as follows. h8i 9t : 0 &lt; t p i : r + j=1 t m Observe that h8j : j i : (m j + 1) s m j ri ^ sched PCP implies h8i 9t : 0 &lt; t p i : P i l p
Reference: [18] <author> L. Sha, R. Rajkumar, and J. Lehoczky, </author> <title> "Priority Inheritance Protocols: An Approach to Real-Time System Synchronization", </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. 39, No. 9, </volume> <year> 1990, </year> <pages> pp. 1175-1185. </pages>
Reference-contexts: The third author was supported by grants from Intel and IBM. Email: fanderson, ramamurt, jeffayg@cs.unc.edu. In Proceedings of the 16 th IEEE Real-Time Systems Symposium, Pisa, Italy, 1995, pp. 28-37. of lower priority to unlock a semaphore. Mechanisms such as the priority ceiling protocol (PCP) <ref> [17, 18] </ref> are used to solve this problem. The PCP requires the operating system to identify those tasks that may lock a semaphore.
Reference: [19] <author> A. Singh, J. Anderson, and M. Gouda, </author> <title> "The Elusive Atomic Register", </title> <journal> Journal of the ACM , Vol. </journal> <volume> 41, No. 2, </volume> <month> March </month> <year> 1994, </year> <pages> pp. 311-339. </pages>
Reference-contexts: Wait-free objects guarantee a strong form of lock-freedom that precludes all waiting dependencies among tasks <ref> [6, 7, 19] </ref> (including potentially unbounded retry loops). 2 Although one motivation for work on wait-free objects has been their potential use in real-time systems, our results show that lock-free objects are usually superior for real-time computing on uniprocessors.
Reference: [20] <author> P. Sorensen, </author> <title> A Methodology for Real-Time System Development , Ph.D. </title> <type> Thesis, </type> <institution> University of Toronto, </institution> <year> 1974. </year>
Reference-contexts: The lock-free approach to real-time object sharing that we espouse is actually rooted in work done by Sorenson and Hamacher in the real-time systems community some twenty years ago <ref> [20, 21] </ref>. Sorenson and Hamacher's work involved a real-time communication mechanism based on wait-free read/write buffers. In their approach, buffers are managed by the operating system, so it suffers from many of the same shortcomings as conventional lock-based approaches.
Reference: [21] <author> P. Sorensen and V. Hemacher, </author> <title> "A Real-Time System Design Methodology", </title> <journal> INFOR, </journal> <volume> Vol. 13, No. 1, </volume> <month> February </month> <year> 1975, </year> <pages> pp. 1-18. </pages>
Reference-contexts: The lock-free approach to real-time object sharing that we espouse is actually rooted in work done by Sorenson and Hamacher in the real-time systems community some twenty years ago <ref> [20, 21] </ref>. Sorenson and Hamacher's work involved a real-time communication mechanism based on wait-free read/write buffers. In their approach, buffers are managed by the operating system, so it suffers from many of the same shortcomings as conventional lock-based approaches.
Reference: [22] <author> D. Stone, </author> <title> Managing the Effect of Delay Jitter on the Display of Live Continuous Media, </title> <type> Doctoral Dissertation, </type> <institution> University of North Carolina, Chapel Hill, </institution> <year> 1995. </year>
Reference-contexts: For a more detailed description of this system, we refer the interested reader to <ref> [22] </ref>. We evaluated the performance of the system when the shared queues were implemented using lock-free algorithms, wait-free algorithms, and lock-based techniques.
References-found: 22

