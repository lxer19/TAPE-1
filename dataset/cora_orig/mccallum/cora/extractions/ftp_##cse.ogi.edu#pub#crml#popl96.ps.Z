URL: ftp://cse.ogi.edu/pub/crml/popl96.ps.Z
Refering-URL: http://www.cse.ogi.edu/PacSoft/publications/bibliograph.html
Root-URL: http://www.cse.ogi.edu
Email: ffegaras,sheardg@cse.ogi.edu  
Title: Revisiting Catamorphisms over Datatypes with Embedded Functions (or, Programs from Outer Space)  
Author: Leonidas Fegaras Tim Sheard 
Address: 20000 N.W. Walker Road P.O. Box 91000 Portland, OR 97291-1000  
Affiliation: Department of Computer Science and Engineering Oregon Graduate Institute of Science Technology  
Abstract: We revisit the work of Paterson and of Meijer & Hutton, which describes how to construct catamorphisms for recursive datatype definitions that embed contravariant occurrences of the type being defined. Their construction requires, for each catamorphism, the definition of an anamor-phism that has an inverse-like relationship to that cata-morphism. We present an alternative construction, which replaces the stringent requirement that an inverse anamor-phism be defined for each catamorphism with a more lenient restriction. The resulting construction has a more efficient implementation than that of Paterson, Meijer, and Hutton and the relevant restriction can be enforced by a Hindley-Milner type inference algorithm. We provide numerous examples illustrating our method. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Bird and O. de Moor. </author> <title> Solving Optimisation Problems with Catamorphisms. </title> <booktitle> In Mathematics of Program Construction, </booktitle> <pages> pp 45-66. </pages> <publisher> Springer-Verlag, LNCS 669, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: Catamorphisms have also been used by functional programmers as a medium in which programs can be calculated from specifications [7, 6, 5] and as a good intermediate representation of programs that supports optimization <ref> [14, 3, 4, 1] </ref>. It is, thus, truly ironic that these functions apply only to first order datatypes. Until recently, it was not known how to express catamor-phisms for datatypes with embedded function types.
Reference: [2] <author> A. Church. </author> <title> A Formulation of the Simple Theory of Types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 5 </volume> <pages> 56-68, </pages> <year> 1940. </year>
Reference-contexts: j Appl of Term fi Term j Abs of Term ! Term For example, the lambda term (x:1 + x) 1 is represented by the Term construction Appl (Abs (fn x ) Appl (Succ,x)),Const 1) This term representation can be traced back to Church's seminal work on the lambda calculus <ref> [2] </ref>, in which universal quantification 8x:A is modeled by the addition of a constant and by writing (x:A).
Reference: [3] <author> L. Fegaras, T. Sheard, and T. Zhou. </author> <title> Improving Programs which Recurse over Multiple Inductive Structures. </title> <booktitle> In ACM SIGPLAN Workshop on Partial Evaluation and Semantics-Based Program Manipulation, Or-lando, Florida, </booktitle> <pages> pp 21-32, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Catamorphisms have also been used by functional programmers as a medium in which programs can be calculated from specifications [7, 6, 5] and as a good intermediate representation of programs that supports optimization <ref> [14, 3, 4, 1] </ref>. It is, thus, truly ironic that these functions apply only to first order datatypes. Until recently, it was not known how to express catamor-phisms for datatypes with embedded function types.
Reference: [4] <author> J. Launchbury and T. Sheard. </author> <title> Warm Fusion. </title> <booktitle> Seventh Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> La Jolla, California, </address> <pages> pp 314-323, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Catamorphisms have also been used by functional programmers as a medium in which programs can be calculated from specifications [7, 6, 5] and as a good intermediate representation of programs that supports optimization <ref> [14, 3, 4, 1] </ref>. It is, thus, truly ironic that these functions apply only to first order datatypes. Until recently, it was not known how to express catamor-phisms for datatypes with embedded function types.
Reference: [5] <author> G. Malcolm. </author> <title> Data Structures and Program Transformation. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 14 </volume> <pages> 255-279, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction Functional programmers often use catamorphisms (or fold functions) as an elegant means of expressing algorithms over algebraic datatypes. Catamorphisms have also been used by functional programmers as a medium in which programs can be calculated from specifications <ref> [7, 6, 5] </ref> and as a good intermediate representation of programs that supports optimization [14, 3, 4, 1]. It is, thus, truly ironic that these functions apply only to first order datatypes. Until recently, it was not known how to express catamor-phisms for datatypes with embedded function types.
Reference: [6] <author> G. Malcolm. </author> <title> Homomorphisms and Promotability. </title> <booktitle> In Mathematics of Program Construction, </booktitle> <pages> pp 335-347. </pages> <publisher> Springer-Verlag, LNCS 375, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Functional programmers often use catamorphisms (or fold functions) as an elegant means of expressing algorithms over algebraic datatypes. Catamorphisms have also been used by functional programmers as a medium in which programs can be calculated from specifications <ref> [7, 6, 5] </ref> and as a good intermediate representation of programs that supports optimization [14, 3, 4, 1]. It is, thus, truly ironic that these functions apply only to first order datatypes. Until recently, it was not known how to express catamor-phisms for datatypes with embedded function types.
Reference: [7] <author> E. Meijer, M. Fokkinga, and R. Paterson. </author> <title> Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire. </title> <booktitle> In Proceedings of the 5th ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> Cambridge, Massachusetts, </address> <pages> pp 124-144. </pages> <publisher> Springer-Verlag, LNCS 523, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Functional programmers often use catamorphisms (or fold functions) as an elegant means of expressing algorithms over algebraic datatypes. Catamorphisms have also been used by functional programmers as a medium in which programs can be calculated from specifications <ref> [7, 6, 5] </ref> and as a good intermediate representation of programs that supports optimization [14, 3, 4, 1]. It is, thus, truly ironic that these functions apply only to first order datatypes. Until recently, it was not known how to express catamor-phisms for datatypes with embedded function types.
Reference: [8] <author> E. Meijer and G. Hutton. </author> <title> Bananas in Space: Extending Fold and Unfold to Exponential Types. </title> <booktitle> Seventh Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> La Jolla, California, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: It is, thus, truly ironic that these functions apply only to first order datatypes. Until recently, it was not known how to express catamor-phisms for datatypes with embedded function types. The work by Paterson [10] and Meijer & Hutton <ref> [8] </ref> finally provided a method for doing so. While elegant and theoretically sound, their solution suffers from the disadvantage of being somewhat inefficient. This paper extends their technique using a simple trick that results to more efficient programs and turns out to also have several other interesting applications. <p> Representations like this have been avoided because of the difficulty of expressing certain kinds of computations. The Paterson/Meijer/Hutton Approach We now present an evaluator for terms in the style of Pa-terson [10], and Meijer & Hutton <ref> [8] </ref>. We use explicit recursion instead of catamorphisms to make it clear how it works and to illustrate the inefficiencies of this approach. Our approach, which improves this method, is described in detail in the next subsection. <p> But, as we will see next, in many cases, an approximate right inverse of print with constant time complexity is all that is needed. These dual mutually recursive definitions have been explored by Paterson [10] and Meijer & Hutton <ref> [8] </ref>. <p> For example, the following pro gram computes mapC (g), the map over Clist: cata Clist (inL y: inL y [] inR y: inR ((inL z: inL (((a; r): (g a; r)) z) Meijer and Hutton <ref> [8] </ref> define a catamorphism cata T in conjunction with its dual, the anamorphism ana T , as follows: cata T (in T x) = (E T (cata T ; ana T ) x) ana T x = in T (E T (ana T ; cata T ) ( x)) That is,
Reference: [9] <author> G. Nadathur and D. Miller. </author> <title> Higher-Order Logic Programming. </title> <editor> In D. Gabbay, C. Hogger, and A. Robinson, editors, </editor> <booktitle> Handbook of Logic in Artificial Intelligence and Logic Programming. </booktitle> <publisher> Oxford University Press, </publisher> <year> 1995. </year> <note> To appear. </note>
Reference-contexts: This representation is also similar to the higher-order abstract syntax representation of programs, formulas, and rules by Pfenning and Elliot [12], and is also related to the work of Nadathur and Miller <ref> [9] </ref> on higher-order logic programming. The datatype definition for Term differs from most in that in most lambda term representations, lambda abstractions are constructed by value constructors of type variablefi Term ! Term, and most representations also include constructors like Var of type variable ! Term.
Reference: [10] <author> R. Paterson. </author> <title> Control Structures from Types. </title> <note> Unpublished draft. Available by anonymous ftp from ftp-ala.doc.ic.ac.uk/pub/papers/R.Paterson/folds.dvi, </note> <year> 1994. </year>
Reference-contexts: It is, thus, truly ironic that these functions apply only to first order datatypes. Until recently, it was not known how to express catamor-phisms for datatypes with embedded function types. The work by Paterson <ref> [10] </ref> and Meijer & Hutton [8] finally provided a method for doing so. While elegant and theoretically sound, their solution suffers from the disadvantage of being somewhat inefficient. <p> Representations like this have been avoided because of the difficulty of expressing certain kinds of computations. The Paterson/Meijer/Hutton Approach We now present an evaluator for terms in the style of Pa-terson <ref> [10] </ref>, and Meijer & Hutton [8]. We use explicit recursion instead of catamorphisms to make it clear how it works and to illustrate the inefficiencies of this approach. Our approach, which improves this method, is described in detail in the next subsection. <p> The computational complexity of the parser is linear in the size of the input string. But, as we will see next, in many cases, an approximate right inverse of print with constant time complexity is all that is needed. These dual mutually recursive definitions have been explored by Paterson <ref> [10] </ref> and Meijer & Hutton [8].
Reference: [11] <author> L. Paulson. </author> <title> ML for the working programmer. </title> <publisher> Cam-bridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: We represent terms as structures with embedded functions in a manner similar to the higher-order abstract syntax representation of programs by Pfenning and Elliot [12] (all our examples are written in Standard ML (SML) <ref> [11] </ref>): datatype Term = Const of int j Succ j Appl of Term fi Term j Abs of Term ! Term For example, the lambda term (x:1 + x) 1 is represented by the Term construction Appl (Abs (fn x ) Appl (Succ,x)),Const 1) This term representation can be traced back <p> One way to construct infinite lists in SML is to use lazy lists (also known as streams), which use an explicit "thunk" for the tail of a list to obtain tail laziness <ref> [11] </ref>: datatype ff Clist = Nil j Cons of ff fi (unit ! ff Clist) For example, the list circ=0:1:circ is expressed as follows: let fun circ () = Cons (0,fn () ) Cons (1,circ)) in circ () end Even though many circular structures can be defined this way, many operations
Reference: [12] <author> F. Pfenning and C. Elliott. </author> <title> Higher-order Abstract Syntax. </title> <booktitle> Proceedings of the ACM SIGPLAN '88 Symposium on Language Design and Implementation, At-lanta, Georgia, </booktitle> <pages> pp 199-208, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: We represent terms as structures with embedded functions in a manner similar to the higher-order abstract syntax representation of programs by Pfenning and Elliot <ref> [12] </ref> (all our examples are written in Standard ML (SML) [11]): datatype Term = Const of int j Succ j Appl of Term fi Term j Abs of Term ! Term For example, the lambda term (x:1 + x) 1 is represented by the Term construction Appl (Abs (fn x ) <p> This representation is also similar to the higher-order abstract syntax representation of programs, formulas, and rules by Pfenning and Elliot <ref> [12] </ref>, and is also related to the work of Nadathur and Miller [9] on higher-order logic programming.
Reference: [13] <author> C. Reade. </author> <title> Elements of Functional Programming. </title> <publisher> Ad-dison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: The most common way to represent graphs in a functional language is to use a vector of adjacency lists. But, this approach is not really different from using pointers in a procedural language, since permits ad-hoc constructions and manipulations of graphs. In <ref> [13] </ref> a graph type is defined as: datatype ff graph = Graph of ff ! ff list Here a graph consists of a function that computes the successors of each node. This definition requires special care while programming to guarantee program termination.
Reference: [14] <author> T. Sheard and L. Fegaras. </author> <title> A Fold for All Seasons. </title> <booktitle> Sixth Conference on Functional Programming Languages and Computer Architecture, Copenhagen, Denmark, </booktitle> <pages> pp 233-242, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Catamorphisms have also been used by functional programmers as a medium in which programs can be calculated from specifications [7, 6, 5] and as a good intermediate representation of programs that supports optimization <ref> [14, 3, 4, 1] </ref>. It is, thus, truly ironic that these functions apply only to first order datatypes. Until recently, it was not known how to express catamor-phisms for datatypes with embedded function types.
Reference: [15] <editor> P. Wadler. </editor> <booktitle> Theorems for Free! Fourth Conference on Functional Programming Languages and Computer Architecture, </booktitle> <institution> Imperial College, </institution> <address> London, </address> <month> September </month> <year> 1989. </year> <month> 11 </month>
Reference-contexts: The problem appears when we go beyond the typical encoding of terms. 2.1.2 The Parametricity Theorem As another example of representing terms by structures with embedded functions, we construct the parametricity theorem for a polymorphic function. To understand this section, the reader must be familiar with Wadler's theorems-for-free paper <ref> [15] </ref>. Any function f of type t satisfies a parametricity theorem, which is derived directly from the type t . For first-order functions, this theorem states that any strict polymorphic function is a natural transformation.
References-found: 15

