URL: ftp://ftp.win.tue.nl/pub/techreports/michelr/ComputingScienceReports97-11.ps.Z
Refering-URL: http://www.win.tue.nl/cs/fm/sjouke/publications.html
Root-URL: http://www.win.tue.nl
Email: fengels|sjouke|michelrg@win.tue.nl  
Title: A Hierarchy of Communication Models for Message Sequence Charts  
Author: A. Engels, S. Mauw, M.A. Reniers, 
Address: P.O. Box 513, 5600 MB Eindhoven, The Netherlands  
Affiliation: Department of Mathematics and Computing Science, Eindhoven University of Technology,  
Abstract: In a Message Sequence Chart (MSC) the dynamical behaviour of a number of cooperating processes is depicted. An MSC defines a partial order on the communication events between these processes. This order determines the physical architecture needed for implementing the specified behaviour, such as a FIFO buffer between each of the processes. In a systematic way, we define 50 communication models for MSC and we define what it means for an MSC to be implementable by such a model. Some of these models turn out to be equivalent, in the sense that they implement the same class of MSCs. After analysing the notion of implementability, only ten models remain, for which we develop a hierarchy. 
Abstract-found: 1
Intro-found: 1
Reference: [AHP96] <author> R. Alur, G. J. Holzmann, and D. Peled. </author> <title> An analyzer for Message Sequence Charts. </title> <booktitle> Software Concepts and Tools, </booktitle> <volume> 17(2) </volume> <pages> 70-77, </pages> <year> 1996. </year>
Reference-contexts: In literature several ways to define the semantics of MSC are proposed [MR94a, LL95, GGR93]. The process algebra approach [MR94b] has been standardised as Annex B to ITU recommendation Z.120 [IT95]. The partial order representation <ref> [AHP96] </ref> used in this paper coincides with most of these proposals for the class of Basic Message Sequence Charts. We also define the traces expressed by an MSC. 2.1 Basics The MSCs studied here consist of a collection of instances (or processes) with a number of messages attached to them. <p> have both ?m &lt; io ?m 0 (because !m &lt; msc k !m 0 ) and ?m 0 &lt; io ?m (because ?m 0 &lt; msc ?m), so the MSC k is not inst w -implementable. ffi Another paper in which different communication models for MSC have been studied, is <ref> [AHP96] </ref>.
Reference: [BAL97] <author> H. Ben-Abdallah and S. Leue. </author> <title> Syntactic detection of process divergence and non-local choice in Message Sequence Charts. </title> <editor> In Ed Brinksma, editor, </editor> <booktitle> Tools and Algorithms for the Construction and Analysis of Systems, number 1217 in Lecture Notes on Computer Science, </booktitle> <pages> pages 259-274. </pages> <publisher> Springer Verlag, </publisher> <year> 1997. </year>
Reference-contexts: It may be the case that &lt; msc does not define a partial order, due to cyclic dependencies of the events. Such an MSC is said to contain a deadlock, or is called inconsistent. In Z.120 [IT96] inconsistent MSCs are considered illegal, and in <ref> [BAL97] </ref> an algorithm is described for determining whether a given MSC is consistent.
Reference: [CBMT96] <author> B. Charron-Bost, F. Mattern, and G. Tel. </author> <title> Synchronous, asynchronous and causally ordered communication. </title> <journal> Distributed Computing, </journal> <volume> 9(4) </volume> <pages> 173-191, </pages> <year> 1996. </year>
Reference-contexts: Second, if a randomly chosen trace t is pair-implementable, then k is pair w - implementable, and thus also pair s -implementable. 10. See Lemma 27. ffi 7 Comparison In this section we will compare our conclusions with those found in related literature. In <ref> [CBMT96] </ref> Charron-Bost et al. discuss three different implementations for MSC-like diagrams: RSC (Realizable with Synchronous Communication), CO (Causally Ordered) and FIFO. They also define A (asynchronous), but this is (just like msg in our hierarchy) used to denote the set of all allowable diagrams, not some subset. <p> They also define A (asynchronous), but this is (just like msg in our hierarchy) used to denote the set of all allowable diagrams, not some subset. They find that there is a strict ordering RSC ae CO ae FIFO ae A. Theorem 40 The implementations that in <ref> [CBMT96] </ref> are named RSC and FIFO are equal to the implementations nobuf w , and pair. The implementation CO is strictly between the implementations inst w and pair. Proof * RSC-nobuf w : Definition 3.6 in [CBMT96] states, after translating it into our terminology, that a computation is RSC if and <p> Theorem 40 The implementations that in <ref> [CBMT96] </ref> are named RSC and FIFO are equal to the implementations nobuf w , and pair. The implementation CO is strictly between the implementations inst w and pair. Proof * RSC-nobuf w : Definition 3.6 in [CBMT96] states, after translating it into our terminology, that a computation is RSC if and only if there is a trace t for which for each m 2 M we have that the set fx 2 C j!m &lt; trace t x &lt; trace t ?mg is empty, which is equal <p> t for which for each m 2 M we have that the set fx 2 C j!m &lt; trace t x &lt; trace t ?mg is empty, which is equal to the definition that is obtained by combining Lemma 15 and Definition 19. * FIFO-pair: The definition for FIFO in <ref> [CBMT96] </ref> (Definition 3.3) translates to (by rewriting the terminology of Charron-Bost et al. in ours): !m &lt; msc k !m 0 ^ from.m/ D from.m 0 / ^ t o.m/ D t o.m 0 / )?m &lt; msc k ?m 0 , or from.m/ D from.m 0 / ^ to.m/ D <p> / ) .?m &lt; msc k ?m 0 _?m 0 &lt; msc k ?m/ and from.m/ D from.m 0 / ) .!m &lt; msc k !m 0 _!m 0 &lt; msc * CO: That the class of pair-implementable MSCs is strictly greater than that of CO-implementable MSCs is shown in <ref> [CBMT96] </ref>. Remains to be shown that the class of CO-implementable MSCs is strictly greater than that of inst w -implementable MSCs. The definition of CO as given in [CBMT96] (definition 3.4) can be translated to t o.m/ D t o.m 0 /^!m &lt; msc k !m 0 )?m &lt; msc ?m <p> 0 &lt; msc * CO: That the class of pair-implementable MSCs is strictly greater than that of CO-implementable MSCs is shown in <ref> [CBMT96] </ref>. Remains to be shown that the class of CO-implementable MSCs is strictly greater than that of inst w -implementable MSCs. The definition of CO as given in [CBMT96] (definition 3.4) can be translated to t o.m/ D t o.m 0 /^!m &lt; msc k !m 0 )?m &lt; msc ?m 0 . An example of an MSC that is CO-implementable, but not inst w -implementable, is the MSC 'lobster' in Figure 13.
Reference: [GGR93] <author> J. Grabowski, P. Graubmann, and E. Rudolph. </author> <title> Towards a Petri net based semantics definition for Message Sequence Charts. </title> <editor> In O. Frgemand and A. Sarma, editors, </editor> <title> SDL'93 Using Objects, </title> <booktitle> Proceedings of the Sixth SDL Forum, </booktitle> <pages> pages 179-190. </pages> <publisher> North-Holland, </publisher> <year> 1993. </year>
Reference-contexts: We use a partial order on the events of an MSC to express the semantics. In literature several ways to define the semantics of MSC are proposed <ref> [MR94a, LL95, GGR93] </ref>. The process algebra approach [MR94b] has been standardised as Annex B to ITU recommendation Z.120 [IT95]. The partial order representation [AHP96] used in this paper coincides with most of these proposals for the class of Basic Message Sequence Charts.
Reference: [IT95] <author> ITU-TS. </author> <title> ITU-TS Recommendation Z.120 Annex B: Algebraic semantics of Message Sequence Charts. </title> <address> ITU-TS, Geneva, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: We use a partial order on the events of an MSC to express the semantics. In literature several ways to define the semantics of MSC are proposed [MR94a, LL95, GGR93]. The process algebra approach [MR94b] has been standardised as Annex B to ITU recommendation Z.120 <ref> [IT95] </ref>. The partial order representation [AHP96] used in this paper coincides with most of these proposals for the class of Basic Message Sequence Charts.
Reference: [IT96] <author> ITU-TS. </author> <title> ITU-TS Draft Recommendation Z.120: Message Sequence Chart 1996 (MSC96). </title> <address> ITU-TS, Geneva, </address> <year> 1996. </year>
Reference-contexts: One of the most popular classes of formalisms for this purpose is the class of sequence charts. Of those, Message Sequence Chart (MSC) has been standardised by the International Telecommunication Union (ITU) as Recommendation Z.120 <ref> [IT96] </ref>. Two important reasons for the popularity of MSC are that they provide a clear intuition to both engineers and designers and at the same time posses a well-defined semantics. <p> Depending on the particular dialect of the MSC language, one can assign different classes of events to an MSC. For example, in Interworkings [MWW93] every message is considered to be a single event. There is no buffering, and thus communication is synchronous. In MSC <ref> [IT96] </ref>, messages are divided into two events, the output and the input of the message. The output of message m is denoted by !m and the input by ?m. The only assumption about the implemen 2 tation of communication is that an output precedes its corresponding input. <p> It may be the case that &lt; msc does not define a partial order, due to cyclic dependencies of the events. Such an MSC is said to contain a deadlock, or is called inconsistent. In Z.120 <ref> [IT96] </ref> inconsistent MSCs are considered illegal, and in [BAL97] an algorithm is described for determining whether a given MSC is consistent.
Reference: [LL95] <author> P.B. Ladkin and S. Leue. </author> <title> Interpreting message flow graphs. </title> <journal> Formal Aspects of Computing, </journal> <volume> 7(5) </volume> <pages> 473-509, </pages> <year> 1995. </year>
Reference-contexts: We use a partial order on the events of an MSC to express the semantics. In literature several ways to define the semantics of MSC are proposed <ref> [MR94a, LL95, GGR93] </ref>. The process algebra approach [MR94b] has been standardised as Annex B to ITU recommendation Z.120 [IT95]. The partial order representation [AHP96] used in this paper coincides with most of these proposals for the class of Basic Message Sequence Charts.
Reference: [MR94a] <author> S. Mauw and M. A. Reniers. </author> <title> An algebraic semantics of Basic Message Sequence Charts. </title> <journal> The Computer Journal, </journal> <volume> 37(4) </volume> <pages> 269-277, </pages> <year> 1994. </year>
Reference-contexts: We use a partial order on the events of an MSC to express the semantics. In literature several ways to define the semantics of MSC are proposed <ref> [MR94a, LL95, GGR93] </ref>. The process algebra approach [MR94b] has been standardised as Annex B to ITU recommendation Z.120 [IT95]. The partial order representation [AHP96] used in this paper coincides with most of these proposals for the class of Basic Message Sequence Charts.
Reference: [MR94b] <author> S. Mauw and M.A. Reniers. </author> <title> An algebraic semantics of Message Sequence Charts. </title> <type> Technical Report CSN 94/23, </type> <institution> Eindhoven University of Technology, Department of Computing Science, Eindhoven, </institution> <year> 1994. </year>
Reference-contexts: We use a partial order on the events of an MSC to express the semantics. In literature several ways to define the semantics of MSC are proposed [MR94a, LL95, GGR93]. The process algebra approach <ref> [MR94b] </ref> has been standardised as Annex B to ITU recommendation Z.120 [IT95]. The partial order representation [AHP96] used in this paper coincides with most of these proposals for the class of Basic Message Sequence Charts.
Reference: [MWW93] <author> S. Mauw, M. van Wijk, and T. Winter. </author> <title> A formal semantics of synchronous Interworkings. </title> <editor> In O. Frgemand and A. Sarma, editors, </editor> <title> SDL'93 Using Objects, </title> <booktitle> Proceedings of the Sixth SDL Forum, </booktitle> <pages> pages 167-178. </pages> <publisher> North-Holland, </publisher> <year> 1993. </year> <month> 30 </month>
Reference-contexts: Depending on the particular dialect of the MSC language, one can assign different classes of events to an MSC. For example, in Interworkings <ref> [MWW93] </ref> every message is considered to be a single event. There is no buffering, and thus communication is synchronous. In MSC [IT96], messages are divided into two events, the output and the input of the message. The output of message m is denoted by !m and the input by ?m. <p> Finally, our assumption of infinite FIFO buffers may be relaxed, allowing other types of buffers and buffers with finite capacity. The results obtained in this paper form a solid base for several applications. First, they allow us to discuss the relation between different variants of MSC, such as Interworkings <ref> [MWW93] </ref>. Interwork-ings presuppose a synchronous communication mechanism. An Interworking can be considered as the restriction of the semantics of an MSC to only the nobuf-implementable traces.
References-found: 10

