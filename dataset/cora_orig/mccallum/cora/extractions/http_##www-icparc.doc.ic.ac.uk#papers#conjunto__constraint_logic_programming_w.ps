URL: http://www-icparc.doc.ic.ac.uk/papers/conjunto:_constraint_logic_programming_w.ps
Refering-URL: http://www-icparc.doc.ic.ac.uk/papers.html
Root-URL: 
Email: carmen@ecrc.de  
Title: Conjunto: Constraint Logic Programming with Finite Set Domains  
Author: Carmen Gervet 
Address: Arabellastrae 17, D-81925 Munich, Germany  
Affiliation: ECRC  
Abstract: Combinatorial problems involving sets and relations are currently tackled by integer programming and expressed with vectors or matrices of 0-1 variables. This is efficient but not flexible and unnatural in problem formulation. Toward a natural programming of combinatorial problems based on sets, graphs or relations, we define a new CLP language with set constraints. This language Conjunto 1 aims at combining the declarative aspect of Prolog with the efficiency of constraint solving techniques. We propose to constrain a set variable to range over finite set domains specified by lower and upper bounds for set inclusion. Conjunto is based on the inclusion and disjointness constraints applied to set expressions which comprise the union, intersection and difference symbols. The main contribution herein is the constraint handler which performs constraint propagation by applying consistency techniques over set constraints. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alexander Aiken and Edward L. Wimmers. </author> <title> Solving Systems of Set Constraints. </title> <booktitle> In IEEE Symposium on Logic in Computer Science, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Various systems of set constraints have been defined for purposes such as ax-iomatizing a set theory in flogg [4], prototyping combinatorial problems with sets, multisets and sequences in CLPS [13], manipulating strings in CLP ( fl ) [16], analyzing programs [7] <ref> [1] </ref> [2] among others. According to the objectives aimed at, each of these languages proposes a constraint solver for a class of set constraints over a computation domain. <p> The exhaustive set of possible instances of s is computed. As soon as the domain of one x i is modified, the domain of s is recomputed. 2.2 Systems of set constraints A related line of work is program analysis systems [7] <ref> [1] </ref> [2] among others. They handle a larger class of sets (infinite sets) than Conjunto, flogg or CLPS. The set variables are introduced to model a program. The different resolution algorithms are based on transformation algorithms. <p> The set variables are introduced to model a program. The different resolution algorithms are based on transformation algorithms. These transformations preserve consistency either by computing a least model [7] which does not preserve all solutions or by computing a finite set of systems in solved form <ref> [1] </ref>. [2] demonstrated that the latter algorithm is solvable in non-deterministic exponential time. 3 Representing sets by lower and upper bounds The previous section reflects that to embed sets in a CLP language, there are two alternatives: (i) to define a set constructor which allows to build a set term ,
Reference: [2] <author> L. Bachmair, H. Ganzinger, and U. Waldmann. </author> <title> Set Constraints are the Monadic Class. </title> <booktitle> In Proceedings of the LICS'93, </booktitle> <year> 1993. </year>
Reference-contexts: 1 Introduction Various systems of set constraints have been defined for purposes such as ax-iomatizing a set theory in flogg [4], prototyping combinatorial problems with sets, multisets and sequences in CLPS [13], manipulating strings in CLP ( fl ) [16], analyzing programs [7] [1] <ref> [2] </ref> among others. According to the objectives aimed at, each of these languages proposes a constraint solver for a class of set constraints over a computation domain. <p> The exhaustive set of possible instances of s is computed. As soon as the domain of one x i is modified, the domain of s is recomputed. 2.2 Systems of set constraints A related line of work is program analysis systems [7] [1] <ref> [2] </ref> among others. They handle a larger class of sets (infinite sets) than Conjunto, flogg or CLPS. The set variables are introduced to model a program. The different resolution algorithms are based on transformation algorithms. <p> The set variables are introduced to model a program. The different resolution algorithms are based on transformation algorithms. These transformations preserve consistency either by computing a least model [7] which does not preserve all solutions or by computing a finite set of systems in solved form [1]. <ref> [2] </ref> demonstrated that the latter algorithm is solvable in non-deterministic exponential time. 3 Representing sets by lower and upper bounds The previous section reflects that to embed sets in a CLP language, there are two alternatives: (i) to define a set constructor which allows to build a set term , (ii)
Reference: [3] <author> M. Dincbas, H. Simonis, and P. Van Hentenryck et al. </author> <title> The Constraint Logic Programming Language CHIP. In FGCS, </title> <address> Japan, </address> <month> Aug. </month> <year> 1988. </year>
Reference-contexts: In Conjunto, we propose a specific case of this alternative, by constraining a set variable to belong to a finite set domain. The notion of finite domain has first been used and defined in the constraint logic programming language CHIP <ref> [3] </ref>. Such a computation domain has proved its efficiency in the CLP framework by a powerful use of consistency checking techniques. In Conjunto, a set is an extensional set which contains only Herbrand terms (no variables and no sets). We use the word ground to define it.
Reference: [4] <author> A. Dovier and G. Rossi. </author> <title> Embedding Extensional Finite Sets in CLP. </title> <booktitle> In ILPS'93, </booktitle> <year> 1993. </year>
Reference-contexts: 1 Introduction Various systems of set constraints have been defined for purposes such as ax-iomatizing a set theory in flogg <ref> [4] </ref>, prototyping combinatorial problems with sets, multisets and sequences in CLPS [13], manipulating strings in CLP ( fl ) [16], analyzing programs [7] [1] [2] among others. <p> CLP ( fl ) constraints are of the form A in (X."ab".Y) which states that any string attached to variable A must contain the sub-string ab. A scheduling strategy for selecting constraints ensures termination of the satisfiability procedure. flogg <ref> [4] </ref> is based on an axiomatized set theory where set terms are constructed using the interpreted functor with, e.g. ; with x with (; with y with z) = ffz,yg,xg. <p> The solver schedules in a data-driven way, the set constraints checked through consistency techniques. 5.1 Preliminary definitions First let us consider a constraint graph G to represent a constraint satisfaction problem. The approach is the usual one, that is each node s i of the 4 In flogg <ref> [4] </ref> they do not need to distinguish these constraints from as they can write x 2 S $ fxg S.
Reference: [5] <author> M.R. Garey and D. S. Johnson. </author> <title> Computers and intractability, A guide to the theory of NP-completeness. </title> <editor> Victor Klee, </editor> <year> 1979. </year> <pages> 124-130. </pages>
Reference-contexts: Problem description Bin packing problems belong to the class of set partitioning problems <ref> [5] </ref>. A multiset of n integers is given fw 1 ; :::; w n g and specifies the weight elements to partition. Another integer W max is given and represents the weight capacity.
Reference: [6] <author> G. Gierz and K.H. Hofman et al. </author> <title> A Compendium of Continuous Lattices. </title> <publisher> Springer Verlag, </publisher> <address> Berlin Heidelberg New York, </address> <year> 1980. </year> <note> Chapter 0. </note>
Reference-contexts: A set expression is composed of set domain variables together with set operator symbols. The domain of a set expression is also a finite lattice under inclusion <ref> [6] </ref>. It could be represented by computing its exact bounds at an exponential cost in the size of the largest upper bound invoked. But for efficiency reasons, it is represented in Conjunto by approximating its bounds in terms of the domain bounds of the set variables.
Reference: [7] <author> N. Heintze and J. Jaffar. </author> <title> A Decision Procedure for a Class of Set Constraints. </title> <booktitle> In Proceedings of the Sixth Annual IEEE Symposium on Logic in CS, </booktitle> <pages> pages 300-309, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Various systems of set constraints have been defined for purposes such as ax-iomatizing a set theory in flogg [4], prototyping combinatorial problems with sets, multisets and sequences in CLPS [13], manipulating strings in CLP ( fl ) [16], analyzing programs <ref> [7] </ref> [1] [2] among others. According to the objectives aimed at, each of these languages proposes a constraint solver for a class of set constraints over a computation domain. <p> The exhaustive set of possible instances of s is computed. As soon as the domain of one x i is modified, the domain of s is recomputed. 2.2 Systems of set constraints A related line of work is program analysis systems <ref> [7] </ref> [1] [2] among others. They handle a larger class of sets (infinite sets) than Conjunto, flogg or CLPS. The set variables are introduced to model a program. The different resolution algorithms are based on transformation algorithms. These transformations preserve consistency either by computing a least model [7] which does not <p> program analysis systems <ref> [7] </ref> [1] [2] among others. They handle a larger class of sets (infinite sets) than Conjunto, flogg or CLPS. The set variables are introduced to model a program. The different resolution algorithms are based on transformation algorithms. These transformations preserve consistency either by computing a least model [7] which does not preserve all solutions or by computing a finite set of systems in solved form [1]. [2] demonstrated that the latter algorithm is solvable in non-deterministic exponential time. 3 Representing sets by lower and upper bounds The previous section reflects that to embed sets in a CLP language,
Reference: [8] <author> P. Van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. Logic Programming Series. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, </address> <year> 1989. </year>
Reference-contexts: The CLPS language is founded on the set notion of sets of finite depth over Herbrand terms (simple sets are sets of depth one). The satisfaction of constraints is performed using consistency checking techniques <ref> [8] </ref> over set elements defined as domain variables.
Reference: [9] <author> P. Van Hentenryck and Y. Deville. </author> <title> Operational Semantics of Constraint Logic Programming over Finite Domains. </title> <booktitle> In Proceedings of PLILP'91, </booktitle> <pages> pages 396-406, </pages> <address> Passau, Germany, </address> <month> Aug. </month> <year> 1991. </year>
Reference-contexts: P 2 is the set of basic arithmetic constraints defined in <ref> [9] </ref> (fax = by + c; ax 6= c; ax by + c; ax by + c; x 2 fa 1 ; ::; a n gg where the a,b,c,a 1 , a n are positive integers and x,y are domain variables). <p> It concerns the set of fX 2 S; X =2 Sg 4 constraints. 4.2.4 Admissible system of constraints As an adaptation of <ref> [9] </ref>, an admissible system of constraints is a system of constraints where every set constrained variable occurs in some set domain constraints. Set constraints are only considered in a given context (where domains are attached to the variables). <p> This assumption simplifies the algorithm description but no restriction is actually imposed on real Conjunto programs. The definitions of node, arc consistency [14] and solved form <ref> [9] </ref> are kept and recalled hereafter. <p> The membership and nonmembership constraints are delayed (flounder notion in <ref> [9] </ref>) until they become unary constraints. Algorithm The solver acts in a data driven way using a relation between states.
Reference: [10] <author> P. Van Hentenryck, Y. Deville, and C.-M. Teng. </author> <title> A generic arc-consistency algorithm and its specializations. </title> <journal> Artificial Intelligence, </journal> <volume> 57 </volume> <pages> 291-321, </pages> <year> 1992. </year>
Reference-contexts: The existing arc consistency algorithms can not be simply adapted to check consistency of set relation constraints over set domain variables. The reason is that these algorithms are based on a domain reasoning (except for AC-5 over arithmetic constraints <ref> [10] </ref>). That is, an arc (i,j) is consistent for each element of an integer domain D i . This reasoning takes polynomial time in the length of the largest domain. <p> In the case of set domains, this reasoning would lead to an exponential number of tests in the largest upper bound length. For efficiency reasons, this reasoning is replaced in Conjunto by a reasoning on the domain bounds. As formally introduced in <ref> [10] </ref>, the existing arc consistency algorithms manipulate a list or queue of elements to reconsider. Once a variable domain j has been modified, some constraints need to be checked again. In terms of arcs, this means that some arcs (i; j) need to be reconsidered.
Reference: [11] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 111-119, </pages> <address> Munich, Germany, </address> <year> 1987. </year>
Reference-contexts: Set constraints are only considered in a given context (where domains are attached to the variables). Having defined the foundations of Conjunto we need to define its operational semantics comprising the consistency algorithms. 5 Operational semantics for set constraints Conjunto does not fit to the standard CLP scheme <ref> [11] </ref> as the operational semantics is based on the notions of postponing some constraints and propagating other constraints whose satisfiability is not always provable.
Reference: [12] <author> J. L. Lauriere. </author> <title> A Language and a Program for Stating and Solving Combinatorial Problems. </title> <journal> Artificial Intelligence, </journal> <volume> 10 </volume> <pages> 29-127, </pages> <year> 1978. </year>
Reference-contexts: But from our experiment set constraints are not expressive enough to tackle the problems on graphs. In fact, our objectives are not limited to the definition of set domains but also aim at describing relations in the same way. Lauriere first addressed this issue in his seminal language ALICE <ref> [12] </ref>. In Conjunto, a finite relation domain constrains a relation variable R S 1 fi S 2 where S 1 and S 2 are respectively the domain and the range of R (ground sets). A graph is a specific relation where the domain and range coincide.
Reference: [13] <author> B. Legeard and E. Legros. </author> <title> Short overview of the CLPS System. </title> <booktitle> In Proceedings of PLILP'91, </booktitle> <address> Passau, Germany, </address> <month> Aug. </month> <year> 1991. </year> <booktitle> 3rd International Symposium on Programming Language Implementation and Logic Programming. </booktitle>
Reference-contexts: 1 Introduction Various systems of set constraints have been defined for purposes such as ax-iomatizing a set theory in flogg [4], prototyping combinatorial problems with sets, multisets and sequences in CLPS <ref> [13] </ref>, manipulating strings in CLP ( fl ) [16], analyzing programs [7] [1] [2] among others. According to the objectives aimed at, each of these languages proposes a constraint solver for a class of set constraints over a computation domain.
Reference: [14] <author> A. K. Mackworth. </author> <title> Consistency in networks of relations. </title> <journal> Artificial Intelligence, </journal> <year> 1977. </year>
Reference-contexts: This assumption simplifies the algorithm description but no restriction is actually imposed on real Conjunto programs. The definitions of node, arc consistency <ref> [14] </ref> and solved form [9] are kept and recalled hereafter.
Reference: [15] <author> Z. Pawlak. </author> <title> Rough Sets: Theoretical Aspects of Reasoning about Data. D: System theory, Knowledge engineering and Problem solving. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year>
Reference-contexts: Y lub (Y ) 2. lub (Y [ Z) = lub (Y ) [ lub (Z) 4. lub (Y " Z) lub (Y ) " lub (Z) 6. lub (Y n Z) = lub (Y ) n glb (Z) Proof The proof of the first five properties is given in <ref> [15] </ref>. <p> In <ref> [15] </ref> they use this notion of bounds as knowledge approximation on behalf of the whole knowledge base. In Conjunto, these properties constitute a very important issue on a constraint propagation viewpoint.
Reference: [16] <author> C. Walinsky. </author> <title> CLP( fl ): Constraint Logic Programming with Regular Sets. </title> <booktitle> In ICLP'89, </booktitle> <pages> pages 181-190, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction Various systems of set constraints have been defined for purposes such as ax-iomatizing a set theory in flogg [4], prototyping combinatorial problems with sets, multisets and sequences in CLPS [13], manipulating strings in CLP ( fl ) <ref> [16] </ref>, analyzing programs [7] [1] [2] among others. According to the objectives aimed at, each of these languages proposes a constraint solver for a class of set constraints over a computation domain. <p> Directions for future works are mentioned in the conclusion. 2 Related Work 2.1 Sets in CLP Several approaches have been tackled in the recent years to embed sets in the CLP framework. CLP ( fl ) <ref> [16] </ref> (string handling) represents an instance of the CLP scheme in the computation domain of regular sets which are finite sets composed from finite strings.
References-found: 16

