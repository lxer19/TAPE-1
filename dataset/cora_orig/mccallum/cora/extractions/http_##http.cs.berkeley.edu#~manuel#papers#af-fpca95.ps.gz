URL: http://http.cs.berkeley.edu/~manuel/papers/af-fpca95.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~manuel/publications.html
Root-URL: 
Email: faiken,manuelg@cs.berkeley.edu  
Title: Dynamic Typing and Subtype Inference  
Author: Alexander Aiken Manuel F ahndrich 
Address: Berkeley, CA 94720-1776  
Affiliation: Computer Science Division University of California, Berkeley  
Abstract: Dynamic typing is a program analysis targeted at removing runtime tagging and untagging operations from programs written in dynamically typed languages. This paper compares dynamic typing with a subtyping system based on set constraints. The purpose is both to make precise the relationship between two superficially unrelated type systems and to illustrate how the advantages of dynamic typing and subtype inference can be combined. The central result is a theorem showing that a typing discipline at least as powerful as dynamic typing can be expressed using set constraints. 
Abstract-found: 1
Intro-found: 1
Reference: [Aik94] <author> A. Aiken. </author> <title> Set constraints: Results, applications, and future directions. </title> <booktitle> In Second Workshop on the Principles and Practice of Constraint Programming, </booktitle> <pages> pages 171-179, </pages> <address> Orcas Island, Washingtion, </address> <month> May </month> <year> 1994. </year> <note> Springer-Verlag LNCS no. 874. </note>
Reference-contexts: It is our thesis that many constraint-based analyses can be expressed using a particular constraint theory known as set constraints. Set constraints are a simple, general, and well-studied theory that is powerful enough to express many program analyses <ref> [HJ90, AW92, Hei92, Aik94] </ref>. In testing our thesis on a variety of program analyses, it became apparent that dynamic typing is in some ways fundamentally different from other examples of constraint theories used in program analysis.
Reference: [AM91] <author> A. Aiken and B. Murphy. </author> <title> Static type inference in a dynamically typed language. </title> <booktitle> In Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 279-290, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Coercions from type Dynamic were introduced in a subsequent paper [Tha90]. A large number of analysis algorithms for dynamically typed languages have been proposed in recent years <ref> [Gom90, AM91, CF91, Hen92b, WH92, WC94] </ref>. With the exception of the works of Henglein, Thatte, and Gomard, it is fair to characterize all of these as (inclusion-based) subtyping systems; none treat tag inference.
Reference: [AW92] <author> A. Aiken and E. Wimmers. </author> <title> Solving systems of set constraints. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <pages> pages 329-340, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: It is our thesis that many constraint-based analyses can be expressed using a particular constraint theory known as set constraints. Set constraints are a simple, general, and well-studied theory that is powerful enough to express many program analyses <ref> [HJ90, AW92, Hei92, Aik94] </ref>. In testing our thesis on a variety of program analyses, it became apparent that dynamic typing is in some ways fundamentally different from other examples of constraint theories used in program analysis. <p> These constraint resolution rules are essentially those of [MR85, Hei92, AW93] specialized to our application. The soundness of these rules can be proven using standard techniques (e.g., see <ref> [AW92, AW93] </ref>). In an arbitrary variable. Rules 10 and 11 of Figure 6 appear non-constructive, but are actually easy to implement.
Reference: [AW93] <author> A. Aiken and E. Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Proceedings of the 1993 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 31-41, </pages> <address> Copenhagen, Den-mark, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Dynamic typing also can be modified directly to avoid the extra tagging; the resulting system is no longer dynamic typing and is closer than dynamic typing to the system we present. 2 Known results on set constraints also admit immediate generalizations in other, orthogonal ways, including adding polymorphic types <ref> [AW93] </ref> and analysis of conditional branches [AWL94]. The formal development proceeds as follows. Section 2 presents a type inference system for dynamic typing. This system proves facts of the form A ` D e : t Section 3 presents an alternative formulation of dynamic typing using set constraints. <p> For brevity, we skip the development of ideal models needed to formalize types as sets of values; the construction is well-known (e.g., see <ref> [MPS84, AW93] </ref>). We work with systems of set constraints of the following forms: X Y Q 6= tag [ notag T 6= 0 ) Q R Here X, Y stand for any expressions drawn from the grammar above. <p> To discover which completions are possible, it is necessary to solve the constraints. Figure 6 gives a set of rewrite rules that, when applied until closure (until no new constraints can be generated), reduce a system of constraints to solved form. These constraint resolution rules are essentially those of <ref> [MR85, Hei92, AW93] </ref> specialized to our application. The soundness of these rules can be proven using standard techniques (e.g., see [AW92, AW93]). In an arbitrary variable. Rules 10 and 11 of Figure 6 appear non-constructive, but are actually easy to implement. <p> These constraint resolution rules are essentially those of [MR85, Hei92, AW93] specialized to our application. The soundness of these rules can be proven using standard techniques (e.g., see <ref> [AW92, AW93] </ref>). In an arbitrary variable. Rules 10 and 11 of Figure 6 appear non-constructive, but are actually easy to implement.
Reference: [AWL94] <author> A. Aiken, E. Wimmers, </author> <title> and T.K. Lakshman. Soft typing with conditional types. </title> <booktitle> In Twenty-First Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 163-173, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: The purpose and results of our study are two-fold. First, while dynamic typing is a very interesting system, it cannot remove as many type checks as other recently proposed algorithms based on inclusion subtyping <ref> [AWL94, WC94] </ref>. By inclusion subtyping, we mean systems where type t 1 is a subtype of t 2 if t 2 includes every value of t 1 ; we will refer to this simply as subtyping. <p> modified directly to avoid the extra tagging; the resulting system is no longer dynamic typing and is closer than dynamic typing to the system we present. 2 Known results on set constraints also admit immediate generalizations in other, orthogonal ways, including adding polymorphic types [AW93] and analysis of conditional branches <ref> [AWL94] </ref>. The formal development proceeds as follows. Section 2 presents a type inference system for dynamic typing. This system proves facts of the form A ` D e : t Section 3 presents an alternative formulation of dynamic typing using set constraints. <p> For dynamic typing, where all components of tagged values are tagged, it is possible to modify the inference rules and the constraint resolution algorithm to handle coercions at arbitrary points. 6.3 Polymorphism The semantics of polymorphic types based on set constraints has been developed in <ref> [AWL94] </ref>. A polymorphic type has the form 8fl 1 ; : : : ; fl n :( where S). Intuitively, this type expresses bounded quantification, with the set of constraints S acting as bounds on the quantified variables. <p> More formally, the meaning is the intersection of all types s () where s is a solution of the constraints S for some choice of fl 1 ; : : : ; fl n . Polymorphism in the style of <ref> [AWL94] </ref> can be added to our system without modifying any other aspect. When tag variables are quantified, the meaning of coercions is parameterized in the type. <p> Thus, the same technique should integrate easily into other systems for analyzing dynamically typed programs. The system in <ref> [AWL94] </ref> is probably the most expressive and accurate such inference system known. Besides polymorphism, the most significant difference between [AWL94] and the system we have described is that types in [AWL94] can express control-flow through runtime tests. <p> Thus, the same technique should integrate easily into other systems for analyzing dynamically typed programs. The system in <ref> [AWL94] </ref> is probably the most expressive and accurate such inference system known. Besides polymorphism, the most significant difference between [AWL94] and the system we have described is that types in [AWL94] can express control-flow through runtime tests. <p> Thus, the same technique should integrate easily into other systems for analyzing dynamically typed programs. The system in <ref> [AWL94] </ref> is probably the most expressive and accurate such inference system known. Besides polymorphism, the most significant difference between [AWL94] and the system we have described is that types in [AWL94] can express control-flow through runtime tests. That is, given a conditional if e e 0 e 00 , the types of e 0 and e 00 are constrained to reflect the values for which e is true and false respectively. <p> We can report that it is in fact straightforward to adapt the techniques reported in this paper to the system of <ref> [AWL94] </ref>, yielding a system that can both remove as many dynamic type checks as [AWL94] and as many runtime tags as dynamic typing. We omit all details for lack of space. <p> We can report that it is in fact straightforward to adapt the techniques reported in this paper to the system of <ref> [AWL94] </ref>, yielding a system that can both remove as many dynamic type checks as [AWL94] and as many runtime tags as dynamic typing. We omit all details for lack of space.
Reference: [CF91] <author> R. Cartwright and M. Fagan. </author> <title> Soft typing. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 278-292, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Currently, the main application of dynamic typing is the optimization of programs written in dynamically typed languages (such as Lisp and Scheme) by removing runtime tests of type tags where they are provably unnecessary (so-called soft typing <ref> [CF91, WC94] </ref>). A remarkable, and to our knowledge unique, aspect of dynamic typing is that it not only permits the removal of dynamic type tag tests, but also allows the elimination of type tagging operations themselves. The purpose and results of our study are two-fold. <p> Coercions from type Dynamic were introduced in a subsequent paper [Tha90]. A large number of analysis algorithms for dynamically typed languages have been proposed in recent years <ref> [Gom90, AM91, CF91, Hen92b, WH92, WC94] </ref>. With the exception of the works of Henglein, Thatte, and Gomard, it is fair to characterize all of these as (inclusion-based) subtyping systems; none treat tag inference.
Reference: [Gom90] <author> C. Gomard. </author> <title> Partial type inference for untyped functional programs (extended abstract). </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 282-287, </pages> <year> 1990. </year>
Reference-contexts: Besides previous work on program analysis using set constraints, Henglein's work on dynamic typing is the most closely related to our own. Henglein's work is based, in turn, on earlier works of Thatte and Gomard <ref> [Gom90] </ref> . Thatte originally worked with a system called partial types [Tha88], in which types could be coerced to a universal type, but not vice versaa pure subtyp-ing system. Coercions from type Dynamic were introduced in a subsequent paper [Tha90]. <p> Coercions from type Dynamic were introduced in a subsequent paper [Tha90]. A large number of analysis algorithms for dynamically typed languages have been proposed in recent years <ref> [Gom90, AM91, CF91, Hen92b, WH92, WC94] </ref>. With the exception of the works of Henglein, Thatte, and Gomard, it is fair to characterize all of these as (inclusion-based) subtyping systems; none treat tag inference.
Reference: [Hei92] <author> N. Heintze. </author> <title> Set Based Program Analysis. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1992. </year>
Reference-contexts: It is our thesis that many constraint-based analyses can be expressed using a particular constraint theory known as set constraints. Set constraints are a simple, general, and well-studied theory that is powerful enough to express many program analyses <ref> [HJ90, AW92, Hei92, Aik94] </ref>. In testing our thesis on a variety of program analyses, it became apparent that dynamic typing is in some ways fundamentally different from other examples of constraint theories used in program analysis. <p> To discover which completions are possible, it is necessary to solve the constraints. Figure 6 gives a set of rewrite rules that, when applied until closure (until no new constraints can be generated), reduce a system of constraints to solved form. These constraint resolution rules are essentially those of <ref> [MR85, Hei92, AW93] </ref> specialized to our application. The soundness of these rules can be proven using standard techniques (e.g., see [AW92, AW93]). In an arbitrary variable. Rules 10 and 11 of Figure 6 appear non-constructive, but are actually easy to implement. <p> Once no constraints can be added, any remaining implication constraints can be deleted using Rule 11. A detailed justification is presented in <ref> [Hei92] </ref>. Rules 12 and 13 take advantage of the special structure of constraints involving tag variables. Rule 12 expresses the fact that if a tag variable fi is known to be a subset of tag, then fi = tag, since no tag variable can be 0.
Reference: [Hen92a] <author> F. Henglein. </author> <title> Dynamic typing. </title> <booktitle> In Proceedings of the Eurpean Symposium on Programming, </booktitle> <month> February </month> <year> 1992. </year>
Reference-contexts: 1 Introduction This paper presents a study of Henglein's dynamic typing discipline <ref> [Hen92a, Hen92b] </ref>. Dynamic typing extends conventional static types with a single new type Dynamic. Special functions called coercions inject values into and project values from type Dynamic. <p> However, the set constraint formulation does not naturally suggest the very efficient resolution algorithms known for dynamic typing [Hen92b]; in this respect, dynamic typing appears to stand apart. The rest of this section presents an overview of the paper. Some basic definitions are needed. Following <ref> [Hen92a] </ref>, our results are presented using a small, paradigmatic language called dynamically typed lambda calculus. <p> We are free to choose among correct completions, though completions with fewer coercions are preferred for efficiency reasons. Thus, the goal of dynamic typing is to compute a correct completion with as few coercions as possible. Dynamic typing, as formulated in <ref> [Hen92a] </ref>, has computable minimal completions. A completion e 0 of e is minimal if every derivable completion of e includes all the coercions of e 0 . Two examples are given in Figure 1. The first example shows two completions of the term (x:x)(y:y). <p> type of the function that results, so it must have type FUNC? : Dynamic ; (Dynamic ! Dynamic), which forces the components of the function type to also be tagged and tested at runtime. (The use of ; instead of ! in the type is for consistency with notation in <ref> [Hen92b, Hen92a] </ref> and emphasizes the special role of coercions.) In dynamic typing, if a value has type Dynamic, then all of its components must have type Dynamic. <p> We also consider a variation of dynamic typing where coercions may appear at points other than value creations and uses. (We do not consider induced coercions, another variation on dynamic typing in Henglein's original work <ref> [Hen92a] </ref>.) Finally, we report that the set constraint system can be incorporated into the most expressive system known for removing type tags, although in this case there are no longer minimal completions and constraint resolution becomes inherently exponential.
Reference: [Hen92b] <author> F. Henglein. </author> <title> Global tagging optimization by type inference. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 205-215, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: 1 Introduction This paper presents a study of Henglein's dynamic typing discipline <ref> [Hen92a, Hen92b] </ref>. Dynamic typing extends conventional static types with a single new type Dynamic. Special functions called coercions inject values into and project values from type Dynamic. <p> The main technical challenge, and our central result, is establishing that set constraints can encode dynamic typing. This characterization facilitates direct comparison of dynamic typing with other constraint-based analyses. However, the set constraint formulation does not naturally suggest the very efficient resolution algorithms known for dynamic typing <ref> [Hen92b] </ref>; in this respect, dynamic typing appears to stand apart. The rest of this section presents an overview of the paper. Some basic definitions are needed. Following [Hen92a], our results are presented using a small, paradigmatic language called dynamically typed lambda calculus. <p> type of the function that results, so it must have type FUNC? : Dynamic ; (Dynamic ! Dynamic), which forces the components of the function type to also be tagged and tested at runtime. (The use of ; instead of ! in the type is for consistency with notation in <ref> [Hen92b, Hen92a] </ref> and emphasizes the special role of coercions.) In dynamic typing, if a value has type Dynamic, then all of its components must have type Dynamic. <p> Coercions from type Dynamic were introduced in a subsequent paper [Tha90]. A large number of analysis algorithms for dynamically typed languages have been proposed in recent years <ref> [Gom90, AM91, CF91, Hen92b, WH92, WC94] </ref>. With the exception of the works of Henglein, Thatte, and Gomard, it is fair to characterize all of these as (inclusion-based) subtyping systems; none treat tag inference.
Reference: [HJ90] <author> N. Heintze and J. Jaffar. </author> <title> A decision procedure for a class of Herbrand set constraints. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <pages> pages 42-51, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: It is our thesis that many constraint-based analyses can be expressed using a particular constraint theory known as set constraints. Set constraints are a simple, general, and well-studied theory that is powerful enough to express many program analyses <ref> [HJ90, AW92, Hei92, Aik94] </ref>. In testing our thesis on a variety of program analyses, it became apparent that dynamic typing is in some ways fundamentally different from other examples of constraint theories used in program analysis.
Reference: [MPS84] <author> D. MacQueen, G. Plotkin, and R. Sethi. </author> <title> An ideal model for recursive polymophic types. </title> <booktitle> In Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 165-174, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: For brevity, we skip the development of ideal models needed to formalize types as sets of values; the construction is well-known (e.g., see <ref> [MPS84, AW93] </ref>). We work with systems of set constraints of the following forms: X Y Q 6= tag [ notag T 6= 0 ) Q R Here X, Y stand for any expressions drawn from the grammar above.
Reference: [MR85] <author> P. Mishra and U. Reddy. </author> <title> Declaration-free type checking. </title> <booktitle> In Proceedings of the Twelfth Annual ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 7-21, </pages> <year> 1985. </year>
Reference-contexts: To discover which completions are possible, it is necessary to solve the constraints. Figure 6 gives a set of rewrite rules that, when applied until closure (until no new constraints can be generated), reduce a system of constraints to solved form. These constraint resolution rules are essentially those of <ref> [MR85, Hei92, AW93] </ref> specialized to our application. The soundness of these rules can be proven using standard techniques (e.g., see [AW92, AW93]). In an arbitrary variable. Rules 10 and 11 of Figure 6 appear non-constructive, but are actually easy to implement.
Reference: [Tha88] <author> S. Thatte. </author> <title> Type inference with partial types. </title> <booktitle> In Automata, Languages and Programming: 15th International Colloquium, </booktitle> <pages> pages 615-629. </pages> <booktitle> Springer-Verlag Lecture Notes in Computer Science, </booktitle> <volume> vol. 317, </volume> <month> July </month> <year> 1988. </year>
Reference-contexts: Besides previous work on program analysis using set constraints, Henglein's work on dynamic typing is the most closely related to our own. Henglein's work is based, in turn, on earlier works of Thatte and Gomard [Gom90] . Thatte originally worked with a system called partial types <ref> [Tha88] </ref>, in which types could be coerced to a universal type, but not vice versaa pure subtyp-ing system. Coercions from type Dynamic were introduced in a subsequent paper [Tha90].
Reference: [Tha90] <author> S. Thatte. </author> <title> Quasi-static typing. </title> <booktitle> In Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 367-381, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Thatte originally worked with a system called partial types [Tha88], in which types could be coerced to a universal type, but not vice versaa pure subtyp-ing system. Coercions from type Dynamic were introduced in a subsequent paper <ref> [Tha90] </ref>. A large number of analysis algorithms for dynamically typed languages have been proposed in recent years [Gom90, AM91, CF91, Hen92b, WH92, WC94]. With the exception of the works of Henglein, Thatte, and Gomard, it is fair to characterize all of these as (inclusion-based) subtyping systems; none treat tag inference.
Reference: [WC94] <author> A. Wright and R. Cartwright. </author> <title> A practical soft typing system for Scheme. </title> <booktitle> In Proceedings of the 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 250-262, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Currently, the main application of dynamic typing is the optimization of programs written in dynamically typed languages (such as Lisp and Scheme) by removing runtime tests of type tags where they are provably unnecessary (so-called soft typing <ref> [CF91, WC94] </ref>). A remarkable, and to our knowledge unique, aspect of dynamic typing is that it not only permits the removal of dynamic type tag tests, but also allows the elimination of type tagging operations themselves. The purpose and results of our study are two-fold. <p> The purpose and results of our study are two-fold. First, while dynamic typing is a very interesting system, it cannot remove as many type checks as other recently proposed algorithms based on inclusion subtyping <ref> [AWL94, WC94] </ref>. By inclusion subtyping, we mean systems where type t 1 is a subtype of t 2 if t 2 includes every value of t 1 ; we will refer to this simply as subtyping. <p> Coercions from type Dynamic were introduced in a subsequent paper [Tha90]. A large number of analysis algorithms for dynamically typed languages have been proposed in recent years <ref> [Gom90, AM91, CF91, Hen92b, WH92, WC94] </ref>. With the exception of the works of Henglein, Thatte, and Gomard, it is fair to characterize all of these as (inclusion-based) subtyping systems; none treat tag inference.
Reference: [WH92] <author> E. Wang and P. N. Hilfinger. </author> <title> Analysis of recursive types in Lisp-like languages. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 216-225, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Coercions from type Dynamic were introduced in a subsequent paper [Tha90]. A large number of analysis algorithms for dynamically typed languages have been proposed in recent years <ref> [Gom90, AM91, CF91, Hen92b, WH92, WC94] </ref>. With the exception of the works of Henglein, Thatte, and Gomard, it is fair to characterize all of these as (inclusion-based) subtyping systems; none treat tag inference.
References-found: 17

