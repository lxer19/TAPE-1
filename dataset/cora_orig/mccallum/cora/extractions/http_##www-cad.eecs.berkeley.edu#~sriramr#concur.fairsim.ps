URL: http://www-cad.eecs.berkeley.edu/~sriramr/concur.fairsim.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/~sriramr/research.html
Root-URL: 
Email: Email: ftah,orna,sriramrg@eecs.berkeley.edu  
Title: Fair Simulation  
Author: Thomas A. Henzinger Orna Kupferman Sriram K. Rajamani 
Keyword: computable local criterion for proving linear-time abstraction hierarchies.  
Address: Berkeley, CA 94720-1770, U.S.A.  
Affiliation: EECS Department, University of California,  
Abstract: The simulation preorder for labeled transition systems is defined locally as a game that relates states with their immediate successor states. Live- ness assumptions about transition systems are typically modeled using fairness constraints. Existing notions of simulation for fair transition systems, however, are not local, and as a result, many appealing properties of the simulation preorder are lost. We extend the local definition of simulation to account for fairness: system S fairly simulates system I iff in the simulation game, there is a strategy that matches with each fair computation of I a fair computation of S. Our definition enjoys a fully abstract semantics and has a logical characterization: S fairly simulates I iff every fair computation tree embedded in the unrolling of I can be embedded also in the unrolling of S or, equivalently, iff every Fair-8AFMC formula satisfied by I is satisfied also by S (8AFMC is the universal fragment of the alternation-free -calculus). The locality of the definition leads us to a polynomial-time algorithm for checking fair simulation for finite-state systems with weak and strong fairness constraints. Finally, fair simulation implies fair trace-containment, and is therefore useful as an efficiently 
Abstract-found: 1
Intro-found: 1
Reference: [AL91] <author> M. Abadi and L. Lamport. </author> <title> The existence of refinement mappings. </title> <journal> Theoretical Computer Science, </journal> <volume> 82 </volume> <pages> 253-284, </pages> <year> 1991. </year>
Reference-contexts: by Lynch and others [LT87, Lyn96], usually a stronger notion of fair simulation is used, which we call 8-simulation (see also [DHWT91]): for each fair computation of I, every related computation of S is required to be fair. 3 Again, this definition is neither robust (no logical characterization 2 In <ref> [AL91] </ref>, it is shown that if auxiliary observable variables may be added to a system, then simulation is not only a sound proof technique but also complete for proving trace <br>- containment. 3 Using a similar proof technique, Lamport and others [Lam83, AL91] suggest a restricted, is known) nor can it <p> definition is neither robust (no logical characterization 2 In [AL91], it is shown that if auxiliary observable variables may be added to a system, then simulation is not only a sound proof technique but also complete for proving trace <br>- containment. 3 Using a similar proof technique, Lamport and others <ref> [Lam83, AL91] </ref> suggest a restricted, is known) nor can it be checked efficiently (it is NP-complete [Hoj96]). While both 9-- simulation and 8-simulation are sufficient conditions for fair trace-containment, they do not provide any computational advantage (indeed, algorithms for checking 9-simulation use subroutines for checking fair trace-containment). <p> Particularly popular is a functional version of simulation: the simulation S is a refinement mapping if whenever S (w 1 ; w 2 ) and S (w 0 1 ; w 2 ), then w 1 = w 0 1 <ref> [AL91] </ref>. If S is a refinement mapping, then S is a 8-simulation iff S is an 9-simulation. Our definition of fair simulation Recall the simulation game of the protagonist K 1 against the adversary K 2 .
Reference: [ASB + 94] <author> A. Aziz, V. Singhal, F. Balarin, R.K. Brayton, and A.L. Sangiovanni-Vincentelli. </author> <title> Equivalences for fair Kripke structures. </title> <booktitle> In Proc. 21st ICALP, </booktitle> <publisher> Springer LNCS 820, </publisher> <pages> pp. 364-375, </pages> <year> 1994. </year>
Reference-contexts: It is not so obvious how to generalize the branching framework of simulation to account for fairness. Indeed, several proposals can be found in the literature. The definition suggested by Grumberg and Long [GL94], and used among others by <ref> [ASB + 94, KV96] </ref>, rests on the motivation that S fairly simulates I iff every Fair-8CTL ? formula that holds for S holds also for I (the universal path quantifier of Fair-8CTL ? ranges over fair computations only). <p> This definition, however, is neither robust (Fair-8CTL induces a weaker preorder <ref> [ASB + 94] </ref>, and Fair-8AFMC, as we show here, induces a stronger one) nor can it be checked efficiently (it is complete for PSPACE [KV96]). <p> By contrast, 9-similarity is not the coarsest abstraction that preserves Fair-8CTL: there are two Buchi structures K 1 and K 2 that satisfy the same formulas of 8CTL, but K 1 does not 9-simulate K 2 <ref> [ASB + 94] </ref>.
Reference: [BBLS92] <editor> S. Bensalem, A. Bouajjani, C. Loiseaux, and J. Sifakis. Property-preserving simu-lations. </editor> <booktitle> In Proc. 4th CAV, </booktitle> <publisher> Springer LNCS 663, </publisher> <pages> pp. 260-273, </pages> <year> 1992. </year>
Reference-contexts: robust: for universal branching temporal logics (where only universal path quantification is allowed) such as 8CTL (the universal fragment of Computation Tree Logic), 8CTL ? , and 8AFMC (the universal fragment of the alternation free -calculus), S simulates I iff every formula that holds for S holds also for I <ref> [BBLS92, GL94] </ref>. Second, unlike trace-containment, the definition of simulation is local, as the relation between two states is based only on their successor states. <p> The temporal-logic view. The three branching-time logics 8CTL, 8CTL ? , and 8AFMC are the fragments of CTL, CTL fl , and the alternation-free -calculus that do not contain existential path quantifiers <ref> [BBLS92, GL94] </ref>. It is well-known that K 1 simulates K 2 iff for every formula of 8CTL (or 8CTL ? or 8AFMC), if K 1 satisfies , then K 2 satisfies . It follows that similarity is the coarsest abstraction that preserves any of these three logics.
Reference: [BKO87] <author> J.A. Bergstra, J.W. Klop, and E.R. Olderog. </author> <title> Failures without chaos: a new process semantics for fair abstraction. </title> <booktitle> In Proc. 3rd IFIP FDPC, </booktitle> <publisher> Elsevier, </publisher> <pages> pp. 77-103, </pages> <year> 1987. </year>
Reference-contexts: In the degenerate case of deterministic systems, fair simulation coincides with fair trace-containment. We note that in process algebra, several other preorders and equivalences on state- transition systems have been extended to account for fairness, including failure pre- orders <ref> [BKO87] </ref> and testing preorders [Hen87, BRV95, NC95].
Reference: [BP96] <author> B. Bloom and R. Paige. </author> <title> Transformational design and implementation of a new effi-cient solution to the ready simulation problem. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 24:189220, </address> <year> 1996. </year>
Reference-contexts: Second, unlike trace-containment, the definition of simulation is local, as the relation between two states is based only on their successor states. As a result, it can be checked in polynomial time (quadratic in both S and I) whether S simulates I <ref> [CPS93, BP96] </ref>, and a witnessing relation for simulation can be computed using a symbolic fixpoint procedure [HHK95]. <p> The problem of checking if K 1 simulates K 2 can be solved in time O ((jW 1 j + jW 2 j) (jR 1 j + jR 2 j)) <ref> [BP96, HHK95] </ref>. If K 1 simulates K 2 , then K 1 trace-contains K 2 . If K 1 and K 2 are both deterministic, then similarity coincides with trace-containment. The following three alternative definitions of similarity are equivalent to the definition above. The game-theoretic view. <p> The construction of ^ S requires time O ((jW 1 j + jW 2 j) (jR 1 j + jR 2 j)) <ref> [BP96, HHK95] </ref>. Hence we are left to find an algorithm that efficiently checks, given a relation S W 1 fi W 2 , if S is an init-fair simulation from K 2 to K 1 .
Reference: [BRV95] <author> E. Brinksma, A. Rensink, and W. Vogler. </author> <title> Fair testing. </title> <booktitle> In Proc. 6th CONCUR, </booktitle> <publisher> Springer LNCS 962, </publisher> <pages> pp. 313-327, </pages> <year> 1995. </year>
Reference-contexts: In the degenerate case of deterministic systems, fair simulation coincides with fair trace-containment. We note that in process algebra, several other preorders and equivalences on state- transition systems have been extended to account for fairness, including failure pre- orders [BKO87] and testing preorders <ref> [Hen87, BRV95, NC95] </ref>.
Reference: [BVW94] <author> O. Bernholtz, M.Y. Vardi, and P. Wolper. </author> <title> An automata-theoretic approach to branching-time model checking. </title> <booktitle> In Proc. 6th CAV, </booktitle> <publisher> Springer LNCS 818, </publisher> <pages> pp. 142-155, </pages> <year> 1994. </year>
Reference-contexts: Hence, I j= '. Our definition of Fair-9AFMC is very similar to the automata-theoretic characterization of the alternation-free -calculus. Indeed, a convincing sat-tree of K for can be viewed as a run of an alternating tree automaton for on K <ref> [BVW94] </ref>. We also note that for the Fair-9AFMC formulas that correspond to the existential fragment of Fair-CTL, our definition coincides with the usual semantics for Fair-CTL [CES86].
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal-logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8 </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference-contexts: Indeed, a convincing sat-tree of K for can be viewed as a run of an alternating tree automaton for on K [BVW94]. We also note that for the Fair-9AFMC formulas that correspond to the existential fragment of Fair-CTL, our definition coincides with the usual semantics for Fair-CTL <ref> [CES86] </ref>. Fair simulation and Fair-9AFMC Before we show that fair simulation and Fair-9AFMC induce the same relation on fair structures, we demonstrate that this is not the case for 9-simulation. Consider again the fair structures from Figure 1. We saw that the Fair-9AFMC formula ' is satisfied in I.
Reference: [CPS93] <author> R.J. Cleaveland, J. Parrow, and B. Steffen. </author> <title> The Concurrency Workbench: a semantics-based tool for the verification of finite-state systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15 </volume> <pages> 36-72, </pages> <year> 1993. </year>
Reference-contexts: Second, unlike trace-containment, the definition of simulation is local, as the relation between two states is based only on their successor states. As a result, it can be checked in polynomial time (quadratic in both S and I) whether S simulates I <ref> [CPS93, BP96] </ref>, and a witnessing relation for simulation can be computed using a symbolic fixpoint procedure [HHK95]. <p> The locality advantage is so compelling as to make simulation useful also to researchers that favor trace-based specification: in automatic verification, simulation is widely used as an efficiently-computable sufficient condition for trace-containment <ref> [CPS93, Hoj96] </ref>; in manual verification, trace-containment is most naturally proved by exhibiting local witnesses such as simulation relations or refinement mappings (a restricted form of simulation relations) [Lam83, LT87, Lyn96]. 2 State-transition systems describe only the safe behaviors of programs.
Reference: [DHWT91] <author> D. Dill, A.J. Hu, and H. Wong-Toi. </author> <title> Checking for language inclusion using simu-lation relations. </title> <booktitle> In Proc. 3rd CAV, </booktitle> <publisher> Springer LNCS 575, </publisher> <pages> pp. 255-265, </pages> <year> 1991. </year>
Reference-contexts: In manual verification, by Lynch and others [LT87, Lyn96], usually a stronger notion of fair simulation is used, which we call 8-simulation (see also <ref> [DHWT91] </ref>): for each fair computation of I, every related computation of S is required to be fair. 3 Again, this definition is neither robust (no logical characterization 2 In [AL91], it is shown that if auxiliary observable variables may be added to a system, then simulation is not only a sound <p> Moreover, 9-similarity does not preserve Fair-8AFMC: as we show in Section 4, there are two Buchi structures K 1 and K 2 , and a Fair-8AFMC formula , such that K 1 9-simulates K 2 , and K 1 satisfies , but K 2 does not satisfy . 8-simulation <ref> [LT87, DHWT91] </ref>. A binary relation S W 1 fi W 2 is a 8-simulation of K 2 by K 1 if the following two conditions hold: 1. S is a simulation of K 2 by K 1 . 2.
Reference: [EJ88] <author> E.A. Emerson and C. Jutla. </author> <title> The complexity of tree automata and logics of programs. </title> <booktitle> In Proc. 29th FOCS, IEEE Computer Society, </booktitle> <pages> pp. 368-377, </pages> <year> 1988. </year>
Reference-contexts: It is easy to see that the protagonist has a winning strategy iff the intersection of A S and A F is nonempty. Since checking the nonemptiness of a Streett tree automaton with n states and f pairs requires time O ((nf ) 3f ) <ref> [EJ88] </ref>, the theorem below follows. Theorem 6.
Reference: [GL94] <author> O. Grumberg and D.E. </author> <title> Long. Model checking and modular verification. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16 </volume> <pages> 843-871, </pages> <year> 1994. </year>
Reference-contexts: robust: for universal branching temporal logics (where only universal path quantification is allowed) such as 8CTL (the universal fragment of Computation Tree Logic), 8CTL ? , and 8AFMC (the universal fragment of the alternation free -calculus), S simulates I iff every formula that holds for S holds also for I <ref> [BBLS92, GL94] </ref>. Second, unlike trace-containment, the definition of simulation is local, as the relation between two states is based only on their successor states. <p> Robustness with respect to LTL, and PSPACE-completeness extend to the fair case. It is not so obvious how to generalize the branching framework of simulation to account for fairness. Indeed, several proposals can be found in the literature. The definition suggested by Grumberg and Long <ref> [GL94] </ref>, and used among others by [ASB + 94, KV96], rests on the motivation that S fairly simulates I iff every Fair-8CTL ? formula that holds for S holds also for I (the universal path quantifier of Fair-8CTL ? ranges over fair computations only). <p> The temporal-logic view. The three branching-time logics 8CTL, 8CTL ? , and 8AFMC are the fragments of CTL, CTL fl , and the alternation-free -calculus that do not contain existential path quantifiers <ref> [BBLS92, GL94] </ref>. It is well-known that K 1 simulates K 2 iff for every formula of 8CTL (or 8CTL ? or 8AFMC), if K 1 satisfies , then K 2 satisfies . It follows that similarity is the coarsest abstraction that preserves any of these three logics. <p> It follows that similarity is the coarsest abstraction that preserves any of these three logics. Previous definitions of fair simulation In the literature, we find several extensions of similarity that account for fairness constraints. In particular, the following two extensions have been studied and used extensively. 9-simulation <ref> [GL94] </ref>. A binary relation S W 1 fi W 2 is an 9-simulation of K 2 by K 1 if the following two conditions hold: 1. If S (w 1 ; w 2 ), then L 1 (w 1 ) = L 2 (w 2 ). 2. <p> K 2 is complete for PSPACE [KV96]. 9-similarity is the coarsest abstraction that preserves Fair-8CTL ? , where the universal path quantifiers range over the fair runs only: K 1 9-simulates K 2 iff for every formula of Fair-8CTL ? , if K 1 satisfies , then K 2 satisfies <ref> [GL94] </ref>. By contrast, 9-similarity is not the coarsest abstraction that preserves Fair-8CTL: there are two Buchi structures K 1 and K 2 that satisfy the same formulas of 8CTL, but K 1 does not 9-simulate K 2 [ASB + 94].
Reference: [Hen87] <author> M.C.B. Hennessy. </author> <title> An algebraic theory of fair asynchronous communicating processes. </title> <journal> Theoretical Computer Science, </journal> <volume> 49 </volume> <pages> 121-143, </pages> <year> 1987. </year>
Reference-contexts: In the degenerate case of deterministic systems, fair simulation coincides with fair trace-containment. We note that in process algebra, several other preorders and equivalences on state- transition systems have been extended to account for fairness, including failure pre- orders [BKO87] and testing preorders <ref> [Hen87, BRV95, NC95] </ref>.
Reference: [HHK95] <author> M.R. Henzinger, T.A. Henzinger, and P.W. Kopke. </author> <title> Computing simulations on finite and infinite graphs. </title> <booktitle> In Proc. 36th FOCS, IEEE Computer Society, </booktitle> <pages> pp. 453-462, </pages> <year> 1995. </year>
Reference-contexts: As a result, it can be checked in polynomial time (quadratic in both S and I) whether S simulates I [CPS93, BP96], and a witnessing relation for simulation can be computed using a symbolic fixpoint procedure <ref> [HHK95] </ref>. <p> The problem of checking if K 1 simulates K 2 can be solved in time O ((jW 1 j + jW 2 j) (jR 1 j + jR 2 j)) <ref> [BP96, HHK95] </ref>. If K 1 simulates K 2 , then K 1 trace-contains K 2 . If K 1 and K 2 are both deterministic, then similarity coincides with trace-containment. The following three alternative definitions of similarity are equivalent to the definition above. The game-theoretic view. <p> The construction of ^ S requires time O ((jW 1 j + jW 2 j) (jR 1 j + jR 2 j)) <ref> [BP96, HHK95] </ref>. Hence we are left to find an algorithm that efficiently checks, given a relation S W 1 fi W 2 , if S is an init-fair simulation from K 2 to K 1 .
Reference: [Hoj96] <author> R. Hojati. </author> <title> A BDD-based Environment for Formal Verification of Hardware Systems. </title> <type> PhD thesis, </type> <institution> EECS Department, University of California, Berkeley, </institution> <year> 1996. </year>
Reference-contexts: The locality advantage is so compelling as to make simulation useful also to researchers that favor trace-based specification: in automatic verification, simulation is widely used as an efficiently-computable sufficient condition for trace-containment <ref> [CPS93, Hoj96] </ref>; in manual verification, trace-containment is most naturally proved by exhibiting local witnesses such as simulation relations or refinement mappings (a restricted form of simulation relations) [Lam83, LT87, Lyn96]. 2 State-transition systems describe only the safe behaviors of programs. <p> This definition, however, is neither robust (Fair-8CTL induces a weaker preorder [ASB + 94], and Fair-8AFMC, as we show here, induces a stronger one) nor can it be checked efficiently (it is complete for PSPACE [KV96]). Following <ref> [Hoj96] </ref>, we call the Grumberg-Long version of fair simulation 9-simulation, because it can be defined as simulation where each fair computation of I is related to some fair computation of S. <p> observable variables may be added to a system, then simulation is not only a sound proof technique but also complete for proving trace <br>- containment. 3 Using a similar proof technique, Lamport and others [Lam83, AL91] suggest a restricted, is known) nor can it be checked efficiently (it is NP-complete <ref> [Hoj96] </ref>). While both 9-- simulation and 8-simulation are sufficient conditions for fair trace-containment, they do not provide any computational advantage (indeed, algorithms for checking 9-simulation use subroutines for checking fair trace-containment). <p> For vacuous constraints F 1 and F 2 , 8-similarity coincides with similarity. For Buchi or Streett constraints F 1 and F 2 , the problem of checking whether K 1 8-simulates K 2 is NP-complete <ref> [Hoj96] </ref>. 8-simulation is widely used for proving abstraction hierarchies of distributed protocols [Lyn96].
Reference: [KV96] <author> O. Kupferman and M.Y. Vardi. </author> <title> Verification of fair transition systems. </title> <booktitle> In Proc. 8th CAV, </booktitle> <publisher> Springer LNCS 1102, </publisher> <pages> pp. 372-382, </pages> <year> 1996. </year>
Reference-contexts: It is not so obvious how to generalize the branching framework of simulation to account for fairness. Indeed, several proposals can be found in the literature. The definition suggested by Grumberg and Long [GL94], and used among others by <ref> [ASB + 94, KV96] </ref>, rests on the motivation that S fairly simulates I iff every Fair-8CTL ? formula that holds for S holds also for I (the universal path quantifier of Fair-8CTL ? ranges over fair computations only). <p> This definition, however, is neither robust (Fair-8CTL induces a weaker preorder [ASB + 94], and Fair-8AFMC, as we show here, induces a stronger one) nor can it be checked efficiently (it is complete for PSPACE <ref> [KV96] </ref>). Following [Hoj96], we call the Grumberg-Long version of fair simulation 9-simulation, because it can be defined as simulation where each fair computation of I is related to some fair computation of S. <p> For vacuous constraints F 1 and F 2 , 9-similarity coincides with similarity. For Buchi or Streett constraints F 1 and F 2 , the problem of checking if K 1 9-simulates K 2 is complete for PSPACE <ref> [KV96] </ref>. 9-similarity is the coarsest abstraction that preserves Fair-8CTL ? , where the universal path quantifiers range over the fair runs only: K 1 9-simulates K 2 iff for every formula of Fair-8CTL ? , if K 1 satisfies , then K 2 satisfies [GL94].
Reference: [Lam83] <author> L. Lamport. </author> <title> Specifying concurrent program modules. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5 </volume> <pages> 190-222, </pages> <year> 1983. </year>
Reference-contexts: simulation useful also to researchers that favor trace-based specification: in automatic verification, simulation is widely used as an efficiently-computable sufficient condition for trace-containment [CPS93, Hoj96]; in manual verification, trace-containment is most naturally proved by exhibiting local witnesses such as simulation relations or refinement mappings (a restricted form of simulation relations) <ref> [Lam83, LT87, Lyn96] </ref>. 2 State-transition systems describe only the safe behaviors of programs. In order to model liveness assumptions, one typically augments state-transition systems with fairness constraints, which partition the infinite computations of a system into fair and unfair computations. <p> definition is neither robust (no logical characterization 2 In [AL91], it is shown that if auxiliary observable variables may be added to a system, then simulation is not only a sound proof technique but also complete for proving trace <br>- containment. 3 Using a similar proof technique, Lamport and others <ref> [Lam83, AL91] </ref> suggest a restricted, is known) nor can it be checked efficiently (it is NP-complete [Hoj96]). While both 9-- simulation and 8-simulation are sufficient conditions for fair trace-containment, they do not provide any computational advantage (indeed, algorithms for checking 9-simulation use subroutines for checking fair trace-containment). <p> There is evidence that most practical specifications fairly simulate their implementations. In particular, since fair simulation is implied by 8-simulation, the fair simulation condition can be used as an efficient check to verify distributed protocols that have been verified using 8-simulation <ref> [Lam83, LS93, Lyn96] </ref>. In the degenerate case of vacuous fairness constraints, fair simulation coincides with simulation. In the degenerate case of deterministic systems, fair simulation coincides with fair trace-containment.
Reference: [LS93] <author> N.A. Lynch and R. Segala. </author> <title> A comparison of simulation techniques and algebraic tech-niques for verifying concurrent systems. </title> <type> Technical Report MIT/LCS/TM-499, </type> <institution> Laboratory for Computer Science, MIT, </institution> <year> 1993. </year>
Reference-contexts: There is evidence that most practical specifications fairly simulate their implementations. In particular, since fair simulation is implied by 8-simulation, the fair simulation condition can be used as an efficient check to verify distributed protocols that have been verified using 8-simulation <ref> [Lam83, LS93, Lyn96] </ref>. In the degenerate case of vacuous fairness constraints, fair simulation coincides with simulation. In the degenerate case of deterministic systems, fair simulation coincides with fair trace-containment.
Reference: [LT87] <author> N.A. Lynch and M.R. Tuttle. </author> <title> Hierarchical correctness proofs for distributed algo-rithms. </title> <booktitle> In Proc. 6th PODC, ACM, </booktitle> <pages> pp. 137-151, </pages> <year> 1987. </year>
Reference-contexts: simulation useful also to researchers that favor trace-based specification: in automatic verification, simulation is widely used as an efficiently-computable sufficient condition for trace-containment [CPS93, Hoj96]; in manual verification, trace-containment is most naturally proved by exhibiting local witnesses such as simulation relations or refinement mappings (a restricted form of simulation relations) <ref> [Lam83, LT87, Lyn96] </ref>. 2 State-transition systems describe only the safe behaviors of programs. In order to model liveness assumptions, one typically augments state-transition systems with fairness constraints, which partition the infinite computations of a system into fair and unfair computations. <p> Following [Hoj96], we call the Grumberg-Long version of fair simulation 9-simulation, because it can be defined as simulation where each fair computation of I is related to some fair computation of S. In manual verification, by Lynch and others <ref> [LT87, Lyn96] </ref>, usually a stronger notion of fair simulation is used, which we call 8-simulation (see also [DHWT91]): for each fair computation of I, every related computation of S is required to be fair. 3 Again, this definition is neither robust (no logical characterization 2 In [AL91], it is shown that <p> Moreover, 9-similarity does not preserve Fair-8AFMC: as we show in Section 4, there are two Buchi structures K 1 and K 2 , and a Fair-8AFMC formula , such that K 1 9-simulates K 2 , and K 1 satisfies , but K 2 does not satisfy . 8-simulation <ref> [LT87, DHWT91] </ref>. A binary relation S W 1 fi W 2 is a 8-simulation of K 2 by K 1 if the following two conditions hold: 1. S is a simulation of K 2 by K 1 . 2.
Reference: [Lyn96] <author> N.A. Lynch. </author> <title> Distributed Algorithms. </title> <publisher> Morgan-Kaufmann, </publisher> <year> 1996. </year>
Reference-contexts: simulation useful also to researchers that favor trace-based specification: in automatic verification, simulation is widely used as an efficiently-computable sufficient condition for trace-containment [CPS93, Hoj96]; in manual verification, trace-containment is most naturally proved by exhibiting local witnesses such as simulation relations or refinement mappings (a restricted form of simulation relations) <ref> [Lam83, LT87, Lyn96] </ref>. 2 State-transition systems describe only the safe behaviors of programs. In order to model liveness assumptions, one typically augments state-transition systems with fairness constraints, which partition the infinite computations of a system into fair and unfair computations. <p> Following [Hoj96], we call the Grumberg-Long version of fair simulation 9-simulation, because it can be defined as simulation where each fair computation of I is related to some fair computation of S. In manual verification, by Lynch and others <ref> [LT87, Lyn96] </ref>, usually a stronger notion of fair simulation is used, which we call 8-simulation (see also [DHWT91]): for each fair computation of I, every related computation of S is required to be fair. 3 Again, this definition is neither robust (no logical characterization 2 In [AL91], it is shown that <p> There is evidence that most practical specifications fairly simulate their implementations. In particular, since fair simulation is implied by 8-simulation, the fair simulation condition can be used as an efficient check to verify distributed protocols that have been verified using 8-simulation <ref> [Lam83, LS93, Lyn96] </ref>. In the degenerate case of vacuous fairness constraints, fair simulation coincides with simulation. In the degenerate case of deterministic systems, fair simulation coincides with fair trace-containment. <p> For vacuous constraints F 1 and F 2 , 8-similarity coincides with similarity. For Buchi or Streett constraints F 1 and F 2 , the problem of checking whether K 1 8-simulates K 2 is NP-complete [Hoj96]. 8-simulation is widely used for proving abstraction hierarchies of distributed protocols <ref> [Lyn96] </ref>.
Reference: [Mil71] <author> R. Milner. </author> <title> An algebraic definition of simulation between programs. </title> <booktitle> In Proc. 2nd IJCAI, British Computer Society, </booktitle> <pages> pp. 481-489, </pages> <year> 1971. </year>
Reference-contexts: The notion of tree-containment is equivalent to the notion of simulation, as defined by Milner <ref> [Mil71] </ref>: S tree-contains I iff S simulates I; that is, we can relate each state of I to a state of S so that two related states i and s agree on their observations and every successor of i is related to some successor of s. <p> Simulation A binary relation S W 1 fi W 2 is a simulation of K 2 by K 1 if the following two conditions hold <ref> [Mil71] </ref>: 1. If S (w 1 ; w 2 ), then L 1 (w 1 ) = L 2 (w 2 ). 2.
Reference: [NC95] <author> V. Natarajan and R.J. Cleaveland. </author> <title> Divergence and fair testing. </title> <booktitle> In Proc. 22nd ICALP, </booktitle> <publisher> Springer LNCS 944, </publisher> <pages> pp. 648-659, </pages> <year> 1995. </year>
Reference-contexts: In the degenerate case of deterministic systems, fair simulation coincides with fair trace-containment. We note that in process algebra, several other preorders and equivalences on state- transition systems have been extended to account for fairness, including failure pre- orders [BKO87] and testing preorders <ref> [Hen87, BRV95, NC95] </ref>.
Reference: [Pnu85] <author> A. Pnueli. </author> <title> Linear and branching structures in the semantics and logics of reactive systems. </title> <booktitle> In Proc. 12th ICALP, </booktitle> <publisher> Springer LNCS 194, </publisher> <pages> pp. 15-32, </pages> <year> 1985. </year>
Reference-contexts: In tree-based satisfaction, we require that every branching property (i.e., every property of computation trees) which holds for the specification holds also for the implementation <ref> [Pnu85] </ref>. If we represent the implementation I and the specification S using state-transition systems, then the formal relation that captures trace-based satisfaction is trace-containment: S trace-contains I iff it is possible to generate by S every sequence of observations that can be generated by I.
Reference: [PR89] <author> A. Pnueli and R. Rosner. </author> <title> On the synthesis of a reactive module. </title> <booktitle> In Proc. 16th POPL, ACM, </booktitle> <pages> pp. 179-190, </pages> <year> 1989. </year>
Reference-contexts: In Section 3, we suggest an algorithm for checking whether two fair structures are fairly similar. The algorithm reduces the fair-similarity problem to the nonemptiness problem of tree automata. Known results about tree automata <ref> [Rab70, PR89] </ref> then imply that in Condition 2. above, if a required strategy exists, then there exists a finite-state strategy; that is, a strategy produced by a finite-state machine. <p> Then, the protagonist has a winning strategy in this game iff S is an init-fair simulation from K 2 to K 1 . The problem of checking the existence of a winning strategy (and the synthesis of such a strategy <ref> [Rab70, PR89] </ref>) can be reduced to the nonemptiness problem for tree automata. We construct two automata: 1.
Reference: [Rab70] <author> M.O. Rabin. </author> <title> Weakly definable relations and special automata. </title> <booktitle> In Proc. Mathematical Logic and Foundations of Set Theory, </booktitle> <publisher> Elsevier, </publisher> <pages> pp. 1-23, </pages> <year> 1970. </year>
Reference-contexts: In Section 3, we suggest an algorithm for checking whether two fair structures are fairly similar. The algorithm reduces the fair-similarity problem to the nonemptiness problem of tree automata. Known results about tree automata <ref> [Rab70, PR89] </ref> then imply that in Condition 2. above, if a required strategy exists, then there exists a finite-state strategy; that is, a strategy produced by a finite-state machine. <p> Then, the protagonist has a winning strategy in this game iff S is an init-fair simulation from K 2 to K 1 . The problem of checking the existence of a winning strategy (and the synthesis of such a strategy <ref> [Rab70, PR89] </ref>) can be reduced to the nonemptiness problem for tree automata. We construct two automata: 1. <p> Let A 1 and A 2 be tree automata that accept all fair trace-trees of K 1 and K 2 , respectively. By Proposition 3, the language of A 1 does not contain the language of A 2 . Hence, by <ref> [Rab70] </ref>, there is a regular tree (i.e., a tree with only finitely many distinct subtrees) that is accepted by A 2 and not accepted by A 1 . This tree can be encoded by a Fair-9AFMC formula such that K 2 j= and K 1 6j= . Acknowledgment.
Reference: [Saf88] <author> S. Safra. </author> <title> On the complexity of !-automata. </title> <booktitle> In Proc. 29th FOCS, IEEE Computer Society, </booktitle> <pages> pp. 319-327, </pages> <year> 1988. </year>
Reference-contexts: For vacuous constraints F 1 and F 2 , fair trace-containment coincides with trace-containment. For Buchi or Streett constraints F 1 and F 2 , the problem of checking if K 1 fairly trace-contains K 2 is complete for PSPACE <ref> [SVW87, Saf88] </ref>. Simulation A binary relation S W 1 fi W 2 is a simulation of K 2 by K 1 if the following two conditions hold [Mil71]: 1. If S (w 1 ; w 2 ), then L 1 (w 1 ) = L 2 (w 2 ). 2.
Reference: [SM73] <author> L.J. Stockmeyer and A.R. Meyer. </author> <title> Word problems requiring exponential time. </title> <booktitle> In Proc. 5th STOC, ACM, </booktitle> <pages> pp. 1-9, </pages> <year> 1973. </year>
Reference-contexts: The notion of trace-containment is robust with respect to linear temporal logics such as LTL, in the sense that S trace-contains I iff every LTL formula that holds for S holds also for I. Unfortunately, it is difficult to check trace- containment (complete for PSPACE <ref> [SM73] </ref>), and we are unlikely to find an efficient algorithm. ? This research was supported in part by the ONR YIP award N00014-95-1-0520, by the NSF CAREER award CCR-9501708, by the NSF grant CCR-9504469, by the AFOSR contract F49620-93-1-0056, by the ARO MURI grant DAAH-04-96-1-0341, by the ARPA grant NAG2-892, and <p> The problem of checking if K 1 trace-contains K 2 is complete for PSPACE <ref> [SM73] </ref>. The fair structure K 1 fairly trace-contains the fair structure K 2 if every fair trace of K 2 is also a fair trace of K 1 . For vacuous constraints F 1 and F 2 , fair trace-containment coincides with trace-containment.
Reference: [SVW87] <author> A.P. Sistla, M.Y. Vardi, and P. Wolper. </author> <title> The complementation problem for Buchi automata with applications to temporal logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 49 </volume> <pages> 217-237, </pages> <year> 1987. </year>
Reference-contexts: For vacuous constraints F 1 and F 2 , fair trace-containment coincides with trace-containment. For Buchi or Streett constraints F 1 and F 2 , the problem of checking if K 1 fairly trace-contains K 2 is complete for PSPACE <ref> [SVW87, Saf88] </ref>. Simulation A binary relation S W 1 fi W 2 is a simulation of K 2 by K 1 if the following two conditions hold [Mil71]: 1. If S (w 1 ; w 2 ), then L 1 (w 1 ) = L 2 (w 2 ). 2.
References-found: 28

