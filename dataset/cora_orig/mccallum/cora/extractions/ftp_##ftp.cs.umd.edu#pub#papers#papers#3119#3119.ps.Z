URL: ftp://ftp.cs.umd.edu/pub/papers/papers/3119/3119.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Title: A FRAMEWORK FOR DYNAMIC RECONFIGURATION OF DISTRIBUTED PROGRAMS  
Author: Christine R. Hofmeister James M. Purtilo 
Address: College Park, MD 20742  
Affiliation: Computer Science Department University of Maryland,  
Abstract: Current techniques for a software engineer to change a computer program are limited to static activities | once the application begins executing, there are few reliable ways to reconfigure it. We have developed a general framework for reconfigurating application software dynamically. A sound method for managing changes in a running program allows developers to perform maintenance activities without loss of the overall system's service. The same methods also support some forms of load balancing in a distributed system, and research in software fault tolerance. Our goal has been to create an environment for organizing and effecting software reconfiguration activities dynamically. First we present the overall framework within which reconfiguration is possible, then we describe our formal approach for programmers to capture the state of a process abstractly. Next, we describe our implementation of this method within an environment for experimenting with program reconfiguration. We conclude with a summary of the key research problems that we are continuing to pursue in this area. This research was supported by a grant from the National Science Foundation, contract NSF CCR-9021222. An earlier and shorter version of this paper appeared as "Dynamic Reconfiguration of Distributed Programs," Proceedings of the 11th International Conference on Distributed Computing Systems, pp. 560-571, 1991. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Y. Artsy, R. Finkel, </author> <title> "Designing a Process Migration Facility: The Charlotte Experience," </title> <journal> IEEE Computer, </journal> <volume> vol. 22, no. 9, </volume> <pages> pp. 47-56, </pages> <year> 1989. </year>
Reference-contexts: The ideal behavior would be for all such kernel-based information to be adapted during migration, transparent to the application's execution (except for possible differences in performance). For homogeneous distributed systems, then there is strong evidence from other projects (such as Charlotte <ref> [1] </ref>) this ideal can be achieved. <p> This idea contrasts with previous approaches to migration in homogeneous systems <ref> [1, 5] </ref>, because those methods relocate a process by moving its actual representation in the operating system, not an abstraction. The actual representation is architecture-dependent, and for this reason these approaches do not directly apply to a heterogeneous computing system. <p> Geometric reconfiguration (but only between processors of like architecture and operating systems) has been considered in the form of process migration, e.g. <ref> [5, 1] </ref>. More recent research provides some reconfiguration of system structure, e.g. [3]. The most important previous work in this area is the formalism exposed within the Conic system [11]. Our approach is based upon the software bus abstraction as currently implemented in the POLYLITH system [15].
Reference: [2] <author> J. Bloch, </author> <title> "The Camelot Library: C Language Extension for Programming General Purpose Distributed Transaction System," </title> <booktitle> Proc of 9th Conf on Distributed Computing Systems, </booktitle> <pages> pp. 172-180, </pages> <year> 1989. </year>
Reference-contexts: Especially appropriate for multiprocessor configurations are Camelot <ref> [2] </ref> (a transaction facility built on top of Mach) and Avalon (a language resource constructed using Camelot.) The V Kernel [5] implements a distributed-and parallel-programming resource appropriate for a homogeneous set of hosts. The HCS project [14] shows one way to provide a heterogeneous RPC capability in a distributed environment.
Reference: [3] <author> M. Barbacci, D. Doubleday, C. Weinstock, J. Wing, </author> <title> "A Status Report on Durra: A Tool for PMS-level Programming," </title> <booktitle> Proceedings of 3rd Workshop on Large-grained Parallelism, </booktitle> <year> 1989. </year>
Reference-contexts: Geometric reconfiguration (but only between processors of like architecture and operating systems) has been considered in the form of process migration, e.g. [5, 1]. More recent research provides some reconfiguration of system structure, e.g. <ref> [3] </ref>. The most important previous work in this area is the formalism exposed within the Conic system [11]. Our approach is based upon the software bus abstraction as currently implemented in the POLYLITH system [15]. This project is related to a large body of previous technologies. <p> Several early projects emphasized a network filesystem approach (such as Locus [16].) An interesting approach to cross-architecture procedure call using a common backing-store is given by Essick [6]. Finally, the Durra system allows for some forms of dynamic reconfiguration within the Ada environment <ref> [3] </ref>, while 13 the Mercury system supports heterogeneity in applications by managing a networked object repository [13]. 6 CONCLUSION We have described a broad framework that organizes software reconfiguration activities, specifically within a distributed programming environment.
Reference: [4] <author> K. Chandy, J. Misra, </author> <title> "The Drinking Philosophers Problem," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 6, no. 4, </volume> <pages> pp. 632-646, </pages> <year> 1984. </year>
Reference-contexts: After eating, the diner returns to thinking, thus beginning the cycle again. Our implementation of this problem uses the decentralized algorithm developed by Chandy and Misra <ref> [4] </ref>. The details of this algorithm are not critical to our purpose here, so we show only the pseudo-code for a diner in Figure 2. Our original example has four diners, each a separate process, passing forks and requests for forks on bindings between two diners (Figure 1, right).
Reference: [5] <author> D. Cheriton, </author> <title> "The V Distributed System," </title> <journal> Communications of the ACM, </journal> <volume> vol. 31, </volume> <pages> pp. 314-333, </pages> <year> 1988. </year>
Reference-contexts: This idea contrasts with previous approaches to migration in homogeneous systems <ref> [1, 5] </ref>, because those methods relocate a process by moving its actual representation in the operating system, not an abstraction. The actual representation is architecture-dependent, and for this reason these approaches do not directly apply to a heterogeneous computing system. <p> Geometric reconfiguration (but only between processors of like architecture and operating systems) has been considered in the form of process migration, e.g. <ref> [5, 1] </ref>. More recent research provides some reconfiguration of system structure, e.g. [3]. The most important previous work in this area is the formalism exposed within the Conic system [11]. Our approach is based upon the software bus abstraction as currently implemented in the POLYLITH system [15]. <p> Especially appropriate for multiprocessor configurations are Camelot [2] (a transaction facility built on top of Mach) and Avalon (a language resource constructed using Camelot.) The V Kernel <ref> [5] </ref> implements a distributed-and parallel-programming resource appropriate for a homogeneous set of hosts. The HCS project [14] shows one way to provide a heterogeneous RPC capability in a distributed environment. Concert [20] and Marionette [18] are more variations on a theme.
Reference: [6] <author> R. Essick, </author> <title> The Cross-architecture Procedure Call. </title> <type> Ph.D. Thesis, </type> <institution> UIUC Dept of Computer Science UIUC-R-87-1340, </institution> <year> 1987. </year>
Reference-contexts: Concert [20] and Marionette [18] are more variations on a theme. Several early projects emphasized a network filesystem approach (such as Locus [16].) An interesting approach to cross-architecture procedure call using a common backing-store is given by Essick <ref> [6] </ref>.
Reference: [7] <author> R. Hayes, S. Manweiler, R. Schlichting, </author> <title> "A Simple System for Constructing Distributed, Mixed-language Programs," </title> <journal> Software Practice and Experience, </journal> <volume> vol. 18, no. 7, </volume> <pages> pp. 641-600, </pages> <year> 1988. </year>
Reference-contexts: Much work has been done in primitive data representation in the presence of heterogeneity. For example, our approach benefited from review of previous experiences with Courier. Sun Microsystem's XDR is a similar approach, as is UTS, a `universal type system' internal to the MLP (Mixed Language Programming) system <ref> [7] </ref>. More abstractly, transmission of abstract data types (ADTs) is presented in [8]; Herlihy's ADT transmission mechanism inspired our work on capturing and transmitting the state of an executing process. POLYLITH's previous focus was on simple data structures for interfaces.
Reference: [8] <author> M. Herlihy, B. Liskov, </author> <title> "A Value Transmission Method for Abstract Data Types," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 2, </volume> <pages> pp. 527-551, </pages> <year> 1982. </year>
Reference-contexts: This abstraction can then guide the subsequent invocation of a comparable implementation of that task. The problem then is to find how to characterize the process state abstractly at run-time. To accomplish this we use a generalization of the approach to transmission of ADTs that was presented in <ref> [8] </ref>. In Herlihy's work, two new operations, encode and decode, are added to the ADT, and the developer provides a suitable implementation of these operations for each host. <p> For example, our approach benefited from review of previous experiences with Courier. Sun Microsystem's XDR is a similar approach, as is UTS, a `universal type system' internal to the MLP (Mixed Language Programming) system [7]. More abstractly, transmission of abstract data types (ADTs) is presented in <ref> [8] </ref>; Herlihy's ADT transmission mechanism inspired our work on capturing and transmitting the state of an executing process. POLYLITH's previous focus was on simple data structures for interfaces.
Reference: [9] <author> E. Jul, H. Levy, N. Hutchinson, A. Black, </author> <title> "Fine-grained Mobility in the Emerald System," </title> <journal> Transactions on Computer Systems, </journal> <volume> vol. 6, no. 1, </volume> <pages> pp. 109-133, </pages> <year> 1988. </year>
Reference-contexts: The POLYLITH language binds the instance's accessors into those modules using it, and thereafter those modules transact capability to that instance, rather than `flattening' it for transmission. This approach is very similar to that shown in <ref> [9] </ref>, where a call by object-reference method is described in detail. Structure-oriented languages were used to control a distributed programming environment in several earlier projects, notably CLU [12] and MESA [19]. Both support distributed programming by coupling their notation with their supporting systems.
Reference: [10] <author> M. Jones, R. Rashid, M. Thompson, "Matchmaker: </author> <title> An Interface Specification Language for Distributed Processing," </title> <booktitle> Proc of 12th Symp on Principles of Prog Languages, </booktitle> <year> 1985. </year>
Reference-contexts: Both support distributed programming by coupling their notation with their supporting systems. Each of these systems represent a significant step forward in the area's ability to realize the vast potential of distributing a computation. Subsequently, Matchmaker <ref> [10] </ref> provided a transformational approach to the problem of integrating distributed components: an application would be written in a synthesis of, say, Pascal and a higher-level `specification language.' This source would be transformed into ordinary Pascal code having accessors to the host communication system inserted explicitly, again for static control of
Reference: [11] <author> J. Kramer, J. Magee, </author> <title> "The Evolving Philosophers Problem: Dynamic Change Management," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 16, no. 11, </volume> <pages> pp. 1293-1306. </pages> <year> 1990. </year>
Reference-contexts: Kramer and Magee describe a formalism that characterizes precisely when a distributed program may be reconfig-ured, and in what way; furthermore, they describe an experimental implementation in Conic <ref> [11] </ref>. Their approach focuses upon changes that are primarily either creation or deletion of nodes, plus connection establishment and removal between those nodes. <p> Kramer and Magee define a reconfigurable state as one in which all modules involved in the change are quiescent: they will not initiate any new communication, and have provided all services needed for other modules to reach their quiescent state <ref> [11] </ref>. They prove that this quiescent state is reachable for all modules involved in a reconfiguration. However, the communication between modules is limited to certain types of interactions, primarily rpc-type interactions. <p> More recent research provides some reconfiguration of system structure, e.g. [3]. The most important previous work in this area is the formalism exposed within the Conic system <ref> [11] </ref>. Our approach is based upon the software bus abstraction as currently implemented in the POLYLITH system [15]. This project is related to a large body of previous technologies. Much work has been done in primitive data representation in the presence of heterogeneity.
Reference: [12] <author> B. Liskov, R. Atkinson, </author> <title> CLU Reference Manual, </title> <publisher> Springer-Verlag LNCS 114, </publisher> <year> 1981. </year>
Reference-contexts: This approach is very similar to that shown in [9], where a call by object-reference method is described in detail. Structure-oriented languages were used to control a distributed programming environment in several earlier projects, notably CLU <ref> [12] </ref> and MESA [19]. Both support distributed programming by coupling their notation with their supporting systems. Each of these systems represent a significant step forward in the area's ability to realize the vast potential of distributing a computation.
Reference: [13] <author> B. Liskov, T. Bloom, D. Gifford, R. Scheifler, W. Weihl, </author> <title> "Communication in the Mercury System," </title> <booktitle> Proceedings of the 21st Annual Hawaii Conference on System Sciences, </booktitle> <pages> pp. 178-187, </pages> <year> 1988. </year>
Reference-contexts: Finally, the Durra system allows for some forms of dynamic reconfiguration within the Ada environment [3], while 13 the Mercury system supports heterogeneity in applications by managing a networked object repository <ref> [13] </ref>. 6 CONCLUSION We have described a broad framework that organizes software reconfiguration activities, specifically within a distributed programming environment. In order to run experiments within this framework, we have constructed an execution environment containing a few, fundamental reconfiguration capabilities.
Reference: [14] <author> D. Notkin, A. Black, E. Lazowska et alia, </author> <title> "Interconnecting Heterogeneous Computer Systems," </title> <journal> Communications of the ACM, </journal> <volume> vol. 31, no. 3, </volume> <pages> pp. 258-273, </pages> <year> 1988. </year> <month> 14 </month>
Reference-contexts: Especially appropriate for multiprocessor configurations are Camelot [2] (a transaction facility built on top of Mach) and Avalon (a language resource constructed using Camelot.) The V Kernel [5] implements a distributed-and parallel-programming resource appropriate for a homogeneous set of hosts. The HCS project <ref> [14] </ref> shows one way to provide a heterogeneous RPC capability in a distributed environment. Concert [20] and Marionette [18] are more variations on a theme.
Reference: [15] <author> J. Purtilo, </author> <note> "The Polylith Software Toolbus," to appear, ACM Transactions on Programming Languages and Systems, currently available as University of Maryland CSD Technical Report 2469, </note> <year> 1990. </year>
Reference-contexts: Because the algorithm is decentralized, the protocol for sharing forks is contained in each diner, and is based entirely on its own local state. We illustrate this problem in terms of an existing distributed programming system, POLYLITH <ref> [15] </ref>. In order to run this example on a heterogeneous network using POLYLITH, the user needs to provide a simple description of the application's modular structure, in terms of a module interconnection language (MIL). <p> this text to the POLYLITH packaging system, the user's C source files would be accessed and compiled, then linked with automatically generated network stubs (i.e., procedures that intercept the call in the local process and perform a remote procedure call through the network; this activity is described in detail in <ref> [15] </ref>.) The user could 2 then directly execute this application, as POLYLITH is responsible for invoking the executables and establishing a communication channel between the tasks. <p> Our approach to meeting the above requirements is to build upon the existing POLYLITH software interconnection system <ref> [15] </ref>. POLYLITH already provides users with an environment for easily constructing large (and possibly distributed) applications for use in heterogeneous execution environments. For these reasons, POLYLITH is a natural starting point for investigating how applications might later be reconfigured. <p> More recent research provides some reconfiguration of system structure, e.g. [3]. The most important previous work in this area is the formalism exposed within the Conic system [11]. Our approach is based upon the software bus abstraction as currently implemented in the POLYLITH system <ref> [15] </ref>. This project is related to a large body of previous technologies. Much work has been done in primitive data representation in the presence of heterogeneity. For example, our approach benefited from review of previous experiences with Courier.
Reference: [16] <author> G. Popek, B. Walker, J. Chow et alia, </author> <title> "LOCUS: A Network Transparent, High Reliability Distributed System," </title> <booktitle> Proc of 9th Symp on Operating Systems Principles, </booktitle> <pages> pp. 169-177, </pages> <year> 1981. </year>
Reference-contexts: The HCS project [14] shows one way to provide a heterogeneous RPC capability in a distributed environment. Concert [20] and Marionette [18] are more variations on a theme. Several early projects emphasized a network filesystem approach (such as Locus <ref> [16] </ref>.) An interesting approach to cross-architecture procedure call using a common backing-store is given by Essick [6].
Reference: [17] <author> R. Strom, D. Bacon, </author> <title> "Hermes: A High-level Process-based Language for Reliable Distributed Computing," </title> <booktitle> Proceedings of 3rd Workshop on Large-grain Parallelism, </booktitle> <year> 1989. </year>
Reference-contexts: all possible future configurations would have to be anticipated and represented in the initial software source, hence denying us from incorporating new software components that did not exist at initiation time. (A good example of a system that provides only internal reconfiguration is NIL, with its later implementation called Hermes <ref> [17] </ref>.) 4 There are a large number of activities that must be coordinated before a user can begin to capture and manipulate the state of a running process.
Reference: [18] <author> M. Sullivan, D. Anderson, "Marionette: </author> <title> A system for Parallel Distributed Programming using a Master/slave Model," </title> <booktitle> Proc of 9th Conf on Distributed Computing Systems, </booktitle> <pages> pp. 181-189, </pages> <year> 1989. </year>
Reference-contexts: The HCS project [14] shows one way to provide a heterogeneous RPC capability in a distributed environment. Concert [20] and Marionette <ref> [18] </ref> are more variations on a theme. Several early projects emphasized a network filesystem approach (such as Locus [16].) An interesting approach to cross-architecture procedure call using a common backing-store is given by Essick [6].
Reference: [19] <author> R. Sweet, </author> <title> "The Mesa Programming Environment," </title> <booktitle> Proceedings of the ACM SIGPLAN Symposium on Programming Issues in Programming Environments, </booktitle> <pages> pp. 216-229, </pages> <year> 1985. </year>
Reference-contexts: This approach is very similar to that shown in [9], where a call by object-reference method is described in detail. Structure-oriented languages were used to control a distributed programming environment in several earlier projects, notably CLU [12] and MESA <ref> [19] </ref>. Both support distributed programming by coupling their notation with their supporting systems. Each of these systems represent a significant step forward in the area's ability to realize the vast potential of distributing a computation.
Reference: [20] <author> S. Yemini, G. Goldszmidt et alia, </author> <title> "CONCERT: A High-level Language Approach to Heterogeneous Distributed Systems," </title> <booktitle> Proc of 9th Conf on Distributed Computing Systems, </booktitle> <pages> pp. 162-171, </pages> <year> 1989. </year> <title> ACKNOWLEDGEMENT We appreciate the guidance given to us by Rich LeBlanc. Also, we are grateful to Jeff Kramer and Jeff Magee, both for their helpful comments concerning this research and for cheerfully sharing their experiences with Conic. </title> <type> 15 </type>
Reference-contexts: The HCS project [14] shows one way to provide a heterogeneous RPC capability in a distributed environment. Concert <ref> [20] </ref> and Marionette [18] are more variations on a theme. Several early projects emphasized a network filesystem approach (such as Locus [16].) An interesting approach to cross-architecture procedure call using a common backing-store is given by Essick [6].
References-found: 20

