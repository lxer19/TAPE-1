URL: http://www.cs.iastate.edu/tech-reports/TR96-04d.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: Protective Interface Specifications Keywords: Protective specifications; Specification languages; Underspecifica-tion; Partiality; Larch. languages, theory, Larch, VDM,
Author: Gary T. Leavens and Jeannette M. Wing TR #-d 
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Note: 1996 CR Categories: D.2.1 [Software Engineering] Requirements/Specifications  
Date: April 1996, Revised October, December 1996, February, September 1997  
Abstract: Submitted for publication. An earlier version of this paper, without the appendix sections, appeared in Michel Bidoit and Max Dauchet (editors), TAPSOFT '97: Theory and Practice of Software Development, 7th International Joint Conference CAAP/FASE, Lille, France. Volume 1214 of Lecture Notes in Computer Science, Springer-Verlag, 1997, pages 520-534. An earlier version of this paper was called "Protection from the Underspecified". This technical report is also CMU-CS-96-129R. Copyright c fl 1997 by Springer-Verlag. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Andrews et al. </author> <title> Information technology programming languages - VDM-SL: First committee draft standard CD1387-1. Document ISO/IEC JTC1/SC22/WG19 N-20, </title> <booktitle> International Standards Organization, </booktitle> <month> Nov. </month> <year> 1993. </year> <month> ftp://gatekeeper.dec.com/pub/standards/vdmsl/. </month>
Reference-contexts: For example, VDM-SL <ref> [19, 1] </ref> uses a logic called LPF [19, Section 3.3] [2, 3, 20], which has three logical values and two kinds of equality. 1 As another example, the specification language COLD-K [10] uses a logic having just two logical values, but in which all other types have an improper value, ?,
Reference: [2] <author> H. Barringer, J. H. Cheng, and C. B. Jones. </author> <title> A logic covering undefinedness in program proofs. </title> <journal> Acta Informatica, </journal> <volume> 21(3) </volume> <pages> 251-269, </pages> <month> Oct. </month> <year> 1984. </year>
Reference-contexts: For example, VDM-SL [19, 1] uses a logic called LPF [19, Section 3.3] <ref> [2, 3, 20] </ref>, which has three logical values and two kinds of equality. 1 As another example, the specification language COLD-K [10] uses a logic having just two logical values, but in which all other types have an improper value, ?, which models the "undefined" results of partial functions, and also
Reference: [3] <author> J. Bicarregui, J. S. Fitgerald, P. A. Lindsay, R. Moore, and B. Ritchie. </author> <title> Proof in VDM: A Practitioner's Guide. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1994. </year>
Reference-contexts: For example, VDM-SL [19, 1] uses a logic called LPF [19, Section 3.3] <ref> [2, 3, 20] </ref>, which has three logical values and two kinds of equality. 1 As another example, the specification language COLD-K [10] uses a logic having just two logical values, but in which all other types have an improper value, ?, which models the "undefined" results of partial functions, and also
Reference: [4] <author> A. Bijlsma. </author> <title> Semantics of quasi-boolean expressions. </title> <editor> In W. H. J. Feijen et al., editors, </editor> <booktitle> Beauty is Our Business, </booktitle> <pages> pages 27-35. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: All other values are proper. In COLD-K there is also a definedness predicate, D, that allows one to reason explicitly about whether a term denotes a proper value or not. There are several other languages with similar concepts <ref> [4, 6, 27, 21, 29] </ref>. The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses underspecifica-tion. In such a logic, one avoids specifying a value for undefined terms [14, 18].
Reference: [5] <author> A. Blikle. </author> <title> The clean termination of iterative programs. </title> <journal> Acta Informatica, </journal> <volume> 16 </volume> <pages> 199-217, </pages> <year> 1981. </year>
Reference-contexts: These resemble the domain predicates, Dom (`E'), described by some authors <ref> [12, 9, 5] </ref>. However, they have a different purpose, since an operator, such as choose on nonempty sets, may be underspecified for a reason other than being partial.
Reference: [6] <author> A. Blikle. </author> <title> Three-valued predicates for software specification and validation. </title> <journal> Fun-damenta Informaticae, </journal> <volume> XIV:387-410, </volume> <year> 1991. </year>
Reference-contexts: All other values are proper. In COLD-K there is also a definedness predicate, D, that allows one to reason explicitly about whether a term denotes a proper value or not. There are several other languages with similar concepts <ref> [4, 6, 27, 21, 29] </ref>. The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses underspecifica-tion. In such a logic, one avoids specifying a value for undefined terms [14, 18].
Reference: [7] <author> M. Broy and M. Wirsing. </author> <title> Partial abstract types. </title> <journal> Acta Informatica, </journal> <volume> 18(1) </volume> <pages> 47-64, </pages> <month> Nov. </month> <year> 1982. </year>
Reference-contexts: However, they have a different purpose, since an operator, such as choose on nonempty sets, may be underspecified for a reason other than being partial. They also resemble the definedness predicate (D) used in studies of partial algebras <ref> [7] </ref> and in COLD [10]; however D is defined model-theoretically, not syntactically. The definition of Exact (`') is based on the exact clauses given in the trait's implications and those of included traits.
Reference: [8] <author> J. H. Cheng and C. B. Jones. </author> <title> On the usability of logics which handle partial functions. </title> <editor> In C. Morgan and J. C. P. Woodcock, editors, </editor> <booktitle> Proceedings of the Third Refinement Workshop, Workshops in Computing Series, </booktitle> <pages> pages 51-69, </pages> <address> Berlin, 1990. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In this paper we consider what protection means with respect to partiality and underspecification. Our treatment of protection is not meant to be exhaustive, but merely to illustrate concepts that are useful with some logics that are widely used for formal specification. (See <ref> [8, 14] </ref> for surveys that also cover additional kinds of logics that might be used in formal specification, and hence might need their own concepts of protection.
Reference: [9] <author> D. Coleman and J. W. Hughes. </author> <title> The clean termination of Pascal programs. </title> <journal> Acta Informatica, </journal> <volume> 11 </volume> <pages> 195-210, </pages> <year> 1979. </year>
Reference-contexts: These resemble the domain predicates, Dom (`E'), described by some authors <ref> [12, 9, 5] </ref>. However, they have a different purpose, since an operator, such as choose on nonempty sets, may be underspecified for a reason other than being partial.
Reference: [10] <author> L. M. G. Feijs and H. B. M. Jonkers. </author> <title> Formal Specification and Design, </title> <booktitle> volume 35 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> Cambridge, UK, </address> <year> 1992. </year>
Reference-contexts: For example, VDM-SL [19, 1] uses a logic called LPF [19, Section 3.3] [2, 3, 20], which has three logical values and two kinds of equality. 1 As another example, the specification language COLD-K <ref> [10] </ref> uses a logic having just two logical values, but in which all other types have an improper value, ?, which models the "undefined" results of partial functions, and also models computations that go into infinite loops or cause errors. All other values are proper. <p> However, they have a different purpose, since an operator, such as choose on nonempty sets, may be underspecified for a reason other than being partial. They also resemble the definedness predicate (D) used in studies of partial algebras [7] and in COLD <ref> [10] </ref>; however D is defined model-theoretically, not syntactically. The definition of Exact (`') is based on the exact clauses given in the trait's implications and those of included traits.
Reference: [11] <author> S. J. Garland, J. V. Guttag, and J. J. Horning. </author> <title> Debugging Larch Shared Language specifications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(6) </volume> <pages> 1044-1057, </pages> <month> Sept. </month> <year> 1990. </year> <month> 20 </month>
Reference-contexts: The concept of an exact term is based on an extension to LSL that allows one to specify which terms are not intended to be underspecified. This extension to LSL provides better documentation and allows enhanced debugging (in the sense of <ref> [11] </ref> [15, Chapter 7]) of LSL specifications. <p> B.1 Conversion In an LSL trait, one can state redundant properties (theorems) that one believes do (or should) hold. These redundant properties are stated in the implies section of the specification. Proofs of such properties can be attempted, and are a way of debugging the trait <ref> [11] </ref> [15, Chapter 7]. For our purposes, the most interesting kind of redundant property one can state in the implies section is that an operator is well-defined with respect to other operators. This is done by using a converts clause, as was done in Figure 14.
Reference: [12] <author> S. M. </author> <title> German. Automating proofs of the absence of common runtime errors. </title> <booktitle> In Conference record of the Fifth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 105-118. </pages> <publisher> ACM, </publisher> <month> Jan. </month> <year> 1978. </year>
Reference-contexts: These resemble the domain predicates, Dom (`E'), described by some authors <ref> [12, 9, 5] </ref>. However, they have a different purpose, since an operator, such as choose on nonempty sets, may be underspecified for a reason other than being partial.
Reference: [13] <author> M. Gogolla, S. Conrad, G. Denker, R. Herzig, N. Vlachantonis, and H. Ehrig. </author> <title> TROLL light | the language and its development environment. </title> <editor> In M. Broy and S. Jahnichen, editors, KORSO: </editor> <booktitle> Methods, Languages and Tools for the Construction of Correct Software, volume 1009 of Lecture Notes in Computer Science, </booktitle> <pages> pages 205-220. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1995. </year>
Reference-contexts: behavioral interface specification protects "its users from the incompleteness of the" mathematical vocabulary used in that specification "by ensuring that the meaning of the procedure specification is independent of any incompleteness" in that vocabulary (p. 123). 2.1 Partiality Protection In a specification language like VDM-SL or COLD-K, and TROLL light <ref> [13] </ref>, the notion of a procedure specification that protects against partiality is relatively straightforward.
Reference: [14] <author> D. Gries and F. B. Schneider. </author> <title> Avoiding the undefined by underspecification. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Computer Science Today: Recent Trends and Developments, number 1000 in Lecture Notes in Computer Science, </booktitle> <pages> pages 366-373. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1995. </year>
Reference-contexts: In this paper we consider what protection means with respect to partiality and underspecification. Our treatment of protection is not meant to be exhaustive, but merely to illustrate concepts that are useful with some logics that are widely used for formal specification. (See <ref> [8, 14] </ref> for surveys that also cover additional kinds of logics that might be used in formal specification, and hence might need their own concepts of protection. <p> The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses underspecifica-tion. In such a logic, one avoids specifying a value for undefined terms <ref> [14, 18] </ref>. In this approach, to make a term "undefined" one simply does not specify its value; hence it will not be possible to prove anything about such a term. <p> For example, head (empty) denotes some element of the appropriate type, even if the user has not specified what element that term denotes. Where an LSL specification is silent, terms take on some (unspecified) value. In common with other logics that use underspecification to avoid the undefined <ref> [14] </ref>, the logic of LSL is classical, and thus has several pleasing formal properties. <p> For example, one can write factTrait as in Figure 6, where the equation for the recursive case is only postulated to hold for 17 its intended domain <ref> [14] </ref>. By writing factTrait in that way, one avoids postulating Equation (9); that is, nothing at all is specified about the value of fact (-1).
Reference: [15] <author> J. V. Guttag, J. J. Horning, S. Garland, K. Jones, A. Modet, and J. Wing. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1993. </year>
Reference-contexts: In this approach, to make a term "undefined" one simply does not specify its value; hence it will not be possible to prove anything about such a term. This kind of logic is used in the Larch Shared Language, LSL <ref> [15, Chapter 4] </ref> [16], which is the mathematical component of the Larch family BISLs [15], in the BISLs of the RESOLVE family [24], 1 However, in LPF nonstrict (i.e., strong) equality and the definedness operator, , are only used in meta-arguments, since the logic is designed so that one only needs <p> This kind of logic is used in the Larch Shared Language, LSL [15, Chapter 4] [16], which is the mathematical component of the Larch family BISLs <ref> [15] </ref>, in the BISLs of the RESOLVE family [24], 1 However, in LPF nonstrict (i.e., strong) equality and the definedness operator, , are only used in meta-arguments, since the logic is designed so that one only needs to use strict (i.e., weak) equality in proofs. 4 and in Z [17, 26] <p> First we define the notion of a primed LSL trait and primed LSL term. (A LSL trait is a specification of mathematical vocabulary in an augmented form of first-order logic with equality <ref> [15, Chapter 4] </ref>.) That notion is used to describe a notion of a "completely-defined" term. An LSL term is completely-defined if it can be proved to have the same value in all models of its trait. <p> Finally we define the notion of underspec-protection itself. The notion of a primed trait and term is a variation of the idea of "priming" traits and terms found in the Larch Prover (where it is used in proving that an operator is "converted" <ref> [15, pp. 142-4] </ref>). Definition 2.2 (Primed Trait, T 0 ) Let T be an LSL trait. <p> The trait factTrait 0 has fact replaced by fact 0 , but true and the boolean operators are not primed, and neither are 0, pred, and succ, because they are mentioned in the generated by clause of the trait Integer <ref> [15, p. 161] </ref>. Operators mentioned in a generated by clause are meant to give a way to produce all values of a given sort; priming these would add "junk" to the specification. <p> As another example, consider the trait ChoiceSet <ref> [15, p. 176] </ref> where the operator choose is specified as follows. b 6= - ) choose (b) 2 b For this trait, the term choose (f1g [ f2g) is not completely-defined. <p> This is done by using a converts clause. A converts clause says that the axioms of the trait uniquely define the operators named in the clause, "relative to the other operators in the trait" <ref> [15, p. 142] </ref>. (We include in Appendix B a more detailed explanation of conversion for the sake of completeness.) However, proving that an LSL operator is converted does not mean it is completely-defined; it may still be underspecified. For example, consider the trait in Figure 8. <p> The concept of an exact term is based on an extension to LSL that allows one to specify which terms are not intended to be underspecified. This extension to LSL provides better documentation and allows enhanced debugging (in the sense of [11] <ref> [15, Chapter 7] </ref>) of LSL specifications. <p> For example, the operator that returns the head of a list can be modeled as a partial function on lists; if that is done, then head (empty) fails to denote an element. (That is, head (empty) is "undefined.") The logic used by the Larch Shared Language (LSL) <ref> [15, Chapter 4] </ref> [16] deals with partiality by using underspecification. As noted in the main body, this means that one avoids specifying a value for undefined terms, but the logic assumes that all functions are total. <p> B.1 Conversion In an LSL trait, one can state redundant properties (theorems) that one believes do (or should) hold. These redundant properties are stated in the implies section of the specification. Proofs of such properties can be attempted, and are a way of debugging the trait [11] <ref> [15, Chapter 7] </ref>. For our purposes, the most interesting kind of redundant property one can state in the implies section is that an operator is well-defined with respect to other operators. This is done by using a converts clause, as was done in Figure 14. <p> This is done by using a converts clause, as was done in Figure 14. A converts clause says that the axioms of the trait uniquely define the operators named in the clause, "relative to the other operators in the trait" <ref> [15, p. 142] </ref>. To prove this, one must show it for all possible arguments. The Larch Prover (LP) uses the following proof technique [15, pp. 142-4]. Let T ( ~ f ) be a trait, which names operators ~ f in converts clauses in its implies section. <p> A converts clause says that the axioms of the trait uniquely define the operators named in the clause, "relative to the other operators in the trait" [15, p. 142]. To prove this, one must show it for all possible arguments. The Larch Prover (LP) uses the following proof technique <ref> [15, pp. 142-4] </ref>. Let T ( ~ f ) be a trait, which names operators ~ f in converts clauses in its implies section. <p> B.2 An extension to LSL The exempting clause in the current LSL <ref> [15, Chapter 4] </ref> [16] does not have enough expressive power to state, in general, what is left underspecified. One can only exempt a class of terms that are described by constants or universally quantified variables.
Reference: [16] <author> J. V. Guttag, J. J. Horning, and A. Modet. </author> <title> Report on the Larch Shared Language: Version 2.3. </title> <type> Technical Report 58, </type> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <address> 130 Lytton Avenue, Palo Alto, CA 94301, </address> <month> Apr. </month> <year> 1990. </year> <title> Order from src-report@src.dec.com. </title>
Reference-contexts: In this approach, to make a term "undefined" one simply does not specify its value; hence it will not be possible to prove anything about such a term. This kind of logic is used in the Larch Shared Language, LSL [15, Chapter 4] <ref> [16] </ref>, which is the mathematical component of the Larch family BISLs [15], in the BISLs of the RESOLVE family [24], 1 However, in LPF nonstrict (i.e., strong) equality and the definedness operator, , are only used in meta-arguments, since the logic is designed so that one only needs to use strict <p> For example, the operator that returns the head of a list can be modeled as a partial function on lists; if that is done, then head (empty) fails to denote an element. (That is, head (empty) is "undefined.") The logic used by the Larch Shared Language (LSL) [15, Chapter 4] <ref> [16] </ref> deals with partiality by using underspecification. As noted in the main body, this means that one avoids specifying a value for undefined terms, but the logic assumes that all functions are total. <p> B.2 An extension to LSL The exempting clause in the current LSL [15, Chapter 4] <ref> [16] </ref> does not have enough expressive power to state, in general, what is left underspecified. One can only exempt a class of terms that are described by constants or universally quantified variables.
Reference: [17] <author> I. Hayes, </author> <title> editor. Specification Case Studies. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <address> second edition, </address> <year> 1993. </year>
Reference-contexts: BISLs [15], in the BISLs of the RESOLVE family [24], 1 However, in LPF nonstrict (i.e., strong) equality and the definedness operator, , are only used in meta-arguments, since the logic is designed so that one only needs to use strict (i.e., weak) equality in proofs. 4 and in Z <ref> [17, 26] </ref> (according to its draft standard [30]). The subtle problems that underspecification may cause for the unwary in LSL (and similar logics) are discussed in Appendix A; indeed Jones's paper pointing out these problems [18] motivated the present work.
Reference: [18] <author> C. Jones. </author> <title> Partial functions and logics: A warning. </title> <journal> Inf. Process. Lett., </journal> <volume> 54(2) </volume> <pages> 65-67, </pages> <year> 1995. </year>
Reference-contexts: The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses underspecifica-tion. In such a logic, one avoids specifying a value for undefined terms <ref> [14, 18] </ref>. In this approach, to make a term "undefined" one simply does not specify its value; hence it will not be possible to prove anything about such a term. <p> The subtle problems that underspecification may cause for the unwary in LSL (and similar logics) are discussed in Appendix A; indeed Jones's paper pointing out these problems <ref> [18] </ref> motivated the present work. It is not the purpose of this paper to advocate one kind of logic over another. Instead, this paper explores concepts of protection, with the aim of improving intuition about it and providing more guidance to specifiers. <p> Where an LSL specification is silent, terms take on some (unspecified) value. In common with other logics that use underspecification to avoid the undefined [14], the logic of LSL is classical, and thus has several pleasing formal properties. However, as Jones pointed out in a recent paper <ref> [18] </ref>, there are a few subtle aspects to this kind of logic that users should be aware of. 15 JonesExample1: trait includes Integer introduces it: ! OneElem f: Int ! OneElem asserts OneElem generated by it 8 i: Int f (i) == if i=0 then it else f (i-1) implies converts <p> This trait defines a sort, OneElem, a constant it, and a function f. Because of the generated by clause, the sort OneElem has only one element, the constant it. (The current version of LSL allows such sorts, contrary to <ref> [18] </ref>.) In LSL f (-1) = it, because f has to take on some value when applied to -1, and the only possible value is it.
Reference: [19] <author> C. B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: For example, VDM-SL <ref> [19, 1] </ref> uses a logic called LPF [19, Section 3.3] [2, 3, 20], which has three logical values and two kinds of equality. 1 As another example, the specification language COLD-K [10] uses a logic having just two logical values, but in which all other types have an improper value, ?, <p> For example, VDM-SL [19, 1] uses a logic called LPF <ref> [19, Section 3.3] </ref> [2, 3, 20], which has three logical values and two kinds of equality. 1 As another example, the specification language COLD-K [10] uses a logic having just two logical values, but in which all other types have an improper value, ?, which models the "undefined" results of partial
Reference: [20] <author> C. B. Jones and K. Middelburg. </author> <title> A typed logic of partial functions reconstructed classically. </title> <journal> Acta Informatica, </journal> <volume> 31(5) </volume> <pages> 399-430, </pages> <year> 1994. </year>
Reference-contexts: For example, VDM-SL [19, 1] uses a logic called LPF [19, Section 3.3] <ref> [2, 3, 20] </ref>, which has three logical values and two kinds of equality. 1 As another example, the specification language COLD-K [10] uses a logic having just two logical values, but in which all other types have an improper value, ?, which models the "undefined" results of partial functions, and also
Reference: [21] <author> B. Konikowska, A. Tarlecki, and A. Blikle. </author> <title> A three-valued logic for software specification and validation. </title> <note> Fundamenta Informaticae, XIV:411-453, </note> <year> 1991. </year>
Reference-contexts: All other values are proper. In COLD-K there is also a definedness predicate, D, that allows one to reason explicitly about whether a term denotes a proper value or not. There are several other languages with similar concepts <ref> [4, 6, 27, 21, 29] </ref>. The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses underspecifica-tion. In such a logic, one avoids specifying a value for undefined terms [14, 18].
Reference: [22] <author> G. T. Leavens. </author> <note> Larch/C++ Reference Manual. Version 5.10. Available in ftp://ftp.cs.iastate.edu/pub/larchc++/lcpp.ps.gz or on the World Wide Web at the URL http://www.cs.iastate.edu/~leavens/larchc++.html, Aug. </note> <year> 1997. </year>
Reference-contexts: requires informally "x is nonnegative and x is not too big"; ensures informally "result is the factorial of x"; - The pre- and postconditions follow requires and ensures, respectively; when the precondition is satisfied, the procedure must terminate in a state that satisfies the postcondition. (The keyword informally in Larch/C++ <ref> [22] </ref> signals the start of an informal predicate.) This specification is ill-defined, because it is not clear what the procedure should return when x is negative.
Reference: [23] <author> B. Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <year> 1988. </year>
Reference-contexts: Checks that a VDM-SL procedure is underspec-protective can be done in same way as we described them for the Larch family. Both kinds of protection may also be useful for writers of executable specifications. For example, in a language like Eiffel <ref> [23] </ref>, partiality-protection for a procedure would ensure that its precondition would be flagged as false instead of encountering an error, allowing an error to happen in its body, or encountering an error in its postcondition.
Reference: [24] <author> W. F. Ogden, M. Sitaraman, B. W. Weide, and S. H. </author> <title> Zweben. Part I: The RESOLVE framework and discipline | a research synopsis. </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 19(4) </volume> <pages> 23-28, </pages> <month> Oct </month> <year> 1994. </year> <month> 21 </month>
Reference-contexts: This kind of logic is used in the Larch Shared Language, LSL [15, Chapter 4] [16], which is the mathematical component of the Larch family BISLs [15], in the BISLs of the RESOLVE family <ref> [24] </ref>, 1 However, in LPF nonstrict (i.e., strong) equality and the definedness operator, , are only used in meta-arguments, since the logic is designed so that one only needs to use strict (i.e., weak) equality in proofs. 4 and in Z [17, 26] (according to its draft standard [30]).
Reference: [25] <author> S. Owre, J. Rushby, N. Shankar, and F. von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <month> Feb. </month> <year> 1995. </year>
Reference-contexts: Also PVS <ref> [25] </ref> represents another kind of specification logic that should be considered in extending our concepts.) The first concept of protection we discuss is appropriate for behavioral interface specification languages (BISLs) that use a logic that accepts the existence of partial functions and has various non-classical ways to reason about them.
Reference: [26] <author> J. M. Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <address> New York, N.Y., </address> <note> second edition, </note> <year> 1992. </year>
Reference-contexts: BISLs [15], in the BISLs of the RESOLVE family [24], 1 However, in LPF nonstrict (i.e., strong) equality and the definedness operator, , are only used in meta-arguments, since the logic is designed so that one only needs to use strict (i.e., weak) equality in proofs. 4 and in Z <ref> [17, 26] </ref> (according to its draft standard [30]). The subtle problems that underspecification may cause for the unwary in LSL (and similar logics) are discussed in Appendix A; indeed Jones's paper pointing out these problems [18] motivated the present work.
Reference: [27] <author> D. S. Stefan Kahrs and A. Tarlecki. </author> <title> The definition of Extended ML: a gentle introduction. </title> <type> Technical Report ECS-LFCS-95-322, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, </institution> <month> Oct. </month> <year> 1995. </year> <note> To appear in Theoretical Computer Science. </note>
Reference-contexts: All other values are proper. In COLD-K there is also a definedness predicate, D, that allows one to reason explicitly about whether a term denotes a proper value or not. There are several other languages with similar concepts <ref> [4, 6, 27, 21, 29] </ref>. The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses underspecifica-tion. In such a logic, one avoids specifying a value for undefined terms [14, 18].
Reference: [28] <author> J. M. Wing. </author> <title> A two-tiered approach to specifying programs. </title> <type> Technical Report TR-299, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <year> 1983. </year>
Reference-contexts: Instead, this paper explores concepts of protection, with the aim of improving intuition about it and providing more guidance to specifiers. We also discuss how to prove protection from the effects of underspecification. 2 Protective Procedure Specifications The idea of protection in a BISL was first formulated by Wing <ref> [28, Section 5.1.4] </ref>.
Reference: [29] <author> U. Wolter, K. Didrich, F. Cornelius, M. Klar, R. Wessaly, and H. Ehrig. </author> <title> How to cope with the spectrum of spectrum. </title> <editor> In M. Broy and S. Jahnichen, editors, KORSO: </editor> <booktitle> Methods, Languages and Tools for the Construction of Correct Software, volume 1009 of Lecture Notes in Computer Science, </booktitle> <pages> pages 173-189. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1995. </year>
Reference-contexts: All other values are proper. In COLD-K there is also a definedness predicate, D, that allows one to reason explicitly about whether a term denotes a proper value or not. There are several other languages with similar concepts <ref> [4, 6, 27, 21, 29] </ref>. The second concept of protection we discuss is appropriate for BISLs that use a logic that does not admit the existence of partial functions, but uses underspecifica-tion. In such a logic, one avoids specifying a value for undefined terms [14, 18].
Reference: [30] <author> J. Woodcock and D. Jackson. </author> <title> About the semantics of partial functions in Z. </title> <type> Personal communication, </type> <month> Apr. </month> <year> 1996. </year>
Reference-contexts: RESOLVE family [24], 1 However, in LPF nonstrict (i.e., strong) equality and the definedness operator, , are only used in meta-arguments, since the logic is designed so that one only needs to use strict (i.e., weak) equality in proofs. 4 and in Z [17, 26] (according to its draft standard <ref> [30] </ref>). The subtle problems that underspecification may cause for the unwary in LSL (and similar logics) are discussed in Appendix A; indeed Jones's paper pointing out these problems [18] motivated the present work. It is not the purpose of this paper to advocate one kind of logic over another.
References-found: 30

