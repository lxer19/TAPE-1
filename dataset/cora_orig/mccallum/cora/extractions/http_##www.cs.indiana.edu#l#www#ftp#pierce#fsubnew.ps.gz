URL: http://www.cs.indiana.edu/l/www/ftp/pierce/fsubnew.ps.gz
Refering-URL: http://www.cs.indiana.edu/l/www/ftp/pierce/
Root-URL: http://www.cs.indiana.edu
Email: castagna@dmi.ens.fr  bcp@dcs.ed.ac.uk  
Title: Decidable Bounded Quantification  
Author: Giuseppe Castagna LIENS(CNRS)-DMI Benjamin C. Pierce 
Date: February 27, 1994  
Address: Edinburgh  
Affiliation: LFCS, Univ. of  
Abstract: The standard formulation of bounded quantification, system F , is difficult to work with and lacks important syntactic properties, such as decidability. More tractable variants have been studied, but those studied so far either exclude significant classes of useful programs or lack a compelling semantics. We propose here a simple variant of F that ameliorates these difficulties. It has a natural semantic interpretation, enjoys a number of important properties that fail in F , and includes all of the programming examples for which F has been used in practice. Since publication of this paper in POPL '94, we have become aware of a serious shortcoming in the system studied here. Although the subtyping relation is well behaved, the typing relation, which we did not consider explicitly, fails to possess the crucial property of minimal typing. More details can be found in two messages from the Types forum, reproduced in Appendix B.
Abstract-found: 1
Intro-found: 1
Reference: [Ama91] <author> R. Amadio. </author> <title> Recursion and Subtyping in Lambda Calculi. </title> <type> PhD thesis, </type> <institution> Universita degli Studi di Pisa, </institution> <year> 1991. </year>
Reference-contexts: For a deeper treatment of the combination of recursion and subtyping see <ref> [Ama91] </ref>.
Reference: [BM92] <author> Kim Bruce and John Mitchell. </author> <title> PER models of subtyping, recursive types and higher-order polymorphism. </title> <booktitle> In Proceedings of the Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> Albequerque, NM, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: Moreover, the rule (8-top) is arguably more natural than the other variants we have mentioned, since it embodies a notion of pointwise subtyping familiar from the treatment of other type constructors <ref> [Mit90, BM92, Bru93, PT93] </ref>: it simply says that 8F 8G (with F; G : Type!Type) iff dom (G) dom (F ) and F is pointwise smaller than G. F enjoys many syntactic properties missing from F .
Reference: [Bru93] <author> K. B. Bruce. </author> <title> Safe type checking in a statically typed object-oriented programming language. </title> <booktitle> In 20th Ann. ACM Symp. on Principles of Programming Languages. </booktitle> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: Moreover, the rule (8-top) is arguably more natural than the other variants we have mentioned, since it embodies a notion of pointwise subtyping familiar from the treatment of other type constructors <ref> [Mit90, BM92, Bru93, PT93] </ref>: it simply says that 8F 8G (with F; G : Type!Type) iff dom (G) dom (F ) and F is pointwise smaller than G. F enjoys many syntactic properties missing from F .
Reference: [BTCGS91] <author> V. Breazu-Tannen, T. Coquand, C. Gunter, and A. Scedrov. </author> <title> Inheritance as implicit coercion. </title> <journal> Information and Computation, </journal> <volume> 93(1) </volume> <pages> 172-221, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: In the same way, we obtain a simpler proof of coherence of the semantic framework for bounded quantification proposed by Breazu-Tannen, Coquand, Gunter, and Scedrov <ref> [BTCGS91] </ref>, which we sketch in Section 5; indeed, the existence of meets and joins in our subtype relation permits us to prove the coherence of a stronger system including variant types. ([BTCGS91] established a similar result for the variant of F with variant types and the (8-Fun) rule.) One of the <p> By the induction hypothesis, ` A S 3 S 1 and [ fX Topg ` A S 0 0 3 ; the result follows by (Alg8). Note that this case causes significant difficulty in the proofs of Curien and Ghelli [CG92] and Breazu-Tannen et al. <ref> [BTCGS91] </ref>. End of proof. Theorem 4.4 (Soundness and completeness) For each context and well-formed types S 1 and S 2 , Proof. We start by proving soundness ()) by induction on the depth of the proof of ` A S 1 S 2 . <p> In this section we introduce terms and three new type constructors. We provide a sound semantics for the obtained language and a coherence result for the corresponding proof system. This section is largely based on <ref> [BTCGS91] </ref>, where the reader can find a more detailed presentation of the technique we use here. In [BTCGS91], a semantics for F plus record and recursive types is given by translating the system into an extension of System F for which sound semantic interpretations are already defined. <p> We provide a sound semantics for the obtained language and a coherence result for the corresponding proof system. This section is largely based on <ref> [BTCGS91] </ref>, where the reader can find a more detailed presentation of the technique we use here. In [BTCGS91], a semantics for F plus record and recursive types is given by translating the system into an extension of System F for which sound semantic interpretations are already defined. The soundness of the method is given by a coherence result. <p> The soundness of the method is given by a coherence result. This proof fails if variant types are also added to the system (this is essentially due to the absence of meets and joins in F ). Our system behaves better since the technique of <ref> [BTCGS91] </ref> works for our system even if we extend it by variant types, as we show in this section. 5.1 Extended F &gt; We enrich our set of types by record types (hh` 1 : T 1 ; : : : ; ` p : T p ii), variant types ([` <p> ` 1 ; : : : ; ` p = (a p ); inj ` p where a 1 : S 1 ffi! T 1 ; : : : ; a p : S p ffi! T p and inj ` i = x Note that, unlike the translation in <ref> [BTCGS91] </ref>, the term interpreting forall is linear in the parameter x. The interpretation via of coercions as functions must completely determine their identity as coercions. <p> ; : : : ; ` n ) a n ) = (case a of ` 1 ) a 1 ; (P ); : : : ; ` n ) a n ; (P )) The precise definitions of all the rules can be found in the Appendix B of <ref> [BTCGS91] </ref>, which also discusses the motivation for the rule hCRNi. 15 5.3 Translation We are now ready to give the formal translation of derivations of our source language. <p> Proof. The proof is much the same as the one in <ref> [BTCGS91] </ref>, although it becomes a little bit simpler. It is not surprising that the main differences lie in the proof of the coherence of the translation of the subtyping derivation, since this is where the systems differ. Thus the reader can just follow the proof in section 5 of [BTCGS91]; the <p> in <ref> [BTCGS91] </ref>, although it becomes a little bit simpler. It is not surprising that the main differences lie in the proof of the coherence of the translation of the subtyping derivation, since this is where the systems differ. Thus the reader can just follow the proof in section 5 of [BTCGS91]; the differences are as follows: * In Lemma 6 of [BTCGS91], use the equality forall (a)(X:x X ffi!1 :b) fi forall (c)(X:y X ffi!1 :d) = forall (c fi a)(X:y X ffi!1 to prove the equality of the translations when the derivation ends by a (8) rule. * Erase Lemma <p> Thus the reader can just follow the proof in section 5 of <ref> [BTCGS91] </ref>; the differences are as follows: * In Lemma 6 of [BTCGS91], use the equality forall (a)(X:x X ffi!1 :b) fi forall (c)(X:y X ffi!1 :d) = forall (c fi a)(X:y X ffi!1 to prove the equality of the translations when the derivation ends by a (8) rule. * Erase Lemma 7. * Use the same proof for Lemma 8 (of course <p> section to take into account the new type constructors (it essentially amounts to add two cases that can be solved by a straight forward use of the induction hypothesis induction: the weight of a record/variant being the sum of the weights of its components): this corresponds to Lemma 11 of <ref> [BTCGS91] </ref> (and it is where that proof failed for F ). * The proof of Lemma 12 is nearly the same: just replace in the case [8Elim] (in the paper [B-SPEC]) every occurrence of a s i and a r in the type contexts by a Top and use the (FORALL) <p> For a review of the models of TARGET see section 6 of <ref> [BTCGS91] </ref>. 17 6 Conservativity of Simple Recursive Types In Section 5, the only rule for comparing recursive types was reflexivity.
Reference: [Car92] <author> Luca Cardelli. </author> <title> Extensible records in a pure calculus of subtyping. </title> <note> Research report 81, DEC Systems Research Center, January 1992. To appear in [GM93]. </note>
Reference-contexts: Similarly, all the example programs in Cardelli's implementation of F [Car93] also typecheck in F &gt; , apart from the intentionally pathological cases cited above [Luca Cardelli, personal communication, 1993] Another fairly complex application of bounded quantification is Cardelli's translation of a calculus of extensible record operations into pure F <ref> [Car92] </ref>. Again, since each of the row variables in the high-level calculus is translated into a row of type variables bounded by Top, F appears to work just as well.
Reference: [Car93] <author> L. Cardelli. </author> <title> An implementation of F &lt;: </title> . <type> Technical Report 97, </type> <institution> Digital Equipment Corporation, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Similarly, all the example programs in Cardelli's implementation of F <ref> [Car93] </ref> also typecheck in F &gt; , apart from the intentionally pathological cases cited above [Luca Cardelli, personal communication, 1993] Another fairly complex application of bounded quantification is Cardelli's translation of a calculus of extensible record operations into pure F [Car92].
Reference: [CG92] <author> P. L. Curien and G. Ghelli. </author> <title> Coherence of subsumption, minimum typing and the type checking in F . Mathematical Structures in Computer Science, </title> <type> 2(1), </type> <year> 1992. </year>
Reference-contexts: The standard formulation of second-order bounded quantification, often called F ("F-sub"), was given by Curien and Ghelli <ref> [CG92] </ref>. Its subtype relation includes the following rule for comparing polymorphic types: (8-orig) ` T 1 S 1 [ fX T 1 g ` S 2 T 2 X 62 dom () Intuitively, this rule may be read as follows. <p> The easier syntactic formulation also leads to a significant simplification of the proofs for this system. For example, Curien and Ghelli prove the admissibility of the rule of transitivity <ref> [CG92] </ref> using a rewiting technique similar to Gentzen's cut-elimination theorem, whereas here a simple induction on proofs suffices. <p> The difference in expressive power between F and F &gt; can be understood by observing the behavior of their "standard" algorithms for checking the subtype relation. (For F , the standard algorithm <ref> [CG92] </ref> is a semi-decision procedure; the algorithm for F &gt; presented in Section 4.1 below is a decision procedure.) The two algorithms are identical at all points, except for the cases for comparing two quantified types, which are just the rules (8-orig) and (8-top), respectively. <p> We show the decidability of the subtyping relation, the existence of a least upper bound (lub) for every finite set of types and a greatest lower bound (glb) for every finite and downward-bounded set of types. 4.1 Subtyping algorithm It is easy to adapt Curien and Ghelli's algorithm <ref> [CG92] </ref> to F &gt; . Only the rule (Alg8) is different: here it is identical to (8-top), whereas in the algorithm for F it coincides with (8-orig). <p> By the induction hypothesis, ` A S 3 S 1 and [ fX Topg ` A S 0 0 3 ; the result follows by (Alg8). Note that this case causes significant difficulty in the proofs of Curien and Ghelli <ref> [CG92] </ref> and Breazu-Tannen et al. [BTCGS91]. End of proof. Theorem 4.4 (Soundness and completeness) For each context and well-formed types S 1 and S 2 , Proof. We start by proving soundness ()) by induction on the depth of the proof of ` A S 1 S 2 .
Reference: [CW85] <author> L. Cardelli and P. Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year> <month> 21 </month>
Reference-contexts: 1 Introduction Since its introduction by Cardelli and Wegner <ref> [CW85] </ref>, the idea of bounded quantification has become a fundamental tool in the study of statically typed programming languages combining subtyping and polymorphism. <p> The weaker "equal-bounds subtyping rule" from Cardelli and Wegner's original Fun calculus <ref> [CW85] </ref> (8-Fun) ` 8 (X U )S 2 8 (X U )T 2 avoids this confusion and yields a system for which the subtyping problem can easily be shown to be decidable, at the cost of introducing an ugly syntactic restriction | that the bounds of the two types must be
Reference: [dB72] <author> Nicolas G. de Bruijn. </author> <title> Lambda-calculus notation with nameless dummies: a tool for automatic formula manipulation with application to the Church-Rosser theorem. </title> <journal> Indag. Math., </journal> <volume> 34(5) </volume> <pages> 381-392, </pages> <year> 1972. </year>
Reference-contexts: F , another property that fails in F [Ghe93b]. 2 Syntax In what follows, we work modulo ff-conversion for type variables, with the convention that bound variables are silently ff-converted as necessary so that contexts and types appearing in instances of the rules are well formed. (Equivalently, we follow deBruijn <ref> [dB72] </ref> in regarding the connection between occurrences of variables and their binders as part of the syntax of the calculus, considering "poorly scoped" terms as not even parseable.) It easy to check that, for example, the rules below preserve the well-formedness of judgments, i.e. the judgments in the premises are well
Reference: [Ghe90] <author> G. Ghelli. </author> <title> Proof Theoretic Studies about a Minimal Type System Integrating Inclusion and Parametric Polymorphism. </title> <type> PhD thesis, </type> <institution> Dipartimento di Inform-atica, Universita di Pisa, </institution> <month> March </month> <year> 1990. </year> <type> Tech. Rep. </type> <institution> TD-6/90. </institution>
Reference-contexts: To begin with, the subtype relation is undecidable [Pie93, Ghe93b], which implies the undecidability of the typechecking problem even for explicitly typed terms. Even more seriously, F lacks greatest lower bounds for compatible (i.e. lower-bounded) sets of types <ref> [Ghe90] </ref>, which blocks certain useful forms of argument by induction on the subtype relation. <p> Corollary 4.8 The algorithm terminates. 4.2 Meets and joins Decidability of subtyping is clearly a desirable property, but in practice the undecidability of F has been much less problematic than the nonexistence of least upper bounds and greatest lower bounds in the subtype relation. Ghelli <ref> [Ghe90] </ref> observed that, in F , the types S 8 (Z X ! Y ) X ! Y T 8 (Z X ! Y ) X ! Y in the context fX Top; Y Top; X X; Y Y g have two lower bounds | namely U 8 (Z X 0
Reference: [Ghe93a] <author> G. Ghelli. </author> <title> Divergence of F type-checking. </title> <type> Technical Report 5/93, </type> <institution> Dipartimento d'Informatica, Universita degli Studi di Pisa, </institution> <year> 1993. </year>
Reference-contexts: S and T for which ` S T is provable in F but not in F &gt; instance, the construction used to show the undecidability of F [Pie93] depends crucially on the form of F 's original quantifier subtyping rule; similar examples can be built using techniques studied by Ghelli <ref> [Ghe93a] </ref> in his analysis of the possibility of nontermination in the standard semi-decision procedure for the F subtype relation. But these examples were designed specifically to illustrate pathologies in F . Are there any useful examples that lie between F and F &gt; ? We believe not.
Reference: [Ghe93b] <author> G. Ghelli. </author> <title> Recursive types are not conservative over F . In M. </title> <editor> Bezem and J.F. Groote, editors, </editor> <booktitle> International Conference on Typed Lambda calculi and Applications, number 664 in LNCS, </booktitle> <pages> pages 146-162, </pages> <address> Utrecht, The Netherlands, March 1993. </address> <publisher> Springer-Verlag. TLCA'93. </publisher>
Reference-contexts: To begin with, the subtype relation is undecidable <ref> [Pie93, Ghe93b] </ref>, which implies the undecidability of the typechecking problem even for explicitly typed terms. Even more seriously, F lacks greatest lower bounds for compatible (i.e. lower-bounded) sets of types [Ghe90], which blocks certain useful forms of argument by induction on the subtype relation. <p> We illustrate this in 3 Section 6, which shows how a simple kind of recursive types form a conservative extension of F , another property that fails in F <ref> [Ghe93b] </ref>. 2 Syntax In what follows, we work modulo ff-conversion for type variables, with the convention that bound variables are silently ff-converted as necessary so that contexts and types appearing in instances of the rules are well formed. (Equivalently, we follow deBruijn [dB72] in regarding the connection between occurrences of variables <p> In <ref> [Ghe93b] </ref> it is shown that adding these two rules to F leads to a non-conservative extension | i.e. that there is a subtyping judgment in F which is not provable in the original system but which is provable with the extended system. <p> Let us see more precisely the types we take into account; they are those of F &gt; plus the recursive types: T ::= X j T ! T j 8 (X S)T j X:T As in <ref> [Ghe93b] </ref>, we forbid recursive types whose body is either Y , Top, or X:T ; this will simplify the proofs without changing the power of the system: the first two can be forbidden since X:Y (Y 6 X), and X:Top denote just Y and Top; X:X is meaningless (this is the
Reference: [Ghe93c] <author> G. Ghelli. </author> <title> S-All-Loc is not transitive. Mail to the TYPES mailing list, </title> <month> February </month> <year> 1993. </year>
Reference-contexts: Another obvious variation uses the bound S 1 of the smaller type in place of T 1 in the right-hand premise: (8-local) ` T 1 S 1 [ fX S 1 g ` S 2 T 2 X 62 dom () But Giorgio Ghelli has pointed out <ref> [Ghe93c] </ref> that this variant is algorithmically impractical, although the problem of its decidability remains open.
Reference: [Gir72] <author> J-Y. Girard. </author> <title> Interpretation fonctionelle et elimination des coupures dans l'arithmetique d'ordre superieur. </title> <institution> These de doctorat d'etat, 1972. Universite Paris VII. </institution>
Reference-contexts: 1 Introduction Since its introduction by Cardelli and Wegner [CW85], the idea of bounded quantification has become a fundamental tool in the study of statically typed programming languages combining subtyping and polymorphism. Systems with bounded quantification are formed by enriching a typed -calculus, such as System F <ref> [Gir72, Rey74] </ref> or F ! [Gir72], with a subtype relation on type expressions, ` An extended abstract of this paper has been presented in the 21st Annual Symposium on Principles of Programming Languages. <p> Systems with bounded quantification are formed by enriching a typed -calculus, such as System F [Gir72, Rey74] or F ! <ref> [Gir72] </ref>, with a subtype relation on type expressions, ` An extended abstract of this paper has been presented in the 21st Annual Symposium on Principles of Programming Languages. <p> In this way we obtain the coherence of our semantic interpretation. 5.2 The language TARGET The target language is an extension of Girard's System F <ref> [Gir72] </ref> with recursive types, variants, records, and coercion spaces. Coercion spaces are used to interpret subtyping judgments (for the reader acquaitened with the models of System F, coercion spaces are interpreted as strict maps in the model of dI-domains and as linear maps in coherent spaces).
Reference: [GM93] <author> Carl A. Gunter and John C. Mitchell. </author> <title> Theoretical Aspects of Object-Oriented Programming: Types, Semantics, and Language Design. </title> <publisher> The MIT Press, </publisher> <year> 1993. </year> <note> To appear. </note>
Reference: [GP93] <author> G. Ghelli and B. Pierce. </author> <title> Bounded existentials and minimal typing. </title> <type> Draft report, </type> <institution> Dipartimento d'Informatica Universita di Pisa, </institution> <year> 1993. </year> <note> Unpublished. </note>
Reference-contexts: Even more seriously, F lacks greatest lower bounds for compatible (i.e. lower-bounded) sets of types [Ghe90], which blocks certain useful forms of argument by induction on the subtype relation. The most natural extension of F with bounded existential types <ref> [GP93] </ref> even fails to possess a minimal type for every typeable term! In all these cases, it is the quantifier subtyping rule that appears as the principal culprit. <p> This leads us to believe that F &gt; should also retain the minimal typing property when extended by bounded existential types. (This property has been established in <ref> [GP93] </ref> for F with (8-Fun) instead of (8-orig) by showing the completeness of a type synthesis algorithm suggested by Dezani, which can perhaps be adapted to (8-top).) The investigation of extensions of F &gt; with higher-order polymorphism is also underway.
Reference: [KS92] <author> D. Katiyar and S. Sankar. </author> <title> Completely bounded quantification is decidable. </title> <booktitle> In Proceedings of the ACM SIGPLAN Workshop on ML and its Applications, </booktitle> <pages> pages 68-77, </pages> <address> San Francisco, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Other variants of (8-orig) have been proposed in the literature. Katiyar and Shankar <ref> [KS92] </ref> describe a restriction in which the bounds on polymorphic types may not contain Top. In this way they obtain a decidable subtype relation, but at significant expense in expressive 2 ness. <p> This is used in the following proof to define an ordering that depends on the bounds of a variable. Katiyar and Shankar <ref> [KS92] </ref> give a similar proof of termination for their variant of F . Lemma 4.5 For each type T well formed in a context , the weight T (T ) is finite and positive. Proof. First, it is obvious that the weight T (T ) is always positive.
Reference: [Mit90] <author> John C. Mitchell. </author> <title> Toward a typed foundation for method specialization and inheritance. </title> <booktitle> In Proceedings of the 17th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 109-124, </pages> <month> January </month> <year> 1990. </year> <note> To appear in [GM93]. </note>
Reference-contexts: Moreover, the rule (8-top) is arguably more natural than the other variants we have mentioned, since it embodies a notion of pointwise subtyping familiar from the treatment of other type constructors <ref> [Mit90, BM92, Bru93, PT93] </ref>: it simply says that 8F 8G (with F; G : Type!Type) iff dom (G) dom (F ) and F is pointwise smaller than G. F enjoys many syntactic properties missing from F .
Reference: [Pie93] <author> Benjamin C. Pierce. </author> <title> Bounded quantification is undecidable. </title> <journal> Information and Computation, </journal> <note> 1993. To appear; also to appear in [GM93]. Preliminary version in proceedings of POPL '92. </note>
Reference-contexts: To begin with, the subtype relation is undecidable <ref> [Pie93, Ghe93b] </ref>, which implies the undecidability of the typechecking problem even for explicitly typed terms. Even more seriously, F lacks greatest lower bounds for compatible (i.e. lower-bounded) sets of types [Ghe90], which blocks certain useful forms of argument by induction on the subtype relation. <p> 1 )T 2 (When no ambiguity can arise, we denote the rule (8-top) simply by (8).) 3 Expressiveness There are some values of S and T for which ` S T is provable in F but not in F &gt; instance, the construction used to show the undecidability of F <ref> [Pie93] </ref> depends crucially on the form of F 's original quantifier subtyping rule; similar examples can be built using techniques studied by Ghelli [Ghe93a] in his analysis of the possibility of nontermination in the standard semi-decision procedure for the F subtype relation.
Reference: [PT93] <author> B.C. Pierce and D.N. Turner. </author> <title> Simple type-theoretic foundations for object-oriented programming. </title> <journal> Journal of Functional Programming, </journal> <note> 1993. To appear; a preliminary version appeared in Principles of Programming Languages, </note> <year> 1993, </year> <title> and as University of Edinburgh technical report ECS-LFCS-92-225, under the title "Object-Oriented Programming Without Recursive Types". </title>
Reference-contexts: Moreover, the rule (8-top) is arguably more natural than the other variants we have mentioned, since it embodies a notion of pointwise subtyping familiar from the treatment of other type constructors <ref> [Mit90, BM92, Bru93, PT93] </ref>: it simply says that 8F 8G (with F; G : Type!Type) iff dom (G) dom (F ) and F is pointwise smaller than G. F enjoys many syntactic properties missing from F . <p> Are there any useful examples that lie between F and F &gt; ? We believe not. For example, one of the areas where bounded quantification has been most intensively applied is in static type systems for object-oriented languages. One recent study by Pierce and Turner <ref> [PT93] </ref> presents a statically typed model of the core of Smalltalk using an extension of F with the higher-order polymorphism of Girard's System F ! terms in this model have exactly the same types in F &gt; as in F .
Reference: [Rey74] <author> J.C. Reynolds. </author> <title> Towards a theory of type structures. </title> <publisher> LNCS, </publisher> <pages> 19 408-425, </pages> <year> 1974. </year> <month> 22 </month>
Reference-contexts: 1 Introduction Since its introduction by Cardelli and Wegner [CW85], the idea of bounded quantification has become a fundamental tool in the study of statically typed programming languages combining subtyping and polymorphism. Systems with bounded quantification are formed by enriching a typed -calculus, such as System F <ref> [Gir72, Rey74] </ref> or F ! [Gir72], with a subtype relation on type expressions, ` An extended abstract of this paper has been presented in the 21st Annual Symposium on Principles of Programming Languages.
References-found: 21

