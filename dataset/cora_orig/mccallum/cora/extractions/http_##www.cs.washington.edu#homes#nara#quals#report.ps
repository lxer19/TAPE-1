URL: http://www.cs.washington.edu/homes/nara/quals/report.ps
Refering-URL: http://www.cs.washington.edu/homes/nara/Papers.html
Root-URL: 
Email: nara@cs.washington.edu  
Title: An Analysis of Swizzling Costs in an OODBMS  
Author: Vivek R. Narasayya 
Date: May 15, 1995  
Note: Draft of  
Abstract: Swizzling is a mechanism used by OODBMSs to convert pointers from their disk formats to a more efficient in-memory format. In this project we analyze the the costs associated with swizzling in Texas, an OODBMS which does pointer swizzling at page-fault time. We report the costs of signal handling, object translation, the virtual memory overhead, and unswizzling. We compare the performance of Texas with that of Opal, a single address space system, in which no swizzling is necessary.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Seth J. White. </author> <title> Pointer Swizzling Techniques for Object-Oriented Database Systems. </title> <type> Phd. Thesis. </type> <institution> University of Wisconsin, Madison, </institution> <year> 1994. </year>
Reference-contexts: This avoids the overhead of performing a check on each pointer access of the software scheme. However, it is possible that pointers which are never used by the application may get loaded into memory. Swizzling is a complex technique with a number of different dimensions <ref> [1] </ref>; however in this study we are concerned with one specific swizzling technique called pointer swizzling at page fl Submitted in fulfillment of the Ph.D. Qualifying Project. 1 fault time [4]. We choose this technique because it is believed to be one that carries a low runtime overhead. <p> This study is done in the context of Mneme, which is a persistent object store that swizzles in software. Thus, there is no evaluation of the hardware based swizzling scheme. White <ref> [1] </ref> describes and analyzes in detail, both software and hardware pointer swizzling techniques. The software swizzling scheme studied is that used by E, which is a persistent programming language.
Reference: [2] <author> Vivek Singhal, Sheetal V. Kakkad, and Paul R. Wilson. </author> <title> Texas: An efficient, Portable Persistent Store. </title> <booktitle> Proceedings of Fifth International Workshop on Persistent Object Sytems, </booktitle> <address> San Miniato, Italy, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: Qualifying Project. 1 fault time [4]. We choose this technique because it is believed to be one that carries a low runtime overhead. The aim of this project is to * analyze the costs of swizzling in Texas <ref> [2] </ref>, a POS that uses a virtual memory hardware to detect accesses to non-resident objects and trigger swizzling. * compare the performance of Texas with that of Opal [3], a single address space oper ating system, in which swizzling is not necessary.
Reference: [3] <author> Jeffrey S. Chase, Henry M. Levy, Michael J. Feeley, and Edward D. Lazowska. </author> <title> Sharing and Protection in a single address space operating system. </title> <journal> ACM Transactions on Computer Systems, </journal> <month> May </month> <year> 1994. </year>
Reference-contexts: The aim of this project is to * analyze the costs of swizzling in Texas [2], a POS that uses a virtual memory hardware to detect accesses to non-resident objects and trigger swizzling. * compare the performance of Texas with that of Opal <ref> [3] </ref>, a single address space oper ating system, in which swizzling is not necessary. Our motivation for this study is at least twofold. First, we are interested in understanding the behavior of swizzling systems so that we can determine how modern operating systems should change to allow explicitly support OODBMSs.
Reference: [4] <author> Paul R. Wilson. </author> <title> Pointer Swizzling at page fault time: Efficiently supporting huge address spaces on standard hardware. </title> <journal> ACM SIGARCH Computer Architecture News, </journal> <volume> 19(4), </volume> <month> June </month> <year> 1991. </year>
Reference-contexts: Swizzling is a complex technique with a number of different dimensions [1]; however in this study we are concerned with one specific swizzling technique called pointer swizzling at page fl Submitted in fulfillment of the Ph.D. Qualifying Project. 1 fault time <ref> [4] </ref>. We choose this technique because it is believed to be one that carries a low runtime overhead.
Reference: [5] <author> J. Eliot B. Moss. </author> <title> Working with Persistent Objects: To Swizzle or Not to Swizzle. </title> <journal> IEEE Transactions on Software Engineering. </journal> <volume> 18(8) </volume> <pages> 657-673, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: It also is not affected by the problem of unnecessary page-outs of "dirty" pages which are not really dirty, since Opal does not need to swizzle. 3 Related Work Moss <ref> [5] </ref> describes an analytical model to account for the cost of swizzling.
Reference: [6] <author> Seth J. White, David J. Dewitt. </author> <title> QuickStore: A High Performance Mapped Object Store. </title> <booktitle> Proceedings of the 1994 ACM-SIGMOD Conference on the Management of Data, </booktitle> <address> Minneapolis, MN May 1994. </address>
Reference-contexts: It uses an interpreter, the E Persistent Virtual Machine (EPVM) to coordinate access to persistent data that is manged by the EXODUS Storage Manger (ESM). The persistent hardware swizzling scheme studied is the one used by QuickStore <ref> [6] </ref>, a system which is very similar to ObjectStore [7]. QuickStore is different from Texas because it uses techniques to avoid swizzling when possible. QuickStore also has control over caching of database pages. (see Section 8 for a discussion of QuickStore). <p> QuickStore <ref> [6] </ref> is a POS that also uses pointer swizzling at page fault time. However, it tries to reduce the costs of swizzling in the following ways: * QuickStore has control over the caching of database pages in memory since it directly manages the client buffer pool.
Reference: [7] <author> C. Lamb, G. Landis, J. Orenstein, D. Weinreb. </author> <title> The ObjectStore database system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10), </volume> <month> October </month>
Reference-contexts: It uses an interpreter, the E Persistent Virtual Machine (EPVM) to coordinate access to persistent data that is manged by the EXODUS Storage Manger (ESM). The persistent hardware swizzling scheme studied is the one used by QuickStore [6], a system which is very similar to ObjectStore <ref> [7] </ref>. QuickStore is different from Texas because it uses techniques to avoid swizzling when possible. QuickStore also has control over caching of database pages. (see Section 8 for a discussion of QuickStore). A performance comparison is also made between E and ObjectStore.
Reference: [8] <author> Michael J. Carey, David J. Dewitt, Jeffrey F. Naughton. </author> <title> The OO7 Benchmark. </title> <booktitle> 1993 ACM Sigmod. International Conference on Management of Data, </booktitle> <volume> 22(2) </volume> <pages> 12-21, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: QuickStore is different from Texas because it uses techniques to avoid swizzling when possible. QuickStore also has control over caching of database pages. (see Section 8 for a discussion of QuickStore). A performance comparison is also made between E and ObjectStore. Carey, Dewitt and Naughton <ref> [8] </ref> compare the overall performance of three different OODBMSs, E/Exodus, Objectivity and Ontos using the OO7 benchmark. 4 The costs of swizzling While swizzling allows translation between virtual memory and persistent storage, there are costs to be paid for this. <p> The only differences are the specific calls that must be made to each system. Thus, we are confident that the measured differences can be attributed solely to architectural features of each system. The OO7 <ref> [8] </ref> database consists of a design library, which is made up of a number of CompositeParts. The structure of the OO7 database is shown in Figure 1. Each Compos-itePart itself is made up of a graph of AtomicParts. An AtomicPart is the logically smallest object in the database.
Reference: [9] <author> Eugene Shekita, Michael Zwilling. Cricket: </author> <title> A Mapped, Persistent Object Store. </title> <booktitle> Proceedings of the Fourth International Workshop on Persistent Object Systems, </booktitle> <address> Martha's Vineyard, MA, </address> <month> Sept. </month> <year> 1990. </year>
Reference: [10] <author> W.P. Cockshot, M.P. Atkinson, K.J.Chisholm. </author> <title> Persistent object management system. </title> <journal> Software Practice and Experience, </journal> <volume> 14(1), </volume> <month> January </month> <year> 1984. </year> <month> 17 </month>
References-found: 10

