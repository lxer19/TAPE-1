URL: http://www.sics.se/~joachim/cwb.ps.Z
Refering-URL: http://www.cs.toronto.edu/~chechik/courses/2124/readings.html
Root-URL: 
Title: The Concurrency Workbench: A Semantics Based Tool for the Verification of Concurrent Systems  
Author: Rance Cleaveland Joachim Parrow Bernhard Steffen 
Date: September 13, 1994  
Abstract: The Concurrency Workbench is an automated tool for analyzing networks of finite-state processes expressed in Milner's Calculus of Communicating Systems. Its key feature is its breadth: a variety of different verification methods, including equivalence checking, preorder checking, and model checking, are supported for several different process semantics. One experience from our work is that a large number of interesting verification methods can be formulated as combinations of a small number of primitive algorithms. The Workbench has been applied to the verification of communications protocols and mutual exclusion algorithms and has proven a valuable aid in teaching and research.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bartlett, K.A., R.A. Scantlebury and P.T. Wilkinson. </author> <title> "A Note on Reliable Full-Duplex Transmission over Half-Duplex Links." </title> <journal> Communications of the ACM 12, n. </journal> <volume> 5, </volume> <pages> pp. 260-261, </pages> <month> May </month> <year> 1969. </year>
Reference-contexts: The result is the following. Command: csp Agent: PROTOCOL Proposition: SERVICE1 & SERVICE2 & SERVICE3 & SERVICE4 true This establishes the correctness of the protocol specification in the logical framework. 7.5 Debugging a Protocol In this section we develop a version of the well-known Alternating Bit Protocol <ref> [1] </ref>; although apparently correct, the system is faulty, and we show how to debug the system with the help of utilities supplied by the Workbench. <p> It is just such considerations that motivate the need for automated verification tools. The Alternating Bit Protocol <ref> [1] </ref> is designed to ensure the reliable transfer of data over faulty communications lines; it is an example of a sliding window protocol (with window size one). <p> Senders and receivers may also time out while waiting for acknowledgements and messages, respectively. A full account of the protocol may be found in <ref> [1] </ref>. Here we formalize a version of this protocol consisting of one sender and one receiver, with the sender sending data values consisting of a single bit over the given medium to the receiver. The general structure of our system appears in Figure 8.
Reference: [2] <author> Bloom, B., S. Istrail and A. Meyer. </author> <title> "Bisimulation Can't Be Traced." </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1988. </year>
Reference-contexts: There are also several ways in which the functionality of the Workbench could be extended and improved. As an example, other equivalences and preorders, including GSOS equivalence and the 2 3 -bisimulation preorder (also called ready simulation) <ref> [2, 40] </ref>, turn out to be instances of the general relations that we examine, and adding these relations to the Workbench is one avenue we plan to pursue. Another involves the computation of distinguishing formulas [30, 8].
Reference: [3] <author> Boudol, G., de Simone, R. and Vergamini, D. </author> <title> "Experiment with Auto and Autograph on a Simple Case Sliding Window Protocol." </title> <type> INRIA Report 870, </type> <month> July </month> <year> 1988. </year>
Reference-contexts: Exam--ples of such systems include Aldebaran [22], AUTO <ref> [3] </ref>, CESAR [47], COSPAN [28], EMC [6], and Winston [42]. Other tools, such as SPIN [32], perform more specialized kinds of analysis (such as deadlock detection) and are used primarily to validate (as opposed to verify) existing real-world systems.
Reference: [4] <author> Camilleri, J. and Winskel, G. </author> <title> "CCS with Priority Choice." </title> <booktitle> In Proceedings of the Sixth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pp. 246-255. </pages> <publisher> Computer Society Press, Los Alamitos, </publisher> <year> 1991. </year>
Reference-contexts: Work is also underway on automated techniques for reasoning about actions with priority, probabilistic processes and real-time systems (cf. <ref> [4, 10, 18, 24, 34, 49] </ref>). Acknowledgements We would like to thank Matthew Hennessy, Robin Milner and Colin Stirling for initiating and overseeing the Workbench project.
Reference: [5] <author> Clarke, </author> <title> E.M. "Compositional Model Checking." </title> <booktitle> In Proceedings of the Workshop on Automatic Verification Methods for Finite-State Systems. Lecture Notes in Computer Science 407, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1989. </year>
Reference-contexts: The loss of efficiency compared with the equivalence algorithm is due to the fact that we cannot use the same compact representation of behavioral relations as in Section 4.3. 6 Model Checking The Workbench also supports a verification method based on model checking <ref> [5, 6, 7, 20, 53] </ref>, in which specifications are written in an expressive modal logic based on the propositional (modal) mu-calculus. The system can automatically check whether an agent meets such a specification. The Workbench actually uses two logics, an interface logic and a system logic. <p> The preorder has been investigated in this respect [14, 26, 54]. It is also conceivable that the model checker could be extended to check formulas compositionally using methods developed in <ref> [5, 52, 56] </ref>. There are also several ways in which the functionality of the Workbench could be extended and improved.
Reference: [6] <author> Clarke, E.M., Emerson, E. and Sistla, </author> <title> A.P. "Automatic Verification of Finite State Concurrent Systems Using Temporal Logic Specifications." </title> <journal> ACM Transactions on Programming Languages and Systems, v. </journal> <volume> 8, </volume> <editor> n. </editor> <volume> 2, </volume> <pages> pp. 244-263, </pages> <year> 1986. </year>
Reference-contexts: Exam--ples of such systems include Aldebaran [22], AUTO [3], CESAR [47], COSPAN [28], EMC <ref> [6] </ref>, and Winston [42]. Other tools, such as SPIN [32], perform more specialized kinds of analysis (such as deadlock detection) and are used primarily to validate (as opposed to verify) existing real-world systems. In order to achieve this flexibility the algorithms in the Workbench are partitioned into three layers. <p> The loss of efficiency compared with the equivalence algorithm is due to the fact that we cannot use the same compact representation of behavioral relations as in Section 4.3. 6 Model Checking The Workbench also supports a verification method based on model checking <ref> [5, 6, 7, 20, 53] </ref>, in which specifications are written in an expressive modal logic based on the propositional (modal) mu-calculus. The system can automatically check whether an agent meets such a specification. The Workbench actually uses two logics, an interface logic and a system logic. <p> We have found that the most effective way to use the model checker is to choose a collection of intuitively well-understood operators and then "code up" these operators as macros. For instance, it is possible to define the operators of the temporal logic CTL <ref> [6] </ref> as macros. Examples include the following. <p> The decision procedure has been implemented as an extension to the Workbench [41] and is exponential in the size of the agent|in fact, the problem has been shown to be NP-hard. An interface has also been built between the Workbench and the Extended Model Checker <ref> [6] </ref> (EMC), which is a tool for checking the satisfiability of temporal logic (CTL) formulas. EMC views 33 processes somewhat differently than the other analysis procedures in the Workbench do; there are no communication actions, and states are labeled by atomic propositions.
Reference: [7] <author> Cleaveland, R. </author> <title> "Tableau-Based Model Checking in the Propositional Mu-Calculus." </title> <journal> Acta Informatica, v. </journal> <volume> 27, </volume> <year> 1990, </year> <pages> pp. 725-747. </pages>
Reference-contexts: The loss of efficiency compared with the equivalence algorithm is due to the fact that we cannot use the same compact representation of behavioral relations as in Section 4.3. 6 Model Checking The Workbench also supports a verification method based on model checking <ref> [5, 6, 7, 20, 53] </ref>, in which specifications are written in an expressive modal logic based on the propositional (modal) mu-calculus. The system can automatically check whether an agent meets such a specification. The Workbench actually uses two logics, an interface logic and a system logic. <p> The (informal) interpretation of this sequent is that under the assumptions H, n satisfies . The procedure is tableau-based, meaning that it attempts to build a top-down "proof" of H ` n 2 . The method used comes from <ref> [7] </ref>; we shall not describe it here. Another tableau-based approach appears in [53], while a semantics-based algorithm is given in [20]; an automated proof system for a subset of the logic is presented in [38].
Reference: [8] <author> Cleaveland, R. </author> <title> "On Automatically Distinguishing Inequivalent Processes." </title> <booktitle> In Computer-Aided Verification '90, </booktitle> <pages> pp. 463-477. </pages> <publisher> American Mathematical Society, </publisher> <address> Providence, </address> <year> 1991. </year> <note> Also Lecture Notes in Computer Science 531, Springer-Verlag, Berlin, 1991. 35 </note>
Reference-contexts: In this case, the answer is computed in approximately 10 seconds. Command: bpi Identifier: Deadlock Proposition: ~&lt;.&gt;T 2 Future versions of the Workbench will have error diagnostic facilities based on techniques developed in <ref> [8] </ref>, thus considerably easing the task of locating the faults in systems. 28 Command: csp Agent: ABP Proposition: AG (~Deadlock) false So the system is not deadlock-free! To locate specific deadlocked states in ABP, we use the command fd, which outputs a list of all deadlocked states together with a sequence <p> Another involves the computation of distinguishing formulas <ref> [30, 8] </ref>. At present, when agents are found not to be equivalent, no indication is given as to why. One way to convey such information is to give a formula in the mu-calculus satisfied by one agent but not by the other. <p> One way to convey such information is to give a formula in the mu-calculus satisfied by one agent but not by the other. A technique for generating such formulas for partition-refinement-based bisimulation algorithms has been proposed in <ref> [8] </ref>; work is also underway on generating similar diagnostic information for the testing equivalences. A graphical interface is also under development; this tool will permit users to 34 design systems graphically, with the tool then generating the appropriate CCS descriptions.
Reference: [9] <author> Cleaveland, R. and Hennessy, M.C.B. </author> <title> "Testing Equivalence as a Bisimulation Equivalence." </title> <booktitle> In Proceedings of the Workshop on Automatic Verification Methods for Finite-State Systems, </booktitle> <pages> pp. 11-23. </pages> <booktitle> Lecture Notes in Computer Science 407, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1989. </year>
Reference-contexts: In order to compute these relations the Workbench includes an algorithm for transforming transition graphs into language-equivalent deterministic graphs (also called Dgraphs in <ref> [9] </ref>), i.e. graphs having no t -derivatives and at most one a-derivative per node for any action a. <p> The appropriate transition graphs for these relations are acceptance graphs (also called Tgraphs in <ref> [9] </ref>); these are deterministic graphs whose nodes additionally contain information regarding divergence and nondeterminism encoded as acceptance sets. The acceptance set n:acc of a node n is a set of sets of actions. <p> A closely related kind of graph, the must graph (also called STgraph), is appropriate for the must equivalence and preorder ([29]). Must graphs are like acceptance graphs, except that divergent nodes have no outgoing edges. The algorithm for generating acceptance and must graphs is described in <ref> [9] </ref>. 4 Equivalence Checking The first analysis procedure we present computes equivalences between two agents. <p> Two transition graphs are must equivalent if their associated must graphs are A-equivalent, and they are testing (failures) equivalent if their associated acceptance graphs are A-equivalent <ref> [9] </ref>. As an example, recall the definitions for buf n and cbuf n (see Section 3). <p> Then these relations are the following instances of the general preorder <ref> [9] </ref>. The may preorder: P a = N , Q a = ;, and C = U .
Reference: [10] <author> Cleaveland, R. and Hennessy, M.C.B. </author> <title> "Priorities in Process Algebra." Information and Computation, </title> <editor> v. </editor> <volume> 87, </volume> <editor> n. </editor> <volume> 1/2, </volume> <year> 1990, </year> <pages> pp. 58-77. </pages>
Reference-contexts: Work is also underway on automated techniques for reasoning about actions with priority, probabilistic processes and real-time systems (cf. <ref> [4, 10, 18, 24, 34, 49] </ref>). Acknowledgements We would like to thank Matthew Hennessy, Robin Milner and Colin Stirling for initiating and overseeing the Workbench project.
Reference: [11] <author> Cleaveland, R., Parrow, J. and Steffen, B. </author> <title> The Concurrency Workbench: Operating Instructions, </title> <type> Technical Note 10, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, </institution> <month> September </month> <year> 1988. </year>
Reference-contexts: 1 Introduction This paper describes the Concurrency Workbench <ref> [11, 12, 13] </ref>, a tool that supports the automatic verification of finite-state processes. Such tools are practically motivated: the development of complex distributed computer systems requires sophisticated verification techniques to guarantee correctness, and the increase in detail rapidly becomes unmanageable without computer assistance.
Reference: [12] <author> Cleaveland, R., Parrow, J. and Steffen, B. </author> <title> "A Semantics-Based Tool for the Verification of Finite-State Systems." </title> <booktitle> In Proceedings of the Ninth IFIP Symposium on Protocol Specification, Testing and Verification, </booktitle> <month> June </month> <year> 1989, </year> <pages> pp. 287-302. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction This paper describes the Concurrency Workbench <ref> [11, 12, 13] </ref>, a tool that supports the automatic verification of finite-state processes. Such tools are practically motivated: the development of complex distributed computer systems requires sophisticated verification techniques to guarantee correctness, and the increase in detail rapidly becomes unmanageable without computer assistance.
Reference: [13] <author> Cleaveland, R., Parrow, J. and Steffen, B. </author> <title> "The Concurrency Workbench." </title> <booktitle> In Proceedings of the Workshop on Automatic Verification Methods for Finite-State Systems, </booktitle> <pages> pp. 24-37. </pages> <booktitle> Lecture Notes in Computer Science 407, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1989. </year>
Reference-contexts: 1 Introduction This paper describes the Concurrency Workbench <ref> [11, 12, 13] </ref>, a tool that supports the automatic verification of finite-state processes. Such tools are practically motivated: the development of complex distributed computer systems requires sophisticated verification techniques to guarantee correctness, and the increase in detail rapidly becomes unmanageable without computer assistance.
Reference: [14] <author> Cleaveland, R. and B. Steffen. </author> <title> "When is `Partial' Complete? A Logic-Based Proof Technique using Partial Specifications." </title> <booktitle> In Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pp. 440-449. </pages> <publisher> Computer Society Press, Los Alamitos, </publisher> <year> 1990. </year>
Reference-contexts: In addition, the divergence preorder yields a compositional proof technique for bisimulation equivalences that enables partial specifications to be used in proofs that implementations are equivalent to complete specifications (cf. <ref> [14, 15, 39, 54] </ref>). The key observation underlying this technique is that some processes, although not equivalent, may be used interchangeably in certain contexts. As an example, assume that we have a transport protocol with sender entity sender and receiver entity receiver interconnected through ports L with a medium medium. <p> One means of coping with this is to verify the parallel components separately in a way that implies the correctness of the composite process. The preorder has been investigated in this respect <ref> [14, 26, 54] </ref>. It is also conceivable that the model checker could be extended to check formulas compositionally using methods developed in [5, 52, 56]. There are also several ways in which the functionality of the Workbench could be extended and improved.
Reference: [15] <author> Cleaveland, R. and B. Steffen. </author> <title> "A Preorder for Partial Process Specifications." </title> <booktitle> In Proceedings of CONCUR '90, </booktitle> <pages> pp. 141-151. </pages> <booktitle> Lecture Notes in Computer Science 458, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: In addition, the divergence preorder yields a compositional proof technique for bisimulation equivalences that enables partial specifications to be used in proofs that implementations are equivalent to complete specifications (cf. <ref> [14, 15, 39, 54] </ref>). The key observation underlying this technique is that some processes, although not equivalent, may be used interchangeably in certain contexts. As an example, assume that we have a transport protocol with sender entity sender and receiver entity receiver interconnected through ports L with a medium medium.
Reference: [16] <author> Cleaveland, R. and B. Steffen. </author> <title> "Computing Behavioural Relations, Logically." </title> <booktitle> In Proceedings International Colloquium on Automata, Languages and Programming. Lecture Notes in Computer Science 510, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference-contexts: The time and space complexities of this algorithm are O (k 4 fl `) and O (k 2 + `), respectively, where k is the number of states, and ` is the number of transitions, in the two transition graphs. In <ref> [16] </ref> an algorithm is proposed whose worst case time complexity is O (` 2 ). The implementation of this algorithm is underway. <p> In addition, more efficient algorithms for preorder checking <ref> [16] </ref> and model checking [17] have been discovered, and these should be implemented in the system. Another area of investigation would involve developing techniques for reducing the size of transition graphs that the system computes when verification routines are invoked.
Reference: [17] <author> Cleaveland, R. and B. Steffen. </author> <title> "A Linear-Time Model-Checking Algorithm for the Alternation-Free Modal Mu-Calculus." In Proceedings of Computer-Aided Verification '91. </title> <note> To appear in Lecture Notes in Computer Science. </note>
Reference-contexts: AG ((AF hinitt) _ (AF houtitt)) The algorithm in general has complexity that is exponential in the size of the formula being checked, although for special classes of formulas it is well-behaved. A linear-time algorithm for a particular subclass of this logic has been proposed in <ref> [17] </ref> and will be incorporated in future versions of the Concurrency Workbench. 7 Using the Concurrency Workbench In this section we illustrate the main analysis procedures of the Workbench by verifying a very simple communications protocol. <p> In addition, more efficient algorithms for preorder checking [16] and model checking <ref> [17] </ref> have been discovered, and these should be implemented in the system. Another area of investigation would involve developing techniques for reducing the size of transition graphs that the system computes when verification routines are invoked.
Reference: [18] <author> Cleaveland, R. and Zwarico, A. </author> <title> "A Theory of Testing for Real Time". </title> <booktitle> In Proceedings of the Sixth Annual Symposium on Logic in Computer Science. </booktitle> <publisher> Computer Society Press, Los Alamitos, </publisher> <year> 1991. </year>
Reference-contexts: Work is also underway on automated techniques for reasoning about actions with priority, probabilistic processes and real-time systems (cf. <ref> [4, 10, 18, 24, 34, 49] </ref>). Acknowledgements We would like to thank Matthew Hennessy, Robin Milner and Colin Stirling for initiating and overseeing the Workbench project.
Reference: [19] <author> DeNicola, R. and Hennessy, M.C.B. </author> <title> "Testing Equivalences for Processes." </title> <booktitle> Theoretical Computer Science, v. </booktitle> <volume> 34, </volume> <pages> pp. 83-133, </pages> <year> 1983. </year>
Reference: [20] <author> Emerson, E.A. and Lei, C.-L. </author> <title> "Efficient Model Checking in Fragments of the Propositional Mu-Calculus." </title> <booktitle> In Proceedings of the First Annual Symposium on Logic in Computer Science, </booktitle> <pages> pp. 267-278. </pages> <publisher> Computer Society Press, </publisher> <address> Washington, </address> <year> 1986. </year>
Reference-contexts: Assertions formulated in this logic are viewed as specifications; examples of such assertions are "there are no deadlocks" or "every action of type a is always followed by an action of type b". The logic exhibits a considerable expressive power <ref> [20, 50] </ref>. The model-checking algorithm determines whether a process satisfies such an assertion; it is described in Section 6. The basic analysis algorithms are "polymorphic" in the sense that they work equally well on the different kinds of transition graphs supplied by the semantics layer. <p> The loss of efficiency compared with the equivalence algorithm is due to the fact that we cannot use the same compact representation of behavioral relations as in Section 4.3. 6 Model Checking The Workbench also supports a verification method based on model checking <ref> [5, 6, 7, 20, 53] </ref>, in which specifications are written in an expressive modal logic based on the propositional (modal) mu-calculus. The system can automatically check whether an agent meets such a specification. The Workbench actually uses two logics, an interface logic and a system logic. <p> Dually let ^ 0 be the proposition ff, and let ^ i+1 be defined as [ ^ i =X]. Then X: may be interpreted as the infinite disjunction W 1 ^ i . The recursive proposition constructors add tremendous expressive power to the logic (cf. <ref> [20, 50] </ref>). For example, they allow the description of invariance (or safety) and eventuality (or liveness) properties. However, the formulas are in general unintuitive and difficult to understand. <p> It is also possible to write formulas expressing properties that are useful in describing fairness constraints; many of these involve the use of mutually recursive greatest and least fixed point formulas <ref> [20] </ref>. 16 6.2 The Algorithm The algorithm for determining whether a node satisfies a system logic formula works on sequents of the form H ` n 2 , where n is a node, is a formula, and H is a set of hypotheses, or assumptions of the form n 0 : <p> The procedure is tableau-based, meaning that it attempts to build a top-down "proof" of H ` n 2 . The method used comes from [7]; we shall not describe it here. Another tableau-based approach appears in [53], while a semantics-based algorithm is given in <ref> [20] </ref>; an automated proof system for a subset of the logic is presented in [38]. Applying the algorithm to graphs generated by the different graph transformations yields different notions of satisfaction.
Reference: [21] <author> Ernberg, P. and Fredlund, L.-a. </author> <title> "Identifying some Bottlenecks of the Concurrency Workbench". </title> <type> Technical Report T90002, </type> <institution> Swedish Institute of Computer Science, </institution> <year> 1990. </year> <month> 36 </month>
Reference-contexts: : : : ; 7. (For n &lt; 4 the scheduler is fairly trivial, and for n &gt; 7 the state graph is too large for the Workbench.) The size of these schedulers is indicated in Table 1 (this information, and the running times of the Workbench, is collected from <ref> [21] </ref>). The column "States in SCHED n " gives the number of distinct states that the Workbench constructs in the transition graph. Note that agents such as D and d:A are considered distinct here, even though they intuitively represent the same state.
Reference: [22] <author> Fernandez, J.-C. Aldebaran: </author> <title> Une Systeme de Verification par Reduction de Processus Com--municants. </title> <type> Ph.D. Thesis, </type> <institution> Universite de Grenoble, </institution> <year> 1988. </year>
Reference-contexts: Exam--ples of such systems include Aldebaran <ref> [22] </ref>, AUTO [3], CESAR [47], COSPAN [28], EMC [6], and Winston [42]. Other tools, such as SPIN [32], perform more specialized kinds of analysis (such as deadlock detection) and are used primarily to validate (as opposed to verify) existing real-world systems.
Reference: [23] <author> Fredlund, L.-a, B. Jonsson and J. Parrow. </author> <title> "An Implementation of a Transitional Semantics for an Imperative Language." </title> <booktitle> In Proceedings of CONCUR '90, </booktitle> <pages> pp. 246-262. </pages> <booktitle> Lecture Notes in Computer Science 458, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: EMC has successfully been applied to verification of nontrivial pieces of hardware. The integration with the Workbench was achieved by defining a translation from labeled transition graphs to the type of structures analyzed by EMC [35]. Another extension is the Lunsen system <ref> [23] </ref>. Lunsen is an imperative language with primitives for communication between parallel processes. A compiler translates Lunsen code into CCS in the format acceptable to the Workbench, making it possible to use the Workbench for automatic analysis of Lunsen programs.
Reference: [24] <author> Glabbeek R. van and Smolka S. A. and Steffen B. and Tofts C. M. N. </author> <title> "Reactive, Generative, and Stratified Models of Probabilistic Processes." </title> <booktitle> In Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pp. 130-141. </pages> <publisher> Computer Society Press, Los Alamitos, </publisher> <year> 1990. </year>
Reference-contexts: Work is also underway on automated techniques for reasoning about actions with priority, probabilistic processes and real-time systems (cf. <ref> [4, 10, 18, 24, 34, 49] </ref>). Acknowledgements We would like to thank Matthew Hennessy, Robin Milner and Colin Stirling for initiating and overseeing the Workbench project.
Reference: [25] <author> Goyer, J.H. </author> <title> Communications Protocols for the B-HIVE Multicomputer. </title> <type> Master's Thesis, </type> <institution> North Carolina State University, </institution> <year> 1991. </year>
Reference-contexts: The Workbench has been successfully applied to verifying communication protocols, notably the Alternating Bit Protocol, the CSMA/CD protocol [46] and the communication layer of the BHIVE multiprocessor <ref> [25] </ref>, and mutual exclusion algorithms [55]; it has also been used to debug the Edinburgh Computer Science Department's electronic mailing system.
Reference: [26] <author> Graf, S. and Steffen, B. </author> <title> "Using Interface Specifications for Compositional Reduction." In Computer-Aided Verification '90. </title> <publisher> American Mathematical Society, </publisher> <address> Providence, </address> <year> 1991. </year> <note> Also Lecture Notes in Computer Science 531. </note>
Reference-contexts: One means of coping with this is to verify the parallel components separately in a way that implies the correctness of the composite process. The preorder has been investigated in this respect <ref> [14, 26, 54] </ref>. It is also conceivable that the model checker could be extended to check formulas compositionally using methods developed in [5, 52, 56]. There are also several ways in which the functionality of the Workbench could be extended and improved.
Reference: [27] <author> Groote, J. F. and Vaandrager, F. </author> <title> "An Efficient Algorithm for Branching Bisimulation and Stuttering Equivalence." </title> <booktitle> In Proceedings, 17th International Colloquium on Automata, Languages and Programming. Lecture Notes in Computer Science 443, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: The execution time of the Concurrency Workbench on a Sun Sparcstation with 8Mb memory is 10, 70, 400, and 2000 CPU seconds for 4, 5, 6 and 7 customers respectively. Other, more specialized tools| e.g. AUTO system [48] or the system for deciding branching bisimulation reported in <ref> [27] </ref>| have been reported to be up to several hundred times faster, if one compares the figures given here with those in [27]. <p> Other, more specialized tools| e.g. AUTO system [48] or the system for deciding branching bisimulation reported in <ref> [27] </ref>| have been reported to be up to several hundred times faster, if one compares the figures given here with those in [27].
Reference: [28] <author> Har'el, Z. and R.P. Kurshan. </author> <title> "Software for Analytical Development of Communications Protocols." </title> <journal> AT&T Technical Journal, v. </journal> <volume> 69, </volume> <editor> n. </editor> <volume> 1, </volume> <pages> pp. 45-59. </pages> <month> February, </month> <year> 1990. </year>
Reference-contexts: Exam--ples of such systems include Aldebaran [22], AUTO [3], CESAR [47], COSPAN <ref> [28] </ref>, EMC [6], and Winston [42]. Other tools, such as SPIN [32], perform more specialized kinds of analysis (such as deadlock detection) and are used primarily to validate (as opposed to verify) existing real-world systems.
Reference: [29] <author> Hennessy, M.C.B. </author> <title> Algebraic Theory of Processes. </title> <publisher> MIT Press, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: Accordingly, the transition graphs mentioned in Sections 3.2 and 3.3.1 faithfully record each time a agent makes such a choice. However, other relations do not require such detailed accounts of the choice structure of agents; for example, the may preorder and equivalence <ref> [29] </ref> (which coincide with trace containment and equivalence, respectively) require only information about an agent's language, or the sequences of visible actions the agent may perform. <p> Our experience, however, indicates that the number of nodes is usually smaller than the number of nodes in the original graph, owing to the collapsing of t -transitions. 3.3.3 Acceptance Graphs In addition to the language of an agent, other relations, such as the testing and failures equivalences and preorders <ref> [29, 31] </ref>, require information about an agent's divergence potential and degree of nondeterminism as it attempts to execute a sequence of visible actions.
Reference: [30] <author> Hillerstrom, M. </author> <title> Verification of CCS-processes. M.Sc. </title> <type> Thesis, </type> <institution> Computer Science Department, Aalborg University, </institution> <year> 1987. </year>
Reference-contexts: Another involves the computation of distinguishing formulas <ref> [30, 8] </ref>. At present, when agents are found not to be equivalent, no indication is given as to why. One way to convey such information is to give a formula in the mu-calculus satisfied by one agent but not by the other.
Reference: [31] <author> Hoare, </author> <title> C.A.R. Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <address> London, </address> <year> 1985. </year>
Reference-contexts: Our experience, however, indicates that the number of nodes is usually smaller than the number of nodes in the original graph, owing to the collapsing of t -transitions. 3.3.3 Acceptance Graphs In addition to the language of an agent, other relations, such as the testing and failures equivalences and preorders <ref> [29, 31] </ref>, require information about an agent's divergence potential and degree of nondeterminism as it attempts to execute a sequence of visible actions.
Reference: [32] <author> Holzmann, G. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, </address> <year> 1991. </year>
Reference-contexts: Exam--ples of such systems include Aldebaran [22], AUTO [3], CESAR [47], COSPAN [28], EMC [6], and Winston [42]. Other tools, such as SPIN <ref> [32] </ref>, perform more specialized kinds of analysis (such as deadlock detection) and are used primarily to validate (as opposed to verify) existing real-world systems. In order to achieve this flexibility the algorithms in the Workbench are partitioned into three layers.
Reference: [33] <author> Hopcroft, J. and Ullman, J. </author> <title> Introduction to Automata Theory, Languages and Computation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, </address> <year> 1979. </year>
Reference-contexts: As a simple example, the transition graph r r @ ? b is transformed to r HHj @ @R As another example, the deterministic graph of cbuf 2 is precisely the transition graph of buf : 2 The algorithm for computing deterministic graphs is well-known from automata theory (see e.g. <ref> [33] </ref>). In general, this transformation has an exponential complexity, owing to the fact that it is theoretically possible to have a node in the deterministic graph for each subset of nodes in the original graph.
Reference: [34] <author> Jensen, C.-T. </author> <title> "The Concurrency Workbench with Priorities." In Proceedings of Computer-Aided Verification '91. </title> <note> To appear in Lecture Notes in Computer Science. </note>
Reference-contexts: Work is also underway on automated techniques for reasoning about actions with priority, probabilistic processes and real-time systems (cf. <ref> [4, 10, 18, 24, 34, 49] </ref>). Acknowledgements We would like to thank Matthew Hennessy, Robin Milner and Colin Stirling for initiating and overseeing the Workbench project.
Reference: [35] <author> Jonsson, B., Kahn, A., and Parrow, J. </author> <title> "Implementing a Model Checking Algorithm by Adapting Existing Automated Tools." </title> <booktitle> In Proceedings of the Workshop on Automatic Verification Methods for Finite-State Systems, </booktitle> <pages> pp. 179-188. </pages> <booktitle> Lecture Notes in Computer Science 407, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1989. </year> <month> 37 </month>
Reference-contexts: EMC has successfully been applied to verification of nontrivial pieces of hardware. The integration with the Workbench was achieved by defining a translation from labeled transition graphs to the type of structures analyzed by EMC <ref> [35] </ref>. Another extension is the Lunsen system [23]. Lunsen is an imperative language with primitives for communication between parallel processes. A compiler translates Lunsen code into CCS in the format acceptable to the Workbench, making it possible to use the Workbench for automatic analysis of Lunsen programs.
Reference: [36] <author> Jonsson, B. and Parrow, J. </author> <title> "Deciding Bisimulation Equivalences for a Class of Non-Finite--State Programs." </title> <booktitle> In Proceedings of the Sixth Annual Symposium on Theoretical Aspects of Computer Science, </booktitle> <pages> pp. 421-433. </pages> <booktitle> Lecture Notes in Computer Science 349, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1989. </year> <note> To appear in Information and Computation. </note>
Reference-contexts: Section7.5). In the case of infinite value domains, however, this leads to syntactically infinite agents. In <ref> [36] </ref>, an alternative encoding is proposed, in which the infinitely many data values are represented schematically. Using the resulting transitional semantics, bisimulation equivalences can be defined in such a way as to correspond exactly to the bisimulation equivalences in full CCS.
Reference: [37] <author> Kanellakis, P. and Smolka, S.A. </author> <title> "CCS Expressions, Finite State Processes, and Three Problems of Equivalence." Information and Computation, </title> <editor> v. </editor> <volume> 86, </volume> <editor> n. </editor> <volume> 1, </volume> <pages> pp. 43-68, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: For each n, these two agents can be shown to be equivalent according to each of these equivalences, with the exception of strong equivalence. 4.3 The Algorithm Our algorithm is adapted from one presented in <ref> [37] </ref>. It works by attempting to find a C-bisimulation relating the root nodes of the transition graphs. To do so, it maintains a partitioning of the nodes in G 1 and G 2 , the transition graphs under consideration.
Reference: [38] <author> Larsen, K.G. </author> <title> "Proof Systems for Hennessy-Milner Logic with Recursion." </title> <booktitle> In Proceedings of CAAP, Lecture Notes in Computer Science 299, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1988. </year>
Reference-contexts: The method used comes from [7]; we shall not describe it here. Another tableau-based approach appears in [53], while a semantics-based algorithm is given in [20]; an automated proof system for a subset of the logic is presented in <ref> [38] </ref>. Applying the algorithm to graphs generated by the different graph transformations yields different notions of satisfaction.
Reference: [39] <author> Larsen, K.G. and Thomsen, B. </author> <title> "Compositional Proofs by Partial Specification of Processes." </title> <booktitle> In Proceedings of the Third Annual Symposium on Logic in Computer Science. </booktitle> <publisher> Computer Society Press, </publisher> <address> Washington, </address> <year> 1988. </year>
Reference-contexts: In addition, the divergence preorder yields a compositional proof technique for bisimulation equivalences that enables partial specifications to be used in proofs that implementations are equivalent to complete specifications (cf. <ref> [14, 15, 39, 54] </ref>). The key observation underlying this technique is that some processes, although not equivalent, may be used interchangeably in certain contexts. As an example, assume that we have a transport protocol with sender entity sender and receiver entity receiver interconnected through ports L with a medium medium.
Reference: [40] <author> Larsen, K.G. and Skou, A. </author> <title> "Bisimulation through Probabilistic Testing." </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1989. </year>
Reference-contexts: There are also several ways in which the functionality of the Workbench could be extended and improved. As an example, other equivalences and preorders, including GSOS equivalence and the 2 3 -bisimulation preorder (also called ready simulation) <ref> [2, 40] </ref>, turn out to be instances of the general relations that we examine, and adding these relations to the Workbench is one avenue we plan to pursue. Another involves the computation of distinguishing formulas [30, 8].
Reference: [41] <author> Lee, C.-H. </author> <note> "Implementering av CCS med vardeoverforing." SICS Technical Report 1989 (in Swedish). </note>
Reference-contexts: This result entails a decision procedure for data-independent agents, i.e. agents which communicate data values but do not perform any computations or tests on the values. The decision procedure has been implemented as an extension to the Workbench <ref> [41] </ref> and is exponential in the size of the agent|in fact, the problem has been shown to be NP-hard. An interface has also been built between the Workbench and the Extended Model Checker [6] (EMC), which is a tool for checking the satisfiability of temporal logic (CTL) formulas.
Reference: [42] <author> Malhotra, J., Smolka, S.A., Giacalone, A. and Shapiro, R. "Winston: </author> <title> A Tool for Hierarchical Design and Simulation of Concurrent Systems." </title> <booktitle> In Proceedings of the Workshop on Specification and Verification of Concurrent Systems, </booktitle> <institution> University of Stirling, </institution> <address> Scotland, </address> <year> 1988. </year>
Reference-contexts: Exam--ples of such systems include Aldebaran [22], AUTO [3], CESAR [47], COSPAN [28], EMC [6], and Winston <ref> [42] </ref>. Other tools, such as SPIN [32], perform more specialized kinds of analysis (such as deadlock detection) and are used primarily to validate (as opposed to verify) existing real-world systems. In order to achieve this flexibility the algorithms in the Workbench are partitioned into three layers.
Reference: [43] <author> Milner, R. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall 1989. </publisher>
Reference-contexts: Parsers transform the concrete syntax of such parameters into parse trees, which may be stored in environments maintained by the Workbench. There is also a package defining the basic semantics of processes. Following <ref> [43] </ref>, a process is interpreted as labeled transition graph that describes the states a process may enter and 2 Layer 1: INTERFACE command interpreter parsers unparsers environments basic semantic definitions Layer 2: SEMANTIC TRANSFORMATION observation graphs deterministic graphs acceptance graphs Layer 3: BASIC ANALYSIS equival ence, minimizer preorder model checker 3 <p> Input action a and output action a are said to be complementary, reflecting the fact that they represent input and output on the "port" a. We consider only communication actions without value parameters. Agents are defined using the following standard operators from <ref> [43] </ref>. <p> In most cases the subroutine for transitive closure accounts for more than 80 per cent of the execution time when determining observation equivalence. A variation of the observation transformation computes congruence graphs, which are used to check for observational congruence <ref> [43] </ref> and weak precongruence [54]. Intuitively, these graphs are observation graphs that record the possibility of initial t -actions. To construct them, a copy of the root node is created; this new node becomes the root node of the congruence graph, and by construction it has no incoming edges. <p> U = N fiN . A U -bisimulation is a bisimulation in the sense of Milner <ref> [43] </ref> and U -equivalence is strong equivalence in CCS. <p> In order to provide a flavor of the performance of the automatic analyses in the Workbench, we have chosen the task of minimizing transition graphs with respect to observation equivalence. The agents are taken from Chapter 5 of <ref> [43] </ref>, and are as follows: A = a:c:(b:d:A + d:b:A) SCHED n = (A [f 1 ] j D [f 2 ] j j D [f n ])nfc 1 ; : : : c n g where f i denotes the relabeling [a i =a; b i =b; c i =c; <p> The scheduler is composed of n "cyclers" (A and D); each cycler maintains communication with one customer on ports a and b, and all cyclers are linked into a ring through ports c and d. For a further explanation of this example see <ref> [43] </ref>.
Reference: [44] <author> Paige, R. and Tarjan, R.E. </author> <title> "Three Partition Refinement Algorithms." </title> <journal> SIAM Journal of Computing, v. </journal> <volume> 16, </volume> <editor> n. </editor> <volume> 6, </volume> <pages> pp. 973-989, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: The time and space complexities of this algorithm are O (k fl `) and O (k + `) respectively, where k is the number of nodes, and ` is the number of transitions, in the two transition graphs. In <ref> [44] </ref> an algorithm is proposed whose worst case time complexity is O (log (k) fl `); however, there is not yet enough evidence to suggest that this algorithm is appreciably faster in practice.
Reference: [45] <author> Parrow, J. </author> <title> "Submodule Construction as Equation Solving in CCS." </title> <booktitle> Theoretical Computer Science, v. </booktitle> <volume> 68, </volume> <pages> pp. 175-202, </pages> <year> 1989. </year>
Reference-contexts: These types of analyses are traditionally found in automatic verification tools and will not be discussed further in this paper. 8.2 Equation Solving The equation-solving feature of the Workbench <ref> [45] </ref> is used to solve equations of type (AjX)nL = B where A; B and L are given.
Reference: [46] <author> Parrow, J. </author> <title> "Verifying a CSMA/CD-Protocol with CCS." </title> <booktitle> In Proceeding of the Eighth IFIP Symposium on Protocol Specification, Testing, and Verification, </booktitle> <pages> pp. 373-387. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1988. </year>
Reference-contexts: Depending on the verification method used, a specification may either be another process (describing the desired behavior) or a formula in a modal logic expressing a relevant property. The Workbench has been successfully applied to verifying communication protocols, notably the Alternating Bit Protocol, the CSMA/CD protocol <ref> [46] </ref> and the communication layer of the BHIVE multiprocessor [25], and mutual exclusion algorithms [55]; it has also been used to debug the Edinburgh Computer Science Department's electronic mailing system.
Reference: [47] <author> Richier, J., Rodriguez, C., Sifakis, J. and Voiron, J.. </author> <title> "Verification in XESAR of the Sliding Window Protocol." </title> <booktitle> In Proceedings of the Seventh IFIP Symposium on Protocol Specification, Testing, and Verification. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1987. </year>
Reference-contexts: Exam--ples of such systems include Aldebaran [22], AUTO [3], CESAR <ref> [47] </ref>, COSPAN [28], EMC [6], and Winston [42]. Other tools, such as SPIN [32], perform more specialized kinds of analysis (such as deadlock detection) and are used primarily to validate (as opposed to verify) existing real-world systems.
Reference: [48] <author> Roy, V. and de Simone, R. "Auto/Autograph." </author> <booktitle> In Computer-Aided Verification '90, </booktitle> <pages> pp. 477-491. </pages> <publisher> American Mathematical Society, </publisher> <address> Providence, </address> <year> 1991. </year>
Reference-contexts: The execution time of the Concurrency Workbench on a Sun Sparcstation with 8Mb memory is 10, 70, 400, and 2000 CPU seconds for 4, 5, 6 and 7 customers respectively. Other, more specialized tools| e.g. AUTO system <ref> [48] </ref> or the system for deciding branching bisimulation reported in [27]| have been reported to be up to several hundred times faster, if one compares the figures given here with those in [27].
Reference: [49] <author> Smolka S.A. and Steffen B. </author> <title> "Priority as Extremal Probability." </title> <booktitle> In Proceedings of CONCUR'90. Lecture Notes in Computer Science 458, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: Work is also underway on automated techniques for reasoning about actions with priority, probabilistic processes and real-time systems (cf. <ref> [4, 10, 18, 24, 34, 49] </ref>). Acknowledgements We would like to thank Matthew Hennessy, Robin Milner and Colin Stirling for initiating and overseeing the Workbench project.
Reference: [50] <author> Steffen, B. </author> <title> "Characteristic Formulae." </title> <booktitle> In Proceedings International Colloquium on Automata, Languages and Programming, </booktitle> <pages> pp. 723-733. </pages> <booktitle> Lecture Notes in Computer Science 372, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1989. </year> <month> 38 </month>
Reference-contexts: Assertions formulated in this logic are viewed as specifications; examples of such assertions are "there are no deadlocks" or "every action of type a is always followed by an action of type b". The logic exhibits a considerable expressive power <ref> [20, 50] </ref>. The model-checking algorithm determines whether a process satisfies such an assertion; it is described in Section 6. The basic analysis algorithms are "polymorphic" in the sense that they work equally well on the different kinds of transition graphs supplied by the semantics layer. <p> Dually let ^ 0 be the proposition ff, and let ^ i+1 be defined as [ ^ i =X]. Then X: may be interpreted as the infinite disjunction W 1 ^ i . The recursive proposition constructors add tremendous expressive power to the logic (cf. <ref> [20, 50] </ref>). For example, they allow the description of invariance (or safety) and eventuality (or liveness) properties. However, the formulas are in general unintuitive and difficult to understand.
Reference: [51] <author> Steffen, B.U., and Ingolfsdottir, A. </author> <title> "Characteristic Formulae for CCS with Divergence." </title> <note> To appear in Theoretical Computer Science. </note>
Reference: [52] <author> Stirling, C. </author> <title> "Modal Logics for Communicating Systems." </title> <booktitle> Theoretical Computer Science, v. </booktitle> <volume> 49, </volume> <pages> pp. 311-347, </pages> <year> 1987. </year>
Reference-contexts: Let U denote the universal relation on N and + a the local convergence predicate on a; n+ a holds if n is not globally divergent and cannot be triggered by means of an a-action to reach a globally divergent state. For details of this predicate see <ref> [52, 54] </ref>. * The bisimulation divergence preorder [52, 54] results by setting: P a = N; Q a = fnjn+ ag and C = fhm; nij for all a: m+ a ) n+ ag: This defines the strong version of the divergence preorder. <p> For details of this predicate see <ref> [52, 54] </ref>. * The bisimulation divergence preorder [52, 54] results by setting: P a = N; Q a = fnjn+ ag and C = fhm; nij for all a: m+ a ) n+ ag: This defines the strong version of the divergence preorder. <p> The preorder has been investigated in this respect [14, 26, 54]. It is also conceivable that the model checker could be extended to check formulas compositionally using methods developed in <ref> [5, 52, 56] </ref>. There are also several ways in which the functionality of the Workbench could be extended and improved.
Reference: [53] <author> Stirling, C. and Walker, </author> <title> D.J. " Local Model Checking in the Modal Mu-Calculus", </title> <booktitle> In Proceedings of TAPSOFT. Lecture Notes in Computer Science 352, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1989. </year>
Reference-contexts: The loss of efficiency compared with the equivalence algorithm is due to the fact that we cannot use the same compact representation of behavioral relations as in Section 4.3. 6 Model Checking The Workbench also supports a verification method based on model checking <ref> [5, 6, 7, 20, 53] </ref>, in which specifications are written in an expressive modal logic based on the propositional (modal) mu-calculus. The system can automatically check whether an agent meets such a specification. The Workbench actually uses two logics, an interface logic and a system logic. <p> The procedure is tableau-based, meaning that it attempts to build a top-down "proof" of H ` n 2 . The method used comes from [7]; we shall not describe it here. Another tableau-based approach appears in <ref> [53] </ref>, while a semantics-based algorithm is given in [20]; an automated proof system for a subset of the logic is presented in [38]. Applying the algorithm to graphs generated by the different graph transformations yields different notions of satisfaction.
Reference: [54] <author> Walker, </author> <title> D.J. "Bisimulation Equivalence and Divergence in CCS." </title> <booktitle> In Proceedings of the Third Annual Symposium on Logic in Computer Science, </booktitle> <pages> pp. 186-192. </pages> <publisher> Computer Society Press, </publisher> <address> Washington, </address> <year> 1988. </year>
Reference-contexts: In most cases the subroutine for transitive closure accounts for more than 80 per cent of the execution time when determining observation equivalence. A variation of the observation transformation computes congruence graphs, which are used to check for observational congruence [43] and weak precongruence <ref> [54] </ref>. Intuitively, these graphs are observation graphs that record the possibility of initial t -actions. To construct them, a copy of the root node is created; this new node becomes the root node of the congruence graph, and by construction it has no incoming edges. <p> Let U denote the universal relation on N and + a the local convergence predicate on a; n+ a holds if n is not globally divergent and cannot be triggered by means of an a-action to reach a globally divergent state. For details of this predicate see <ref> [52, 54] </ref>. * The bisimulation divergence preorder [52, 54] results by setting: P a = N; Q a = fnjn+ ag and C = fhm; nij for all a: m+ a ) n+ ag: This defines the strong version of the divergence preorder. <p> For details of this predicate see <ref> [52, 54] </ref>. * The bisimulation divergence preorder [52, 54] results by setting: P a = N; Q a = fnjn+ ag and C = fhm; nij for all a: m+ a ) n+ ag: This defines the strong version of the divergence preorder. <p> In addition, the divergence preorder yields a compositional proof technique for bisimulation equivalences that enables partial specifications to be used in proofs that implementations are equivalent to complete specifications (cf. <ref> [14, 15, 39, 54] </ref>). The key observation underlying this technique is that some processes, although not equivalent, may be used interchangeably in certain contexts. As an example, assume that we have a transport protocol with sender entity sender and receiver entity receiver interconnected through ports L with a medium medium. <p> One means of coping with this is to verify the parallel components separately in a way that implies the correctness of the composite process. The preorder has been investigated in this respect <ref> [14, 26, 54] </ref>. It is also conceivable that the model checker could be extended to check formulas compositionally using methods developed in [5, 52, 56]. There are also several ways in which the functionality of the Workbench could be extended and improved.
Reference: [55] <author> Walker, </author> <title> D.J. "Analysing Mutual Exclusion Algorithms Using CCS." </title> <journal> Formal Aspects of Computing, </journal> <volume> v.1, </volume> <pages> pp. 273-292, </pages> <year> 1989. </year>
Reference-contexts: The Workbench has been successfully applied to verifying communication protocols, notably the Alternating Bit Protocol, the CSMA/CD protocol [46] and the communication layer of the BHIVE multiprocessor [25], and mutual exclusion algorithms <ref> [55] </ref>; it has also been used to debug the Edinburgh Computer Science Department's electronic mailing system. It is currently being investigated as a tool for analyzing communications protocols by Swedish Telecom and by Hewlett-Packard, and it has been successfully used in education, in industry as well as in universities.
Reference: [56] <author> Winskel, G. </author> <title> "On the Compositional Checking of Validity." </title> <booktitle> In Proceedings CONCUR'90, Lecture Notes in Computer Science 458, </booktitle> <pages> pp. 481-501, </pages> <year> 1990. </year> <month> 39 </month>
Reference-contexts: The preorder has been investigated in this respect [14, 26, 54]. It is also conceivable that the model checker could be extended to check formulas compositionally using methods developed in <ref> [5, 52, 56] </ref>. There are also several ways in which the functionality of the Workbench could be extended and improved.
References-found: 56

