URL: ftp://ftp.cs.indiana.edu/pub/scheme-repository/doc/prop/blume-mod.ps.gz
Refering-URL: http://www.cs.indiana.edu/scheme-repository/doc.proposals.html
Root-URL: http://www.cs.indiana.edu
Title: Separate Compilation for Scheme needs to be augmented with concepts like modules, types, and signatures,
Author: Matthias Blume 
Note: Even though  
Date: February 18, 1994  
Affiliation: Department of Computer Science Princeton University  
Abstract: This paper presents the outline of a module system for the Scheme programming language in order to solve several problems commonly encountered with contemporary implementations. These problems include the lack of support for separate compilation and cross-module type checking as well as the necessity for non-standard language extensions to aid certain compiler optimizations like open compilation and procedure in-lining. 
Abstract-found: 1
Intro-found: 1
Reference: [Ce91] <editor> William Clinger and Jonathan Rees (editors). </editor> <title> Revised 4 report on the algorithmic language scheme. LISP Pointers, </title> <address> IV(3):1-55, </address> <month> July-September </month> <year> 1991. </year>
Reference-contexts: this might be 13 There can be more signatures, which al-low to import scheme, and there can be other built-in modules: * Signature noc-scheme-sig allows to import scheme, but it prohibits open com pilation. * Module r4rs and signatures r4rs-sig as well as noc-r4rs-sig refer to Scheme as described in <ref> [Ce91] </ref>. * Pre-defined names like - r3rs, - noc-r3rs-sig, - ieee-scheme, ieee-scheme-sig, and noc-ieee-scheme-sig do the same trick for a Scheme conform ing to other versions of the standard. * : : : Preferring signatures over modules to carry information about open compilation still offers the opportunity to use different implementations
Reference: [CF91] <author> Robert Cartwright and Mike Fagan. </author> <title> Soft typing. </title> <booktitle> Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <volume> 26(6) </volume> <pages> 278-292, </pages> <month> June </month> <year> 1991. </year>
Reference: [CR90] <author> Pavel Curtis and James Rauen. </author> <title> A module system for scheme. </title> <booktitle> In 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 13-19, </pages> <year> 1990. </year>
Reference-contexts: The result of evaluating such an entity will be an alternative top-level environment. In comparison with the interactive environment the important differences are: * The compiler sees all definitions at once. * The environment is not mutable. Most previous attempts ([Ree93], <ref> [CR90] </ref>) to add a module system to Scheme stop here. Other proposals take a completely different approach. [Tun92] emphasizes interactive programming and distinguishes between developing and developed modules. Developing modules facilitate interactive program development, while developed modules are meant to be well-suited for separate compilation.
Reference: [CR91] <author> William Clinger and Jonathan Rees. </author> <title> Macros that work. </title> <booktitle> In POPL'91 [POP91], </booktitle> <pages> pages 155-162. </pages>
Reference-contexts: Type information must be separated from actual value definitions. In some sense types are similar to syntactic definitions. Both of them provide information to the compiler. To be useful both of them must be known at compile-time. With the emergence of hygienic macro systems <ref> [CR91] </ref> for Scheme the language community has become conscious of the distinction between syntactic definitions and value definitions. Syntactic extensions 2 are second-class citizens of the language, and so are types. They can not be passed as arguments to procedures, they can not be stored into data structures.
Reference: [LW91] <author> Xavier Leroy and Pierre Weis. </author> <title> Polymorphic type inference and assignment. </title> <booktitle> In POPL'91 [POP91], </booktitle> <pages> pages 291-302. </pages>
Reference-contexts: It allows for variables which can be assigned to. This will work even outside the module where they are defined. The variable mode is similar to the ref type of SML. It is a well-known fact that there are some fundamental difficulties with references to polymorphic types <ref> [LW91] </ref>. Consider: (define-type s1 (signature (x) (variable x number))) (define m (module s2 ... (define x 1))) 8 Signatures defined in separate files can be loaded into the interactive environment.
Reference: [MT] <author> David B. MacQueen and Mads Tofte. </author> <title> A semantics for higher-order functors. </title>
Reference-contexts: In particular, an implementation does not need 18 Meanwhile, the theory of higher-order functors has been worked out, and there is an implementation in SML/NJ. The semantics of higher-order functors are explained in <ref> [MT] </ref>. to support the reification of local environments like the ones created by scoping constructs. It has been hinted that modules can be regarded as top-level environments, or rather as top-level environment specifiers.
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Thus, separate compilation re quires the separation of syntactic defini tions from value definitions. The module system proposed here draws many ideas from other languages, most notably from Standard ML <ref> [MTH90] </ref>. In particular it distinguishes between modules 1 and signatures.
Reference: [POP91] <institution> Eighteenth Annual ACM Symposium on Principles of Programming Languages, </institution> <year> 1991. </year>
Reference: [Ree92] <author> Jonathan Rees. </author> <title> The scheme of things: </title> <booktitle> The june 1992 meeting, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: There have been many arguments about the relative merits of such a construct. More importantly, there has been some discussion about its semantics. In the fifth revision of the "Report of the Algorithmic Language Scheme", which has yet to appear <ref> [Ree92] </ref>, eval will be a procedure. It takes two arguments: the symbolic expression to evaluate and an environment specifier. This second argument is used to denote the environment the expression is to be evaluated within.
Reference: [Ree93] <author> Jonathan Rees. </author> <title> Another module system for scheme, </title> <month> January </month> <year> 1993. </year>
Reference: [SA93] <author> Zhong Shao and Andrew Ap-pel. </author> <title> Smartest recompilation. </title> <booktitle> In Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 439-450, </pages> <year> 1993. </year>
Reference-contexts: Types in Scheme In strongly typed languages it is possible to infer type information for other modules by observing how these modules are used. Therefore, the compilation of one module does not require extra information about any other module <ref> [SA93] </ref>. In Scheme it is not possible to acquire reliable type information using this technique. This means that a module system should also be able to provide type information to the compiler. Type information must be separated from actual value definitions. In some sense types are similar to syntactic definitions.
Reference: [Tun92] <author> Sho-Huang Simon Tung. </author> <title> Interactive modular programming in scheme. </title> <booktitle> In 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 86-95, </pages> <year> 1992. </year>
Reference-contexts: In comparison with the interactive environment the important differences are: * The compiler sees all definitions at once. * The environment is not mutable. Most previous attempts ([Ree93], [CR90]) to add a module system to Scheme stop here. Other proposals take a completely different approach. <ref> [Tun92] </ref> emphasizes interactive programming and distinguishes between developing and developed modules. Developing modules facilitate interactive program development, while developed modules are meant to be well-suited for separate compilation.
Reference: [WC93] <author> Andrew K. Wright and Robert Cartwright. </author> <title> A practical soft type system for scheme. </title> <type> Technical Report TR93-218, </type> <institution> Department of Computer Science, Rice University, </institution> <month> December </month> <year> 1993. </year> <month> 16 </month>
Reference-contexts: A detailed specification certainly requires discussion in the Scheme language community. Since it is intended to communicate type information which might be used by existing type inference mechanisms like <ref> [WC93] </ref>, it must be coordinated with those mechanisms, should they ever become widespread in use. The early motivation to design the module system presented in this paper was to support optimization of the procedure calling protocol. In particular, eliminating most of the arity-checking code could noticably improve overall performance.
References-found: 13

