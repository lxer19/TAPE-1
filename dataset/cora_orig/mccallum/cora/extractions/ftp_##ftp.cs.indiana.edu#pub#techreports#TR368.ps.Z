URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR368.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Email: e-mail: vijay@cs.indiana.edu  e-mail: saxton@cs.uregina.ca  e-mail: vgucht@cs.indiana.edu  
Title: An Object Based Algebra for Parallel Query Processing and Optimization  
Author: Vijay M. Sarathy Lawrence V. Saxton Dirk Van Gucht 
Address: Bloomington, Indiana 47405-4101, USA  Regina, Saskatchewan S4S 0A2, Canada  Bloomington, Indiana 47405-4101, USA  
Affiliation: Indiana University Computer Science Department  University of Regina Department of Computer Science  Indiana University Computer Science Department  
Abstract: The Tarski algebra provides an algebraic foundation for object-based query languages. This is demonstrated by showing how queries expressed in a graph-oriented query language (based on the functional data model) can be translated into the Tarski algebra. The graphical representation of queries in combination with the Tarski algebra is a convenient mechanism to study optimization in the context of object based query languages. We then propose extensions to the Tarski algebra that facilitate parallel query processing and address the issue of parallel query optimization in this algebraic framework. We also show how our framework helps in the study of non-monotonic query optimization. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> S. Abiteboul, P. Fischer, and H.J. Schek, editors. </editor> <title> Nested Relations and Complex Objects in Databases. </title> # <booktitle> 361 in Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: These database models can be classified into three main categories: the complex object models, the function-based object models, and hybrids of these. Complex object models <ref> [1, 2, 32, 35] </ref> (also called value-based models) extend the relational model by allowing, besides flat relations, complex object types obtained as a sequence of type constructions, such as tuple, (finite) set, (finite) list, array, and pointer formation. <p> In the area of query languages for complex object databases, researchers have successfully extended the well-known relational query languages. This has resulted in calculus, algebraic, rule-based, and SQL-like query languages for complex object databases <ref> [1, 2, 3, 31, 35, 53] </ref>. In contrast, the study of query languages for function-based object databases is less developed. In this area, the most progress has been made in the specification of SQL and rule-based languages [5, 9, 28, 39, 47].
Reference: [2] <author> S. Abiteboul and V. Kanellakis. </author> <title> Database Theory Column: Query Languages for Complex Object Databases. </title> <journal> ACM SIGACT NEWS 21, </journal> <volume> 2, </volume> <month> Summer </month> <year> 1990, </year> <pages> pp. 9-19. </pages>
Reference-contexts: These database models can be classified into three main categories: the complex object models, the function-based object models, and hybrids of these. Complex object models <ref> [1, 2, 32, 35] </ref> (also called value-based models) extend the relational model by allowing, besides flat relations, complex object types obtained as a sequence of type constructions, such as tuple, (finite) set, (finite) list, array, and pointer formation. <p> In the area of query languages for complex object databases, researchers have successfully extended the well-known relational query languages. This has resulted in calculus, algebraic, rule-based, and SQL-like query languages for complex object databases <ref> [1, 2, 3, 31, 35, 53] </ref>. In contrast, the study of query languages for function-based object databases is less developed. In this area, the most progress has been made in the specification of SQL and rule-based languages [5, 9, 28, 39, 47]. <p> In other words, complex objects are not explicitly materialized but are specified referentially. Although both approaches are equivalent, the Tarski algebra is more uniform since it is not overloaded with operations to deal with the complexity of differently typed structured objects, unlike most other algebras for function-based object databases <ref> [2, 53] </ref>. More importantly, we feel that addressing query optimization is impeded in a complex and strongly typed language [11, 53]. Our approach, enables specification of simple and general query optimization rules in a simple algebraic framework.
Reference: [3] <author> S. Abiteboul and V. Kanellakis. </author> <title> Object Identity as a Query Language Primitive, </title> <booktitle> In Proc. ACM SIGMOD, </booktitle> <month> May </month> <year> 1989, </year> <pages> pp. 159-173. </pages>
Reference-contexts: In the area of query languages for complex object databases, researchers have successfully extended the well-known relational query languages. This has resulted in calculus, algebraic, rule-based, and SQL-like query languages for complex object databases <ref> [1, 2, 3, 31, 35, 53] </ref>. In contrast, the study of query languages for function-based object databases is less developed. In this area, the most progress has been made in the specification of SQL and rule-based languages [5, 9, 28, 39, 47].
Reference: [4] <author> S. Abiteboul and V. Vianu. </author> <title> Procedural Languages for Database Queries and Updates. </title> <journal> Journal of Computer and System Sciences 41, </journal> <year> 1990, </year> <pages> pp. 181-229. </pages>
Reference: [5] <author> J. Annevelink. </author> <title> Database Programming Languages: A Functional Approach. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conf. on Management of Data, </booktitle> <address> Denver, Colorado, </address> <year> 1991, </year> <pages> pp. 318-327. </pages>
Reference-contexts: In contrast, the study of query languages for function-based object databases is less developed. In this area, the most progress has been made in the specification of SQL and rule-based languages <ref> [5, 9, 28, 39, 47] </ref>. Although proposals for function-based object algebras have appeared in the literature, such algebras strongly resemble the algebras defined for complex object databases [13, 18, 46, 53].
Reference: [6] <author> M. Atkinson, F. Bancilhon, D.J. DeWitt, K. Dittrich, D. Maier, and S. Zdonik. </author> <title> The Object-Oriented Database System Manifesto. </title> <booktitle> In Proc. 1st Int'l Conf. on Deductive and Object-Oriented Databases, </booktitle> <address> Kyoto, Japan, </address> <year> 1989, </year> <pages> pp. 40-57. </pages>
Reference: [7] <author> F. Bancilhon. </author> <title> Object Oriented Database Systems. </title> <booktitle> In Proc. 7th ACM SIGACT-SIGMOD-SIGART Symp. on Princ. Database Systems, </booktitle> <address> Austin, Texas, </address> <year> 1988, </year> <pages> pp. 152-162. 17 </pages>
Reference: [8] <author> F. Bancilhon, T. Briggs, S. Khoshafian, and P. Valduriez. </author> <title> FAD, A Powerful and Simple Database Language. </title> <booktitle> In Proc. of the 13th Int'l Conf. on Very Large Databases, </booktitle> <year> 1987. </year>
Reference: [9] <author> F. Bancilhon, S. Cluet, C. Delobel. </author> <title> A Query Language for the O 2 Object-Oriented Database System. </title> <booktitle> In 2nd Int'l. Workshop on Database Programming Languages, </booktitle> <address> Oregon, </address> <year> 1989, </year> <pages> pp. 122-138. </pages>
Reference-contexts: In contrast, the study of query languages for function-based object databases is less developed. In this area, the most progress has been made in the specification of SQL and rule-based languages <ref> [5, 9, 28, 39, 47] </ref>. Although proposals for function-based object algebras have appeared in the literature, such algebras strongly resemble the algebras defined for complex object databases [13, 18, 46, 53].
Reference: [10] <author> C. Beeri. </author> <title> New Data Models and Languages The Challenge. </title> <booktitle> In ACM SIGACT-SIGMOD-SIGART Symp. on Princ. Database Systems, </booktitle> <address> San Diego, California, </address> <year> 1992, </year> <pages> pp. 1-15. </pages>
Reference-contexts: 1 Introduction Over the last decade, a variety of new database models <ref> [10] </ref> have been introduced to deal with data applications involving objects with a complex external and/or internal structure. These database models can be classified into three main categories: the complex object models, the function-based object models, and hybrids of these.
Reference: [11] <author> C. Beeri, Y. Kornatzky. </author> <title> Algebraic Optimization of Object-Oriented Query Languages. </title> <booktitle> In Proc. 3rd Int'l Conf. on Database Theory, </booktitle> <address> Paris, France Dec. </address> <year> 1990, </year> <pages> pp. 72-88. </pages>
Reference-contexts: More importantly, we feel that addressing query optimization is impeded in a complex and strongly typed language <ref> [11, 53] </ref>. Our approach, enables specification of simple and general query optimization rules in a simple algebraic framework. There are also some derived Tarski operators that will prove useful in subsequent sections.
Reference: [12] <author> V. Breazu-Tannen, P. Buneman, and S. Naqvi. </author> <title> Structural Recursion as a Query Language. </title> <booktitle> In Proc. 3rd Int'l Workshop on Database Programming Languages, </booktitle> <address> Greece, </address> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: Parallelism in the context of database programming languages has received a renewed interest in recent times [27, 42]. Other related work has focussed on the expressiveness and query optimization for such languages <ref> [12, 19] </ref>. These approaches have been based on the functional programming paradigm because it naturally lends itself to the divide and conquer principle and consequently parallelism can be exploited. <p> It is important to point out that most other approaches that use the divide and conquer approach to parallelism <ref> [12, 19, 27, 42] </ref> use the functional programming paradigm, and rely on a host of complicated type constructors. This not only makes these languages unduly complex, but also makes query optimization more difficult and less general because each extra type constructor necessitates special type-specific optimization rules.
Reference: [13] <author> V. </author> <booktitle> Breauzu-Tannen et.al. </booktitle> <pages> (pp. 23-28), </pages> <editor> S. </editor> <booktitle> Vandenberg and D.J. </booktitle> <pages> DeWitt (pp. 48-53), </pages> <editor> and S. </editor> <booktitle> Daniels et.al. </booktitle> <pages> (pp. 58-63). </pages> <booktitle> Special Issue on Foundations of Object-Oriented Database Systems. Data Engineering, </booktitle> <volume> 14, 2, </volume> <month> June </month> <year> 1991. </year>
Reference-contexts: In this area, the most progress has been made in the specification of SQL and rule-based languages [5, 9, 28, 39, 47]. Although proposals for function-based object algebras have appeared in the literature, such algebras strongly resemble the algebras defined for complex object databases <ref> [13, 18, 46, 53] </ref>. Defining algebras in this fashion deviates from the basic philosophy of the pure function-based approach as the level of abstraction at which these algebras operate is several layers higher than the graph-oriented nature of the function-based approach.
Reference: [14] <author> V. Bussche and J.Paredaens. </author> <title> The Expressive Power of Structured Values in Pure OODB's. </title> <booktitle> In Proc. 10th ACM SIGACT-SIGMOD-SIGART Symp. on Princ. Database Systems, </booktitle> <year> 1991, </year> <pages> pp. 291-299. </pages>
Reference-contexts: Complex object models [1, 2, 32, 35] (also called value-based models) extend the relational model by allowing, besides flat relations, complex object types obtained as a sequence of type constructions, such as tuple, (finite) set, (finite) list, array, and pointer formation. On the other hand, function-based object models <ref> [14, 21, 28, 47] </ref> view a database as a graph of objects organized in classes, where the links between objects express single-valued and multi-valued functions (relationships) between objects. In the area of query languages for complex object databases, researchers have successfully extended the well-known relational query languages.
Reference: [15] <author> M.J. Carey, D.J. DeWitt, G. Graefe, D.M. Haight, J.E. Richardson, D.T. Schuch, E.J. Shekita, and S.L. Van-denberg. </author> <title> The EXODUS Extensible DBMS Project: An Overview. In Readings in Object-Oriented Database Systems. Edited by S.B. </title> <editor> Zdonik and D. Maier, </editor> <publisher> Morgan Kaufmann Publ., </publisher> <year> 1989. </year>
Reference: [16] <author> M.P. Consens and A.O. Mendelzon. </author> <title> GraphLog: A Visual Formalism for Real Life Recursion. </title> <booktitle> In Proc. 9th ACM SIGACT-SIGMOD-SIGART Symp. on Princ. Database Systems, </booktitle> <address> Nashville, Tenn., </address> <year> 1990, </year> <pages> pp. 404-416. </pages>
Reference: [17] <author> G. Copeland and S. Khoshafian. </author> <title> A Decomposition Storage Model. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conf. on Management of Data, </booktitle> <address> Austin, Texas, </address> <year> 1985, </year> <pages> pp. 268-279. </pages>
Reference-contexts: However, there are some limitations with the basic Tarski algebra, which we outline in this section. The Tarski algebra operates on binary relations, and one possible storage structure to support such an algebra is the Decomposed Storage Model (DSM) as discussed in Section 4. As argued in <ref> [17, 29] </ref>, the principal motivation for the use of the DSM is the advantages it offers for query processing in parallel. The advantages are due to the vertical fragmentation of large relations into a set of smaller binary relations. <p> The data partitioning is expressed in the algebra itself giving the user explicit control over the degree of parallelism. This is in contrast to a DSM approach which uses vertical partitioning and achieves parallelism only at the physical level giving the user no control over the parallelism <ref> [17, 29] </ref>. The horizontal partitioning is achieved by adding the for construct to the algebra. This is specified as follows: for [x; y] in (tarski-expression1) accumulate (tarski-expression2) The tarski-expressions 1 and 2 can be arbitrarily complex, giving the user flexibility over the degree of parallelism.
Reference: [18] <author> U. Dayal. </author> <title> Queries and Views in an Object-Oriented Data Model. </title> <booktitle> In Proc. of 2nd Database Programming Languages Workshop, </booktitle> <year> 1989, </year> <pages> pp. 80-102. </pages>
Reference-contexts: In this area, the most progress has been made in the specification of SQL and rule-based languages [5, 9, 28, 39, 47]. Although proposals for function-based object algebras have appeared in the literature, such algebras strongly resemble the algebras defined for complex object databases <ref> [13, 18, 46, 53] </ref>. Defining algebras in this fashion deviates from the basic philosophy of the pure function-based approach as the level of abstraction at which these algebras operate is several layers higher than the graph-oriented nature of the function-based approach.
Reference: [19] <author> M. Erwig, and U.W. Lipeck. </author> <title> A Functional DBPL Revealing High Level Optimizations. </title> <booktitle> In Proc. 9th ACM SIGACT-SIGMOD-SIGART Symp. on Princ. Database Systems, </booktitle> <address> Nashville, Tenn., </address> <year> 1990, </year> <pages> pp. 417-424. </pages>
Reference-contexts: Parallelism in the context of database programming languages has received a renewed interest in recent times [27, 42]. Other related work has focussed on the expressiveness and query optimization for such languages <ref> [12, 19] </ref>. These approaches have been based on the functional programming paradigm because it naturally lends itself to the divide and conquer principle and consequently parallelism can be exploited. <p> Tarski-expression2 16 could be evaluated in parallel for each pair [x; y] in tarski-expression1, the results of which are then accumulated to provide the final answer to the query. This specifies fan-in parallelism. The accumulate operator has to satisfy the following properties <ref> [19] </ref>. 1. It should be consistent with the basic Tarski algebra, 2. It should be commutative, and 3. It should be associative. These properties ensure that the results can be accumulated in any order, and therefore ensure that the parallelism is truly independent. <p> It is important to point out that most other approaches that use the divide and conquer approach to parallelism <ref> [12, 19, 27, 42] </ref> use the functional programming paradigm, and rely on a host of complicated type constructors. This not only makes these languages unduly complex, but also makes query optimization more difficult and less general because each extra type constructor necessitates special type-specific optimization rules.
Reference: [20] <author> M. Gyssens, J. Paredaens, and Dirk Van Gucht. </author> <title> A Graph Oriented Object Database Model. </title> <booktitle> In Proc. 9th ACM SIGACT-SIGMOD-SIGART Symp. on Princ. Database Systems, </booktitle> <address> Nashville, Tenn., </address> <year> 1990, </year> <pages> pp. 417-424. </pages>
Reference-contexts: To demonstrate this, we show how to translate queries specified in a graph-oriented query language into the Tarski algebra. A graph-oriented query specification language was chosen because graphs are the natural representation of function-based object databases <ref> [20, 21, 30] </ref>. We then propose extensions to the basic Tarski algebra that facilitate parallel query execution and optimization in an algebraic framework. Parallelism in the context of database programming languages has received a renewed interest in recent times [27, 42]. <p> The labeled nodes in the schema (instance) correspond to the object classes (objects) in the database, and the labeled edges correspond to the functions or relationships between these classes (objects) <ref> [20, 21, 41] </ref>. Consider the graph in Figure 1. The left graph represents the object base schema of a departments database, and the right graph represents an instance over the departments schema. The rectangular nodes represent structured object classes, whereas the circular nodes represent basic object classes.
Reference: [21] <author> M. Gyssens, J. Paredaens, and Dirk Van Gucht. </author> <title> A Graph Oriented Object Model for Database End-User Interfaces. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conf. on Management of Data, </booktitle> <address> Atlantic City, New Jersey, </address> <year> 1990, </year> <pages> pp. 24-33. </pages>
Reference-contexts: Complex object models [1, 2, 32, 35] (also called value-based models) extend the relational model by allowing, besides flat relations, complex object types obtained as a sequence of type constructions, such as tuple, (finite) set, (finite) list, array, and pointer formation. On the other hand, function-based object models <ref> [14, 21, 28, 47] </ref> view a database as a graph of objects organized in classes, where the links between objects express single-valued and multi-valued functions (relationships) between objects. In the area of query languages for complex object databases, researchers have successfully extended the well-known relational query languages. <p> To demonstrate this, we show how to translate queries specified in a graph-oriented query language into the Tarski algebra. A graph-oriented query specification language was chosen because graphs are the natural representation of function-based object databases <ref> [20, 21, 30] </ref>. We then propose extensions to the basic Tarski algebra that facilitate parallel query execution and optimization in an algebraic framework. Parallelism in the context of database programming languages has received a renewed interest in recent times [27, 42]. <p> The labeled nodes in the schema (instance) correspond to the object classes (objects) in the database, and the labeled edges correspond to the functions or relationships between these classes (objects) <ref> [20, 21, 41] </ref>. Consider the graph in Figure 1. The left graph represents the object base schema of a departments database, and the right graph represents an instance over the departments schema. The rectangular nodes represent structured object classes, whereas the circular nodes represent basic object classes.
Reference: [22] <author> M. Gyssens, L. Saxton, and Dirk Van Gucht. </author> <title> Tagging as an Alternative to Object Creation. Presented at The Dagstuhl Seminar on Query Processing in Object Oriented, Complex Object, and Nested Relation Databases. </title>
Reference-contexts: by 1) encoding the object base as a collection of conceptual binary relations as shown in Figure 4 corresponding to the classes and functions in the graph instance, and 2) resorting to an algebra over binary relations introduced by Tarski 4 , and augmented by Gyssens et.al and Sarathy et.al <ref> [22, 44] </ref>. The kernel of this algebra consists of four well-known operators on binary relations: union (r [ s), composition (r fi s) 5 , inverse (r 1 ) 6 , and (finite) complementation (r) 7 . This algebra is not powerful enough to express all reasonable queries. <p> This is the set of pairs (t; t), where t is an oid of an ordered pair of r, and is called the ordered-pair oids operator. 10 This is the regular intersection of two relations and can be specified in the Tarski algebra as shown in <ref> [22] </ref>. 4 3 The Query Graph Translation Algorithm We now turn to translating query graphs into equivalent Tarski algebra expressions. We first need to encode an object base instance as a set of conceptual binary relations, which can be manipulated by the Tarski algebra. <p> Before we proceed, we would like to introduce the if then else construct. This is a derived construct that can be simulated in the basic Tarski algebra <ref> [22] </ref> and is specified as follows: if (tarski-expression1) then (tarski-expression2) else (tarski-expression3) The semantics of this construct are straightforward, if tarski-expression1 evaluates to a non-empty binary relation, then the binary relation that tarski-expression2 evaluates to is returned, else the binary relation that tarski-expression3 evaluates to is returned. 5.4 Examples In this <p> on the 2nd floor. result = iname l temp * SQL solution. select ino from iname i where not exists (select fl from f loor f where f loor = 0 2 0 18 We use set difference which can be simulated in the basic Tarski algebra as shown in <ref> [22] </ref>. 12 and not exists ( select fl from sales where ino = i:ino and dno = f:dno)) It is clear that both the basic Tarski algebra and the SQL solutions are complicated. This example clearly illustrates that query formulation in our extended algebra is simpler and more intuitive.
Reference: [23] <author> M. Guo, S.Y.W. Su, and H. Lam. </author> <title> An Association Algebra For Processing Object-Oriented Databases. </title> <booktitle> In Proc. Seventh IEEE Int'l Conf. on Data Engineering, </booktitle> <year> 1991. </year>
Reference: [24] <author> L.M. Haas, J.C. Freytag, G.M. Lohman and H. Pirahesh. </author> <title> Extensible Query Processing in Starburst IBM Almaden Research Center, </title> <address> San Jose, California. </address>
Reference: [25] <author> A. Hafez, and G. Ozsoyoglu. </author> <title> Storage Structures for Nested Relations. In Special Issue on Nested Relations, </title> <journal> IEEE Computer Society Technical Committee on Data Engineering, </journal> <month> Sept. </month> <year> 1988, </year> <pages> pp. 31-38. </pages>
Reference-contexts: a storage organization based on binary relations in which an n-ary relation is broken into several binary relations consisting of surrogate-attribute 14 The quintuple captures the five objects in the subset query graph of Figure 2. 15 Various techniques and their relative merits/demerits for implementing complex objects are discussed in <ref> [25, 52] </ref>. 7 pairs. Clearly, the DSM lends itself naturally as a physical storage model to support the Tarski algebra. The DSM is best suited for join queries that do not report more than a few attributes in the final result.
Reference: [26] <author> E.N. Hanson, T.M. Harvey, and M.A. Roth. </author> <title> Experiences in DBMS Implementation Using an Object-Oriented Persistent Programming Language and a Database Toolkit. </title> <booktitle> In Proc. OOPSLA 1991, </booktitle> <pages> pp. 314-328. </pages>
Reference: [27] <author> B. Hart, S. Danforth, and P. Valduriez. </author> <title> Parallelizing FAD, A Database Programming Language. </title> <booktitle> In Proc. Int'l Symposium on Databases in Distributed and Parallel Systems, </booktitle> <address> Austin, Texas, </address> <month> Dec. </month> <year> 1988. </year> <month> 18 </month>
Reference-contexts: We then propose extensions to the basic Tarski algebra that facilitate parallel query execution and optimization in an algebraic framework. Parallelism in the context of database programming languages has received a renewed interest in recent times <ref> [27, 42] </ref>. Other related work has focussed on the expressiveness and query optimization for such languages [12, 19]. These approaches have been based on the functional programming paradigm because it naturally lends itself to the divide and conquer principle and consequently parallelism can be exploited. <p> It is important to point out that most other approaches that use the divide and conquer approach to parallelism <ref> [12, 19, 27, 42] </ref> use the functional programming paradigm, and rely on a host of complicated type constructors. This not only makes these languages unduly complex, but also makes query optimization more difficult and less general because each extra type constructor necessitates special type-specific optimization rules.
Reference: [28] <author> R. Hull and M. Yoshikawa. </author> <title> ILOG: Declarative Creation and Manipulation of Object Identifiers. </title> <editor> D. McLeod, R. Sacks-Davis, and H. Schek, editors, </editor> <booktitle> In Proc. 16th Int'l Conf. on Very Large Databases, </booktitle> <address> Brisbane, Australia, </address> <year> 1990. </year>
Reference-contexts: Complex object models [1, 2, 32, 35] (also called value-based models) extend the relational model by allowing, besides flat relations, complex object types obtained as a sequence of type constructions, such as tuple, (finite) set, (finite) list, array, and pointer formation. On the other hand, function-based object models <ref> [14, 21, 28, 47] </ref> view a database as a graph of objects organized in classes, where the links between objects express single-valued and multi-valued functions (relationships) between objects. In the area of query languages for complex object databases, researchers have successfully extended the well-known relational query languages. <p> In contrast, the study of query languages for function-based object databases is less developed. In this area, the most progress has been made in the specification of SQL and rule-based languages <ref> [5, 9, 28, 39, 47] </ref>. Although proposals for function-based object algebras have appeared in the literature, such algebras strongly resemble the algebras defined for complex object databases [13, 18, 46, 53].
Reference: [29] <author> S. Khoshafian, G. Copeland, T. Jagodits, H. Boral and P. Valduriez. </author> <title> A Query Processing Strategy for the Decomposed Storage Model. </title> <booktitle> In IEEE Data Engineering, </booktitle> <year> 1987. </year> <pages> pp. 636-643. </pages>
Reference-contexts: However, there are some limitations with the basic Tarski algebra, which we outline in this section. The Tarski algebra operates on binary relations, and one possible storage structure to support such an algebra is the Decomposed Storage Model (DSM) as discussed in Section 4. As argued in <ref> [17, 29] </ref>, the principal motivation for the use of the DSM is the advantages it offers for query processing in parallel. The advantages are due to the vertical fragmentation of large relations into a set of smaller binary relations. <p> The data partitioning is expressed in the algebra itself giving the user explicit control over the degree of parallelism. This is in contrast to a DSM approach which uses vertical partitioning and achieves parallelism only at the physical level giving the user no control over the parallelism <ref> [17, 29] </ref>. The horizontal partitioning is achieved by adding the for construct to the algebra. This is specified as follows: for [x; y] in (tarski-expression1) accumulate (tarski-expression2) The tarski-expressions 1 and 2 can be arbitrarily complex, giving the user flexibility over the degree of parallelism.
Reference: [30] <author> S. Khoshafian and P. Valduriez. </author> <title> Sharing, Persistence, and Object Orientation: A Database Perspective. </title> <booktitle> Advances in Database Programming Languages. </booktitle> <publisher> ACM Press, Frontier Series, </publisher> <pages> pp. 221-240. </pages>
Reference-contexts: To demonstrate this, we show how to translate queries specified in a graph-oriented query language into the Tarski algebra. A graph-oriented query specification language was chosen because graphs are the natural representation of function-based object databases <ref> [20, 21, 30] </ref>. We then propose extensions to the basic Tarski algebra that facilitate parallel query execution and optimization in an algebraic framework. Parallelism in the context of database programming languages has received a renewed interest in recent times [27, 42].
Reference: [31] <author> M. Kifer, W. Kim, and Y. Sagiv. </author> <title> Querying Object Oriented Databases. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conf. on Management of Data, </booktitle> <address> San Diego, California, </address> <year> 1992, </year> <pages> pp. 393-402. </pages>
Reference-contexts: In the area of query languages for complex object databases, researchers have successfully extended the well-known relational query languages. This has resulted in calculus, algebraic, rule-based, and SQL-like query languages for complex object databases <ref> [1, 2, 3, 31, 35, 53] </ref>. In contrast, the study of query languages for function-based object databases is less developed. In this area, the most progress has been made in the specification of SQL and rule-based languages [5, 9, 28, 39, 47].
Reference: [32] <author> M. Kifer, G. Lausen, and J. Wu. </author> <title> Logical Foundations of Object Oriented and Frame-Based Languages. </title> <type> Technical Report 90/14, </type> <institution> Dept. of Comp. Science, SUNY Stony Brook, </institution> <year> 1990. </year>
Reference-contexts: These database models can be classified into three main categories: the complex object models, the function-based object models, and hybrids of these. Complex object models <ref> [1, 2, 32, 35] </ref> (also called value-based models) extend the relational model by allowing, besides flat relations, complex object types obtained as a sequence of type constructions, such as tuple, (finite) set, (finite) list, array, and pointer formation.
Reference: [33] <editor> W. Kim and F.H. Lochovsky, editors. </editor> <title> Object-Oriented Concepts, Databases, and Applications. </title> <publisher> ACM Press (Frontier Series), </publisher> <year> 1989. </year>
Reference: [34] <author> W. Kim, D.S. Reiner, and D.S. Batory. </author> <title> Query Processing in Database Systems. </title> <publisher> Springer Verlag Publishers, </publisher> <year> 1985. </year>
Reference: [35] <author> G. Kuper and M. Vardi. </author> <title> A New Approach to Database Logic. </title> <booktitle> In Proc. of the 3rd ACM Symposium on Principles of Database Systems, </booktitle> <pages> pp. 86-96, </pages> <publisher> ACM Press, </publisher> <year> 1984. </year>
Reference-contexts: These database models can be classified into three main categories: the complex object models, the function-based object models, and hybrids of these. Complex object models <ref> [1, 2, 32, 35] </ref> (also called value-based models) extend the relational model by allowing, besides flat relations, complex object types obtained as a sequence of type constructions, such as tuple, (finite) set, (finite) list, array, and pointer formation. <p> In the area of query languages for complex object databases, researchers have successfully extended the well-known relational query languages. This has resulted in calculus, algebraic, rule-based, and SQL-like query languages for complex object databases <ref> [1, 2, 3, 31, 35, 53] </ref>. In contrast, the study of query languages for function-based object databases is less developed. In this area, the most progress has been made in the specification of SQL and rule-based languages [5, 9, 28, 39, 47].
Reference: [36] <author> M. Lacroix and A. Pirotte. </author> <title> Example Queries in Relational Languages. </title> <note> Technical Note No. 107 Brussels: </note> <editor> M. B. L. </editor> <publisher> E. </publisher>
Reference-contexts: Most of our examples are chosen from the set of 66 queries in <ref> [36] </ref> to show the expressive power of our algebra. The examples are chosen to cover different types of queries, from very simple to very difficult, to show the range of the algebra, and are numbered as in [36]. Some of our own examples are also presented and are ordered alphabetically. <p> Most of our examples are chosen from the set of 66 queries in <ref> [36] </ref> to show the expressive power of our algebra. The examples are chosen to cover different types of queries, from very simple to very difficult, to show the range of the algebra, and are numbered as in [36]. Some of our own examples are also presented and are ordered alphabetically. Some of the examples may be solved with the basic Tarski algebra itself.
Reference: [37] <author> R.D. Maddux. </author> <title> The Origin of Relation Algebras in the Development and Axiomatization of the Calculus of Relations. </title> <journal> In Studia Logica L, </journal> <volume> 3/4, </volume> <pages> pp. 421-455, </pages> <year> 1991. </year>
Reference-contexts: For some recent surveys of this work see <ref> [37] </ref>. 5 The set of ordered pairs (u; w) such that there exists a value v, such that the ordered pair (u; v) 2 r and (v; w) 2 s: 6 The set of ordered pairs (v; u) such that the ordered pair (u; v) 2 r. 7 Finite complementation is
Reference: [38] <author> D. Maier. </author> <title> The Theory of Relational Databases. </title> <publisher> Computer Science Press, </publisher> <year> 1983. </year>
Reference: [39] <author> M. Mannino, I. Choi, D. Batory. </author> <title> An Overview of an Object Oriented Data Language. </title> <booktitle> In Proc. of IEEE Data Engineering Conf., </booktitle> <year> 1989. </year>
Reference-contexts: In contrast, the study of query languages for function-based object databases is less developed. In this area, the most progress has been made in the specification of SQL and rule-based languages <ref> [5, 9, 28, 39, 47] </ref>. Although proposals for function-based object algebras have appeared in the literature, such algebras strongly resemble the algebras defined for complex object databases [13, 18, 46, 53].
Reference: [40] <author> O. </author> <title> Ore. Theory of Graphs. </title> <publisher> American Mathematical Society, </publisher> <year> 1962. </year>
Reference-contexts: To solve such queries, it is best to resort to a mathematical framework that is faithful to the function-based approach. Since the object base schemas and instances we are working with are labeled graphs, a natural (and easy) way to conceptualize them is as a collection of binary relations <ref> [40] </ref>.
Reference: [41] <author> J. Paredaens, J. Van den Bussche, D. Van Gucht, V. Sarathy, and L. Saxton. </author> <title> An Overview of GOOD. </title> <booktitle> In SIGMOD Record, </booktitle> <volume> Volume 21, Number 1, </volume> <month> March </month> <year> 1992. </year>
Reference-contexts: The labeled nodes in the schema (instance) correspond to the object classes (objects) in the database, and the labeled edges correspond to the functions or relationships between these classes (objects) <ref> [20, 21, 41] </ref>. Consider the graph in Figure 1. The left graph represents the object base schema of a departments database, and the right graph represents an instance over the departments schema. The rectangular nodes represent structured object classes, whereas the circular nodes represent basic object classes.
Reference: [42] <author> D.S. Parker, E. Simon, and P. Valduriez. </author> <title> SVP A Model Capturing Sets, Streams, and Parallelism. </title> <booktitle> In Proc. of the 18th Int'l Conf. on Very Large Databases, </booktitle> <address> Vancouver, Canada, </address> <year> 1992. </year>
Reference-contexts: We then propose extensions to the basic Tarski algebra that facilitate parallel query execution and optimization in an algebraic framework. Parallelism in the context of database programming languages has received a renewed interest in recent times <ref> [27, 42] </ref>. Other related work has focussed on the expressiveness and query optimization for such languages [12, 19]. These approaches have been based on the functional programming paradigm because it naturally lends itself to the divide and conquer principle and consequently parallelism can be exploited. <p> Furthermore, the resulting parallelism is entirely at the physical level and the user has no control over the degree of parallelism at the query language level. The other, and more frequently studied data fragmentation beneficial for parallel query processing is the horizontal fragmentation of data <ref> [42] </ref>. As such, the basic Tarski algebra has no mechanisms to specify such horizontal data fragmentation. In this section, we extend the basic Tarski algebra to enable horizontal data fragmentation (partitioning) and specification of parallelism within the algebra itself. <p> The independent data partitioning specifies independent fan-out parallelism <ref> [42] </ref> since the independent subproblems can be solved independently in parallel. The data partitioning is expressed in the algebra itself giving the user explicit control over the degree of parallelism. <p> It is important to point out that most other approaches that use the divide and conquer approach to parallelism <ref> [12, 19, 27, 42] </ref> use the functional programming paradigm, and rely on a host of complicated type constructors. This not only makes these languages unduly complex, but also makes query optimization more difficult and less general because each extra type constructor necessitates special type-specific optimization rules.
Reference: [43] <author> A. Rosenthal and C.G. Legaria. </author> <title> Query Graphs, Implementing Trees, and Freely-Reorderable Outerjoins. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conf. on Management of Data, </booktitle> <address> Atlantic City, New Jersey, </address> <year> 1990, </year> <pages> pp. 291-299. </pages>
Reference: [44] <author> V. Sarathy, L. Saxton and D. Van Gucht. </author> <title> Translating Query Graphs into Tarski Algebra Expressions. </title> <type> Technical Report # 342, </type> <institution> Dept. of Computer Science, Indiana University, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: Given this situation, we propose a simple algebra, the Tarski algebra, that is appropriate to support object-based query languages <ref> [44] </ref>. Unlike previously considered algebras, the Tarski algebra operates on graphs (interpreted as conceptual binary relations 1 ) rather than on objects of complex types. <p> by 1) encoding the object base as a collection of conceptual binary relations as shown in Figure 4 corresponding to the classes and functions in the graph instance, and 2) resorting to an algebra over binary relations introduced by Tarski 4 , and augmented by Gyssens et.al and Sarathy et.al <ref> [22, 44] </ref>. The kernel of this algebra consists of four well-known operators on binary relations: union (r [ s), composition (r fi s) 5 , inverse (r 1 ) 6 , and (finite) complementation (r) 7 . This algebra is not powerful enough to express all reasonable queries. <p> This avoids infinite relations. 8 Oid-creation can be expensive and will be used only when absolutely necessary. Later, we will show how the extensions to the Tarski Algebra can eliminate oid-creation. 9 Due to space limitations, we refer the reader to <ref> [44] </ref> for details on the finite-set oid creation operator. 3 r r / r . a c 2 a 2 c c d 4 c 4 d then (1; 2) represents the complex object (a; b; fc; dg). <p> query graph has one fewer node and one fewer edge, i.e., node combination is a graph reduction operation. 11 We encode a class as a relation of identity pairs to maintain a uniform binary relation approach. 12 Two other graph reduction techniques (graph constraining and chain reduction) are illustrated in <ref> [44, 45] </ref> for optimization in the translation process. 13 Here multiple is not to be confused with multi-valued, and just means "more than one". 5 A stands for manages t , a stands for manages . fi works f or 1 , and b stands for manages / fi isa. <p> Once we have these, computing the required attributes by appropriate compositions is simple and is outlined in <ref> [44, 45] </ref>. <p> This also shows that the Extended Tarski algebra (without oid-creation) is equivalent to the basic Tarski algebra in expressive power. 21 Due to finite complementation in the basic Tarski algebra, r " s cannot be expressed as r [ s using DeMorgan's laws. 16 6.5 Other Optimizations In <ref> [44] </ref>, we outlined several syntactic and semantic graph level optimization techniques for the translation of object based queries into the Tarski algebra. We also showed some algebraic rewrite optimization rules.
Reference: [45] <author> V. Sarathy, L. Saxton and D. Van Gucht. </author> <title> Algebraic Foundation and Optimization for Object Based Query Languages. </title> <booktitle> To appear in Proc. Ninth IEEE Int'l Conf. on Data Engineering, </booktitle> <address> Vienna, Austria, </address> <year> 1993. </year>
Reference-contexts: query graph has one fewer node and one fewer edge, i.e., node combination is a graph reduction operation. 11 We encode a class as a relation of identity pairs to maintain a uniform binary relation approach. 12 Two other graph reduction techniques (graph constraining and chain reduction) are illustrated in <ref> [44, 45] </ref> for optimization in the translation process. 13 Here multiple is not to be confused with multi-valued, and just means "more than one". 5 A stands for manages t , a stands for manages . fi works f or 1 , and b stands for manages / fi isa. <p> Once we have these, computing the required attributes by appropriate compositions is simple and is outlined in <ref> [44, 45] </ref>. <p> Although the basic Tarski algebra is simple, the oid-creation operator was critical in the translation of object based queries. For many queries, oid-creation can be avoided by using the chain reduction technique as shown in <ref> [45] </ref>. However, for solving many complicated queries such as that shown in Figure 8, oid-creation becomes an absolute necessity. Oid-creation could potentially become an expensive operation. Our extensions to the basic Tarski algebra also enable us to eliminate the necessity for oid-creation.
Reference: [46] <author> G. Shaw and S. Zdonik. </author> <title> An Object-Oriented Query Algebra. </title> <booktitle> In Data Engineering, </booktitle> <month> September </month> <year> 1989, </year> <pages> pp. 12(3) 29-36. </pages>
Reference-contexts: In this area, the most progress has been made in the specification of SQL and rule-based languages [5, 9, 28, 39, 47]. Although proposals for function-based object algebras have appeared in the literature, such algebras strongly resemble the algebras defined for complex object databases <ref> [13, 18, 46, 53] </ref>. Defining algebras in this fashion deviates from the basic philosophy of the pure function-based approach as the level of abstraction at which these algebras operate is several layers higher than the graph-oriented nature of the function-based approach.
Reference: [47] <author> D. Shipman. </author> <title> The Functional Data Model and the Data Language DAPLEX. In Readings in object-oriented database systems. Edited by S.B. </title> <editor> Zdonik and D. Maier, </editor> <publisher> Morgan Kaufmann Publ., </publisher> <year> 1989. </year>
Reference-contexts: Complex object models [1, 2, 32, 35] (also called value-based models) extend the relational model by allowing, besides flat relations, complex object types obtained as a sequence of type constructions, such as tuple, (finite) set, (finite) list, array, and pointer formation. On the other hand, function-based object models <ref> [14, 21, 28, 47] </ref> view a database as a graph of objects organized in classes, where the links between objects express single-valued and multi-valued functions (relationships) between objects. In the area of query languages for complex object databases, researchers have successfully extended the well-known relational query languages. <p> In contrast, the study of query languages for function-based object databases is less developed. In this area, the most progress has been made in the specification of SQL and rule-based languages <ref> [5, 9, 28, 39, 47] </ref>. Although proposals for function-based object algebras have appeared in the literature, such algebras strongly resemble the algebras defined for complex object databases [13, 18, 46, 53].
Reference: [48] <author> M. Stonebraker, </author> <title> editor. </title> <booktitle> Readings in Database Systems. </booktitle> <publisher> Morgan Kaufmann Publ., </publisher> <year> 1988. </year>
Reference: [49] <author> A. Tarski. </author> <title> On the Calculus of Relations. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 6, </volume> <year> 1941, </year> <pages> pp. 73-89. 19 </pages>
Reference: [50] <author> A. Tarski and S. Givant. </author> <title> A Formalization of Set Theory Without Variables. </title> <publisher> American Mathematical Society, </publisher> <address> Providence, Rhode Island, </address> <year> 1986. </year>
Reference: [51] <author> J.D. Ullman. </author> <title> Principles of Database and Knowledge-Base Systems, Volume II. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference: [52] <author> P. Valduriez, S. Khoshafian, and G. Copeland. </author> <title> Implementation Techniques for Complex Objects. </title> <booktitle> In Proceedings of the 12th Int'l Conf. on Very Large Databases, </booktitle> <address> Kyoto, </address> <month> August </month> <year> 1986, </year> <pages> pp. 101-109. </pages>
Reference-contexts: The representation of the object base as a collection of binary relations is purely conceptual. The decomposed storage model (DSM) <ref> [52] </ref> is a storage organization based on binary relations in which an n-ary relation is broken into several binary relations consisting of surrogate-attribute 14 The quintuple captures the five objects in the subset query graph of Figure 2. 15 Various techniques and their relative merits/demerits for implementing complex objects are discussed <p> a storage organization based on binary relations in which an n-ary relation is broken into several binary relations consisting of surrogate-attribute 14 The quintuple captures the five objects in the subset query graph of Figure 2. 15 Various techniques and their relative merits/demerits for implementing complex objects are discussed in <ref> [25, 52] </ref>. 7 pairs. Clearly, the DSM lends itself naturally as a physical storage model to support the Tarski algebra. The DSM is best suited for join queries that do not report more than a few attributes in the final result.
Reference: [53] <author> S.L. Vandenberg and D.J. DeWitt. </author> <title> Algebraic Support for Complex Objects with Arrays, Identity and Inheritance. </title> <booktitle> In Proc. ACM SIGMOD Int'l Conf. on Management of Data, </booktitle> <address> Denver, Colorado, </address> <year> 1991, </year> <pages> pp. 158-167. </pages>
Reference-contexts: In the area of query languages for complex object databases, researchers have successfully extended the well-known relational query languages. This has resulted in calculus, algebraic, rule-based, and SQL-like query languages for complex object databases <ref> [1, 2, 3, 31, 35, 53] </ref>. In contrast, the study of query languages for function-based object databases is less developed. In this area, the most progress has been made in the specification of SQL and rule-based languages [5, 9, 28, 39, 47]. <p> In this area, the most progress has been made in the specification of SQL and rule-based languages [5, 9, 28, 39, 47]. Although proposals for function-based object algebras have appeared in the literature, such algebras strongly resemble the algebras defined for complex object databases <ref> [13, 18, 46, 53] </ref>. Defining algebras in this fashion deviates from the basic philosophy of the pure function-based approach as the level of abstraction at which these algebras operate is several layers higher than the graph-oriented nature of the function-based approach. <p> In other words, complex objects are not explicitly materialized but are specified referentially. Although both approaches are equivalent, the Tarski algebra is more uniform since it is not overloaded with operations to deal with the complexity of differently typed structured objects, unlike most other algebras for function-based object databases <ref> [2, 53] </ref>. More importantly, we feel that addressing query optimization is impeded in a complex and strongly typed language [11, 53]. Our approach, enables specification of simple and general query optimization rules in a simple algebraic framework. <p> More importantly, we feel that addressing query optimization is impeded in a complex and strongly typed language <ref> [11, 53] </ref>. Our approach, enables specification of simple and general query optimization rules in a simple algebraic framework. There are also some derived Tarski operators that will prove useful in subsequent sections.
Reference: [54] <author> W. Wong and K. Youseffi. </author> <title> Decomposition A Strategy for Query Processing. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> Vol. 1, No. 3, </volume> <pages> pp. 223-241. </pages>
Reference: [55] <author> C. Zaniolo. </author> <title> The Database Language GEM. </title> <booktitle> Readings in Database Systems. </booktitle> <publisher> Morgan Kaufmann Publ., </publisher> <year> 1988. </year>
Reference: [56] <editor> S.B. Zdonik and D. Maier, editors. </editor> <booktitle> Readings in Object-Oriented Database Systems. </booktitle> <publisher> Morgan Kaufmann Publ., </publisher> <year> 1989. </year>
References-found: 56

