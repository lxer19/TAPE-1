URL: http://www.cs.cornell.edu/cs614-sp98/berkeley-262/lvm.ps
Refering-URL: http://www.cs.cornell.edu/cs614-sp98/berkeley-262/default.html
Root-URL: 
Email: fcheriton,kjdg@cs.stanford.edu  
Title: Logged Virtual Memory  
Author: David R. Cheriton and Kenneth J. Duda 
Address: Stanford, CA 94305  
Affiliation: Computer Science Department Stanford University  
Abstract: Logged virtual memory (LVM) provides a log of writes to one or more specified regions of the virtual address space. Logging is useful for applications that require rollback and/or persistence such as parallel simulations and memory-mapped object-oriented databases. It can also be used for output, debugging and distributed consistency maintenance. This paper describes logged virtual memory as an extension of the standard virtual memory system software and hardware, our prototype implementation, and some performance measurements from this prototype. Based on these measurements and the experience with our prototype, we argue that logged virtual memory can be supported with modest extensions to standard virtual memory systems, provides significant benefit to applications and servers, and is faster than other log-generation techniques. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. Buzzell and M. Robb. </author> <title> Modular vme rollback hardware for time warp. </title> <booktitle> In Proceedings of the Parallel and Distribute Simulation Workshop, </booktitle> <pages> pages 153-156. </pages> <publisher> Simulation Society, </publisher> <month> May </month> <year> 1989. </year>
Reference-contexts: Resetting the state to an earlier timestep simply requires resetting the memory to make that corresponding level the current timestep (and removing memory levels corresponding to the later timesteps). A chip implementation was proposed and a VME memory board was apparently actually constructed <ref> [1] </ref>. This approach optimizes for rollback at the cost of increasing the normal 5 It could however be extended to provide logging at a page granularity. read access time.
Reference: [2] <author> J. Carter, J. Bennet, and W. Zwaenepoel. </author> <title> Implementation and performance of Munin. </title> <booktitle> In Proceedingsof the Thirteenth Symp. on Operating Systems Principles, </booktitle> <month> December </month> <year> 1991. </year>
Reference-contexts: In indexed mode, the log generates a sequenceof data values into the log segment without addresses or other information. This mode can be used to generate streamed output to a device. Logging can also be used for consistency. For example, producer-consumer objects in Munin <ref> [2] </ref> could use LVM to identify updates in the producer, which are then transmitted to the consumers to update their copies. LVM reduces the overhead of determining the updates to transmit and allows just the updated data to be transmitted, rather than whole pages.
Reference: [3] <author> D.R. Cheriton and K.J. Duda. </author> <title> A caching model of operating system kernel functionality. </title> <booktitle> Proceedings of the First Symposium on Operating System Design and Implementation, </booktitle> <month> November </month> <year> 1994. </year>
Reference-contexts: This paper describes the design of a logged virtual memory system and a prototype implementation we have built. The prototype consists of extensions to the virtual memory system software of the V++ Cache Kernel <ref> [3] </ref>, an experimental operating system kernel, hardware support for logging in the ParaDiGM experimental multiprocessor [4] and a user-level library.
Reference: [4] <author> D.R. Cheriton, H. Goosen, and P. Boyle. </author> <title> ParaDiGM: A highly scalable shared-memory multi-computer architecture. </title> <journal> IEEE Computer, </journal> <volume> 24(2), </volume> <month> February </month> <year> 1991. </year>
Reference-contexts: This paper describes the design of a logged virtual memory system and a prototype implementation we have built. The prototype consists of extensions to the virtual memory system software of the V++ Cache Kernel [3], an experimental operating system kernel, hardware support for logging in the ParaDiGM experimental multiprocessor <ref> [4] </ref> and a user-level library. Our experience and measurements suggest that a logged virtual memory system can be implemented efficiently with a modest extension to virtual memory hardware and software, making it an attractive addition to the basic facilities of standard computer systems.
Reference: [5] <author> D.R. Cheriton, A. Gupta, P.D. Boyle, and H.A. Goosen. </author> <title> The VMP multiprocessor: Initial experience, refinements and performance evaluation. </title> <booktitle> In Proc. 15th Int. Symp. on Computer Architecture, </booktitle> <pages> pages 410-421. </pages> <publisher> ACM SIGARCH, IEEE Computer Society, </publisher> <month> June </month> <year> 1988. </year>
Reference-contexts: amount exceeds system resources or user limits because the logger can generate arbitrary amounts of data. 3.3 Deferred Copy Implementation The prototype implements the deferred-copy mechanism using extensions in the second-level cache to associate a source address and a destination address with each cache line, as developed earlier in VMP <ref> [5] </ref>. A deferred-copy mapping at the software level associates a source page address with each page of the destination segment corresponding to the appropriate page frame in the source segment.
Reference: [6] <author> M. Feeley, J. Chase, V. Narasayya, and H. Levy. </author> <title> Integrating coherency and recoverability in distributed systems. </title> <booktitle> In First Symp. on Operating Systems Design and Implementation, </booktitle> <pages> pages 215-227. </pages> <publisher> Usenix, </publisher> <year> 1994. </year>
Reference-contexts: Thus, the bus overhead for logging provides interprocessor consistency with no additional overhead; the consistency snoop simply monitors the logging bus traffic. 3 Log-based consistency is similar to the log-based coherency described by Feeley et al. <ref> [6] </ref>. 2.7 Advantages and Issues The LVM approach to logging has a number of significant advantages. First, LVM avoids the error-prone and tedious approach of manually specifying in the source code the write operations to be logged.
Reference: [7] <author> S. Feldman and C. Brown. IGOR: </author> <title> A system for program debugging via reversible execution. </title> <journal> In ACM SIGPLAN Notices, </journal> <pages> pages 79-88. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1989. </year>
Reference-contexts: The debugger can then determine when data was erroneously overwritten as well as generally monitor the state updates in a program under development. The log can also be used to support reverse execution <ref> [7] </ref>, a debugging technique in which a program is allowed to run until it fails, and then backed up or reverse-executed until the problem is located 1 .
Reference: [8] <author> R. S. Finlayson and D. R. Cheriton. </author> <title> Log files: An extended file service exploiting write-once storage. </title> <booktitle> In Proceedings of the 11th ACM Symposium on Operating System Principle s, </booktitle> <pages> pages 139-148, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: The Finlayson/Cheriton log server <ref> [8] </ref> provides a logging facility for storing log data on disk, particularly WORMs, and is not concerned with the data collection aspect of logging, the primary concern here. The virtual-memory-based checkpoint facility of Li and Ap-pelt [13] provides checkpointing rather than true logging.
Reference: [9] <author> R. Fujimoto, J. Tsai, and G. Gopalakrishnan. </author> <title> Design and performance of special-purpose hardware for time warp. </title> <booktitle> In Proceedings of the 15th Int. Symposium on Computer Architecture. ACM, </booktitle> <month> June </month> <year> 1988. </year>
Reference-contexts: As another mechanism, the history registers on some processors retain the immediately previous values of some registers but are extremely limited relative to our logger hardware. Fujimoto <ref> [9] </ref> proposed a virtual time machine architecture for optimistic parallel discrete event simulation in which a multi-level memory stores the states of the simulation corresponding to the most recent timesteps.
Reference: [10] <author> R. Hagmann. </author> <title> Reimplementing the Cedar file system using logging and group commit. </title> <booktitle> Proceedings of the 11th ACM Symposium on Operating System Principles, </booktitle> <pages> pages 155-162, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: system work that uses and/or provides logging facilities, ii) hardware support for logging and state saving, and iii) application software-level techniques. 5.1 Logging in Operating Systems Most related operating system work focuses on using logs in file systems, such as the Sprite log-structured file system [15], Hagmann's log-based file system <ref> [10] </ref> and the standard syslog facility in Unix. The Finlayson/Cheriton log server [8] provides a logging facility for storing log data on disk, particularly WORMs, and is not concerned with the data collection aspect of logging, the primary concern here.
Reference: [11] <author> D.R. Jefferson. </author> <title> Virtual time. </title> <journal> Transactions on Programming Languages and Systems, </journal> <volume> 7(3) </volume> <pages> 404-425, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: Each record contains the address, data value written to the address, and the data size. A variety of important applications can use logged virtual memory if it is provided efficiently by the operating system. For example, parallel discrete-event simulators that use optimistic con-currency control (TimeWarp, described in <ref> [11] </ref> and [12]) can use logged virtual memory to log modifications to the states of objects to support rollback. This state saving is a major overhead in optimistic simulation without LVM because it is memory-intensive, and because the cost is incurred even by the slowest (bottleneck) process in the simulation.
Reference: [12] <author> D.R. Jefferson. </author> <title> Virtual time II: The cancelback protocol for storage management in TimeWarp. </title> <booktitle> Proceedings of the Ninth Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: Each record contains the address, data value written to the address, and the data size. A variety of important applications can use logged virtual memory if it is provided efficiently by the operating system. For example, parallel discrete-event simulators that use optimistic con-currency control (TimeWarp, described in [11] and <ref> [12] </ref>) can use logged virtual memory to log modifications to the states of objects to support rollback. This state saving is a major overhead in optimistic simulation without LVM because it is memory-intensive, and because the cost is incurred even by the slowest (bottleneck) process in the simulation. <p> This cost may force less frequent state saving using the conventional approach, which means that a simulation may roll back to an earlier time than GVT because the state at GVT has not been saved. It also avoids the roll-forward event processing and message logging overhead incurred in TimeWarp <ref> [12] </ref> to accomplish the same precise rollback behavior.
Reference: [13] <author> K.Lai, J. Naughton, and A. Appel. </author> <title> Concurrent, real-time checkpoint for parallel programs. </title> <booktitle> In Proceedings of the 2nd ACM SIGPLAN Symp. on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 79-88. </pages> <publisher> ACM, </publisher> <month> March </month> <year> 1990. </year>
Reference-contexts: The Finlayson/Cheriton log server [8] provides a logging facility for storing log data on disk, particularly WORMs, and is not concerned with the data collection aspect of logging, the primary concern here. The virtual-memory-based checkpoint facility of Li and Ap-pelt <ref> [13] </ref> provides checkpointing rather than true logging. In that work, the operating system uses page write-protect to force a trap on the first write to a page after a checkpoint to save a copy of the page as part of this earlier checkpoint.
Reference: [14] <author> B. Randell. </author> <title> System structuring for software fault-tolerance. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-1(2):220-232, </volume> <month> June </month> <year> 1975. </year>
Reference-contexts: Our approach is slower for rollback, but rollback only occurs for processes that are not the performance bottleneck, and so have little effect on the application performance. A recursive cache similar to Fujimoto's approach was implemented in the emulator layer of Newcastle's recovery block system <ref> [14] </ref>. Here, the rollback mechanism was used to retry a different algorithm within the recovery block on failure.
Reference: [15] <author> M. Rosenblum and J. Ousterhout. </author> <title> The design and implement-ation of a log-structured file system. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(1) </volume> <pages> 26-52, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: be divided into: i) operating system work that uses and/or provides logging facilities, ii) hardware support for logging and state saving, and iii) application software-level techniques. 5.1 Logging in Operating Systems Most related operating system work focuses on using logs in file systems, such as the Sprite log-structured file system <ref> [15] </ref>, Hagmann's log-based file system [10] and the standard syslog facility in Unix. The Finlayson/Cheriton log server [8] provides a logging facility for storing log data on disk, particularly WORMs, and is not concerned with the data collection aspect of logging, the primary concern here.
Reference: [16] <author> M. Satyanarayanan et al. </author> <title> Lightweight recoverable virtual memory. </title> <booktitle> In Proceedings of the Fourteenth Symposium on Operating System Principles. ACM, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: log generated by LVM can also be used for debugging the simulation or for better understanding its results, such as by performing postprocessing, visualizing, etc. 2.5 Example Application: RLVM LVM can be used to implement recoverable logged virtual memory (RLVM), the recoverable virtual memory (RVM) system of Cam-elot and Coda <ref> [16] </ref>. Coda RVM requires that the application programmer insert a call to set range () before modifying recoverable memory to inform the library of the pending modification. On transaction commit (or abort), the library saves or restores only the address ranges specified with set range (). <p> On transaction commit (or abort), the library saves or restores only the address ranges specified with set range (). The authors of the Coda RVM report <ref> [16] </ref> acknowledge the problem of correctly specifying all the address ranges to be modified and suggest using language-level support to automatically add calls to set range () for any write that could possibly be logged. However, this approach has not to our knowledge been tried. <p> The same issues with performance apply here as with Fujimoto's design. 5.3 Application-level Techniques The most competitive alternative to LVM as part of the virtual memory system is to insert logging instructions directly into the application code. RVM <ref> [16] </ref> is an example of a system in which the user has to insert calls explicitly, e.g., set range () in RVM.
Reference: [17] <author> R. Wahbe. </author> <title> Efficient data breakpoints. </title> <booktitle> In ASPLOS. ACM, </booktitle> <month> Oc-tober </month> <year> 1992. </year>
Reference-contexts: This approach strikes us as difficult to program correctly, and runs the risk of costing more in execution time than it saves. Another application-level approach would be to extend the sand-boxing techniques described by Wahbe et al. <ref> [17, 18] </ref> to log write operations. Sandboxing would eliminate the burden on the application programmer of specifying individual modifications to be logged.
Reference: [18] <author> R. Wahbe, S. Lucco, T. Anderson, and S. Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In Proceedings of the Fourteenth Symposium on Operating System Principles. ACM, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: This approach strikes us as difficult to program correctly, and runs the risk of costing more in execution time than it saves. Another application-level approach would be to extend the sand-boxing techniques described by Wahbe et al. <ref> [17, 18] </ref> to log write operations. Sandboxing would eliminate the burden on the application programmer of specifying individual modifications to be logged.
References-found: 18

