URL: http://www.cs.purdue.edu/research/PaCS/ps/ssavewsc97.ps
Refering-URL: http://www.cs.purdue.edu/research/PaCS/parasol.html
Root-URL: http://www.cs.purdue.edu
Title: CHECKPOINT AND RECOVERY METHODS IN THE ParaSol SIMULATION SYSTEM  
Author: Edward Mascarenhas Felipe Knop Reuben Pasquini Vernon Rego 
Address: 2011 N. Shoreline Blvd. MS 510 Mountain View, CA 94043  522 South Road, MS P963 Poughkeepsie, NY 12601  West Lafayette, IN 47907  
Affiliation: Silicon Graphics Computer Systems  IBM Corporation  Department of Computer Sciences Purdue University  
Abstract: State-saving operations are a major source of overheads in optimistic and adaptive parallel discrete-event simulations. We present some techniques for saving state in the the context of the ParaSol mul-tithreaded parallel simulation system. In this system, threads are used to implement both logical processes and active transactions which access passive simulation objects. Hence, system state is a combination of thread-state and object-state. We introduce a new save-if-modified method for incremental checkpoint-ing of threads and objects. Because of the ParaSol system's domain-oriented support, checkpoint-ing is transparent to the user. Application-level objects that are foreign to a domain may be saved via invocations to primitives in the system's ParaState module. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Fujimoto, R. </author> <year> 1990. </year> <title> Parallel discrete event simulation. </title> <journal> Communications of the ACM, </journal> <volume> 33(10) </volume> <pages> 30-53. </pages>
Reference-contexts: At this instant, both object-state and thread-state may undergo change. The thread continues to execute until it either suspends itself again, or leaves the system. Thus, as control is passed between transactions which suspend themselves for some simulation time, the simulator's clock advances. ParaSol uses well-known optimistic synchronization <ref> (Fujimoto 1990) </ref> and novel adaptive synchronization methods (Mascarenhas 1996). A key advantage of optimistic synchronization is that it enables reduced programming effort.
Reference: <author> Fujimoto, R., J. Tsai, and G. Gopalakrishnan. </author> <year> 1988. </year> <title> The roll back chip: Hardware support for distributed simulation using Time Warp. </title> <booktitle> In Proceedings of the SCS Distributed Simulation Conference, </booktitle> <pages> 81-86. </pages>
Reference-contexts: Various methods for efficient checkpointing of objects have been proposed. These include copy state-saving complete state is saved, incremental state-saving only modified state is saved (Steinman 1993), hardware-based state-saving <ref> (Fujimoto, Tsai, and Gopalakr-ishnan 1988) </ref>, and language extensions for state-saving (Gomes, Unger, and Cleary 1996). Efficient schemes for incremental state-saving, such as those employed by Steinmain (1993), require user-intervention for check-pointing and state-saving. <p> Domain-level global objects come equipped with with state-saving/restore functions. Thus, users developing code at the application level are spared the expense of state management. State management overheads are known to have a serious negative impact on the performance of optimistic protocols <ref> (Fujimoto, Tsai, and Gopalakrishnan 1988) </ref>. We describe a novel save-if-modified method for state-saving in ParaSol. The pseudo-code for this procedure is shown in Figure 2.
Reference: <author> Gomes, F., B. Unger, and J. Cleary. </author> <year> 1996. </year> <title> Language based state saving extensions for optimistic parallel simulation. </title> <booktitle> In Proceedings of the Winter Simulation Conference, </booktitle> <pages> 794-800. </pages>
Reference-contexts: Various methods for efficient checkpointing of objects have been proposed. These include copy state-saving complete state is saved, incremental state-saving only modified state is saved (Steinman 1993), hardware-based state-saving (Fujimoto, Tsai, and Gopalakr-ishnan 1988), and language extensions for state-saving <ref> (Gomes, Unger, and Cleary 1996) </ref>. Efficient schemes for incremental state-saving, such as those employed by Steinmain (1993), require user-intervention for check-pointing and state-saving. Users need to get involved because the state to be checkpointed depends on the type of event executed.
Reference: <author> Mascarenhas, E., F. Knop, and V. Rego. </author> <year> 1995. </year> <title> ParaSol: A multithreaded system for parallel simulation based on mobile threads. </title> <booktitle> In Proceedings of the Winter Simulation Conference, </booktitle> <pages> 690-697. </pages>
Reference-contexts: In contrast to existing event-based systems in which LPs communicate and synchronize with timestamped messages, ParaSol enables communication and synchronization between LPs via transparent thread migration. Indeed, this transparency leads to greatly simplified model development at the application level and was an important design consideration <ref> (Mascarenhas, Knop, and Rego 1995) </ref>. ParaSol presents the user with an environment that offers transactions (i.e., dynamic, computational units with some private data) and a set of domain-dependent global objects. All transactions and objects are distributed among the physical processors hosting a simulation.
Reference: <author> Mascarenhas, E., and V. Rego. </author> <year> 1996. </year> <title> Ariadne: Architecture of a portable threads system supporting thread migration. </title> <journal> Software-Practice and Experience, </journal> <volume> 26(3) </volume> <pages> 327-356. </pages>
Reference-contexts: The thread continues to execute until it either suspends itself again, or leaves the system. Thus, as control is passed between transactions which suspend themselves for some simulation time, the simulator's clock advances. ParaSol uses well-known optimistic synchronization (Fujimoto 1990) and novel adaptive synchronization methods <ref> (Mascarenhas 1996) </ref>. A key advantage of optimistic synchronization is that it enables reduced programming effort. That is, application level programs can be developed without explicit synchronization directives; this is a highly attractive feature, considering that a major source of distributed program complexity lies in efforts to synchronize processors. <p> The kernel provides basic support services, and the domain libraries support application-level functionality. The kernel insulates the upper layers from all parallel simulation details, including transaction management, migration, communication, rollback, etc. The kernel is supported from below by the Ariadne threads system <ref> (Mascarenhas and Rego 1996) </ref> and a suitable communications substrate, e.g., PVM (Sun-deram 1990). Thread migration is supported by the Ariadne threads system. The kernel programming interface is represented by the public methods of class PSol, the main simulation class in ParaSol's C++ interface.
Reference: <author> Mascarenhas, E. </author> <year> 1996. </year> <title> A System for Multithreaded Parallel Simulation and Computation with Migrant Threads and Objects. </title> <type> PhD thesis, </type> <institution> Department of Computer Sciences, Purdue University. </institution>
Reference-contexts: The thread continues to execute until it either suspends itself again, or leaves the system. Thus, as control is passed between transactions which suspend themselves for some simulation time, the simulator's clock advances. ParaSol uses well-known optimistic synchronization (Fujimoto 1990) and novel adaptive synchronization methods <ref> (Mascarenhas 1996) </ref>. A key advantage of optimistic synchronization is that it enables reduced programming effort. That is, application level programs can be developed without explicit synchronization directives; this is a highly attractive feature, considering that a major source of distributed program complexity lies in efforts to synchronize processors. <p> The kernel provides basic support services, and the domain libraries support application-level functionality. The kernel insulates the upper layers from all parallel simulation details, including transaction management, migration, communication, rollback, etc. The kernel is supported from below by the Ariadne threads system <ref> (Mascarenhas and Rego 1996) </ref> and a suitable communications substrate, e.g., PVM (Sun-deram 1990). Thread migration is supported by the Ariadne threads system. The kernel programming interface is represented by the public methods of class PSol, the main simulation class in ParaSol's C++ interface.
Reference: <author> Ronngren R., and R. Ayani. </author> <year> 1994. </year> <title> Adaptive check-pointing in time warp. </title> <booktitle> In Proceedings of the 8th Workshop on Parallel and Distributed Simulation, </booktitle> <pages> 94-100. </pages>
Reference: <author> Steinman, J. </author> <year> 1993. </year> <title> Incremental state saving in SPEEDES using C++. </title> <booktitle> In Proceedings of the Winter Simulation Conference, </booktitle> <pages> 687-696. </pages>
Reference-contexts: Various methods for efficient checkpointing of objects have been proposed. These include copy state-saving complete state is saved, incremental state-saving only modified state is saved <ref> (Steinman 1993) </ref>, hardware-based state-saving (Fujimoto, Tsai, and Gopalakr-ishnan 1988), and language extensions for state-saving (Gomes, Unger, and Cleary 1996). Efficient schemes for incremental state-saving, such as those employed by Steinmain (1993), require user-intervention for check-pointing and state-saving.

References-found: 8

