URL: ftp://ftp.eecs.umich.edu/people/mathur/franconia.ps.Z
Refering-URL: http://www.eecs.umich.edu/~mathur/
Root-URL: http://www.cs.umich.edu
Email: mathur, keefe-@cmpe.psu.edu  
Title: The Concurrency Control and Recovery Problem for Multilevel Update Transactions in MLS Systems  
Author: Amit G. Mathur and Thomas F. Keefe 
Address: Park, PA 16802.  
Affiliation: Department of Electrical and Computer Engineering The Pennsylvania State University University  
Abstract: This paper addresses the problem of a transaction reading and writing data at multiple classification levels in a Multilevel Secure (MLS) database. We refer to such transactions as multilevel update transactions. We show that no scheduler can ensure atomicity of multilevel update transactions in the presence of transaction aborts and at the same time be secure. There are essentially two ways of scheduling multilevel update transactions. The first method, which ensures strong atomicity, involves delaying low-level subtransactions until the fates of the sibling high-level subtransactions are known. The second scheme, which ensures only semantic atomicity, involves compensating the effects of any committed subtransactions. Analysis of these schemes indicates that the compensation approach leads to lower covert channel bandwidths. A concurrency control and recovery protocol based on compensation is proposed for multilevel update transactions. The security and correctness of the protocol is considered. 
Abstract-found: 1
Intro-found: 1
Reference: [ACL 87] <author> R. Agrawal, M.J. Carey, and M. Livny, </author> <title> Concurrency Control Performance M o d e l i n g : A l t e r n a t i v e s a n d Implications,ACM Transactions on Database Systems, </title> <address> 12(4) (Dec. </address> <year> 1987), </year> <pages> pp. 609-654. </pages>
Reference-contexts: complex and includes information about cpus, disks, size and granularity of the database, load control mechanism for controlling the number of active transactions, concurrency control and recovery costs, nature of user transactions (batch or interactive), and reference behavior and processing requirements of the transactions (see for example [CM 86] and <ref> [ACL 87] </ref>). The model here abstracts most of these details by assuming a uniform processing time t op for all operations, but nevertheless allows us to gain valuable insights into the nature and bandwidth of the covert channels.
Reference: [BL 76] <author> D.E. Bell and L.J. LaPadula, </author> <title> Secure Computer Systems: Unified Exposition and Multics Interpretations, </title> <type> Technical Report MTR-2997, </type> <institution> Mitre Corp., </institution> <month> March </month> <year> 1976. </year>
Reference-contexts: In a MLS database each data item and each transaction is assigned a classification from this lattice. These classifications are assumed to be static. It is also assumed that there are access control mechanisms in the system that enforce the simple security and *- properties <ref> [BL 76] </ref>. The security problem is then reduced to one of eliminating covert channels. Covert channels can arise for a variety of reasons; here we concern ourselves with those caused by transaction processing. The scheduler in a database implements the concurrency control and recovery protocols.
Reference: [BHG 87] <author> P.A. Bernstein, V. Hadzilacos, and N. Goodman, </author> <title> Concurrency Control and Recovery in Database Systems, </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1987. </year>
Reference-contexts: Through these multiple subtransactions, the multilevel update transaction is able to perform its task of reading and writing at multiple classification levels, while at the same time satisfying the simple and *-properties. Each subtransaction is a flat transaction in the sense of <ref> [BHG 87] </ref>. We restate the definition of a flat transaction and then formally define multilevel update transactions. Definition 2.1 (Flat transaction) A flat transaction T i is a partial order (&lt; i ) on read, write, commit, and abort operations (denoted r (x), w (x), c, and a respectively). <p> In general, the reverse is not true, i.e. strong atomicity does not imply serializability and semantic atomicity does not imply semantic correctness. We next formally define these correctness criteria. The definitions are based on the framework developed in <ref> [BHG 87] </ref> for the concurrency control and recovery of flat-transactions. Definition 2.2.1 (History of multilevel update transactions) Let T = -T 1, T 2, ..., T n - be a set of multilevel update transactions. <p> Otherwise, edge T ij fi T pq is included. Theorem <ref> [BHG 87] </ref> A multiversion history H is 1-copy serializable iff there exists a version order &lt;&lt; such that MVSG (H , &lt;&lt;) is acyclic. <p> The MLS property requires that a subject with classification level l not be able to distinguish between the behavior of the system in response to p and p l . A database system consists of a number of transaction managers, a scheduler, and a data manager <ref> [BHG 87] </ref>. Since we are only interested in the security properties of various scheduling schemes and not in actual implementation details, for the purposes of the security analysis we only consider the scheduler component of the database. The scheduler is treated as a black box with inputs and outputs. <p> If we treat the subtransactions of a multilevel update transaction as separate flat transactions, then it is easy to see that the protocol is very similar to the MVTO protocol <ref> [BHG 87] </ref>. The difference only lies in the way timestamps are assigned to transactions. <p> We know that the MVSG resulting from the regular MVTO protocol for flat transactions is acyclic and that for all edges T ij fi T mn in the MVSG, ts (T ij ) &lt; ts (T mn ) (a proof of this appears in <ref> [BHG 87] </ref>). Due to the similarity of the above protocol to MVTO, the MVSG is acyclic in this case too. So all that remains to be shown is that the equivalent serialization order obtained from this MVSG is one in which the sibling subtransactions are adjacent to each other.
Reference: [BOHGM 92] <author> A. Buchmann, M.T. Ozsu, M. Hornick, D. Georgakapoulous, and F.A. </author> <month> Manola, </month>
Reference-contexts: Each subtransaction is a flat transaction with an independent commit or abort step. (c) Each component subtransaction satisfies the simple and *-properties. (d) Each component subtransaction is declared as being vital or non-vital (this term is borrowed from <ref> [BOHGM 92] </ref>). A subtransaction is said to be vital if its abort requires the parent transaction to abort. Otherwise it is non-vital. A typical transaction is represented as shown in Fig. 2.1. To appreciate the above definition, let us consider the bank example given above in a little more detail.
References-found: 4

