URL: http://rakaposhi.eas.asu.edu/jour-prune.ps
Refering-URL: http://rakaposhi.eas.asu.edu/yochan.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: Email: rao@asu.edu  
Title: Admissible Pruning Strategies based on plan minimality for Plan-Space Planning  
Author: Subbarao Kambhampati 
Date: January 19, 1996  
Web: WWW: http://rakaposhi.eas.asu.edu/pub/rao/rao.html  
Address: Tempe, AZ 85287-5406  
Affiliation: Department of Computer Science and Engineering Arizona State University,  
Abstract: Although plan-space planners have been shown to be flexible and efficient in plan generation, they do suffer from the problem of ``looping'' -- that is, they may spend an inordinate amount of time doing locally seemingly useful but globally useless refinements. In this paper, I review the anatomy of looping and argue that looping is intimately tied to the production of non-minimal solutions. I then propose two classes of admissible pruning techniques based on the notion of plan minimality. I show that the first one is admissible for planners which do not protect their establishments, but allow a precondition to be reestablished any number of times. The second one is admissible for planners which protect their establishments through causal links. I also discuss the complexity of the proposed pruning strategies, and their potential applications. fl This paper is a revised and extended version of a paper that was presented at IJCAI-95 []. This research is supported in part by NSF research initiation award (RIA) IRI-9210997, NSF young investigator award (NYI) IRI-9457634 and ARPA/Rome Laboratory planning initiative grant F30602-93-C-0039. I thank Eric Cohen, Yong Qu, Suresh Katukam and Laurie Ihrig for helpful comments. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Barrett and D. Weld. </author> <title> Partial Order Planning: Evaluating Possible Efficiency Gains Artificial Intelligence, </title> <journal> Vol. </journal> <volume> 67, No. 1, </volume> <year> 1994. </year>
Reference-contexts: 1 Introduction Domain independent classical planning techniques come in two main varieties -- those that search in the space of world states and those that search in the space of plans. The conventional wisdom of the planning community, supported to a large extent by the recent analytical and empirical studies <ref> [1, 15] </ref>, holds that searching in the space of plans provides a more flexible and efficient framework for planning. Despite its many perceived advantages, plan-space planning techniques still lag behind state-space planning techniques in terms of search control and pruning heuristics. <p> Instead, the increased branching factor, and the commitment of the state-space planners tend to dominate over the larger search space size of the plan-space planners. This explains why we typically 2 (a) car-door example (b) hf/he example find plan-space planners faring better than state space planners in many domains <ref> [1, 15] </ref>. Despite this, pruning strategies for plan-space planners are still very important for several reasons. Even with best-first search, looping can cause serious problems when faced with unsolvable problems. Further, many practical planners use depth-first rather than best-first search strategies for efficiency purposes. <p> The studies were done on a version of TWEAK 19 planning algorithm implemented on top of Barrett and Weld's SNLP code <ref> [1] </ref>.
Reference: [2] <author> J. Blythe and M. Veloso. </author> <title> An analysis of Search Techniques for a totally-ordered nonlinear planner. </title> <booktitle> In Proc. 1st Intl. Conf. on AI Planning Systems, </booktitle> <year> 1992. </year>
Reference-contexts: we suspended further work as Peot and Smith [18] recently reported an incremental pruning strategy, also based on plan minimality, that seems to improve performance more effectively (see Section 8 for further discussion on this). 7 Related Work As mentioned earlier, most state space planners, including STRIPS [7] and PRODIGY <ref> [2] </ref> use state loop and goal loop based pruning strategies. State-loop heuristics prune any path that visits the same world state more than once. Goal-loop heuristics are used in state-space planners that use means-ends analysis, or planners that do backward search in the space of states.
Reference: [3] <author> D. Chapman. </author> <title> Planning for conjunctive goals. </title> <booktitle> Artificial Intelligence, </booktitle> <address> 32:333 -377, </address> <year> 1987. </year>
Reference-contexts: The first one generalizes the notion of minimality to incomplete partial plans, and uses this notion to prune partial plans that are non-minimal. I will show that this technique is admissible for non-causal link planners, such as UA and TO <ref> [15, 3] </ref>, which continue to refine a partial plan as long as there are preconditions that are not necessarily true (even if it means working on a precondition more than once). <p> A plan P is said to be minimal if it is complete, and no subplan of P is complete. A precondition p of a step s in a partial plan is said to be necessarily true <ref> [3] </ref> (or satisfied) if in every ground linearization of the plan, there is some step s 0 that precedes s and gives p, and no step between s 0 and s deletes p. <p> Similarly, if at least one ground linearization satisfies these conditions, then p is said to be possibly true. If all preconditions of all the steps are necessarily true, then the plan is complete. For actions whose preconditions and effects are function-less first order literals (called the TWEAK representation) Chapman <ref> [3] </ref> provides the necessary and sufficient conditions for checking the necessary truth of a precondition in polynomial time. Plan space planning involves repeatedly selecting and ``establishing'' a 6 precondition of a step in the plan, such that it becomes necessarily true. When all preconditions are necessarily true, planning is complete. <p> In [9], we point out that such protection strategies lead to reduction of redundancy in the search space. Examples of this class of planners include SNLP [13] and UCPOP [16]. A second class of planners, such as TWEAK <ref> [3] </ref>, UA and TO [15], which may be called non-causal link planners, do not protect their establishments, but allow re-establishment of a precondition that was previously established, and was subsequently undone. <p> The foregoing discussion raises the possibility that Nsat-prune may be admissible for non-causal link planners that do not protect establishments, and work on preconditions as many times as required until the plan becomes complete. Let us consider the case of a non-causal link planner, such as TWEAK <ref> [3] </ref>, UA or TO [15] solving the above blocks world problem. To begin with, standard implementations of TWEAK [3] and UA [15] work only on preconditions that are not necessarily true, and thus will not even consider holding (A) for establishment at the beginning. <p> Let us consider the case of a non-causal link planner, such as TWEAK <ref> [3] </ref>, UA or TO [15] solving the above blocks world problem. To begin with, standard implementations of TWEAK [3] and UA [15] work only on preconditions that are not necessarily true, and thus will not even consider holding (A) for establishment at the beginning. However, we argue in [9] that this goal selection strategy is a design choice orthogonal to their non-causal link nature. <p> The latter plan will still be non-minimal incomplete plan and will be pruned. Unlike the 2 To see this, note that only the precondition holding (A)@s 1 is necessarily true <ref> [3] </ref>. The Nsatplan for this plan is thus going to have the same steps and orderings, but will have the single precondition holding (A)@s 1 . <p> Given this, and the fact that the null plan P ; is a minimal incomplete plan, the theorem follows by induction on the number of steps in the plan. Perhaps surprisingly, the theorem above does not hold for TWEAK <ref> [3] </ref>. Here is a counter example: Example showing that Nsat-prune is inadmissible for TWEAK: Consider a domain that has two operators O 1 and O 2 . O 1 has an effect p. O 2 has an effect q, but it deletes p. Neither operator has any precondition. <p> Constructing the Nsatplan involves checking the necessary truth of each precondition of the plan, and can be done in polynomial time for plans containing actions in TWEAK representation <ref> [3] </ref>. Checking whether a given complete plan is minimal is unfortunately NP-hard even for plans in TWEAK action representation (see [6] for a proof). However, it is possible to formulate weaker conditions that provide necessary but insufficient conditions for minimality. Two such constraints are unbloated plans and greedily justified plans.
Reference: [4] <author> E. Cohen. </author> <title> Understanding the Utility of Pruning by Minimality in partial order planning. </title> <type> MCS Project Report. </type> <institution> ASU CSE dept. </institution> <month> May </month> <year> 1993. </year>
Reference: [5] <author> M. Drummond and K. Currie. </author> <title> Exploiting Temporal Coherence in Nonlinear Plan Construction. </title> <booktitle> In Computational Intelligence, </booktitle> <volume> Vol. 4, </volume> <year> 1988. </year>
Reference-contexts: Although there exist a variety of techniques for pruning search branches in state space planning (including the state-loop, goal-loop and inconsistent-state heuristics; see Section 7), these loop control techniques turn out to be either inapplicable, or inadmissible for plan-space planners [8] (following <ref> [5] </ref>, we consider a pruning technique admissible if it does not affect the planner's ability to find all minimal solutions for any given problem). <p> Even this analysis allows loop control in only a very restricted class of situations. Both the Nsat-prune and the Cutset-prune strategies will stop looping on all the examples described in their paper, without requiring any special analysis of filter conditions. Drummond and Currie <ref> [5] </ref> describe a pruning strategy called temporal coherence heuristic, which is analogous to the inconsistent state heuristics used by backward state-space planners.
Reference: [6] <author> E. Fink and Q. Yang. </author> <title> A Spectrum of Plan Justifications. </title> <booktitle> In Proc. Canadian AI Conference, </booktitle> <year> 1992. </year>
Reference-contexts: Since every solvable problem must have a minimal solution, a complete planner need only generate all minimal solutions for any given planning problem. While we can recognize and discard non-minimal solution plans (c.f. <ref> [6] </ref>), discarding complete non-minimal plans after they are generated by the planner, is an ineffective pruning strategy. <p> Constructing the Nsatplan involves checking the necessary truth of each precondition of the plan, and can be done in polynomial time for plans containing actions in TWEAK representation [3]. Checking whether a given complete plan is minimal is unfortunately NP-hard even for plans in TWEAK action representation (see <ref> [6] </ref> for a proof). However, it is possible to formulate weaker conditions that provide necessary but insufficient conditions for minimality. Two such constraints are unbloated plans and greedily justified plans. <p> The particular minimality criterion used in many of these proofs corresponds to what we called ``unbloated plans'' in this paper (the term first appears in the completeness proof for PEDESTAL [14]). As I mentioned earlier, Fink and Yang <ref> [6] </ref> formulate a set of tractable necessary but insufficient conditions for checking non-minimality of partial plans. They however do not use their notions of minimality in improving planning performance.
Reference: [7] <author> R. Fikes, P. Hart, and N. Nilsson. </author> <title> Learning and executing generalized robot plans. </title> <journal> Artificial Intelligence, </journal> <volume> 3(4):251--288, </volume> <year> 1972. </year>
Reference-contexts: directions were encouraging, we suspended further work as Peot and Smith [18] recently reported an incremental pruning strategy, also based on plan minimality, that seems to improve performance more effectively (see Section 8 for further discussion on this). 7 Related Work As mentioned earlier, most state space planners, including STRIPS <ref> [7] </ref> and PRODIGY [2] use state loop and goal loop based pruning strategies. State-loop heuristics prune any path that visits the same world state more than once. Goal-loop heuristics are used in state-space planners that use means-ends analysis, or planners that do backward search in the space of states.
Reference: [8] <author> R. Feldman and P. Morris. </author> <title> Admissible criteria for loop control in planning. </title> <booktitle> In Proc. AAAI 1990. </booktitle>
Reference-contexts: Consequently, a plan-space planner trying to solve an unsolvable problem may never halt without looping checks, even when the the corresponding state-space planner will terminate. As an example, consider the problems shown Figure 1. In the car-door example <ref> [8] </ref>, the infinite regress occurs because the planner subgoals on having keys to open the door, and subgoals back on opening the door to get the keys (which are inside the car). <p> Although there exist a variety of techniques for pruning search branches in state space planning (including the state-loop, goal-loop and inconsistent-state heuristics; see Section 7), these loop control techniques turn out to be either inapplicable, or inadmissible for plan-space planners <ref> [8] </ref> (following [5], we consider a pruning technique admissible if it does not affect the planner's ability to find all minimal solutions for any given problem). <p> Similar looping also occurs when the planner attempts to generate a plan for opening the door of a car when the keys are inside the car and the door is closed <ref> [8] </ref>, or plans for clearing a block by putting another block on top of it and then removing it. <p> The state-loop techniques are inapplicable for plan-space planners which do not keep track of world-state during planning. The goal loop strategies turn out to be inadmissible in general (c.f. <ref> [8] </ref>). In [12], 24 we present a generalized planner called UCP that combines both state-space and plan-space approaches within a single framework. UCP does have the ability to use the state loop and goal loop pruning, as well as the minimality pruning strategies described in this paper. Morris et. al. [8] <p> <ref> [8] </ref>). In [12], 24 we present a generalized planner called UCP that combines both state-space and plan-space approaches within a single framework. UCP does have the ability to use the state loop and goal loop pruning, as well as the minimality pruning strategies described in this paper. Morris et. al. [8] discuss a way of using filter conditions to avoid certain types of looping in partial order planners. Their method depends on an a priori analysis of the domain operators to identify the preconditions which should not be expanded.
Reference: [9] <author> S. Kambhampati, C. Knoblock and Q. Yang. </author> <title> Planning as Refinement Search: A Unified framework for evaluating design tradeoffs in partial order planning. </title> <journal> Artificial Intelligence special issue on Planning and Scheduling. </journal> <volume> Vol. 76, No. </volume> <pages> 1-2, </pages> <year> 1995. </year>
Reference-contexts: Section 7 discusses related work and Section 8 summarizes the paper's contributions. The appendix contains complete proofs of all theorems. 2 Preliminaries and Terminology In this section, I review some preliminaries and terminology related to plan space planning algorithms. Readers unfamiliar with plan-space planning might want to consult <ref> [9, 15] </ref> for more comprehensive reviews. A planning problem is a 3-tuple hI; G; Ai, where I is the description of the initial state, G is the (partial) description of the goal state, and A is the set of actions (also called ``operators''). <p> example, although plans that lead to state cycles (e.g. the sequence of actions Open the door, Close the door one after other) are non-minimal for any problem containing goals of achievement, they may be minimal if the goal of the planner itself is to exhibit that specific behavior (state sequence) <ref> [9] </ref>. Thus a general domain independent planner is forced to have such plans in its search space. 5 the planning problem, and the resulting state of the world satisfies all the goals of the planning problem. <p> When all preconditions are necessarily true, planning is complete. Since the establishment refinements used by most planners ensure completeness by considering all possible ways of achieving a chosen precondition <ref> [9] </ref>, the order in which different preconditions are selected for establishment (referred to as ``goal selection order'' or ``goal order'') does not matter. <p> Because of this, a causal link planner will never undo an establishment that it has made, and thus never has to work on the same precondition more than once. In <ref> [9] </ref>, we point out that such protection strategies lead to reduction of redundancy in the search space. Examples of this class of planners include SNLP [13] and UCPOP [16]. <p> This check is useful when the underlying planners use causal links, but postpone resolution of the conflicts with the causal links <ref> [9, 17] </ref>. Checking the link inconsistency of an arbitrary partial plan is NP-complete [17]. Sometimes, the constraints on the plan themselves may not be inconsistent, but may be inconsistent together with some implicit domain knowledge. <p> In particular, most plan-space planners refine partial plans by concentrating on establishing the preconditions of individual steps <ref> [9] </ref>. The order in which preconditions are considered for establishment is called the goal order. We can show that any planner that considers all possible goal orderings will eventually generate the sequence of minimal refinements leading to the solution, and is thus complete. <p> We can show that any planner that considers all possible goal orderings will eventually generate the sequence of minimal refinements leading to the solution, and is thus complete. However, since the refinements used in plan-space planning are complete for any goal ordering <ref> [9] </ref>, most plan-space planners do not backtrack on goal ordering. I will look at the admissibility of Nsat-prune for two broad classes of plan-space planners discussed in Section 2 -- causal link planners which protect their establishments, and non-causal link planners which reestablish each precondition as many times as necessary. <p> To begin with, standard implementations of TWEAK [3] and UA [15] work only on preconditions that are not necessarily true, and thus will not even consider holding (A) for establishment at the beginning. However, we argue in <ref> [9] </ref> that this goal selection strategy is a design choice orthogonal to their non-causal link nature. So, let us consider what happens if they do select holding (A).
Reference: [10] <author> S. Kambhampati, S. Katukam and Y. Qu. </author> <title> Failure Driven Dynamic Search Control for Partial Order Planners: An Explanation Based Approach. </title> <journal> Artificial Intelligence, </journal> <note> To appear. (Available from http://rakaposhi.eas.asu.edu:8001/yochan.html). 30 </note>
Reference-contexts: Further, many practical planners use depth-first rather than best-first search strategies for efficiency purposes. Looping can significantly affect the efficiency of depth-first search regimes. The final, and often overlooked, need for pruning strategies has got to do with the importance of failures in learning <ref> [10] </ref>. Most speedup learning strategies to improve planning performance learn from the failures encountered in plan generation. Existence of a variety of pruning techniques provides a rich opportunity for the learner to learn from the pruned branches. <p> In the presence of learning strategies, the cost of pruning techniques also tends to be less of a concern. In particular, it is possible to use the pruning techniques strategically by combining them with a depth-limited search, and applying them only to the plans that cross the depth-limits (see <ref> [10] </ref> for a demonstration of the effectiveness of this approach). Despite their importance, very little work has been done towards formulation 3 and evaluation of pruning techniques for plan-space planning. Most existing plan-space planners prune a plan when the constraints on the partial plan are mutually inconsistent. <p> An an example consider the simplified blocks-world problem of achieving On (A; B) ^ On (B; C) starting from an initial state where A is on B, and C is on the table <ref> [10] </ref>. <p> Although applying this strategy at every refinement could be costly, in <ref> [10] </ref>, we show that combining this strategy with an explanation based learning framework can significantly improve planning performance. 4 Minimality based pruning for non-causal link plan ners As I discussed earlier, pruning techniques based on constraint inconsistency alone are not enough to stop looping in many situations. <p> Once again, I believe that the primary utility of this strategy will be in terms of its guidance to an underlying learning system (c.f. <ref> [10] </ref>). In particular, it can be applied to plans crossing depth limits to see if they are provably non-minimal. If so, the explanation of non-minimality can be used to guide an EBL based system to learn effective control rules to avoid the looping branches in the future [10]. 6 Empirical Evaluation <p> learning system (c.f. <ref> [10] </ref>). In particular, it can be applied to plans crossing depth limits to see if they are provably non-minimal. If so, the explanation of non-minimality can be used to guide an EBL based system to learn effective control rules to avoid the looping branches in the future [10]. 6 Empirical Evaluation To understand the utility of minimality based pruning strategies in planning, we conducted empirical studies. The studies were done on a version of TWEAK 19 planning algorithm implemented on top of Barrett and Weld's SNLP code [1]. <p> There are two possible ways of doing this. The first is to make the planner ``learn'' to avoid non-minimal plan generation. Specifically, we are looking into using failure-driven explanation-based learning techniques <ref> [10] </ref> for this purpose. The idea is to use the proof of non-minimality of the plan as the ``explanation of failure'' of the pruned plan, and use the regression and propagation process of EBL to learn search control rules.
Reference: [11] <author> S. Kambhampati. </author> <title> Admissible pruning Strategies based on Plan minimality for plan-space planning In Proc. </title> <booktitle> IJCAI-95, </booktitle> <year> 1995. </year>
Reference: [12] <author> S. Kambhampati and B. Srivastava. </author> <title> 5 Universal Classical Planner: An Algorithm for unifying state-space and plan-space planning. </title> <type> ASU CSE TR 94-002. </type>
Reference-contexts: The state-loop techniques are inapplicable for plan-space planners which do not keep track of world-state during planning. The goal loop strategies turn out to be inadmissible in general (c.f. [8]). In <ref> [12] </ref>, 24 we present a generalized planner called UCP that combines both state-space and plan-space approaches within a single framework. UCP does have the ability to use the state loop and goal loop pruning, as well as the minimality pruning strategies described in this paper.
Reference: [13] <author> D. McAllester and D. Rosenblitt. </author> <title> Systematic Nonlinear Planning. </title> <booktitle> In Proc. 9th AAAI, </booktitle> <year> 1991. </year>
Reference-contexts: Unfortunately, however, it is not applicable to planners which use causal links <ref> [13] </ref>, and do not work on any precondition more than once. To prune based on minimality for systematic causal link planners such as SNLP [13], I develop another strategy that uses the causal links to decide if any portion of the plan is ``taking'' more conditions than it is ``giving.'' The <p> Unfortunately, however, it is not applicable to planners which use causal links <ref> [13] </ref>, and do not work on any precondition more than once. To prune based on minimality for systematic causal link planners such as SNLP [13], I develop another strategy that uses the causal links to decide if any portion of the plan is ``taking'' more conditions than it is ``giving.'' The rest of this paper is organized as follows: The next section introduces some terminology for plan space planning. <p> There are two general approaches for handling this -- some planners, popularly called goal protection planners or causal link planners, post constraints (called causal links) to protect their past establishments <ref> [13] </ref>. In particular, if the planner uses the effects of step s 0 to make the condition p true at step s, it posts a causal link s 0 p ! s on the partial plan. <p> In [9], we point out that such protection strategies lead to reduction of redundancy in the search space. Examples of this class of planners include SNLP <ref> [13] </ref> and UCPOP [16]. A second class of planners, such as TWEAK [3], UA and TO [15], which may be called non-causal link planners, do not protect their establishments, but allow re-establishment of a precondition that was previously established, and was subsequently undone. <p> An an example consider the simplified blocks-world problem of achieving On (A; B) ^ On (B; C) starting from an initial state where A is on B, and C is on the table [10]. A a causal link planner such as SNLP <ref> [13] </ref> may generate the partial plan shown in Figure 2 in solving this problem: In this plan, the goal condition On (A; B) is being established from the effects of the initial state, and a new step P uton (B; C) is added to achieve the second goal On (B; C).
Reference: [14] <author> D. McDermott. </author> <title> Regression Planning. </title> <journal> Intl. Jour. Intelligent Systems, </journal> <volume> 6 </volume> <pages> 357-416, </pages> <year> 1991. </year>
Reference-contexts: However, it is possible to formulate weaker conditions that provide necessary but insufficient conditions for minimality. Two such constraints are unbloated plans and greedily justified plans. A complete plan is called unbloated or well-justified plans (c.f. <ref> [14] </ref>) if it is not possible to remove a single step from the plan while keeping the plan correct. We can check whether a plan is unbloated in time polynomial in the length of the plan. <p> The particular minimality criterion used in many of these proofs corresponds to what we called ``unbloated plans'' in this paper (the term first appears in the completeness proof for PEDESTAL <ref> [14] </ref>). As I mentioned earlier, Fink and Yang [6] formulate a set of tractable necessary but insufficient conditions for checking non-minimality of partial plans. They however do not use their notions of minimality in improving planning performance.
Reference: [15] <author> S. Minton, J. Bresina and M. Drummond. </author> <title> Total Order and Partial Order Planning: a comparative analysis. </title> <note> Journal of Artificial Intelligence Research 2 (1994) 227-262. </note>
Reference-contexts: 1 Introduction Domain independent classical planning techniques come in two main varieties -- those that search in the space of world states and those that search in the space of plans. The conventional wisdom of the planning community, supported to a large extent by the recent analytical and empirical studies <ref> [1, 15] </ref>, holds that searching in the space of plans provides a more flexible and efficient framework for planning. Despite its many perceived advantages, plan-space planning techniques still lag behind state-space planning techniques in terms of search control and pruning heuristics. <p> Instead, the increased branching factor, and the commitment of the state-space planners tend to dominate over the larger search space size of the plan-space planners. This explains why we typically 2 (a) car-door example (b) hf/he example find plan-space planners faring better than state space planners in many domains <ref> [1, 15] </ref>. Despite this, pruning strategies for plan-space planners are still very important for several reasons. Even with best-first search, looping can cause serious problems when faced with unsolvable problems. Further, many practical planners use depth-first rather than best-first search strategies for efficiency purposes. <p> The first one generalizes the notion of minimality to incomplete partial plans, and uses this notion to prune partial plans that are non-minimal. I will show that this technique is admissible for non-causal link planners, such as UA and TO <ref> [15, 3] </ref>, which continue to refine a partial plan as long as there are preconditions that are not necessarily true (even if it means working on a precondition more than once). <p> Section 7 discusses related work and Section 8 summarizes the paper's contributions. The appendix contains complete proofs of all theorems. 2 Preliminaries and Terminology In this section, I review some preliminaries and terminology related to plan space planning algorithms. Readers unfamiliar with plan-space planning might want to consult <ref> [9, 15] </ref> for more comprehensive reviews. A planning problem is a 3-tuple hI; G; Ai, where I is the description of the initial state, G is the (partial) description of the goal state, and A is the set of actions (also called ``operators''). <p> In [9], we point out that such protection strategies lead to reduction of redundancy in the search space. Examples of this class of planners include SNLP [13] and UCPOP [16]. A second class of planners, such as TWEAK [3], UA and TO <ref> [15] </ref>, which may be called non-causal link planners, do not protect their establishments, but allow re-establishment of a precondition that was previously established, and was subsequently undone. <p> Let us consider the case of a non-causal link planner, such as TWEAK [3], UA or TO <ref> [15] </ref> solving the above blocks world problem. To begin with, standard implementations of TWEAK [3] and UA [15] work only on preconditions that are not necessarily true, and thus will not even consider holding (A) for establishment at the beginning. <p> Let us consider the case of a non-causal link planner, such as TWEAK [3], UA or TO <ref> [15] </ref> solving the above blocks world problem. To begin with, standard implementations of TWEAK [3] and UA [15] work only on preconditions that are not necessarily true, and thus will not even consider holding (A) for establishment at the beginning. However, we argue in [9] that this goal selection strategy is a design choice orthogonal to their non-causal link nature. <p> Although Nsat-prune prunes the former refinement path, it leaves undisturbed a path through the latter, thus retaining completeness. In particular, we have the following theorem: Theorem 1 Nsat-prune is an admissible pruning strategy for UA and TO <ref> [15] </ref> The proof of the theorem follows from an extension of the proofs of completeness of UA and TO planners [15]. <p> In particular, we have the following theorem: Theorem 1 Nsat-prune is an admissible pruning strategy for UA and TO <ref> [15] </ref> The proof of the theorem follows from an extension of the proofs of completeness of UA and TO planners [15]. <p> The reason turns out to be that in TWEAK, a condition that is not necessarily true may be possibly 13 true, while in UA and TO a condition is either necessarily true or necessarily false (Minton et. al. term this property ``unambiguousness'' <ref> [15] </ref>). 4.1 Cost of Nsat-prune The cost of Nsat-prune depends on the cost of constructing the Nsatplan from a given incomplete plan, and the cost of checking the minimality of a complete plan. <p> Smith and Peot provide experimental results that show that this technique significantly improves the performance of SNLP. It will be intersting to see how their general approach can be adapted to non-causal link planners. 26 A Proofs Theorem 3 Nsat-prune is an admissible pruning strategy for UA and TO <ref> [15] </ref> Proof: Let [I; G] be a planning problem. We need to prove that for every minimal solution P s of this problem, there exists a sequence of UA/TO refinements that will pass through minimal incomplete plans, and terminate with P s . <p> Since P is a strict subplan of P s , c@s 00 must also be a precondition in P s . Let s add be the last step in P s that adds c before s 00 (such a step exists for any partial plan generated by UA/TO planners <ref> [15] </ref>). We construct P i+1 by adding s add to P , and order s add in such a way that the partial ordering relation on P i+1 is a subset of the partial ordering relation on P s . <p> By construction, P i+1 is a subplan of P s . It is also a 1-step refinement of P as done by UA/TO <ref> [15] </ref> To show that this specific refinement sequence will survive Nsat-prune we need to show that all the plans in the sequence are minimal incomplete plans. We already know that P ; is a minimal incomplete plan, and P s is a minimal plan.
Reference: [16] <author> J.S. Penberthy and D. Weld. UCPOP: </author> <title> A Sound, Complete, Partial Order Planner for ADL. </title> <booktitle> In Proc. </booktitle> <address> KR-92, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: In [9], we point out that such protection strategies lead to reduction of redundancy in the search space. Examples of this class of planners include SNLP [13] and UCPOP <ref> [16] </ref>. A second class of planners, such as TWEAK [3], UA and TO [15], which may be called non-causal link planners, do not protect their establishments, but allow re-establishment of a precondition that was previously established, and was subsequently undone.
Reference: [17] <author> D.E. Smith and M.A. Peot. </author> <title> Postponing threats in partial-order planning. </title> <booktitle> In Proc. Eleventh AAAI, </booktitle> <year> 1993. </year>
Reference-contexts: This check is useful when the underlying planners use causal links, but postpone resolution of the conflicts with the causal links <ref> [9, 17] </ref>. Checking the link inconsistency of an arbitrary partial plan is NP-complete [17]. Sometimes, the constraints on the plan themselves may not be inconsistent, but may be inconsistent together with some implicit domain knowledge. <p> This check is useful when the underlying planners use causal links, but postpone resolution of the conflicts with the causal links [9, 17]. Checking the link inconsistency of an arbitrary partial plan is NP-complete <ref> [17] </ref>. Sometimes, the constraints on the plan themselves may not be inconsistent, but may be inconsistent together with some implicit domain knowledge. Admissible pruning is possible even in such situations, as long as relevant knowledge about the domain is available. <p> On the other hand, looping occurs more readily in LIFO goal selection strategies than it does in FIFO orders. We have considered relaxing the pruning strategy by using the operator graph of the domain <ref> [17] </ref>. Specifically, the operator graph structure can be used to compute an optimistic approximation of the pp-cutset of the steps -- that is, what are all the possible open conditions following s 00 that s 00 and its possible predecessor steps can support.
Reference: [18] <author> D.E. Smith and M.A. Peot. </author> <title> Suspending Recursion in Planning. </title> <booktitle> In Proc. </booktitle> <address> AIPS-96, </address> <year> 1996. </year> <note> In press. </note>
Reference-contexts: If the optimistic cutset is in itself 23 First Search dominated, then we can be sure that Cutset-prune will eventually hold. Although initial results in this directions were encouraging, we suspended further work as Peot and Smith <ref> [18] </ref> recently reported an incremental pruning strategy, also based on plan minimality, that seems to improve performance more effectively (see Section 8 for further discussion on this). 7 Related Work As mentioned earlier, most state space planners, including STRIPS [7] and PRODIGY [2] use state loop and goal loop based pruning <p> In other words, rather than wait until the partial plan becomes provably non-minimal and then prune it, we could try to ``black list'' partial plans that are likely to become non-minimal. Recently, Smith and Peot <ref> [18] </ref> described a method that ``suspends'' working on recursive preconditions in a partial plan (roughly speaking, an open condition c@s is considered recursive, if it is part of a causal chain that contains another step precondition c@s 0 , that has already been achieved).
Reference: [19] <author> Q. Yang and C. Murray. </author> <title> An evaluation of the temporal coherence heuristic in partial-order planning. </title> <journal> Computational Intelligence Journal, </journal> <volume> 10(3), </volume> <year> 1994. </year> <note> 5 Technical reports available via URL ftp: //rakaposhi.eas.asu.edu/pub/rao/papers.html 31 </note>
Reference-contexts: This method essentially constrains the planner to work on the goals in the reverse order of their achievement, and thus is complete only when the planner backtracks on all goal orderings. Murray and Yang <ref> [19] </ref> describe empirical studies that show that the increased branching factor caused by backtracking over goal orderings is typically not offset by the temporal coherence based pruning. In contrast, the minimality based pruning strategies described in our work are complete for a much larger class of planners.
References-found: 19

