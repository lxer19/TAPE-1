URL: http://www.cs.man.ac.uk/~bill/Papers/hidden.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~bill/Papers/
Root-URL: http://www.cs.man.ac.uk
Email: bill@cs.man.ac.uk  
Title: Protecting Secret Keys in a Compromissed Computational System problem of protecting the code fragments dealing
Author: W. P. R. Mitchell 
Note: The paper treats the  
Date: February 4th, 1999  
Address: Manchester M13 9PL  
Affiliation: Department of Computer Science University of Manchester  
Abstract: Software applications which run in a compromised environment and perform sensitive operations, such as providing a secure communication channel between two individuals, require protection in order to prevent them being run by an unautherised adversary. This paper looks at how to build in some protection against an adversary who wishes to modify an application so that it no longer authenticates the user before running. This protection works against a casual observer, that is someone who has access only to standard debugging tools, visualisation tools, and decompilers. The tricks given in the paper do not work against an all powerful adversary. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Daivid Aucshmith, </author> <title> Tamper Resistant Software: An Implementation. </title> <booktitle> Proceedings of Workshop on Information Hiding, Cambridge 1996, Springer-Verlag, Lecture Notes in Computer Science, </booktitle> <volume> Volume 1174, </volume> <pages> pp 317-333. </pages>
Reference-contexts: Mitchell Protecting Secret Keys in a Compromissed Computational System 1.1 Related Work One of the most interesting ideas for protecting an application is to build self encrypting code <ref> [ 1 ] </ref> . The idea is that each block of machine code is a decryption cipher, which decrypts the next block of code to run, plus some small part of the application which is encrypted. After running the block re-encrypts itself. <p> o as o = rand [(rand [:f ]) _ (rand [f ])] Similarly we can define a random falsehood @ (a formula which always evaluates to false) as @ = rand [:((rand [:f ]) _ (rand [f ]))] Choosing fi [i] deceitfully Let P be the set of permutations of <ref> [1; 2; : : : ; n] </ref>. Such a permutation extends to B P n in the usual way. That is for ae 2 P , ae (f ) is the result of replacing each occurrence of p i by p ae (i) . <p> Also, the authentication process is usually performed sparingly and often is not as time critical as the rest of the application so that the extra cost may not have a great impact on performance. Looking again at the idea of self encrypting machine code in <ref> [ 1 ] </ref> we can see how to effectively combine that work with the tricks given here. Instead of code which contains its own encryption key, take the key as hidden in some kind of smart card say.
Reference: [2] <institution> DashO-Pro Obfuscator optimising compiler for Java. </institution> <note> http://www.preemptive.com/DashO/obfuscate.html </note>
Reference-contexts: It also has portability costs. Finally should an adversary suspect that the code is decrypting itself one block at a time it will then be easy to recapture a fully working version of the unprotected code. An approach taken in such products as <ref> [ 2 ] </ref> is to build a compiler which uses novel optimising techniques which are not easily reversible, so effectively hiding the authentication process. This has portability issues and is more difficult to maintain than an abstract protection mechanism built into the code itself. <p> o as o = rand [(rand [:f ]) _ (rand [f ])] Similarly we can define a random falsehood @ (a formula which always evaluates to false) as @ = rand [:((rand [:f ]) _ (rand [f ]))] Choosing fi [i] deceitfully Let P be the set of permutations of <ref> [1; 2; : : : ; n] </ref>. Such a permutation extends to B P n in the usual way. That is for ae 2 P , ae (f ) is the result of replacing each occurrence of p i by p ae (i) .
Reference: [3] <author> Cifuentes, Cristina and K. John Gough, </author> <title> Decompilation of binary programs. </title> <journal> Software | Practice and Experience, </journal> <volume> vol. 25, no. 7, </volume> <pages> pp. 811-829, </pages> <month> July, </month> <year> 1995. </year> <title> http://www.csee.uq.edu.au/cristina/pubs.html 12 W. Mitchell Protecting Secret Keys in a Compromissed Computational System </title>
Reference-contexts: Reverse engineering of binary code is a real danger for secure applications, <ref> [ 3 ] </ref> [ 4 ] , [ 5 ] , [ 6 ] give details of sophisticated decompilation tools and decompilers currently available or under development.
Reference: [4] <author> C Cifuentes, </author> <title> Partial Automation of an Integrated Reverse Engineering Environment of Binary Code. </title> <booktitle> Proceedings Third Working Conference on Reverse Engineering. </booktitle> <address> Monterey, CA, Nov 8-10 1996. </address> <publisher> IEEE-CS Press. </publisher> <pages> pp 50-56. </pages> <address> http://www.csee.uq.edu.au/cristina/pubs.html </address>
Reference-contexts: Reverse engineering of binary code is a real danger for secure applications, [ 3 ] <ref> [ 4 ] </ref> , [ 5 ] , [ 6 ] give details of sophisticated decompilation tools and decompilers currently available or under development.
Reference: [5] <author> C Cifuentes, D Simon and A Fraboulet, </author> <title> Assembly to High-Level Language Translation. </title> <booktitle> Proceedings of the International Conference on Software Maintenance, </booktitle> <address> Wash-ington DC, USA, Nov 1998, </address> <publisher> IEEE-CS Press, </publisher> <pages> pp 228-237. </pages> <address> http://www.csee.uq.edu.au/cristina/pubs.html </address>
Reference-contexts: Reverse engineering of binary code is a real danger for secure applications, [ 3 ] [ 4 ] , <ref> [ 5 ] </ref> , [ 6 ] give details of sophisticated decompilation tools and decompilers currently available or under development. We will regard the problem of preventing the authentication process from being subverted as equivalent to computing the encryption of a piece of plaintext without revealing the encryption key.
Reference: [6] <author> C Cifuentes and A Fraboulet, </author> <title> Interprocedural Data Flow Recovery of High-level Language Code from Assembly. </title> <type> Technical Report 421, </type> <institution> Department of Computer Science and Electrical Engineering, The University of Queensland, </institution> <month> Dec </month> <year> 1997. </year> <note> http://www.csee.uq.edu.au/cristina/pubs.html </note>
Reference-contexts: Reverse engineering of binary code is a real danger for secure applications, [ 3 ] [ 4 ] , [ 5 ] , <ref> [ 6 ] </ref> give details of sophisticated decompilation tools and decompilers currently available or under development. We will regard the problem of preventing the authentication process from being subverted as equivalent to computing the encryption of a piece of plaintext without revealing the encryption key.
Reference: [7] <author> Cimitile A., De Lucia A., Munro M., </author> <title> A Specification Driven Slicing Process for Identifying Reusable Functions, </title> <journal> Journal of Software Maintenance : Research and Practice, </journal> <volume> 8(3), pp145-178, </volume> <year> 1996 </year>
Reference-contexts: The tricks are also designed so that it is hard to break them down into smaller parts which can be individually attacked through dynamic slicing techniques <ref> [ 7 ] </ref> , [ 10 ] . This forces the attacker to understand the dynamics of the whole protection mechanism during run time in order to attack any part of it.
Reference: [8] <author> Collberg, Christian, Clark Thomborson and Douglas Low. </author> <title> A taxonomy of obfuscating transformations. </title> <type> Technical Report 148, </type> <institution> Department of Computer Science, University of Auckland, </institution> <address> New Zealand, </address> <month> July, </month> <year> 1997. </year> <note> http://www.cs.auckland.ac.nz/ collberg/Research/Publications/CollbergThomborsonLow97a/index.html </note>
Reference-contexts: The other drawback is that the final code has static protection mechanisms built into it, which by definition are simpler to crack than dynamically varying ones. Using the idea of hiding values in a higher order abstract data type is not new, in <ref> [ 8 ] </ref> , [ 9 ] , [ 12 ] they show how to protect against reverse engineering by such tricks.
Reference: [9] <author> Collberg, Christian, Clark Thomborson and Douglas Low. </author> <title> Manufacturing cheap, resilient, and stealthy opaque constructs. </title> <institution> Department of Computer Science, University of Auckland, </institution> <address> New Zealand, </address> <month> July, </month> <year> 1997. </year> <note> To appear in ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL'98). http://www.cs.auckland.ac.nz/ collberg/Research/Publications/CollbergThomborsonLow98a/index.html </note>
Reference-contexts: The other drawback is that the final code has static protection mechanisms built into it, which by definition are simpler to crack than dynamically varying ones. Using the idea of hiding values in a higher order abstract data type is not new, in [ 8 ] , <ref> [ 9 ] </ref> , [ 12 ] they show how to protect against reverse engineering by such tricks. Their work is concerned with allowing an algorithm to run in such a way that the adversary can not reconstruct the original algorithm, thus protecting the intellectual property contained in the algorithm.
Reference: [10] <author> De Lucia A., Fasolino A.R., Munro M., </author> <title> Understanding Function Behaviors through Program Slicing, Workshop on Program Comprehension, </title> <publisher> IEEE Press, </publisher> <year> 1996. </year> <note> http://www.dur.ac.uk/dcs1elb/delucia-wpc96.html </note>
Reference-contexts: The tricks are also designed so that it is hard to break them down into smaller parts which can be individually attacked through dynamic slicing techniques [ 7 ] , <ref> [ 10 ] </ref> . This forces the attacker to understand the dynamics of the whole protection mechanism during run time in order to attack any part of it.
Reference: [11] <author> Oded Goldreich, Birgit Pfitzmann and Ronald L. Rivest, </author> <title> Self-Delegation with Controlled Propogation | or | What If You Loose Your Laptop, </title> <booktitle> CRYPTO' 98, </booktitle> <volume> LNCS 1462, </volume> <pages> pp. 153-168 </pages>
Reference-contexts: This is different from our problem, where we are not concerned with the algorithm being discovered, but with the more difficult problem of hiding some of the values which pass through the algorithm. In <ref> [ 11 ] </ref> they look at the related problem of how to use a personal key to designate authority to temporary subkeys in a compromised system without revealing too much about the personal key.
Reference: [12] <institution> Java Code Engineering & Reverse Engineering. </institution> <address> http://meurrens.ml.org/ip-Links/Java/CodeEngineering/mm scale.html </address>
Reference-contexts: Using the idea of hiding values in a higher order abstract data type is not new, in [ 8 ] , [ 9 ] , <ref> [ 12 ] </ref> they show how to protect against reverse engineering by such tricks. Their work is concerned with allowing an algorithm to run in such a way that the adversary can not reconstruct the original algorithm, thus protecting the intellectual property contained in the algorithm.
Reference: [13] <author> Bruce Schneier. </author> <title> Applied Cryptography, Second Edition, </title> <publisher> John Wiley & Sons, </publisher> <year> 1996 </year>
Reference-contexts: The graph is dynamically constructed during run time and will change at random from one execution of the program to the next. Assume the encryption cipher is an r-round cipher <ref> [ 13 ] </ref> where each round is given by the function O (k (i) ; a i ), where k (i) is the key material used at the i-th round from the key k, and a i is the ciphertext of the i-th round.
Reference: [14] <author> B. Schneier, J. Kelsey, D. Whiting, D. Wagner, C. Hall, N. Ferguson. Twofish: </author> <title> A 128-Bit Block Cipher, </title> <month> June </month> <year> 1998, </year> <note> http://www.counterpane.com/twofish-paper.html 13 </note>
Reference-contexts: Not all encryption ciphers fit this description, for example the Twofish cipher <ref> [ 14 ] </ref> doesn't. However block ciphers usually include many rounds using essentially the same function, and this part of the cipher can be protected using the ideas in this section.
References-found: 14

