URL: ftp://flint.cs.yale.edu/pub/flint/publications/tcps.ps.gz
Refering-URL: http://daffy.cs.yale.edu/users/shao-zhong/papers.html
Root-URL: http://www.cs.yale.edu
Title: A Type-Based Compiler for Standard ML  
Author: Zhong Shao Andrew W. Appel 
Date: March 28, 1995  
Address: PRINCETON-CS-TR-487-95  
Affiliation: Yale University Princeton University  
Abstract: Compile-time type information should be valuable in efficient compilation of statically typed functional languages such as Standard ML. But how should type-directed compilation work in real compilers, and how much performance gain will type-based optimizations yield? In order to support more efficient data representations and gain more experience about type-directed compilation, we have implemented a new type-based middle end and back end for the Standard ML of New Jersey compiler. We describe the basic design of the new compiler, identify a number of practical issues, and then compare the performance of our new compiler with the old non-type-based compiler. Our measurement shows that a combination of several simple type-based optimizations reduces heap allocation by 36%; and improves the already-efficient code generated by the old non-type-based compiler by about 19% on a DECsta-tion 5000. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> William E. Aitken and John H. Reppy. </author> <title> Abstract value constructors: Symbolic constants for Standard ML. </title> <type> Technical Report TR 92-1290, </type> <institution> Department of Computer Science, Cor-nell University, </institution> <month> June </month> <year> 1992. </year> <note> A shorter version appears in the proceedings of the "ACM SIGPLAN Workshop on ML and its Applications," </note> <year> 1992. </year>
Reference-contexts: Here, coercions of projections and injections for data constructors can be implemented by recording the origin type lt c with T.FOO or by using abstract value constructors proposed by Aitken and Reppy <ref> [1] </ref>. 4.4 Translating Absyn into LEXP Now that we have explained how to translate static semantic objects into LTY and how to coerce from one LTY to another, the translation of Absyn into LEXP is straightforward.
Reference: [2] <author> Andrew W. Appel. </author> <title> A runtime system. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 3(4) </volume> <pages> 343-80, </pages> <year> 1990. </year>
Reference-contexts: Figure 8 compares execution time, heap allocation, code size, and compile time (based on the average ratios of all twelve benchmarks). We can draw the following conclusions from these comparisons: 7 Unfortunately, the SML/NJ version 1.03z still uses the old runtime system <ref> [2] </ref>. Reals are not always aligned properly, so memory fetch (or store) of a floating-point number must be implemented using two single-word memory-load (memory-store) instructions.
Reference: [3] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cam-bridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: by memo-izing coercions. * We evaluate the utility of minimum typing derivations [7]|a method for eliminating unnecessary "wrapper" functions introduced by representation anal ysis. * We show how the type annotations can be simplified in successive phases of the compiler, and how representation analysis can interact with the Continuation-Passing Style <ref> [24, 3] </ref> used by the SML/NJ compiler's optimizer [5, 3]. * We compare representation analysis with the crude (but effective) known-function parameter specializa tion implemented by Kranz [14]. * Our measurements show that a combination of several type-based optimizations reduces heap allocation by 36%, and improves the already-efficient code generated by <p> of minimum typing derivations [7]|a method for eliminating unnecessary "wrapper" functions introduced by representation anal ysis. * We show how the type annotations can be simplified in successive phases of the compiler, and how representation analysis can interact with the Continuation-Passing Style [24, 3] used by the SML/NJ compiler's optimizer <ref> [5, 3] </ref>. * We compare representation analysis with the crude (but effective) known-function parameter specializa tion implemented by Kranz [14]. * Our measurements show that a combination of several type-based optimizations reduces heap allocation by 36%, and improves the already-efficient code generated by the old non-type-based compiler by about 19%. <p> In this section, we explain the details of our translation algorithm, and present solutions to several practical implementation problems. 4.1 The typed lambda language LEXP The typed call-by-value lambda language LEXP is very similar to the untyped lambda languages <ref> [3, sec. 4.7] </ref> used in previous versions of the compiler: it contains lambda, application, constants, tuple and selection operators (i.e., RECORD and SELECT), and so on. <p> The LEXP language is converted into a CPS notation (cexp) that makes flow of control explicit. CPS [24, 14] and its use in the SML/NJ compiler <ref> [4, 3] </ref> have been described in the literature. Previous versions of SML/NJ 5 have used an untyped CPS language. But now we propagate some very simple type annotations into CPS. Each variable in the CPS language is annotated, at its binding occurrence, with a "CPS type" (CTY). <p> For integers represented by boxing, then iwrap could heap-allocate a boxed integer. 5.1 CPS conversion The overall structure and algorithm of our CPS conversion phase is almost same as the one described by Appel <ref> [3, Ch. 5] </ref>. The conversion function takes two arguments: an LEXP expression E and a "continuation" function c of type value ! cexp ; and returns a CPS expression as the result. <p> The optimizer of the SML/NJ compiler operates on the CPS intermediate representation. Optimization phases are almost unchanged, except that they must correctly propagate the CTYs, which is simple to do; CPS optimizations are naturally type-consistent. Besides those described by Appel <ref> [3] </ref>, two new CPS optimizations are performed: pairs of "wrapper" and "unwrapper" operations are cancelled; and record copying operations of the form let val (x,y) = a in (x,y) end can be eliminated, since now we know the size of a at compile time. <p> When the closure analysis phase must build heap records for closure environments, it can use all the record representations shown in Figure 1. The closure conversion algorithm is very cautious about "optimizing" transformations that extend the lifetime of variables, since this can cause a kind of memory leak <ref> [23, 3] </ref>. The CTY information allows the lifetime of integers (and other constant-size variables) to be safely extended, a useful benefit. 6 Performance Evaluation Type-directed compilation should support much more efficient data representations. <p> All of these compilers use the new closure conversion algorithm [23] and with three general purpose callee-save registers [6], and all use tagged 31-bit integer representations. Other aspects of these compilers are close to those described by Appel <ref> [3] </ref>. sml.nrp A non-type-based compiler. No type information is propagated beyond the elaboration phase. Data uses standard boxed representations. Functions take one argument and return one result. sml.fag The sml.nrp compiler with the argument flattening optimization [14, 3]. <p> Other aspects of these compilers are close to those described by Appel [3]. sml.nrp A non-type-based compiler. No type information is propagated beyond the elaboration phase. Data uses standard boxed representations. Functions take one argument and return one result. sml.fag The sml.nrp compiler with the argument flattening optimization <ref> [14, 3] </ref>. If the call sites of a function are known at compile time, its n-tuple argument can be flattened and passed in n registers. This compiler is similar to SML/NJ 0.93 [3]. sml.rep The new type-based compiler that supports very basic representation analysis (on records). <p> Functions take one argument and return one result. sml.fag The sml.nrp compiler with the argument flattening optimization [14, 3]. If the call sites of a function are known at compile time, its n-tuple argument can be flattened and passed in n registers. This compiler is similar to SML/NJ 0.93 <ref> [3] </ref>. sml.rep The new type-based compiler that supports very basic representation analysis (on records). Floating point numbers still use boxed representations. <p> Because of the potential code explosion problem, the compiler must do static analysis to decide when and where to do specialization. Our type-based compiler uses coercions rather than specializations; however, because our CPS optimizer <ref> [3] </ref> always inline-expands small functions, small and local polymorphic functions still end up being specialized in our compiler. We believe that a combination of representation analysis and type specialization would achieve the best performance, and we intend to explore this in the future.
Reference: [4] <author> Andrew W. Appel and Trevor Jim. </author> <title> Continuation-passing, closure-passing style. </title> <booktitle> In Sixteenth ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 293-302, </pages> <address> New York, 1989. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The LEXP language is converted into a CPS notation (cexp) that makes flow of control explicit. CPS [24, 14] and its use in the SML/NJ compiler <ref> [4, 3] </ref> have been described in the literature. Previous versions of SML/NJ 5 have used an untyped CPS language. But now we propagate some very simple type annotations into CPS. Each variable in the CPS language is annotated, at its binding occurrence, with a "CPS type" (CTY).
Reference: [5] <author> Andrew W. Appel and David B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <editor> In Martin Wirsing, editor, </editor> <booktitle> Third Int'l Symp. on Prog. Lang. Implementation and Logic Programming, </booktitle> <pages> pages 1-13, </pages> <address> New York, </address> <month> August </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference-contexts: of minimum typing derivations [7]|a method for eliminating unnecessary "wrapper" functions introduced by representation anal ysis. * We show how the type annotations can be simplified in successive phases of the compiler, and how representation analysis can interact with the Continuation-Passing Style [24, 3] used by the SML/NJ compiler's optimizer <ref> [5, 3] </ref>. * We compare representation analysis with the crude (but effective) known-function parameter specializa tion implemented by Kranz [14]. * Our measurements show that a combination of several type-based optimizations reduces heap allocation by 36%, and improves the already-efficient code generated by the old non-type-based compiler by about 19%. <p> In this section, we explain in detail what the standard boxed representations are, and what other more efficient alternatives one can use in type-based compilers. Non-type-based compilers for polymorphic languages, such as the old SML/NJ compiler <ref> [5] </ref>, must use the standard boxed representations for all data objects. <p> The Elabora-tor/Type-checker produces typed abstract syntax (Absyn), which is almost unchanged from previous versions of the compiler <ref> [5] </ref>, except that we annotate each occurrence of a polymorphic variable or data constructor with its type in-stantiation at each use, inferred by the type checker. The front end must also remember the details of each module-level (structure or functor) abstraction and instantiation in order to do module-level type-based analysis.
Reference: [6] <author> Andrew W. Appel and Zhong Shao. </author> <title> Callee-save registers in continuation-passing style. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 5 </volume> <pages> 189-219, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: To represent environments for higher-order functions with nested scope, the compiler uses our new space-efficient closure conversion algorithm [23]. Previously, this phase had to discover which functions are continuations by dataflow analysis <ref> [6] </ref>; now the information is manifest in the CTYs. When the closure analysis phase must build heap records for closure environments, it can use all the record representations shown in Figure 1. <p> The six compilers we use are all simple variations of the Standard ML of New Jersey compiler version 1.03z. All of these compilers use the new closure conversion algorithm [23] and with three general purpose callee-save registers <ref> [6] </ref>, and all use tagged 31-bit integer representations. Other aspects of these compilers are close to those described by Appel [3]. sml.nrp A non-type-based compiler. No type information is propagated beyond the elaboration phase. Data uses standard boxed representations.
Reference: [7] <author> Nikolaj S. </author> <title> Bjorner. Minimial typing derivations. </title> <booktitle> In ACM SIGPLAN Workshop on ML and its Applications, </booktitle> <pages> pages 120-126, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: The derivation is done after the elaboration so that it is only applied to type-correct programs. Our algorithm, which is similar to Bjtrner's algorithm M <ref> [7] </ref>, does a bottom-up traversal of the Absyn. During the traversal, we mark all non-exported variables: let-bound variables and those that are hidden by signature matching. <p> Hen-glein and Jorgensen [13] present a term-rewriting method that translates a program with many coercions into one that contains a "formally optimal" set of coercions. Neither technique appears easy to extend to the SML module language. We use minimum typing derivations <ref> [7] </ref> to decrease the degree of polymorphism for all local and hidden functions. This is very easy to extend to the module system. Our approach may achieve almost the same result as "formally optimal" unboxing.
Reference: [8] <author> Craig Chambers. </author> <title> The Design and Implementation of the SELF Compiler, an Optimizing Compiler for Object-Oriented Programming Languages. </title> <type> PhD thesis, </type> <institution> Stanford University, Stanford,California, </institution> <month> March </month> <year> 1992. </year> <note> Tech Report STAN-CS-92-1420. </note>
Reference-contexts: Our approach may achieve almost the same result as "formally optimal" unboxing. And we have shown that simple dataflow optimizations (cancelling wrap/unwrap pairs in the CPS back end) is almost as effective as type-theory-based wrapper elimination. Type specialization or customization <ref> [9, 8] </ref> is another way to transform polymorphic functions into monomorphic ones. Specialization can also be applied to parameterized modules (i.e., functors), just as generic modules are implemented in Ada and Modula-3.
Reference: [9] <author> Craig Chambers and David Ungar. </author> <title> Customization: Optimizing compiler technology for SELF, a dynamically-typed object-oriented programming language. </title> <booktitle> In Proc. ACM SIG-PLAN '89 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 146-160, </pages> <address> New York, July 1989. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Our approach may achieve almost the same result as "formally optimal" unboxing. And we have shown that simple dataflow optimizations (cancelling wrap/unwrap pairs in the CPS back end) is almost as effective as type-theory-based wrapper elimination. Type specialization or customization <ref> [9, 8] </ref> is another way to transform polymorphic functions into monomorphic ones. Specialization can also be applied to parameterized modules (i.e., functors), just as generic modules are implemented in Ada and Modula-3.
Reference: [10] <author> Luis Damas and Robin Milner. </author> <title> Principal type-schemes for functional programs. </title> <booktitle> In Ninth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-12, </pages> <address> New York, 1982. </address> <publisher> ACM Press. </publisher> <pages> Page 13 </pages>
Reference-contexts: Therefore, for each functor signature matching, the elaborator records everything occurring in functor application F (X) plus the thinning function generated for matching F (X) against the result signature RSIG. Minimum typing derivation Similar to the Damas-Milner type assignment algorithm W <ref> [10] </ref>, the old Elaborator/Type-checker in our compiler infers the most general type schemes for all SML programs. As a result, local variables are always assigned the most general polymorphic types even though they are not used polymorphically.
Reference: [11] <author> Robert Harper and Mark Lillibridge. </author> <title> A type-theoretic ap-proach to higher-order modules with sharing. </title> <booktitle> In Twenty First Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 123-137, </pages> <address> New York, Jan 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: In Figure 5, U is bound to the result of matching structure S against signature SIG. Signature matching in ML is transparent <ref> [18, 16, 11] </ref>, so f and p in the instantiation structure U have type real ! (real fl real ) and real . <p> transparent <ref> [18, 16, 11] </ref>, so f and p in the instantiation structure U have type real ! (real fl real ) and real . The new types and their old types in structure S (also shown in * Abstraction is similar to signature matching; but matching for abstraction is opaque [18, 16, 11]. In addition to the thinning function, the elaboration phase also remembers the result signature. In Figure 5, V is an abstraction of structure S on signature SIG. V remembers the thinning function generated when doing signature matching of S against SIG, plus the actual signature SIG.
Reference: [12] <author> Robert Harper and Greg Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <booktitle> In Twenty-second Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 130-141, </pages> <address> New York, Jan 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: We believe that a combination of representation analysis and type specialization would achieve the best performance, and we intend to explore this in the future. Harper and Morrisett <ref> [12] </ref> have recently proposed a type-based compilation framework called compiling with intensional type analysis for the core-ML language. They use a typed lambda calculus with explicit type abstractions and type applications as the intermediate language.
Reference: [13] <author> Fritz Henglein and Jesper Jorgensen. </author> <title> Formally optimal boxing. </title> <booktitle> In Proc. 21st Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <pages> pages 213-226. </pages> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: Many people have worked on eliminating unnecessary "wrapper" functions introduced by representation analysis. Both Peyton Jones [20] and Poulsen [21] let the programmer to tag some types with a boxity annotation, and then statically determine when to use boxed representations. Hen-glein and Jorgensen <ref> [13] </ref> present a term-rewriting method that translates a program with many coercions into one that contains a "formally optimal" set of coercions. Neither technique appears easy to extend to the SML module language.
Reference: [14] <author> David Kranz. </author> <title> ORBIT: An optimizing compiler for Scheme. </title> <type> PhD thesis, </type> <institution> Yale University, </institution> <address> New Haven, CT, </address> <year> 1987. </year>
Reference-contexts: how the type annotations can be simplified in successive phases of the compiler, and how representation analysis can interact with the Continuation-Passing Style [24, 3] used by the SML/NJ compiler's optimizer [5, 3]. * We compare representation analysis with the crude (but effective) known-function parameter specializa tion implemented by Kranz <ref> [14] </ref>. * Our measurements show that a combination of several type-based optimizations reduces heap allocation by 36%, and improves the already-efficient code generated by the old non-type-based compiler by about 19%. <p> The LEXP language is converted into a CPS notation (cexp) that makes flow of control explicit. CPS <ref> [24, 14] </ref> and its use in the SML/NJ compiler [4, 3] have been described in the literature. Previous versions of SML/NJ 5 have used an untyped CPS language. But now we propagate some very simple type annotations into CPS. <p> Other aspects of these compilers are close to those described by Appel [3]. sml.nrp A non-type-based compiler. No type information is propagated beyond the elaboration phase. Data uses standard boxed representations. Functions take one argument and return one result. sml.fag The sml.nrp compiler with the argument flattening optimization <ref> [14, 3] </ref>. If the call sites of a function are known at compile time, its n-tuple argument can be flattened and passed in n registers. This compiler is similar to SML/NJ 0.93 [3]. sml.rep The new type-based compiler that supports very basic representation analysis (on records).
Reference: [15] <author> Xavier Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Nineteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 177-188, </pages> <address> New York, </address> <month> January </month> <year> 1992. </year> <note> ACM Press. </note>
Reference-contexts: If the natural representation of a value (such as a floating-point number) does not fit into one word, the value is boxed (i.e., allocated on the heap) and the pointer to this boxed object is used instead. This is inefficient. Leroy <ref> [15] </ref> has recently presented a representation analysis technique that does not always require variables be boxed in one word. In his scheme, data objects whose types are not polymorphic can be represented in multiple words or in machine registers; only those variables that have polymorphic types must use boxed representations. <p> Representation analysis enables many interesting type-based compiler optimizations. But since no existing compiler has fully implemented representation analysis for the complete SML language, many practical implementation issues are still unclear. For example, while Leroy <ref> [15] </ref> has shown in detail how to insert coercions for core-ML, he does not address the issues in the ML module system [19, 17], that is, how to insert coercions for functor application and signature matching. <p> We treat this as a coercion, and we define a compilation function coerce that produces the right combination of WRAP and UNWRAP operators. Our coerce is similar to Leroy's wrap Page 6 and unwrap <ref> [15] </ref>; but ours does not require that one type be an instantiation of the other. <p> If one of t 1 and t 2 is RBOXEDty, this requires coercing an arbitrary unboxed object into a pointer (or vice versa); moreover, the object itself must be coerced into the standard boxed representation (or vice versa); this coercion is similar to the recursive wrapping operations defined by Leroy <ref> [15] </ref>. <p> Simple representation analysis <ref> [15] </ref> would run into two problems when compiling F 's body: * At the function application S.f (S.p), since S.f is polymorphic and S.p is monomorphic, a coercion must be inserted here; but the detail of this coercion is not known because it depends on the actual instan-tiation of t. <p> the Life benchmark where with MTD, the (slow) polymorphic equality in a tight loop (testing membership of an ele ment in a set) is successfully transformed into a (fast) monomorphic equality operator|and the program runs 10 times faster. 7 Related Work and Conclusion Representation analysis, proposed and implemented by Leroy <ref> [15] </ref> (for ML-like languages) and Peyton Jones and Launchbury [20] (for Haskell-like languages), allows data objects whose types are not polymorphic to use more efficient unboxed representations. <p> Peyton Jones and Launch-bury's approach [20] requires extending the language (i.e., Haskell) with a new set of "unboxed" monomorphic types; the programmer has to explicitly write "boxing" coercions when passing unboxed monomorphic values to polymorphic functions. Leroy's <ref> [15] </ref> approach is more attractive because it requires no language extension or user interven Page 12 tion. The work described in this paper is an extension and implementation of Leroy's techniques for the entire SML language.
Reference: [16] <author> Xavier Leroy. </author> <title> Manifest types, modules, and separate compilation. </title> <booktitle> In Twenty First Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 109-122, </pages> <address> New York, Jan 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: In Figure 5, U is bound to the result of matching structure S against signature SIG. Signature matching in ML is transparent <ref> [18, 16, 11] </ref>, so f and p in the instantiation structure U have type real ! (real fl real ) and real . <p> transparent <ref> [18, 16, 11] </ref>, so f and p in the instantiation structure U have type real ! (real fl real ) and real . The new types and their old types in structure S (also shown in * Abstraction is similar to signature matching; but matching for abstraction is opaque [18, 16, 11]. In addition to the thinning function, the elaboration phase also remembers the result signature. In Figure 5, V is an abstraction of structure S on signature SIG. V remembers the thinning function generated when doing signature matching of S against SIG, plus the actual signature SIG.
Reference: [17] <author> David B. MacQueen and Mads Tofte. </author> <title> A semantics for higher-order functors. </title> <booktitle> In Proc. European Symposium on Programming (ESOP'94), </booktitle> <pages> pages 409-423, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: But since no existing compiler has fully implemented representation analysis for the complete SML language, many practical implementation issues are still unclear. For example, while Leroy [15] has shown in detail how to insert coercions for core-ML, he does not address the issues in the ML module system <ref> [19, 17] </ref>, that is, how to insert coercions for functor application and signature matching. Propagating type information into the middle end and back end of the compiler can also incur large compilation overhead if it is not done carefully, because all the intermediate optimizations must preserve type consistency. <p> Abstraction and instantiation may occur in signature matching (Figure 5), abstraction declaration (Figure 5), functor application (see Figure 4c), and functor signature matching (used by higher-order modules <ref> [25, 17] </ref>).
Reference: [18] <author> Robin Milner and Mads Tofte. </author> <title> Commentary on Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: In Figure 5, U is bound to the result of matching structure S against signature SIG. Signature matching in ML is transparent <ref> [18, 16, 11] </ref>, so f and p in the instantiation structure U have type real ! (real fl real ) and real . <p> transparent <ref> [18, 16, 11] </ref>, so f and p in the instantiation structure U have type real ! (real fl real ) and real . The new types and their old types in structure S (also shown in * Abstraction is similar to signature matching; but matching for abstraction is opaque [18, 16, 11]. In addition to the thinning function, the elaboration phase also remembers the result signature. In Figure 5, V is an abstraction of structure S on signature SIG. V remembers the thinning function generated when doing signature matching of S against SIG, plus the actual signature SIG. <p> In the previous example, the body of functor F references several identifiers defined in the argument signature SIG. 3 Following the SML Definition and Commentary <ref> [19, 18] </ref>, all type constructor names defined as type specifications in signatures are flexible; all other type constructor names are rigid. Because S.t is flexible (i.e., abstract) inside F , the identifier S.p has LTY lt p = RBOXEDty and the identifier S.f has LTY lt f = ARROWty (RBOXEDty,BOXEDty).
Reference: [19] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: Permissions may be requested from Publications Dept, ACM Inc., 1515 Broadway, New York, NY 10036 USA, fax +1 (212)869-0481, or &lt;permissions@acm.org&gt;. time. For statically typed languages such as Standard ML (SML) <ref> [19] </ref>, there is sufficient type information at compile time to guarantee that primitive operators will never be applied to values of the wrong type. But, because of SML's parametric polymorphism, there are still contexts in which the types of (polymorphic) variables are unknown. <p> But since no existing compiler has fully implemented representation analysis for the complete SML language, many practical implementation issues are still unclear. For example, while Leroy [15] has shown in detail how to insert coercions for core-ML, he does not address the issues in the ML module system <ref> [19, 17] </ref>, that is, how to insert coercions for functor application and signature matching. Propagating type information into the middle end and back end of the compiler can also incur large compilation overhead if it is not done carefully, because all the intermediate optimizations must preserve type consistency. <p> In the previous example, the body of functor F references several identifiers defined in the argument signature SIG. 3 Following the SML Definition and Commentary <ref> [19, 18] </ref>, all type constructor names defined as type specifications in signatures are flexible; all other type constructor names are rigid. Because S.t is flexible (i.e., abstract) inside F , the identifier S.p has LTY lt p = RBOXEDty and the identifier S.f has LTY lt f = ARROWty (RBOXEDty,BOXEDty).
Reference: [20] <author> Simon L. Peyton Jones and John Launchbury. </author> <title> Unboxed values as first class citizens in a non-strict functional language. </title> <booktitle> In The Fifth International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 636-666, </pages> <address> New York, </address> <month> August </month> <year> 1991. </year> <note> ACM Press. </note>
Reference-contexts: equality in a tight loop (testing membership of an ele ment in a set) is successfully transformed into a (fast) monomorphic equality operator|and the program runs 10 times faster. 7 Related Work and Conclusion Representation analysis, proposed and implemented by Leroy [15] (for ML-like languages) and Peyton Jones and Launchbury <ref> [20] </ref> (for Haskell-like languages), allows data objects whose types are not polymorphic to use more efficient unboxed representations. Peyton Jones and Launch-bury's approach [20] requires extending the language (i.e., Haskell) with a new set of "unboxed" monomorphic types; the programmer has to explicitly write "boxing" coercions when passing unboxed monomorphic values <p> the program runs 10 times faster. 7 Related Work and Conclusion Representation analysis, proposed and implemented by Leroy [15] (for ML-like languages) and Peyton Jones and Launchbury <ref> [20] </ref> (for Haskell-like languages), allows data objects whose types are not polymorphic to use more efficient unboxed representations. Peyton Jones and Launch-bury's approach [20] requires extending the language (i.e., Haskell) with a new set of "unboxed" monomorphic types; the programmer has to explicitly write "boxing" coercions when passing unboxed monomorphic values to polymorphic functions. Leroy's [15] approach is more attractive because it requires no language extension or user interven Page 12 tion. <p> We concentrate on practical issues of implementing type-directed compilation such as interaction with ML module system and efficient propagation of type information through many rounds of compiler transformations and optimizations. Many people have worked on eliminating unnecessary "wrapper" functions introduced by representation analysis. Both Peyton Jones <ref> [20] </ref> and Poulsen [21] let the programmer to tag some types with a boxity annotation, and then statically determine when to use boxed representations. Hen-glein and Jorgensen [13] present a term-rewriting method that translates a program with many coercions into one that contains a "formally optimal" set of coercions.
Reference: [21] <author> Eigil Poulsen. </author> <title> Representation analysis for efficient implementation of polymorphism. </title> <type> Master's thesis, </type> <institution> DIKU, University of Copenhagen, </institution> <year> 1993. </year>
Reference-contexts: We concentrate on practical issues of implementing type-directed compilation such as interaction with ML module system and efficient propagation of type information through many rounds of compiler transformations and optimizations. Many people have worked on eliminating unnecessary "wrapper" functions introduced by representation analysis. Both Peyton Jones [20] and Poulsen <ref> [21] </ref> let the programmer to tag some types with a boxity annotation, and then statically determine when to use boxed representations. Hen-glein and Jorgensen [13] present a term-rewriting method that translates a program with many coercions into one that contains a "formally optimal" set of coercions.
Reference: [22] <author> Zhong Shao. </author> <title> Compiling Standard ML for Efficient Execution on Modern Machines. </title> <type> PhD thesis, </type> <institution> Princeton University, Princeton, NJ, </institution> <month> November </month> <year> 1994. </year> <note> Tech Report CS-TR-475-94. </note>
Reference-contexts: But now it is a typed language <ref> [22] </ref>, with types LTY described by this simple set of constructors: datatype lty = INTty | REALty | RECORDty of lty list | ARROWty of lty * lty | BOXEDty | RBOXEDty A lambda type LTY can be a primitive numeric type (INTty or REALty); a record type RECORDty [t 1 <p> In order to find out how much performance gain we can get for different type-based optimizations, we have measured the performance of six dif ferent compilers on twelve SML benchmarks (described in Shao <ref> [22] </ref>). Among these twelve benchmarks, MBrot, Nucleic, Simple, Ray, and BHut involve intensive floating-point operations; Sieve and KB-Comp frequently use first-class continuations or exceptions; VLIW and KB-Comp make heavy use of higher-order functions. The average size of these benchmarks is 1820 lines of SML source code. <p> Function call and return pass floating-point arguments in floating-point registers. Records of floats are represented "flat," as in each unboxed value being boxed separately. sml.fp3 The sml.ffb compiler, but with three floating-point callee-save registers <ref> [22] </ref>. All measurements are done on a DEC5000/240 workstation with 128 megabytes of memory, using the methodology described in Shao's Ph.D. thesis [22]. In Figure 7 we show the execution time of all the benchmarks using the above six compilers, using sml.nrp as the baseline value. <p> Records of floats are represented "flat," as in each unboxed value being boxed separately. sml.fp3 The sml.ffb compiler, but with three floating-point callee-save registers <ref> [22] </ref>. All measurements are done on a DEC5000/240 workstation with 128 megabytes of memory, using the methodology described in Shao's Ph.D. thesis [22]. In Figure 7 we show the execution time of all the benchmarks using the above six compilers, using sml.nrp as the baseline value. Figure 8 compares execution time, heap allocation, code size, and compile time (based on the average ratios of all twelve benchmarks).
Reference: [23] <author> Zhong Shao and Andrew W. Appel. </author> <title> Space-efficient closure representations. </title> <booktitle> In Proc. 1994 ACM Conf. on Lisp and Functional Programming, </booktitle> <pages> pages 150-161. </pages> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: We have previously reported a 14% speedup using new closure representations for accessing variables <ref> [23] </ref>; the two optimizations together yield a 28% speedup. 2 Data Representations One important benefit of type-directed compilation is to allow data objects with specialized types to use more efficient data representations. <p> To represent environments for higher-order functions with nested scope, the compiler uses our new space-efficient closure conversion algorithm <ref> [23] </ref>. Previously, this phase had to discover which functions are continuations by dataflow analysis [6]; now the information is manifest in the CTYs. When the closure analysis phase must build heap records for closure environments, it can use all the record representations shown in Figure 1. <p> When the closure analysis phase must build heap records for closure environments, it can use all the record representations shown in Figure 1. The closure conversion algorithm is very cautious about "optimizing" transformations that extend the lifetime of variables, since this can cause a kind of memory leak <ref> [23, 3] </ref>. The CTY information allows the lifetime of integers (and other constant-size variables) to be safely extended, a useful benefit. 6 Performance Evaluation Type-directed compilation should support much more efficient data representations. <p> The average size of these benchmarks is 1820 lines of SML source code. The six compilers we use are all simple variations of the Standard ML of New Jersey compiler version 1.03z. All of these compilers use the new closure conversion algorithm <ref> [23] </ref> and with three general purpose callee-save registers [6], and all use tagged 31-bit integer representations. Other aspects of these compilers are close to those described by Appel [3]. sml.nrp A non-type-based compiler. No type information is propagated beyond the elaboration phase. Data uses standard boxed representations.
Reference: [24] <author> Guy L. Steele. Rabbit: </author> <title> a compiler for Scheme. </title> <type> Technical Report AI-TR-474, </type> <institution> MIT, </institution> <address> Cambridge, MA, </address> <year> 1978. </year>
Reference-contexts: by memo-izing coercions. * We evaluate the utility of minimum typing derivations [7]|a method for eliminating unnecessary "wrapper" functions introduced by representation anal ysis. * We show how the type annotations can be simplified in successive phases of the compiler, and how representation analysis can interact with the Continuation-Passing Style <ref> [24, 3] </ref> used by the SML/NJ compiler's optimizer [5, 3]. * We compare representation analysis with the crude (but effective) known-function parameter specializa tion implemented by Kranz [14]. * Our measurements show that a combination of several type-based optimizations reduces heap allocation by 36%, and improves the already-efficient code generated by <p> The LEXP language is converted into a CPS notation (cexp) that makes flow of control explicit. CPS <ref> [24, 14] </ref> and its use in the SML/NJ compiler [4, 3] have been described in the literature. Previous versions of SML/NJ 5 have used an untyped CPS language. But now we propagate some very simple type annotations into CPS.
Reference: [25] <author> Mads Tofte. </author> <title> Principal signatures for higher-order program modules. </title> <booktitle> In Nineteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 189-199, </pages> <address> New York, Jan 1992. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Abstraction and instantiation may occur in signature matching (Figure 5), abstraction declaration (Figure 5), functor application (see Figure 4c), and functor signature matching (used by higher-order modules <ref> [25, 17] </ref>).
Reference: [26] <author> David M. Ungar. </author> <title> The Design and Evaluation of a High Performance Smalltalk System. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1986. </year> <pages> Page 14 </pages>
Reference-contexts: Since coerce (s; t) is an identity function in the common case that s = t, we can improve the performance of the compiler by optimizing the implementation of coerce with 4 In order to support generational garbage collection <ref> [26] </ref>, most compilers must do some bookkeeping at each update so that the pointers from older generation to youngest generation are correctly identified.
References-found: 26

