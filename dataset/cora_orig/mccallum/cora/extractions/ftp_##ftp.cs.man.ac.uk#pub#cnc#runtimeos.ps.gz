URL: ftp://ftp.cs.man.ac.uk/pub/cnc/runtimeos.ps.gz
Refering-URL: http://www.cs.man.ac.uk/cnc/arena/publication.html
Root-URL: http://www.cs.man.ac.uk
Email: ken@cs.man.ac.uk bridglaj@cs.man.ac.uk  
Title: Arena a Run-Time Operating System for Parallel Applications  
Author: K.R. Mayes and J. Bridgland 
Address: Oxford Road, Manchester, UK  
Affiliation: Centre for Novel Computing, Department of Computer Science, University of Manchester,  
Abstract: This paper presents the case for a run-time operating system to provide predictable and controllable resource management for parallel applications. Developments in compilers for parallel applications, which depend on analysis of program behaviour, require corresponding developments in predictable and controllable operating system-level resource management. A customisable system, Arena, is described which provides operating system-level resource management at user-level, where it is accessible to application and run-time system developers. This resource management is accessed via libraries, and effectively becomes part of the application run-time system. In such a system the application gets only the resource management that it needs. A low-policy hardware-dependent executive provides a low-level interface presenting an abstraction of processor hardware to the hardware-independent resource managers. The use of Arena on a Sparc-based distributed store multicom-puter is described, and three parallel application areas being investigated on Arena are briefly discussed. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T. Anderson, B. Bershad, E. Lazowska, and H. Levy. Sched-uler activations: </author> <title> Effective kernel support for the user-level management of parallelism. </title> <journal> tocs, </journal> <volume> 10(1) </volume> <pages> 53-79, </pages> <year> 1992. </year>
Reference-contexts: Although this allows some redefinition of management code outside the kernel, it requires process management and IPC support in the kernel. It has been argued that such systems provide insufficient flexibility for library and language implementors [18] [13]. Work on Psyche [14] and on scheduler activations <ref> [1] </ref> take thread scheduling out of the kernel by enabling the kernel to make `upcalls' to the user level. Threads on Arena exist only at user-level. There are no kernel threads, and no permanent kernel state for user-level threads [17].
Reference: [2] <author> H. Assenmacher, T. Breitbach, P. Buhler, V. Hubsch, H. Peine, and R. </author> <title> Schwarz. </title> <booktitle> Meeting the application in user space. In Proceeding of the 6th ACM SIGOPS European Workshop, </booktitle> <pages> pages 82-87, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: There are no kernel threads, and no permanent kernel state for user-level threads [17]. This means that all scheduling policy decisions are in the user-level PM, in the realm of the application. More recent systems, which are similar to Arena in em-phasising user-level application-specific resource management, are PANDA <ref> [2] </ref> and Exokernel [8]. This latter paper coined the term `library operating system' to describe such systems. An alternative approach to application-orientated resource management is to allow the operating system kernel to be tailored [19] [3]. 7.
Reference: [3] <author> B. Bershad, S. Savage, P. Pardyak, E. Sirer, M. Fiuczynski, D. Becker, C. Chambers, and S. Eggers. </author> <title> Extensibility, safety and performance int the spin operating system. </title> <booktitle> In Proceeding of 15th ACM Symposium on Operating System Principles, </booktitle> <pages> pages 267-284, </pages> <year> 1995. </year>
Reference-contexts: This latter paper coined the term `library operating system' to describe such systems. An alternative approach to application-orientated resource management is to allow the operating system kernel to be tailored [19] <ref> [3] </ref>. 7. Discussion Users of high performance parallel computers may wish to develop and link their applications directly on some node of the target machine (though this would seem to be unnecessary with a cross-compiler).
Reference: [4] <author> J. Bridgland. </author> <title> Secondary store management in a customisable operating system. </title> <note> 1996. In Preparation. </note>
Reference-contexts: Requiem database The Requiem relational database [21] has been ported to Arena. It runs on both EDS and PC platforms. The database is the target application for work on secondary storage management <ref> [4] </ref>. Requiem runs on a Unix system call interface. This is provided on Arena by using a library of Unix system calls, implemented at user-level on top of the SSM interface.
Reference: [5] <author> R. Bryant, H. Chang, and B. Rosenburg. </author> <title> Experience developing the rp3 operating system. </title> <booktitle> In Proceedings of Usenix Association Distributed and Multiprocessor Systems, </booktitle> <pages> pages 1-18, </pages> <month> Summer </month> <year> 1995. </year>
Reference-contexts: However, not all users of parallel architectures require such abstractions. For example, Bryant and co-workers described their experience with Fortran users of the IBM RP3 system <ref> [5] </ref>. These users regarded the operating system as an adversary bent on denying them direct access to the hardware. Similarly, developers of data management and persistent object stores need sophisticated use of caching, and allowing the application access to file-caching policies has been found to improve performance [6].
Reference: [6] <author> P. Cao, E. Felten, and K. Li. </author> <title> Application-controlled file caching policies. </title> <booktitle> In Proceedings of Usenix Association Conference, </booktitle> <pages> pages 171-182, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: These users regarded the operating system as an adversary bent on denying them direct access to the hardware. Similarly, developers of data management and persistent object stores need sophisticated use of caching, and allowing the application access to file-caching policies has been found to improve performance <ref> [6] </ref>. Many existing parallel language implementations multiplex their own process structure onto a smaller set of operating system-provided processes, where the operating system-provided process may run a user-level scheduler.
Reference: [7] <author> R. Draves. </author> <title> A revised ipc interface. </title> <booktitle> In Proceedings of Usenix Mach Symposium, </booktitle> <pages> pages 101-121, </pages> <year> 1990. </year>
Reference-contexts: Related work There are two ways in which user-level policy can be implemented: by providing a user-level server process or by providing a library of routines. Existing microkernels such as Mach and Chorus support user-provision of store, file and network management by user-level servers (e.g. <ref> [7] </ref> [11]). Microkernel systems can locate code in servers, and use an IPC mechanism to bind applications to that code. Although this allows some redefinition of management code outside the kernel, it requires process management and IPC support in the kernel.
Reference: [8] <author> D. Engler, M. Kaashoek, and J. O'Toole. Exokernel: </author> <title> An operating system architecture for application-level resource management. </title> <booktitle> In Proceeding of 15th ACM Symposium on Operating System Principles, </booktitle> <pages> pages 251-266, </pages> <year> 1995. </year>
Reference-contexts: This means that all scheduling policy decisions are in the user-level PM, in the realm of the application. More recent systems, which are similar to Arena in em-phasising user-level application-specific resource management, are PANDA [2] and Exokernel <ref> [8] </ref>. This latter paper coined the term `library operating system' to describe such systems. An alternative approach to application-orientated resource management is to allow the operating system kernel to be tailored [19] [3]. 7.
Reference: [9] <author> R. Ford, A. Nisbet, and J. Bull. </author> <title> User-level vsm optimization and its application. </title> <booktitle> Proceedings of 2nd International Workshop on Applied Parallel Computing. Lecture Notes in Computer Science, </booktitle> <volume> 1041 </volume> <pages> 223-232, </pages> <year> 1995. </year>
Reference-contexts: More `kernelised' general-purpose systems would not facilitate this. 5.3. Virtual shared memory for Fortran Work has been done on parallel Fortran using user-level VSM on a microkernel-based system running on an EDS machine <ref> [9] </ref>. It is intended to use the accessibility of the mechanisms provided by Arena to implement the primitives of a VSM framework [10] which will be incorporated into a Fortran compiler. As mentioned in Section 3.4, the Arena page fault handling thread can implement VSM.
Reference: [10] <author> R. Ford, A. Nisbet, and M. O'Boyle. </author> <title> A new hybrid coherence mechanism: compilation and application. </title> <note> 1996. In Preparation. </note>
Reference-contexts: Virtual shared memory for Fortran Work has been done on parallel Fortran using user-level VSM on a microkernel-based system running on an EDS machine [9]. It is intended to use the accessibility of the mechanisms provided by Arena to implement the primitives of a VSM framework <ref> [10] </ref> which will be incorporated into a Fortran compiler. As mentioned in Section 3.4, the Arena page fault handling thread can implement VSM. VSM implementation is based is the transferring of a virtual page between nodes, over a network, in response to a page fault in a virtually-shared region.
Reference: [11] <author> M. Guillemont, J. Lipkis, D. Orr, and M. Rozzier. </author> <title> A second-generation micro-kernel based unix; lessons in performance and compatibility. </title> <booktitle> In Proceedings of Usenix Association Conference, </booktitle> <pages> pages 13-21, </pages> <month> Winter </month> <year> 1991. </year>
Reference-contexts: Related work There are two ways in which user-level policy can be implemented: by providing a user-level server process or by providing a library of routines. Existing microkernels such as Mach and Chorus support user-provision of store, file and network management by user-level servers (e.g. [7] <ref> [11] </ref>). Microkernel systems can locate code in servers, and use an IPC mechanism to bind applications to that code. Although this allows some redefinition of management code outside the kernel, it requires process management and IPC support in the kernel.
Reference: [12] <author> B. Herrmann, M. Ortega, and L. Philippe. </author> <title> Unix on a multi-computer: The benefits of the chorus architecture. </title> <type> Technical Report CS/TR-91-46, </type> <institution> Chorus Systems, </institution> <year> 1991. </year>
Reference-contexts: Arena is a system being developed which takes this approach [16]. It emphasises individual application performance (though it is designed to allow multiple applications to run `concurrently' if required). 2. Background It has been argued (e.g. <ref> [12] </ref>) that operating systems for multicomputers should present an abstraction, a `single system image', to hide the physical machine architecture from users. However, not all users of parallel architectures require such abstractions. For example, Bryant and co-workers described their experience with Fortran users of the IBM RP3 system [5].
Reference: [13] <author> E. Lazowska. </author> <title> System support for high performance multiprocessing. </title> <booktitle> In Proceeding of the Usenix Association Symposium on Experiences with Distributed and Multiprocessor Systems, </booktitle> <pages> pages 1-11, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Although this allows some redefinition of management code outside the kernel, it requires process management and IPC support in the kernel. It has been argued that such systems provide insufficient flexibility for library and language implementors [18] <ref> [13] </ref>. Work on Psyche [14] and on scheduler activations [1] take thread scheduling out of the kernel by enabling the kernel to make `upcalls' to the user level. Threads on Arena exist only at user-level. There are no kernel threads, and no permanent kernel state for user-level threads [17].
Reference: [14] <author> B. Marsh, M. Scott, T. LeBlanc, and E. Markatos. </author> <title> First-class user-level threads. </title> <booktitle> In Proceeding of 13th ACM Symposium on Operating System Principles, </booktitle> <pages> pages 110-121, </pages> <year> 1991. </year>
Reference-contexts: Although this allows some redefinition of management code outside the kernel, it requires process management and IPC support in the kernel. It has been argued that such systems provide insufficient flexibility for library and language implementors [18] [13]. Work on Psyche <ref> [14] </ref> and on scheduler activations [1] take thread scheduling out of the kernel by enabling the kernel to make `upcalls' to the user level. Threads on Arena exist only at user-level. There are no kernel threads, and no permanent kernel state for user-level threads [17].
Reference: [15] <author> K. Mayes, J. Bridgland, S. Quick, and A. Nisbet. </author> <title> Network performance in arena. </title> <booktitle> Proceedings of High Performance Computing and Networking, Europe. Lecture Notes in Computer Science, </booktitle> <volume> 1067 </volume> <pages> 1007-1008, </pages> <year> 1996. </year>
Reference-contexts: Network performance in Arena, for user-level to user-level transfer of data, was measured to be faster than a microker-nel running on the EDS machine <ref> [15] </ref>. Both systems used user-level message buffers in the transfer, with no intermediate copying. Node 1 Node 2 DSM DPM disk DSSM CM network NWM disk interface DSSM CM NWM interface network interface interface tributed application. 5.
Reference: [16] <author> K. Mayes, S. Quick, J. Bridgland, and A. Nisbet. </author> <title> Language-and application-oriented resource management for parallel architectures. </title> <booktitle> In Proceeding of the 6th ACM SIGOPS Eu-ropean Workshop, </booktitle> <pages> pages 172-177, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: This paper describes a solution to this problem to provide a generic `hardware' interface which can reside on the nodes of the parallel machine and which can host the run-time operating system. Arena is a system being developed which takes this approach <ref> [16] </ref>. It emphasises individual application performance (though it is designed to allow multiple applications to run `concurrently' if required). 2. Background It has been argued (e.g. [12]) that operating systems for multicomputers should present an abstraction, a `single system image', to hide the physical machine architecture from users.
Reference: [17] <author> K. Mayes, S. Quick, and B. Warboys. </author> <title> User-level threads on a general hardware interface. </title> <journal> ACM SIGOPS Operating Systems Review, </journal> <volume> 29(4) </volume> <pages> 57-62, </pages> <year> 1995. </year>
Reference-contexts: Work on Psyche [14] and on scheduler activations [1] take thread scheduling out of the kernel by enabling the kernel to make `upcalls' to the user level. Threads on Arena exist only at user-level. There are no kernel threads, and no permanent kernel state for user-level threads <ref> [17] </ref>. This means that all scheduling policy decisions are in the user-level PM, in the realm of the application. More recent systems, which are similar to Arena in em-phasising user-level application-specific resource management, are PANDA [2] and Exokernel [8].
Reference: [18] <author> T. L. M.L. Scott and and B. Marsh. </author> <booktitle> Multi-model parallel programming in psyche. In Proceedings of the 2nd ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 70-78, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Although this allows some redefinition of management code outside the kernel, it requires process management and IPC support in the kernel. It has been argued that such systems provide insufficient flexibility for library and language implementors <ref> [18] </ref> [13]. Work on Psyche [14] and on scheduler activations [1] take thread scheduling out of the kernel by enabling the kernel to make `upcalls' to the user level. Threads on Arena exist only at user-level. There are no kernel threads, and no permanent kernel state for user-level threads [17].
Reference: [19] <author> B. Mukherjee and K. Schwan. </author> <title> Experimentation with a reconfigurable microkernel. </title> <booktitle> In Proceedings of the Usenix Association Symposium on Microkernels and other Kernel Architectures, </booktitle> <pages> pages 45-60, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: This latter paper coined the term `library operating system' to describe such systems. An alternative approach to application-orientated resource management is to allow the operating system kernel to be tailored <ref> [19] </ref> [3]. 7. Discussion Users of high performance parallel computers may wish to develop and link their applications directly on some node of the target machine (though this would seem to be unnecessary with a cross-compiler).
Reference: [20] <author> B. Mukherjee, K. Schwan, and P. Gopinath. </author> <title> A survey of multiprocessor operating system kernels. </title> <type> Technical report, </type> <institution> Georgia Institute of Technology, College of Computing, </institution> <year> 1993. </year>
Reference-contexts: This is the situation found in many real-time applications. Mukherjee and co-workers described such real-time systems using the term `operating software' in order to emphasise the intimate connection between real-time application and real-time operating system <ref> [20] </ref>. However, it is unreasonable to expect parallel application developers to write their own low-level, hardware-specific code. This paper describes a solution to this problem to provide a generic `hardware' interface which can reside on the nodes of the parallel machine and which can host the run-time operating system.
Reference: [21] <author> M. Papazoglou and W. Valder. </author> <title> Relational Database Management A Systems Programming Approach. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: Node 1 Node 2 DSM DPM disk DSSM CM network NWM disk interface DSSM CM NWM interface network interface interface tributed application. 5. Target application areas In order to demonstrate the usefulness of the Arena approach, several applications are being investigated. 5.1. Requiem database The Requiem relational database <ref> [21] </ref> has been ported to Arena. It runs on both EDS and PC platforms. The database is the target application for work on secondary storage management [4]. Requiem runs on a Unix system call interface.
Reference: [22] <author> D. Pierson. </author> <title> Integrating parallel lisp with modern unix-based operating systems. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 441 </volume> <pages> 312-315, </pages> <year> 1989. </year>
Reference-contexts: There are many problems associated with building a language on a conventional operating system platform due to mismatches between operating system process model and the requirements of the language <ref> [22] </ref>. The problem then, for high performance systems, is how to empower the application writer and language developer so that they can safely access the hardware mechanisms, and control the policy of resource management which is traditionally locked into the operating system kernel.
Reference: [23] <author> S. </author> <title> Quick. A generalised hardware interface for operating systems. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, </institution> <year> 1996. </year>
Reference-contexts: Hardware Object The HWO is essentially a run-time executive which provides a primitive machine interface to the resource managers. This interface presents a generalised view of processor hardware, so that porting of the system to various hardware platforms is facilitated <ref> [23] </ref>. The HWO interface provides a set of downcalls which is used by the hardware-independent, user-level, manager code. There are, at present, 34 primitives in the HWO interface (Figure 2), not including any device-specific interface primitives.
Reference: [24] <editor> J. Sargeant. </editor> <booktitle> Uniting functional and object-oriented programming. International Symposium on Object Technologies for Advanced Software. Lecture Notes in Computer Science, </booktitle> <volume> 742 </volume> <pages> 1-26, </pages> <year> 1993. </year>
Reference-contexts: Initial results indicate that performance of the two systems is similar using a flush-back policy. However with a more realistic write-through policy, Arena out-performs Linux by a factor of 1.6. 5.2. UFO language Arena is intended to support parallel languages. Investigations into running the parallel UFO language <ref> [24] </ref> on Arena are in progress. Current work is using a distributed PM and CM to investigate a multi-nodal implementation on the EDS machine. The distributed PM allows remote creation of threads.
Reference: [25] <author> M. Ward and P. Townsend. </author> <title> Eds hardware architecture. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 457 </volume> <pages> 816-827, </pages> <year> 1990. </year>
Reference-contexts: All the hardware-dependent code for manipulating the hardware resides in a `nanokernel', or run-time executive, which is accessed by a generic low-level interface. Having a general low-level interface facilitates system portability. Arena has been implemented on the EDS <ref> [25] </ref> Sparc and PC-AT Intel 3/486 architectures. Application Run-time System Hardware User-level O.S. ARENA Hardware Object Application Run-time System O.S. Kernel Hardware MONOLITHIC O.S. based components are shaded. 3.1. Arena structure The basic structure of Arena is shown in Figure 2. There are basically two components. <p> Arena has been implemented for execution on multiprocessor platforms, although this aspect is not emphasised, and has not yet been tested. Arena does however already run on a distributed store multicomputer. The EDS machine <ref> [25] </ref> has nodes connected by an internal deltanet. Each node consists of two Sparc processors sharing 64 Mb of store. Only one of these Sparcs receives the network interrupts, and at present Arena runs only on that processor on each node.
Reference: [26] <author> W. Wulf, E. Cohen, W. Corwin, A. Jones, R. Levin, C. Pier-son, and F. Pollack. Hydra: </author> <title> The kernel of a multiprocessor operating system. </title> <journal> cacm, </journal> <volume> 17(6) </volume> <pages> 337-345, </pages> <year> 1974. </year>
Reference-contexts: The key here is to separate operating system policy from mechanism. The desirability of separating policy from mechanism has been recognised for some time, and was a motivating force in the design of the Hydra operating system <ref> [26] </ref>. A trend in operating system work has been to move policy out of the supervisor-mode kernel and into the realm of the user. That is, to put policy at user-level.
References-found: 26

