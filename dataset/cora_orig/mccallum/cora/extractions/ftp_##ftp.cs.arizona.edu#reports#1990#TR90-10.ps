URL: ftp://ftp.cs.arizona.edu/reports/1990/TR90-10.ps
Refering-URL: http://www.cs.arizona.edu/research/reports.html
Root-URL: http://www.cs.arizona.edu
Title: Programming in Idol: An Object Primer  
Author: Clinton L. Jeffery TR -c 
Address: Tucson, AZ 85721  
Affiliation: Department of Computer Science The University of Arizona  
Date: 25, 1990; Last revised August 4, 1992  
Note: January  
Abstract: Idol is an objectoriented extension and environment for the Icon programming language. This document describes Idol in two parts. The first part presents Idol's objectoriented programming concepts as an integral tool with which a programmer maps a good program design into a good implementation. As such, it serves as the user's guide for Idol's extensions to Icon. Idol's objectoriented programming facilities are viewed within the broader framework of structured programming and modular design in general. Idol's precise syntax and semantics are detailed in the second part, An Icon-Derived Object Language, which serves as a reference manual. 
Abstract-found: 1
Intro-found: 1
Reference: [Gris87] <author> Griswold, R. E. </author> <title> Programming in Icon; Part IIProgramming with Co-Expressions. </title> <type> Technical Report 87-6, </type> <institution> Department of Computer Science, University of Arizona, </institution> <month> June </month> <year> 1987. </year>
Reference-contexts: The use of objects also is a significant alternative for implementations of Icon in which co-expressions are not available or memory is limited. 10 Parallel Evaluation In <ref> [Gris87] </ref>, co-expressions are used to obtain the results from several generators in parallel: decimal := create (0 to 255) hex := create (!"0123456789ABCDEF" jj !"0123456789ABCDEF") octal := create ((0 to 3) jj (0 to 7) jj (0 to 7)) character := create (image (!&cset)) while write (right (@decimal, 3), " ", <p> Since the sequence class is already written and available, its use is an attractive alternative to co-expressions in many settings. For example, a general class of label generators (another use of co-expressions cited in <ref> [Gris87] </ref>) is defined by the following library class: class labelgen : Sequence (prefix,postfix) method activate () return $.prefixjjself$Sequence.activatejj$.postfix end initially /($.prefix) := "" /($.postfix) := "" /($.bounds) := [50000] self$Sequence.initially () end After creation of a label generator object (e.g. label := labelgen ("L",":")), each resulting label is obtained via $@label.
Reference: [Gris90] <author> Griswold, R. E. and Griswold, M. T. </author> <title> The Icon Programming Language, second edition. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1990. </year>
Reference-contexts: C++ has neither of these flaws, but the same low-level machine-oriented character that makes it efficient also makes C++ less than ideal as an algorithmic notation usable by nonexperts. Idol owes most of its desirable traits to its foundation, the Icon programming language, developed at the University of Arizona <ref> [Gris90] </ref>. In fact, Idol presents objects simply as a tool to aid in the writing of Icon programs. Idol integrates a concise, robust notation for objectoriented programming into a language considerably more advanced than C or Pascal. Icon already uses a powerful notation for expressing a general class of algorithms.
Reference: [Walk86] <author> Walker, K. </author> <title> Dynamic EnvironmentsA Generalization of Icon String Scanning. </title> <type> Technical Report 86-7, </type> <institution> Department of Computer Science, University of Arizona, </institution> <month> March </month> <year> 1986. </year> <month> 22 </month>
Reference-contexts: In an Icon scanning expression of the form e1 ? e2, the result of evaluating e1 is used implicitly in e2 via 8 a variety of scanning functions. In effect, the scanning operation defines a scope in which state variables &subject and &pos are redefined. <ref> [Walk86] </ref> proposes an extension to Icon allowing programmer-defined scanning environments. The extension involves a new record data type augmented by sections of code to be executed upon entry, resumption, and exit of the scanning environment.
References-found: 3

