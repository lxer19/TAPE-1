URL: http://www.tns.lcs.mit.edu/~djw/library/osdi96/mosberger.ps.gz
Refering-URL: http://www.tns.lcs.mit.edu/~djw/library/osdi96/index.html
Root-URL: 
Email: Email: office@usenix.org  
Title: Making Paths Explicit in the Scout Operating System  
Phone: 1. Phone: 510 528-8649 2. FAX: 510 548-5738 3.  4.  
Author: David Mosberger and Larry L. Peterson 
Affiliation: University of Arizona  
Web: WWW URL: http://www.usenix.org  
Date: October 1996  
Note: The following paper was originally published in the Proceedings of the USENIX 2nd Symposium on Operating Systems Design and Implementation Seattle, Washington,  For more information about USENIX Association contact:  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> M. B. Abbott and L. L. Peterson. </author> <title> Increasing network throughput by integrating protocol layers. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 1(5) </volume> <pages> 600-610, </pages> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: efficiently move data across a sequence of protection domains. 2 Fbufs depend on being able to identify the path through the system over which the data will flow. 2 Although layering does not imply multiple protection domains, systems often impose hardware-enforced protection at layer boundaries. * Integrated layer processing (ILP) <ref> [4, 1] </ref> is a tech-nique for fusing the data manipulation loops of multiple protocol layers. It depends on knowing exactly what sequence of protocol modules a network packet will traverse. * Packet classifiers [31, 20, 2, 8] distinguish among incoming network packets based on certain fields found in their headers. <p> This related work falls broadly into two categories, depending on their primary objective: * optimizing code along the fast path, or * improving resource management. Examples of fast path optimizations include Synthesis [19], Synthetix [24], PathIDs [17], Protocol Accelerators [29], and integrated layer processing <ref> [4, 1] </ref>. Examples in the second category include processor capacity reserves [21], distributed/migrating threads [5, 9], and Rialto activities [16].
Reference: [2] <author> M. L. Bailey, B. Gopal, M. A. Pagels, L. L. Peterson, and P. Sarkar. PathFinder: </author> <title> A pattern-based packet classifier. </title> <booktitle> In Proc. of the 1st Symp. on Operating Systems Design and Implementation, </booktitle> <pages> pages 115-123, </pages> <year> 1994. </year>
Reference-contexts: It depends on knowing exactly what sequence of protocol modules a network packet will traverse. * Packet classifiers <ref> [31, 20, 2, 8] </ref> distinguish among incoming network packets based on certain fields found in their headers. In a sense, a packet classifier pre-computes the path that a given message will follow. * Specialization is sometimes used to optimize common path code sequences [24, 23]. <p> Since a path enters a router at one service and leaves it through another, a stage effectively connects a pair of services. That is, it represents a fixed routing decision. A stage is a rich object that contains at least the following members: struct Stage f Iface end <ref> [2] </ref>; Path path; Router router; long (*establish)(Stage s, Attrs a); void (*destroy)(Stage s); g; Member end is an array containing pointers to the interfaces of the stage. These interfaces are derived from the services that a stage connects in a manner that will be explained below. <p> Given the definition of stages and interfaces, it is now easy to describe the actual path object: struct Path f Stage end <ref> [2] </ref>; long pid; void (*wakeup)(Path p, Thread t); PathQueue q [4]; struct Attrs attrs; g; The array end contains two pointers to the stages at the extreme ends of the path. <p> For the purposes of Scout, it is acceptable to hand off IP fragments to a path that knows how to reassemble the fragments. Once the full datagram is available, the IP protocol can rerun the classifier to find the next path. Many packet classifiers have been proposed (e.g., <ref> [31, 20, 2, 8] </ref>), but none of them address all of the Scout requirements satisfactorily. For this reason, Scout adopted the simple solution of requiring each router to provide a function that performs a classification. Any given router typically implements only a small portion of the entire classification process.
Reference: [3] <author> R. Braden, D. Clark, and S. Shenker. RFC-1633: </author> <title> Integrated services in the Internet architecture: an overview. </title> <note> Available at ftp://ftp.internic.net/rfc, </note> <month> July </month> <year> 1994. </year>
Reference-contexts: A complete analysis is beyond the scope of this paper. In general, bounding the size of this queue requires cooperation with admission control and would typically employ a network reservation system, such as RSVP <ref> [3] </ref>. The current implementation leaves this parameter under user control to facilitate experimentation. 4.3 Scheduling Since each video path has its own input queue and since the packet classifier is run at interrupt time, newly arriving packets are immediately placed in the correct queue.
Reference: [4] <author> D. Clark and D. Tennenhouse. </author> <title> Architectural considerations for a new generation of protocols. </title> <booktitle> In Proc. of SIG-COMM '90 Symp., </booktitle> <pages> pages 200-208, </pages> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: efficiently move data across a sequence of protection domains. 2 Fbufs depend on being able to identify the path through the system over which the data will flow. 2 Although layering does not imply multiple protection domains, systems often impose hardware-enforced protection at layer boundaries. * Integrated layer processing (ILP) <ref> [4, 1] </ref> is a tech-nique for fusing the data manipulation loops of multiple protocol layers. It depends on knowing exactly what sequence of protocol modules a network packet will traverse. * Packet classifiers [31, 20, 2, 8] distinguish among incoming network packets based on certain fields found in their headers. <p> Given the definition of stages and interfaces, it is now easy to describe the actual path object: struct Path f Stage end [2]; long pid; void (*wakeup)(Path p, Thread t); PathQueue q <ref> [4] </ref>; struct Attrs attrs; g; The array end contains two pointers to the stages at the extreme ends of the path. A path can set the wakeup function pointer to request that a specific function gets executed when a thread t is awakened to execute in a path p. <p> The MPEG router accepts messages from MFLOW, applies the MPEG decompression algorithm to them, and sends the decoded images to the DISPLAY router. There, the images are queued for display at the appropriate time. The MPEG router uses application-level framing (ALF) <ref> [4] </ref> to minimize internal buffering. That is, the MPEG source sends Ethernet MTU-sized packets that contain an integral number of work-units (MPEG macroblocks). This ensures that the MPEG decoder does not have to maintain complex state across packet boundaries and obviates the need for undesirable queueing between MPEG and MFLOW. <p> This related work falls broadly into two categories, depending on their primary objective: * optimizing code along the fast path, or * improving resource management. Examples of fast path optimizations include Synthesis [19], Synthetix [24], PathIDs [17], Protocol Accelerators [29], and integrated layer processing <ref> [4, 1] </ref>. Examples in the second category include processor capacity reserves [21], distributed/migrating threads [5, 9], and Rialto activities [16].
Reference: [5] <author> R. K. Clark, E. D. Jensen, and F. D. Reynolds. </author> <title> An architectural overview of the Alpha real-time distributed kernel. </title> <booktitle> In 1993 Winter USENIX Conf., </booktitle> <pages> pages 127-146, </pages> <month> Apr. </month> <year> 1993. </year>
Reference-contexts: Specialization, in turn, depends on the existence of invariants that constrain the path through the code that is likely to be executed. * The Alpha OS allows threads to migrate across a sequence of protection domains <ref> [5] </ref>; others have defined similar mechanisms [13, 9]. Such mechanisms recognize that tasks often span multiple domains, and so account for resource usage on a path basis rather than a domain basis. <p> Examples of fast path optimizations include Synthesis [19], Synthetix [24], PathIDs [17], Protocol Accelerators [29], and integrated layer processing [4, 1]. Examples in the second category include processor capacity reserves [21], distributed/migrating threads <ref> [5, 9] </ref>, and Rialto activities [16]. Because space does not permit us to contrast all of this work in detail, we simply point out that the path abstraction as presented in this paper is an attempt at unifying these various ideas.
Reference: [6] <author> P. Druschel and L. L. Peterson. Fbufs: </author> <title> A high-bandwidth cross-domain transfer facility. </title> <booktitle> In Proc. of the 14th ACM Symp. on Operating System Principles, </booktitle> <pages> pages 189-202, </pages> <month> Dec. </month> <year> 1993. </year> <note> ACM. </note>
Reference-contexts: Finally, paths can be loosely understood by considering specific OS mechanisms that have been proposed over the last few years. Consider the following examples. * Fbufs <ref> [6] </ref> are a path-oriented buffer management mechanism designed to efficiently move data across a sequence of protection domains. 2 Fbufs depend on being able to identify the path through the system over which the data will flow. 2 Although layering does not imply multiple protection domains, systems often impose hardware-enforced protection
Reference: [7] <author> P. Druschel, L. L. Peterson, and B. S. Davie. </author> <title> Experiences with a high-speed network adaptor: A software perspective. </title> <booktitle> In Proc. of SIGCOMM '94 Symp., </booktitle> <pages> pages 2-13, </pages> <month> Aug. </month> <year> 1994. </year>
Reference-contexts: Kay [17] introduces the notion of a PathID, which is designed specifically to reduce the latency of receive-side network processing. Fundamentally, a PathID is similar to a fine-grained virtual circuit identifier (VCI) in ATM networks <ref> [7] </ref>. Since PathIDs are stored in a known location in the header of network messages, packet classification becomes trivial (in the worst case a table-lookup). In [17], packets with a PathID are processed by highly optimized, handwritten code.
Reference: [8] <author> D. Engler and M. F. Kaashoek. DPF: </author> <title> Fast, flexible message demultiplexing using dynamic code generation. </title> <booktitle> In Proc. of SIGCOMM '96 Symp., </booktitle> <pages> pages 53-59, </pages> <month> Aug. </month> <year> 1996. </year>
Reference-contexts: It depends on knowing exactly what sequence of protocol modules a network packet will traverse. * Packet classifiers <ref> [31, 20, 2, 8] </ref> distinguish among incoming network packets based on certain fields found in their headers. In a sense, a packet classifier pre-computes the path that a given message will follow. * Specialization is sometimes used to optimize common path code sequences [24, 23]. <p> For the purposes of Scout, it is acceptable to hand off IP fragments to a path that knows how to reassemble the fragments. Once the full datagram is available, the IP protocol can rerun the classifier to find the next path. Many packet classifiers have been proposed (e.g., <ref> [31, 20, 2, 8] </ref>), but none of them address all of the Scout requirements satisfactorily. For this reason, Scout adopted the simple solution of requiring each router to provide a function that performs a classification. Any given router typically implements only a small portion of the entire classification process.
Reference: [9] <author> B. Ford and J. Lepreau. </author> <title> Evolving Mach 3.0 to a migrating thread model. </title> <booktitle> In 1994 Winter USENIX Conf., </booktitle> <pages> pages 97-114, </pages> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: Specialization, in turn, depends on the existence of invariants that constrain the path through the code that is likely to be executed. * The Alpha OS allows threads to migrate across a sequence of protection domains [5]; others have defined similar mechanisms <ref> [13, 9] </ref>. Such mechanisms recognize that tasks often span multiple domains, and so account for resource usage on a path basis rather than a domain basis. <p> Examples of fast path optimizations include Synthesis [19], Synthetix [24], PathIDs [17], Protocol Accelerators [29], and integrated layer processing [4, 1]. Examples in the second category include processor capacity reserves [21], distributed/migrating threads <ref> [5, 9] </ref>, and Rialto activities [16]. Because space does not permit us to contrast all of this work in detail, we simply point out that the path abstraction as presented in this paper is an attempt at unifying these various ideas.
Reference: [10] <author> J. Gosling, F. Yellin, </author> <title> and The Java Team. The Java Application Programming Interface. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1996. </year>
Reference-contexts: However, it is possible to configure an interpreter into the router graph, thereby supporting extensibility. For example, we are currently implementing the Java API (and interpreter) in Scout <ref> [10] </ref>. This will make it possible to download Java applications into Scout at runtime. 4 Demonstration Application This section demonstrates the use and benefits of paths with a simple, but realistic application implemented in Scout. The application consists of receiving, decoding, and displaying MPEG encoded video streams.
Reference: [11] <author> A. Gotti. </author> <title> The Da CaPo communication system. </title> <type> Technical report, </type> <institution> ETHZ, Switzerland, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: The rest of this section discusses the related work we consider most relevant in more detail. The system that is probably closest to Scout, at least in terminology, is Da CaPo (dynamic configuration of protocols) <ref> [11] </ref>. It defines an infrastructure for building multimedia protocols. While Da CaPo has a notion of paths and stages, there are important differences at all levels. At lowest level, Da CaPo paths are uni-directional and stages have very restricted functionality (they are essentially non-blocking event-handlers).
Reference: [12] <author> A. Habermann, L. Flon, and L. Cooprider. </author> <title> Modularization and hierarchy in a family of operating systems. </title> <journal> Communications of the ACM, </journal> <volume> 19(5) </volume> <pages> 266-272, </pages> <month> May </month> <year> 1976. </year>
Reference-contexts: 1 Introduction Layering is a fundamental structuring technique with a long history in system design. From early work on layered operating systems and network architectures <ref> [12, 32] </ref>, to more recent advances in stackable systems [27, 15, 14, 26], layering has played a central role in managing complexity, isolating failure, and enhancing configurabil-ity. This paper describes a complementary, but equally fundamental structuring technique, which we call paths.
Reference: [13] <author> G. Hamilton and P. Kougiouris. </author> <title> The Spring nucleus: a microkernel for objects. </title> <booktitle> In Proc. of the Summer 1993 USENIX Conf., </booktitle> <pages> pages 147-159, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Specialization, in turn, depends on the existence of invariants that constrain the path through the code that is likely to be executed. * The Alpha OS allows threads to migrate across a sequence of protection domains [5]; others have defined similar mechanisms <ref> [13, 9] </ref>. Such mechanisms recognize that tasks often span multiple domains, and so account for resource usage on a path basis rather than a domain basis.
Reference: [14] <author> J. S. Heidemann and G. J. Popek. </author> <title> File-system development with stackable layers. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 12(1) </volume> <pages> 58-89, </pages> <month> Feb. </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Layering is a fundamental structuring technique with a long history in system design. From early work on layered operating systems and network architectures [12, 32], to more recent advances in stackable systems <ref> [27, 15, 14, 26] </ref>, layering has played a central role in managing complexity, isolating failure, and enhancing configurabil-ity. This paper describes a complementary, but equally fundamental structuring technique, which we call paths.
Reference: [15] <author> N. C. Hutchinson and L. L. Peterson. </author> <title> The x-kernel: An architecture for implementing network protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-76, </pages> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Layering is a fundamental structuring technique with a long history in system design. From early work on layered operating systems and network architectures [12, 32], to more recent advances in stackable systems <ref> [27, 15, 14, 26] </ref>, layering has played a central role in managing complexity, isolating failure, and enhancing configurabil-ity. This paper describes a complementary, but equally fundamental structuring technique, which we call paths.
Reference: [16] <author> M. Jones, P. Leach, R. Draves, and J. Barrera. </author> <title> Support for user-centric modular real-time resource management in the Rialto operating system. </title> <booktitle> In Proc. of the 5th Intl. Workshop on Network and OS Support for Digital Audio and Video, </booktitle> <pages> pages 55-66, </pages> <month> Apr. </month> <year> 1995. </year> <note> ACM. </note>
Reference-contexts: Examples of fast path optimizations include Synthesis [19], Synthetix [24], PathIDs [17], Protocol Accelerators [29], and integrated layer processing [4, 1]. Examples in the second category include processor capacity reserves [21], distributed/migrating threads [5, 9], and Rialto activities <ref> [16] </ref>. Because space does not permit us to contrast all of this work in detail, we simply point out that the path abstraction as presented in this paper is an attempt at unifying these various ideas.
Reference: [17] <author> J. S. Kay. </author> <title> Path IDs: A Mechanism for Reducing Network Software Latency. </title> <type> PhD thesis, </type> <institution> University of California, </institution> <address> San Diego, </address> <year> 1995. </year>
Reference-contexts: This related work falls broadly into two categories, depending on their primary objective: * optimizing code along the fast path, or * improving resource management. Examples of fast path optimizations include Synthesis [19], Synthetix [24], PathIDs <ref> [17] </ref>, Protocol Accelerators [29], and integrated layer processing [4, 1]. Examples in the second category include processor capacity reserves [21], distributed/migrating threads [5, 9], and Rialto activities [16]. <p> In contrast, our path abstraction makes it easy to exploit both local and global knowledge during path creation. At a higher level, Da CaPo focuses completely on automatically selecting appropriate protocol functionality; performance and resource allocation appear to be secondary issues. Kay <ref> [17] </ref> introduces the notion of a PathID, which is designed specifically to reduce the latency of receive-side network processing. Fundamentally, a PathID is similar to a fine-grained virtual circuit identifier (VCI) in ATM networks [7]. <p> Fundamentally, a PathID is similar to a fine-grained virtual circuit identifier (VCI) in ATM networks [7]. Since PathIDs are stored in a known location in the header of network messages, packet classification becomes trivial (in the worst case a table-lookup). In <ref> [17] </ref>, packets with a PathID are processed by highly optimized, handwritten code. Since this code is manually tuned, maintainability and ease of use are problematic.
Reference: [18] <author> C. L. Liu and J. W. Layland. </author> <title> Scheduling algorithms for multiprogramming in a hard-real-time environment. </title> <journal> Journal of the ACM, </journal> <volume> 1(20) </volume> <pages> 46-61, </pages> <month> Jan. </month> <year> 1973. </year>
Reference-contexts: Scout supports an arbitrary number of scheduling policies, and allocates a percentage of CPU time to each. The minimum share that each policy gets is determined by a system-tunable parameter. Two scheduling policies have been implemented to date: (1) fixed-priority round-robin, and (2) earliest-deadline first (EDF) <ref> [18] </ref>. The reason for implementing the EDF policy is that for many soft-realtime applications, it is most natural to express a path's priority in terms of a deadline. We present an example of this in the next section.
Reference: [19] <author> H. Massalin. </author> <title> Synthesis: An Efficient Implementation of Fundamental Operating System Services. </title> <type> PhD thesis, </type> <institution> Columbia University, </institution> <address> New York, NY, </address> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: This related work falls broadly into two categories, depending on their primary objective: * optimizing code along the fast path, or * improving resource management. Examples of fast path optimizations include Synthesis <ref> [19] </ref>, Synthetix [24], PathIDs [17], Protocol Accelerators [29], and integrated layer processing [4, 1]. Examples in the second category include processor capacity reserves [21], distributed/migrating threads [5, 9], and Rialto activities [16].
Reference: [20] <author> S. McCanne and V. Jacobson. </author> <title> The BSD packet filter: A new architecture for user-level packet capture. </title> <booktitle> In 1993 Winter USENIX Conf., </booktitle> <pages> pages 259-269, </pages> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: It depends on knowing exactly what sequence of protocol modules a network packet will traverse. * Packet classifiers <ref> [31, 20, 2, 8] </ref> distinguish among incoming network packets based on certain fields found in their headers. In a sense, a packet classifier pre-computes the path that a given message will follow. * Specialization is sometimes used to optimize common path code sequences [24, 23]. <p> For the purposes of Scout, it is acceptable to hand off IP fragments to a path that knows how to reassemble the fragments. Once the full datagram is available, the IP protocol can rerun the classifier to find the next path. Many packet classifiers have been proposed (e.g., <ref> [31, 20, 2, 8] </ref>), but none of them address all of the Scout requirements satisfactorily. For this reason, Scout adopted the simple solution of requiring each router to provide a function that performs a classification. Any given router typically implements only a small portion of the entire classification process.
Reference: [21] <author> C. W. Mercer, S. Savage, and H. Tokuda. </author> <title> Processor capacity reserves: An abstraction for managing processor usage. </title> <booktitle> In Proc. of the 4th Workshop on Workstation Operating Systems (WWOS-IV), </booktitle> <pages> pages 129-134, </pages> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: Examples of fast path optimizations include Synthesis [19], Synthetix [24], PathIDs [17], Protocol Accelerators [29], and integrated layer processing [4, 1]. Examples in the second category include processor capacity reserves <ref> [21] </ref>, distributed/migrating threads [5, 9], and Rialto activities [16]. Because space does not permit us to contrast all of this work in detail, we simply point out that the path abstraction as presented in this paper is an attempt at unifying these various ideas.
Reference: [22] <author> J. C. Mogul and K. K. Ramakrishnan. </author> <title> Eliminating receive livelock in an interrupt-driven kernel. </title> <booktitle> In 1996 Winter USENIX Conf., </booktitle> <pages> pages 99-112, </pages> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: Clearly, the early separation afforded by paths can have significant benefits. This is not to say that paths are the only way to solve this particular problem (e.g., <ref> [22] </ref>), but it does support our claim that paths can be an effective solution to such problems.
Reference: [23] <author> D. Mosberger, L. Peterson, P. Bridges, and S. O'Malley. </author> <title> Analysis of techniques to improve protocol latency. </title> <booktitle> In Proc. of SIGCOMM '96 Symp., </booktitle> <pages> pages 73-84, </pages> <month> Sept. </month> <year> 1996. </year>
Reference-contexts: In a sense, a packet classifier pre-computes the path that a given message will follow. * Specialization is sometimes used to optimize common path code sequences <ref> [24, 23] </ref>. Specialization, in turn, depends on the existence of invariants that constrain the path through the code that is likely to be executed. * The Alpha OS allows threads to migrate across a sequence of protection domains [5]; others have defined similar mechanisms [13, 9]. <p> In particular, Section 4 describes an application that receives MPEG-compressed video over a network and then decodes and displays it. A companion paper demonstrates some of the code-related improvements attributable to paths <ref> [23] </ref>. 2 Path Abstraction While it is tempting to view paths as an optimization that can be super-imposed on an existing layered system and it is certainly the case that many of the ideas described in this paper can be applied in this waywe take a more first principles approach to <p> For example, if a path contains a sequence of interfaces for which there is optimized code is available, then the function pointers in the interfaces can be updated to point to this optimized code. More details on such code-related path-transformations can be found in a companion paper <ref> [23] </ref>. Section 4 discusses some transformations that improve resource management. When a Scout system boots, there are typically a few routers that create a handful of paths, e.g., to receive key strokes or network packets. All other paths are either directly or indirectly created by these initial paths.
Reference: [24] <author> C. Pu et al. </author> <title> Optimistic incremental specialization: Streamlining a commercial operating system. </title> <booktitle> In Proc. of the 15th ACM Symp. on Operating System Principles, </booktitle> <pages> pages 314-324, </pages> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: In a sense, a packet classifier pre-computes the path that a given message will follow. * Specialization is sometimes used to optimize common path code sequences <ref> [24, 23] </ref>. Specialization, in turn, depends on the existence of invariants that constrain the path through the code that is likely to be executed. * The Alpha OS allows threads to migrate across a sequence of protection domains [5]; others have defined similar mechanisms [13, 9]. <p> This related work falls broadly into two categories, depending on their primary objective: * optimizing code along the fast path, or * improving resource management. Examples of fast path optimizations include Synthesis [19], Synthetix <ref> [24] </ref>, PathIDs [17], Protocol Accelerators [29], and integrated layer processing [4, 1]. Examples in the second category include processor capacity reserves [21], distributed/migrating threads [5, 9], and Rialto activities [16].
Reference: [25] <author> D. D. Redell et al. </author> <title> Pilot: an operating system for a personal computer. </title> <journal> Communications of the ACM, </journal> <volume> 23(2) </volume> <pages> 81-92, </pages> <month> Feb. </month> <year> 1980. </year>
Reference-contexts: This avoids wasting CPU cycles at a time when they are at a premium. 5 Related Work At a superficial level, Scout paths are similar to UNIX pipes [28] and Pilot streams <ref> [25] </ref>. While all three abstractions have in common a linear sequence of components (processes in UNIX, Mesa modules in Pilot, stages in Scout), neither pipes nor streams provide any global context to the individual modules. Neither do they attempt to optimize the code along a path.
Reference: [26] <author> R. V. Renesse, K. Birman, R. Friedman, M. Hayden, and D. Karr. </author> <title> A framework for protocol composition in Ho-rus. </title> <booktitle> In Proc. of the 14th ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pages 80-89, </pages> <month> Aug. </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Layering is a fundamental structuring technique with a long history in system design. From early work on layered operating systems and network architectures [12, 32], to more recent advances in stackable systems <ref> [27, 15, 14, 26] </ref>, layering has played a central role in managing complexity, isolating failure, and enhancing configurabil-ity. This paper describes a complementary, but equally fundamental structuring technique, which we call paths.
Reference: [27] <author> D. M. Ritchie. </author> <title> A stream input-output system. </title> <journal> AT&T Bell Laboratories Technical Journal, </journal> <volume> 63(8) </volume> <pages> 311-324, </pages> <month> Oct. </month> <year> 1984. </year>
Reference-contexts: 1 Introduction Layering is a fundamental structuring technique with a long history in system design. From early work on layered operating systems and network architectures [12, 32], to more recent advances in stackable systems <ref> [27, 15, 14, 26] </ref>, layering has played a central role in managing complexity, isolating failure, and enhancing configurabil-ity. This paper describes a complementary, but equally fundamental structuring technique, which we call paths.
Reference: [28] <author> D. M. Ritchie and K. Thompson. </author> <title> The UNIX time-sharing system. </title> <journal> Communications of the ACM, </journal> <volume> 17(7) </volume> <pages> 365-375, </pages> <month> July </month> <year> 1974. </year>
Reference-contexts: This avoids wasting CPU cycles at a time when they are at a premium. 5 Related Work At a superficial level, Scout paths are similar to UNIX pipes <ref> [28] </ref> and Pilot streams [25]. While all three abstractions have in common a linear sequence of components (processes in UNIX, Mesa modules in Pilot, stages in Scout), neither pipes nor streams provide any global context to the individual modules. Neither do they attempt to optimize the code along a path.
Reference: [29] <author> R. van Renesse. </author> <title> Masking the overhead of protocol layering. </title> <booktitle> In Proc. of SIGCOMM '96 Symp., </booktitle> <volume> volume 26, </volume> <pages> pages 96-104, </pages> <address> Stanford, CA, </address> <month> Aug. </month> <year> 1996. </year> <note> ACM. </note>
Reference-contexts: This related work falls broadly into two categories, depending on their primary objective: * optimizing code along the fast path, or * improving resource management. Examples of fast path optimizations include Synthesis [19], Synthetix [24], PathIDs [17], Protocol Accelerators <ref> [29] </ref>, and integrated layer processing [4, 1]. Examples in the second category include processor capacity reserves [21], distributed/migrating threads [5, 9], and Rialto activities [16].
Reference: [30] <author> R. Wahbe, S. Lucco, T. Anderson, and S. Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In Proc. of the 14th ACM Symp. on Operating System Principles, </booktitle> <pages> pages 203-216, </pages> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: There are many other aspects of Scout that space does not permit us to describe; most of them are orthogonal to paths. For example, we believe software-based fault isolation (SFI) <ref> [30] </ref> could be imposed on top of paths by defining each router to be in a separate fault domain. Similarly, hardware-enforced protection could be imposed between paths.
Reference: [31] <author> M. Yuhara, B. N. Bershad, C. Maeda, and J. E. B. Moss. </author> <title> Efficient packet demultiplexing for multiple endpoints and large messages. </title> <booktitle> In 1994 Winter USENIX Conf., </booktitle> <pages> pages 153-165, </pages> <year> 1994. </year>
Reference-contexts: It depends on knowing exactly what sequence of protocol modules a network packet will traverse. * Packet classifiers <ref> [31, 20, 2, 8] </ref> distinguish among incoming network packets based on certain fields found in their headers. In a sense, a packet classifier pre-computes the path that a given message will follow. * Specialization is sometimes used to optimize common path code sequences [24, 23]. <p> For the purposes of Scout, it is acceptable to hand off IP fragments to a path that knows how to reassemble the fragments. Once the full datagram is available, the IP protocol can rerun the classifier to find the next path. Many packet classifiers have been proposed (e.g., <ref> [31, 20, 2, 8] </ref>), but none of them address all of the Scout requirements satisfactorily. For this reason, Scout adopted the simple solution of requiring each router to provide a function that performs a classification. Any given router typically implements only a small portion of the entire classification process.
Reference: [32] <author> H. Zimmermann. </author> <title> OSI reference modelthe ISO model of architecture for open systems interconnection. </title> <journal> IEEE Transactions on Communications, </journal> <volume> COM-28(4):425-432, </volume> <month> Apr. </month> <year> 1980. </year>
Reference-contexts: 1 Introduction Layering is a fundamental structuring technique with a long history in system design. From early work on layered operating systems and network architectures <ref> [12, 32] </ref>, to more recent advances in stackable systems [27, 15, 14, 26], layering has played a central role in managing complexity, isolating failure, and enhancing configurabil-ity. This paper describes a complementary, but equally fundamental structuring technique, which we call paths.
References-found: 32

