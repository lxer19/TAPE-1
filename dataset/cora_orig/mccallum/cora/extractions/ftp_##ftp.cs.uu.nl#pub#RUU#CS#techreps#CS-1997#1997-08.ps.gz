URL: ftp://ftp.cs.uu.nl/pub/RUU/CS/techreps/CS-1997/1997-08.ps.gz
Refering-URL: http://www.cs.ruu.nl/docs/research/publication/TechList1.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: e-mail: hansz@cs.ruu.nl  
Title: Termination of context-sensitive rewriting  
Author: H. Zantema 
Address: P.O. box 80.089, 3508 TB Utrecht, The Netherlands  
Affiliation: Utrecht University, Department of Computer Science,  
Abstract: Context-sensitive term rewriting is a kind of term rewriting in which reduction is not allowed inside some fixed arguments of some function symbols. We introduce two new techniques for proving termination of context-sensitive rewriting. The first one is a modification of the technique of interpretation in a well-founded order, the second one is implied by a transformation in which context-sensitive termination of the original system can be concluded from termination of the transformed one. In combination with purely automatic techniques for proving ordinary termination, the latter technique is purely automatic too. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Arts, T., and Giesl, J. </author> <title> Termination of constructor systems. </title> <booktitle> In Proceedings of the 7th Conference on Rewriting Techniques and Applications (1996), vol. 1103 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer, </publisher> <pages> pp. 63-77. </pages>
Reference-contexts: For proving termination of TRSs many techniques have been developed. Standard techniques for automatic proving termination include recursive path order and Knuth-Bendix order; for overviews we refer to [4, 8]. A more recent approach for an automatic technique is proposed in <ref> [1] </ref>. Often stronger but less automatic techniques are polynomial interpretations ([3]), transformation order ([2]) and semantic labelling ([10]). 3 3 Context-sensitive reduction orders and inter- pretations Let be a replacement map for a signature F .
Reference: [2] <author> Bellegarde, F., and Lescanne, P. </author> <title> Termination by completion. Applicable Algebra in Engineering, </title> <journal> Communication and Computing 1, </journal> <volume> 2 (1990), </volume> <pages> 79-96. </pages>
Reference: [3] <author> Ben-Cherifa, A., and Lescanne, P. </author> <title> Termination of rewriting systems by polynomial interpretations and its implementation. </title> <booktitle> Science of Computing Programming 9, 2 (1987), </booktitle> <pages> 137-159. </pages>
Reference: [4] <author> Dershowitz, N. </author> <title> Termination of rewriting. </title> <journal> Journal of Symbolic Computation 3, </journal> <volume> 1 and 2 (1987), </volume> <pages> 69-116. </pages>
Reference-contexts: Hence -termination follows from 0 -termination, in particular -termination follows from termination, as was already remarked in [7]. For proving termination of TRSs many techniques have been developed. Standard techniques for automatic proving termination include recursive path order and Knuth-Bendix order; for overviews we refer to <ref> [4, 8] </ref>. A more recent approach for an automatic technique is proposed in [1]. Often stronger but less automatic techniques are polynomial interpretations ([3]), transformation order ([2]) and semantic labelling ([10]). 3 3 Context-sensitive reduction orders and inter- pretations Let be a replacement map for a signature F .
Reference: [5] <author> Lucas, S. </author> <title> Fundamentals of context-sensitive rewriting. </title> <booktitle> In Proceedings of the 22nd Seminar on Current Trends in Theory and Practice of Informatics (SOFSEM95) (1995), </booktitle> <editor> J. S. M. Bartosek and J. Wiedermann, Eds., </editor> <volume> vol. </volume> <booktitle> 1012 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer, </publisher> <pages> pp. 405 - 412. </pages>
Reference-contexts: More general, for 1 every symbol we can define inside which of its arguments reduction is allowed or not. This kind of rewriting is called context-sensitive rewriting. It is introduced and discussed by Salvador Lucas, <ref> [5, 7, 6] </ref>. For further motivation we refer to those papers, here the emphasis is on introduction and justification of new techniques for proving termination of context-sensitive rewriting, shortly denoted as context-sensitive termination. <p> The definition of ,! R; given in <ref> [5, 7, 6] </ref> looks slightly different: there it is based on the notation for positions as being strings of natural number. However, it is easy to check that both definitions are equivalent. <p> If (f ) 0 (f ) for all f 2 F and two replacement maps ; 0 , then clearly every ,! R; -reduction is a ,! R; 0 -reduction too, as was already remarked in <ref> [5] </ref>. Hence -termination follows from 0 -termination, in particular -termination follows from termination, as was already remarked in [7]. For proving termination of TRSs many techniques have been developed. Standard techniques for automatic proving termination include recursive path order and Knuth-Bendix order; for overviews we refer to [4, 8].
Reference: [6] <author> Lucas, S. </author> <title> Context-sensitive computations in confluent programs. </title> <booktitle> In Proceedings of the 8th International Symposium on Programming Languages: Implementations, Logics and Programs (PLILP96) (1996), </booktitle> <editor> H. Kuchen and S. D. Swierstra, Eds., </editor> <volume> vol. </volume> <booktitle> 1140 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer, </publisher> <pages> pp. 408-422. 15 </pages>
Reference-contexts: More general, for 1 every symbol we can define inside which of its arguments reduction is allowed or not. This kind of rewriting is called context-sensitive rewriting. It is introduced and discussed by Salvador Lucas, <ref> [5, 7, 6] </ref>. For further motivation we refer to those papers, here the emphasis is on introduction and justification of new techniques for proving termination of context-sensitive rewriting, shortly denoted as context-sensitive termination. <p> The definition of ,! R; given in <ref> [5, 7, 6] </ref> looks slightly different: there it is based on the notation for positions as being strings of natural number. However, it is easy to check that both definitions are equivalent. <p> Note that neither g A nor h A is strictly monotone in its argument. Example 2. From <ref> [6] </ref> we take the following rewrite system sel (0; x : y) ! x from (x) ! x : from (s (x)): Here `:' is the cons function: x : y means that the element x is put in front of the list y.
Reference: [7] <author> Lucas, S. </author> <title> Termination of context-sensitive rewriting by rewriting. </title> <booktitle> In Proceedings of the 23rd International Colloquium on Automata, Languages and Programming (ICALP96) (1996), </booktitle> <editor> F. Meyer auf der Heide and B. Monien, Eds., </editor> <volume> vol. </volume> <booktitle> 1099 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer, </publisher> <pages> pp. 122 - 133. </pages>
Reference-contexts: More general, for 1 every symbol we can define inside which of its arguments reduction is allowed or not. This kind of rewriting is called context-sensitive rewriting. It is introduced and discussed by Salvador Lucas, <ref> [5, 7, 6] </ref>. For further motivation we refer to those papers, here the emphasis is on introduction and justification of new techniques for proving termination of context-sensitive rewriting, shortly denoted as context-sensitive termination. <p> The latter one about monotone algebras implies a practical technique for proving context-sensitive termination, quite similar to polynomial interpretations as used for proving ordinary termination. A first investigation of proving context-sensitive termination was given in <ref> [7] </ref>. The main result was that context-sensitive termination of a rewrite system can be concluded from ordinary termination of a transformed system. Roughly speaking in the transformed system all arguments at forbidden positions are removed in the left and right hand sides of the rules. <p> The definition of the transformation is very simple and fully constructive, by which the combination with well-known automatic techniques for proving ordinary termination yields a fully automatic technique for proving context-sensitive termination. Roughly speaking, compared with the technique of <ref> [7] </ref>, in our transformation the arguments at forbidden positions are marked instead of removed. For correctness some extra rules have to be added for handling the unmarking needed when in a reduction forbidden positions change into allowed positions. <p> By means of our transformation we show how context-sensitive termination can be proved fully automatic for a number of non-terminating examples describing recursive programs with an if-then-else-construction or selecting arguments in infinite lists. For none of the examples the method from <ref> [7] </ref> is applicable. 2 Preliminaries Let T (F ; X ) denote the set of terms over a signature F and a set of variables X , where every f 2 F has a fixed arity ar (f ). <p> The definition of ,! R; given in <ref> [5, 7, 6] </ref> looks slightly different: there it is based on the notation for positions as being strings of natural number. However, it is easy to check that both definitions are equivalent. <p> Hence -termination follows from 0 -termination, in particular -termination follows from termination, as was already remarked in <ref> [7] </ref>. For proving termination of TRSs many techniques have been developed. Standard techniques for automatic proving termination include recursive path order and Knuth-Bendix order; for overviews we refer to [4, 8]. A more recent approach for an automatic technique is proposed in [1]. <p> Proposition 3 is not only useful for proving context-sensitive termination of particular rewrite systems, it can also be used for obtaining theoretical results. In particular it implies a simpler proof of the main result of <ref> [7] </ref>. There for a TRS R and a replacement map a TRS R is introduced obtained from R by removing all arguments at forbidden positions in all left and right hand sides of the rules of R. <p> It may happen that the result is not a TRS, then it is left undefined. The result of <ref> [7] </ref> states that R is -terminating if R is terminating.
Reference: [8] <author> Steinbach, J. </author> <title> Simplification orderings: history of results. </title> <note> Fundamenta Informaticae 24 (1995), 47-87. </note>
Reference-contexts: Hence -termination follows from 0 -termination, in particular -termination follows from termination, as was already remarked in [7]. For proving termination of TRSs many techniques have been developed. Standard techniques for automatic proving termination include recursive path order and Knuth-Bendix order; for overviews we refer to <ref> [4, 8] </ref>. A more recent approach for an automatic technique is proposed in [1]. Often stronger but less automatic techniques are polynomial interpretations ([3]), transformation order ([2]) and semantic labelling ([10]). 3 3 Context-sensitive reduction orders and inter- pretations Let be a replacement map for a signature F .
Reference: [9] <author> Zantema, H. </author> <title> Termination of term rewriting: interpretation and type elimination. </title> <journal> Journal of Symbolic Computation 17 (1994), </journal> <pages> 23-50. </pages>
Reference-contexts: A, so l &gt; A r, which we had to prove. 2 For the replacement map defined by (f ) = f1; : : : ; ar (f )g for all f 2 F , the notion of well-founded -monotone algebra coincides with the notion of well-founded monotone algebra from <ref> [9] </ref>; in this way Proposition 1 in [9] is a special case of Proposition 3. <p> we had to prove. 2 For the replacement map defined by (f ) = f1; : : : ; ar (f )g for all f 2 F , the notion of well-founded -monotone algebra coincides with the notion of well-founded monotone algebra from <ref> [9] </ref>; in this way Proposition 1 in [9] is a special case of Proposition 3.
Reference: [10] <author> Zantema, H. </author> <title> Termination of term rewriting by semantic labelling. </title> <note> Fundamenta Infor-maticae 24 (1995), 89-105. 16 </note>
References-found: 10

