URL: http://www.cs.umr.edu/techreports/93-28.ps
Refering-URL: http://www.cs.umr.edu/techreports/
Root-URL: 
Title: Using Temporal Subsumption for Developing Efficient Error-Detecting Distributed Algorithms 1  
Author: Martina Schollmeyer and Bruce McMillin 
Date: October 21, 1993 CSC 93-28  
Abstract: Distributed algorithms can use executable assertions derived from program verification to detect errors at run-time. However, a complete verification proof outline contains a large number of assertions, and embedding all of them into the program to be checked at run-time would make error-detection very inefficient. The technique of temporal subsumption examines the dependencies between the individual assertions along program execution paths. In contrast to classical subsumption, where all logical expressions to be examined are true simultaneously, an assertion need only be true when the corresponding statement in the distributed program has been executed. Thus, temporal subsumption based on the set of assertions derived from a verification proof and in combination with the set of all legal states in the system, allows for the removal of (partial) assertions along execution sequences. We assume a fault model of Byzantine (malicious) behavior, and therefore an individual process cannot check itself for faults. We assume that a non-faulty process will always perform the correct computation so that once external data (obtained through communication) has been verified, the local computation does not need to be checked. A non-faulty process can thus detect faults produced by a faulty process based on the information it receives from it. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Heydtmann. </author> <title> Subsumption in modal logic. M.S. </title> <type> Thesis, </type> <institution> Computer Science Department, University of Missouri-Rolla, </institution> <year> 1993. </year>
Reference-contexts: The work in subsumption that is described in <ref> [1] </ref>, and which appears to be the only other work in this area, is a very general model which is not directly applicable to program verification and the methods described here. <p> Subsumption has long been known as a 5 technique to detect redundant clauses in the search space of automated deduction sys-tems for classical first order logics. Because of the need to develop similar techniques for non-classical modal logics, <ref> [1] </ref> examined how subsumption can be made to work in the context of these modal logic deduction systems. Modal logics, such as temporal logic, reason about possible worlds, i.e. not every statement made will be true all the time but only in certain specific worlds. <p> Paths can lead from one world to the next, and depending on the path selected, different truths can be shown. Thus, it is easy to see that whatever needs to be proven depends on a specific path, and a logic called World Path Logic (WPL) is introduced in <ref> [1] </ref> as a possible target language in which a proof can be done. [1] then continues to develop a subsumption model which will work in this environment. For more details, the reader is asked to refer directly to the material presented in [1]. <p> Thus, it is easy to see that whatever needs to be proven depends on a specific path, and a logic called World Path Logic (WPL) is introduced in <ref> [1] </ref> as a possible target language in which a proof can be done. [1] then continues to develop a subsumption model which will work in this environment. For more details, the reader is asked to refer directly to the material presented in [1]. <p> called World Path Logic (WPL) is introduced in <ref> [1] </ref> as a possible target language in which a proof can be done. [1] then continues to develop a subsumption model which will work in this environment. For more details, the reader is asked to refer directly to the material presented in [1]. It can easily be seen how this this concept of sequences of worlds and paths connecting them could be related to programs and the program statements which are also connected by "paths" through the program. The approach by [1], although more abstract since it deals only with modal logics as <p> reader is asked to refer directly to the material presented in <ref> [1] </ref>. It can easily be seen how this this concept of sequences of worlds and paths connecting them could be related to programs and the program statements which are also connected by "paths" through the program. The approach by [1], although more abstract since it deals only with modal logics as such, was developed concurrently at UMR with the approach presented in this paper. In contrast to the work by [1], the model presented in this work deals specifically with distributed programs and describes a very different approach for generating <p> The approach by <ref> [1] </ref>, although more abstract since it deals only with modal logics as such, was developed concurrently at UMR with the approach presented in this paper. In contrast to the work by [1], the model presented in this work deals specifically with distributed programs and describes a very different approach for generating subsumption rules as they are very closely linked to the application, distributed programs. 3.2 Terminology A distributed program P consists of a set of processes running concurrently on a set of
Reference: [2] <author> C. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-583, </pages> <year> 1969. </year>
Reference-contexts: The axiomatic approach to program verification is based on making assertions about program variables before, during, and after program execution. These assertions characterize properties of program variables and relationships between the variables at the different stages of the program execution <ref> [2] </ref>. Axiomatic proof techniques for distributed systems are described in [10]. They include, besides the sequential proof of a program, a proof of non-interference, a satisfaction proof, and a proof of freedom of deadlock. In an error-detecting program we embed assertions derived from program verification into the actual program code. <p> For more detail on how assertions can be determined from a program using axiomatic semantics see <ref> [2] </ref> and [4]). To reduce the number of assertions that need to be examined as candidates for (V; S)- subsumption, we want to divide the program into parts that can be examined independently. In general, we want these sections to be enclosed by a forward and a backward concurrency point.
Reference: [3] <author> J. Jou and J. Abraham. </author> <title> Fault-tolerant matrix arithmetic and signal processing on highly parallel computing structures. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 74(5) </volume> <pages> 732-741, </pages> <month> May </month> <year> 1986. </year>
Reference-contexts: 1 Introduction Error-detecting algorithms work by checking assertions, at run-time, to detect hardware, communication <ref> [3] </ref> and software errors [8]. A properly chosen set of assertions, such as those generated from program verification, guarantees that, when operationally evaluated, the program meets its specification [6].
Reference: [4] <author> G.M. Levin and D. Gries. </author> <title> A proof technique for communicating sequential processes. </title> <journal> Acta Informatica, </journal> <volume> 15 </volume> <pages> 281-302, </pages> <year> 1981. </year>
Reference-contexts: For more detail on how assertions can be determined from a program using axiomatic semantics see [2] and <ref> [4] </ref>). To reduce the number of assertions that need to be examined as candidates for (V; S)- subsumption, we want to divide the program into parts that can be examined independently. In general, we want these sections to be enclosed by a forward and a backward concurrency point.
Reference: [5] <author> D.W. Loveland. </author> <title> Automated Theorem Proving, </title> <booktitle> chapter 4. Number 6 in Fundamental Studies in Computer Science. </booktitle> <publisher> North-Holland, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: In the (automated reasoning) literature, subsumption is defined as follows <ref> [5] </ref>: Definition 4.2 A clause C subsumes a clause D if and only if 8C ! 8D is valid, and 8C is the notation for the universal closure of the clause C.
Reference: [6] <author> H. Lutfiyya, M. Schollmeyer, and B. McMillin. </author> <title> Fault-tolerant distributed sort generated from a verification proof outline. </title> <booktitle> 2nd Responsive Systems Symposium, 1992. </booktitle> <publisher> Springer Verlag. </publisher>
Reference-contexts: 1 Introduction Error-detecting algorithms work by checking assertions, at run-time, to detect hardware, communication [3] and software errors [8]. A properly chosen set of assertions, such as those generated from program verification, guarantees that, when operationally evaluated, the program meets its specification <ref> [6] </ref>. Mili [9] was the first to notice the relationship between program verification and fault tolerance of a program through software specified executable assertions. However, his approach was designed for the sequential verification environment. The development of executable assertions for a program in the distributed environment is more complex.
Reference: [7] <author> H. Lutfiyya, M. Schollmeyer, and B. McMillin. </author> <title> Formal generation of executable assertions for application-oriented fault tolerance. </title> <type> Technical Report CSC 92-15, </type> <institution> UMR Department of Computer Science, </institution> <year> 1992. </year>
Reference-contexts: Thus, GAVs are treated as local variables in each process and become known to other processes only when they are communicated instead of being communicated and known instantaneously. This is possible due to the non-interference of the sequential proofs <ref> [7] </ref>. Since this delay of the communication of the 'global' knowledge contained in the GAVs retains the soundness and (relative) completeness of the proof system used for the verification proof, we can use the same boundaries here for the (V; S)-subsumption. <p> j 2 R s i ) ^ (s c2 2 R s j )^ e e e and c1 and c2 are the backward and forward concurrency points, respectively, correspond ing to two consecutive communication points in an execution sequence. 11 This lemma follows directly from the reasoning above and <ref> [7] </ref>. During program execution, and thus in the proof outline, only few variable values or relationships change from program step to program step. Assertions describe program states and they are therefore often conjunctions of clauses describing individual variables and their relationships with other variables. <p> From this substitution, immediately the above theorem follows. fl We again introduce concurrency points as subsumption boundaries. This is based on efficiency reasons as well as error-detecting ability and the soundness and completeness of the proof system used <ref> [7] </ref>. We want to verify the correct execution of each statement, and we also want to ensure that data that was obtained from other processes meets its specifications and that the current states are permitted states.
Reference: [8] <author> B. McMillin and L. Ni. </author> <title> Executable assertion development for the distributed parallel environment. </title> <booktitle> Proceedings of the 12th International COMPSAC, </booktitle> <pages> pages 284-291, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Error-detecting algorithms work by checking assertions, at run-time, to detect hardware, communication [3] and software errors <ref> [8] </ref>. A properly chosen set of assertions, such as those generated from program verification, guarantees that, when operationally evaluated, the program meets its specification [6]. Mili [9] was the first to notice the relationship between program verification and fault tolerance of a program through software specified executable assertions.
Reference: [9] <author> A. Mili. </author> <title> Self-checking programs: An axiomatisation of program validation by executable assertions. </title> <booktitle> Proceedings of the 11th International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 118-120, </pages> <year> 1981. </year>
Reference-contexts: 1 Introduction Error-detecting algorithms work by checking assertions, at run-time, to detect hardware, communication [3] and software errors [8]. A properly chosen set of assertions, such as those generated from program verification, guarantees that, when operationally evaluated, the program meets its specification [6]. Mili <ref> [9] </ref> was the first to notice the relationship between program verification and fault tolerance of a program through software specified executable assertions. However, his approach was designed for the sequential verification environment. The development of executable assertions for a program in the distributed environment is more complex.
Reference: [10] <author> S. Owicki and D. Gries. </author> <title> An axiomatic proof technique for parallel programs. </title> <journal> Acta Informatica, </journal> <volume> 6 </volume> <pages> 319-340, </pages> <year> 1976. </year> <month> 23 </month>
Reference-contexts: These assertions characterize properties of program variables and relationships between the variables at the different stages of the program execution [2]. Axiomatic proof techniques for distributed systems are described in <ref> [10] </ref>. They include, besides the sequential proof of a program, a proof of non-interference, a satisfaction proof, and a proof of freedom of deadlock. In an error-detecting program we embed assertions derived from program verification into the actual program code.
References-found: 10

