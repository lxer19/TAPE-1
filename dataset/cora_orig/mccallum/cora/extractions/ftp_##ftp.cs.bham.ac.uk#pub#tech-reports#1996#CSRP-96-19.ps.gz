URL: ftp://ftp.cs.bham.ac.uk/pub/tech-reports/1996/CSRP-96-19.ps.gz
Refering-URL: http://www.cs.bham.ac.uk/~wbl/biblio/gp-bibliography.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: E-mail: R.Poli@cs.bham.ac.uk  
Title: Evolution of Recursive Transition Networks for Natural Language Recognition with Parallel Distributed Genetic Programming  
Author: Riccardo Poli 
Date: December 1996  
Address: Birmingham  
Affiliation: School of Computer Science The University of  
Pubnum: Technical Report: CSRP-96-19  
Abstract: This paper describes the application of Parallel Distributed Genetic Programming (PDGP) to the problem of inducing programs for natural language processing. PDGP is a new form of Genetic Programming (GP) which is suitable for the development of programs with a high degree of parallelism and an efficient and effective reuse of partial results. Programs are represented in PDGP as graphs with nodes representing functions and terminals, and links representing the flow of control and results. PDGP allows the exploration of a large space of possible programs including standard tree-like programs, logic networks, neural networks, finite state automata, Recursive Transition Networks (RTNs), etc. The paper describes the representations, the operators and the interpreters used in PDGP, and illustrates its behaviour on the problem of inducing RTN-based recognisers for natural lan guage from positive and negative examples.
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> Late Breaking Papers at the Genetic Programming 1996 Conference, Stanford University, </institution> <address> July 1996. </address> <publisher> Stanford Bookstore. </publisher>
Reference-contexts: This form of GP has been applied successfully to a large number of difficult problems like automated design, pattern recognition, robot control, symbolic regression, music generation, image compression, image analysis, etc. <ref> [10, 11, 8, 9, 1, 17] </ref>. When appropriate terminals, functions and/or interpreters are defined, standard GP can go beyond the production of sequential tree-like programs.
Reference: [2] <author> David Andre, Forrest H. Bennett III, and John R. Koza. </author> <title> Discovery by genetic programming of a cellular automata rule that is better than any known rule for the majority classification problem. </title> <editor> In John R. Koza, David E. Goldberg, David B. Fogel, and Rick L. Riolo, editors, </editor> <booktitle> Genetic Programming 1996: Proceedings of the First Annual Conference, </booktitle> <pages> page 3, </pages> <address> Stanford University, CA, USA, 28-31 July 1996. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Also, in conjunction with an interpreter implementing a parallel virtual machine, GP can be used to translate sequential programs into parallel ones [22] or to develop some kinds of parallel programs <ref> [3, 2, 21] </ref>.
Reference: [3] <author> Forrest H. Bennett III. </author> <title> Automatic creation of an efficient multi-agent architecture using genetic programming with architecture-altering operations. </title> <editor> In John R. Koza, David E. Goldberg, David B. Fogel, and Rick L. Riolo, editors, </editor> <booktitle> Genetic Programming 1996: Proceedings of the First Annual Conference, </booktitle> <pages> page 30, </pages> <address> Stanford University, CA, USA, 28-31 July 1996. </address> <publisher> MIT Press. </publisher> <pages> 8 </pages>
Reference-contexts: Also, in conjunction with an interpreter implementing a parallel virtual machine, GP can be used to translate sequential programs into parallel ones [22] or to develop some kinds of parallel programs <ref> [3, 2, 21] </ref>.
Reference: [4] <author> Scott Brave. </author> <title> Evolving deterministic finite automata using cellular encoding. </title> <editor> In John R. Koza, David E. Goldberg, David B. Fogel, and Rick L. Riolo, editors, </editor> <booktitle> Genetic Programming 1996: Proceedings of the First Annual Conference, </booktitle> <pages> page 39, </pages> <address> Stanford University, CA, USA, 28-31 July 1996. </address> <publisher> MIT Press. </publisher>
Reference-contexts: A very recent review of these is present in [5]. To the author's knowledge only two applications have been published in the area of genetic programming [20, 14]: none dealing with the problem of natural language recognition. More closely related to this topic is the work described in <ref> [4, 16] </ref> on inducing, from positive and negative example, deterministic finite state automata capable of recognising simple regular languages. Deterministic finite state automata (FSA) are a well known means of building recognisers for this kind of languages. <p> Deterministic finite state automata (FSA) are a well known means of building recognisers for this kind of languages. However, they are not particularly suited to represent the natural recursivity of natural-language grammars. Indeed, the work in in <ref> [4, 16] </ref> considered very simple non-recursive languages, like L=a*b*a*b* (consisting of all sentences with 0 or more a's followed by 0 or more b's, etc), which have nothing to do with the complexity of natural language.
Reference: [5] <author> Ted E. Dunning and Mark W. Davis. </author> <title> Evolutionary algorithms for natural language processing. </title> <editor> In John R. Koza, editor, </editor> <booktitle> Late Breaking Papers at the Genetic Programming 1996 Conference Stanford University July 28-31, </booktitle> <year> 1996, </year> <pages> pages 16-23, </pages> <address> Stanford University, CA, USA, 28-31 July 1996. </address> <publisher> Stanford Bookstore. </publisher>
Reference-contexts: A limited amount of work has been done on evolutionary algorithms applied to the problems of natural language processing. A very recent review of these is present in <ref> [5] </ref>. To the author's knowledge only two applications have been published in the area of genetic programming [20, 14]: none dealing with the problem of natural language recognition.
Reference: [6] <author> F Gruau and D. Whitley. </author> <title> Adding learning to the cellular development process: a comparative study. </title> <journal> Evolutionary Computation, </journal> <volume> 1(3) </volume> <pages> 213-233, </pages> <year> 1993. </year>
Reference-contexts: When appropriate terminals, functions and/or interpreters are defined, standard GP can go beyond the production of sequential tree-like programs. For example using cellular encoding GP can be used to develop (grow) structures, like neural nets <ref> [6, 7] </ref> or electronic circuits [13, 12], which can be thought of as performing some form of parallel analogue computation.
Reference: [7] <author> Frederic Gruau. </author> <title> Genetic micro programming of neural networks. </title> <editor> In Kenneth E. Kinnear, Jr., editor, </editor> <booktitle> Advances in Genetic Programming, chapter 24. </booktitle> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: When appropriate terminals, functions and/or interpreters are defined, standard GP can go beyond the production of sequential tree-like programs. For example using cellular encoding GP can be used to develop (grow) structures, like neural nets <ref> [6, 7] </ref> or electronic circuits [13, 12], which can be thought of as performing some form of parallel analogue computation.
Reference: [8] <editor> K. E. Kinnear, Jr., editor. </editor> <booktitle> Advances in Genetic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: This form of GP has been applied successfully to a large number of difficult problems like automated design, pattern recognition, robot control, symbolic regression, music generation, image compression, image analysis, etc. <ref> [10, 11, 8, 9, 1, 17] </ref>. When appropriate terminals, functions and/or interpreters are defined, standard GP can go beyond the production of sequential tree-like programs.
Reference: [9] <editor> J. R. Koza, D. E. Goldberg, D. B. Fogel, and R. L. Riolo, editors. </editor> <booktitle> Proceedings of the First International Conference on Genetic Programming, </booktitle> <address> Stenford University, July 1996. </address> <publisher> MIT Press. </publisher>
Reference-contexts: This form of GP has been applied successfully to a large number of difficult problems like automated design, pattern recognition, robot control, symbolic regression, music generation, image compression, image analysis, etc. <ref> [10, 11, 8, 9, 1, 17] </ref>. When appropriate terminals, functions and/or interpreters are defined, standard GP can go beyond the production of sequential tree-like programs.
Reference: [10] <author> John R. Koza. </author> <title> Genetic Programming: On the Programming of Computers by Means of Natural Selection. </title> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction In Genetic Programming <ref> [10, 11] </ref> programs are expressed as parse trees to be executed sequentially in the standard depth-first evaluation order. <p> This form of GP has been applied successfully to a large number of difficult problems like automated design, pattern recognition, robot control, symbolic regression, music generation, image compression, image analysis, etc. <ref> [10, 11, 8, 9, 1, 17] </ref>. When appropriate terminals, functions and/or interpreters are defined, standard GP can go beyond the production of sequential tree-like programs.
Reference: [11] <author> John R. Koza. </author> <title> Genetic Programming II: Automatic Discovery of Reusable Programs. </title> <publisher> MIT Pres, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1994. </year>
Reference-contexts: 1 Introduction In Genetic Programming <ref> [10, 11] </ref> programs are expressed as parse trees to be executed sequentially in the standard depth-first evaluation order. <p> This form of GP has been applied successfully to a large number of difficult problems like automated design, pattern recognition, robot control, symbolic regression, music generation, image compression, image analysis, etc. <ref> [10, 11, 8, 9, 1, 17] </ref>. When appropriate terminals, functions and/or interpreters are defined, standard GP can go beyond the production of sequential tree-like programs.
Reference: [12] <author> John R. Koza, David Andre, Forrest H. Bennett III, and Martin A. Keane. </author> <title> Use of automatically defined functions and architecture-altering operations in automated circuit synthesis using genetic programming. </title> <editor> In John R. Koza, David E. Goldberg, David B. Fogel, and Rick L. Riolo, editors, </editor> <booktitle> Genetic Programming 1996: Proceedings of the First Annual Conference, </booktitle> <pages> page 132, </pages> <address> Stanford University, CA, USA, 28-31 July 1996. </address> <publisher> MIT Press. </publisher>
Reference-contexts: When appropriate terminals, functions and/or interpreters are defined, standard GP can go beyond the production of sequential tree-like programs. For example using cellular encoding GP can be used to develop (grow) structures, like neural nets [6, 7] or electronic circuits <ref> [13, 12] </ref>, which can be thought of as performing some form of parallel analogue computation. Also, in conjunction with an interpreter implementing a parallel virtual machine, GP can be used to translate sequential programs into parallel ones [22] or to develop some kinds of parallel programs [3, 2, 21].
Reference: [13] <author> John R. Koza, Forrest H. Bennett III David Andre, and Martin A. Keane. </author> <title> Automated WYWIWYG design of both the topology and component values of electrical circuits using genetic programming. </title> <editor> In John R. Koza, David E. Goldberg, David B. Fogel, and Rick L. Riolo, editors, </editor> <booktitle> Genetic Programming 1996: Proceedings of the First Annual Conference, </booktitle> <pages> page 123, </pages> <address> Stanford University, CA, USA, 28-31 July 1996. </address> <publisher> MIT Press. </publisher>
Reference-contexts: When appropriate terminals, functions and/or interpreters are defined, standard GP can go beyond the production of sequential tree-like programs. For example using cellular encoding GP can be used to develop (grow) structures, like neural nets [6, 7] or electronic circuits <ref> [13, 12] </ref>, which can be thought of as performing some form of parallel analogue computation. Also, in conjunction with an interpreter implementing a parallel virtual machine, GP can be used to translate sequential programs into parallel ones [22] or to develop some kinds of parallel programs [3, 2, 21].
Reference: [14] <author> Thomas R. Osborn, Adib Charif, Ricardo Lamas, and Eugene Dubossarsky. </author> <booktitle> Genetic logic programming. In 1995 IEEE Conference on Evolutionary Computation, </booktitle> <address> Perth, Australia, 1995. </address> <publisher> IEEE Press. </publisher>
Reference-contexts: A limited amount of work has been done on evolutionary algorithms applied to the problems of natural language processing. A very recent review of these is present in [5]. To the author's knowledge only two applications have been published in the area of genetic programming <ref> [20, 14] </ref>: none dealing with the problem of natural language recognition. More closely related to this topic is the work described in [4, 16] on inducing, from positive and negative example, deterministic finite state automata capable of recognising simple regular languages.
Reference: [15] <author> R. Poli. </author> <title> Discovery of symbolic, neuro-symbolic and neural networks with parallel distributed genetic programming. </title> <type> Technical Report CSRP-96-14, </type> <institution> School of Computer Science, The University of Birmingham, </institution> <month> August </month> <year> 1996. </year>
Reference-contexts: From the implementation point of view PDGP represents programs as arrays with the same topology as the grid, in which each cell contains a function label and the horizontal 1 Some preliminary work on PDGP is described in <ref> [18, 15, 16] </ref>. 2 (a) (b) (c) (b) Grid-based representation of graphs representing programs in PDGP (hollow circles represent functions, grey circles represent terminals); (c) Grid-based representation of the expression in (a). displacement of the nodes in the previous layer used as arguments for the function.
Reference: [16] <author> R. Poli. </author> <title> Parallel distributed genetic programming. </title> <type> Technical Report CSRP-96-15, </type> <institution> School of Computer Science, The University of Birmingham, </institution> <month> September </month> <year> 1996. </year> <month> 9 </month>
Reference-contexts: From the implementation point of view PDGP represents programs as arrays with the same topology as the grid, in which each cell contains a function label and the horizontal 1 Some preliminary work on PDGP is described in <ref> [18, 15, 16] </ref>. 2 (a) (b) (c) (b) Grid-based representation of graphs representing programs in PDGP (hollow circles represent functions, grey circles represent terminals); (c) Grid-based representation of the expression in (a). displacement of the nodes in the previous layer used as arguments for the function. <p> In the following we will only describe two forms of crossover (more details can be found in <ref> [16] </ref>). The basic crossover operator of PDGP, which we call Sub-graph Active-Active Node (SAAN) crossover, is a generalisation to graphs of the crossover used in GP to recombine trees. <p> 3 Evolution of Natural Language Recognisers In this section we will report on experiments which emphasise the representational power of PDGP and its behaviour on a hard problem: the induction of an RTN-based recogniser for natural language from positive and negative examples (experimental results on simpler problems are described in <ref> [16] </ref>). A recogniser for natural language is a program that given a sentence (say in English) returns true if the sentence is grammatical, false otherwise. <p> A very recent review of these is present in [5]. To the author's knowledge only two applications have been published in the area of genetic programming [20, 14]: none dealing with the problem of natural language recognition. More closely related to this topic is the work described in <ref> [4, 16] </ref> on inducing, from positive and negative example, deterministic finite state automata capable of recognising simple regular languages. Deterministic finite state automata (FSA) are a well known means of building recognisers for this kind of languages. <p> Deterministic finite state automata (FSA) are a well known means of building recognisers for this kind of languages. However, they are not particularly suited to represent the natural recursivity of natural-language grammars. Indeed, the work in in <ref> [4, 16] </ref> considered very simple non-recursive languages, like L=a*b*a*b* (consisting of all sentences with 0 or more a's followed by 0 or more b's, etc), which have nothing to do with the complexity of natural language. <p> RTNs are extensions of FSA, in which the label associated to a 3 For brevity we will not describe here the changes needed to evaluate correctly nodes with side effects. More information on this is given in <ref> [16] </ref>. 5 link can represent either symbols of the language (like in standard FSA) or other RTNs (possibly including the RTN containing the link).
Reference: [17] <author> Riccardo Poli. </author> <title> Genetic programming for image analysis. </title> <editor> In John R. Koza, David E. Goldberg, David B. Fogel, and Rick L. Riolo, editors, </editor> <booktitle> Genetic Programming 1996: Proceedings of the First Annual Conference, </booktitle> <pages> page 363, </pages> <address> Stanford University, CA, USA, 28-31 July 1996. </address> <publisher> MIT Press. </publisher>
Reference-contexts: This form of GP has been applied successfully to a large number of difficult problems like automated design, pattern recognition, robot control, symbolic regression, music generation, image compression, image analysis, etc. <ref> [10, 11, 8, 9, 1, 17] </ref>. When appropriate terminals, functions and/or interpreters are defined, standard GP can go beyond the production of sequential tree-like programs.
Reference: [18] <author> Riccardo Poli. </author> <title> Some steps towards a form of parallel distributed genetic programming. </title> <booktitle> In Proceedings of the First On-line Workshop on Soft Computing, </booktitle> <month> August </month> <year> 1996. </year>
Reference-contexts: From the implementation point of view PDGP represents programs as arrays with the same topology as the grid, in which each cell contains a function label and the horizontal 1 Some preliminary work on PDGP is described in <ref> [18, 15, 16] </ref>. 2 (a) (b) (c) (b) Grid-based representation of graphs representing programs in PDGP (hollow circles represent functions, grey circles represent terminals); (c) Grid-based representation of the expression in (a). displacement of the nodes in the previous layer used as arguments for the function.
Reference: [19] <author> Stuart C. Shapiro. </author> <booktitle> Encyclopedia of Artificial Intelligence. </booktitle> <publisher> Wiley, </publisher> <address> New York, </address> <note> second edition, </note> <year> 1992. </year>
Reference-contexts: The problem of inducing recognisers (and parsers) from actual sentences of the language, also known as language acquisition, is a very hard machine learning problem (see <ref> [19, pages 443-451] </ref> for a survey on the topic). A limited amount of work has been done on evolutionary algorithms applied to the problems of natural language processing. A very recent review of these is present in [5].
Reference: [20] <author> Eric V. Siegel. </author> <title> Competitively evolving decision trees against fixed training cases for natural language processing. </title> <editor> In Kenneth E. Kinnear, Jr., editor, </editor> <booktitle> Advances in Genetic Programming, chapter 19, </booktitle> <pages> pages 409-423. </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: A limited amount of work has been done on evolutionary algorithms applied to the problems of natural language processing. A very recent review of these is present in [5]. To the author's knowledge only two applications have been published in the area of genetic programming <ref> [20, 14] </ref>: none dealing with the problem of natural language recognition. More closely related to this topic is the work described in [4, 16] on inducing, from positive and negative example, deterministic finite state automata capable of recognising simple regular languages.
Reference: [21] <author> Astro Teller and Manuela Veloso. </author> <title> PADO: Learning tree structured algorithms for orchestration into an object recognition system. </title> <type> Technical Report CMU-CS-95-101, </type> <institution> Department of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, USA, </address> <year> 1995. </year>
Reference-contexts: Also, in conjunction with an interpreter implementing a parallel virtual machine, GP can be used to translate sequential programs into parallel ones [22] or to develop some kinds of parallel programs <ref> [3, 2, 21] </ref>.
Reference: [22] <author> Paul Walsh and Conor Ryan. </author> <title> Paragen: A novel technique for the autoparallelisation of sequential programs using genetic programming. </title> <editor> In John R. Koza, David E. Goldberg, David B. Fogel, and Rick L. Riolo, editors, </editor> <booktitle> Genetic Programming 1996: Proceedings of the First Annual Conference, </booktitle> <pages> page 406, </pages> <address> Stanford University, CA, USA, 28-31 July 1996. </address> <publisher> MIT Press. </publisher> <pages> 10 </pages>
Reference-contexts: Also, in conjunction with an interpreter implementing a parallel virtual machine, GP can be used to translate sequential programs into parallel ones <ref> [22] </ref> or to develop some kinds of parallel programs [3, 2, 21].
References-found: 22

