URL: http://www.cs.iastate.edu/tech-reports/TR91-14.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: 
Title: Typed Homomorphic Relations Extended with Subtypes  
Author: Gary T. Leavens and Don Pigozzi 
Address: Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science Iowa State University  
Date: June, 1991  
Pubnum: TR #91-14  
Abstract: This paper will appear in the proceedings of Mathematical Foundations of Programming Semantics '91, to be published by Springer-Verlag, in the Lecture Notes in Computer Science series. 1991 CR Categories: D.3.1 [Programming Languages] Formal Definitions and Theory | semantics; D.3.2 [Programming Languages] Language Classifications | applicative languages, nondeterministic languages, object-oriented languages; D.3.3 [Programming Languages] Language Constructs | abstract data types; F.3.2 [Logics and Meanings of Programs] Semantics of Programming Languages | algebraic approaches to semantics, denotational semantics; F.3.3 [Logics and Meanings of Programs] Studies of Program Constructs | type structure; F.4.1 [Mathematical Logic and Formal Languages] Mathematical Logic | lambda calculus and related systems. c fl 1991 Springer-Verlag
Abstract-found: 1
Intro-found: 1
Reference: [Ame87] <author> Pierre America. </author> <title> Inheritance and Subtyping in a Parallel Object-Oriented Language. </title> <editor> In Jean Bezivin et al., editors, </editor> <booktitle> ECOOP '87, European Conference on Object-Oriented Programming, Paris, France, </booktitle> <pages> pages 234-242, </pages> <address> New York, N.Y., </address> <month> June </month> <year> 1987. </year> <title> Springer-Verlag. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 276. </volume>
Reference-contexts: Aside from the work of Reynolds, Bruce and Wegner, and the first author, there is some work by America that is closely related. America defines subtyping for mutable types based on implications between pre- and post-conditions of the relevant operation specifications <ref> [Ame87] </ref> [Ame89]. (A more widely known, but less formal account of subtyping is embodied in Meyer's book on the language Eiffel [Mey88].) America's definition is more useful than ours for programmers, since it gives a direct way to prove that one has a legal subtype relation.
Reference: [Ame89] <author> Pierre America. </author> <title> A Behavioural Approach to Subtyping in Object-Oriented Programming Languages. </title> <type> Technical Report 443, </type> <institution> Philips Research Laboratories, Nederlandse Philips Bedrijven B. V., </institution> <month> April </month> <year> 1989. </year> <note> Revised from the January 1989 version. </note>
Reference-contexts: Aside from the work of Reynolds, Bruce and Wegner, and the first author, there is some work by America that is closely related. America defines subtyping for mutable types based on implications between pre- and post-conditions of the relevant operation specifications [Ame87] <ref> [Ame89] </ref>. (A more widely known, but less formal account of subtyping is embodied in Meyer's book on the language Eiffel [Mey88].) America's definition is more useful than ours for programmers, since it gives a direct way to prove that one has a legal subtype relation.
Reference: [BTCGS89] <author> V. Breazu-Tannen, T. Coquand, C. A. Gunter, and A. Scedrov. </author> <title> Inheritance and Explicit Coercion (Preliminary Report). </title> <booktitle> In Fourth Annual Symposium on Logic in Computer Science, </booktitle> <address> Pacific Grove, California, </address> <pages> pages 112-129. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1989. </year> <note> Revised version to appear in Information and Computation. Also appears as University of Pennsylvania, </note> <institution> Department of Computer and Information Science, </institution> <note> Logic and Computation 1, MS-CIS-89-01. </note>
Reference-contexts: The following lemma says that the extension of a simulation relation to a logical relation satisfies the coercion property if the type frames are generated. The proof uses the idea of syntactic coercions from <ref> [BTCGS89] </ref>. Lemma 3.4. Let C = (F; C; C [[]]) and A = (D; A; A [[]]) be -type frames. Let R be a -logical relation from C to A.
Reference: [BW90] <author> Kim B. Bruce and Peter Wegner. </author> <title> An Algebraic Model of Subtype and Inheritance. </title> <editor> In Francois Ban~cilhon and Peter Buneman, editors, </editor> <booktitle> Advances in 23 Database Programming Languages, </booktitle> <pages> pages 75-96. </pages> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1990. </year>
Reference-contexts: For example, one can think of R Pair as describing how a triple (or a pair) is coerced into a pair <ref> [BW90] </ref>. Or one might think of R Pair as describing which triples (and pairs) behave like which pairs. We distinguish two families of such of relations in this paper. <p> Our generalization of typed relations and its applications to reasoning about object-oriented programs was inspired by Bruce and Wegner's coercion functions <ref> [BW90] </ref>, which generalize the inclusions of an order-sorted algebra [GM87]. The idea is that a generalized order-sorted algebra has a coercion function c S;T for each T and each subtype S of T that maps the carrier set of S to the carrier set of T .
Reference: [Car84] <author> Luca Cardelli. </author> <title> A Semantics of Multiple Inheritance. </title> <editor> In D. B. MacQueen G. Kahn and G. Plotkin, editors, </editor> <booktitle> Semantics of Data Types: International Symposium, Sophia-Antipolis, France, volume 173 of Lecture Notes in Computer Science, </booktitle> <pages> pages 51-66. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> June </month> <year> 1984. </year> <note> A revised version of this paper appears in Information and Computation, </note> <institution> volume 76, </institution> <type> numbers 2/3, </type> <pages> pages 138-164, </pages> <month> February/March </month> <year> 1988. </year>
Reference-contexts: An objection to our generalization of strictly typed relations would be that one can always construct algebraic models where the carrier set of a subtype is a subset of the carrier sets of its supertypes. (As is done, for example, in <ref> [Car84] </ref>. <p> The preorder on the sorts of is extended to a preorder on type expressions using the usual anti-monotonic rule for function types <ref> [Car84] </ref>. The abstract syntax of pre-terms over is given by the following grammar: e ::= x j g (~e) j x : T :e j e e where x is an identifier and g is an element of OPS . <p> Our definition does permits the interpretation of a subtype to be a subset of the interpretation of a supertype; however, we do not require this property. Our lambda calculus with subtypes given above provides an alternative to calculi with rules of subsumption (e.g., as in <ref> [Car84] </ref>). In our calculus, each term has at most one type, and proofs of typings are unique if they exist, just as in the simply typed lambda calculus.
Reference: [Fri75] <author> H. Friedman. </author> <title> Equality between Functionals. </title> <editor> In R. Parikh, editor, </editor> <booktitle> Logic Colloquium, Symposium on Logic Held at Boston, </booktitle> <pages> 1972-73, </pages> <booktitle> volume 453 of Lecture Notes in Mathematics, </booktitle> <pages> pages 22-37. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1975. </year>
Reference-contexts: The style of this presentation roughly follows [Gun90] and <ref> [Fri75] </ref>. We then prove other results similar to the previous section's. 3.1 The Language The abstract syntax of type expressions over is given by the following grammar T ::= C j T ! T where C is an element of SORTS .
Reference: [GM87] <author> Joseph A. Goguen and Jose Meseguer. </author> <title> Order-Sorted Algebra Solves the Constructor-Selector, Multiple Representation and Coercion Problems. </title> <type> Technical Report CSLI-87-92, </type> <institution> Center for the Study of Language and Information, </institution> <month> March </month> <year> 1987. </year> <booktitle> Appears in Second Annual Symposium on Logic in Computer Science, </booktitle> <address> Ithaca, NY, </address> <month> June, </month> <year> 1987, </year> <pages> pages 18-29. </pages>
Reference-contexts: This condition is also imposed on models in order-sorted algebras <ref> [GM87] </ref>.) For example, given an arbitrary algebraic model of a specification, A, where the carrier sets A S are disjoint, one can construct a model A 0 such that for each type T , A 0 T is the union of A S for all subtypes S of T . <p> Our generalization of typed relations and its applications to reasoning about object-oriented programs was inspired by Bruce and Wegner's coercion functions [BW90], which generalize the inclusions of an order-sorted algebra <ref> [GM87] </ref>. The idea is that a generalized order-sorted algebra has a coercion function c S;T for each T and each subtype S of T that maps the carrier set of S to the carrier set of T .
Reference: [Gun90] <author> Carl A. Gunter. </author> <title> Structures and Techniques for the Semantics of Programming Languages. </title> <type> Technical report, </type> <institution> Department of Computer and Information Science, University of Pennsylvania, </institution> <month> September </month> <year> 1990. </year>
Reference-contexts: The style of this presentation roughly follows <ref> [Gun90] </ref> and [Fri75]. We then prove other results similar to the previous section's. 3.1 The Language The abstract syntax of type expressions over is given by the following grammar T ::= C j T ! T where C is an element of SORTS . <p> For example, should equations between terms of different types needed? We believe the answer is "no", but this remains to be shown. Other future research would be to follow Gunter's development of the semantics of the simply typed lambda calculus <ref> [Gun90] </ref> farther, and investigate cartesian closed categories as models of the simply typed lambda calculus with subtypes. 5 Conclusions Generalized homomorphic relations and generalized logical relations are useful tools for the study of languages with subtyping.
Reference: [Hes88] <author> Wim H. Heselink. </author> <title> A Mathematical Approach to Nondeterminism in Data Types. </title> <journal> TOPLAS, </journal> <volume> 10(1) </volume> <pages> 87-117, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: such a specification. (The standard initial model construction would add new elements to the carrier set of Int, and thus would not be a hierarchical model.) Furthermore, to allow the maximum expression of the incompleteness of such a specification, one might also wish to consider models with nondeterministic operations [Nip86] <ref> [Hes88] </ref>. If one considers models with nondeterministic operations, then the type IntSet can have subtypes.
Reference: [Lea90] <author> Gary T. Leavens. </author> <title> Modular Verification of Object-Oriented Programs with Subtypes. </title> <type> Technical Report 90-09, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, July </month> <year> 1990. </year>
Reference-contexts: Simulation relations are used to define when one abstract data type is a subtype of another. Applications of such relations to the problems of specifying and verifying object-oriented programming languages are discussed in [LW90], [Lea91], and <ref> [Lea90] </ref>. Verification is based on supertype abstraction, where functions are verified using properties of the supertype's specification, including datatype induction, as if the supertype had no subtypes. <p> cannot preserve the meaning of choose for Interval objects and IntSet, since in B max applying choose to an Interval has the least element of the interval as its only possible result, and applying choose to a nonempty IntSet has the set's maximum element as its only possible result (see <ref> [Lea90] </ref> for a detailed proof of a similar statement). The following lemma is the key property of simulation relations. Lemma 2.5. Let H be a sort context. Let C and A be -algebras such that there is a -simulation R from C to A. <p> But in an environment where s denotes the Interval [1; 10], the set of possible results of this observation, f1g, would be surprising for fB max g. A result similar to Theorem 2.7 also holds for languages that can make more interesting observations. For example, in <ref> [Lea90] </ref>, a similar result is proved for a language with if-expressions, recursion, and angelic nondeterminism. 3 Relations for Lambda Calculus with Subtypes In this section we define a typed lambda calculus, type frames, and a generalization of logical relations on type frames, taking subtyping into account. <p> For example, the language could make more interesting observations if it was extended by such features as angelic nondeterminism, streamed output, and recursion. It may be possible to extend the results in <ref> [Lea90] </ref> along these lines. 4.2 Language Semantics with Subtypes Our definition of a type frame does not require that the interpretation of a subtype be a subset of the interpretation of each of its supertypes.
Reference: [Lea91] <author> Gary T. Leavens. </author> <title> Modular Specification and Verification of Object-Oriented Programs. </title> <journal> IEEE Software, </journal> <volume> 8(4) </volume> <pages> 72-80, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Simulation relations are used to define when one abstract data type is a subtype of another. Applications of such relations to the problems of specifying and verifying object-oriented programming languages are discussed in [LW90], <ref> [Lea91] </ref>, and [Lea90]. Verification is based on supertype abstraction, where functions are verified using properties of the supertype's specification, including datatype induction, as if the supertype had no subtypes. <p> Our criteria is based on observable behavior. The criteria says that the use of subtyping should not give surprising results. This criteria has several important implications for program verification [LW90] <ref> [Lea91] </ref>. Our independent description of subtyping is based on simulation relations. The definition of a legal subtype relation, which uses simulation satisfies our criteria.
Reference: [LW90] <author> Gary T. Leavens and William E. Weihl. </author> <title> Reasoning about Object-oriented Programs that use Subtypes (extended abstract). </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 25(10) </volume> <pages> 212-223, </pages> <month> October </month> <year> 1990. </year> <booktitle> OOPSLA ECOOP '90 Proceedings, N. Mey-rowitz (editor). </booktitle>
Reference-contexts: Simulation relations are used to define when one abstract data type is a subtype of another. Applications of such relations to the problems of specifying and verifying object-oriented programming languages are discussed in <ref> [LW90] </ref>, [Lea91], and [Lea90]. Verification is based on supertype abstraction, where functions are verified using properties of the supertype's specification, including datatype induction, as if the supertype had no subtypes. <p> Our criteria is based on observable behavior. The criteria says that the use of subtyping should not give surprising results. This criteria has several important implications for program verification <ref> [LW90] </ref> [Lea91]. Our independent description of subtyping is based on simulation relations. The definition of a legal subtype relation, which uses simulation satisfies our criteria.
Reference: [Mey88] <author> Bertrand Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <year> 1988. </year>
Reference-contexts: America defines subtyping for mutable types based on implications between pre- and post-conditions of the relevant operation specifications [Ame87] [Ame89]. (A more widely known, but less formal account of subtyping is embodied in Meyer's book on the language Eiffel <ref> [Mey88] </ref>.) America's definition is more useful than ours for programmers, since it gives a direct way to prove that one has a legal subtype relation. Our definition is difficult to use directly for those not versed in several semantic techniques.
Reference: [Nip86] <author> Tobias Nipkow. </author> <title> Non-deterministic Data Types: Models and Implementations. </title> <journal> Acta Informatica, </journal> <volume> 22(16) </volume> <pages> 629-661, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: of such a specification. (The standard initial model construction would add new elements to the carrier set of Int, and thus would not be a hierarchical model.) Furthermore, to allow the maximum expression of the incompleteness of such a specification, one might also wish to consider models with nondeterministic operations <ref> [Nip86] </ref> [Hes88]. If one considers models with nondeterministic operations, then the type IntSet can have subtypes. <p> Below (C; T ) def [ C U (1) If C is a -algebra, then it is understood that the preorder used in this abbreviation is the preorder on the sorts of . The extension of homomorphic relations to nondeterministic algebras was inspired by <ref> [Nip86] </ref>. However, as nondeterminism is not the main point of this paper, we would like to deemphasize it in our notation. So we use another abbreviation when comparing sets of possible results with a relation R T . <p> It would be interesting to know whether an analogous result holds in higher-order type systems, such as the calculus of constructions. But perhaps a more interesting extension would be to prove a "no surprises" result for a language that could make more observations <ref> [Nip86] </ref>. For example, the language could make more interesting observations if it was extended by such features as angelic nondeterminism, streamed output, and recursion. <p> This marriage of algebraic models and programming languages is certainly not new (see <ref> [Nip86] </ref>, for example), but we believe it provides a good theoretical playground for studying languages with abstract data types. We have not, as yet, fully investigated the equational theory of the simply typed 22 lambda calculus with subtypes.
Reference: [Rey80] <author> John C. Reynolds. </author> <title> Using Category Theory to Design Implicit Conversions and Generic Operators. </title> <editor> In Neil D. Jones, editor, </editor> <booktitle> Semantics-Directed Compiler Generation, Proceedings of a Workshop, Aarhus, Denmark, volume 94 24 of Lecture Notes in Computer Science, </booktitle> <pages> pages 211-258. </pages> <publisher> Springer-Verlag, </publisher> <month> Jan--uary </month> <year> 1980. </year>
Reference-contexts: One way to think of the R T component of a generalized relations is as the union of all of Bruce and Wegner's c S;U for all subtypes S and U of T . An earlier reference is Reynolds's work on category-sorted algebras <ref> [Rey80] </ref>, where similar "conversion functions" are required. We use algebraic models similar to category-sorted algebras. The major difference between our work and that of these authors is that we do not require the coercions between carrier sets to be internal to an algebra. <p> This essentially follows Reynolds <ref> [Rey80, Page 217] </ref>. The visible sorts (e.g., Bool) are used below to define observations. <p> This relation is not a II -simulation relation, since it does not satisfy the coercion property. However, the relation R 0 defined above that in addition relates [x; y] by R 0 IntSet to fz j x z yg is a II -simulation relation. In a category-sorted algebra <ref> [Rey80] </ref>, the family of conversion functions regarded as a family of relations will be a self-simulation. Not every II -algebra in the class II permits a self-simulation.
Reference: [Sta85] <author> R. Statman. </author> <title> Logical Relations and the Typed -Calculus. </title> <journal> Information and Control, </journal> 65(2/3):85-97, May/June 1985. 
Reference-contexts: Logical relations among models of the typed lambda calculus are families of relations indexed by type, so that elements of type T in one model are only related to elements of type T in the other model <ref> [Sta85] </ref>.
Reference: [WPP + 83] <author> Martin Wirsing, Peter Pepper, Helmut Partsch, Walter Dosch, and Manfred Broy. </author> <title> On Hierarchies of Abstract Data Types. </title> <journal> Acta Informatica, </journal> <volume> 20(1) </volume> <pages> 1-33, </pages> <month> October </month> <year> 1983. </year> <month> 25 </month>
Reference-contexts: In particular, such a construction may invalidate datatype induction. This concern arises because such a construction may build a model that is outside the intended class of the specification's models. For example, consider hierarchical specifications and hierarchical models <ref> [WPP + 83, Definition 15] </ref>. For modularity of specification and verification, one would consider the supertype's specification to be the base to which subtypes are added.
References-found: 17

