URL: http://www.cs.cornell.edu/kozen/686/Vardi/lics95.ps
Refering-URL: http://www.cs.cornell.edu/kozen/686/
Root-URL: 
Title: On the Complexity of Modular Model Checking  
Author: Moshe Y. Vardi 
Affiliation: Rice University  
Abstract: In modular verification the specification of a module consists of two parts. One part describes the guaranteed behavior of the module. The other part describes the assumed behavior of the environment with which the module is interacting. This is called the assume-guarantee paradigm. Even when one specifies the guaranteed behavior of the module in a branching temporal logic, the assumption in the assume- guarantee pair concerns the interaction of the environment with the module along each computation, and is therefore often naturally expressed in linear temporal logic. In this paper we consider assume-guarantee specifications in which the assumption is given by an LTL formula and the guarantee is given by a CTL formula. Verifying modules with respect to such specifications is called the linear-branching model-checking problem. We apply automata-theoretic techniques to obtain a model-checking algorithm whose running time is linear in the size of the module and the size of the CTL guarantee, but doubly exponential in the size of the LTL assumption. We also show that the high complexity in the size of the LTL specification is inherent by proving that the problem is EXPSPACE- complete. The lower bound applies even if the branching temporal guarantee is restricted to be specified in 8CTL, the universal fragment of CTL. 
Abstract-found: 1
Intro-found: 1
Reference: [AL93] <author> M. Abadi and L. Lamport. </author> <title> Composing specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 73-132, </pages> <year> 1993. </year>
Reference-contexts: If the size of the linear assumption ' is not too large and the doubly exponential blowup is avoided, then our algorithm might not be always impractical. Indeed, it is argued in <ref> [AL93] </ref> that assumption formulas should be small, simpler than guarantee formulas. Our result provide an a posteriori justification for Josko's restriction on the linear temporal assumption [Jos87a, Jos87b, Jos89]. In the full paper we will provide an automata-theoretic explanation for Josko's complexity results.
Reference: [ASSSV94] <author> A. Aziz, T.R. Shiple, V. Singhal, and A.L. Sangiovanni-Vincentelli. </author> <title> Formuladependent equivalence for compositional CTL model checking. </title> <booktitle> In Proc. 6th Conf. on Computer Aided Verification, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 324-337, </pages> <address> Stanford, CA, June 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: This issue is one of the most important one in the area of computer-aided verification and is the subject of active research (cf. [BCM + 90]). Modular verification is one possible way to address the state-explosion problem, cf. <ref> [CLM89, ASSSV94] </ref>.
Reference: [BCM + 90] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, and L.J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proceedings of the 5th Symposium on Logic in Computer Science, </booktitle> <pages> pages 428439, </pages> <address> Philadelphia, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: This gives rise to state spaces of exceedingly large sizes, which makes even linear-time algorithms impractical. This issue is one of the most important one in the area of computer-aided verification and is the subject of active research (cf. <ref> [BCM + 90] </ref>). Modular verification is one possible way to address the state-explosion problem, cf. [CLM89, ASSSV94].
Reference: [Buc62] <author> J.R. Buchi. </author> <title> On a decision method in re-stricted second order arithmetic. </title> <booktitle> In Proc. Internat. Congr. Logic, Method and Philos. Sci. </booktitle> <year> 1960, </year> <pages> pages 1-12, </pages> <address> Stanford, 1962. </address> <publisher> Stanford University Press. </publisher>
Reference-contexts: The formal definition of the relation j= can be found in [Eme90]. 2.2 Automata on Infinite Words For an introduction to the theory of automata on infinite words and trees see [Tho90]. The types of finite automata on infinite words we consider are those defined by Buchi <ref> [Buc62] </ref>.
Reference: [BV95] <author> O. Bernholtz and M.Y. Vardi. </author> <title> On the complexity of branching modular model checking. </title> <month> March </month> <year> 1995. </year>
Reference-contexts: It is not hard to see that 8CTL is easier to reason about than CTL. For example, while the sat- isfiability problem for CTL is EXPTIME-complete [FL79], it can be shown that the satisfiability problem for 8CTL is PSPACE-complete <ref> [BV95] </ref>. Nev- ertheless, Theorem 3.3 shows that even for branching temporal guarantees in 8CTL, the complexity of linear-branching model checking is EXPSPACE-hard. Clearly, M j= ' iff M 6j= ' : . <p> For many years, one of the beliefs dominating this discussion has been "model checking for CTL is easy, while model checking for LTL is hard". Our results show that this belief is not valid when one consider modular verification (furthermore, it is shown in <ref> [BV95] </ref> that modular model checking is computationally hard even when both assumptions and guarantees are given in 8CTL). This suggests that the tradeoff between CTL and LTL is not a simple tradeoff between complexity and expressiveness.
Reference: [BVW94] <author> O. Bernholtz, M.Y. Vardi, and P. Wolper. </author> <title> An automata-theoretic ap-proach to branching-time model checking. </title> <booktitle> In Computer Aided Verification, Proc. 6th Int. Workshop, </booktitle> <address> Stanford, California, </address> <month> June </month> <year> 1994. </year> <note> Lecture Notes in Computer Science, Springer-Verlag. full version avail-able from authors. </note>
Reference-contexts: We bring to bear on the problem the automata-theoretic techniques that were developed for linear and branching temporal logics <ref> [VW86, BVW94] </ref>. In both cases, one associates with each temporal formula a finite automaton on infinite structures that accepts exactly all the structures that satisfy the formula. <p> The labels of a node and its successors have to satisfy the transition function. The run is accepting if all its infinite paths satisfy the acceptance condition. For formal details see <ref> [BVW94, MS87] </ref>. In [BVW94], Bernholtz et al. introduce hesitant alternating automata (HAA). The acceptance condition of an HAA consists of a pair F = hG; Bi of subsets of S. <p> The labels of a node and its successors have to satisfy the transition function. The run is accepting if all its infinite paths satisfy the acceptance condition. For formal details see [BVW94, MS87]. In <ref> [BVW94] </ref>, Bernholtz et al. introduce hesitant alternating automata (HAA). The acceptance condition of an HAA consists of a pair F = hG; Bi of subsets of S. <p> The set of infinite trees accepted by A is denoted L ! (A). The number of sets in the partition of S is defined as the alternation depth of A. The following theorem establishes the correspondence between CTL and HAA. Theorem 2.3 <ref> [BVW94] </ref> Given a CTL formula and a finite set D IN, we can construct an HAA A D; = h2 AP ; D; S; s 0 ; ; F i, where jSj O (j j), such that L ! (A D; ) is exactly the set of computation trees, with branching <p> As is shown in <ref> [BVW94] </ref>, CTL model checking can be reduced to the 1-letter nonemptiness problem for HAA (i.e., the nonemptiness problem over 1-letter alphabets). Theorem 2.4 [BVW94] 1. The 1-letter nonemptiness problem for HAA is solvable in TIME (O (n)), where n is the size of the input automaton. 2. <p> As is shown in <ref> [BVW94] </ref>, CTL model checking can be reduced to the 1-letter nonemptiness problem for HAA (i.e., the nonemptiness problem over 1-letter alphabets). Theorem 2.4 [BVW94] 1. The 1-letter nonemptiness problem for HAA is solvable in TIME (O (n)), where n is the size of the input automaton. 2. <p> Finally, each of the set S and S is a minimal set of the partition. We now have to check that A D;'; accepts M t ' . As is shown in <ref> [BVW94] </ref>, this can be done by taking the product of A D;'; with M ' . The result is an HAA A M;'; over a 1-letter alphabet, where the size of A M;'; nm2 2 O (l) .
Reference: [CD88] <author> E.M. Clarke and I.A. Draghicescu. </author> <title> Expressibility results for linear-time and branching-time logics. In Proc. Workshop on Linear Time, Branching Time, </title> <booktitle> and Partial Order in Logics and Mod-els for Concurrency, </booktitle> <pages> pages 428-437. </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <address> SpringerVerlag, </address> <year> 1988. </year>
Reference-contexts: Put otherwise, a 8CTL formula in positive-normal form contains only A quantifiers. It is known that 8CTL can express properties that are not expressible in LTL; for exam-ple, the 8CTL formula AF AGp is not expressible in LTL <ref> [CD88] </ref>. It is not hard to see that 8CTL is easier to reason about than CTL. For example, while the sat- isfiability problem for CTL is EXPTIME-complete [FL79], it can be shown that the satisfiability problem for 8CTL is PSPACE-complete [BV95].
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finitestate concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: One of the most significant developments in this area is the discovery of algorithmic methods for verifying temporal logic properties of finite-state programs <ref> [CES86, LP85, QS81] </ref>. This derives its significance both from the fact that many synchronization and communication protocols can be modeled as finite-state programs, as well as from the great ease of use of fully algorithmic methods. <p> The complexity of model checking for both linear and branching temporal logics is well understood. Sup- pose we are given a program of size n and a temporal specification of size m. For a branching temporal logic such as CTL, model-checking algorithms run in time that O (nm) <ref> [CES86] </ref>, while, for linear temporal logic such as LTL, model-checking algorithms run in time O (n2 m ) [LP85]. The latter bound probably cannot be improved, since model checking with respect to linear temporal specification is PSPACE-complete [SC85]. <p> In contrast, the assumption in the assume-guarantee pair concerns the interaction of the environment with the module along each computation, and is therefore often naturally expressed in linear temporal logic. This point is already implicit in <ref> [CES86] </ref>. As explained there, in many applications we can prove that the module behaves in the desired way only under a fairness assumption. This assumption concerns the interaction of the environment with the module along every computation is not expressible in CTL. <p> This assumption concerns the interaction of the environment with the module along every computation is not expressible in CTL. For this reason, the basic model-checking algorithm for CTL is extended in <ref> [CES86] </ref> to handle also fairness assumptions (see also [EL85, EL87]).
Reference: [CG87] <author> E.M. Clarke and O. Grumberg. </author> <title> Research on automatic verification of finite-state concurrent systems. </title> <booktitle> In Annual Review of Computer Science, </booktitle> <volume> volume 2, </volume> <pages> pages 269290, </pages> <year> 1987. </year>
Reference-contexts: Hence the name model checking for the verification methods derived from this viewpoint. Surveys can be found in <ref> [CG87, Wol89, CGL93] </ref>. We distinguish between two types of temporal logics: linear and branching [Lam80]. In linear temporal logics, each moment in time has a unique possible future, while in branching temporal logics, each moment in time may split into several possible futures.
Reference: [CGL93] <author> E.M. Clarke, O. Grumberg, and D. </author> <title> Long. Verification tools for finite-state concur-rent systems. </title> <editor> In J.W. de Bakker, W.- P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Decade of Concurrency Reflections and Perspectives (Proceedings of REX School), Lecture Notes in Computer Science, </booktitle> <pages> pages 124-175. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Hence the name model checking for the verification methods derived from this viewpoint. Surveys can be found in <ref> [CG87, Wol89, CGL93] </ref>. We distinguish between two types of temporal logics: linear and branching [Lam80]. In linear temporal logics, each moment in time has a unique possible future, while in branching temporal logics, each moment in time may split into several possible futures.
Reference: [CLM89] <author> E.M. Clarke, D.E. Long, and K.L. McMillan. </author> <title> Compositional model checking. </title> <booktitle> In Proc. 4th IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 353-362, </pages> <year> 1989. </year>
Reference-contexts: This issue is one of the most important one in the area of computer-aided verification and is the subject of active research (cf. [BCM + 90]). Modular verification is one possible way to address the state-explosion problem, cf. <ref> [CLM89, ASSSV94] </ref>. <p> We note that it is argued in [LP85] that an exponential time complexity in the size of the specification might be tolerable in practical applications. Our results also provide an a posteriori justification to the approach taken in <ref> [CLM89] </ref> to avoid the assume- guarantee paradigm. Instead of describing the interaction of the module by an LTL formula, it is proposed there to model the environment by interface processes. As is shown there, these processes are typically much simpler than the full environment of the module.
Reference: [DDGJ89] <author> W. Damm, G. Dohmen, V. Gerstner, and B. Josko. </author> <title> Modular verification of Petri nets: the temporal logic approach. In Stepwise Refinement of Distributed Systems: Models, </title> <booktitle> Formalisms, Correctness (Proceedings of REX Workshop), volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 180-207, </pages> <address> Mook, The Netherlands, May/June 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: For this reason, the basic model-checking algorithm for CTL is extended in [CES86] to handle also fairness assumptions (see also [EL85, EL87]). This point was made explicit by Josko and his collaborators <ref> [Jos87a, Jos87b, Jos89, DDGJ89] </ref>, who have demonstrated by many examples that an assume- guarantee pair for branching temporal verification should consist of a linear temporal assumption ' and a branching temporal guarantee . <p> That is, in 8CTL one can state properties of all computations of the program, but one cannot state that certain computations exist. It has been argued by many researchers that this fragment is sufficiently expressive for many verification applications and is advantageous for modular verification (cf. <ref> [DDGJ89, Jos89, DGG93, GL94] </ref>). <p> Thus, in order to perform modular verification, one has to restrict attention to properties that have the upward preservation property, i.e., once they are satisfied in a module, they are satisfied also in every system that contains this module. For this reason, it is argued in <ref> [DDGJ89, Jos89, DGG93, GL94] </ref>, that in the context of modular verification in it advantageous to use only universal branching temporal logic, i.e., branching temporal logic without existential path quantifiers.
Reference: [DGG93] <author> D. Dams, O. Grumberg, and R. Gerth. </author> <title> Generation of reduced models for check-ing fragments of CTL. </title> <booktitle> In Proc. 5th Conf. on Computer Aided Verification, volume 697 of Lecture Notes in Computer Science, </booktitle> <pages> pages 479-490. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: That is, in 8CTL one can state properties of all computations of the program, but one cannot state that certain computations exist. It has been argued by many researchers that this fragment is sufficiently expressive for many verification applications and is advantageous for modular verification (cf. <ref> [DDGJ89, Jos89, DGG93, GL94] </ref>). <p> Thus, in order to perform modular verification, one has to restrict attention to properties that have the upward preservation property, i.e., once they are satisfied in a module, they are satisfied also in every system that contains this module. For this reason, it is argued in <ref> [DDGJ89, Jos89, DGG93, GL94] </ref>, that in the context of modular verification in it advantageous to use only universal branching temporal logic, i.e., branching temporal logic without existential path quantifiers.
Reference: [EL85] <author> E.A. Emerson and C.-L. Lei. </author> <title> Temporal model checking under generalized fairness constraints. </title> <booktitle> In Proc. 18th Hawaii International Conference on System Sciences, Hawaii, </booktitle> <year> 1985. </year>
Reference-contexts: This assumption concerns the interaction of the environment with the module along every computation is not expressible in CTL. For this reason, the basic model-checking algorithm for CTL is extended in [CES86] to handle also fairness assumptions (see also <ref> [EL85, EL87] </ref>). This point was made explicit by Josko and his collaborators [Jos87a, Jos87b, Jos89, DDGJ89], who have demonstrated by many examples that an assume- guarantee pair for branching temporal verification should consist of a linear temporal assumption ' and a branching temporal guarantee . <p> The set of infinite words accepted by A is denoted L ! (A). The automaton A is said to be nonempty if L ! (A) 6= ;. Theorem 2.1 1. <ref> [EL85, EL87] </ref> The nonemptiness problem for Buchi automata is solvable in linear time. 2. [VW94] The nonemptiness problem for Buchi automata is solvable in nondeterministic logarithmic space. The following theorem establishes the correspondence between LTL and Buchi automata.
Reference: [EL87] <author> E.A. Emerson and C.-L. Lei. </author> <title> Modalities for model checking: Branching time logic strikes back. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 275-306, </pages> <year> 1987. </year>
Reference-contexts: This assumption concerns the interaction of the environment with the module along every computation is not expressible in CTL. For this reason, the basic model-checking algorithm for CTL is extended in [CES86] to handle also fairness assumptions (see also <ref> [EL85, EL87] </ref>). This point was made explicit by Josko and his collaborators [Jos87a, Jos87b, Jos89, DDGJ89], who have demonstrated by many examples that an assume- guarantee pair for branching temporal verification should consist of a linear temporal assumption ' and a branching temporal guarantee . <p> The set of infinite words accepted by A is denoted L ! (A). The automaton A is said to be nonempty if L ! (A) 6= ;. Theorem 2.1 1. <ref> [EL85, EL87] </ref> The nonemptiness problem for Buchi automata is solvable in linear time. 2. [VW94] The nonemptiness problem for Buchi automata is solvable in nondeterministic logarithmic space. The following theorem establishes the correspondence between LTL and Buchi automata.
Reference: [Eme83] <author> E.A. Emerson. </author> <title> Alternative semantics for temporal logics. </title> <journal> Theoretical Computer Science, </journal> <volume> 26 </volume> <pages> 121-130, </pages> <year> 1983. </year>
Reference-contexts: We then say that M satisfies with respect to ', denoted M j= ' , if M t ; w 0 j= ' . It remains to define satisfaction in M t . We follow the framework of generalized temporal semantics in <ref> [Eme83] </ref>. A path in M t is an infinite sequence 0 ; 1 ; : : :. where ( i ; i+1 ) 2 R t for all i 0. We say that the path is anchored if 0 is w 0 .
Reference: [Eme90] <author> E.A. Emerson. </author> <title> Temporal and modal logic. </title> <booktitle> Handbook of theoretical computer science, </booktitle> <pages> pages 997-1072, </pages> <year> 1990. </year>
Reference-contexts: We use the notation P; w j= ' to denote that ' holds at state w of the program P . The formal definition of the relation j= can be found in <ref> [Eme90] </ref>. 2.2 Automata on Infinite Words For an introduction to the theory of automata on infinite words and trees see [Tho90]. The types of finite automata on infinite words we consider are those defined by Buchi [Buc62].
Reference: [FL79] <author> M.J. Fischer and R.E. Ladner. </author> <title> Propositional dynamic logic of regular programs. </title> <journal> J. of Computer and Systems Sciences, </journal> <volume> 18 </volume> <pages> 194-211, </pages> <year> 1979. </year>
Reference-contexts: It is not hard to see that 8CTL is easier to reason about than CTL. For example, while the sat- isfiability problem for CTL is EXPTIME-complete <ref> [FL79] </ref>, it can be shown that the satisfiability problem for 8CTL is PSPACE-complete [BV95]. Nev- ertheless, Theorem 3.3 shows that even for branching temporal guarantees in 8CTL, the complexity of linear-branching model checking is EXPSPACE-hard. Clearly, M j= ' iff M 6j= ' : .
Reference: [GL94] <author> O. Grumberg and D.E. </author> <title> Long. Model checking and modular verification. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 843-871, </pages> <year> 1994. </year>
Reference-contexts: That is, in 8CTL one can state properties of all computations of the program, but one cannot state that certain computations exist. It has been argued by many researchers that this fragment is sufficiently expressive for many verification applications and is advantageous for modular verification (cf. <ref> [DDGJ89, Jos89, DGG93, GL94] </ref>). <p> Thus, in order to perform modular verification, one has to restrict attention to properties that have the upward preservation property, i.e., once they are satisfied in a module, they are satisfied also in every system that contains this module. For this reason, it is argued in <ref> [DDGJ89, Jos89, DGG93, GL94] </ref>, that in the context of modular verification in it advantageous to use only universal branching temporal logic, i.e., branching temporal logic without existential path quantifiers.
Reference: [Jon83] <author> C.B. Jones. </author> <title> Specification and de-sign of (parallel) programs. In R.E.A. </title> <editor> Mason, editor, </editor> <booktitle> Information Processing 83: Proceedings of the IFIP 9th World Congress, </booktitle> <pages> pages 321-332. </pages> <publisher> IFIP, </publisher> <address> NorthHolland, </address> <year> 1983. </year>
Reference-contexts: Thus, efforts to develop modular verification frameworks were undertaken in the mid 1980s; [Pnu85] is a good survey. A key observation, see <ref> [Jon83, Lam83] </ref>, is that in modular verification the specification should include two parts. One part describes the desired behavior of the module. The other part describes the assumed behavior of the environment with which the module is interacting.
Reference: [Jos87a] <author> B. Josko. </author> <title> MCTL an extension of CTL for modular verification of concurrent sys-tems. In Temporal Logic in Specification, </title> <booktitle> Proceedings, volume 398 of Lecture Notes in Computer Science, </booktitle> <pages> pages 165-187, </pages> <address> Altrincham,UK, </address> <month> April </month> <year> 1987. </year> <month> SpringerVerlag. </month>
Reference-contexts: For this reason, the basic model-checking algorithm for CTL is extended in [CES86] to handle also fairness assumptions (see also [EL85, EL87]). This point was made explicit by Josko and his collaborators <ref> [Jos87a, Jos87b, Jos89, DDGJ89] </ref>, who have demonstrated by many examples that an assume- guarantee pair for branching temporal verification should consist of a linear temporal assumption ' and a branching temporal guarantee . <p> The problem of verifying that a given module satisfies such a pair, which we call the linear-branching model-checking problem, is more general than either linear or branching model checking and has received little attention in the literature. Josko has considered a special case of the linear- branching model-checking problem <ref> [Jos87a, Jos87b, Jos89] </ref>. In his formalism, called MCTL, an assume- guarantee pair h'; i consists of a CTL formula and an LTL formula ' of a special form (Josko also defined GMCTL, in which somewhat more general LTL formulas are allowed). <p> To see that note that if the linear temporal assumption ' is the LTL formula true, then M j= ' iff M j= . Also, if the branching temporal guarantee is the CTL formula 1 We note that the formal definitions in <ref> [Jos87a, Jos87b, Jos89] </ref> apply only to restricted linear temporal assumptions and involve a complicated syntactic construction. Afalse, then M j= ' iff M j= :'. We now show how linear temporal model checking and branching temporal model checking can be combined to yield a linear- branching model-checking algorithm. <p> Thus, in a universal branching temporal logic one can state properties of all computations of a program, but one cannot state that certain computations exist. Consequently, universal branching temporal logic formulas have the upward preservartion property. Under this restriction <ref> [Jos87a, Jos87b, Jos89] </ref>, assume-guarantee assertions are used in modular proof rules of the following form: h' 2 iM 1 h 1 i htrueiM 1 hbr (' 1 )i h' 1 iM 2 h 2 i htrueiM 1 hbr (' 2 )i 9 &gt; ; htrueiM 1 kM 2 h 1 ^ <p> Indeed, it is argued in [AL93] that assumption formulas should be small, simpler than guarantee formulas. Our result provide an a posteriori justification for Josko's restriction on the linear temporal assumption <ref> [Jos87a, Jos87b, Jos89] </ref>. In the full paper we will provide an automata-theoretic explanation for Josko's complexity results. Essentially, because of the restriction imposed on the linear temporal assumption, one can get more economical automata-theoretic construction (exponential rather than doubly exponential) of M ' .
Reference: [Jos87b] <author> B. Josko. </author> <title> Model checking of CTL formu-lae under liveness assumptions. </title> <booktitle> In Proc. 14th Colloq. on Automata, Programming, and Languages (ICALP), volume 267 of Lecture Notes in Computer Science, </booktitle> <pages> pages 280-289. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1987. </year>
Reference-contexts: For this reason, the basic model-checking algorithm for CTL is extended in [CES86] to handle also fairness assumptions (see also [EL85, EL87]). This point was made explicit by Josko and his collaborators <ref> [Jos87a, Jos87b, Jos89, DDGJ89] </ref>, who have demonstrated by many examples that an assume- guarantee pair for branching temporal verification should consist of a linear temporal assumption ' and a branching temporal guarantee . <p> The problem of verifying that a given module satisfies such a pair, which we call the linear-branching model-checking problem, is more general than either linear or branching model checking and has received little attention in the literature. Josko has considered a special case of the linear- branching model-checking problem <ref> [Jos87a, Jos87b, Jos89] </ref>. In his formalism, called MCTL, an assume- guarantee pair h'; i consists of a CTL formula and an LTL formula ' of a special form (Josko also defined GMCTL, in which somewhat more general LTL formulas are allowed). <p> To see that note that if the linear temporal assumption ' is the LTL formula true, then M j= ' iff M j= . Also, if the branching temporal guarantee is the CTL formula 1 We note that the formal definitions in <ref> [Jos87a, Jos87b, Jos89] </ref> apply only to restricted linear temporal assumptions and involve a complicated syntactic construction. Afalse, then M j= ' iff M j= :'. We now show how linear temporal model checking and branching temporal model checking can be combined to yield a linear- branching model-checking algorithm. <p> Thus, in a universal branching temporal logic one can state properties of all computations of a program, but one cannot state that certain computations exist. Consequently, universal branching temporal logic formulas have the upward preservartion property. Under this restriction <ref> [Jos87a, Jos87b, Jos89] </ref>, assume-guarantee assertions are used in modular proof rules of the following form: h' 2 iM 1 h 1 i htrueiM 1 hbr (' 1 )i h' 1 iM 2 h 2 i htrueiM 1 hbr (' 2 )i 9 &gt; ; htrueiM 1 kM 2 h 1 ^ <p> Indeed, it is argued in [AL93] that assumption formulas should be small, simpler than guarantee formulas. Our result provide an a posteriori justification for Josko's restriction on the linear temporal assumption <ref> [Jos87a, Jos87b, Jos89] </ref>. In the full paper we will provide an automata-theoretic explanation for Josko's complexity results. Essentially, because of the restriction imposed on the linear temporal assumption, one can get more economical automata-theoretic construction (exponential rather than doubly exponential) of M ' .
Reference: [Jos89] <author> B. Josko. </author> <title> Verifying the correctness of AADL modules using model chekcing. In Stepwise Refinement of Distributed Systems: Models, </title> <booktitle> Formalisms, Correctness (Proceedings of REX Workshop), volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 386-400, </pages> <address> Mook, The Netherlands, May/June 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: For this reason, the basic model-checking algorithm for CTL is extended in [CES86] to handle also fairness assumptions (see also [EL85, EL87]). This point was made explicit by Josko and his collaborators <ref> [Jos87a, Jos87b, Jos89, DDGJ89] </ref>, who have demonstrated by many examples that an assume- guarantee pair for branching temporal verification should consist of a linear temporal assumption ' and a branching temporal guarantee . <p> The problem of verifying that a given module satisfies such a pair, which we call the linear-branching model-checking problem, is more general than either linear or branching model checking and has received little attention in the literature. Josko has considered a special case of the linear- branching model-checking problem <ref> [Jos87a, Jos87b, Jos89] </ref>. In his formalism, called MCTL, an assume- guarantee pair h'; i consists of a CTL formula and an LTL formula ' of a special form (Josko also defined GMCTL, in which somewhat more general LTL formulas are allowed). <p> That is, in 8CTL one can state properties of all computations of the program, but one cannot state that certain computations exist. It has been argued by many researchers that this fragment is sufficiently expressive for many verification applications and is advantageous for modular verification (cf. <ref> [DDGJ89, Jos89, DGG93, GL94] </ref>). <p> To see that note that if the linear temporal assumption ' is the LTL formula true, then M j= ' iff M j= . Also, if the branching temporal guarantee is the CTL formula 1 We note that the formal definitions in <ref> [Jos87a, Jos87b, Jos89] </ref> apply only to restricted linear temporal assumptions and involve a complicated syntactic construction. Afalse, then M j= ' iff M j= :'. We now show how linear temporal model checking and branching temporal model checking can be combined to yield a linear- branching model-checking algorithm. <p> Thus, in order to perform modular verification, one has to restrict attention to properties that have the upward preservation property, i.e., once they are satisfied in a module, they are satisfied also in every system that contains this module. For this reason, it is argued in <ref> [DDGJ89, Jos89, DGG93, GL94] </ref>, that in the context of modular verification in it advantageous to use only universal branching temporal logic, i.e., branching temporal logic without existential path quantifiers. <p> Thus, in a universal branching temporal logic one can state properties of all computations of a program, but one cannot state that certain computations exist. Consequently, universal branching temporal logic formulas have the upward preservartion property. Under this restriction <ref> [Jos87a, Jos87b, Jos89] </ref>, assume-guarantee assertions are used in modular proof rules of the following form: h' 2 iM 1 h 1 i htrueiM 1 hbr (' 1 )i h' 1 iM 2 h 2 i htrueiM 1 hbr (' 2 )i 9 &gt; ; htrueiM 1 kM 2 h 1 ^ <p> Indeed, it is argued in [AL93] that assumption formulas should be small, simpler than guarantee formulas. Our result provide an a posteriori justification for Josko's restriction on the linear temporal assumption <ref> [Jos87a, Jos87b, Jos89] </ref>. In the full paper we will provide an automata-theoretic explanation for Josko's complexity results. Essentially, because of the restriction imposed on the linear temporal assumption, one can get more economical automata-theoretic construction (exponential rather than doubly exponential) of M ' .
Reference: [Lam80] <author> L. Lamport. </author> <title> Sometimes is sometimes "not never" on the temporal logic of pro-grams. </title> <booktitle> In Proceedings of the 7th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 174-185, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: Hence the name model checking for the verification methods derived from this viewpoint. Surveys can be found in [CG87, Wol89, CGL93]. We distinguish between two types of temporal logics: linear and branching <ref> [Lam80] </ref>. In linear temporal logics, each moment in time has a unique possible future, while in branching temporal logics, each moment in time may split into several possible futures. The complexity of model checking for both linear and branching temporal logics is well understood.
Reference: [Lam83] <author> L. Lamport. </author> <title> Specifying concurrent pro-gram modules. </title> <journal> ACM Trans. on Programming Languages and Systenms, </journal> <volume> 5 </volume> <pages> 190-222, </pages> <year> 1983. </year>
Reference-contexts: Thus, efforts to develop modular verification frameworks were undertaken in the mid 1980s; [Pnu85] is a good survey. A key observation, see <ref> [Jon83, Lam83] </ref>, is that in modular verification the specification should include two parts. One part describes the desired behavior of the module. The other part describes the assumed behavior of the environment with which the module is interacting.
Reference: [LP85] <author> O. Lichtenstein and A. Pnueli. </author> <title> Checking that finite state concurrent programs satisfy their linear specification. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 97-107, </pages> <address> New Orleans, </address> <month> January </month> <year> 1985. </year>
Reference-contexts: One of the most significant developments in this area is the discovery of algorithmic methods for verifying temporal logic properties of finite-state programs <ref> [CES86, LP85, QS81] </ref>. This derives its significance both from the fact that many synchronization and communication protocols can be modeled as finite-state programs, as well as from the great ease of use of fully algorithmic methods. <p> For a branching temporal logic such as CTL, model-checking algorithms run in time that O (nm) [CES86], while, for linear temporal logic such as LTL, model-checking algorithms run in time O (n2 m ) <ref> [LP85] </ref>. The latter bound probably cannot be improved, since model checking with respect to linear temporal specification is PSPACE-complete [SC85]. The difference in the complexity of linear and branching model checking has been viewed as an argument in favor of the branching paradigm. <p> It will be interesting to find other fragments of LTL (perhaps the fragment studied in [SZ93]) for which we can obtain such a complexity bound. We note that it is argued in <ref> [LP85] </ref> that an exponential time complexity in the size of the specification might be tolerable in practical applications. Our results also provide an a posteriori justification to the approach taken in [CLM89] to avoid the assume- guarantee paradigm.
Reference: [MS87] <author> D.E. Muller and P.E. Schupp. </author> <title> Alternat-ing automata on infinite trees. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 54,:267-276, </address> <year> 1987. </year>
Reference-contexts: AP ; S; S 0 ; ; F i, where jSj 2 O (j'j) , such that L ! (A ' ) is exactly the set of computations satisfying the formula '. 2.3 Alternating Tree Automata Alternating automata on infinite trees generalize nondeterministic tree automata and were first introduced in <ref> [MS87] </ref>. For simplicity, we refer first to automata over infinite binary trees. <p> The labels of a node and its successors have to satisfy the transition function. The run is accepting if all its infinite paths satisfy the acceptance condition. For formal details see <ref> [BVW94, MS87] </ref>. In [BVW94], Bernholtz et al. introduce hesitant alternating automata (HAA). The acceptance condition of an HAA consists of a pair F = hG; Bi of subsets of S.
Reference: [Pnu77] <author> A. Pnueli. </author> <title> The temporal logic of pro-grams. </title> <booktitle> In Proc. 18th IEEE Symposium on Foundation of Computer Science, </booktitle> <pages> pages 46-57, </pages> <year> 1977. </year>
Reference-contexts: 1 Introduction Temporal logics, which are modal logics geared towards the description of the temporal ordering of events, have been adopted as a powerful tool for specifying and verifying concurrent programs <ref> [Pnu77, Pnu81] </ref>. One of the most significant developments in this area is the discovery of algorithmic methods for verifying temporal logic properties of finite-state programs [CES86, LP85, QS81].
Reference: [Pnu81] <author> A. Pnueli. </author> <title> The temporal semantics of con-current programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 13 </volume> <pages> 45-60, </pages> <year> 1981. </year>
Reference-contexts: 1 Introduction Temporal logics, which are modal logics geared towards the description of the temporal ordering of events, have been adopted as a powerful tool for specifying and verifying concurrent programs <ref> [Pnu77, Pnu81] </ref>. One of the most significant developments in this area is the discovery of algorithmic methods for verifying temporal logic properties of finite-state programs [CES86, LP85, QS81].
Reference: [Pnu85] <author> A. Pnueli. </author> <title> In transition from global to modular temporal reasoning about pro-grams. </title> <editor> In K. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, volume F13 of NATO Advanced Summer Institutes, </booktitle> <pages> pages 123-144. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Modu- lar verification is advocated also for other methodological reasons; a robust verification methodology should provide rules for deducing properties of programs from the properties of their constituent modules. Thus, efforts to develop modular verification frameworks were undertaken in the mid 1980s; <ref> [Pnu85] </ref> is a good survey. A key observation, see [Jon83, Lam83], is that in modular verification the specification should include two parts. One part describes the desired behavior of the module. The other part describes the assumed behavior of the environment with which the module is interacting. <p> The meaning of such a pair is that the behavior of the module is guaranteed to satisfy , assuming that the behavior of the environment satisfies '. As observed in <ref> [Pnu85] </ref>, in this case the assume-guarantee pair can be combined to a single linear temporal specification ' ! . Thus, verifying a module with respect to assume-guarantee linear temporal pairs is essentially the same as verifying the module with respect to linear temporal formulas.
Reference: [QS81] <author> J.P. Queille and J. Sifakis. </author> <title> Specification and verification of concurrent systems in Cesar. </title> <booktitle> In Proc. 5th Int'l Symp. on Programming, </booktitle> <volume> volume 137, </volume> <pages> pages 337-351. </pages> <note> Springer-Verlag, Lecture Notes in Computer Science, </note> <year> 1981. </year>
Reference-contexts: One of the most significant developments in this area is the discovery of algorithmic methods for verifying temporal logic properties of finite-state programs <ref> [CES86, LP85, QS81] </ref>. This derives its significance both from the fact that many synchronization and communication protocols can be modeled as finite-state programs, as well as from the great ease of use of fully algorithmic methods.
Reference: [RS59] <author> M.O. Rabin and D. Scott. </author> <title> Finite au-tomata and their decision problems. </title> <institution> IBM J. of Research and Development, 3:115125, </institution> <year> 1959. </year>
Reference-contexts: We then apply to A ' the classical subset construction of <ref> [RS59] </ref>, that is, we extend to a mapping from 2 S fi 2 AP to 2 S as follows: (X; a) = ft 2 S : t 2 (s; a) for some s 2 Xg: We now combine the subset transition diagram of A ' with M .
Reference: [Sav70] <author> W.J. Savitch. </author> <title> Relationship between non-deterministic and deterministic tape com-plexities. </title> <journal> J. on Computer and System Sciences, </journal> <volume> 4 </volume> <pages> 177-192, </pages> <year> 1970. </year>
Reference-contexts: It is easy to see that the alternation depth of A M;'; is O (jpsij). Thus, we can check nonempti <p>- ness in NSPACE (O (m (log n + log m + 2 O (l) ))). The claimed bound then follows by the Savitch Theorem <ref> [Sav70] </ref>. Remark. The algorithms above can be extended to handle branching temporal guarantees in CTL fl .
Reference: [SC85] <author> A.P. Sistla and E.M. Clarke. </author> <title> The com-plexity of propositional linear temporal logic. </title> <journal> J. ACM, </journal> <volume> 32 </volume> <pages> 733-749, </pages> <year> 1985. </year>
Reference-contexts: The latter bound probably cannot be improved, since model checking with respect to linear temporal specification is PSPACE-complete <ref> [SC85] </ref>. The difference in the complexity of linear and branching model checking has been viewed as an argument in favor of the branching paradigm. Model checking suffers, however, from the so-called state-explosion problem. In a concurrent setting, the program under consideration is typically the parallel composition of many modules. <p> Josko also showed that the PSPACE-hardness lower bound for linear model checking <ref> [SC85] </ref> applies also to the linear-branching model-checking problem. In this paper we investigate the linear-branching model-checking problem in its full generality, i.e., we allow the assumption to be specified by an arbitrary LTL formula and the guarantee to be specified by an arbitrary CTL formula.
Reference: [SZ93] <author> A.P. Sistla and L.D. Zuck. </author> <title> Reasoning in a restricted temporal logic. </title> <journal> Information and Computation, </journal> <volume> 102(2) </volume> <pages> 167-195, </pages> <year> 1993. </year>
Reference-contexts: In particular, under this restriction we can show a space bound of O (i.e., polyno <p>- mial rather than exponential in the size of '). It will be interesting to find other fragments of LTL (perhaps the fragment studied in <ref> [SZ93] </ref>) for which we can obtain such a complexity bound. We note that it is argued in [LP85] that an exponential time complexity in the size of the specification might be tolerable in practical applications.
Reference: [Tho90] <author> W. Thomas. </author> <title> Automata on infinite objects. </title> <booktitle> Handbook of theoretical computer science, </booktitle> <pages> pages 165-191, </pages> <year> 1990. </year>
Reference-contexts: The formal definition of the relation j= can be found in [Eme90]. 2.2 Automata on Infinite Words For an introduction to the theory of automata on infinite words and trees see <ref> [Tho90] </ref>. The types of finite automata on infinite words we consider are those defined by Buchi [Buc62].
Reference: [VS85] <author> M.Y. Vardi and L. Stockmeyer. </author> <title> Improved upper and lower bounds for modal logics of programs. </title> <booktitle> In Proc 17th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 240-251, </pages> <year> 1985. </year>
Reference-contexts: By taking N to be a machine that accepts an EXPSPACE-complete language, we can fix N and vary only x. Our encoding is somewhat similar to the encoding used in <ref> [VS85] </ref> to prove that satisfiability of CTL fl is 2EXPTIME-complete. There is a basic difficulty, however, in adapting the encoding of [VS85]. The formula constructed there uses O (jxj) atomic propositions, and essentially all 2 O (jxj) truth assignments to these propositions occur in the intended model of this formula. <p> Our encoding is somewhat similar to the encoding used in <ref> [VS85] </ref> to prove that satisfiability of CTL fl is 2EXPTIME-complete. There is a basic difficulty, however, in adapting the encoding of [VS85]. The formula constructed there uses O (jxj) atomic propositions, and essentially all 2 O (jxj) truth assignments to these propositions occur in the intended model of this formula. <p> To be able to do such a comparison, it is not sufficient to consider one path in the module. While one "real" path represents the computation of N , we need to introduce many auxiliary paths, as in <ref> [VS85] </ref>. An atomic proposition I will hold on the real path and fail on the auxiliary paths.
Reference: [VW86] <author> M.Y. Vardi and P. Wolper. </author> <title> An automatatheoretic approach to automatic program verification. </title> <booktitle> In Proceedings of the First Symposium on Logic in Computer Science, </booktitle> <pages> pages 322-331, </pages> <address> Cambridge, </address> <month> June </month> <year> 1986. </year>
Reference-contexts: We bring to bear on the problem the automata-theoretic techniques that were developed for linear and branching temporal logics <ref> [VW86, BVW94] </ref>. In both cases, one associates with each temporal formula a finite automaton on infinite structures that accepts exactly all the structures that satisfy the formula.
Reference: [VW94] <author> M.Y. Vardi and P. Wolper. </author> <title> Reasoning about infinite computations. </title> <journal> Information and Computation, </journal> <volume> 115(1) </volume> <pages> 1-37, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: The set of infinite words accepted by A is denoted L ! (A). The automaton A is said to be nonempty if L ! (A) 6= ;. Theorem 2.1 1. [EL85, EL87] The nonemptiness problem for Buchi automata is solvable in linear time. 2. <ref> [VW94] </ref> The nonemptiness problem for Buchi automata is solvable in nondeterministic logarithmic space. The following theorem establishes the correspondence between LTL and Buchi automata. Theorem 2.2 [VW94] Given an LTL formula ', one can build a Buchi automaton A ' = h2 AP ; S; S 0 ; ; F i, <p> Theorem 2.1 1. [EL85, EL87] The nonemptiness problem for Buchi automata is solvable in linear time. 2. <ref> [VW94] </ref> The nonemptiness problem for Buchi automata is solvable in nondeterministic logarithmic space. The following theorem establishes the correspondence between LTL and Buchi automata. Theorem 2.2 [VW94] Given an LTL formula ', one can build a Buchi automaton A ' = h2 AP ; S; S 0 ; ; F i, where jSj 2 O (j'j) , such that L ! (A ' ) is exactly the set of computations satisfying the formula '. 2.3 Alternating Tree
Reference: [Wol89] <author> P. Wolper. </author> <title> On the relation of programs and computations to models of temporal logic. </title> <editor> In B. Banieqbal, H. Barringer, and A. Pnueli, editors, </editor> <booktitle> Proc. Temporal Logic in Specification, </booktitle> <volume> volume 398, </volume> <pages> pages 75123. </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: Hence the name model checking for the verification methods derived from this viewpoint. Surveys can be found in <ref> [CG87, Wol89, CGL93] </ref>. We distinguish between two types of temporal logics: linear and branching [Lam80]. In linear temporal logics, each moment in time has a unique possible future, while in branching temporal logics, each moment in time may split into several possible futures.
References-found: 40

