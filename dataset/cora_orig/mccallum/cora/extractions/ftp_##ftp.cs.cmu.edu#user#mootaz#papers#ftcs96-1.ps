URL: ftp://ftp.cs.cmu.edu/user/mootaz/papers/ftcs96-1.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/user/mootaz/ftp/html/pub.html
Root-URL: 
Title: Support for Software Interrupts in Log-Based Rollback-Recovery  
Author: J. Hamilton Slye E.N. Elnozahy 
Keyword: Index Terms: Checkpointing, Distributed Systems, Instruction Counters, Mes sage Logging, Rollback-Recovery.  
Date: July 27, 1997  
Affiliation: Transarc IBM Austin Research Lab  
Abstract: The piecewise deterministic execution model is a fundamental assumption in many log-based rollback-recovery protocols. Process execution in this model consists of intervals, each starting with the receipt of a message at an application-defined execution point. Execution within each interval is deterministic and messages are the only source of nondeterminism that affects the computation. This simple model excludes many forms of nondeterminism that exist in practice. In particular, applications may experience nondeterminism due to receiving asynchronous signals or interrupts at arbitrary execution points. Also, multithreaded applications experience nondeterminism due to interleaved shared memory access among threads. We present a solution that removes these restrictions and enables support for these two forms of nondeterminism in log-based rollback-recovery. Our solution relies on using a software counter to compute the number of instructions between the asynchronous signals during normal operation. Should a failure occur, the instruction counts are used to force the replay of these signals at the same execution points. The execution of the application thus can be replayed to recreate the pre-failure state, while accommodating nondeterminism due to asynchronous signals. We also use this technique to support a user-level thread package in which thread scheduling decisions can be replayed if a failure occurs. By repeating the scheduling decisions during an execution replay, threads access the shared memory in the same order and the execution is reconstructed. Performance measurements show that the overhead due to this technique is no more than a 6% slowdown in execution on the DEC Alpha, and from 6% to 18% on the Intel Pentium. Thus, restrictions of the piecewise deterministic execution model can be lifted at a reasonable cost. fl This research was supported in part by the National Science Foundation under grants CCR 9410116 and CCR 9502933, and by the Advanced Research Project Agency under contract DABT63-93-C-0054. The views in this paper do not necessarily reflect those of the sponsors. A preliminary version of about half the work in this paper was presented in the 26 th Symposium on Fault-Tolerant Computing Systems, June 1996. The experimental work was done while both authors were at Carnegie Mellon University. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Alvisi, B. Hoppe, and K. Marzullo. </author> <title> Nonblocking and orphan-free message logging protocols. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 145-154, </pages> <year> 1993. </year>
Reference: [2] <author> L. Alvisi and K. Marzullo. </author> <title> Message logging: Pessimistic, optimistic, and causal. </title> <booktitle> In Proc. IEEE Int. Conf. </booktitle> <institution> Distributed Comput. Syst., </institution> <year> 1995. </year> <month> 17 </month>
Reference-contexts: The log typically contains the messages that a process receives during normal operation. Should a failure occur, a process restarts from a saved checkpoint and reconstructs its pre-failure execution by replaying the messages from the log. Different flavors of logging have been suggested with different performance and resilience characteristics <ref> [2] </ref>. Despite these differences, most protocols commonly rely on the piecewise deterministic execution model [13]. Process execution in this model consists of a sequence of intervals, each starting with the receipt of a message at an application-defined execution point.
Reference: [3] <author> D. Bacon. </author> <title> File system measurements and their applications to the design of efficient operation logging algorithm. </title> <booktitle> In Proceedings of the 10th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 21-30, </pages> <month> Oct. </month> <year> 1991. </year>
Reference: [4] <author> P. Barrett, A. Hilborne, P. Verissimo, L. Rodrigues, P. Bond, D. Seaton, and N. Speirs. </author> <title> The Delta-4 extra performance architecture XPA. </title> <booktitle> In Proceedings of the 20th International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 481-488, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Additionally, the V kernel's small context switching time allowed the usage of system-provided semaphores with an acceptable penalty. These limitations, however, could make this technique impractical in other systems. The Delta-4 system handled nondeterministic execution in active process replication <ref> [4, 9] </ref>. Their technique, certainly applicable to rollback-recovery, relied on modifying the application program to use polling. Interrupts are queued until the application program executes a polling routine, in which all replicas synchronize and agree on which interrupts were received and the order in which they are processed.
Reference: [5] <author> A. Borg, J. Baumbach, and S. Glazer. </author> <title> A message system supporting fault toler ance. </title> <booktitle> In Proceedings of the 9th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 90-99, </pages> <month> Oct. </month> <year> 1983. </year>
Reference: [6] <author> A. Borg, W. Blau, W. Graetsch, F. Herrmann, and W. Oberle. </author> <title> Fault tolerance under UNIX. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 7(1) </volume> <pages> 1-24, </pages> <month> Feb. </month> <year> 1989. </year>
Reference-contexts: The solution in this paper does not handle other types of nondeterminism, such as results from system calls and values read from an external input source or message. These have been handled by previous work <ref> [6, 11, 16, 17] </ref>. The performance study also is independent from any particular checkpointing or logging protocol to prevent any interference with the measurements. The rest of the paper is organized as follows. Section 2 describes the method proposed for tracking interrupts in modern RISC and CISC architecture. <p> This solution, however, would not work for a primary-backup system because the backup would be unable to keep up with the primary in execution speed. Other systems handled nondeterminism due to signals by converting them into synchronous messages that the application can receive at well defined points. The Targon/32 <ref> [6] </ref> system relied on hardware for efficient logging of messages exchanged between processes. To support nondeterministic execution, the operating system was rewritten to transform all asynchronous events into synchronous messages.
Reference: [7] <author> T. Bressoud and F. Schneider. </author> <title> Hypervisor-based fault tolerance. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles, </booktitle> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: These results again support the claim of the viability of the proposed technique in tracking nondeterminism. 15 5 Comparisons to Related Work Previous fault-tolerant systems used different techniques to handle nondeterminism. The Hypervisor system uses hardware instruction counters to support primary-backup replication <ref> [7] </ref>. It exploits the hardware instruction counter available in the HP PA-RISC architecture. A virtual machine layer is inserted beneath the operating system. This layer uses the hardware counter to count instructions between hardware interrupts. It also records information about each interrupt at the primary machine.
Reference: [8] <author> T. Cargill and B. Locanthi. </author> <title> Cheap hardware support for software debugging and profiling. </title> <booktitle> In Proceedings of the 2nd Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 82-83, </pages> <month> Oct. </month> <year> 1987. </year>
Reference-contexts: Thus, if the program always starts from a given state and receives the same interrupts at the same execution points, it will produce the same output. We use instruction counters to enable this form of repeatable execution <ref> [8] </ref>. Using these counters, it is possible to log the number of instructions executed between consecutive interrupts during normal operation. If a failure occurs, the instruction counts in the log and the counters are used to reapply the signals at the same execution points. <p> We first describe instruction counters and then show how we emulated them in software on two different architectures. 2.1 Instruction Counters An instruction counter is a register that is decremented upon the execution of each instruction <ref> [8] </ref>. The hardware generates an exception when the register content becomes zero. An instruction counter can be used in two modes. In one, the register is loaded with the number of instructions to be executed. <p> For example, a 32-bit register would underflow every 20 seconds of execution on a 200 MHz machine. Reinitializing the register at well defined points resolves this issue. The use of instruction counters has been suggested for debugging shared memory parallel programs <ref> [8, 25, 28] </ref>. Instruction counters may be available in hardware, as in the HP PA-RISC architecture. They also can be emulated in software [25]. The emulation uses the observation that a count of instructions is not strictly necessary for execution replay.
Reference: [9] <author> M. Chereque, D. Powell, P. Reynier, J.-L. Richier, and J. Voiron. </author> <title> Active replication in Delta-4. </title> <booktitle> In Proceedings of the 22nd International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 28-37, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Additionally, the V kernel's small context switching time allowed the usage of system-provided semaphores with an acceptable penalty. These limitations, however, could make this technique impractical in other systems. The Delta-4 system handled nondeterministic execution in active process replication <ref> [4, 9] </ref>. Their technique, certainly applicable to rollback-recovery, relied on modifying the application program to use polling. Interrupts are queued until the application program executes a polling routine, in which all replicas synchronize and agree on which interrupts were received and the order in which they are processed.
Reference: [10] <author> D. Cheriton. </author> <title> The V distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 31(3):314 333, </volume> <month> March </month> <year> 1988. </year>
Reference-contexts: The support included logging and replaying the results of certain system calls, and tracking the interprocess synchronization based on system-visible semaphores. This limited support was adequate on the V-System kernel which does not support asynchronous event notification <ref> [10] </ref>. Additionally, the V kernel's small context switching time allowed the usage of system-provided semaphores with an acceptable penalty. These limitations, however, could make this technique impractical in other systems. The Delta-4 system handled nondeterministic execution in active process replication [4, 9].
Reference: [11] <author> E. Elnozahy. Manetho: </author> <title> Fault Tolerance in Distributed Systems Using Rollback Recovery and Process Replication. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> Oct. </month> <year> 1993. </year> <note> Also available as Technical Report TR93-212. </note>
Reference-contexts: Previous systems have dealt with these two forms of nondeterminism in different ways. Some systems tolerated them by forcing processes to take checkpoints before sending a message or producing an output to an end user <ref> [11] </ref>. The system need not reproduce the nondeterministic events as it would start from a checkpoint that occurred after the events affected the computation. This solution however has a very large overhead, especially when a checkpoint has to involve several processes. <p> The solution in this paper does not handle other types of nondeterminism, such as results from system calls and values read from an external input source or message. These have been handled by previous work <ref> [6, 11, 16, 17] </ref>. The performance study also is independent from any particular checkpointing or logging protocol to prevent any interference with the measurements. The rest of the paper is organized as follows. Section 2 describes the method proposed for tracking interrupts in modern RISC and CISC architecture. <p> Such a solution requires a substantial implementation effort and it is not easy to port to other platforms because of the reliance on special hardware. The Manetho system supported limited forms of nondeterminism that could be tracked efficiently by the operating system <ref> [11] </ref>. The support included logging and replaying the results of certain system calls, and tracking the interprocess synchronization based on system-visible semaphores. This limited support was adequate on the V-System kernel which does not support asynchronous event notification [10].
Reference: [12] <author> E. Elnozahy. </author> <title> An efficient technique for tracking nondeterministic execution and its applications. </title> <type> Technical Report CMU-CS-95-157, </type> <institution> Carnegie-Mellon University, </institution> <month> May </month> <year> 1995. </year>
Reference: [13] <author> E.N. Elnozahy, D.B. Johnson, and Y-M. Wang. </author> <title> A survey of rollback-recovery pro tocols in message passing systems. </title> <type> Technical Report CMU-CS-96-181, </type> <institution> Department of Computer Science, Carnegie Mellon University, </institution> <month> September </month> <year> 1996. </year>
Reference-contexts: Different flavors of logging have been suggested with different performance and resilience characteristics [2]. Despite these differences, most protocols commonly rely on the piecewise deterministic execution model <ref> [13] </ref>. Process execution in this model consists of a sequence of intervals, each starting with the receipt of a message at an application-defined execution point. <p> We report these measurements and also describe our experience using this instrumentation to support rollback-recovery in a multithreaded, long-running simulation program. Note that the measurements do not reflect any checkpointing or message logging activity, and logs were flushed asynchronously to disk like in optimistic or causal logging systems <ref> [13] </ref>. Excluding overhead due to checkpointing or pessimistic logging is consistent with the purpose of these experiments, which is to identify the overhead due only to code instrumentation. By studying the instrumentation in isolation, we identify its costs independent of any particular message logging and checkpointing protocol.
Reference: [14] <author> E. Elnozahy and W. Zwaenepoel. Manetho: </author> <title> Transparent rollback-recovery with low overhead, limited rollback, and fast output commit. </title> <journal> IEEE Transactions on Computers Special Issue On Fault-Tolerant Computing, </journal> <volume> 41(5) </volume> <pages> 526-531, </pages> <month> May </month> <year> 1992. </year>
Reference: [15] <author> E. N. Elnozahy and W. Zwaenepoel. </author> <title> On the use and implementation of message logging. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 298-307, </pages> <year> 1994. </year>
Reference: [16] <author> A. Goldberg, A. Gopal, K. Li, R. Strom, and D. Bacon. </author> <title> Transparent recovery of Mach applications. </title> <booktitle> In Proceedings of the Usenix Mach Workshop, </booktitle> <pages> pages 169-184, </pages> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: The solution in this paper does not handle other types of nondeterminism, such as results from system calls and values read from an external input source or message. These have been handled by previous work <ref> [6, 11, 16, 17] </ref>. The performance study also is independent from any particular checkpointing or logging protocol to prevent any interference with the measurements. The rest of the paper is organized as follows. Section 2 describes the method proposed for tracking interrupts in modern RISC and CISC architecture. <p> Systems that support nondeterminism due to thread interactions supply their own 16 sets of locking primitives, and require applications to use them for protecting access to shared memory <ref> [16] </ref>. The primitives are instrumented to insert an entry in the log identifying the calling thread and the nature of the synchronization operation [16]. However, this technique has several problems. It makes shared memory access expensive, and may generate a large volume of data in the log. <p> that support nondeterminism due to thread interactions supply their own 16 sets of locking primitives, and require applications to use them for protecting access to shared memory <ref> [16] </ref>. The primitives are instrumented to insert an entry in the log identifying the calling thread and the nature of the synchronization operation [16]. However, this technique has several problems. It makes shared memory access expensive, and may generate a large volume of data in the log. Furthermore, if the application does not adhere to the synchronization model (due to a programmer's error, for instance), execution replay may not be possible.
Reference: [17] <author> Y. Huang and C. Kintala. </author> <title> Software implemented fault tolerance: Technologies and experience. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 2-9, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: The solution in this paper does not handle other types of nondeterminism, such as results from system calls and values read from an external input source or message. These have been handled by previous work <ref> [6, 11, 16, 17] </ref>. The performance study also is independent from any particular checkpointing or logging protocol to prevent any interference with the measurements. The rest of the paper is organized as follows. Section 2 describes the method proposed for tracking interrupts in modern RISC and CISC architecture.
Reference: [18] <author> Y. Huang and Y. M. Wang. </author> <title> Why optimistic message logging has not been used in telecommunications systems. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 459-463, </pages> <month> June </month> <year> 1995. </year>
Reference: [19] <author> D. Johnson. </author> <title> Distributed System Fault Tolerance Using Message Logging and Checkpointing. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> Dec. </month> <year> 1989. </year>
Reference: [20] <author> D. Johnson and W. Zwaenepoel. </author> <title> Sender-based message logging. </title> <booktitle> In Proceedings of the 17th International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 14-19, </pages> <month> June </month> <year> 1987. </year> <month> 18 </month>
Reference: [21] <author> D. Johnson and W. Zwaenepoel. </author> <title> Recovery in distributed systems using optimistic message logging and checkpointing. </title> <journal> Journal of Algorithms, </journal> <volume> 11(3) </volume> <pages> 462-491, </pages> <month> Sept. </month> <year> 1990. </year>
Reference: [22] <author> T. Juang and S. Venkatesan. </author> <title> Crash recovery with little overhead. </title> <booktitle> In Proceedings of the 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 454-461, </pages> <month> May </month> <year> 1991. </year>
Reference: [23] <author> J. </author> <title> Jump. YACSIM Reference Manual, </title> <note> Version 2.1. </note> <month> Mar. </month> <year> 1993. </year>
Reference-contexts: Lastly, for completeness, Table 6 shows the number of backward branches in each benchmark. 4.2 Multithreaded Network Simulator We used the thread package described in Section 3 to support a partial port of Rice's YACSIM public domain simulator <ref> [23] </ref>. YACSIM is a multithreaded, process-driven simulator that has proved useful in simulating networks and computer architectures. The implementation was used to simulate an Ethernet-style network bus. A thread was used to represent a simulation process (in this example, an Ethernet packet).
Reference: [24] <author> H. V. Leong and D. Agrawal. </author> <title> Using message semantics to reduce rollback in optimistic message logging recovery schemes. </title> <booktitle> In Proc. IEEE Int. Conf. Distributed Comput. Syst., </booktitle> <pages> pages 227-234, </pages> <year> 1994. </year>
Reference: [25] <author> J. Mellor-Crummey and T. LeBlanc. </author> <title> A software instruction counter. </title> <booktitle> In Proceed ings of the 3rd Symposium on Architectural Support' for Programming Languages and Operating Systems, </booktitle> <pages> pages 78-86, </pages> <month> Apr. </month> <year> 1989. </year>
Reference-contexts: For example, a 32-bit register would underflow every 20 seconds of execution on a 200 MHz machine. Reinitializing the register at well defined points resolves this issue. The use of instruction counters has been suggested for debugging shared memory parallel programs <ref> [8, 25, 28] </ref>. Instruction counters may be available in hardware, as in the HP PA-RISC architecture. They also can be emulated in software [25]. The emulation uses the observation that a count of instructions is not strictly necessary for execution replay. <p> Reinitializing the register at well defined points resolves this issue. The use of instruction counters has been suggested for debugging shared memory parallel programs [8, 25, 28]. Instruction counters may be available in hardware, as in the HP PA-RISC architecture. They also can be emulated in software <ref> [25] </ref>. The emulation uses the observation that a count of instructions is not strictly necessary for execution replay. Instead, a count of the branches taken by the program during execution would be sufficient to determine the exact location whence an event of interest occurs. <p> design philosophy with a small number of registers and powerful, complex instructions that result in small code footprints in the instruction cache. 2.2 Instruction Counter Emulation for the DEC Alpha A straightforward application of the technique by Mellor-Crummey and LeBlanc would have resulted in about 5 instructions per basic block <ref> [25] </ref>. The resulting overhead would be large on a RISC machine like the DEC Alpha [25]. Our solution, however, dramatically reduces the overhead by exploiting the DEC architecture features and the fact that the purpose of emulation is to support rollback-recovery. <p> small code footprints in the instruction cache. 2.2 Instruction Counter Emulation for the DEC Alpha A straightforward application of the technique by Mellor-Crummey and LeBlanc would have resulted in about 5 instructions per basic block <ref> [25] </ref>. The resulting overhead would be large on a RISC machine like the DEC Alpha [25]. Our solution, however, dramatically reduces the overhead by exploiting the DEC architecture features and the fact that the purpose of emulation is to support rollback-recovery. Using these features, we limit the instrumentation overhead to a single instruction added to every 5 basic block in a program. <p> Additionally, our technique produces two different versions of the instrumented program, one for normal operation and one for execution replay after a failure. Our approach thus differs from other instrumentation techniques which produce the same program for normal operation and execution replay <ref> [25] </ref>. The goal is to allow better optimization for the normal operation of the program, even if it comes at the expense of a higher performance penalty in replay. <p> On other architectures, it may be necessary to compensate for the effects of the additional instrumentation instructions on the condition codes <ref> [25] </ref>. This compensation typically requires additional instructions and therefore additional overhead. An initialization routine is linked with every user program to set the branch counter to 0 at the beginning of the program. <p> Therefore, instructions cannot be arbitrarily placed in front of branches with no consideration for their possible effect on condition codes. Instead, expensive compensation instructions must be added to the instrumentation code to prevent the instrumentation instructions from altering the semantics of the application <ref> [25] </ref>. Finally, registers are 32-bit wide, which require checking for underflow of the branch holder at each basic block. Given all these limitations, there was no apparent benefit from preparing two different versions of the instrumented program like in the DEC Alpha.
Reference: [26] <author> R. H. B. Netzer and J. Xu. </author> <title> Adaptive message logging for incremental program replay. </title> <journal> IEEE Parallel and Distributed Technology, </journal> <volume> 1(4) </volume> <pages> 32-39, </pages> <month> Nov. </month> <year> 1993. </year>
Reference: [27] <author> M. Powell and D. Presotto. </author> <title> Publishing: A reliable broadcast communication mechanism. </title> <booktitle> In Proceedings of the 9th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 100-109, </pages> <month> Oct. </month> <year> 1983. </year>
Reference: [28] <author> M. Russinovich and B. Cogswell. </author> <title> Replay for concurrent non-deterministic shared memory applications. </title> <booktitle> In Proceedings of the 1996 ACM SIGPLAN Conference on Programming Language Design an Implementation, </booktitle> <pages> pages 258-266, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: For example, a 32-bit register would underflow every 20 seconds of execution on a 200 MHz machine. Reinitializing the register at well defined points resolves this issue. The use of instruction counters has been suggested for debugging shared memory parallel programs <ref> [8, 25, 28] </ref>. Instruction counters may be available in hardware, as in the HP PA-RISC architecture. They also can be emulated in software [25]. The emulation uses the observation that a count of instructions is not strictly necessary for execution replay.
Reference: [29] <author> M. Russinovich, Z. Segall, and D. P. Siewiorek. </author> <title> Application transparent fault management in fault-tolerant Mach. </title> <booktitle> In Proceedings of the Twenty Third Annual International Symposium on Fault-Tolerant Computing, FTCS-23, </booktitle> <pages> pages 10-19, </pages> <month> June </month> <year> 1993. </year>
Reference: [30] <author> A. Sistla and J. Welch. </author> <title> Efficient distributed recovery using message logging. </title> <booktitle> In Proceedings of the 8th Annual ACM Symposium on Principles of Distributed Com puting, </booktitle> <pages> pages 223-238, </pages> <month> Aug. </month> <year> 1989. </year>
Reference: [31] <author> J. H. </author> <title> Slye Adding support for software interrupts in log-based rollback-recovery protocols. M.S. </title> <type> thesis, </type> <institution> Carnegie Mellon University, Department of Electrical and Computer Enginnering, </institution> <month> Dec. </month> <year> 1996. </year>
Reference-contexts: A full report is available elsewhere, and all results support the conclusions made here <ref> [31] </ref>. We report here the performance of three long-running, compute-intensive programs from the SPEC95 benchmark suite. The three applications were instrumented as described in Section 2 for normal operation and replay. Additionally, we have instrumented the standard system libraries that are commonly linked with executables.
Reference: [32] <author> J. H. Slye and E. N. Elnozahy. </author> <title> Supporting nondeterministic execution in fault tolerant systems. </title> <booktitle> In Proceedings of the Twenty Sixth Annual International Sym posium on Fault-Tolerant Computing, FTCS-26, </booktitle> <pages> pages 250-259, </pages> <month> June </month> <year> 1996. </year>
Reference: [33] <author> R. Strom, D. Bacon, and S. Yemini. </author> <title> Volatile logging in n-fault-tolerant distributed systems. </title> <booktitle> In Proceedings of the 18th International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 44-49, </pages> <month> June </month> <year> 1988. </year>
Reference: [34] <author> R. Strom and S. Yemini. </author> <title> Optimistic recovery in distributed systems. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 3(3) </volume> <pages> 204-226, </pages> <month> Aug. </month> <year> 1985. </year>
Reference-contexts: Messages in this model are the only form of nondeterminism that affects the computation. Previous research has proposed that to realize this execution model, an implementation should convert all sources of nondeterminism found in practice into messages that processes receive at application-defined execution points <ref> [34] </ref>. In practice, however, this realization has proved difficult as there are several forms of nondeterminism that cannot be logged efficiently or converted into synchronous messages [6,13].
Reference: [35] <author> G. Suri, B. Janssens, and W. K. Fuchs. </author> <title> Reduced overhead logging for rollback recovery in distributed shared memory. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 279-288, </pages> <month> June </month> <year> 1995. </year>
Reference: [36] <author> N. H. Vaidya. </author> <title> Dynamic cluster-based recovery: Pessimistic and optimistic schemes. </title> <type> Technical Report # 93-027, </type> <institution> Dept. of Computer Science, Texas A&M University, </institution> <month> May </month> <year> 1993. </year>
Reference: [37] <author> N. H. Vaidya. </author> <title> A case of two-level distributed recovery schemes. </title> <booktitle> In Proceedings of the International Conference on Measurement and Modeling of Computer Systems (Sigmetrics '95), </booktitle> <pages> pages 64-73, </pages> <month> May </month> <year> 1995. </year>
Reference: [38] <author> Y. M. Wang. </author> <title> Reducing message logging overhead for log-based recovery. </title> <booktitle> In Proc. IEEE Int'l Symp. on Circuits and Systems, </booktitle> <pages> pages 1925-1928, </pages> <month> May </month> <year> 1993. </year> <month> 19 </month>
Reference: [39] <author> Y.-M. Wang and W. Fuchs. </author> <title> Optimistic message logging for independent check--pointing in message-passing systems. </title> <booktitle> In Proceedings of the 11th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 147-154, </pages> <month> Oct. </month> <year> 1992. </year>
Reference: [40] <author> Y.-M. Wang and W. Fuchs. </author> <title> Scheduling message processing for reducing rollback propagation. </title> <booktitle> In Proceedings of the 22nd International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 204-211, </pages> <month> July </month> <year> 1992. </year>
Reference: [41] <author> Y. M. Wang, Y. Huang, K. P. Vo, P. Y. Chung, and C. Kintala. </author> <title> Checkpointing and its applications. </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symp., </booktitle> <pages> pages 22-31, </pages> <month> June </month> <year> 1995. </year> <month> 20 </month>
References-found: 41

