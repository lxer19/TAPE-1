URL: http://www.cs.utexas.edu/users/sriram/Papers/TR-98-01.ps
Refering-URL: http://www.cs.utexas.edu/users/sriram/mm/papers.html
Root-URL: 
Email: E-mail: florenzo,sriram,ving@cs.utexas.edu,  
Phone: Telephone: (512) 471-9792, Fax: (512) 471-8885  
Title: Low-overhead Protocols for Fault-tolerant File-sharing  
Author: Lorenzo Alvisi, Sriram Rao, and Harrick M. Vin 
Web: URL: http://www.cs.utexas.edu/users/florenzo,sriram,ving  
Address: Taylor Hall 2.124 Austin, Texas 78712-1188, USA  
Affiliation: Department of Computer Sciences The University of Texas at Austin  
Abstract: In this paper, we quantify the adverse effect of file-sharing on the performance of reliable distributed applications. We demonstrate that file-sharing incurs significant overhead, which is likely to triple over the next five years. We present a novel approach that eliminates this overhead. Our approach (1) tracks causal dependencies resulting from file-sharing using determinants, (2) efficiently replicates the determinants in the volatile memory of agents to ensure their availability during recovery, and (3) reproduces during recovery the interactions with the file server as well as the file data lost in a failure. Our approach allows agents to exchange files directly, without first saving the files on disks at the server. As a consequence, the costs of supporting file-sharing and message passing in reliable distributed application become virtually identical. The result is a simple, uniform approach, which can provide low-overhead fault-tolerance to applications in which communication is performed through message passing, file sharing, or a combination of the two. Citation: Proceedings of International Conference on Distributed Computing and Systems (ICDCS'98), Amsterdam, Netherlands, May 1998 (to appear). Also available as Technical Report TR-98-01, Department of Computer Sciences, University of Texas, Austin, TX. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Alvisi. </author> <title> Understanding the Message Logging Paradigm for Masking Process Crashes. </title> <type> PhD thesis, </type> <institution> Cornell University Department of Computer Science, </institution> <month> January </month> <year> 1996. </year>
Reference-contexts: We treat write events similarly. The resulting determinants can be efficiently encoded using compression techniques discussed elsewhere <ref> [1, 2] </ref>. We can also reduce the number of file versions logged in the volatile memory of agents. Suppose an agent p acquires write ownership on a file F and repeatedly modifies it before its ownership is revoked.
Reference: [2] <author> L. Alvisi, B. Hoppe, and K. Marzullo. </author> <title> Nonblocking and Orphan-Free Message Logging Protocols. </title> <booktitle> In Proceedings of the 23rd Fault-Tolerant Computing Symposium, </booktitle> <pages> pages 145154, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Low-overhead fault-tolerance protocolssuch as checkpointing and message logging <ref> [2, 3, 4, 13, 14, 17, 21, 27, 32, 30] </ref>have been extensively studied for message passing distributed applications. These protocols seek to tolerate common failures while minimizing the use of additional resources and the impact on performance during failure-free executions. <p> We show that if determinants are available during recovery, then interactions with the file server can be reproduced, and file data lost in a failure can be regenerated. To ensure determinants availability, we use an efficient replication scheme <ref> [2] </ref> that stores determinants in agents' volatile memory. The final contribution of this paper is the introduction of a novel conceptimplementation in volatile memory of stable storage for files. <p> On receiving a file access request, they require the agent possessing the most recent version of the file to synchronously write-back the file at the server prior to servicing the request. Second, as the following example illustrates, conventional rollback-recovery protocols such as checkpointing and message logging <ref> [2, 3, 4, 17, 19, 31] </ref> incur substantial overhead when used for applications in which agents communicate also through file-sharing. Example Consider the execution in Figure 1, in which agents p, q, and r exchange messages and share a file F . <p> We treat write events similarly. The resulting determinants can be efficiently encoded using compression techniques discussed elsewhere <ref> [1, 2] </ref>. We can also reduce the number of file versions logged in the volatile memory of agents. Suppose an agent p acquires write ownership on a file F and repeatedly modifies it before its ownership is revoked. <p> Our approach can tolerate concurrent crashes of multiple agents as well as hardware failures. It eliminates synchronous output commits on writes, synchronous logging on reads, and the synchronous write-backs required by the file server during file-sharing. To achieve this result, it uses causal logging <ref> [2, 3, 4, 13] </ref>, a roll back recovery technique of which FBL is an instance. Causal logging protocols log determinants in volatile memory, and never rollback correct processes.
Reference: [3] <author> L. Alvisi and K. Marzullo. </author> <title> Message Logging: Pessimistic, Optimistic, and Causal. </title> <booktitle> In Proceedings of the 15th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 229236. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Low-overhead fault-tolerance protocolssuch as checkpointing and message logging <ref> [2, 3, 4, 13, 14, 17, 21, 27, 32, 30] </ref>have been extensively studied for message passing distributed applications. These protocols seek to tolerate common failures while minimizing the use of additional resources and the impact on performance during failure-free executions. <p> On receiving a file access request, they require the agent possessing the most recent version of the file to synchronously write-back the file at the server prior to servicing the request. Second, as the following example illustrates, conventional rollback-recovery protocols such as checkpointing and message logging <ref> [2, 3, 4, 17, 19, 31] </ref> incur substantial overhead when used for applications in which agents communicate also through file-sharing. Example Consider the execution in Figure 1, in which agents p, q, and r exchange messages and share a file F . <p> In fact, if there is a unique way to associate data with the corresponding determinant, and all determinants are available during recovery, then a simple induction on the length of the execution 7 shows that delivered messages and file versions accessed for reading or writing can be deterministically regenerated <ref> [3] </ref>. Therefore, assuming that we can guarantee the availability of determinants (see Section 4.2), we substitute data in #e with following pair: hsource; sesni. The meaning of source and sesn depends on e. <p> This guarantees their availability during recovery. The performance of log-based protocols depends on the scheme used to make determinants stable. Our protocols are based on Family-Based Logging (FBL)a logging technique we have proved to be optimal with respect to several significant performance metrics <ref> [3] </ref>. FBL was originally designed to log determinants of deliver events. However, because the determinants of read, write, and deliver events that we have derived have an identical structure, we can naturally extend FBL protocols to handle communication resulting from file-sharing. <p> In each case, we need to guarantee that p first becomes a member of Log (e). In message passing application this can be accomplished by piggybacking determinants on existing application messages: determinants are piggybacked until logged by at least t + 1 agents <ref> [3, 13] </ref>. We now show how to apply a similar scheme to the dependencies generated by file-sharing. Current file servers provide no mechanism to enforce Property 1. <p> Our approach can tolerate concurrent crashes of multiple agents as well as hardware failures. It eliminates synchronous output commits on writes, synchronous logging on reads, and the synchronous write-backs required by the file server during file-sharing. To achieve this result, it uses causal logging <ref> [2, 3, 4, 13] </ref>, a roll back recovery technique of which FBL is an instance. Causal logging protocols log determinants in volatile memory, and never rollback correct processes.
Reference: [4] <author> L. Alvisi and K. Marzullo. </author> <title> Tradeoffs in Implementing Optimal Message Logging Protocols. </title> <booktitle> In Proceedings of the Fifteenth Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 5867. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Low-overhead fault-tolerance protocolssuch as checkpointing and message logging <ref> [2, 3, 4, 13, 14, 17, 21, 27, 32, 30] </ref>have been extensively studied for message passing distributed applications. These protocols seek to tolerate common failures while minimizing the use of additional resources and the impact on performance during failure-free executions. <p> On receiving a file access request, they require the agent possessing the most recent version of the file to synchronously write-back the file at the server prior to servicing the request. Second, as the following example illustrates, conventional rollback-recovery protocols such as checkpointing and message logging <ref> [2, 3, 4, 17, 19, 31] </ref> incur substantial overhead when used for applications in which agents communicate also through file-sharing. Example Consider the execution in Figure 1, in which agents p, q, and r exchange messages and share a file F . <p> To help agents keep their estimates accurate, different FBL protocols provide agents with different amount of information about the causal past of each non-deterministic event of which they log the determinant <ref> [4] </ref>. We describe here the simplest FBL protocol, in which an agent p estimates jLog (e)j as follows: 1. If p generates #e, it creates a corresponding entry dle in DetLog p and sets dle:logged at to fpg. 2. <p> Our approach can tolerate concurrent crashes of multiple agents as well as hardware failures. It eliminates synchronous output commits on writes, synchronous logging on reads, and the synchronous write-backs required by the file server during file-sharing. To achieve this result, it uses causal logging <ref> [2, 3, 4, 13] </ref>, a roll back recovery technique of which FBL is an instance. Causal logging protocols log determinants in volatile memory, and never rollback correct processes.
Reference: [5] <author> T. Anderson, M. Dahlin, J. Neefe, D. Patterson, D. Roselli, and R. Wang. </author> <title> Serverless Network File Systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <month> February </month> <year> 1996. </year>
Reference-contexts: Traditionally, a file F modified by an agent p can be shared by another agent q only after p has synchronously written F to disks at the file server <ref> [5, 16] </ref>. In our solution, no synchronous write is needed, and p can send F to q without delays. The remainder of the paper is organized as follows. In Section 2, we describe our system model. <p> Agents communicate using both message passing and file-sharing. Messages are exchanged over FIFO channels that can fail by transiently losing messages. Files are shared according to an ownership-based consistency protocol <ref> [5, 16] </ref>. Specifically, the file server supports shared read-ownership, and exclusive write-ownership (i.e., a multiple-reader, single-writer policy). At any point in time, the content of a file is uniquely identified by its version. We denote version v of file F by F:v. <p> File servers that support read and write events efficiently have been a topic of much research. For instance, the log-structured file system employ techniques for improving the performance of file writes [24]; xFS implements cooperative caching to improve the performance of file reads <ref> [5] </ref>. Additionally, several techniques for designing file servers that assist applications during failure recovery have been investigated. For instance, versioning file systems eliminate the need for read logging by ensuring that a file version read by an agent prior to failure will be available during recovery [28].
Reference: [6] <author> M. Baker, S. Asami, E. Deprit, J. Ousterhout, and M. Seltzer. </author> <title> Non-Volatile Memory for Fast, Reliable File Systems. </title> <booktitle> In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS), </booktitle> <pages> pages 1022, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: For instance, versioning file systems eliminate the need for read logging by ensuring that a file version read by an agent prior to failure will be available during recovery [28]. Similarly, implementation of stable storage, using special hardware, such as non-volatile RAM <ref> [6, 33] </ref>, or a specialized operating system, such as the Rio file cache [9], in the memory sub-system at the server eliminates the need for synchronous writes to disks. Unfortunately, neither of these approaches address the problem of fault-tolerant file-sharing in its entirety.
Reference: [7] <author> A. Borg, J. Baumbach, and S. Glazer. </author> <title> A message system supporting fault tolerance. </title> <booktitle> In Proceedings of the Symposium on Operating Systems Principles, pages 9099. ACM SIGOPS, </booktitle> <month> October </month> <year> 1983. </year>
Reference-contexts: Causal logging protocols log determinants in volatile memory, and never rollback correct processes. Thus, they achieve the performance of optimistic protocols [18, 26, 29, 31], and the fault-containment of pessimistic protocols <ref> [7, 23] </ref>. 14 8 Conclusion The next generation of distributed applications will be structured around groups of agents that communicate through message passing and file-sharing. Unfortunately, file-sharing adversely affects the performance of today's reliable distributed applications.
Reference: [8] <author> K. M. Chandy and L. Lamport. </author> <title> Distributed snapshots: determining global states of distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1):6375, </volume> <month> February </month> <year> 1985. </year> <month> 15 </month>
Reference-contexts: Two agents p and q are mutually consistent if they are both mutually message- and file-consistent. A collection of states, one from each agent, is a consistent global state if all pairs of states are mutually consistent <ref> [8] </ref>; otherwise it is inconsistent. We assume that agents fail according to the fail-stop model [25]. That is, agents fail independently, only by halting, and a faulty agent is eventually detected by all correct agents. The file server can also fail independently and only by halting.
Reference: [9] <author> P. M. Chen, W. T. Ng, S. Chandra, C. Aycock, G. Rajamani, and D. Lowell. </author> <title> The Rio File Cache: Surviving Operating System Crashes. </title> <booktitle> In Proceedings of the Seventh International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS), </booktitle> <address> Cambridge, MA, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: Similarly, implementation of stable storage, using special hardware, such as non-volatile RAM [6, 33], or a specialized operating system, such as the Rio file cache <ref> [9] </ref>, in the memory sub-system at the server eliminates the need for synchronous writes to disks. Unfortunately, neither of these approaches address the problem of fault-tolerant file-sharing in its entirety.
Reference: [10] <author> M. D. Dahlin. </author> <title> Serverless Network File Systems. </title> <type> PhD thesis, </type> <institution> University of California, Berkeley, </institution> <month> De-cember </month> <year> 1995. </year>
Reference-contexts: The simulations were seeded by processor, network, and disk performance values that represent the state-of-the-art workstations and networks. To put these results in perspective, we need to account for the expected technological improvements (see Figure 3) <ref> [10] </ref>. O r + O o ) imposed by 1 , and by 1 enhanced with the above optimizations.
Reference: [11] <author> E. N. Elnozahy. </author> <title> On the relevance of communication costs of rollback-recovery protocols. </title> <booktitle> In Proceedings of the Fourteenth Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 7479, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: If other processes fail while p is recovering, then determining when Phase 1 is complete is a non-trivial problem <ref> [11] </ref>. To solve it, we use an algorithm that detects the end of Phase 1 without forcing correct processes to block while p recovers. A detailed description of our algorithm is beyond the scope of this paper.
Reference: [12] <author> E. N. Elnozahy, D. B. Johnson, and W. Zwaenepoel. </author> <title> The Performance of Consistent Checkpointing. </title> <booktitle> In Proceedings of the Eleventh Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 3947, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: However, due to the limited size of volatile memory, these data structures are asynchronously logged to a backing store. To garbage collect these logs, the state of the application is periodically saved using a coordinated checkpoint <ref> [12] </ref>. 6.7 Failure Recovery As we saw in Section 4.3, recovery of an agent p proceeds in two phases.
Reference: [13] <author> E. N. Elnozahy and W. Zwaenepoel. Manetho: </author> <title> Transparent rollback-recovery with low overhead, limited rollback and fast output commit. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 41(5):526531, </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Low-overhead fault-tolerance protocolssuch as checkpointing and message logging <ref> [2, 3, 4, 13, 14, 17, 21, 27, 32, 30] </ref>have been extensively studied for message passing distributed applications. These protocols seek to tolerate common failures while minimizing the use of additional resources and the impact on performance during failure-free executions. <p> In each case, we need to guarantee that p first becomes a member of Log (e). In message passing application this can be accomplished by piggybacking determinants on existing application messages: determinants are piggybacked until logged by at least t + 1 agents <ref> [3, 13] </ref>. We now show how to apply a similar scheme to the dependencies generated by file-sharing. Current file servers provide no mechanism to enforce Property 1. <p> Our approach can tolerate concurrent crashes of multiple agents as well as hardware failures. It eliminates synchronous output commits on writes, synchronous logging on reads, and the synchronous write-backs required by the file server during file-sharing. To achieve this result, it uses causal logging <ref> [2, 3, 4, 13] </ref>, a roll back recovery technique of which FBL is an instance. Causal logging protocols log determinants in volatile memory, and never rollback correct processes.
Reference: [14] <author> E. N. Elnozahy and W. Zwaenepoel. </author> <title> On the use and implementation of message logging. </title> <booktitle> In Digest of Papers: 24 Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 298307. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Low-overhead fault-tolerance protocolssuch as checkpointing and message logging <ref> [2, 3, 4, 13, 14, 17, 21, 27, 32, 30] </ref>have been extensively studied for message passing distributed applications. These protocols seek to tolerate common failures while minimizing the use of additional resources and the impact on performance during failure-free executions.
Reference: [15] <author> J. N. Gray. </author> <title> Notes on Data Base Operating Systems. </title> <editor> In R. Bayer, R. M. Graham, and G. Seegmueller, editors, </editor> <booktitle> Operating Systems: An Advanced Course, </booktitle> <pages> pages 393481. </pages> <publisher> Springer-Verlag, </publisher> <year> 1977. </year> <note> Lecture Notes on Computer Science 60. </note>
Reference-contexts: That is, agents fail independently, only by halting, and a faulty agent is eventually detected by all correct agents. The file server can also fail independently and only by halting. However, its failure and recovery are not addressed in this paper. Finally, we assume that stable storage <ref> [15] </ref> is available throughout the system, persists across failures, and is implemented either using disks at the file server or through replication in the volatile memory of agents. 3 Problem Statement The next generation of distributed applications will be structured around groups of agents that communicate in different ways.
Reference: [16] <author> J. H. Howard, M. L. Kazar, S. G. Menees, D. A. Nichols, M. Satyanarayanan, R. N. Sidebotham, and M. J. West. </author> <title> Scale and Performance in a Distributed File System. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1):5181, </volume> <month> February </month> <year> 1988. </year>
Reference-contexts: Traditionally, a file F modified by an agent p can be shared by another agent q only after p has synchronously written F to disks at the file server <ref> [5, 16] </ref>. In our solution, no synchronous write is needed, and p can send F to q without delays. The remainder of the paper is organized as follows. In Section 2, we describe our system model. <p> Agents communicate using both message passing and file-sharing. Messages are exchanged over FIFO channels that can fail by transiently losing messages. Files are shared according to an ownership-based consistency protocol <ref> [5, 16] </ref>. Specifically, the file server supports shared read-ownership, and exclusive write-ownership (i.e., a multiple-reader, single-writer policy). At any point in time, the content of a file is uniquely identified by its version. We denote version v of file F by F:v.
Reference: [17] <author> D. B. Johnson. </author> <title> Distributed System Fault Tolerance Using Message Logging and Checkpointing. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> December </month> <year> 1989. </year> <note> Available as report COMP TR89-101. </note>
Reference-contexts: 1 Introduction Low-overhead fault-tolerance protocolssuch as checkpointing and message logging <ref> [2, 3, 4, 13, 14, 17, 21, 27, 32, 30] </ref>have been extensively studied for message passing distributed applications. These protocols seek to tolerate common failures while minimizing the use of additional resources and the impact on performance during failure-free executions. <p> On receiving a file access request, they require the agent possessing the most recent version of the file to synchronously write-back the file at the server prior to servicing the request. Second, as the following example illustrates, conventional rollback-recovery protocols such as checkpointing and message logging <ref> [2, 3, 4, 17, 19, 31] </ref> incur substantial overhead when used for applications in which agents communicate also through file-sharing. Example Consider the execution in Figure 1, in which agents p, q, and r exchange messages and share a file F .
Reference: [18] <author> D. B. Johnson and W. Zwaenepoel. </author> <title> Recovery in Distributed Systems Using Optimistic Message Logging and Checkpointing. </title> <journal> Journal of Algorithms, </journal> <volume> 11:462491, </volume> <year> 1990. </year>
Reference-contexts: In this case, it may be possible to execute the output commit protocol asynchronously, albeit it must complete prior to the corresponding batched write <ref> [18] </ref>. 2. The simulations were seeded by processor, network, and disk performance values that represent the state-of-the-art workstations and networks. To put these results in perspective, we need to account for the expected technological improvements (see Figure 3) [10]. <p> To achieve this result, it uses causal logging [2, 3, 4, 13], a roll back recovery technique of which FBL is an instance. Causal logging protocols log determinants in volatile memory, and never rollback correct processes. Thus, they achieve the performance of optimistic protocols <ref> [18, 26, 29, 31] </ref>, and the fault-containment of pessimistic protocols [7, 23]. 14 8 Conclusion The next generation of distributed applications will be structured around groups of agents that communicate through message passing and file-sharing. Unfortunately, file-sharing adversely affects the performance of today's reliable distributed applications.
Reference: [19] <author> R. Koo and S. Toueg. </author> <title> Checkpointing and Rollback-Recovery for Distributed Systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-13(1):2331, </volume> <month> January </month> <year> 1987. </year>
Reference-contexts: On receiving a file access request, they require the agent possessing the most recent version of the file to synchronously write-back the file at the server prior to servicing the request. Second, as the following example illustrates, conventional rollback-recovery protocols such as checkpointing and message logging <ref> [2, 3, 4, 17, 19, 31] </ref> incur substantial overhead when used for applications in which agents communicate also through file-sharing. Example Consider the execution in Figure 1, in which agents p, q, and r exchange messages and share a file F .
Reference: [20] <author> L. Lamport. </author> <title> Time, Clocks, and the Ordering of Events in a Distributed System. </title> <journal> Communications of the ACM, </journal> <volume> 21(7):558565, </volume> <month> July </month> <year> 1978. </year>
Reference-contexts: On accessing F , the file server returns the latest version of F . The execution of the system is represented by a run, which is an irreflexive partial ordering of send, receive, read, write, and local events, ordered by potential causality <ref> [20] </ref>. For each agent p, a special class of events local to p are called deliver events. These events correspond to the delivery of a message to the application that p is part of. <p> To specify FBL's logging technique, we introduce two sets for each non-deterministic event e Depend (e) This set includes the agent which executed e and any agent that executed an event e 0 such that e happens-before e 0 <ref> [20] </ref>. Log (e) This set includes the agents that maintain a copy of #e in volatile memory.
Reference: [21] <author> J. S. Plank, M. Beck, G. Kingsley, and K. Li. </author> <title> Libckpt : Transparent checkpointing under Unix. </title> <booktitle> In Proceedings of the USENIX Technical Conference, </booktitle> <pages> pages 213224, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Low-overhead fault-tolerance protocolssuch as checkpointing and message logging <ref> [2, 3, 4, 13, 14, 17, 21, 27, 32, 30] </ref>have been extensively studied for message passing distributed applications. These protocols seek to tolerate common failures while minimizing the use of additional resources and the impact on performance during failure-free executions.
Reference: [22] <author> A. Pnueli. </author> <title> The Temporal Logic of Programs. </title> <booktitle> In Proceedings of the Eighteenth Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 4657, </pages> <month> November </month> <year> 1977. </year>
Reference-contexts: FBL guarantees that the following property holds: 2 (8e : :stable (e) : (Depend (e) Log (e)) ^ 3 (Depend (e) = Log (e))) (1) where 2 and 3 are, respectively, the always and eventually temporal operators <ref> [22] </ref>. This property strongly couples logging in FBL with tracking of causal dependencies involving non-deterministic events.
Reference: [23] <author> M. L. Powell and D. L. Presotto. </author> <title> Publishing: A reliable broadcast communication mechanism. </title> <booktitle> In Proceedings of the Ninth Symposium on Operating System Principles, pages 100109. ACM SIGOPS, </booktitle> <month> October </month> <year> 1983. </year> <month> 16 </month>
Reference-contexts: Causal logging protocols log determinants in volatile memory, and never rollback correct processes. Thus, they achieve the performance of optimistic protocols [18, 26, 29, 31], and the fault-containment of pessimistic protocols <ref> [7, 23] </ref>. 14 8 Conclusion The next generation of distributed applications will be structured around groups of agents that communicate through message passing and file-sharing. Unfortunately, file-sharing adversely affects the performance of today's reliable distributed applications.
Reference: [24] <author> M. Rosenblum and J. K. Ousterhout. </author> <title> A Case for Log-Structured File Systems. </title> <booktitle> In Proceedings of the Thirteenth Symposium on Operating Systems Principles, </booktitle> <pages> pages 115, </pages> <address> Pacific Grove, CA, </address> <month> October </month> <year> 1991. </year> <note> ACM. </note>
Reference-contexts: However, it is straightforward to change the protocol so that modified files are asynchronously written back to the file server, thereby making them readily available during recovery. The file server in this case needs to support file versioning: this is achieved, for instance, using a log-structured file server <ref> [24] </ref>. 6 Protocol Design Issues Due to space limitations, we do not present the pseudo-code for our protocol. <p> File servers that support read and write events efficiently have been a topic of much research. For instance, the log-structured file system employ techniques for improving the performance of file writes <ref> [24] </ref>; xFS implements cooperative caching to improve the performance of file reads [5]. Additionally, several techniques for designing file servers that assist applications during failure recovery have been investigated.
Reference: [25] <author> F. B. Schneider. </author> <title> Byzantine Generals in Action: Implementing Fail-Stop Processors. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(2):145154, </volume> <month> May </month> <year> 1984. </year>
Reference-contexts: A collection of states, one from each agent, is a consistent global state if all pairs of states are mutually consistent [8]; otherwise it is inconsistent. We assume that agents fail according to the fail-stop model <ref> [25] </ref>. That is, agents fail independently, only by halting, and a faulty agent is eventually detected by all correct agents. The file server can also fail independently and only by halting. However, its failure and recovery are not addressed in this paper.
Reference: [26] <author> R. B. Strom and S. Yemeni. </author> <title> Optimistic recovery in distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(3):204226, </volume> <month> April </month> <year> 1985. </year>
Reference-contexts: To achieve this result, it uses causal logging [2, 3, 4, 13], a roll back recovery technique of which FBL is an instance. Causal logging protocols log determinants in volatile memory, and never rollback correct processes. Thus, they achieve the performance of optimistic protocols <ref> [18, 26, 29, 31] </ref>, and the fault-containment of pessimistic protocols [7, 23]. 14 8 Conclusion The next generation of distributed applications will be structured around groups of agents that communicate through message passing and file-sharing. Unfortunately, file-sharing adversely affects the performance of today's reliable distributed applications.
Reference: [27] <author> R. E. Strom, D. F. Bacon, and S. A. Yemini. </author> <title> Volatile Logging in n-Fault-Tolerant Distributed Systems. </title> <booktitle> In Proceedings of the Eighteenth Annual International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 4449, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction Low-overhead fault-tolerance protocolssuch as checkpointing and message logging <ref> [2, 3, 4, 13, 14, 17, 21, 27, 32, 30] </ref>have been extensively studied for message passing distributed applications. These protocols seek to tolerate common failures while minimizing the use of additional resources and the impact on performance during failure-free executions. <p> Deliver, read and write events are non-deterministic, because the order in which an agent receives messages and the file versions it accesses are execution-dependent. Send events and 2 other local events are instead deterministic. Agent execution is piecewise deterministic <ref> [27] </ref>: It consists of a sequence of deterministic intervals of execution, joined by non-deterministic events. At any point during the execution, the state of an agent is a mapping of program variables and implicit variables (such as program counters) to their current values 1 .
Reference: [28] <author> R. E. Strom, S. A. Yemini, and D. F. Bacon. </author> <title> A recoverable object store. </title> <booktitle> In Proceedings of Hawaii International Conference on System Sciences (HICCS-88), </booktitle> <pages> pages II215II221, </pages> <month> January </month> <year> 1988. </year>
Reference-contexts: Additionally, several techniques for designing file servers that assist applications during failure recovery have been investigated. For instance, versioning file systems eliminate the need for read logging by ensuring that a file version read by an agent prior to failure will be available during recovery <ref> [28] </ref>. Similarly, implementation of stable storage, using special hardware, such as non-volatile RAM [6, 33], or a specialized operating system, such as the Rio file cache [9], in the memory sub-system at the server eliminates the need for synchronous writes to disks.
Reference: [29] <author> S. Venkatesan and T. Y. Juang. </author> <title> Efficient Algorithms for Optimistic Crash Recovery. </title> <booktitle> Distributed Computing, </booktitle> <address> 8(2):105114, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: To achieve this result, it uses causal logging [2, 3, 4, 13], a roll back recovery technique of which FBL is an instance. Causal logging protocols log determinants in volatile memory, and never rollback correct processes. Thus, they achieve the performance of optimistic protocols <ref> [18, 26, 29, 31] </ref>, and the fault-containment of pessimistic protocols [7, 23]. 14 8 Conclusion The next generation of distributed applications will be structured around groups of agents that communicate through message passing and file-sharing. Unfortunately, file-sharing adversely affects the performance of today's reliable distributed applications.
Reference: [30] <author> Y. M. Wang, O. P. Damani, and V. K. Garg. </author> <title> Distributed Recovery with K-Optimistic Logging. </title> <booktitle> In Proceedings of the 17th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 6067, </pages> <year> 1997. </year>
Reference-contexts: 1 Introduction Low-overhead fault-tolerance protocolssuch as checkpointing and message logging <ref> [2, 3, 4, 13, 14, 17, 21, 27, 32, 30] </ref>have been extensively studied for message passing distributed applications. These protocols seek to tolerate common failures while minimizing the use of additional resources and the impact on performance during failure-free executions.
Reference: [31] <author> Y. M. Wang and W. K. Fuchs. </author> <title> Optimisitic message logging for independent checkpointing in message-passing systems. </title> <booktitle> In Proceedings of the 11th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 147 154, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: On receiving a file access request, they require the agent possessing the most recent version of the file to synchronously write-back the file at the server prior to servicing the request. Second, as the following example illustrates, conventional rollback-recovery protocols such as checkpointing and message logging <ref> [2, 3, 4, 17, 19, 31] </ref> incur substantial overhead when used for applications in which agents communicate also through file-sharing. Example Consider the execution in Figure 1, in which agents p, q, and r exchange messages and share a file F . <p> To achieve this result, it uses causal logging [2, 3, 4, 13], a roll back recovery technique of which FBL is an instance. Causal logging protocols log determinants in volatile memory, and never rollback correct processes. Thus, they achieve the performance of optimistic protocols <ref> [18, 26, 29, 31] </ref>, and the fault-containment of pessimistic protocols [7, 23]. 14 8 Conclusion The next generation of distributed applications will be structured around groups of agents that communicate through message passing and file-sharing. Unfortunately, file-sharing adversely affects the performance of today's reliable distributed applications.
Reference: [32] <author> Y. M. Wang, Y. Huang, K. P. Vo, P. Y. Chung, and C. Kintala. </author> <title> Checkpointing and Its Applications. </title> <booktitle> In Proceedings of the IEEE Fault-Tolerant Computing Symposium (FTCS-25), </booktitle> <pages> pages 2231, </pages> <address> Pasadena, CA, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Low-overhead fault-tolerance protocolssuch as checkpointing and message logging <ref> [2, 3, 4, 13, 14, 17, 21, 27, 32, 30] </ref>have been extensively studied for message passing distributed applications. These protocols seek to tolerate common failures while minimizing the use of additional resources and the impact on performance during failure-free executions.
Reference: [33] <author> M. Wu and W. Zwaenepoel. eNVy: </author> <title> A Non-Volatile Main Memory Storage System. </title> <booktitle> In Proceedings of the Sixth Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 8697, </pages> <month> October </month> <year> 1994. </year> <month> 17 </month>
Reference-contexts: For instance, versioning file systems eliminate the need for read logging by ensuring that a file version read by an agent prior to failure will be available during recovery [28]. Similarly, implementation of stable storage, using special hardware, such as non-volatile RAM <ref> [6, 33] </ref>, or a specialized operating system, such as the Rio file cache [9], in the memory sub-system at the server eliminates the need for synchronous writes to disks. Unfortunately, neither of these approaches address the problem of fault-tolerant file-sharing in its entirety.
References-found: 33

