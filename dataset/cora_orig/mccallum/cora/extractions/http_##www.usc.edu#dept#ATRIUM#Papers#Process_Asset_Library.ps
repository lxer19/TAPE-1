URL: http://www.usc.edu/dept/ATRIUM/Papers/Process_Asset_Library.ps
Refering-URL: http://cwis.usc.edu/dept/ATRIUM/index.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fscacchig@gilligan.usc.edu  
Phone: Tel (213) 740-4782  
Title: A Knowledge-Based Software Process Library for Process-Driven Software Development  
Author: Peiwei Mi Ming-June Lee and Walt Scacchi 
Address: Los Angeles, CA 90089-1421  
Affiliation: Computer Science Dept. and Information and Operations Management Dept. University of Southern California 1  
Abstract: Process-driven software development represents a new technique for software production, in which a conceptual knowledge representation. called a software process, is used to represent and guide development activities. Management and reuse of software processes therefore becomes a requirement for process-driven software development. In this paper, we present a knowledge-based process library (SPLib) that supports the organization, access and reuse of software processes. SPLib consists of a knowledge base of software process representations. It also provides a set of process operations that support browsing, searching composition and abstraction. These operations reason about the content of software processes as well as maintain proper interdependency relationships among the software processes. To demonstrate the use of SPLib in process-driven software development, we provide a usage scenario where SPLib facilitates the access and reuse of software processes in real applications. 
Abstract-found: 1
Intro-found: 1
Reference: [AL89] <author> B.P. Allen and S.D. Lee. </author> <title> A Knowledge-based Environment for the Development of Software Parts Composition Systems. </title> <booktitle> In Proc. of the 11th International Conference on Software Engineering, </booktitle> <pages> pages 104-112, </pages> <address> Pittsburgh, PA, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: In this case, locating and determining which functions to use relies upon directory information and keyword/string search which is often cumbersome and problematic. Subsequently, knowledge-based techniques are being investigated for more sophisticated support mechanisms. Bauhaus <ref> [AL89] </ref> is a knowledge-based software parts composition system shell. It has a knowledge base of reusable software component description, a catalog for browsing and editing the knowledge base, a composition editor for component specification, and a code generator for composed or tailored components.
Reference: [Boe86] <author> B. Boehm. </author> <title> A Spiral Model of Software Development and Enhancement. </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 11(4) </volume> <pages> 22-42, </pages> <month> Aug </month> <year> 1986. </year>
Reference-contexts: A process-driven CASE environment is also required to integrate process representation, data management, and tool invocation. Recent progress in software process modeling and process integration has made process-driven software development a very promising, yet realistic engineering technique for the software engineering community <ref> [Boe86, HK89, Kai88, MS90, MS91] </ref>. When knowledge-based process representations are utilized, management and reuse of the classes and instances of the representations becomes a necessity. To this end, a knowledge-based process library provides a solution the problem of process management and reuse.
Reference: [Boo91] <author> G. Booch. </author> <title> Object Oriented Design with Applications. </title> <publisher> The Benjamin/Cummings Publishing Company, Inc., </publisher> <year> 1991. </year>
Reference-contexts: When we revisit the usage scenario later, we will show an example of refinement where formulate-design in preliminary-design is replaced by the OO-design process. OO-design produces an upward-compatible set of provided-resources to those of formulate-design, and it also specifies a particular design methodology, e.g. Booch's object-oriented design method <ref> [Boo91] </ref>. In more complicated cases, the composition operation must identify both the candidate process models and their precedence order. This is accomplished as follows: First, a user specifies construction goals for the derived process model in terms of its provided-resources, required-resources, agents, and tools. <p> For instance, a process model based on Booch's object-oriented design method <ref> [Boo91] </ref> can be retrieved as a method for software design (Fig ure 5). * Step 3: Compose these two process models into a tailored development plan for the project.
Reference: [Car86] <institution> Carnegie Group Inc. </institution> <note> Knowledge Craft User's Guide (Vol.1, Vol.2, and Vol.3), </note> <year> 1986. </year>
Reference-contexts: These two parts represent two levels of descriptions. One represents interdependencies among software processes, the other represents the contents of software processes. SPLib has been prototyped using the Articulator process modeling environment [MS90] and Knowledge-Craft <ref> [Car86] </ref>, which specifies objects and relations as schemata with attributes. In this section, we first present the reasons to have these two parts separate. Then we discuss the SPLib process representation, i.e. the library and the process model in detail.
Reference: [CS89] <author> S.C. Choi and W. Scacchi. </author> <title> Assurring the Correctness of Configured Software Descriptions. </title> <journal> ACM Software Engineering Notes, </journal> <volume> 17(7) </volume> <pages> 67-76, </pages> <year> 1989. </year> <month> 20 </month>
Reference-contexts: These resources are represented as independent object classes and have relations that link them to process models. For example, a product model of a software system could be defined to have a module decomposition structure, whose modules are linked to their producer and consumer subtasks <ref> [CS89] </ref>. In sum, the object classes used in software processes include: * A task and an action is a representation of development work. Tasks are decomposable, actions are not. * Agents are developers that perform role-specific development activities during software development.
Reference: [DBe90] <author> P. Devanbu, R.J. Brachman, </author> <title> and etc. LaSSIE: A Knowledge-based Software Infor--mation System. </title> <booktitle> In Proc. of the 12th International Conference on Software Engineering, </booktitle> <pages> pages 249-261, </pages> <address> Nice, France, </address> <month> March </month> <year> 1990. </year>
Reference-contexts: Bauhaus [AL89] is a knowledge-based software parts composition system shell. It has a knowledge base of reusable software component description, a catalog for browsing and editing the knowledge base, a composition editor for component specification, and a code generator for composed or tailored components. LaSSIE <ref> [DBe90] </ref> is a knowledge-based software information system. It has a frame-based knowledge representation for software objects and relations, and it provides functions to query and browse software objects. Software Components Catalogue [WS88] is another knowledge-based system for software reuse. It is an integrated component classification and retrieval system. <p> A very good approach to do this search is by a classification algorithm described in <ref> [DBe90] </ref>. In SPLib, we extend this algorithm to incorporate the additional process relations as defined earlier. The search-and-query operation first allows users to specify a level of detail to search, but it also allows them to switch levels as needed during search.
Reference: [FBe91] <author> D. Frailey, R. Bate, </author> <title> and etc. Modeling Information in a Software Process. </title> <booktitle> In Proc. of the 1st International Conference on the Software Process, </booktitle> <pages> pages 60-67, </pages> <address> Redondo Beach, CA, </address> <month> Oct </month> <year> 1991. </year>
Reference-contexts: Modeling of software processes is a new research area that has emerged in recent years. Software process modeling originally started with informal and narrative descriptions, such as natural language, which is aimed at recording experiential knowledge about development processes. Frailey and Bate <ref> [FBe91] </ref> describe Texas Instruments' effort to define a corporate-wide software process for the last three years, which is documented by English following DOD or IEEE documentation standards. Ramesh and Dhar [RD91] describe an effort to record process knowledge through a semi-formal representation. <p> Development is underway to host the SPLib on top of a distributed hypertext repository called DHT [NS91] to accommodate heterogeneous storage servers and remote access. SPLib is also being expanded to support different forms of process descriptions, such as textual <ref> [FBe91] </ref> and process programming [Ost87]. We therefore believe that the future use and reliance upon process-driven software development environments [MS92] will require and benefit from a knowledge-based process library such as we have presented here.
Reference: [HK89] <author> W.S. Humphrey and M.I. Kellner. </author> <title> Software Process Modeling: </title> <booktitle> Principles of Entity Process Models. In Proc. of the 11th International Conference on Software Engineering, </booktitle> <pages> pages 331-342, </pages> <address> Pittsburgh, PA, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: A process-driven CASE environment is also required to integrate process representation, data management, and tool invocation. Recent progress in software process modeling and process integration has made process-driven software development a very promising, yet realistic engineering technique for the software engineering community <ref> [Boe86, HK89, Kai88, MS90, MS91] </ref>. When knowledge-based process representations are utilized, management and reuse of the classes and instances of the representations becomes a necessity. To this end, a knowledge-based process library provides a solution the problem of process management and reuse.
Reference: [HL88] <author> K.E. Huff and V.R. Lesser. </author> <title> A Plan-Based Intelligent Assistant That Supports the Process of Programming. </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 13 </volume> <pages> 97-106, </pages> <month> Nov </month> <year> 1988. </year>
Reference-contexts: Therefore, informal process descriptions are limited to serve primarily as recording media, which often fall out of date. Alternatively, knowledge representations of software processes have been introduced. For example, Grapple <ref> [HL88] </ref> uses a set of goal operators and a planning mechanism to represent software processes. These are used to demonstrated goal-directed reasoning about software processes. Marvel [Kai88] uses inference rules to model software processes.
Reference: [Kai88] <author> G.E. Kaiser. </author> <title> Rule-Based Modeling of the Software Development Process. </title> <booktitle> In Proc. of the 4th International Software Process Workshop, </booktitle> <pages> pages 84-86, </pages> <address> New York, NY, </address> <year> 1988. </year>
Reference-contexts: A process-driven CASE environment is also required to integrate process representation, data management, and tool invocation. Recent progress in software process modeling and process integration has made process-driven software development a very promising, yet realistic engineering technique for the software engineering community <ref> [Boe86, HK89, Kai88, MS90, MS91] </ref>. When knowledge-based process representations are utilized, management and reuse of the classes and instances of the representations becomes a necessity. To this end, a knowledge-based process library provides a solution the problem of process management and reuse. <p> Alternatively, knowledge representations of software processes have been introduced. For example, Grapple [HL88] uses a set of goal operators and a planning mechanism to represent software processes. These are used to demonstrated goal-directed reasoning about software processes. Marvel <ref> [Kai88] </ref> uses inference rules to model software processes. The condition part of a process rule identifies preconditions for a process to start and the action part of a process rule then describes the effect of the process and its outcome.
Reference: [MS90] <author> P. Mi and W. Scacchi. </author> <title> A Knowledge-based Environment for Modeling and Simulating Software Engineering Processes. </title> <journal> IEEE Trans. on Knowledge and Data Engineering, </journal> <volume> 2(3) </volume> <pages> 283-294, </pages> <month> Sept </month> <year> 1990. </year>
Reference-contexts: A process-driven CASE environment is also required to integrate process representation, data management, and tool invocation. Recent progress in software process modeling and process integration has made process-driven software development a very promising, yet realistic engineering technique for the software engineering community <ref> [Boe86, HK89, Kai88, MS90, MS91] </ref>. When knowledge-based process representations are utilized, management and reuse of the classes and instances of the representations becomes a necessity. To this end, a knowledge-based process library provides a solution the problem of process management and reuse. <p> In this paper, we present a knowledge-based approach to organize, access and reuse software processes. We describe the initial design and prototype implementation for a knowledge-based software process library called SPLib. SPLib supports an extended version of the Articulator meta-model of software processes <ref> [MS90] </ref> and provides knowledge-based operations to access and reuse of software processes. <p> Marvel [Kai88] uses inference rules to model software processes. The condition part of a process rule identifies preconditions for a process to start and the action part of a process rule then describes the effect of the process and its outcome. The Articulator <ref> [MS90] </ref> describes software processes in terms of object classes and relations, such as task decomposition hierarchies. The defined process classes and relations form formal models of software processes, organizations, and resources, which are used to store process knowledge and simulate process enactment. <p> Accordingly, we 5 now turn to discuss the SPLib process representation and operations respectively. 5 The SPLib Process Representation The SPLib software process representation is an extended version of the Articulator meta-model we previously developed <ref> [MS90] </ref>. It consists of two parts: the library model is the extended part that describes interactions and interdependencies of software processes, the process model is the original Articulator meta-model that describes software processes themselves. These two parts represent two levels of descriptions. <p> These two parts represent two levels of descriptions. One represents interdependencies among software processes, the other represents the contents of software processes. SPLib has been prototyped using the Articulator process modeling environment <ref> [MS90] </ref> and Knowledge-Craft [Car86], which specifies objects and relations as schemata with attributes. In this section, we first present the reasons to have these two parts separate. Then we discuss the SPLib process representation, i.e. the library and the process model in detail. <p> It actually reuses the Articulator meta-model of software processes explained in <ref> [MS90] </ref>. Here we only give a brief discussion about the Articulator meta-model in order to help understand the process operations. In the Articulator, a software process is specified as an interrelated collection of objects which represent development activities, artifacts, tools, and developers. <p> Further, these objects are linked through many kinds of relations. Altogether, software process models serve as a repository of information on the status of development processes and activities that get manipulated throughout a software development project <ref> [MS90] </ref>. A software process model includes an activity hierarchy that describes a decomposition of development activities and resource requirements including software artifacts, tools, developer roles, and other critical resources. Figure 3 shows the partial schematic activity hierarchy and resource specification of a sample process fragment. <p> Here without reiterating these details, we simply list these process operations and their references when available. The simple process operations include upload, download, create-process-views, create-process-measurements, get-historical-process, and process search-and-query. The advanced process operations include process definition, process composition, 12 process specialization, process abstraction, process instantiation, process simulation <ref> [MS90] </ref>, process enactment [MS92], and process articulation [MS91]. Due to space limitations, we discuss three of these process operations in detail next. These are process search-and-query, process composition, and process abstraction. 6.1 A Process Search-and-Query Operation Process search-and-query based on a user request is a very important operation in SPLib.
Reference: [MS91] <author> P. Mi and W. Scacchi. </author> <title> Modeling Articulation Work in Software Engineering Processes. </title> <booktitle> Proc. of the 1st International Conference on the Software Process, </booktitle> <pages> pages 188-201, </pages> <month> Oct </month> <year> 1991. </year>
Reference-contexts: A process-driven CASE environment is also required to integrate process representation, data management, and tool invocation. Recent progress in software process modeling and process integration has made process-driven software development a very promising, yet realistic engineering technique for the software engineering community <ref> [Boe86, HK89, Kai88, MS90, MS91] </ref>. When knowledge-based process representations are utilized, management and reuse of the classes and instances of the representations becomes a necessity. To this end, a knowledge-based process library provides a solution the problem of process management and reuse. <p> The simple process operations include upload, download, create-process-views, create-process-measurements, get-historical-process, and process search-and-query. The advanced process operations include process definition, process composition, 12 process specialization, process abstraction, process instantiation, process simulation [MS90], process enactment [MS92], and process articulation <ref> [MS91] </ref>. Due to space limitations, we discuss three of these process operations in detail next. These are process search-and-query, process composition, and process abstraction. 6.1 A Process Search-and-Query Operation Process search-and-query based on a user request is a very important operation in SPLib.
Reference: [MS92] <author> P. Mi and W. Scacchi. </author> <title> Process Integration in CASE Environments. </title> <journal> IEEE Software, </journal> <volume> 9(2) </volume> <pages> 45-53, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Process-driven software development represents a new technique for software production in which a conceptual knowledge representation, called a software process, is used to represent and guide development activities <ref> [MS92, Ost87] </ref>. During process-driven software development, process engineers first specify a software process that is tailored for project goals and other resource constraints, and then enact the process as a guide for developers. <p> Ramesh and Dhar [RD91] describe an effort to record process knowledge through a semi-formal representation. The weakness of an informal or semi-formal representation lies in its inability to reason about process details, be symbolically executed, or downloaded into process-driven software engineering environments <ref> [MS92] </ref>. Therefore, informal process descriptions are limited to serve primarily as recording media, which often fall out of date. Alternatively, knowledge representations of software processes have been introduced. For example, Grapple [HL88] uses a set of goal operators and a planning mechanism to represent software processes. <p> The simple process operations include upload, download, create-process-views, create-process-measurements, get-historical-process, and process search-and-query. The advanced process operations include process definition, process composition, 12 process specialization, process abstraction, process instantiation, process simulation [MS90], process enactment <ref> [MS92] </ref>, and process articulation [MS91]. Due to space limitations, we discuss three of these process operations in detail next. These are process search-and-query, process composition, and process abstraction. 6.1 A Process Search-and-Query Operation Process search-and-query based on a user request is a very important operation in SPLib. <p> the project. * Later Steps include: Instantiate the final process model to a planned instance (i.e., bind specific resource values to the resource classes included in the plan); Simulate the planned instance in order to analyze and adjust resource allocations; Enact the planned instance within a process-driven software engineering environment <ref> [MS92] </ref>. view of the final customized process model after all the process operations. 18 ;; Process models at the national level -- MIL-STD-2167A INSTANCE: PROCESS-MODEL HAS-DETAILED-PROCESS: 2167-A LEVEL: NATIONAL-- ;; Process models at the organizational level -- OODP-B -- 2167-A INSTANCE: PROCESS-MODEL INSTANCE: PROCESS-MODEL HAS-DERIVATION: DVP-PLAN HAS-ABSTRACTED-PROCESS: MIL-STD-2167A LEVEL: ORGANIZATIONAL-- HAS-DERIVATION: <p> SPLib is also being expanded to support different forms of process descriptions, such as textual [FBe91] and process programming [Ost87]. We therefore believe that the future use and reliance upon process-driven software development environments <ref> [MS92] </ref> will require and benefit from a knowledge-based process library such as we have presented here.
Reference: [NS91] <author> J. Noll and W. Scacchi. </author> <title> Integrating Diverse Information Repositories: A Distributed Hypertext Approach. </title> <journal> Computer, </journal> <volume> 24(12) </volume> <pages> 38-45, </pages> <month> Dec. </month> <year> 1991. </year>
Reference-contexts: Users are also able to perform operations to compose, abstract and manipulate the process descriptions. Development is underway to host the SPLib on top of a distributed hypertext repository called DHT <ref> [NS91] </ref> to accommodate heterogeneous storage servers and remote access. SPLib is also being expanded to support different forms of process descriptions, such as textual [FBe91] and process programming [Ost87].
Reference: [Ost87] <author> L. Osterweil. </author> <title> Software Processes are Software Too. </title> <booktitle> In Proc. of the 9th International Conference on Software Engineering, </booktitle> <pages> pages 2-13, </pages> <address> Monterey, CA, </address> <month> Apr </month> <year> 1987. </year> <month> 21 </month>
Reference-contexts: 1 Introduction Process-driven software development represents a new technique for software production in which a conceptual knowledge representation, called a software process, is used to represent and guide development activities <ref> [MS92, Ost87] </ref>. During process-driven software development, process engineers first specify a software process that is tailored for project goals and other resource constraints, and then enact the process as a guide for developers. <p> Development is underway to host the SPLib on top of a distributed hypertext repository called DHT [NS91] to accommodate heterogeneous storage servers and remote access. SPLib is also being expanded to support different forms of process descriptions, such as textual [FBe91] and process programming <ref> [Ost87] </ref>. We therefore believe that the future use and reliance upon process-driven software development environments [MS92] will require and benefit from a knowledge-based process library such as we have presented here.
Reference: [RD91] <author> B. Ramesh and V. Dhar. </author> <title> Representation and Maintenance of Process Knowledge for Large Scale Systems Development. </title> <booktitle> In Proc. of 6th Knowledge-based Software Engineering Conference, </booktitle> <pages> pages 223-231, </pages> <month> Sept </month> <year> 1991. </year>
Reference-contexts: Frailey and Bate [FBe91] describe Texas Instruments' effort to define a corporate-wide software process for the last three years, which is documented by English following DOD or IEEE documentation standards. Ramesh and Dhar <ref> [RD91] </ref> describe an effort to record process knowledge through a semi-formal representation. The weakness of an informal or semi-formal representation lies in its inability to reason about process details, be symbolically executed, or downloaded into process-driven software engineering environments [MS92].
Reference: [WS88] <author> M. Wood and I. Sommerville. </author> <title> A Knowledge-based Software Components Catalogue. </title> <editor> In P. Brereton, editor, </editor> <booktitle> Software Engineering Environments, </booktitle> <pages> pages 116-133. </pages> <publisher> Ellis Horwood Limited, </publisher> <year> 1988. </year> <month> 22 </month>
Reference-contexts: LaSSIE [DBe90] is a knowledge-based software information system. It has a frame-based knowledge representation for software objects and relations, and it provides functions to query and browse software objects. Software Components Catalogue <ref> [WS88] </ref> is another knowledge-based system for software reuse. It is an integrated component classification and retrieval system. It utilizes a conceptual dependency database describing software components and their relations, then matches users requests for software components with descriptions of components which satisfy these requests.
References-found: 17

