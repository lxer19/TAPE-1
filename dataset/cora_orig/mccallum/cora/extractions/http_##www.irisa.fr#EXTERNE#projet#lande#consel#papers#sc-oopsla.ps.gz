URL: http://www.irisa.fr/EXTERNE/projet/lande/consel/papers/sc-oopsla.ps.gz
Refering-URL: http://www.cs.washington.edu/research/projects/unisw/DynComp/www/Related/papers.html
Root-URL: 
Email: e-mail: fvolanski,consel,mullerg@irisa.fr  e-mail: crispin@cse.ogi.edu  
Title: Declarative Specialization of Object-Oriented Programs  
Author: Eugen N. Volanschi, Charles Consel, Gilles Muller Crispin Cowan 
Web: http://www.irisa.fr/compose/  
Address: Campus Beaulieu, F-35042 Rennes Cedex, France  
Affiliation: Irisa/Inria University of Rennes  Department of Computer Science and Engineering Oregon Graduate Institute of Science and Technology  
Abstract: This paper presents an approach aimed at reconciling genericity and efficiency. To do so, we introduce declarations to the Java language to enable a programmer to specify how generic programs should be specialized for a particular usage pattern. Our approach has been implemented as a compiler from our extended language into standard Java. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Andersen. </author> <title> Program Analysis and Specialization for the C Programming Language. </title> <type> PhD thesis, </type> <institution> DIKU, University of Copenhagen, Denmark, </institution> <year> 1994. </year> <note> DIKU Research Report 94/19. </note>
Reference-contexts: This manual approach solves the efficiency problem, but has a limited applicability, because of the complexity of such a task. Recently, some tools have been developed to automatically specialize programs <ref> [1, 3, 11, 4, 26, 27, 10] </ref>. Applications of such tools are emerging To appear in OOPSLA'97. Also available as Technical Report RR-3118, INRIA, 1997. in a number of fields, including scientific code [4, 5, 12], systems software [19, 30], computer graphics [22, 2], with already very promising results. <p> In essence, these automatic tools are transformation engines: they implement a set of program transformations which may be directly accessible to the programmer [18] or generated by some program analyses based on the usage context of the program <ref> [3, 11, 27, 1] </ref>. Programs can now be efficiently specialized at either compile time [1, 11] or run time [27, 3, 11]. The variety of options now available to the programmer drastically broadens the applicability of program specialization. However, it also makes it difficult to use for a nonexpert. <p> Programs can now be efficiently specialized at either compile time <ref> [1, 11] </ref> or run time [27, 3, 11]. The variety of options now available to the programmer drastically broadens the applicability of program specialization. However, it also makes it difficult to use for a nonexpert. Some steps towards helping the programmer control specific aspects of specialization have been achieved. <p> An interesting direction would be to explore a selection algorithm for (general) program specialization. This algorithm would compute the most useful specialization classes, based on profiling information. Existing program specializers offer different levels of support for expressing and guiding specialization. In CMix <ref> [1] </ref>, a specializer for C programs, the transformations are guided by command line parameters to the specializer. The management of specialized components is not addressed, because the program is always specialized as a whole.
Reference: [2] <author> P. Andersen. </author> <title> Partial evaluation applied to ray tracing. </title> <type> DIKU Research Report 95/2, </type> <institution> DIKU, University of Copenhagen, Denmark, </institution> <year> 1995. </year>
Reference-contexts: Applications of such tools are emerging To appear in OOPSLA'97. Also available as Technical Report RR-3118, INRIA, 1997. in a number of fields, including scientific code [4, 5, 12], systems software [19, 30], computer graphics <ref> [22, 2] </ref>, with already very promising results. In essence, these automatic tools are transformation engines: they implement a set of program transformations which may be directly accessible to the programmer [18] or generated by some program analyses based on the usage context of the program [3, 11, 27, 1].
Reference: [3] <author> J. Auslander, M. Philipose, C. Chambers, S. Eggers, and B. Bershad. </author> <title> Fast, effective dynamic compilation. </title> <booktitle> In PLDI96 [33], </booktitle> <pages> pages 149-159. </pages>
Reference-contexts: This manual approach solves the efficiency problem, but has a limited applicability, because of the complexity of such a task. Recently, some tools have been developed to automatically specialize programs <ref> [1, 3, 11, 4, 26, 27, 10] </ref>. Applications of such tools are emerging To appear in OOPSLA'97. Also available as Technical Report RR-3118, INRIA, 1997. in a number of fields, including scientific code [4, 5, 12], systems software [19, 30], computer graphics [22, 2], with already very promising results. <p> In essence, these automatic tools are transformation engines: they implement a set of program transformations which may be directly accessible to the programmer [18] or generated by some program analyses based on the usage context of the program <ref> [3, 11, 27, 1] </ref>. Programs can now be efficiently specialized at either compile time [1, 11] or run time [27, 3, 11]. The variety of options now available to the programmer drastically broadens the applicability of program specialization. However, it also makes it difficult to use for a nonexpert. <p> Programs can now be efficiently specialized at either compile time [1, 11] or run time <ref> [27, 3, 11] </ref>. The variety of options now available to the programmer drastically broadens the applicability of program specialization. However, it also makes it difficult to use for a nonexpert. Some steps towards helping the programmer control specific aspects of specialization have been achieved. <p> Some steps towards helping the programmer control specific aspects of specialization have been achieved. In some systems, annotations are introduced in the original program to delimit code fragments to be specialized, or to indicate how to manage specialized code at run time <ref> [3, 21] </ref>. In other systems, some programming constructs in the language are overloaded to specify potential stages at which specialization can occur [27]. Although these existing strategies make specialization more usable for non-expert programmers they address very specific aspects of program specialization; many issues remain unexplored. <p> The specializable component is a function, and it is up to the programmer to generate and manage the specialized functions. In the C dynamic compiler developed by University of Washington <ref> [3, 21] </ref>, the programmer can mark replaceable components by directly annotating the program, using a few syntax extensions. The management of specialized blocks is done automatically. Cowan et al. describe some execution support for managing several versions of the same procedure, in the context of adaptive operating systems [15].
Reference: [4] <author> R. Baier, R. Gluck, and R. Zochling. </author> <title> Partial evaluation of numerical programs in Fortran. </title> <booktitle> In ACM SIGPLAN Workshop on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 119-132, </pages> <address> Orlando, FL, USA, </address> <month> June </month> <year> 1994. </year> <type> Technical Report 94/9, </type> <institution> University of Melbourne, Australia. </institution>
Reference-contexts: This manual approach solves the efficiency problem, but has a limited applicability, because of the complexity of such a task. Recently, some tools have been developed to automatically specialize programs <ref> [1, 3, 11, 4, 26, 27, 10] </ref>. Applications of such tools are emerging To appear in OOPSLA'97. Also available as Technical Report RR-3118, INRIA, 1997. in a number of fields, including scientific code [4, 5, 12], systems software [19, 30], computer graphics [22, 2], with already very promising results. <p> Recently, some tools have been developed to automatically specialize programs [1, 3, 11, 4, 26, 27, 10]. Applications of such tools are emerging To appear in OOPSLA'97. Also available as Technical Report RR-3118, INRIA, 1997. in a number of fields, including scientific code <ref> [4, 5, 12] </ref>, systems software [19, 30], computer graphics [22, 2], with already very promising results.
Reference: [5] <author> A. </author> <title> Berlin. Partial evaluation applied to numerical computation. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 139-150, </pages> <address> Nice, France, 1990. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Recently, some tools have been developed to automatically specialize programs [1, 3, 11, 4, 26, 27, 10]. Applications of such tools are emerging To appear in OOPSLA'97. Also available as Technical Report RR-3118, INRIA, 1997. in a number of fields, including scientific code <ref> [4, 5, 12] </ref>, systems software [19, 30], computer graphics [22, 2], with already very promising results.
Reference: [6] <author> B. Bershad, T. Anderson, E. Lazowska, and H. Levy. </author> <title> Lightweight remote procedure call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(1) </volume> <pages> 37-55, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: Program specialization can lead to considerable performance gains, by eliminating from the specialized code all the aspects which do not directly concern that precise context. Often, specialization has been performed manually by adapting critical program components to the most common usage patterns <ref> [36, 35, 6] </ref>. This manual approach solves the efficiency problem, but has a limited applicability, because of the complexity of such a task. Recently, some tools have been developed to automatically specialize programs [1, 3, 11, 4, 26, 27, 10]. Applications of such tools are emerging To appear in OOPSLA'97.
Reference: [7] <author> R. Campbell, N. Islam, P. Madany, and D. Raila. </author> <title> Designing and implementing Choices: an object-oriented system in C++. </title> <journal> Communications of the ACM, </journal> <year> 1993. </year>
Reference-contexts: Regarding applications of specialization classes, we are continuing the effort initiated by Cowan et al. in the area of adaptive operating system components [16]. We would like to use specialization classes to specify a number of systems optimizations that have been described in the litterature (e.g., <ref> [23, 7, 37, 20] </ref>). In particular, we are redesigning a part of the Chorus IPC subsystem, to exploit opportunities for run-time optimization that have not been addressed so far because of a lack of appropriate methodologies and tools.
Reference: [8] <author> C. Chambers. </author> <title> Predicate classes. </title> <booktitle> In Proceedings of the ECOOP'93 European Conference on Object-oriented Programming, volume 707 of Lecture Notes in Computer Science, </booktitle> <pages> pages 268-296, </pages> <address> Kaiserstautern, Ger-many, </address> <month> July </month> <year> 1993. </year>
Reference-contexts: Our unit of declaration is a specialization class. It enriches information regarding an existing class. The relationship between regular classes and specialization classes is defined by a form of inheritance, based on predicate classes as developed by Chambers <ref> [8] </ref>. An important consequence of this technique is the ability to perform incremental specialization [14] based on class inheritance. That is, the specialization of a class is not fixed, it evolves as specialization values become available. <p> Second, the user can supply manually specialized code, by supplying a complete definition for each specializable function in a specialization class. Note that this manual strategy only works when the code can be specialized statically (i.e., only for compile-time specialization classes). 5 Related Work Predicate classes <ref> [8] </ref> are a form of dynamic inheritance, which complements the static inherintace of an object-oriented language. They offer support for defining an object with several implementations, which are dynamically selected based on arbitrary predicates on the object's state.
Reference: [9] <author> W. Cheung and L. A. </author> <title> Exploring issues of operating systems structuring: from microkernel to extensible systems. </title> <journal> ACM Operating Systems Reviews, </journal> <volume> 29(4) </volume> <pages> 4-16, </pages> <month> Oct. </month> <year> 1995. </year>
Reference-contexts: This structuring leads to a number of important software engineering improvements regarding maintainability and reusability of code. However, these advantages often translate to a loss in performance. The conflict between software generality and performance has long been recognized in areas such as operating systems <ref> [9] </ref> and graphics [28]. This conflict is being increasingly addressed, with success, using forms of program specialization. This approach consists of adapting a generic program component to a given usage context.
Reference: [10] <author> C. Consel. </author> <title> A tour of Schism. </title> <booktitle> In PEPM93 [31], </booktitle> <pages> pages 66-77. </pages>
Reference-contexts: This manual approach solves the efficiency problem, but has a limited applicability, because of the complexity of such a task. Recently, some tools have been developed to automatically specialize programs <ref> [1, 3, 11, 4, 26, 27, 10] </ref>. Applications of such tools are emerging To appear in OOPSLA'97. Also available as Technical Report RR-3118, INRIA, 1997. in a number of fields, including scientific code [4, 5, 12], systems software [19, 30], computer graphics [22, 2], with already very promising results.
Reference: [11] <author> C. Consel, L. Hornof, F. Noel, J. Noye, and E. Volan-schi. </author> <title> A uniform approach for compile-time and run-time specialization. </title> <editor> In O. Danvy, R. Gluck, and P. Thie-mann, editors, </editor> <title> Partial Evaluation, </title> <booktitle> International Seminar, Dagstuhl Castle, number 1110 in Lecture Notes in Computer Science, </booktitle> <pages> pages 54-72, </pages> <month> Feb. </month> <year> 1996. </year>
Reference-contexts: This manual approach solves the efficiency problem, but has a limited applicability, because of the complexity of such a task. Recently, some tools have been developed to automatically specialize programs <ref> [1, 3, 11, 4, 26, 27, 10] </ref>. Applications of such tools are emerging To appear in OOPSLA'97. Also available as Technical Report RR-3118, INRIA, 1997. in a number of fields, including scientific code [4, 5, 12], systems software [19, 30], computer graphics [22, 2], with already very promising results. <p> In essence, these automatic tools are transformation engines: they implement a set of program transformations which may be directly accessible to the programmer [18] or generated by some program analyses based on the usage context of the program <ref> [3, 11, 27, 1] </ref>. Programs can now be efficiently specialized at either compile time [1, 11] or run time [27, 3, 11]. The variety of options now available to the programmer drastically broadens the applicability of program specialization. However, it also makes it difficult to use for a nonexpert. <p> Programs can now be efficiently specialized at either compile time <ref> [1, 11] </ref> or run time [27, 3, 11]. The variety of options now available to the programmer drastically broadens the applicability of program specialization. However, it also makes it difficult to use for a nonexpert. Some steps towards helping the programmer control specific aspects of specialization have been achieved. <p> Programs can now be efficiently specialized at either compile time [1, 11] or run time <ref> [27, 3, 11] </ref>. The variety of options now available to the programmer drastically broadens the applicability of program specialization. However, it also makes it difficult to use for a nonexpert. Some steps towards helping the programmer control specific aspects of specialization have been achieved. <p> In CMix [1], a specializer for C programs, the transformations are guided by command line parameters to the specializer. The management of specialized components is not addressed, because the program is always specialized as a whole. In Tempo <ref> [11] </ref>, (our specializer for C programs) both run-time and compile-time specialization can be done [13], based on a separate description of the specialization context. This description is flat and somewhat limited, due to the lack of sufficient structure in C programs.
Reference: [12] <author> C. Consel, L. Hornof, F. Noel, J. Noye, and E. Volan-schi. </author> <title> A uniform approach for compile-time and run-time specialization. </title> <institution> Rapport de recherche 2775, INRIA, Rennes, France, </institution> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: Recently, some tools have been developed to automatically specialize programs [1, 3, 11, 4, 26, 27, 10]. Applications of such tools are emerging To appear in OOPSLA'97. Also available as Technical Report RR-3118, INRIA, 1997. in a number of fields, including scientific code <ref> [4, 5, 12] </ref>, systems software [19, 30], computer graphics [22, 2], with already very promising results. <p> We are currently working on a specializer for Java code which is not yet fully functional. The idea is to use our existing Java-bytecode to C compiler, called Harissa [29], as a front-end to our existing specializer for C programs, called Tempo <ref> [12, 24] </ref>. Specialized programs may then be translated back to Java. In the meantime, one can use specialization classes in two ways. First, Tempo can be directly used for specializing native methods in Java programs, both for compile-time and run-time specialization classes.
Reference: [13] <author> C. Consel and F. Noel. </author> <title> A general approach for run-time specialization and its application to C. </title> <booktitle> In POPL96 [34], </booktitle> <pages> pages 145-156. </pages>
Reference-contexts: The management of specialized components is not addressed, because the program is always specialized as a whole. In Tempo [11], (our specializer for C programs) both run-time and compile-time specialization can be done <ref> [13] </ref>, based on a separate description of the specialization context. This description is flat and somewhat limited, due to the lack of sufficient structure in C programs. The run-time specialized versions must be entirely managed by the user.
Reference: [14] <author> C. Consel, C. Pu, and J. Walpole. </author> <title> Incremental specialization: The key to high performance, modularity and portability in operating systems. </title> <booktitle> In PEPM93 [31], </booktitle> <pages> pages 44-46. </pages> <note> Invited paper. </note>
Reference-contexts: It enriches information regarding an existing class. The relationship between regular classes and specialization classes is defined by a form of inheritance, based on predicate classes as developed by Chambers [8]. An important consequence of this technique is the ability to perform incremental specialization <ref> [14] </ref> based on class inheritance. That is, the specialization of a class is not fixed, it evolves as specialization values become available. Configuring an application for a given usage context now amounts to separately declaring a set of specialization classes. From these declarations, the specialized behavior is derived.
Reference: [15] <author> C. Cowan, T. Autrey, C. Krasic, C. Pu, and J. Walpole. </author> <title> Fast concurrent dynamic linking for an adaptive operating system. </title> <booktitle> In International Conference on Configurable Distributed Systems, Annapolis, </booktitle> <address> MD, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: The management of specialized blocks is done automatically. Cowan et al. describe some execution support for managing several versions of the same procedure, in the context of adaptive operating systems <ref> [15] </ref>. Their work focuses on a re-plugging algorithm able to deal with the concurrency issues of an operating system. Finally, let us note that our compiling scheme for generating the execution support generalizes some programming patterns found in object-oriented applications dealing with forms of dynamic adaptivity.
Reference: [16] <author> C. Cowan, A. Black, C. Krasic, C. Pu, J. Walpole, C. Consel, and E. Volanschi. </author> <title> Specialization classes: An object framework for specialization. </title> <booktitle> In Fifth IEEE International Workshop on Object-Orientation in Operating Systems, </booktitle> <address> Seattle, Washington, </address> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: In particular, we plan on introducing disjunctions and class variables to improve the expressive power of predicates. Regarding applications of specialization classes, we are continuing the effort initiated by Cowan et al. in the area of adaptive operating system components <ref> [16] </ref>. We would like to use specialization classes to specify a number of systems optimizations that have been described in the litterature (e.g., [23, 7, 37, 20]).
Reference: [17] <author> J. Dean, C. Chambers, and D. Grove. </author> <title> Selective specialization for object-oriented languages. </title> <booktitle> In Proceedings of the ACM SIGPLAN '95 Conference on Programming Language Design and Implementation. ACM SIGPLAN Notices, </booktitle> <volume> 30(6), </volume> <month> June </month> <year> 1995. </year> <month> 12 </month>
Reference-contexts: Dean et al. explore a specific form of program specialization, which is aimed at eliminating most of the virtual method calls in an object-oriented language <ref> [17] </ref>. To eliminate a virtual method call on a receiver object, a clone of the caller method is produced for each possible type of both the receiver and the arguments. Special care is taken to avoid an uncontrolled code growth by selectively performing this optimization.
Reference: [18] <author> D. Engler, W. Hsieh, and M. Kaashoek. </author> <title> `C: A lan-guage for high-level, efficient, and machine-independent dynamic code generation. </title> <booktitle> In POPL96 [34], </booktitle> <pages> pages 131-144. </pages>
Reference-contexts: In essence, these automatic tools are transformation engines: they implement a set of program transformations which may be directly accessible to the programmer <ref> [18] </ref> or generated by some program analyses based on the usage context of the program [3, 11, 27, 1]. Programs can now be efficiently specialized at either compile time [1, 11] or run time [27, 3, 11].
Reference: [19] <author> D. Engler and M. Kaashoek. DPF: </author> <title> Fast, flexible message demultiplexing using dynamic code generation. </title> <booktitle> In SIGCOMM Symposium on Communications Architectures and Protocols, </booktitle> <address> Stanford University, CA, Aug. 1996. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Recently, some tools have been developed to automatically specialize programs [1, 3, 11, 4, 26, 27, 10]. Applications of such tools are emerging To appear in OOPSLA'97. Also available as Technical Report RR-3118, INRIA, 1997. in a number of fields, including scientific code [4, 5, 12], systems software <ref> [19, 30] </ref>, computer graphics [22, 2], with already very promising results.
Reference: [20] <author> M. Gien. </author> <title> Evolution of the CHORUS open microkernel architecture: The STREAM project. </title> <booktitle> In Proceedings of Fifth IEEE Workshop on Future Trends in Distributed Computing Systems (FTDCS'95), </booktitle> <address> Cheju Island, Korea, </address> <month> Aug. </month> <year> 1995. </year> <note> IEEE Computer Society Press. Also Technical Report CS/TR-95-107, Chorus Systemes. </note>
Reference-contexts: file, read-only fl= g == File hierarchy: specclass ReadFile specializes class File f mode; =fl any value is good fl= ReadFileInode ino; =fl restriction on the inode's state fl= read (); =fl produce a simpler version: disk file, mode is known fl= g specclass ExclReadFile extends specclass ReadFile cached Amortization <ref> [20] </ref> f count == 1; read (); =fl produce an even simpler version: no more locking fl= g 9 compile-time class to be classified run-time by prefixing the specialization class declaration with the keyword runtime. <p> Regarding applications of specialization classes, we are continuing the effort initiated by Cowan et al. in the area of adaptive operating system components [16]. We would like to use specialization classes to specify a number of systems optimizations that have been described in the litterature (e.g., <ref> [23, 7, 37, 20] </ref>). In particular, we are redesigning a part of the Chorus IPC subsystem, to exploit opportunities for run-time optimization that have not been addressed so far because of a lack of appropriate methodologies and tools.
Reference: [21] <author> B. Grant, M. Mock, M. Philipose, C. Chambers, and S. Eggers. </author> <title> Annotation-directed run-time specialization in C. </title> <booktitle> In PEPM97 [32], </booktitle> <pages> pages 163-178. </pages>
Reference-contexts: Some steps towards helping the programmer control specific aspects of specialization have been achieved. In some systems, annotations are introduced in the original program to delimit code fragments to be specialized, or to indicate how to manage specialized code at run time <ref> [3, 21] </ref>. In other systems, some programming constructs in the language are overloaded to specify potential stages at which specialization can occur [27]. Although these existing strategies make specialization more usable for non-expert programmers they address very specific aspects of program specialization; many issues remain unexplored. <p> The specializable component is a function, and it is up to the programmer to generate and manage the specialized functions. In the C dynamic compiler developed by University of Washington <ref> [3, 21] </ref>, the programmer can mark replaceable components by directly annotating the program, using a few syntax extensions. The management of specialized blocks is done automatically. Cowan et al. describe some execution support for managing several versions of the same procedure, in the context of adaptive operating systems [15].
Reference: [22] <author> B. Guenter, T. Knoblock, and E. Ruf. Specializing shaders. </author> <booktitle> In Computer Graphics Proceedings, Annual Conference Series, </booktitle> <pages> pages 343-350. </pages> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: Applications of such tools are emerging To appear in OOPSLA'97. Also available as Technical Report RR-3118, INRIA, 1997. in a number of fields, including scientific code [4, 5, 12], systems software [19, 30], computer graphics <ref> [22, 2] </ref>, with already very promising results. In essence, these automatic tools are transformation engines: they implement a set of program transformations which may be directly accessible to the programmer [18] or generated by some program analyses based on the usage context of the program [3, 11, 27, 1].
Reference: [23] <author> G. Hamilton and P. Kougiouris. </author> <title> The Spring nucleus: A microkernel for objects. </title> <type> Technical Report SMLI TR-93-14, </type> <institution> Sun Microsystems Laboratories, Inc., </institution> <month> Apr. </month> <year> 1993. </year>
Reference-contexts: Regarding applications of specialization classes, we are continuing the effort initiated by Cowan et al. in the area of adaptive operating system components [16]. We would like to use specialization classes to specify a number of systems optimizations that have been described in the litterature (e.g., <ref> [23, 7, 37, 20] </ref>). In particular, we are redesigning a part of the Chorus IPC subsystem, to exploit opportunities for run-time optimization that have not been addressed so far because of a lack of appropriate methodologies and tools.
Reference: [24] <author> L. Hornof and J. </author> <title> Noye. Accurate binding-time analysis for imperative languages: Flow, context, and return sensitivity. </title> <booktitle> In PEPM97 [32]. </booktitle>
Reference-contexts: We are currently working on a specializer for Java code which is not yet fully functional. The idea is to use our existing Java-bytecode to C compiler, called Harissa [29], as a front-end to our existing specializer for C programs, called Tempo <ref> [12, 24] </ref>. Specialized programs may then be translated back to Java. In the meantime, one can use specialization classes in two ways. First, Tempo can be directly used for specializing native methods in Java programs, both for compile-time and run-time specialization classes.
Reference: [25] <author> G. Kiczales. </author> <note> Aspect-oriented programming. http://- www.parc.xerox.com/spl/projects/aop/, 1996. </note>
Reference-contexts: Declaring the specialization behavior of a program should not cause the disturbance of the source of this program. We advocate that declaring specialization should be seen as adding information just as one would declare different aspects of a software component in an Aspect-Oriented language <ref> [25] </ref>. In fact, in our approach, a separate specialization declaration can be associated with any class. * A uniform approach. As previously noted, progress in program specialization has considerably increased the number of parameters of this process (manual, automatic, incremental, run-time, compile-time, : : : ).
Reference: [26] <author> P. Kleinrubatscher, A. Kriegshaber, R. Zochling, and R. Gluck. </author> <title> Fortran program specialization. </title> <editor> In U. Meyer and G. Snelting, editors, </editor> <booktitle> Workshop Semantikgestutzte Analyse, Entwicklung und Generierung von Program-men, </booktitle> <pages> pages 45-54. </pages> <address> Justus-Liebig-Universitat, Giessen, Germany, </address> <year> 1994. </year> <note> Report No. 9402. </note>
Reference-contexts: This manual approach solves the efficiency problem, but has a limited applicability, because of the complexity of such a task. Recently, some tools have been developed to automatically specialize programs <ref> [1, 3, 11, 4, 26, 27, 10] </ref>. Applications of such tools are emerging To appear in OOPSLA'97. Also available as Technical Report RR-3118, INRIA, 1997. in a number of fields, including scientific code [4, 5, 12], systems software [19, 30], computer graphics [22, 2], with already very promising results.
Reference: [27] <author> P. Lee and M. Leone. </author> <title> Optimizing ML with run-time code generation. </title> <booktitle> In PLDI96 [33], </booktitle> <pages> pages 137-148. </pages>
Reference-contexts: This manual approach solves the efficiency problem, but has a limited applicability, because of the complexity of such a task. Recently, some tools have been developed to automatically specialize programs <ref> [1, 3, 11, 4, 26, 27, 10] </ref>. Applications of such tools are emerging To appear in OOPSLA'97. Also available as Technical Report RR-3118, INRIA, 1997. in a number of fields, including scientific code [4, 5, 12], systems software [19, 30], computer graphics [22, 2], with already very promising results. <p> In essence, these automatic tools are transformation engines: they implement a set of program transformations which may be directly accessible to the programmer [18] or generated by some program analyses based on the usage context of the program <ref> [3, 11, 27, 1] </ref>. Programs can now be efficiently specialized at either compile time [1, 11] or run time [27, 3, 11]. The variety of options now available to the programmer drastically broadens the applicability of program specialization. However, it also makes it difficult to use for a nonexpert. <p> Programs can now be efficiently specialized at either compile time [1, 11] or run time <ref> [27, 3, 11] </ref>. The variety of options now available to the programmer drastically broadens the applicability of program specialization. However, it also makes it difficult to use for a nonexpert. Some steps towards helping the programmer control specific aspects of specialization have been achieved. <p> In other systems, some programming constructs in the language are overloaded to specify potential stages at which specialization can occur <ref> [27] </ref>. Although these existing strategies make specialization more usable for non-expert programmers they address very specific aspects of program specialization; many issues remain unexplored. This paper We present a complete declarative approach for program specialization in the context of the object-oriented paradigm. <p> This description is flat and somewhat limited, due to the lack of sufficient structure in C programs. The run-time specialized versions must be entirely managed by the user. In Fabius <ref> [27] </ref>, a special-izer for ML programs, the user guides the transformations by rewriting the program to expose two execution stages, using currying. The specializable component is a function, and it is up to the programmer to generate and manage the specialized functions.
Reference: [28] <author> B. Locanthi. </author> <title> Fast bitblt() with asm() and cpp. </title> <booktitle> In Eu-ropean UNIX Systems User Group Conference Proceedings, </booktitle> <pages> pages 243-259, </pages> <institution> AT&T Bell Laboratories, </institution> <address> Murray Hill, </address> <month> Sept. </month> <year> 1987. </year> <month> EUUG. </month>
Reference-contexts: This structuring leads to a number of important software engineering improvements regarding maintainability and reusability of code. However, these advantages often translate to a loss in performance. The conflict between software generality and performance has long been recognized in areas such as operating systems [9] and graphics <ref> [28] </ref>. This conflict is being increasingly addressed, with success, using forms of program specialization. This approach consists of adapting a generic program component to a given usage context.
Reference: [29] <author> G. Muller, B. Moura, F. Bellard, and C. Consel. </author> <title> JIT vs. o*ine compilers: Limits and benefits of bytecode compilation. </title> <institution> Rapport de recherche 1063, IRISA, Rennes, France, </institution> <month> Dec. </month> <year> 1996. </year>
Reference-contexts: Our prototype directly implements the compilation algorithm given in Appendix A, using the JavaCC parser generator from Sun [38]. We are currently working on a specializer for Java code which is not yet fully functional. The idea is to use our existing Java-bytecode to C compiler, called Harissa <ref> [29] </ref>, as a front-end to our existing specializer for C programs, called Tempo [12, 24]. Specialized programs may then be translated back to Java. In the meantime, one can use specialization classes in two ways.
Reference: [30] <author> G. Muller, E. Volanschi, and R. Marlet. </author> <title> Scaling up partial evaluation for optimizing a commercial RPC protocol. </title> <institution> Rapport de recherche 1068, IRISA, Rennes, France, </institution> <month> Dec. </month> <year> 1996. </year> <booktitle> Also published in ACM SIGPLAN Conference on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <year> 1997. </year>
Reference-contexts: Recently, some tools have been developed to automatically specialize programs [1, 3, 11, 4, 26, 27, 10]. Applications of such tools are emerging To appear in OOPSLA'97. Also available as Technical Report RR-3118, INRIA, 1997. in a number of fields, including scientific code [4, 5, 12], systems software <ref> [19, 30] </ref>, computer graphics [22, 2], with already very promising results.
Reference: [31] <institution> Partial Evaluation and Semantics-Based Program Manipulation, Copenhagen, </institution> <address> Denmark, June 1993. </address> <publisher> ACM Press. </publisher>
Reference: [32] <institution> ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </institution> <address> Amsterdam, The Netherlands, June 1997. </address> <publisher> ACM Press. </publisher>
Reference: [33] <institution> Proceedings of the ACM SIGPLAN '96 Conference on Programming Language Design and Implementation. ACM SIGPLAN Notices, </institution> <month> 31(5), May </month> <year> 1996. </year>
Reference: [34] <institution> Conference Record of the 23 rd Annual ACM SIGPLAN-SIGACT Symposium on Principles Of Programming Languages, </institution> <address> St. Petersburg Beach, FL, USA, Jan. 1996. </address> <publisher> ACM Press. </publisher>
Reference: [35] <author> C. Pu, T. Autrey, A. Black, C. Consel, C. Cowan, J. Inouye, L. Kethana, J. Walpole, and K. Zhang. </author> <title> Optimistic incremental specialization: Streamlining a commercial operating system. </title> <booktitle> In Proceedings of the 1995 ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 314-324, </pages> <address> Copper Mountain Resort, CO, USA, </address> <month> Dec. </month> <year> 1995. </year> <title> ACM Operating Systems Reviews, </title> <publisher> 29(5),ACM Press. </publisher>
Reference-contexts: Program specialization can lead to considerable performance gains, by eliminating from the specialized code all the aspects which do not directly concern that precise context. Often, specialization has been performed manually by adapting critical program components to the most common usage patterns <ref> [36, 35, 6] </ref>. This manual approach solves the efficiency problem, but has a limited applicability, because of the complexity of such a task. Recently, some tools have been developed to automatically specialize programs [1, 3, 11, 4, 26, 27, 10]. Applications of such tools are emerging To appear in OOPSLA'97. <p> If its value can never change, the predicate is said to be stable. If it can be invalidated because of some state changes, it is said to be unstable. Both stable and unstable predicates correspond to actual situations found in real experiments <ref> [36, 35, 39] </ref>. Incremental specialization. A set of predicates may not be satisfied all at once. Usually, all predicates do not become true at once. <p> There are some other syntactic constructs through which the user can influence how the specialization is achieved (keywords runtime and cached). They relate to run-time specialization, and are discussed in section 4. 3.2 Specializing a Filesystem In a previous study <ref> [35] </ref>, Pu et al. motivated the need for incremental specialization in the context of adaptive operating systems. This experiment focused on the HP-UX file system. A number of stable and unstable predicates were identified 3 , under which specialization was performed by hand with very good results.
Reference: [36] <author> C. Pu, H. Massalin, and J. Ioannidis. </author> <title> The Synthesis kernel. </title> <journal> Computing Systems, </journal> <volume> 1(1) </volume> <pages> 11-32, </pages> <month> Winter </month> <year> 1988. </year>
Reference-contexts: Program specialization can lead to considerable performance gains, by eliminating from the specialized code all the aspects which do not directly concern that precise context. Often, specialization has been performed manually by adapting critical program components to the most common usage patterns <ref> [36, 35, 6] </ref>. This manual approach solves the efficiency problem, but has a limited applicability, because of the complexity of such a task. Recently, some tools have been developed to automatically specialize programs [1, 3, 11, 4, 26, 27, 10]. Applications of such tools are emerging To appear in OOPSLA'97. <p> If its value can never change, the predicate is said to be stable. If it can be invalidated because of some state changes, it is said to be unstable. Both stable and unstable predicates correspond to actual situations found in real experiments <ref> [36, 35, 39] </ref>. Incremental specialization. A set of predicates may not be satisfied all at once. Usually, all predicates do not become true at once.
Reference: [37] <author> V. Rozier, V. Abrossimov, F. Armand, I. Boule, M. Gien, M. Guillemont, F. Herrmann, C. Kaiser, S. Langlois, P. Leonard, and W. Neuhauser. </author> <title> Overview of the Chorus distributed operating system. </title> <booktitle> In USENIX Workshop Proceedings - Micro-kernels and Other Kernel Architectures, </booktitle> <pages> pages 39-70, </pages> <address> Seattle, WA, USA, </address> <month> Apr. </month> <year> 1992. </year>
Reference-contexts: Regarding applications of specialization classes, we are continuing the effort initiated by Cowan et al. in the area of adaptive operating system components [16]. We would like to use specialization classes to specify a number of systems optimizations that have been described in the litterature (e.g., <ref> [23, 7, 37, 20] </ref>). In particular, we are redesigning a part of the Chorus IPC subsystem, to exploit opportunities for run-time optimization that have not been addressed so far because of a lack of appropriate methodologies and tools.
Reference: [38] <author> Sun. </author> <title> JavaCC | the Java compiler compiler. </title> <note> http://- www.suntest.com/JavaCC/, 1997. </note>
Reference-contexts: Our prototype directly implements the compilation algorithm given in Appendix A, using the JavaCC parser generator from Sun <ref> [38] </ref>. We are currently working on a specializer for Java code which is not yet fully functional. The idea is to use our existing Java-bytecode to C compiler, called Harissa [29], as a front-end to our existing specializer for C programs, called Tempo [12, 24].
Reference: [39] <author> E. Volanschi, G. Muller, and C. Consel. </author> <title> Safe operating system specialization: the RPC case study. </title> <booktitle> In Workshop Record of WCSSS'96 The Inaugural Workshop on Compiler Support for Systems Software, </booktitle> <pages> pages 24-28, </pages> <address> Tucson, AZ, USA, </address> <month> Feb. </month> <year> 1996. </year> <month> 13 </month>
Reference-contexts: If its value can never change, the predicate is said to be stable. If it can be invalidated because of some state changes, it is said to be unstable. Both stable and unstable predicates correspond to actual situations found in real experiments <ref> [36, 35, 39] </ref>. Incremental specialization. A set of predicates may not be satisfied all at once. Usually, all predicates do not become true at once.
References-found: 39

