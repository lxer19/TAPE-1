URL: http://osl.cs.uiuc.edu/Papers/sturman-phd.ps
Refering-URL: http://osl.cs.uiuc.edu/ExMembers/sturman/
Root-URL: http://www.cs.uiuc.edu
Note: c flCopyright by Daniel Charles Sturman, 1996  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> M. Acceta, R. Baron, W. Bolosky, D. Golub, R. Rashid, A. Tevanian, and M. Young. </author> <title> Mach: A New Kernel Foundation for UNIX Development. </title> <booktitle> In USENIX 1986 Summer Conference Proceedings, </booktitle> <month> June </month> <year> 1986. </year>
Reference-contexts: Applications interact with the system through system-calls, thereby invoking a predefined function at the system level. To extend this model to support customization, micro-kernels move much of the functionality reserved for the system into the application domain <ref> [1] </ref>. Object-oriented operating systems also support customization through the use of frameworks: sets of classes customizing the operating system for a particular execution environment [14]. These approaches, however, only enable coarse-grained customization of a system.
Reference: [2] <author> G. Agha, I. Mason, S. Smith, and C. Talcott. </author> <title> Towards a Theory of Actor Computation. </title> <editor> In R. Cleaveland, editor, </editor> <booktitle> The Third International Conference on Concurrency Theory (CONCUR '92), </booktitle> <pages> pages 565-579. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year> <note> LNCS 630. </note>
Reference-contexts: Such an approach was taken by the Carnot project at MCC [61]. In Carnot, the actor language Rosette "glues" sequential components together to facilitate heterogeneous distributed computing for enterprise integration. Actor operators have also been combined with functional languages. Specifically, actor operators have been added to the call-by-value -calculus <ref> [2] </ref>. In this case, local computation is modeled as sequential functional computation. An operational semantics is developed for the resulting language that supports operational reasoning. <p> For example, a recursive factorial function may be described with rec in our language (assuming primitive functions =, fi, and ): 5.2.2 Actor Extensions Given the above definitions and grammar for the lambda calculus the extensions necessary to realize actors and communicators may be expressed as primitive functions and operators <ref> [2] </ref>. Before detailing these operators, however, it is necessary to first address actor representation in the language. Fundamentally, an actor is a message reception endpoint. Associated with each actor will be a behavior which defines its response to a message. <p> Actor addresses belong to a countable set A d. For simplicity, we identify A d with X. This pun allows us to use expressions to describe actors and messages. Furthermore, choosing of names for newly created actors is simplified though an extended form of ff-conversion <ref> [2] </ref>. The ready primitive is a unary operator which specifies an actor's replacement behavior, i.e., the behavior for processing the next message. An actor blocks on a ready operation until a message is available for processing, at which point it applies the argument of operator to the new message.
Reference: [3] <author> Gul Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: In particular, we ignore issues such as typing and inheritance and instead focus on the fundamental actor concepts of communication and dynamic creation. Our language is an extension of the call-by-value lambda calculus. We extend the calculus to support the Actor model <ref> [3] </ref> by incorporating commands for actor functionality. In particular, we develop primitive commands for communication, actor creation, and continuity of state. Specifically, the following three commands, when added to a language, enable the description of actors: send Transmits a message, letactor Creates new actors and assigns them fresh actor addresses.
Reference: [4] <author> Gul Agha and Daniel C. Sturman. </author> <title> A Methodology for Adapting to Patterns of Faults. </title> <editor> In Gary M. Koob and Clifford G. Lau, editors, </editor> <title> Foundations of Dependable Computing: Models and Frameworks for Dependable Systems, chapter 1.2. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1994. </year>
Reference-contexts: The platform supports C++ calls for both send and new. Using Broadway, developers of distributed programs may use a well known language | C++ | to develop distributed programs. Besides the basic primitives presented above, Broadway supports exception handling <ref> [4] </ref> and synchronization constraints [21]. Synchronization constraints provide local control over when messages may be processed. Individual methods may be disabled or enabled based on the state of the actor to ensure state consistency. <p> Through several examples we demonstrate how dependability techniques may be expressed using the architecture. 4.2.1 Customizing Communication We use reflection to customize the transmission and reception behavior of a component <ref> [4] </ref>. Specifically, actor behavior may be modified by installing a communication meta-level actor called a communicator. A communicator provides a representation of both the actor's dispatch and reception behaviors. Each actor may be customized by its own meta-level object, enabling customization on a per-component basis. <p> Basic actor functionality is augmented with support for migration, exception handling <ref> [4] </ref>, and synchronization constraints [21]. These additional features greatly simplify the development of distributed programs. The platform currently runs on Ultrix for DEC MIPS workstations, on Solaris for SUN Sparcstations, and IRIX 5 for SGI workstations.
Reference: [5] <author> Gul A. Agha, Ian Mason, Scott Smith, and Carolyn Talcott. </author> <title> A Foundation for Actor Computation. </title> <journal> Journal of Functional Programming, </journal> <note> 1996. (to be published). </note>
Reference-contexts: To achieve this goal, we develop an operational semantics describing the affect of communicators in an actor system. We begin with the definition of a simple actor language and present a brief explanation of the semantics for this language. For a more detailed analysis of Actor semantics see <ref> [5] </ref>. This semantics defines transition rules for reasoning about configurations of actors including configuration composition and equivalence relations. <p> The transition system presented can be used in conjunction with existing techniques developed for actor systems <ref> [5] </ref> to reason about properties such as safety, liveness, correctness, or equivalence.
Reference: [6] <institution> Architecture Projects Management Limited, </institution> <address> Cambridge, United Kingdom. </address> <booktitle> A Model for Interface Groups, </booktitle> <year> 1993. </year> <month> AR.002.01. </month>
Reference-contexts: Availability specifications allow the programmer to create resilient objects with a custom policy controlling number of replicas and the synchronization control to be used between these replicas. The ESPRIT/ISA project supports interface groups that allow replication policies to be customized <ref> [46, 6] </ref> by allowing the programmer to specify the interface to a group of concurrent objects. Thus a programmer may choose between active versus passive replication as well as specifying the number of replicas or a custom control policy for the replicas.
Reference: [7] <author> M. Astley and G. Agha. </author> <title> A Visualization Model for Concurrent Systems. </title> <journal> International Journal of Information Science, </journal> <note> 1996. (To Appear). </note>
Reference-contexts: The concepts developed in this thesis may serve as a model for separating arbitrary design concerns in a distributed environment. Further examples of this approach include object placement and load-balancing [48], multi-object synchronization constraints [22], program visualization <ref> [7] </ref>, or real-time constraints [53, 44]. All of these approaches provide meta-level access to traditionally system-level aspects of actor behavior to avoid complication of application code to support these concepts. Another application of these techniques is solving some of the complex problems posed by the global computing environment.
Reference: [8] <author> Lodewijk Bergmans. </author> <title> Composing Concurrent Objects. </title> <type> PhD thesis, </type> <institution> University of Twente, </institution> <year> 1994. </year>
Reference-contexts: The flexibility of this approach, although desirable for priority-based messaging schemes, greatly complicates the semantics of the reflective state operators and message processing, and therefore makes it more difficult to express protocols. The composition-filter model allows customization of communication through the use of filters <ref> [8] </ref>. Although filters simplify coordination between distributed components, filters have no state and may not receive messages thereby making them inappropriate for developing fault-tolerant protocols. Our approach allows communication modification to be expressed as objects using the same techniques already familiar to the programmer in designing application objects.
Reference: [9] <author> K. P. Birman and T. A. Joseph. </author> <title> Communication Support for Reliable Distributed Computing. In Fault-tolerant Distributed Computing. </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: In addition to transaction systems, another area which has been targeted by systems to simplify distributed programming has been in group or replica management. The focus in in Consul [40], by Cooper [17], and in Isis <ref> [12, 9, 11] </ref> is to provide a set of protocols that represent common communication patterns found in fault-tolerant systems. The Isis system provides support for communication between groups of distributed processes. Multiple approaches to replication may be used as there are few restrictions on which processes may comprise a group.
Reference: [10] <author> Ken Birman. </author> <title> A Response to Cheriton and Skeen's Criticism of Causal and Totally Ordered Communca-tion. </title> <journal> ACM Operating Systems Review, </journal> <month> October </month> <year> 1993. </year>
Reference-contexts: A rebuttal to this argument is that system designers need tools which simplify distributed programming and implementing each protocol for each application in a customized manner will greatly complicate the development process <ref> [10] </ref>. Dil provides techniques which address both arguments. Protocols may be customized on a per-application basis and support an interface with the application, thereby enabling end-to-end design. At the same time, a static interface enables reuse of protocols with other applications and the construction of protocol libraries.
Reference: [11] <author> Kenneth P. Birman. </author> <title> The Process Group Approach to Reliable Distributed Computing. </title> <journal> Communications of the ACM, </journal> <volume> 36(12) </volume> <pages> 37-53, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: In addition to transaction systems, another area which has been targeted by systems to simplify distributed programming has been in group or replica management. The focus in in Consul [40], by Cooper [17], and in Isis <ref> [12, 9, 11] </ref> is to provide a set of protocols that represent common communication patterns found in fault-tolerant systems. The Isis system provides support for communication between groups of distributed processes. Multiple approaches to replication may be used as there are few restrictions on which processes may comprise a group.
Reference: [12] <author> Kenneth P. Birman, Thomas A. Joseph, Thomas Raeuchle, and Amr El Abbadi. </author> <title> Implementing Fault-Tolerant Distributed Objects. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 11(6) </volume> <pages> 502-508, </pages> <month> June </month> <year> 1985. </year>
Reference-contexts: In addition to transaction systems, another area which has been targeted by systems to simplify distributed programming has been in group or replica management. The focus in in Consul [40], by Cooper [17], and in Isis <ref> [12, 9, 11] </ref> is to provide a set of protocols that represent common communication patterns found in fault-tolerant systems. The Isis system provides support for communication between groups of distributed processes. Multiple approaches to replication may be used as there are few restrictions on which processes may comprise a group.
Reference: [13] <author> Navin Budhiraja, Keith Marzullo, Fred B. Schneider, and Sam Toueg. </author> <title> Primary-Backup Protocols: Lower Bounds and Optimal Implementations. </title> <type> Technical Report TR92-1265, </type> <institution> Cornell University, Department of Computer Science, </institution> <month> January </month> <year> 1992. </year>
Reference-contexts: A simple primary-backup protocol which tolerates a single server crash can be expressed expressed easily (in English). This protocol assumes that all communication is through point-to-point non-faulty links and that each link has an upper bound ffi on message delivery time <ref> [13] </ref>. We use this simple protocol, as shown in Figure 2.2, to illustrate the deficiencies in the object-based approach. This protocol takes the following actions. 1. The client logs the request and sends it to the server. The server processes the request. 2. <p> The application is a simple data-base application. A client repeatedly sets values in the database. After 1000 writes, the client reads back each value written. The protocol used is a simple primary-backup protocol <ref> [13] </ref>. Whenever the server receives a request it: 1. processes the message, 2. sends the message to the backup, 3. without waiting for an acknowledgment from the backup, replies to the client that the task is complete.
Reference: [14] <author> Roy Campbell, Nayeem Islam, David Raila, and Peter Madany. </author> <title> Designing and Implementing Choices: An Object-Oriented System in C++. </title> <journal> Communications of the ACM, </journal> <pages> pages 117-126, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: To extend this model to support customization, micro-kernels move much of the functionality reserved for the system into the application domain [1]. Object-oriented operating systems also support customization through the use of frameworks: sets of classes customizing the operating system for a particular execution environment <ref> [14] </ref>. These approaches, however, only enable coarse-grained customization of a system. Another approach, however, is to move system-level behavior into the application-level, but to export this behavior on a per-object basis rather than on a system-wide basis. <p> Both interface groups and distributed locking address only replication. Our approach supports the manipulation of state as well as the addition and removal of messages. Other non-reflective systems which support customization tend to do so only on a system-wide basis. In an object-oriented operating system such as Choices <ref> [14] </ref>, frameworks may be customized for a particular application. However, once customized the characteristics are fixed for all objects linked with the framework. Reflection in an object based system allows customization of the underlying system independently for each object.
Reference: [15] <author> David R. Cheriton and Dale Skeen. </author> <title> Understanding the Limitations of Causally and Totally Ordered Communication. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, volume 17(5) of ACM Operating Systems Review, </booktitle> <pages> pages 69-79. </pages> <booktitle> ACM Special Interest Group on Operating Systems, </booktitle> <month> December </month> <year> 1993. </year> <month> 63 </month>
Reference-contexts: Only in this manner, the argument states, can optimal performance and correctness be achieved. In particular, issues regarding the utility of causal and totally ordered communication 22 have been raised <ref> [15] </ref> because they are implemented independent of application specific informa-tion. A rebuttal to this argument is that system designers need tools which simplify distributed programming and implementing each protocol for each application in a customized manner will greatly complicate the development process [10]. Dil provides techniques which address both arguments.
Reference: [16] <author> Andrew Chien, Vijay Karamcheti, and John Plevyak. </author> <title> The Concert System Compiler and Runtime Support for Efficient Fine-Grained Concurrent Object-Oriented Programs. </title> <type> Technical Report UIUCDCS-R-93-1815, </type> <institution> Department of Computer Science, University of Illinois, Urbana, Illinois, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: To eliminate this cost, we build on previous work aimed at optimizing concurrent object-oriented languages for parallel systems <ref> [34, 16, 51] </ref>. Specifically, we concentrate on converting communication between a meta-actor and its base-actor into a series of function calls. Techniques have been proposed that use the results from type-inference [47] to replace local message sends with function calls.
Reference: [17] <author> E. Cooper. </author> <title> Programming Language Support for Multicast Communication in Distributed Systems. </title> <booktitle> In Tenth International Conference on Distributed Computer Systems, </booktitle> <year> 1990. </year>
Reference-contexts: Thus, inheritance may be used to customize how this functionality is supported for a particular component. In addition to transaction systems, another area which has been targeted by systems to simplify distributed programming has been in group or replica management. The focus in in Consul [40], by Cooper <ref> [17] </ref>, and in Isis [12, 9, 11] is to provide a set of protocols that represent common communication patterns found in fault-tolerant systems. The Isis system provides support for communication between groups of distributed processes.
Reference: [18] <author> Jeffrey L. Eppinger, Lily B. Mummert, and Alfred Z. Spector, </author> <title> editors. CAMELOT AND AVALON: A Distributed Transaction Facility. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1991. </year>
Reference-contexts: They also support calls to obtain and release locks on data. The Camelot library supports transactions on top of the Mach operating system <ref> [18] </ref>. Camelot provides routines to support basic transaction functionality as well as supporting distributed programming using remote procedure calls. Camelot also supports nested transactions. Avalon provides linguistic support for programming with Camelot.
Reference: [19] <author> Jacques Ferber and Jean-Pierre Briot. </author> <booktitle> Design of a Concurrent Language for Distributed Artificial Intelligence. In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <volume> volume 2, </volume> <pages> pages 755-762. </pages> <institution> Institute for New Generation Computer Technology, </institution> <year> 1988. </year>
Reference-contexts: A reflective implementation of object migration is reported in [65]. Reflection has been used in the Muse Operating System [67] for dynamically modifying system behavior. Reflective frameworks for the Actor languages MERING IV and Rosette have been proposed in <ref> [19] </ref> and [60], respectively. In MERING IV, programs may access meta-instances to modify an object or meta-classes to change a class definition.
Reference: [20] <author> Daniel P. Friedman, Mitchell Wand, and Christopher T. Haynes. </author> <title> Essentials of Programming Languages. </title> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: The recursion operator rec computes the least fixed point of a value, thereby enabling recursion in our language <ref> [39, 20] </ref>. Intuitively, rec repeatedly re-applies a function to itself.
Reference: [21] <author> S. Frtlund. </author> <title> Inheritance of Synchronization Constraints in Concurrent Object-Oriented Programming Languages. </title> <booktitle> In Proceedings of ECOOP 1992. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1992. </year> <note> LNCS 615. </note>
Reference-contexts: The platform supports C++ calls for both send and new. Using Broadway, developers of distributed programs may use a well known language | C++ | to develop distributed programs. Besides the basic primitives presented above, Broadway supports exception handling [4] and synchronization constraints <ref> [21] </ref>. Synchronization constraints provide local control over when messages may be processed. Individual methods may be disabled or enabled based on the state of the actor to ensure state consistency. <p> The keyword event denotes methods which may be invoked by application components in the system. Since role events and methods are invoked asynchronously, it is useful to provide state-based constraints on their invocation. The constrain keyword denotes a synchronization constraint <ref> [21] </ref> for a role. <p> Basic actor functionality is augmented with support for migration, exception handling [4], and synchronization constraints <ref> [21] </ref>. These additional features greatly simplify the development of distributed programs. The platform currently runs on Ultrix for DEC MIPS workstations, on Solaris for SUN Sparcstations, and IRIX 5 for SGI workstations. Broadway supports basic actor functionality using a multi-threaded scheduler, distributed name service, and platform independent communication service.
Reference: [22] <author> Svend Frtlund. </author> <title> Coordinating Distributed Objects: An Actor-Based Approach to Synchronization. </title> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: The concepts developed in this thesis may serve as a model for separating arbitrary design concerns in a distributed environment. Further examples of this approach include object placement and load-balancing [48], multi-object synchronization constraints <ref> [22] </ref>, program visualization [7], or real-time constraints [53, 44]. All of these approaches provide meta-level access to traditionally system-level aspects of actor behavior to avoid complication of application code to support these concepts.
Reference: [23] <author> W. Wayt Gibbs. </author> <title> Software's Chronic Crisis. </title> <journal> Scientific American, </journal> <volume> 271(3) </volume> <pages> 86-95, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Applications are shielded from changing requirements in interaction semantics as governed by hardware, availability, performance, etc. Such changes in requirements have been acknowledged as a leading cause of cost and time overruns as well as project failure in distributed system development <ref> [23] </ref>. The concepts developed in this thesis may serve as a model for separating arbitrary design concerns in a distributed environment. Further examples of this approach include object placement and load-balancing [48], multi-object synchronization constraints [22], program visualization [7], or real-time constraints [53, 44].
Reference: [24] <author> James Gosling and Henry McGilton. </author> <title> The Java Language Environment: A White Paper. </title> <type> Technical report, </type> <institution> Sun Microsystems Comptuer Company, </institution> <year> 1995. </year>
Reference-contexts: In particular, Actors may be used to express popular environments such as CORBA [45] or Java <ref> [24] </ref>. A uniform model is of particular importance when designing a mechanism for protocol/application interaction. A general model of distributed computation facilitates the isolation of factors affecting inter-component interactions. Actors are an abstract representation for distributed system in terms of concurrent object-based programming.
Reference: [25] <author> Graham Hamilton, Michael L. Powell, and James G. Mitchell. Subcontract: </author> <title> A Flexible Base for Distributed Programming. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, volume 17(5) of Operating Systems Review, </booktitle> <pages> pages 69-79. </pages> <booktitle> ACM Special Interest Group on Operating Systems, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: Because different protocols are generally required for very specific subsets of the objects in a system, such flexibility is required for implementing protocols. Furthermore, existing system support for customization often requires additional knowledge of the system's operation on the part of the programmer. For example, sub-contracts <ref> [25] </ref> may be used in the Spring operating system to allow customization of communication, but sub-contracts must explicitly interact with Interface Definition Language (IDL) stubs. IDL allows interfaces to be specified independent of the implementation language. IDL definitions are converted into implementation language stubs by a stub generator.
Reference: [26] <author> Matthew Hennessy. </author> <title> The Semantics of Programming Languages: An Elementary Introduction using Structural Operational Semantics. </title> <publisher> John Wiley & Sons Ltd., </publisher> <address> Chichester, England, </address> <year> 1990. </year>
Reference-contexts: We describe the grammar for our language in terms of expressions (E ) and irreducible values (V) as shown in Figure 5.2.1. The syntax captures the standard features of lambda calculus <ref> [26] </ref>. An abstraction x:e has a variable (x), and a body (e). The abstraction may be applied to a value (v), e.g. (x:e)v where v is syntactically substituted for x in e. This process is known as fi-reduction.
Reference: [27] <author> Norman C. Hutchinson and Larry L. Peterson. </author> <title> The x-Kernel: An Architecture for Implementing Network Protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(1) </volume> <pages> 64-75, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: The Horus project which is based on the work in Isis, supports customization of protocols for each group [63, 62]. Protocol layers share a common API and may be stacked dynamically. This concept was originally developed in the x-Kernel which applied protocol stacks to general distributed protocols <ref> [27] </ref>. Protocol layers present a fairly extensive interface: Horus defines a fourteen point API for its layers. Furthermore, protocol stacks must be identical on both ends of a communication and are therefore not suitable for fine grain of customization.
Reference: [28] <author> Bill Janssen, Denis Severson, and Mike Spreitzer. </author> <note> ILU 1.8 Reference Manual. Xerox PARC, 1995. Available from http://www.parc.xerox.com. </note>
Reference-contexts: An operational semantics is developed for the resulting language that supports operational reasoning. In [64], the semantics is extended to support formal reasoning about meta-level systems. 2.3 Limitations of Current Technologies The need to simplify distributed application development has lead to distributed object environments such as ILU <ref> [28] </ref> and CORBA [45]. These systems realize the benefits of object-orientation in a distributed environment and may be modeled in terms of Actors. These benefits include the separation of a distributed server's interface from its implementation, inheritance and sub-typing, and a uniform RPC mechanism between objects.
Reference: [29] <author> L. V. Kale. </author> <title> The Chare Kernel Parallel Programming System. </title> <booktitle> In Proceedings of the 1990 International Conference on Parallel Processing, </booktitle> <address> pages II.17 II.25, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Furthermore, protocol stacks must be identical on both ends of a communication and are therefore not suitable for fine grain of customization. Another approach to building fault-tolerant distributed systems is to provide automatic check-pointing of distributed applications. A software recovery scheme for actor systems [50] in the Charm++ System <ref> [29, 30] </ref> exploits the semantics and fine-grain nature of actors to realize a efficient, fault-tolerant platform with low-latency recovery. This work simplifies programming distributed systems by providing an underlying software layer which automatically handles fault-tolerance without explicit programmer intervention.
Reference: [30] <author> L. V. Kale and S. Krishnan. Charm++: </author> <title> A Portable Concurrent Object-Oriented System Based on C++. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 91-108, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: Furthermore, protocol stacks must be identical on both ends of a communication and are therefore not suitable for fine grain of customization. Another approach to building fault-tolerant distributed systems is to provide automatic check-pointing of distributed applications. A software recovery scheme for actor systems [50] in the Charm++ System <ref> [29, 30] </ref> exploits the semantics and fine-grain nature of actors to realize a efficient, fault-tolerant platform with low-latency recovery. This work simplifies programming distributed systems by providing an underlying software layer which automatically handles fault-tolerance without explicit programmer intervention.
Reference: [31] <author> David Keppel. </author> <title> Tools and Techniques for Building Fast Portable Threads Packages. </title> <type> Technical Report UWCSE 93-05-06, </type> <institution> University of Washington, Department of Computer Science and Engineering, </institution> <year> 1993. </year>
Reference-contexts: The above transformation is easily achieved through use of a actor-language compiler. However, Broadway uses run-time technology to achieve the same result. Each RPC blocks the thread executing the current method. User threads have been implemented using the QuickThreads package <ref> [31] </ref>. A synchronization constraint disables processing any additional messages by the actor until a reply is received. Once a reply is received, the blocked thread is rescheduled to continue execution of the invoking method. In addition to run-time functionality, Broadway includes a library of system actors.
Reference: [32] <author> Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1991. </year>
Reference-contexts: One such example is the meta-object protocol 1 developed for CLOS, an object-oriented 1 The term meta-object protocol should not be confused with distributed protocols. Rather, the term meta-object protocol refers to their meta-level architecture. 46 extension to LISP <ref> [32] </ref>. Their architecture was developed to enable customization of CLOS to provide different interpretations of object-oriented features within the same language. The meta-level facilities available in CLOS are quite general and require reinterpretation of code, a feature available in CLOS systems. The CLOS approach also does not address concurrency.
Reference: [33] <author> W. Kim and G. Agha. </author> <title> Efficient Support of Location Transparency in Concurrent Object-Oriented Programming Languages. </title> <booktitle> In Supercomputing '95, </booktitle> <year> 1995. </year> <note> (to appear). </note>
Reference-contexts: Techniques have been proposed that use the results from type-inference [47] to replace local message sends with function calls. These techniques utilize type-inference to determine which methods to invoke and a locality check to ensure that the target of the message is local <ref> [33] </ref>. Unfortunately, none of these approaches have been designed to handle dynamic operations such as installation of a communicator. Such approaches derive and exploit type information during compilation whereas our approach requires run-time information.
Reference: [34] <author> Wooyoung Kim and Gul Agha. </author> <title> Compilation of a Highly Parallel Actor-Based Language. </title> <editor> In U. Banerjee, D. Gelernter, A. Nicolau, and D. Padua, editors, </editor> <booktitle> Proceedings of the 5th International Workshop on Languages and Compilers for Parallel Computing, volume 757 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-15. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year> <month> 64 </month>
Reference-contexts: With one notable exception | replies from RPC invocations | only one method may be active for a single actor: there is no internal concurrency. Although RPC communication is not developed in the basic Actor model, RPC is easily reconciled with actor semantics through a syntactic transformation <ref> [34] </ref>. Each RPC may converted into two asynchronous sends, an additional method serving as the continuation of the invoking method, and a synchronization constraint disabling all methods except the continuation method. The request for the RPC includes a method identifier which the reply method uses to invoke the continuation. <p> To eliminate this cost, we build on previous work aimed at optimizing concurrent object-oriented languages for parallel systems <ref> [34, 16, 51] </ref>. Specifically, we concentrate on converting communication between a meta-actor and its base-actor into a series of function calls. Techniques have been proposed that use the results from type-inference [47] to replace local message sends with function calls.
Reference: [35] <author> Leslie Lamport. </author> <title> Time, Clocks, and the Ordering of Events in a Distributed System. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: Multiple approaches to replication may be used as there are few restrictions on which processes may comprise a group. The communication primitives in Isis are based on the concept of virtual synchrony. Virtual synchrony provides message delivery and group membership modifications consistent with Lamport's concept of logical clocks <ref> [35] </ref>. The Horus project which is based on the work in Isis, supports customization of protocols for each group [63, 62]. Protocol layers share a common API and may be stacked dynamically. This concept was originally developed in the x-Kernel which applied protocol stacks to general distributed protocols [27].
Reference: [36] <author> C.E. Landwehr, B. Randell, and L. Simoncini, </author> <title> editors. A Linguistic Framework for the Dynamic Composition of Dependability Protocols, </title> <booktitle> volume VIII of Dependable Computing and Fault-Tolerant Systems. IFIP Transactions, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Furthermore, fault-tolerance is in an important concern in the development of most distributed systems. Thus, the study of fault-tolerant systems provided has led to multiple languages and systems simplifying the development of distributed programming including the initial work with our approach <ref> [36] </ref>. Much of the work in the development of fault-tolerant tools has been oriented towards the development of transaction systems. Transactions provide failure atomicity, permanence, and seri-alizability [42]. Furthermore, transactions may be nested to support parallelism [41].
Reference: [37] <author> Barbara Liskov. </author> <title> Distributed Programming in Argus. </title> <journal> Communications of the ACM, </journal> <volume> 31(3) </volume> <pages> 300-312, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Camelot also supports nested transactions. Avalon provides linguistic support for programming with Camelot. Avalon/C++ extends C++ to support stable objects which survive crashes, read and write locks on objects, and a transaction construct. Another transaction system is Argus <ref> [37] </ref>. Argus is language an object-based language similar to CLU. Rather than explicitly defining transactions, a programmer defines an encapsulated object known as a guardian. Methods in guardians, referred to as handlers, are invoked as sub-transactions.
Reference: [38] <author> P. Maes. </author> <title> Computational Reflection. </title> <type> Technical Report 87-2, </type> <institution> Artificial Intelligence Laboratory, Vrije University, </institution> <year> 1987. </year>
Reference-contexts: This approach, known as reflection, provides finer grain customization than micro-kernels or object-oriented operating systems. Reflection means that objects in a system can manipulate a causally connected description of their system-level behavior <ref> [56, 38] </ref>. These descriptions are themselves represented as objects. A change in these descriptions, or meta-objects, results in a change in how objects are implemented. The object for which a meta-object represents certain aspects of the implementation is called the base-object.
Reference: [39] <author> I. A. Mason and C. L. Talcott. </author> <title> Equivalence in Functional Languages with Effect. </title> <journal> Journal of Functional Programming, </journal> <volume> 1 </volume> <pages> 287-327, </pages> <year> 1991. </year>
Reference-contexts: The recursion operator rec computes the least fixed point of a value, thereby enabling recursion in our language <ref> [39, 20] </ref>. Intuitively, rec repeatedly re-applies a function to itself.
Reference: [40] <author> S. Mishra, L. L. Peterson, and R. D. Schlichting. </author> <title> Consul: A communication Substrate for Fault-Tolerant Distributed Programs. </title> <type> Technical Report TR91-32, </type> <institution> University of Arizona, Tucson, </institution> <year> 1991. </year>
Reference-contexts: Thus, inheritance may be used to customize how this functionality is supported for a particular component. In addition to transaction systems, another area which has been targeted by systems to simplify distributed programming has been in group or replica management. The focus in in Consul <ref> [40] </ref>, by Cooper [17], and in Isis [12, 9, 11] is to provide a set of protocols that represent common communication patterns found in fault-tolerant systems. The Isis system provides support for communication between groups of distributed processes.
Reference: [41] <author> J.E. B. Moss. </author> <title> Nested Transactions: An Approach to Reliable Distributed Computing. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <address> Cambridge, Mass., </address> <year> 1981. </year>
Reference-contexts: Much of the work in the development of fault-tolerant tools has been oriented towards the development of transaction systems. Transactions provide failure atomicity, permanence, and seri-alizability [42]. Furthermore, transactions may be nested to support parallelism <ref> [41] </ref>.
Reference: [42] <editor> Sape Mullender, editor. </editor> <booktitle> Distributed Systems, chapter 10, </booktitle> <pages> pages 191-214. </pages> <publisher> ACM Press, </publisher> <address> 1 edition, </address> <year> 1989. </year>
Reference-contexts: Much of the work in the development of fault-tolerant tools has been oriented towards the development of transaction systems. Transactions provide failure atomicity, permanence, and seri-alizability <ref> [42] </ref>. Furthermore, transactions may be nested to support parallelism [41].
Reference: [43] <author> Tony P. Ng. </author> <title> Probabilistic Failure Detection Using Watchdog Timers. </title> <type> Technical Report UIUCDCS-R-90-1521, </type> <institution> University of Illinois, Department of Computer Science, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: In addition to run-time functionality, Broadway includes a library of system actors. These actors include an i/o and file system interface, a failure detector, and a migration controller. The failure detector uses a watch-dog timer approach <ref> [43] </ref> to detect crash failures in remote workstations. Application actors interact with the system actors using standard asynchronous message passing. Of particular interest is the migration controller. Broadway uses this actor to support both off-node creation of actors as well as actor migration.
Reference: [44] <author> Brian Nielsen and Gul Agha. </author> <title> Semantics for an Actor-Based Real-Time Language. </title> <booktitle> In Fourth International Workshop on Parallel and Distributed Real-Time Systems, </booktitle> <address> Honolulu, </address> <month> April </month> <year> 1996. </year> <note> (to appear). </note>
Reference-contexts: The concepts developed in this thesis may serve as a model for separating arbitrary design concerns in a distributed environment. Further examples of this approach include object placement and load-balancing [48], multi-object synchronization constraints [22], program visualization [7], or real-time constraints <ref> [53, 44] </ref>. All of these approaches provide meta-level access to traditionally system-level aspects of actor behavior to avoid complication of application code to support these concepts. Another application of these techniques is solving some of the complex problems posed by the global computing environment.
Reference: [45] <author> Object Management Group. </author> <title> Common Object Request Broker: Architecture and Specification, 1991. OMG Document Number 91.12.1. </title>
Reference-contexts: In particular, Actors may be used to express popular environments such as CORBA <ref> [45] </ref> or Java [24]. A uniform model is of particular importance when designing a mechanism for protocol/application interaction. A general model of distributed computation facilitates the isolation of factors affecting inter-component interactions. Actors are an abstract representation for distributed system in terms of concurrent object-based programming. <p> In [64], the semantics is extended to support formal reasoning about meta-level systems. 2.3 Limitations of Current Technologies The need to simplify distributed application development has lead to distributed object environments such as ILU [28] and CORBA <ref> [45] </ref>. These systems realize the benefits of object-orientation in a distributed environment and may be modeled in terms of Actors. These benefits include the separation of a distributed server's interface from its implementation, inheritance and sub-typing, and a uniform RPC mechanism between objects.
Reference: [46] <author> M. H. Olsen, E. Oskiewicz, and J. P. Warne. </author> <title> A Model for Interface Groups. </title> <booktitle> In Tenth Symposium on Reliable Distributed Systems, </booktitle> <address> Pisa, Italy, </address> <year> 1991. </year>
Reference-contexts: Availability specifications allow the programmer to create resilient objects with a custom policy controlling number of replicas and the synchronization control to be used between these replicas. The ESPRIT/ISA project supports interface groups that allow replication policies to be customized <ref> [46, 6] </ref> by allowing the programmer to specify the interface to a group of concurrent objects. Thus a programmer may choose between active versus passive replication as well as specifying the number of replicas or a custom control policy for the replicas.
Reference: [47] <author> J. Palsberg and M. I. Schwartzbach. </author> <title> Object-Oriented Type Inference. </title> <booktitle> In Proceedings OOPSLA '91, ACM SIGPLAN Sixth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 146-161. </pages> <publisher> ACM Press, </publisher> <month> October </month> <year> 1991. </year>
Reference-contexts: To eliminate this cost, we build on previous work aimed at optimizing concurrent object-oriented languages for parallel systems [34, 16, 51]. Specifically, we concentrate on converting communication between a meta-actor and its base-actor into a series of function calls. Techniques have been proposed that use the results from type-inference <ref> [47] </ref> to replace local message sends with function calls. These techniques utilize type-inference to determine which methods to invoke and a locality check to ensure that the target of the message is local [33].
Reference: [48] <author> Rajendra Panwar. </author> <title> Specification of Resource Management Strategies for Concurrent Objects. </title> <type> PhD thesis, </type> <institution> University of Illinois, Urbana-Champaign, </institution> <year> 1996. </year>
Reference-contexts: The concepts developed in this thesis may serve as a model for separating arbitrary design concerns in a distributed environment. Further examples of this approach include object placement and load-balancing <ref> [48] </ref>, multi-object synchronization constraints [22], program visualization [7], or real-time constraints [53, 44]. All of these approaches provide meta-level access to traditionally system-level aspects of actor behavior to avoid complication of application code to support these concepts.
Reference: [49] <author> G. D. Parrington and S. K. Shrivastava. </author> <title> Implementing Concurrency Control in Reliable Distributed Object-Oriented Systems. </title> <booktitle> In Proceedings of the Second European Conference on Object-Oriented Programming, </booktitle> <address> ECOOP88. </address> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: Guardians allow much of the explicit control of transactions, such as obtaining locks, to be hidden from the programmer though explicit support for these functions is provided to allow optimization by the programmer. As with Avalon/C++ objects, guardians may consist of both stable and volatile data. Arjuna <ref> [49, 55] </ref> is a library of C++ classes which support transaction processing. The library provides classes for atomic actions, stable state, and locks that, through inheritance, are used to build a system. Subclasses exist which support various implementations of error recovery mechanisms, locks, and stable storage.
Reference: [50] <author> Michael Peercy and Prithviraj Banerjee. </author> <title> Software Schemes of Reconfiguration and Recovery in Distributed Memory Multicomputers Using the Actor Model. </title> <booktitle> In Proceedings of the Twenty-Fifth Fault-Tolerant Computing Symposium (FTCS-25), </booktitle> <address> Pasadena, CA, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: Furthermore, protocol stacks must be identical on both ends of a communication and are therefore not suitable for fine grain of customization. Another approach to building fault-tolerant distributed systems is to provide automatic check-pointing of distributed applications. A software recovery scheme for actor systems <ref> [50] </ref> in the Charm++ System [29, 30] exploits the semantics and fine-grain nature of actors to realize a efficient, fault-tolerant platform with low-latency recovery. This work simplifies programming distributed systems by providing an underlying software layer which automatically handles fault-tolerance without explicit programmer intervention.
Reference: [51] <author> John Plevyak, Xingbin Zhang, and Andrew A. Chien. </author> <title> Obtaining Sequential Efficiency in Concurrent Object-Oriented Programs. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Programming Languages, </booktitle> <month> January </month> <year> 1995. </year>
Reference-contexts: To eliminate this cost, we build on previous work aimed at optimizing concurrent object-oriented languages for parallel systems <ref> [34, 16, 51] </ref>. Specifically, we concentrate on converting communication between a meta-actor and its base-actor into a series of function calls. Techniques have been proposed that use the results from type-inference [47] to replace local message sends with function calls.
Reference: [52] <author> Brian Randell and Jie Xu. </author> <title> The Evolution of the Recovery Block Concept. </title> <editor> In Michael R. Lyu, editor, </editor> <title> Software Fault Tolerance, </title> <booktitle> number 3 in Trends in Software, chapter 1, </booktitle> <pages> pages 1-21. </pages> <publisher> John Wiley & Sons, Inc., </publisher> <year> 1995. </year>
Reference-contexts: At the same time, a static interface enables reuse of protocols with other applications and the construction of protocol libraries. Protocols from the libraries may be replaced with customized application-specific protocols if necessary and if engineering resources are available. Recovery blocks and conversations <ref> [52] </ref> support components with more general failure semantics. A recovery block is a series of atomic actions, each of which has an associated acceptance test. Failure of the primary action's test results in the roll-back of state and invocation of the second action.
Reference: [53] <author> S. Ren, G. Agha, and M. Saito. </author> <title> A Modular Approach for Programming Distributed Real-Time Systems. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <note> 1996. (to appear). </note>
Reference-contexts: The concepts developed in this thesis may serve as a model for separating arbitrary design concerns in a distributed environment. Further examples of this approach include object placement and load-balancing [48], multi-object synchronization constraints [22], program visualization [7], or real-time constraints <ref> [53, 44] </ref>. All of these approaches provide meta-level access to traditionally system-level aspects of actor behavior to avoid complication of application code to support these concepts. Another application of these techniques is solving some of the complex problems posed by the global computing environment.
Reference: [54] <author> J. H. Saltzer, D. P. Reed, and D. D. Clark. </author> <title> End-To-End Arguments in System Design. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(4) </volume> <pages> 277-288, </pages> <month> November </month> <year> 1985. </year> <month> 65 </month>
Reference-contexts: The approach also illustrates the effectiveness of a universal computation model in developing utilities for distributed software engineering. A criticism of these "tool-kit" based approaches is that the "tools" do not address end-to-end arguments <ref> [54] </ref>. The end-to-end argument raises the issue of optimal design based on considering communication (or other specifics) from application to application based on application-level knowledge. Only in this manner, the argument states, can optimal performance and correctness be achieved.
Reference: [55] <author> Santosh Shrivastava, Graeme Dixon, and Graham Parrington. </author> <title> An Overview of the Arjuna Distributed Programming System. </title> <journal> IEEE Software, </journal> <pages> pages 66-73, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Guardians allow much of the explicit control of transactions, such as obtaining locks, to be hidden from the programmer though explicit support for these functions is provided to allow optimization by the programmer. As with Avalon/C++ objects, guardians may consist of both stable and volatile data. Arjuna <ref> [49, 55] </ref> is a library of C++ classes which support transaction processing. The library provides classes for atomic actions, stable state, and locks that, through inheritance, are used to build a system. Subclasses exist which support various implementations of error recovery mechanisms, locks, and stable storage.
Reference: [56] <author> B. C. Smith. </author> <title> Reflection and Semantics in a Procedural Language. </title> <type> Technical Report 272, </type> <institution> Massachusetts Institute of Technology. Laboratory for Computer Science, </institution> <year> 1982. </year>
Reference-contexts: This approach, known as reflection, provides finer grain customization than micro-kernels or object-oriented operating systems. Reflection means that objects in a system can manipulate a causally connected description of their system-level behavior <ref> [56, 38] </ref>. These descriptions are themselves represented as objects. A change in these descriptions, or meta-objects, results in a change in how objects are implemented. The object for which a meta-object represents certain aspects of the implementation is called the base-object.
Reference: [57] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> second edition, </address> <year> 1991. </year>
Reference-contexts: Otherwise Dil uses C++ primitive types and classes. The syntax for C++ types may be found in <ref> [57] </ref>. The body of the protocol is defined in terms of role definitions. A role is defined by a name, a state definition, and a set of methods and events.
Reference: [58] <author> Daniel C. Sturman. </author> <title> Fault-Adaptation for Systems in Unpredictable Environments. </title> <type> Master's thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: Most importantly, the language must support facilities supporting dynamic creation of software components and dynamic reconfiguration of the communication topology. Broadway is a run-time platform that allows actors to be implemented in C++ <ref> [58] </ref>. We use Broadway to implement the ideas described in this thesis. The platform supports C++ calls for both send and new. Using Broadway, developers of distributed programs may use a well known language | C++ | to develop distributed programs.
Reference: [59] <author> Daniel C. Sturman. </author> <title> The Broadway User's Manual: Broadway v. 3.0. </title> <type> Technical report, </type> <institution> Open Systems Laboratory, Department of Computer Science, University of Illionis at Urbana-Champaign, </institution> <year> 1996. </year> <note> (Available from ftp://www-osl.cs.uiuc.edu.). </note>
Reference-contexts: The results in the following section therefore demonstrate that Dil protocols may be implemented efficiently within the framework of existing distributed object technology and standards. 4.4.1 Run-time Environment Broadway <ref> [59] </ref> provides C++ support for distributed actor programs including asynchronous communication, dynamic actor creation, and scheduling of actors. Basic actor functionality is augmented with support for migration, exception handling [4], and synchronization constraints [21]. These additional features greatly simplify the development of distributed programs.
Reference: [60] <author> C. Tomlinson and V. Singh. </author> <title> Inheritance and Synchronization with Enabled-Sets. </title> <booktitle> In OOPSLA Proceedings, </booktitle> <year> 1989. </year>
Reference-contexts: A reflective implementation of object migration is reported in [65]. Reflection has been used in the Muse Operating System [67] for dynamically modifying system behavior. Reflective frameworks for the Actor languages MERING IV and Rosette have been proposed in [19] and <ref> [60] </ref>, respectively. In MERING IV, programs may access meta-instances to modify an object or meta-classes to change a class definition.
Reference: [61] <author> Christine Tomlinson, Phil Cannata, Greg Meredith, and Darrell Woelk. </author> <title> The Extensible Services Switch in Carnot. </title> <journal> IEEE Parallel & Distributed Technology: Systems & Applications, </journal> <volume> 1(2) </volume> <pages> 16-20, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Each method in an actor class invokes a subroutine, or set of routines, written in a sequential language and dispatches messages based on the values returned. Such an approach was taken by the Carnot project at MCC <ref> [61] </ref>. In Carnot, the actor language Rosette "glues" sequential components together to facilitate heterogeneous distributed computing for enterprise integration. Actor operators have also been combined with functional languages. Specifically, actor operators have been added to the call-by-value -calculus [2]. In this case, local computation is modeled as sequential functional computation.
Reference: [62] <author> Robbert van Renesse, Kenneth P. Birman, Roy Friedman, Mark Hayden, and David A. Karr. </author> <title> A Framework for Protocol Composition in Horus. </title> <booktitle> In Proceedings of the Fourteenth Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1995. </year>
Reference-contexts: The communication primitives in Isis are based on the concept of virtual synchrony. Virtual synchrony provides message delivery and group membership modifications consistent with Lamport's concept of logical clocks [35]. The Horus project which is based on the work in Isis, supports customization of protocols for each group <ref> [63, 62] </ref>. Protocol layers share a common API and may be stacked dynamically. This concept was originally developed in the x-Kernel which applied protocol stacks to general distributed protocols [27]. Protocol layers present a fairly extensive interface: Horus defines a fourteen point API for its layers.
Reference: [63] <author> Robbert van Renesse, Takako M. Hickey, and Kenneth P. Birman. </author> <title> Design and Performance of Horus: A Lightweight Group Communications System. </title> <type> Technical Report TR94-1442, </type> <institution> Department of Computer Science, </institution> <month> August </month> <year> 1994. </year>
Reference-contexts: The communication primitives in Isis are based on the concept of virtual synchrony. Virtual synchrony provides message delivery and group membership modifications consistent with Lamport's concept of logical clocks [35]. The Horus project which is based on the work in Isis, supports customization of protocols for each group <ref> [63, 62] </ref>. Protocol layers share a common API and may be stacked dynamically. This concept was originally developed in the x-Kernel which applied protocol stacks to general distributed protocols [27]. Protocol layers present a fairly extensive interface: Horus defines a fourteen point API for its layers.
Reference: [64] <author> Nalini Venkatasubramanian and Caroyln Talcott. </author> <title> Reasoning About Meta-Level Activities in Open Distributed Systems. </title> <booktitle> In Proceedings of ACM Principles of Distributed Computing, </booktitle> <address> Ottawa, Canada, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: Actor operators have also been combined with functional languages. Specifically, actor operators have been added to the call-by-value -calculus [2]. In this case, local computation is modeled as sequential functional computation. An operational semantics is developed for the resulting language that supports operational reasoning. In <ref> [64] </ref>, the semantics is extended to support formal reasoning about meta-level systems. 2.3 Limitations of Current Technologies The need to simplify distributed application development has lead to distributed object environments such as ILU [28] and CORBA [45].
Reference: [65] <author> T. Watanabe and A. Yonezawa. </author> <title> An Actor-Based Meta-level Architecture for Group-Wide Reflection. </title> <editor> In J. W. deBakker, W. P. deRoever, and G. Rozenberg, editors, </editor> <booktitle> Foundations of Object-Oriented Languages, </booktitle> <pages> pages 405-425. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year> <note> LNCS 489. </note>
Reference-contexts: Reflection has been used to address a number of issues in concurrent systems. For example, the scheduling problem of the Time Warp algorithm for parallel discrete event simulation is modeled by means of reflection in [68]. A reflective implementation of object migration is reported in <ref> [65] </ref>. Reflection has been used in the Muse Operating System [67] for dynamically modifying system behavior. Reflective frameworks for the Actor languages MERING IV and Rosette have been proposed in [19] and [60], respectively.
Reference: [66] <author> C. T. Wilkes and R. J. LeBlanc. </author> <title> Distributed Locking: A Mechanism for Constructing Highly Available Objects. </title> <booktitle> In Proceedings of the Seventh Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 194-203, </pages> <year> 1988. </year>
Reference-contexts: In particular, we examine their 45 suitability to separating design concerns and supporting flexibility in customization for distributed protocols. Due their utility, several systems provide support for replication protocols. The distributed locking methodology of the Aeolus, a distributed language for the Clouds operating system, supports customized availability specifications <ref> [66] </ref>. Availability specifications allow the programmer to create resilient objects with a custom policy controlling number of replicas and the synchronization control to be used between these replicas.
Reference: [67] <author> Y. Yokote, A. Mitsuzawa, N. Fujinami, and M. Tokoro. </author> <title> The Muse Object Architecture: A New Operating System Structuring Concept. </title> <type> Technical Report SCSL-TR-91-002, </type> <institution> Sony Computer Science Laboratory Inc., </institution> <month> February </month> <year> 1991. </year>
Reference-contexts: For example, the scheduling problem of the Time Warp algorithm for parallel discrete event simulation is modeled by means of reflection in [68]. A reflective implementation of object migration is reported in [65]. Reflection has been used in the Muse Operating System <ref> [67] </ref> for dynamically modifying system behavior. Reflective frameworks for the Actor languages MERING IV and Rosette have been proposed in [19] and [60], respectively. In MERING IV, programs may access meta-instances to modify an object or meta-classes to change a class definition.
Reference: [68] <author> A. Yonezawa, </author> <title> editor. ABCL An Object-Oriented Concurrent System, </title> <booktitle> chapter Reflection in an Object-Oriented Concurrent Language, </booktitle> <pages> pages 45-70. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year> <month> 66 </month>
Reference-contexts: Reflection has been used to address a number of issues in concurrent systems. For example, the scheduling problem of the Time Warp algorithm for parallel discrete event simulation is modeled by means of reflection in <ref> [68] </ref>. A reflective implementation of object migration is reported in [65]. Reflection has been used in the Muse Operating System [67] for dynamically modifying system behavior. Reflective frameworks for the Actor languages MERING IV and Rosette have been proposed in [19] and [60], respectively.
References-found: 68

