URL: http://larch-www.lcs.mit.edu:8001/~mtv/fse94.ps
Refering-URL: http://larch-www.lcs.mit.edu:8001/~mtv/
Root-URL: 
Title: Using Specialized Procedures and Specification-Based Analysis to Reduce the Runtime Costs of Modularity  
Author: Mark T. Vandevoorde and John V. Guttag 
Keyword: Program Modularity, Software Interfaces, Formal Specifications, Compilers, Program Optimization.  
Address: Cambridge, MA  
Affiliation: Laboratory for Computer Science Massachusetts Institute of Technology  
Abstract: Managing tradeoffs between program structure and program efficiency is one of the most difficult problems facing software engineers. Decomposing programs into abstractions simplifies the construction and maintenance of software and results in fewer errors. However, the introduction of these abstractions often introduces significant inefficiencies. This paper describes a strategy for eliminating many of these inefficiencies. It is based upon providing alternative implementations of the same abstraction, and using information contained in formal specifications to allow a compiler to choose the appropriate one. The strategy has been implemented in a prototype compiler that incorporates theorem proving technology. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aho, R. Sethi, and J. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: PSC identifies sound optimizations, but does not apply them. In addition to performing optimizations based on specialized procedures, PSC takes advantage of the information provided in specifications to perform enhanced global common subexpression elimination, code motion out of loops, and dead code elimination <ref> [1] </ref>. Those aspects of our work are reported in [19, 20]. When PSC was used on the AC-unify program in the way described in Section 2, it was able to optimize all of the nine possible calls. This resulted in a performance improvement of 14%.
Reference: [2] <author> W. W. Bledsoe and M. Tyson. </author> <title> The UT Interactive Prover. </title> <type> ATP 17, </type> <institution> University of Texas Mathematics Dept., </institution> <month> May </month> <year> 1975. </year>
Reference-contexts: In [16], McHugh examines all of the static checks of Gypsy, a derivative of Pascal. Gypsy is a programming environment for verified software, so programs typically contain entry, exit, and other assertions. McHugh's compiler generated optimization conjectures that, when discharged by the UT Interactive Prover <ref> [2] </ref>, resulted in the elimination of code supporting exceptions|i.e., a broad category of runtime checks. McHugh does not describe strategies used to prove the conjectures.
Reference: [3] <author> D. Evans, J. Guttag, J. Horning, and Y. M. Tan. LCLint: </author> <title> A tool for using specifications to check code. </title> <booktitle> In Proceedings of the ACM SIGSOFT Symposium on the Foundations of Software Engineering. ACM, </booktitle> <month> December </month> <year> 1994. </year>
Reference-contexts: One way to avoid such problems is to detect at compile time places where the code and the specifications may be inconsistent with each other. While this is an undecidable problem, there are many occasions where such inconsistencies can be found relatively easily <ref> [3] </ref>. It is relatively easy, for example, to flag places where a formal parameter that should not be modified is mutated.
Reference: [4] <author> R. W. Floyd. </author> <title> Assigning meanings to programs. </title> <booktitle> In Proceedings of Symposia in Applied Mathematics, </booktitle> <volume> volume 19, </volume> <pages> pages 19-31. </pages> <publisher> American Mathematical Society, </publisher> <year> 1967. </year>
Reference-contexts: To reason about the values of program states at edges in a CFG, we use a small set of proof rules (one for each the six kinds of nodes) similar to Hoare and Floyd rules <ref> [4, 12] </ref>. This is where procedure specifications come into play. The proof rule for a procedure call node uses the specification of the called procedure to define the program state after the call in terms of the program state before the call.
Reference: [5] <author> S. Garland and J. Guttag. </author> <title> A guide to LP, The Larch Prover. </title> <type> TR 82, </type> <institution> DEC Systems Research Center, </institution> <address> Palo Alto, CA, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: Finally, PSC chooses the implementation associated with the first guard it is able to discharge. If no guard can be discharged, it chooses the general implementation. Reasoning about the guards is done using equational conditional term rewriting. Early versions of PSC did this by invoking the LP <ref> [5] </ref> theorem proving system. This proved unsatisfactory. The current version of PSC internalizes the theorem proving technology.
Reference: [6] <author> S. M. </author> <title> German. Verifying the absence of common runtime errors in computer programs. </title> <type> Technical Report CS-81-866, </type> <institution> Stanford, </institution> <month> June </month> <year> 1981. </year>
Reference-contexts: This requires proving properties sufficient to eliminate runtime checks in array references, numeric operations, assignments from supertypes to subtypes, etc. The language does not have pointers, so the problem of aliasing is simpler than in Speckle. Sites simulates his technique manually on several examples. In <ref> [6] </ref>, German develops a tool for verifying the absence of runtime errors, such as arithmetic overflow and invalid array indices.
Reference: [7] <author> S. Ghemawat. </author> <title> Disk management for object-oriented databases. </title> <booktitle> In Third International Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 222-225. </pages> <publisher> IEEE Computer Society, </publisher> <month> December </month> <year> 1993. </year>
Reference: [8] <editor> D. Gries, editor. </editor> <title> Programming Methodology: A Collection of Articles by Members of IFIP WG2.3. </title> <address> Springer-Verlang, </address> <year> 1978. </year>
Reference-contexts: Moreover, as discussed below, the amount of specification required to use SPIs is less than that suggested by good software engineering practice. In contrast, while many have suggested that supplying abstraction functions and invariants is useful <ref> [8] </ref>, such information is, in practice, not usually provided. 4 Because SPI compilers rely on specifications, bugs in specifications can lead to optimizations that change the behavior of code. When such a program is run, it may exhibit behavior that cannot be explained merely by examining the code.
Reference: [9] <author> R. Gupta. </author> <title> A fresh look at optimizing array bound checking. </title> <booktitle> In Proceedings of the 1990 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 272-282. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: In general, a third SPI that eliminates just the high bound check would be useful, but this SPI was unnecessary for the hot spots in SIM. These optimizations illustrate one common use of SPIs|removing unnecessary error checks. Such uses of SPIs are closely related to work done by <ref> [9] </ref> and [17] on eliminating checks mandated by the source language. The key difference is that SPIs allow the compiler to remove checks that are particular to programmer-supplied abstractions. The hot spots of SIM invoke the operator [] from 12 call sites. <p> McHugh's compiler generated optimization conjectures that, when discharged by the UT Interactive Prover [2], resulted in the elimination of code supporting exceptions|i.e., a broad category of runtime checks. McHugh does not describe strategies used to prove the conjectures. In <ref> [9] </ref>, Gupta reduces the overhead of array bounds checks by eliminating redundant checks that occur in code fragments such as "a [i] := a [i]+1" and by moving checks out of loops. The strategy used relies on the programming language semantics of arrays and does not extend to user-defined types.
Reference: [10] <author> J. V. Guttag, J. J. Horning, with S. J. Garland, K. D. Jones, A. Modet, and J. M. Wing. </author> <title> Larch: Languages and Tools for Formal Specification. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The combination of side effects and pointers to heap-allocated data structures requires PSC to handle aliasing, the most challenging problem for optimizing compilers. The specification language portion of Speckle builds on the Larch family of specification languages <ref> [10] </ref> and borrows heavily from the Larch/CLU language [21]. Procedure specifications consist of pre- and postconditions written in a stylized fashion. into an intset. Here, the empty requires clause indicates that the precondition is vacuous (true).
Reference: [11] <author> A. Hisgen. </author> <title> Optimization of User-Defined Abstract Data Types: A Program Transformation Approach. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <year> 1985. </year>
Reference-contexts: SPIs, on the other hand, are good for higher-level optimizations, such as not checking whether a newly allocated element object is a member of a previously existing set object. Speckle is not the first language that allows users to define optimizations. In <ref> [11] </ref>, Hisgen presents an unimple-mented design of a strategy based on transformation rules rather than specifications. To define an optimization, an implementor describes transformations to be performed by the compiler.
Reference: [12] <author> C. A. R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-583, </pages> <month> October </month> <year> 1969. </year>
Reference-contexts: To reason about the values of program states at edges in a CFG, we use a small set of proof rules (one for each the six kinds of nodes) similar to Hoare and Floyd rules <ref> [4, 12] </ref>. This is where procedure specifications come into play. The proof rule for a procedure call node uses the specification of the called procedure to define the program state after the call in terms of the program state before the call.
Reference: [13] <author> C. A. R. Hoare. </author> <title> Proofs of correctness of data representations. </title> <journal> Acta Informatica, </journal> <volume> 1(1) </volume> <pages> 271-281, </pages> <year> 1972. </year>
Reference-contexts: PSC, which performs no inter-procedural analysis, may need such invariants to discharge the guards of SPIs. 1 For the purpose of detecting SPIs, the distinction between partial and intended specifications is unnecessary. However, for other optimizations performed by PSC, the distinction is necessary for soundness. Abstraction functions 2 <ref> [13] </ref> map values used to represent an abstract type into values of the abstract type. Suppose that P is a procedure in the interface of data type T. PSC uses the abstraction function of T in two ways.
Reference: [14] <author> B. Liskov, R. Atkinson, T. Bloom, E. Moss, J. C. Schaffert, R. Scheifler, and A. Snyder. </author> <title> CLU Reference Manual. </title> <booktitle> Lecture Notes in Computer Science No. </booktitle> <volume> 114. </volume> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: A subsidiary problem is designing a programming language that incorporates formal specifications and SPIs and related annotations. To come to grips with these problems, we built a prototype compiler for a dialect of CLU <ref> [14] </ref> that we call Speckle. The Prototype Speckle Compiler, PSC, incorporates primitive, automated theorem proving technology to identify opportunities to use SPIs. It does not generate code. Speckle retains most of CLU's features, including static typing, side effects, data abstraction, a garbage-collected heap, iterators, and exceptions. <p> Currently, Greg Nelson and David Detlefs are studying ways of eliminating array bounds checking, nil checks, and other runtime checks in Modula-3 [17]. 6 STATUS AND CONCLUSIONS We have extended the programming language CLU <ref> [14] </ref> to include SPIs and, using the framework outlined in Section 3, built a prototype compiler for that language. PSC identifies sound optimizations, but does not apply them.
Reference: [15] <author> D. C. Luckham, F. W. von Henke, B. Krieg-Bruckner, and O. Owe. </author> <title> ANNA Reference Manual, </title> <booktitle> volume 260 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Another possibility is to have the compiler generate, or the programmer supply, code to check the guards of specialized implementations. In debugging mode, this code can be executed to detect places where an inappropriate SPI has been chosen. This is similar to the assertion checking supplied by ANNA <ref> [15] </ref>. Finally, the compiler could be directed to selectively turn off optimizations. This can be used to pinpoint which optimizations triggered the changed behavior. When tuning performance, we first use conventional techniques, e.g., profiling, to localize the problem.
Reference: [16] <author> J. McHugh. </author> <title> Towards the generation of efficient code from verified programs. </title> <type> Technical Report 40, </type> <institution> University of Texas at Austin, </institution> <month> March </month> <year> 1984. </year>
Reference-contexts: German's work focuses on defining Pascal formally and expressing assertions sufficient to preclude a runtime error. He does not describe the strategies used to discharge assertions. In <ref> [16] </ref>, McHugh examines all of the static checks of Gypsy, a derivative of Pascal. Gypsy is a programming environment for verified software, so programs typically contain entry, exit, and other assertions.
Reference: [17] <author> G. Nelson and D. Detlefs. </author> <title> Extended static checking. Private communication on work in progress at DEC Systems Research Center, </title> <year> 1994. </year>
Reference-contexts: These optimizations illustrate one common use of SPIs|removing unnecessary error checks. Such uses of SPIs are closely related to work done by [9] and <ref> [17] </ref> on eliminating checks mandated by the source language. The key difference is that SPIs allow the compiler to remove checks that are particular to programmer-supplied abstractions. The hot spots of SIM invoke the operator [] from 12 call sites. <p> The strategy used relies on the programming language semantics of arrays and does not extend to user-defined types. Currently, Greg Nelson and David Detlefs are studying ways of eliminating array bounds checking, nil checks, and other runtime checks in Modula-3 <ref> [17] </ref>. 6 STATUS AND CONCLUSIONS We have extended the programming language CLU [14] to include SPIs and, using the framework outlined in Section 3, built a prototype compiler for that language. PSC identifies sound optimizations, but does not apply them.
Reference: [18] <author> R. </author> <title> Sites. Proving that computer programs terminate cleanly. </title> <type> Technical Report CS-74-418, </type> <institution> Stanford, </institution> <year> 1974. </year>
Reference-contexts: Specialized procedures are more general because they can be used to eliminate runtime checks that are not primitive to the source language. In <ref> [18] </ref>, Sites describes a technique for proving that programs written in a language like Algol 60 terminate without runtime errors. This requires proving properties sufficient to eliminate runtime checks in array references, numeric operations, assignments from supertypes to subtypes, etc.
Reference: [19] <author> M. T. Vandevoorde. </author> <title> Specifications can make programs run faster. </title> <booktitle> In Proceedings of TAPSOFT '93. </booktitle> <publisher> Springer Verlag, </publisher> <month> April </month> <year> 1993. </year>
Reference-contexts: In addition to performing optimizations based on specialized procedures, PSC takes advantage of the information provided in specifications to perform enhanced global common subexpression elimination, code motion out of loops, and dead code elimination [1]. Those aspects of our work are reported in <ref> [19, 20] </ref>. When PSC was used on the AC-unify program in the way described in Section 2, it was able to optimize all of the nine possible calls. This resulted in a performance improvement of 14%.
Reference: [20] <author> M. T. Vandevoorde. </author> <title> Exploiting specifications to improve program performance. </title> <type> Technical Report MIT/LCS/TR-598, </type> <institution> M.I.T., </institution> <address> Cambridge, Ma 02139, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: The final component needed before building a compiler is a formal model for reasoning about programs. Our model includes a formalization of program states and a set of proof rules. We sketch our model here; a detailed description of the model used in PSC is contained in <ref> [20] </ref>. In the model, a procedure implementation is represented as a control flow graph (CFG) with six kinds of nodes: assignment, procedure call, iterator call, branch, merge, and loop. <p> This makes more information available for discharging guards of SPIs in P's implementation. The other way PSC uses the abstraction function is to propagate an SPI up through P's implementation, a technique which is explained in <ref> [20] </ref>. In AC-Unify, PSC used the abstraction function of substitution to automatically propagate the SPI of mapping$insert to its caller, substitution$store. Thus, PSC is able to optimize the callers of substitution$store. <p> In addition to performing optimizations based on specialized procedures, PSC takes advantage of the information provided in specifications to perform enhanced global common subexpression elimination, code motion out of loops, and dead code elimination [1]. Those aspects of our work are reported in <ref> [19, 20] </ref>. When PSC was used on the AC-unify program in the way described in Section 2, it was able to optimize all of the nine possible calls. This resulted in a performance improvement of 14%.
Reference: [21] <author> J. M. Wing. </author> <title> A two-tiered approach to specifying programs. </title> <type> Technical Report MIT/LCS/TR-299, </type> <institution> M.I.T., </institution> <year> 1983. </year>
Reference-contexts: The combination of side effects and pointers to heap-allocated data structures requires PSC to handle aliasing, the most challenging problem for optimizing compilers. The specification language portion of Speckle builds on the Larch family of specification languages [10] and borrows heavily from the Larch/CLU language <ref> [21] </ref>. Procedure specifications consist of pre- and postconditions written in a stylized fashion. into an intset. Here, the empty requires clause indicates that the precondition is vacuous (true).
Reference: [22] <author> K. Yelick. </author> <title> A generalized approach to equational unification. </title> <type> Technical Report MIT/LCS/TR-344, </type> <institution> M.I.T., </institution> <month> August </month> <year> 1985. </year> <month> 7 </month>
References-found: 22

