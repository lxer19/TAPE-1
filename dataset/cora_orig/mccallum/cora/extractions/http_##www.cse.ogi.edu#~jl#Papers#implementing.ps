URL: http://www.cse.ogi.edu/~jl/Papers/implementing.ps
Refering-URL: http://www.cse.ogi.edu/~jl/biblio-analysis.html
Root-URL: http://www.cse.ogi.edu
Title: Implementing Projection-based Strictness Analysis  
Author: Ryszard Kubiak, John Hughes, John Launchbury 
Affiliation: Department of Computing Science University of Glasgow  
Abstract: Projection-based backwards strictness analysis has been understood for some years. Surprisingly, even though the method is fairly simple and quite general, no reports of its implementation have appeared. This paper describes ideas underlying our prototype implementation of the analysis for a simple programming language. The implementation serves as a case study before applying the method in the Glasgow Haskell compiler.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Augustsson. </author> <title> A Compiler for Lazy ML. </title> <booktitle> Proceedings of Lisp and Functional Programming Conference, </booktitle> <address> Austin, Texas, </address> <year> 1984. </year>
Reference-contexts: The gain comes from the fact that we rarely require the whole fixed-point, but only its value for a few specified arguments. 6.2 Concrete Representation of Projections The following is the LML <ref> [ 1 ] </ref> definition of the type that represents projections in the implementation type proj = PStr proj + PLift proj + PBot + PProd (List proj) + PMu name (List proj) + PRec name + PSum (List proj) The term PLift p corresponds to p ? and PStr p represents
Reference: [2] <author> K. Davis and P. Wadler, </author> <title> Strictness Analysis in 4D, </title> <booktitle> Third Annual Glasgow Workshop on Functional Programming, Ullapool, Workshops in Computing, </booktitle> <address> S-V, </address> <year> 1990. </year>
Reference-contexts: It is worth noticing that our transformer is slightly more efficient than the one given originally [ 8 ] . Like Davis and Wadler <ref> [ 2 ] </ref> , we collect the result of the analysis in an environment of projections, so allowing the contexts for all the arguments to be found by a single pass through the function's body.
Reference: [3] <author> R.J.M. Hughes and J. Launchbury, </author> <title> Projections for Polymorphic Strictness Analysis, </title> <note> To appear in Mathematical Structures in Computer Science, C.U.P. </note>
Reference-contexts: 1 Introduction The method of projection-based backwards strictness analysis for first-order, lazy functional languages was first presented by Wadler and Hughes [ 8 ] in 1987. Since then it has been generalised by Hughes [ 4 ] and Hughes and Launchbury <ref> [ 3 ] </ref> to work for user-defined types and for polymorphism. Yet, to our knowledge, it has never been implemented even though the method is fairly simple and quite general. The time has come for projection-based strictness analysis to meet practice. This paper describes a prototype implementation. <p> This is reflected in the following development where we use the semantic notation to represent a syntactic construction. 5.1 Contexts for strictness analysis Following the approach of Launchbury [ 6 ] and Hughes and Launchbury <ref> [ 3 ] </ref> we define for each type a finite collection of projections called contexts.
Reference: [4] <author> R.J.M. Hughes, </author> <title> Projections for Polymorphic Strictness Analysis, </title> <booktitle> In Category Theory in Computer Science, </booktitle> <address> Manchester, </address> <year> 1989. </year>
Reference-contexts: 1 Introduction The method of projection-based backwards strictness analysis for first-order, lazy functional languages was first presented by Wadler and Hughes [ 8 ] in 1987. Since then it has been generalised by Hughes <ref> [ 4 ] </ref> and Hughes and Launchbury [ 3 ] to work for user-defined types and for polymorphism. Yet, to our knowledge, it has never been implemented even though the method is fairly simple and quite general. The time has come for projection-based strictness analysis to meet practice.
Reference: [5] <author> N.D. Jones and A. Mycroft, </author> <title> Data Flow Analysis of Applicative Programs Using Minimal Function Graphs, </title> <booktitle> Proc. of the Thirteenth ACM Symposium on Principles of Programmng Languages, </booktitle> <address> St. Petersburg, Florida, </address> <pages> pp. 296-306, </pages> <year> 1986 </year>
Reference-contexts: Of the variety of methods for finding such solutions (fixed points) we use minimal function graphs <ref> [ 5 ] </ref> . Our implementation follows that of Launchbury [ 7 ] .
Reference: [6] <author> J. Launchbury, </author> <title> Projections for Specialisation, </title> <editor> in Bjtrner, Ershov and Jones (eds), </editor> <title> Partial Evaluation and Mixed Computation. </title> <booktitle> Proceedings IFIP TC2 Workshop, </booktitle> <address> Denmark, Oct 1987. </address> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: To achieve this we work with a concrete representation of the projections, syntactically modelling the semantic constructions and operations. This is reflected in the following development where we use the semantic notation to represent a syntactic construction. 5.1 Contexts for strictness analysis Following the approach of Launchbury <ref> [ 6 ] </ref> and Hughes and Launchbury [ 3 ] we define for each type a finite collection of projections called contexts.
Reference: [7] <author> J. Launchbury, </author> <title> Projection Factorisations in Partial Evaluation, </title> <type> Ph.D. thesis, </type> <institution> Glasgow University. Distinguished Dissertations in Computer Science, </institution> <note> Vol 1, CUP, </note> <year> 1991. </year>
Reference-contexts: In particular, we restrict ourselves to a first-order polymorphic language. Another reason for expecting the implementation to be straightforward was that an implementation of projection-based program analysis already existed. In his thesis <ref> [ 7 ] </ref> , Launchbury implemented a binding-time analysis using projections, which analysed programs written in a polymorphic, first-order language with user defined types. In particular, he demonstrated that projections (which are functions) can effectively be manipulated in a concrete implementation. <p> A forwards projection analysis such as appears in Launchbury's thesis <ref> [ 7 ] </ref> is defined by abstract functions which mimic the concrete semantic functions. PR # : FunDefs ! ForwardAbsFunEnv E # : ForwardAbsFunEnv ! Expr ! (AbsValEnv ! AbsValue) In the case of backwards strictness analysis the direction of the final arrow is reversed. <p> Of the variety of methods for finding such solutions (fixed points) we use minimal function graphs [ 5 ] . Our implementation follows that of Launchbury <ref> [ 7 ] </ref> . The minimal function graph contains abstract function results (tuples of contexts representing the demand for the arguments to the function) for selected abstract arguments (contexts representing the demand for the function's result) for the functions in the program.
Reference: [8] <author> P. Wadler and R.J.M. Hughes, </author> <title> Projections for Strictness Analysis, </title> <booktitle> In Functional Programming and Computer Architecture, </booktitle> <address> Portland, USA, </address> <publisher> LNCS 274, </publisher> <year> 1987 </year>
Reference-contexts: 1 Introduction The method of projection-based backwards strictness analysis for first-order, lazy functional languages was first presented by Wadler and Hughes <ref> [ 8 ] </ref> in 1987. Since then it has been generalised by Hughes [ 4 ] and Hughes and Launchbury [ 3 ] to work for user-defined types and for polymorphism. Yet, to our knowledge, it has never been implemented even though the method is fairly simple and quite general. <p> We can always choose p to be Ide, but this is uninformative: Ide corresponds to performing no evaluation at all. We would like to find the smallest p such that the condition holds. In general this is equivalent to the halting problem, but <ref> [ 8 ] </ref> gives methods for finding quite small ps, for monomorphic functions. Later in this paper we give a revised version of these methods. There are four fundamental projections over lifted types which capture various degrees of evaluation. We have already seen Ide (no evaluation), and Str (evaluate). <p> The former is modelled by a lifted product. 3.2 Semantics In order to use Str to discover simple strictness, the methods of <ref> [ 8 ] </ref> demand that instead of analysing a function f : A ! B , its lifted version f ? : A ? ! B ? is used instead. At first this seems to be just a technical trick. <p> Writing f fl? provides a more convenient and compact notation for (Str ffi f ? ), as occurs in earlier papers. Our first use of strict lifting is in the definition of the projection transformer E # . The first equation realises the guard operation from <ref> [ 8 ] </ref> . E # # [[ e ]](p fl? ) t x :Abs Recall that all demands are projections over lifted domains. Such projections may always be expressed in the form either p ? or p fl? . <p> Similarly, the Bot s appearing in the rule for case expressions should be understood as the bottom projections over the target types of the remaining constructors, different from c. It is worth noticing that our transformer is slightly more efficient than the one given originally <ref> [ 8 ] </ref> . Like Davis and Wadler [ 2 ] , we collect the result of the analysis in an environment of projections, so allowing the contexts for all the arguments to be found by a single pass through the function's body. <p> p 1 : : : p n cxt T 1 : : : T n p:P (p) cxt t:T (t) p q 1 : : : q n cxt F T 1 : : : T n As an example of contexts we present the familiar head-strict and tail-strict projections <ref> [ 8 ] </ref> over the the list type L : 1 ? ff ? L ? .
References-found: 8

