URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/hypotheticals/icdt88.ps
Refering-URL: http://www.cs.toronto.edu/DB/people/bonner/papers.html
Root-URL: 
Email: bonner@db.toronto.edu  
Title: Hypothetical Datalog: Complexity and Expressibility  
Author: Anthony J. Bonner 
Address: New Brunswick, NJ 08903  
Affiliation: Department of Computer Science Rutgers University  
Abstract: We present an extension of Horn-clause logic which can hypothetically add and delete tuples from a database. Such logics have been discussed in the literature, but their complexities and expressibilities have remained an open question. This paper examines two such logics in the function-free, predicate case. It is shown, in particular, that augmenting Horn-clause logic with hypothetical addition increases its data-complexity from PTIME to PSPACE. When deletions are added as well, complexity increases again, to EXPTIME. To establish expressibility, we augment the logic with negation-by-failure and view it as a query language for relational databases. The logic of hypothetical additions then expresses all database queries which are computable in PSPACE. When deletions are included, the logic expresses all database queries computable in EXPTIME. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and V. Vianu. </author> <title> A Transaction Language Complete for Database Update Specification. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Database Systems (PODS), </booktitle> <pages> pages 260-268, </pages> <year> 1987. </year> <note> Published in expanded form as Rapports de Recherche no. 715, </note> <institution> INRIA, </institution> <address> 78153 Le Chesnay Cedex, France. </address>
Reference-contexts: In particular, at any point in the inference, the database represents an id of the machine. This is comparable to the use by Abiteboul and Vianu, of a database update language to simulate nondeterministic Turing machines <ref> [1] </ref>. Every machine id is either accepting or rejecting. Furthermore, since M is an alternating Turing machine, it has three kinds of states: accepting, universal and existential.
Reference: [2] <author> K.R. Apt, H.A. Blair, and A. Walker. </author> <title> Towards a Theory of Declarative Knowledge. </title> <editor> In Jack Minker, </editor> <booktitle> 18 editor, Foundations of Deductive Databases and Logic Programming, chapter 2, </booktitle> <pages> pages 89-148. </pages> <publisher> Mor-gan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: See [6] for a more precise definition. which are mutually recursive. This is a familiar problem in Horn-clause logic <ref> [2] </ref>. For example, given the two rules A ~ B and B ~ A and an empty database, it is not clear whether A is to be inferred, or B, or both, or neither.
Reference: [3] <author> K.R. Apt and M.H. Van Emden. </author> <title> Contributions to the Theory of Logic Programming. </title> <journal> Journal of the ACM, </journal> <volume> 29(3) </volume> <pages> 841-862, </pages> <year> 1982. </year>
Reference-contexts: Embedded implications have an intuitionistic semantics. That is, their models are Kripke structures, consisting of many possible substates [11]. McCarty has developed an intuitionistic fixpoint-semantics for embedded implications and has shown that they have interesting semantical properties analogous to the unique minimal-model property of Horn clauses <ref> [20, 3] </ref>. In particular, he has shown that they have a unique maximal Kripke-model, which in turn, has a unique minimal substate. It is also known that in the propositional case, intuitionistic validity is PSPACE-complete [23, 18]. <p> Semantics are introduced, however, mainly as a vehicle for establishing upper complexity bounds. We define a notion of rulebase interpretation and introduce a fixpoint operator, much like the T-operator of Horn clause logic <ref> [3, 24] </ref>. A bottom-up, iterative procedure is developed for computing the "least fixpoint" of a database and a set of rules. It is easy to show that this procedure runs in exponential time. For the restricted logic of hypothetical additions, a mixed top-down/bottom-up algorithm is developed. <p> Such "blowups" can be viewed as the source of the EXPTIME and PSPACE data-complexity bounds for our hypothetical logics. 4 Bottom-Up Inference In this section, hypothetical inference is formulated in terms of a bottom-up, iterative operator, much like the T-operator of Horn-clause logic <ref> [3, 24] </ref>. This view of inference forms the basis of algorithms developed in the next section, algorithms whose complexities are easily determined. This section develops enough theory to verify that these algorithms are sound and complete with respect to the inference system defined in the last section.
Reference: [4] <author> A.J. Bonner. </author> <title> A Logic for Hypothetical Reasoning. </title> <type> Technical Report DCS-TR-230, </type> <institution> Department of Computer Science, Rutgers University, </institution> <address> New Brunswick, NJ 08903, </address> <year> 1988. </year>
Reference-contexts: 1 Introduction Several researchers in the logic programming community have pointed out the utility of augmenting Horn-clause logic with the ability to hypothetically add facts to a database <ref> [13, 12, 22, 26, 19, 4] </ref>. Others have done fl This paper appears in the Proceedings of the Second International Conference on Database Theory (ICDT), pages 144-160. Volume 326 of Lecture Notes in Computer Science. Springer Verlag. <p> Definition 1 A premise (or query) is an expression having one of the following forms: 5 The first rule uses negation-by-failure [17]. 6 Semantics are touched upon only briefly in this paper; but see <ref> [4] </ref> for a proof that the hypothetical logic of additions has an intuitionistic semantics. * A where A is atomic. * A [add : B] where A and B are atomic. * A [del : B] where A and B are atomic. <p> This is the price we pay in worst-case performance, for the ability to reason about hypothetical database updates. What do we get for this price? In <ref> [4] </ref> it is shown that there are low-complexity, hypothetical queries that cannot be expressed in classical logic unless one assumes the user has full knowledge of the rulebase. Thus we get the ability to express certain hypothetical queries in a rulebase-independent way.
Reference: [5] <author> A.J. Bonner. </author> <title> Hypothetical Datalog: Complexity and Expressibility. </title> <type> Technical Report DCS-TR-231, </type> <institution> Department of Computer Science, Rutgers university, </institution> <address> New Brunswick, NJ 08903, </address> <year> 1988. </year> <note> Also published in volume 76 (1990) of Theoretical Computer Science (TCS), pages 3-51. </note>
Reference-contexts: Definition 7 If M is a rulebase interpretation, then * T 0 * T n+1 R (M)] R (M) = [ n=1 R (M) From these definitions, the following theorem is straightforward (see <ref> [5] </ref> for details). It is the basis of the algorithms introduced in the next section. Theorem 1 R; DB ` iff T fl R (I); DB j= . Example 9. Suppose R contains exactly two rules, B C and A B [add : C]. <p> For each transition, the rules add a new machine id to the database, so that the computation path is "grown" one id at a time. The rules are a simple variation of those in section 6.1 (see <ref> [5] </ref> for details). They define a predicate ACCEP T (t) which determines whether the id at the end of a computation path is accepting. <p> This in turn provides a way of counting from 0 to n k 1. In particular, we can write Horn rules to define the following three predicates: F IRST (x), N EXT (x; y), and LAST (y), where x and y are k-tuples (see <ref> [5] </ref> for details). <p> In particular, one can define a predicate IN IT (c; p) which is true iff the tape cell at position p should be initialized to the symbol c, where c 2 f0; 1; blankg (see <ref> [5] </ref> for details). The machine tape is then initialized by the following rule: CELL (c; p; t) IN IT (c; p); F IRST (t): 7.2.5 Order Independence This machine representation depends on the existence of a total linear order on the data domain.
Reference: [6] <author> A.K. Chandra and D. Harel. </author> <title> Computable Queries for Relational Databases. </title> <journal> Journal of Computer and System Sciences (JCSS), </journal> <volume> 21(2) </volume> <pages> 156-178, </pages> <year> 1980. </year>
Reference-contexts: This is sufficient as long as the Turing machine simulation is insensitive to the particular linear-order being used. To prove this, we exploit the definition of generic "database queries" as given by Chandra and Harel <ref> [6, 7] </ref>. This definition requires that a query satisfy a consistency criterion: if the constants in the database are renamed in a consistent way, then the constants in the answer to a query must be renamed in the same way. <p> Hence, it does not matter which linear order is used. In this way, the consistency criterion is central to our ability to use unorderd domains. Before proceeding, we define the notions of rela 12 tional database and of database query. The following definitions are esentially those given in <ref> [6] </ref> and [7]. Definition 8 Let U be a countable set, called the universal data domain. <p> See <ref> [6] </ref> for a more precise definition. which are mutually recursive. This is a familiar problem in Horn-clause logic [2].
Reference: [7] <author> A.K. Chandra and D. Harel. </author> <title> Structure and Complexity of Relational Queries. </title> <booktitle> In Proceedings of the Symposium on the Foundations of Computer Science (FOCS), </booktitle> <pages> pages 333-347, </pages> <year> 1980. </year>
Reference-contexts: This is sufficient as long as the Turing machine simulation is insensitive to the particular linear-order being used. To prove this, we exploit the definition of generic "database queries" as given by Chandra and Harel <ref> [6, 7] </ref>. This definition requires that a query satisfy a consistency criterion: if the constants in the database are renamed in a consistent way, then the constants in the answer to a query must be renamed in the same way. <p> In this way, the consistency criterion is central to our ability to use unorderd domains. Before proceeding, we define the notions of rela 12 tional database and of database query. The following definitions are esentially those given in [6] and <ref> [7] </ref>. Definition 8 Let U be a countable set, called the universal data domain. <p> Thus, EV EN cannot be expressed in our hypothetical logic without negation-by-failure. It is also known, however, that EV EN cannot be expressed in Horn-clause logic even with negation-by-failure <ref> [7, 8] </ref>. Using a slightly more sophisticated use of negation-by-failure, EV EN can be implemented in the restricted logic of hypothetical additions. The trick is to notice that the use of deletion above is particularly simple.
Reference: [8] <author> A.K. Chandra and D. Harel. </author> <title> Horn Clauses and the Fixpoint Query Hierarchy. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Database Systems (PODS), </booktitle> <pages> pages 158-163, </pages> <year> 1982. </year>
Reference-contexts: Thus, EV EN cannot be expressed in our hypothetical logic without negation-by-failure. It is also known, however, that EV EN cannot be expressed in Horn-clause logic even with negation-by-failure <ref> [7, 8] </ref>. Using a slightly more sophisticated use of negation-by-failure, EV EN can be implemented in the restricted logic of hypothetical additions. The trick is to notice that the use of deletion above is particularly simple.
Reference: [9] <author> A.K. Chandra, D. Kozen, and L.J. Stockmeyer. </author> <title> Alternation. </title> <journal> Journal of the ACM, </journal> <volume> 28 </volume> <pages> 114-133, </pages> <year> 1981. </year>
Reference-contexts: In this way, EXPTIME and PSPACE upper-bounds on the data-complexity of query processing are established for the full logic and its restriction, resp. To establish these as lower bounds, we use the logics to encode the computations of alternating Turing-machines <ref> [9] </ref>. In the full logic, the database represents the machine tape and hypothetical updates represent machine transitions. Hypothetical deletion simulates tape erasure, and hypothetical addition simulates tape writing. In this way, alternating PSPACE machines can be encoded. <p> Like nondeterministic machines, an alternating machine may have many possible transitions at any point in the computation. Alternating machines, however, may require that all machine transitions be successful, not just one. This capability gives alternating machines more power than nondeterministic machines <ref> [9] </ref>. 6.1 EXPTIME Lower-Bound We first show that query processing for the full logic of hypothetical additions and deletions is EXPTIME-hard. Our strategy is to use the logic to encode the computations of an alternating PSPACE machine. Since APSPACE=EXPTIME, the result follows [9]. <p> gives alternating machines more power than nondeterministic machines <ref> [9] </ref>. 6.1 EXPTIME Lower-Bound We first show that query processing for the full logic of hypothetical additions and deletions is EXPTIME-hard. Our strategy is to use the logic to encode the computations of an alternating PSPACE machine. Since APSPACE=EXPTIME, the result follows [9]. In addition, these machine encodings are central to the EXPTIME expressiveness result of section 7. Let M be a one-tape, alternating Turing-machine which runs in polynomial space (an APSPACE machine), and let s be an input string. <p> The proof is similar to that of the previous section except that instead of encoding alternating PSPACE machines, we encode alternating PTIME machines. Since APTIME=PSPACE, the result follows <ref> [9] </ref>. These machine encodings are also central to the PSPACE expressiveness result of section 7. The main difference between the encodings in this section and the last is that we now represent time explicitly. <p> Thus, given a PSPACE machine which solves the generation problem for , there is another PSPACE machine which solves the recognition problem. This machine recognizes the language f&lt; x; DB &gt; j x 2 (DB)g. Since PSPACE=APTIME, there is an alternating PTIME machine M which also recognizes this language <ref> [9] </ref>. Our main result is to construct a rulebase R (M ) which solves the recognition problem for by simulating the computations of M .
Reference: [10] <author> A.K. Chandra and L.J. Stockmeyer. </author> <title> Alternation. </title> <booktitle> In Proceedings of the Symposium on the Foundations of Computer Science (FOCS), </booktitle> <pages> pages 98-108, </pages> <year> 1976. </year>
Reference-contexts: This is done by placing the following entries in the database DB (s): HEAD (q 0 ; 0); CELL (s 0 ; 0); CELL (blank; n); CELL (s 1 ; 1); CELL (blank; n + 1); CELL (s n1 ; n 1); CELL (blank; n k 1): 8 see <ref> [10] </ref> for examples of such machines. 9 We must also simulate the read, write and move operations of the machine's control head. This is done by hypothetically adding and deleting entries from the database.
Reference: [11] <author> M.C. </author> <title> Fitting. Intuitionistic Logic, Model Theory and Forcing. </title> <publisher> North-Holland, </publisher> <year> 1969. </year>
Reference-contexts: Rules such as these are called embedded implications [20]. Embedded implications have an intuitionistic semantics. That is, their models are Kripke structures, consisting of many possible substates <ref> [11] </ref>. McCarty has developed an intuitionistic fixpoint-semantics for embedded implications and has shown that they have interesting semantical properties analogous to the unique minimal-model property of Horn clauses [20, 3]. In particular, he has shown that they have a unique maximal Kripke-model, which in turn, has a unique minimal substate.
Reference: [12] <author> D.M. Gabbay. N-Prolog: </author> <title> an Extension of Prolog with Hypothetical Implications. II. Logical Foundations and Negation as Failure. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 2(4) </volume> <pages> 251-283, </pages> <year> 1985. </year>
Reference-contexts: 1 Introduction Several researchers in the logic programming community have pointed out the utility of augmenting Horn-clause logic with the ability to hypothetically add facts to a database <ref> [13, 12, 22, 26, 19, 4] </ref>. Others have done fl This paper appears in the Proceedings of the Second International Conference on Database Theory (ICDT), pages 144-160. Volume 326 of Lecture Notes in Computer Science. Springer Verlag. <p> Section 5 showed that any database query expressible in the full logic is computable is EXPTIME. This section establishes a converse: by augmenting the full logic with negation-by-failure <ref> [17, 12] </ref>, any database query computable in exponential time can be expressed. Similarly, by augmenting the restricted logic with negation-by-failure, any database query computable in polynomial space can be expressed. The proofs rely on the simulations of Turing machines as developed in the section 6.
Reference: [13] <editor> D.M. Gabbay and U. Reyle. N-Prolog: </editor> <title> an Extension of Prolog with Hypothetical Implications. I. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 1(4) </volume> <pages> 319-355, </pages> <year> 1984. </year>
Reference-contexts: 1 Introduction Several researchers in the logic programming community have pointed out the utility of augmenting Horn-clause logic with the ability to hypothetically add facts to a database <ref> [13, 12, 22, 26, 19, 4] </ref>. Others have done fl This paper appears in the Proceedings of the Second International Conference on Database Theory (ICDT), pages 144-160. Volume 326 of Lecture Notes in Computer Science. Springer Verlag. <p> In particular, the act contains rules such as the following: "You are eligible for citizenship if your father would be eligible if he were still alive" <ref> [13] </ref>. Rules such as these are called embedded implications [20]. Embedded implications have an intuitionistic semantics. That is, their models are Kripke structures, consisting of many possible substates [11].
Reference: [14] <author> D. Harel. </author> <title> First-Order Dynamic Logic, </title> <booktitle> volume 68 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: Thus, deletions from the database make no sense in intuitionistic logics. One alternative is to view our logic as a dynamic logic of database updates. In fact, our notation for hypothetical updates is reminiscent of dynamic logic, with additions and deletions being the primitive actions <ref> [14, 19] </ref>. This paper introduces a semantics for hypothetical updates which in some sense is "midway" between that of dynamic and intuitionistic logic. Semantics are introduced, however, mainly as a vehicle for establishing upper complexity bounds.
Reference: [15] <author> J.E. Hopcroft and J.D. Ullman. </author> <title> Introduction to Automata Theory, Languages and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: In general, an alternating Turing machine has a computation tree, containing many such paths. The rulebase R (M ) explores this tree one path at a time, asserting each path hypothetically, and then retracting it. 9 See <ref> [15] </ref> for examples of such languages. 11 As before, the transition relation of the machine M is encoded as a set of hypothetical rules. This time, however, there is one set of hypothetical additions for each transition, and no hypothetical deletions.
Reference: [16] <author> N. Immerman. </author> <title> Relational Queries Computable in Polynomial Time. </title> <booktitle> In Proceedings of the ACM Symposium on Theory of Computing (STOC), </booktitle> <pages> pages 147-152, </pages> <year> 1982. </year>
Reference-contexts: In this respect they are similar to other expressibility proofs in the literature <ref> [16, 25] </ref>. One difference, however, is that we do not require the data domain to be linearly ordered. Linearly-ordered domains are used to simulate counters, which in turn, are used to simulate tape-head movements. Our approach is to start with unordered domains and assert linear orders hypothetically. <p> Similarly, by augmenting the restricted logic with negation-by-failure, any database query computable in polynomial space can be expressed. The proofs rely on the simulations of Turing machines as developed in the section 6. In this respect, they are similar to other expressibility proofs in the literature (e.g., <ref> [16, 25] </ref>). One difference, however, is that we do not require the domain of the database to be linearly ordered. Linearly-ordered domains are used to simulate counters, which in turn, are used to simulate the movement of the control head. <p> The assumption of a linearly ordered domain is common in the literature <ref> [16, 25] </ref>, especially when expressiblity results are established in terms of complexity classes, as in theorem 4. For hypothetical logics, however, this assumption is unnecessary; if there is no linear order on the domain, then one can be asserted hypothetically. The difficulty is in choosing which linear order to assert.
Reference: [17] <author> R. Kowalski. </author> <title> Logic for Problem Solving. </title> <publisher> North-Holland, </publisher> <year> 1979. </year>
Reference-contexts: In particular, we view the two logics as query languages for relational databases; and we ask, "what class of database queries do these logics express?" Because they are monotonic, there are many simple queries that these logics cannot express; so we first augment them with negation-by-failure <ref> [17] </ref>. When augmented in this way, the full logic expresses all database queries which are computable in exponential time; and the restricted logic expresses all database queries computable in poly nomial space. 2 The proofs rely on our simulation of alternating Turing-machines. <p> the rulebase R contains rules such as grad (s) take (s; his101); take (s; eng201): In the following examples, each query is described in three ways: (i) informally, in English, (ii) formally, at the meta-level, and (iii) formally, at the object-level with operators of addition and deletion. 3 3 See <ref> [17] </ref> for a description of meta-level and object-level reasoning. Example 1. <p> Although the rest of this paper fo-cusses on the function-free case, the definitions of this section do not require this restriction. Definition 1 A premise (or query) is an expression having one of the following forms: 5 The first rule uses negation-by-failure <ref> [17] </ref>. 6 Semantics are touched upon only briefly in this paper; but see [4] for a proof that the hypothetical logic of additions has an intuitionistic semantics. * A where A is atomic. * A [add : B] where A and B are atomic. * A [del : B] where A <p> Notice that hypothetical rules include atomic formulas and definite Horn-rules as special cases. This syntax is therefore an extension of that of Horn logic <ref> [17] </ref>. The inference system too is an extension of Horn logic, as the following definition shows. Definition 3 Suppose R is a set of hypothetical rules and DB is a database. Then hypothetical inference is defined as follows, where A and B are ground atomic formulas: 1. <p> Section 5 showed that any database query expressible in the full logic is computable is EXPTIME. This section establishes a converse: by augmenting the full logic with negation-by-failure <ref> [17, 12] </ref>, any database query computable in exponential time can be expressed. Similarly, by augmenting the restricted logic with negation-by-failure, any database query computable in polynomial space can be expressed. The proofs rely on the simulations of Turing machines as developed in the section 6.
Reference: [18] <author> R.E. Ladner. </author> <title> The Computational Complexity of Provability in Systems of Propositional Modal Logic. </title> <journal> SIAM Journal of Computing, </journal> <volume> 6(3) </volume> <pages> 467-480, </pages> <year> 1977. </year>
Reference-contexts: In particular, he has shown that they have a unique maximal Kripke-model, which in turn, has a unique minimal substate. It is also known that in the propositional case, intuitionistic validity is PSPACE-complete <ref> [23, 18] </ref>. To our knowledge, however, we are the first to address the questions of the data-complexity and expressibility of intuitionistic reasoning. In contrast to additions, hypothetical deletions do not appear to have an intuitionistic semantics.
Reference: [19] <author> S. Manchanda and D.S. Warren. </author> <title> A Logic-based Language for Database Updates. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, chapter 10, </booktitle> <pages> pages 363-394. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: 1 Introduction Several researchers in the logic programming community have pointed out the utility of augmenting Horn-clause logic with the ability to hypothetically add facts to a database <ref> [13, 12, 22, 26, 19, 4] </ref>. Others have done fl This paper appears in the Proceedings of the Second International Conference on Database Theory (ICDT), pages 144-160. Volume 326 of Lecture Notes in Computer Science. Springer Verlag. <p> In particular, results on data-complexity and expressibility are established for the function-free predicate case. This paper also examines hypothetical deletion. In contrast to additions, hypothetical deletions have received little attention in the logic-programming literature, one exception being the work of Manchanda and Warren <ref> [19] </ref>. As in their work, this paper focuses on deletions from the database, and not from the least fix-point. <p> Thus, deletions from the database make no sense in intuitionistic logics. One alternative is to view our logic as a dynamic logic of database updates. In fact, our notation for hypothetical updates is reminiscent of dynamic logic, with additions and deletions being the primitive actions <ref> [14, 19] </ref>. This paper introduces a semantics for hypothetical updates which in some sense is "midway" between that of dynamic and intuitionistic logic. Semantics are introduced, however, mainly as a vehicle for establishing upper complexity bounds.
Reference: [20] <author> L.T. McCarty. </author> <title> Clausal Intuitionistic Logic. I. Fixed-Point Semantics. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 5(1) </volume> <pages> 1-31, </pages> <year> 1988. </year>
Reference-contexts: Others have done fl This paper appears in the Proceedings of the Second International Conference on Database Theory (ICDT), pages 144-160. Volume 326 of Lecture Notes in Computer Science. Springer Verlag. Conference held August 1988 at Bruges, Belgium. as much by investigating the intuitionistic semantics of embedded implications <ref> [20, 21] </ref>. However, the complexity and expressibility of these logics has remained an open question. This paper addresses these issues from a database point of view. In particular, results on data-complexity and expressibility are established for the function-free predicate case. This paper also examines hypothetical deletion. <p> In particular, the act contains rules such as the following: "You are eligible for citizenship if your father would be eligible if he were still alive" [13]. Rules such as these are called embedded implications <ref> [20] </ref>. Embedded implications have an intuitionistic semantics. That is, their models are Kripke structures, consisting of many possible substates [11]. McCarty has developed an intuitionistic fixpoint-semantics for embedded implications and has shown that they have interesting semantical properties analogous to the unique minimal-model property of Horn clauses [20, 3]. <p> Embedded implications have an intuitionistic semantics. That is, their models are Kripke structures, consisting of many possible substates [11]. McCarty has developed an intuitionistic fixpoint-semantics for embedded implications and has shown that they have interesting semantical properties analogous to the unique minimal-model property of Horn clauses <ref> [20, 3] </ref>. In particular, he has shown that they have a unique maximal Kripke-model, which in turn, has a unique minimal substate. It is also known that in the propositional case, intuitionistic validity is PSPACE-complete [23, 18].
Reference: [21] <author> L.T. McCarty. </author> <title> Clausal Intuitionistic Logic. II. Tableau Proof Procedures. </title> <journal> Journal of Logic Programming (JLP), </journal> <volume> 5(2) </volume> <pages> 93-132, </pages> <year> 1988. </year>
Reference-contexts: Others have done fl This paper appears in the Proceedings of the Second International Conference on Database Theory (ICDT), pages 144-160. Volume 326 of Lecture Notes in Computer Science. Springer Verlag. Conference held August 1988 at Bruges, Belgium. as much by investigating the intuitionistic semantics of embedded implications <ref> [20, 21] </ref>. However, the complexity and expressibility of these logics has remained an open question. This paper addresses these issues from a database point of view. In particular, results on data-complexity and expressibility are established for the function-free predicate case. This paper also examines hypothetical deletion.
Reference: [22] <author> D. Miller. </author> <title> A Logical Analysis of Modules in Logic Programming. </title> <booktitle> In Proceedings of the IEEE Symposium on Logic Programming, </booktitle> <pages> pages 106-114, </pages> <month> Sept </month> <year> 1986. </year>
Reference-contexts: 1 Introduction Several researchers in the logic programming community have pointed out the utility of augmenting Horn-clause logic with the ability to hypothetically add facts to a database <ref> [13, 12, 22, 26, 19, 4] </ref>. Others have done fl This paper appears in the Proceedings of the Second International Conference on Database Theory (ICDT), pages 144-160. Volume 326 of Lecture Notes in Computer Science. Springer Verlag.
Reference: [23] <author> R. Statman. </author> <title> Intuitionistic Propositional Logic is Polynomial-Space Complete. </title> <journal> Theoretical Computer Science (TCS), </journal> <volume> 9(1) </volume> <pages> 67-72, </pages> <year> 1979. </year>
Reference-contexts: In particular, he has shown that they have a unique maximal Kripke-model, which in turn, has a unique minimal substate. It is also known that in the propositional case, intuitionistic validity is PSPACE-complete <ref> [23, 18] </ref>. To our knowledge, however, we are the first to address the questions of the data-complexity and expressibility of intuitionistic reasoning. In contrast to additions, hypothetical deletions do not appear to have an intuitionistic semantics.
Reference: [24] <author> M.H. Van Emden and R.A. Kowalski. </author> <title> The Semantics of Predicate Logic as a Programming Language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year>
Reference-contexts: Semantics are introduced, however, mainly as a vehicle for establishing upper complexity bounds. We define a notion of rulebase interpretation and introduce a fixpoint operator, much like the T-operator of Horn clause logic <ref> [3, 24] </ref>. A bottom-up, iterative procedure is developed for computing the "least fixpoint" of a database and a set of rules. It is easy to show that this procedure runs in exponential time. For the restricted logic of hypothetical additions, a mixed top-down/bottom-up algorithm is developed. <p> Such "blowups" can be viewed as the source of the EXPTIME and PSPACE data-complexity bounds for our hypothetical logics. 4 Bottom-Up Inference In this section, hypothetical inference is formulated in terms of a bottom-up, iterative operator, much like the T-operator of Horn-clause logic <ref> [3, 24] </ref>. This view of inference forms the basis of algorithms developed in the next section, algorithms whose complexities are easily determined. This section develops enough theory to verify that these algorithms are sound and complete with respect to the inference system defined in the last section.
Reference: [25] <author> M. Vardi. </author> <title> The Complexity of Relational Query Languages. </title> <booktitle> In Proceedings of the ACM Symposium on Theory of Computing (STOC), </booktitle> <pages> pages 137-146, </pages> <year> 1982. </year>
Reference-contexts: In this respect they are similar to other expressibility proofs in the literature <ref> [16, 25] </ref>. One difference, however, is that we do not require the data domain to be linearly ordered. Linearly-ordered domains are used to simulate counters, which in turn, are used to simulate tape-head movements. Our approach is to start with unordered domains and assert linear orders hypothetically. <p> In particular, the data complexity for the full logic is in EXPTIME, and for the restricted logic, it is in PSPACE. Data complexity is the complexity of query processing when the database is regarded as input but the arity of all relations is bounded and the rulebase is fixed <ref> [25] </ref>. <p> In particular, the data-complexity for the full logic is EXPTIME-hard, and for the restricted logic, it is PSPACE-hard. Recall that data-complexity is the complexity of query processing when the database is regarded as input but the arity of all relations is bounded and the rulebase is fixed <ref> [25] </ref>. The main idea is to use our logic to encode the computations of an alternating Turing machine. Like nondeterministic machines, an alternating machine may have many possible transitions at any point in the computation. Alternating machines, however, may require that all machine transitions be successful, not just one. <p> Similarly, by augmenting the restricted logic with negation-by-failure, any database query computable in polynomial space can be expressed. The proofs rely on the simulations of Turing machines as developed in the section 6. In this respect, they are similar to other expressibility proofs in the literature (e.g., <ref> [16, 25] </ref>). One difference, however, is that we do not require the domain of the database to be linearly ordered. Linearly-ordered domains are used to simulate counters, which in turn, are used to simulate the movement of the control head. <p> The assumption of a linearly ordered domain is common in the literature <ref> [16, 25] </ref>, especially when expressiblity results are established in terms of complexity classes, as in theorem 4. For hypothetical logics, however, this assumption is unnecessary; if there is no linear order on the domain, then one can be asserted hypothetically. The difficulty is in choosing which linear order to assert.
Reference: [26] <author> D.S. Warren. </author> <title> Database Updates in Pure Prolog. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 244-253, </pages> <year> 1984. </year>
Reference-contexts: 1 Introduction Several researchers in the logic programming community have pointed out the utility of augmenting Horn-clause logic with the ability to hypothetically add facts to a database <ref> [13, 12, 22, 26, 19, 4] </ref>. Others have done fl This paper appears in the Proceedings of the Second International Conference on Database Theory (ICDT), pages 144-160. Volume 326 of Lecture Notes in Computer Science. Springer Verlag.
References-found: 26

