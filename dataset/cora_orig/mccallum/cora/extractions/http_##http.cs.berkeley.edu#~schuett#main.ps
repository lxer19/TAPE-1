URL: http://http.cs.berkeley.edu/~schuett/main.ps
Refering-URL: http://www.progsoc.uts.edu.au/~geldridg/cpp/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: A comparison of Sather and Eiffel  
Author: Angela Schuett 
Date: December 11, 1994  
Pubnum: CS263  
Abstract: Sather was originally designed as a faster-running, smaller, nonproprietary version of Eiffel. The two languages have diverged more with each succeeding version. This paper examines the differences between the languages, the motivations for these differences, and whether the languages' respective goals have been met. Particular consideration is given to the type system and the use of polymorphism, both subtype and parametric.
Abstract-found: 1
Intro-found: 1
Reference: [BH91] <author> Andrew P. Black and Norman Hutchinson. </author> <title> Typechecking poly-morphism in Emerald. </title> <type> Technical report, </type> <institution> Digital Equipment Corporation, Cambridge Research Lab, </institution> <year> 1991. </year>
Reference-contexts: Some other languages have added the notion of matching, or F-bounded polymorphism, to their type relations. In Sather, parametric polymorphism is defined in terms of subtypes. However, the language Emerald <ref> [BH91] </ref>, and several other research languages, [BSvG, DGLM94], show that requiring type parameters to be subtypes is too restrictive. All that is necessary to prove safe bounded polymorphism is matching, which is basically the relationship that exists between a subclass and a superclass.
Reference: [BSvG] <author> Kim B. Bruce, Angela Schuett, and Robert van Gent. PolyTOIL: </author> <title> A type-safe polymorphic object-oriented language. </title> <note> Extended abstract and draft technical report available by anonymous ftp from cs.williams.edu in directory pub/kim. </note>
Reference-contexts: Some other languages have added the notion of matching, or F-bounded polymorphism, to their type relations. In Sather, parametric polymorphism is defined in terms of subtypes. However, the language Emerald [BH91], and several other research languages, <ref> [BSvG, DGLM94] </ref>, show that requiring type parameters to be subtypes is too restrictive. All that is necessary to prove safe bounded polymorphism is matching, which is basically the relationship that exists between a subclass and a superclass.
Reference: [DGLM94] <author> Mark Day, Robert Gruber, Barbara Liskov, and Andrew L. Mey-ers. </author> <title> Abstraction mechanisms in Theta. </title> <type> Technical report, </type> <institution> MIT Laboratory for Computer Science, </institution> <year> 1994. </year> <month> 11 </month>
Reference-contexts: Some other languages have added the notion of matching, or F-bounded polymorphism, to their type relations. In Sather, parametric polymorphism is defined in terms of subtypes. However, the language Emerald [BH91], and several other research languages, <ref> [BSvG, DGLM94] </ref>, show that requiring type parameters to be subtypes is too restrictive. All that is necessary to prove safe bounded polymorphism is matching, which is basically the relationship that exists between a subclass and a superclass.
Reference: [Mey92] <author> B. Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: Eiffel 3 added a link-time dependency check, which plugs the hole without changing the semantics of the language <ref> [Mey92] </ref>. Sather's initial release in 1991 (version 0.2) didn't address the contravari-ant/covariant problem, concentrating instead on producing fast executable code using slimmed down Eiffel semantics. <p> While the language is still concerned with efficiency, much more attention has been given to type safety. The subtyping problem has been addressed, and several original features, such as iters, have been added [Omo94]. 1 2 Ma jor differences In <ref> [Mey92] </ref> Bertrand Meyer specifies the important factors in programming which Eiffel seeks to address. The three overarching principles are are reusability, extendibility and reliability. Three lesser goals are efficiency, openness (ability to incorporate code from other languages) and portability. <p> Preconditions, postconditions, and invariants are just a few of the program correctness tools which are a syntactic part of the language. Meyer speaks wistfully of a day when these specifications will be used by an automatic tool to prove (or disprove) correctness <ref> [Mey92] </ref>. Currently, however, they are executed as part of the program, and an exception is flagged if an assertion is not true, or a loop iteration doesn't decrease the loop variant. Assertions are also used to produce class summaries, which specify routine interfaces and preconditions without giving any implementation detail.
Reference: [MOS93] <author> Stephan Murer, Stephen Omohundro, and Clemens Szyperski. Sather iters: </author> <title> Object-oriented iteration abstraction. </title> <type> Technical report, </type> <institution> International Computer Science Institute, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: Sather 0.2, unconcerned with proving termination, provides loop &lt;statement&gt; end The user implements all loop forms using break and return. Clearly, in many cases, it will be difficult to prove anything about Sather 0.2 loops. For Sather 1.0, loop constructs were completely redesigned; a complete description is given in <ref> [MOS93] </ref>. The container class specifies an iter which provides a way to loop through its contents. The object which applies the iter doesn't have to be concerned with setting up a pointer and incrementing it because the container class keeps track of the current state. <p> Iters are an excellent example in fulfillment of Sather's goals of simplicity and efficiency. They also bring out an interesting conflict. The Sather designers claim that iters make code "simpler, easier to read, and less buggy <ref> [MOS93] </ref>." They certainly cut down on the volume of code. However, in some cases they may make code more difficult to reason about, precisely because they hide so much detail.
Reference: [Omo91] <author> Stephen M. Omohundro. </author> <title> The Sather Language. </title> <booktitle> International Computer Science Institute, </booktitle> <year> 1991. </year>
Reference-contexts: Sather's initial release in 1991 (version 0.2) didn't address the contravari-ant/covariant problem, concentrating instead on producing fast executable code using slimmed down Eiffel semantics. The language description claims to have eliminated features which are "pedantic, of purely theoretical interest, or necessary only for large or naive programming teams <ref> [Omo91] </ref>." It concentrated on improving the speed of execution for Eiffel-style programs to be closer to that of C or FORTRAN programs. Sather 1.0, released this year is a much different language. While the language is still concerned with efficiency, much more attention has been given to type safety.
Reference: [Omo93] <author> Stephen Omohundro. </author> <title> The Sather language: Efficient, interactive, object-oriented programming. </title> <journal> Dr. Dobbs' Journal, </journal> <volume> 18(11) </volume> <pages> 42-8, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: The three overarching principles are are reusability, extendibility and reliability. Three lesser goals are efficiency, openness (ability to incorporate code from other languages) and portability. Sather's stated goals are to be "simple, efficient, safe, and non-proprietary <ref> [Omo93] </ref>." While too much shouldn't be read into these goals (they are only English after all, not formal specifications) it is tempting to point out that efficiency occurs before safety in Sather's list, while the opposite is true of Eiffel. <p> In 1 From here on, unless otherwise specified, I'll use Eiffel to refer to Eiffel 3, and Sather to Sather 1.0 2 fact, Sather's strong, static typing system is motivated partially by the in-creased efficiency gained from the absence of run-time checks required by Eiffel's more lenient typing <ref> [Omo93] </ref>. 2.1 Design by Contract Eiffel provides a number of tools to support "Design by Contract", a formal specification of the requirements for each piece of code. Preconditions, postconditions, and invariants are just a few of the program correctness tools which are a syntactic part of the language.
Reference: [Omo94] <author> Stephen M. Omohundro. </author> <title> The Sather 1.0 Specification. </title> <booktitle> International Computer Science Institute, </booktitle> <month> July </month> <year> 1994. </year> <month> 12 </month>
Reference-contexts: Sather 1.0, released this year is a much different language. While the language is still concerned with efficiency, much more attention has been given to type safety. The subtyping problem has been addressed, and several original features, such as iters, have been added <ref> [Omo94] </ref>. 1 2 Ma jor differences In [Mey92] Bertrand Meyer specifies the important factors in programming which Eiffel seeks to address. The three overarching principles are are reusability, extendibility and reliability. Three lesser goals are efficiency, openness (ability to incorporate code from other languages) and portability.
References-found: 8

