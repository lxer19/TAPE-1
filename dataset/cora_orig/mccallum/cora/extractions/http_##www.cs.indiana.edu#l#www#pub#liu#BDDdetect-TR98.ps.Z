URL: http://www.cs.indiana.edu/l/www/pub/liu/BDDdetect-TR98.ps.Z
Refering-URL: http://www.cs.indiana.edu/l/www/pub/liu/
Root-URL: http://www.cs.indiana.edu
Title: Efficient Symbolic Detection of Global Properties in Distributed Systems  
Author: Scott D. Stoller and Yanhong A. Liu 
Date: 2 March 1998  
Affiliation: Computer Science Dept, Indiana University  
Abstract: A new approach is presented for detecting whether a computation of an asynchronous distributed system satisfies Poss (read "possibly "), meaning the system could have passed through a global state satisfying property . Previous general-purpose algorithms for this problem explicitly enumerate the set of global states through which the system could have passed during the computation. The new approach is to represent this set symbolically, in particular, using ordered binary decision diagrams. We describe an implementation of this approach, suitable for off-line detection of properties, and compare its performance to the enumeration-based algorithm of Alagar & Venkatesan. In typical cases, the new algorithm is significantly faster. We have measured over 400-fold speedup in some cases. 
Abstract-found: 1
Intro-found: 1
Reference: [AV97] <author> Sridhar Alagar and S. Venkatesan. </author> <title> Techniques to tackle state explosion in global predicate detection. </title> <note> Submitted to IEEE Transactions on Software Engineering, 1997. Preliminary version appeared in International Conference on Parallel and Distributed Systems (ICPDS'94), pp. 412-417, </note> <year> 1994. </year>
Reference-contexts: Any detection algorithm that enumerates all CGSs|whether using the method in [CM91, MN91] or one of the more efficient schemes in <ref> [JMN95, AV97] </ref>|has time complexity that is at least linear in the number of CGSs. This time complexity can be prohibitive, so researchers have sought faster alternatives. <p> The approach can also be applied to online detection. Section 2 provides some background. Section 3 describes our basic and optimized detection algorithms. Section 4 gives performance results from using the new algorithm and an enumeration-based algorithm <ref> [AV97] </ref> to detect violations of invariants in a coherence protocol and a spanning-tree algorithm. For both examples, when the invariant is not violated, the new method is faster by a factor that increases exponentially with the number of processes in the system. <p> bdd ff (~x) if b1 6= false bdd then return ("c j= Poss ()") return ("c 6j= Poss ()") By testing each disjunct of separately, BDD-detection avoids constructing the potentially large intermediate result . 4 Examples We compare the performance of procedure BDD-detection to Alagar & Venkatesan's off-line detection algorithm <ref> [AV97] </ref>, which (to our knowledge) is the most time- and space-efficient previously-known general-purpose algorithm for detecting Poss. Their algorithm, which we refer to as DFS-detection, performs an depth-first-search search of the lattice of consistent global states.
Reference: [BDD] <institution> The BDD Library (version 1.0). </institution> <note> Available via http://www.cs.cmu.edu/ modelcheck/bdd.html. </note>
Reference-contexts: All measurements were made on a SGI Power Challenge with ten 75 MHz MIPS R8000 CPUs and 2GB RAM. The detection algorithms we measured are sequential, so the use of a parallel machine was irrelevant. We use the BDD library developed by E. Clarke's group at CMU <ref> [BDD] </ref>. The reported running times are the "user times" obtained from the UNIX time command; thus, they reflect the amount of CPU time consumed. For BDD-detection, the variable ordering can affect performance. <p> The memory usage of BDD-detection can be greatly reduced by variable reordering, as described in Section 4.6. 9 4.6 Effect of Variable Reordering We also ran BDD-detection using the two variable-reordering methods, called sift and window3, provided by the BDD package <ref> [BDD] </ref>.
Reference: [Bry92] <author> R.E. Bryant. </author> <title> Symbolic boolean manipulation with ordered binary-decision diagrams. </title> <journal> ACM Computing Surveys, </journal> <volume> 24(3), </volume> <year> 1992. </year>
Reference-contexts: 0 ) _ (idx 1 = 1 ^ 1 idx 0 )) ^ ((idx 0 = 0 ^ 0 idx 1 ) _ (idx 0 = 1 ^ 0 idx 1 )) 3.1 Implementation and an Optimization We represent the formula defined by (7) using ordered binary decision diagrams (BDDs) <ref> [Bry92] </ref>. The main benefits of this representation are: (1) it is a canonical form, so testing satisfiability is easy; (2) for 4 We could take idx p to be vc p;p , since the rules for updating vector clocks imply that c [p][i](vc p;p ) = i.
Reference: [C + 92] <author> E. M. Clarke et al. </author> <title> Automatic verification of sequential circuit design. </title> <editor> In C. A. R. Hoare and M. J. C. Gordon, editors, </editor> <title> Mechanized Reasoning and Hardware Design. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: Thus, the optimization incorporated in procedure BDD-detection has drastically different effectiveness on different examples. Future work is needed to characterize the class of examples for which the optimization is effective. 5 Comparison with Symbolic Model Checking for CTL Detection of Poss can be reduced to CTL model checking <ref> [C + 92] </ref>: a computation is encoded as a transition system whose runs are the histories consistent with the computation, and a CTL model checker is used to check whether that transition system satisfies the CTL formula 9 .
Reference: [CM91] <author> Robert Cooper and Keith Marzullo. </author> <title> Consistent detection of global predicates. </title> <booktitle> In Proc. ACM/ONR Workshop on Parallel and Distributed Debugging, 1991. Appeared as ACM SIGPLAN Notices 26(12) </booktitle> <pages> 167-174, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: This leads to an obvious difficulty for detecting whether a global property (i.e., a predicate on global states) held. Cooper and Marzullo's solution to this difficulty involves two modalities, which we denote by Poss (read "possibly") and Def (read "definitely") <ref> [CM91] </ref>. These modalities are based on logical time as embodied in the happened-before relation !, a partial order that reflects causal dependencies [Lam78]. A history of an asynchronous distributed system can be approximated by a computation, which comprises the local computation of each process together with the happened-before relation. <p> A computation satisfies Def iff, in all histories consistent with that computation, the system passes through a global state satisfying . Cooper and Marzullo give centralized algorithms for detecting Poss and Def for an arbitrary predicate <ref> [CM91] </ref>. A stub at each process reports the local states of that process to a central monitor. The central monitor incrementally constructs a lattice whose elements correspond to CGSs of the computation. A straightforward search of the lattice reveals whether the computation satisfies Poss or Def . <p> Any detection algorithm that enumerates all CGSs|whether using the method in <ref> [CM91, MN91] </ref> or one of the more efficient schemes in [JMN95, AV97]|has time complexity that is at least linear in the number of CGSs. This time complexity can be prohibitive, so researchers have sought faster alternatives.
Reference: [FR94] <author> Eddy Fromentin and Michel Raynal. </author> <title> Local states in distributed computations: A few relations and formulas. </title> <journal> Operating Systems Review, </journal> <volume> 28(2), </volume> <month> April </month> <year> 1994. </year>
Reference-contexts: Thus, concurrency of two local states can be tested in O (N ) time using vector timestamps. Concurrency of two local states can be tested in constant time by exploiting the following theorem <ref> [FR94] </ref>: for a local state s 1 of process p 1 and a local state s 2 of process p 2 , s 1 k s 2 s 1 (vc p 1 )[p 2 ] s 2 (vc p 2 )[p 2 ] ^ s 2 (vc p 2 )[p 1
Reference: [FR97] <author> Eddy Fromentin and Michel Raynal. </author> <title> Inevitable global states: a concept to detect unstable properties of distributed computations in an observer independent way. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 55(3), </volume> <month> December </month> <year> 1997. </year>
Reference-contexts: One approach has been to restrict the problem and develop efficient algorithms for detecting only certain classes of predicates [GW94, TG93]. 2 Another approach has been to modify some aspect of the problem|for example, detecting a different modality <ref> [FR97] </ref> or assuming that the system is partially synchronous [MN91, Sto97]. This paper presents an efficient and general approach to detecting Poss . In this approach, the set of CGSs is represented symbolically, using ordered binary decision diagrams. This can be much more efficient than explicit enumeration.
Reference: [GW94] <author> Vijay K. Garg and Brian Waldecker. </author> <title> Detection of weak unstable predicates in distributed programs. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 5(3) </volume> <pages> 299-307, </pages> <year> 1994. </year>
Reference-contexts: This time complexity can be prohibitive, so researchers have sought faster alternatives. One approach has been to restrict the problem and develop efficient algorithms for detecting only certain classes of predicates <ref> [GW94, TG93] </ref>. 2 Another approach has been to modify some aspect of the problem|for example, detecting a different modality [FR97] or assuming that the system is partially synchronous [MN91, Sto97]. This paper presents an efficient and general approach to detecting Poss . <p> So, we restrict attention to consistent global states, i.e., global states through which the system might have passed during the computation. We define consistency for global states in terms of the happened-before relation on local states <ref> [GW94] </ref>. Intuitively, a local state s 1 happened-before a local state s 2 (of the same or a different process) if s 1 finished before s 2 started.
Reference: [JMN95] <author> R. Jegou, R. Medina, and L. Nourine. </author> <title> Linear space algorithm for on-line detection of global predicates. </title> <editor> In J. Desel, editor, </editor> <booktitle> Proc. International Workshop on Structures in Concurrency Theory (STRICT '95), Workshops in Computing. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Any detection algorithm that enumerates all CGSs|whether using the method in [CM91, MN91] or one of the more efficient schemes in <ref> [JMN95, AV97] </ref>|has time complexity that is at least linear in the number of CGSs. This time complexity can be prohibitive, so researchers have sought faster alternatives.
Reference: [Lam78] <author> Leslie Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-564, </pages> <year> 1978. </year>
Reference-contexts: Cooper and Marzullo's solution to this difficulty involves two modalities, which we denote by Poss (read "possibly") and Def (read "definitely") [CM91]. These modalities are based on logical time as embodied in the happened-before relation !, a partial order that reflects causal dependencies <ref> [Lam78] </ref>. A history of an asynchronous distributed system can be approximated by a computation, which comprises the local computation of each process together with the happened-before relation. Happened-before is useful for detection algorithms because, using vector clocks [Mat89], it can be determined by processes in the system.
Reference: [Lyn96] <author> Nancy A. Lynch. </author> <title> Distributed Algorithms. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1996. </year>
Reference-contexts: protocol) when c j= Poss C holds, because DFS-detection halts as soon as it finds a consistent global state satisfying the predicate, and with luck, that can happen early in the search. running time of detection algorithms. 4.3 Spanning Tree The following algorithm constructs a spanning tree in a network <ref> [Lyn96, Section 15.3] </ref>. For convenience, we assume that process 0 always initiates the algorithm and therefore always becomes the root of the spanning tree. Process 0 initiates the algorithm by sending its level in the tree (namely, 0) to each of its neighbors in the network.
Reference: [Mat89] <author> Friedemann Mattern. </author> <title> Virtual time and global states of distributed systems. </title> <editor> In M. Corsnard, editor, </editor> <booktitle> Proc. International Workshop on Parallel and Distributed Algorithms, </booktitle> <pages> pages 120-131. </pages> <publisher> North-Holland, </publisher> <year> 1989. </year>
Reference-contexts: A history of an asynchronous distributed system can be approximated by a computation, which comprises the local computation of each process together with the happened-before relation. Happened-before is useful for detection algorithms because, using vector clocks <ref> [Mat89] </ref>, it can be determined by processes in the system. Happened-before is not a total order, so it does not uniquely determine the history. But it does restrict the possibilities. Histories consistent with a computation are exactly those sequences that correspond to total orders containing the happened-before relation. <p> A global state is consistent iff its constituent local states are pairwise concurrent. Vector timestamps are useful because they capture the happened-before relation <ref> [Mat89] </ref>. Define a partial order on vector timestamps by: v 1 v 2 iff (8p 2 PID : v 1 [p] v 2 [p]).
Reference: [MN91] <author> Keith Marzullo and Gil Neiger. </author> <title> Detection of global state predicates. </title> <booktitle> In Proc. 5th International Workshop on Distributed Algorithms (WDAG '91), volume 579 of Lecture Notes in Computer Science, </booktitle> <pages> pages 254-272. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Any detection algorithm that enumerates all CGSs|whether using the method in <ref> [CM91, MN91] </ref> or one of the more efficient schemes in [JMN95, AV97]|has time complexity that is at least linear in the number of CGSs. This time complexity can be prohibitive, so researchers have sought faster alternatives. <p> One approach has been to restrict the problem and develop efficient algorithms for detecting only certain classes of predicates [GW94, TG93]. 2 Another approach has been to modify some aspect of the problem|for example, detecting a different modality [FR97] or assuming that the system is partially synchronous <ref> [MN91, Sto97] </ref>. This paper presents an efficient and general approach to detecting Poss . In this approach, the set of CGSs is represented symbolically, using ordered binary decision diagrams. This can be much more efficient than explicit enumeration.
Reference: [SMV] <author> SMV. </author> <note> Available via http://www.cs.cmu.edu/ modelcheck/. </note>
Reference-contexts: With this encoding, an OBDD-based model checker, such as SMV <ref> [SMV] </ref>, would represent sets of CGSs as OBDDs, as we do. However, that approach could still differ appreciably in performance from our method, due to different sequences of intermediate BDDs being constructed during the calculation.
Reference: [Sto97] <author> Scott D. Stoller. </author> <title> Detecting global predicates in distributed systems with clocks. </title> <editor> In Marios Mavronikolas, editor, </editor> <booktitle> Proc. 11th International Workshop on Distributed Algorithms (WDAG '97), volume 1320 of Lecture Notes in Computer Science, </booktitle> <pages> pages 185-199. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: One approach has been to restrict the problem and develop efficient algorithms for detecting only certain classes of predicates [GW94, TG93]. 2 Another approach has been to modify some aspect of the problem|for example, detecting a different modality [FR97] or assuming that the system is partially synchronous <ref> [MN91, Sto97] </ref>. This paper presents an efficient and general approach to detecting Poss . In this approach, the set of CGSs is represented symbolically, using ordered binary decision diagrams. This can be much more efficient than explicit enumeration.
Reference: [TG93] <author> Alexander I. Tomlinson and Vijay K. Garg. </author> <title> Detecting relational global predicates in distributed systems. </title> <booktitle> In Proc. ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <year> 1993. </year> <note> Appeared as ACM SIGPLAN Notices 28(12), </note> <month> December </month> <year> 1993. </year> <month> 11 </month>
Reference-contexts: This time complexity can be prohibitive, so researchers have sought faster alternatives. One approach has been to restrict the problem and develop efficient algorithms for detecting only certain classes of predicates <ref> [GW94, TG93] </ref>. 2 Another approach has been to modify some aspect of the problem|for example, detecting a different modality [FR97] or assuming that the system is partially synchronous [MN91, Sto97]. This paper presents an efficient and general approach to detecting Poss .
References-found: 16

