URL: http://osl.cs.uiuc.edu/Papers/rtsem.ps
Refering-URL: http://osl.cs.uiuc.edu/Papers/RT.html
Root-URL: http://www.cs.uiuc.edu
Email: Email: f nielsen j agha g@cs.uiuc.edu  
Title: Semantics for an Actor-Based Real-Time Language  
Author: Brian Nielsen Gul Agha 
Address: 1304 W. Springfield Avenue Urbana, IL 61801, USA  
Affiliation: Department of Computer Science  
Abstract: We give formal semantics for a distributed concurrent object-oriented real-time programming language based on a variant of the actor model which includes an extention enabling the specification of time constraints on message-invocation. Real-time semantics must capture both the qualitative and quantitative aspects of the language, and provide a meaning for the real-time constructs. The real-time semantics of our language is given as timed graph, an existing real-time specification formalism. We present the semantics by first defining an operational semantics for the untimed language, and then translating this into a timed graph which interprets the time constructs. Our semantics is formulated independently of the underlying resources needed to execute a program; the semantics of a program thus defines the set of permissible concrete implementations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Gul Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, Los Alamitos, </publisher> <address> California, </address> <year> 1986. </year> <note> ISBN 0-262-01092-5. </note>
Reference-contexts: We define the semantics in two steps. First, we define the operational semantics for an untimed actor language. We then extend our language with timing constraints and provide its semantics in terms of an existing real-time specification formalism, timed graphs. 2 The Actor Model Actors <ref> [1, 2, 4] </ref> is a model for distributed concurrent computing systems. An actor system is comprised of autonomous objects, called actors, that communicate using asynchronous message passing. Messages that have been sent but not yet received are conceptually queued up in the receiver actor's mailbox. <p> This consists of computing expressions, changing state by assigning to state variables, sending messages or creating new actors. An actor processes one message at a time, i.e., actors are single threaded. After processing a message it is ready to accept the next (queued) message. (In <ref> [1, 2] </ref>, an explicit become-primitive provides a restricted form of multithreading that is possible to represent in our semantics). Send a message: The primitive send (a; cv) sends a message with communication value cv asynchronously to the actor with the address a.
Reference: [2] <author> Gul Agha. </author> <title> Concurrent Object-Oriented Programming. </title> <journal> Communications of the ACM, </journal> <volume> 33(9):125141, </volume> <month> September </month> <year> 1990. </year>
Reference-contexts: We define the semantics in two steps. First, we define the operational semantics for an untimed actor language. We then extend our language with timing constraints and provide its semantics in terms of an existing real-time specification formalism, timed graphs. 2 The Actor Model Actors <ref> [1, 2, 4] </ref> is a model for distributed concurrent computing systems. An actor system is comprised of autonomous objects, called actors, that communicate using asynchronous message passing. Messages that have been sent but not yet received are conceptually queued up in the receiver actor's mailbox. <p> This consists of computing expressions, changing state by assigning to state variables, sending messages or creating new actors. An actor processes one message at a time, i.e., actors are single threaded. After processing a message it is ready to accept the next (queued) message. (In <ref> [1, 2] </ref>, an explicit become-primitive provides a restricted form of multithreading that is possible to represent in our semantics). Send a message: The primitive send (a; cv) sends a message with communication value cv asynchronously to the actor with the address a.
Reference: [3] <author> Gul Agha. </author> <title> The Structure and Semantics of Actor Languages. </title> <editor> In J.W. de Bakker, W.P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Foundations of Object-Oriented Languages, </booktitle> <pages> pages 1 59. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference: [4] <author> Gul Agha, Ian A. Mason, Scott F. Smith, and Carolyn L. Talcott. </author> <title> A Foundation for Actor Computation. </title> <journal> Journal of Functional Programming, </journal> <note> page 68pp, To be published. </note>
Reference-contexts: We define the semantics in two steps. First, we define the operational semantics for an untimed actor language. We then extend our language with timing constraints and provide its semantics in terms of an existing real-time specification formalism, timed graphs. 2 The Actor Model Actors <ref> [1, 2, 4] </ref> is a model for distributed concurrent computing systems. An actor system is comprised of autonomous objects, called actors, that communicate using asynchronous message passing. Messages that have been sent but not yet received are conceptually queued up in the receiver actor's mailbox. <p> Operational semantics define how the state of the system changes when a primitive operation is performed, thus giving an abstract interpretation of the language. The actor semantics presented here is inspired by the work of <ref> [4] </ref>. The state of an actor system is represented by a config-uration. A configuration can be thought of as an instantaneous snapshot of the system state made by a conceptual observer.
Reference: [5] <author> Rajeev Alur, Costas Courcoubetis, and David Dill. </author> <title> Model checking for realtime systems. </title> <booktitle> In Proceedings of the Fifth IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 414 425, </pages> <year> 1990. </year>
Reference-contexts: First, we give our interpretation of timed graphs used the underlying formalism for our semantics. The operational semantics for actors and the timing constructs are then translated into a timed graph. Timed graphs is a real-time specification formalism similar to timed automata, originally proposed by Alur and Dill (see <ref> [5] </ref>), but has no accept states. The graphs we use here are inspired by the ones defined in [11]. 4.1 Timed Graphs A graph consists of nodes and edges, where nodes re-pressent system states, and edges repressent possible actions. <p> A variety of time models and time extensions to traditional specification languages has been proposed and debated. Often, the models take the form of extended automata (Timed automata <ref> [5] </ref>, Timed Graphs [5, 11], or process algebras (Timed CCS and Timed Modal Specifications [9], Timed CSP [15]). Although these are intended as specification languages, and not as programming languages per se, they have served as foundation for our semantics, and have been im-portant sources of inspiration. <p> A variety of time models and time extensions to traditional specification languages has been proposed and debated. Often, the models take the form of extended automata (Timed automata [5], Timed Graphs <ref> [5, 11] </ref>, or process algebras (Timed CCS and Timed Modal Specifications [9], Timed CSP [15]). Although these are intended as specification languages, and not as programming languages per se, they have served as foundation for our semantics, and have been im-portant sources of inspiration.
Reference: [6] <author> G. Berry and L. Cosserat. </author> <title> The ESTEREL Synchronous Programming Language and its Mathematical Semantics. </title> <booktitle> In Lecture Notes in Computer Science, </booktitle> <volume> volume 197, </volume> <pages> pages 389 448. </pages> <publisher> Springer Verlag, </publisher> <year> 1984. </year>
Reference: [7] <author> Azer Bestavros. </author> <title> Specification and Verification of Real-time Embedded Systems using Time-constrained Reactive Automata. </title> <booktitle> In Proc. Real-Time Systems Symposium, </booktitle> <pages> pages 244 253, </pages> <address> San Antonio, TX, USA, 1991. </address> <publisher> IEEE. </publisher>
Reference-contexts: Both, these semantics thus model relative concrete system, rather than being specifications for a set of possible systems, as is our goal. A system in the TRA-formalism (Time Restriced Automata) <ref> [7] </ref>, consists of a set of TRA's communicating by signaling events asynchronously through communication channels. A TRA specification defines timing constraints on causal events on in and output channels. This approach to specifying timing constraints resembles that of our send primitive.
Reference: [8] <author> Richard Gerber and Insup Lee. </author> <title> Communicating Shared Resources: A Model for Distributed Real-Time Systems. </title> <booktitle> In Proc. Real-Time Systems Symposium, </booktitle> <pages> pages 6878, </pages> <address> Santa Monica, CA, USA, 1989. </address> <publisher> IEEE. </publisher>
Reference-contexts: No physical implementation is able to refine such a program. Actors differ from the TRA-model in many other ways. The problem of defining the behavior of a real-time program in the presence of a limited set of shared resources is addressed by the Communicating Shared Resources (CSR) formalism <ref> [8, 13] </ref>. Here, a process always runs on some, possible shared, resource. A set of processes can be mapped to different sets of resources, hence describing different implementations. However, unlike our proposal, one cannot reason about program properties without giving a specific resource model.
Reference: [9] <author> Jens Chr. Godskesen. </author> <title> Timed Modal Specifications. </title> <type> PhD thesis, </type> <institution> Department of Mathematics and Computer Science, Institute for Electronic Systems, Aalborg University, </institution> <month> October </month> <year> 1994. </year>
Reference-contexts: A variety of time models and time extensions to traditional specification languages has been proposed and debated. Often, the models take the form of extended automata (Timed automata [5], Timed Graphs [5, 11], or process algebras (Timed CCS and Timed Modal Specifications <ref> [9] </ref>, Timed CSP [15]). Although these are intended as specification languages, and not as programming languages per se, they have served as foundation for our semantics, and have been im-portant sources of inspiration. Others have defined semantics for real-time languages.
Reference: [10] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall International (UK), </publisher> <year> 1989. </year> <month> 0-13-114984-9. </month>
Reference-contexts: Others have defined semantics for real-time languages. In [14] semantics of a real-time object-oriented language is given by translating programs to RtCCSa version of CCS <ref> [10] </ref> extended with time using explicit tick transitions. The resulting translation includes an abstract model of the execution environment (number of CPU's, scheduler, execution time). Similarly the semantics presented in [16] assumes knowledge about excution time of assignments and assumes a CPU for each process.
Reference: [11] <author> Xavier Nicollin, Joseph Sifakis, and Sergio Yovine. </author> <title> Compiling Real-Time Specifications into Extended Automata. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(9):805 816, </volume> <month> September </month> <year> 1992. </year>
Reference-contexts: Timed graphs is a real-time specification formalism similar to timed automata, originally proposed by Alur and Dill (see [5]), but has no accept states. The graphs we use here are inspired by the ones defined in <ref> [11] </ref>. 4.1 Timed Graphs A graph consists of nodes and edges, where nodes re-pressent system states, and edges repressent possible actions. Timed graphs are equipped with a set of clocks and an enabling condition for each edge (transition). <p> A variety of time models and time extensions to traditional specification languages has been proposed and debated. Often, the models take the form of extended automata (Timed automata [5], Timed Graphs <ref> [5, 11] </ref>, or process algebras (Timed CCS and Timed Modal Specifications [9], Timed CSP [15]). Although these are intended as specification languages, and not as programming languages per se, they have served as foundation for our semantics, and have been im-portant sources of inspiration.
Reference: [12] <author> Shangping Ren and Gul Agha. RT-Synchronizer: </author> <title> Language Support for Real-Time Specifications in Distributed Systems. </title> <journal> ACM Sigplan Notices, </journal> <volume> 30(11), </volume> <month> November </month> <year> 1995. </year> <booktitle> Proceedings of the ACM Sigplan 1995 Workshop on Languages, Compilers, and Tools for Real-Time Systems. </booktitle>
Reference-contexts: Our work will set the foundation for semantics for a considerably more complex language <ref> [12] </ref>. Our primary objective is to formulate the semantics of a real-time program independently of the resources (number of CPUs, network topology, speed, etc.) needed to execute it.
Reference: [13] <author> Richard Gerber and Insup Lee. </author> <title> A Layered Approach to Automating the Verification of Real-Time Systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(9):768 784, </volume> <month> September </month> <year> 1992. </year>
Reference-contexts: No physical implementation is able to refine such a program. Actors differ from the TRA-model in many other ways. The problem of defining the behavior of a real-time program in the presence of a limited set of shared resources is addressed by the Communicating Shared Resources (CSR) formalism <ref> [8, 13] </ref>. Here, a process always runs on some, possible shared, resource. A set of processes can be mapped to different sets of resources, hence describing different implementations. However, unlike our proposal, one cannot reason about program properties without giving a specific resource model.
Reference: [14] <author> Ichiro Satoh and Mario Tokoro. </author> <title> Semantics for a Real-Time Object-Oriented Programming Language. </title> <booktitle> In Int. Conf. on Computer Languages, </booktitle> <pages> pages 159170, </pages> <address> Toulouse, France, 1994. </address> <publisher> IEEE. </publisher>
Reference-contexts: Although these are intended as specification languages, and not as programming languages per se, they have served as foundation for our semantics, and have been im-portant sources of inspiration. Others have defined semantics for real-time languages. In <ref> [14] </ref> semantics of a real-time object-oriented language is given by translating programs to RtCCSa version of CCS [10] extended with time using explicit tick transitions. The resulting translation includes an abstract model of the execution environment (number of CPU's, scheduler, execution time).
Reference: [15] <author> Steve Schneider. </author> <title> An Operational Semantics for Timed CSP. </title> <type> Tech. Report TR-1-91, </type> <institution> Oxford University, </institution> <month> February </month> <year> 1991. </year>
Reference-contexts: A variety of time models and time extensions to traditional specification languages has been proposed and debated. Often, the models take the form of extended automata (Timed automata [5], Timed Graphs [5, 11], or process algebras (Timed CCS and Timed Modal Specifications [9], Timed CSP <ref> [15] </ref>). Although these are intended as specification languages, and not as programming languages per se, they have served as foundation for our semantics, and have been im-portant sources of inspiration. Others have defined semantics for real-time languages.
Reference: [16] <author> P. Zhou and J. Hooman. </author> <title> A Proof Theory for Asynchronously Communicating Real-Time Systems. </title> <booktitle> In Proc. Real-Time Systems Symposium, </booktitle> <pages> pages 177186, </pages> <address> Phoenix, AZ, USA, 1992. </address> <publisher> IEEE. </publisher>
Reference-contexts: In [14] semantics of a real-time object-oriented language is given by translating programs to RtCCSa version of CCS [10] extended with time using explicit tick transitions. The resulting translation includes an abstract model of the execution environment (number of CPU's, scheduler, execution time). Similarly the semantics presented in <ref> [16] </ref> assumes knowledge about excution time of assignments and assumes a CPU for each process. Both, these semantics thus model relative concrete system, rather than being specifications for a set of possible systems, as is our goal.
References-found: 16

