URL: http://www.cs.uoregon.edu/paracomp/proj/tau/tau-ppuc.ps.gz
Refering-URL: http://www.cs.uoregon.edu/paracomp/proj/tau/papers.html
Root-URL: http://www.cs.uoregon.edu
Email: fmohr,malony,cunyg@cs.uoregon.edu  
Title: Chapter 1  Tuning and Analysis Utilities for Portable Parallel Programming  
Author: Tau Bernd Mohr, Allen D. Malony, Janice E. Cuny 
Note: This research is supported by ARPA under Rome Labs contract AF 30602-92-C-0135 and Fort Huachuca contract ARMY DABT63-94-C-0029, and in part by the National Science Foundation under grant NSF ASC92-13500, by a grant from OACIS, and by IBM R&D contract MHVU3704.  
Web: http://www.cs.uoregon.edu/paracomp/tau  
Date: October 27, 1995  
Abstract-found: 0
Intro-found: 0
Reference: [1] <author> Vikram S. Adve, John Mellor-Crummey, Mark Anderson, Ken Kennedy, Jhy-Chun Wang, and Daniel A. Reed. </author> <title> An Integrated Compilation and Performance Analysis Environment for Data Parallel Programs. </title> <booktitle> In Proceedings of Supercomputing'95, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: The current implementation of pC++ does not optimize aggressively, but as the next generation parallel C++ language system, HPC++, is developed, t will have to provide more assistance in maintaining the source/execution correspondence. Our approach will be similar to that of <ref> [1] </ref>, in which the compiler provides performance tools with extensive information on the mapping between source and SPMD codes.
Reference: [2] <author> Alfred Arnold, Ulrich Deter, and Wolfgang E. Nagel. </author> <title> Performance Optimization of Parallel Programs: Tracing, Zooming, Understanding. </title> <editor> In Bob Winget and Karen Winget, editors, </editor> <booktitle> Proceedings Cray User Group Meeting, Spring 1995, </booktitle> <pages> pages 252-258, </pages> <address> Denver, Colorado, </address> <month> March </month> <year> 1995. </year>
Reference-contexts: The program and performance analysis environment is shown in the bottom right corner of Figure 1.1. It includes the t toolset, instrumentation, profiling, tracing, and breakpointing support, and interfaces to performance analysis tools developed by other groups <ref> [5, 8, 2, 12] </ref>. The t tools are described in more detail in Section 1.4. 1.3.2 TAU Implementation The t architecture defines how the tools interoperate and fit into the pC++ programming system. This section discusses two components of t that support this: global features and well-defined internal tool interfaces. <p> The instrumentation required by tracing is implemented in the same way as profiling instrumentation. We have also implemented several utilities for merging event traces, for converting them to other formats, such as PARvis's PV <ref> [2] </ref>, Pablo's SDDF [12], or Upshot's ALOG [5], and for analyzing and visualizing traces using the Simple environment or other tools based on the Tdl/Poet interface [8]. Easy (Event And State displaY) is an Upshot-like event and state display tool.
Reference: [3] <author> Francois Bodin, Pete Beckman, Dennis Gannon, Jake Gotwals, S. Narayana, Suvas Srinivas, and Beata Winnicka. Sage++: </author> <title> An Object Oriented Toolkit and Class Library for Building Fortran and C++ Restructuring Tools. </title> <editor> In ???, editor, </editor> <booktitle> Proceedings OONSKI '94. </booktitle> ???, <year> 1994. </year>
Reference-contexts: The most difficult challenges during the development of t were to determine what low-level instrumentation was needed to capture high-level execution abstractions, and how to translate performance data back to the application and language level. Integrate with compilers and runtime systems. t uses the Sage++ toolkit <ref> [3] </ref> as an interface to the pC++ compiler for instrumentation and accessing properties of program objects. t is also integrated with the runtime system of pC++ for profiling and tracing support. Enable portability, extensibility, and retargetability.
Reference: [4] <author> Darryl Brown, Allen Malony, and Bernd Mohr. </author> <title> Language-based Parallel Program Interaction: the Breezy Approach. </title> <booktitle> In Proceedings of the International Conference on High Performance Computing (HiPC'95), </booktitle> <address> New Delhi, India, </address> <month> December </month> <year> 1995. </year> <booktitle> IEEE Computer Society, </booktitle> <publisher> Tata McGraw-Hill. </publisher>
Reference-contexts: A particular event or state can be examined by clicking on the corresponding graphical object. States are displayed in such a way that they show when states are nested. Barrier Breakpoint Debugging An extended version of this section was previously published in <ref> [4] </ref>. 16 CHAPTER 1. TAU EC BASIC Basic runtime events like begin and end of the whole pro gram and the user's main function. EC KERNEL Creation and deletion of collections, collection element access. <p> Events of this class are automatically inserted by the pC++ instrumentor. EC USER1 EC USER4 Available to the user for manually inserted event recording calls. Table 1.1: pC++ Event Classes We have developed a program interaction system for pC++ called Breezy (BReakpoint Executive Environment for visualiZation and data DisplaY) <ref> [4] </ref>. Breezy provides the infrastructure for a client application to attach to a pC++ application at runtime.
Reference: [5] <author> V. Herrarte and E. Lusk. </author> <title> Studying Parallel Program Behavior with Upshot. </title> <type> Technical Report ANL-91/15, </type> <institution> Mathematics and Computer Science Division, Argonne National Laboratory, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: The program and performance analysis environment is shown in the bottom right corner of Figure 1.1. It includes the t toolset, instrumentation, profiling, tracing, and breakpointing support, and interfaces to performance analysis tools developed by other groups <ref> [5, 8, 2, 12] </ref>. The t tools are described in more detail in Section 1.4. 1.3.2 TAU Implementation The t architecture defines how the tools interoperate and fit into the pC++ programming system. This section discusses two components of t that support this: global features and well-defined internal tool interfaces. <p> The instrumentation required by tracing is implemented in the same way as profiling instrumentation. We have also implemented several utilities for merging event traces, for converting them to other formats, such as PARvis's PV [2], Pablo's SDDF [12], or Upshot's ALOG <ref> [5] </ref>, and for analyzing and visualizing traces using the Simple environment or other tools based on the Tdl/Poet interface [8]. Easy (Event And State displaY) is an Upshot-like event and state display tool.
Reference: [6] <author> Joydip Kundu and Janice E. Cuny. </author> <title> The Integration of Event- and State-Based Debugging in Ariadne. </title> <editor> In Constantine Polychronopoulos, editor, </editor> <booktitle> Proceedings of the 1995 International Conference on Parallel Processing (ICPP), </booktitle> <pages> pages 130-134. </pages> <publisher> CRC Press, </publisher> <month> August </month> <year> 1995. </year>
Reference-contexts: Programs with complex inter-process interactions will require a multilevel debugging strategy, in which event-based techniques are initially used to find gross patterns of process interactions, and state-based techniques predominate after the focus of attention has been narrowed to a single process or small set of processes <ref> [6] </ref>. Initial use of event-based techniques focuses the user's attention on manageable portions of the state space and provides the basis for establishing consistent, meaningful, global breakpoints. Event-based techniques can incorporate replay mechanisms that support reproducible execution and logical time transformations to filter out perturbations due to asynchrony. <p> Our current prototype demonstrates that this interaction can be quite powerful: it allows the user to set consistent breakpoints that are meaningful in the context of her ongoing event-based analysis. Often, these breakpoints would have been difficult or even impossible to set with conventional mechanisms <ref> [6] </ref>. 1.7. CONCLUSION AND FUTURE WORK 39 We will need to develop appropriate abstractions to include event-based tools in our environment. Most existing tools operate at a very low level, basing their models on explicit read and write operations that are not meaningful to the pC++ or HPF programmer.
Reference: [7] <author> Allen Malony, Bernd Mohr, Pete Beckman, Dennis Gannon, Shelby Yang, and Francois Bodin. </author> <title> Performance Analysis of pC++: A Portable 41 42 BIBLIOGRAPHY Data-Parallel Programming System for Scalable Parallel Computers. </title> <editor> In Howard Jay Siegel, editor, </editor> <booktitle> Proceedings of the 8th International Parallel Processing Symbosium (IPPS), </booktitle> <pages> pages 75-85, </pages> <address> Cancun, Mexico, April 1994. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: These are supported by an execution profile data browser called Racy, an event trace browser called Easy, and a barrier breakpoint debugger called Breezy. Program Instrumentation An earlier version of this section was published in <ref> [7] </ref>. All three analysis modes use instrumentation to capture runtime data. The program transformations needed for this are done at the language level to ensure portability. One problem this approach faces is to ensure that code to profile function exits is executed as late as possible. <p> A bar graph shows the percentage of collection accesses that were local or remote. By clicking on the collection name, the user can get a per-node profile of this data. (Figure 1.17). Event Tracing for pC++ Some of this material was previously published in <ref> [7] </ref>. In addition to profiling, we have implemented a system for tracing pC++ program events. Events are stored in a buffer on each node, which is written to disk when it is full or when the program ends.
Reference: [8] <author> Bernd Mohr. </author> <title> Standardization of Event Traces Considered Harmful or Is an Implementation of Object-Independent Event Trace Monitoring and Analysis Systems Possible? In J. </title> <editor> J. Dongarra and B. Tourancheau, editors, </editor> <booktitle> Proceedings of the CNRS-NSF Workshop on Environments and Tools For Parallel Scientific Computing, volume 6 of Advances in Parallel Computing, </booktitle> <pages> pages 103-24. </pages> <publisher> Elsevier, </publisher> <month> September </month> <year> 1992. </year>
Reference-contexts: The program and performance analysis environment is shown in the bottom right corner of Figure 1.1. It includes the t toolset, instrumentation, profiling, tracing, and breakpointing support, and interfaces to performance analysis tools developed by other groups <ref> [5, 8, 2, 12] </ref>. The t tools are described in more detail in Section 1.4. 1.3.2 TAU Implementation The t architecture defines how the tools interoperate and fit into the pC++ programming system. This section discusses two components of t that support this: global features and well-defined internal tool interfaces. <p> We have also implemented several utilities for merging event traces, for converting them to other formats, such as PARvis's PV [2], Pablo's SDDF [12], or Upshot's ALOG [5], and for analyzing and visualizing traces using the Simple environment or other tools based on the Tdl/Poet interface <ref> [8] </ref>. Easy (Event And State displaY) is an Upshot-like event and state display tool. It displays states and events on an X-Y graph, allowing more detailed access to event data when necessary. The Y axis shows individual processors, while the X axis shows elapsed time.
Reference: [9] <author> Bernd Mohr, Darryl Brown, and Allen Malony. </author> <title> TAU: A Portable Parallel Program Analysis Environment for pC++. </title> <editor> In Bruno Buch-berger and Jens Volkert, editors, </editor> <booktitle> Proceedings of CONPAR 94-VAPP VI, volume 854 of Lecture Notes in Computer Science, </booktitle> <pages> pages 29-40. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1994. </year>
Reference-contexts: A critique of its current state is given in Section 1.6. Section 1.7 discusses future development of t, particularly its extension to other parallel language environments and the incorporation of more sophisticated tools. 1.2 Design Requirements and Goals An earlier version of this material was published in <ref> [9] </ref>. t was designed to improve parallel programming productivity by combining advances in parallel debugging, performance evaluation, and program visualization tools. We feel that the requirements the design and the tools had to address are common to next-generation parallel programming environments, and include: Give a user (program-level) view. <p> However, this cannot be fully realized unless tools can leverage other programming system technologies (e.g., use the compiler to implement instrumentation). 1.3 TAU Overview Parts of this material (Section 1.3 and Section 1.3.1) were pre viously published in <ref> [9] </ref>. The t architecture defines how its components interoperate and fit in the pC++ language system. Below, we describe the t design and show how it addresses the programming productivity requirements of pC++. t is not a general solution to the problem of parallel program analysis. <p> As t was designed to support extensions to the toolset, new tools are continually being developed and incorporated into the t architecture. 1.4.1 Static Analysis Tools An earlier version of this material was previously published in <ref> [9] </ref>. This material has been updated where tool features have changed or new tool features added. A major motivation for using C++ as the base for new parallel languages is its ability to support develoment and maintenance of large, complex applications. <p> Classy also allows 1.4. TAU TOOLS 13 quick access to key properties of a class, such as data members. Finally, Classy marks collections by putting the string "k" before their names. 1.4.2 Dynamic Analysis Tools An earlier version of this material was published in <ref> [9] </ref>.
Reference: [10] <author> Object Management Group. </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <note> Version 1.2 edition, </note> <month> December </month> <year> 1993. </year>
Reference-contexts: Important features of Breezy are: * Its modular design allows for component re-use and clean substitution of new technologies (such as replacing the transport layer with CORBA/IDL <ref> [10] </ref>). * It allows the programmer to make functions available for calling by the 18 CHAPTER 1. TAU client, giving the client the power to alter the course of the program or perform specific computations.
Reference: [11] <author> John Ousterhout. </author> <title> Tcl and the Tk Toolkit. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Enable portability, extensibility, and retargetability. We implemented t in C++ and C to ensure an efficient, portable, and reusable implementation. The same reasoning led us to use Tcl/Tk <ref> [11] </ref> for our graphical interface. The t tools are implemented as graphical hypertools. While each is distinct, they act in concert like a single application.
Reference: [12] <author> D. A. Reed, R. D. Olson, R. A. Aydt, T. M. Madhyasta, T. Birkett, D. W. Jensen, A. A. Nazief, and B. K. Totty. </author> <title> Scalable Performance Environments for Parallel Systems. </title> <booktitle> In Proceedings of the 6th Distributed Memory Computing Conference, </booktitle> <pages> pages 562-69. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: The program and performance analysis environment is shown in the bottom right corner of Figure 1.1. It includes the t toolset, instrumentation, profiling, tracing, and breakpointing support, and interfaces to performance analysis tools developed by other groups <ref> [5, 8, 2, 12] </ref>. The t tools are described in more detail in Section 1.4. 1.3.2 TAU Implementation The t architecture defines how the tools interoperate and fit into the pC++ programming system. This section discusses two components of t that support this: global features and well-defined internal tool interfaces. <p> The instrumentation required by tracing is implemented in the same way as profiling instrumentation. We have also implemented several utilities for merging event traces, for converting them to other formats, such as PARvis's PV [2], Pablo's SDDF <ref> [12] </ref>, or Upshot's ALOG [5], and for analyzing and visualizing traces using the Simple environment or other tools based on the Tdl/Poet interface [8]. Easy (Event And State displaY) is an Upshot-like event and state display tool.
Reference: [13] <author> Kesavan Shanmugam. </author> <title> Performance Extrapolation of Parallel Programs. </title> <type> Master's thesis, </type> <institution> University of Oregon, Department of Computer and Information Science, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: A trace-driven simulation attempts to model such features and predict when events would have occurred in a real n-processor execution environment. These extrapolated trace files are then used to obtain performance metrics for the pC++ program. The technique is depicted in Figure 1.5, and described in more detail in <ref> [13, 14, 16] </ref>. ExtraP uses pC++'s built-in event tracing system to generate the traces needed for the simulation. These traces can be analyzed using t's event trace browsers, and compared and validated against traces from real parallel executions.
Reference: [14] <author> Kesavan Shanmugam, Allen Malony, and Bernd Mohr. </author> <title> Performance Extrapolation of Parallel Programs. </title> <type> Technical Report CIS-TR-95-14, </type> <institution> University of Oregon, Department of Computer and Information Science, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: A trace-driven simulation attempts to model such features and predict when events would have occurred in a real n-processor execution environment. These extrapolated trace files are then used to obtain performance metrics for the pC++ program. The technique is depicted in Figure 1.5, and described in more detail in <ref> [13, 14, 16] </ref>. ExtraP uses pC++'s built-in event tracing system to generate the traces needed for the simulation. These traces can be analyzed using t's event trace browsers, and compared and validated against traces from real parallel executions.
Reference: [15] <author> Kesavan Shanmugam, Allen Malony, and Bernd Mohr. Speedy: </author> <title> An Integrated Performance Extrapolation Tool for pC++ Programs. </title> <booktitle> In Proceedings of the Joint Conference PERFORMANCE TOOLS'95 and MMB'95, </booktitle> <month> September </month> <year> 1995. </year> <note> BIBLIOGRAPHY 43 </note>
Reference-contexts: Also, it means that a new implementation of Breezy is not required for each new architecture; because Breezy is implemented using the language, it runs everywhere the language does. 1.4.3 Performance Extrapolation for pC++ An extended version of this section was previously published in <ref> [15] </ref>. The dynamic analysis tools already discussed enable users to investigate the execution behavior of pC++ programs. However, because pC++ programs are portable, users may want to develop and analyze programs that will run across platforms or that will run in environments different from the development environment. <p> To support this type of program analysis, we implemented a performance extrapolation system for pC++ called Ex-traP, that has been integrated into t in the guise of the Speedy tool <ref> [15] </ref>. The ExtraP/Speedy combination allows users to predict the performance of pC++ programs in target execution environments. The technique that we developed extrapolates the performance of a n-thread pC++ program from a 1-processor execution to a n-processor execution.
Reference: [16] <author> Shanmugam, Kesavan and Malony, Allen. </author> <title> Performance Extrapolation of Parallel Programs. </title> <editor> In Constantine Polychronopoulos, editor, </editor> <booktitle> Proceedings of the 1995 International Conference on Parallel Processing (ICPP), volume II Software, </booktitle> <pages> pages 117-20. </pages> <publisher> CRC Press, </publisher> <month> August </month> <year> 1995. </year>
Reference-contexts: A trace-driven simulation attempts to model such features and predict when events would have occurred in a real n-processor execution environment. These extrapolated trace files are then used to obtain performance metrics for the pC++ program. The technique is depicted in Figure 1.5, and described in more detail in <ref> [13, 14, 16] </ref>. ExtraP uses pC++'s built-in event tracing system to generate the traces needed for the simulation. These traces can be analyzed using t's event trace browsers, and compared and validated against traces from real parallel executions.
References-found: 16

