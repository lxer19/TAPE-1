URL: http://www.cs.brandeis.edu/~grath/gnupages/obst/tclOBST.ps
Refering-URL: http://www.cs.brandeis.edu/~grath/gnupages/obst/index.html
Root-URL: http://www.cs.brandeis.edu
Title: STONE A Structured and Open Environment  
Abstract: Title: The Design of a Tcl Interface to OBST Author: Dietmar Theobald Date: 16/12/94 Result #: FZI.47.7 Status: finished Distribution: public Address: Forschungszentrum Informatik Haid-und-Neu-Str. 10-14 D-76131 Karlsruhe Germany ---theobald,dbs@fzi.de 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. Casais, M. Ranft, B. Schiefer, D. Theobald, W. Zimmer, </author> <title> "OBST An Overview," </title> <type> Tech. Rep. </type> <institution> FZI.039.1, Forschungszentrum Informatik (FZI), Karlsruhe, Germany, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: Design Overview This section introduces the OBST system and the interactive tools formerly provided by the OBST environment. It contains the design rationale of the Tcl interface and gives an overview of its architecture. 1.1 Introduction 1.1.1 The OBST System OBST, the Object Management System of STONE <ref> [1] </ref>, is an object-oriented database system developed as a core component of the STONE environment [2]. STONE, a Structured and Open Environment, aims at the development of an open software engineering environment for the educational domain. OBST is going to serve as the persistent store of a STONE environment. <p> This last list did already hint at some important constituents of the environment of an OBST application. OBST itself is targeted at UNIX workstations, connected via a LAN and a network file system <ref> [1] </ref>, and the prime implementation language for OBST applications is C ++ . Furthermore, some tools designed around OBST are built on top of the X windows system [6].
Reference: [2] <author> C. Lewerentz, E. Casais, "STONE: </author> <title> A Short Overview," </title> <type> Tech. Rep. </type> <institution> FZI.040.1, Forschungszentrum Informatik (FZI), Karlsruhe, Germany, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: It contains the design rationale of the Tcl interface and gives an overview of its architecture. 1.1 Introduction 1.1.1 The OBST System OBST, the Object Management System of STONE [1], is an object-oriented database system developed as a core component of the STONE environment <ref> [2] </ref>. STONE, a Structured and Open Environment, aims at the development of an open software engineering environment for the educational domain. OBST is going to serve as the persistent store of a STONE environment. <p> is the name of the method, paramno the number of parameters including all default arguments, resulttp holds an encoding of the result type, paramtps [0..paramno-1] encodes the parameter types, and refparams [] is either NULL, or a 1 terminated array of ascending indices denoting reference parameters (i.e. parameter number refparams <ref> [2] </ref> is the third reference parameter).
Reference: [3] <author> J. Uhl, D. Theobald, B. Schiefer, M. Ranft, W. Zimmer, J. Alt, </author> <title> "The Object Management System of STONE OBST Release 3.4," </title> <type> Tech. Rep. </type> <institution> FZI.027.5, Forschungszentrum Informatik (FZI), Karlsruhe, Germany, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: OBST is going to serve as the persistent store of a STONE environment. OBST features an object-oriented data model which supports the common core concepts found in major object-oriented languages <ref> [3] </ref>. OBST does not define a new or enhance a specific object-oriented programming language. Instead, embeddings are provided into the host languages of interest. Currently, an embedding into C ++ [4] is supported. <p> These are listed in section 2.2.3 and not repeated elsewhere. 2.1 What is going to be interfaced to C? Before presenting the C interface in more detail, it is about time to take a closer look at the OBST data model as defined in <ref> [3] </ref>. An overview of the hierarchy of OBST types is depicted in Figure 2. 2.1.1 Scalar Types OBST features a hybrid data model: objects of scalar types correspond to what is called values in some object-oriented languages. <p> Therefore, the C interface must first provide appropriate definitions for the representation of scalar types in the programming language C, 11 and secondly provide access to the conversion operations. As noted above, OBST treats scalar types as implicit subtypes of the class sosScalarobject (3) <ref> [3] </ref>. It is therefore possible to invoke the methods of sosScalarobject on a scalar value in its object representation and the C interface must provide this facility, too. 2.1.2 Class Types Classes are user-defined types comprising structural and behavioral properties which are common to all instances of a class. <p> We can exploit here that OBST does not distinguish between a volatile main memory representation of an object and the persistent representation on disk. Instead, all references to the state of an object are performed by accessing the disk via methods automatically generated by the OBST schema compiler <ref> [3] </ref>. An OBST object in main memory is actually just a handle mainly made up of the object identifier (OID). Two important implications of this are: We can concentrate on providing access to methods, since any solution to this problem does automatically provide access to an object's attributes, too. <p> This involves a potential problem, since the OBST data model has no globally unique type names. Instead, type names must be unique with respect to the schema the type is defined in, as well as any (transitively) imported schemas <ref> [3] </ref>. It is perfectly legal to define equally named types in two different schemas, iff these schemas are not related to each other via the schema import relation. <p> By generating enumeration type definitions and requiring a schema implementor to provide definitions for external types, the C interface would become a C language binding, albeit a generic one compared to the standard C ++ binding of OBST <ref> [3] </ref>. That means that the C binding would then still lack the possibility to write method implementations in C. 10 2.2.2.2 Converting Scalars The C ++ language binding of OBST requires the schema implementor to provide two conversion functions for each external type [3] which convert the programming language representation into <p> the standard C ++ binding of OBST <ref> [3] </ref>. That means that the C binding would then still lack the possibility to write method implementations in C. 10 2.2.2.2 Converting Scalars The C ++ language binding of OBST requires the schema implementor to provide two conversion functions for each external type [3] which convert the programming language representation into a standard format used internally by OBST (see 2.1.1). <p> The actual type of *sptr must be int in case of an enumeration type. It is up to the caller to destroy the string returned by obstscalar2string, and obstobject2string, respectively. 2.3.2.2.1 Controlling Memory Usage As noted in the description of the C ++ mapping of external types in <ref> [3] </ref>, there is an inherent problem with the above mentioned string conversions for some external types, in particular sosCstring, in that these conversion operations can only be safely written if they allocate memory while performing the conversion. <p> Specific conversion operations are denoted by enumerators. Using the operation names required by the C ++ language binding of OBST, they refer to makestpobjectfromstring (cvtString2Object), and makestringfromstpobject (cvtString2Object), respectively <ref> [3] </ref>. 52 Note, that any converter definitions will be dropped when obstsetschemas is called (see 2.2.1.4). 2.3.3 Methods 2.3.3.1 Calling Methods As mentioned in section 2.2.1.2, there is a varargs (3) (respectively stdarg (3)) interface to the method call routines, which is more handy than the interface described before, if not <p> The Tcl interface is built entirely on top of the C interface. Its implementation makes heavy use of the reflexive capabilities of OBST. The realization of such an interface supports the claim in <ref> [3] </ref> that the OBST data model is language independent in that a mapping into even a non object-oriented language could be provided.
Reference: [4] <author> M. A. Ellis, B. Stroustrup, </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: OBST features an object-oriented data model which supports the common core concepts found in major object-oriented languages [3]. OBST does not define a new or enhance a specific object-oriented programming language. Instead, embeddings are provided into the host languages of interest. Currently, an embedding into C ++ <ref> [4] </ref> is supported. An important feature of OBST is that the system maintains a description of the types of all objects, kept in the so-called meta database. The meta database is actually no separate database at all. <p> definition for the external type sosInt defined in the basic OBST library. 12 Slots, instance variables, or attributes, as they are called in other object-oriented languages. 13 The call of non-public methods must be located within the implementation of another method of the respective class or one of its subclasses <ref> [4] </ref>. 14 It is up to a language binding how reference parameters are implemented: e.g. by 'call by reference' in the C ++ binding and by 'call by value/result' in tclOBST (see 3.2.1). 15 and thereby also as the types of components (cf. 2.1.2). 5 provide error handling facilities, provide tracing
Reference: [5] <author> C. Schurmann, </author> <title> "How to use the OShell in STONE," </title> <type> Tech. Rep. </type> <institution> FZI.048.0, Forschungszentrum Informatik (FZI), Karlsruhe, Germany, </institution> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: The GShell is an interactive object inspector which makes it possible to traverse the object graph stored in an OBST database, to examine the contents of objects, and to invoke publicly visible methods on those objects. The OShell <ref> [5] </ref> is an interactive interpreter for an object-oriented command language based on the lambda calculus. In addition to providing access to the usual OBST functionality e.g. creation of objects and invocation of methods it provides a set of predefined functions and procedural constructs. <p> standard 51 The described solution somewhat reminds of the approach taken in the OShell, though that approach is even more general: it is there possible to define not just conversion operations but general methods for objects of external types and external values are treated like objects at the user interface <ref> [5] </ref>. 52 It is also possible to define string converters for enumeration types where the mentioned make . . . operations are not automatically generated by the OBST C ++ binding. 53 Note, that the facility described here provides currently no means to associate new methods with a class.
Reference: [6] <author> A. Nye, ed., </author> <title> Xlib Reference Manual. </title> <publisher> O'Reilly & Associates, Inc. </publisher>
Reference-contexts: OBST itself is targeted at UNIX workstations, connected via a LAN and a network file system [1], and the prime implementation language for OBST applications is C ++ . Furthermore, some tools designed around OBST are built on top of the X windows system <ref> [6] </ref>. Besides X11 based tools, one must take into account UNIX shells and tools with textual command languages, such as emacs, when thinking of interactive UNIX applications.
Reference: [7] <author> J. K. Ousterhout, </author> <title> "Tcl: An Embeddable Command Language," </title> <booktitle> in Proc. Winter USENIX Conference, </booktitle> <pages> pp. 133-146, </pages> <year> 1990. </year>
Reference-contexts: Tcl is as well an embeddable textual command language as an interpreter for that language <ref> [7] </ref>. Tcl was designed for interactive applications which are to use Tcl as the basis for their command languages. It consists of a library package providing the Tcl parser, command handler, and a set of built-in commands.
Reference: [8] <author> B. W. Kernighan, D. M. Ritchie, </author> <title> The C Programming Language. </title> <publisher> Prentice Hall, 2nd ed. </publisher>
Reference-contexts: It consists of a library package providing the Tcl parser, command handler, and a set of built-in commands. That predefined set of commands can be augmented with application-specific commands which will then be treated like any other built-in command. Tcl itself is written in C <ref> [8] </ref>, and any added command must at least provide a C call interface. These add-on commands can be made known to a Tcl interpreter at any time. There can be several active Tcl interpreters within an application program; one of those is selected when handing over a command for evaluation.
Reference: [9] <author> J. K. Ousterhout, </author> <title> "An X11 Toolkit based on the Tcl Language," </title> <booktitle> in Proc. Winter USENIX Conference, </booktitle> <pages> pp. 105-115, </pages> <year> 1991. </year>
Reference-contexts: Currently, there are a rapidly growing number of Tcl extensions. In particular, there are extensions for invoking Tcl commands remotely in other processes and a X11 toolkit called Tk <ref> [9] </ref> which covers roughly the same functionality as the standard toolkit Xt [10]. Tcl was chosen as the basis for the interactive access facility for OBST because Tcl fulfills most requirements listed in the preceding section.
Reference: [10] <author> T. O'Reilly, ed., </author> <title> X Toolkit Intrinsics Reference Manual. </title> <publisher> O'Reilly & Associates, Inc. </publisher>
Reference-contexts: Currently, there are a rapidly growing number of Tcl extensions. In particular, there are extensions for invoking Tcl commands remotely in other processes and a X11 toolkit called Tk [9] which covers roughly the same functionality as the standard toolkit Xt <ref> [10] </ref>. Tcl was chosen as the basis for the interactive access facility for OBST because Tcl fulfills most requirements listed in the preceding section. Experience suggests that Tcl provides the required programming capabilities and serves well as glue between independent functional extensions.
Reference: [11] <author> B. Schiefer, D. Theobald, J. Uhl, </author> <title> "User's Guide OBST Release 3.4," </title> <type> Tech. Rep. </type> <institution> FZI.032.6, Forschungszentrum Informatik (FZI), Karlsruhe, Germany, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: This can be done either statically, or deferred until the first instance of such a class is accessed by exploiting the incremental loading facilities of OBST <ref> [11] </ref>. 3 Separating the problem of accessing OBST from within a C program from the embedding into Tcl increases the maintainability of the interface implementation. 9 Moreover, the C interface is useful in its own respect: besides its use in C programs, it can also serve as a didactical example of <p> According to 2.2.4, the main () routine must be compiled with a C ++ compiler. Since the initialization operations are to be called immediately after entering main () <ref> [11] </ref>, there is no need to call them from within C code. Finally, most of the auxiliary operations are seen as internal and hence do not have to be exported via the C interface.
Reference: [12] <author> A. Goldberg, D. Robson, </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year> <month> 39 </month>
Reference-contexts: [mcall] obj method arg... mcall class::method arg... and the initial mcall may be omitted in case of instance methods iff the object encoding is bound to the mcall command handler (see 3.2.2). 75 Note, that these correspond to the does not understand type of errors in a smalltalk like environment <ref> [12] </ref> and will typically lead to a ...:core dumped like action in case of a compiled language such as C ++ . 76 When an error occurs, the Tcl command handler unwinds its procedure stack while adding a stack trace to errorInfo, and any Tcl commands which evaluate other Tcl commands <p> However, there is a more fundamental difference which does not immediately emerge: the C code is to a large part fully dynamically typed, 91 but C programs lack the programming environment which makes dynamically typed programming systems practically usable. 92 Compared to e.g. smalltalk <ref> [12] </ref> and C ++ , the C interface in a way represents the worst of both worlds considering its use as a programming environment.
References-found: 12

