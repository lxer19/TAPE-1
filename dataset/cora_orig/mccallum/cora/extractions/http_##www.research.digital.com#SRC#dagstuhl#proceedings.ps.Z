URL: http://www.research.digital.com/SRC/dagstuhl/proceedings.ps.Z
Refering-URL: http://www.research.digital.com/SRC/dagstuhl/dagstuhl.html
Root-URL: http://www.research.digital.com
Title: A TLA Solution to the RPC-Memory Specification Problem  
Author: Martn Abadi Leslie Lamport and Stephan Merz 
Note: Table of Contents  
Affiliation: 1 Systems Research Center, Digital Equipment Corporation 2 Institut fur Informatik, Technische Universitat Munchen  
Abstract: We present a complete solution to the Broy-Lamport specification problem. Our specifications are written in TLA + , a formal language based on TLA. We give the high levels of structured proofs and sketch the lower levels, which will appear in full elsewhere. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Martn Abadi and Leslie Lamport. </author> <title> The existence of refinement mappings. </title> <journal> Theoretical Computer Science, </journal> <volume> 82(2) </volume> <pages> 253-284, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: In predicate logic, one proves a formula P ) 9 x : Q (x ) by proving P ) Q (x ) for a suitable instantia-tion x of x . In temporal logic, the instantiation is called a refinement mapping <ref> [1] </ref>. To prove Impl , we define a pair of state functions mem and result and prove F ) G , where G is the formula obtained by substituting mem and result for mem and result in G. For our proof, we let mem equal mem. <p> For our proof, we let mem equal mem. To define result, we must introduce a history variable <ref> [1] </ref>. Intuitively, a history variable a is one that is added to remember what happened in the past.
Reference: 2. <author> Martn Abadi and Leslie Lamport. </author> <title> An old-fashioned recipe for real time. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5) </volume> <pages> 1543-1571, </pages> <month> Septem-ber </month> <year> 1994. </year>
Reference-contexts: The structure of this specification is familiar. 13 The only novelty is the specification of real-time constraints. Real-time constraints are expressed using the formulas defined in module RealTime in Figure 19 on page 35; it is based on the treatment of real time given in <ref> [2] </ref>. This module is the same one that has been used before [11, 14], except that it defines an additional formula NonZeno. That formula appeared in [2], where it was called NZ . <p> using the formulas defined in module RealTime in Figure 19 on page 35; it is based on the treatment of real time given in <ref> [2] </ref>. This module is the same one that has been used before [11, 14], except that it defines an additional formula NonZeno. That formula appeared in [2], where it was called NZ .
Reference: 3. <author> Martn Abadi and Leslie Lamport. </author> <title> Conjoining specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(3) </volume> <pages> 507-534, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: One might want a specification that describes an actual procedure-calling software standard, complete with register-usage conventions. One might also want a different high-level abstraction. We can convert our specifications into ones with a different interface abstraction by using an interface refinement, as described in <ref> [3, page 518] </ref> and [7]. Our specification makes precise one important detail that is not quite stated in the informal specification. <p> Composing a caller component and a returner component produces a system in which the two components interact according to the protocol. In TLA, composition is conjunction <ref> [3] </ref>. <p> The conjunction of the specifications of the two components therefore expresses what we would expect to be the specification of the complete handshake protocol. We are using a noninterleaving representation <ref> [3] </ref>, in which a single step can represent operations performed by several processes. This approach seems more convenient for this specification problem than the more traditional interleaving representation, in which each step represents an operation of at most one process. <p> We might therefore expect the specification of a reliable memory to be E :LegalCaller ) RSpec. However, for reasons explained in <ref> [3] </ref>, we instead write this specification as the formula E :LegalCaller + . RSpec. This formula means roughly that RSpec remains true as long as E :LegalCaller does. <p> We would expect the assumption/guarantee specification of the reliable memory to imply that of the unreliable memory: (E :LegalCaller + . RSpec) ) (E :LegalCaller + . USpec) (2) The relation between the two forms of implementation conditions exemplified by (1) and (2) is investigated in <ref> [3] </ref>. <p> The specification Spec of the RPC component appears in module RPC of module RPC import RPCParameters, Naturals, Sequences export RPC, Snd, Rcv module Inner parameters rstate : variable Init (p) = (rstate [p] = "A") ^ :Rcv :Calling (p) RelayArg (p) = hsndCh [p]:arg [2]i ffi sndCh [p]:arg <ref> [3] </ref> Forward (p) = ^ Snd:Calling (p) ^ (rstate [p] = "A") ^ RelayArg (p) 2 LegalRcvArgs ^ Rcv :Call (p; RelayArg (p)) ^ rstate 0 [p] = "B" ^ unchanged Snd :rtrner (p) Reject (p) = ^ rstate [p] = "A" ^ RelayArg (p) =2 LegalRcvArgs ^ Snd:Return (p; "BadCall")
Reference: 4. <author> Martn Abadi, Leslie Lamport, and Stephan Merz. </author> <title> The Dagstuhl example|a TLA solution. World Wide Web page at http://www.research.digital.com/SRC /dagstuhl/dagstuhl.html. It can also be found by searching the Web for the 26-letter string formed by concatenating uid and lamportdagstuhlspecprob. </title>
Reference-contexts: Here, we present only the higher levels of the proofs. Proofs carried down to the level where each justification involves instantiation of proof rules and simple predicate logic will be available on a Web page <ref> [4] </ref>. Although our proofs are careful and detailed, neither they nor the specifications have been checked mechanically; minor errors undoubtedly remain. Rigor entails a certain degree of tedium. A complete programming language requires boring details like variable declarations that can be omitted in informal pseudo-code.
Reference: 5. <author> Manfred Broy and Leslie Lamport. </author> <title> The RPC-memory specification problem. </title> <note> In this volume. Also available on [4]. 44 </note>
Reference-contexts: Introduction Broy and Lamport have proposed a specification and verification problem <ref> [5] </ref>. It calls for specifying simple memory and RPC (remote procedure call) components, and proving the correctness of two simple implementations. We present a complete solution to this problem using TLA, the temporal logic of actions [12]. We assume the reader is familiar with Broy and Lamport's problem statement.
Reference: 6. <author> Nissim Francez. </author> <title> Fairness. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <address> New York, Berlin, Heidelberg, Tokyo, </address> <year> 1986. </year>
Reference-contexts: of these three choices of fairness conditions for RPSpec (p) yield essentially the same specification. (The three fairness conditions need not be equivalent on a behavior in which memCh [p]:arg changes while the memory is processing a procedure call by process p.) Weak fairness is a standard concept of concurrency <ref> [6, 17] </ref>. The reader who is not already familiar with it may find fairness conditions difficult to understand. Fairness can be subtle, and it is not obvious why we express it in TLA with WF formulas.
Reference: 7. <author> Rob Gerth, Ruurd Kuiper, and John Segers. </author> <title> Interface refinement in reactive systems. </title> <editor> In W. R. Cleaveland, editor, </editor> <booktitle> 3rd International Conference on Concurrency Theory, volume 630 of Lecture Notes in Computer Science, </booktitle> <pages> pages 77-93, </pages> <address> Berlin, Heidelberg, 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: One might want a specification that describes an actual procedure-calling software standard, complete with register-usage conventions. One might also want a different high-level abstraction. We can convert our specifications into ones with a different interface abstraction by using an interface refinement, as described in [3, page 518] and <ref> [7] </ref>. Our specification makes precise one important detail that is not quite stated in the informal specification.
Reference: 8. <author> Cliff B. Jones. </author> <title> Specification and design of (parallel) programs. </title> <editor> In R. E. A. Mason, editor, </editor> <booktitle> Information Processing 83: Proceedings of the IFIP 9th World Congress, </booktitle> <pages> pages 321-332, </pages> <address> Amsterdam, </address> <month> September </month> <year> 1983. </year> <title> IFIP, </title> <publisher> North-Holland. </publisher>
Reference-contexts: However, for reasons explained in [3], we instead write this specification as the formula E :LegalCaller + . RSpec. This formula means roughly that RSpec remains true as long as E :LegalCaller does. Such a formula is called an assumption/guarantee specification <ref> [8] </ref>; the memory guarantees to satisfy its component-specification RSpec as long as the environment assumption E :LegalCaller is satisfied. When we present a component specification as a solution to one of the specification problems, we indicate its environment assumption. Writing the corresponding assumption/guarantee specification is then trivial.
Reference: 9. <author> Leslie Lamport. </author> <title> TLA|temporal logic of actions. At URL http://www.research. digital.com/SRC/tla/ on the World Wide Web. It can also be found by searching the Web for the 21-letter string formed by concatenating uid and lamporttlahomepage. </title>
Reference-contexts: TLA is described in detail in [12], and there are several published examples of TLA + specifications [11, 14]. Further information about TLA and TLA + can be found on the Web <ref> [9] </ref>. The problem is not very challenging for TLA, TLA + , or our proof style. With our experience, it was possible to grind out the requisite specifications and proofs without much thought. More difficult was choosing from among the many possible ways of writing the specifications.
Reference: 10. <author> Leslie Lamport. </author> <title> How to write a proof. </title> <journal> American Mathematical Monthly, </journal> <volume> 102(7) </volume> <pages> 600-608, </pages> <month> August-September </month> <year> 1993. </year>
Reference-contexts: Our specifications are written in TLA + , a formal language based on TLA. Our proofs are completely formal, except that some names are abbreviated for readability. We use a hierarchical proof method <ref> [10] </ref> that is the most reliable way we know of to write hand proofs. Here, we present only the higher levels of the proofs. Proofs carried down to the level where each justification involves instantiation of proof rules and simple predicate logic will be available on a Web page [4]. <p> A general theorem of TLA proves the validity of 999 999 rmhist : Hist. The High-Level Proof We describe a structured proof of theorem Impl , in the style of <ref> [10] </ref>. We first present the high-level proof.
Reference: 11. <editor> Leslie Lamport. Hybrid systems in TLA + . In Robert L. Grossman, Anil Nerode, Anders P. Ravn, and Hans Rischel, editors, </editor> <booktitle> Hybrid Systems, volume 736 of Lecture Notes in Computer Science, </booktitle> <pages> pages 77-102, </pages> <address> Berlin, Heidelberg, 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: We assume no prior knowledge of TLA or TLA + . Concepts and notations are explained as they are introduced; the index on page 45 can help the reader find those explanations. TLA is described in detail in [12], and there are several published examples of TLA + specifications <ref> [11, 14] </ref>. Further information about TLA and TLA + can be found on the Web [9]. The problem is not very challenging for TLA, TLA + , or our proof style. With our experience, it was possible to grind out the requisite specifications and proofs without much thought. <p> Real-time constraints are expressed using the formulas defined in module RealTime in Figure 19 on page 35; it is based on the treatment of real time given in [2]. This module is the same one that has been used before <ref> [11, 14] </ref>, except that it defines an additional formula NonZeno. That formula appeared in [2], where it was called NZ .
Reference: 12. <author> Leslie Lamport. </author> <title> The temporal logic of actions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 872-923, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Introduction Broy and Lamport have proposed a specification and verification problem [5]. It calls for specifying simple memory and RPC (remote procedure call) components, and proving the correctness of two simple implementations. We present a complete solution to this problem using TLA, the temporal logic of actions <ref> [12] </ref>. We assume the reader is familiar with Broy and Lamport's problem statement. Since the problem is so much simpler than the ones encountered in real applications, any approach that claims to be both practical and formal should allow a completely formal solution. <p> Our specifications and proofs are rigorous, hence somewhat tedious. We assume no prior knowledge of TLA or TLA + . Concepts and notations are explained as they are introduced; the index on page 45 can help the reader find those explanations. TLA is described in detail in <ref> [12] </ref>, and there are several published examples of TLA + specifications [11, 14]. Further information about TLA and TLA + can be found on the Web [9]. The problem is not very challenging for TLA, TLA + , or our proof style.
Reference: 13. <author> Leslie Lamport. </author> <title> TLA in pictures. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(9) </volume> <pages> 768-775, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: A pair changes iff one of its elements changes, so RPSpec (p) describes changes to E :rtrner (p), the returner's part of the communication channel memCh [p], and to result [p]. We explain RPSpec (p) with the help of the predicate-action diagram <ref> [13] </ref> of result [p] = NotAResult t result [p] 6= NotAResult t - Y Read (p) _ 9 l : Write (p; l ) Return (p) U Read (p) _ 9 l : Write (p; l) Fig. 6. <p> A Read (p) or Write (p; l ) step leaves result [p] unequal to NotAResult , while a Return (p) step sets it to NotAResult. Predicate-action diagrams are defined formally in <ref> [13] </ref> to represent TLA formulas. The assertion that Figure 6 is a diagram for RPSpec (p) means that RPSpec (p) implies the formula represented by the diagram. In general, one can draw many different diagrams for the same formula.
Reference: 14. <author> Leslie Lamport and Stephan Merz. </author> <title> Specifying and verifying fault-tolerant systems. </title> <editor> In H. Langmaack, W.-P. de Roever, and J. Vytopil, editors, </editor> <booktitle> Formal Techniques in Real-Time and Fault-Tolerant Systems, volume 863 of Lecture Notes in Computer Science, </booktitle> <pages> pages 41-76. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1994. </year>
Reference-contexts: We assume no prior knowledge of TLA or TLA + . Concepts and notations are explained as they are introduced; the index on page 45 can help the reader find those explanations. TLA is described in detail in [12], and there are several published examples of TLA + specifications <ref> [11, 14] </ref>. Further information about TLA and TLA + can be found on the Web [9]. The problem is not very challenging for TLA, TLA + , or our proof style. With our experience, it was possible to grind out the requisite specifications and proofs without much thought. <p> The module appeared in <ref> [14] </ref> (without the definition of Seq , 10 TLA + uses square brackets to denote function application. An "array variable" is just a variable whose value is a function. 18 which was not needed there) and is given without further explanation in Figure 8 on this page. <p> Real-time constraints are expressed using the formulas defined in module RealTime in Figure 19 on page 35; it is based on the treatment of real time given in [2]. This module is the same one that has been used before <ref> [11, 14] </ref>, except that it defines an additional formula NonZeno. That formula appeared in [2], where it was called NZ .
Reference: 15. <author> A. C. Leisenring. </author> <title> Mathematical Logic and Hilbert's "-Symbol. </title> <publisher> Gordon and Breach, </publisher> <address> New York, </address> <year> 1969. </year>
Reference-contexts: It allows a behavior in which v never changes. We require that certain changes do occur by conjoining an additional condition F , which 8 The definition of NotAResult in submodule Inner uses the operator choose, which is the TLA + name for Hilbert's " <ref> [15] </ref>. 9 Informally, we often think of 8 x 2 S : F (x ) as the conjunction of the formulas F (x ) for all x in S . 12 constrains what must eventually happen but does not disallow any individual step.
Reference: 16. <author> Carver Mead and Lynn Conway. </author> <title> Introduction to VLSI Systems, chapter 7. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1980. </year>
Reference-contexts: These bars have no semantic significance. 1.2 State Functions, State Predicates, and Actions To model the procedure-calling interface, we let ch [p] be a "channel" over which process p of the caller component interacts with process p of the returner component. Our model uses a standard two-phase handshake protocol <ref> [16] </ref> illustrated in caller|a signaling wire ch [p]:cbit and an argument-passing wire ch [p]:arg|and two wires controlled by the returner|a signaling wire ch [p]:rbit and a result-returning wire ch [p]:res. In the standard two-phase handshake protocol shown in Figure 2, the signaling values ch [p]:cbit and ch [p]:rbit are bits.

References-found: 16

