URL: http://www.cs.wustl.edu/~schmidt/HPL.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/new.html
Root-URL: http://www.cs.wustl.edu
Email: schmidt@cs.wustl.edu  
Title: Applying Patterns and Frameworks to Develop Object-Oriented Communication Software  
Author: Douglas C. Schmidt 
Address: St. Louis, MO 63130  
Affiliation: Department of Computer Science Washington University,  
Abstract: This paper appeared in the Handbook of Programming Languages, Volume I, edited by Peter Salus, MacMillan Computer Publishing, 1997. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. P. Brooks, </author> <title> The Mythical Man-Month. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1975. </year>
Reference-contexts: Across the industry, this situation has produced a communication software crisis, where computing hardware and networks get smaller, faster, and cheaper; yet communication software gets larger, slower, and more expensive to develop and maintain. The challenges of communication software arise from inherent and accidental complexities <ref> [1] </ref>. Inherent complexities stem from fundamental challenges of developing communication software. Chief among these are detecting and recovering from network and host failures, minimizing the impact of communication latency, and determining an optimal partitioning of application service components and workload onto processing elements throughout a network.
Reference: [2] <author> A. Gokhale and D. C. Schmidt, </author> <title> Measuring the Performance of Communication Middleware on High-Speed Networks, </title> <booktitle> in Proceedings of SIGCOMM '96, </booktitle> <address> (Stanford, CA), </address> <pages> pp. 306317, </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1996. </year>
Reference-contexts: For instance, low-level network programming interfaces like Sockets are tedious and error-prone. Likewise, higher-level distributed computing middleware like CORBA, DCOM, and Java RMI lack key features, such as asynchronous I/O and end-to-end QoS guarantees. Moreover, conventional higher-level middleware implementations are not yet optimized for applications with stringent performance requirements <ref> [2, 3] </ref>. Another source of accidental complexity arises from the widespread use of algorithmic design [4] to develop communication software. Although graphical user-interfaces (GUIs) are largely built using object-oriented (OO) design, communication software has traditionally been developed with algorithmic design. <p> For instance, conventional higher-level middle-ware does not specify important aspects of high-performance and real-time distributed server development such as shared memory, asynchronous I/O, multi-threading, and synchronization [20]. Lack of performance: Conventional higher-level middle-ware incurs significant throughput and latency overhead <ref> [2, 21] </ref>.
Reference: [3] <author> D. C. Schmidt, S. Mungee, S. Flores-Gaitan, and A. Gokhale, </author> <title> Alleviating Priority Inversion and Non-determinism in Real-time CORBA ORB Core Architectures, </title> <booktitle> in Proceedings of the 4 th IEEE Real-Time Technology and Applications Symposium, </booktitle> <address> (Denver, </address> <publisher> CO), IEEE, </publisher> <month> June </month> <year> 1998. </year>
Reference-contexts: For instance, low-level network programming interfaces like Sockets are tedious and error-prone. Likewise, higher-level distributed computing middleware like CORBA, DCOM, and Java RMI lack key features, such as asynchronous I/O and end-to-end QoS guarantees. Moreover, conventional higher-level middleware implementations are not yet optimized for applications with stringent performance requirements <ref> [2, 3] </ref>. Another source of accidental complexity arises from the widespread use of algorithmic design [4] to develop communication software. Although graphical user-interfaces (GUIs) are largely built using object-oriented (OO) design, communication software has traditionally been developed with algorithmic design. <p> TAO contains the network interface, OS, communication protocol, and CORBA middle-ware components and features shown in Figure 3. TAO is based on the standard OMG CORBA reference model [16], with the enhancements designed to overcome the shortcomings of conventional ORBs <ref> [3] </ref> for high-performance and real-time applications. TAO, like ACE, is freely available at www.cs.wustl.edu/schmidt/TAO.html. JAWS: JAWS [37] is a high-performance, adaptive Web server built using the framework components and patterns provided by ACE. Figure 4 illustrates the major structural components and design patterns in JAWS.
Reference: [4] <author> G. Booch, </author> <title> Object Oriented Analysis and Design with Applications (2 nd Edition). </title> <address> Redwood City, California: Ben-jamin/Cummings, </address> <year> 1993. </year>
Reference-contexts: Moreover, conventional higher-level middleware implementations are not yet optimized for applications with stringent performance requirements [2, 3]. Another source of accidental complexity arises from the widespread use of algorithmic design <ref> [4] </ref> to develop communication software. Although graphical user-interfaces (GUIs) are largely built using object-oriented (OO) design, communication software has traditionally been developed with algorithmic design. However, algorithmic design yields non-extensible software architectures that cannot be customized rapidly to meet changing application requirements.
Reference: [5] <author> M. E. Fayad and D. C. Schmidt, </author> <title> Object-Oriented Application Frameworks, </title> <journal> Communications of the ACM, </journal> <volume> vol. 40, </volume> <month> October </month> <year> 1997. </year>
Reference-contexts: global competition, it is prohibitively expensive and time consuming to repeatedly develop applications from scratch using algorithmic design techniques. 1.2 Alleviating the Complexity of Communica tion Software with OO Frameworks and Patterns OO techniques provide principles, methods, and tools that significantly reduce the complexity and cost of developing communication software <ref> [5] </ref>. The primary benefits of OO stem from its emphasis on modularity, reusability, and extensibility. Modularity encapsulates volatile implementation details behind stable interfaces. Reusability and extensibility enhance software by factoring out common object structures and functionality.
Reference: [6] <author> R. Johnson and B. Foote, </author> <title> Designing Reusable Classes, </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> vol. 1, </volume> <pages> pp. 2235, </pages> <month> June/July </month> <year> 1988. </year>
Reference-contexts: Reusability and extensibility enhance software by factoring out common object structures and functionality. This paper illustrates how to produce flexible and ef 1 ficient communication software using OO application frame-works and design patterns. A framework is a reusable, semi-complete application that can be specialized to produce custom applications <ref> [6] </ref>. A pattern represents a recurring solution to a software development problem within a particular context [7]. Patterns and frameworks can be applied together synergistically to improve the quality of communication software by capturing successful software development strategies.
Reference: [7] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: A framework is a reusable, semi-complete application that can be specialized to produce custom applications [6]. A pattern represents a recurring solution to a software development problem within a particular context <ref> [7] </ref>. Patterns and frameworks can be applied together synergistically to improve the quality of communication software by capturing successful software development strategies. Patterns capture abstract designs and software architectures in a systematic format that can be readily comprehended by developers. <p> Together, patterns and frameworks help alleviate the continual re-discovery and re-invention of communication software concepts and components by capturing solutions to standard communication software development problems <ref> [7] </ref>. 2.2.1 The Benefits of Patterns Patterns are particularly useful for documenting the structure and participants in common micro-architectures for concur-rency and communication such as Reactors [13], Active Objects [23], and Brokers [24]. <p> This is illustrated in Figure 1 (A), where the application-specific logic manages the event loop. In contrast, frameworks are active, i.e., they manage the flow of control within an application via event dispatching patterns like Reactor [13] and Observer <ref> [7] </ref>. The callback-driven run-time architecture of a framework is shown in Figure 1 (B). This inversion of control is referred to as The Hollywood Principle [26], i.e., don't call us, we'll call you. In practice, frameworks and class libraries are complementary technologies. <p> This flexibility is achieved in ACE by combining (1) C++ language features, such as templates, inheritance, and dynamic binding, (2) design patterns, such as Abstract Factory, Strategy, and Service Configurator <ref> [7, 31] </ref>, and (3) OS mechanisms, such as dynamic linking and multi threading. 6 3.1.4 Self-contained Distributed Service Components In addition to its C++ wrappers and framework components, ACE provides a standard library of distributed services that are packaged as self-contained components.
Reference: [8] <author> D. C. Schmidt and T. Suda, </author> <title> An Object-Oriented Framework for Dynamically Configuring Extensible Distributed Communication Systems, </title> <journal> IEE/BCS Distributed Systems Engineering Journal (Special Issue on Configurable Distributed Systems), </journal> <volume> vol. 2, </volume> <pages> pp. 280293, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: Patterns capture abstract designs and software architectures in a systematic format that can be readily comprehended by developers. Frameworks capture concrete designs, algorithms, and implementations in particular programming languages. The examples in the paper focus on developing high-performance concurrent Web servers using the ACE framework <ref> [8] </ref>. ACE is an OO framework that provides components that implement core concurrency and distribution patterns [9] related to the domain of communication software. <p> To illustrate how OO patterns and frameworks are being successfully applied to communication software, the remainder of this paper examines the structure and use of the ACE framework <ref> [8] </ref>. 3 Overview of ACE ACE is an object-oriented (OO) framework that implements core concurrency and distribution patterns [9] for communication software. <p> The components in ACE provide reusable implementations of the following common communication software tasks: * Connection establishment and service initialization [28]; * Event demultiplexing and event handler dispatching [13, 29, 30]; * Interprocess communication [15] and shared memory management; * Static and dynamic configuration <ref> [8, 31] </ref> of communica tion services; * Concurrency and synchronization [29, 23]; * Distributed communication services such as naming, event routing [9], logging, time synchronization, and net work locking; * Higher-level distributed computing middleware components such as Object Request Brokers (ORBs) [20], Web servers [32], and electronic medical imaging sys tems <p> These framework components support the flex ible configuration of concurrent communication applications and services <ref> [8] </ref>. The framework layer in ACE contains the following components: Event demultiplexing components: The ACE Reactor [13] and Proactor [30] are extensible, object-oriented demultiplex ers that dispatch application-specific handlers in response to various types of I/O-based, timer-based, signal-based, and synchronization-based events. <p> Service configuration components: The ACE Service Con figurator [31] supports the configuration of applications whose services may be assembled dynamically at installation-time and/or run-time. Hierarchically-layered stream components: The ACE Streams components <ref> [8, 36] </ref> simplify the development of com munication software applications, such as user-level protocol stacks, that are composed of hierarchically-layered services. ORB adapter components: ACE can be integrated seam lessly with single-threaded and multi-threaded CORBA imple mentations via its ORB adapters [10]. <p> ORB adapter components: ACE can be integrated seam lessly with single-threaded and multi-threaded CORBA imple mentations via its ORB adapters [10]. The ACE framework components facilitate the development of communication software that can be updated and extended without the need to modify, recompile, relink, or often restart running applications <ref> [8] </ref>.
Reference: [9] <author> D. C. Schmidt, </author> <title> A Family of Design Patterns for Application-level Gateways, </title> <journal> The Theory and Practice of Object Systems (Special Issue on Patterns and Pattern Languages), </journal> <volume> vol. 2, no. 1, </volume> <year> 1996. </year>
Reference-contexts: Frameworks capture concrete designs, algorithms, and implementations in particular programming languages. The examples in the paper focus on developing high-performance concurrent Web servers using the ACE framework [8]. ACE is an OO framework that provides components that implement core concurrency and distribution patterns <ref> [9] </ref> related to the domain of communication software. The framework and patterns in this paper are representative of solutions that have been successfully applied to communication systems ranging from telecommunication system management [9] to enterprise medical imaging [10] and real-time avionics [11]. <p> ACE is an OO framework that provides components that implement core concurrency and distribution patterns <ref> [9] </ref> related to the domain of communication software. The framework and patterns in this paper are representative of solutions that have been successfully applied to communication systems ranging from telecommunication system management [9] to enterprise medical imaging [10] and real-time avionics [11]. <p> To illustrate how OO patterns and frameworks are being successfully applied to communication software, the remainder of this paper examines the structure and use of the ACE framework [8]. 3 Overview of ACE ACE is an object-oriented (OO) framework that implements core concurrency and distribution patterns <ref> [9] </ref> for communication software. ACE provides a rich set of reusable C++ wrappers and framework components that are targeted for developers of high-performance, real-time services and applications across a wide range of OS platforms, including Win32, most versions of UNIX, and many real-time operating systems. <p> Connection establishment and service initialization [28]; * Event demultiplexing and event handler dispatching [13, 29, 30]; * Interprocess communication [15] and shared memory management; * Static and dynamic configuration [8, 31] of communica tion services; * Concurrency and synchronization [29, 23]; * Distributed communication services such as naming, event routing <ref> [9] </ref>, logging, time synchronization, and net work locking; * Higher-level distributed computing middleware components such as Object Request Brokers (ORBs) [20], Web servers [32], and electronic medical imaging sys tems [33]. 4 This section outlines the structure and functionality of the ACE framework. <p> Although these service components are not strictly part of the ACE framework library, they play two important roles: Factoring out reusable distributed application building blocks: These service components provide reusable implementations of common distributed application tasks such as naming, event routing <ref> [9] </ref>, logging, time synchronization, and network locking. <p> This URL contains complete source code, documentation, and example applications, including JAWS. ACE has been used in research and development projects at many universities and companies. For instance, it has been used to build avionics systems at Boeing [11]; telecommunication systems at Bell-core [13], Ericsson [41], and Motorola <ref> [9] </ref>; medical imaging systems at Siemens [31] and Kodak [10]; and many academic research projects.
Reference: [10] <author> I. Pyarali, T. H. Harrison, and D. C. Schmidt, </author> <title> Design and Performance of an Object-Oriented Framework for High-Performance Electronic Medical Imaging, </title> <booktitle> USENIX Computing Systems, </booktitle> <volume> vol. 9, </volume> <month> November/December </month> <year> 1996. </year>
Reference-contexts: The framework and patterns in this paper are representative of solutions that have been successfully applied to communication systems ranging from telecommunication system management [9] to enterprise medical imaging <ref> [10] </ref> and real-time avionics [11]. <p> Hierarchically-layered stream components: The ACE Streams components [8, 36] simplify the development of com munication software applications, such as user-level protocol stacks, that are composed of hierarchically-layered services. ORB adapter components: ACE can be integrated seam lessly with single-threaded and multi-threaded CORBA imple mentations via its ORB adapters <ref> [10] </ref>. The ACE framework components facilitate the development of communication software that can be updated and extended without the need to modify, recompile, relink, or often restart running applications [8]. <p> ACE has been used in research and development projects at many universities and companies. For instance, it has been used to build avionics systems at Boeing [11]; telecommunication systems at Bell-core [13], Ericsson [41], and Motorola [9]; medical imaging systems at Siemens [31] and Kodak <ref> [10] </ref>; and many academic research projects.
Reference: [11] <author> T. H. Harrison, D. L. Levine, and D. C. Schmidt, </author> <title> The Design and Performance of a Real-time CORBA Event Service, </title> <booktitle> in Proceedings of OOPSLA '97, </booktitle> <address> (Atlanta, GA), </address> <publisher> ACM, </publisher> <month> October </month> <year> 1997. </year>
Reference-contexts: The framework and patterns in this paper are representative of solutions that have been successfully applied to communication systems ranging from telecommunication system management [9] to enterprise medical imaging [10] and real-time avionics <ref> [11] </ref>. <p> This URL contains complete source code, documentation, and example applications, including JAWS. ACE has been used in research and development projects at many universities and companies. For instance, it has been used to build avionics systems at Boeing <ref> [11] </ref>; telecommunication systems at Bell-core [13], Ericsson [41], and Motorola [9]; medical imaging systems at Siemens [31] and Kodak [10]; and many academic research projects.
Reference: [12] <author> D. C. Schmidt and C. Cleeland, </author> <title> Applying Patterns to Develop Extensible ORB Middleware, </title> <journal> IEEE Communications Magazine, </journal> <note> to appear 1999. </note>
Reference-contexts: Traditionally, these tasks have been implemented in an ad hoc manner using low-level native OS application programming interfaces (APIs), such as the Win32 or POSIX, which are written in C. Unfortunately, native OS APIs are not an effective way to develop complex communication middleware and applications <ref> [12] </ref>. The following are common pitfalls associated with the use of native OS APIs: Excessive low-level details: Developers must have intimate knowledge of low-level OS details. For instance, developers must carefully track which error codes are returned by each system call and handle these OS-specific problems in their applications.
Reference: [13] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, </editor> <booktitle> eds.), </booktitle> <pages> pp. 529545, </pages> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: These details divert attention from the broader, more strategic application-related semantics and program structure. Continuous re-discovery and re-invention of incompatible higher-level programming abstractions: A common remedy for the excessive level of detail with OS APIs is to define higher-level programming abstractions. For instance, a Reactor <ref> [13] </ref> is a useful component for demultiplexing I/O events and dispatching their associated event handlers. However, these abstractions are often re-discovered and re-invented in an ad hoc manner by each developer or project. <p> and frameworks help alleviate the continual re-discovery and re-invention of communication software concepts and components by capturing solutions to standard communication software development problems [7]. 2.2.1 The Benefits of Patterns Patterns are particularly useful for documenting the structure and participants in common micro-architectures for concur-rency and communication such as Reactors <ref> [13] </ref>, Active Objects [23], and Brokers [24]. These patterns are generalizations of object-structures that have proven useful to build flexible and efficient event-driven and concurrent communication software frameworks and applications. <p> This is illustrated in Figure 1 (A), where the application-specific logic manages the event loop. In contrast, frameworks are active, i.e., they manage the flow of control within an application via event dispatching patterns like Reactor <ref> [13] </ref> and Observer [7]. The callback-driven run-time architecture of a framework is shown in Figure 1 (B). This inversion of control is referred to as The Hollywood Principle [26], i.e., don't call us, we'll call you. In practice, frameworks and class libraries are complementary technologies. <p> The components in ACE provide reusable implementations of the following common communication software tasks: * Connection establishment and service initialization [28]; * Event demultiplexing and event handler dispatching <ref> [13, 29, 30] </ref>; * Interprocess communication [15] and shared memory management; * Static and dynamic configuration [8, 31] of communica tion services; * Concurrency and synchronization [29, 23]; * Distributed communication services such as naming, event routing [9], logging, time synchronization, and net work locking; * Higher-level distributed computing middleware components <p> These framework components support the flex ible configuration of concurrent communication applications and services [8]. The framework layer in ACE contains the following components: Event demultiplexing components: The ACE Reactor <ref> [13] </ref> and Proactor [30] are extensible, object-oriented demultiplex ers that dispatch application-specific handlers in response to various types of I/O-based, timer-based, signal-based, and synchronization-based events. <p> All the Web server implementations described below use the Acceptor pattern to decouple connection establishment from HTTP protocol processing. The Reactor pattern: This pattern <ref> [13] </ref> decouples the synchronous event demultiplexing and event handler notification dispatching logic of server applications from the service (s) performed in response to events. Figure 9 illustrates the structure of the Reactor pattern in the context of Web 9 servers. <p> This URL contains complete source code, documentation, and example applications, including JAWS. ACE has been used in research and development projects at many universities and companies. For instance, it has been used to build avionics systems at Boeing [11]; telecommunication systems at Bell-core <ref> [13] </ref>, Ericsson [41], and Motorola [9]; medical imaging systems at Siemens [31] and Kodak [10]; and many academic research projects.
Reference: [14] <author> M. K. McKusick, K. Bostic, M. J. Karels, and J. S. Quarter-man, </author> <title> The Design and Implementation of the 4.4BSD Operating System. </title> <publisher> Addison Wesley, </publisher> <year> 1996. </year>
Reference-contexts: High potential for errors: Programming to low-level OS APIs is tedious and error-prone due to their lack of typesafety. For example, many networking applications are programmed with the Socket API <ref> [14] </ref>. However, endpoints of communication in the Socket API are represented as untyped handles. This increases the potential for subtle programming mistakes and run-time errors [15]. Lack of portability: Low-level OS APIs are notoriously non-portable, even across releases of the same OS.
Reference: [15] <author> D. C. Schmidt, T. H. Harrison, and E. Al-Shaer, </author> <title> Object-Oriented Components for High-speed Network Programming, </title> <booktitle> in Proceedings of the 1 st Conference on Object-Oriented Technologies and Systems, </booktitle> <address> (Monterey, CA), </address> <publisher> USENIX, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: For example, many networking applications are programmed with the Socket API [14]. However, endpoints of communication in the Socket API are represented as untyped handles. This increases the potential for subtle programming mistakes and run-time errors <ref> [15] </ref>. Lack of portability: Low-level OS APIs are notoriously non-portable, even across releases of the same OS. For instance, implementations of the Socket API on Win32 platforms (WinSock) are subtly different than on UNIX platforms. <p> The components in ACE provide reusable implementations of the following common communication software tasks: * Connection establishment and service initialization [28]; * Event demultiplexing and event handler dispatching [13, 29, 30]; * Interprocess communication <ref> [15] </ref> and shared memory management; * Static and dynamic configuration [8, 31] of communica tion services; * Concurrency and synchronization [29, 23]; * Distributed communication services such as naming, event routing [9], logging, time synchronization, and net work locking; * Higher-level distributed computing middleware components such as Object Request Brokers (ORBs) <p> IPC and filesystem components: The ACE C++ wrappers encapsulate local and/or remote IPC mechanisms <ref> [15] </ref> such as sockets, TLI, UNIX FIFOs and STREAM pipes, and Win32 Named Pipes. In addition, the ACE C++ wrappers encapsulate the OS filesystem APIs.
Reference: [16] <author> Object Management Group, </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <editor> 2.2 ed., </editor> <month> Feb. </month> <year> 1998. </year>
Reference-contexts: Common examples of higher-level distributed computing middleware include CORBA <ref> [16] </ref>, DCOM [17], and Java RMI [18]. Higher-level distributed computing middleware resides between clients and servers and eliminates many tedious, error-prone, and non-portable aspects of developing and maintaining distributed applications by automating common network programming tasks such as object location, object activation, parameter marshaling, fault recovery, and security. <p> It is possible to alleviate some of the complexity of developing communication applications by employing higher-level distributed computing middleware, such as CORBA <ref> [16] </ref>, DCOM [17], or Java RMI [18]. <p> TAO contains the network interface, OS, communication protocol, and CORBA middle-ware components and features shown in Figure 3. TAO is based on the standard OMG CORBA reference model <ref> [16] </ref>, with the enhancements designed to overcome the shortcomings of conventional ORBs [3] for high-performance and real-time applications. TAO, like ACE, is freely available at www.cs.wustl.edu/schmidt/TAO.html. JAWS: JAWS [37] is a high-performance, adaptive Web server built using the framework components and patterns provided by ACE.
Reference: [17] <author> D. </author> <title> Box, Essential COM. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1997. </year>
Reference-contexts: Common examples of higher-level distributed computing middleware include CORBA [16], DCOM <ref> [17] </ref>, and Java RMI [18]. Higher-level distributed computing middleware resides between clients and servers and eliminates many tedious, error-prone, and non-portable aspects of developing and maintaining distributed applications by automating common network programming tasks such as object location, object activation, parameter marshaling, fault recovery, and security. <p> It is possible to alleviate some of the complexity of developing communication applications by employing higher-level distributed computing middleware, such as CORBA [16], DCOM <ref> [17] </ref>, or Java RMI [18]. Higher-level distributed computing middleware resides between clients and servers and automates many tedious and error-prone aspects of distributed application development, including: * Authentication, authorization, and data security. * Service location and binding. * Service registration and activation. * Demultiplexing and dispatching in response to events.
Reference: [18] <author> A. Wollrath, R. Riggs, and J. Waldo, </author> <title> A Distributed Object Model for the Java System, </title> <booktitle> USENIX Computing Systems, </booktitle> <volume> vol. 9, </volume> <month> November/December </month> <year> 1996. </year>
Reference-contexts: Common examples of higher-level distributed computing middleware include CORBA [16], DCOM [17], and Java RMI <ref> [18] </ref>. Higher-level distributed computing middleware resides between clients and servers and eliminates many tedious, error-prone, and non-portable aspects of developing and maintaining distributed applications by automating common network programming tasks such as object location, object activation, parameter marshaling, fault recovery, and security. <p> It is possible to alleviate some of the complexity of developing communication applications by employing higher-level distributed computing middleware, such as CORBA [16], DCOM [17], or Java RMI <ref> [18] </ref>. Higher-level distributed computing middleware resides between clients and servers and automates many tedious and error-prone aspects of distributed application development, including: * Authentication, authorization, and data security. * Service location and binding. * Service registration and activation. * Demultiplexing and dispatching in response to events.
Reference: [19] <author> D. C. Schmidt and S. Vinoski, </author> <title> Object Adapters: Concepts and Terminology, </title> <journal> C++ Report, </journal> <volume> vol. 9, </volume> <month> November/December </month> <year> 1997. </year>
Reference-contexts: However, higher-level distributed computing middleware is often only a partial solution, for the following reasons: Lack of portability: Conventional higher-level middleware is not widely portable. For instance, the Object Adapter component in the CORBA 2.0 specification is woefully under-specified <ref> [19] </ref>. Therefore, servers written in CORBA are not portable among ORB products from different vendors. Likewise, DCOM is targeted for Win32 platforms and Java RMI is targeted for applications written in Java. Lack of features: Conventional higher-level middleware focuses primarily on communication.
Reference: [20] <author> D. C. Schmidt, A. Gokhale, T. Harrison, and G. </author> <month> Parulkar, </month>
Reference-contexts: Lack of features: Conventional higher-level middleware focuses primarily on communication. Therefore, it does not cover other key issues associated with developing distributed applications. For instance, conventional higher-level middle-ware does not specify important aspects of high-performance and real-time distributed server development such as shared memory, asynchronous I/O, multi-threading, and synchronization <ref> [20] </ref>. Lack of performance: Conventional higher-level middle-ware incurs significant throughput and latency overhead [2, 21]. <p> and shared memory management; * Static and dynamic configuration [8, 31] of communica tion services; * Concurrency and synchronization [29, 23]; * Distributed communication services such as naming, event routing [9], logging, time synchronization, and net work locking; * Higher-level distributed computing middleware components such as Object Request Brokers (ORBs) <ref> [20] </ref>, Web servers [32], and electronic medical imaging sys tems [33]. 4 This section outlines the structure and functionality of the ACE framework.
References-found: 20

