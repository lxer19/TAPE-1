URL: ftp://ftp.cs.utexas.edu/pub/predator/sigsoft-93.ps
Refering-URL: http://www.cs.utexas.edu/users/jthomas/publications.html
Root-URL: 
Title: Abstract  
Abstract: Many software libraries (e.g., the Booch C++ Components, libg++, NIHCL, COOL) provide components (classes) that implement data structures. Each component is written by hand and represents a unique combination of features (e.g. concurrency, data structure, memory allocation algorithms) that distinguishes it from other components. We argue that this way of building data structure component libraries is inherently unscalable. Libraries should not enumerate complex components with numerous features; rather, libraries should take a minimalist approach: they should provide only primitive building blocks and be accompanied by generators that can combine these blocks to yield complex custom data structures. In this paper, we describe a prototype data structure generator and the building blocks that populate its library. We also present preliminary experimental results which suggest that this approach does not compromise programmer productivity nor the run-time performance of generated data structures. 
Abstract-found: 1
Intro-found: 1
Reference: [ACM91] <editor> ACM. </editor> <title> Next generation database systems. </title> <journal> Communications of the ACM, </journal> <volume> 34(10), </volume> <month> October </month> <year> 1991. </year>
Reference-contexts: [20]; char last_name [20]; int age; int class_no; - employee; // employee record type container &lt;employee&gt; stored_as list2 with - odlist1 key is empno; // layer annotations odlist2 key is age; array size is 100; - e1, e2; // instance declaration Cursors are used to reference objects within a container <ref> [Kor91, ACM91] </ref>. <p> cursor &lt;e1&gt; curs where age>35 && first_name==Don; To iterate over each qualified employee and increment his/her class_no attribute, we use a special iteration construct, foreach: foreach (curs) - curs.class_no++; - In general, P2 presents an interface to containers that is similar to embedded relational languages or persistent data manipulation languages <ref> [ACM91] </ref>. 4.2 The P2 Architecture P2 is an extensible language. Whenever a new layer is added to P2, new lexical tokens and grammar rules may be needed to parse the layers annotation. We found the grammar for ANSI C to be too complicated to modify when new annotations were added.
Reference: [Bat88] <author> D. S. Batory, J. R. Barnett, J. F. Garza, K. P. Smith, K. Tsukuda, B. C. Twichell, and T. E. Wise. </author> <title> GENESIS: An extensible database management system. </title> <journal> IEEE Trans. on Software Engineering, </journal> <month> November </month> <year> 1988. </year>
Reference-contexts: Predator is an outgrowth of Genesis, the first extensible DBMS that showed that customized database management systems could be assembled from prefabricated components <ref> [Bat88] </ref>. Predator differs from Genesis in that (a) the performance of Predator-generated code is highly optimized, and (b) the target domain of Predator is data structures, rather than database systems. Currently there are three Predator subprojects.
Reference: [Bat91] <author> D. S. Batory and J. R. Barnett. DaTE: </author> <title> The Genesis DBMS software layout editor. </title> <editor> In R. Zicari, editor, </editor> <title> Conceptual Modelling, Databases, and CASE. </title> <publisher> McGraw-Hill, </publisher> <year> 1991. </year>
Reference-contexts: An example of such a tool (for the domain of database management systems) is DaTE which captures semantic information about each database component to ensure that only legal systems may be constructed <ref> [Bat91] </ref>. Note that many details about layers have not been discussed (e.g., how sort fields are conveyed to the appropriate layer, etc.). In the next section, we discuss the solutions to these problems that we are using now in a prototype data structure generator.
Reference: [Bat92a] <author> D. Batory, V. Singhal, and M. Sirkin. </author> <title> Implementing a domain model for data structures. </title> <journal> International Journal of Software Engineering and Knowledge Engineering, </journal> <volume> 2(3) </volume> <pages> 375-402, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: This is accomplished by a layer/mapping (or a view [Nov92]). We denote this layer by deq_sync [x:DEQ]: DEQ. 2 2. We use the notation in <ref> [Bat92a] </ref>.
Reference: [Bat92b] <author> D. Batory and S. OMalley. </author> <title> The design and implementation of hierarchical software systems with reusable components. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <month> October </month> <year> 1992. </year>
Reference-contexts: In this paper, we propose a generative means for realizing scalable data structure libraries. The composition techniques that we propose are based on the GenVoca model <ref> [Bat92b] </ref>, a model for constructing hierarchical software systems from reusable components. The techniques that we use do not rely on inheritance as offered by contemporary object-oriented languages. Instead, GenVoca models system implementations as combinations of layered software components. <p> Currently there are three Predator subprojects. Our first prototype system, P1, augments a subset of ANSI C with declarations for specifying data structure implementations; P1s goal is to evaluate the potential of data structure generators <ref> [Bat92b, Sir93] </ref>. P2 is more extensible: it supports extensions to ANSI C within a more modular and maintainable architecture. P++ introduces domain-independent language extensions to ANSI C++ to support large-scale reuse.
Reference: [Boo87] <author> G. Booch. </author> <title> Software Components with Ada, </title> <publisher> Benjamin/ Cummings, </publisher> <year> 1987. </year>
Reference-contexts: 1 Introduction Software libraries are a popular means of boosting programmer productivity and reducing software development time and cost. The Booch C++ Components <ref> [Boo87] </ref>, libg++ [Lea88], NIHCL [Gor90], and COOL [Fon90] are examples. These libraries provide C++ classes that implement a wide variety of common data structure, string, complex number, and graph classes that programmers can instantiate. 1. <p> We show in the following subsections how a typical data structure can be decomposed into the composition of primitive layers, where each layer exports a standardized, high-level interface. We use an example from the Booch C++ Components <ref> [Boo87] </ref>. 3.1 An Example of Data Structure Decomposition A deque is a queue from which objects can be added and removed at either end. It is unbounded if there is no fixed limit to the number of objects that it can contain.
Reference: [Bra93] <author> D. A. Brant and D. P. Miranker. </author> <title> Index support for rule activation. </title> <booktitle> In Proceedings of 1993 ACM SIGMOD, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: Preliminary experimental evidence presented here and in [Sir93] show that P2 does not compromise programmer productivity nor the performance of generated code. Much more work remains. We are in the process of re-engineering the OPS5c production system compiler <ref> [Bra93] </ref>, which uses highly-customized data structures to realize a high-performance active database application. We believe that if success can be demonstrated in generating complex data structures for such sophisticated applications, we will have established that the generative approach can play an important role in the future of software component libraries.
Reference: [Coh93] <author> D. Cohen and N. Campbell. </author> <title> Automating relational operations on data structures. </title> <journal> IEEE Software, </journal> <volume> 10(3) </volume> <pages> 53-60, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: We believe that the results presented here have indeed accomplished our initial goals. 6 Related Work Several other research projects have provided tools that alleviate the drudgery of writing data structure implementations. <ref> [Coh93] </ref> describes a set of language extensions which permit the elements of a container to be accessed via relational operations. This system also provides a set of pre-written data structure components which all share the same relational interface.
Reference: [Fon90] <author> M. Fontana, L. Oren, and M. Neath. </author> <title> COOL C++ object-oriented library. </title> <institution> Texas Instruments, </institution> <year> 1990. </year>
Reference-contexts: 1 Introduction Software libraries are a popular means of boosting programmer productivity and reducing software development time and cost. The Booch C++ Components [Boo87], libg++ [Lea88], NIHCL [Gor90], and COOL <ref> [Fon90] </ref> are examples. These libraries provide C++ classes that implement a wide variety of common data structure, string, complex number, and graph classes that programmers can instantiate. 1. This research was supported in part by Applied Research Laboratories at The University of Texas, Schlumberger, and Digital Equipment Corporation.
Reference: [Gog86] <author> J. Goguen. </author> <title> Reusing and interconnecting software components. </title> <journal> IEEE Computer, </journal> <volume> 19(2) </volume> <pages> 16-28, </pages> <month> February </month> <year> 1986. </year>
Reference-contexts: A typical P2 component is defined in terms of the interface of its lower layer component, and it is parameterized by the type of objects stored in the data structure. Goguen has formalized these aspects of component design in a model called parameterized programming <ref> [Gog86] </ref>. This model identifies two kinds of parameters: vertical parameters (which 8 specify lower layer components) and horizontal parameters (which correspond to type and constant values). The concept of software templates is also related to the design of P2 components.
Reference: [Gor90] <author> K. Gorlen, S. Orlow, and P. Plexico. </author> <title> Data Abstraction and Object-Oriented Programming in C++, </title> <publisher> John Wiley, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction Software libraries are a popular means of boosting programmer productivity and reducing software development time and cost. The Booch C++ Components [Boo87], libg++ [Lea88], NIHCL <ref> [Gor90] </ref>, and COOL [Fon90] are examples. These libraries provide C++ classes that implement a wide variety of common data structure, string, complex number, and graph classes that programmers can instantiate. 1.
Reference: [Kor91] <author> H. F. Korth and A. Silberschatz. </author> <title> Database System Concepts, </title> <publisher> McGraw-Hill, </publisher> <year> 1991. </year>
Reference-contexts: [20]; char last_name [20]; int age; int class_no; - employee; // employee record type container &lt;employee&gt; stored_as list2 with - odlist1 key is empno; // layer annotations odlist2 key is age; array size is 100; - e1, e2; // instance declaration Cursors are used to reference objects within a container <ref> [Kor91, ACM91] </ref>.
Reference: [Kru92] <author> C. W. Krueger, </author> <title> Software Reuse, </title> <journal> ACM Computing Surveys, </journal> <month> June </month> <year> 1992. </year>
Reference-contexts: Every legal combination of features yields a distinct data structure. Because there are many possible combinations, it is not surprising that this library is indeed large. Feature combinatorics are inherent to all libraries <ref> [Kru92] </ref>. Moreover, all library components are written by hand, with occasional use of inheritance to minimize gross code replication. We claim that todays method of constructing libraries is inherently unscalable.
Reference: [Lea88] <author> D. Lea. libg++, </author> <title> the GNU C++ library. </title> <booktitle> In Proceedings of the USENIX C++ Conference, </booktitle> <year> 1988. </year>
Reference-contexts: 1 Introduction Software libraries are a popular means of boosting programmer productivity and reducing software development time and cost. The Booch C++ Components [Boo87], libg++ <ref> [Lea88] </ref>, NIHCL [Gor90], and COOL [Fon90] are examples. These libraries provide C++ classes that implement a wide variety of common data structure, string, complex number, and graph classes that programmers can instantiate. 1.
Reference: [Nov92] <author> G. Novak. </author> <title> Software Reuse through View Type Clusters. </title> <booktitle> In Proceedings of the 7th Knowledge-Based Software Engineering Conference (KBSE-92), </booktitle> <year> 1992. </year>
Reference-contexts: This is accomplished by a layer/mapping (or a view <ref> [Nov92] </ref>). We denote this layer by deq_sync [x:DEQ]: DEQ. 2 2. We use the notation in [Bat92a]. <p> Unlike Predator, however, Cohens components are not layered, and therefore suffer the aforementioned problems of scalability. In Novaks GLISP system, a data structures implementation is represented as a series of view transformations <ref> [Nov92] </ref>. A view describes the abstract interface of a container. A transformation describes the computation steps necessary to convert from one view to another. The Programmers Apprentice takes a similar approach to generating code: data structures are implemented by successively applying program transformations, called cliches [Ric90].
Reference: [Ric90] <author> C. Rich and R. Waters. </author> <title> The Programmers Apprentice, </title> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: A view describes the abstract interface of a container. A transformation describes the computation steps necessary to convert from one view to another. The Programmers Apprentice takes a similar approach to generating code: data structures are implemented by successively applying program transformations, called cliches <ref> [Ric90] </ref>. A cliche encodes in a language independent representation the actions needed to transform a data structure from one state to another. Although GLISP and Programmers Apprentice provide powerful facilities for decomposing complex components into primitive ones, decomposition alone cannot solve the scalability problem.
Reference: [Sin93] <author> V. Singhal and D. Batory. </author> <title> P++: a language for large-scale reusable software components. </title> <institution> Department of Computer Sciences, Univ. of Texas at Austin, </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: P++ introduces domain-independent language extensions to ANSI C++ to support large-scale reuse. Specific instances of these extensions are used by the P1 and P2 systems; once P++ is completed, we envision that it will be the platform for all future development of the Predator project <ref> [Sin93] </ref>. In this section, we review the P2 prototype. 4.1 P2 Source Files A P2 source file is an ANSI C program with P2 declarations: typex, container, and cursor. The typex statement allows users to define named compositions of predefined layers.
Reference: [Sir93] <author> M. Sirkin, D. Batory, and V. Singhal. </author> <title> Software components in a data structure precompiler. </title> <booktitle> In Proceedings of the 15th International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: Currently there are three Predator subprojects. Our first prototype system, P1, augments a subset of ANSI C with declarations for specifying data structure implementations; P1s goal is to evaluate the potential of data structure generators <ref> [Bat92b, Sir93] </ref>. P2 is more extensible: it supports extensions to ANSI C within a more modular and maintainable architecture. P++ introduces domain-independent language extensions to ANSI C++ to support large-scale reuse. <p> Libraries should offer only primitive building blocks, accompanied by generators that can combine these blocks into complex and custom data structures. We described a prototype, P2, that has demonstrated great potential in realizing the generative approach. Preliminary experimental evidence presented here and in <ref> [Sir93] </ref> show that P2 does not compromise programmer productivity nor the performance of generated code. Much more work remains. We are in the process of re-engineering the OPS5c production system compiler [Bra93], which uses highly-customized data structures to realize a high-performance active database application.
Reference: [Vol85] <author> D. Volpano and R. Kieburtz. </author> <title> Software templates, </title> <booktitle> In Proceedings of the 8th International Conference on Software Engineering, </booktitle> <year> 1985. </year> <month> 9 </month>
Reference-contexts: This model identifies two kinds of parameters: vertical parameters (which 8 specify lower layer components) and horizontal parameters (which correspond to type and constant values). The concept of software templates is also related to the design of P2 components. As described in <ref> [Vol85] </ref>, a software template provides a generic representation for data types and algorithms; this representation can be used to declare only the abstract interface of a software component without revealing its implementation.
References-found: 19

