URL: http://www.cs.rice.edu:80/~rjf/papers/MASCOTS94.ps.gz
Refering-URL: http://www.cs.rice.edu:80/~rjf/pubs.html
Root-URL: 
Title: MINT: A Front End for Efficient Simulation of Shared-Memory Multiprocessors  
Author: Jack E. Veenstra Robert J. Fowler 
Address: Rochester, NY 14627 Universitetsparken 1 DK-2100 Copenhagen DENMARK  
Affiliation: Department of Computer Science Department of Computer Science University of Rochester University of Copenhagen  
Abstract: Mint is a software package designed to ease the process of constructing event-driven memory hierarchy simulators for multiprocessors. It provides a set of simulated processors that run standard Unix executable files compiled for a MIPS R3000 based multiprocessor. These generate multiple streams of memory reference events that drive a user-provided memory system simulator. Mint uses a novel hybrid technique that exploits the best aspects of native execution and software interpretation to minimize the overhead of processor simulation. Combined with related techniques to improve performance, this approach makes simulation on uniprocessor hosts extremely efficient. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> James Boyle, Ralph Butler, Terrence Disz, Bar-nett Blickfeld, Ewing Lusk, and Ross Overbeek. </author> <title> Portable Programs for Parallel Processors. </title> <publisher> Holt, Rinehart and Winston, </publisher> <year> 1987. </year>
Reference-contexts: Furthermore, the application program usually must be in a specific source language. For example, RPPT requires the input source to be Concurrent C, Tango requires the input source to use the Argonne macro package <ref> [1] </ref>, and Proteus requires the input source to be annotated with a set of language extensions specific to Proteus. using Mint. The application need not be recompiled, so no source is needed.
Reference: [2] <author> E. A. Brewer, C. N. Dellarocas, A. Colbrook, and W. E. Weihl. PROTEUS: </author> <title> A High-Performance Parallel-Architecture Simulator. </title> <type> Technical Report MIT/LCS/TR-516, </type> <institution> MIT, </institution> <month> sep </month> <year> 1991. </year>
Reference-contexts: In addition, every memory reference typically requires a check at run-time to determine whether the memory location is shared. In contrast, the interaction between processes on a message-passing machine is limited to sending and receiving messages. Proteus <ref> [2] </ref> is an execution-driven simulator for shared-memory machines that simulates multiple processes in a single address space. The input to Pro-teus is an annotated C program that is preprocessed to produce an instrumented C source program. The annotations are language extensions that identify accesses to shared memory. <p> The program is compiled separately from the simulator and the simulator treats the resulting object code as input data. application must be compiled specially using this procedure. In contrast, execution-driven simulators that use native execution, such as Tango [4], Proteus <ref> [2] </ref>, and RPPT [3], work by inserting calls to the simulator directly into the program to be simulated so that the execution of the modified program explicitly generates the events that are sent to the simulator.
Reference: [3] <author> R. C. Covington, S. Madala, V. Mehta, J. R. Jump, and J. B. Sinclair. </author> <title> The Rice Parallel Processing Testbed. </title> <booktitle> In ACM SIGMETRICS International Conference on Measurement and Modeling of Computer Systems, </booktitle> <pages> pages 4-11, </pages> <year> 1988. </year>
Reference-contexts: A practical disadvantage is that each trace file can require hundreds of megabytes of disk space, though there are clever techniques for reducing the storage requirements [7]. 1.2 Program-driven simulation Program-driven simulation <ref> [3] </ref> overcomes these problems by performing the simulation as the traced program executes. The simulator controls the scheduling of processes so that the interleaving of memory references is the same as it would be on the simulated machine. Furthermore, there is no need to store a trace file on disk. <p> Mint has been carefully engineered for performance by using a novel simulation technique, tuning the speed of each component, and by choosing mechanisms that interact efficiently. Mint is designed specifically for multiprocessor simulation, so the internal mechanisms are tuned for that task. 1.3 Execution-driven simulation Execution-driven simulation <ref> [3] </ref> is a special case of program-driven simulation. Execution-driven simulators modify the application to be simulated by inserting calls to the back end functions directly into the application source or object code so that the execution of the program generates the memory trace. <p> Trapeds [12] collects multicomputer traces for the Intel iPSC/2. It modifies the assembly language to insert calls to a function that analyzes the previously executed basic block. The Rice Parallel Processing Testbed (RPPT) <ref> [3] </ref> uses execution-driven simulation to model message-passing architectures. The input is a Concurrent C program, an architecture specification, and a mapping of processes and data to processors. <p> The program is compiled separately from the simulator and the simulator treats the resulting object code as input data. application must be compiled specially using this procedure. In contrast, execution-driven simulators that use native execution, such as Tango [4], Proteus [2], and RPPT <ref> [3] </ref>, work by inserting calls to the simulator directly into the program to be simulated so that the execution of the modified program explicitly generates the events that are sent to the simulator.
Reference: [4] <author> Helen Davis, Stephen R. Goldschmidt, and John Hennessy. </author> <title> Multiprocessor Simulation and Tracing Using Tango. </title> <booktitle> In Proceedings of the 1991 Conference on Parallel Processing, </booktitle> <pages> pages II-99-II-107, </pages> <month> aug </month> <year> 1991. </year>
Reference-contexts: An important limitation of this approach is that contention cannot be modelled accurately since each processor must wait for all messages to be delivered before simulating the next time quantum. Although the WWT is fast, the hardware platform required to run it is expensive. Tango <ref> [4] </ref> is another execution-driven simulator that uses a separate Unix process for each simulated process. Although multiple processes are used, no real parallelism is exploited. Only one process executes at a time; the others remain blocked. <p> The program is compiled separately from the simulator and the simulator treats the resulting object code as input data. application must be compiled specially using this procedure. In contrast, execution-driven simulators that use native execution, such as Tango <ref> [4] </ref>, Proteus [2], and RPPT [3], work by inserting calls to the simulator directly into the program to be simulated so that the execution of the modified program explicitly generates the events that are sent to the simulator.
Reference: [5] <author> Susan J. Eggers, David R. Keppel, Eric J. Koldinger, and Henry M. Levy. </author> <title> Techniques for Efficient Inline Tracing on a Shared-Memory Multiprocessor. </title> <booktitle> In ACM SIGMETRICS International Conference on Measurement and Modeling of Computer Systems, </booktitle> <pages> pages 37-47, </pages> <year> 1990. </year>
Reference-contexts: The trace may not even be accurate for the system on which it was collected, since the very action of trace collection slows down some parts of the program and may perturb the interleaving of references <ref> [5] </ref>. A practical disadvantage is that each trace file can require hundreds of megabytes of disk space, though there are clever techniques for reducing the storage requirements [7]. 1.2 Program-driven simulation Program-driven simulation [3] overcomes these problems by performing the simulation as the traced program executes.
Reference: [6] <author> Gerry Kane and Joe Heinrich. </author> <title> MIPS RISC Architecture. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: This technique usually requires preprocessing and recompiling the application. In contrast, the input to Mint is a statically-linked Irix executable file compiled for the MIPS R3000 processor <ref> [6] </ref>. It is not necessary to instrument application code for simulation or to recompile.
Reference: [7] <author> James R. Larus. </author> <title> Abstract Execution: A Technique for Efficiently Tracing Programs. </title> <journal> Software: Practice and Experience, </journal> 20(12) 1241-1258, De-cember 1990. 
Reference-contexts: A practical disadvantage is that each trace file can require hundreds of megabytes of disk space, though there are clever techniques for reducing the storage requirements <ref> [7] </ref>. 1.2 Program-driven simulation Program-driven simulation [3] overcomes these problems by performing the simulation as the traced program executes. The simulator controls the scheduling of processes so that the interleaving of memory references is the same as it would be on the simulated machine.
Reference: [8] <author> James R. Larus. SPIM S20: </author> <title> A MIPS R2000 Simulator. </title> <type> Technical Report TR966, </type> <institution> Computer Sciences Department, University of Wisconsin-Madison, </institution> <month> sep </month> <year> 1990. </year>
Reference-contexts: When generating events for every memory reference, a Mint simulation typically takes between 20 and 70 times longer 5 than native execution on the same machine. This is comparable to the slowdown for uniprocessor MIPS code interpreters such as SPIM <ref> [8] </ref>, for which a slowdown of 20 has been reported. High cache miss rates explain why the native execution time for mm-dp is much larger than for mm and mm-sp.
Reference: [9] <author> Henry Massalin. </author> <title> Synthesis: An Efficient Implementation of Fundamental Operating System Services. </title> <type> PhD thesis, </type> <institution> Columbia University, </institution> <year> 1992. </year>
Reference-contexts: The target processor state is kept 3 in memory as much as possible. To reduce the cost of loading registers from memory on every instruction, Mint uses a form of code synthesis <ref> [9] </ref> to encapsulate each straight-line block of code that generates no events internally. 1 For each such block, Mint creates a new function when the object code of the program is loaded.
Reference: [10] <author> Steven K. Reinhardt, Mark D. Hill, James R. Larus, Alvin R. Lebeck, James C. Lewis, and David A. Wood. </author> <title> The Wisconsin Wind Tunnel: Virtual Prototyping of Parallel Computers. </title> <booktitle> In ACM SIGMETRICS International Conference on Measurement and Modeling of Computer Systems, </booktitle> <month> may </month> <year> 1993. </year>
Reference-contexts: The preprocessor inserts a call to a simulator function at each shared memory reference, so it is important that all such references be annotated. In the current version, annotation is done manually. A performance comparison of Proteus with Mint is given in Section 4. The Wisconsin Wind Tunnel <ref> [10] </ref> is a fast execution-driven simulator for distributed shared-memory machines. It runs in parallel on a CM-5 host (a SPARC-based multicomputer) and uses the ECC (error-correcting code) bits as "valid" bits for cache lines within a page to trap accesses to shared memory.
Reference: [11] <author> Jaswinder Pal Singh, Wolf-Dietrich Weber, and Anoop Gupta. </author> <title> SPLASH: Stanford Parallel Applications for Shared-Memory. </title> <journal> ACM SIGARCH Computer Architecture News, </journal> <volume> 20(1) </volume> <pages> 5-44, </pages> <year> 1992. </year>
Reference-contexts: Mint was linked with empty back-end functions and each application used 1 simulated process. Private as well as shared memory references were simulated. Gaussian elimination on a 400 fi 400 matrix of single-precision floats. "MP3D" is a three-dimensional wind tunnel simulator from the SPLASH suite <ref> [11] </ref>. MP3D was run with 20,000 molecules for 50 time steps. As can be seen in Table 1, the ratio of instructions to memory references varies across programs. This ratio significantly affects the execution time of the simulation.
Reference: [12] <author> Craig B. Stunkel and W. Kent Fuchs. TRAPEDS: </author> <title> Producing Traces for Multicomputers Via Execution Driven Simulation. In Performance Evaluation Review, </title> <booktitle> 17(1), </booktitle> <pages> pages 70-78, </pages> <month> May </month> <year> 1989. </year> <month> 7 </month>
Reference-contexts: Their simulators take advantage of the properties of message-passing machines to achieve good performance and are not designed to simulate shared-memory machines. Trapeds <ref> [12] </ref> collects multicomputer traces for the Intel iPSC/2. It modifies the assembly language to insert calls to a function that analyzes the previously executed basic block. The Rice Parallel Processing Testbed (RPPT) [3] uses execution-driven simulation to model message-passing architectures.
References-found: 12

