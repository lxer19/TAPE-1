URL: http://wwwipd.ira.uka.de/~prechelt/Biblio/wcre96.ps.gz
Refering-URL: 
Root-URL: 
Email: (prechelt@ira.uka.de)  
Phone: +49/721/608-4068, Fax: +49/721/694092  
Title: Design Recovery by Automated Search for Structural Design Patterns in Object-Oriented Software  
Author: Christian Kramer (ckraemer@ctec-sw.com) Lutz Prechelt 
Keyword: design patterns, object-oriented, CASE, Prolog, maintainability  
Address: D-76133 Karlsruhe, Germany  D-76128 Karlsruhe, Germany  
Affiliation: Computec GmbH Software Engineering Dept.  Fakultat fur Informatik Universitat Karlsruhe  
Abstract: The object-oriented design community has recently begun to collect so-called design patterns: cliches plus hints to their recommended use in software construction. The structural design patterns Adapter, Bridge, Composite, Decorator, and Proxy represent packaged problem/context/solution/properties descriptions to common problems in object-oriented design. Localizing instances of these patterns in existing software produced without explicit use of patterns can improve the maintainability of software. In our approach, called the Pat system, design information is extracted directly from C ++ header files and stored in a repository. The patterns are expressed as Prolog rules and the design information is translated into facts. A single Prolog query is then used to search for all patterns. We examined four applications, including the popular class libraries zApp and LEDA, with Pat. With some restrictions all pattern instances are found; the precision is about 40 percent. Since manual filtering of the output is relatively easy, we consider Pat a useful tool for discovering or recovering design information. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. Beck, J.O. Coplien, R. Crocker, L. Dominick, G. Meszaros, F. Paulisch, and J. Vlissides. </author> <title> Industrial experience with design patterns. </title> <booktitle> In 18th Intl. Conf. on Software Engineering, </booktitle> <pages> pages 103-114, </pages> <address> Berlin, March 1996. </address> <publisher> IEEE CS press. </publisher>
Reference-contexts: For the same reason it is also difficult to find behavioral patterns instead of structural ones. 3 Related work Design patterns are a young field and until now, they are mostly used for understanding and communicating during the production of designs. Seven pattern practitioners <ref> [1] </ref> agree that one of the largest benefits of design patterns is their use as a means of communication and understanding. This observation suggests that finding patterns in existing designs should make understanding these designs easier.
Reference: [2] <author> Ted J. Biggerstaff. </author> <title> Design recovery for maintenance and reuse. </title> <journal> IEEE Computer, </journal> <volume> 22(7) </volume> <pages> 36-49, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: This observation suggests that finding patterns in existing designs should make understanding these designs easier. In contrast to much other work in reverse engineering, Pat does not strive for detailed program understanding [3, 11] or design recovery <ref> [2] </ref>. In those cases, a wide gap has to be closed between the syntactic representation of the program (and maybe other artifacts) and the understanding of semantics and pragmatics that is to be gained.
Reference: [3] <author> Ted J. Biggerstaff, Bharat G. Mitbander, and Dal-las E. Webster. </author> <title> Program understanding and the concept assignment problem. </title> <journal> Communications of the ACM, </journal> <volume> 37(5) </volume> <pages> 72-83, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: This observation suggests that finding patterns in existing designs should make understanding these designs easier. In contrast to much other work in reverse engineering, Pat does not strive for detailed program understanding <ref> [3, 11] </ref> or design recovery [2]. In those cases, a wide gap has to be closed between the syntactic representation of the program (and maybe other artifacts) and the understanding of semantics and pragmatics that is to be gained. <p> Therefore, structural design patterns allow to infer program pragmatics from syntactic source code features with moderately complex machine deduction and only a modest amount of additional interpretation by the user. In particular, design pattern search does not call for automatic concept assignment <ref> [3] </ref> and the output is useful without a domain model. Koenig [7] suggests the notion of antipatterns that capture bad or non-working designs that are frequently "reused".
Reference: [4] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1995. </year>
Reference-contexts: 1 Design patterns for understanding The structural design patterns introduced by Gamma et al. <ref> [4] </ref> are concepts to improve the understanding of object-oriented designs. A design pattern packages expert knowledge; it represents a solution to a common fl Appeared in Proc. Working Conf. on Reverse Engineering, IEEE CS press, Monterey, November 1996. design problem and can be reused frequently and easily.
Reference: [5] <author> H.S. </author> <title> Heaps. Information Retrieval. </title> <publisher> Academic Press, </publisher> <year> 1978. </year>
Reference-contexts: How useful is the output for actual program un derstanding and maintenance tasks? We cannot answer the third question at this time, as it requires a rather costly empirical study. The first two questions are answered in terms of the information retrieval quality measures called precision and recall <ref> [5] </ref>. Assume that Pat outputs C pattern instance candidates after the automatic postprocess-ing. Assume further that the design analyzed actually contains I true pattern instances and that F of them are found by Pat. Then precision = F=C and recall = F=I.
Reference: [6] <institution> Inmark Development Corporation, Mountain View, CA. zApp Programmer's Guide, </institution> <year> 1994. </year>
Reference-contexts: the execution time needed for the automatic search and the time needed for human filtering of the results to remove false positives. 7.1 The benchmarks Four different sets of classes were examined: Network Management Environment Browser (NME), Library of Efficient Datatypes and Algorithms (LEDA, [8]), the zApp class library (zApp, <ref> [6] </ref>), and Automatic Call Distribution (ACD). NME and ACD are telecommunication software developed at Computec, the other two are widely used class libraries. None of these four benchmarks included explicit design information; all data was extracted from C ++ header files as described above.
Reference: [7] <author> Andrew Koenig. </author> <title> Patterns and antipatterns. </title> <journal> Journal of Object Oriented Programming, </journal> <volume> 8(1) </volume> <pages> 46-48, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: In particular, design pattern search does not call for automatic concept assignment [3] and the output is useful without a domain model. Koenig <ref> [7] </ref> suggests the notion of antipatterns that capture bad or non-working designs that are frequently "reused".
Reference: [8] <author> Stefan Naher. </author> <title> LEDA User Manual Version 3.0. </title> <institution> Fachbereich Informatik, Universitat des Saarlan-des, Saarbrucken, Germany, </institution> <year> 1992. </year>
Reference-contexts: Furthermore, we measured the execution time needed for the automatic search and the time needed for human filtering of the results to remove false positives. 7.1 The benchmarks Four different sets of classes were examined: Network Management Environment Browser (NME), Library of Efficient Datatypes and Algorithms (LEDA, <ref> [8] </ref>), the zApp class library (zApp, [6]), and Automatic Call Distribution (ACD). NME and ACD are telecommunication software developed at Computec, the other two are widely used class libraries. None of these four benchmarks included explicit design information; all data was extracted from C ++ header files as described above.
Reference: [9] <institution> Prolog Development Center, Brtndby, </institution> <month> Danmark. </month> <title> Visual Prolog 4.0 (Professional Version), </title> <year> 1996. </year>
Reference-contexts: This rule ignores the delegation from Proxy::Op to RealSubj::Op. 6 Implementation details The Pat system was developed with the Paradigm Plus 2.01 ooCASE tool [10] and the Visual Prolog 4.0 Beta (Professional Version) compiler system <ref> [9] </ref>. The programs P2prolog and D2prolog are written in the BASIC dialect provided by Paradigm Plus and are executed directly by Paradigm Plus. Therefore they have direct access to the repository.
Reference: [10] <author> ProtoSoft Inc., Houston, </author> <title> TX. Paradigm Plus 2.01 Reference Manual, </title> <year> 1994. </year>
Reference-contexts: Koenig [7] suggests the notion of antipatterns that capture bad or non-working designs that are frequently "reused". Should structural antipatterns exist, our approach could be used as a design quality checker by searching for antipattern instances. 4 The Paradigm Plus ooCASE tool Paradigm Plus 2.01 <ref> [10] </ref> by Platinum (formerly Proto-Soft) is an object-oriented CASE tool for all phases of the software lifecycle. Several methods and notations are supported, one of them OMT. <p> This rule ignores the delegation from Proxy::Op to RealSubj::Op. 6 Implementation details The Pat system was developed with the Paradigm Plus 2.01 ooCASE tool <ref> [10] </ref> and the Visual Prolog 4.0 Beta (Professional Version) compiler system [9]. The programs P2prolog and D2prolog are written in the BASIC dialect provided by Paradigm Plus and are executed directly by Paradigm Plus. Therefore they have direct access to the repository.
Reference: [11] <author> Charles Rich and Richard C. Waters. </author> <title> The Programmer's Apprentice. Frontier Series. </title> <publisher> acm press, Addison-Wesley, </publisher> <address> New York, NY, Reading, MA, </address> <year> 1990. </year>
Reference-contexts: This observation suggests that finding patterns in existing designs should make understanding these designs easier. In contrast to much other work in reverse engineering, Pat does not strive for detailed program understanding <ref> [3, 11] </ref> or design recovery [2]. In those cases, a wide gap has to be closed between the syntactic representation of the program (and maybe other artifacts) and the understanding of semantics and pragmatics that is to be gained.
Reference: [12] <author> James Rumbaugh. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: We describe in order the general approach taken, related work, the CASE tool used, the Prolog representation for the search, and a quantitative evaluation of the system. As an example of a pattern, see the description of an Adapter in the OMT diagram <ref> [12] </ref> of Figure 1. The purpose of an Adapter is to provide an additional usage interface to an adapted class (called the adaptee), so that the adapter class can adhere to the calling conventions of a client but the interface of the adaptee need not be changed.
Reference: [13] <author> Peter G. Selfridge, Richard C. Waters, and El-liot J. Chikofsky. </author> <title> Challenges to the field of reverse engineering. </title> <booktitle> In Proc. Working Conf. on Reverse Engineering, </booktitle> <year> 1993. </year> <month> 8 </month>
Reference-contexts: In this work, we will use the term pattern to refer only to (one of) the solution (s). Therefore, for our purpose, a pattern is just a particular kind of design cliche <ref> [13] </ref>. It would be useful to find instances of such patterns in designs were they were not used explicitly or where their use is not documented. This could improve the maintainability of software, because larger chunks could be understood as a whole.
References-found: 13

