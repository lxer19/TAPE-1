URL: http://www.cs.colorado.edu/~zorn/cs5535/Fall-1995/projects/hertzman.ps
Refering-URL: http://www.cs.colorado.edu/~zorn/cs5535/Fall-1995/index.html
Root-URL: http://www.cs.colorado.edu
Title: Lazy Imperative Languages Report on a Project to Examine the Use of Lazy Evaluation in
Author: Randy Hertzman 
Date: 13 November 1995  
Pubnum: CSCI 5535  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Abelson, Harold and Sussman, Gerald Jay, </author> <year> 1985. </year> <title> Structure and Interpretation of Computer Programs. </title> <address> Cambridge, Mass: </address> <publisher> The MIT Press, </publisher> <pages> 542 pages. </pages>
Reference-contexts: In this section, we describe the model and present several examples of its use. The signal processing model of computation Abelson and Sussman devote a section of their Structure and Interpretation of Computer Programs to the use of streams to program in a signal processing model <ref> [1] </ref>. They describe the signal processing model as a method of disentangling the generation of data from its use. <p> The second method involves evaluation by 2 There is an apocryphal story that the term "thunk" comes from the sound made when a block of data is pushed onto the stack in a running Algol-60 system <ref> [1] </ref>. - 10 - graph reduction. It too requires the creation of suspensions which include pieces of unevaluated graph and bindings for free variables which occur within the graph. At the implementation level, as Peyton Jones states, there is little substantive difference between the two methods.
Reference: 2. <author> Augustsson, L. and Johnson, T., </author> <year> 1989. </year> <note> The Chalmers Lazy-ML compiler. In The Computer Journal, v.32, n.2, </note> <month> April, </month> <pages> pp. 127-141. </pages>
Reference-contexts: However, there are strict languages such as Scheme [21] which implement non-strict data constructors; these constructors will serve as the model for our application of lazy techniques to imperative languages. 3.1. NON-STRICT FUNCTION CALLS Several purely functional languages such as Haskell [11, 12], Chalmers LML ("Lazy ML") <ref> [2] </ref>, and Miranda1 [24] use non-strict semantics for all function calls: they do not evaluate the arguments of a function call before calling the function. There are two main advantages of using non-strict semantics for function calls.
Reference: 3. <author> Backus, John, </author> <year> 1978. </year> <title> Can programming be liberated from the von Neumann style? A functional style and its algebra of programs. </title> <journal> In Communications of the ACM, v. </journal> <volume> 21, </volume> <editor> n. </editor> <volume> 8, </volume> <month> August, </month> <pages> pp. 613-641. </pages>
Reference-contexts: Abelson and Sussman describe how such a stream processing element can be used to model a process with state without using any assignment or mutation. Basically, a stream is used to represent a time series of different states. This is extraordinarily powerful: John Backus's AST machine <ref> [3] </ref>, for instance, could be modeled quite naturally as a stately stream processing function: the input stream would contain the programs to be run; the output stream would contain their output. The state stream would represent the effects of the state changes caused by the individual programs.
Reference: 4. <author> Bloss, Adrienne, Hudak, Paul and Young, Jonathan, </author> <year> 1988. </year> <title> Code optimizations for lazy evaluation. In Lisp and Symbolic Computation: An International Journal, </title> <editor> v.1, n. </editor> <volume> 2, </volume> <pages> pp. 147-164. </pages>
Reference: 5. <author> Bloss, Adrienne, Hudak, P. and Young, J., </author> <year> 1989. </year> <title> An optimizing compiler for a modern functional language. </title> <journal> In The Computer Journal, v.32, </journal> <volume> n.2, </volume> <month> April, </month> <pages> pp. 152-161. </pages>
Reference-contexts: Abstract control structures Lazy evaluation provides a very useful increase in expressive power because it allows the programmer to design arbitrary control structures. Consider the following simple example, taken from Bloss, Hudak, and Young <ref> [5] </ref>.
Reference: 6. <author> Panel: </author> <title> nondeterminacy in functional programming: an essential feature or a programmer's nightmare. In High Performance Functional Computing Proceedings, </title> <editor> A. P. Wim Bohm and John T. Feo, eds., </editor> <month> April. </month> <pages> 4 pages. </pages>
Reference: 7. <author> Budd, Timothy A., </author> <year> 1994. </year> <title> LEDA: A blend of imperative and relational programming. </title> <note> To appear in IEEE Software. </note> <month> September. </month> <pages> 19 pages. </pages>
Reference-contexts: RELATED WORK In recent years, researchers have begun focusing attention on the concept of creating mixed-paradigm languages: mixing functional, relational and objectoriented paradigms [15], imperative and relational paradigms <ref> [7] </ref>, functional and imperative paradigms [23]. Most of this research has considered control structures and abstraction methods; to my knowledge, none of it has looked specifically at lazy evaluation.
Reference: 8. <author> Clinger, William, </author> <year> 1982. </year> <title> Nondeterministic call by need is neither lazy nor by name. </title> <booktitle> In Proceedings of the ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pp. 226-234. </pages>
Reference-contexts: Another name for call by value is "eager" evaluation. Call by value is also known as "applicative order" evaluation, because all arguments are evaluated before the function is applied to them. "Call by lazy" (using William Clinger's terminology in <ref> [8] </ref>) is the name given to procedure calls which use non-strict semantics. In languages with call by lazy procedure calls, the arguments are not evaluated before being substituted into the procedure body.
Reference: 9. <author> Friedman, D. P. and Wise, D.S., </author> <year> 1976. </year> <title> CONS should not evaluate its arguments. </title> <booktitle> In Automated Languages and Programming: Third International Colloquium at the University of Edinburgh, </booktitle> <editor> S. Michaelson and R. Milner, eds. </editor> <publisher> Edinburgh University Press, </publisher> <pages> pp. 257-284. </pages>
Reference-contexts: Call by need evaluation, therefore, extends call by lazy methods by using memoization to avoid the need for repeated evaluation. Friedman and Wise were among the earliest advocates of call by need evaluation, proposing "suicidal suspensions" which self-destructed when they were first evaluated, replacing themselves with their values <ref> [9] </ref>. 2.4. SINGULAR VS. PLURAL SEMANTICS Clinger made one more distinction: between "singular" and "plural" semantics. In the presence of nondeterminacy, there are two possible semantics for normal-order argument substitution in function calls. <p> P.J. Landin [16] first originated the idea of a non-strict data structure; the idea mostly languished until the publication of Friedman and Wise's "CONS should not evaluate its arguments" in 1976 <ref> [9] </ref>. The essential benefit of using delayed data structures is simple in concept: it separates the time at which a data structure is defined from the time at which its elements are actually constructed.
Reference: 10. <author> Frost, R. and Launchbury, J., </author> <year> 1989. </year> <title> Constructing natural languages interpreters in a lazy functional language. </title> <journal> In The Computer Journal, v.32, </journal> <volume> n.2, </volume> <month> April, </month> <pages> pp. 108-121. </pages>
Reference: 11. <editor> Hudak, Paul et. al, </editor> <year> 1992, </year> <title> Report on the programming language Haskell: a non-strict, purely functional language. </title> <journal> In ACM SIGPLAN Notices , v.27, </journal> <note> n.5, May, p. R-1. </note>
Reference-contexts: However, there are strict languages such as Scheme [21] which implement non-strict data constructors; these constructors will serve as the model for our application of lazy techniques to imperative languages. 3.1. NON-STRICT FUNCTION CALLS Several purely functional languages such as Haskell <ref> [11, 12] </ref>, Chalmers LML ("Lazy ML") [2], and Miranda1 [24] use non-strict semantics for all function calls: they do not evaluate the arguments of a function call before calling the function. There are two main advantages of using non-strict semantics for function calls.
Reference: 12. <author> Hudak, Paul and Fasel, Joseph H, </author> <year> 1992. </year> <title> A gentle introduction to Haskell. </title> <journal> In ACM SIGPLAN Notices, </journal> <note> v.27, n.5, May, p. T-1. </note>
Reference-contexts: However, there are strict languages such as Scheme [21] which implement non-strict data constructors; these constructors will serve as the model for our application of lazy techniques to imperative languages. 3.1. NON-STRICT FUNCTION CALLS Several purely functional languages such as Haskell <ref> [11, 12] </ref>, Chalmers LML ("Lazy ML") [2], and Miranda1 [24] use non-strict semantics for all function calls: they do not evaluate the arguments of a function call before calling the function. There are two main advantages of using non-strict semantics for function calls. <p> Hudak and Fasel present the idea of a lazy file reader, which places the sequential elements in an input file into a stream, which the program can then consume <ref> [12] </ref>. In this manner, a programmer can avoid the theoretically difficult problem of successive calls to the same function (a "read" function) which return different values each time.
Reference: 13. <author> Hughes, J, </author> <year> 1989. </year> <title> Why functional programming matters. </title> <journal> In The Computer Journal, v.32, </journal> <volume> n.2, </volume> <pages> pp. 98-107. </pages>
Reference-contexts: In "Why Functional Programming Matters," for instance, J. Hughes presents one such argument for the merits of functional programming over the imperative style <ref> [13] </ref>. His argument is based around two capabilities, absent from imperative languages but commonly found in functional languages: higher-order functions and lazy evaluation. He argues that each of these constructs provides a "glue" to assemble simpler programming constructs into more complicated abstractions. <p> The implementation of an alphabeta search in AI was presented by J. Hughes as one example of the usefulness of lazy evaluation <ref> [13] </ref>. While Hughes's example was set in the context of a fully non-strict language, it could be implemented just as easily using non-strict CONS cells to build the search tree.
Reference: 14. <author> Jones, S. B. and Sinclair, </author> <title> A.F., </title> <booktitle> 1989. Functional programming and operating systems. In The Computer Journal, </booktitle> <address> v.32, n.2, </address> <month> April, </month> <pages> pp. 162-174. </pages>
Reference-contexts: Both Hughes and Jones and Sinclair <ref> [14] </ref> discuss at some length the advantages of being able to compose complicated functions using lazy evaluation. Hughes asks what happens when we evaluate g (f (input)), where the value returned by f is either very large or even infinite (i.e. f is non-terminating).
Reference: 15. <author> Korth, Henry F., </author> <year> 1986. </year> <title> Extending the scope of relational languages. </title> <booktitle> In IEEE Software, </booktitle> <address> v.3, n.1, </address> <month> January, </month> <pages> pp. 19-28. - 23 </pages> - 
Reference-contexts: RELATED WORK In recent years, researchers have begun focusing attention on the concept of creating mixed-paradigm languages: mixing functional, relational and objectoriented paradigms <ref> [15] </ref>, imperative and relational paradigms [7], functional and imperative paradigms [23]. Most of this research has considered control structures and abstraction methods; to my knowledge, none of it has looked specifically at lazy evaluation.
Reference: 16. <author> Landin, P. J., </author> <year> 1965. </year> <title> A correspondence between ALGOL-60 and Church's lambda notation, part I. </title> <journal> In Communications of the ACM, </journal> <volume> v.8, </volume> <pages> pp. 89-101. </pages>
Reference-contexts: LAZY DATA STRUCTURES The second major area of application of delayed evaluation is concerned with constructing data objects whose elements are not evaluated until they are needed. P.J. Landin <ref> [16] </ref> first originated the idea of a non-strict data structure; the idea mostly languished until the publication of Friedman and Wise's "CONS should not evaluate its arguments" in 1976 [9]. <p> Streams In 1965, P. J. Landin proposed the idea of a "head-strict" CONS cell, in which the first argument is evaluated by CONS, and the second argument delayed until forced by using CDR <ref> [16] </ref>. Such a CONS would allow the construction of delayed lists. This idea evolved into the concept of "streams".
Reference: 17. <author> Mohr, E., Kranz, D., and Halstead Jr., R., </author> <year> 1991. </year> <title> Lazy task creation: a technique for increasing the granularity of parallel programs. </title> <journal> In IEEE Transactions on Parallel and Distributed Systems, v.2, </journal> <volume> n.3, </volume> <month> July, </month> <pages> 264-280. </pages>
Reference: 18. <author> Peter Naur (ed.), J. W. Backus, F. L. Bauer, J. Green, C. Katz, J. McCarthy, A. J. Perlis, H. Rutishauser, K. Samelson, B. Vauquois, J. H. Wegstein, A. van Wijngaarden, and M. Woodger, </author> <year> 1963. </year> <title> Revised report on the algorithmic language Algol-60. </title> <booktitle> In Communications of the ACM, </booktitle> <month> January </month> <year> 1963. </year>
Reference-contexts: Call by lazy evaluation is also known as "normal order" evaluation, because of the order (outermost to innermost, left to right) of evaluation of an expression. "Call by name" is a particular implementation of call by lazy, used in Algol-60 <ref> [18] </ref>. The designers of Algol-60 intended that call-by-name parameters be physically substituted into the procedure body, enclosed by parentheses and with suitable name changes to avoid conflicts, before the body was evaluated. 2.3. CALL BY LAZY VS.
Reference: 19. <editor> Peyton Jones, Simon L., </editor> <booktitle> The Implementation of Functional Programming Languages. </booktitle> <address> New York: </address> <publisher> Prentice-Hall Inc. </publisher> <pages> 445 pages. </pages>
Reference-contexts: Why has such a powerful tool not been applied to imperative languages? The next section briefly discusses some of the issues which make lazy evaluation difficult to implement in imperative languages. 4. WHY LAZY EVALUATION IS NOT IMPLEMENTED IN IMPERATIVE LANGUAGES In The Implementation of Functional Programming Languages <ref> [19] </ref>, Simon L. Peyton Jones presents two reasons why imperative languages rarely include delayed evaluation.
Reference: 20. <editor> Peyton Jones, Simon L. and Wadler, Philip, </editor> <year> 1993. </year> <title> Imperative functional programming. </title> <booktitle> In Conference Record of the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 71-84. </pages>
Reference-contexts: Because the stream is a lazy structure, these inputs and outputs can be interwoven, so that the result is an interactive process. Peyton Jones and - 8 - Wadler <ref> [20] </ref> demonstrate how this model can be used to handle input from a keyboard and output to a monitor. Hudak and Fasel extent this to consider the "user" as another process which consumes a stream of input and produces a stream of output. <p> For instance, Simon Jones and Philip Wadler have developed a treatment of the I/O problem using monads to confine the referential opacity to strictly-bounded and mathematically tractable portions of the code <ref> [20] </ref>. The focus of this work is on functional programming, however, rather than on imperative programming. Research is currently in progress on the use of "futures," a form of lazy evaluation which aids programming for parallel processing computers [17,26,27].
Reference: 21. <editor> Rees, J. and Clinger, W. eds., </editor> <year> 1986. </year> <title> The revised report on the algorithmic language Scheme. </title> <journal> In ACM SIGPLAN Notices, v.21, n.12, pp.37-79. </journal>
Reference-contexts: In a fully functional lazy language, lazy data structures are a byproduct of lazy evaluation: all data created using a function as a constructor are automatically lazy. However, there are strict languages such as Scheme <ref> [21] </ref> which implement non-strict data constructors; these constructors will serve as the model for our application of lazy techniques to imperative languages. 3.1.
Reference: 22. <author> Sondergaard, Harold and Sestoft, Peter, </author> <year> 1990. </year> <title> Referential transparency, definiteness, </title> <journal> and unfoldability. In Acta Informatica, v.27, </journal> <volume> n.6, </volume> <year> 1990, </year> <pages> pp. 505-517. </pages>
Reference-contexts: We consider each of these reasons in more detail below. 4.1. REFERENTIAL TRANSPARENCY Mathematically, lazy evaluation depends on the existence of referential transparency, which ensures that an expression will always evaluate to the same value, regardless of when it is evaluated or in what order. Sondergaard and Sestoft <ref> [22] </ref> found at least six different definitions for referential transparency in the literature. Referentially transparent languages, according to these definitions, must have one of the following properties: Extensionality.
Reference: 23. <author> Tu, Hai-Chen and Perlis, Alan J., </author> <year> 1986. </year> <title> FAC: a functional APL language. </title> <booktitle> In IEEE Software, </booktitle> <address> v.3, n.1, </address> <month> January, </month> <pages> pp. 36-46. </pages>
Reference-contexts: RELATED WORK In recent years, researchers have begun focusing attention on the concept of creating mixed-paradigm languages: mixing functional, relational and objectoriented paradigms [15], imperative and relational paradigms [7], functional and imperative paradigms <ref> [23] </ref>. Most of this research has considered control structures and abstraction methods; to my knowledge, none of it has looked specifically at lazy evaluation. A good deal of research has gone into the problems of using side effect-causing constructs (generally, those involving I/O) in functional languages.
Reference: 24. <author> Turner, David, </author> <year> 1990. </year> <title> An overview of Miranda. </title> <booktitle> in Research Topics in Functional Programming, </booktitle> <editor> D. A. Turner, ed., </editor> <publisher> Addison-Wesley Publishers. </publisher>
Reference-contexts: NON-STRICT FUNCTION CALLS Several purely functional languages such as Haskell [11, 12], Chalmers LML ("Lazy ML") [2], and Miranda1 <ref> [24] </ref> use non-strict semantics for all function calls: they do not evaluate the arguments of a function call before calling the function. There are two main advantages of using non-strict semantics for function calls.
Reference: 25. <author> Wadler, Philip, </author> <year> 1990. </year> <title> Comprehending monads. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 61-78. </pages>
Reference-contexts: The state stream would represent the effects of the state changes caused by the individual programs. Wadler <ref> [25] </ref> shows how to use this concept in a functional language to handle input and output which must be in a required sequence. The state stream acts as a synchronizer, enforcing a strict execution order on the various operations which transform input to output.
Reference: 26. <author> Wagner, David. B. and Calder, Bradley G., </author> <year> 1992, </year> <title> Portable, efficient futures. </title> <institution> Computer Science Technical Report #CU-CS-609-92, University of Colorado, Boulder, CO, </institution> <month> August. </month>
Reference: 27. <author> Wagner, David. B. and Calder, Bradley G., </author> <year> 1993. </year> <title> Leapfrogging: a portable technique for implementing efficient futures. </title> <journal> In ACM SIGPLAN Notices, v.28, </journal> <volume> n.7, </volume> <month> July, </month> <pages> pp. 208-217. </pages>
Reference: 28. <author> Wray, S. C. and Fairbairn, J., </author> <year> 1989. </year> <title> Non-strict languages programming and implementation. </title> <journal> In The Computer Journal, v. </journal> <volume> 32, n.2, </volume> <month> April, </month> <pages> pp. 142-151. </pages>
Reference-contexts: It is worth noting that these signal processing elements can have feedback loops, in which one of their inputs is their own output. Feedback signal generators are referred to as "almost-circular" definitions. Consider Wray and Fairbairn's example of a generating device which produces a stream of all natural numbers <ref> [28] </ref>.
Reference: 29. <institution> The Xerox Learning Research Group, </institution> <year> 1981. </year> <title> The Smalltalk-80 system. </title> <journal> In Byte Magazine, </journal> <month> August, </month> <pages> pp. 36-48. </pages>
Reference-contexts: A more complex example of this reasoning is the use of blocks to define arbitrary control structures in Smalltalk. A block in Smalltalk is essentially a delayed expression, passed to some object which may or may not force it using the "value" selector <ref> [29] </ref>. 3.2. LAZY DATA STRUCTURES The second major area of application of delayed evaluation is concerned with constructing data objects whose elements are not evaluated until they are needed. P.J.
References-found: 29

