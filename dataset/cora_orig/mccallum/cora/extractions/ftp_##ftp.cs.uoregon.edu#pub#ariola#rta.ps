URL: ftp://ftp.cs.uoregon.edu/pub/ariola/rta.ps
Refering-URL: http://www.cs.uoregon.edu/~ariola/publications.html
Root-URL: http://www.cs.uoregon.edu
Title: Relating Graph and Term Rewriting via Bohm Models  
Author: Zena M. Ariola 
Address: Eugene, OR 97403-1202  
Affiliation: Computer Information Science Department, University of Oregon  
Abstract: Dealing properly with sharing is important for expressing some of the common compiler optimizations, such as common subex-pressions elimination, lifting of free expressions and removal of invariants from a loop, as source-to-source transformations. Graph rewriting is a suitable vehicle to accommodate these concerns. In [4] we have presented a term model for graph rewriting systems (GRSs) without interfering rules, and shown the partial correctness of the aforementioned optimizations. In this paper we define a different model for GRSs, which allows us to prove total correctness of those optimizations. Differently from [4] we will discard sharing from our observations and introduce more restrictions on the rules. We will introduce the notion of Bohm tree for GRSs, and show that in a system without interfering and non-left linear rules (orthogonal GRSs), Bohm tree equivalence defines a congruence. Total correctness then follows in a straightforward way from showing that if a program M contains less sharing than a program N , then both M and N have the same Bohm tree. We will also show that orthogonal GRSs are a correct implementation of orthogonal TRSs. The basic idea of the proof is to show that the behavior of a graph can be deduced from its finite approximations, that is, graph rewriting is a continuous operation. Our approach differs from that of other researchers [6, 9], which is based on infinite rewriting.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Z. Ariola and Arvind. P-TAC: </author> <title> A Parallel Intermediate Language. </title> <booktitle> In Proc. ACM Conference on Functional Programming Languages and Computer Architecture, </booktitle> <address> London, </address> <month> September </month> <year> 1989. </year>
Reference-contexts: Moreover, due to its implicit parallelism it is also suitable as an intermediate language for compilation on parallel machines. We have successfully described the operational semantics and the compilation of Id [11] using two different graph rewriting systems, Kid and P-TAC <ref> [1, 2, 3] </ref>. Graph rewriting has usually been described in terms of labeled graphs and homomorphisms [5].
Reference: 2. <author> Z. Ariola and Arvind. </author> <title> A Syntactic Approach to Program Transformations. </title> <booktitle> In Proc. ACM SIGPLAN Symposium on Partial Evaluation and Semantics Based Program Manipulation, </booktitle> <institution> Yale University, </institution> <address> New Haven, CT, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: Moreover, due to its implicit parallelism it is also suitable as an intermediate language for compilation on parallel machines. We have successfully described the operational semantics and the compilation of Id [11] using two different graph rewriting systems, Kid and P-TAC <ref> [1, 2, 3] </ref>. Graph rewriting has usually been described in terms of labeled graphs and homomorphisms [5]. <p> A way of assuring that BT is a congruence is to show that for any context C <ref> [2] </ref> the behavior of C [M ] can be inferred from the observations about M ; that is, 8C [2]; C [M ] BT F fC [~a] j a 2 Print fl (M )g where Print fl ( F S fPrint fl (s) j s 2 Sg, and ~a represents the <p> A way of assuring that BT is a congruence is to show that for any context C <ref> [2] </ref> the behavior of C [M ] can be inferred from the observations about M ; that is, 8C [2]; C [M ] BT F fC [~a] j a 2 Print fl (M )g where Print fl ( F S fPrint fl (s) j s 2 Sg, and ~a represents the GRS form of a TRS term. <p> Consider the rule: x 1 = A (x 1 ) . Let M ft 0 = A (t 0 ) In t 0 g and C <ref> [2] </ref> ft 1 = G (t 2 ); t 2 = 2 In t 1 g, then we have C [M ] 6 BT F fC [~a] j a 2 Print fl (M )g because, Print fl (C [M ]) = f; 1g while Print fl (C [~a]) = fg, for <p> As another example, consider the rule: x 1 = A (y; y) . Let M ft = A (t 1 ; t 1 ); t 1 = B (0); In tg and C <ref> [2] </ref> ft 1 = G (t 2 ); t 2 = 2 In t 1 g. <p> Then we have C [M ] 6 BT F fC [~a] j a 2 Print fl (M )g, because, Print fl (C [M ]) = f; 1g while Print fl (C [~a]) = fg, for any observation a of M . The direction 8C <ref> [2] </ref>; F fC [~a] j a 2 Print fl (M )g v BT C [M ] trivially follows from the monotonicity of v BT with respect to the ! ordering. Lemma 17 Monotonicity of v BT with respect to ! .
Reference: 3. <author> Z. Ariola and Arvind. </author> <title> Compilation of Id. </title> <booktitle> In Proc. of the Fourth Worskshop on Languages and Compilers for Parallel Computing, </booktitle> <address> Santa Clara, California, </address> <publisher> Springer-Verlag LNCS 589, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: Moreover, due to its implicit parallelism it is also suitable as an intermediate language for compilation on parallel machines. We have successfully described the operational semantics and the compilation of Id [11] using two different graph rewriting systems, Kid and P-TAC <ref> [1, 2, 3] </ref>. Graph rewriting has usually been described in terms of labeled graphs and homomorphisms [5].
Reference: 4. <author> Z. Ariola and Arvind. </author> <title> Graph Rewriting Systems For Efficient Compilation, chapter 6. </title> <publisher> John Wiley & Sons, </publisher> <year> 1993. </year>
Reference-contexts: We have successfully described the operational semantics and the compilation of Id [11] using two different graph rewriting systems, Kid and P-TAC [1, 2, 3]. Graph rewriting has usually been described in terms of labeled graphs and homomorphisms [5]. Instead, in <ref> [4] </ref> we have introduced a novel approach to graph rewriting systems (GRSs), where the graph is represented as a set of mutually recursive equations, i.e., a letrec expression, and reduction is explained in a way similar to term rewriting. In [4] we have also presented a term model for GRSs without <p> Instead, in <ref> [4] </ref> we have introduced a novel approach to graph rewriting systems (GRSs), where the graph is represented as a set of mutually recursive equations, i.e., a letrec expression, and reduction is explained in a way similar to term rewriting. In [4] we have also presented a term model for GRSs without interfering (i.e., overlapping) rules, where the terms in the model are graphs and showed that a less-sharing relation corresponds to the pre-congruence relation induced by the model. <p> As an example, consider the following terms M and N , respectively. Notice that M &lt; N , where &lt; is the sharing relation, and as such, according to the model in <ref> [4] </ref>, M v N , where v is the relation induced by the model. In other words, we would say that M will produce less observable information than N in any context. <p> Moreover, we will show that the relation of less-sharing introduced in <ref> [4] </ref> guarantees the Bohm tree equivalence, and thus showing the total correctness of the optimizations that only affect sharing. The Bohm tree model also constitutes an adequate notion for comparing GRSs and TRSs. <p> The notion of Bohm tree allows us to consider cyclic graphs, differently from [5]. We conclude the paper with our thoughts on future work. This paper is self contained and only requires some understanding of TRSs. In particular, the model presented can be understood without reading <ref> [4] </ref>. 2 Overview of a GRS We express graph rewriting through a novel system, called a GRS. The objects of a GRS are simply a set of mutually recursive equations, i.e., letrec expressions, instead of being complicated objects such as labeled graphs. <p> In that respect notice that if a term contains a binding of the kind "x = x" then we will substitute a constant, ffi, for each occurrence of x; ffi stands for a circular binding. As shown in <ref> [4] </ref> this guarantees the confluence of a certain subclass of GRSs. Furthermore, the internal block structure of a term is merely syntactic sugar, that is, all internal blocks are flattened to compute the canonical form. <p> We will also make use of the notation M [F e], where F is a set of redexes, indicating that all redexes in F are replaced by the expression e. GRSs are formally introduced in <ref> [4] </ref>, where GRSs without interfering rules are proved to be confluent. <p> Notice that the above term will also be reduced to if we replace the second rule by x = G (y) ! x = 1, that is, the !-rules are generated without analyzing the right hand side of rules. In <ref> [4] </ref> the stable part of a term was computed by applying the !-reductions on the term obtained by replacing all its redexes by , that is, sharing was part of our observations. Instead, in this paper we go one step further by considering the expansions or finite information. <p> Instead, in this paper we go one step further by considering the expansions or finite information. For example, consider the rule: x 1 = A (y) , and the term M ft = F (t) In tg. Since M does not contain a redex, following <ref> [4] </ref>, we will consider M as stable information. <p> Definition 12 Answer of a GRS Term. Given a GRS term M , the answer of M is Print fl (M ) = S fPrint (M 0 ) j M !! M 0 g: Since orthogonal GRSs are confluent <ref> [4] </ref>, in order to guarantee that the answer is well defined, it is sufficient to show that the printable value is monotonic with respect to reduction. To that end, let us introduce an ordering, ! , on GRS terms, which captures both the sharing and the prefix ordering. <p> Suppose C [M ] !! N . By the com-mutativity of a GRS <ref> [4] </ref> we have that 9M 0 ; C [M ] !! C [M 0 ] and C [M 0 ] reduces to N without performing any redexes occurring in M 0 , i.e., C [M 0 ] %! M 0 N .
Reference: 5. <author> H. Barendregt, M. van Eekelen, J. Glauert, J. Kennaway, M. Plasmeijer, and M. Sleep. </author> <title> Term Graph Rewriting. </title> <booktitle> In Proceedings of the PARLE Conference, </booktitle> <address> Eind-hoven, The Netherlands, </address> <publisher> Springer-Verlag LNCS 259, </publisher> <pages> pages 141-158, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: We have successfully described the operational semantics and the compilation of Id [11] using two different graph rewriting systems, Kid and P-TAC [1, 2, 3]. Graph rewriting has usually been described in terms of labeled graphs and homomorphisms <ref> [5] </ref>. Instead, in [4] we have introduced a novel approach to graph rewriting systems (GRSs), where the graph is represented as a set of mutually recursive equations, i.e., a letrec expression, and reduction is explained in a way similar to term rewriting. <p> Moreover, we will show that the relation of less-sharing introduced in [4] guarantees the Bohm tree equivalence, and thus showing the total correctness of the optimizations that only affect sharing. The Bohm tree model also constitutes an adequate notion for comparing GRSs and TRSs. Barendregt et al. <ref> [5] </ref> base the relation between GRSs and TRSs on the notion of normal form, which leads to some undesirable conclusions. We believe that the notion of normal form is inadequate for such a comparison. <p> Finally, using the notion of Bohm tree, in Section 4 we will show that orthogonal GRSs are a correct implementation of orthogonal term rewriting systems (TRSs). The notion of Bohm tree allows us to consider cyclic graphs, differently from <ref> [5] </ref>. We conclude the paper with our thoughts on future work. This paper is self contained and only requires some understanding of TRSs. In particular, the model presented can be understood without reading [4]. 2 Overview of a GRS We express graph rewriting through a novel system, called a GRS.
Reference: 6. <author> W. Farmer and R. Watro. </author> <title> Redex Capturing in Term Graph Rewriting. </title> <type> Technical Report M89-59, </type> <institution> MITRE corporation, Massachusetts, </institution> <year> 1989. </year>
Reference-contexts: On the other hand, our approach is based on showing that the behavior of a graph can be deduced from its finite approximations. In other words, we show that graph rewriting is a continuous operation. This approach is different from that of other researchers <ref> [6, 9] </ref>. For example, Farmer and Watro [6] have shown the soundness of the cyclic Y-rule based on infinite rewriting. Similarly the approach taken by Klop et al. [9] is also based on rewriting infinite terms. In Section 2 we will briefly introduce the reader to graph rewriting systems (GRSs). <p> In other words, we show that graph rewriting is a continuous operation. This approach is different from that of other researchers [6, 9]. For example, Farmer and Watro <ref> [6] </ref> have shown the soundness of the cyclic Y-rule based on infinite rewriting. Similarly the approach taken by Klop et al. [9] is also based on rewriting infinite terms. In Section 2 we will briefly introduce the reader to graph rewriting systems (GRSs).
Reference: 7. <author> M. Hennessy. </author> <title> Algebraic Theory of Processes. </title> <publisher> MIT Press, </publisher> <year> 1988. </year>
Reference-contexts: Given a GRS, the set of all finite observations is !-T rees = S f!(M k ) j 8 GRS terms M; k 0g: Since we want to guarantee that infinite chains have a limit, we turn !-T rees into a complete partial order using the ideal completion method <ref> [7] </ref>. Definition 9 Bohm Domain: !-T rees 1 .
Reference: 8. <author> G. Huet and J.-J. Levy. </author> <title> Computations in Orthogonal Rewriting Systems 1 and </title>
Reference-contexts: To cope with this phenomenon in the -calculus, both Wadsworth [12] and Levy [10] have introduced the notion of !-rule, which states P ! . Huet and Levy have applied the same concept to orthogonal TRSs <ref> [8] </ref>. Analogously, for GRSs we introduce a set of !-rules.
Reference: 2. <editor> In Computational logic. Essays in Honor of Alan Robinson. Ed. J.-L. Lassez & G.D. Plotkin, </editor> <year> 1991. </year>
Reference-contexts: Moreover, due to its implicit parallelism it is also suitable as an intermediate language for compilation on parallel machines. We have successfully described the operational semantics and the compilation of Id [11] using two different graph rewriting systems, Kid and P-TAC <ref> [1, 2, 3] </ref>. Graph rewriting has usually been described in terms of labeled graphs and homomorphisms [5]. <p> A way of assuring that BT is a congruence is to show that for any context C <ref> [2] </ref> the behavior of C [M ] can be inferred from the observations about M ; that is, 8C [2]; C [M ] BT F fC [~a] j a 2 Print fl (M )g where Print fl ( F S fPrint fl (s) j s 2 Sg, and ~a represents the <p> A way of assuring that BT is a congruence is to show that for any context C <ref> [2] </ref> the behavior of C [M ] can be inferred from the observations about M ; that is, 8C [2]; C [M ] BT F fC [~a] j a 2 Print fl (M )g where Print fl ( F S fPrint fl (s) j s 2 Sg, and ~a represents the GRS form of a TRS term. <p> Consider the rule: x 1 = A (x 1 ) . Let M ft 0 = A (t 0 ) In t 0 g and C <ref> [2] </ref> ft 1 = G (t 2 ); t 2 = 2 In t 1 g, then we have C [M ] 6 BT F fC [~a] j a 2 Print fl (M )g because, Print fl (C [M ]) = f; 1g while Print fl (C [~a]) = fg, for <p> As another example, consider the rule: x 1 = A (y; y) . Let M ft = A (t 1 ; t 1 ); t 1 = B (0); In tg and C <ref> [2] </ref> ft 1 = G (t 2 ); t 2 = 2 In t 1 g. <p> Then we have C [M ] 6 BT F fC [~a] j a 2 Print fl (M )g, because, Print fl (C [M ]) = f; 1g while Print fl (C [~a]) = fg, for any observation a of M . The direction 8C <ref> [2] </ref>; F fC [~a] j a 2 Print fl (M )g v BT C [M ] trivially follows from the monotonicity of v BT with respect to the ! ordering. Lemma 17 Monotonicity of v BT with respect to ! .
Reference: 9. <author> J. Kennaway, J. Klop, M. Sleep, and F. de Vries. </author> <title> Transfinite Reductions in Orthogonal Term Rewriting Systems. </title> <booktitle> In Proc. RTA '91, </booktitle> <publisher> Springer-Verlag LNCS, </publisher> <year> 1991. </year>
Reference-contexts: On the other hand, our approach is based on showing that the behavior of a graph can be deduced from its finite approximations. In other words, we show that graph rewriting is a continuous operation. This approach is different from that of other researchers <ref> [6, 9] </ref>. For example, Farmer and Watro [6] have shown the soundness of the cyclic Y-rule based on infinite rewriting. Similarly the approach taken by Klop et al. [9] is also based on rewriting infinite terms. In Section 2 we will briefly introduce the reader to graph rewriting systems (GRSs). <p> In other words, we show that graph rewriting is a continuous operation. This approach is different from that of other researchers [6, 9]. For example, Farmer and Watro [6] have shown the soundness of the cyclic Y-rule based on infinite rewriting. Similarly the approach taken by Klop et al. <ref> [9] </ref> is also based on rewriting infinite terms. In Section 2 we will briefly introduce the reader to graph rewriting systems (GRSs). We restrict our attention to GRSs which are adequate to describe sharing in combinatory systems.
Reference: 10. <author> J.-J. Levy. </author> <title> Reductions Correctes et Optimales dans le Lambda-Calcul. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <month> October </month> <year> 1978. </year>
Reference-contexts: The printable value corresponds to the notions of instant semantics [15] and direct approximation <ref> [10, 12] </ref> introduced for the -calculus. As for the -calculus, all redexes must first be substituted by a new constant , which stands for no information. However, this is not enough to guarantee the monotonicity of the information content with respect to reduction. <p> The problem is due to the upward creation of redexes; that is, even though a term M is not a redex, it can become so when some redexes under it are performed. To cope with this phenomenon in the -calculus, both Wadsworth [12] and Levy <ref> [10] </ref> have introduced the notion of !-rule, which states P ! . Huet and Levy have applied the same concept to orthogonal TRSs [8]. Analogously, for GRSs we introduce a set of !-rules.
Reference: 11. <author> R. S. Nikhil. </author> <title> Id (Version 90.0) Reference Manual. </title> <type> Technical Report CSG Memo 284-a, </type> <institution> MIT Laboratory for Computer Science, 545 Technology Square, </institution> <address> Cambridge, MA 02139, USA, </address> <month> July </month> <year> 1990. </year>
Reference-contexts: Moreover, due to its implicit parallelism it is also suitable as an intermediate language for compilation on parallel machines. We have successfully described the operational semantics and the compilation of Id <ref> [11] </ref> using two different graph rewriting systems, Kid and P-TAC [1, 2, 3]. Graph rewriting has usually been described in terms of labeled graphs and homomorphisms [5].
Reference: 12. <author> C. Wadsworth. </author> <title> Semantics And Pragmatics Of The Lambda-Calculus. </title> <type> PhD thesis, </type> <institution> University of Oxford, </institution> <month> September </month> <year> 1971. </year>
Reference-contexts: The printable value corresponds to the notions of instant semantics [15] and direct approximation <ref> [10, 12] </ref> introduced for the -calculus. As for the -calculus, all redexes must first be substituted by a new constant , which stands for no information. However, this is not enough to guarantee the monotonicity of the information content with respect to reduction. <p> The problem is due to the upward creation of redexes; that is, even though a term M is not a redex, it can become so when some redexes under it are performed. To cope with this phenomenon in the -calculus, both Wadsworth <ref> [12] </ref> and Levy [10] have introduced the notion of !-rule, which states P ! . Huet and Levy have applied the same concept to orthogonal TRSs [8]. Analogously, for GRSs we introduce a set of !-rules.
Reference: 13. <author> C. Wadsworth. </author> <title> The Relation between Computational and Denotational Properties for Scott's D 1 -Models of the Lambda-Calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 5, </volume> <year> 1976. </year>
Reference-contexts: We believe that the notion of normal form is inadequate for such a comparison. This point was already stressed by Wadsworth in his analysis of the relation between the syntactic and the semantic aspects of the -calculus <ref> [13, 14] </ref>. On the other hand, our approach is based on showing that the behavior of a graph can be deduced from its finite approximations. In other words, we show that graph rewriting is a continuous operation. This approach is different from that of other researchers [6, 9].
Reference: 14. <author> C. Wadsworth. </author> <title> Approximate Reduction and Lambda Calculus Models. </title> <journal> Theoretical Computer Science, </journal> <volume> 7, </volume> <year> 1978. </year>
Reference-contexts: We believe that the notion of normal form is inadequate for such a comparison. This point was already stressed by Wadsworth in his analysis of the relation between the syntactic and the semantic aspects of the -calculus <ref> [13, 14] </ref>. On the other hand, our approach is based on showing that the behavior of a graph can be deduced from its finite approximations. In other words, we show that graph rewriting is a continuous operation. This approach is different from that of other researchers [6, 9].
Reference: 15. <author> P. Welch. </author> <title> Continuous Semantics and Inside-out Reductions. In -Calculus and Computer Science Theory, </title> <publisher> Italy (Springer-Verlag LNCS 37), </publisher> <month> March </month> <year> 1975. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: The printable value corresponds to the notions of instant semantics <ref> [15] </ref> and direct approximation [10, 12] introduced for the -calculus. As for the -calculus, all redexes must first be substituted by a new constant , which stands for no information. However, this is not enough to guarantee the monotonicity of the information content with respect to reduction.
References-found: 16

