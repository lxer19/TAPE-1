URL: http://www.cs.kuleuven.ac.be/publicaties/rapporten/cw/CW246.ps.gz
Refering-URL: http://www.cs.kuleuven.ac.be/publicaties/rapporten/CW1997.html
Root-URL: 
Email: e-mail fstefaan,dannydg@cs.kuleuven.ac.be  e-mail massimo@hilbert.math.unipd.it  
Title: Exploiting the Power of Typed Norms in Automatic Inference of Interargument Relations  
Author: Stefaan Decorte Danny De Schreye Massimo Fabris 
Address: Celestijnenlaan 200A, B-3001 Heverlee, Belgium.  Via Belzoni 7, 35131 Padova Italy  
Affiliation: Department of Computer Science, K.U.Leuven,  Dip. di Matematica Pura e Applicata, Universita di Padova  
Abstract: Recently, the introduction of type formalisms for statically analysing logic programs has become a commonly applied technique. More specifically in termination analysis, typed norms have been introduced as a refined way to measure the sizes of terms and atoms. While the expressiveness of these typed norms makes them practically indispensable for a refined termination analysis particularly when proving termination of queries with partially instantiated terms -, it was not clear how relations between the sizes of (differently measured) arguments of predicates could be derived, and what sense they would make. We present a technique based on abstract interpretation for computing such relations and indicate its role in termination analysis. The resulting analysis extends the power of some of the more refined automatic termination analysis techniques presented previously.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Barbuti, R. Giacobazzi, and G. Levi. </author> <title> A general framework for semantics-based bottom-up abstract interpretation of logic programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 133-181, </pages> <year> 1991. </year>
Reference-contexts: A main distinction with respect to [ 19 ] besides of the focus on typed norms and the improved expressivity this entails is the use of the bottom-up abstract interpretation framework of <ref> [ 1 ] </ref> , which reduces the technical complexity of the analysis. The main advantage of this framework being that we can abstract away from the operational semantics of SLD-resolution, used in top-down abstract interpretation frameworks. The remainder of the paper is organised as follows. <p> An alternative is to use the bottom-up type inference of <ref> [ 1 ] </ref> . However, here the problem is that such an approach does not easily allow to take the call information, with which a clause is entered, into account. 3. <p> In this paper we consider the T P semantics and we adopt the bottom-up abstract interpretation of <ref> [ 1 ] </ref> . The basic operation is the abstract interpretation of unification.
Reference: [2] <author> A. Bossi, N. Cocco, and M. Fabris. </author> <title> Proving termination of logic programs by exploiting term properties. </title> <booktitle> In Proc. CCPSD-TAPSOFT'91, </booktitle> <pages> pages 153-180. </pages> <publisher> Springer-Verlag, LNCS 494, </publisher> <year> 1991. </year>
Reference-contexts: from terms to natural numbers, interpreted as measuring the size of each term, are referred to as norms and form the basis of the well-founded orderings used to prove termination in many techniques (e.g. [ 15 ] , [ 13 ] , [ 14 ] , [ 20 ] , <ref> [ 2 ] </ref> , [ 18 ] , [ 6 ] , [ 16 ] ). 2) Types allow to select the norm in such a way that the norm of those terms in the derivations that are taken into account for the well-founded ordering (which can be thought of as <p> 1 and jj:jj t 2 are defined as jj [t 1 jt 2 ]jj t 1 = jjt 2 jj t 2 + jjt 2 jj t 1 jjtjj t 1 = 0, for any other term and jjtjj t 2 = 0, for any other term Clearly, the term <ref> [[1; 2] </ref>] belongs to the type t 1 as well as to t 2 , and jj [[1; 2]]jj t 1 = 2, while jj [[1; 2]]jj t 2 = 1. <p> jjt 2 jj t 2 + jjt 2 jj t 1 jjtjj t 1 = 0, for any other term and jjtjj t 2 = 0, for any other term Clearly, the term <ref> [[1; 2] </ref>] belongs to the type t 1 as well as to t 2 , and jj [[1; 2]]jj t 1 = 2, while jj [[1; 2]]jj t 2 = 1. The purpose of allowing the generality of typed norms is both to facilitate the automatic inference of "suitable" norms from type information (see [ 7 ] ) and to improve the expressivity of interargument relations. <p> jj t 1 jjtjj t 1 = 0, for any other term and jjtjj t 2 = 0, for any other term Clearly, the term <ref> [[1; 2] </ref>] belongs to the type t 1 as well as to t 2 , and jj [[1; 2]]jj t 1 = 2, while jj [[1; 2]]jj t 2 = 1. The purpose of allowing the generality of typed norms is both to facilitate the automatic inference of "suitable" norms from type information (see [ 7 ] ) and to improve the expressivity of interargument relations. <p> In fact, this syntactic verification forms the key criterion for inferring the norms from the given types. As argued in [ 7 ] , typed norms can easily be integrated into existing termination analysis techniques, such as [ 6 ] , [ 20 ] , <ref> [ 2 ] </ref> . Only one aspect of the termination analysis is an exception in this respect : the inference of the interargument relations. <p> In this paper we follow the termination analysis framework of [ 6 ] . This is not a limitation in the sense that most of the results in the following sections can easily be integrated in other frameworks, such as e.g. <ref> [ 2 ] </ref> . To simplify the discussion, we recall the key notions of [ 6 ] in the context of directly recursive programs only. In what follows, ~ denotes the variant relation on both atoms and terms.
Reference: [3] <author> A. Bossi, N. Cocco, and M. Fabris. </author> <title> Typed norms. </title> <editor> In B. Krieg-Brueckner, editor, </editor> <booktitle> Proc. ESOP'92, </booktitle> <pages> pages 73-92. </pages> <publisher> Springer-Verlag, LNCS 582, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction Types are fulfilling an increasingly important role in state of the art approaches to Logic Program termination analysis (e.g. [ 4 ] , [ 17 ] , <ref> [ 3 ] </ref> , [ 7 ] ). The main reason for this is that one wants to be able to study termination properties of programs for queries containing partially instantiated terms. <p> At first sight, this can be regarded as a minor, technical point. It should be observed however that, although [ 20 ] is one of the more powerful automatic termination techniques available, the method was still based on ordinary norms. In [ 7 ] , <ref> [ 3 ] </ref> and [ 4 ] it has been clearly pointed out that termination analysis for non-ground queries can be significantly improved only if type information is taken into account. <p> Moreover, practically all the examples mentioned in [ 7 ] , which fall outside the scope of [ 17 ] , can successfully be handled by our extension. Flatten is just one representative of this class. Others are the tree-to-list conversion and the change predicate. See <ref> [ 3 ] </ref> for a more extensive list. In view of full automation, the only component of our approach of which automation was not described in this paper is the generation of consistently success-typed programs.
Reference: [4] <author> F. Bronsard, T.K. Lakshman, and U.S. Reddy. </author> <title> A framework of directionality for proving termination of logic programs. </title> <editor> In Krzysztof Apt, editor, </editor> <booktitle> Proc. JICSLP '92, </booktitle> <pages> pages 321-335. </pages> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction Types are fulfilling an increasingly important role in state of the art approaches to Logic Program termination analysis (e.g. <ref> [ 4 ] </ref> , [ 17 ] , [ 3 ] , [ 7 ] ). The main reason for this is that one wants to be able to study termination properties of programs for queries containing partially instantiated terms. <p> At first sight, this can be regarded as a minor, technical point. It should be observed however that, although [ 20 ] is one of the more powerful automatic termination techniques available, the method was still based on ordinary norms. In [ 7 ] , [ 3 ] and <ref> [ 4 ] </ref> it has been clearly pointed out that termination analysis for non-ground queries can be significantly improved only if type information is taken into account.
Reference: [5] <author> D. De Schreye and S. Decorte. </author> <title> Termination of logic programs: the never-ending story. </title> <journal> Journal of Logic Programming, </journal> <note> (Special anniversary edition), 1994. Accepted for publication. </note>
Reference-contexts: The main trade-off in this attempt is to avoid too much decrease in precision. With respect to related work on inference of interargument relations, we refer to <ref> [ 5 ] </ref> 18 for an overview. That paper also discusses the differences in expressivity, e.g. in relation to the use of systems of linear equations.
Reference: [6] <author> D. De Schreye, K. Verschaetse, and M. Bruynooghe. </author> <title> A framework for analysing the termination of definite logic programs with respect to call patterns. </title> <booktitle> In Proc. FGCS'92, </booktitle> <pages> pages 481-488, </pages> <address> ICOT Tokyo, 1992. </address> <publisher> ICOT. </publisher>
Reference-contexts: the size of each term, are referred to as norms and form the basis of the well-founded orderings used to prove termination in many techniques (e.g. [ 15 ] , [ 13 ] , [ 14 ] , [ 20 ] , [ 2 ] , [ 18 ] , <ref> [ 6 ] </ref> , [ 16 ] ). 2) Types allow to select the norm in such a way that the norm of those terms in the derivations that are taken into account for the well-founded ordering (which can be thought of as the 'input' terms) is guaranteed not to grow <p> In fact, this syntactic verification forms the key criterion for inferring the norms from the given types. As argued in [ 7 ] , typed norms can easily be integrated into existing termination analysis techniques, such as <ref> [ 6 ] </ref> , [ 20 ] , [ 2 ] . Only one aspect of the termination analysis is an exception in this respect : the inference of the interargument relations. <p> So, measuring terms of different types in different ways (especially, measuring a same term differently depending on the considered type) can be expected to obscure the termination argument. In this paper we follow the termination analysis framework of <ref> [ 6 ] </ref> . This is not a limitation in the sense that most of the results in the following sections can easily be integrated in other frameworks, such as e.g. [ 2 ] . To simplify the discussion, we recall the key notions of [ 6 ] in the context <p> the termination analysis framework of <ref> [ 6 ] </ref> . This is not a limitation in the sense that most of the results in the following sections can easily be integrated in other frameworks, such as e.g. [ 2 ] . To simplify the discussion, we recall the key notions of [ 6 ] in the context of directly recursive programs only. In what follows, ~ denotes the variant relation on both atoms and terms. Definition 2.10 (call set) Let P be a definite program and S a set of atomic queries with a fixed predicate symbol. <p> A 0 ) = exists, * for any atom B i , such that I j= B j ; 1 j &gt; i and having the same predicate symbol as A : 7 f (A) &gt; f (B i ) The following proposition is one of the key results in <ref> [ 6 ] </ref> . Proposition 2.13 A directly recursive program P terminates for any query in S if and only if P is acceptable wrt S. From the above it becomes clear that the extension from norms to typed norms has no impact on the termination conditions as such. <p> Thus, the call and descending recursive call are measured in the same way, and Definition 2.12 remains to capture well-founding and termination. The problem of providing the model I in the definition of acceptability is a quite different matter. In <ref> [ 6 ] </ref> this is done by computing an interargument relation for the intermediate atoms B 1 ; ; B i1 . This in turn is achieved through abstract interpretation, as discussed in [ 18 ] .
Reference: [7] <author> S. Decorte, D. De Schreye, and M. Fabris. </author> <title> Automatic inference of norms : a missing link in automatic termination analysis. </title> <editor> In D. Miller, editor, </editor> <booktitle> Proceedings ILPS'93, </booktitle> <pages> pages 420-436, </pages> <address> Vancouver, Canada, </address> <year> 1993. </year>
Reference-contexts: 1 Introduction Types are fulfilling an increasingly important role in state of the art approaches to Logic Program termination analysis (e.g. [ 4 ] , [ 17 ] , [ 3 ] , <ref> [ 7 ] </ref> ). The main reason for this is that one wants to be able to study termination properties of programs for queries containing partially instantiated terms. <p> Such upperbounds are typically derived from the term, the type of all possible further instantiation that can occur on it in future derivation steps and the norm itself. In <ref> [ 7 ] </ref> we propose a technique for inferring appropriate norms from type information. The inferred norms are slightly more general than the ones mentioned above. In the setting of [ 7 ] , a typed norm is a function which maps every pair (t; t ), consisting of a term <p> In <ref> [ 7 ] </ref> we propose a technique for inferring appropriate norms from type information. The inferred norms are slightly more general than the ones mentioned above. In the setting of [ 7 ] , a typed norm is a function which maps every pair (t; t ), consisting of a term t and a type t such that t belongs to t , to a natural number. <p> The purpose of allowing the generality of typed norms is both to facilitate the automatic inference of "suitable" norms from type information (see <ref> [ 7 ] </ref> ) and to improve the expressivity of interargument relations. Here, an interargument relation refers to a relation that holds between the (typed) norms of the terms in different argument positions (measured according to each argument's type) of success instances of a predicate. <p> No "non-typed" norm is capable of representing this, since even expressing this relation requires norms that do assign different sizes to a same term, depending on the type it is considered to belong to. The main property of the typed norms inferred in <ref> [ 7 ] </ref> is rigidity. For any term t 1 of type t 1 and for any substitution : jjt 1 jj t 1 = jjt 1 jj t 1 . Note that normal rigid types are substitution closed, so that jjt 1 jj t 1 is well defined. <p> Rigidity of (typed) norms is a conservative way of ensuring that no unbounded growth of the norm of a term can occur due to further derivation steps. In general, it is also a practical way of ensuring it, since for typed norms it can be syntactically verified (see <ref> [ 7 ] </ref> ). In fact, this syntactic verification forms the key criterion for inferring the norms from the given types. As argued in [ 7 ] , typed norms can easily be integrated into existing termination analysis techniques, such as [ 6 ] , [ 20 ] , [ 2 <p> In general, it is also a practical way of ensuring it, since for typed norms it can be syntactically verified (see <ref> [ 7 ] </ref> ). In fact, this syntactic verification forms the key criterion for inferring the norms from the given types. As argued in [ 7 ] , typed norms can easily be integrated into existing termination analysis techniques, such as [ 6 ] , [ 20 ] , [ 2 ] . Only one aspect of the termination analysis is an exception in this respect : the inference of the interargument relations. <p> Only one aspect of the termination analysis is an exception in this respect : the inference of the interargument relations. As we reported in <ref> [ 7 ] </ref> , a rather straightforward extension of the technique proposed in [ 19 ] to the case of typed norms will be sound, but the loss in precision is most often unacceptable. We refer to subsection 2.3 for a discussion of the problems. <p> A rigid type graph T describes a (possibly infinite) set of finite terms. This set of finite terms is found by means of the denotation function, ID. We refer to ( [ 12 ] , Def. 2.3.4 and following) for formal definition. In <ref> [ 7 ] </ref> , the function TypeLabel was introduced to regard a rigid type graph as a specification of a set of rigid types : every node in the type graph can be considered as the root of a new type graph, defined by the subgraph rooted at that node. <p> The successor type label set of n; succ label (n) is defined as succ label (n) = fL j 9 (n; m) 2 F orArcs [ BackArcs ^ m 0 2 P rincipal (m) ^T ypeLabel (m 0 ) = Lg: Given a normal type T , in <ref> [ 7 ] </ref> the authors faced the problem of deriving a norm which makes all terms in the denotation of the type rigid. 5 Definition 2.6 (typed norm induced by a TypeLabel in a normal type) Let T be a labelled normal type and L = T ypeLabel (n) the TypeLabel <p> Let jj:jj S 1 ; ; jj:jj S m be any sequence of associated typed norms generated for S 1 ; ; S m following <ref> [ 7 ] </ref> . <p> In the setting of typed norms the notion of an interargument relation needs to be specialised wrt the types of the argument positions. In the following definition, we assume that for any type T a corresponding typed norm jj:jj T generated as in <ref> [ 7 ] </ref> has been fixed. Definition 2.14 (interargument relation wrt a tuple of types) Let p=n be a predicate of P and (T 1 ; ; T n ) an n-tuple of normal rigid types. <p> At first sight, this can be regarded as a minor, technical point. It should be observed however that, although [ 20 ] is one of the more powerful automatic termination techniques available, the method was still based on ordinary norms. In <ref> [ 7 ] </ref> , [ 3 ] and [ 4 ] it has been clearly pointed out that termination analysis for non-ground queries can be significantly improved only if type information is taken into account. Furthermore, [ 7 ] convincingly shows that types allow for improved automatic inference of norms and <p> In <ref> [ 7 ] </ref> , [ 3 ] and [ 4 ] it has been clearly pointed out that termination analysis for non-ground queries can be significantly improved only if type information is taken into account. Furthermore, [ 7 ] convincingly shows that types allow for improved automatic inference of norms and that the expressivity of the typed norms is a significant enhancement. <p> On the level of practicality, our approach can deal with any of the programs successfully studied in [ 17 ] , since typed norms extend non-typed ones. Moreover, practically all the examples mentioned in <ref> [ 7 ] </ref> , which fall outside the scope of [ 17 ] , can successfully be handled by our extension. Flatten is just one representative of this class. Others are the tree-to-list conversion and the change predicate. See [ 3 ] for a more extensive list.
Reference: [8] <author> S. Decorte, D. De Schreye, and M. Fabris. </author> <title> Exploiting the power of typed norms in automatic inference of interargument relations. </title> <type> Technical report, </type> <institution> Department of Computer Science, K.U.Leuven, Belgium, </institution> <year> 1994. </year>
Reference-contexts: Others are the tree-to-list conversion and the change predicate. See [ 3 ] for a more extensive list. In view of full automation, the only component of our approach of which automation was not described in this paper is the generation of consistently success-typed programs. In <ref> [ 8 ] </ref> we give a constructive transformation that assigns a consistently success-typed program to any given program, predicate and tuple of success types. The transformation relies on an abstract interpretation with reexecution.
Reference: [9] <author> G. Janssens and M. Bruynooghe. </author> <title> Deriving descriptions of possible values of program variables by means of abstract interpretation. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(2 </volume> & 3):205-258, 1992. 
Reference-contexts: The type system is that of normal rigid types introduced in <ref> [ 9 ] </ref> . Under a typed norm, a same term can be measured in different ways depending on the type it is considered to belong to. These different type memberships will typically result from the different argument positions of predicates in which that same term may occur. <p> A type inference system (e.g. <ref> [ 9 ] </ref> ) allows to derive that any descending call has the same types. <p> Section 4 presents the abstract domain and the abstract analysis. In section 5 we present a detailed example. Finally, we discuss the merits of the technique and relate it to other work. 2 Preliminaries 2.1 (labelled) rigid types The type formalism chosen in this paper is the one of <ref> [ 9 ] </ref> . The reasons for this choice are 1) rigid types provide sufficient precision for the application, 2) automatic inference of rigid types through abstract interpretation has been fully developed and described in [ 9 ] , 3) the tools for inferring them are available at our site, allowing <p> 2.1 (labelled) rigid types The type formalism chosen in this paper is the one of <ref> [ 9 ] </ref> . The reasons for this choice are 1) rigid types provide sufficient precision for the application, 2) automatic inference of rigid types through abstract interpretation has been fully developed and described in [ 9 ] , 3) the tools for inferring them are available at our site, allowing for extensive experiments with the proposed techniques. Due to space restrictions and since rigid types are not part of the contribution of this paper, we refer to [ 9 ] and [ 12 ] for <p> has been fully developed and described in <ref> [ 9 ] </ref> , 3) the tools for inferring them are available at our site, allowing for extensive experiments with the proposed techniques. Due to space restrictions and since rigid types are not part of the contribution of this paper, we refer to [ 9 ] and [ 12 ] for the underlying intuitions. Here, we only recall the basic definitions and give an example. There exist a number of primitive types (e.g. INT, REAL), which represent subsets of the set of constants in the language. <p> Rigid types are formally defined by means of type graphs, which are a particular instance of directed graphs. We assume that the reader is familiar with the basics of graph theory. Definition 2.1 (labelled rigid type graph; adapted from <ref> [ 9 ] </ref> ) A labelled rigid type graph T is a 6-tuple, (Nodes,ForArcs,BackArcs,Label,ArgPos,TypeLabel), where 1. Nodes is a finite, non-empty set of nodes, 2. ForArcs Nodes fi Nodes such that (Nodes; ForArcs) is a tree, 3. <p> In figure 1 the set of all nil-terminated lists which take nil-terminated lists of any terms as elements is depicted as a type graph. It could be used to specify the call type of the first argument of the flatten predicate in Example 1.1. 4 In <ref> [ 9 ] </ref> , rigid type graphs are used as a component of an abstract domain. For reasons of efficiency, rigid type graphs must be further restricted to normal type graphs. Definition 2.4 (principal nodes; see [ 9 ] : definition 4.5) Let T =(Nodes,ForArcs,BackArcs,Label,ArgPos,TypeLabel) be a rigid type graph. <p> type of the first argument of the flatten predicate in Example 1.1. 4 In <ref> [ 9 ] </ref> , rigid type graphs are used as a component of an abstract domain. For reasons of efficiency, rigid type graphs must be further restricted to normal type graphs. Definition 2.4 (principal nodes; see [ 9 ] : definition 4.5) Let T =(Nodes,ForArcs,BackArcs,Label,ArgPos,TypeLabel) be a rigid type graph. <p> In other words, S = f p (t 1 ; ; t n )jt i 2 ID (T i )g for some given T 1 ; ; T n . Furthermore, we assume that an upper approximation of Call (P; S) is provided using the type inference of <ref> [ 9 ] </ref> . <p> Here, the following considerations are important. We illustrate them with the above example. 1. A simple solution would be to apply the type inference of <ref> [ 9 ] </ref> and to collect all success types that hold at execution point 2 for the intermediate atoms (p=n and 8 r=k) and for all other predicates on which these depend in P . <p> The problem is that, given an additional clause p (t 0 n ) s (v 1 ; ; v l ) (3) of P , a method such as the one in <ref> [ 9 ] </ref> will only provide success types for s=l which hold locally at point 3, without incorporating the additional instantiations caused on s (v 1 ; ; v l ) by solving r (u 1 ; ; u k ) (at point 2). <p> However, here the problem is that such an approach does not easily allow to take the call information, with which a clause is entered, into account. 3. A final option, and essentially the solution we take in the remainder of the paper, is to use the approach of <ref> [ 9 ] </ref> augmented with a reexecution strategy (see e.g. [ 11 ] ). This means that, once success types for p=n have been computed, the type inference is restarted using the previously obtained success types as the call types for p=n. <p> Proposition 3.8 states that the latter interargument relation is also an interargument relation for p wrt T in P . Throughout the remainder of the paper we assume that the program P is in normal form (see e.g. <ref> [ 9 ] </ref> ). On the highest level this means that all unifications are made explicit using the unification builtin =/2. Furthermore, all arguments of atoms with user defined predicates are variables and, for each clause, all such variables in the clause are mutually distinct.
Reference: [10] <author> M. Karr. </author> <title> Affine relationships among variables of a program. </title> <journal> Acta Informatica, </journal> <volume> 6 </volume> <pages> 133-151, </pages> <year> 1976. </year>
Reference-contexts: Given two systems of equations S 1 and S 2 , their disjunction is a new system which has as solutions the solutions of both systems. Of course, the union of two hyperplanes is very seldom a new hyperplane. We refer to <ref> [ 10 ] </ref> for the presentation of a technique which computes the most precise system of equations whose solution set comprises the two given hyperplanes. * Restriction. Let A be an mfin-matrix and let X be the transposition of [X 1 ; ; X n ].
Reference: [11] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> Reexecution in abstract interpretation of prolog. </title> <editor> In Krzysztof Apt, editor, </editor> <booktitle> Proceedings of the Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 750-764. </pages> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: A final option, and essentially the solution we take in the remainder of the paper, is to use the approach of [ 9 ] augmented with a reexecution strategy (see e.g. <ref> [ 11 ] </ref> ). This means that, once success types for p=n have been computed, the type inference is restarted using the previously obtained success types as the call types for p=n.
Reference: [12] <author> A. Mulkers. </author> <title> Deriving Live Data Structures in Logic Programs by means of Abstract Interpretation. </title> <booktitle> Number 675 in LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <month> 19 </month>
Reference-contexts: Due to space restrictions and since rigid types are not part of the contribution of this paper, we refer to [ 9 ] and <ref> [ 12 ] </ref> for the underlying intuitions. Here, we only recall the basic definitions and give an example. There exist a number of primitive types (e.g. INT, REAL), which represent subsets of the set of constants in the language. <p> A rigid type graph T describes a (possibly infinite) set of finite terms. This set of finite terms is found by means of the denotation function, ID. We refer to ( <ref> [ 12 ] </ref> , Def. 2.3.4 and following) for formal definition.
Reference: [13] <author> L. Plumer. </author> <title> Termination proofs for logic programs. Number 446 in LNAI. </title> <publisher> Springer--Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The main reason for this is that one wants to be able to study termination properties of programs for queries containing partially instantiated terms. Most of the earlier work in this area (e.g. [ 16 ] , <ref> [ 13 ] </ref> ) was restricted to queries with ground input arguments and relied on mode information to specify the queries of interest and the way the input data propagates throughout the computation. <p> Functions from terms to natural numbers, interpreted as measuring the size of each term, are referred to as norms and form the basis of the well-founded orderings used to prove termination in many techniques (e.g. [ 15 ] , <ref> [ 13 ] </ref> , [ 14 ] , [ 20 ] , [ 2 ] , [ 18 ] , [ 6 ] , [ 16 ] ). 2) Types allow to select the norm in such a way that the norm of those terms in the derivations that are taken
Reference: [14] <author> L. Plumer. </author> <title> Automatic termination proofs for Prolog programs operating on non-ground terms. </title> <booktitle> In Proc. ILPS'91, </booktitle> <pages> pages 503-517, </pages> <address> San Diego, October 1991. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Functions from terms to natural numbers, interpreted as measuring the size of each term, are referred to as norms and form the basis of the well-founded orderings used to prove termination in many techniques (e.g. [ 15 ] , [ 13 ] , <ref> [ 14 ] </ref> , [ 20 ] , [ 2 ] , [ 18 ] , [ 6 ] , [ 16 ] ). 2) Types allow to select the norm in such a way that the norm of those terms in the derivations that are taken into account for the
Reference: [15] <author> K. Sohn and A. Van Gelder. </author> <title> Termination detection in logic programs using argument sizes. </title> <booktitle> In Proceedings 10th symposium on principles of database systems, </booktitle> <pages> pages 216-226. </pages> <publisher> ACM Press, </publisher> <month> May </month> <year> 1991. </year>
Reference-contexts: Functions from terms to natural numbers, interpreted as measuring the size of each term, are referred to as norms and form the basis of the well-founded orderings used to prove termination in many techniques (e.g. <ref> [ 15 ] </ref> , [ 13 ] , [ 14 ] , [ 20 ] , [ 2 ] , [ 18 ] , [ 6 ] , [ 16 ] ). 2) Types allow to select the norm in such a way that the norm of those terms in the
Reference: [16] <author> J.D. Ullman and A. Van Gelder. </author> <title> Efficient tests for top-down termination of logical rules. </title> <journal> Journal ACM, </journal> <volume> 35(2) </volume> <pages> 345-373, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: The main reason for this is that one wants to be able to study termination properties of programs for queries containing partially instantiated terms. Most of the earlier work in this area (e.g. <ref> [ 16 ] </ref> , [ 13 ] ) was restricted to queries with ground input arguments and relied on mode information to specify the queries of interest and the way the input data propagates throughout the computation. <p> term, are referred to as norms and form the basis of the well-founded orderings used to prove termination in many techniques (e.g. [ 15 ] , [ 13 ] , [ 14 ] , [ 20 ] , [ 2 ] , [ 18 ] , [ 6 ] , <ref> [ 16 ] </ref> ). 2) Types allow to select the norm in such a way that the norm of those terms in the derivations that are taken into account for the well-founded ordering (which can be thought of as the 'input' terms) is guaranteed not to grow unboundedly in size due
Reference: [17] <author> K. Verschaetse. </author> <title> Static Termination Analysis for Definite Horn Clause Programs. </title> <type> PhD thesis, </type> <institution> Dept. Computer Science, K.U.Leuven, </institution> <year> 1992. </year>
Reference-contexts: 1 Introduction Types are fulfilling an increasingly important role in state of the art approaches to Logic Program termination analysis (e.g. [ 4 ] , <ref> [ 17 ] </ref> , [ 3 ] , [ 7 ] ). The main reason for this is that one wants to be able to study termination properties of programs for queries containing partially instantiated terms. <p> We have derived a size relation expressing that both lists contain the same number of basic elements. 6 Conclusions The contribution of this paper is to fill in the one technical gap needed to extend automatic termination analysis techniques such as the ones in [ 20 ] and <ref> [ 17 ] </ref> to be able to take advantage of typed norms: the inference of interargument relations for such norms. At first sight, this can be regarded as a minor, technical point. <p> On the level of practicality, our approach can deal with any of the programs successfully studied in <ref> [ 17 ] </ref> , since typed norms extend non-typed ones. Moreover, practically all the examples mentioned in [ 7 ] , which fall outside the scope of [ 17 ] , can successfully be handled by our extension. Flatten is just one representative of this class. <p> On the level of practicality, our approach can deal with any of the programs successfully studied in <ref> [ 17 ] </ref> , since typed norms extend non-typed ones. Moreover, practically all the examples mentioned in [ 7 ] , which fall outside the scope of [ 17 ] , can successfully be handled by our extension. Flatten is just one representative of this class. Others are the tree-to-list conversion and the change predicate. See [ 3 ] for a more extensive list.
Reference: [18] <author> K. Verschaetse and D. De Schreye. </author> <title> Deriving termination proofs for logic programs, using abstract procedures. </title> <booktitle> In Proc. ICLP'91, </booktitle> <pages> pages 301-315, </pages> <address> Paris, June 1991. </address> <publisher> MIT Press. </publisher>
Reference-contexts: numbers, interpreted as measuring the size of each term, are referred to as norms and form the basis of the well-founded orderings used to prove termination in many techniques (e.g. [ 15 ] , [ 13 ] , [ 14 ] , [ 20 ] , [ 2 ] , <ref> [ 18 ] </ref> , [ 6 ] , [ 16 ] ). 2) Types allow to select the norm in such a way that the norm of those terms in the derivations that are taken into account for the well-founded ordering (which can be thought of as the 'input' terms) is <p> In [ 6 ] this is done by computing an interargument relation for the intermediate atoms B 1 ; ; B i1 . This in turn is achieved through abstract interpretation, as discussed in <ref> [ 18 ] </ref> . In the setting of typed norms the notion of an interargument relation needs to be specialised wrt the types of the argument positions.
Reference: [19] <author> K. Verschaetse and D. De Schreye. </author> <title> Derivation of linear size relations by abstract interpretation. </title> <editor> In M. Bruynooghe and M. Wirsing, editors, </editor> <booktitle> Proceedings PLILP'92, </booktitle> <volume> LNCS 631, </volume> <pages> pages 296-310. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Only one aspect of the termination analysis is an exception in this respect : the inference of the interargument relations. As we reported in [ 7 ] , a rather straightforward extension of the technique proposed in <ref> [ 19 ] </ref> to the case of typed norms will be sound, but the loss in precision is most often unacceptable. We refer to subsection 2.3 for a discussion of the problems. In this paper, we propose an automated technique for inferring interargument relations for typed norms. <p> in <ref> [ 19 ] </ref> to the case of typed norms will be sound, but the loss in precision is most often unacceptable. We refer to subsection 2.3 for a discussion of the problems. In this paper, we propose an automated technique for inferring interargument relations for typed norms. As in [ 19 ] , 1) we infer systems of linear relations to approximate the interargument relations, and 2) we formulate the technique as an instance of an abstract interpretation framework. A main distinction with respect to [ 19 ] besides of the focus on typed norms and the improved expressivity this <p> As in <ref> [ 19 ] </ref> , 1) we infer systems of linear relations to approximate the interargument relations, and 2) we formulate the technique as an instance of an abstract interpretation framework. A main distinction with respect to [ 19 ] besides of the focus on typed norms and the improved expressivity this entails is the use of the bottom-up abstract interpretation framework of [ 1 ] , which reduces the technical complexity of the analysis. <p> All atoms in such a set obey their annotations, i.e. the atoms are well-typed. We can equip D with a partial order relation defined as the subset relation on sets. 4.2 Abstract domain Analogously to <ref> [ 19 ] </ref> , we abstract size relations as systems of linear equations. A linear equation is an equation of the form a 1 X 1 + + a m X m = b where a i ; b 2 Q; 8i 2 f1; ; mg. <p> Because there exist multiple ways to represent unsolvable systems, we adopt the convention to denote such a system by the symbol ?. We refer to <ref> [ 19 ] </ref> for more details. In the abstract interpretation procedure, the following operations on systems of equa tions will occur frequently. 12 * Intersection. Obviously, a tuple is a solution of the intersection of two systems if it is a solution of both systems. <p> 9x 1 ; ; x n 2 IR : (x 1 ; ; x k ; x k+1 ; ; x n ) is a solution of A X = c m (x k+1 ; ; x n ) is a solution of A r X r = c r <ref> [ 19 ] </ref> describes how to compute this operation for a system in reduced row-echelon form. * Extension. This is the converse of the restriction operation. <p> As <ref> [ 19 ] </ref> indicates, there do not exist infinitely ascending chains of systems S 0 &lt; S 1 &lt; . The maximum length of a strictly ascending chain is equal to the dimension of the domain. We are now in a position to specify our abstract domain. <p> In this paper we consider the T P semantics and we adopt the bottom-up abstract interpretation of [ 1 ] . The basic operation is the abstract interpretation of unification. In <ref> [ 19 ] </ref> , using a top-down framework, given a call to unification, X = t, and an abstract call substitution, E k q (a system of linear equations) the abstract success substitution is E k q [fX = abs jj:jj (t)g. <p> With respect to related work on inference of interargument relations, we refer to [ 5 ] 18 for an overview. That paper also discusses the differences in expressivity, e.g. in relation to the use of systems of linear equations. With respect to <ref> [ 19 ] </ref> the main differences are the improved expressivity by integrating types and the use of a conceptually simpler abstract interpretation scheme.
Reference: [20] <author> K. Verschaetse, S. Decorte, and D. De Schreye. </author> <title> Automatic termination analysis. </title> <booktitle> In Proc. </booktitle> <address> LOPSTR'92, </address> <publisher> LNCS. Springer-Verlag, </publisher> <year> 1993. </year> <month> 20 </month>
Reference-contexts: Functions from terms to natural numbers, interpreted as measuring the size of each term, are referred to as norms and form the basis of the well-founded orderings used to prove termination in many techniques (e.g. [ 15 ] , [ 13 ] , [ 14 ] , <ref> [ 20 ] </ref> , [ 2 ] , [ 18 ] , [ 6 ] , [ 16 ] ). 2) Types allow to select the norm in such a way that the norm of those terms in the derivations that are taken into account for the well-founded ordering (which can <p> In fact, this syntactic verification forms the key criterion for inferring the norms from the given types. As argued in [ 7 ] , typed norms can easily be integrated into existing termination analysis techniques, such as [ 6 ] , <ref> [ 20 ] </ref> , [ 2 ] . Only one aspect of the termination analysis is an exception in this respect : the inference of the interargument relations. <p> We have derived a size relation expressing that both lists contain the same number of basic elements. 6 Conclusions The contribution of this paper is to fill in the one technical gap needed to extend automatic termination analysis techniques such as the ones in <ref> [ 20 ] </ref> and [ 17 ] to be able to take advantage of typed norms: the inference of interargument relations for such norms. At first sight, this can be regarded as a minor, technical point. It should be observed however that, although [ 20 ] is one of the more <p> analysis techniques such as the ones in <ref> [ 20 ] </ref> and [ 17 ] to be able to take advantage of typed norms: the inference of interargument relations for such norms. At first sight, this can be regarded as a minor, technical point. It should be observed however that, although [ 20 ] is one of the more powerful automatic termination techniques available, the method was still based on ordinary norms.
References-found: 20

