URL: ftp://ftp.cs.wisc.edu/wwt/ppopp97_grain.ps
Refering-URL: http://www.cs.wisc.edu/~david/david.html
Root-URL: 
Email: fyzhou,liv,jps,lig@cs.princeton.edu  ftoonen,schoinas,markhill,davidg@cs.wisc.edu  
Title: Relaxed Consistency and Coherence Granularity in DSM Systems: A Performance Evaluation  
Author: Yuanyuan Zhou, Liviu Iftode, Jaswinder Pal Singh and Kai Li Brian R. Toonen, Ioannis Schoinas, Mark D. Hill, and David A. Wood 
Address: Princeton, NJ 08544  Madison, WI 53705  
Affiliation: Computer Science Department Princeton University  Computer Sciences Department University of Wisconsin, Madison  
Abstract: During the past few years, two main approaches have been taken to improve the performance of software shared memory implementations: relaxing consistency models and providing fine-grained access control. Their performance tradeoffs, however, are not well understood. This paper studies these tradeoffs on a platform that provides access control in hardware but runs coherence protocols in software. We compare the performance of three protocols across four coherence granularities, using 12 applications on a 16-node cluster of workstations. Our results show that no single combination of protocol and granularity performs best for all the applications. The combination of a sequentially consistent (SC) protocol and fine granularity works well with 7 of the 12 applications. The combination of a multiple-writer, home-based lazy release consistency (HLRC) protocol and page granularity works well with 8 out of the 12 applications. For applications that suffer performance losses in moving to coarser granularity under sequential consistency, the performance can usually be regained quite effectively using relaxed protocols, particularly HLRC. We also find that the HLRC protocol performs substantially better than a single-writer lazy release consistent (SW-LRC) protocol at coarse granularity for many irregular applications. For our applications and platform, when we use the original versions of the applications ported directly from hardware-coherent shared memory, we find that the SC protocol with 256-byte granularity performs best on average. However, when the best versions of the applications are compared, the balance shifts in favor of HLRC at page granularity. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J.K. Bennett, J.B. Carter, and W. Zwaenepoel. </author> <title> Adaptive Software Cache Management for Distributed Shared Memory Architectures. </title> <booktitle> In Proceedings of the 17th Annual Symposium on Computer Architecture, </booktitle> <pages> pages 125-134, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: SVM. (All these performance differences would be larger on real SVM systems, where the overheads of access violations, i.e. page faults, are higher.) 5.2 Detailed Analysis To understand the reasons for the performance differences, it is useful to classify the applications according to their data access patterns and synchronization behavior <ref> [29, 1, 12] </ref>. In this section, we will first describe application classifications according to the number of writers per coherence unit, spatial data access granularity and temporal synchronization granularity.
Reference: [2] <author> B.N. Bershad, M.J. Zekauskas, </author> <title> and W.A. </title> <booktitle> Sawdon. The Midway Distributed Shared Memory System. In Proceedings of the IEEE COMPCON '93 Conference, </booktitle> <month> February </month> <year> 1993. </year>
Reference-contexts: Relaxed consistency models introduce additional programmer restrictions in exchange for (hopefully) better performance. Examples of relaxed consistency models include release consistency [10], entry consistency <ref> [2] </ref>, scope consistency [13]. Lazy release consistency (LRC) [15] is a software implementation of release consistency which delays the coherence action until the acquire time. Most software shared systems today use LRC-based protocols [14] [11] [30] [16]. These consistency models employ sophisticated protocols to reduce false sharing and fragmentation. <p> Examples of relaxed consistency models and systems include release consistency (RC) [10] and its SVM implementation [5], delayed consistency model [8] and its SVM protocols [4, 9], multiple-writer lazy release consistency (LRC) model [15] and implementation [14], entry consistency model and prototype <ref> [2] </ref>, automatic update release consistency [11], scope consistency [13], home-based lazy release consistency and its implementations [30], and single-writer lazy release consistency [16]. All prototypes based on relaxed consistency models use virtual memory page sizes as their coherence units.
Reference: [3] <author> Nanette J. Boden, Danny Cohen, Robert E. Felderman, Alan E. Kulawik, Charles L. Seitz, Jakov N. Seizovic, and Wen-King Su. Myrinet: </author> <title> A Gigabit-per-Second Local Area Network. </title> <journal> IEEE Micro, </journal> <volume> 15(1) </volume> <pages> 29-36, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: The cache-coherent 50 MHz MBus connects the processors and memory. I/O devices reside on the 25 MHz SBus, which connects to the MBus via a bridge. All nodes run Solaris 2.4. Each node contains a Myrinet network interface <ref> [3] </ref>, which consists of a 7-MIPS custom processor (LANai) and 128KB of memory. The LANai performs limited protocol processing and schedules DMA transfers between the network and LANai memory or LANai memory and SPARC memory. The 16 nodes used in this paper are connected with three Myrinet 8-port crossbar switches.
Reference: [4] <author> L. Borrmann and M. Herdieckerhoff. </author> <title> A Coherency Model for Virtual Shared Memory. </title> <booktitle> In Proceedings of the 10th International Parallel Processing Symposium, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: Examples of relaxed consistency models and systems include release consistency (RC) [10] and its SVM implementation [5], delayed consistency model [8] and its SVM protocols <ref> [4, 9] </ref>, multiple-writer lazy release consistency (LRC) model [15] and implementation [14], entry consistency model and prototype [2], automatic update release consistency [11], scope consistency [13], home-based lazy release consistency and its implementations [30], and single-writer lazy release consistency [16].
Reference: [5] <author> J.B. Carter, J.K. Bennett, and W. Zwaenepoel. </author> <title> Implementation and Performance of Munin. </title> <booktitle> In Proceedings of the Thirteenth Symposium on Operating Systems Principles, </booktitle> <pages> pages 152-164, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Since then, two main approaches have been taken to deal with the false-sharing and fragmentation problem in SVM systems: relaxing consistency models and providing fine-grained access control. Examples of relaxed consistency models and systems include release consistency (RC) [10] and its SVM implementation <ref> [5] </ref>, delayed consistency model [8] and its SVM protocols [4, 9], multiple-writer lazy release consistency (LRC) model [15] and implementation [14], entry consistency model and prototype [2], automatic update release consistency [11], scope consistency [13], home-based lazy release consistency and its implementations [30], and single-writer lazy release consistency [16].
Reference: [6] <author> David Culler, Lok Tin Liu, Richard Martin, and Chad Yoshikawa. </author> <title> LogP Performance Assessment of Fast Network Interfaces. </title> <booktitle> IEEE Micro, </booktitle> <pages> pages 35-43, </pages> <month> February </month> <year> 1996. </year>
Reference-contexts: With Myrinet hardware, the host (SPARC) processor and Myrinet LANai processor cooperate to send and receive data. Our communication library is based on the LANai Control Program (LCP) used in Berkeley's LAM library <ref> [6] </ref>. The host processor uses loads and stores to move small messages and headers for large messages to and from LANai 1 Note to reviewers: We actually have 40 machines and hope to have 32-node runs for the final version. memory.
Reference: [7] <author> David Culler, Lok Tin Liu, Richard Martin, and Chad Yoshikawa. </author> <title> LogP Performance Assessment of Fast Network Interfaces. </title> <booktitle> IEEE Micro, </booktitle> <pages> pages 35-43, </pages> <month> February </month> <year> 1996. </year>
Reference-contexts: However, polling introduces needlessly overhead when no message is present. A microbenchmark shows 4-, 64-, 256-, 1K- and 4K-byte messages see round-trip times of 40, 61, 100, 256 and 876 usecs. Large messages achieve bandwidths of about 17 MB/sec, with is close to the values obtained by others <ref> [7, 21] </ref>. 4 Applications To evaluate the performance of the three protocols with different sizes of coherence units, we used 8 benchmarks from SPLASH-2, including LU decomposition, Ocean, FFT, Water-Nsquared, Volrend, Water-Spatial, Raytrace, and Barnes. We have two versions for Ocean, two versions for Volrend and three versions for Barnes.
Reference: [8] <author> M. Dubois, J.C. Wang, L.A. Barroso, K. Lee, and Y-S Chen. </author> <title> Delayed Consistency and Its Effects on the Miss Rate of Parallel Programs. </title> <booktitle> In Supercomputing '91, </booktitle> <pages> pages 197-206, </pages> <year> 1991. </year>
Reference-contexts: The total number of misses under SC decreases significantly, down to 4%-70% of the polling case. In essence, the interrupt method approximates Dubois, et al.'s delayed consistency implementations, which are specifically targeted at reducing the impact of false sharing <ref> [8] </ref>. <p> Since then, two main approaches have been taken to deal with the false-sharing and fragmentation problem in SVM systems: relaxing consistency models and providing fine-grained access control. Examples of relaxed consistency models and systems include release consistency (RC) [10] and its SVM implementation [5], delayed consistency model <ref> [8] </ref> and its SVM protocols [4, 9], multiple-writer lazy release consistency (LRC) model [15] and implementation [14], entry consistency model and prototype [2], automatic update release consistency [11], scope consistency [13], home-based lazy release consistency and its implementations [30], and single-writer lazy release consistency [16].
Reference: [9] <author> A. Erlichson, N. Nuckolls, G. Chesson, and J. Hennessy. Soft-FLASH: </author> <title> Analyzing the Performance of Clustered Distributed Virtual Shared Memory. </title> <booktitle> In The 6th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: Examples of relaxed consistency models and systems include release consistency (RC) [10] and its SVM implementation [5], delayed consistency model [8] and its SVM protocols <ref> [4, 9] </ref>, multiple-writer lazy release consistency (LRC) model [15] and implementation [14], entry consistency model and prototype [2], automatic update release consistency [11], scope consistency [13], home-based lazy release consistency and its implementations [30], and single-writer lazy release consistency [16].
Reference: [10] <author> K. Gharachorloo, D. Lenoski, J. Laudon, P. Gibbons, A. Gupta, and J. Hennessy. </author> <title> Memory Consistency and Event Ordering in Scalable Shared-Memory Multiprocessors. </title> <booktitle> In Proceedings of the 17th Annual Symposium on Computer Architecture, </booktitle> <pages> pages 15-26, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: During the past few years, two main approaches have been taken to address this problem: relaxing consistency models and providing access control at a fine granularity. Relaxed consistency models introduce additional programmer restrictions in exchange for (hopefully) better performance. Examples of relaxed consistency models include release consistency <ref> [10] </ref>, entry consistency [2], scope consistency [13]. Lazy release consistency (LRC) [15] is a software implementation of release consistency which delays the coherence action until the acquire time. Most software shared systems today use LRC-based protocols [14] [11] [30] [16]. <p> Since then, two main approaches have been taken to deal with the false-sharing and fragmentation problem in SVM systems: relaxing consistency models and providing fine-grained access control. Examples of relaxed consistency models and systems include release consistency (RC) <ref> [10] </ref> and its SVM implementation [5], delayed consistency model [8] and its SVM protocols [4, 9], multiple-writer lazy release consistency (LRC) model [15] and implementation [14], entry consistency model and prototype [2], automatic update release consistency [11], scope consistency [13], home-based lazy release consistency and its implementations [30], and single-writer lazy
Reference: [11] <author> L. Iftode, C. Dubnicki, E. W. Felten, and Kai Li. </author> <title> Improving Release-Consistent Shared Virtual Memory using Automatic Update. </title> <booktitle> In The 2nd IEEE Symposium on High-Performance Computer Architecture, </booktitle> <month> February </month> <year> 1996. </year>
Reference-contexts: Examples of relaxed consistency models include release consistency [10], entry consistency [2], scope consistency [13]. Lazy release consistency (LRC) [15] is a software implementation of release consistency which delays the coherence action until the acquire time. Most software shared systems today use LRC-based protocols [14] <ref> [11] </ref> [30] [16]. These consistency models employ sophisticated protocols to reduce false sharing and fragmentation. An alternative approach is to preserve the simplicity of sequential consistency, but find some approach to reduce the coherence granularity. <p> Examples of relaxed consistency models and systems include release consistency (RC) [10] and its SVM implementation [5], delayed consistency model [8] and its SVM protocols [4, 9], multiple-writer lazy release consistency (LRC) model [15] and implementation [14], entry consistency model and prototype [2], automatic update release consistency <ref> [11] </ref>, scope consistency [13], home-based lazy release consistency and its implementations [30], and single-writer lazy release consistency [16]. All prototypes based on relaxed consistency models use virtual memory page sizes as their coherence units.
Reference: [12] <author> L. Iftode, J. P. Singh, and Kai Li. </author> <title> Understanding Application Performance on Shared Virtual Memory. </title> <booktitle> In Proceedings of the 23rd Annual Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1996. </year>
Reference-contexts: SVM. (All these performance differences would be larger on real SVM systems, where the overheads of access violations, i.e. page faults, are higher.) 5.2 Detailed Analysis To understand the reasons for the performance differences, it is useful to classify the applications according to their data access patterns and synchronization behavior <ref> [29, 1, 12] </ref>. In this section, we will first describe application classifications according to the number of writers per coherence unit, spatial data access granularity and temporal synchronization granularity. <p> Write-write false sharing occurs only for multiple writer applications. affected by the disk swapping and becomes irrelevant for this study.] * Coarse-grain vs. Fine-grain data access Data access granularity affects how the communication to computation ratio changes with the coherence granularity <ref> [12] </ref>. Applications with coarse-grain access tend to access a whole contiguous page at a time. Fine-grain applications are likely to scatter reads and writes across multiple pages. Fine-grain reads can introduce fragmentation with coarse coherence granularity and/or false sharing. * Coarse-grain vs. <p> Thus, there is little false sharing but significant fragmentation in the induced patterns. In FFT, the write access granularity is coarse while the read access granularity is fine-grained for this problem size <ref> [12] </ref> (a processor reads subrows of size 192 bytes from other processors). All the protocols performs poorly. The best speedup is 2.7 for Ocean-Original and 1.9 for FFT.
Reference: [13] <author> L. Iftode, J.P. Singh, and K. Li. </author> <title> Scope Consistency: a Bridge Between Release Consistency and Entry Consistency. </title> <booktitle> In Proceedings of the 8th Annual ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <month> June </month> <year> 1996. </year>
Reference-contexts: Relaxed consistency models introduce additional programmer restrictions in exchange for (hopefully) better performance. Examples of relaxed consistency models include release consistency [10], entry consistency [2], scope consistency <ref> [13] </ref>. Lazy release consistency (LRC) [15] is a software implementation of release consistency which delays the coherence action until the acquire time. Most software shared systems today use LRC-based protocols [14] [11] [30] [16]. These consistency models employ sophisticated protocols to reduce false sharing and fragmentation. <p> Examples of relaxed consistency models and systems include release consistency (RC) [10] and its SVM implementation [5], delayed consistency model [8] and its SVM protocols [4, 9], multiple-writer lazy release consistency (LRC) model [15] and implementation [14], entry consistency model and prototype [2], automatic update release consistency [11], scope consistency <ref> [13] </ref>, home-based lazy release consistency and its implementations [30], and single-writer lazy release consistency [16]. All prototypes based on relaxed consistency models use virtual memory page sizes as their coherence units. Another approach is to preserve the sequential consistency model and to find ways to reduce the coherence granularity.
Reference: [14] <author> P. Keleher, A.L. Cox, S. Dwarkadas, and W. Zwaenepoel. TreadMarks: </author> <title> Distributed Shared Memory on Standard Workstations and Operating Systems. </title> <booktitle> In Proceedings of the Winter USENIX Conference, </booktitle> <pages> pages 115-132, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Examples of relaxed consistency models include release consistency [10], entry consistency [2], scope consistency [13]. Lazy release consistency (LRC) [15] is a software implementation of release consistency which delays the coherence action until the acquire time. Most software shared systems today use LRC-based protocols <ref> [14] </ref> [11] [30] [16]. These consistency models employ sophisticated protocols to reduce false sharing and fragmentation. An alternative approach is to preserve the simplicity of sequential consistency, but find some approach to reduce the coherence granularity. <p> Updates from one copy are transferred into another copy by diff-ing the first copy, sending the diff and applying it on the second copy. The traditional LRC implementation uses a distributed diff scheme where diffs are merged on demand in a distributed fashion <ref> [14] </ref>. To bring a copy up-to-date, diffs must be applied in the proper causal order determined using vector timestamps [15]. The HLRC multiple-writer scheme differs from LRC by having the diffs sent and applied eagerly a designated home of the block. <p> Examples of relaxed consistency models and systems include release consistency (RC) [10] and its SVM implementation [5], delayed consistency model [8] and its SVM protocols [4, 9], multiple-writer lazy release consistency (LRC) model [15] and implementation <ref> [14] </ref>, entry consistency model and prototype [2], automatic update release consistency [11], scope consistency [13], home-based lazy release consistency and its implementations [30], and single-writer lazy release consistency [16]. All prototypes based on relaxed consistency models use virtual memory page sizes as their coherence units.
Reference: [15] <author> P. Keleher, A.L. Cox, and W. Zwaenepoel. </author> <title> Lazy Consistency for Software Distributed Shared Memory. </title> <booktitle> In Proceedings of the 19th Annual Symposium on Computer Architecture, </booktitle> <pages> pages 13-21, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Relaxed consistency models introduce additional programmer restrictions in exchange for (hopefully) better performance. Examples of relaxed consistency models include release consistency [10], entry consistency [2], scope consistency [13]. Lazy release consistency (LRC) <ref> [15] </ref> is a software implementation of release consistency which delays the coherence action until the acquire time. Most software shared systems today use LRC-based protocols [14] [11] [30] [16]. These consistency models employ sophisticated protocols to reduce false sharing and fragmentation. <p> This model is more relaxed than the sequential consistency, but less relaxed than the multiple-writer lazy release consistency protocols. Our SW-LRC protocol uses the same timestamp-based coherence control as proposed for Lazy Release Consistency <ref> [15] </ref> but it allows only a single writable copy to co-exist with multiple read-only copies. In this protocol, a write fault causes ownership to migrate but, unlike a sequential consistency protocol, read-only copies are not invalidated. <p> The traditional LRC implementation uses a distributed diff scheme where diffs are merged on demand in a distributed fashion [14]. To bring a copy up-to-date, diffs must be applied in the proper causal order determined using vector timestamps <ref> [15] </ref>. The HLRC multiple-writer scheme differs from LRC by having the diffs sent and applied eagerly a designated home of the block. With such a scheme the home's copy of the block is kept up-to-date and its whole content will be fetched on demand to update the other copies. <p> Examples of relaxed consistency models and systems include release consistency (RC) [10] and its SVM implementation [5], delayed consistency model [8] and its SVM protocols [4, 9], multiple-writer lazy release consistency (LRC) model <ref> [15] </ref> and implementation [14], entry consistency model and prototype [2], automatic update release consistency [11], scope consistency [13], home-based lazy release consistency and its implementations [30], and single-writer lazy release consistency [16]. All prototypes based on relaxed consistency models use virtual memory page sizes as their coherence units.
Reference: [16] <author> P.J. Keleher. </author> <title> The Relative Importance of Concurrent Writers and Weak Consistency Models. </title> <booktitle> In Proceedings of the IEEE COMPCON '96 Conference, </booktitle> <month> February </month> <year> 1996. </year>
Reference-contexts: Examples of relaxed consistency models include release consistency [10], entry consistency [2], scope consistency [13]. Lazy release consistency (LRC) [15] is a software implementation of release consistency which delays the coherence action until the acquire time. Most software shared systems today use LRC-based protocols [14] [11] [30] <ref> [16] </ref>. These consistency models employ sophisticated protocols to reduce false sharing and fragmentation. An alternative approach is to preserve the simplicity of sequential consistency, but find some approach to reduce the coherence granularity. <p> We studied the combinations of three consistency protocols (sequential consistency (SC) [17], single-writer lazy release consistency (SW-LRC) <ref> [16] </ref> and home-based lazy release consistency (HLRC) [30]) with four sizes of coherence granularity. We also studied two mechanisms (polling and interrupt) to handle message arrivals for each case. Our experiments used eight real benchmarks developed for hardware shared memory systems and their variations (so total 12 applications). <p> polling/interrupt issue); read-only copies are invalidated and read-write copies are written-back to the home node and invalidated. 2.2 SW-LRC Protocol The single-writer lazy release consistency (SW-LRC) model allows a single-writer to co-exist with multiple readers and delays the propagations of updates to shared memory to the executions of acquire operations <ref> [16] </ref>. This model is more relaxed than the sequential consistency, but less relaxed than the multiple-writer lazy release consistency protocols. Our SW-LRC protocol uses the same timestamp-based coherence control as proposed for Lazy Release Consistency [15] but it allows only a single writable copy to co-exist with multiple read-only copies. <p> SVM implementation [5], delayed consistency model [8] and its SVM protocols [4, 9], multiple-writer lazy release consistency (LRC) model [15] and implementation [14], entry consistency model and prototype [2], automatic update release consistency [11], scope consistency [13], home-based lazy release consistency and its implementations [30], and single-writer lazy release consistency <ref> [16] </ref>. All prototypes based on relaxed consistency models use virtual memory page sizes as their coherence units. Another approach is to preserve the sequential consistency model and to find ways to reduce the coherence granularity. <p> Examples of providing fine-grained access control include taking advantage architectural features such as the ECC bits to trap access faults [27], using software instrumentation for shared reads and writes [27, 26], and building special access control hardware for commodity workstations [23]. Keleher <ref> [16] </ref> compares sequential consistency with single writer and multiple-writer LRC protocols and concludes that overall, the multiple-writer version is only 9% better than the single-writer one and 34% better than the sequential consistency one.
Reference: [17] <author> L. Lamport. </author> <title> How to Make a Multiprocessor Computer That Correctly Executes Multiprocessor Programs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-28(9):690-691, </volume> <year> 1979. </year>
Reference-contexts: The original shared virtual memory (SVM) proposal and prototype [20] uses the traditional virtual memory access protection mechanisms to detect access misses and implements a sequential consistency model <ref> [17] </ref>. The main advantage of the approach is that it implements shared memory entirely in software on a network of commodity workstations [19] to run applications developed for hardware shared-memory multiprocessors. A disadvantage is that it restricts the coherence granularity to be a virtual memory page size. <p> We studied the combinations of three consistency protocols (sequential consistency (SC) <ref> [17] </ref>, single-writer lazy release consistency (SW-LRC) [16] and home-based lazy release consistency (HLRC) [30]) with four sizes of coherence granularity. We also studied two mechanisms (polling and interrupt) to handle message arrivals for each case. <p> The original shared virtual memory (SVM) proposal and prototype [20] uses the traditional virtual memory access protection mechanism to detect access misses and implements the sequential consistency model <ref> [17] </ref> on a network of workstations. The coherence unit of the prototype is a 1,024-byte virtual memory page. Since then, two main approaches have been taken to deal with the false-sharing and fragmentation problem in SVM systems: relaxing consistency models and providing fine-grained access control.
Reference: [18] <author> Daniel Lenoski, James Laudon, Kourosh Gharachorloo, Wolf-Dietrich Weber, Anoop Gupta, John Hennessy, Mark Horowitz, and Monica Lam. </author> <title> The Stanford DASH Multiprocessor. </title> <journal> IEEE Computer, </journal> <volume> 25(3) </volume> <pages> 63-79, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: This model is generally considered the simplest for programmers, because, informally, a read always returns the result of the most recent write. Our sequential consistency implementation is based on the Stache protocol [24] and is similar to many directory-based hardware implementations <ref> [18] </ref>. On a miss, a request message is sent to the designated home node. If invalidations are required, the home node collects the acknowledgments before forwarding the data to the requesting node.
Reference: [19] <author> K. Li. IVY: </author> <title> A Shared Virtual Memory System for Parallel Computing. </title> <booktitle> In Proceedings of the 1988 International Conference on Parallel Processing, volume II Software, </booktitle> <pages> pages 94-101, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: The main advantage of the approach is that it implements shared memory entirely in software on a network of commodity workstations <ref> [19] </ref> to run applications developed for hardware shared-memory multiprocessors. A disadvantage is that it restricts the coherence granularity to be a virtual memory page size. For systems with large page sizes, false sharing and fragmentation will occur in applications with multiple writer, fine-grained access patterns.
Reference: [20] <author> K. Li and P. Hudak. </author> <title> Memory Coherence in Shared Virtual Memory Systems. </title> <booktitle> In Proceedings of the 5th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 229-239, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: This paper evaluates the performance tradeoffs of the combinations of three consistency models with four sizes of coherence granularity for software shared memory implementations on a real hardware platform. The original shared virtual memory (SVM) proposal and prototype <ref> [20] </ref> uses the traditional virtual memory access protection mechanisms to detect access misses and implements a sequential consistency model [17]. The main advantage of the approach is that it implements shared memory entirely in software on a network of commodity workstations [19] to run applications developed for hardware shared-memory multiprocessors. <p> The most related work to this paper includes research on relaxing consistency models and providing fine-grained coherence granularity for software coherent shared memory. The original shared virtual memory (SVM) proposal and prototype <ref> [20] </ref> uses the traditional virtual memory access protection mechanism to detect access misses and implements the sequential consistency model [17] on a network of workstations. The coherence unit of the prototype is a 1,024-byte virtual memory page.
Reference: [21] <author> Scott Pakin, Mario Laura, and Andrew Chien. </author> <title> High Performance Messaging on Workstations: Illinois Fast Messages (FM) for Myrinet. </title> <booktitle> In Proceedings of Supercomputing '95, </booktitle> <year> 1995. </year>
Reference-contexts: However, polling introduces needlessly overhead when no message is present. A microbenchmark shows 4-, 64-, 256-, 1K- and 4K-byte messages see round-trip times of 40, 61, 100, 256 and 876 usecs. Large messages achieve bandwidths of about 17 MB/sec, with is close to the values obtained by others <ref> [7, 21] </ref>. 4 Applications To evaluate the performance of the three protocols with different sizes of coherence units, we used 8 benchmarks from SPLASH-2, including LU decomposition, Ocean, FFT, Water-Nsquared, Volrend, Water-Spatial, Raytrace, and Barnes. We have two versions for Ocean, two versions for Volrend and three versions for Barnes.
Reference: [22] <author> Robert W. Pfile. </author> <title> Typhoon-Zero Implementation: The Vortex Module. </title> <type> Technical report, </type> <institution> Wisconsin University, CS department, </institution> <year> 1995. </year>
Reference-contexts: Two ports of each switch are used to connect to other switches. Each node also contains a Typhoon-0 card that logically performs fine-grain access control checks on all loads and stores by physically snooping memory bus transactions and exploiting inclusion <ref> [22] </ref>. When the Typhoon-0 hardware detects an access control violation, it generates an exception to the shared-memory run-time system via a special fast-exception method supported by the device driver (approximately 5 s). All protocol processing occurs on the faulting processor.
Reference: [23] <author> S. K. Reinhard, R. W. Pfile, and D. A. Wood. </author> <title> Decoupled Hardware Support for Distributed Shared Memory. </title> <booktitle> In Proceedings of the 23rd Annual Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1996. </year>
Reference-contexts: Examples of providing fine-grained access control include taking advantage architectural features such as the ECC bits to trap access faults [27], using software instrumentation for shared reads and writes [27, 26], and building special access control hardware for commodity workstations <ref> [23] </ref>. The finer the granularity, the less false sharing and fragmentation occur, and hence the less need to use relaxed models. A disadvantage of fine-grain coherence is that the smaller granularity may result in excessive misses and poor remote bandwidth. <p> Examples of providing fine-grained access control include taking advantage architectural features such as the ECC bits to trap access faults [27], using software instrumentation for shared reads and writes [27, 26], and building special access control hardware for commodity workstations <ref> [23] </ref>. Keleher [16] compares sequential consistency with single writer and multiple-writer LRC protocols and concludes that overall, the multiple-writer version is only 9% better than the single-writer one and 34% better than the sequential consistency one.
Reference: [24] <author> S.K. Reinhardt, J.R. Larus, and D.A. Wood. Tempest and Typhoon: </author> <title> User-Level Shared Memory. </title> <booktitle> In Proceedings of the 21st Annual Symposium on Computer Architecture, </booktitle> <pages> pages 325-336, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: This model is generally considered the simplest for programmers, because, informally, a read always returns the result of the most recent write. Our sequential consistency implementation is based on the Stache protocol <ref> [24] </ref> and is similar to many directory-based hardware implementations [18]. On a miss, a request message is sent to the designated home node. If invalidations are required, the home node collects the acknowledgments before forwarding the data to the requesting node.
Reference: [25] <author> ROSS Technology, Inc. </author> <title> SPARC RISC User's Guide: </title> <address> hyper-SPARC Edition, </address> <month> September </month> <year> 1993. </year>
Reference-contexts: Our implementation extends earlier work [30] by supporting various coherence granularities. 3 Testbed This section describes the platform used for these experiments. The testbed consists of 16 dual-processor Sun SPARCStation 20s 1 . Each contains two 66 MHz Ross HyperSPARC processors <ref> [25] </ref>; however, our study only uses one processor on each node. Each processor has a 256 KB L2 cache and each node contains 64 MB of main memory. The cache-coherent 50 MHz MBus connects the processors and memory.
Reference: [26] <author> D.J. Scales, K. Gharachorloo, </author> <title> and C.A. </title> <type> Thekkath. Shasta: </type>
Reference-contexts: An alternative approach is to preserve the simplicity of sequential consistency, but find some approach to reduce the coherence granularity. Examples of providing fine-grained access control include taking advantage architectural features such as the ECC bits to trap access faults [27], using software instrumentation for shared reads and writes <ref> [27, 26] </ref>, and building special access control hardware for commodity workstations [23]. The finer the granularity, the less false sharing and fragmentation occur, and hence the less need to use relaxed models. <p> Another approach is to preserve the sequential consistency model and to find ways to reduce the coherence granularity. Examples of providing fine-grained access control include taking advantage architectural features such as the ECC bits to trap access faults [27], using software instrumentation for shared reads and writes <ref> [27, 26] </ref>, and building special access control hardware for commodity workstations [23]. Keleher [16] compares sequential consistency with single writer and multiple-writer LRC protocols and concludes that overall, the multiple-writer version is only 9% better than the single-writer one and 34% better than the sequential consistency one. <p> Finally, this study has not examined all-software systems, since access-control was performed in hardware on the platform we used. It would be interesting to also investigate all-software systems that provide fine-grained access control through software instrumentation of loads and stores <ref> [27, 26] </ref> or page-grained access control entirely through the virtual memory mechanism.
References-found: 26

