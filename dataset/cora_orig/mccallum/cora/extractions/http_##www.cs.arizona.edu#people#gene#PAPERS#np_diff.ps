URL: http://www.cs.arizona.edu/people/gene/PAPERS/np_diff.ps
Refering-URL: http://www.cs.arizona.edu/people/gene/vita.html
Root-URL: http://www.cs.arizona.edu
Title: An O(NP) Sequence Comparison Algorithm  
Author: Sun Wu, Udi Manber Gene Myers and Webb Miller 
Date: August 1989  
Address: Tucson, AZ 85721  Park, PA 16802.  
Affiliation: Department of Computer Science University of Arizona  Department of Computer Science, The Pennsylvania State University University  
Abstract: Let A and B be two sequences of length M and N respectively, where without loss of generality N M, and let D be the length of a shortest edit script between them. A parameter related to D is the number of deletions in such a script, P = D/2 - (N - M)/2. We present an algorithm for finding a shortest edit distance of A and B whose worst case running time is O(NP) and whose expected running time is O(N + PD). The algorithm is simple and is very efficient whenever A is similar to a subsequence of B. It is nearly twice as fast as the O(ND) algorithm of Myers [9], and much more efficient when A and B differ substantially in length. 
Abstract-found: 1
Intro-found: 1
Reference: [2] <author> F. Hadlock, </author> <title> ``Minimum detour methods for string or sequence comparison,'' </title> <journal> Congressus Numerantium, </journal> <volume> 61 (1988), </volume> <pages> pp. 263-274. </pages>
Reference-contexts: In particular, P, the number of deletions in a shortest edit script is always equal to D/2 - (N - M)/2. The problem of determining a shortest edit script (SES) or a longest common subsequence (LCS) between two sequences of symbols has been studied extensively <ref> [2, 4, 5, 7, 9, 11, 14, 16] </ref>. The classic dynamic programming algorithm, invented by Wagner and Fischer [16] and others [12, 15], has O (MN) worst-case running time. <p> The algorithm improves upon Myers's algorithm [9] by exploring fewer of the vertices in the edit graph. It does so by using a path-compression technique that has been used as a heuristic for shortest paths problems [13]. This technique was also used by Hadlock <ref> [2] </ref> to give an O ( NP) sequence comparison algorithm, however, Hadlock used a version of Dijkstra's algorithm and thus the expected running time of his algorithm is also O (NP), whereas the expected running time of our algorithm is O (N + PD).
Reference: [3] <author> D. S. Hirschberg, </author> <title> ``A linear space algorithm for computing longest common subsequences,'' </title> <journal> Communications of the ACM, </journal> <volume> 18 (1975), </volume> <pages> pp. 341-343. </pages>
Reference-contexts: The algorithm's dependence on P implies that it is particularly efficient when A is similar to a subsequence of the longer sequence B. In fact, the algorithm is O (N) when A is a subsequence of B. By using Hirschberg's divide-and-conquer technique <ref> [3, 9] </ref>, the algorithm can be modified to deliver a shortest edit script using only linear space. 2.
Reference: [4] <author> D. S. Hirschberg, </author> <title> ``Algorithms for the longest common subsequence problem,'' </title> <journal> Journal of the ACM, </journal> <volume> 24 (1977), </volume> <pages> pp. 664-675. </pages>
Reference-contexts: In particular, P, the number of deletions in a shortest edit script is always equal to D/2 - (N - M)/2. The problem of determining a shortest edit script (SES) or a longest common subsequence (LCS) between two sequences of symbols has been studied extensively <ref> [2, 4, 5, 7, 9, 11, 14, 16] </ref>. The classic dynamic programming algorithm, invented by Wagner and Fischer [16] and others [12, 15], has O (MN) worst-case running time.
Reference: [5] <author> J. W. Hunt, and T. G. Szymanski, </author> <title> ``A fast algorithm for computing longest common subsequences,'' </title> <journal> Communications of the ACM, </journal> <volume> 20 (1977), </volume> <pages> pp. 350-353. </pages>
Reference-contexts: In particular, P, the number of deletions in a shortest edit script is always equal to D/2 - (N - M)/2. The problem of determining a shortest edit script (SES) or a longest common subsequence (LCS) between two sequences of symbols has been studied extensively <ref> [2, 4, 5, 7, 9, 11, 14, 16] </ref>. The classic dynamic programming algorithm, invented by Wagner and Fischer [16] and others [12, 15], has O (MN) worst-case running time. <p> In terms of the input parameters M and N this bound has not been improved upon, but several recent designs have complexities that depend on output parameters such as D and P. For example, Hunt and Szymanski <ref> [5] </ref> presented an algorithm whose running time is O (R log M ), where R is the total number of ordered pairs of positions at which the two sequences match.
Reference: [6] <author> V. I. Levenshtein, </author> <title> ``Binary codes capable of correcting deletions, insertions, and reversals,'' </title> <booktitle> Problems in Information Transmission 1 (1965), </booktitle> <pages> pp. 8-17. </pages>
Reference-contexts: 1. Introduction Let A and B be two sequences of length M and N respectively, where without loss of generality N M, and let D be the length of a shortest edit script between them. The parameter D is also known as the simple Levenshtein distance between the sequences <ref> [6] </ref>. The number of deletions and insertions in such a shortest script are also well defined quantities. In particular, P, the number of deletions in a shortest edit script is always equal to D/2 - (N - M)/2.
Reference: [7] <author> W. J. Masek, and M. S. Paterson, </author> <title> ``A faster algorithm for computing string edit distances,'' </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 20 (1980), </volume> <pages> pp. 18-31. </pages>
Reference-contexts: In particular, P, the number of deletions in a shortest edit script is always equal to D/2 - (N - M)/2. The problem of determining a shortest edit script (SES) or a longest common subsequence (LCS) between two sequences of symbols has been studied extensively <ref> [2, 4, 5, 7, 9, 11, 14, 16] </ref>. The classic dynamic programming algorithm, invented by Wagner and Fischer [16] and others [12, 15], has O (MN) worst-case running time. <p> The classic dynamic programming algorithm, invented by Wagner and Fischer [16] and others [12, 15], has O (MN) worst-case running time. Masek and Paterson <ref> [7] </ref> improved this algorithm by using the ``Four-Russians'' technique [1] to reduce the worst-case running time to hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 1 Supported in part by an NSF Presidential Young Investigator Award (grant DCR-8451397), with matching funds from AT&T. 2 Supported in part by the National Institutes of Health (grant LM-04970). 3 Supported in
Reference: [8] <author> W. Miller, and E. W. Myers, </author> <title> ``A file comparison program,'' </title> <journal> Software Practice & Experience, </journal> <volume> 15 (1985), </volume> <pages> pp. 1025-1040. </pages>
Reference-contexts: Later, Myers [9], Ukkonen [14], and Nakatsu, et al. [11] gave algorithms with worst-case time complexity O (ND), which are efficient when A and B are similar. Such algorithms have been used in file comparison programs <ref> [8] </ref> and for economically updating the video screen by a text editing program [10]. This represents an improvement since P = D/2 - D/2, where D = N - M, and in practice our algorithm is always twice as fast as the O (ND) algorithms.
Reference: [9] <author> E. W. Myers, </author> <title> ``An O(ND) difference algorithm and its variations,'' </title> <journal> Algorithmica, </journal> <volume> 1 (1986), </volume> <pages> pp. 251-266. </pages>
Reference-contexts: In particular, P, the number of deletions in a shortest edit script is always equal to D/2 - (N - M)/2. The problem of determining a shortest edit script (SES) or a longest common subsequence (LCS) between two sequences of symbols has been studied extensively <ref> [2, 4, 5, 7, 9, 11, 14, 16] </ref>. The classic dynamic programming algorithm, invented by Wagner and Fischer [16] and others [12, 15], has O (MN) worst-case running time. <p> For example, Hunt and Szymanski [5] presented an algorithm whose running time is O (R log M ), where R is the total number of ordered pairs of positions at which the two sequences match. Later, Myers <ref> [9] </ref>, Ukkonen [14], and Nakatsu, et al. [11] gave algorithms with worst-case time complexity O (ND), which are efficient when A and B are similar. Such algorithms have been used in file comparison programs [8] and for economically updating the video screen by a text editing program [10]. <p> Its superiority is even more pronounced when the problem is highly asymmetric, i.e., D &gt;> 0. Our algorithm is best explained by casting the longest common subsequence problem as a shortest paths problem on a grid-like graph called an edit graph (e.g., see <ref> [9] </ref>). The algorithm improves upon Myers's algorithm [9] by exploring fewer of the vertices in the edit graph. It does so by using a path-compression technique that has been used as a heuristic for shortest paths problems [13]. <p> Our algorithm is best explained by casting the longest common subsequence problem as a shortest paths problem on a grid-like graph called an edit graph (e.g., see <ref> [9] </ref>). The algorithm improves upon Myers's algorithm [9] by exploring fewer of the vertices in the edit graph. It does so by using a path-compression technique that has been used as a heuristic for shortest paths problems [13]. <p> The algorithm's dependence on P implies that it is particularly efficient when A is similar to a subsequence of the longer sequence B. In fact, the algorithm is O (N) when A is a subsequence of B. By using Hirschberg's divide-and-conquer technique <ref> [3, 9] </ref>, the algorithm can be modified to deliver a shortest edit script using only linear space. 2. <p> The problem of finding a longest common subsequence (LCS) and of finding a shortest edit script (SES) are dual problems as reflected in the equality D + 2L = M + N (e.g., see <ref> [9] </ref>). The edit graph for sequences A and B is a directed graph with a vertex at each grid point (x, y), 0 x M and 0 y N. Each vertex has a horizontal and a vertical edge to its right and lower neighbor if they exist. <p> With this definition diagonals are numbered from - M to N, diagonal 0 contains the source, and diagonal D = N - M contains the sink. The algorithm of Myers <ref> [9] </ref> examines vertices between diagonal - D and D, shown as the D band in Figure 2. Our algorithm only examines vertices in the smaller region between diagonals - P and D + P, shown as the P band in Figure 2. <p> Figure 3 depicts all D-values not greater than D = 6 and P-values not greater than P = 2 for the sequences of Figure 1. Like Myers's algorithm <ref> [9] </ref>, our algorithm centers on computing a set of furthest vertices in order of distance until the sink is reached. The furthest d-point in diagonal k is the vertex on diagonal k with D-value d that has the greatest y (x) coordinate. <p> The set of furthest d-points is FD (d) = - (y - k , y) : y = fd (k, d) and - d k d - (e.g., see <ref> [9] </ref>). The set FD (d) is the frontier of vertices whose edit distance is d. In Figure 3, the furthest points are underlined. <p> Let the total number of matched edges traversed be R P . Then, the total number of points visited is O (R p + PD), because at most D + 1 diagonals are covered in the computation. By an analysis as in <ref> [9] </ref>, we can show that the expected number of traversed matched edges is O (N + PD ). The expected time complexity of the algorithm is therefore O (N + PD). 4. Implementation We implemented our algorithm and compared it to Myers's O (ND) algorithm [9]. <p> By an analysis as in <ref> [9] </ref>, we can show that the expected number of traversed matched edges is O (N + PD ). The expected time complexity of the algorithm is therefore O (N + PD). 4. Implementation We implemented our algorithm and compared it to Myers's O (ND) algorithm [9]. Table 1 shows the test results for 100 randomly generated strings. Table 1 shows average values over 100 trials on randomly generated strings over an alphabet of size 16. <p> The sixth column shows the number of comparisons made during the computation of the O (ND) algorithm <ref> [9] </ref>. The last two columns show running times on a VAX 8650 under 4.3bsd UNIX. As can be seen in the table, the speedup is quite large when A and B differ in length but are quite similar.
Reference: [10] <author> E. W. Myers, and W. Miller, </author> <title> ``Row replacement algorithms for screen editors,'' </title> <journal> ACM Trans. Prog. Lang. and Syst., </journal> <volume> 11 (1989), </volume> <pages> pp. 33-56. </pages>
Reference-contexts: Later, Myers [9], Ukkonen [14], and Nakatsu, et al. [11] gave algorithms with worst-case time complexity O (ND), which are efficient when A and B are similar. Such algorithms have been used in file comparison programs [8] and for economically updating the video screen by a text editing program <ref> [10] </ref>. This represents an improvement since P = D/2 - D/2, where D = N - M, and in practice our algorithm is always twice as fast as the O (ND) algorithms. Its superiority is even more pronounced when the problem is highly asymmetric, i.e., D &gt;> 0.
Reference: [11] <author> N. Nakatsu, Y. Kambayashi, and S. Yajima, </author> <title> ``A longest common subsequence algorithm suitable for similar text string,'' </title> <journal> Acta Informatica, </journal> <volume> 18 (1982), </volume> <pages> pp. 171-179. </pages>
Reference-contexts: In particular, P, the number of deletions in a shortest edit script is always equal to D/2 - (N - M)/2. The problem of determining a shortest edit script (SES) or a longest common subsequence (LCS) between two sequences of symbols has been studied extensively <ref> [2, 4, 5, 7, 9, 11, 14, 16] </ref>. The classic dynamic programming algorithm, invented by Wagner and Fischer [16] and others [12, 15], has O (MN) worst-case running time. <p> For example, Hunt and Szymanski [5] presented an algorithm whose running time is O (R log M ), where R is the total number of ordered pairs of positions at which the two sequences match. Later, Myers [9], Ukkonen [14], and Nakatsu, et al. <ref> [11] </ref> gave algorithms with worst-case time complexity O (ND), which are efficient when A and B are similar. Such algorithms have been used in file comparison programs [8] and for economically updating the video screen by a text editing program [10].
Reference: [12] <author> S. B. Needleman, and C. D. Wunsch, </author> <title> ``A general method applicable to the search for similarities in the amino acid sequence of two proteins,'' </title> <journal> Journal of Molecular Biology, </journal> <volume> 48 (1970), </volume> <pages> pp. 443-453. </pages>
Reference-contexts: The problem of determining a shortest edit script (SES) or a longest common subsequence (LCS) between two sequences of symbols has been studied extensively [2, 4, 5, 7, 9, 11, 14, 16]. The classic dynamic programming algorithm, invented by Wagner and Fischer [16] and others <ref> [12, 15] </ref>, has O (MN) worst-case running time.
Reference: [13] <author> R. Sedgewick, and J. S. Vitter, </author> <title> ``Shortest paths in Euclidean graphs,'' </title> <journal> Algorithmica, </journal> <volume> 1 (1986), </volume> <pages> pp. 31-48. </pages>
Reference-contexts: The algorithm improves upon Myers's algorithm [9] by exploring fewer of the vertices in the edit graph. It does so by using a path-compression technique that has been used as a heuristic for shortest paths problems <ref> [13] </ref>.
Reference: [14] <author> E. Ukkonen, </author> <title> ``Algorithms for approximate string matching,'' </title> <journal> Information and Control, </journal> <volume> 64, </volume> <year> (1985), </year> <pages> pp. 100-118. </pages>
Reference-contexts: In particular, P, the number of deletions in a shortest edit script is always equal to D/2 - (N - M)/2. The problem of determining a shortest edit script (SES) or a longest common subsequence (LCS) between two sequences of symbols has been studied extensively <ref> [2, 4, 5, 7, 9, 11, 14, 16] </ref>. The classic dynamic programming algorithm, invented by Wagner and Fischer [16] and others [12, 15], has O (MN) worst-case running time. <p> For example, Hunt and Szymanski [5] presented an algorithm whose running time is O (R log M ), where R is the total number of ordered pairs of positions at which the two sequences match. Later, Myers [9], Ukkonen <ref> [14] </ref>, and Nakatsu, et al. [11] gave algorithms with worst-case time complexity O (ND), which are efficient when A and B are similar. Such algorithms have been used in file comparison programs [8] and for economically updating the video screen by a text editing program [10].
Reference: [15] <author> T.K. Vintsyuk, </author> <title> ``Speech discrimination by dynamic programming,'' </title> <journal> Cybernetics, </journal> <volume> 4 (1968), </volume> <pages> pp. 55-57. </pages>
Reference-contexts: The problem of determining a shortest edit script (SES) or a longest common subsequence (LCS) between two sequences of symbols has been studied extensively [2, 4, 5, 7, 9, 11, 14, 16]. The classic dynamic programming algorithm, invented by Wagner and Fischer [16] and others <ref> [12, 15] </ref>, has O (MN) worst-case running time.
Reference: [16] <author> R. A. Wagner and M. J. Fischer, </author> <title> ``The string to string correction problem,'' </title> <journal> Journal of the ACM, </journal> <volume> 21 (1974), </volume> <pages> pp. 168-173. </pages>
Reference-contexts: In particular, P, the number of deletions in a shortest edit script is always equal to D/2 - (N - M)/2. The problem of determining a shortest edit script (SES) or a longest common subsequence (LCS) between two sequences of symbols has been studied extensively <ref> [2, 4, 5, 7, 9, 11, 14, 16] </ref>. The classic dynamic programming algorithm, invented by Wagner and Fischer [16] and others [12, 15], has O (MN) worst-case running time. <p> The problem of determining a shortest edit script (SES) or a longest common subsequence (LCS) between two sequences of symbols has been studied extensively [2, 4, 5, 7, 9, 11, 14, 16]. The classic dynamic programming algorithm, invented by Wagner and Fischer <ref> [16] </ref> and others [12, 15], has O (MN) worst-case running time.
References-found: 15

