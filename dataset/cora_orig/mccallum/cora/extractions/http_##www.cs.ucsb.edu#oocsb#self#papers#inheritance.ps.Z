URL: http://www.cs.ucsb.edu/oocsb/self/papers/inheritance.ps.Z
Refering-URL: http://www.cs.ucsb.edu/oocsb/self/papers/parents-shared-parts.html
Root-URL: http://www.cs.ucsb.edu
Email: (self@self.stanford.edu)  
Title: Parents are Shared Parts of Objects: Inheritance and Encapsulation in SELF  
Author: CRAIG CHAMBERS DAVID UNGAR BAY-WEI CHANG URS HLZLE 
Address: 94305  
Affiliation: Computer Systems Laboratory, Stanford University, Stanford, California  
Date: 4, 3, 1991  
Note: To be published in: LISP AND SYMBOLIC COMPUTATION: An International Journal,  1991 Kluwer Academic Publishers Manufactured in The Netherlands  
Abstract: The design of inheritance and encapsulation in SELF, an object-oriented language based on prototypes, results from understanding that inheritance allows parents to be shared parts of their children. The programmer resolves ambiguities arising from multiple inheritance by prioritizing an objects parents. Unifying unordered and ordered multiple inheritance supports differential programming of abstractions and methods, combination of unrelated abstractions, unequal combination of abstractions, and mixins. In SELF, a private slot may be accessed if the sending method is a shared part of the receiver, allowing privileged communication between related objects. Thus, classless SELF enjoys the benefits of class-based encapsulation. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Bobrow, D. G., DeMichiel, L. G., Gabriel, R. P., Keene, S. E., Kiczales, G., and Moon, D. A. </author> <title> Common Lisp Object System Specification. </title> <journal> Published as SIGPLAN Notices, </journal> <volume> 23, </volume> <month> 9 </month> <year> (1988). </year> <title> INHERITANCE AND ENCAPSULATION IN SELF 35 </title>
Reference-contexts: But multiple inheritance introduces a new complexity: two or more parents may define slots with the same name. 2.1 Ordered vs. Unordered Multiple Inheritance Previous languages belong to one of two camps in handling this name clash problem. Some languages, like New Flavors [16], CommonLoops [2], and CLOS <ref> [1] </ref>, rank an objects parents, and automatically resolve the ambiguity in favor of the slot inherited from the highest-ranked parent. We call this approach ordered inheritance.
Reference: 2. <author> Bobrow, D. G., Kahn, K., Kiczales, G., Masinter, L., Stefik, M., and Zdybel, F. CommonLoops: </author> <title> Merging Lisp and Object-Oriented Programming. </title> <booktitle> In OOPSLA 86 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 21, </volume> <month> 11 </month> <year> (1986) </year> <month> 17-29. </month>
Reference-contexts: But multiple inheritance introduces a new complexity: two or more parents may define slots with the same name. 2.1 Ordered vs. Unordered Multiple Inheritance Previous languages belong to one of two camps in handling this name clash problem. Some languages, like New Flavors [16], CommonLoops <ref> [2] </ref>, and CLOS [1], rank an objects parents, and automatically resolve the ambiguity in favor of the slot inherited from the highest-ranked parent. We call this approach ordered inheritance.
Reference: 3. <author> Borning, A. H. </author> <title> Classes Versus Prototypes in Object-Oriented Languages. </title> <booktitle> In Proceedings of the ACM/IEEE Fall Joint Computer Conference (1986) 36-40. </booktitle>
Reference-contexts: Many of these languages are based on classes and use inheritance to allow a class to obtain methods and instance variables [26]. (Sometimes classes and inheritance are also used to specify type compatibility.) Within the last few years, however, there have been several proposals for languages based on prototypes <ref> [3, 9, 10, 12, 22, 25] </ref>. These languages do not include classes but instead allow individual objects to inherit from (or delegate to) other objects. The issues surrounding inheritance and encapsulation need to be revisited when designing such a language.
Reference: 4. <author> Chambers, C., and Ungar, D. </author> <title> Customization: Optimizing Compiler Technology for SELF, a Dynamically-Typed Object-Oriented Programming Language. </title> <booktitle> In Proceedings of the SIGPLAN 89 Conference on Programming Language Design and Implementation. Published as SIGPLAN Notices, </booktitle> <volume> 24, </volume> <month> 7 </month> <year> (1989) </year> <month> 146-160. </month>
Reference-contexts: The issues surrounding inheritance and encapsulation need to be revisited when designing such a language. This paper describes the inheritance and encapsulation mechanisms we designed and implemented in one prototype-based language, SELF <ref> [4, 5, 11, 25] </ref>. Our design *This work has been generously supported by National Science Foundation Presidential Young Investigator Grant #CCR-8657631, and by Sun Microsystems, IBM, Apple Computer, Cray Labora tories, Tandem Computers, NCR, Texas Instruments, and DEC.
Reference: 5. <author> Chambers, C., Ungar, D., and Lee, E. </author> <title> An Efficient Implementation of SELF, a Dynamically-Typed Object-Oriented Language Based on Prototypes. </title> <booktitle> In OOPSLA 89 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 24, </volume> <month> 10 </month> <year> (1989) </year> <month> 49-70. </month> <note> Also to be published in Lisp and Symbolic Computation, 4, 3 (1991). </note>
Reference-contexts: The issues surrounding inheritance and encapsulation need to be revisited when designing such a language. This paper describes the inheritance and encapsulation mechanisms we designed and implemented in one prototype-based language, SELF <ref> [4, 5, 11, 25] </ref>. Our design *This work has been generously supported by National Science Foundation Presidential Young Investigator Grant #CCR-8657631, and by Sun Microsystems, IBM, Apple Computer, Cray Labora tories, Tandem Computers, NCR, Texas Instruments, and DEC. <p> An object may allow assignments to a data slot by associating an assignment slot with the data slot. New objects are created by cloning (shallow-copying) pre-existing objects. For a more complete description of SELFs syntax and object model, see <ref> [5, 11, 25] </ref>. In the absence of inheritance, message lookup in SELF is handled by searching the receiver for a slot that matches the message name and evaluating the contents of the matching slot (or generating a messageNotUnderstood error if there is no matching slot).
Reference: 6. <author> Cunningham, W. </author> <title> Objects without inheritance. </title> <type> Personal communication (1989). </type>
Reference-contexts: We concern ourselves here only with inheritance as a code sharing mechanism. 2 An alternate approach would be to provide a mechanism to visit every object in some set, and automatically perform the change to each object in the set. This approach has been explored by other researchers <ref> [6, 19] </ref>. INHERITANCE AND ENCAPSULATION IN SELF 23 This view of inheritance provides a natural explanation for many aspects of an object-oriented language.
Reference: 7. <author> Goldberg, A., and Robson, D. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1983). </address>
Reference-contexts: This distinction between unspecified scope and public scope is a unique feature of SELF designed to support both exploratory and production programming. 3.2 The Meaning of Privacy Existing encapsulation systems are either object-based or module-based (class-based). For example, the Smalltalk-80 5 language <ref> [7] </ref> provides object-based encapsulation of instance variables, meaning that a method may only access the instance variables of self. Trellis/Owl and Eiffel use object-based encapsulation for both instance variables and methods. Unfortunately, object-based encapsulation alone is too restrictive.
Reference: 8. <author> Kristensen, B. B., Madsen, O. L., Mller-Pedersen, and Nygaard, K. </author> <title> The BETA Programming Language. </title> <editor> In Shriver, B., and Wegner, P., editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <publisher> The MIT Press, </publisher> <address> Cam-bridge, MA (1987). </address>
Reference-contexts: Directed resends may not be used in mixins, where the method invoked by the resend differs depending on what objects are mixed in at a lower priority. In BETA <ref> [8, 13] </ref>, virtual functions are invoked from least specific to most specific, with the keyword inner being used to invoke the next more specific method.
Reference: 9. <author> LaLonde, W. R. </author> <title> Designing Families of Data Types Using Exemplars. </title> <journal> In ACM Transactions on Programming Languages and Systems, </journal> <volume> 11, </volume> <month> 2 </month> <year> (1989) </year> <month> 212-248. </month>
Reference-contexts: Many of these languages are based on classes and use inheritance to allow a class to obtain methods and instance variables [26]. (Sometimes classes and inheritance are also used to specify type compatibility.) Within the last few years, however, there have been several proposals for languages based on prototypes <ref> [3, 9, 10, 12, 22, 25] </ref>. These languages do not include classes but instead allow individual objects to inherit from (or delegate to) other objects. The issues surrounding inheritance and encapsulation need to be revisited when designing such a language.
Reference: 10. <author> LaLonde, W. R., Thomas, D. A., and Pugh, J. R. </author> <title> An Exemplar Based Small-talk. </title> <booktitle> In OOPSLA 86 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 21, </volume> <month> 11 </month> <year> (1986) </year> <month> 322-330. </month>
Reference-contexts: Many of these languages are based on classes and use inheritance to allow a class to obtain methods and instance variables [26]. (Sometimes classes and inheritance are also used to specify type compatibility.) Within the last few years, however, there have been several proposals for languages based on prototypes <ref> [3, 9, 10, 12, 22, 25] </ref>. These languages do not include classes but instead allow individual objects to inherit from (or delegate to) other objects. The issues surrounding inheritance and encapsulation need to be revisited when designing such a language.
Reference: 11. <author> Lee, E. </author> <title> Object Storage and Inheritance for SELF, a Prototype-Based Object-Oriented Programming Language. </title> <type> Engineers thesis, </type> <institution> Stanford University (1988). </institution>
Reference-contexts: The issues surrounding inheritance and encapsulation need to be revisited when designing such a language. This paper describes the inheritance and encapsulation mechanisms we designed and implemented in one prototype-based language, SELF <ref> [4, 5, 11, 25] </ref>. Our design *This work has been generously supported by National Science Foundation Presidential Young Investigator Grant #CCR-8657631, and by Sun Microsystems, IBM, Apple Computer, Cray Labora tories, Tandem Computers, NCR, Texas Instruments, and DEC. <p> An object may allow assignments to a data slot by associating an assignment slot with the data slot. New objects are created by cloning (shallow-copying) pre-existing objects. For a more complete description of SELFs syntax and object model, see <ref> [5, 11, 25] </ref>. In the absence of inheritance, message lookup in SELF is handled by searching the receiver for a slot that matches the message name and evaluating the contents of the matching slot (or generating a messageNotUnderstood error if there is no matching slot).
Reference: 12. <author> Lieberman, H. </author> <title> Using Prototypical Objects to Implement Shared Behavior in Object-Oriented Systems. </title> <booktitle> In OOPSLA 86 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 21, </volume> <month> 11 </month> <year> (1986) </year> <month> 214-223. </month> <type> 36 CHAMBERS, UNGAR, </type> <institution> CHANG, AND HLZLE </institution>
Reference-contexts: Many of these languages are based on classes and use inheritance to allow a class to obtain methods and instance variables [26]. (Sometimes classes and inheritance are also used to specify type compatibility.) Within the last few years, however, there have been several proposals for languages based on prototypes <ref> [3, 9, 10, 12, 22, 25] </ref>. These languages do not include classes but instead allow individual objects to inherit from (or delegate to) other objects. The issues surrounding inheritance and encapsulation need to be revisited when designing such a language.
Reference: 13. <author> Madsen, O. L., and Mller-Pedersen, B. </author> <title> Virtual Classes: A Powerful Mechanism in Object-Oriented Programming. </title> <booktitle> In OOPSLA 89 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 24, </volume> <month> 10 </month> <year> (1989) </year> <month> 397-406. </month>
Reference-contexts: Directed resends may not be used in mixins, where the method invoked by the resend differs depending on what objects are mixed in at a lower priority. In BETA <ref> [8, 13] </ref>, virtual functions are invoked from least specific to most specific, with the keyword inner being used to invoke the next more specific method.
Reference: 14. <author> Meyer, B. </author> <title> Genericity versus Inheritance. </title> <booktitle> In OOPSLA 86 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 21, </volume> <month> 11 </month> <year> (1986) </year> <month> 391-405. </month>
Reference-contexts: Linearization has two drawbacks: it masks ambiguities between otherwise unordered ancestors, and it fails with inheritance graphs that it deems inconsistent. The opposite approach to resolving ambiguities among an objects parents is to leave it up to the programmer. Languages like Trellis/Owl [17, 18], Eiffel <ref> [14, 15] </ref>, C++ version 2.0 [23, 24], and CommonObjects [20, 21] treat an objects parents as equals without a relative ordering and treat ambiguities as programming errors that need to be explicitly resolved by the programmer. 3 We call this approach unordered inheritance.
Reference: 15. <author> Meyer, B. </author> <title> Eiffel: An Introduction, Version 2.1. TR-EI-3/GI, Interactive Software Engineering, </title> <publisher> Inc., </publisher> <address> Goleta, CA (1988). </address>
Reference-contexts: Linearization has two drawbacks: it masks ambiguities between otherwise unordered ancestors, and it fails with inheritance graphs that it deems inconsistent. The opposite approach to resolving ambiguities among an objects parents is to leave it up to the programmer. Languages like Trellis/Owl [17, 18], Eiffel <ref> [14, 15] </ref>, C++ version 2.0 [23, 24], and CommonObjects [20, 21] treat an objects parents as equals without a relative ordering and treat ambiguities as programming errors that need to be explicitly resolved by the programmer. 3 We call this approach unordered inheritance.
Reference: 16. <author> Moon, D. A. </author> <title> Object-Oriented Programming with Flavors. </title> <booktitle> In OOPSLA 86 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 21, </volume> <month> 11 </month> <year> (1986) </year> <month> 1-16. </month>
Reference-contexts: But multiple inheritance introduces a new complexity: two or more parents may define slots with the same name. 2.1 Ordered vs. Unordered Multiple Inheritance Previous languages belong to one of two camps in handling this name clash problem. Some languages, like New Flavors <ref> [16] </ref>, CommonLoops [2], and CLOS [1], rank an objects parents, and automatically resolve the ambiguity in favor of the slot inherited from the highest-ranked parent. We call this approach ordered inheritance.
Reference: 17. <author> Schaffert, C., Cooper, T., and Wilpolt, C. </author> <title> Trellis Object-Based Environment: Language Reference Manual, </title> <type> Version 1.1. </type> <institution> DEC-TR-372, Digital Equipment Corp., Hudson, </institution> <address> MA (1985). </address>
Reference-contexts: Linearization has two drawbacks: it masks ambiguities between otherwise unordered ancestors, and it fails with inheritance graphs that it deems inconsistent. The opposite approach to resolving ambiguities among an objects parents is to leave it up to the programmer. Languages like Trellis/Owl <ref> [17, 18] </ref>, Eiffel [14, 15], C++ version 2.0 [23, 24], and CommonObjects [20, 21] treat an objects parents as equals without a relative ordering and treat ambiguities as programming errors that need to be explicitly resolved by the programmer. 3 We call this approach unordered inheritance.
Reference: 18. <author> Schaffert, C., Cooper, T., Bullis, B., Kilian, M., and Wilpolt, C. </author> <title> An Introduction to Trellis/Owl. </title> <booktitle> In OOPSLA 86 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 21, </volume> <month> 11 </month> <year> (1986) </year> <month> 9-16. </month>
Reference-contexts: Linearization has two drawbacks: it masks ambiguities between otherwise unordered ancestors, and it fails with inheritance graphs that it deems inconsistent. The opposite approach to resolving ambiguities among an objects parents is to leave it up to the programmer. Languages like Trellis/Owl <ref> [17, 18] </ref>, Eiffel [14, 15], C++ version 2.0 [23, 24], and CommonObjects [20, 21] treat an objects parents as equals without a relative ordering and treat ambiguities as programming errors that need to be explicitly resolved by the programmer. 3 We call this approach unordered inheritance.
Reference: 19. <author> Smith, R. B. </author> <title> Objects without inheritance. </title> <type> Personal communication (1990). </type>
Reference-contexts: We concern ourselves here only with inheritance as a code sharing mechanism. 2 An alternate approach would be to provide a mechanism to visit every object in some set, and automatically perform the change to each object in the set. This approach has been explored by other researchers <ref> [6, 19] </ref>. INHERITANCE AND ENCAPSULATION IN SELF 23 This view of inheritance provides a natural explanation for many aspects of an object-oriented language.
Reference: 20. <author> Snyder, A. CommonObjects: </author> <title> An Overview. </title> <institution> STL-86-13, Hewlett-Packard Laboratories, </institution> <address> Palo Alto, CA (1986). </address>
Reference-contexts: The opposite approach to resolving ambiguities among an objects parents is to leave it up to the programmer. Languages like Trellis/Owl [17, 18], Eiffel [14, 15], C++ version 2.0 [23, 24], and CommonObjects <ref> [20, 21] </ref> treat an objects parents as equals without a relative ordering and treat ambiguities as programming errors that need to be explicitly resolved by the programmer. 3 We call this approach unordered inheritance.
Reference: 21. <author> Snyder, A. </author> <title> Encapsulation and Inheritance in Object-Oriented Programming Languages. </title> <booktitle> In OOPSLA 86 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 21, </volume> <month> 11 </month> <year> (1986) </year> <month> 17-29. </month>
Reference-contexts: The opposite approach to resolving ambiguities among an objects parents is to leave it up to the programmer. Languages like Trellis/Owl [17, 18], Eiffel [14, 15], C++ version 2.0 [23, 24], and CommonObjects <ref> [20, 21] </ref> treat an objects parents as equals without a relative ordering and treat ambiguities as programming errors that need to be explicitly resolved by the programmer. 3 We call this approach unordered inheritance.
Reference: 22. <author> Stein, L. A. </author> <title> Delegation Is Inheritance. </title> <booktitle> In OOPSLA 87 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 22, </volume> <month> 12 </month> <year> (1987) </year> <month> 138-146. </month>
Reference-contexts: Many of these languages are based on classes and use inheritance to allow a class to obtain methods and instance variables [26]. (Sometimes classes and inheritance are also used to specify type compatibility.) Within the last few years, however, there have been several proposals for languages based on prototypes <ref> [3, 9, 10, 12, 22, 25] </ref>. These languages do not include classes but instead allow individual objects to inherit from (or delegate to) other objects. The issues surrounding inheritance and encapsulation need to be revisited when designing such a language.
Reference: 23. <author> Stroustrup, B. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1986). </address>
Reference-contexts: The opposite approach to resolving ambiguities among an objects parents is to leave it up to the programmer. Languages like Trellis/Owl [17, 18], Eiffel [14, 15], C++ version 2.0 <ref> [23, 24] </ref>, and CommonObjects [20, 21] treat an objects parents as equals without a relative ordering and treat ambiguities as programming errors that need to be explicitly resolved by the programmer. 3 We call this approach unordered inheritance.
Reference: 24. <author> Stroustrup, B. </author> <title> The Evolution of C++: </title> <booktitle> 1985 to 1987. In USENIX C++ Workshop Proceedings (1987) 1-21. </booktitle>
Reference-contexts: The opposite approach to resolving ambiguities among an objects parents is to leave it up to the programmer. Languages like Trellis/Owl [17, 18], Eiffel [14, 15], C++ version 2.0 <ref> [23, 24] </ref>, and CommonObjects [20, 21] treat an objects parents as equals without a relative ordering and treat ambiguities as programming errors that need to be explicitly resolved by the programmer. 3 We call this approach unordered inheritance.
Reference: 25. <author> Ungar, D., and Smith, R. B. </author> <title> SELF: The Power of Simplicity. </title> <booktitle> In OOPSLA 87 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 22, </volume> <month> 12 </month> <year> (1987) </year> <month> 227-241. </month> <note> Also to be published in Lisp and Symbolic Computation, 4, 3 (1991). </note>
Reference-contexts: Many of these languages are based on classes and use inheritance to allow a class to obtain methods and instance variables [26]. (Sometimes classes and inheritance are also used to specify type compatibility.) Within the last few years, however, there have been several proposals for languages based on prototypes <ref> [3, 9, 10, 12, 22, 25] </ref>. These languages do not include classes but instead allow individual objects to inherit from (or delegate to) other objects. The issues surrounding inheritance and encapsulation need to be revisited when designing such a language. <p> The issues surrounding inheritance and encapsulation need to be revisited when designing such a language. This paper describes the inheritance and encapsulation mechanisms we designed and implemented in one prototype-based language, SELF <ref> [4, 5, 11, 25] </ref>. Our design *This work has been generously supported by National Science Foundation Presidential Young Investigator Grant #CCR-8657631, and by Sun Microsystems, IBM, Apple Computer, Cray Labora tories, Tandem Computers, NCR, Texas Instruments, and DEC. <p> An object may allow assignments to a data slot by associating an assignment slot with the data slot. New objects are created by cloning (shallow-copying) pre-existing objects. For a more complete description of SELFs syntax and object model, see <ref> [5, 11, 25] </ref>. In the absence of inheritance, message lookup in SELF is handled by searching the receiver for a slot that matches the message name and evaluating the contents of the matching slot (or generating a messageNotUnderstood error if there is no matching slot).
Reference: 26. <author> Wegner, P. </author> <title> Dimensions of Object-Based Language Design. </title> <booktitle> In OOPSLA 87 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 22, </volume> <month> 12 </month> <year> (1987) </year> <month> 168-182. </month>
Reference-contexts: 1 Introduction Inheritance is a basic feature of most object-oriented languages. Many of these languages are based on classes and use inheritance to allow a class to obtain methods and instance variables <ref> [26] </ref>. (Sometimes classes and inheritance are also used to specify type compatibility.) Within the last few years, however, there have been several proposals for languages based on prototypes [3, 9, 10, 12, 22, 25].
References-found: 26

