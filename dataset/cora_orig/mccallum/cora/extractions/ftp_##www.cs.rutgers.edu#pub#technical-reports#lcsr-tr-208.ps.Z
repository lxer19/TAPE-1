URL: ftp://www.cs.rutgers.edu/pub/technical-reports/lcsr-tr-208.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: STATIC DETECTION OF DEADLOCKS IN POLYNOMIAL TIME  Written under the direction of  
Author: BY STEPHEN P. MASTICOLA Dr. Barbara G. Ryder 
Degree: A dissertation submitted to the Graduate School|New Brunswick  in partial fulfillment of the requirements for the degree of Doctor of Philosophy  and approved by  
Date: May, 1993  
Note: Graduate Program in Computer Science  
Address: New Jersey  Brunswick, New Jersey  
Affiliation: Rutgers, The State University of  New  
Abstract-found: 0
Intro-found: 0
Reference: [ABC + 91] <author> G. S. Avrunin, U. A. Buy, J. C. Corbett, L. K. Dillon, and J. C. Wileden. </author> <title> Experiments with an improved constrained expression toolset. </title> <booktitle> In Proceedings of the ACM SIGSOFT '91 Fourth Symposium on Testing, Analysis, and Verification (TAV4), </booktitle> <pages> pages 178-187, </pages> <address> Victoria, BC, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: Thus, they are unlikely to come into general use in the near future. Also, if the control set (or a useful superset) for the program cannot be described by a simple predicate, the number of proof steps required may explode combinatorially. Later published work on constrained expressions <ref> [ADW89, ABC + 91] </ref> describes the implementation of a concurrency analysis tool based on constrained expressions, and gives empirical results for small test programs. 10.5.3 Optimizing the proof process: Apt [Apt83]. In [Apt83], Apt proposes a formal proof technique for freedom from infinite waits (which he calls deadlocks).
Reference: [Ada92] <author> Ada 9X Mapping/Revision Team. </author> <title> Ada 9X mapping volume I: mapping rationale version 4.1. </title> <type> Technical Report IR-MA-1249-2, </type> <institution> Intermetrics, Inc., </institution> <address> Cambridge, MA, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: For instance, the representation for SACnt records is known to be larger than necessary. More complete modeling of Ada tasking. In particular, we would like to directly model subprograms with included tasking, dynamic task creation, and the abort statement. Modeling Ada 9X synchronization. The Ada 9X draft mapping document <ref> [Ada92] </ref> specifies further additions to the tasking model. These additions include non-blocking signaling, asynchronous multicast, support for large numbers of tasks, and statement-level parallelism. The impact of these additions upon static deadlock detection should be investigated theoretically and experimentally. * Binary semaphores. Acquire test programs; implement and test algorithm.
Reference: [ADW89] <author> G. S. Avrunin, L. K. Dillon, and J. C. Wileden. </author> <title> Experiments with automated constrained expression analysis of concurrent software systems. </title> <editor> In R. A. Kemmerer, editor, </editor> <booktitle> Proceedings of the ACM SIGSOFT '89 Third Symposium on Testing, Analysis, and Verification (TAV3), </booktitle> <pages> pages 124-130, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Thus, they are unlikely to come into general use in the near future. Also, if the control set (or a useful superset) for the program cannot be described by a simple predicate, the number of proof steps required may explode combinatorially. Later published work on constrained expressions <ref> [ADW89, ABC + 91] </ref> describes the implementation of a concurrency analysis tool based on constrained expressions, and gives empirical results for small test programs. 10.5.3 Optimizing the proof process: Apt [Apt83]. In [Apt83], Apt proposes a formal proof technique for freedom from infinite waits (which he calls deadlocks).
Reference: [ADWR86] <author> G. S. Avrunin, L. K. Dillon, J. C. Wileden, and W. E. Riddle. </author> <title> Constrained expressions: adding analysis capabilities to design methods for concurrent software systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 278-291, </pages> <month> February </month> <year> 1986. </year>
Reference-contexts: Constrained regular expressions: Avrunin, Dillon, Wileden, and Riddle <ref> [ADWR86] </ref>. : : : : : : : : : : : : : : : : : : : : : : 371 10.5.2. Isolation-based proofs: Dillon [Dil90]. : : : : : : : : : : : : : : : 372 10.5.3. <p> The work of Apt ([Apt83], Section 10.5.3) is related to both of these; he also enumerates potentially blocked states to prove they cannot be entered. Section 10.5.4 gives a concise summary of model-checking approaches. 10.5.1 Constrained regular expressions: Avrunin, Dillon, Wileden, and Riddle <ref> [ADWR86] </ref>. Avrunin, Dillon, Wileden, and Riddle [ADWR86] propose the use of constrained expressions to express concurrency. A constrained expression consists of a regular expression, which generates concurrency histories, and a set of constraints to filter out impossible histories. <p> The work of Apt ([Apt83], Section 10.5.3) is related to both of these; he also enumerates potentially blocked states to prove they cannot be entered. Section 10.5.4 gives a concise summary of model-checking approaches. 10.5.1 Constrained regular expressions: Avrunin, Dillon, Wileden, and Riddle <ref> [ADWR86] </ref>. Avrunin, Dillon, Wileden, and Riddle [ADWR86] propose the use of constrained expressions to express concurrency. A constrained expression consists of a regular expression, which generates concurrency histories, and a set of constraints to filter out impossible histories. <p> In [Apt83], Apt proposes a formal proof technique for freedom from infinite waits (which he calls deadlocks). Apt's technique is related to both [Dil90] and <ref> [ADWR86] </ref>; proof of freedom from infinite wait depends upon enumerating the blocked configurations (infinite 374 wait states) of the program. For each of these blocked configurations, the programmer is required to prove that the conjunction of assertions at each program point in each task in the configuration is logically inconsistent. <p> For each of these blocked configurations, the programmer is required to prove that the conjunction of assertions at each program point in each task in the configuration is logically inconsistent. As in <ref> [ADWR86] </ref>, Apt uses regular expressions to prune unreachable configurations. Apt also proposes to optimize the number of blocked configurations by dividing the program into communication-closed layers, which is equivalent to the parceling optimization made in [Tay83b]. This reduces the number of blocked configurations, thus easing the proof task. <p> Iterative refinement of CHT races [ZYN86] 10.3.1 Exp Deadlocks [MSS89] 10.3.2 Exp Infinite waits [CU91] 10.3.2 Exp Deadlocks; livelocks [KB90] 10.3.3 ? Livelock-induced starvation [CS88] 10.4.1 Poly CHT B4 problem formulation [DS91] 10.4.2 Poly CHT B4 problem formulation [Mer92] 10.4.3 Poly CHT [EP88] 10.4.4 Exp Races [BK89] 10.4.5 ? Races <ref> [ADWR86] </ref> 10.5.1 N/A Proofs [Dil90] 10.5.2 N/A Proofs [Apt83] 10.5.3 N/A Proofs [CES86] 10.5.4 Exp Model checking Table 10.1: Summary of related synchronization and non-concurrency analysis tech niques. 377 the accuracy of the solution.
Reference: [Ame83] <author> American National Standards Institute. </author> <title> ANSI/MIL-STD 1815A (1983) reference manual for the Ada programming language. </title> <institution> United States Government Printing Office, </institution> <year> 1983. </year>
Reference-contexts: Ada <ref> [Ame83] </ref> has features that allow the rendezvous to act as a type of "remote procedure call". The task entry (or accept) acts as the body of the called procedure, and the signaling task acts as the caller. <p> The else clause will typically not include any coordinations with other tasks. However, the ANSI Ada specification <ref> [Ame83] </ref> does not rule out this possibility, so it must be 86 considered for the sake of completeness. We first examine the impact of else clauses without rendezvous on possible deadlocks, and then look at the effects of including rendezvous statements in the else clause.
Reference: [Apt83] <author> K. R Apt. </author> <title> A static analysis of CSP programs. </title> <booktitle> In Lecture Notes in Computer Science #164 Logics of Programs, </booktitle> <pages> pages 1-17. </pages> <publisher> Springer-Verlag, </publisher> <year> 1983. </year>
Reference-contexts: Isolation-based proofs: Dillon [Dil90]. : : : : : : : : : : : : : : : 372 10.5.3. Optimizing the proof process: Apt <ref> [Apt83] </ref> . : : : : : : : : : : : : 373 10.5.4. Model checking. : : : : : : : : : : : : : : : : : : : : : : : : : : : 374 10.6. <p> Later published work on constrained expressions [ADW89, ABC + 91] describes the implementation of a concurrency analysis tool based on constrained expressions, and gives empirical results for small test programs. 10.5.3 Optimizing the proof process: Apt <ref> [Apt83] </ref>. In [Apt83], Apt proposes a formal proof technique for freedom from infinite waits (which he calls deadlocks). Apt's technique is related to both [Dil90] and [ADWR86]; proof of freedom from infinite wait depends upon enumerating the blocked configurations (infinite 374 wait states) of the program. <p> Later published work on constrained expressions [ADW89, ABC + 91] describes the implementation of a concurrency analysis tool based on constrained expressions, and gives empirical results for small test programs. 10.5.3 Optimizing the proof process: Apt <ref> [Apt83] </ref>. In [Apt83], Apt proposes a formal proof technique for freedom from infinite waits (which he calls deadlocks). Apt's technique is related to both [Dil90] and [ADWR86]; proof of freedom from infinite wait depends upon enumerating the blocked configurations (infinite 374 wait states) of the program. <p> Deadlocks [MSS89] 10.3.2 Exp Infinite waits [CU91] 10.3.2 Exp Deadlocks; livelocks [KB90] 10.3.3 ? Livelock-induced starvation [CS88] 10.4.1 Poly CHT B4 problem formulation [DS91] 10.4.2 Poly CHT B4 problem formulation [Mer92] 10.4.3 Poly CHT [EP88] 10.4.4 Exp Races [BK89] 10.4.5 ? Races [ADWR86] 10.5.1 N/A Proofs [Dil90] 10.5.2 N/A Proofs <ref> [Apt83] </ref> 10.5.3 N/A Proofs [CES86] 10.5.4 Exp Model checking Table 10.1: Summary of related synchronization and non-concurrency analysis tech niques. 377 the accuracy of the solution.
Reference: [ASU86] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Another upper bound is O (jTasksj 2 ), since the call graph has at most O (jTasksj) nodes. The strong components of CallG may be found in time proportional to the number of nodes and edges of CallG <ref> [ASU86] </ref>; step 4 thus takes O (jTasksj 2 ) in the worst case. Step 5 can then be done via a simple scan of E call , in O (jTasksj 2 ) time.
Reference: [Ban78] <author> J. P. Banning. </author> <title> A Method for Determining the Side Effects of Procedure Calls. </title> <type> PhD thesis, </type> <institution> Department of Electrical Engineering, Stanford University, </institution> <month> August </month> <year> 1978. </year>
Reference-contexts: States of entries. In an execution wave (E; A), the entries of E may be in one of two states. E [i] is in state READY if it can complete execution with abstract store A, under the assumption that all control paths represented by E [i] are executable <ref> [Ban78] </ref>. <p> if we omit the Ada select statement.) Taylor restricts the domain of his proofs to programs whose tasks are statically defined, and which execute exactly while the main procedure is executing (i.e., the 1 Taylor's criterion of exactness is actually that the problem solutions are precise up to symbolic execution <ref> [Ban78] </ref>, i.e., they make the assumption that all control paths are executable. Since he analyzes concurrent programs, he also assumes that all rendezvous between statements are executable. 342 programs have no abort statements).
Reference: [BCM + 90] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, D. L. Dill, and L. J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proceedings of the Fifth IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <address> Philadelphia, PA, </address> <year> 1990. </year>
Reference-contexts: Although model checking can be automated, it may be combinatorially explosive; much of the work in the field is aimed at minimizing the size of the state spaces that must be generated <ref> [BCM + 90, CGL92] </ref>. 10.6 Summary of static analysis methods. Table 10.1 is a summary of the static and formal methods for analyzing synchronization.
Reference: [BCW88] <author> R. A. Becker, J. M. Chambers, , and A. R. Wilks. </author> <title> The New S Language. </title> <publisher> Wadsworth and Brooks/Cole, </publisher> <address> Pacific Grove, CA, </address> <year> 1988. </year> <note> ISBN 0-534-09192-X. 400 </note>
Reference-contexts: Thus, no analysis that ran for more than 1200 seconds would have run to completion, even given unlimited time. 7.4.1 Data gathered. Tables 7.1, 7.2, and 7.3 list the types of data gathered on the performance of the polynomial and all-states deadlock analyzers. The S statistical package <ref> [BCW88] </ref> was used to analyze and plot the raw data. The independent variables (Table 7.1) depend upon the structure of the source program under test for deadlock. The dependent variables indicate the performance of the polynomial time (Table 7.2) and all-states (Table 7.3) analyzers for a particular test program.
Reference: [BDER79] <author> G. Bristow, C. Drey, B. Edwards, and W. Riddle. </author> <title> Anomaly detection in concurrent programs. </title> <booktitle> In Proceedings of the 4th International Conference on Software Engineering, </booktitle> <pages> pages 265-273, </pages> <year> 1979. </year>
Reference-contexts: and Clarke [LC89] . : : : 349 Task clans: McDowell [McD89] . : : : : : : : : : : : : : : : : : : 350 Deadlock cycle pruning in resource graphs: Saxena [Sax77] . : : : 352 Iterative refinement: Bristow et. al. <ref> [BDER79] </ref> . : : : : : : : : : 353 Linear algebraic methods: Zhou, Yeh, and Ng [ZYN86] . : : : : : 354 10.3.2. <p> Petri net methods use Petri net [Pet81] abstractions of program behavior, possibly with modifications to the Petri net model; these are described in Section 10.3.2. Most of the flow graph methods rely on state enumeration, though two do not <ref> [Sax77, BDER79] </ref>. All the Petri-net methods we have found rely, in one way or another, on state enumeration. 346 Section 10.3.3 discusses the work of Karam and Buhr [KB90], in detecting livelock-induced starvation; strictly speaking, their work does not address infinite waits. <p> In an early work similar to our own, Saxena [Sax77] finds deadlock cycles in a graph of tasks and resource requests, and prunes spurious cycles using constraints. Although deadlock detection is not their primary goal, Bristow et. al. <ref> [BDER79] </ref> give a method of detecting some, but not all, deadlocks; more importantly, they make the first mention of iterative refinement of a "happened before" relation similar to B4 . <p> However, Saxena presents his results in terms quite specific to his shared resource 353 model, and does not give experimental results. Iterative refinement: Bristow et. al. <ref> [BDER79] </ref>. Bristow, Drey, Edwards and Riddle, in [BDER79], proposed an early use of static analysis to detect races and infinite waits in concurrent programs. Their work centered around a hypothetical language they called X, which had post-wait-clear synchronization and dynamic initiation of single process instances. <p> However, Saxena presents his results in terms quite specific to his shared resource 353 model, and does not give experimental results. Iterative refinement: Bristow et. al. <ref> [BDER79] </ref>. Bristow, Drey, Edwards and Riddle, in [BDER79], proposed an early use of static analysis to detect races and infinite waits in concurrent programs. Their work centered around a hypothetical language they called X, which had post-wait-clear synchronization and dynamic initiation of single process instances. Their emphases were on both synchronization anomalies and data races. <p> Bristow et. al. construct an interprocess precedence graph, which strongly resembles the sync graph. Both control and interprocess precedence edges (IPPEs) (i.e., sync edges) are directed. Waits could apparently be governed by negated event variables, so sync edges go from reset EV statements to wait for not EV statements. <ref> [BDER79] </ref> describes an algorithm to generate BEFORE and AFTER sets, based upon a form of analysis that resembles [CS88], but is formulated as an algorithm. In Section V.3, [BDER79] makes the first mention of iterative refinement of sync edges, and event variable killing, that we have found in the literature. <p> could apparently be governed by negated event variables, so sync edges go from reset EV statements to wait for not EV statements. <ref> [BDER79] </ref> describes an algorithm to generate BEFORE and AFTER sets, based upon a form of analysis that resembles [CS88], but is formulated as an algorithm. In Section V.3, [BDER79] makes the first mention of iterative refinement of sync edges, and event variable killing, that we have found in the literature. They delete IPPEs (m; n) when either n is before m, or a node that cancels the effects of m must always execute after m and before n. <p> They refine iteratively by deleting IPPEs until the BEFORE and AFTER solutions stabilize. Thus, Bristow et. al. probably discovered iterative refinement of both CHT and the sync graph (in our terminology), but did not apply it to refinements of CHT other than B4 . <ref> [BDER79] </ref> gives a simple heuristic for detecting infinite wait anomalies, including deadlock. <p> Of these synchronization analysis methods, only Saxena's work [Sax77] centers on safe static deadlock detection in polynomial time. However, due to the coarse "grain size" of his graph representation, we suspect that his algorithm may have accuracy problems in practice. Bristow et. al. <ref> [BDER79] </ref> proposed a method of infinite wait anomaly detection as a side issue, but it is also likely to have accuracy problems. The remainder of the infinite wait anomaly detection algorithms require exponential (or worse) time. <p> Based on experimental evidence and theoretical review, we believe that their work has problems with both accuracy and safety. Nonetheless, their research had a large influence on the evolution of our B4 analysis. Bristow et. al. <ref> [BDER79] </ref> provided perhaps the genesis of the idea of iterative refinement of CHT . <p> Exp Infinite waits; Validation and accuracy CHT perf benchmark for CHT and deadlock computation software [YT88] 10.3.1 Exp Infinite waits; Partitioning in Concurrent C CHT perf [LC89] 10.3.1 Exp Infinite waits; CHT perf [McD89] 10.3.1 Exp Infinite waits; CHT perf [Sax77] 10.3.1 Poly Deadlocks Deadlock cycle pruning; nested critical sections <ref> [BDER79] </ref> 10.3.1 Poly Infinite waits; Iterative refinement of CHT races [ZYN86] 10.3.1 Exp Deadlocks [MSS89] 10.3.2 Exp Infinite waits [CU91] 10.3.2 Exp Deadlocks; livelocks [KB90] 10.3.3 ? Livelock-induced starvation [CS88] 10.4.1 Poly CHT B4 problem formulation [DS91] 10.4.2 Poly CHT B4 problem formulation [Mer92] 10.4.3 Poly CHT [EP88] 10.4.4 Exp Races
Reference: [BK89] <author> V. Balasundaram and K. Kennedy. </author> <title> Compile-time detection of race conditions in a parallel program. </title> <booktitle> In Proceedings of 1989 International Conference on Supercomputing, </booktitle> <pages> pages 175-185, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Congruences: Mercouroff [Mer92] . : : : : : : : : : : : : : : : : : 365 10.4.4. Classification of determinacy: Emrath and Padua [EP88] . : : : : 367 10.4.5. Balasundaram and Kennedy <ref> [BK89] </ref> . : : : : : : : : : : : : : : : 369 10.5. <p> It is not clear that this can be done efficiently. 10.4.5 Balasundaram and Kennedy <ref> [BK89] </ref>. Balasundaram and Kennedy [BK89] work on detection of race conditions in programs using post-wait synchronization, as do Callahan and Subhlok [CS88]. Starting with a simple model of unconditional task execution, they progressively expand it to allow branching and loops with event arrays. <p> It is not clear that this can be done efficiently. 10.4.5 Balasundaram and Kennedy <ref> [BK89] </ref>. Balasundaram and Kennedy [BK89] work on detection of race conditions in programs using post-wait synchronization, as do Callahan and Subhlok [CS88]. Starting with a simple model of unconditional task execution, they progressively expand it to allow branching and loops with event arrays. <p> 10.3.1 Poly Infinite waits; Iterative refinement of CHT races [ZYN86] 10.3.1 Exp Deadlocks [MSS89] 10.3.2 Exp Infinite waits [CU91] 10.3.2 Exp Deadlocks; livelocks [KB90] 10.3.3 ? Livelock-induced starvation [CS88] 10.4.1 Poly CHT B4 problem formulation [DS91] 10.4.2 Poly CHT B4 problem formulation [Mer92] 10.4.3 Poly CHT [EP88] 10.4.4 Exp Races <ref> [BK89] </ref> 10.4.5 ? Races [ADWR86] 10.5.1 N/A Proofs [Dil90] 10.5.2 N/A Proofs [Apt83] 10.5.3 N/A Proofs [CES86] 10.5.4 Exp Model checking Table 10.1: Summary of related synchronization and non-concurrency analysis tech niques. 377 the accuracy of the solution.
Reference: [BK90] <author> V. Balasundaram and K. Kennedy. </author> <title> A mechanism for keeping useful information in parallel programming tools: the data access descriptor. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 9 </volume> <pages> 154-170, </pages> <year> 1990. </year>
Reference-contexts: We expect that these algorithms will be improved, in both accuracy and representational completeness, within the next few years. * Programs do not contain arrays or linked structures that refer to processes or transactions. Such structures introduce imprecision in identifying references. Array sectioning <ref> [CK88, BK90] </ref> or structure summarization [CWZ90, HN90, HHN92] would be needed to resolve array references; it is unlikely that any sectioning method would be as precise as scalar analysis. * Procedure and function calls are either inlined (if they are not recursive) or trans formed to iteration (if they are recursive).
Reference: [Bur70] <author> J. Burgess. </author> <title> Sex, </title> <booktitle> honor, and the Italian driver. Reader's Digest, </booktitle> <pages> pages 110-113, </pages> <month> September </month> <year> 1970. </year>
Reference-contexts: The "four-way Sicilian deadlock" <ref> [Bur70] </ref> . : : : : : : : : : : : : : : : : : 2 1.2. Ada code fragment corresponding to Figure 1.1 . : : : : : : : : : : : : : 3 2.1.
Reference: [Cal88] <author> D. Callahan. </author> <title> The program summary graph and flow-sensitive interproce-dural data flow analysis. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 47-56, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Also, defining u y2; y = &gt; often eliminates special cases in implementation. 36 Cross-product of heterogeneous lattice frameworks. Another possible representation for some multi-source problems uses a data flow formulation like that of <ref> [Cal88, LR92] </ref>. In these formulations, the elements of the base lattice are the members of some set. The meet operator is set union for some nodes, and set intersection for others. 7 Thus, some nodes are represented by the base lattice, while others are represented by the "inverted" base lattice. <p> Rather, the property would have to be proved for the functions on the cross-product lattice. These difficulties are obviated by the use of the heterogeneous cross-product frameworks described above. 7 Neither of <ref> [Cal88, LR92] </ref> formulate their data flow problems as lattice frameworks; this represents one method of doing so. 37 n n n n Source 1 Source 2 Source k Meet is intersection Meet is union erogeneous cross-product framework. 2.3.5 Cycle location graphs.
Reference: [CAU88] <author> J. Cheng, K. Araki, and K. Ushijima. </author> <title> Tasking communication deadlocks in concurrent Ada programs. </title> <journal> Ada Letters, </journal> <pages> pages 61-70, </pages> <month> Septenber/October </month> <year> 1988. </year>
Reference-contexts: blocking (Ex. 18). * Tasking blocking without activation waiting (Ex. 19). * Tasking blocking without acceptance waiting (Ex. 20). * Tasking blocking without dependence waiting (Ex. 21). * Tasking blocking without termination waiting (Ex. 22). * Complex tasking blocking (Ex. 23). [Che90] is an extension of Cheng, Araki and Ushijima <ref> [CAU88] </ref>, in which four types of deadlock are enumerated. [CAU88] also mentions that deadlock in a program can be dynamically detected by detecting the existence of a cycle in the TWFG of the executing program (called the "digraph" in [CAU88]). 10.3 Static nontermination anomaly detection. <p> (Ex. 19). * Tasking blocking without acceptance waiting (Ex. 20). * Tasking blocking without dependence waiting (Ex. 21). * Tasking blocking without termination waiting (Ex. 22). * Complex tasking blocking (Ex. 23). [Che90] is an extension of Cheng, Araki and Ushijima <ref> [CAU88] </ref>, in which four types of deadlock are enumerated. [CAU88] also mentions that deadlock in a program can be dynamically detected by detecting the existence of a cycle in the TWFG of the executing program (called the "digraph" in [CAU88]). 10.3 Static nontermination anomaly detection. <p> (Ex. 23). [Che90] is an extension of Cheng, Araki and Ushijima <ref> [CAU88] </ref>, in which four types of deadlock are enumerated. [CAU88] also mentions that deadlock in a program can be dynamically detected by detecting the existence of a cycle in the TWFG of the executing program (called the "digraph" in [CAU88]). 10.3 Static nontermination anomaly detection. In this section, we will describe past research in static detection of deadlocks and other infinite wait anomalies, and show how our work extends, or avoids difficulties in, that of other researchers. <p> In the introduction, he asserts, "The most important 360 conclusion is that finding a correct tasking deadlock detection method is still an open issue." He then reviews a total of four static methods [Tay83b, ZYN86, CU91, MSS89] and two dynamic methods <ref> [HL85, CAU88] </ref> of deadlock detection, dismissing each of these in turn as as "incorrect." Since most of these articles are presented in this chapter, we will not repeat the reviews here. The word "correct" does not describe what Cheng should rightly imply; "incomplete" would be a much less loaded term.
Reference: [CC77] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fix-points. </title> <booktitle> In Conference Record of the 4th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <address> Los Angeles, </address> <month> January </month> <year> 1977. </year>
Reference-contexts: Abstraction of the program state. In this section, we provide intuition on how the execution wave represents a set of abstract program states. We will not use the full formal machinery of abstract interpretation <ref> [CC77] </ref>, but rather present this explanation so that it should indicate how an abstract interpretation model might be developed. The concrete concurrency state of a program may be represented as a list of statements that are executing currently.
Reference: [CD73] <author> E. G. Coffman and P. J. Denning. </author> <title> Operating systems theory. </title> <publisher> Prentice-Hall, </publisher> <year> 1973. </year> <note> ISBN 0-13637-868-4. </note>
Reference-contexts: Coffman and Denning <ref> [CD73] </ref> . : : : : : : : : : : : : : : : : : : : 340 10.2.2. Complexity of static synchronization analysis: Taylor [Tay83a] . 341 10.2.3. <p> In this section, we discuss the literature characterizing the types and characteristics of deadlocks, the complexity of deadlock detection, and methods of resolving the problem of deadlock. 340 Concise overview. First, in Section 10.2.1 Coffman and Denning <ref> [CD73] </ref> give a general overview of the phenomenon of deadlock itself. Using their general model of deadlock, we update their classification of strategies for deadlock management to include static deadlock detection. Taylor [Tay83a] characterizes the complexity of static analysis of synchronization, including analysis of deadlock and CHT . <p> In Section 10.2.3, we discuss which of these are, and are not, covered by our Ada deadlock analysis algorithm, and the problems which must be solved to cover all the deadlock types Cheng lists. 10.2.1 Coffman and Denning <ref> [CD73] </ref>. In their text, Coffman and Denning [CD73] present a formal overview of the problem of deadlock. They address the required conditions for deadlock, and the broad categories of preventive measures. Deadlock is described in terms of a progress space, through which the program negotiates a route to its completion. <p> In Section 10.2.3, we discuss which of these are, and are not, covered by our Ada deadlock analysis algorithm, and the problems which must be solved to cover all the deadlock types Cheng lists. 10.2.1 Coffman and Denning <ref> [CD73] </ref>. In their text, Coffman and Denning [CD73] present a formal overview of the problem of deadlock. They address the required conditions for deadlock, and the broad categories of preventive measures. Deadlock is described in terms of a progress space, through which the program negotiates a route to its completion.
Reference: [CES86] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: The disadvantages of Dillon's technique also apply to Apt's: lack of full automation, tedium, the need for trained experts, the need to re-prove if the program changes, and the possibility of combinatorially complex proofs. 10.5.4 Model checking. The model checking approach <ref> [CES86] </ref> has been applied to verify properties of concurrent systems, especially protocol validation. Model checking is closely related to formal proof methods; unlike the other formal methods given here, it can be automated (but it may suffer from combinatorial explosion problems). <p> Infinite waits [CU91] 10.3.2 Exp Deadlocks; livelocks [KB90] 10.3.3 ? Livelock-induced starvation [CS88] 10.4.1 Poly CHT B4 problem formulation [DS91] 10.4.2 Poly CHT B4 problem formulation [Mer92] 10.4.3 Poly CHT [EP88] 10.4.4 Exp Races [BK89] 10.4.5 ? Races [ADWR86] 10.5.1 N/A Proofs [Dil90] 10.5.2 N/A Proofs [Apt83] 10.5.3 N/A Proofs <ref> [CES86] </ref> 10.5.4 Exp Model checking Table 10.1: Summary of related synchronization and non-concurrency analysis tech niques. 377 the accuracy of the solution.
Reference: [CGL92] <author> E. M. Clarke, O. Grumberg, and D. E. </author> <title> Long. Model checking and abstraction. </title> <booktitle> In Conference Record of the 19th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 343-354, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: Although model checking can be automated, it may be combinatorially explosive; much of the work in the field is aimed at minimizing the size of the state spaces that must be generated <ref> [BCM + 90, CGL92] </ref>. 10.6 Summary of static analysis methods. Table 10.1 is a summary of the static and formal methods for analyzing synchronization.
Reference: [Che90] <author> J. Cheng. </author> <title> A classification of tasking deadlocks. </title> <journal> Ada Letters, </journal> <pages> pages 110-127, </pages> <month> May/June </month> <year> 1990. </year>
Reference-contexts: Coffman and Denning [CD73] . : : : : : : : : : : : : : : : : : : : 340 10.2.2. Complexity of static synchronization analysis: Taylor [Tay83a] . 341 10.2.3. Classification of Ada deadlocks: Cheng <ref> [Che90] </ref> . : : : : : : : : : 343 10.3. <p> Taylor [Tay83a] characterizes the complexity of static analysis of synchronization, including analysis of deadlock and CHT . In Section 10.2.2, we relate these complexity results to our own work. Lastly, Cheng <ref> [Che90] </ref> provides a specific enumeration of types of deadlocks which may occur in Ada. <p> The conclusions we must draw are that, except in unrealistically simple programs, exact detection of synchronization anomalies may be exponentially complex in the number of synchronization statements. We should therefore investigate safe and accurate approximations. 10.2.3 Classification of Ada deadlocks: Cheng <ref> [Che90] </ref>. In [Che90], Cheng's intent is to enumerate all possible types of deadlocks which can occur in the Ada language. <p> The conclusions we must draw are that, except in unrealistically simple programs, exact detection of synchronization anomalies may be exponentially complex in the number of synchronization statements. We should therefore investigate safe and accurate approximations. 10.2.3 Classification of Ada deadlocks: Cheng <ref> [Che90] </ref>. In [Che90], Cheng's intent is to enumerate all possible types of deadlocks which can occur in the Ada language. <p> To do this, Cheng presents 22 different types of deadlock, using his task wait for graph (TWFG) as a representation of task and subprogram interaction during dynamic program execution. 2 It is useful to review here the types of deadlocks listed in <ref> [Che90] </ref>, and to cite which of these our present algorithm and methodology can detect. The TWFG has nodes of two types and edges of five types. Nodes represent tasks or subprograms. <p> It should be noted that the termination waiting edge type arises only from accept statements that are waiting on an open terminate alternative, and not from tasks which have reached 2 In [Che91], Cheng puts the number of types of deadlock at 18; nonetheless, <ref> [Che90] </ref> has 22 examples. 344 the end of their execution. Cheng defines deadlock as a circular "waits-on" relation between tasks; this is identical to our definition. He categorizes deadlocks according to the combinations of the five edge types they contain. <p> These include the following types of deadlocks: * Self acceptance waiting (Ex. 3). * Self entry calling during activation of a task (Ex. 5). * Self entry calling during execution of a task body (Ex. 7). Certain of the deadlock types listed in <ref> [Che90] </ref> cannot presently be detected by our algorithm, but we feel that, with minor extensions to our deadlock detection machinery, these could also be modeled and detected in our methodology. These include deadlocks which incorporate activation, dependence, or termination edges. <p> (Ex. 17). * Entry call and dependence and termination blocking (Ex. 18). * Tasking blocking without activation waiting (Ex. 19). * Tasking blocking without acceptance waiting (Ex. 20). * Tasking blocking without dependence waiting (Ex. 21). * Tasking blocking without termination waiting (Ex. 22). * Complex tasking blocking (Ex. 23). <ref> [Che90] </ref> is an extension of Cheng, Araki and Ushijima [CAU88], in which four types of deadlock are enumerated. [CAU88] also mentions that deadlock in a program can be dynamically detected by detecting the existence of a cycle in the TWFG of the executing program (called the "digraph" in [CAU88]). 10.3 Static <p> Cheng's criteria for correctness are, "(1) the method must be able to detect, in finite time, any tasking deadlock in any Ada program, and (2) the method does not report any nonexistent deadlock in any Ada program." Criterion (1) is with respect to all the types of deadlock enumerated in <ref> [Che90] </ref>; it seems to be a goal that is feasible in principle, but one that simply has not yet been met. On the other hand, the problem of simultaneously meeting both criteria would subsume the Turing halting problem; 4 it is simply not possible.
Reference: [Che91] <author> J. Cheng. </author> <title> A survey of tasking deadlock detection methods. </title> <journal> Ada Letters, </journal> <pages> pages 82-91, </pages> <month> January/February </month> <year> 1991. </year>
Reference-contexts: Livelock-induced starvation: Karam and Buhr [KB90] . : : : : : 359 10.3.4. Survey of Ada deadlock detection methods: Cheng <ref> [Che91] </ref> . : : 359 10.4. <p> It should be noted that the termination waiting edge type arises only from accept statements that are waiting on an open terminate alternative, and not from tasks which have reached 2 In <ref> [Che91] </ref>, Cheng puts the number of types of deadlock at 18; nonetheless, [Che90] has 22 examples. 344 the end of their execution. Cheng defines deadlock as a circular "waits-on" relation between tasks; this is identical to our definition. <p> Finally, Section 10.3.4 reviews, and refutes some assertions in, a survey of deadlock detection methods by Cheng <ref> [Che91] </ref>. 10.3.1 Flow graph methods. The methods described in this section are based on condensed flow graph representations of the program. These are graphs in which nodes represent synchronization operations (or phases of synchronization) and directed control edges represent control paths between synchronizations. <p> It would be exceedingly difficult, in our opinion, to reproduce or extend the authors' results, due to the opacity of the technical exposition. 10.3.4 Survey of Ada deadlock detection methods: Cheng <ref> [Che91] </ref>. In [Che91], Cheng surveys seven of the published methods for detection of deadlock in Ada programs; both static and dynamic methods are examined, and tested against "correctness" criteria that he invents. <p> It would be exceedingly difficult, in our opinion, to reproduce or extend the authors' results, due to the opacity of the technical exposition. 10.3.4 Survey of Ada deadlock detection methods: Cheng <ref> [Che91] </ref>. In [Che91], Cheng surveys seven of the published methods for detection of deadlock in Ada programs; both static and dynamic methods are examined, and tested against "correctness" criteria that he invents.
Reference: [Che92] <author> J. Cheng. </author> <title> The task dependence net in Ada software development. Ada Letters, </title> <booktitle> XII(4):24-35, July/August 1992. </booktitle> <pages> 401 </pages>
Reference-contexts: Abstract interpretation: Reif and Smolka [RS90] . : : : : : : : : 379 10.7.3. Data dependency graph construction: Moser [Mos90] . : : : : : : 380 10.7.4. Task dependence nets: Cheng <ref> [Che92] </ref> . : : : : : : : : : : : : : : 381 10.8. <p> However, none of the four CHT refinements listed in Chapter 5 are safe for local analyses; more work is needed in this area to identify locally safe means of propagating CHT information between tasks. 381 10.7.4 Task dependence nets: Cheng <ref> [Che92] </ref>. In [Che92], Cheng augments the standard program dependence graph (PDG) model [FOW87] to represent task interactions. <p> However, none of the four CHT refinements listed in Chapter 5 are safe for local analyses; more work is needed in this area to identify locally safe means of propagating CHT information between tasks. 381 10.7.4 Task dependence nets: Cheng <ref> [Che92] </ref>. In [Che92], Cheng augments the standard program dependence graph (PDG) model [FOW87] to represent task interactions.
Reference: [CK84] <author> K. D. Cooper and K. Kennedy. </author> <title> Efficient computation of flow insensitive in-terprocedural summary information. </title> <booktitle> In Proceedings of the ACM SIGPLAN '84 Symposium on Compiler Construction, </booktitle> <month> June </month> <year> 1984. </year>
Reference-contexts: Mask ( (S fi ONE ), where ONE is the array of all ones, and fi is the usual (Boolean) matrix product. 5 4 Boolean arrays can equivalently be viewed as functions from sets to sets; we adopt this notation system from computer graphics, and refer the reader to <ref> [CK84] </ref> as a precedent. 5 Multiplying a set by a Boolean array can equivalently be thought of as function application. 29 The Boolean matrix notation used here, and subsequently in this chapter, is described in Appendix A. 2. Tarray ( (ONE Vector fi T ) " (Mask). <p> guarantee that the program produces determinate results, we must usually also guarantee that conflicting statement instances are totally ordered, rather than just non-concurrent. 394 Appendix A Boolean matrix notation. 395 In this thesis, many formulae are given in the form of operations on Boolean matrices, somewhat after Cooper and Kennedy <ref> [CK84] </ref>. We find that this is both a succinct and precise way to explain many of the operations we perform on relations from objects to sets of objects; it is far less prone to misinterpretation than verbal explanations.
Reference: [CK88] <author> D. Callahan and K. Kennedy. </author> <title> Analysis of interprocedural side effects in a parallel programming environment. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 5 </volume> <pages> 517-550, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: We expect that these algorithms will be improved, in both accuracy and representational completeness, within the next few years. * Programs do not contain arrays or linked structures that refer to processes or transactions. Such structures introduce imprecision in identifying references. Array sectioning <ref> [CK88, BK90] </ref> or structure summarization [CWZ90, HN90, HHN92] would be needed to resolve array references; it is unlikely that any sectioning method would be as precise as scalar analysis. * Procedure and function calls are either inlined (if they are not recursive) or trans formed to iteration (if they are recursive).
Reference: [CKS90] <author> D. Callahan, K. Kennedy, , and J. Subhlok. </author> <title> Analysis of event synchronization in a parallel programming tool. </title> <booktitle> In Proceedings of the 2nd ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 21-30, </pages> <year> 1990. </year>
Reference-contexts: Non-concurrency: Callahan and Subhlok <ref> [CS88, CKS90] </ref> . : : : : 362 10.4.2. Interprocedural analysis: Duesterwald and Soffa [DS91] , [Due91] .364 10.4.3. Congruences: Mercouroff [Mer92] . : : : : : : : : : : : : : : : : : 365 10.4.4. <p> Emrath and Padua ([EP88], Section 10.4.4) outline a hierarchy of program determinacy criteria, and present a race detection algorithm. Balasundaram and Kennedy ([BK89], Section 10.4.5) analyze post-wait synchronization for non-concurrency. 10.4.1 Non-concurrency: Callahan and Subhlok <ref> [CS88, CKS90] </ref>. Callahan and Subhlok [CS88] is probably the first publication on polynomial time con-currency analysis. Their goal in doing this research is static race anomaly detection. <p> Our own experiments suggest that their SCPreserved analysis might yield only a small subset of the CHT information that could be found by concurrency state enumeration. However, we should note that finding CHT is not the primary goal of the authors. Later work <ref> [CKS90] </ref> extends their model to include loops. The extension allows identifying the SCPreserved relation between statement instances in loops. <p> To analyze the execution order of statement instances, Emrath and Padua construct an ordering graph representation of the program. Nodes represent synchronization statements; edges represent orderings between them. Control and synchronization edges are not distinguished from each other. Some edges are marked with distance vectors, similar to <ref> [CKS90] </ref>; an edge with no marking means that the corresponding distance vector is the zero vector. Conflict arcs in the ordering graph represent potential races.
Reference: [CKU91] <author> J. Cheng, Y. Kasahara, and K. Ushijima. </author> <title> A tasking deadlock detector for Ada programs. </title> <booktitle> In COMPSAC91, </booktitle> <address> Tokyo, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: Real-time systems, resource allocation, and dynamic deadlock: Shih and Stankovic [SS90] . : : : : : : : : : : : : : : : : : 385 10.8.4. Cheng, Kasahara and Ushijima <ref> [CKU91] </ref> . : : : : : : : : : : : : : 386 10.9. <p> Instead, we must detect a knot (a cycle without exiting edges). * AND-OR: Agents individually either wait on any or all of several resources to be released. The AND-OR model has been used as a framework to represent the Ada rendezvous <ref> [SS90, CKU91] </ref>. * k : Agents may specify that they wish to obtain any k resources out of a pool of n resources, where n is fixed but k may vary. This generalizes the AND-OR model. * Unrestricted: Agents wait on arbitrary combinations of resources. <p> The probe messages maintain information on the soonest timing constraint of any task in the path; this is the probe deadline. The probe deadline is maintained to eliminate false deadlock cycles in real-time systems, where tasks may time out and enable others. 10.8.4 Cheng, Kasahara and Ushijima <ref> [CKU91] </ref>. Cheng, Kasahara and Ushijima [CKU91] describe a dynamic deadlock detector for Ada, based upon the task waits-for graph (TWFG) representation of program tasking. See Section 10.2.3 for a description of the authors' version of the TWFG. <p> The probe deadline is maintained to eliminate false deadlock cycles in real-time systems, where tasks may time out and enable others. 10.8.4 Cheng, Kasahara and Ushijima <ref> [CKU91] </ref>. Cheng, Kasahara and Ushijima [CKU91] describe a dynamic deadlock detector for Ada, based upon the task waits-for graph (TWFG) representation of program tasking. See Section 10.2.3 for a description of the authors' version of the TWFG. <p> It is detailed briefly in [Kna87], from which much of the terminology of the paper is borrowed. Note that, while [HC83] is a distributed algorithm, the implementation of <ref> [CKU91] </ref> uses a centralized monitor task. Section 3 of [CKU91] describes the implementation, which is called EDEN. The authors instrument the object program to collect tasking events and pass them to the EDEN run-time monitor. <p> It is detailed briefly in [Kna87], from which much of the terminology of the paper is borrowed. Note that, while [HC83] is a distributed algorithm, the implementation of <ref> [CKU91] </ref> uses a centralized monitor task. Section 3 of [CKU91] describes the implementation, which is called EDEN. The authors instrument the object program to collect tasking events and pass them to the EDEN run-time monitor.
Reference: [CS88] <author> D. Callahan and J. Subhlok. </author> <title> Static analysis of low-level synchronization. </title> <booktitle> In Proceedings of the ACM SIGPLAN and SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 100-111, </pages> <year> 1988. </year>
Reference-contexts: Non-concurrency: Callahan and Subhlok <ref> [CS88, CKS90] </ref> . : : : : 362 10.4.2. Interprocedural analysis: Duesterwald and Soffa [DS91] , [Due91] .364 10.4.3. Congruences: Mercouroff [Mer92] . : : : : : : : : : : : : : : : : : 365 10.4.4. <p> Our non-concurrency analysis framework can incorporate, and improve upon, the results of other researchers in the field <ref> [CS88, DS91] </ref>. We show experimental evidence that non-concurrency analysis is crucial for effective deadlock detection. We also claim that non-concurrency analysis has important practical applications other than deadlock detection. <p> In such problems, edges in the program graph are partitioned naturally into classes (e.g., control and synchronization), and information propagates separately along edges of each class. The "must happen before" analyses of 9 <ref> [CS88, DS91] </ref>, are multi-source problems, which have not been formulated as lattice frameworks prior to this work; our multi-source framework formulations can also accommodate new data flow problems we introduce. * Experimental investigation and validation of deadlock detection for the Ada subset. <p> All head nodes may execute at the same time. (a) The nodes in D must represent statements whose instances can happen to gether. (b) All nodes in D are co-executable in the sense of Callahan and Subhlok <ref> [CS88] </ref>. In the presence of accept-do statements, we have new information on co-executability of the nodes in D. <p> All head nodes may execute at the same time. (a) The nodes in D must represent statements whose instances can happen to gether. (b) All nodes in D are co-executable in the sense of Callahan and Subhlok <ref> [CS88] </ref>. This implies Equation (4.7): X y2Sigs [Scope set (D; y) SigN set (D; y)] (jEj jDj): 4. <p> This form of analysis is called B4 analysis, and is closely related to the SCPreserved analysis in loopless programs performed by Callahan and Subhlok <ref> [CS88] </ref>. More recently, Duesterwald and Soffa [DS91], [Due91] formulated a before analysis of Ada-like programs; our analysis is similar to theirs in principle, although they use a different graph representation and execution model. <p> However, [DS91] represents recursion and process creation, while we require that subroutines be fully inlined and all processes created at the start of the program. While we find little or no use of recursive process creation in practice, we hope to eliminate these restrictions in future research. Lastly, while <ref> [CS88] </ref> and [DS91] presented their analyses as sets of data flow equations, we present B4 more formally here as a lattice framework, and derive its convergence time and accuracy properties based on lattice-theoretic arguments. 1 While the authors refer to selective wait, they do not provide examples of its representation. 95 <p> Table 7.7 and Figure 7.9 show that, while the B4 analysis of [DS91] (and, by implication, <ref> [CS88] </ref>) are valuable as refinements, they clearly miss a large component of non-concurrency information in most programs. <p> Waits could apparently be governed by negated event variables, so sync edges go from reset EV statements to wait for not EV statements. [BDER79] describes an algorithm to generate BEFORE and AFTER sets, based upon a form of analysis that resembles <ref> [CS88] </ref>, but is formulated as an algorithm. In Section V.3, [BDER79] makes the first mention of iterative refinement of sync edges, and event variable killing, that we have found in the literature. <p> Emrath and Padua ([EP88], Section 10.4.4) outline a hierarchy of program determinacy criteria, and present a race detection algorithm. Balasundaram and Kennedy ([BK89], Section 10.4.5) analyze post-wait synchronization for non-concurrency. 10.4.1 Non-concurrency: Callahan and Subhlok <ref> [CS88, CKS90] </ref>. Callahan and Subhlok [CS88] is probably the first publication on polynomial time con-currency analysis. Their goal in doing this research is static race anomaly detection. <p> Emrath and Padua ([EP88], Section 10.4.4) outline a hierarchy of program determinacy criteria, and present a race detection algorithm. Balasundaram and Kennedy ([BK89], Section 10.4.5) analyze post-wait synchronization for non-concurrency. 10.4.1 Non-concurrency: Callahan and Subhlok [CS88, CKS90]. Callahan and Subhlok <ref> [CS88] </ref> is probably the first publication on polynomial time con-currency analysis. Their goal in doing this research is static race anomaly detection. Working with post-wait synchronization, they formulate a set of data flow equations whose fixed point approximates a relation similar to B4 , for programs without control loops. <p> Their goal in doing this research is static race anomaly detection. Working with post-wait synchronization, they formulate a set of data flow equations whose fixed point approximates a relation similar to B4 , for programs without control loops. The iterative flow analysis equations of <ref> [CS88] </ref> are the basis of the analysis of [DS91] and our B4 analysis. Post-wait synchronization is similar to binary semaphores, but there are important differences. <p> In this way, a relation like the extended SCPreserved might be used to refine or extend CHT information. 10.4.2 Interprocedural analysis: Duesterwald and Soffa [DS91], [Due91]. Duesterwald and Soffa [DS91, Due91] propose using the technology of <ref> [CS88] </ref> directly in the analysis of Ada programs, and applying it interprocedurally. Like Callahan and Subhlok ([CS88] et. seq.), their goal is race detection. Our B4 analysis is closely related to their Before Sync analysis, described later in this section. <p> Node m 2 Before Loc (n) if there is a control path from m to n, but no control path from n to m; [DS91] derives Before Loc from sets may before and may after . In this way, [DS91] extends <ref> [CS88] </ref> to programs with loops without using distance vectors. We use the same method to initialize B4 , but compute the initial value using a lattice framework for control reachability. <p> We use the same method to initialize B4 , but compute the initial value using a lattice framework for control reachability. The next step is synchronization analysis. [DS91] applies Callahan and Subhlok's framework directly to the MIG to derive Before Sync . As with <ref> [CS88] </ref>, our multiple edge type lattice frameworks can represent their iterative equations in a more conventional format, allowing a wider range of theoretical analyses. Direct use of the algorithm of [CS88] in this application has some technical problems, though. <p> As with <ref> [CS88] </ref>, our multiple edge type lattice frameworks can represent their iterative equations in a more conventional format, allowing a wider range of theoretical analyses. Direct use of the algorithm of [CS88] in this application has some technical problems, though. Recall that the semantics of "m 2 SCPreserved (n)" are that all instances of m have completed by the time that any instance of n completes. <p> This still admits the possibility that the last instance (s) of m may co-execute with the first instance of n. Thus, direct application of the framework of <ref> [CS88] </ref> may result in Before Sync (n) for some node n containing some nodes that are not ordered with respect to n. 365 For instance, in their Table 1, node 4 is in the Before Sync set for node 10, despite the fact that node 4 must be able to happen <p> It is not clear that this can be done efficiently. 10.4.5 Balasundaram and Kennedy [BK89]. Balasundaram and Kennedy [BK89] work on detection of race conditions in programs using post-wait synchronization, as do Callahan and Subhlok <ref> [CS88] </ref>. Starting with a simple model of unconditional task execution, they progressively expand it to allow branching and loops with event arrays. In the process of doing this, they outline a non-concurrency computation that may be viewed as a somewhat primitive variant on [CS88], but which includes at least some loops. <p> post-wait synchronization, as do Callahan and Subhlok <ref> [CS88] </ref>. Starting with a simple model of unconditional task execution, they progressively expand it to allow branching and loops with event arrays. In the process of doing this, they outline a non-concurrency computation that may be viewed as a somewhat primitive variant on [CS88], but which includes at least some loops. Deadlock detection is discussed briefly. <p> Infinite waits; CHT perf [McD89] 10.3.1 Exp Infinite waits; CHT perf [Sax77] 10.3.1 Poly Deadlocks Deadlock cycle pruning; nested critical sections [BDER79] 10.3.1 Poly Infinite waits; Iterative refinement of CHT races [ZYN86] 10.3.1 Exp Deadlocks [MSS89] 10.3.2 Exp Infinite waits [CU91] 10.3.2 Exp Deadlocks; livelocks [KB90] 10.3.3 ? Livelock-induced starvation <ref> [CS88] </ref> 10.4.1 Poly CHT B4 problem formulation [DS91] 10.4.2 Poly CHT B4 problem formulation [Mer92] 10.4.3 Poly CHT [EP88] 10.4.4 Exp Races [BK89] 10.4.5 ? Races [ADWR86] 10.5.1 N/A Proofs [Dil90] 10.5.2 N/A Proofs [Apt83] 10.5.3 N/A Proofs [CES86] 10.5.4 Exp Model checking Table 10.1: Summary of related synchronization and non-concurrency <p> Callahan and Subhlok <ref> [CS88] </ref> apply this methodology to post/wait synchronization in programs without loops. 1 To guarantee that the program produces determinate results, we must usually also guarantee that conflicting statement instances are totally ordered, rather than just non-concurrent. 394 Appendix A Boolean matrix notation. 395 In this thesis, many formulae are given in
Reference: [CU91] <author> J. Cheng and K. Ushijima. </author> <title> Analyzing Ada tasking deadlocks and livelocks using extended Petri nets. </title> <booktitle> In Lecture Notes in Computer Science #499, </booktitle> <pages> pages 125-146. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: : : : : : : : : : : : : 357 xix Software tool kits. : : : : : : : : : : : : : : : : : : : : : : : : : : 357 Extended Petri nets: Cheng and Ushijima <ref> [CU91] </ref> . : : : : : : : : 358 10.3.3. Livelock-induced starvation: Karam and Buhr [KB90] . : : : : : 359 10.3.4. Survey of Ada deadlock detection methods: Cheng [Che91] . : : 359 10.4. <p> Other tools (such as reduction transformers or 358 deadlock analyzers) can be invoked from the BIDS; the intent is to provide a flexible platform from which static analysis technology of the type described in [MSS89] and [TSM90] can be studied. Extended Petri nets: Cheng and Ushijima <ref> [CU91] </ref>. Cheng and Ushijima [CU91] propose to statically detect both deadlocks and livelocks using an extended Petri net (EPN) model. In this model, transitions may be inhibited from firing if certain of their input places are marked. <p> Extended Petri nets: Cheng and Ushijima <ref> [CU91] </ref>. Cheng and Ushijima [CU91] propose to statically detect both deadlocks and livelocks using an extended Petri net (EPN) model. In this model, transitions may be inhibited from firing if certain of their input places are marked. <p> Any program with synchronization in terminating loops will exhibit both infinite wait anomalies and static livelocks using this approach. Thus, the false alarm rate for the approach of <ref> [CU91] </ref> will be unacceptably high. The method, as described in [CU91], thus cannot be used in practice. 359 10.3.3 Livelock-induced starvation: Karam and Buhr [KB90]. Karam and Buhr [KB90] use a method similar to symbolic execution to generate a set of reachable program state assertions (PSAs) for Ada programs. <p> Any program with synchronization in terminating loops will exhibit both infinite wait anomalies and static livelocks using this approach. Thus, the false alarm rate for the approach of <ref> [CU91] </ref> will be unacceptably high. The method, as described in [CU91], thus cannot be used in practice. 359 10.3.3 Livelock-induced starvation: Karam and Buhr [KB90]. Karam and Buhr [KB90] use a method similar to symbolic execution to generate a set of reachable program state assertions (PSAs) for Ada programs. <p> In the introduction, he asserts, "The most important 360 conclusion is that finding a correct tasking deadlock detection method is still an open issue." He then reviews a total of four static methods <ref> [Tay83b, ZYN86, CU91, MSS89] </ref> and two dynamic methods [HL85, CAU88] of deadlock detection, dismissing each of these in turn as as "incorrect." Since most of these articles are presented in this chapter, we will not repeat the reviews here. <p> This is especially true for large programs and programs with conditionally executed rendezvous and guarded entries. Furthermore, as Cheng himself points out in an article on his own static deadlock detection method <ref> [CU91] </ref>, "As a static analysis method, our method has the same major advantage as that [sic] other proposed static analysis methods have, i.e., the method can guarantee the absence of some tasking ... deadlocks, and the analysis result is independent of run-time environment." Thus, Cheng simultaneously denounces static deadlock detection as <p> waits; Partitioning in Concurrent C CHT perf [LC89] 10.3.1 Exp Infinite waits; CHT perf [McD89] 10.3.1 Exp Infinite waits; CHT perf [Sax77] 10.3.1 Poly Deadlocks Deadlock cycle pruning; nested critical sections [BDER79] 10.3.1 Poly Infinite waits; Iterative refinement of CHT races [ZYN86] 10.3.1 Exp Deadlocks [MSS89] 10.3.2 Exp Infinite waits <ref> [CU91] </ref> 10.3.2 Exp Deadlocks; livelocks [KB90] 10.3.3 ? Livelock-induced starvation [CS88] 10.4.1 Poly CHT B4 problem formulation [DS91] 10.4.2 Poly CHT B4 problem formulation [Mer92] 10.4.3 Poly CHT [EP88] 10.4.4 Exp Races [BK89] 10.4.5 ? Races [ADWR86] 10.5.1 N/A Proofs [Dil90] 10.5.2 N/A Proofs [Apt83] 10.5.3 N/A Proofs [CES86] 10.5.4 Exp
Reference: [CWZ90] <author> D. R. Chase, M. Wegman, and F. K. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <month> June </month> <year> 1990. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol 25, No 6. </volume>
Reference-contexts: The second reason is that some features, such as recursive process initiation, are beyond the scope of a preliminary effort. These features, though, probably could be addressed using techniques developed for the analysis of recursively defined data structures <ref> [HPR89, HN90, CWZ90, HHN92] </ref>. Of note in this area is Duesterwald and Soffa [DS91], in which the authors perform concurrency analysis in the presence of recursive activation of units, i.e., tasks or procedures. <p> We expect that these algorithms will be improved, in both accuracy and representational completeness, within the next few years. * Programs do not contain arrays or linked structures that refer to processes or transactions. Such structures introduce imprecision in identifying references. Array sectioning [CK88, BK90] or structure summarization <ref> [CWZ90, HN90, HHN92] </ref> would be needed to resolve array references; it is unlikely that any sectioning method would be as precise as scalar analysis. * Procedure and function calls are either inlined (if they are not recursive) or trans formed to iteration (if they are recursive). * Processes do not create
Reference: [Dij68] <author> E. W. Dijkstra. </author> <title> Co-operating sequential processes. </title> <editor> In F. Genuys, editor, </editor> <booktitle> Programming Languages; NATO Advanced Study Institute, </booktitle> <pages> pages 43-112. </pages> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1968. </year>
Reference-contexts: Wampler [TLK92, Wam85] shows that jTasksj jTasksj 2 is an accurate predictor of the number of reachable states of a program, for the "dining philosophers" problem <ref> [Dij68] </ref>. By implication, Taylor et. al., in [TLK92], assume that Wampler's hypothesis applies to a wider set of programs. This assumption is reasonable if all tasks have the same number of nodes, and if nodes appear on the execution wave independently of the other nodes on the wave. <p> Binary semaphores can be conveniently used both for mutual exclusion of access to shared resources and for event notification between tasks. Integer semaphores. Binary semaphores are a specialization of integer semaphores <ref> [Dij68] </ref>. Given this, static deadlock detection will likely be at least as difficult in programs using integer semaphores as it is in programs using binary semaphores. 8.2 Modeling binary semaphore synchronization for deadlock detec tion. We must begin by explaining the program model we intend to use.
Reference: [Dil90] <author> L. K Dillon. </author> <title> Verifying general safety properties of Ada tasking programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 51-63, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Constrained regular expressions: Avrunin, Dillon, Wileden, and Riddle [ADWR86]. : : : : : : : : : : : : : : : : : : : : : : 371 10.5.2. Isolation-based proofs: Dillon <ref> [Dil90] </ref>. : : : : : : : : : : : : : : : 372 10.5.3. Optimizing the proof process: Apt [Apt83] . : : : : : : : : : : : : 373 10.5.4. <p> The authors propose a software tool set to aid in making the proofs. 10.5.2 Isolation-based proofs: Dillon <ref> [Dil90] </ref>. Dillon [Dil90] proposes a methodology for formally proving safety properties, including freedom from deadlock, for Ada programs. <p> The authors propose a software tool set to aid in making the proofs. 10.5.2 Isolation-based proofs: Dillon <ref> [Dil90] </ref>. Dillon [Dil90] proposes a methodology for formally proving safety properties, including freedom from deadlock, for Ada programs. <p> In [Apt83], Apt proposes a formal proof technique for freedom from infinite waits (which he calls deadlocks). Apt's technique is related to both <ref> [Dil90] </ref> and [ADWR86]; proof of freedom from infinite wait depends upon enumerating the blocked configurations (infinite 374 wait states) of the program. <p> races [ZYN86] 10.3.1 Exp Deadlocks [MSS89] 10.3.2 Exp Infinite waits [CU91] 10.3.2 Exp Deadlocks; livelocks [KB90] 10.3.3 ? Livelock-induced starvation [CS88] 10.4.1 Poly CHT B4 problem formulation [DS91] 10.4.2 Poly CHT B4 problem formulation [Mer92] 10.4.3 Poly CHT [EP88] 10.4.4 Exp Races [BK89] 10.4.5 ? Races [ADWR86] 10.5.1 N/A Proofs <ref> [Dil90] </ref> 10.5.2 N/A Proofs [Apt83] 10.5.3 N/A Proofs [CES86] 10.5.4 Exp Model checking Table 10.1: Summary of related synchronization and non-concurrency analysis tech niques. 377 the accuracy of the solution.
Reference: [DS91] <author> E. Duesterwald and M. L. Soffa. </author> <title> Concurrency analysis in the presence of procedures using a data flow framework. </title> <booktitle> In Proceedings of the ACM SIGSOFT '91 Fourth Symposium on Testing, Analysis, and Verification (TAV4), </booktitle> <pages> pages 36-48, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Overall accuracy. : : : : : : : : : : : : : : : : : : : : : : : : : : : 208 Comparison with <ref> [DS91] </ref> . : : : : : : : : : : : : : : : : : : : : : : 210 7.8.3. Contributions of the refinements of CHT . : : : : : : : : : : : : : 210 7.8.4. <p> Non-concurrency: Callahan and Subhlok [CS88, CKS90] . : : : : 362 10.4.2. Interprocedural analysis: Duesterwald and Soffa <ref> [DS91] </ref> , [Due91] .364 10.4.3. Congruences: Mercouroff [Mer92] . : : : : : : : : : : : : : : : : : 365 10.4.4. Classification of determinacy: Emrath and Padua [EP88] . : : : : 367 10.4.5. <p> Our non-concurrency analysis framework can incorporate, and improve upon, the results of other researchers in the field <ref> [CS88, DS91] </ref>. We show experimental evidence that non-concurrency analysis is crucial for effective deadlock detection. We also claim that non-concurrency analysis has important practical applications other than deadlock detection. <p> In such problems, edges in the program graph are partitioned naturally into classes (e.g., control and synchronization), and information propagates separately along edges of each class. The "must happen before" analyses of 9 <ref> [CS88, DS91] </ref>, are multi-source problems, which have not been formulated as lattice frameworks prior to this work; our multi-source framework formulations can also accommodate new data flow problems we introduce. * Experimental investigation and validation of deadlock detection for the Ada subset. <p> This form of analysis is called B4 analysis, and is closely related to the SCPreserved analysis in loopless programs performed by Callahan and Subhlok [CS88]. More recently, Duesterwald and Soffa <ref> [DS91] </ref>, [Due91] formulated a before analysis of Ada-like programs; our analysis is similar to theirs in principle, although they use a different graph representation and execution model. Our sync hypergraphs extend their representation by including the accept-do construct, selective wait, and conditional entry calls 1 . <p> Our sync hypergraphs extend their representation by including the accept-do construct, selective wait, and conditional entry calls 1 . Though [Due91] proposes to eliminate spurious sync edges using their ordering relation, they do not mention doing so iteratively, or in combination with other refinements. However, <ref> [DS91] </ref> represents recursion and process creation, while we require that subroutines be fully inlined and all processes created at the start of the program. While we find little or no use of recursive process creation in practice, we hope to eliminate these restrictions in future research. Lastly, while [CS88] and [DS91] <p> <ref> [DS91] </ref> represents recursion and process creation, while we require that subroutines be fully inlined and all processes created at the start of the program. While we find little or no use of recursive process creation in practice, we hope to eliminate these restrictions in future research. Lastly, while [CS88] and [DS91] presented their analyses as sets of data flow equations, we present B4 more formally here as a lattice framework, and derive its convergence time and accuracy properties based on lattice-theoretic arguments. 1 While the authors refer to selective wait, they do not provide examples of its representation. 95 B4 lattice <p> o oooo o o o oooo o ooo oo o o o o o o o o o o o o o oo o o o o o log-log for clarity. 0 20 40 60 80 100 20 60 % of perfect CHT No. of programs ratio. 210 Comparison with <ref> [DS91] </ref>. Table 7.7 and Figure 7.9 show that, while the B4 analysis of [DS91] (and, by implication, [CS88]) are valuable as refinements, they clearly miss a large component of non-concurrency information in most programs. <p> o o o o o o o o o oo o o o o o log-log for clarity. 0 20 40 60 80 100 20 60 % of perfect CHT No. of programs ratio. 210 Comparison with <ref> [DS91] </ref>. Table 7.7 and Figure 7.9 show that, while the B4 analysis of [DS91] (and, by implication, [CS88]) are valuable as refinements, they clearly miss a large component of non-concurrency information in most programs. <p> These features, though, probably could be addressed using techniques developed for the analysis of recursively defined data structures [HPR89, HN90, CWZ90, HHN92]. Of note in this area is Duesterwald and Soffa <ref> [DS91] </ref>, in which the authors perform concurrency analysis in the presence of recursive activation of units, i.e., tasks or procedures. <p> Their work is translated to rendezvous synchronization by Duesterwald and Soffa (<ref> [DS91] </ref>, Section 10.4.2), who also extend it to interprocedural non-concurrency analysis. While [DS91] has technical flaws, it suggested the method we use for our B4 analysis. Mercouroff ([Mer92], Section 10.4.3) proposes the use of a lattice framework of arithmetical congruences for intertask non-concurrency analysis. <p> Working with post-wait synchronization, they formulate a set of data flow equations whose fixed point approximates a relation similar to B4 , for programs without control loops. The iterative flow analysis equations of [CS88] are the basis of the analysis of <ref> [DS91] </ref> and our B4 analysis. Post-wait synchronization is similar to binary semaphores, but there are important differences. <p> In this way, a relation like the extended SCPreserved might be used to refine or extend CHT information. 10.4.2 Interprocedural analysis: Duesterwald and Soffa <ref> [DS91] </ref>, [Due91]. Duesterwald and Soffa [DS91, Due91] propose using the technology of [CS88] directly in the analysis of Ada programs, and applying it interprocedurally. Like Callahan and Subhlok ([CS88] et. seq.), their goal is race detection. <p> In this way, a relation like the extended SCPreserved might be used to refine or extend CHT information. 10.4.2 Interprocedural analysis: Duesterwald and Soffa [DS91], [Due91]. Duesterwald and Soffa <ref> [DS91, Due91] </ref> propose using the technology of [CS88] directly in the analysis of Ada programs, and applying it interprocedurally. Like Callahan and Subhlok ([CS88] et. seq.), their goal is race detection. Our B4 analysis is closely related to their Before Sync analysis, described later in this section. <p> Using the MIG, Duesterwald and Soffa first perform local control flow analysis; this derives the relation Before Loc . Node m 2 Before Loc (n) if there is a control path from m to n, but no control path from n to m; <ref> [DS91] </ref> derives Before Loc from sets may before and may after . In this way, [DS91] extends [CS88] to programs with loops without using distance vectors. We use the same method to initialize B4 , but compute the initial value using a lattice framework for control reachability. <p> Node m 2 Before Loc (n) if there is a control path from m to n, but no control path from n to m; <ref> [DS91] </ref> derives Before Loc from sets may before and may after . In this way, [DS91] extends [CS88] to programs with loops without using distance vectors. We use the same method to initialize B4 , but compute the initial value using a lattice framework for control reachability. The next step is synchronization analysis. [DS91] applies Callahan and Subhlok's framework directly to the MIG to derive Before <p> In this way, <ref> [DS91] </ref> extends [CS88] to programs with loops without using distance vectors. We use the same method to initialize B4 , but compute the initial value using a lattice framework for control reachability. The next step is synchronization analysis. [DS91] applies Callahan and Subhlok's framework directly to the MIG to derive Before Sync . As with [CS88], our multiple edge type lattice frameworks can represent their iterative equations in a more conventional format, allowing a wider range of theoretical analyses. <p> The recurrence is used to propagate Ord information from activation sites to the units they activate. The authors claim that this process can be made to work even in the presence of recursion [Due91]. While <ref> [DS91] </ref> does not discuss iterative refinement of the Ord relation, it mentions the possibility of increasing precision by removing spurious sync edges. [Due91] mentions using the Ord relation itself to find spurious sync edges. 10.4.3 Congruences: Mercouroff [Mer92]. Mercouroff [Mer92] describes a non-concurrency analysis using a novel lattice framework. <p> Many of the other state enumeration methods could also be used for this purpose. Of the methods for non-concurrency analysis, probably that of Duesterwald and Soffa <ref> [DS91] </ref> is most closely related. Based on experimental evidence and theoretical review, we believe that their work has problems with both accuracy and safety. Nonetheless, their research had a large influence on the evolution of our B4 analysis. <p> Infinite waits; CHT perf [Sax77] 10.3.1 Poly Deadlocks Deadlock cycle pruning; nested critical sections [BDER79] 10.3.1 Poly Infinite waits; Iterative refinement of CHT races [ZYN86] 10.3.1 Exp Deadlocks [MSS89] 10.3.2 Exp Infinite waits [CU91] 10.3.2 Exp Deadlocks; livelocks [KB90] 10.3.3 ? Livelock-induced starvation [CS88] 10.4.1 Poly CHT B4 problem formulation <ref> [DS91] </ref> 10.4.2 Poly CHT B4 problem formulation [Mer92] 10.4.3 Poly CHT [EP88] 10.4.4 Exp Races [BK89] 10.4.5 ? Races [ADWR86] 10.5.1 N/A Proofs [Dil90] 10.5.2 N/A Proofs [Apt83] 10.5.3 N/A Proofs [CES86] 10.5.4 Exp Model checking Table 10.1: Summary of related synchronization and non-concurrency analysis tech niques. 377 the accuracy of
Reference: [Due91] <author> E. Duesterwald. </author> <title> Static concurrency analysis in the presence of procedures. </title> <type> Technical Report 91-6, </type> <institution> Department of Computer Science, University of Pittsburgh, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: Non-concurrency: Callahan and Subhlok [CS88, CKS90] . : : : : 362 10.4.2. Interprocedural analysis: Duesterwald and Soffa [DS91] , <ref> [Due91] </ref> .364 10.4.3. Congruences: Mercouroff [Mer92] . : : : : : : : : : : : : : : : : : 365 10.4.4. Classification of determinacy: Emrath and Padua [EP88] . : : : : 367 10.4.5. <p> This form of analysis is called B4 analysis, and is closely related to the SCPreserved analysis in loopless programs performed by Callahan and Subhlok [CS88]. More recently, Duesterwald and Soffa [DS91], <ref> [Due91] </ref> formulated a before analysis of Ada-like programs; our analysis is similar to theirs in principle, although they use a different graph representation and execution model. Our sync hypergraphs extend their representation by including the accept-do construct, selective wait, and conditional entry calls 1 . Though [Due91] proposes to eliminate spurious <p> Duesterwald and Soffa [DS91], <ref> [Due91] </ref> formulated a before analysis of Ada-like programs; our analysis is similar to theirs in principle, although they use a different graph representation and execution model. Our sync hypergraphs extend their representation by including the accept-do construct, selective wait, and conditional entry calls 1 . Though [Due91] proposes to eliminate spurious sync edges using their ordering relation, they do not mention doing so iteratively, or in combination with other refinements. However, [DS91] represents recursion and process creation, while we require that subroutines be fully inlined and all processes created at the start of the program. <p> In this way, a relation like the extended SCPreserved might be used to refine or extend CHT information. 10.4.2 Interprocedural analysis: Duesterwald and Soffa [DS91], <ref> [Due91] </ref>. Duesterwald and Soffa [DS91, Due91] propose using the technology of [CS88] directly in the analysis of Ada programs, and applying it interprocedurally. Like Callahan and Subhlok ([CS88] et. seq.), their goal is race detection. <p> In this way, a relation like the extended SCPreserved might be used to refine or extend CHT information. 10.4.2 Interprocedural analysis: Duesterwald and Soffa [DS91], [Due91]. Duesterwald and Soffa <ref> [DS91, Due91] </ref> propose using the technology of [CS88] directly in the analysis of Ada programs, and applying it interprocedurally. Like Callahan and Subhlok ([CS88] et. seq.), their goal is race detection. Our B4 analysis is closely related to their Before Sync analysis, described later in this section. <p> The recurrence is used to propagate Ord information from activation sites to the units they activate. The authors claim that this process can be made to work even in the presence of recursion <ref> [Due91] </ref>. While [DS91] does not discuss iterative refinement of the Ord relation, it mentions the possibility of increasing precision by removing spurious sync edges. [Due91] mentions using the Ord relation itself to find spurious sync edges. 10.4.3 Congruences: Mercouroff [Mer92]. <p> The authors claim that this process can be made to work even in the presence of recursion <ref> [Due91] </ref>. While [DS91] does not discuss iterative refinement of the Ord relation, it mentions the possibility of increasing precision by removing spurious sync edges. [Due91] mentions using the Ord relation itself to find spurious sync edges. 10.4.3 Congruences: Mercouroff [Mer92]. Mercouroff [Mer92] describes a non-concurrency analysis using a novel lattice framework. The analysis works for channel-based communications (as in CSP).
Reference: [EGP89] <author> P. A. Emrath, S. Ghosh, and D. A. Padua. </author> <title> Event synchronization analysis for debugging parallel programs. </title> <booktitle> In Proceedings of Supercomputing '89, </booktitle> <month> November </month> <year> 1989. </year> <note> ISBN 0-89791-341-8. </note>
Reference-contexts: The authors' aims include both static and dynamic race detection; their work on dynamic races is continued in <ref> [EGP89] </ref>. The authors' categorization of programs, according to their determinacy for a given input, is: * Determinate. The program produces the same output for a given input. Internally determinate. The program has the same trace for a given input. Externally determinate. <p> In the former, the static tool can infer that there will be a race at run-time; in the latter, there might be a false alarm. If possible races are detected, the authors propose to instrument the program and detect races at run time <ref> [EGP89] </ref>. Our CHT analysis can, likewise, sometimes infer the possibility of a definite infinite wait or unreachable code anomaly, when some node n is in CHT (n). All other anomalies must be considered possible.
Reference: [EP88] <author> P. A. Emrath and D. A. Padua. </author> <title> Automatic detection of nondeterminacy in parallel programs. </title> <booktitle> In Proceedings of the ACM SIGPLAN and SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 89-141, </pages> <year> 1988. </year> <month> 402 </month>
Reference-contexts: Interprocedural analysis: Duesterwald and Soffa [DS91] , [Due91] .364 10.4.3. Congruences: Mercouroff [Mer92] . : : : : : : : : : : : : : : : : : 365 10.4.4. Classification of determinacy: Emrath and Padua <ref> [EP88] </ref> . : : : : 367 10.4.5. Balasundaram and Kennedy [BK89] . : : : : : : : : : : : : : : : 369 10.5. <p> A demonstration analyzer, based on Mercouroff's methodology, is available for the with a congruence. 367 Macintosh (tm) computer. 10.4.4 Classification of determinacy: Emrath and Padua <ref> [EP88] </ref>. In 1988, Emrath and Padua [EP88] discussed a method of race detection in Cedar Fortran [GPHL90] programs, and gave a classification of the types of nondeterminacy which could appear in the program. <p> A demonstration analyzer, based on Mercouroff's methodology, is available for the with a congruence. 367 Macintosh (tm) computer. 10.4.4 Classification of determinacy: Emrath and Padua <ref> [EP88] </ref>. In 1988, Emrath and Padua [EP88] discussed a method of race detection in Cedar Fortran [GPHL90] programs, and gave a classification of the types of nondeterminacy which could appear in the program. The authors' aims include both static and dynamic race detection; their work on dynamic races is continued in [EGP89]. <p> If such a path is found, then no race exists between m and n. The authors do not detail an efficient methodology for testing whether such a path exists. In some cases, the race-detection methodology of <ref> [EP88] </ref> might be applied to estimate CHT ; we could establish that m 2 CHT (n) by establishing that there is a path of ordering arcs of length ffi from m to n, and one of length ~ ffi + (0; :::; 0; 1; 0; :::; 0) from 369 n to <p> nested critical sections [BDER79] 10.3.1 Poly Infinite waits; Iterative refinement of CHT races [ZYN86] 10.3.1 Exp Deadlocks [MSS89] 10.3.2 Exp Infinite waits [CU91] 10.3.2 Exp Deadlocks; livelocks [KB90] 10.3.3 ? Livelock-induced starvation [CS88] 10.4.1 Poly CHT B4 problem formulation [DS91] 10.4.2 Poly CHT B4 problem formulation [Mer92] 10.4.3 Poly CHT <ref> [EP88] </ref> 10.4.4 Exp Races [BK89] 10.4.5 ? Races [ADWR86] 10.5.1 N/A Proofs [Dil90] 10.5.2 N/A Proofs [Apt83] 10.5.3 N/A Proofs [CES86] 10.5.4 Exp Model checking Table 10.1: Summary of related synchronization and non-concurrency analysis tech niques. 377 the accuracy of the solution.
Reference: [FOW87] <author> J. Ferrante, K. J. Ottenstein, and J. D. Warren. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 319-349, </pages> <year> 1987. </year>
Reference-contexts: In [Che92], Cheng augments the standard program dependence graph (PDG) model <ref> [FOW87] </ref> to represent task interactions.
Reference: [FW74] <author> G. M. Furnival and Jr. Wilson, R. W. </author> <title> Regressions by leaps and bounds. </title> <journal> Technometrics, </journal> <volume> 16(4) </volume> <pages> 499-511, </pages> <month> November </month> <year> 1974. </year>
Reference-contexts: To find this, we use the leaps function, which finds the best regression of any subset of the independent variables by leaps and bounds <ref> [FW74] </ref>.
Reference: [GNV88] <author> E. R. Gansner, S. C. North, , and K. P. Vo. </author> <title> DAG | a program that draws directed graphs. </title> <journal> Software | Practice and Experience, </journal> <volume> 18(11) </volume> <pages> 1047-1062, </pages> <month> November </month> <year> 1988. </year>
Reference-contexts: Sync graphs and source listings of the program can also be output as alphanumerics, under command line control separate from the detail level control. Finally, ggen can produce a representation of the sync graph which can be interpreted by the DAG program <ref> [GNV88] </ref>. Thus, the user can view sync graphs in their most natural graphical form. 191 7.2.4 Source files. The ggen program is built from the following source files: * ggen.c. The control program and command line interpreter. * ggen.h. Header file for ggen.c, defining global variables and symbols. * ada.y.
Reference: [GPHL90] <author> M. D. Guzzi, D. A. Padua, J. Hoeflinger, and D. H. Lawrie. </author> <title> Cedar Fortran and other vector and parallel Fortran dialects. </title> <journal> Journal of Supercomputing, </journal> <volume> 4(1) </volume> <pages> 37-62, </pages> <year> 1990. </year>
Reference-contexts: A demonstration analyzer, based on Mercouroff's methodology, is available for the with a congruence. 367 Macintosh (tm) computer. 10.4.4 Classification of determinacy: Emrath and Padua [EP88]. In 1988, Emrath and Padua [EP88] discussed a method of race detection in Cedar Fortran <ref> [GPHL90] </ref> programs, and gave a classification of the types of nondeterminacy which could appear in the program. The authors' aims include both static and dynamic race detection; their work on dynamic races is continued in [EGP89].
Reference: [GR86] <author> N. H. Gehani and W. D. Roome. </author> <title> Concurrent C. </title> <journal> Software Practice and Experience, </journal> <volume> 16(9) </volume> <pages> 821-844, </pages> <month> September </month> <year> 1986. </year>
Reference: [GR88] <author> N. H. Gehani and W. D. Roome. </author> <title> Rendezvous facilities: Concurrent C and the Ada programming language. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(11) </volume> <pages> 1546-1553, </pages> <month> November </month> <year> 1988. </year>
Reference: [Gra91] <author> P. Granger. </author> <title> Static analysis of linear congruence equalities among variables of a program. </title> <booktitle> In Lecture Notes in Computer Science #493, </booktitle> <pages> pages 169-192. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: This approxima tion allows him to eliminate spurious sync edges in some cases. A perfectly accurate representation of this information would be a subset of N , but this is obviously incomputable. The representation Mercouroff uses is the lattice of arithmetical congruences <ref> [Gra91] </ref> bound by a finite set 5 . Elements of this lattice are ;, 5 This term is somewhat of a misnomer, since Mercouroff's approximation is the union of a finite set 366 Z, or sets [ (c; m). <p> The author claims that his lattice framework converges in polynomial time, presumably in the size of the source program; it should also be noted that there is a factor of log (m) in the time bound <ref> [Gra91] </ref>. To find the number of synchronizations that may occur before and after each program point in a terminating program, both forward and backward analyses are conducted.
Reference: [Hab69] <author> A. N. Habermann. </author> <title> Prevention of system deadlock. </title> <journal> Communications of the ACM, </journal> <volume> 12(7) </volume> <pages> 373-377, </pages> <month> July </month> <year> 1969. </year>
Reference-contexts: As with prevention, recovery remains a problem. * Avoidance of the unsafe region, using scheduling methods that steer the progress path away from the unsafe space. Habermann <ref> [Hab69] </ref> proposed such avoidance methods. However, the unsafe space may sometimes not be avoidable; if it cannot be avoided, then the program must deadlock. None of these methods quite expresses what static deadlock detection attempts to do.
Reference: [HC83] <author> T. Hermann and K. M. Chandy. </author> <title> A distributed procedure to detect AND-OR deadlock. </title> <type> Technical Report TR LCS-8301, </type> <institution> Department of Computer Science, University of Texas, Austin, Texas, </institution> <year> 1983. </year>
Reference-contexts: The authors give an algorithm to detect deadlock. It operates by updating the TWFG dynamically as the program executes, and calling another algorithm upon appropriate updates to actually detect the deadlock cycle. The authors do not present a 387 deadlock cycle detection algorithm; rather, Hermann and Chandy's algorithm <ref> [HC83] </ref> is suggested for this purpose. It is detailed briefly in [Kna87], from which much of the terminology of the paper is borrowed. Note that, while [HC83] is a distributed algorithm, the implementation of [CKU91] uses a centralized monitor task. <p> The authors do not present a 387 deadlock cycle detection algorithm; rather, Hermann and Chandy's algorithm <ref> [HC83] </ref> is suggested for this purpose. It is detailed briefly in [Kna87], from which much of the terminology of the paper is borrowed. Note that, while [HC83] is a distributed algorithm, the implementation of [CKU91] uses a centralized monitor task. Section 3 of [CKU91] describes the implementation, which is called EDEN. The authors instrument the object program to collect tasking events and pass them to the EDEN run-time monitor.
Reference: [Hec77] <author> M. S. Hecht. </author> <title> Flow analysis of computer programs. </title> <publisher> Elsevier North-Holland, </publisher> <address> New York, </address> <year> 1977. </year> <note> ISBN 0-444-00210-3. </note>
Reference-contexts: Dynamic testing is therefore unsafe; programs are judged either "probably all 5 right" or "definitely incorrect." We feel that this is inadequate for critical applications; programs must be proved free of the tested anomalies. Static analysis. We must therefore use some method of static analysis <ref> [Hec77] </ref>, or formal proofs of correctness, to guarantee safety. Static analysis finds specific properties of the program which are true in all possible executions; it thus has the unique ability to prove that an arbitrary program is free from deadlock. <p> The sync graph model of a particular program is a triple (N; E C ; E S ). N is the set of nodes of the graph. Each node is akin to a basic block <ref> [Hec77] </ref>, ending with a synchronization statement or tasking event rather than a branch. Node n s represents all instances of the synchronization statement s, and all instances of non-synchronization statements or tasking events on paths ending at s that do not include other synchro nization. <p> Our experimental work has found ineffective summary information in this way (Section 7.9). 42 Chapter 3 Lattice frameworks and properties. 43 3.1 Lattice frameworks and properties for deadlock detection. A lattice framework <ref> [Hec77] </ref> is a quadruple D = (G; L; F; M ) where G = (N; E) is a graph, L is a lattice, F is a set of monotone functions L ! L such that F is closed under meet and composition, and M is a mapping function E ! F <p> Lemma 12 If a lattice L has a finite height h, and is used in a monotone data flow framework D = (G; L; F; M ) where G = (N; E), then the worklist iterative algorithm <ref> [Hec77] </ref> applied to D where each node in N has an initial value of ? terminates after no more than hjN j 2 dlog 2 (jN j)e meet operations and hjN j 2 edge function evaluations in the worst case.
Reference: [HHN92] <author> L. J. Hendren, J. Hummel, , and A. Nicolau. </author> <title> Abstractions for recursive pointer structures: improving the analysis and transformation of imperative programs. </title> <booktitle> In Proceedings of the SIGPLAN '92 Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 249-260, </pages> <address> San Francisco, </address> <month> June </month> <year> 1992. </year> <note> ISBN 0-89791-475-9. </note>
Reference-contexts: The second reason is that some features, such as recursive process initiation, are beyond the scope of a preliminary effort. These features, though, probably could be addressed using techniques developed for the analysis of recursively defined data structures <ref> [HPR89, HN90, CWZ90, HHN92] </ref>. Of note in this area is Duesterwald and Soffa [DS91], in which the authors perform concurrency analysis in the presence of recursive activation of units, i.e., tasks or procedures. <p> We expect that these algorithms will be improved, in both accuracy and representational completeness, within the next few years. * Programs do not contain arrays or linked structures that refer to processes or transactions. Such structures introduce imprecision in identifying references. Array sectioning [CK88, BK90] or structure summarization <ref> [CWZ90, HN90, HHN92] </ref> would be needed to resolve array references; it is unlikely that any sectioning method would be as precise as scalar analysis. * Procedure and function calls are either inlined (if they are not recursive) or trans formed to iteration (if they are recursive). * Processes do not create
Reference: [HL85] <author> D. Helmbold and D. Luckham. </author> <title> Debugging Ada tasking programs. </title> <journal> IEEE Software, </journal> <pages> pages 47-57, </pages> <month> March </month> <year> 1985. </year>
Reference-contexts: Survey of dynamic deadlock detection: Knapp [Kna87] . : : : : : 382 xx 10.8.2. Deadlock and interactive debugging: Helmbold and Luckham <ref> [HL85] </ref> . : : : : : : : : : : : : : : : : : : : : : : : : : : : : 384 10.8.3. <p> In the introduction, he asserts, "The most important 360 conclusion is that finding a correct tasking deadlock detection method is still an open issue." He then reviews a total of four static methods [Tay83b, ZYN86, CU91, MSS89] and two dynamic methods <ref> [HL85, CAU88] </ref> of deadlock detection, dismissing each of these in turn as as "incorrect." Since most of these articles are presented in this chapter, we will not repeat the reviews here. The word "correct" does not describe what Cheng should rightly imply; "incomplete" would be a much less loaded term. <p> than expected," and advises, "it is ... advisable | in order to avoid unnecessary complexity | to choose the least general technique that is still general enough to solve the problem at hand." Our experiences have borne out both of these assertions. 10.8.2 Deadlock and interactive debugging: Helmbold and Luckham <ref> [HL85] </ref>. Helmbold and Luckham [HL85] describe a debugger with facilities for dealing with "deadness errors" in Ada programs. A program to be monitored is instrumented with 385 calls to a monitor task; the monitor task keeps track of the state of each task, and may be queried by a user. <p> "it is ... advisable | in order to avoid unnecessary complexity | to choose the least general technique that is still general enough to solve the problem at hand." Our experiences have borne out both of these assertions. 10.8.2 Deadlock and interactive debugging: Helmbold and Luckham <ref> [HL85] </ref>. Helmbold and Luckham [HL85] describe a debugger with facilities for dealing with "deadness errors" in Ada programs. A program to be monitored is instrumented with 385 calls to a monitor task; the monitor task keeps track of the state of each task, and may be queried by a user.
Reference: [HN90] <author> L. J. Hendren and A. Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 105-133, </pages> <year> 1990. </year>
Reference-contexts: The second reason is that some features, such as recursive process initiation, are beyond the scope of a preliminary effort. These features, though, probably could be addressed using techniques developed for the analysis of recursively defined data structures <ref> [HPR89, HN90, CWZ90, HHN92] </ref>. Of note in this area is Duesterwald and Soffa [DS91], in which the authors perform concurrency analysis in the presence of recursive activation of units, i.e., tasks or procedures. <p> We expect that these algorithms will be improved, in both accuracy and representational completeness, within the next few years. * Programs do not contain arrays or linked structures that refer to processes or transactions. Such structures introduce imprecision in identifying references. Array sectioning [CK88, BK90] or structure summarization <ref> [CWZ90, HN90, HHN92] </ref> would be needed to resolve array references; it is unlikely that any sectioning method would be as precise as scalar analysis. * Procedure and function calls are either inlined (if they are not recursive) or trans formed to iteration (if they are recursive). * Processes do not create
Reference: [Hol72] <author> R. C. Holt. </author> <title> Some deadlock properties on computer systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 4(3) </volume> <pages> 179-196, </pages> <month> September </month> <year> 1972. </year> <month> 403 </month>
Reference-contexts: Nodes represent resources; a directed edge (r i ; r j ) is drawn if any process holding resource r i requests r j . Note the resemblance between the resource graph and the general resource graph of <ref> [Hol72] </ref>. A program can deadlock only if its resource graph has a cycle. Even if the resource graph does have a cycle, it may sometimes be possible to prove that the program will not deadlock. <p> Thus, deadlock can occur when some agents are mutually waiting on each other to release 383 resources. The relations of transaction agents waiting on each other are described by their waits-for graph (WFG). The WFG is somewhat akin to the general resource graph structure described by Holt <ref> [Hol72] </ref>. Nodes in the WFG represent agents; a directed edge (m; n) exists if m is blocked and is waiting on a resource held by n. <p> It is the authors' goal to avoid reporting temporal deadlocks, as long as they do not cause any task to miss a deadline. A third class of potential problems is non-deadlocked blocking, which includes livelocks, starvation ("orphan tasks," in the authors' terminology), and normal blocking conditions. Following <ref> [Hol72] </ref>, Shih and Stankovic represent dynamic Ada task activity using a general resource graph (GRG). The GRG is a generalization of the task waits-for graph (TWFG).
Reference: [HPR89] <author> S. Horwitz, P. Pfeiffer, and T. Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> In Proceedings of the SIGPLAN '89 Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 28-40, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: The second reason is that some features, such as recursive process initiation, are beyond the scope of a preliminary effort. These features, though, probably could be addressed using techniques developed for the analysis of recursively defined data structures <ref> [HPR89, HN90, CWZ90, HHN92] </ref>. Of note in this area is Duesterwald and Soffa [DS91], in which the authors perform concurrency analysis in the presence of recursive activation of units, i.e., tasks or procedures.
Reference: [HY82] <author> K. Hao and Y. T. Yeh. </author> <title> Detection of inherent deadlocks in distributed programs. </title> <booktitle> In Proceedings of IEEE International Conference on Distributed Computing Systems, </booktitle> <pages> pages 518-523, </pages> <address> Florida, </address> <month> October </month> <year> 1982. </year>
Reference-contexts: The stages are: (1) a source-level transformation, (2) comparing the number of accept statements and entry calls for each signal, and (3) "virtual execution" of the program. This paper essentially extends the work of Hao and Yeh <ref> [HY82] </ref> from CSP to Ada. The source-level transformation produces a condensed version of the program's source code, reduced to synchronization statements and with procedures inlined. 3 Transformation 6 is unsafe, since it changes the control flow of the program by eliminating goto and exit statements.
Reference: [Job91] <author> J. D. Jobson. </author> <title> Applied multivariate data analysis, volume 1: regression and experimental design. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1991. </year> <note> ISBN 0-387-97660-4. </note>
Reference-contexts: In this section, we explain some of the statistical terms and methods used in the experimental work. This section is provided as a convenience for the reader who is not immediately familiar with the terminology. For a thorough treatment of multivariate statistical analysis, we recommend <ref> [Job91] </ref>. 7.5.1 Least mean squares regression. Some of our work involves developing methods to estimate the analysis time for programs. We do this by using the experimental data to develop multivariate least mean square regressions, from the independent variables to the analysis time for the program. <p> Adjusted r 2 . The "unadjusted" r 2 metric, or coefficient of determination <ref> [Job91] </ref>, indicates what fraction of the variation in observed data is explained by the regression. Unadjusted r 2 may falsely indicate that a regression with many independent variables, relative to the number of data points, explains noisy data better than a regression with fewer independent variables. <p> In contrast, the adjusted r 2 metric, or coefficient of determination adjusted for degrees of freedom <ref> [Job91] </ref>, also takes into account the sample size and the number of independent variables. Both r 2 and adjusted r 2 vary from 1 to 1, with higher values indicating a better fit. Values below zero indicate that the predicted data is actually "noisier" than the observations.
Reference: [KB90] <author> G. M. Karam and R. J. A. Buhr. </author> <title> Starvation and critical race analyzers for Ada. </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 829-843, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: Livelock-induced starvation: Karam and Buhr <ref> [KB90] </ref> . : : : : : 359 10.3.4. Survey of Ada deadlock detection methods: Cheng [Che91] . : : 359 10.4. <p> Most of the flow graph methods rely on state enumeration, though two do not [Sax77, BDER79]. All the Petri-net methods we have found rely, in one way or another, on state enumeration. 346 Section 10.3.3 discusses the work of Karam and Buhr <ref> [KB90] </ref>, in detecting livelock-induced starvation; strictly speaking, their work does not address infinite waits. Finally, Section 10.3.4 reviews, and refutes some assertions in, a survey of deadlock detection methods by Cheng [Che91]. 10.3.1 Flow graph methods. <p> Thus, the false alarm rate for the approach of [CU91] will be unacceptably high. The method, as described in [CU91], thus cannot be used in practice. 359 10.3.3 Livelock-induced starvation: Karam and Buhr <ref> [KB90] </ref>. Karam and Buhr [KB90] use a method similar to symbolic execution to generate a set of reachable program state assertions (PSAs) for Ada programs. From these, "starved" states are detected, and tested to see whether they could have been produced under "fair" scheduling. <p> Thus, the false alarm rate for the approach of [CU91] will be unacceptably high. The method, as described in [CU91], thus cannot be used in practice. 359 10.3.3 Livelock-induced starvation: Karam and Buhr <ref> [KB90] </ref>. Karam and Buhr [KB90] use a method similar to symbolic execution to generate a set of reachable program state assertions (PSAs) for Ada programs. From these, "starved" states are detected, and tested to see whether they could have been produced under "fair" scheduling. <p> Karam and Buhr's term "starvation" would, perhaps, better be described as "starvation induced by livelock." This analysis, and the fact that they prune some false alarms by use of assumptions about scheduling, are the primary contributions of this paper. The technical description in <ref> [KB90] </ref> is quite difficult to follow. The authors describe their program state assertion (PSA) tree as analogous to the tree of reachable states, but with additional associated information. <p> CHT perf [LC89] 10.3.1 Exp Infinite waits; CHT perf [McD89] 10.3.1 Exp Infinite waits; CHT perf [Sax77] 10.3.1 Poly Deadlocks Deadlock cycle pruning; nested critical sections [BDER79] 10.3.1 Poly Infinite waits; Iterative refinement of CHT races [ZYN86] 10.3.1 Exp Deadlocks [MSS89] 10.3.2 Exp Infinite waits [CU91] 10.3.2 Exp Deadlocks; livelocks <ref> [KB90] </ref> 10.3.3 ? Livelock-induced starvation [CS88] 10.4.1 Poly CHT B4 problem formulation [DS91] 10.4.2 Poly CHT B4 problem formulation [Mer92] 10.4.3 Poly CHT [EP88] 10.4.4 Exp Races [BK89] 10.4.5 ? Races [ADWR86] 10.5.1 N/A Proofs [Dil90] 10.5.2 N/A Proofs [Apt83] 10.5.3 N/A Proofs [CES86] 10.5.4 Exp Model checking Table 10.1: Summary
Reference: [Kna87] <author> E. Knapp. </author> <title> Deadlock detection in distributed databases. </title> <journal> ACM Computing Surveys, </journal> <volume> 19(4) </volume> <pages> 303-328, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: Survey of dynamic deadlock detection: Knapp <ref> [Kna87] </ref> . : : : : : 382 xx 10.8.2. Deadlock and interactive debugging: Helmbold and Luckham [HL85] . : : : : : : : : : : : : : : : : : : : : : : : : : : : : 384 10.8.3. <p> Last, Chen et. al. ([CKU91], Section 10.8.4 employ an algorithm designed for database use to detect deadlocks in Ada programs. 10.8.1 Survey of dynamic deadlock detection: Knapp <ref> [Kna87] </ref>. Edgar Knapp surveys the area of dynamic deadlock detection in [Kna87]. Although the surveyed work focuses upon applications in distributed databases, much of it is applicable to the problem of detecting deadlock in any concurrent system, including programs or operating systems. <p> Last, Chen et. al. ([CKU91], Section 10.8.4 employ an algorithm designed for database use to detect deadlocks in Ada programs. 10.8.1 Survey of dynamic deadlock detection: Knapp <ref> [Kna87] </ref>. Edgar Knapp surveys the area of dynamic deadlock detection in [Kna87]. Although the surveyed work focuses upon applications in distributed databases, much of it is applicable to the problem of detecting deadlock in any concurrent system, including programs or operating systems. <p> Shih and Stankovic [SS90] discuss the problems of dynamic deadlock detection in programs of several levels of complexity, in the terms of <ref> [Kna87] </ref>. They are concerned with resource acquisition, as well as the rendezvous mechanism, in deadlock detection, and also characterize the types of deadlocks occurring in real time programs. Finally, they give edge-chasing algorithms for deadlock detection for problems in the two lowest levels of complexity. <p> Finally, they give edge-chasing algorithms for deadlock detection for problems in the two lowest levels of complexity. The authors enumerate a hierarchy of Ada deadlock models, along the lines of the problem complexity levels of <ref> [Kna87] </ref>. With each of these models is associated a set of restrictions on the Ada programs that can be handled. <p> The authors do not present a 387 deadlock cycle detection algorithm; rather, Hermann and Chandy's algorithm [HC83] is suggested for this purpose. It is detailed briefly in <ref> [Kna87] </ref>, from which much of the terminology of the paper is borrowed. Note that, while [HC83] is a distributed algorithm, the implementation of [CKU91] uses a centralized monitor task. Section 3 of [CKU91] describes the implementation, which is called EDEN.
Reference: [Knu71] <author> D. E. Knuth. </author> <title> An empirical study of FORTRAN programs. </title> <journal> Software - Practice and Experience, </journal> <volume> 1 </volume> <pages> 105-133, </pages> <year> 1971. </year>
Reference-contexts: However, create chains may have finite length limits in practice, as loop nest depth in Fortran apparently does <ref> [Knu71] </ref>. We need ex perimental data to determine whether the create set representation will help to disprove deadlock in enough instances to make its size penalty worthwhile.
Reference: [KR78] <author> B. W. Kernighan and D. M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1978. </year> <note> ISBN 0-13-110163-3. </note>
Reference-contexts: Entry aborting select...else select...otherwise Self-termination terminate terminate Task aborting abort c abort Table 9.1: Corresponding synchronization features in Ada and Concurrent C. 9.1 Overview of Concurrent C. Concurrent C [GR86],[GR88] is a version of the C language <ref> [KR78] </ref>, augmented for use in concurrent programming. It uses a rendezvous style of synchronization, quite similar in functionality (and often in syntax) to that of Ada.
Reference: [KU76] <author> J. B. Kam and J. D. Ullman. </author> <title> Global flow analysis and iterative algorithms. </title> <journal> Journal of the ACM, </journal> <volume> 23(1) </volume> <pages> 158-171, </pages> <year> 1976. </year>
Reference-contexts: However, in the analysis problems we have investigated, we have found that the useful frameworks of this type are generally not distributive, i.e., 9a; b 2 L k : f (a u b) 6= f (a) u f (b). Thus, the frameworks are not rapid <ref> [KU76] </ref>. One advantage of using homogeneous lattice frameworks is that they are easier to analyze than the cross-product of heterogeneous lattice frameworks (described below.) The edge functions from one node lattice framework have the same properties in each of the other node lattice spaces, since all these spaces are identical. <p> However, they allow us to reduce the asymptotic upper bound on the complexity of the lattice problems used in deadlock detection. 3.1.4 Kam-Ullman "rapid" problems in irreducible graphs. Kam and Ullman <ref> [KU76] </ref> describe a version of Kildall's iterative node-listing algorithm which halts in at most d (G) + 3 iterations over the nodes of a graph G, where d (G) is the loop connectedness of G, or the largest number of back edges found in any cycle-free path in G (with respect <p> Lemma 14 Given a rapid lattice framework D = (G; L; F; M ) where G = (V; E) is a general graph, Kildall's algorithm converges in O (jV jjEj) edge function evaluations and O (jV j 2 log (jV j)) meet operations. Proof: From Theorem 2 of <ref> [KU76] </ref>, Kildall's algorithm halts in no more than d (G)+2 iterations on a rapid problem. In the initialization step of Kildall's algorithm, the edge functions into each node are initially evaluated and a meet of the edges into each node is taken.
Reference: [Lam78] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in distributed systems. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: The idea is to determine a consistent global state without freezing the computation, and detect deadlock in that state. The consistent global state is derived using a "happened before" relation, similar to that of Lamport <ref> [Lam78] </ref>.
Reference: [LC89] <author> D. L. Long and L. A. Clarke. </author> <title> Task interaction graphs for concurrency analysis. </title> <booktitle> In Proceedings of the 11th International Conference on Software Engineering, </booktitle> <pages> pages 44|52, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: : : : 346 Concurrency analysis and symbolic execution: Young and Taylor [YT88] . : : : : : : : : : : : : : : : : : : : : : : : : : : : 347 Control edges as task interaction: Long and Clarke <ref> [LC89] </ref> . : : : 349 Task clans: McDowell [McD89] . : : : : : : : : : : : : : : : : : : 350 Deadlock cycle pruning in resource graphs: Saxena [Sax77] . : : : 352 Iterative refinement: Bristow et. al. [BDER79] . : <p> Other edges, representing the synchronizations themselves, may or may not be present. Our sync graph representations fall into this category. Concise overview. Taylor [Tay83b] details a state-enumeration approach on a control flow graph of the program; variations on Taylor's work include Young and Taylor [YT88], Long and Clarke <ref> [LC89] </ref>, and McDowell [McD89]. In an early work similar to our own, Saxena [Sax77] finds deadlock cycles in a graph of tasks and resource requests, and prunes spurious cycles using constraints. <p> More work is clearly needed. 349 Control edges as task interaction: Long and Clarke <ref> [LC89] </ref>. Long and Clarke [LC89], reacting to the combinatorial explosions in Taylor's original approach [Tay83b], proposed a concurrency analysis based upon a different graph representation for programs. They dubbed their representation a task interaction graph, or TIG; the TIG represented the concurrency behavior of a single task. <p> More work is clearly needed. 349 Control edges as task interaction: Long and Clarke <ref> [LC89] </ref>. Long and Clarke [LC89], reacting to the combinatorial explosions in Taylor's original approach [Tay83b], proposed a concurrency analysis based upon a different graph representation for programs. They dubbed their representation a task interaction graph, or TIG; the TIG represented the concurrency behavior of a single task. <p> Nonetheless, since the state space of a program may be exponential in the number of source statements, the size of the TICG (and therefore the time required to analyze concurrency) may also be 350 exponential. In section 4.2 of <ref> [LC89] </ref>, Long and Clarke describe a method of infinite wait anomaly detection using the TICG. It should be noted that they use the term "deadlock" in a different sense than we do; to them, deadlocks encompass all infinite wait anomalies, including starvation. <p> Also in Section 4.2, Long and Clarke develop the concept of edge groups, representing transitions to the alternatives of a select statement. These edge groups closely resemble the groups of sister nodes used in our analysis. <ref> [LC89] </ref> does not address the issue of guarded versus unguarded select alternatives. In some special cases, it is possible to reduce the number of TIG nodes needed to represent a task. <p> Section 4.3 describes such a structural optimization, which reduces the number of nodes needed to represent entry calls or entries from 3 to 2, if the entries have no nested synchronization. However, this linear optimization cannot prevent combinatorial explosion in the size of the TICG. In summary, <ref> [LC89] </ref> should be viewed as an incremental advance over [Tay83b], but retains the undesirable, combinatorially explosive behavior of the former. Task clans: McDowell [McD89]. In [McD89], McDowell investigates a state enumeration method in which sets of related concurrency states [Tay83b] are represented by a single virtual state. <p> the corresponding parameter passing is eliminated from the data flow problem, improving 376 Time Information Method Section bounds returned Contribution or influence [Tay83b] 10.3.1 Exp Infinite waits; Validation and accuracy CHT perf benchmark for CHT and deadlock computation software [YT88] 10.3.1 Exp Infinite waits; Partitioning in Concurrent C CHT perf <ref> [LC89] </ref> 10.3.1 Exp Infinite waits; CHT perf [McD89] 10.3.1 Exp Infinite waits; CHT perf [Sax77] 10.3.1 Poly Deadlocks Deadlock cycle pruning; nested critical sections [BDER79] 10.3.1 Poly Infinite waits; Iterative refinement of CHT races [ZYN86] 10.3.1 Exp Deadlocks [MSS89] 10.3.2 Exp Infinite waits [CU91] 10.3.2 Exp Deadlocks; livelocks [KB90] 10.3.3 ?
Reference: [LC91] <author> D. L. Long and L. A. Clarke. </author> <title> Data flow analysis of concurrent systems that use the rendezvous model of synchronization. </title> <booktitle> In Proceedings of the ACM SIGSOFT '91 Fourth Symposium on Testing, Analysis, and Verification (TAV4), </booktitle> <pages> pages 21-35, </pages> <address> Vancouver, BC, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: Classic iterative analysis: Long and Clarke <ref> [LC91] </ref> . : : : : : : : 377 10.7.2. Abstract interpretation: Reif and Smolka [RS90] . : : : : : : : : 379 10.7.3. Data dependency graph construction: Moser [Mos90] . : : : : : : 380 10.7.4. <p> This may indicate either an infinite wait anomaly involving the control ancestors of n, or the situation that n is unreachable in control flow. The second additional use of CHT is in data flow analysis involving communications between tasks <ref> [LC91] </ref>. For example, consider reaching definitions analysis. If two tasks do not share memory, then definitions can propagate directly between them only through the parameters of a rendezvous. The rendezvous cannot occur if the corresponding signaling and accept-in nodes can't happen together. <p> The development of interprocess data flow algorithms is beyond the scope of the current research; we will simply assume, for the moment, that they can be developed. Others <ref> [LC91] </ref> have made some preliminary investigations in interprocess data flow methods. We expect that these algorithms will be improved, in both accuracy and representational completeness, within the next few years. * Programs do not contain arrays or linked structures that refer to processes or transactions. <p> Moser ([Mos90], Section 10.7.3) gives techniques for finding data dependences statically within small regions of the program. Cheng ([Che92], Section 10.7.4) describes an extended version of the program dependence graph for use in concurrent programs. 10.7.1 Classic iterative analysis: Long and Clarke <ref> [LC91] </ref>. Long and Clarke [LC91] build upon the work of Taylor and Osterweil [TO80], in that they divide programs into components which are each analyzed only once. <p> Moser ([Mos90], Section 10.7.3) gives techniques for finding data dependences statically within small regions of the program. Cheng ([Che92], Section 10.7.4) describes an extended version of the program dependence graph for use in concurrent programs. 10.7.1 Classic iterative analysis: Long and Clarke <ref> [LC91] </ref>. Long and Clarke [LC91] build upon the work of Taylor and Osterweil [TO80], in that they divide programs into components which are each analyzed only once. The components that Long and Clarke analyze are called fragments; a fragment represents a task, a loop body, or the code contained inside an accept statement. <p> Livelock detection, though theoretically undecidable, might also yield to memory state modeling for many common programs. 11.2 Additional applications for non-concurrency analysis. Information about guaranteed non-concurrency has many possible uses in compilation and debugging, apart from static deadlock detection. Specifically, it is useful for data flow analysis <ref> [RS90, LC91] </ref>, rendezvous optimization, dead code elimination, and race anomaly detection. In this section, we briefly outline some of these expected benefits. This area will likely be an important one for future research. 392 Debuggers and program understanding tools.
Reference: [Lon86] <author> D. Longley. </author> <title> Dictionary of information technology. </title> <publisher> Macmillan Press, </publisher> <address> New York, </address> <year> 1986. </year> <note> ISBN 0-19-520519-7. </note>
Reference-contexts: Deadlock: In computing, an error condition in which processing cannot continue because each of two elements of the process is waiting for an action from the other. Synonymous with deadly embrace. (Dennis Longley, <ref> [Lon86] </ref>.) An example of a deadlock, not from the computer domain, is shown in Figure 1.1. Each of the four cars in the figure is waiting for the car in front of it to move out of the way.
Reference: [LR92] <author> W. Landi and B. G. Ryder. </author> <title> A safe approximation algorithm for interproce-dural pointer aliasing. </title> <booktitle> In Proceedings of the SIGPLAN '92 Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 235-248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Also, defining u y2; y = &gt; often eliminates special cases in implementation. 36 Cross-product of heterogeneous lattice frameworks. Another possible representation for some multi-source problems uses a data flow formulation like that of <ref> [Cal88, LR92] </ref>. In these formulations, the elements of the base lattice are the members of some set. The meet operator is set union for some nodes, and set intersection for others. 7 Thus, some nodes are represented by the base lattice, while others are represented by the "inverted" base lattice. <p> Rather, the property would have to be proved for the functions on the cross-product lattice. These difficulties are obviated by the use of the heterogeneous cross-product frameworks described above. 7 Neither of <ref> [Cal88, LR92] </ref> formulate their data flow problems as lattice frameworks; this represents one method of doing so. 37 n n n n Source 1 Source 2 Source k Meet is intersection Meet is union erogeneous cross-product framework. 2.3.5 Cycle location graphs.
Reference: [LT79] <author> T. Lengauer and R. E. Tarjan. </author> <title> A fast algorithm for finding dominators in a flowgraph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 1(1) </volume> <pages> 121-141, </pages> <month> July </month> <year> 1979. </year> <month> 404 </month>
Reference-contexts: j, n = jEj, t is the time required to find the path expressions for the dominator strong components of G, and ff is the inverse Ackermann function. 1 We use Tarjan's notation system in this section. 48 Deriving the dominator tree of G takes time O (mff (m; n)) <ref> [LT79] </ref>. From these, the path expressions of the dominator strong components of G must be found by applying the algorithm recursively to each component. <p> Proof: The dominator and postdominator trees of a flow graph can be found in time O (jEj log (jN j)) by the simpler algorithm of <ref> [LT79] </ref>. From this, the initial pairs (n n ; n x ) 2 S may be constructed by traversing these trees.
Reference: [McD89] <author> C. E. McDowell. </author> <title> A practical algorithm for static analysis of parallel programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 6(3) </volume> <pages> 515-536, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Young and Taylor [YT88] . : : : : : : : : : : : : : : : : : : : : : : : : : : : 347 Control edges as task interaction: Long and Clarke [LC89] . : : : 349 Task clans: McDowell <ref> [McD89] </ref> . : : : : : : : : : : : : : : : : : : 350 Deadlock cycle pruning in resource graphs: Saxena [Sax77] . : : : 352 Iterative refinement: Bristow et. al. [BDER79] . : : : : : : : : : 353 <p> Our sync graph representations fall into this category. Concise overview. Taylor [Tay83b] details a state-enumeration approach on a control flow graph of the program; variations on Taylor's work include Young and Taylor [YT88], Long and Clarke [LC89], and McDowell <ref> [McD89] </ref>. In an early work similar to our own, Saxena [Sax77] finds deadlock cycles in a graph of tasks and resource requests, and prunes spurious cycles using constraints. <p> However, this linear optimization cannot prevent combinatorial explosion in the size of the TICG. In summary, [LC89] should be viewed as an incremental advance over [Tay83b], but retains the undesirable, combinatorially explosive behavior of the former. Task clans: McDowell <ref> [McD89] </ref>. In [McD89], McDowell investigates a state enumeration method in which sets of related concurrency states [Tay83b] are represented by a single virtual state. <p> However, this linear optimization cannot prevent combinatorial explosion in the size of the TICG. In summary, [LC89] should be viewed as an incremental advance over [Tay83b], but retains the undesirable, combinatorially explosive behavior of the former. Task clans: McDowell <ref> [McD89] </ref>. In [McD89], McDowell investigates a state enumeration method in which sets of related concurrency states [Tay83b] are represented by a single virtual state. <p> the data flow problem, improving 376 Time Information Method Section bounds returned Contribution or influence [Tay83b] 10.3.1 Exp Infinite waits; Validation and accuracy CHT perf benchmark for CHT and deadlock computation software [YT88] 10.3.1 Exp Infinite waits; Partitioning in Concurrent C CHT perf [LC89] 10.3.1 Exp Infinite waits; CHT perf <ref> [McD89] </ref> 10.3.1 Exp Infinite waits; CHT perf [Sax77] 10.3.1 Poly Deadlocks Deadlock cycle pruning; nested critical sections [BDER79] 10.3.1 Poly Infinite waits; Iterative refinement of CHT races [ZYN86] 10.3.1 Exp Deadlocks [MSS89] 10.3.2 Exp Infinite waits [CU91] 10.3.2 Exp Deadlocks; livelocks [KB90] 10.3.3 ? Livelock-induced starvation [CS88] 10.4.1 Poly CHT B4
Reference: [Mer92] <author> N. Mercouroff. </author> <title> An algorithm for analyzing concurrent processes. </title> <booktitle> In Lecture Notes in Computer Science #598. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year> <note> ISBN 0-38755-511-0. </note>
Reference-contexts: Non-concurrency: Callahan and Subhlok [CS88, CKS90] . : : : : 362 10.4.2. Interprocedural analysis: Duesterwald and Soffa [DS91] , [Due91] .364 10.4.3. Congruences: Mercouroff <ref> [Mer92] </ref> . : : : : : : : : : : : : : : : : : 365 10.4.4. Classification of determinacy: Emrath and Padua [EP88] . : : : : 367 10.4.5. <p> They use a notation (a+flB), where a is a set of integers denoting possible contributions to the count from single-instance statements, and B is a set of possible contributions from multiple-instance statements. This amounts to a set of congruences; see <ref> [Mer92] </ref> for a more formal application of this idea. Using the expression, a set of discriminating equations is formulated for the program. The discriminating equations assert that, for successful termination, the number of calls to each entry equals the number of times the entry is accepted. <p> While [DS91] does not discuss iterative refinement of the Ord relation, it mentions the possibility of increasing precision by removing spurious sync edges. [Due91] mentions using the Ord relation itself to find spurious sync edges. 10.4.3 Congruences: Mercouroff <ref> [Mer92] </ref>. Mercouroff [Mer92] describes a non-concurrency analysis using a novel lattice framework. The analysis works for channel-based communications (as in CSP). Mercouroff's main contribution is to approximate the number of times that communication statements addressing a particular channel may be executed in each task. <p> While [DS91] does not discuss iterative refinement of the Ord relation, it mentions the possibility of increasing precision by removing spurious sync edges. [Due91] mentions using the Ord relation itself to find spurious sync edges. 10.4.3 Congruences: Mercouroff <ref> [Mer92] </ref>. Mercouroff [Mer92] describes a non-concurrency analysis using a novel lattice framework. The analysis works for channel-based communications (as in CSP). Mercouroff's main contribution is to approximate the number of times that communication statements addressing a particular channel may be executed in each task. <p> Nonetheless, their research had a large influence on the evolution of our B4 analysis. Bristow et. al. [BDER79] provided perhaps the genesis of the idea of iterative refinement of CHT . The work of Mercouroff <ref> [Mer92] </ref> is interesting because it is perhaps least closely related to the other non-concurrency analyses; an empirical comparison to our CHT analysis, or a combination of approaches, might provide a good line of future work. 10.7 Static intertask data flow analysis. <p> Deadlocks Deadlock cycle pruning; nested critical sections [BDER79] 10.3.1 Poly Infinite waits; Iterative refinement of CHT races [ZYN86] 10.3.1 Exp Deadlocks [MSS89] 10.3.2 Exp Infinite waits [CU91] 10.3.2 Exp Deadlocks; livelocks [KB90] 10.3.3 ? Livelock-induced starvation [CS88] 10.4.1 Poly CHT B4 problem formulation [DS91] 10.4.2 Poly CHT B4 problem formulation <ref> [Mer92] </ref> 10.4.3 Poly CHT [EP88] 10.4.4 Exp Races [BK89] 10.4.5 ? Races [ADWR86] 10.5.1 N/A Proofs [Dil90] 10.5.2 N/A Proofs [Apt83] 10.5.3 N/A Proofs [CES86] 10.5.4 Exp Model checking Table 10.1: Summary of related synchronization and non-concurrency analysis tech niques. 377 the accuracy of the solution. <p> This may improve the execution time of state space enumeration. * Non-concurrency analysis. Generalizing critical sections, as outlined in Section 5.1.5. Propagating pinning information along control and sync edges. An example is given in Section 5.1.2. - Congruences as a CHT refinement. The work of Mercouroff <ref> [Mer92] </ref> uses congruences to detect non-concurrent synchronization statements in the CSP 391 language. Future work may investigate the generalization of Mercouroff's method to other types of synchronization, and the use of CHT information to improve the congruence analysis. Other uses for non-concurrency information.
Reference: [MM92] <author> T. J. Marlowe and S. P. Masticola. </author> <title> Safe optimization for hard real-time programming. </title> <booktitle> In Second International Conference on Systems Integration, </booktitle> <pages> pages 438-446, </pages> <month> June </month> <year> 1992. </year>
Reference: [Mos90] <author> L. E. Moser. </author> <title> Data dependency graphs for Ada programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(5) </volume> <pages> 498-509, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Classic iterative analysis: Long and Clarke [LC91] . : : : : : : : 377 10.7.2. Abstract interpretation: Reif and Smolka [RS90] . : : : : : : : : 379 10.7.3. Data dependency graph construction: Moser <ref> [Mos90] </ref> . : : : : : : 380 10.7.4. Task dependence nets: Cheng [Che92] . : : : : : : : : : : : : : : 381 10.8. <p> Reif and Smolka use a n function for each RECEIVE node n, to achieve the same effect as our multiple-edge-type data flow frameworks. Our frameworks could directly subsume their functions, encoding their analysis as a more standard data flow framework. 10.7.3 Data dependency graph construction: Moser <ref> [Mos90] </ref>. Moser, in [Mos90], outlines a technique for constructing the data dependency graphs of Ada programs, based on composition of subgraphs during parsing. The expected operational advantage of doing this is that the graph may be obtained for a small portion of the program at any time. <p> Reif and Smolka use a n function for each RECEIVE node n, to achieve the same effect as our multiple-edge-type data flow frameworks. Our frameworks could directly subsume their functions, encoding their analysis as a more standard data flow framework. 10.7.3 Data dependency graph construction: Moser <ref> [Mos90] </ref>. Moser, in [Mos90], outlines a technique for constructing the data dependency graphs of Ada programs, based on composition of subgraphs during parsing. The expected operational advantage of doing this is that the graph may be obtained for a small portion of the program at any time. <p> It is possible that a local analysis of non-concurrency properties might also be of use in dependence analysis and optimization. For example, locally available CHT information might eliminate some spurious data dependence edges from the graphs of <ref> [Mos90] </ref>. However, none of the four CHT refinements listed in Chapter 5 are safe for local analyses; more work is needed in this area to identify locally safe means of propagating CHT information between tasks. 381 10.7.4 Task dependence nets: Cheng [Che92].
Reference: [MR90a] <author> S. P. Masticola and B. G. Ryder. </author> <title> Static infinite wait anomaly detection in polynomial time. </title> <booktitle> In Proceedings of the 1990 International Conference on Parallel Processing, </booktitle> <pages> pages II78-II87, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: However, it is easy to show that, if the cycle does enter a single instance task more than once, then either there is a deadlock cycle that enters only once, or the cycle contains a pair of head nodes that can't happen together <ref> [MR90a] </ref>. 2.3.6 The DeadPath problem. The final step in analysis is to determine, for all potential head nodes h, whether a deadlock path exists from h to itself. We do this using a DeadPath lattice framework. <p> Naturally, the question arises: Given the new execution model, are deadlocks and starvation still the only possible types of infinite wait anomalies? The answer is yes; the proof is identical to that of Theorem 1 of <ref> [MR90a] </ref>. Deadlocks involving hyperedges. A deadlock is characterized by a group of tasks that mutually wait on each other. Consider a subset D of the head nodes of deadlocked tasks in an execution wave. <p> In cycle detection, we use a hyperedge cycle location graph, or HCLG, corresponding to the sync hypergraph. The HCLG for the sync hypergraph is a particularization of the cycle location graphs of Section 2.3.5. The HCLG is constructed so that any cycles must satisfy constraint 1 of <ref> [MR90a] </ref>, i.e., that any cycle that enters a task should traverse at least one control edge in that task. Such a construction eliminates cycles which are spurious under constraint 1. <p> Interactions in mode (c) have some node in x 0 as a head node, and traverse (a o ; s d ). 4.3.5 Scope depth and feasible deadlocks. In <ref> [MR90a] </ref>, constraint 2 states that no two head nodes of a deadlock cycle may rendezvous with each other. <p> If E is anomalous, then we can substitute in Equation (4.2) to obtain Accept?(E; y) ) SigN set (E; y) = 0: (4.5) This implies the original constraint 2 of <ref> [MR90a] </ref>, that no pair of head nodes in a deadlocked execution wave (and hence a deadlock cycle) can rendezvous. We would like to derive from Equation (4.1) and Equation (4.3) those conditions which can be checked given only knowledge of the deadlock cycle and the total number of active tasks. <p> Furthermore, q cannot be the return node r (which could rendezvous with x). By Theorem 1 of <ref> [MR90a] </ref>, q must be a starved node, or a head node of a deadlock cycle, or transitively connected to a starved task or a deadlock. 2 c x' x q c' z Transitive chain to cycle containing x Lemma 58 If any valid deadlock cycle includes the return node of a <p> We now develop a set of constraints on deadlocked execution waves in the binary semaphore model. These constraints will aid in pruning invalid cycles during deadlock detection, and are analogous to the constraints developed for the Ada model in <ref> [MR90a] </ref>. Suppose that execution wave (E; S) is deadlocked, and that D N is the set of head nodes of the deadlock. Let S D be the set of semaphores upon which the nodes of 232 D wait. The following constraints hold on D, E, and S: 1. <p> Since most of these constructs have been successfully incorporated into the Ada model, they should present few problems for the successful modeling of Concurrent C. The resulting Concurrent C model thus has much the same flavor as the early Ada model of <ref> [MR90a] </ref>, with the addition of process-valued variables and explicit process creation. * A reasonably accurate static analysis algorithm is available to estimate reaching definitions and def-clear paths of scalar variables. <p> PD is NP-complete for programs observing restrictions 1 and 2 (Theorem 6), or 1 and 3 (Theorem 7), so it is also at least NP-complete for general programs. 343 In <ref> [MR90a] </ref>, we prove related theorems showing that detection of deadlock cycles that observe constraints 1 and 2, or 1 and 3, is NP-hard.
Reference: [MR90b] <author> S. P. Masticola and B. G. Ryder. </author> <title> Static infinite wait anomaly detection in polynomial time. </title> <type> Technical Report LCSR-TR-141, </type> <institution> Laboratory for Computer Science Research, Rutgers University, </institution> <year> 1990. </year> <note> This is an expanded version of the ICPP `90 paper. </note>
Reference: [MR91a] <author> T. J. Marlowe and B. G. Ryder. </author> <title> Properties of data flow frameworks: a unified model. </title> <journal> Acta Informatica, </journal> <volume> 28(2) </volume> <pages> 121-164, </pages> <year> 1991. </year>
Reference-contexts: Proof: Direct from Lemmas 7 and 8. 2 Lemma 11 Inflationary functions are 1-semibounded. Proof: A function is 1-semibounded if, for all x; y 2 L, f (y) w y u x u f (x) <ref> [MR91a] </ref>. If f is inflationary, then f (y) w y w y u x u f (x). 2 Convergence time for iterative lattice problems. <p> Therefore, mapping the data flow problem to the path expression will require O (m 2 ) meet operations and edge function applications, when the data flow problem is k-bounded and that k is constant in m and n. 1-semiboundedness implies 2-boundedness <ref> [MR91a] </ref>. Therefore, the lemma holds. 49 We note that Tarjan's methods may have high overhead costs, and are not frequently used in practice.
Reference: [MR91b] <author> S. P. Masticola and B. G. Ryder. </author> <title> A model of Ada programs for static deadlock detection in polynomial time. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <address> Santa Cruz, CA, </address> <pages> pages 91-102, </pages> <month> May </month> <year> 1991. </year> <journal> Also published as ACM SIGPLAN Notices, </journal> <volume> vol. 26, no. 12, </volume> <month> December </month> <year> 1991. </year>
Reference: [MR93] <author> S. P. Masticola and B. G. Ryder. </author> <title> Non-concurrency analysis. </title> <booktitle> In Proceedings of the 4th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <month> May </month> <year> 1993. </year> <note> Accepted for publication. </note>
Reference-contexts: For an initial, intuitive overview of the thesis, we suggest reading about the general framework, the basic Ada model, and the experimental work on it. This material is contained in Chapters 1, 2, Section 4.2, and Chapters 5 (subsection headers only), 7 and 11. <ref> [MR93] </ref> presents a reasonable synopsis of Chapter 5. Chapters 8 and 9 provide evidence that the deadlock detection framework can be generalized to synchronization and tasking primitives which are quite different from the Ada model; they represent work in progress.
Reference: [MS82] <author> J. Martinez and M. Silva. </author> <title> A simple and fast algorithm to obtain all invariants of a generalized Petri net. </title> <booktitle> In Application and Theory of Petri Nets (Informatik-Fachberichte 52), </booktitle> <pages> pages 301-310. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1982. </year>
Reference-contexts: An S-invariant is a set of weights on the places of the Petri net, such that the weighted sum of the tokens in the net remains constant. The invariants can be obtained by a conceptually simple algorithm, which has the disadvantage of being exponentially complex in time <ref> [MS82] </ref>. The authors propose a representation of Ada programs as Petri nets; since the Petri net execution model is well-defined, this automatically gives them an execution model. Places represent phases of rendezvous within tasks; transitions represent synchronization occurring between tasks. Deadlocks, in the authors' notation, include all infinite wait anomalies.
Reference: [MSS89] <author> T. Murata, B. Shenker, and S. M. Shatz. </author> <title> Detection of Ada static deadlocks using Petri net invariants. </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 314-326, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: : : : : : : : : : : : : 355 Concise overview. : : : : : : : : : : : : : : : : : : : : : : : : : : : 355 Petri net invariants: Murata, Shenker, and Shatz <ref> [MSS89] </ref> , and related work. : : : : : : : : : : : : : : : : : : : : : : : : 356 Reduction transforms. : : : : : : : : : : : : : : : : : : : <p> Cheng and Ushijima ([CU91], Section 10.3.2) detect deadlocks by state enumeration, in a version of the Petri net extended with "inhibit" inputs to transitions. 356 Petri net invariants: Murata, Shenker, and Shatz <ref> [MSS89] </ref>, and related work. Murata, Shenker, and Shatz [MSS89] use the concept of invariants on Petri nets to detect deadlock. Invariants are used initially to guide a phase of interactive program modification, and are then used to constrain state space generation. <p> Cheng and Ushijima ([CU91], Section 10.3.2) detect deadlocks by state enumeration, in a version of the Petri net extended with "inhibit" inputs to transitions. 356 Petri net invariants: Murata, Shenker, and Shatz <ref> [MSS89] </ref>, and related work. Murata, Shenker, and Shatz [MSS89] use the concept of invariants on Petri nets to detect deadlock. Invariants are used initially to guide a phase of interactive program modification, and are then used to constrain state space generation. <p> Following this, the Ada T-invariants are used to generate a subset of the state space of the Petri net representing the program; again, this may be exponentially complex. The algorithms of <ref> [MSS89] </ref> are combinatorially explosive in theory. The authors do not present experimental data, so their time performance in practice cannot be evaluated. However, unless one is willing to ignore deadlocks in loops, the safety properties of [MSS89] need improvement. Reduction transforms. <p> The algorithms of <ref> [MSS89] </ref> are combinatorially explosive in theory. The authors do not present experimental data, so their time performance in practice cannot be evaluated. However, unless one is willing to ignore deadlocks in loops, the safety properties of [MSS89] need improvement. Reduction transforms. In a later article, Tu, Shatz and Murata [TSM90] describe a set of reduction transforms on the Petri net representations of Ada programs. Each transform can be applied in time linear in the size of the Petri net. <p> The authors show an example of the "gas station" problem, a 3-task program whose original Petri net has 46 places, and whose reduced net has only 7 places. While the reduction does not eliminate the combinatorial explosion problems of <ref> [MSS89] </ref>, it may go a long way toward alleviating them. Software tool kits. Shatz, Black and Tu, in [SMBT90], describe a software tool kit for analyzing Ada tasking programs. <p> Other tools (such as reduction transformers or 358 deadlock analyzers) can be invoked from the BIDS; the intent is to provide a flexible platform from which static analysis technology of the type described in <ref> [MSS89] </ref> and [TSM90] can be studied. Extended Petri nets: Cheng and Ushijima [CU91]. Cheng and Ushijima [CU91] propose to statically detect both deadlocks and livelocks using an extended Petri net (EPN) model. In this model, transitions may be inhibited from firing if certain of their input places are marked. <p> In the introduction, he asserts, "The most important 360 conclusion is that finding a correct tasking deadlock detection method is still an open issue." He then reviews a total of four static methods <ref> [Tay83b, ZYN86, CU91, MSS89] </ref> and two dynamic methods [HL85, CAU88] of deadlock detection, dismissing each of these in turn as as "incorrect." Since most of these articles are presented in this chapter, we will not repeat the reviews here. <p> software [YT88] 10.3.1 Exp Infinite waits; Partitioning in Concurrent C CHT perf [LC89] 10.3.1 Exp Infinite waits; CHT perf [McD89] 10.3.1 Exp Infinite waits; CHT perf [Sax77] 10.3.1 Poly Deadlocks Deadlock cycle pruning; nested critical sections [BDER79] 10.3.1 Poly Infinite waits; Iterative refinement of CHT races [ZYN86] 10.3.1 Exp Deadlocks <ref> [MSS89] </ref> 10.3.2 Exp Infinite waits [CU91] 10.3.2 Exp Deadlocks; livelocks [KB90] 10.3.3 ? Livelock-induced starvation [CS88] 10.4.1 Poly CHT B4 problem formulation [DS91] 10.4.2 Poly CHT B4 problem formulation [Mer92] 10.4.3 Poly CHT [EP88] 10.4.4 Exp Races [BK89] 10.4.5 ? Races [ADWR86] 10.5.1 N/A Proofs [Dil90] 10.5.2 N/A Proofs [Apt83] 10.5.3
Reference: [MSW + 93] <author> T. J. Marlowe, A. D. Stoyenko, L. R. Welch, P. LaPlante, and S. P. Masti-cola. </author> <title> Incremental analysis for reuse and change in hard-real-time systems. </title> <booktitle> In Tenth IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <month> May </month> <year> 1993. </year> <note> To appear. </note>
Reference: [Pet81] <author> J. L. Peterson. </author> <title> Petri Net Theory and the Modeling of Systems. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1981. </year> <note> ISBN 0-13661-983-5. 405 </note>
Reference-contexts: Concise overview. We have divided the past work in infinite wait anomaly detection according to the preferred representation. Flow graph methods are built around abstractions of the program's flow graph; these are described in Section 10.3.1. Petri net methods use Petri net <ref> [Pet81] </ref> abstractions of program behavior, possibly with modifications to the Petri net model; these are described in Section 10.3.2. Most of the flow graph methods rely on state enumeration, though two do not [Sax77, BDER79]. <p> We review several of the Petri net papers here, for comparison with our work. We assume here that the reader has some familiarity with the general Petri net representation; a widely used text on the subject is <ref> [Pet81] </ref>. The idea in this research is (or should be) to use the extensive collection of Petri net analysis methods to facilitate approximate deadlock analysis. <p> Similarly, Theorem 4.3 shows that, if another linear equation has no positive integer solution for X, then the program cannot livelock. <ref> [Pet81] </ref> gives procedures for testing whether a vector is a firing vector. However, even ignoring the difficulties of disproving the existence of positive integer solutions which are firing vectors, there is a basic problem.
Reference: [RMP88] <author> B. G. Ryder, T. J. Marlowe, and M. C. Paull. </author> <title> Conditions for incremental iteration: examples and counterexamples. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 11 </volume> <pages> 1-15, </pages> <year> 1988. </year>
Reference-contexts: L 0 INCR . Proof: From Lemma 16, and Theorem 4.3 of <ref> [RMP88] </ref>. 2 53 Chapter 4 Modeling a subset of Ada programs. 54 4.1 Introduction. In this chapter, we first delineate a simple subset of the Ada language, and show a sync graph and execution wave model for the subset.
Reference: [RS90] <author> J. H. Reif and S. A. Smolka. </author> <title> Data flow analysis of distributed communicating processes. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 19(1) </volume> <pages> 1-30, </pages> <year> 1990. </year>
Reference-contexts: Classic iterative analysis: Long and Clarke [LC91] . : : : : : : : 377 10.7.2. Abstract interpretation: Reif and Smolka <ref> [RS90] </ref> . : : : : : : : : 379 10.7.3. Data dependency graph construction: Moser [Mos90] . : : : : : : 380 10.7.4. Task dependence nets: Cheng [Che92] . : : : : : : : : : : : : : : 381 10.8. <p> For example, variables in calling tasks may be live, through parameter passing in entry calls, to a use in the called task following the accept statement. This case will be missed by their analysis. 10.7.2 Abstract interpretation: Reif and Smolka <ref> [RS90] </ref>. Reif and Smolka [RS90] develop a broad framework, based on abstract interpretation, for data flow analysis in a system of communicating processes. The processes communicate via non-blocking TRANSMIT statements; synchronization behavior is thus similar to that for the general semaphore model. <p> For example, variables in calling tasks may be live, through parameter passing in entry calls, to a use in the called task following the accept statement. This case will be missed by their analysis. 10.7.2 Abstract interpretation: Reif and Smolka <ref> [RS90] </ref>. Reif and Smolka [RS90] develop a broad framework, based on abstract interpretation, for data flow analysis in a system of communicating processes. The processes communicate via non-blocking TRANSMIT statements; synchronization behavior is thus similar to that for the general semaphore model. <p> This corresponds roughly to the difference between Ada and Concurrent C. The flow graph of <ref> [RS90] </ref> is essentially a control flow graph in a limited language. Nodes represent program statements of four kinds: assignment, TRANSMIT, RECEIVE, and no-op. Directed edges represent control transitions between the statements. Reif and Smolka also develop a formal semantics of their programming model. <p> Nodes represent program statements of four kinds: assignment, TRANSMIT, RECEIVE, and no-op. Directed edges represent control transitions between the statements. Reif and Smolka also develop a formal semantics of their programming model. The event spanning graph of a program in the <ref> [RS90] </ref> model represents "enable to proceed" relations between statements, and resembles a DAG which spans the sync graph of a binary semaphore program. Directed message link edges are included from TRANSMIT to RECEIVE nodes for the same channel (i.e., signal) reference. <p> The predicates represent strongest post-conditions about the program variables. Section 4 addresses data flow analysis in the presence of static communication between processes; section 5 extends this to dynamic communication. Non-concurrency information could not be directly used to refine the solution, because the TRANSMIT statement in the model of <ref> [RS90] </ref> does not block. Instead, we would have to solve a "message kill" problem, similar to SemKill, for that purpose. Reif and Smolka use a n function for each RECEIVE node n, to achieve the same effect as our multiple-edge-type data flow frameworks. <p> Livelock detection, though theoretically undecidable, might also yield to memory state modeling for many common programs. 11.2 Additional applications for non-concurrency analysis. Information about guaranteed non-concurrency has many possible uses in compilation and debugging, apart from static deadlock detection. Specifically, it is useful for data flow analysis <ref> [RS90, LC91] </ref>, rendezvous optimization, dead code elimination, and race anomaly detection. In this section, we briefly outline some of these expected benefits. This area will likely be an important one for future research. 392 Debuggers and program understanding tools.
Reference: [Sax77] <author> A. Saxena. </author> <title> Static detection of deadlocks. </title> <type> Technical Report CU-CS-122-77, </type> <institution> Department of Computer Science, University of Colorado at Boulder, </institution> <year> 1977. </year>
Reference-contexts: : : : : 347 Control edges as task interaction: Long and Clarke [LC89] . : : : 349 Task clans: McDowell [McD89] . : : : : : : : : : : : : : : : : : : 350 Deadlock cycle pruning in resource graphs: Saxena <ref> [Sax77] </ref> . : : : 352 Iterative refinement: Bristow et. al. [BDER79] . : : : : : : : : : 353 Linear algebraic methods: Zhou, Yeh, and Ng [ZYN86] . : : : : : 354 10.3.2. <p> Critical section call graphs. To resolve the problem of nested critical section calls, we can move up one level of abstraction and examine the critical section call graph of the program, following a construction developed by Saxena <ref> [Sax77] </ref> for binary semaphores. <p> In stars tennis2 demo, a complex mutual-exclusion structure was used between two tasks that represented tennis players; the structure involved intertask data and control dependences. Several programs included tasks that allocated resources; these tasks used counters 220 of available resources as guard conditions. Analysis such as that of <ref> [Sax77] </ref> might be applied to insure that sufficient resources would always be available to meet demand. <p> Petri net methods use Petri net [Pet81] abstractions of program behavior, possibly with modifications to the Petri net model; these are described in Section 10.3.2. Most of the flow graph methods rely on state enumeration, though two do not <ref> [Sax77, BDER79] </ref>. All the Petri-net methods we have found rely, in one way or another, on state enumeration. 346 Section 10.3.3 discusses the work of Karam and Buhr [KB90], in detecting livelock-induced starvation; strictly speaking, their work does not address infinite waits. <p> Our sync graph representations fall into this category. Concise overview. Taylor [Tay83b] details a state-enumeration approach on a control flow graph of the program; variations on Taylor's work include Young and Taylor [YT88], Long and Clarke [LC89], and McDowell [McD89]. In an early work similar to our own, Saxena <ref> [Sax77] </ref> finds deadlock cycles in a graph of tasks and resource requests, and prunes spurious cycles using constraints. <p> This represents, for a head node h, a superset of the nodes that can execute together with h, and thus a superset of the possible concurrency states of the program. 352 Deadlock cycle pruning in resource graphs: Saxena <ref> [Sax77] </ref>. Saxena, in [Sax77], proposes to statically detect deadlock in systems in which tasks share resources. Thus, there is no synchronization per se, only mutual exclusion. His methods have influenced our analysis of nested critical sections (see Section 5.1.4). <p> This represents, for a head node h, a superset of the nodes that can execute together with h, and thus a superset of the possible concurrency states of the program. 352 Deadlock cycle pruning in resource graphs: Saxena <ref> [Sax77] </ref>. Saxena, in [Sax77], proposes to statically detect deadlock in systems in which tasks share resources. Thus, there is no synchronization per se, only mutual exclusion. His methods have influenced our analysis of nested critical sections (see Section 5.1.4). <p> Time bounds are "Exp" for algorithms exponential in lines of source code, "Poly" for 375 polynomial algorithms, "N/A" for algorithms that cannot be fully automated. "Contribution or influence" refers to the contribution or influence each method has had on our work. Of these synchronization analysis methods, only Saxena's work <ref> [Sax77] </ref> centers on safe static deadlock detection in polynomial time. However, due to the coarse "grain size" of his graph representation, we suspect that his algorithm may have accuracy problems in practice. <p> Information Method Section bounds returned Contribution or influence [Tay83b] 10.3.1 Exp Infinite waits; Validation and accuracy CHT perf benchmark for CHT and deadlock computation software [YT88] 10.3.1 Exp Infinite waits; Partitioning in Concurrent C CHT perf [LC89] 10.3.1 Exp Infinite waits; CHT perf [McD89] 10.3.1 Exp Infinite waits; CHT perf <ref> [Sax77] </ref> 10.3.1 Poly Deadlocks Deadlock cycle pruning; nested critical sections [BDER79] 10.3.1 Poly Infinite waits; Iterative refinement of CHT races [ZYN86] 10.3.1 Exp Deadlocks [MSS89] 10.3.2 Exp Infinite waits [CU91] 10.3.2 Exp Deadlocks; livelocks [KB90] 10.3.3 ? Livelock-induced starvation [CS88] 10.4.1 Poly CHT B4 problem formulation [DS91] 10.4.2 Poly CHT B4
Reference: [Set89] <author> R. Sethi. </author> <title> Programming languages: concepts and constructs. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachussetts, </address> <year> 1989. </year> <note> ISBN 0-201-10365-6. </note>
Reference-contexts: Figure 8.1 shows the code for this task. Note that the terminate alternatives are present only to allow the T Ci tasks to terminate when the rest of the program does. Also note that some simpler published simulations of clear semaphores, e.g. the one in Section 9.7 of <ref> [Set89] </ref>, do not behave according to our model, in that they may cause v () statements to wait.
Reference: [SMBT90] <author> S. M. Shatz, K. Mai, C. Black, and S. Tu. </author> <title> Design and implementation of a Petri net based toolkit for Ada tasking analysis. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(4) </volume> <pages> 424-441, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: While the reduction does not eliminate the combinatorial explosion problems of [MSS89], it may go a long way toward alleviating them. Software tool kits. Shatz, Black and Tu, in <ref> [SMBT90] </ref>, describe a software tool kit for analyzing Ada tasking programs. It consists of two major components: the front end (FETS), which parses programs and assembles their Ada nets, and the back end (BIDS), which returns query information about the Petri nets.
Reference: [SMHY92] <author> A. D. Stoyenko, T. J. Marlowe, W. A. Halang, and M. Younis. </author> <title> Enabling efficient schedulability analysis through conditional linking and program transformations. </title> <type> Technical Report CIS-92-20, </type> <institution> Department of Computer and Information Science, New Jersey Institute of Technology, Newark, NJ, </institution> <year> 1992. </year>
Reference-contexts: Modeling memory state. The performance of the deadlock analyzer might be improved by using additional semantic information. For example, it might be possible to deduce that conditionals are linked within, or between tasks <ref> [SMHY92] </ref>, thereby improving the CHT relation. Graph reduction techniques. Tu, Schatz, and Murata [TSM90] proposed a set of graph reduction techniques to reduce the complexity of state enumeration in Petri nets. We might perform similar reductions to reduce the complexity of polynomial deadlock detection in sync graphs.
Reference: [SS90] <author> C-S. Shih and J. A. Stankovic. </author> <title> Distributed deadlock detection in Ada runtime environments. </title> <booktitle> In TRI-Ada `90, </booktitle> <address> Baltimore, MD, </address> <month> December </month> <year> 1990. </year>
Reference-contexts: Deadlock and interactive debugging: Helmbold and Luckham [HL85] . : : : : : : : : : : : : : : : : : : : : : : : : : : : : 384 10.8.3. Real-time systems, resource allocation, and dynamic deadlock: Shih and Stankovic <ref> [SS90] </ref> . : : : : : : : : : : : : : : : : : 385 10.8.4. Cheng, Kasahara and Ushijima [CKU91] . : : : : : : : : : : : : : 386 10.9. <p> The authors identify three conditions needed for the unsafe region to exist: mutual exclusion between tasks, non-preemption of deadlocked tasks, and resource waiting (i.e., tasks hold their resources while waiting for others). This model may, with effort, be adapted to synchronization such as rendezvous <ref> [SS90] </ref>. 341 Coffman and Denning describe three main ways of dealing with deadlocks: * Prevention, by removing one of the three conditions for deadlock. This is the way in which "deadlock-free" schedulers operate. <p> Instead, we must detect a knot (a cycle without exiting edges). * AND-OR: Agents individually either wait on any or all of several resources to be released. The AND-OR model has been used as a framework to represent the Ada rendezvous <ref> [SS90, CKU91] </ref>. * k : Agents may specify that they wish to obtain any k resources out of a pool of n resources, where n is fixed but k may vary. This generalizes the AND-OR model. * Unrestricted: Agents wait on arbitrary combinations of resources. <p> to static deadlock detection is that "it becomes important to know at which call or accept a statement is waiting." Our algorithm can present the potential head nodes of a deadlock cycle without modification, and therefore addresses this concern. 10.8.3 Real-time systems, resource allocation, and dynamic deadlock: Shih and Stankovic <ref> [SS90] </ref>. Shih and Stankovic [SS90] discuss the problems of dynamic deadlock detection in programs of several levels of complexity, in the terms of [Kna87]. <p> is that "it becomes important to know at which call or accept a statement is waiting." Our algorithm can present the potential head nodes of a deadlock cycle without modification, and therefore addresses this concern. 10.8.3 Real-time systems, resource allocation, and dynamic deadlock: Shih and Stankovic <ref> [SS90] </ref>. Shih and Stankovic [SS90] discuss the problems of dynamic deadlock detection in programs of several levels of complexity, in the terms of [Kna87]. They are concerned with resource acquisition, as well as the rendezvous mechanism, in deadlock detection, and also characterize the types of deadlocks occurring in real time programs.
Reference: [Tar81a] <author> R. E. Tarjan. </author> <title> Fast algorithms for solving path problems. </title> <journal> Journal of the ACM, </journal> <volume> 28(3) </volume> <pages> 594-614, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: The result for each vertex v of G is a solution to the data flow problem at v. Constructing the set of path expressions in a general graph takes O (mff (m; n) + t) time <ref> [Tar81a] </ref>, where m = jV j, n = jEj, t is the time required to find the path expressions for the dominator strong components of G, and ff is the inverse Ackermann function. 1 We use Tarjan's notation system in this section. 48 Deriving the dominator tree of G takes time
Reference: [Tar81b] <author> R. E. Tarjan. </author> <title> A unified approach to path problems. </title> <journal> Journal of the ACM, </journal> <volume> 28(3) </volume> <pages> 577-593, </pages> <month> July </month> <year> 1981. </year>
Reference-contexts: We may make the same statements if we initialize all v n to &gt;, in which case each v n will be deflationary during the execution of the worklist algorithm. 2 3.1.3 Tarjan's path problem methods. Tarjan <ref> [Tar81b] </ref> gives an algorithm for solving global flow analysis problems which are represented as instances of the all pairs path expression problem.
Reference: [Tay83a] <author> R. N. Taylor. </author> <title> Complexity of analyzing the synchronization structure of concurrent programs. </title> <journal> Acta Informatica, </journal> <volume> 19 </volume> <pages> 57-84, </pages> <year> 1983. </year>
Reference-contexts: Coffman and Denning [CD73] . : : : : : : : : : : : : : : : : : : : 340 10.2.2. Complexity of static synchronization analysis: Taylor <ref> [Tay83a] </ref> . 341 10.2.3. Classification of Ada deadlocks: Cheng [Che90] . : : : : : : : : : 343 10.3. <p> In this section, we discuss the difficulty of detecting deadlock cycles that obey certain combinations of the constraints. These results refine the complexity results of <ref> [Tay83a] </ref>. First, we examine the complexity of finding cycles that obey constraint 1, but not necessarily any of the other constraints. <p> First, in Section 10.2.1 Coffman and Denning [CD73] give a general overview of the phenomenon of deadlock itself. Using their general model of deadlock, we update their classification of strategies for deadlock management to include static deadlock detection. Taylor <ref> [Tay83a] </ref> characterizes the complexity of static analysis of synchronization, including analysis of deadlock and CHT . In Section 10.2.2, we relate these complexity results to our own work. Lastly, Cheng [Che90] provides a specific enumeration of types of deadlocks which may occur in Ada. <p> If the program cannot deadlock, it is certified to be free of deadlocks. Elimination and certification includes all static deadlock detection methods. 10.2.2 Complexity of static synchronization analysis: Taylor <ref> [Tay83a] </ref>. In [Tay83a], Taylor addresses the complexity of concurrency analysis, for a variety of synchronization analysis problems, under a variety of different assumptions about program structure. <p> If the program cannot deadlock, it is certified to be free of deadlocks. Elimination and certification includes all static deadlock detection methods. 10.2.2 Complexity of static synchronization analysis: Taylor <ref> [Tay83a] </ref>. In [Tay83a], Taylor addresses the complexity of concurrency analysis, for a variety of synchronization analysis problems, under a variety of different assumptions about program structure. <p> The idea in this research is (or should be) to use the extensive collection of Petri net analysis methods to facilitate approximate deadlock analysis. However, much of the Petri net research seems to be devoted to direct state enumeration, rather than approximation methods; <ref> [Tay83a] </ref> proves that this may be combinatorially explosive, regardless of representation. Petri nets also have the disadvantage of placing an additional level of abstraction between the program structure and the results of analysis. Concise overview.
Reference: [Tay83b] <author> R. N. Taylor. </author> <title> A general-purpose algorithm for analyzing concurrent programs. </title> <journal> Communications of the ACM, </journal> <volume> 26(5) </volume> <pages> 362-376, </pages> <month> May </month> <year> 1983. </year>
Reference-contexts: : : : : : : : : : : : : : : : 346 Concise overview. : : : : : : : : : : : : : : : : : : : : : : : : : : : 346 Concurrency state enumeration: Taylor <ref> [Tay83b] </ref> . : : : : : : : : 346 Concurrency analysis and symbolic execution: Young and Taylor [YT88] . : : : : : : : : : : : : : : : : : : : : : : : : : : : 347 Control edges <p> Thus, the set of concurrency states of the program can be represented by a powerset of nodes; the abstract concurrency history <ref> [Tay83b] </ref> of a program thus has a finite number of concurrency states. Nodes may be of different types, corresponding to the class of statements or events they represent. <p> These are graphs in which nodes represent synchronization operations (or phases of synchronization) and directed control edges represent control paths between synchronizations. Other edges, representing the synchronizations themselves, may or may not be present. Our sync graph representations fall into this category. Concise overview. Taylor <ref> [Tay83b] </ref> details a state-enumeration approach on a control flow graph of the program; variations on Taylor's work include Young and Taylor [YT88], Long and Clarke [LC89], and McDowell [McD89]. <p> Finally, Zhou, Yeh, and Ng [ZYN86] propose the use of linear algebra to analyze path expressions, as a step preliminary to state enumeration. Concurrency state enumeration: Taylor <ref> [Tay83b] </ref>. Taylor, in [Tay83b], presented one of the first published algorithms for static analysis of concurrency in languages using rendezvous. The method used is to represent the program as a set of flow graphs, and find the concurrency history (set of reachable concurrency states and state transitions) given this representation. <p> Finally, Zhou, Yeh, and Ng [ZYN86] propose the use of linear algebra to analyze path expressions, as a step preliminary to state enumeration. Concurrency state enumeration: Taylor <ref> [Tay83b] </ref>. Taylor, in [Tay83b], presented one of the first published algorithms for static analysis of concurrency in languages using rendezvous. The method used is to represent the program as a set of flow graphs, and find the concurrency history (set of reachable concurrency states and state transitions) given this representation. <p> Taylor's optimization is parceling, or dividing the state generation between sets of tasks which are represented by biconnected components in the task graph. The effectiveness of parceling had not been investigated experimentally at the time <ref> [Tay83b] </ref> was published. In conclusion, the graph representations of [Tay83b] closely resemble our sync graphs, and Taylor's analysis is analogous to our all-states analysis. However, as our experimental data shows, Taylor's analysis can be combinatorially explosive in practice. Concurrency analysis and symbolic execution: Young and Taylor [YT88]. <p> Taylor's optimization is parceling, or dividing the state generation between sets of tasks which are represented by biconnected components in the task graph. The effectiveness of parceling had not been investigated experimentally at the time <ref> [Tay83b] </ref> was published. In conclusion, the graph representations of [Tay83b] closely resemble our sync graphs, and Taylor's analysis is analogous to our all-states analysis. However, as our experimental data shows, Taylor's analysis can be combinatorially explosive in practice. Concurrency analysis and symbolic execution: Young and Taylor [YT88]. <p> However, as our experimental data shows, Taylor's analysis can be combinatorially explosive in practice. Concurrency analysis and symbolic execution: Young and Taylor [YT88]. In [YT88], Young and Taylor attempt to address the possible combinatorial explosiveness in <ref> [Tay83b] </ref> in two ways: by using symbolic execution to constrain concurrency state generation, and by partitioning the program. 348 The authors propose to construct a directed graph, representing the execution of the program, and to annotate the nodes with path expressions (PEs) and path conditions (PCs). <p> The authors also give a heuristic for prioritizing symbolic execution states, for expansion by marking them as "interesting" (when they represent error states, such as deadlocks) or "promising" (when they are ancestors of "interesting" nodes). The section on program partitioning considers biconnected components (as did <ref> [Tay83b] </ref>), and weak monitors. A weak monitor is a part of the program with specific properties that allow it to be analyzed separately, then ignored in the analysis of the containing code. <p> More work is clearly needed. 349 Control edges as task interaction: Long and Clarke [LC89]. Long and Clarke [LC89], reacting to the combinatorial explosions in Taylor's original approach <ref> [Tay83b] </ref>, proposed a concurrency analysis based upon a different graph representation for programs. They dubbed their representation a task interaction graph, or TIG; the TIG represented the concurrency behavior of a single task. <p> Upon the TIG representation, they build a task interaction concurrency graph, or TICG, representing the behavior of the entire program. The TIG of a task is a directed graph. Rather than representing the rendezvous statements of a task, as in <ref> [Tay83b] </ref>, the nodes of the TIG represent the regions of the task, i.e., the code between tasking statements. Nodes are annotated with pseudocode for the regions they represent; the pseudocode is Ada, annotated with ENTER and EXIT transition pseudostatements, denoting the task interactions that cause transitions between regions. <p> Section 4.1 outlines an extension of the model that allows for nested task activations and early termination via the terminate alternative. The authors cite empirical data suggesting that, in practice, the TIG/TICG model has a lower number of reachable states than the model of <ref> [Tay83b] </ref>. Long and Clarke note that the TICG representation is usually smaller than, and is never larger than, the concurrency histories of [Tay83b]. <p> The authors cite empirical data suggesting that, in practice, the TIG/TICG model has a lower number of reachable states than the model of <ref> [Tay83b] </ref>. Long and Clarke note that the TICG representation is usually smaller than, and is never larger than, the concurrency histories of [Tay83b]. Nonetheless, since the state space of a program may be exponential in the number of source statements, the size of the TICG (and therefore the time required to analyze concurrency) may also be 350 exponential. <p> An infinite wait anomaly occurs at a TICG node n if none of the regions in n is able to provide synchronization for any other region in n. This may occur even if the TICG node has successors, unlike the concurrency state graph of <ref> [Tay83b] </ref>. Also in Section 4.2, Long and Clarke develop the concept of edge groups, representing transitions to the alternatives of a select statement. These edge groups closely resemble the groups of sister nodes used in our analysis. [LC89] does not address the issue of guarded versus unguarded select alternatives. <p> However, this linear optimization cannot prevent combinatorial explosion in the size of the TICG. In summary, [LC89] should be viewed as an incremental advance over <ref> [Tay83b] </ref>, but retains the undesirable, combinatorially explosive behavior of the former. Task clans: McDowell [McD89]. In [McD89], McDowell investigates a state enumeration method in which sets of related concurrency states [Tay83b] are represented by a single virtual state. <p> In summary, [LC89] should be viewed as an incremental advance over <ref> [Tay83b] </ref>, but retains the undesirable, combinatorially explosive behavior of the former. Task clans: McDowell [McD89]. In [McD89], McDowell investigates a state enumeration method in which sets of related concurrency states [Tay83b] are represented by a single virtual state. <p> Although McDowell compares his work to Taylor's <ref> [Tay83b] </ref>, he actually analyzes a source language quite different from Ada. <p> The final virtual execution step of detection is thus a state enumeration like that 3 There is a serious typographical error in step 4, implying that all loops with synchronization should be eliminated. The example does not reflect the step as it is worded. 355 of <ref> [Tay83b] </ref>, followed by a cycle detection for each of the dead states. Any efficiency gains in [ZYN86] must therefore come from the use of discriminating equations to de tect programs that do not deadlock. <p> The PSA tree is itself produced by a deadlock analyzer; it seems to be similar in structure to the concurrency history of <ref> [Tay83b] </ref>, though the authors do not give explicit algorithms for generating the PSA tree. <p> In the introduction, he asserts, "The most important 360 conclusion is that finding a correct tasking deadlock detection method is still an open issue." He then reviews a total of four static methods <ref> [Tay83b, ZYN86, CU91, MSS89] </ref> and two dynamic methods [HL85, CAU88] of deadlock detection, dismissing each of these in turn as as "incorrect." Since most of these articles are presented in this chapter, we will not repeat the reviews here. <p> As in [ADWR86], Apt uses regular expressions to prune unreachable configurations. Apt also proposes to optimize the number of blocked configurations by dividing the program into communication-closed layers, which is equivalent to the parceling optimization made in <ref> [Tay83b] </ref>. This reduces the number of blocked configurations, thus easing the proof task. However, the value of this technique has not been demonstrated in practice; it is not known whether the majority of programs can be decomposed into communication-closed layers. <p> Bristow et. al. [BDER79] proposed a method of infinite wait anomaly detection as a side issue, but it is also likely to have accuracy problems. The remainder of the infinite wait anomaly detection algorithms require exponential (or worse) time. Taylor's state enumeration <ref> [Tay83b] </ref> provided a simple means to validate the deadlock analyzer implementation, and check both the accuracy of deadlock detection and CHT estimation. Many of the other state enumeration methods could also be used for this purpose. <p> First, non-concurrency analysis may be used to eliminate some rendezvous between nodes that can never happen together. Thus, the corresponding parameter passing is eliminated from the data flow problem, improving 376 Time Information Method Section bounds returned Contribution or influence <ref> [Tay83b] </ref> 10.3.1 Exp Infinite waits; Validation and accuracy CHT perf benchmark for CHT and deadlock computation software [YT88] 10.3.1 Exp Infinite waits; Partitioning in Concurrent C CHT perf [LC89] 10.3.1 Exp Infinite waits; CHT perf [McD89] 10.3.1 Exp Infinite waits; CHT perf [Sax77] 10.3.1 Poly Deadlocks Deadlock cycle pruning; nested critical
Reference: [TLK92] <author> R. N. Taylor, D. L. Levine, , and C. D. Kelly. </author> <title> Structural testing of concurrent programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(3) </volume> <pages> 206-215, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Wampler <ref> [TLK92, Wam85] </ref> shows that jTasksj jTasksj 2 is an accurate predictor of the number of reachable states of a program, for the "dining philosophers" problem [Dij68]. By implication, Taylor et. al., in [TLK92], assume that Wampler's hypothesis applies to a wider set of programs. <p> Wampler [TLK92, Wam85] shows that jTasksj jTasksj 2 is an accurate predictor of the number of reachable states of a program, for the "dining philosophers" problem [Dij68]. By implication, Taylor et. al., in <ref> [TLK92] </ref>, assume that Wampler's hypothesis applies to a wider set of programs. This assumption is reasonable if all tasks have the same number of nodes, and if nodes appear on the execution wave independently of the other nodes on the wave.
Reference: [TO80] <author> R. N. Taylor and L. J. Osterweil. </author> <title> Anomaly detection in concurrent software by static data flow analysis. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE6(3):265-277, </volume> <month> May </month> <year> 1980. </year>
Reference-contexts: Cheng ([Che92], Section 10.7.4) describes an extended version of the program dependence graph for use in concurrent programs. 10.7.1 Classic iterative analysis: Long and Clarke [LC91]. Long and Clarke [LC91] build upon the work of Taylor and Osterweil <ref> [TO80] </ref>, in that they divide programs into components which are each analyzed only once. The components that Long and Clarke analyze are called fragments; a fragment represents a task, a loop body, or the code contained inside an accept statement.
Reference: [TSM90] <author> S. Tu, S. M. Shatz, and T. Murata. </author> <title> Applying Petri net reduction to support Ada-tasking deadlock detection. </title> <booktitle> In Proceedings of IEEE International Conference on Distributed Computing Systems, </booktitle> <pages> pages 96-103, </pages> <address> Paris, </address> <month> May </month> <year> 1990. </year> <month> 406 </month>
Reference-contexts: The authors do not present experimental data, so their time performance in practice cannot be evaluated. However, unless one is willing to ignore deadlocks in loops, the safety properties of [MSS89] need improvement. Reduction transforms. In a later article, Tu, Shatz and Murata <ref> [TSM90] </ref> describe a set of reduction transforms on the Petri net representations of Ada programs. Each transform can be applied in time linear in the size of the Petri net. <p> Other tools (such as reduction transformers or 358 deadlock analyzers) can be invoked from the BIDS; the intent is to provide a flexible platform from which static analysis technology of the type described in [MSS89] and <ref> [TSM90] </ref> can be studied. Extended Petri nets: Cheng and Ushijima [CU91]. Cheng and Ushijima [CU91] propose to statically detect both deadlocks and livelocks using an extended Petri net (EPN) model. In this model, transitions may be inhibited from firing if certain of their input places are marked. <p> Modeling memory state. The performance of the deadlock analyzer might be improved by using additional semantic information. For example, it might be possible to deduce that conditionals are linked within, or between tasks [SMHY92], thereby improving the CHT relation. Graph reduction techniques. Tu, Schatz, and Murata <ref> [TSM90] </ref> proposed a set of graph reduction techniques to reduce the complexity of state enumeration in Petri nets. We might perform similar reductions to reduce the complexity of polynomial deadlock detection in sync graphs. Directed state space enumeration.
Reference: [Wam85] <author> G. K. Wampler. </author> <title> Static concurrency analysis of Ada programs. </title> <type> Master's thesis, </type> <institution> University of California, </institution> <address> Irvine, CA, </address> <year> 1985. </year>
Reference-contexts: Execution time does not apparently correlate well with any of the twelve measured parameters. It is possible that execution time might correlate well with some function of a combination of the measured independent parameters. We examine such a combination of parameters, proposed by Wampler <ref> [Wam85] </ref>, in Section 7.10.2. However, it appears that number of possible execution waves cannot be reliably predicted from the sync graph statistics, since sync hypergraphs with identical parameters may have vastly different numbers of possible execution waves. A careful examination of Figure 7.16 indicates that this is true in practice. <p> Wampler <ref> [TLK92, Wam85] </ref> shows that jTasksj jTasksj 2 is an accurate predictor of the number of reachable states of a program, for the "dining philosophers" problem [Dij68]. By implication, Taylor et. al., in [TLK92], assume that Wampler's hypothesis applies to a wider set of programs.
Reference: [Wei84] <author> M. Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352-357, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: Like the PDG, the TDN can have either a static version, representing all possible dependences, or a dynamic version, representing the dependences that occur in an actual run of the program. Cheng proposes to use the TDN in conjunction with Weiser slicing <ref> [Wei84] </ref> of either the static or dynamic TDN as appropriate, to aid in program debugging. 10.8 Dynamic deadlock detection. Dynamic deadlock detection has the same major goal as static deadlock detection: to identify the problem of deadlocks so they can be remediated.
Reference: [YT88] <author> M. Young and R. N. Taylor. </author> <title> Combining static concurrency analysis with symbolic execution. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(10) </volume> <pages> 1499-1511, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: : : : : : : : : : : : : : : : : : : : : : : : : : : 346 Concurrency state enumeration: Taylor [Tay83b] . : : : : : : : : 346 Concurrency analysis and symbolic execution: Young and Taylor <ref> [YT88] </ref> . : : : : : : : : : : : : : : : : : : : : : : : : : : : 347 Control edges as task interaction: Long and Clarke [LC89] . : : : 349 Task clans: McDowell [McD89] . : : <p> Other edges, representing the synchronizations themselves, may or may not be present. Our sync graph representations fall into this category. Concise overview. Taylor [Tay83b] details a state-enumeration approach on a control flow graph of the program; variations on Taylor's work include Young and Taylor <ref> [YT88] </ref>, Long and Clarke [LC89], and McDowell [McD89]. In an early work similar to our own, Saxena [Sax77] finds deadlock cycles in a graph of tasks and resource requests, and prunes spurious cycles using constraints. <p> In conclusion, the graph representations of [Tay83b] closely resemble our sync graphs, and Taylor's analysis is analogous to our all-states analysis. However, as our experimental data shows, Taylor's analysis can be combinatorially explosive in practice. Concurrency analysis and symbolic execution: Young and Taylor <ref> [YT88] </ref>. In [YT88], Young and Taylor attempt to address the possible combinatorial explosiveness in [Tay83b] in two ways: by using symbolic execution to constrain concurrency state generation, and by partitioning the program. 348 The authors propose to construct a directed graph, representing the execution of the program, and to annotate the <p> In conclusion, the graph representations of [Tay83b] closely resemble our sync graphs, and Taylor's analysis is analogous to our all-states analysis. However, as our experimental data shows, Taylor's analysis can be combinatorially explosive in practice. Concurrency analysis and symbolic execution: Young and Taylor <ref> [YT88] </ref>. In [YT88], Young and Taylor attempt to address the possible combinatorial explosiveness in [Tay83b] in two ways: by using symbolic execution to constrain concurrency state generation, and by partitioning the program. 348 The authors propose to construct a directed graph, representing the execution of the program, and to annotate the nodes with <p> Weak monitors are intended to avoid combinatorial explosion, while partitions are intended to improve the accuracy of analysis. Also, while manual identification of partitions can be used, our intention is that partitions be identified automatically. Essentially, <ref> [YT88] </ref> is an "idea paper." There is no evidence that symbolic execution will reduce the total analysis time, improve the precision of the analysis, or significantly reduce the combinatorial explosions of state generation, in practice. More work is clearly needed. 349 Control edges as task interaction: Long and Clarke [LC89]. <p> Thus, the corresponding parameter passing is eliminated from the data flow problem, improving 376 Time Information Method Section bounds returned Contribution or influence [Tay83b] 10.3.1 Exp Infinite waits; Validation and accuracy CHT perf benchmark for CHT and deadlock computation software <ref> [YT88] </ref> 10.3.1 Exp Infinite waits; Partitioning in Concurrent C CHT perf [LC89] 10.3.1 Exp Infinite waits; CHT perf [McD89] 10.3.1 Exp Infinite waits; CHT perf [Sax77] 10.3.1 Poly Deadlocks Deadlock cycle pruning; nested critical sections [BDER79] 10.3.1 Poly Infinite waits; Iterative refinement of CHT races [ZYN86] 10.3.1 Exp Deadlocks [MSS89] 10.3.2
Reference: [Zad84] <author> F. K. Zadeck. </author> <title> Incremental data flow analysis in a structured program editor. </title> <booktitle> In Proceedings of the ACM SIGPLAN '84 Symposium on Compiler Construction, </booktitle> <pages> pages 132-143, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: Lemma 76 The total time for solution of a D SigCnt lattice problem using Tarjan's path expression algorithm is O (jN j 2 jSigsj) in the worst case. Proof: Direct from Lemmas 13, 71, 73 and 74. 2 A similar node-splitting operation is used by Zadeck <ref> [Zad84] </ref> to prove that a class of lattice frameworks O (jN j + jEj), assuming that the time to perform a meet operation is constant.

References-found: 95

