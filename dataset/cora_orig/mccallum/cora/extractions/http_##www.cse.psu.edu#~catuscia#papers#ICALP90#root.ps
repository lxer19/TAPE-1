URL: http://www.cse.psu.edu/~catuscia/papers/ICALP90/root.ps
Refering-URL: http://www.cse.psu.edu/~catuscia/publications.html
Root-URL: http://www.cse.psu.edu
Title: Algebraic Properties of Idempotent Substitutions  
Author: Catuscia Palamidessi 
Date: October 29, 1996  
Address: Corso Italia 40, 56125 Pisa, Italy  
Affiliation: Dipartimento di Informatica, Universita di Pisa,  
Abstract: This paper presents an algebra of idempotent substitutions whose operations have many properties. We provide an algorithm to compute these operations and we show how they are related to the standard composition. The theory of Logic Programming can be rewritten in terms of these new operations. The advantages are that both the operational and the declarative semantics of Horn Clause Logic can be formalized in a compositional way and the proofs of standard results, like the switching lemma, get easier and more intuitive. Moreover, this formalization can be naturally extended to a parallel computational model, and therefore it can be regarded as a basis for a theory of concurrent logic programming. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. Apt. </author> <title> Introduction to logic programming (revised and extended version). </title> <type> Technical Report CS-R8826, </type> <institution> Centre for Mathematics and Computer Science, </institution> <address> Amsterdam, </address> <year> 1988. </year> <note> To appear as a chapter in Handbook of Theoretical Computer Science, </note> <editor> North-Holland (J. van Leeuwen, </editor> <publisher> editor). </publisher>
Reference-contexts: 1 Introduction. A nice aspects of logic programming <ref> [1] </ref>, [18] is to be based on a rigorous mathematical theory: the Horn Clause Logic (HCL). A critical aspects is that this mathematical framework makes an extensive use of the notion of substitution. <p> We will use (mainly) the terminology of <ref> [1] </ref>, [18], [17], and [6], to which we refer for a more detailed presentation of these topics. 2.1 Substitutions Let Var be a non empty set of variables, with typical elements x; y; z; : : :. <p> In this paper we will use this notion of renaming, that has been introduced in [6], and corresponds to what is called permutation of variables in [17]. The definitions of renaming given in <ref> [1] </ref> and [18] are slightly different. A substitution # is more general than # 0 , # # 0 , iff there exists oe such that #oe = # 0 . The associated equivalence relation will be denoted by . <p> Subst = (the set of the equivalence classes of Subst w.r.t. ), that will still be denoted by . 2.2 Unification The notion of unification can be given, equivalently, either with respect to a set of sets of terms [6], [18], or with respect to a set of equations [17], <ref> [1] </ref>. We choose the second approach. 4 An equation is an expression of the form t = u, where t and u are terms. <p> Let first briefly recall some basic notions about HCL. We refer to <ref> [1] </ref>, [18] for a detailed introduction to it. Let Pred be a set of predicates, with typical elements p; q; r; : : :.
Reference: [2] <author> J. de Bakker and J. Kok. </author> <title> Uniform abstraction, atomicity and contractions in the comparative semantics of Concurrent Prolog. </title> <booktitle> In Proc. of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 347-355, </pages> <address> Tokyo, Japan, </address> <year> 1988. </year> <note> OHMSHA, LTD. Extended Abstract, full version available as CWI report CS-8834. To appear on Theoretical Computer Science. </note>
Reference-contexts: If we look now to the whole goal G, its intended semantics should contain # 2 oe = fx=a; y=a; z=ag, but not # 1 oe = fx=y; z=yg. The problem of compositionality in the semantics of concurrent logic languages has been addressed in [16], <ref> [2] </ref>, [20], [3], [4], [11]. An approach to solve this problem is to replace the notion of substitution by the one of equation set.
Reference: [3] <author> F. de Boer, J. Kok, C. Palamidessi, and J. Rutten. </author> <title> Control flow versus logic: a denotational and a declarative model for Guarded Horn Clauses. </title> <editor> In A. Kreczmar and G. Mirkowska, editors, </editor> <booktitle> Proc. of the Symposium on Mathematical Foundations of Computer Science, volume 379 of Lecture Notes in Computer Science, </booktitle> <pages> pages 165-176. </pages> <publisher> Springer Verlag, </publisher> <year> 1989. </year>
Reference-contexts: If we look now to the whole goal G, its intended semantics should contain # 2 oe = fx=a; y=a; z=ag, but not # 1 oe = fx=y; z=yg. The problem of compositionality in the semantics of concurrent logic languages has been addressed in [16], [2], [20], <ref> [3] </ref>, [4], [11]. An approach to solve this problem is to replace the notion of substitution by the one of equation set. <p> An other algorithm ("reconciliation"), presented in [13], is based on the correspondence between the poset of substitutions and the poset of terms. The algorithm we present has been introduced and used in [20], <ref> [3] </ref>, [4], [5] to define an operator (the parallel composition) suitable to describe in a compositional way the semantics of languages based on HCL. What was still missing there was the relation between this operator and the least upper bound, and the formalization of its properties.
Reference: [4] <author> F. de Boer, J. Kok, C. Palamidessi, and J. Rutten. </author> <title> Semantic models for a version of PARLOG. </title> <editor> In G. Levi and M. Martelli, editors, </editor> <booktitle> Proc. of the Sixth International Conference on Logic Programming, </booktitle> <pages> pages 621-636, </pages> <address> Lisboa, </address> <year> 1989. </year> <note> MIT Press. Extended version to appear in Theoretical Computer Science. </note>
Reference-contexts: If we look now to the whole goal G, its intended semantics should contain # 2 oe = fx=a; y=a; z=ag, but not # 1 oe = fx=y; z=yg. The problem of compositionality in the semantics of concurrent logic languages has been addressed in [16], [2], [20], [3], <ref> [4] </ref>, [11]. An approach to solve this problem is to replace the notion of substitution by the one of equation set. <p> An other algorithm ("reconciliation"), presented in [13], is based on the correspondence between the poset of substitutions and the poset of terms. The algorithm we present has been introduced and used in [20], [3], <ref> [4] </ref>, [5] to define an operator (the parallel composition) suitable to describe in a compositional way the semantics of languages based on HCL. What was still missing there was the relation between this operator and the least upper bound, and the formalization of its properties.
Reference: [5] <author> F. de Boer, J. Kok, C. Palamidessi, and J. Rutten. </author> <title> From failure to success: Comparing a denotational and a declarative semantics for Horn Clause Logic. </title> <booktitle> In Proc. of the International Workshop on Semantics for Concurrency, Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Another point on which the notion of composition results to be inadequate is related to the problem of describing the semantics of HCL in a compositional way, i.e. such that the meaning of a construct is a function of the meanings of its components (see <ref> [5] </ref>). Such a function cannot be based on the notion composition. Consider, for instance, the substitutions # 1 = fx=y; z=yg and # 2 = fx=z; y=zg. <p> An other algorithm ("reconciliation"), presented in [13], is based on the correspondence between the poset of substitutions and the poset of terms. The algorithm we present has been introduced and used in [20], [3], [4], <ref> [5] </ref> to define an operator (the parallel composition) suitable to describe in a compositional way the semantics of languages based on HCL. What was still missing there was the relation between this operator and the least upper bound, and the formalization of its properties. <p> : : : # n : The operational semantics of a goal G in a program W is defined by the set (not ground success set) O (G) = f# j G 7! fl 2g 6.1.1 Compositionality We give now a compositional characterization of the operational semantics of HCL, following <ref> [5] </ref>. <p> 2fi 2 # 1 " # 2 if it is different from fo g ; otherwise We have then O 0 ( A 1 ; A 2 ) = O 0 ( A 1 ) " O 0 ( A 2 ) (4) For the proof of (4) we refer <ref> [5] </ref>. We now prove that this new semantics exactly corresponds to the standard one. For a different proof, more complicate but much more general, because it deals also with the finite failure and the infinite failure sets, we refer again [5]. <p> 2 ) (4) For the proof of (4) we refer <ref> [5] </ref>. We now prove that this new semantics exactly corresponds to the standard one. For a different proof, more complicate but much more general, because it deals also with the finite failure and the infinite failure sets, we refer again [5]. Observe that in the definition of O 0 we don't make use of the standard notion of composition. This justifies the assertion, made in the introduction, that we can redefine the whole theory of logic programming without this operator.
Reference: [6] <author> E. Eder. </author> <title> Properties of substitutions and unifications. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 1 </volume> <pages> 31-46, </pages> <year> 1985. </year>
Reference-contexts: The natural solution is to get back to the notion of substitution, that represents, in a sense, the solved form of a set of equations, and gives the intermediate results in an explicit form. Our approach is based on the lattice of idempotent substitutions firstly introduced by Eder <ref> [6] </ref>. It turns out that this structure is very similar to the one based 2 on equations, investigated in [17]. Actually, the two structures are isomorphic, apart from some particular cases. <p> An algorithm to compute the least upper bound has been informally described by Eder <ref> [6] </ref>, but it still makes use of the notion of standard composition. An other algorithm ("reconciliation"), presented in [13], is based on the correspondence between the poset of substitutions and the poset of terms. <p> We will use (mainly) the terminology of [1], [18], [17], and <ref> [6] </ref>, to which we refer for a more detailed presentation of these topics. 2.1 Substitutions Let Var be a non empty set of variables, with typical elements x; y; z; : : :. <p> Equivalently, ae is a renaming iff there exists its inverse, i.e. a substitution ae 1 such that aeae 1 = ae 1 ae = *. In this paper we will use this notion of renaming, that has been introduced in <ref> [6] </ref>, and corresponds to what is called permutation of variables in [17]. The definitions of renaming given in [1] and [18] are slightly different. A substitution # is more general than # 0 , # # 0 , iff there exists oe such that #oe = # 0 . <p> reflexive and transitive relation) and it induces a partial ordering on Subst = (the set of the equivalence classes of Subst w.r.t. ), that will still be denoted by . 2.2 Unification The notion of unification can be given, equivalently, either with respect to a set of sets of terms <ref> [6] </ref>, [18], or with respect to a set of equations [17], [1]. We choose the second approach. 4 An equation is an expression of the form t = u, where t and u are terms. <p> In particular, the composition of substitutions is not commutative and it is not compatible with the equivalence relation (i.e., there exist #; # 0 ; oe such that # # 0 but #oe 6 # 0 oe, cfr. remark 2.4 in <ref> [6] </ref>). Moreover, there exist sets of (classes of) substitutions that are bounded from above but have no least upper bound (cfr. example 2.7 in [6]). On the contrary, the set of idempotent substitutions ISubst = can be provided with operations having elegant and useful properties. <p> the equivalence relation (i.e., there exist #; # 0 ; oe such that # # 0 but #oe 6 # 0 oe, cfr. remark 2.4 in <ref> [6] </ref>). Moreover, there exist sets of (classes of) substitutions that are bounded from above but have no least upper bound (cfr. example 2.7 in [6]). On the contrary, the set of idempotent substitutions ISubst = can be provided with operations having elegant and useful properties. In particular, (ISubst = ; ) can be embedded into a complete lattice [6]. <p> substitutions that are bounded from above but have no least upper bound (cfr. example 2.7 in <ref> [6] </ref>). On the contrary, the set of idempotent substitutions ISubst = can be provided with operations having elegant and useful properties. In particular, (ISubst = ; ) can be embedded into a complete lattice [6]. For the sake of uniformity we give here a definition that is slightly different from the original one, but equivalent to it. Definition 3.1 Let o be an arbitrary object that is not an element of ISubst . Let ISubst o be the set ISubst [fo g. <p> We extend the partial ordering and the equivalence to ISubst o by requiring o to be the greatest element of ISubst o . We denote by ISubst o = the new quotient set and by # the equivalence class in which # lies. Theorem 3.2 (Eder, <ref> [6] </ref>) (ISubst o = ; ) is a complete lattice, i.e. every subset of ISubst o = has a lub (least upper bound) and a glb (greatest lower bound). The smallest element is * and the greatest element is o . <p> The smallest element is * and the greatest element is o . Remark 3.3 Here we have followed the original presentation of <ref> [6] </ref>, but in order to get a complete lattice it is not always necessary to add an external element. More precisely, it is not necessary when Var is finite and the Herbrand universe is trivial, i.e. it contains only an element, say a. <p> The operations of lub and glb are both computable in finite time, when performed on finite sets 2 . In the following sections we give the algorithms to compute them and we prove their correctness. Eder <ref> [6] </ref> has already presented a way to determine the lub. Namely, lub (#; oe) can be obtained as the composition of # and the mgu of the set fx# = t# j x=t 2 oeg. <p> By proposition 3.7 we have that # 2 unif (E (# 1 )) and # 2 unif (E (# 2 )). Therefore # 2 unif (E (# 1 " # 2 )). 2 20 Note that the definition given by Eder <ref> [6] </ref> for the least upper bound is just lub (# 2 ) = # 1 mgu (E (# 2 )# 1 ). Therefore this proposition, together with proposi tion 4.2, shows the correctness of his definition.
Reference: [7] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> A new declarative semantics for logic languages. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. of the Fifth International Conference on Logic Programming, Series in Logic Programming, </booktitle> <pages> pages 993-1005, </pages> <address> Seattle, USA, 1988. </address> <publisher> MIT press, </publisher> <address> Cambridge, Mass. </address>
Reference-contexts: A critical aspects is that this mathematical framework makes an extensive use of the notion of substitution. The standard operational semantics of HCL [23], and also some recent approaches to the declarative semantics <ref> [7] </ref>, [8] are based on this notion. People working in the theory of logic programming usually notice that the substitutions are a quite hard matter to deal with. In particular, it is problematic to deal with the only operation available on substitutions, the composition.
Reference: [8] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative modeling of the operational behaviour of logic languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year>
Reference-contexts: A critical aspects is that this mathematical framework makes an extensive use of the notion of substitution. The standard operational semantics of HCL [23], and also some recent approaches to the declarative semantics [7], <ref> [8] </ref> are based on this notion. People working in the theory of logic programming usually notice that the substitutions are a quite hard matter to deal with. In particular, it is problematic to deal with the only operation available on substitutions, the composition.
Reference: [9] <author> M. Gabbrielli and G. Levi. </author> <title> An unfolding reactive semantics for concurrent constraint programming. </title> <type> Technical Report TR ../90, </type> <institution> Dipartimento di Informatica, Universita di Pisa, Pisa, </institution> <year> 1990. </year>
Reference-contexts: Moreover, it can be generalized to the theory of Constraint Logic Programming, see [14]. Finally, when applied to Concurrent Logic Languages, it allows to use an uniform concept of guard [19], [21], [22], [10], <ref> [9] </ref>. The main disadvantage is that we have, at each step, only an implicit notion of result, in terms of an equation set, and this can lead to useless computations if the consistency check is done only at the end (of the computation).
Reference: [10] <author> H. Gaifman, M. J. Maher, and E. Shapiro. </author> <title> Reactive Behaviour semantics for Concurrent Constraint Logic Programs. </title> <editor> In E. Lusk and R. Overbeck, editors, </editor> <booktitle> North American Conference on Logic Programming, </booktitle> <year> 1989. </year>
Reference-contexts: Moreover, it can be generalized to the theory of Constraint Logic Programming, see [14]. Finally, when applied to Concurrent Logic Languages, it allows to use an uniform concept of guard [19], [21], [22], <ref> [10] </ref>, [9]. The main disadvantage is that we have, at each step, only an implicit notion of result, in terms of an equation set, and this can lead to useless computations if the consistency check is done only at the end (of the computation).
Reference: [11] <author> R. Gerth, M. Codish, Y. Lichtenstein, and E. Shapiro. </author> <title> Fully abstract denota-tional semantics for Concurrent Prolog. </title> <booktitle> In Proc. of the Third IEEE Symposium on Logic In Computer Science, </booktitle> <pages> pages 320-335. </pages> <publisher> IEEE Computer Society Press, </publisher> <address> New York, </address> <year> 1988. </year> <month> 23 </month>
Reference-contexts: If we look now to the whole goal G, its intended semantics should contain # 2 oe = fx=a; y=a; z=ag, but not # 1 oe = fx=y; z=yg. The problem of compositionality in the semantics of concurrent logic languages has been addressed in [16], [2], [20], [3], [4], <ref> [11] </ref>. An approach to solve this problem is to replace the notion of substitution by the one of equation set.
Reference: [12] <author> G. Huet. </author> <title> Resolution d'Equations dans des Langages d'Order 1, </title> <type> 2,: : : ,!. PhD thesis, </type> <institution> Univ. Paris VII, </institution> <year> 1976. </year>
Reference-contexts: Namely, we could transform the substitutions into sets of equations, compute their more specific generalization, and transform again the equation set obtained so far into its solved form. This algorithm is based on the Huet's algorithm for anti-unification <ref> [12] </ref>, that usually introduces extra-variables, which have to be dropped again afterwards. We give a direct algorithm that does not require any transformation into equational form, and no introduction of extra-variables. <p> We will give a constructive definition of #, i.e. via an algorithm. Actually, an algorithm to compute the greatest lower bound of equation sets, w.r.t. , has been already defined in [17] (cfr. the generalization algorithm). Their method is based on the anti-unification algorithm of Huet <ref> [12] </ref>, and it works in the following way.
Reference: [13] <author> J.-M. Jacquet. Conclog: </author> <title> a Methodological Approach to Concurrent Logic Programming. </title> <type> PhD thesis, </type> <institution> Facultes Universitaires Notre-Dame de la Paix, University of Namur, Belgium, </institution> <year> 1989. </year>
Reference-contexts: An algorithm to compute the least upper bound has been informally described by Eder [6], but it still makes use of the notion of standard composition. An other algorithm ("reconciliation"), presented in <ref> [13] </ref>, is based on the correspondence between the poset of substitutions and the poset of terms. <p> What was still missing there was the relation between this operator and the least upper bound, and the formalization of its properties. The same algorithm was also introduced independently in <ref> [13] </ref> as an alternative way to compute the "reconciliation". Regarding to the greatest lower bound, it could be computed by using the algorithm described in [17] to generate the more specific generalization of a set of sets of equations. <p> fi 2 , we have # 2 " (# (fi 0 1 )) = o then (by the weak distributivity) it is useless to compare # 2 with the single elements of fi 0 1 . (A similar method to speed up the detection of inconsistencies has been proposed in <ref> [13] </ref>.) If, on the other side, # 2 " (# (fi 0 1 )) = 6= o , then we can use the side substitutions of theorem 5.10 to compute the real results.
Reference: [14] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In 14th ACM Principles of Programming Languages Conference, </booktitle> <pages> pages 111-119, </pages> <address> Munich, F.R.G., 1987. </address> <publisher> ACM, </publisher> <address> New York. </address>
Reference-contexts: A nice theory for equation syntactic unification has been developed in [17]. This approach presents the advantage of being elegantly extendible to Equational+Logic programming (namely, HCL plus some equational theory), see [15]. Moreover, it can be generalized to the theory of Constraint Logic Programming, see <ref> [14] </ref>. Finally, when applied to Concurrent Logic Languages, it allows to use an uniform concept of guard [19], [21], [22], [10], [9].
Reference: [15] <author> J. Jaffar, J.-L. Lassez, and M. Maher. </author> <title> A logic programming language scheme. </title> <editor> In D. de Groot and G. Lindstrom, editors, </editor> <booktitle> Logic Programming, Functions, Relations and Equations, </booktitle> <pages> pages 441-468. </pages> <publisher> Prentice Hall, </publisher> <year> 1986. </year>
Reference-contexts: A nice theory for equation syntactic unification has been developed in [17]. This approach presents the advantage of being elegantly extendible to Equational+Logic programming (namely, HCL plus some equational theory), see <ref> [15] </ref>. Moreover, it can be generalized to the theory of Constraint Logic Programming, see [14]. Finally, when applied to Concurrent Logic Languages, it allows to use an uniform concept of guard [19], [21], [22], [10], [9].
Reference: [16] <author> J. Kok. </author> <title> A compositional semantics for Concurrent Prolog. </title> <editor> In R. Cori and M. Wirsing, editors, </editor> <booktitle> Proc. Fifth Symposium on Theoretical Aspects of Computer Science, volume 294 of Lecture Notes in Computer Science, </booktitle> <pages> pages 373-388. </pages> <publisher> Springer Verlag, </publisher> <year> 1988. </year>
Reference-contexts: If we look now to the whole goal G, its intended semantics should contain # 2 oe = fx=a; y=a; z=ag, but not # 1 oe = fx=y; z=yg. The problem of compositionality in the semantics of concurrent logic languages has been addressed in <ref> [16] </ref>, [2], [20], [3], [4], [11]. An approach to solve this problem is to replace the notion of substitution by the one of equation set.
Reference: [17] <author> J. L. Lassez, M. J. Maher, and K. Marriot. </author> <title> Unification Revisited. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming. </booktitle> <publisher> Morgann Kaufmann, </publisher> <address> Los Altos, </address> <year> 1988. </year>
Reference-contexts: A nice theory for equation syntactic unification has been developed in <ref> [17] </ref>. This approach presents the advantage of being elegantly extendible to Equational+Logic programming (namely, HCL plus some equational theory), see [15]. Moreover, it can be generalized to the theory of Constraint Logic Programming, see [14]. <p> Our approach is based on the lattice of idempotent substitutions firstly introduced by Eder [6]. It turns out that this structure is very similar to the one based 2 on equations, investigated in <ref> [17] </ref>. Actually, the two structures are isomorphic, apart from some particular cases. In this paper we investigate a new lattice of equations, that is always isomorphic to the lattice of idempotent substitutions, and it is more suitable for the semantics of logic programming. <p> The same algorithm was also introduced independently in [13] as an alternative way to compute the "reconciliation". Regarding to the greatest lower bound, it could be computed by using the algorithm described in <ref> [17] </ref> to generate the more specific generalization of a set of sets of equations. Namely, we could transform the substitutions into sets of equations, compute their more specific generalization, and transform again the equation set obtained so far into its solved form. <p> We will use (mainly) the terminology of [1], [18], <ref> [17] </ref>, and [6], to which we refer for a more detailed presentation of these topics. 2.1 Substitutions Let Var be a non empty set of variables, with typical elements x; y; z; : : :. <p> In this paper we will use this notion of renaming, that has been introduced in [6], and corresponds to what is called permutation of variables in <ref> [17] </ref>. The definitions of renaming given in [1] and [18] are slightly different. A substitution # is more general than # 0 , # # 0 , iff there exists oe such that #oe = # 0 . The associated equivalence relation will be denoted by . <p> on Subst = (the set of the equivalence classes of Subst w.r.t. ), that will still be denoted by . 2.2 Unification The notion of unification can be given, equivalently, either with respect to a set of sets of terms [6], [18], or with respect to a set of equations <ref> [17] </ref>, [1]. We choose the second approach. 4 An equation is an expression of the form t = u, where t and u are terms. <p> In the following, in this special case, we consider o to be defined as fx=a j x 2 Varg 2 ISubst . There is a close relation between (ISubst o = ; ) and the complete lattice of equations sets introduced in <ref> [17] </ref>. Actually, the two structures are isomorphic. The results showed in the next section can be considered immediate consequences of properties investigated in [17], but some of our proofs are simpler. <p> There is a close relation between (ISubst o = ; ) and the complete lattice of equations sets introduced in <ref> [17] </ref>. Actually, the two structures are isomorphic. The results showed in the next section can be considered immediate consequences of properties investigated in [17], but some of our proofs are simpler. Indeed, we deal directly with the unifiers of equations sets, instead of their solutions (ground unifiers), as it is done in [17]. This allows to obtain a more immediate correspondence between equations sets and idempotent substitutions. <p> The results showed in the next section can be considered immediate consequences of properties investigated in <ref> [17] </ref>, but some of our proofs are simpler. Indeed, we deal directly with the unifiers of equations sets, instead of their solutions (ground unifiers), as it is done in [17]. This allows to obtain a more immediate correspondence between equations sets and idempotent substitutions. Moreover, we get an isomorphism res ult that holds in general, thus extending the isomorphism result stated in [17]. <p> with the unifiers of equations sets, instead of their solutions (ground unifiers), as it is done in <ref> [17] </ref>. This allows to obtain a more immediate correspondence between equations sets and idempotent substitutions. Moreover, we get an isomorphism res ult that holds in general, thus extending the isomorphism result stated in [17]. This last one indeed does not hold when the Herbrand universe is trivial. 3.1 Idempotent substitutions and equation sets Each substitution # "naturally" corresponds to a set of equations given by E (#) = fx = t j x=t 2 #g. <p> # = # 1 # 1 oe# = (by idempotency of # 1 ) # 1 oe# = # 2 # = (by proposition 3.4, only if part) # therefore (by proposition 3.4, if part), # 2 unif (E (# 1 )) holds. 2 Definition 3.8 (Lassez, Maher, and Marriot, <ref> [17] </ref>) The set of solutions of an equation set E, soln (E), is the set of all the ground unifiers of E. 6 This notion of soln (E) is used in [17] in order to define the complete lattice of equation sets. <p> proposition 3.4, if part), # 2 unif (E (# 1 )) holds. 2 Definition 3.8 (Lassez, Maher, and Marriot, <ref> [17] </ref>) The set of solutions of an equation set E, soln (E), is the set of all the ground unifiers of E. 6 This notion of soln (E) is used in [17] in order to define the complete lattice of equation sets. For the sake of uniformity, we will use a terminology different from the original one. <p> Therefore, it induces an equivalence relation that we denote by , and a partial ordering, on the quotient set, that we still represent by . The equivalence class of E will be denoted by E . Theorem 3.9 (Lassez, Maher, and Marriot, <ref> [17] </ref>) (Eqn = ; ) is a complete lattice where the lub of fE 1 ; : : : ; E n ; : : :g is given by (E 1 [ : : : E n [ : : :) . <p> The following theorem states the isomorphism between the lattice (ISubst o = ; ) and the lattice (Eqn = ; ). This property extends the one stated in <ref> [17] </ref>, concerning the isomorphism between (ISubst o = ; ) and (Eqn = ; ). Indeed, the second one does not hold when the Herbrand universe is trivial. Note that in [17] this correspondence is shown by making use of the following property (cfr. theorem 6 in [17]) # 2 mgu <p> This property extends the one stated in <ref> [17] </ref>, concerning the isomorphism between (ISubst o = ; ) and (Eqn = ; ). Indeed, the second one does not hold when the Herbrand universe is trivial. Note that in [17] this correspondence is shown by making use of the following property (cfr. theorem 6 in [17]) # 2 mgu (E) iff E (#) E that does not hold in the trivial case. Example 3.14 will provide a counterexample to it. <p> one stated in <ref> [17] </ref>, concerning the isomorphism between (ISubst o = ; ) and (Eqn = ; ). Indeed, the second one does not hold when the Herbrand universe is trivial. Note that in [17] this correspondence is shown by making use of the following property (cfr. theorem 6 in [17]) # 2 mgu (E) iff E (#) E that does not hold in the trivial case. Example 3.14 will provide a counterexample to it. <p> Consider the equation set E = ;. We have soln (# 5 ) = f# 5 g = soln (E), whilst # 5 62 mgu (E) = f*g. This is a counterexample to theorem 6 in <ref> [17] </ref>. More in general, the equations sets are all equivalent with respect to . In fact, f# 5 g is 9 the only possible solution set and it is not possible to build an equation set without solutions. Thus, Eqn = contains only one element. <p> This can be derived from an analogous result concerning anti-unification of terms (cfr. proposition 18 in <ref> [17] </ref>). However, although very interesting, this topic is out of the scope of this paper. 3 This remark, and the following example, are due to Jean-Marie Jacquet. 10 answer substitutions # 1 and # 2 have to be combined, afterwards, in order to get the final result. <p> We will give a constructive definition of #, i.e. via an algorithm. Actually, an algorithm to compute the greatest lower bound of equation sets, w.r.t. , has been already defined in <ref> [17] </ref> (cfr. the generalization algorithm). Their method is based on the anti-unification algorithm of Huet [12], and it works in the following way.
Reference: [18] <author> J. Lloyd. </author> <title> Foundations of logic programming. </title> <publisher> Springer-Verlag, </publisher> <address> second edition, </address> <year> 1987. </year>
Reference-contexts: 1 Introduction. A nice aspects of logic programming [1], <ref> [18] </ref> is to be based on a rigorous mathematical theory: the Horn Clause Logic (HCL). A critical aspects is that this mathematical framework makes an extensive use of the notion of substitution. <p> We will use (mainly) the terminology of [1], <ref> [18] </ref>, [17], and [6], to which we refer for a more detailed presentation of these topics. 2.1 Substitutions Let Var be a non empty set of variables, with typical elements x; y; z; : : :. <p> In this paper we will use this notion of renaming, that has been introduced in [6], and corresponds to what is called permutation of variables in [17]. The definitions of renaming given in [1] and <ref> [18] </ref> are slightly different. A substitution # is more general than # 0 , # # 0 , iff there exists oe such that #oe = # 0 . The associated equivalence relation will be denoted by . <p> and transitive relation) and it induces a partial ordering on Subst = (the set of the equivalence classes of Subst w.r.t. ), that will still be denoted by . 2.2 Unification The notion of unification can be given, equivalently, either with respect to a set of sets of terms [6], <ref> [18] </ref>, or with respect to a set of equations [17], [1]. We choose the second approach. 4 An equation is an expression of the form t = u, where t and u are terms. <p> Let first briefly recall some basic notions about HCL. We refer to [1], <ref> [18] </ref> for a detailed introduction to it. Let Pred be a set of predicates, with typical elements p; q; r; : : :. <p> We give here an example. Example 6.3 (Switching lemma) The property stated by the switching lemma (cfr. lemma 9.1 in <ref> [18] </ref>) is the following: Assume A 1 ; A 2 7! ( B 1 ; A 2 )# 0 with H 1 B 1 2 W (renamed); # 0 2 mgu (A 1 = H 1 ) # 00 7! ( B 1 ; B 2 )# 0 # 00 with
Reference: [19] <author> M. J. Maher. </author> <title> Logic semantics for a class of committed-choice programs. </title> <editor> In J.-L. Lassez, editor, </editor> <booktitle> Proc. of the Fourth International Conference on Logic Programming, Series in Logic Programming, </booktitle> <pages> pages 858-876, </pages> <address> Melbourne, 1987. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Moreover, it can be generalized to the theory of Constraint Logic Programming, see [14]. Finally, when applied to Concurrent Logic Languages, it allows to use an uniform concept of guard <ref> [19] </ref>, [21], [22], [10], [9]. The main disadvantage is that we have, at each step, only an implicit notion of result, in terms of an equation set, and this can lead to useless computations if the consistency check is done only at the end (of the computation).
Reference: [20] <author> C. Palamidessi. </author> <title> A fixpoint semantics for Guarded Horn Clauses. </title> <type> Technical Report CS-R8833, </type> <institution> Centre for Mathematics and Computer Science, </institution> <address> Amsterdam, </address> <year> 1988. </year>
Reference-contexts: If we look now to the whole goal G, its intended semantics should contain # 2 oe = fx=a; y=a; z=ag, but not # 1 oe = fx=y; z=yg. The problem of compositionality in the semantics of concurrent logic languages has been addressed in [16], [2], <ref> [20] </ref>, [3], [4], [11]. An approach to solve this problem is to replace the notion of substitution by the one of equation set. <p> An other algorithm ("reconciliation"), presented in [13], is based on the correspondence between the poset of substitutions and the poset of terms. The algorithm we present has been introduced and used in <ref> [20] </ref>, [3], [4], [5] to define an operator (the parallel composition) suitable to describe in a compositional way the semantics of languages based on HCL. What was still missing there was the relation between this operator and the least upper bound, and the formalization of its properties.
Reference: [21] <author> V. Saraswat. </author> <title> Concurrent Constraint Programming Languages. </title> <type> PhD thesis, </type> <month> january </month> <year> 1989. </year> <note> To be published by the MIT Press. </note>
Reference-contexts: Moreover, it can be generalized to the theory of Constraint Logic Programming, see [14]. Finally, when applied to Concurrent Logic Languages, it allows to use an uniform concept of guard [19], <ref> [21] </ref>, [22], [10], [9]. The main disadvantage is that we have, at each step, only an implicit notion of result, in terms of an equation set, and this can lead to useless computations if the consistency check is done only at the end (of the computation).
Reference: [22] <author> V. Saraswat and M. Rinard. </author> <title> Concurrent constraint programming. </title> <booktitle> In Conference Record of the Annual ACM Symposium on Principles of Programming Languages. ACM, </booktitle> <address> New York, </address> <year> 1990. </year>
Reference-contexts: Moreover, it can be generalized to the theory of Constraint Logic Programming, see [14]. Finally, when applied to Concurrent Logic Languages, it allows to use an uniform concept of guard [19], [21], <ref> [22] </ref>, [10], [9]. The main disadvantage is that we have, at each step, only an implicit notion of result, in terms of an equation set, and this can lead to useless computations if the consistency check is done only at the end (of the computation).
Reference: [23] <author> M. van Emden and R. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year> <month> 24 </month>
Reference-contexts: 1 Introduction. A nice aspects of logic programming [1], [18] is to be based on a rigorous mathematical theory: the Horn Clause Logic (HCL). A critical aspects is that this mathematical framework makes an extensive use of the notion of substitution. The standard operational semantics of HCL <ref> [23] </ref>, and also some recent approaches to the declarative semantics [7], [8] are based on this notion. People working in the theory of logic programming usually notice that the substitutions are a quite hard matter to deal with.
References-found: 23

