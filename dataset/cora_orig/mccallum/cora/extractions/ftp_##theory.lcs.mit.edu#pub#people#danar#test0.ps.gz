URL: ftp://theory.lcs.mit.edu/pub/people/danar/test0.ps.gz
Refering-URL: http://theory.lcs.mit.edu/~danar/ggr.html
Root-URL: 
Title: Property Testing and its connection to Learning and Approximation  
Author: Oded Goldreich Shafi Goldwasser Dana Ron 
Abstract: We study the question of determining whether an unknown function has a particular property or is *-far from any function with that property. A property testing algorithm is given a sample of the value of the function on instances drawn according to some distribution, and possibly may query the function on instances of its choice. First, we establish some connections between property testing and problems in learning theory. Next, we focus on testing graph properties, and devise algorithms to test whether a graph has properties such as being k-colorable or having a -clique (clique of density w.r.t the vertex set). Our graph property testing algorithms are probabilistic and make assertions which are correct with high probability, utilizing only poly(1=*) edge-queries into the graph, where * is the distance parameter. Moreover, the property testing algorithms can be used to efficiently (i.e., in time linear in the number of vertices) construct partitions of the graph which correspond to the property being tested, if it holds for the input graph. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> N. Alon, R. A. Duke, H. Lefmann, V. Rodl, and R. Yuster. </author> <title> The algorithmic aspects of the regularity lemma. </title> <journal> Journal of Algorithms, </journal> <volume> 16 </volume> <pages> 80-109, </pages> <year> 1994. </year>
Reference-contexts: All other algorithms have two-sided error, and this is unavoidable within o (N ) query complexity. * Our algorithms for k-Colorability, -Clique and -Cut can be easily extended to provide testers with respect to product distributions: that is, distributions : V (G) 2 7! <ref> [0; 1] </ref> of the form (u; v) = (u) (v), where : V (G) 7! [0; 1] is a distribution on the vertices. In contrast, it is not possible to test any of the graph properties discussed above in a distribution-free manner. GENERAL GRAPH PARTITION. <p> unavoidable within o (N ) query complexity. * Our algorithms for k-Colorability, -Clique and -Cut can be easily extended to provide testers with respect to product distributions: that is, distributions : V (G) 2 7! <ref> [0; 1] </ref> of the form (u; v) = (u) (v), where : V (G) 7! [0; 1] is a distribution on the vertices. In contrast, it is not possible to test any of the graph properties discussed above in a distribution-free manner. GENERAL GRAPH PARTITION. <p> We do not know whether the same is true with respect to the algorithms in [3]. Results on testing graph properties can be derived also from work by Alon et. al. <ref> [1] </ref>. <p> In comparison with our k-Colorability Tester, which takes a sample of O (k 2 log k=* 3 ) vertices, the k-colorability tester derived (from <ref> [1] </ref>) takes a much bigger sample of size equaling a tower of (k=*) 20 exponents (i.e., log fl A DIFFERENT NOTION OF APPROXIMATION FOR MAX-CLIQUE. Our notion of -Clique Testing differs from the traditional notion of Max-Clique Approximation. <p> TESTING GRAPH PROPERTIES. Our notion of testing a graph property P is a relaxation of the notion of deciding the graph 2 As noted by Noga Alon, similar results, alas with much worse dependence on *, can be obtained by using the results of Alon et. al. <ref> [1] </ref>. property P which has received much attention in the last two decades [29]. In the classical problem there are no margins of error, and one is required to accept all graphs having property P and reject all graphs which lack it. <p> Following the approach of Alon et. al. <ref> [1] </ref>, but using a modification of the regularity Lemma (and thus obtaining much improved running times), Frieze and Kannan [20] devise PTAS for several graph partition problems such as Max-Cut and Bisection. We note that compared to all the above results, our respective graph partitioning algorithms have better running-times.
Reference: [2] <author> S. Arora, A. Frieze, and H. Kaplan. </author> <title> A new rounding procedure for the assignment problem with applications to dense graph arrangement problems. </title> <booktitle> In these proceedings, </booktitle> <year> 1996. </year>
Reference-contexts: We say that a function f defined on f0; 1g n is *-close to F n with respect to D n if there exists a function g 2 F n such that 3 In <ref> [2] </ref>, the approach of [3] is extended to other problems, such as Graph Isomorphism, using a new rounding procedure for the Assignment Problem. 4 The range of these functions may vary and for many of the results and discussions it suffices to consider Boolean function. 4 Prob x~D n [f (x)
Reference: [3] <author> S. Arora, D. Karger, and M Karpinski. </author> <title> Polynomial time approximation schemes for dense instances of NP-hard problems. </title> <booktitle> In 27th STOC, </booktitle> <pages> pages 284-293, </pages> <year> 1995. </year>
Reference-contexts: In case of 2 k-Colorability certain k-colorings of the subgraph induced by this sample will do, and these are found by k-coloring a slightly augmented graph. In the other algorithms we exhaustively try all possible partitions. This is reminiscent of the exhaustive sampling of Arora et. al. <ref> [3] </ref>, except that the partitions considered by us are always directly related to the combinatorial structure of the problem. We show how each possible partition of the sample induces a partition of the entire graph so that the following holds. <p> Thus, for any constant * &gt; 0, we can approximate the size of the max-cut to within *N 2 in constant time. This yields a constant time approxi mation scheme (i.e., to within any constant relative error) for dense graphs, improving on Arora et. al. <ref> [3] </ref> and de la Vega [17] who solved this problem in polynomial-time (O (N 1=* 2 )-time and exp ( ~ O (1=(* 2 )))N 2 -time, respectively). In both works the problem is solved by actually constructing approximate max-cuts. <p> In several cases this is possible. For example, using some ideas from our work, the Max-CUT algorithm of [17] can be transformed into a tester of complexity comparable to ours. We do not know whether the same is true with respect to the algorithms in <ref> [3] </ref>. Results on testing graph properties can be derived also from work by Alon et. al. [1]. <p> Whereas the latter problem is NP-Hard, for 1=64 (see [9, Sec. 3.9]), we've shown that the former problem can be solved in exp (O (1=* 2 ))-time, for any ; * &gt; 0. Furthermore, Arora et. al. <ref> [3] </ref> showed that the dense-subgraph problem, a generalization of -cliqueness, has a polynomial-time approximation scheme (PTAS) for dense instances. TESTING k-COLORABILITY VS. APPROXIMATING k-COLORABILITY. <p> Our results, that some non-trivial monotone graph properties can be tested by examining a constant number of random locations in the matrix, stand in striking contrast to all of the above. APPROXIMATION IN DENSE GRAPHS. As stated previously, Arora et. al. <ref> [3] </ref> and de la Vega [17] presented PTAS for dense instances of Max-CUT. <p> We say that a function f defined on f0; 1g n is *-close to F n with respect to D n if there exists a function g 2 F n such that 3 In [2], the approach of <ref> [3] </ref> is extended to other problems, such as Graph Isomorphism, using a new rounding procedure for the Assignment Problem. 4 The range of these functions may vary and for many of the results and discussions it suffices to consider Boolean function. 4 Prob x~D n [f (x) 6= g (x)] *
Reference: [4] <author> S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy. </author> <title> Proof verification and intractability of approximation problems. </title> <booktitle> In 33rd FOCS, </booktitle> <pages> pages 14-23, </pages> <year> 1992. </year>
Reference-contexts: Specifically, the property tested is being a codeword with respect to a specific code. This paradigm explicitly introduced in [6] has shifted from testing codes defined by low-degree polynomials <ref> [6, 19, 5, 4] </ref> to testing Hadamard codes [4, 10, 11, 8], and recently to testing the long code [9]. PROPERTY TESTING IN THE CONTEXT OF PROGRAM CHECKING: There is an immediate analogy between program self-testing [14] and property-testing with queries. <p> Specifically, the property tested is being a codeword with respect to a specific code. This paradigm explicitly introduced in [6] has shifted from testing codes defined by low-degree polynomials [6, 19, 5, 4] to testing Hadamard codes <ref> [4, 10, 11, 8] </ref>, and recently to testing the long code [9]. PROPERTY TESTING IN THE CONTEXT OF PROGRAM CHECKING: There is an immediate analogy between program self-testing [14] and property-testing with queries.
Reference: [5] <author> S. Arora and S. Safra. </author> <title> Probabilistic checkable proofs: A new characterization of NP. </title> <booktitle> In 33rd FOCS, </booktitle> <pages> pages 1-13, </pages> <year> 1992. </year>
Reference-contexts: Specifically, the property tested is being a codeword with respect to a specific code. This paradigm explicitly introduced in [6] has shifted from testing codes defined by low-degree polynomials <ref> [6, 19, 5, 4] </ref> to testing Hadamard codes [4, 10, 11, 8], and recently to testing the long code [9]. PROPERTY TESTING IN THE CONTEXT OF PROGRAM CHECKING: There is an immediate analogy between program self-testing [14] and property-testing with queries.
Reference: [6] <author> L. Babai, L. Fortnow, L. Levin, and M. Szegedy. </author> <title> Checking computations in polylogarithmic time. </title> <booktitle> In 23nd STOC, </booktitle> <pages> pages 21-31, </pages> <year> 1991. </year>
Reference-contexts: Other Related Work PROPERTY TESTING IN THE CONTEXT OF PCP: Property testing plays a central role in the construction of PCP systems. Specifically, the property tested is being a codeword with respect to a specific code. This paradigm explicitly introduced in <ref> [6] </ref> has shifted from testing codes defined by low-degree polynomials [6, 19, 5, 4] to testing Hadamard codes [4, 10, 11, 8], and recently to testing the long code [9]. <p> Specifically, the property tested is being a codeword with respect to a specific code. This paradigm explicitly introduced in [6] has shifted from testing codes defined by low-degree polynomials <ref> [6, 19, 5, 4] </ref> to testing Hadamard codes [4, 10, 11, 8], and recently to testing the long code [9]. PROPERTY TESTING IN THE CONTEXT OF PROGRAM CHECKING: There is an immediate analogy between program self-testing [14] and property-testing with queries. <p> Invoking known results on linearity testing [14, 7, 19, 10, 11, 8] we conclude that there is a class of 2 n functions which can be tested within query complexity O (log (1=ffi)=*), and yet learning it requires at least n queries. Similarly, using results on low-degree testing <ref> [7, 6, 21, 36] </ref>, there is a class of exp (2 n ) function which can be tested within query complexity O ( * n), and yet learning it requires exp (n) many queries. AGNOSTIC LEARNING AND TESTING.
Reference: [7] <author> L. Babai, L. Fortnow, and C. Lund. </author> <title> Non-deterministic exponential time has two-prover interactive protocols. </title> <journal> Computational Complexity, </journal> <volume> 1(1) </volume> <pages> 3-40, </pages> <year> 1991. </year>
Reference-contexts: The class presented in Proposition 2.5 consists of multi-valued functions. We leave it as an open problem whether a similar result holds for a class of Boolean functions. LEARNING AND TESTING WITH QUERIES (under the uniform distribution). Invoking known results on linearity testing <ref> [14, 7, 19, 10, 11, 8] </ref> we conclude that there is a class of 2 n functions which can be tested within query complexity O (log (1=ffi)=*), and yet learning it requires at least n queries. <p> Invoking known results on linearity testing [14, 7, 19, 10, 11, 8] we conclude that there is a class of 2 n functions which can be tested within query complexity O (log (1=ffi)=*), and yet learning it requires at least n queries. Similarly, using results on low-degree testing <ref> [7, 6, 21, 36] </ref>, there is a class of exp (2 n ) function which can be tested within query complexity O ( * n), and yet learning it requires exp (n) many queries. AGNOSTIC LEARNING AND TESTING.
Reference: [8] <author> M. Bellare, D. Coppersmith, J. Hastad, M. Kiwi, and M. Sudan. </author> <title> Linearity testing in characteristic two. </title> <booktitle> In 36th FOCS, </booktitle> <pages> pages 432-441, </pages> <year> 1995. </year>
Reference-contexts: Specifically, the property tested is being a codeword with respect to a specific code. This paradigm explicitly introduced in [6] has shifted from testing codes defined by low-degree polynomials [6, 19, 5, 4] to testing Hadamard codes <ref> [4, 10, 11, 8] </ref>, and recently to testing the long code [9]. PROPERTY TESTING IN THE CONTEXT OF PROGRAM CHECKING: There is an immediate analogy between program self-testing [14] and property-testing with queries. <p> The class presented in Proposition 2.5 consists of multi-valued functions. We leave it as an open problem whether a similar result holds for a class of Boolean functions. LEARNING AND TESTING WITH QUERIES (under the uniform distribution). Invoking known results on linearity testing <ref> [14, 7, 19, 10, 11, 8] </ref> we conclude that there is a class of 2 n functions which can be tested within query complexity O (log (1=ffi)=*), and yet learning it requires at least n queries.
Reference: [9] <author> M. Bellare, O. Goldreich, and M. Sudan. </author> <title> Free bits, pcps and non-approximability towards tight results. </title> <booktitle> In 36th FOCS, </booktitle> <pages> pages 422-431, </pages> <year> 1995. </year>
Reference-contexts: Whereas the latter problem is NP-Hard, for 1=64 (see <ref> [9, Sec. 3.9] </ref>), we've shown that the former problem can be solved in exp (O (1=* 2 ))-time, for any ; * &gt; 0. Furthermore, Arora et. al. [3] showed that the dense-subgraph problem, a generalization of -cliqueness, has a polynomial-time approximation scheme (PTAS) for dense instances. TESTING k-COLORABILITY VS. <p> Specifically, the property tested is being a codeword with respect to a specific code. This paradigm explicitly introduced in [6] has shifted from testing codes defined by low-degree polynomials [6, 19, 5, 4] to testing Hadamard codes [4, 10, 11, 8], and recently to testing the long code <ref> [9] </ref>. PROPERTY TESTING IN THE CONTEXT OF PROGRAM CHECKING: There is an immediate analogy between program self-testing [14] and property-testing with queries.
Reference: [10] <author> M. Bellare, S. Goldwasser, C. Lund, and A. Russell. </author> <title> Efficient probabilistically checkable proofs and applications to approximation. </title> <booktitle> In 25th STOC, </booktitle> <pages> pages 294-304, </pages> <year> 1993. </year>
Reference-contexts: Specifically, the property tested is being a codeword with respect to a specific code. This paradigm explicitly introduced in [6] has shifted from testing codes defined by low-degree polynomials [6, 19, 5, 4] to testing Hadamard codes <ref> [4, 10, 11, 8] </ref>, and recently to testing the long code [9]. PROPERTY TESTING IN THE CONTEXT OF PROGRAM CHECKING: There is an immediate analogy between program self-testing [14] and property-testing with queries. <p> The class presented in Proposition 2.5 consists of multi-valued functions. We leave it as an open problem whether a similar result holds for a class of Boolean functions. LEARNING AND TESTING WITH QUERIES (under the uniform distribution). Invoking known results on linearity testing <ref> [14, 7, 19, 10, 11, 8] </ref> we conclude that there is a class of 2 n functions which can be tested within query complexity O (log (1=ffi)=*), and yet learning it requires at least n queries.
Reference: [11] <author> M. Bellare and M. Sudan. </author> <title> Improved non-approximability results. </title> <booktitle> In 26th STOC, </booktitle> <pages> pages 184-193, </pages> <year> 1994. </year>
Reference-contexts: Specifically, the property tested is being a codeword with respect to a specific code. This paradigm explicitly introduced in [6] has shifted from testing codes defined by low-degree polynomials [6, 19, 5, 4] to testing Hadamard codes <ref> [4, 10, 11, 8] </ref>, and recently to testing the long code [9]. PROPERTY TESTING IN THE CONTEXT OF PROGRAM CHECKING: There is an immediate analogy between program self-testing [14] and property-testing with queries. <p> The class presented in Proposition 2.5 consists of multi-valued functions. We leave it as an open problem whether a similar result holds for a class of Boolean functions. LEARNING AND TESTING WITH QUERIES (under the uniform distribution). Invoking known results on linearity testing <ref> [14, 7, 19, 10, 11, 8] </ref> we conclude that there is a class of 2 n functions which can be tested within query complexity O (log (1=ffi)=*), and yet learning it requires at least n queries.
Reference: [12] <author> S. Ben-David. </author> <title> Can finite samples detect singularities of real-valued functions? In 24th STOC, </title> <address> pages 390-399, </address> <year> 1992. </year>
Reference-contexts: Rubinfeld [35] focuses on property testing as applied to properties which take the form of functional equations of various types. PROPERTY TESTING IN THE CONTEXT OF LEARNING THEORY: Departing from work in Statistics regarding the classification of distributions (e.g., [24, 16, 41]), Ben-David <ref> [12] </ref> and Kulka-rni and Zeitouni [28] considered the problem of classifying an unknown function into one of two classes of functions, given labeled examples. Ben-David studied this classification problem in the limit (of the number of examples), and Kulkarni and Zeitouni studied it in a PAC inspired model.
Reference: [13] <author> A. Blum and R. Rivest. </author> <title> Training a 3-node neural network is NP-complete. </title> <booktitle> In Advances in Neural Information Processing Systems I, </booktitle> <pages> pages 494-501, </pages> <year> 1989. </year>
Reference-contexts: In contrast to Proposition 2.1 and to Corollary 2.2, we show that there are classes which are efficiently learnable (though not by a proper learning algorithm) but are not efficiently testable. This is proven by observing that many hardness results for proper learning (cf. <ref> [31, 13, 32] </ref>) actually establish the hardness of testing (for the same classes). Furthermore, we believe that it is more natural to view these hardness results as referring to testing.
Reference: [14] <author> M. Blum, M. Luby, and R. Rubinfeld. </author> <title> Self-testing/correcting with applications to numerical problems. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 47 </volume> <pages> 549-595, </pages> <year> 1993. </year>
Reference-contexts: Similarly, in the context of program checking, one may choose to test that the program satisfies certain properties before checking that it computes a specified function. This paradigm has been followed both in the theory of program checking <ref> [14, 36] </ref> and in practice where often programmers first test their programs by verifying that the programs satisfy properties that are known to be satisfied by the function they compute. Thirdly, we show how to apply property testing to the domain of graphs by considering several classical graph properties. <p> PROPERTY TESTING IN THE CONTEXT OF PROGRAM CHECKING: There is an immediate analogy between program self-testing <ref> [14] </ref> and property-testing with queries. The difference is that in self-testing, a function f (represented by a program) is tested for being close to a fully specified function g, whereas in property-testing the test is whether f is close to any function in a function class G. <p> The difference is that in self-testing, a function f (represented by a program) is tested for being close to a fully specified function g, whereas in property-testing the test is whether f is close to any function in a function class G. Interestingly, many self-testers <ref> [14, 36] </ref> work by first testing that the program satisfies some properties which the function it is supposed to compute satisfies (and only then checking that the program satisfies certain constraints specific to the function). <p> The class presented in Proposition 2.5 consists of multi-valued functions. We leave it as an open problem whether a similar result holds for a class of Boolean functions. LEARNING AND TESTING WITH QUERIES (under the uniform distribution). Invoking known results on linearity testing <ref> [14, 7, 19, 10, 11, 8] </ref> we conclude that there is a class of 2 n functions which can be tested within query complexity O (log (1=ffi)=*), and yet learning it requires at least n queries.
Reference: [15] <author> A. Blumer, A. Ehrenfeucht, D. Haussler, and M. K. Warmuth. </author> <title> Learnability and the Vapnik-Chervonenkis dimension. </title> <journal> JACM, </journal> <volume> 36(4) </volume> <pages> 929-965, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: The proof of this proposition, as well as of all other propositions in this section, can be found in our report [22]. The above proposition implies that if for every n, F n has polynomial (in n) VC-dimension <ref> [38, 15] </ref>, then F has a tester whose sample complexity is poly (n=*)log (1=ffi). The reason is that classes with polynomial VC-dimension can be properly learned from a sample of the above size [15]. <p> The above proposition implies that if for every n, F n has polynomial (in n) VC-dimension [38, 15], then F has a tester whose sample complexity is poly (n=*)log (1=ffi). The reason is that classes with polynomial VC-dimension can be properly learned from a sample of the above size <ref> [15] </ref>. However, the running time of such a proper learning algorithm, and hence of the resulting testing algorithm might be exponential in n. Corollary 2.2 Every class which is learnable with a poly (n=*) sample is testable with a poly (n=*) sample (in at most exponential time).
Reference: [16] <author> T. M. </author> <title> Cover. On determining the rationality of the mean of a random variable. </title> <journal> Annals of Statistics, </journal> <volume> 1 </volume> <pages> 862-871, </pages> <year> 1973. </year>
Reference-contexts: Rubinfeld [35] focuses on property testing as applied to properties which take the form of functional equations of various types. PROPERTY TESTING IN THE CONTEXT OF LEARNING THEORY: Departing from work in Statistics regarding the classification of distributions (e.g., <ref> [24, 16, 41] </ref>), Ben-David [12] and Kulka-rni and Zeitouni [28] considered the problem of classifying an unknown function into one of two classes of functions, given labeled examples.
Reference: [17] <author> W. F. de la Vega. </author> <title> MAX-CUT has a randomized approximation scheme in dense graphs. </title> <note> To appear in Random Structures and Algorithms, </note> <year> 1994. </year>
Reference-contexts: This yields a constant time approxi mation scheme (i.e., to within any constant relative error) for dense graphs, improving on Arora et. al. [3] and de la Vega <ref> [17] </ref> who solved this problem in polynomial-time (O (N 1=* 2 )-time and exp ( ~ O (1=(* 2 )))N 2 -time, respectively). In both works the problem is solved by actually constructing approximate max-cuts. <p> One can turn the question around and ask whether approximation algorithms for dense instances can be transformed into corresponding testers as defined above. In several cases this is possible. For example, using some ideas from our work, the Max-CUT algorithm of <ref> [17] </ref> can be transformed into a tester of complexity comparable to ours. We do not know whether the same is true with respect to the algorithms in [3]. Results on testing graph properties can be derived also from work by Alon et. al. [1]. <p> Our results, that some non-trivial monotone graph properties can be tested by examining a constant number of random locations in the matrix, stand in striking contrast to all of the above. APPROXIMATION IN DENSE GRAPHS. As stated previously, Arora et. al. [3] and de la Vega <ref> [17] </ref> presented PTAS for dense instances of Max-CUT. The approach of Arora et. al. uses Linear Programming and Randomized Rounding, and applies to other problems which can be casted as a smooth Integer Programs. 3 The methods of de la Vega [17] are purely combinatorial and apply also to similar graph <p> previously, Arora et. al. [3] and de la Vega <ref> [17] </ref> presented PTAS for dense instances of Max-CUT. The approach of Arora et. al. uses Linear Programming and Randomized Rounding, and applies to other problems which can be casted as a smooth Integer Programs. 3 The methods of de la Vega [17] are purely combinatorial and apply also to similar graph partition problems.
Reference: [18] <author> K. Edwards. </author> <title> The complexity of colouring problems on dense graphs. </title> <journal> Theoretical Computer Science, </journal> <volume> 43 </volume> <pages> 337-343, </pages> <year> 1986. </year>
Reference-contexts: 2 =* 3 )-time, between k-colorable N -vertex graphs and N -vertex graphs which remain non-k-colorable even if one omits at most *N 2 of their edges. 2 We note that deciding k-colorability even for N -vertex graphs of minimum degree at least k3 k2 N is NP-complete (cf., Edwards <ref> [18] </ref>). On the other hand, Edwards also gave a polynomial-time algorithm for k-coloring k-colorable N - vertex graphs of minimum degree at least ffN , for any constant ff &gt; k3 1.4.
Reference: [19] <author> U. Feige, S. Goldwasser, L. Lovasz, S. Safra, and M. Szegedy. </author> <title> Approximating clique is almost NP-complete. </title> <booktitle> In 32nd FOCS, </booktitle> <pages> pages 2-12, </pages> <year> 1991. </year>
Reference-contexts: Specifically, the property tested is being a codeword with respect to a specific code. This paradigm explicitly introduced in [6] has shifted from testing codes defined by low-degree polynomials <ref> [6, 19, 5, 4] </ref> to testing Hadamard codes [4, 10, 11, 8], and recently to testing the long code [9]. PROPERTY TESTING IN THE CONTEXT OF PROGRAM CHECKING: There is an immediate analogy between program self-testing [14] and property-testing with queries. <p> The class presented in Proposition 2.5 consists of multi-valued functions. We leave it as an open problem whether a similar result holds for a class of Boolean functions. LEARNING AND TESTING WITH QUERIES (under the uniform distribution). Invoking known results on linearity testing <ref> [14, 7, 19, 10, 11, 8] </ref> we conclude that there is a class of 2 n functions which can be tested within query complexity O (log (1=ffi)=*), and yet learning it requires at least n queries.
Reference: [20] <author> A. Frieze and R. Kanan. </author> <title> The regularity lemma and approximation schemes for dense problems. </title> <booktitle> In these proceedings, </booktitle> <year> 1996. </year>
Reference-contexts: Following the approach of Alon et. al. [1], but using a modification of the regularity Lemma (and thus obtaining much improved running times), Frieze and Kannan <ref> [20] </ref> devise PTAS for several graph partition problems such as Max-Cut and Bisection. We note that compared to all the above results, our respective graph partitioning algorithms have better running-times. Like de la Vega, our methods use elementary combinatorial arguments related to the problem at hand.
Reference: [21] <author> P. Gemmell, R. Lipton, R. Rubinfeld, M. Sudan, and A. Wigderson. </author> <title> Self-testing/correcting for polynomials and for approximate functions. </title> <booktitle> In 23nd STOC, </booktitle> <pages> pages 32-42, </pages> <year> 1991. </year>
Reference-contexts: Invoking known results on linearity testing [14, 7, 19, 10, 11, 8] we conclude that there is a class of 2 n functions which can be tested within query complexity O (log (1=ffi)=*), and yet learning it requires at least n queries. Similarly, using results on low-degree testing <ref> [7, 6, 21, 36] </ref>, there is a class of exp (2 n ) function which can be tested within query complexity O ( * n), and yet learning it requires exp (n) many queries. AGNOSTIC LEARNING AND TESTING.
Reference: [22] <author> O. Goldreich, S. Goldwasser, and D. Ron. </author> <title> Property testing and its connection to learning and approximation. </title> <note> Available from http://theory.lcs.mit.edu/~oded/ggr.html. </note>
Reference-contexts: The definition and theorem regarding the General Graph Partition property appears in Subsection 3.3. All other results as well as proofs and further details can be found in our report <ref> [22] </ref>. 2. General Definitions and Observations 2.1. <p> Furthermore, the same relation holds between the running times of the two algorithm. The proof of this proposition, as well as of all other propositions in this section, can be found in our report <ref> [22] </ref>. The above proposition implies that if for every n, F n has polynomial (in n) VC-dimension [38, 15], then F has a tester whose sample complexity is poly (n=*)log (1=ffi). <p> Claim 3.1.5 For every U and a perfect k-partition of U, after at most ` = 4k=* iterations, the Restriction Procedure halts and outputs either U 0 or error. The proof of this claim, as well as all other missing proofs, can be found in our report <ref> [22] </ref>. Before we show how U 0 can be used to define a k-partition of V (G), we need to ensure that with high probability, the restriction procedure in fact outputs a set U 0 and not error. To this end, we first define the notion of a covering set.
Reference: [23] <author> P. Hajnal. </author> <title> An (n 4=3 ) lower bound on the randomized complexity of graph properties. </title> <journal> Combinatorica, </journal> <volume> 11(2) </volume> <pages> 131-144, </pages> <year> 1991. </year>
Reference-contexts: The query complexity of randomized decision procedures was conjectured by Yao to be (N 2 ). Progress towards this goal was made by Yao [40], King [27] and Hajnal <ref> [23] </ref> culminating in an (N 4=3 ) lower bound. Our results, that some non-trivial monotone graph properties can be tested by examining a constant number of random locations in the matrix, stand in striking contrast to all of the above. APPROXIMATION IN DENSE GRAPHS.
Reference: [24] <author> W. Hoeffding and J. Wolfowitz. </author> <title> Distinguishability of sets of distributions. </title> <journal> Annals of Mathematical Statistics, </journal> <volume> 29 </volume> <pages> 700-718, </pages> <year> 1958. </year>
Reference-contexts: Rubinfeld [35] focuses on property testing as applied to properties which take the form of functional equations of various types. PROPERTY TESTING IN THE CONTEXT OF LEARNING THEORY: Departing from work in Statistics regarding the classification of distributions (e.g., <ref> [24, 16, 41] </ref>), Ben-David [12] and Kulka-rni and Zeitouni [28] considered the problem of classifying an unknown function into one of two classes of functions, given labeled examples.
Reference: [25] <author> M. J. Kearns, Y. Mansour, D. Ron, R. Rubinfeld, R. E. Schapire, and L. Sellie. </author> <title> On the learnability of discrete distributions. </title> <booktitle> In The 25th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 273-282, </pages> <year> 1994. </year>
Reference-contexts: In particular, agnostic learning with respect to a hypothesis class H implies proper learning of the class H and thus property testing of H. LEARNING AND TESTING DISTRIBUTIONS. The context of learning (cf., <ref> [25] </ref>) and testing distributions offers a dramatic demonstration to the importance of a promise (i.e., the fact that the learning algorithm is required to work only when the target belongs to the class, whereas the testing algorithm needs to work for all targets which are either in the class or far
Reference: [26] <author> M. J. Kearns, R. E. Schapire, and L. M. Sellie. </author> <title> Toward efficient agnostic learning. </title> <booktitle> In 5th COLT, </booktitle> <pages> pages 341-352, </pages> <year> 1992. </year>
Reference-contexts: AGNOSTIC LEARNING AND TESTING. In a variant of PAC learning, called Agnostic PAC learning <ref> [26] </ref>, there is no promise concerning the target function f . Instead, the learner is required to output a hypothesis h from a certain hypothesis class H, such that h is *-close to the function in H which is closest to f .
Reference: [27] <author> V. King. </author> <title> An (n 5=4 ) lower bound on the randomized complexity of graph properties. </title> <journal> Combinatorica, </journal> <volume> 11(1) </volume> <pages> 23-32, </pages> <year> 1991. </year>
Reference-contexts: The query complexity of randomized decision procedures was conjectured by Yao to be (N 2 ). Progress towards this goal was made by Yao [40], King <ref> [27] </ref> and Hajnal [23] culminating in an (N 4=3 ) lower bound. Our results, that some non-trivial monotone graph properties can be tested by examining a constant number of random locations in the matrix, stand in striking contrast to all of the above. APPROXIMATION IN DENSE GRAPHS.
Reference: [28] <author> S. R. Kulkarni and O. Zeitouni. </author> <title> On probably correct classification of concepts. </title> <booktitle> In 6th COLT, </booktitle> <pages> pages 111-116, </pages> <year> 1993. </year>
Reference-contexts: Rubinfeld [35] focuses on property testing as applied to properties which take the form of functional equations of various types. PROPERTY TESTING IN THE CONTEXT OF LEARNING THEORY: Departing from work in Statistics regarding the classification of distributions (e.g., [24, 16, 41]), Ben-David [12] and Kulka-rni and Zeitouni <ref> [28] </ref> considered the problem of classifying an unknown function into one of two classes of functions, given labeled examples. Ben-David studied this classification problem in the limit (of the number of examples), and Kulkarni and Zeitouni studied it in a PAC inspired model.
Reference: [29] <author> L. Lovasz and N. Young. </author> <title> Lecture notes on evasiveness of graph properties. </title> <type> Technical Report TR-317-91, </type> <institution> Princeton University, Computer Science Department, </institution> <year> 1991. </year>
Reference-contexts: P is a relaxation of the notion of deciding the graph 2 As noted by Noga Alon, similar results, alas with much worse dependence on *, can be obtained by using the results of Alon et. al. [1]. property P which has received much attention in the last two decades <ref> [29] </ref>. In the classical problem there are no margins of error, and one is required to accept all graphs having property P and reject all graphs which lack it.
Reference: [30] <author> E. Petrank. </author> <title> The hardness of approximations: Gap location. </title> <journal> Computational Complexity, </journal> <volume> 4 </volume> <pages> 133-157, </pages> <year> 1994. </year>
Reference-contexts: TESTING k-COLORABILITY VS. APPROXIMATING k-COLORABILITY. Petrank has shown that it is NP-Hard to distinguish 3-colorable graphs from graphs in which every 3-partition of the vertex set violates at least a constant fraction of the edges <ref> [30] </ref>. In contrast, our k-Colorability Tester im plies that solving the same promise problem is easy for dense graphs, where by dense graphs we mean N -vertex graphs 3 with (N 2 ) edges.
Reference: [31] <author> L. Pitt and L. G. Valiant. </author> <title> Computational limitations on learning from examples. </title> <journal> JACM, </journal> <volume> 35(4) </volume> <pages> 965-984, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: Namely, the absence of a promise makes testing potentially harder than learning, whereas deciding whether a function belongs to a class rather than finding the function may make testing easier. In the learning literature, a distinction is made between proper (or representation dependent) learning and non-proper learning <ref> [31] </ref>. In the former model, the hypothesis output by the learning algorithm is required to belong to the same function class as the target function f , i.e. h 2 F , while in the latter model, no such restriction is made. <p> In contrast to Proposition 2.1 and to Corollary 2.2, we show that there are classes which are efficiently learnable (though not by a proper learning algorithm) but are not efficiently testable. This is proven by observing that many hardness results for proper learning (cf. <ref> [31, 13, 32] </ref>) actually establish the hardness of testing (for the same classes). Furthermore, we believe that it is more natural to view these hardness results as referring to testing.
Reference: [32] <author> L. Pitt and M. K. Warmuth. </author> <title> The minimum consistent DFA problem cannot be approximated within any polynomial. </title> <journal> JACM, </journal> <volume> 40(1) </volume> <pages> 95-142, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: In contrast to Proposition 2.1 and to Corollary 2.2, we show that there are classes which are efficiently learnable (though not by a proper learning algorithm) but are not efficiently testable. This is proven by observing that many hardness results for proper learning (cf. <ref> [31, 13, 32] </ref>) actually establish the hardness of testing (for the same classes). Furthermore, we believe that it is more natural to view these hardness results as referring to testing.
Reference: [33] <author> R. L. Rivest and J. Vuillemin. </author> <title> On recognizing graph properties from adjacency matrices. </title> <journal> Theoretical Computer Science, </journal> <volume> 3 </volume> <pages> 371-384, </pages> <year> 1976. </year>
Reference-contexts: In the classical problem there are no margins of error, and one is required to accept all graphs having property P and reject all graphs which lack it. In 1975 Rivest and Vuillemin <ref> [33] </ref> resolved the Aanderaa-Rosenberg Conjecture [34], showing that any deterministic procedure for deciding any non-trivial monotone N -vertex graph property must examine (N 2 ) entries in the adjacency matrix representing the graph. The query complexity of randomized decision procedures was conjectured by Yao to be (N 2 ).
Reference: [34] <author> A. L. Rosenberg. </author> <title> On the time required to recognize properties of graphs: A problem. </title> <journal> SIGACT News, </journal> <volume> 5 </volume> <pages> 15-16, </pages> <year> 1973. </year>
Reference-contexts: In the classical problem there are no margins of error, and one is required to accept all graphs having property P and reject all graphs which lack it. In 1975 Rivest and Vuillemin [33] resolved the Aanderaa-Rosenberg Conjecture <ref> [34] </ref>, showing that any deterministic procedure for deciding any non-trivial monotone N -vertex graph property must examine (N 2 ) entries in the adjacency matrix representing the graph. The query complexity of randomized decision procedures was conjectured by Yao to be (N 2 ).
Reference: [35] <author> R. Rubinfeld. </author> <title> Robust functional equations and their applications to program testing. </title> <booktitle> In 35th FOCS, </booktitle> <year> 1994. </year>
Reference-contexts: The problem of testing properties emerges naturally in the context of program checking and probabilistically checkable proofs as applied to multi-linear functions or low-degree polynomials [14, 7, 6, 19, 21, 36, 5, 4, 10, 11, 8, 9]. Property testing per se was considered in <ref> [36, 35] </ref>. Our definition of property testing is inspired by the PAC learning model [37]. <p> Rubinfeld and Sudan [36] defined property testing, under the uniform distribution and using queries, and related it to their notion of Robust Characterization. Rubinfeld <ref> [35] </ref> focuses on property testing as applied to properties which take the form of functional equations of various types.
Reference: [36] <author> R. Rubinfeld and M. Sudan. </author> <title> Robust characterization of polynomials with applications to program testing. </title> <journal> SIAM Journal on Computing, </journal> <volume> 25(2) </volume> <pages> 252-271, </pages> <year> 1996. </year>
Reference-contexts: The problem of testing properties emerges naturally in the context of program checking and probabilistically checkable proofs as applied to multi-linear functions or low-degree polynomials [14, 7, 6, 19, 21, 36, 5, 4, 10, 11, 8, 9]. Property testing per se was considered in <ref> [36, 35] </ref>. Our definition of property testing is inspired by the PAC learning model [37]. <p> Similarly, in the context of program checking, one may choose to test that the program satisfies certain properties before checking that it computes a specified function. This paradigm has been followed both in the theory of program checking <ref> [14, 36] </ref> and in practice where often programmers first test their programs by verifying that the programs satisfy properties that are known to be satisfied by the function they compute. Thirdly, we show how to apply property testing to the domain of graphs by considering several classical graph properties. <p> The difference is that in self-testing, a function f (represented by a program) is tested for being close to a fully specified function g, whereas in property-testing the test is whether f is close to any function in a function class G. Interestingly, many self-testers <ref> [14, 36] </ref> work by first testing that the program satisfies some properties which the function it is supposed to compute satisfies (and only then checking that the program satisfies certain constraints specific to the function). <p> Interestingly, many self-testers [14, 36] work by first testing that the program satisfies some properties which the function it is supposed to compute satisfies (and only then checking that the program satisfies certain constraints specific to the function). Rubinfeld and Sudan <ref> [36] </ref> defined property testing, under the uniform distribution and using queries, and related it to their notion of Robust Characterization. Rubinfeld [35] focuses on property testing as applied to properties which take the form of functional equations of various types. <p> Invoking known results on linearity testing [14, 7, 19, 10, 11, 8] we conclude that there is a class of 2 n functions which can be tested within query complexity O (log (1=ffi)=*), and yet learning it requires at least n queries. Similarly, using results on low-degree testing <ref> [7, 6, 21, 36] </ref>, there is a class of exp (2 n ) function which can be tested within query complexity O ( * n), and yet learning it requires exp (n) many queries. AGNOSTIC LEARNING AND TESTING.
Reference: [37] <author> L. G. Valiant. </author> <title> A theory of the learnable. </title> <journal> CACM, </journal> <volume> 27(11) </volume> <pages> 1134-1142, </pages> <month> November </month> <year> 1984. </year>
Reference-contexts: Property testing per se was considered in [36, 35]. Our definition of property testing is inspired by the PAC learning model <ref> [37] </ref>. <p> In this case we refer to the number of queries made by A (which is a function of n, *, and ffi), as the query complexity of A. 2.2. Property Testing and PAC Learning A Probably Approximately Correct (PAC) learning algorithm <ref> [37] </ref> works in the same framework as that described in Definition 2.1 except for the following (crucial) differences: (1) It is given a promise that the unknown function f (referred to as the target function) belongs to F ; (2) It is required to output (with probability at least 1 ffi)
Reference: [38] <author> V. N. Vapnik and A. Y. Chervonenkis. </author> <title> On the uniform convergence of relative frequencies of events to their probabilities. </title> <journal> Theory of Probability and its applications, </journal> <volume> 17(2) </volume> <pages> 264-280, </pages> <year> 1971. </year>
Reference-contexts: The proof of this proposition, as well as of all other propositions in this section, can be found in our report [22]. The above proposition implies that if for every n, F n has polynomial (in n) VC-dimension <ref> [38, 15] </ref>, then F has a tester whose sample complexity is poly (n=*)log (1=ffi). The reason is that classes with polynomial VC-dimension can be properly learned from a sample of the above size [15].
Reference: [39] <author> K. Yamanishi. </author> <title> Probably almost discriminative learning. </title> <journal> Machine Learning, </journal> <volume> 18 </volume> <pages> 23-50, </pages> <year> 1995. </year>
Reference-contexts: For any fixed *, the problem of testing the class F with distance parameter * can be casted as such a classification problem (with F and the set of functions *-away from F being the two classes). A different variant of the problem was considered by Yamanishi <ref> [39] </ref>. TESTING GRAPH PROPERTIES.
Reference: [40] <author> A. C. C. Yao. </author> <title> Lower bounds to randomized algorithms for graph properties. </title> <booktitle> In 28th FOCS, </booktitle> <pages> pages 393-400, </pages> <year> 1987. </year>
Reference-contexts: The query complexity of randomized decision procedures was conjectured by Yao to be (N 2 ). Progress towards this goal was made by Yao <ref> [40] </ref>, King [27] and Hajnal [23] culminating in an (N 4=3 ) lower bound. Our results, that some non-trivial monotone graph properties can be tested by examining a constant number of random locations in the matrix, stand in striking contrast to all of the above. APPROXIMATION IN DENSE GRAPHS.
Reference: [41] <author> O. Zeitouni and S. R. Kulkarni. </author> <title> A general classification rule for probability measures. </title> <note> To appear in Annals of Statistics, 1991. 10 </note>
Reference-contexts: Rubinfeld [35] focuses on property testing as applied to properties which take the form of functional equations of various types. PROPERTY TESTING IN THE CONTEXT OF LEARNING THEORY: Departing from work in Statistics regarding the classification of distributions (e.g., <ref> [24, 16, 41] </ref>), Ben-David [12] and Kulka-rni and Zeitouni [28] considered the problem of classifying an unknown function into one of two classes of functions, given labeled examples.
References-found: 41

