URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/tr.outbox/MIT-LCS-TR-705.ps.gz
Refering-URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/tr700.html
Root-URL: 
Title: Replication Control in Distributed B-Trees MIT/LCS/TR-705  
Author: Paul R. Cosway 
Address: 545 Technology Square Cambridge, Massachusetts 02139  
Affiliation: Massachusetts Institute of Technology Laboratory for Computer Science  
Note: c flPaul R. Cosway, 1997. All rights reserved.  
Date: February, 1997  
Abstract: This report was previously published as a Master's thesis, supervised by Prof. William E. Weihl. 
Abstract-found: 1
Intro-found: 1
Reference: [ACJ + 91] <author> A. Agarwal, D. Chaiken, K. Johnson, D. Kranz, J. Kubiatowicz, K. Kurihara, Ben-Hong Lim, G. Maa, and D. Nussbaum. </author> <title> The MIT Alewife Machine: A Large-Scale Distributed-Memory Multiprocessor. In Scalable Shared Memory Multiprocessors. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year>
Reference-contexts: A number of new multiprocessor architectures are moving away from the model of a small number of processors sharing a centralized memory to that of a large number of independent processors, each with its own local memory, and linked by passing messages between them <ref> [Dal90, ACJ + 91] </ref>. The aggregate computing power of the tens, hundreds, or even thousands of processors hooked together is substantial if they can be made to work together.
Reference: [Bar79] <author> Y. Bard. </author> <title> Some Extensions to Multiclass Queueing Network Analysis. </title> <editor> In M. Arato, A. Butrimenko, and E. Gelenbe, editors, </editor> <booktitle> Performance of Computer Systems, </booktitle> <pages> pages 51-62. </pages> <publisher> North-Holland Publishing Co., </publisher> <year> 1979. </year>
Reference-contexts: Most real-world systems to be modeled, including ours, do not meet product-form requirements exactly. However, the techniques for solving product-form networks, with appropriate extensions, have been shown to give accurate results even when product-form requirements are not met <ref> [LZGS84, Bar79, HL84, dSeSM89] </ref>. Our results indicate the extensions are sufficiently accurate to be useful in understanding our problem. To use a queueing network model, we must provide the model with a description of the service centers, customer classes, and class service demand requirements. <p> Lavenberg originally presented the Mean Value Analysis (MVA) algorithm for computing the exact solutions for product-form networks. ("Exact" refers to the mathematical solution of the equations, not the model's fit to the "real world".) However, because of the time and space required when solving for large networks, they and others <ref> [Bar79, CN82] </ref> have presented algorithms to approximate the solutions. <p> Rather than develop a more complicated "simplification" for the equations, we use a simplified algorithm, the approximate MVA algorithm (from Lazowska [LZGS84]) shown in Figure 4-6, and use Schweitzer's method for our approximations. The algorithm, proposed by Schweitzer and described by Bard <ref> [Bar79, Bar80] </ref>, uses the extended MVA equations described in section 4.3.2, but proceeds by refining an estimate of Q c;k (N ) until successive values are within a specified tolerance. The critical step in this algorithm is the approximation of Q i;k (N 1 c ) from Q i;k (N).
Reference: [Bar80] <author> Y. Bard. </author> <title> A Model of Shared DASD and Multipathing. </title> <journal> Communications of the ACM, </journal> <volume> 23(10) </volume> <pages> 564-572, </pages> <month> October </month> <year> 1980. </year>
Reference-contexts: Rather than develop a more complicated "simplification" for the equations, we use a simplified algorithm, the approximate MVA algorithm (from Lazowska [LZGS84]) shown in Figure 4-6, and use Schweitzer's method for our approximations. The algorithm, proposed by Schweitzer and described by Bard <ref> [Bar79, Bar80] </ref>, uses the extended MVA equations described in section 4.3.2, but proceeds by refining an estimate of Q c;k (N ) until successive values are within a specified tolerance. The critical step in this algorithm is the approximation of Q i;k (N 1 c ) from Q i;k (N).
Reference: [BDCW91] <author> E. Brewer, C. Dellarocas, A. Colbrook, and W. E. Weihl. Proteus: </author> <title> a High-performance Parallel Architecture Simulator. </title> <type> Technical Report TR-516, </type> <institution> MIT, </institution> <year> 1991. </year>
Reference-contexts: Other copies are updated by sending the complete new version of the node after every change. 15 Chapter 3 System Setup We implemented a distributed B-tree using Proteus, a high-performance MIMD multiprocessor simulator <ref> [BDCW91, Del91] </ref>. Proteus provided us with a basic multiprocessor architecture - independent processors, each with local memory, that communicate with messages. It also provided exceptionally valuable tools for monitoring and measuring program behavior.
Reference: [BM72] <author> R. Bayer and E. McCreight. </author> <title> Organization and Maintenance of Large Ordered Indices. </title> <journal> Acta Informatica, </journal> <volume> 1(9) </volume> <pages> 173-189, </pages> <year> 1972. </year>
Reference-contexts: to optimize performance; * Chapter 7 describes an approach to the dynamic control of replication and analyzes the results of simulations; * Chapter 8 summarizes the conclusions of our work and indicates avenues for further investigation. 5 Chapter 2 Related Work The original B-tree algorithm introduced by Bayer and McCreight <ref> [BM72] </ref> was designed for execution on a single processor by a single process. Our current problem is the extension of the algorithm to run on multiple processors, each with its own local memory, and each with one or more processes using and modifying the data structure.
Reference: [Bre92] <author> E. Brewer. </author> <title> Aspects of a Parallel-Architecture Simulator. </title> <type> Technical Report TR-527, </type> <institution> MIT, </institution> <year> 1992. </year>
Reference-contexts: In addition to its simulation capabilities, Proteus also provides a rich set of measurement and visualization tools that facilitate debugging and monitoring. Most of the graphs included in this report were produced directly by Proteus. 16 Proteus has been shown to accurately model a variety of multiprocessors <ref> [Bre92] </ref>, but the purpose of our simulations was not to model a specific multiprocessor architecture.
Reference: [BS77] <author> R. Bayer and M. Schkolnick. </author> <title> Concurrency of Operations on B-trees. </title> <journal> Acta Infor-matica, </journal> <volume> 9 </volume> <pages> 1-21, </pages> <year> 1977. </year>
Reference-contexts: Two methods have been proposed to avoid this situation, lock coupling and B-link trees. Bayer and Schkolnick <ref> [BS77] </ref> proposed lock coupling for controlling concurrent access.
Reference: [CBDW91] <author> A. Colbrook, E. Brewer, C. Dellorocas, and W. E. Weihl. </author> <title> Algorithms for Search Trees on Message-Passing Architectures. </title> <type> Technical Report TR-517, </type> <institution> MIT, </institution> <year> 1991. </year> <booktitle> Related paper appears in Proceedings of the 1991 International Conference on Parallel Processing. </booktitle>
Reference-contexts: Before examining those problems, it should be noted that there have been proposals for concurrent, distributed B-trees that do not replicate nodes. Carey and Thompson [CT84] suggested a pipeline of processors to support a B-tree. This work has been extended by Colbrook, et al. <ref> [CS90, CBDW91] </ref>. In these models, each processor is responsible for one level of the B-tree. This limits the amount of parallelism that can be achieved to the depth of the tree. <p> Of course, each node has a minimum of 1 copy, the original. This rule, add copies to balance the capacity of B-tree levels, is also found in other approaches to distributed B-trees. The pipelined approach to B-trees presented by Colbrook et al. in <ref> [CBDW91] </ref> assures equal processing capacity per tree level, by dedicating a single processor to each level. Of course, this method cannot utilize more processors than there are tree levels. Wang's method creates the same number of nodes per level, which creates roughly the same capacity per level.
Reference: [CN82] <author> K. M. Chandy and D. Neuse. Linearizer: </author> <title> A Heuristic Algorithm for Queueing Network Models of Computing Systems. </title> <journal> Communications of the ACM, </journal> <volume> 25(2) </volume> <pages> 126-134, </pages> <month> February </month> <year> 1982. </year>
Reference-contexts: Lavenberg originally presented the Mean Value Analysis (MVA) algorithm for computing the exact solutions for product-form networks. ("Exact" refers to the mathematical solution of the equations, not the model's fit to the "real world".) However, because of the time and space required when solving for large networks, they and others <ref> [Bar79, CN82] </ref> have presented algorithms to approximate the solutions. <p> U i;k (N 1 c ) = &gt; &lt; (N c 1) U i;k (N) if i 6= c We have also used a more complicated approximation algorithm due to Chandy and Neuse <ref> [CN82] </ref> and found its results on our application not significantly different from Schweitzer's algorithm. 4.4 B-Tree Cost Model High Replication To use the MVA algorithms just described to model a distributed B-tree with replicated nodes we must provide the eight parameters mentioned in section 4.3.3: three service times, S home ,
Reference: [Com79] <author> D. Comer. </author> <title> The Ubiquitous B-tree. </title> <journal> Computing Surveys, </journal> <volume> 11(2) </volume> <pages> 121-137, </pages> <year> 1979. </year>
Reference-contexts: In this report we explore the use and control of replication of parts of a distributed data structure to create efficient distributed B-trees. The reader unfamiliar with the basics of B-trees is referred to Comer's excellent summary <ref> [Com79] </ref>. In brief, the B-tree formalizes in a data structure and algorithm the technique one might use in looking up a telephone number in a telephone directory, shown graphically in figure 1-1.
Reference: [Cor69] <author> F. J. Corbato. </author> <title> A Paging Experiment with the MULTICS System. </title> <editor> In H. Feshbach and K. Ingard, editors, In Honor of Philip M. </editor> <booktitle> Morse, </booktitle> <pages> pages 217-228. </pages> <publisher> M.I.T. Press, </publisher> <year> 1969. </year>
Reference-contexts: add to its cache, it must allocate an unused cache entry or discard a currently cached node. (When a cache entry is discarded, the "master" copy of the node is notified.) For the simulations in this chapter we manage the cache with a replacement algorithm developed by the MULTICS project <ref> [Cor69] </ref>, sometimes called second chance, [PS85], clock or marking replacement. In this algorithm a cache entry is "marked" every time it is used. A pointer points to the last cache location discarded.
Reference: [Cox62] <author> D. Cox. </author> <title> Renewal Theory. </title> <publisher> Wiley, </publisher> <year> 1962. </year>
Reference-contexts: The formula for the mean residual service time, r j;k , comes from renewal theory (see <ref> [Cox62, Kle75] </ref>). Note that when the service time distribution is exponential, 2 j;k = S 2 so r j;k = S j;k , as expected. We delay further discussion of our use of service time variance until section 4.4.4. 32 One additional comment on residual service time is required.
Reference: [CS90] <author> A. Colbrook and C. Smythe. </author> <title> Efficient Implementations of Search Trees on Parallel Distributed Memory Architectures. </title> <booktitle> IEE Proceedings Part E, </booktitle> <volume> 137 </volume> <pages> 394-400, </pages> <year> 1990. </year>
Reference-contexts: Before examining those problems, it should be noted that there have been proposals for concurrent, distributed B-trees that do not replicate nodes. Carey and Thompson [CT84] suggested a pipeline of processors to support a B-tree. This work has been extended by Colbrook, et al. <ref> [CS90, CBDW91] </ref>. In these models, each processor is responsible for one level of the B-tree. This limits the amount of parallelism that can be achieved to the depth of the tree.
Reference: [CT84] <author> M. Carey and C. Thompson. </author> <title> An Efficient Implementation of Search Trees on lg N + 1 Processors. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-33(11):1038-1041, </volume> <year> 1984. </year>
Reference-contexts: Before examining those problems, it should be noted that there have been proposals for concurrent, distributed B-trees that do not replicate nodes. Carey and Thompson <ref> [CT84] </ref> suggested a pipeline of processors to support a B-tree. This work has been extended by Colbrook, et al. [CS90, CBDW91]. In these models, each processor is responsible for one level of the B-tree. This limits the amount of parallelism that can be achieved to the depth of the tree.
Reference: [Dal90] <author> W. Dally. </author> <title> Network and Processor Architecture for Message-Driven Computers. </title> <editor> In R. Suaya and G. Birtwistle, editors, </editor> <booktitle> VLSI and Parallel Computation, </booktitle> <pages> pages 140-218. </pages> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1990. </year>
Reference-contexts: A number of new multiprocessor architectures are moving away from the model of a small number of processors sharing a centralized memory to that of a large number of independent processors, each with its own local memory, and linked by passing messages between them <ref> [Dal90, ACJ + 91] </ref>. The aggregate computing power of the tens, hundreds, or even thousands of processors hooked together is substantial if they can be made to work together.
Reference: [Del91] <author> C. Dellarocas. </author> <title> A High-Performance Retargetable Simulator for Parallel Architectures. </title> <type> Technical Report TR-505, </type> <institution> MIT, </institution> <year> 1991. </year>
Reference-contexts: Other copies are updated by sending the complete new version of the node after every change. 15 Chapter 3 System Setup We implemented a distributed B-tree using Proteus, a high-performance MIMD multiprocessor simulator <ref> [BDCW91, Del91] </ref>. Proteus provided us with a basic multiprocessor architecture - independent processors, each with local memory, that communicate with messages. It also provided exceptionally valuable tools for monitoring and measuring program behavior.
Reference: [dSeSM89] <author> E. de Souza e Silva and R. Muntz. </author> <title> Queueing Networks: Solutions and Applications. </title> <type> Technical Report CSD-890052, </type> <institution> UCLA, </institution> <year> 1989. </year>
Reference-contexts: Most real-world systems to be modeled, including ours, do not meet product-form requirements exactly. However, the techniques for solving product-form networks, with appropriate extensions, have been shown to give accurate results even when product-form requirements are not met <ref> [LZGS84, Bar79, HL84, dSeSM89] </ref>. Our results indicate the extensions are sufficiently accurate to be useful in understanding our problem. To use a queueing network model, we must provide the model with a description of the service centers, customer classes, and class service demand requirements.
Reference: [HBDW91] <author> W. Hsieh, E. Brewer, C. Dellarocas, and C. Waldspurger. </author> <title> Core Runtime System Design - PSG Design Note #5. </title> <year> 1991. </year>
Reference-contexts: The model for both elements was the runtime system of Prelude, a programming language being developed on top of Proteus for writing portable, MIMD parallel programs [WBC + 91]. Prelude provided a model for message dispatching and a mechanism for referencing objects across processors <ref> [HBDW91] </ref>. To the Prelude mechanism for distributed object references we added a simple structure for creating and managing copies of objects. 3.2.1 Interprocessor Messages In our simulations each processor is executing one thread (one of the processors actually has a second thread, usually inactive, to control the simulation).
Reference: [HL84] <author> P. Heidelberger and S.S Lavenberg. </author> <title> Computer Performance Evaluation Methodology. </title> <type> Research Report RC 10493, </type> <institution> IBM, </institution> <year> 1984. </year>
Reference-contexts: Most real-world systems to be modeled, including ours, do not meet product-form requirements exactly. However, the techniques for solving product-form networks, with appropriate extensions, have been shown to give accurate results even when product-form requirements are not met <ref> [LZGS84, Bar79, HL84, dSeSM89] </ref>. Our results indicate the extensions are sufficiently accurate to be useful in understanding our problem. To use a queueing network model, we must provide the model with a description of the service centers, customer classes, and class service demand requirements.
Reference: [JC92] <author> T. Johnson and A. Colbrook. </author> <title> A Distributed Data-balanced Dictionary Based on the B-link Tree. </title> <booktitle> In Proceedings of the 6th International Parallel Processing Symposium, </booktitle> <pages> pages 319-324. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: Of the work done with distributed B-trees, Wang [Wan91] showed that increased throughput can be obtained through replicating parts of the B-tree structure, but did not directly address how much replication is necessary or how it can be controlled. Johnson and Colbrook <ref> [JC92] </ref> have suggested an approach to controlling replication that we label "path-to-root", but it has not yet been tested. This work is being extended by Johnson and Krishna [JK93]. <p> This distribution of copies makes intuitive sense, since more copies are made of the more frequently accessed B-tree nodes. Figure 2-1 shows the calculation of relative access frequency and copies per level, where the root is defined to have relative access frequency of 1:0. Johnson and Colbrook <ref> [JC92] </ref> suggested a method for determining where to place the copies 10 Level Relative Frequency Copies h 1 min (P; RF h ) . . . 3 1=BF (h3) min (P; RF 3 ) 1 1=BF (h1) min (P; RF ) of a node that also determines the number of copies <p> Two methods have been proposed. Wang required that all modifications are made to a "master" copy of a node, and then sent out the complete new version of the node to update copies. (The original copy of the node is usually identified as the "master".) Johnson and Colbrook <ref> [JC92] </ref> have proposed sending out just the update transactions to all copies of a node and are exploring an approach to allow modifications to originate at any copy of a node. <p> Of course, a tree node will actually be on #copies processors with probability 1.0, and on (#processors #copies) processors with probability 0.0. But the selection of which processors to give copies is random, without any tie to the tree structure as, for example, Johnson and Colbrook <ref> [JC92] </ref> use in their path-to-root scheme. In our modeling, we assume that all nodes at the same tree level have the same number of copies, 26 and the nodes at a level in a tree are copied to all processors before any copies are made at a lower level.
Reference: [JK93] <author> T. Johnson and P. Krishna. </author> <title> Lazy Updates for Distributed Search Structure. </title> <booktitle> In Proceedings of the International Conference on Management of Data, </booktitle> <pages> pages 337-400. </pages> <booktitle> ACM, 1993. (ACM SIGMOD Record, </booktitle> <volume> Vol. 20, Number 2). </volume>
Reference-contexts: Johnson and Colbrook [JC92] have suggested an approach to controlling replication that we label "path-to-root", but it has not yet been tested. This work is being extended by Johnson and Krishna <ref> [JK93] </ref>. <p> This algorithm has not yet been implemented and requires minor extensions to handle "simultaneous" independent splits correctly, so it will not be fully described here. Johnson and Krishna <ref> [JK93] </ref> are extending this work. While the copy update issue is critical to an actual implementation, it is not critical to our study.
Reference: [JS89] <author> T. Johnson and D. Shasha. </author> <title> Utilization of of B-trees with Inserts, </title> <booktitle> Deletes, and Modifies. In ACM SIGACT/SIGMOD/SIGART Symposium on Principles of Database Systems, </booktitle> <pages> pages 235-246. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: Thus, the probability of each type of operation is: * P lookup = 1 mod pct * P insert = mod pct fl (1 del pct) 48 * P delete = mod pct fl del pct We use the work of Johnson and Shasha <ref> [JS89] </ref> to convert the operation mix into the expected number of node modifications and node splits per operation. <p> It is very noticeable that, even though throughput is generally dropping after replication starts at the second level, the removal of the bottleneck as replication starts at the third level produces an increase in throughput. For the 50/25/25 case, we first note that Johnson and Shasha <ref> [JS89] </ref> showed that the expected leaf utilization will drop to approximately 40%, not the 70% that generally holds when inserts are more prevalent than deletes.
Reference: [JS90] <author> T. Johnson and D. Shasha. </author> <title> A Framework for the Performance Analysis of Concurrent B-tree Algorithms. </title> <booktitle> In Proceedings of the 9th ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 273-287. </pages> <publisher> ACM, </publisher> <year> 1990. </year>
Reference-contexts: Analysis of the various approaches has shown that the B-link algorithm can provide the greatest increases in throughput <ref> [LS86, JS90, Wan91, SC91] </ref>. We use the B-link algorithm and perform only splits in our simulations. The B-link algorithm is particularly well suited for use with replicated B-tree nodes because it allows tree operations to continue around inconsistencies, and inconsistencies may last longer than with a shared memory architecture.
Reference: [Kle75] <author> L. Kleinrock. </author> <title> Queueing Systems, Volume 1: Theory. </title> <publisher> Wiley Interscience, </publisher> <year> 1975. </year>
Reference-contexts: The formula for the mean residual service time, r j;k , comes from renewal theory (see <ref> [Cox62, Kle75] </ref>). Note that when the service time distribution is exponential, 2 j;k = S 2 so r j;k = S j;k , as expected. We delay further discussion of our use of service time variance until section 4.4.4. 32 One additional comment on residual service time is required.
Reference: [Kru83] <author> C. P. Kruskal. </author> <title> Searching, Merging, and Sorting in Parallel Computation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-32(10):942-946, </volume> <year> 1983. </year>
Reference-contexts: The goal of such an extension is to produce a speedup in the processing of B-tree operations. In this work we seek a speedup through the concurrent execution of many requests, not through parallel execution of a single request. Kruskal <ref> [Kru83] </ref> showed that the reduction in latency from parallel execution of a single search is at best logarithmic with the number of processors. In contrast, Wang's study of concurrent, distributed B-trees with partial node replication [Wan91], showed near linear increases in lookup throughput with increasing processors.
Reference: [KW82] <author> Y. Kwong and D. Wood. </author> <title> A New Method for Concurrency in B-trees. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-8(3):211-222, </volume> <month> May </month> <year> 1982. </year>
Reference-contexts: The original proposal did not support the merging of nodes. Lanin and Shasha [LS86] proposed a variant with "backlinks" or left-links to support merging. Wang [Wan91] added a slight correction to this algorithm. Other algorithms have been proposed, as well as variants of these <ref> [KW82, MR85, Sag85] </ref>, but lock coupling and B-link remain the dominant options. All proposals introduce some temporary limit on throughput when performing a restructuring modification, either by locking out access to a sub-tree or lengthening the chain of pointers that must be followed to reach the correct leaf.
Reference: [LS86] <author> V. Lanin and D. Shasha. </author> <title> A Symmetric Concurrent B-tree Algorithm. </title> <booktitle> In 1986 Fall Joint Computer Conference, </booktitle> <pages> pages 380-389, </pages> <year> 1986. </year> <month> 127 </month>
Reference-contexts: The right-link structure only supports concurrent splits of B-tree nodes. The original proposal did not support the merging of nodes. Lanin and Shasha <ref> [LS86] </ref> proposed a variant with "backlinks" or left-links to support merging. Wang [Wan91] added a slight correction to this algorithm. Other algorithms have been proposed, as well as variants of these [KW82, MR85, Sag85], but lock coupling and B-link remain the dominant options. <p> Analysis of the various approaches has shown that the B-link algorithm can provide the greatest increases in throughput <ref> [LS86, JS90, Wan91, SC91] </ref>. We use the B-link algorithm and perform only splits in our simulations. The B-link algorithm is particularly well suited for use with replicated B-tree nodes because it allows tree operations to continue around inconsistencies, and inconsistencies may last longer than with a shared memory architecture.
Reference: [LY81] <author> P. L. Lehman and S. B. Yao. </author> <title> Efficient Locking for Concurrent Operations on B--trees. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(4) </volume> <pages> 650-670, </pages> <year> 1981. </year>
Reference-contexts: To date little work has been done on the static or dynamic problem. Lehman and Yao <ref> [LY81] </ref> developed a B-tree structure that allows concurrent access, but has been historically applied to single processors and shared-memory multiprocessors. <p> The costs of lock coupling increase when the B-tree is distributed across several processors and some nodes are replicated locks must then be held across several processors at the same time. Lehman and Yao <ref> [LY81] </ref> suggested the alternative of B-link trees, a variant of the B-tree in which every node is augmented with a link pointer directed to its sibling on the right.
Reference: [LZGS84] <author> E. Lazowska, J. Zahorjan, G. S. Graham, and K. Sevcik. </author> <title> Quantitative System Performance: Computer System Analysis Using Queueing Network Models. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1984. </year>
Reference-contexts: Most real-world systems to be modeled, including ours, do not meet product-form requirements exactly. However, the techniques for solving product-form networks, with appropriate extensions, have been shown to give accurate results even when product-form requirements are not met <ref> [LZGS84, Bar79, HL84, dSeSM89] </ref>. Our results indicate the extensions are sufficiently accurate to be useful in understanding our problem. To use a queueing network model, we must provide the model with a description of the service centers, customer classes, and class service demand requirements. <p> This change affects the amount of service time remaining for a customer being served at arrival. We describe the required equation change below. In response to these three differences, the MVA equations become <ref> [Rei79a, LZGS84] </ref>: 1. Little's Law applied to the network to calculate system throughput per class from the mean residence time per class at each server. X c (N) = P K 2. <p> We calculate a "blended" residual service time based on the probability that an addition to the work queue is the local return of a result. 4.3.3 Exact MVA Algorithm and Simplifications The exact multi-class MVA algorithm, from Lazowska <ref> [LZGS84] </ref>, is shown in Figure 4-4. This algorithm is not generally useful for large systems, as the time and space requirements are proportional to KC Q C c=1 (N c + 1). In our work, we use the exact algorithm only when there is one customer per class. <p> Rather than develop a more complicated "simplification" for the equations, we use a simplified algorithm, the approximate MVA algorithm (from Lazowska <ref> [LZGS84] </ref>) shown in Figure 4-6, and use Schweitzer's method for our approximations.
Reference: [MR85] <author> Y. Mond and Y. Raz. </author> <title> Concurrency Control in B + -Trees Databases Using Preparatory Operations. </title> <booktitle> In 11th International Conference on Very Large Databases, </booktitle> <pages> pages 331-334. </pages> <address> Stockholm, </address> <month> August </month> <year> 1985. </year>
Reference-contexts: The original proposal did not support the merging of nodes. Lanin and Shasha [LS86] proposed a variant with "backlinks" or left-links to support merging. Wang [Wan91] added a slight correction to this algorithm. Other algorithms have been proposed, as well as variants of these <ref> [KW82, MR85, Sag85] </ref>, but lock coupling and B-link remain the dominant options. All proposals introduce some temporary limit on throughput when performing a restructuring modification, either by locking out access to a sub-tree or lengthening the chain of pointers that must be followed to reach the correct leaf.
Reference: [PS85] <author> J. Peterson and A. Silberschatz. </author> <title> Operating Systems Concepts. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <year> 1985. </year>
Reference-contexts: must allocate an unused cache entry or discard a currently cached node. (When a cache entry is discarded, the "master" copy of the node is notified.) For the simulations in this chapter we manage the cache with a replacement algorithm developed by the MULTICS project [Cor69], sometimes called second chance, <ref> [PS85] </ref>, clock or marking replacement. In this algorithm a cache entry is "marked" every time it is used. A pointer points to the last cache location discarded.
Reference: [Rei79a] <author> M. Reiser. </author> <title> A Queueing Network Analysis of Computer Communication Networks with Window Flow Control. </title> <journal> IEEE Transactions on Communications, </journal> <volume> C-27(8):1199-1209, </volume> <year> 1979. </year>
Reference-contexts: This change affects the amount of service time remaining for a customer being served at arrival. We describe the required equation change below. In response to these three differences, the MVA equations become <ref> [Rei79a, LZGS84] </ref>: 1. Little's Law applied to the network to calculate system throughput per class from the mean residence time per class at each server. X c (N) = P K 2.
Reference: [Rei79b] <author> M. Reiser. </author> <title> Mean Value Analysis of Queueing Networks, A New Look at an Old Problem. </title> <editor> In M. Arato, A. Butrimenko, and E. Gelenbe, editors, </editor> <booktitle> Performance of Computer Systems, pages 63-. </booktitle> <publisher> North-Holland Publishing Co., </publisher> <year> 1979. </year> <note> Also IBM RC 7228. </note>
Reference-contexts: We can also study the affects of more efficient implementations without actually building the system. The queueing network technique we use is Mean Value Analysis (MVA), developed by Reiser and Lavenberg <ref> [Rei79b, RL80] </ref>. We use variations of this technique to construct two different models for distributed B-tree performance. When there is little or no replication of B-tree nodes, a small number of B-tree nodes (and therefore processors) will be a bottleneck for system throughput. <p> The lower throughput result of the two models is used as the composite result. 4.3 Mean Value Analysis Reiser and Lavenberg <ref> [Rei79b, RL80] </ref> have shown that it is possible to compute mean values for queueing network statistics such as queue sizes, waiting times, utilizations, throughputs and latencies for closed, multi-class queueing networks with product-form solution, given the inputs introduced in the previous section.
Reference: [RL80] <author> M. Reiser and S. S. Lavenberg. </author> <title> Mean-Value Analysis of Closed Multichain Queuing Networks. </title> <journal> Journal of the ACM, </journal> <volume> 27(2) </volume> <pages> 313-322, </pages> <month> April </month> <year> 1980. </year>
Reference-contexts: We can also study the affects of more efficient implementations without actually building the system. The queueing network technique we use is Mean Value Analysis (MVA), developed by Reiser and Lavenberg <ref> [Rei79b, RL80] </ref>. We use variations of this technique to construct two different models for distributed B-tree performance. When there is little or no replication of B-tree nodes, a small number of B-tree nodes (and therefore processors) will be a bottleneck for system throughput. <p> The lower throughput result of the two models is used as the composite result. 4.3 Mean Value Analysis Reiser and Lavenberg <ref> [Rei79b, RL80] </ref> have shown that it is possible to compute mean values for queueing network statistics such as queue sizes, waiting times, utilizations, throughputs and latencies for closed, multi-class queueing networks with product-form solution, given the inputs introduced in the previous section. <p> R k (N ) = &gt; &lt; D k delay center D k fl (1 + A k (N )) queueing center 29 The innovation of the MVA algorithm was the method for computing A k (N ), the mean queue length at customer arrival. Reiser and Lavenberg <ref> [RL80] </ref> and Sevcik and Mitrani [SM81] independently proved the arrival theorem that states A k (N ) = Q k (N 1); that is, the average number of customers seen at a service center on arrival is equal to the steady state queue length with one customer removed from the system.
Reference: [Sag85] <author> Y. Sagiv. </author> <title> Concurrent Operations on B fl -Trees with Overtaking. </title> <booktitle> In Fourth Annual ACM SIGACT/SIGMOD Symposium on the Principles of Database Systems, </booktitle> <pages> pages 28-37. </pages> <publisher> ACM, </publisher> <year> 1985. </year>
Reference-contexts: The original proposal did not support the merging of nodes. Lanin and Shasha [LS86] proposed a variant with "backlinks" or left-links to support merging. Wang [Wan91] added a slight correction to this algorithm. Other algorithms have been proposed, as well as variants of these <ref> [KW82, MR85, Sag85] </ref>, but lock coupling and B-link remain the dominant options. All proposals introduce some temporary limit on throughput when performing a restructuring modification, either by locking out access to a sub-tree or lengthening the chain of pointers that must be followed to reach the correct leaf.
Reference: [SC91] <author> V. Srinivasan and M. Carey. </author> <title> Performance of B-tree Concurrency Control Algorithms. </title> <booktitle> In Proceedings of the International Conference on Management of Data, </booktitle> <pages> pages 416-425. </pages> <booktitle> ACM, 1991. (ACM SIGMOD Record, </booktitle> <volume> Vol. 20, Number 2). </volume>
Reference-contexts: Analysis of the various approaches has shown that the B-link algorithm can provide the greatest increases in throughput <ref> [LS86, JS90, Wan91, SC91] </ref>. We use the B-link algorithm and perform only splits in our simulations. The B-link algorithm is particularly well suited for use with replicated B-tree nodes because it allows tree operations to continue around inconsistencies, and inconsistencies may last longer than with a shared memory architecture.
Reference: [SM81] <author> K. C. Sevcik and I. Mitrani. </author> <title> The Distribution of Queueing Network States at Input and Output Instants. </title> <journal> Journal of the ACM, </journal> <volume> 28(2) </volume> <pages> 358-371, </pages> <month> April </month> <year> 1981. </year>
Reference-contexts: Reiser and Lavenberg [RL80] and Sevcik and Mitrani <ref> [SM81] </ref> independently proved the arrival theorem that states A k (N ) = Q k (N 1); that is, the average number of customers seen at a service center on arrival is equal to the steady state queue length with one customer removed from the system.
Reference: [Wan91] <author> P. Wang. </author> <title> An In-Depth Analysis of Concurrent B-tree Algorithms. </title> <type> Technical Report TR-496, </type> <institution> MIT, </institution> <year> 1991. </year> <booktitle> Related paper appears in Proceedings of the IEEE Symposium on Parallel and Distributed Processing, </booktitle> <year> 1990. </year>
Reference-contexts: The obvious solution is to create replicas or copies of selected B-tree nodes on other processors to reduce or eliminate the root bottleneck and reduce the volume of inter-processor messages. Wang <ref> [Wan91] </ref> has shown that replicating parts of the B-tree structure on more than one processor does increase throughput. But while the one original copy of each tree node may be too few, copying the entire B-tree wastes space and requires work to keep the copies consistent. <p> To date little work has been done on the static or dynamic problem. Lehman and Yao [LY81] developed a B-tree structure that allows concurrent access, but has been historically applied to single processors and shared-memory multiprocessors. Of the work done with distributed B-trees, Wang <ref> [Wan91] </ref> showed that increased throughput can be obtained through replicating parts of the B-tree structure, but did not directly address how much replication is necessary or how it can be controlled. <p> Kruskal [Kru83] showed that the reduction in latency from parallel execution of a single search is at best logarithmic with the number of processors. In contrast, Wang's study of concurrent, distributed B-trees with partial node replication <ref> [Wan91] </ref>, showed near linear increases in lookup throughput with increasing processors. To efficiently utilize many processors concurrently participating in B-tree operations, we must extend the B-tree algorithm to control concurrent access and modification of the B-tree, and to efficiently distribute the B-tree data structure and processing across the several processors. <p> The right-link structure only supports concurrent splits of B-tree nodes. The original proposal did not support the merging of nodes. Lanin and Shasha [LS86] proposed a variant with "backlinks" or left-links to support merging. Wang <ref> [Wan91] </ref> added a slight correction to this algorithm. Other algorithms have been proposed, as well as variants of these [KW82, MR85, Sag85], but lock coupling and B-link remain the dominant options. <p> Analysis of the various approaches has shown that the B-link algorithm can provide the greatest increases in throughput <ref> [LS86, JS90, Wan91, SC91] </ref>. We use the B-link algorithm and perform only splits in our simulations. The B-link algorithm is particularly well suited for use with replicated B-tree nodes because it allows tree operations to continue around inconsistencies, and inconsistencies may last longer than with a shared memory architecture. <p> To date there has been little or no work studying dynamic replication for B-trees or even the relationship between replication and performance under static load patterns. However, we take as starting points the replication models used in previous work on distributed B-trees. Wang's <ref> [Wan91] </ref> work on concurrent B-trees was instrumental in showing the possibilities of replication to improve distributed B-tree performance. This work did not explicitly address the issue of node and copy placement because of constraints of the tools being used. In essence, the underlying system placed nodes and copies randomly. <p> However, they do not all have to be updated instantaneously to achieve good B-tree performance. Wang's work <ref> [Wan91] </ref> showed that B-link algorithms do not require strict coherence of the copies of a node. Instead of an atomic update of all copies, he used a weaker version of coherence called multi-version memory [WW90]. Wang demonstrated this approach to coherence dramatically improves concurrent B-tree performance.
Reference: [WBC + 91] <author> W. E. Weihl, E. Brewer, A. Colbrook, C. Dellarocas, W. Hsieh, A. Joseph, C. Waldsburger, and P. Wang. </author> <title> Prelude: A System for Portable Parallel Software. </title> <type> Technical Report TR-519, </type> <institution> MIT, </institution> <year> 1991. </year>
Reference-contexts: The model for both elements was the runtime system of Prelude, a programming language being developed on top of Proteus for writing portable, MIMD parallel programs <ref> [WBC + 91] </ref>. Prelude provided a model for message dispatching and a mechanism for referencing objects across processors [HBDW91].
Reference: [WW90] <author> W. E. Weihl and P. Wang. </author> <title> Multi-Version Memory: Software Cache Management for Concurrent B-trees. </title> <booktitle> In Proceedings of the IEEE Symposium on Parallel and Distributed Processing, </booktitle> <pages> pages 650-655. </pages> <publisher> IEEE, </publisher> <month> December </month> <year> 1990. </year> <month> 128 </month>
Reference-contexts: When one copy of a node is modified, the others are all incorrect. The updates to copies of nodes cannot be distributed instantaneously and during the delay we would like other operations to be allowed to use the temporarily out-of-date copies. As Wang <ref> [WW90] </ref> noted in his work on multi-version memory, the B-link structure allows operations to correct themselves by following the right link from an up-to-date copy if they happen to use out-of-date information and reach an incorrect tree node. <p> Wang's work [Wan91] showed that B-link algorithms do not require strict coherence of the copies of a node. Instead of an atomic update of all copies, he used a weaker version of coherence called multi-version memory <ref> [WW90] </ref>. Wang demonstrated this approach to coherence dramatically improves concurrent B-tree performance. Multi-version memory still leaves a choice for how updates are distributed and old versions brought up to date. Two methods have been proposed.
References-found: 40

