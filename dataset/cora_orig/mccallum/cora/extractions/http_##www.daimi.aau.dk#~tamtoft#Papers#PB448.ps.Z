URL: http://www.daimi.aau.dk/~tamtoft/Papers/PB448.ps.Z
Refering-URL: http://www.daimi.aau.dk/~tamtoft/papers.html
Root-URL: http://www.daimi.aau.dk
Email: internet: tamtoft@daimi.aau.dk  
Title: Strictness Types: An Inference Algorithm and an Application  
Author: Torben Amtoft 
Note: Everything has been implemented; documentation can be found in ap pendix.  
Date: August 10, 1993  
Address: Ny Munkegade, DK-8000 Arhus C, Denmark  
Affiliation: Computer Science Department Aarhus University,  
Abstract: This report deals with strictness types, a way of recording whether a function needs its argument(s) or not. We shall present an inference system for assigning strictness types to expressions and subsequently we transform this system into an algorithm capable of annotating expressions with strictness types. We give an example of a transformation which can be optimized by means of these annotations, and finally we prove the correctness of the optimized transformation at the same time proving the correctness of the annotation. 
Abstract-found: 1
Intro-found: 1
Reference: [BHA86] <author> Geoffrey L. Burn, Chris Hankin, and Samson Abramsky. </author> <title> Strictness analysis for higher-order functions. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 7 </volume> <pages> 249-278, </pages> <year> 1986. </year>
Reference-contexts: Recent years have seen many approaches to strictness analysis, most based on abstract interpretation the starting point being the work of Mycroft [Myc80] which was extended to higher order functions by Burn, Hankin and Abramsky <ref> [BHA86] </ref>. <p> For instance, the translation presented in [DH93] is not proved correct, and even though the strictness analysis presented in <ref> [BHA86] </ref> is proved correct (in the sense that the abstract semantics actually abstracts the concrete semantics) the correctness of an optimization based on this analysis has not been proved.
Reference: [DH92] <author> Olivier Danvy and John Hatcliff. </author> <title> Thunks (continued). </title> <editor> In M. Billaud et al., editor, Analyse statique, </editor> <booktitle> Bordeaux 92 (WSA '92), </booktitle> <pages> pages 3-11, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: On the other hand, as most implementations are call-by-value (CBV) one has to find means for translating from CBN to CBV. The naive approach (as presented e.g. in <ref> [DH92] </ref>) is to "thunkify" all arguments to applications, that is we have the following translation T : * An abstraction x:e translates into x:T (e); * An application e 1 e 2 translates into T (e 1 )(x:T (e 2 )) (where x is a fresh variable) that is, the evaluation
Reference: [DH93] <author> Olivier Danvy and John Hatcliff. </author> <title> CPS transformation after strictness analysis. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 1(3), </volume> <year> 1993. </year>
Reference-contexts: Mycroft's work on strictness analysis. Accordingly, in Sect. 5 we shall present a translation from CBN to CBV which exploits the information present in the strictness types. This translation is essentially similar to the one given by Danvy and Hatcliff <ref> [DH93] </ref>. 1.4 Proving the Translation Correct The optimized translation from CBN to CBV is folklore but a correctness proof is certainly not. For instance, the translation presented in [DH93] is not proved correct, and even though the strictness analysis presented in [BHA86] is proved correct (in the sense that the abstract <p> This translation is essentially similar to the one given by Danvy and Hatcliff <ref> [DH93] </ref>. 1.4 Proving the Translation Correct The optimized translation from CBN to CBV is folklore but a correctness proof is certainly not. For instance, the translation presented in [DH93] is not proved correct, and even though the strictness analysis presented in [BHA86] is proved correct (in the sense that the abstract semantics actually abstracts the concrete semantics) the correctness of an optimization based on this analysis has not been proved.
Reference: [Hug89] <author> John Hughes. </author> <title> Why functional programming matters. </title> <journal> Computer Journal, </journal> <volume> 32(2) </volume> <pages> 98-107, </pages> <year> 1989. </year>
Reference-contexts: new on the other hand, since constraint solving appears in 3 numerous contexts it is quite possible that similar approaches exist in the literature. 1.3 Translating from CBN to CBV Call-by-name (CBN) evaluation of the -calculus (and especially the variant known as "lazy evaluation") has been widely praised (e.g. in <ref> [Hug89] </ref>) because it makes programming a much more convenient task (another advantage is that referential transparency holds). On the other hand, as most implementations are call-by-value (CBV) one has to find means for translating from CBN to CBV.
Reference: [Jen91] <author> Thomas P. Jensen. </author> <title> Strictness analysis in logical form. </title> <editor> In John Hughes, editor, </editor> <booktitle> International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 352-366. </pages> <publisher> Springer Verlag, LNCS 523, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: Accordingly, if it is possible to assign a function the type 0!0 we know that the function is strict. This system, however, is strictly weaker than one based on abstract interpretation on the other hand, Jensen <ref> [Jen91] </ref> proves that if conjunction types are added to the type system one gets a type system with the same power as abstract interpretation.
Reference: [KM89] <author> Tsung-Min Kuo and Prateek Mishra. </author> <title> Strictness analysis: A new perspective based on type inference. </title> <booktitle> In International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 260-272. </pages> <publisher> ACM Press, </publisher> <month> September </month> <year> 1989. </year> <month> 45 </month>
Reference-contexts: Kuo and Mishra <ref> [KM89] </ref> presented a type system where types t are formed from 0 (denoting non-termination), 1 (denoting non-termination or termination, i.e. any term) and t 1 !t 2 . Accordingly, if it is possible to assign a function the type 0!0 we know that the function is strict. <p> It should be clear that this is weaker than abstract interpretation, as Int! 0 Int corresponds to two functions on the abstract domain: the identity function and the zero function. On the other hand, in some cases the method is more powerful than the one of <ref> [KM89] </ref>: a function which needs both of its arguments (cf. the above) can be assigned type Int! 0 Int! 0 Int. <p> e : t; (b; W ) 12 Example 3.5 Consider the function f defined by rec f x:y:z:e where e = if (z = 0) (x + y) (f y x (z 1)). f is strict in all its arguments, but this cannot be inferred by the type system from <ref> [KM89] </ref> due to the lack of conjunction types.
Reference: [Lan92] <author> Torben Poort Lange. </author> <title> The correctness of an optimized code generation. </title> <type> Technical Report PB-427, DAIMI, </type> <institution> University of Aarhus, Denmark, </institution> <month> November </month> <year> 1992. </year> <note> Also in the proceedings of PEPM '93, Copenhagen, ACM press. </note>
Reference-contexts: In [Wan93], Wand proved the correctness of a partial evaluator which exploits binding time information. In Sect. 6 we follow this trend, within the context defined in Sect. 5 (i.e. a CBN-to-CBV translator exploiting strictness information). Also something similar can be found in <ref> [Lan92] </ref> where the correctness of a code generation exploiting strictness information is proved.
Reference: [Myc80] <author> Alan Mycroft. </author> <title> The theory of transforming call-by-need to call-by-value. </title> <editor> In B. Robinet, editor, </editor> <booktitle> International Symposium on Programming, Paris, </booktitle> <pages> pages 269-281. </pages> <publisher> Springer Verlag, LNCS 83, </publisher> <month> April </month> <year> 1980. </year>
Reference-contexts: 1 Introduction 1.1 Strictness Types Strictness analysis is the task of detecting whether a function needs its arguments. Recent years have seen many approaches to strictness analysis, most based on abstract interpretation the starting point being the work of Mycroft <ref> [Myc80] </ref> which was extended to higher order functions by Burn, Hankin and Abramsky [BHA86].
Reference: [NN90] <author> Hanne Riis Nielson and Flemming Nielson. </author> <title> Context information for lazy code generation. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 251-263. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: Example 3.6. And to avoid the kind of superfluous dethunkification/thunkification we encountered in Example 5.2, one may consider keeping track of context somewhat similar to what is done in <ref> [NN90] </ref>.
Reference: [Wan93] <author> Mitchell Wand. </author> <title> Specifying the correctness of binding-time analysis. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 137-143. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1993. </year>
Reference-contexts: The same remarks apply to e.g. [Wri91] and reflect a quite general phenomenon, cf. the claims made in <ref> [Wan93, p. 137] </ref>: 4 The goal of flow analysis is to annotate a program with certain propositions about the behavior of that program. One can then apply optimizations to the program that are justified by those propositions. <p> One can then apply optimizations to the program that are justified by those propositions. However, it has proven remarkably difficult to specify the semantics of those propositions in a way that justifies the resulting optimizations. In <ref> [Wan93] </ref>, Wand proved the correctness of a partial evaluator which exploits binding time information. In Sect. 6 we follow this trend, within the context defined in Sect. 5 (i.e. a CBN-to-CBV translator exploiting strictness information). <p> The noteworthy point is that the fact that a function actually is strict is not expressed using some relationship between concrete/abstract do mains, but simply by stating that it is correct not to thunkify its argu ment! This corresponds to the claim in <ref> [Wan93, p. 137] </ref>: This work suggests that the proposition associated with a flow analysis can simply be that "the optimization works". <p> This concludes the proof of Theorem 6.2. 7 Concluding Remarks We believe the main contributions of this paper to be: 44 * one more (the second, the first being <ref> [Wan93] </ref>) application has been given of the paradigm: an analysis and a transformation exploiting this analysis should be proved correct simultaneously; * a (we think) novel approach to constraint solving, based on normalizing constraints while distinguishing between co/contravariant polarity, has been presented.
Reference: [Wri91] <author> David A. Wright. </author> <title> A new technique for strictness analysis. </title> <booktitle> In TAPSOFT 91, </booktitle> <pages> pages 235-258. </pages> <publisher> Springer Verlag, LNCS 494, </publisher> <month> April </month> <year> 1991. </year>
Reference-contexts: Such a function needs both of its arguments, and accordingly it has type 0!1!0 as well as type 1!0!0. Wright has proposed alternative type systems <ref> [Wri91] </ref> and [Wri92]. The idea is to annotate the arrows: if a function can be assigned type Int! 0 Int this means that the function is strict, whereas a type Int! 1 Int doesn't tell anything about strictness properties. <p> We are thus left with the problem of solving those constraints. In type inference one is usually interested in finding a "principal type" such that all other valid typings can be found as substitution instances of this type. This is also the approach taken in <ref> [Wri91] </ref>. In our framework (which in this respect differs from Wright's), we would like to find a "least type" (wrt. the ordering ). <p> The same remarks apply to e.g. <ref> [Wri91] </ref> and reflect a quite general phenomenon, cf. the claims made in [Wan93, p. 137]: 4 The goal of flow analysis is to annotate a program with certain propositions about the behavior of that program. One can then apply optimizations to the program that are justified by those propositions.
Reference: [Wri92] <author> David A. Wright. </author> <title> An intensional type discipline. </title> <journal> Australian Computer Science Communications, </journal> <volume> 14, </volume> <month> January </month> <year> 1992. </year>
Reference-contexts: Such a function needs both of its arguments, and accordingly it has type 0!1!0 as well as type 1!0!0. Wright has proposed alternative type systems [Wri91] and <ref> [Wri92] </ref>. The idea is to annotate the arrows: if a function can be assigned type Int! 0 Int this means that the function is strict, whereas a type Int! 1 Int doesn't tell anything about strictness properties.
References-found: 12

