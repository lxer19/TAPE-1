URL: ftp://ftp.cs.brown.edu/pub/techreports/91/cs91-41.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-91-41.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [B + 87] <author> Jay Banerjee et al. </author> <title> Data Model Issues for Object-Oriented Applications. </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 5(1) </volume> <pages> 3-26, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Optimization results have also been extended to include more expressive models, such as nested [S + 89, Kor88] and network models [RR85, R + 83]. Object-oriented databases are extensible systems which support (among other features) abstract data types, type inheritance (subtyping), methods and late-binding, and object identity <ref> [MS87, BDK91, ZW86, MD90, B + 87] </ref>. The extensibility of object-oriented databases is founded on the ability to extend the data model through abstract data types and the inheritance structure.
Reference: [B + 90] <author> D. S. Batory et al. </author> <title> GENESIS: An Extensible Database Management System. </title> <editor> In Stanley B. Zdonik and David Maier, editors, </editor> <booktitle> Readings in Object-Oriented Database Systems, </booktitle> <pages> pages 500-518. </pages> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1990. </year>
Reference-contexts: A need for extensibility in data modelling and access led to the development of databases in which such aspects as the data types, operators, and access methods can be extended <ref> [H + 89, SR86, B + 90, CD + 86] </ref>. Extensible database systems often use algebraic rules about query operations to provide transformations that can be applied to queries to generate expressions that will be more 12 efficient to process.
Reference: [BDK91] <editor> F. Bancilhon, C. Delobel, and P. Kanellakis, editors. </editor> <title> Building an Object Oriented Database System: </title> <publisher> the Story of O 2 . Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1991. </year>
Reference-contexts: Optimization results have also been extended to include more expressive models, such as nested [S + 89, Kor88] and network models [RR85, R + 83]. Object-oriented databases are extensible systems which support (among other features) abstract data types, type inheritance (subtyping), methods and late-binding, and object identity <ref> [MS87, BDK91, ZW86, MD90, B + 87] </ref>. The extensibility of object-oriented databases is founded on the ability to extend the data model through abstract data types and the inheritance structure.
Reference: [BK89] <author> Elisa Bertino and Won Kim. </author> <title> Indexing Techniques for Queries on Nested Objects. </title> <type> Technical Report ACT-OODS-132-89, </type> <institution> MCC, </institution> <year> 1989. </year>
Reference-contexts: Support for complex structures also results in languages that regularly use nested query expressions, where variables from outer expressions are referenced in nested expressions. One difficulty with path expressions is the definition of indices for such expressions <ref> [MS86, BK89] </ref>. The presence of arbitrary methods in the path further complicates this problem. The maintenance of an index can require the application of methods and those methods could manipulate arbitrarily many objects. Another problem with path expressions is that they imply an execution order for properties on the path.
Reference: [BK90a] <author> Fran~cois Bancilhon and Won Kim. </author> <title> Object-Oriented Database Systems: In Transition. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 19(4) </volume> <pages> 49-53, </pages> <month> Dec </month> <year> 1990. </year>
Reference-contexts: These techniques are concerned, in particular, with accessing complex structures and the processing of nested query expressions. Optimization in the presence of encapsulation and methods is a recognized problem that is still being studied <ref> [BK90a] </ref>. Graefe and Ward [GW89] propose to statically generate query evaluation plans with alternatives. Information available about objects is used at execution time to choose among the alternatives and generate a final evaluation plan.
Reference: [BK90b] <author> Catriel Beeri and Yoram Kornatzky. </author> <title> Algebraic Optimization of Object-Oriented Query Languages. </title> <booktitle> In Proceedings ICDT, </booktitle> <address> Paris, France, </address> <year> 1990. </year>
Reference-contexts: For example, a method could be written in the query language understood by the optimizer. The method code could then be merged with the query and managed by the query optimizer <ref> [BK90b] </ref>. This approach, of course, limits the expressibility of methods to that of the query language. If the optimizer gathers cost information about a method by querying the method itself [GM88] then type Method must define an interface that can provide the required information. <p> In particular they explore efficient alternatives to object navigation. Kemper and Moerkotte explore the use of relations to support navigation [KM90]. A variety of proposals have been made for optimization based on algebraic transformation rules for query operations <ref> [LB89, Osb88, Zdo89, SO89, BK90b] </ref>. For example, Straube and Ozsu [Str90] propose a methodology for query optimization that includes calculus-based optimization, the transformation of calculus-based queries to algebraic form, type-checking of algebraic expressions, the application of algebraic transformation axioms, and the generation of access plans for the algebraic operations. <p> For example, Straube and Ozsu [Str90] propose a methodology for query optimization that includes calculus-based optimization, the transformation of calculus-based queries to algebraic form, type-checking of algebraic expressions, the application of algebraic transformation axioms, and the generation of access plans for the algebraic operations. Beeri and Kornatzky <ref> [BK90b] </ref> assume there exists a rule-based optimizer and provide an extensive set of rules for bulk data types, thus generalizing existing axioms for object-oriented algebras. Other work in object-oriented query optimization has concentrated on problems that are more specific to object-oriented models.
Reference: [BKK88] <author> Jay Banerjee, Won Kim, and Kyung-Chang Kim. </author> <title> Queries in Object-Oriented Databases. </title> <booktitle> In Proceedings 4th Intl. Conf. on Data Engineering, </booktitle> <pages> pages 31-38. </pages> <publisher> IEEE, </publisher> <month> Feb </month> <year> 1988. </year>
Reference-contexts: We use the EQUAL operations and the ENCORE model to illustrate the discussion in the remainder of this paper. The examples in this exposition will refer to the sample scheme of Table 1. The scheme represents a car-manufacturer database (similar to <ref> [BKK88] </ref>) in which companies have departments, and vehicles are manufactured by companies. There is also a hierarchy of people which includes employees, managers (specialized employees), and students who study at a company under the direction of a manager. Some students are paid while they study (type Student-Employee).
Reference: [CD + 86] <author> Michael J. Carey, David J. DeWitt, et al. </author> <title> The architecture of the exodus extensible dbms. </title> <booktitle> In Proceedings of the 1986 International Workshop on Object-Oriented Database Systems, </booktitle> <pages> pages 52-65, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: A need for extensibility in data modelling and access led to the development of databases in which such aspects as the data types, operators, and access methods can be extended <ref> [H + 89, SR86, B + 90, CD + 86] </ref>. Extensible database systems often use algebraic rules about query operations to provide transformations that can be applied to queries to generate expressions that will be more 12 efficient to process.
Reference: [CD90] <author> Sophie Cluet and Claude Delobel, </author> <month> May </month> <year> 1990. </year> <type> unpublished manuscript. </type>
Reference-contexts: Other work in object-oriented query optimization has concentrated on problems that are more specific to object-oriented models. Research on optimization in O 2 <ref> [CD90] </ref>, for example, combines the Orion results with techniques that include the factorization of common subexpressions, cost-based application of query rewrite rules, and the use of indexes and clustering to guide the query rewrite process and aid in determining access plans.
Reference: [Dat89] <author> C. J. Date. </author> <title> An Introduction to Database Systems, volume I. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA., 5th edition, </address> <year> 1989. </year>
Reference-contexts: Relational query optimizers exploit the semantics of the model and the fixed sets of operators, storage structures, and implementation techniques for the operators. The designs of such optimizers differ and are specific to the system in which the optimizer is built <ref> [Ull89, Dat89] </ref>. Most optimization strategies for relational optimizers focus on queries involving the Select, Project and Join operators (see [Ull89] for a discussion of the theory upon which such strategies are based). Further work in relational optimization looked at extending optimization to include other operators, for example aggregators [Kim82, Day87].
Reference: [Day87] <author> Umeshwar Dayal. </author> <title> Of Nests and Trees: A Unified Approach to Processing Queries That Contain Nested Subqueries, Aggregates, and Quantifiers. </title> <booktitle> In Proceedings of the 13th VLDB Conference, </booktitle> <pages> pages 197-208, </pages> <year> 1987. </year>
Reference-contexts: Most optimization strategies for relational optimizers focus on queries involving the Select, Project and Join operators (see [Ull89] for a discussion of the theory upon which such strategies are based). Further work in relational optimization looked at extending optimization to include other operators, for example aggregators <ref> [Kim82, Day87] </ref>. Optimization results have also been extended to include more expressive models, such as nested [S + 89, Kor88] and network models [RR85, R + 83].
Reference: [Del89] <author> Claude Delobel, </author> <month> May </month> <year> 1989. </year> <type> Personal communication. </type>
Reference-contexts: For example, in the relational model, pushing a Select operation past a Join operation is generally accepted to be a useful transformation. However, in the object-oriented model, the cost of applying a Selection operation is a factor when deciding whether to push the Select past a Join <ref> [Del89] </ref>. The presence of methods in a Selection predicate means that the cost of applying that operation depends on the cost of applying the methods.
Reference: [GD87] <author> Goetz Graefe and David J. DeWitt. </author> <title> The EXODUS Optimizer Generator. </title> <booktitle> In SIGMOD Proceedings, </booktitle> <pages> pages 160-172. </pages> <publisher> ACM, </publisher> <month> May </month> <year> 1987. </year>
Reference-contexts: The revealed information is used to expand the nodes of a query tree with execution information. The query tree, when fully expanded, would be input to a rule-based optimizer such as an EXODUS optimizer <ref> [GD87] </ref>. The variety of problems encountered when optimizing an object-oriented query, and the different approaches to solving these problems, are addressed by our current work in query processing [MZD].
Reference: [GM88] <author> Goetz Graefe and David Maier. </author> <title> Query Optimization in Object-Oriented Database Systems: A Prospectus. </title> <booktitle> In Advances in Object-Oriented Database Systems, </booktitle> <pages> pages 358-363. </pages> <booktitle> International Workshop on Object-Oriented Database Systems, </booktitle> <month> September </month> <year> 1988. </year> <month> 14 </month>
Reference-contexts: We believe that a better understanding of the problems encountered can lead to the development of new (and better) techniques for optimizing object-oriented queries. The application of algebraic transformations has formed the basis for the design of query op-timizers for object-oriented databases <ref> [GM88, SO89, Osb88] </ref>. A recognized difficulty in applying transformations is the problem of manipulating query expressions containing references to arbitrary methods. <p> The method code could then be merged with the query and managed by the query optimizer [BK90b]. This approach, of course, limits the expressibility of methods to that of the query language. If the optimizer gathers cost information about a method by querying the method itself <ref> [GM88] </ref> then type Method must define an interface that can provide the required information. For example, in the simple case, type Method would have a property named cost which, when applied to a method instance, would return an expected cost for executing the method. <p> Information available about objects is used at execution time to choose among the alternatives and generate a final evaluation plan. Graefe and Maier submitted a preliminary architecture for an object-oriented optimizer that sends messages to methods to ask them to "reveal" information about their execution <ref> [GM88] </ref>. The revealed information is used to expand the nodes of a query tree with execution information. The query tree, when fully expanded, would be input to a rule-based optimizer such as an EXODUS optimizer [GD87].
Reference: [GW89] <author> Goetz Graefe and Karen Ward. </author> <title> Dynamic Query Evaluation Plans. </title> <booktitle> In SIGMOD Proceed--ings, </booktitle> <pages> pages 358-366. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: These techniques are concerned, in particular, with accessing complex structures and the processing of nested query expressions. Optimization in the presence of encapsulation and methods is a recognized problem that is still being studied [BK90a]. Graefe and Ward <ref> [GW89] </ref> propose to statically generate query evaluation plans with alternatives. Information available about objects is used at execution time to choose among the alternatives and generate a final evaluation plan.
Reference: [H + 89] <author> Laura M. Haas et al. </author> <title> Extensible Query Processing in Starburst. </title> <booktitle> In SIGMOD Proceedings, </booktitle> <pages> pages 377-388. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: A need for extensibility in data modelling and access led to the development of databases in which such aspects as the data types, operators, and access methods can be extended <ref> [H + 89, SR86, B + 90, CD + 86] </ref>. Extensible database systems often use algebraic rules about query operations to provide transformations that can be applied to queries to generate expressions that will be more 12 efficient to process.
Reference: [HZ80] <author> Michael Hammer and Stanley B. Zdonik, Jr. </author> <title> Knowledge-based query processing. </title> <booktitle> In Proceedings of the 6th VLDB Conference, </booktitle> <pages> pages 137-147. </pages> <publisher> ACM, </publisher> <year> 1980. </year>
Reference-contexts: Since GMempCars has type Set [Vehicle], it must be a subset of Vehicles (the extent of type Vehicle). This simplification is similar to the domain refinement technique in semantic query optimization <ref> [HZ80] </ref>. In our problem, however, the simplification is based on knowledge about set inclusion and abstract data types, not necessarily a particular ADT. Subtyping relationships give similar information about set inclusion relationships. For example, in most object-oriented models, the set Managers is a subset of the set Employees.
Reference: [J + 90] <author> B. Paul Jenq et al. </author> <title> Query Processing in Distributed ORION. </title> <booktitle> In EDBT, </booktitle> <pages> pages 169-187, </pages> <year> 1990. </year>
Reference-contexts: The Gemstone database, for example, focuses on indexing for processing of queries that select from a class based on a predicate [MS86]. Current research on optimization in Orion is directed toward the adaptation of relational techniques to the object-oriented database <ref> [J + 90] </ref>. In particular they explore efficient alternatives to object navigation. Kemper and Moerkotte explore the use of relations to support navigation [KM90]. A variety of proposals have been made for optimization based on algebraic transformation rules for query operations [LB89, Osb88, Zdo89, SO89, BK90b].
Reference: [JS82] <author> G. Jaeschke and H. J. Schek. </author> <title> Remarks on the Algebra of Non First Normal Form Relations. </title> <booktitle> In Proceedings of the Symposium on Principles of Database Systems, </booktitle> <pages> pages 124-138. </pages> <publisher> ACM, </publisher> <month> March </month> <year> 1982. </year>
Reference-contexts: DupEliminate and Coalesce manipulate identities of result objects. Operation Flatten takes a set of sets of objects (type Set [Set [T]]) and returns a set of objects (Set [T]). Nest and UnNest extend the same operators for non-first normal form relations (see <ref> [JS82] </ref>) to sets of objects with identity. Sets of tuples can be unnested to convert a set-valued attribute to single-valued, or nested to create a set-valued attribute. Operation DupEliminate provides the option of eliminating duplicate copies of objects from a collection.
Reference: [KC86] <author> Setrag N. Khoshafian and George P. Copeland. </author> <title> Object Identity. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 406-416. </pages> <publisher> ACM, </publisher> <month> September </month> <year> 1986. </year>
Reference-contexts: When objects have identities, there is a question as to what constitutes equality of two objects (see for example <ref> [KC86] </ref>, [SZ89a]). This carries over to the language, where equality 10 operations are used in predicates and where a decision must be made concerning the creation of new objects by a query.
Reference: [Kim82] <author> Won Kim. </author> <title> On Optimizing an SQL-like Nested Query. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 7(3) </volume> <pages> 443-469, </pages> <month> Sept </month> <year> 1982. </year>
Reference-contexts: Most optimization strategies for relational optimizers focus on queries involving the Select, Project and Join operators (see [Ull89] for a discussion of the theory upon which such strategies are based). Further work in relational optimization looked at extending optimization to include other operators, for example aggregators <ref> [Kim82, Day87] </ref>. Optimization results have also been extended to include more expressive models, such as nested [S + 89, Kor88] and network models [RR85, R + 83].
Reference: [Kim88] <author> Won Kim. </author> <title> A Model of Queries for Object-Oriented Databases. </title> <type> Technical Report ACA-ST-365-88, </type> <institution> MCC, </institution> <year> 1988. </year>
Reference-contexts: Abstract data types in ENCORE give us the ability to define logical complex structures. The properties of an abstract data type are similar to attributes in systems such as Orion <ref> [Kim88] </ref> or O 2 [KLR91] in that they give the ability to access state information about an object. The differences between properties and attributes is important to note however. Properties in ENCORE are actually objects, with methods that access their values.
Reference: [KLR91] <author> Paris Kanellakis, Christophe Lecluse, and Philippe Richard. </author> <title> Introduction to the Data Model. </title> <editor> In Bancilhon et al. </editor> <publisher> [BDK91]. </publisher>
Reference-contexts: Abstract data types in ENCORE give us the ability to define logical complex structures. The properties of an abstract data type are similar to attributes in systems such as Orion [Kim88] or O 2 <ref> [KLR91] </ref> in that they give the ability to access state information about an object. The differences between properties and attributes is important to note however. Properties in ENCORE are actually objects, with methods that access their values. The properties of an object define a logical structure for the object.
Reference: [KM90] <author> Alfons Kemper and Guido Moerkotte. </author> <title> Access Support in Object Bases. </title> <booktitle> In SIGMOD Proceedings, </booktitle> <pages> pages 364-374. </pages> <publisher> ACM, </publisher> <year> 1990. </year>
Reference-contexts: Current research on optimization in Orion is directed toward the adaptation of relational techniques to the object-oriented database [J + 90]. In particular they explore efficient alternatives to object navigation. Kemper and Moerkotte explore the use of relations to support navigation <ref> [KM90] </ref>. A variety of proposals have been made for optimization based on algebraic transformation rules for query operations [LB89, Osb88, Zdo89, SO89, BK90b].
Reference: [Kor88] <author> Henry F. Korth. </author> <title> Optimization of Object-Retrieval Queries. </title> <booktitle> In Advances in Object-Oriented Database Systems, </booktitle> <pages> pages 352-357. </pages> <booktitle> International Workshop on Object-Oriented Database Systems, </booktitle> <month> September </month> <year> 1988. </year>
Reference-contexts: Further work in relational optimization looked at extending optimization to include other operators, for example aggregators [Kim82, Day87]. Optimization results have also been extended to include more expressive models, such as nested <ref> [S + 89, Kor88] </ref> and network models [RR85, R + 83]. Object-oriented databases are extensible systems which support (among other features) abstract data types, type inheritance (subtyping), methods and late-binding, and object identity [MS87, BDK91, ZW86, MD90, B + 87].
Reference: [L + 77] <author> Barbara Liskov et al. </author> <title> Abstraction Mechanisms in CLU. </title> <journal> Communications of the ACM, </journal> <volume> 20(8) </volume> <pages> 564-576, </pages> <month> August </month> <year> 1977. </year>
Reference-contexts: Thus, problems in dealing with optimization in other models also arise in this model. The ENCORE model is based primarily on data abstraction <ref> [L + 77] </ref>. An ENCORE type is an atomic type (Int, String, Boolean, etc.) or an abstract data type describing an interface and an implementation for instances of the type. An instance of a type is an object.
Reference: [LB89] <author> Cesar Galindo Legaria and Renato Barrera. </author> <title> A Rule-Based Query Optimizer. </title> <type> Technical Report 92, </type> <institution> Centro de Investigacion y de Estudios Avanzados Del IPN, </institution> <year> 1989. </year>
Reference-contexts: In particular they explore efficient alternatives to object navigation. Kemper and Moerkotte explore the use of relations to support navigation [KM90]. A variety of proposals have been made for optimization based on algebraic transformation rules for query operations <ref> [LB89, Osb88, Zdo89, SO89, BK90b] </ref>. For example, Straube and Ozsu [Str90] propose a methodology for query optimization that includes calculus-based optimization, the transformation of calculus-based queries to algebraic form, type-checking of algebraic expressions, the application of algebraic transformation axioms, and the generation of access plans for the algebraic operations.
Reference: [MD90] <author> Frank Manola and Umeshwar Dayal. PDM: </author> <title> An Object-Oriented Data Model. </title> <editor> In Stan-ley B. Zdonik and David Maier, editors, </editor> <booktitle> Readings in Object-Oriented Database Systems. </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1990. </year>
Reference-contexts: Optimization results have also been extended to include more expressive models, such as nested [S + 89, Kor88] and network models [RR85, R + 83]. Object-oriented databases are extensible systems which support (among other features) abstract data types, type inheritance (subtyping), methods and late-binding, and object identity <ref> [MS87, BDK91, ZW86, MD90, B + 87] </ref>. The extensibility of object-oriented databases is founded on the ability to extend the data model through abstract data types and the inheritance structure.
Reference: [MS86] <author> David Maier and Jacob Stein. </author> <title> Indexing in an Object-Oriented Database. </title> <booktitle> In International Workshop on Object-Oriented Database Systems, </booktitle> <pages> pages 171-182, </pages> <year> 1986. </year>
Reference-contexts: Support for complex structures also results in languages that regularly use nested query expressions, where variables from outer expressions are referenced in nested expressions. One difficulty with path expressions is the definition of indices for such expressions <ref> [MS86, BK89] </ref>. The presence of arbitrary methods in the path further complicates this problem. The maintenance of an index can require the application of methods and those methods could manipulate arbitrarily many objects. Another problem with path expressions is that they imply an execution order for properties on the path. <p> Optimization techniques and results in relational and extensible databases form the basis for current research in object-oriented query optimization. The Gemstone database, for example, focuses on indexing for processing of queries that select from a class based on a predicate <ref> [MS86] </ref>. Current research on optimization in Orion is directed toward the adaptation of relational techniques to the object-oriented database [J + 90]. In particular they explore efficient alternatives to object navigation. Kemper and Moerkotte explore the use of relations to support navigation [KM90].
Reference: [MS87] <author> David Maier and Jacob Stein. </author> <title> Development and Implementation of an Object-Oriented DBMS. </title> <editor> In B. Shriver and P. Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 355-392. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1987. </year>
Reference-contexts: Optimization results have also been extended to include more expressive models, such as nested [S + 89, Kor88] and network models [RR85, R + 83]. Object-oriented databases are extensible systems which support (among other features) abstract data types, type inheritance (subtyping), methods and late-binding, and object identity <ref> [MS87, BDK91, ZW86, MD90, B + 87] </ref>. The extensibility of object-oriented databases is founded on the ability to extend the data model through abstract data types and the inheritance structure.
Reference: [MZD] <author> Gail Mitchell, Stanley B. Zdonik, and Umeshwar Dayal. </author> <title> An architecture for query processing in persistent object stores. </title> <note> In preparation. 15 </note>
Reference-contexts: The query tree, when fully expanded, would be input to a rule-based optimizer such as an EXODUS optimizer [GD87]. The variety of problems encountered when optimizing an object-oriented query, and the different approaches to solving these problems, are addressed by our current work in query processing <ref> [MZD] </ref>. We propose a new approach to optimizer extensibility which supports extensions to the optimizer control strategies and techniques for query transformation in addition to extensions that support the data model.
Reference: [Osb88] <author> S. L. Osborn. </author> <title> Identity, Equality and Query Optimization. </title> <booktitle> In Advances in Object-Oriented Database Systems, </booktitle> <pages> pages 346-351. </pages> <booktitle> International Workshop on Object-Oriented Database Systems, </booktitle> <month> September </month> <year> 1988. </year>
Reference-contexts: We believe that a better understanding of the problems encountered can lead to the development of new (and better) techniques for optimizing object-oriented queries. The application of algebraic transformations has formed the basis for the design of query op-timizers for object-oriented databases <ref> [GM88, SO89, Osb88] </ref>. A recognized difficulty in applying transformations is the problem of manipulating query expressions containing references to arbitrary methods. <p> In particular they explore efficient alternatives to object navigation. Kemper and Moerkotte explore the use of relations to support navigation [KM90]. A variety of proposals have been made for optimization based on algebraic transformation rules for query operations <ref> [LB89, Osb88, Zdo89, SO89, BK90b] </ref>. For example, Straube and Ozsu [Str90] propose a methodology for query optimization that includes calculus-based optimization, the transformation of calculus-based queries to algebraic form, type-checking of algebraic expressions, the application of algebraic transformation axioms, and the generation of access plans for the algebraic operations.
Reference: [R + 83] <author> Daniel R. Ries et al. </author> <title> Decompilation and Optimization for ADAPLEX: A Procedural Database Language. </title> <type> Technical Report CCA-82-04, </type> <institution> Computer Corporation of America, </institution> <month> Sep </month> <year> 1983. </year>
Reference-contexts: Further work in relational optimization looked at extending optimization to include other operators, for example aggregators [Kim82, Day87]. Optimization results have also been extended to include more expressive models, such as nested [S + 89, Kor88] and network models <ref> [RR85, R + 83] </ref>. Object-oriented databases are extensible systems which support (among other features) abstract data types, type inheritance (subtyping), methods and late-binding, and object identity [MS87, BDK91, ZW86, MD90, B + 87].
Reference: [RR85] <author> Arnon Rosenthal and David S. Reiner. </author> <title> Querying relational views of networks. </title> <editor> In Won Kim, David S. Reiner, and Don S. Batory, editors, </editor> <booktitle> Query Processing in Database Systems, </booktitle> <pages> pages 109-124. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Further work in relational optimization looked at extending optimization to include other operators, for example aggregators [Kim82, Day87]. Optimization results have also been extended to include more expressive models, such as nested [S + 89, Kor88] and network models <ref> [RR85, R + 83] </ref>. Object-oriented databases are extensible systems which support (among other features) abstract data types, type inheritance (subtyping), methods and late-binding, and object identity [MS87, BDK91, ZW86, MD90, B + 87].
Reference: [S + 89] <author> G. Saake et al. </author> <title> Sorting, Grouping and Duplicate Elimination in the Advanced Information Management Prototype. </title> <booktitle> In Proceedings of the 15th VLDB Conference, </booktitle> <pages> pages 307-316, </pages> <year> 1989. </year>
Reference-contexts: Further work in relational optimization looked at extending optimization to include other operators, for example aggregators [Kim82, Day87]. Optimization results have also been extended to include more expressive models, such as nested <ref> [S + 89, Kor88] </ref> and network models [RR85, R + 83]. Object-oriented databases are extensible systems which support (among other features) abstract data types, type inheritance (subtyping), methods and late-binding, and object identity [MS87, BDK91, ZW86, MD90, B + 87].
Reference: [SC75] <author> John Miles Smith and Philip Yen-Tang Chang. </author> <title> Optimizing the Performance of a Relational Algebra Database Interface. </title> <journal> Communications of the ACM, </journal> <volume> 8(10) </volume> <pages> 568-579, </pages> <month> Oct </month> <year> 1975. </year>
Reference-contexts: Relational optimizers make extensive use of heuristics based on logical query transformation rules, such as commutativity of join and pushing select past join. A rule-based system for optimizing relational algebra expressions was proposed by Smith and Chang <ref> [SC75] </ref>. They use rules and algorithms for tree transformation that are based on heuristics for the relational model. For example, they have rules to move selection and projection to the leaves of a query tree.
Reference: [SO87] <author> Sreekumar T. Shenoy and Z. Meral Ozsoyoglu. </author> <title> A System for Semantic Query Optimization. </title> <booktitle> In SIGMOD Proceedings, </booktitle> <pages> pages 181-195. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference-contexts: An object-oriented query optimizer must be able to apply optimizations specific to the types, and optimizations that look at relationships between objects of different types. Such optimizations are similar to those examined in the area of semantic query optimization <ref> [SO87] </ref>.
Reference: [SO89] <author> Dave D. Straube and M. Tamer Ozsu. </author> <title> Query Transformation Rules for an Object Algebra. </title> <type> Technical Report CS-89-23, </type> <institution> University of Alberta, </institution> <year> 1989. </year>
Reference-contexts: We believe that a better understanding of the problems encountered can lead to the development of new (and better) techniques for optimizing object-oriented queries. The application of algebraic transformations has formed the basis for the design of query op-timizers for object-oriented databases <ref> [GM88, SO89, Osb88] </ref>. A recognized difficulty in applying transformations is the problem of manipulating query expressions containing references to arbitrary methods. <p> In particular they explore efficient alternatives to object navigation. Kemper and Moerkotte explore the use of relations to support navigation [KM90]. A variety of proposals have been made for optimization based on algebraic transformation rules for query operations <ref> [LB89, Osb88, Zdo89, SO89, BK90b] </ref>. For example, Straube and Ozsu [Str90] propose a methodology for query optimization that includes calculus-based optimization, the transformation of calculus-based queries to algebraic form, type-checking of algebraic expressions, the application of algebraic transformation axioms, and the generation of access plans for the algebraic operations.
Reference: [SR86] <author> Michael Stonebraker and Lawrence A. Rowe. </author> <title> The Design of POSTGRES. </title> <booktitle> In SIGMOD Proceedings, </booktitle> <pages> pages 340-355. </pages> <publisher> ACM, </publisher> <year> 1986. </year>
Reference-contexts: A need for extensibility in data modelling and access led to the development of databases in which such aspects as the data types, operators, and access methods can be extended <ref> [H + 89, SR86, B + 90, CD + 86] </ref>. Extensible database systems often use algebraic rules about query operations to provide transformations that can be applied to queries to generate expressions that will be more 12 efficient to process.
Reference: [Str90] <author> Dave D. Straube. </author> <title> Queries and Query Processing in Object-Oriented Database Systems. </title> <type> PhD thesis, </type> <institution> Univ. of Alberta, </institution> <month> December </month> <year> 1990. </year>
Reference-contexts: In particular they explore efficient alternatives to object navigation. Kemper and Moerkotte explore the use of relations to support navigation [KM90]. A variety of proposals have been made for optimization based on algebraic transformation rules for query operations [LB89, Osb88, Zdo89, SO89, BK90b]. For example, Straube and Ozsu <ref> [Str90] </ref> propose a methodology for query optimization that includes calculus-based optimization, the transformation of calculus-based queries to algebraic form, type-checking of algebraic expressions, the application of algebraic transformation axioms, and the generation of access plans for the algebraic operations.
Reference: [SZ89a] <author> Gail M. Shaw and Stanley B. Zdonik. </author> <title> Object-Oriented Queries: Equivalence and Optimization. </title> <booktitle> In Proceedings of the First International Conference on Deductive and Object-Oriented Databases, </booktitle> <pages> pages 264-278, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: The costs associated with the application of methods need to be considered when manipulating query expressions to determine database access strategies. We have also found that manipulations involving objects with identity complicate the definition of the equivalence of two query expressions <ref> [SZ89a] </ref> thus complicating the application of transformation rules. Support for abstract data types requires an optimizer support extensibility of the model. <p> When objects have identities, there is a question as to what constitutes equality of two objects (see for example [KC86], <ref> [SZ89a] </ref>). This carries over to the language, where equality 10 operations are used in predicates and where a decision must be made concerning the creation of new objects by a query. <p> The creation of new objects by a query language means that the structure of results as well as the data retrieved by a query must be considered when defining equivalence. We have defined alternate notions for equivalence (see <ref> [SZ89a] </ref>) that must be recognized by an optimizer working with a language that builds objects with identity. For example, our weakest notion of equivalence states that two queries are equivalent if they respond with the same data, regardless of the logical structure of the objects returned.
Reference: [SZ89b] <author> Gail M. Shaw and Stanley B. Zdonik. </author> <title> An Object-Oriented Query Algebra. </title> <booktitle> In Proceedings of the 2nd International Workshop on Database Programming Languages, </booktitle> <pages> pages 103-112, </pages> <month> June </month> <year> 1989. </year> <note> Reprinted in IEEE Data Engineering Bulletin,12,3, </note> <month> September </month> <year> 1989. </year>
Reference-contexts: In Section 4 we discuss some of the current approaches to solving these problems and in Section 5 we conclude with a brief summary. 2 An Object-Oriented Data Model and Algebra We use the ENCORE data model and query algebra (EQUAL; Encore QUery ALgebra) <ref> [SZ89b, SZ90] </ref> as the foundation for our discussion of problems in object-oriented query processing. The model incorporates data modelling features found in other object-oriented systems, such as abstract data types, subtyping (inheritance), encapsulation, complex structures, object identity, and late-binding of methods.
Reference: [SZ90] <author> Gail M. Shaw and Stanley B. Zdonik. </author> <title> A Query Algebra for Object-Oriented Databases. </title> <booktitle> In Proceedings of the 6th International Conference on Data Engineering, </booktitle> <pages> pages 154-162. </pages> <publisher> IEEE, </publisher> <year> 1990. </year> <note> An early version of this paper appears as Brown University tech report CS-89-19. </note>
Reference-contexts: In Section 4 we discuss some of the current approaches to solving these problems and in Section 5 we conclude with a brief summary. 2 An Object-Oriented Data Model and Algebra We use the ENCORE data model and query algebra (EQUAL; Encore QUery ALgebra) <ref> [SZ89b, SZ90] </ref> as the foundation for our discussion of problems in object-oriented query processing. The model incorporates data modelling features found in other object-oriented systems, such as abstract data types, subtyping (inheritance), encapsulation, complex structures, object identity, and late-binding of methods. <p> Tuple attributes in ENCORE are names with associated methods Get attribute value and Set attribute value that can compute values associated with the name. An ENCORE database is a collection of typed objects. The EQUAL query algebra <ref> [SZ90] </ref> for ENCORE provides type specific operations against collections of objects with identity. We query over collections of type Set [T], where T is some data type, and return new objects having type Set [Q], where type Q is statically determined by the query.
Reference: [Ull89] <author> Jeffrey D. Ullman. </author> <title> Principles of Database And Knowledge-Base Systems, volume II. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: Relational query optimizers exploit the semantics of the model and the fixed sets of operators, storage structures, and implementation techniques for the operators. The designs of such optimizers differ and are specific to the system in which the optimizer is built <ref> [Ull89, Dat89] </ref>. Most optimization strategies for relational optimizers focus on queries involving the Select, Project and Join operators (see [Ull89] for a discussion of the theory upon which such strategies are based). Further work in relational optimization looked at extending optimization to include other operators, for example aggregators [Kim82, Day87]. <p> The designs of such optimizers differ and are specific to the system in which the optimizer is built [Ull89, Dat89]. Most optimization strategies for relational optimizers focus on queries involving the Select, Project and Join operators (see <ref> [Ull89] </ref> for a discussion of the theory upon which such strategies are based). Further work in relational optimization looked at extending optimization to include other operators, for example aggregators [Kim82, Day87].
Reference: [Zdo89] <author> Stanley B. Zdonik. </author> <title> Query Optimization in Object-Oriented Database Systems. </title> <booktitle> In Proceedings of the Hawaii International Conference on System Science, </booktitle> <month> January </month> <year> 1989. </year>
Reference-contexts: In particular they explore efficient alternatives to object navigation. Kemper and Moerkotte explore the use of relations to support navigation [KM90]. A variety of proposals have been made for optimization based on algebraic transformation rules for query operations <ref> [LB89, Osb88, Zdo89, SO89, BK90b] </ref>. For example, Straube and Ozsu [Str90] propose a methodology for query optimization that includes calculus-based optimization, the transformation of calculus-based queries to algebraic form, type-checking of algebraic expressions, the application of algebraic transformation axioms, and the generation of access plans for the algebraic operations.
Reference: [ZW86] <author> Stanley B. Zdonik and Peter Wegner. </author> <title> Language and Methodology for Object-Oriented Database Environments. </title> <booktitle> In Proceedings of the Hawaii International Conference on System Sciences, </booktitle> <month> January </month> <year> 1986. </year> <month> 16 </month>
Reference-contexts: Optimization results have also been extended to include more expressive models, such as nested [S + 89, Kor88] and network models [RR85, R + 83]. Object-oriented databases are extensible systems which support (among other features) abstract data types, type inheritance (subtyping), methods and late-binding, and object identity <ref> [MS87, BDK91, ZW86, MD90, B + 87] </ref>. The extensibility of object-oriented databases is founded on the ability to extend the data model through abstract data types and the inheritance structure.
References-found: 46

