URL: http://www.cs.princeton.edu/~erez/bp.ps
Refering-URL: http://www.cs.princeton.edu/~erez/publications.html
Root-URL: http://www.cs.princeton.edu
Email: e-mail: mihir@watson.ibm.com  e-mail erez@cs.technion.ac.il  
Title: Making Zero-Knowledge Provers Efficient  
Author: Mihir Bellare Erez Petrank 
Address: P.O. Box 704, Yorktown Heights, NY 10598, USA.  Israel.  
Affiliation: IBM T.J. Watson Research Center,  Department of Computer Science, Technion, Haifa,  
Note: High Performance Computing and Communications,  
Date: September 14, 1995  
Abstract: We look at the question of how powerful a prover must be to give a zero-knowledge proof. We present the first unconditional bounds on the complexity of a statistical ZK prover. The result is that if a language possesses a statistical zero-knowledge then it also possesses a statistical zero-knowledge proof in which the prover runs in probabilistic, polynomial time with an NP oracle. Previously this was only known given the existence of one-way permutations. Extending these techniques to protocols of knowledge complexity k(n) &gt; 0, we derive bounds on the time complexity of languages of "small" knowledge complexity. Underlying these results is a technique for efficiently generating an "almost" random element of a set S 2 N P. Specifically, we construct a probabilistic machine with an NP oracle which, on input 1 n and ffi &gt; 0 runs in time polynomial in n and lg ffi 1 , and outputs a random string from a distribution within distance ffi of the uniform distribution on S " f0; 1g n . 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> W. Aiello and J. H -astad. </author> <title> Perfect Zero-Knowledge can be Recognized in Two Rounds. </title> <booktitle> Proceedings of the 28th Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1987). </booktitle>
Reference-contexts: This is in contrast to the case of (plain) interactive proofs where a polynomial space prover always suffices. We note that this is true even though we know that languages in statistical ZK are of (relatively) low complexity: results of Fortnow [12] and Aiello-H-astad <ref> [1] </ref> imply that SZK AM " co-AM P 2 " P 2 (where SZK denotes the class of languages possessing statistical ZK interactive proofs of membership). <p> We remark that Theorem 1.1 implies that SZK BPP NP , providing an alternative way of showing that languages in SZK are of relatively low complexity (recall that the earlier and better results are due to Fortnow [12] and Aiello and H-astad <ref> [1] </ref>). 1.2 The Complexity of Non-Zero Knowledge Complexity Knowledge complexity (KC) that is not zero was presented by Goldwasser, Micali, and Rackoff [18] and was formally formulated by Goldreich and Petrank [17]. The idea in the definition is that knowledge complexity measures the computational advantage gained in an interaction. <p> We adopt the natural notion that the error-probability is a negligible (i.e. less than the reciprocal of any polynomial) function of n, and that is what the above theorem assumes. Our result can be viewed as an extension to higher KC of the results of <ref> [12, 1] </ref> showing that languages of zero (statistical) knowledge complexity (i.e. statistical ZK languages) have "low" complexity (they show that SZK AM " co-AM BPP NP ). Our techniques, however, are quite different. Generalizing the techniques of [12, 1] to the setting of higher KC would yield a weaker result than <p> can be viewed as an extension to higher KC of the results of <ref> [12, 1] </ref> showing that languages of zero (statistical) knowledge complexity (i.e. statistical ZK languages) have "low" complexity (they show that SZK AM " co-AM BPP NP ). Our techniques, however, are quite different. Generalizing the techniques of [12, 1] to the setting of higher KC would yield a weaker result than Theorem 1.2 because it seems one must assume that the error-probability of the original proof system was exponentially small. y 1.3 Efficient Almost Uniform Generation A technique underlying these results is to generate almost random elements of <p> The following lemma follows from Lemma 4.1 in Aiello-H-astad <ref> [1] </ref>, which in turn is based on ideas of Babai [2] and Sipser [27]. Lemma 3.3 Let b; k be positive integers, ffi &gt; 0 and S f0; 1g k . Let l = 16 lg (2ffi 1 ).
Reference: [2] <author> L. Babai. </author> <title> Trading Group Theory for Randomness. </title> <booktitle> Proceedings of the 17th Annual ACM Symposium on the Theory of Computing, ACM (1985). </booktitle>
Reference-contexts: The details follow. We use universal hash functions [10]. Let H k;b denote the set of all affine transformations h A;ff : f0; 1g k ! f0; 1g b given by h A;ff (y) = Ay + ff where A is a b by k matrix over GF <ref> [2] </ref> and ff is a b-vector over GF [2], and the arithmetic is over GF [2]. The following lemma follows from Lemma 4.1 in Aiello-H-astad [1], which in turn is based on ideas of Babai [2] and Sipser [27]. <p> Let H k;b denote the set of all affine transformations h A;ff : f0; 1g k ! f0; 1g b given by h A;ff (y) = Ay + ff where A is a b by k matrix over GF <ref> [2] </ref> and ff is a b-vector over GF [2], and the arithmetic is over GF [2]. The following lemma follows from Lemma 4.1 in Aiello-H-astad [1], which in turn is based on ideas of Babai [2] and Sipser [27]. Lemma 3.3 Let b; k be positive integers, ffi &gt; 0 and S f0; 1g k . <p> the set of all affine transformations h A;ff : f0; 1g k ! f0; 1g b given by h A;ff (y) = Ay + ff where A is a b by k matrix over GF <ref> [2] </ref> and ff is a b-vector over GF [2], and the arithmetic is over GF [2]. The following lemma follows from Lemma 4.1 in Aiello-H-astad [1], which in turn is based on ideas of Babai [2] and Sipser [27]. Lemma 3.3 Let b; k be positive integers, ffi &gt; 0 and S f0; 1g k . Let l = 16 lg (2ffi 1 ). <p> (y) = Ay + ff where A is a b by k matrix over GF <ref> [2] </ref> and ff is a b-vector over GF [2], and the arithmetic is over GF [2]. The following lemma follows from Lemma 4.1 in Aiello-H-astad [1], which in turn is based on ideas of Babai [2] and Sipser [27]. Lemma 3.3 Let b; k be positive integers, ffi &gt; 0 and S f0; 1g k . Let l = 16 lg (2ffi 1 ).
Reference: [3] <author> L. Babai, L. Fortnow and C. Lund. </author> <title> Non-Deterministic Exponential Time has Two-Prover Interactive Protocols. </title> <booktitle> Proceedings of the 31st Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1990). </booktitle>
Reference-contexts: The "complexity of the prover" refers to the computational complexity of this function. The complexity of the prover has been addressed by Lund, Fortnow, Karloff and Nisan [23], Beigel, Bellare, Feigenbaum and Goldwasser [4] and (for multi-prover proofs [8]) by Babai, Fortnow and Lund <ref> [3] </ref>. It is also related to the notion of program checking of Blum and Kannan [9].
Reference: [4] <author> R. Beigel, M. Bellare, J. Feigenbaum and S. Goldwasser. </author> <title> Languages that are Easier than their Proofs. </title> <booktitle> Proceedings of the 32nd Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1991). </booktitle>
Reference-contexts: The "complexity of the prover" refers to the computational complexity of this function. The complexity of the prover has been addressed by Lund, Fortnow, Karloff and Nisan [23], Beigel, Bellare, Feigenbaum and Goldwasser <ref> [4] </ref> and (for multi-prover proofs [8]) by Babai, Fortnow and Lund [3]. It is also related to the notion of program checking of Blum and Kannan [9]. <p> Our bound of PPT with NP oracle does not depend on the complexity of the language. Can one find "tighter" relationships between the complexity of L and the complexity of a statistical ZK prover for L? For example, what can one say about statistical ZK in the model of <ref> [4] </ref> where the prover is PPT with an oracle for L? Acknowledgments We thank Oded Goldreich and Avi Wigderson for helpful remarks and proof simplifications.
Reference: [5] <author> M. Bellare, S. Micali and R. Ostrovsky. </author> <title> The (True) Complexity of Statistical Zero-Knowledge. </title> <booktitle> Proceedings of the 22nd Annual ACM Symposium on the Theory of Computing, ACM (1990). </booktitle>
Reference-contexts: Upper bounds on the complexity of a statistical ZK prover have been established by making use of (unproven) complexity assumptions. The first such result was that of Bellare, Micali and Ostrovsky <ref> [5] </ref> who showed that any language which possesses a statistical ZK proof also possesses a statistical ZK proof whose prover is a probabilistic, polynomial time (PPT) machine with a P 2 oracle, provided the discrete log problem is hard. z Since then, both the complexity and the assumption have been reduced: <p> [25] showed that the P 2 oracle may be replaced by an NP one, and on the other hand Ostrovsky, Venkatesan and Yung [26] show that any one-way permutation suffices. y The analogous question for computational ZK is easily resolved as a corollary of the results in [7, 21]. z <ref> [5] </ref> only claims a bound of probabilistic polynomial space, but the improvement to PPT with a P 2 oracle is immediate on combining their construction with the results of Jerrum, Valiant and Vazirani [22] on uniform generation. 2 To summarize, the cumulative effect of all this work was to establish that <p> As in some of the results in [15, 24], one of the ideas in our proof is to make (appropriate) use of the "auxiliary" inputs that the definition of ZK provides (cf. [11, 15, 19, 24, 29]). Previous solutions <ref> [5, 25, 26] </ref> did not exploit this feature of ZK. We note that auxiliary inputs are important to the definition of ZK: Goldreich and Krawczyk [13] show that without auxiliary inputs in the definition, ZK would not even be closed under sequential composition. <p> Here we describe a key component of this construction which we call a simulation based prover, and develop techniques to implement it efficiently. Similar ideas were used first in <ref> [5] </ref> and then later in [25]. These papers however did not incorporate auxiliary inputs into the notion, a difference that is important to some of our results. Definition 4.1 If S is a simulator of g rounds and message length l (cf. <p> We wish to construct a new statistical ZK interactive proof system (P ; V ) for L whose prover is efficient. Let us begin by reviewing previous solutions to the problem and see whence arise the complexity assumptions that we wish to eliminate. The solution of <ref> [5] </ref> begins with the observation that it is easy to construct an efficient prover P h such that the system (P h ; V ) is statistical ZK with respect to the honest verifier V (that is, there exists a P h -simulator for V ). <p> How could this prover know which (of the infinitely many) provers P S bV to run at any point in time? He cannot tell who he is talking to, and, anyway, cannot keep an infinite number of pieces of code handy. In <ref> [5] </ref> the problem of the cheating verifier is surmounted by constructing a "compiler" which, given a proof system for L which is statistical ZK with respect to the honest verifier, transforms it into a new proof system which is statistical ZK with respect to any (cheating) verifier, while preserving the power <p> We recall that these results are known given complexity assumptions <ref> [5] </ref>. Second, on the subject of the power of the prover. Our bound of PPT with NP oracle does not depend on the complexity of the language.
Reference: [6] <author> M. Bellare and E. Petrank. </author> <title> Making Zero-Knowledge Provers Efficient. </title> <type> Technical Report, </type> <institution> Computer Science Department, Technion, Haifa, Israel. </institution>
Reference: [7] <author> M. Ben-Or, S. Goldwasser, O. Goldreich, J. H -astad, J. Kilian, S. Micali and P. Rogaway. </author> <title> Everything Provable is Provable in Zero-Knowledge. </title> <booktitle> Advances in Cryptology | Proceedings of CRYPTO 88, Lecture Notes in Computer Science 403, </booktitle> <publisher> Springer-Verlag (1989). </publisher> <editor> S. Goldwasser, </editor> <publisher> ed. </publisher>
Reference-contexts: one hand Ostrovsky [25] showed that the P 2 oracle may be replaced by an NP one, and on the other hand Ostrovsky, Venkatesan and Yung [26] show that any one-way permutation suffices. y The analogous question for computational ZK is easily resolved as a corollary of the results in <ref> [7, 21] </ref>. z [5] only claims a bound of probabilistic polynomial space, but the improvement to PPT with a P 2 oracle is immediate on combining their construction with the results of Jerrum, Valiant and Vazirani [22] on uniform generation. 2 To summarize, the cumulative effect of all this work was
Reference: [8] <author> M. Ben-Or, S. Goldwasser, J. Kilian and A. Wigderson. </author> <title> Multi-Prover Interactive Proofs: How to Remove Intractability Assumptions. </title> <booktitle> Proceedings of the 20th Annual ACM Symposium on the Theory of Computing, ACM (1988). </booktitle>
Reference-contexts: The "complexity of the prover" refers to the computational complexity of this function. The complexity of the prover has been addressed by Lund, Fortnow, Karloff and Nisan [23], Beigel, Bellare, Feigenbaum and Goldwasser [4] and (for multi-prover proofs <ref> [8] </ref>) by Babai, Fortnow and Lund [3]. It is also related to the notion of program checking of Blum and Kannan [9].
Reference: [9] <author> M. Blum and S. Kannan. </author> <title> Designing Programs that Check their Work. </title> <booktitle> Proceedings of the 21st Annual ACM Symposium on the Theory of Computing, ACM (1989). </booktitle>
Reference-contexts: The complexity of the prover has been addressed by Lund, Fortnow, Karloff and Nisan [23], Beigel, Bellare, Feigenbaum and Goldwasser [4] and (for multi-prover proofs [8]) by Babai, Fortnow and Lund [3]. It is also related to the notion of program checking of Blum and Kannan <ref> [9] </ref>. Here we are interested in the particular case where the interactive proof (P; V ) must also be statistical zero-knowledge y (statistical means that the zero-knowledge is in a strong sense: see x2 for definitions).
Reference: [10] <author> L. Carter and M. Wegman. </author> <title> Universal Classes of Hash Functions. </title> <journal> J. Computer and System Sciences 18, </journal> <month> 143-154 </month> <year> (1979). </year> <month> 26 </month>
Reference-contexts: This result is established by combining techniques from Jerrum, Valiant and Vazirani [22] and Stockmeyer [28] with Carter-Wegman universal hash function <ref> [10] </ref> based techniques for estimating set sizes (Sipser [27]). <p> The details follow. We use universal hash functions <ref> [10] </ref>.
Reference: [11] <author> U. Feige. </author> <title> Interactive Proofs. </title> <type> M.Sc Thesis, </type> <institution> Weizmann Institute of Science. </institution> <month> August </month> <year> 1987. </year>
Reference-contexts: As in some of the results in [15, 24], one of the ideas in our proof is to make (appropriate) use of the "auxiliary" inputs that the definition of ZK provides (cf. <ref> [11, 15, 19, 24, 29] </ref>). Previous solutions [5, 25, 26] did not exploit this feature of ZK. We note that auxiliary inputs are important to the definition of ZK: Goldreich and Krawczyk [13] show that without auxiliary inputs in the definition, ZK would not even be closed under sequential composition. <p> The first condition is called the completeness condition and the second the soundness condition. 6 Next we define zero-knowledge (ZK) proofs [19]. We remark that the auxiliary inputs (cf. <ref> [11, 15, 19, 24, 29] </ref>) are crucial to make the definition meaningful. For one thing, without them, the composition of zero-knowledge protocols is not necessarily a zero-knowledge protocol as we would like it to be [13].
Reference: [12] <author> L. Fortnow. </author> <title> The Complexity of Perfect Zero-Knowledge. Advances in Computing Research (ed. </title> <editor> S. </editor> <volume> Micali) Vol. </volume> <month> 18 </month> <year> (1989). </year>
Reference-contexts: This is in contrast to the case of (plain) interactive proofs where a polynomial space prover always suffices. We note that this is true even though we know that languages in statistical ZK are of (relatively) low complexity: results of Fortnow <ref> [12] </ref> and Aiello-H-astad [1] imply that SZK AM " co-AM P 2 " P 2 (where SZK denotes the class of languages possessing statistical ZK interactive proofs of membership). <p> We remark that Theorem 1.1 implies that SZK BPP NP , providing an alternative way of showing that languages in SZK are of relatively low complexity (recall that the earlier and better results are due to Fortnow <ref> [12] </ref> and Aiello and H-astad [1]). 1.2 The Complexity of Non-Zero Knowledge Complexity Knowledge complexity (KC) that is not zero was presented by Goldwasser, Micali, and Rackoff [18] and was formally formulated by Goldreich and Petrank [17]. <p> We adopt the natural notion that the error-probability is a negligible (i.e. less than the reciprocal of any polynomial) function of n, and that is what the above theorem assumes. Our result can be viewed as an extension to higher KC of the results of <ref> [12, 1] </ref> showing that languages of zero (statistical) knowledge complexity (i.e. statistical ZK languages) have "low" complexity (they show that SZK AM " co-AM BPP NP ). Our techniques, however, are quite different. Generalizing the techniques of [12, 1] to the setting of higher KC would yield a weaker result than <p> can be viewed as an extension to higher KC of the results of <ref> [12, 1] </ref> showing that languages of zero (statistical) knowledge complexity (i.e. statistical ZK languages) have "low" complexity (they show that SZK AM " co-AM BPP NP ). Our techniques, however, are quite different. Generalizing the techniques of [12, 1] to the setting of higher KC would yield a weaker result than Theorem 1.2 because it seems one must assume that the error-probability of the original proof system was exponentially small. y 1.3 Efficient Almost Uniform Generation A technique underlying these results is to generate almost random elements of <p> Jerrum, Valiant and Vazirani [22], using results of Stockmeyer [28] on approximate counting, showed that uniform generation can be done in probabilistic, polynomial time with a P 2 oracle. y Extending Fortnow's techniques <ref> [12] </ref> one can show that if L has a g (n) round, KC k (n), proof system with error probability 2 O (ng (n)) , and if g (n)k (n) = O (log n), then L 2 co-AM. 4 For our applications we would like a lower complexity than PPT with
Reference: [13] <author> O. Goldreich and H. Krawczyk. </author> <title> On the Composition of Zero-Knowledge Proof Systems. </title> <booktitle> Proceedings of ICALP 90 </booktitle> . 
Reference-contexts: Previous solutions [5, 25, 26] did not exploit this feature of ZK. We note that auxiliary inputs are important to the definition of ZK: Goldreich and Krawczyk <ref> [13] </ref> show that without auxiliary inputs in the definition, ZK would not even be closed under sequential composition. Another idea of our proof is to build a "universal" verifier which, for our purpose, captures the behaviors of all possible cheating verifiers. <p> We remark that the auxiliary inputs (cf. [11, 15, 19, 24, 29]) are crucial to make the definition meaningful. For one thing, without them, the composition of zero-knowledge protocols is not necessarily a zero-knowledge protocol as we would like it to be <ref> [13] </ref>. We recall also that any ZK proof which is black box simulation ZK (as all known ones are) is ZK in the auxiliary input model [15, 24]. Let us first define simulators. In the following let p: N ! N be a polynomially bounded, polynomial time computable function.
Reference: [14] <author> O. Goldreich, Y. Mansour and M. Sipser. </author> <title> Interactive Proof Systems: Provers that never Fail and Random Selection. </title> <booktitle> Proceedings of the 28th Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1987). </booktitle>
Reference-contexts: In particular, can one unconditionally establish any of the following? (1) If L has a statistical ZK proof then it has a statistical ZK proof with perfect completeness (i.e. the verifier accepts with probability 1 when x 2 L; cf. <ref> [14] </ref>) (2) If L has a statistical ZK proof then it has a statistical ZK proof with a black-box simulator. 25 (3) If L has an interactive proof which is statistical ZK with respect to the honest verifier, then it has a statistical ZK interactive proof.
Reference: [15] <author> O. Goldreich and Y. Oren. </author> <title> Definitions and Properties of Zero-Knowledge Proof Systems. </title> <type> Technical Report #570, </type> <institution> Technion (1989). </institution>
Reference-contexts: We do know that coins are necessary: Oren [24] and Goldreich and Oren <ref> [15] </ref> show that any ZK prover for a non-trivial language must be probabilistic. Upper bounds on the complexity of a statistical ZK prover have been established by making use of (unproven) complexity assumptions. <p> As in some of the results in <ref> [15, 24] </ref>, one of the ideas in our proof is to make (appropriate) use of the "auxiliary" inputs that the definition of ZK provides (cf. [11, 15, 19, 24, 29]). Previous solutions [5, 25, 26] did not exploit this feature of ZK. <p> As in some of the results in [15, 24], one of the ideas in our proof is to make (appropriate) use of the "auxiliary" inputs that the definition of ZK provides (cf. <ref> [11, 15, 19, 24, 29] </ref>). Previous solutions [5, 25, 26] did not exploit this feature of ZK. We note that auxiliary inputs are important to the definition of ZK: Goldreich and Krawczyk [13] show that without auxiliary inputs in the definition, ZK would not even be closed under sequential composition. <p> The first condition is called the completeness condition and the second the soundness condition. 6 Next we define zero-knowledge (ZK) proofs [19]. We remark that the auxiliary inputs (cf. <ref> [11, 15, 19, 24, 29] </ref>) are crucial to make the definition meaningful. For one thing, without them, the composition of zero-knowledge protocols is not necessarily a zero-knowledge protocol as we would like it to be [13]. <p> For one thing, without them, the composition of zero-knowledge protocols is not necessarily a zero-knowledge protocol as we would like it to be [13]. We recall also that any ZK proof which is black box simulation ZK (as all known ones are) is ZK in the auxiliary input model <ref> [15, 24] </ref>. Let us first define simulators. In the following let p: N ! N be a polynomially bounded, polynomial time computable function. <p> The first step is to define a single universal verifier who, in essence, can "simulate" the behavior of all verifiers as far as the prover is concerned. The key in the definition of the universal verifier V fl (as in several proofs in <ref> [15, 24] </ref>) is to make appropriate use of the auxiliary inputs. Definition 5.1 The universal verifier V fl (of g rounds and message length l) is defined as follows.
Reference: [16] <author> O. Goldreich and E. Petrank. </author> <title> Quantifying Knowledge Complexity. </title> <booktitle> Proceedings of the 32nd Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1991). </booktitle> <editor> O. Goldreich, R. Ostrovsky, and E. </editor> <title> Petrank. Computational Complexity and Knowledge Complexity. </title> <booktitle> 26th ACM Symp. on Theory of Computation, </booktitle> <month> May </month> <year> 1994. </year> <pages> pp. 534-543. </pages>
Reference-contexts: Recently, the restriction on the number of rounds has been removed. Goldreich, Ostrovsky, and Petrank <ref> [16] </ref> used the same procedure as ours with a finer analysis to show that any language that has perfect knowledge complexity O (log n) is in BPP NP . We should stress one important difference between ZK proofs and proofs of higher KC.
Reference: [17] <author> O. Goldreich and E. Petrank. </author> <title> Quantifying Knowledge Complexity. </title> <booktitle> Proceedings of the 32nd Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1991). </booktitle>
Reference-contexts: relatively low complexity (recall that the earlier and better results are due to Fortnow [12] and Aiello and H-astad [1]). 1.2 The Complexity of Non-Zero Knowledge Complexity Knowledge complexity (KC) that is not zero was presented by Goldwasser, Micali, and Rackoff [18] and was formally formulated by Goldreich and Petrank <ref> [17] </ref>. The idea in the definition is that knowledge complexity measures the computational advantage gained in an interaction. One of the motivations to quantify KC originated from the hope that this new 3 approach may shed new light on interesting questions in complexity theory. <p> We call b V a cheating verifier. Finally we also summarize the definition of the knowledge complexity measure (greater or equal to zero) which we use in the sequel. This definition is due to <ref> [17] </ref>, and they call it the "fraction" version. For intuition and motivation we refer the reader to the original paper [17]. <p> Finally we also summarize the definition of the knowledge complexity measure (greater or equal to zero) which we use in the sequel. This definition is due to <ref> [17] </ref>, and they call it the "fraction" version. For intuition and motivation we refer the reader to the original paper [17]. <p> This result relies on an extension to positive KC of our techniques from the previous sections. Throughout this paper, we use the definition of knowledge complexity in the fraction sense <ref> [17] </ref>. Loosely speaking, we say that a protocol (P; V ) has knowledge complexity k (n) if for any verifier b V there exists a simulator S b V with the following "good subspace" property. <p> The formal definition appears in x2. There are two other definitions of non-zero KC: the oracle definition and the hint definition <ref> [17] </ref>. It is shown in [17] that the oracle definition is equal up to an additive constant to the fraction definition. <p> The formal definition appears in x2. There are two other definitions of non-zero KC: the oracle definition and the hint definition <ref> [17] </ref>. It is shown in [17] that the oracle definition is equal up to an additive constant to the fraction definition. The proof of the equivalence result there does not change the interactive proof, and specifically, the equivalence holds also when a restriction is imposed on the number of rounds in the interaction. <p> Therefore, our results apply to the oracle definition as well. Our results apply also to the hint definition. However, with this definition, it is easy to prove even stronger results, and such stronger results already appear in <ref> [17] </ref>. Nevertheless, several reasons are presented in [17] why not to regard the hint definition as an appropriate measure. Recall (Definition 2.3) that we have adopted the convention that an interactive proof has a negligible error probability. <p> Therefore, our results apply to the oracle definition as well. Our results apply also to the hint definition. However, with this definition, it is easy to prove even stronger results, and such stronger results already appear in <ref> [17] </ref>. Nevertheless, several reasons are presented in [17] why not to regard the hint definition as an appropriate measure. Recall (Definition 2.3) that we have adopted the convention that an interactive proof has a negligible error probability.
Reference: [18] <author> S. Goldwasser, S. Micali, and C. Rackoff. </author> <title> The Knowledge Complexity of Interactive Proofs. </title> <booktitle> Proceedings of the 17th Annual ACM Symposium on the Theory of Computing, ACM (1985). </booktitle>
Reference-contexts: way of showing that languages in SZK are of relatively low complexity (recall that the earlier and better results are due to Fortnow [12] and Aiello and H-astad [1]). 1.2 The Complexity of Non-Zero Knowledge Complexity Knowledge complexity (KC) that is not zero was presented by Goldwasser, Micali, and Rackoff <ref> [18] </ref> and was formally formulated by Goldreich and Petrank [17]. The idea in the definition is that knowledge complexity measures the computational advantage gained in an interaction.
Reference: [19] <author> S. Goldwasser, S. Micali, and C. Rackoff. </author> <title> The Knowledge Complexity of Interactive Proofs. </title> <journal> SIAM J. Comput. </journal> <volume> 18 (1), </volume> <month> 186-208 (February </month> <year> 1989). </year>
Reference-contexts: 1 Introduction The investigation of the properties of interactive and zero-knowledge proofs <ref> [19] </ref> has already yielded many powerful results with diverse applications in complexity theory and cryptography. Here we continue this investigation by looking at the complexity of the prover in an interactive proof system, focusing in particular on the case where the proof system is statistical zero-knowledge. <p> As in some of the results in [15, 24], one of the ideas in our proof is to make (appropriate) use of the "auxiliary" inputs that the definition of ZK provides (cf. <ref> [11, 15, 19, 24, 29] </ref>). Previous solutions [5, 25, 26] did not exploit this feature of ZK. We note that auxiliary inputs are important to the definition of ZK: Goldreich and Krawczyk [13] show that without auxiliary inputs in the definition, ZK would not even be closed under sequential composition. <p> We say that the ensembles E 1 and E 2 are statistically indistinguishable if the distance between them is negligible. Next we define interactive proofs <ref> [19] </ref>. We begin by specifying the parties involved: the verifier and the prover. <p> The first condition is called the completeness condition and the second the soundness condition. 6 Next we define zero-knowledge (ZK) proofs <ref> [19] </ref>. We remark that the auxiliary inputs (cf. [11, 15, 19, 24, 29]) are crucial to make the definition meaningful. For one thing, without them, the composition of zero-knowledge protocols is not necessarily a zero-knowledge protocol as we would like it to be [13]. <p> The first condition is called the completeness condition and the second the soundness condition. 6 Next we define zero-knowledge (ZK) proofs [19]. We remark that the auxiliary inputs (cf. <ref> [11, 15, 19, 24, 29] </ref>) are crucial to make the definition meaningful. For one thing, without them, the composition of zero-knowledge protocols is not necessarily a zero-knowledge protocol as we would like it to be [13].
Reference: [20] <author> R. Impagliazzo, L. Levin and M. Luby. </author> <title> Pseudo-Random Generation from One-Way Functions. </title> <booktitle> Proceedings of the 21st Annual ACM Symposium on the Theory of Computing, ACM (1989). </booktitle>
Reference-contexts: If ffi = n c for some fixed constant c then techniques from Impagliazzo, Levin and Luby <ref> [20] </ref> can be used to do almost uniform generation in probabilistic, polynomial (in n) time with an NP oracle. However (for applications in this paper in particular) we would like to be able to achieve values of ffi which are exponentially (in n) small, in the same complexity. <p> Let us now turn to approximations: we will be interested in computing a distribution which is ffi-close to P S . If ffi = n c for some constant c then, following [25], this can be done in PPT with an NP oracle by using techniques from <ref> [20] </ref>. That result will not, however, suffice for the applications in this paper: we need to be able to achieve values of ffi which are exponentially small (in n). The following Theorem says we can do this, still in PPT with an NP oracle.
Reference: [21] <author> R. Impagliazzo and M. Yung. </author> <title> Direct Minimum-Knowledge computations. </title> <booktitle> Advances in Cryptology | Proceedings of CRYPTO 87, Lecture Notes in Computer Science 293, </booktitle> <publisher> Springer-Verlag (1987). </publisher>
Reference-contexts: one hand Ostrovsky [25] showed that the P 2 oracle may be replaced by an NP one, and on the other hand Ostrovsky, Venkatesan and Yung [26] show that any one-way permutation suffices. y The analogous question for computational ZK is easily resolved as a corollary of the results in <ref> [7, 21] </ref>. z [5] only claims a bound of probabilistic polynomial space, but the improvement to PPT with a P 2 oracle is immediate on combining their construction with the results of Jerrum, Valiant and Vazirani [22] on uniform generation. 2 To summarize, the cumulative effect of all this work was
Reference: [22] <author> M. Jerrum, L. Valiant and V. Vazirani. </author> <title> Random Generation of Combinatorial Structures from a Uniform Distribution. </title> <booktitle> Theoretical Computer Science 43, </booktitle> <month> 169-188 </month> <year> (1986). </year>
Reference-contexts: question for computational ZK is easily resolved as a corollary of the results in [7, 21]. z [5] only claims a bound of probabilistic polynomial space, but the improvement to PPT with a P 2 oracle is immediate on combining their construction with the results of Jerrum, Valiant and Vazirani <ref> [22] </ref> on uniform generation. 2 To summarize, the cumulative effect of all this work was to establish that any language which possesses a statistical ZK proof also possesses a statistical ZK proof whose prover is a PPT machine with an NP oracle, given that one-way permutations exist. <p> The uniform generation problem is to generate, on input 1 n , an element of S n distributed uniformly at random. Jerrum, Valiant and Vazirani <ref> [22] </ref>, using results of Stockmeyer [28] on approximate counting, showed that uniform generation can be done in probabilistic, polynomial time with a P 2 oracle. y Extending Fortnow's techniques [12] one can show that if L has a g (n) round, KC k (n), proof system with error probability 2 O <p> In Theorem 3.2 we actually prove something a little stronger: the almost uniform generation is "universal" (in the sense that A does not depend on S but rather gets a description of S as an input). This result is established by combining techniques from Jerrum, Valiant and Vazirani <ref> [22] </ref> and Stockmeyer [28] with Carter-Wegman universal hash function [10] based techniques for estimating set sizes (Sipser [27]). <p> The proof of Theorem 3.2 is derived by combining techniques from <ref> [22, 28, 27] </ref>. First, we build an approximate counter. The approximate counter of Stockmeyer [28] took polynomial time with a P 2 oracle. We begin by showing that its "almost" version can be implemented in PPT with an NP oracle. <p> We begin by showing that its "almost" version can be implemented in PPT with an NP oracle. Our construction uses hashing techniques similar to the ones used by Sipser [27]. Once we have this approximate counter, we use the PPT reduction of Jerrum, Valiant and Vazirani <ref> [22] </ref> from uniform generation to approximate counting. The key observation now is the strength of the [22] reduction: it is capable of sampling distributions within an exponentially small distance from the uniform distribution, when given a primitive for estimating set sizes (namely approximate counting) that is only accurate to within the <p> Our construction uses hashing techniques similar to the ones used by Sipser [27]. Once we have this approximate counter, we use the PPT reduction of Jerrum, Valiant and Vazirani <ref> [22] </ref> from uniform generation to approximate counting. The key observation now is the strength of the [22] reduction: it is capable of sampling distributions within an exponentially small distance from the uniform distribution, when given a primitive for estimating set sizes (namely approximate counting) that is only accurate to within the reciprocal of a polynomial. The details follow. We use universal hash functions [10]. <p> The protocol is given in Figure 1. 10 Notice that the estimates from the above theorem are only accurate to within the recip-rocal of a polynomial (that is, * 1 must be bounded by a polynomial in n). We now use the reduction of <ref> [22] </ref> which is strong enough in this sense. Given an approximation to within a factor of 1 + * (for an * which is a reciprocal of a polynomial) it samples a distribution which is very close to the uniform distribution. Specifically, they show the following: Theorem 3.6 [22]: If there <p> reduction of <ref> [22] </ref> which is strong enough in this sense. Given an approximation to within a factor of 1 + * (for an * which is a reciprocal of a polynomial) it samples a distribution which is very close to the uniform distribution. Specifically, they show the following: Theorem 3.6 [22]: If there exists a universal approximate counter to within a factor of (1 + *) (that never fails) then there exists a universal (exact) uniform gerenrator which, when given access to the approximate counter as an oracle, runs in polynomial time in n and 1 For further reference, let Q <p> The complexity of computing P S is the question we address next. Exact computation of P S is clearly possible in probabilistic polynomial space, and this is easily improved to PPT with a P 2 oracle by using the results of <ref> [22] </ref> on uniform generation. Let us now turn to approximations: we will be interested in computing a distribution which is ffi-close to P S . <p> Proof: Use the same argument as in the proof of the previous theorem (except of course use Lemma 5.3 (2) rather than Corollary 5.4), but implement P S fl using the uniform generation algorithm of <ref> [22] </ref> (rather than the almost uniform generation of Theorem 3.2). It is possible to extend these techniques to derive bounds on the complexity of the prover in a proof of knowledge complexity k (n) &gt; 0 (cf. Definition 2.8) while preserving 17 the KC.
Reference: [23] <author> C. Lund, L. Fortnow, H. Karloff and N. Nisan. </author> <title> Algebraic Methods for Interactive Proof Systems. </title> <booktitle> Proceedings of the 31st Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1990). </booktitle>
Reference-contexts: The "complexity of the prover" refers to the computational complexity of this function. The complexity of the prover has been addressed by Lund, Fortnow, Karloff and Nisan <ref> [23] </ref>, Beigel, Bellare, Feigenbaum and Goldwasser [4] and (for multi-prover proofs [8]) by Babai, Fortnow and Lund [3]. It is also related to the notion of program checking of Blum and Kannan [9].
Reference: [24] <author> Y. Oren. </author> <title> On The Cunning Power of Cheating Verifiers: Some Observations About Zero Knowledge Proofs. </title> <booktitle> Proceedings of the 28th Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1987). </booktitle>
Reference-contexts: We do know that coins are necessary: Oren <ref> [24] </ref> and Goldreich and Oren [15] show that any ZK prover for a non-trivial language must be probabilistic. Upper bounds on the complexity of a statistical ZK prover have been established by making use of (unproven) complexity assumptions. <p> As in some of the results in <ref> [15, 24] </ref>, one of the ideas in our proof is to make (appropriate) use of the "auxiliary" inputs that the definition of ZK provides (cf. [11, 15, 19, 24, 29]). Previous solutions [5, 25, 26] did not exploit this feature of ZK. <p> As in some of the results in [15, 24], one of the ideas in our proof is to make (appropriate) use of the "auxiliary" inputs that the definition of ZK provides (cf. <ref> [11, 15, 19, 24, 29] </ref>). Previous solutions [5, 25, 26] did not exploit this feature of ZK. We note that auxiliary inputs are important to the definition of ZK: Goldreich and Krawczyk [13] show that without auxiliary inputs in the definition, ZK would not even be closed under sequential composition. <p> The first condition is called the completeness condition and the second the soundness condition. 6 Next we define zero-knowledge (ZK) proofs [19]. We remark that the auxiliary inputs (cf. <ref> [11, 15, 19, 24, 29] </ref>) are crucial to make the definition meaningful. For one thing, without them, the composition of zero-knowledge protocols is not necessarily a zero-knowledge protocol as we would like it to be [13]. <p> For one thing, without them, the composition of zero-knowledge protocols is not necessarily a zero-knowledge protocol as we would like it to be [13]. We recall also that any ZK proof which is black box simulation ZK (as all known ones are) is ZK in the auxiliary input model <ref> [15, 24] </ref>. Let us first define simulators. In the following let p: N ! N be a polynomially bounded, polynomial time computable function. <p> The first step is to define a single universal verifier who, in essence, can "simulate" the behavior of all verifiers as far as the prover is concerned. The key in the definition of the universal verifier V fl (as in several proofs in <ref> [15, 24] </ref>) is to make appropriate use of the auxiliary inputs. Definition 5.1 The universal verifier V fl (of g rounds and message length l) is defined as follows.
Reference: [25] <author> R. Ostrovsky. </author> <title> One-Way Functions, Hard on Average Problems, and Statistical Zero-Knowledge Proofs. </title> <note> Structures 1991. </note>
Reference-contexts: which possesses a statistical ZK proof also possesses a statistical ZK proof whose prover is a probabilistic, polynomial time (PPT) machine with a P 2 oracle, provided the discrete log problem is hard. z Since then, both the complexity and the assumption have been reduced: on the one hand Ostrovsky <ref> [25] </ref> showed that the P 2 oracle may be replaced by an NP one, and on the other hand Ostrovsky, Venkatesan and Yung [26] show that any one-way permutation suffices. y The analogous question for computational ZK is easily resolved as a corollary of the results in [7, 21]. z [5] <p> Other than the unconditionality, our transformation offers some other improvements over previous ones. Some of these are * We preserve the number of rounds ([5] blows them up by a constant factor and <ref> [26, 25] </ref> by a polynomial factor). * We can preserve perfect ZK if we allow the prover to have a P 2 oracle instead of an N P one (in previous solutions, even if the original proof system had been perfect ZK, the transformed one would be statistical). <p> As in some of the results in [15, 24], one of the ideas in our proof is to make (appropriate) use of the "auxiliary" inputs that the definition of ZK provides (cf. [11, 15, 19, 24, 29]). Previous solutions <ref> [5, 25, 26] </ref> did not exploit this feature of ZK. We note that auxiliary inputs are important to the definition of ZK: Goldreich and Krawczyk [13] show that without auxiliary inputs in the definition, ZK would not even be closed under sequential composition. <p> Here we describe a key component of this construction which we call a simulation based prover, and develop techniques to implement it efficiently. Similar ideas were used first in [5] and then later in <ref> [25] </ref>. These papers however did not incorporate auxiliary inputs into the notion, a difference that is important to some of our results. Definition 4.1 If S is a simulator of g rounds and message length l (cf. <p> Let us now turn to approximations: we will be interested in computing a distribution which is ffi-close to P S . If ffi = n c for some constant c then, following <ref> [25] </ref>, this can be done in PPT with an NP oracle by using techniques from [20]. That result will not, however, suffice for the applications in this paper: we need to be able to achieve values of ffi which are exponentially small (in n).
Reference: [26] <author> R. Ostrovsky, R. Venkatesan and M. Yung. </author> <title> On the Complexity of Asymmetric Games. </title> <type> Manuscript (1990). </type>
Reference-contexts: P 2 oracle, provided the discrete log problem is hard. z Since then, both the complexity and the assumption have been reduced: on the one hand Ostrovsky [25] showed that the P 2 oracle may be replaced by an NP one, and on the other hand Ostrovsky, Venkatesan and Yung <ref> [26] </ref> show that any one-way permutation suffices. y The analogous question for computational ZK is easily resolved as a corollary of the results in [7, 21]. z [5] only claims a bound of probabilistic polynomial space, but the improvement to PPT with a P 2 oracle is immediate on combining their <p> Other than the unconditionality, our transformation offers some other improvements over previous ones. Some of these are * We preserve the number of rounds ([5] blows them up by a constant factor and <ref> [26, 25] </ref> by a polynomial factor). * We can preserve perfect ZK if we allow the prover to have a P 2 oracle instead of an N P one (in previous solutions, even if the original proof system had been perfect ZK, the transformed one would be statistical). <p> As in some of the results in [15, 24], one of the ideas in our proof is to make (appropriate) use of the "auxiliary" inputs that the definition of ZK provides (cf. [11, 15, 19, 24, 29]). Previous solutions <ref> [5, 25, 26] </ref> did not exploit this feature of ZK. We note that auxiliary inputs are important to the definition of ZK: Goldreich and Krawczyk [13] show that without auxiliary inputs in the definition, ZK would not even be closed under sequential composition.
Reference: [27] <author> M. Sipser. </author> <title> A Complexity Theoretic Approach to Randomness. </title> <booktitle> Proceedings of the 15th Annual ACM Symposium on the Theory of Computing, ACM (1983). </booktitle> <pages> 27 </pages>
Reference-contexts: This result is established by combining techniques from Jerrum, Valiant and Vazirani [22] and Stockmeyer [28] with Carter-Wegman universal hash function [10] based techniques for estimating set sizes (Sipser <ref> [27] </ref>). The details are in x3. 2 Preliminaries If E 1 and E 2 are probability spaces then the distance between them, denoted d (E 1 ; E 2 ), is 1 P We say that E 1 and E 2 are ffi-close if the distance between them is ffi. <p> The proof of Theorem 3.2 is derived by combining techniques from <ref> [22, 28, 27] </ref>. First, we build an approximate counter. The approximate counter of Stockmeyer [28] took polynomial time with a P 2 oracle. We begin by showing that its "almost" version can be implemented in PPT with an NP oracle. <p> First, we build an approximate counter. The approximate counter of Stockmeyer [28] took polynomial time with a P 2 oracle. We begin by showing that its "almost" version can be implemented in PPT with an NP oracle. Our construction uses hashing techniques similar to the ones used by Sipser <ref> [27] </ref>. Once we have this approximate counter, we use the PPT reduction of Jerrum, Valiant and Vazirani [22] from uniform generation to approximate counting. <p> The following lemma follows from Lemma 4.1 in Aiello-H-astad [1], which in turn is based on ideas of Babai [2] and Sipser <ref> [27] </ref>. Lemma 3.3 Let b; k be positive integers, ffi &gt; 0 and S f0; 1g k . Let l = 16 lg (2ffi 1 ).
Reference: [28] <author> L. Stockmeyer. </author> <title> The Complexity of Approximate Counting. </title> <booktitle> Proceedings of the 15th Annual ACM Symposium on the Theory of Computing, ACM (1983). </booktitle>
Reference-contexts: The uniform generation problem is to generate, on input 1 n , an element of S n distributed uniformly at random. Jerrum, Valiant and Vazirani [22], using results of Stockmeyer <ref> [28] </ref> on approximate counting, showed that uniform generation can be done in probabilistic, polynomial time with a P 2 oracle. y Extending Fortnow's techniques [12] one can show that if L has a g (n) round, KC k (n), proof system with error probability 2 O (ng (n)) , and if <p> This result is established by combining techniques from Jerrum, Valiant and Vazirani [22] and Stockmeyer <ref> [28] </ref> with Carter-Wegman universal hash function [10] based techniques for estimating set sizes (Sipser [27]). <p> The proof of Theorem 3.2 is derived by combining techniques from <ref> [22, 28, 27] </ref>. First, we build an approximate counter. The approximate counter of Stockmeyer [28] took polynomial time with a P 2 oracle. We begin by showing that its "almost" version can be implemented in PPT with an NP oracle. <p> The proof of Theorem 3.2 is derived by combining techniques from [22, 28, 27]. First, we build an approximate counter. The approximate counter of Stockmeyer <ref> [28] </ref> took polynomial time with a P 2 oracle. We begin by showing that its "almost" version can be implemented in PPT with an NP oracle. Our construction uses hashing techniques similar to the ones used by Sipser [27]. <p> The notion of approximate counting to whithin a factor (1 + *) with success probability at most (1 ffi) is as follows (cf. <ref> [28] </ref>). Definition 3.4 A universal approximate counter is a (probabilistic) machine C which, on inputs 1 n ; * &gt; 0; ffi &gt; 0; hM i outputs an estimate v which, with probability 1 ffi, satisfies jM n j=(1 + *) v jM n j (1 + *).
Reference: [29] <author> M. Tompa and H. Woll. </author> <title> Random Self-Reducibility and Zero-Knowledge Proofs of Possession of Information. </title> <booktitle> Proceedings of the 28th Annual IEEE Symposium on the Foundations of Computer Science, IEEE (1987). </booktitle> <pages> 28 </pages>
Reference-contexts: As in some of the results in [15, 24], one of the ideas in our proof is to make (appropriate) use of the "auxiliary" inputs that the definition of ZK provides (cf. <ref> [11, 15, 19, 24, 29] </ref>). Previous solutions [5, 25, 26] did not exploit this feature of ZK. We note that auxiliary inputs are important to the definition of ZK: Goldreich and Krawczyk [13] show that without auxiliary inputs in the definition, ZK would not even be closed under sequential composition. <p> The first condition is called the completeness condition and the second the soundness condition. 6 Next we define zero-knowledge (ZK) proofs [19]. We remark that the auxiliary inputs (cf. <ref> [11, 15, 19, 24, 29] </ref>) are crucial to make the definition meaningful. For one thing, without them, the composition of zero-knowledge protocols is not necessarily a zero-knowledge protocol as we would like it to be [13].
References-found: 29

