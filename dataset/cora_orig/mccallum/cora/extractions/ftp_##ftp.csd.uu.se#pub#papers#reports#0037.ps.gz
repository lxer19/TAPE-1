URL: ftp://ftp.csd.uu.se/pub/papers/reports/0037.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Email: JONAS@AIDA.UU.SE  
Phone: +46-18-18 25 00  
Title: Garbage Collection Algorithm for Tricia  
Author: Jonas Barklund P. O. 
Address: Box 520, S-751 20 Uppsala, Sweden  
Affiliation: Uppsala Programming Methodology and Artificial Intelligence Laboratory Computing Science Dept., Uppsala University  
Note: A  Electronic mail:  The research reported herein was supported by the National Swedish Board for Technical Development (STU).  
Abstract: UPMAIL Technical Report No. 37B Abstract. We present a new algorithm for garbage collection of the term stack in David H. D. Warren's abstract Prolog machine (WAM). The algorithm exploits the possibilities of using a large address space, with special attention paid to virtual memory behaviour. The time required for the algorithm depends linearly on the size of the areas in which garbage is collected. Pseudo-code is given for the whole algorithm. It has been fully implemented in Tricia, a Prolog developed at UPMAIL for the DEC-2060 computer. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. Appleby, S. Haridi, D. Sahlin, </author> <title> Garbage Collection for Prolog Based on WAM, SICS Research Report R 86009, </title> <address> Stockholm, </address> <year> 1987. </year>
Reference-contexts: This is similar to `virtual backtracking' [5] and equivalent to `early reset of variables' <ref> [1] </ref>. As mentioned above, marking terms referenced from below LB:H 0 is also done by scanning the trail. Unfortunately, it turns out that partial backtracking and marking from below LB :H 0 cannot be done simultaneously. <p> This is similar to pointer-reversal techniques <ref> [1, 16] </ref>. 13. <p> WORK The first version of this algorithm was developed in the autumn of 1985, and was inspired mostly by the work of Pittomvils, Bruynooghe, and Willems, presented at SLP '85 [15]. 10 Appleby, Haridi and Sahlin have recently presented a garbage collection algorithm for WAM, with many similarities to ours <ref> [1] </ref>. However, they have adapted a pointer reversal technique for the marking phase, instead of using a stack [16]. Their algorithm does not reverse pointers in the choice point stack or save the current state in a choice point.
Reference: [2] <author> J. Barklund, H. Millroth, </author> <title> Garbage Cut for Garbage Collection of Iterative Prolog Programs, </title> <booktitle> 1986 Symposium on Logic Programming, </booktitle> <pages> pp. 276-283, </pages> <address> Salt Lake City, </address> <month> Sept. </month> <year> 1986. </year>
Reference-contexts: It also reduces the number of page faults in virtual memory, because the term stack never grows large, making references more local. For further elaboration on this subject, see Barklund and Millroth <ref> [2] </ref>. 12.
Reference: [3] <author> J. Barklund, H. Millroth, </author> <title> Code Generation and Runtime System for Tricia, </title> <type> UPMAIL Technical Report 36, </type> <institution> Uppsala, </institution> <year> 1987. </year>
Reference-contexts: We think we achieve this, at least in the compacting and updating phases. 3. THE MACHINE The machine for which this algorithm is designed is a somewhat revised version of WAM <ref> [3, 6] </ref>. The revisions relevant to the term stack GC are as follows: 1 * An extra register F is added, containing flags. This register is always tested when a predicate is entered and an exception occurs if any flag in it is set. One of the flags is GCFLAG.
Reference: [4] <author> D. L. Bowen, </author> <title> DECsystem-10 Prolog User's Manual, </title> <institution> University of Edinburgh, Dept. of Artificial Intelligence, Edinburgh, </institution> <year> 1981. </year>
Reference: [5] <author> M. Bruynooghe, </author> <title> Garbage Collection in Prolog Interpreters, </title> <editor> in J. A. Campbell (ed.), </editor> <title> Implementations of Prolog, </title> <publisher> Ellis Horwood, </publisher> <year> 1984. </year>
Reference-contexts: Since the variables will not be referenced until backtracking reaches Chpt , any legal object could be left in them, but if they are changed into uninstantiated variables (i.e., self references in our implementation), the trail entry can also be removed. This is similar to `virtual backtracking' <ref> [5] </ref> and equivalent to `early reset of variables' [1]. As mentioned above, marking terms referenced from below LB:H 0 is also done by scanning the trail. Unfortunately, it turns out that partial backtracking and marking from below LB :H 0 cannot be done simultaneously.
Reference: [6] <author> M. Carlsson, </author> <title> Compilation for Tricia and Its Abstract Machine, </title> <type> UPMAIL Technical Report 35, </type> <institution> Uppsala, </institution> <month> Sept. </month> <year> 1986. </year>
Reference-contexts: We think we achieve this, at least in the compacting and updating phases. 3. THE MACHINE The machine for which this algorithm is designed is a somewhat revised version of WAM <ref> [3, 6] </ref>. The revisions relevant to the term stack GC are as follows: 1 * An extra register F is added, containing flags. This register is always tested when a predicate is entered and an exception occurs if any flag in it is set. One of the flags is GCFLAG.
Reference: [7] <author> T. Chikayama, Y. Kimura, </author> <title> Multiple Reference Management in Flat GHC, </title> <booktitle> 4th International Conference on Logic Programming, </booktitle> <pages> pp. 276-293, </pages> <address> Melbourne, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: Both variable and list-tagged pointers to the first word of the list object may appear. This can be avoided, at a price, by always moving unbound variables out of lists and other compound terms. There may be other reasons than garbage collection to do this <ref> [7] </ref>. The ideal garbage collection would progress in parallel with the computation, without interfering with it. This is sometimes referred to as real-time garbage collection. It requires using several processors or simulation by time-sharing on one processor [10, 18]. The algorithm described below is not a real-time garbage collector.
Reference: [8] <author> W. F. Clocksin, </author> <title> Design and Simulation of a Sequential Prolog Machine, </title> <journal> New Generation Computing, </journal> <volume> vol. 3, no. 2, </volume> <pages> pp. 101-120, </pages> <year> 1985. </year>
Reference-contexts: Placing the responsibility of returning garbage on the programmer is a too heavy burden for non-trivial programs so it should be mechanized and invisible to the programmer. In modern abstract Prolog machines, such as WAM [19] or ZIP <ref> [8] </ref> some garbage collection is built into the machine itself. On backtracking, allocated memory in the environment and term stacks is immediately reclaimed. In addition, environment stack memory is reclaimed during deterministic execution and tail-recursive calls.
Reference: [9] <author> J. Cohen, </author> <title> Garbage Collection of Linked Data Structures, </title> <journal> Computing Surveys, </journal> <volume> vol. 13, no. 3, </volume> <pages> pp. 341-367, </pages> <month> Sept. </month> <year> 1981. </year>
Reference-contexts: SOLUTION We define a mark-compact-update algorithm for garbage collection in a Prolog machine. The garbage collector works in three phases: marking, compacting, and updating. In the terms of Cohen's survey of garbage collection algorithms <ref> [9] </ref> our garbage collector could be characterized as a `sliding, compacting algorithm for varisized cells without using a break table'. The idea is to take advantage of a large virtual memory during garbage collection by using a temporary area, as large as the area being garbage collected.
Reference: [10] <author> E. W. Dijkstra, L. Lamport, A. J. Martin, C. S. Scholten, E. F. M. Steffens, </author> <title> On-the-Fly Garbage Collection: An Exercise in Cooperation, </title> <journal> Communications of the ACM, </journal> <volume> vol. 21, no. 11, </volume> <pages> pp. 966-975, </pages> <month> Nov. </month> <year> 1978. </year>
Reference-contexts: There may be other reasons than garbage collection to do this [7]. The ideal garbage collection would progress in parallel with the computation, without interfering with it. This is sometimes referred to as real-time garbage collection. It requires using several processors or simulation by time-sharing on one processor <ref> [10, 18] </ref>. The algorithm described below is not a real-time garbage collector. Pittomvils' discussion [15] about the modifications needed for real-time use mostly carries over to our algorithm. One aspect of garbage collection which is rarely discussed is when to do garbage collection.
Reference: [11] <author> D. E. Knuth, </author> <title> The Art of Computer Programming: Volume 1 / Fundamental Algorithms, </title> <publisher> Addison-Wesley, </publisher> <year> 1973. </year>
Reference: [12] <author> H. Lieberman, C. Hewitt, </author> <title> A Real Time Garbage Collector Based on the Life Time of Objects, </title> <journal> Communications of the ACM, </journal> <volume> vol. 23, no. 6, </volume> <pages> pp. 419-429, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: Also locality of references may be low while data is spread over a large area. In section 11 we discuss another alternative for when, and where, to do garbage collection which takes the life time of data into account <ref> [12] </ref>. 2. SOLUTION We define a mark-compact-update algorithm for garbage collection in a Prolog machine. The garbage collector works in three phases: marking, compacting, and updating. <p> But this does not necessarily give the shortest total execution time, because much time may be spent collecting garbage in areas containing comparatively little garbage. According to Lieberman and Hewitt, a good strategy is to reclaim garbage among recently created terms more often than among older terms <ref> [12] </ref>. We have noted one particular occasion when one can identify a part of the term stack which contains very much garbage. At the end of each loop in an iterative (here: tail-recursive and deterministic) program, almost everything created since the beginning of the loop is garbage.
Reference: [13] <author> F. L. Morris, </author> <title> A Time- and Space-Efficient Garbage Compaction Algorithm, </title> <journal> Communications of the ACM, </journal> <volume> vol. 21, no. 8, </volume> <pages> pp. 662-665, </pages> <month> Aug. </month> <year> 1978. </year>
Reference-contexts: Assuming that we have this perhaps large amount of virtual memory available, we can make the algorithm more efficient, since we do not have to worry about some complicated and/or time-consuming techniques (e.g., for compaction to keep track of pointers <ref> [13, 17] </ref>). In Cohen's survey, the technique to use a congruent temporary area for marking and updating does not seem to be represented, probably because there are few algorithms written to benefit from the use of a large memory.
Reference: [14] <author> D. A. Moon, </author> <title> Garbage Collection in a Large Lisp System, </title> <booktitle> 1984 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pp. 235-246, </pages> <address> Austin, </address> <month> Aug. </month> <year> 1984. </year>
Reference-contexts: The constant terms do not usually matter very much, except when D is very small. This garbage collection algorithm is intended for machines with a large virtual address space. According to Moon, one should pay attention to the difficulties introduced by virtual memory itself <ref> [14] </ref>. The time spent 9 in accessing memory increases rapidly if the page fault ratio is high. In the marking algorithm the memory references will probably be out of control and generate a quite high page fault rate.
Reference: [15] <author> E. Pittomvils, M. Bruynooghe, Y. D. Willems, </author> <title> Towards a Real Time Garbage Collector for Prolog, </title> <booktitle> 1985 Symposium on Logic Programming, </booktitle> <pages> pp. 185-198, </pages> <address> Boston, </address> <month> July </month> <year> 1985. </year>
Reference-contexts: This is sometimes referred to as real-time garbage collection. It requires using several processors or simulation by time-sharing on one processor [10, 18]. The algorithm described below is not a real-time garbage collector. Pittomvils' discussion <ref> [15] </ref> about the modifications needed for real-time use mostly carries over to our algorithm. One aspect of garbage collection which is rarely discussed is when to do garbage collection. <p> To be fully utilised, Pittomvils' algorithms require a segmentation of memory <ref> [15] </ref>. An object is represented by a word containing a tag and a value. The interpretation of the value depends on the tag. It is usually an address but is sometimes data. The following are the objects which may appear in the term stack and their internal structure. * Variables. <p> The marking phase is a recursive algorithm, adapted to the peculiarities of Prolog in a way similar to that of Pittomvils <ref> [15] </ref>. First, every term accessible from goals older than LB is marked. This information is available on the trail. Secondly, terms accessible from more recent goals, beginning with the most recent, are marked. <p> To keep track of which parts of an environment have been marked from, each environment contains a field N which should be initialized to 1 when an environment is created. This field has the same purpose as 4 the visit and number fields in the OTM algorithm <ref> [15] </ref>. A negative value of N indicates that the environment has not yet been marked. Zero or a positive value indicates that the environment has been visited, and is the number of variables which have been marked so far. <p> PROPERTIES OF THE ALGORITHM Our marking algorithm is like a mixture of the QOIM and serial OIM algorithms <ref> [15] </ref>. It differs from the (optimal) OIM algorithm in not marking objects below LB :H 0 . Still, there are pointers from below LB :H 0 to above. The only possible such pointers are variables that have become bound after the creation of LB . <p> However, the trail rules of WAM guarantee that all such bindings must have been recorded in the trail. So all pointers from below LB :H 0 are in turn pointed to from trail entries above LB :TR 0 . Since, (as Pittomvils notices <ref> [15] </ref>) when the term stack segments below Chpt :H 0 have been garbage collected, they cannot get more garbage until backtracking (or a cut) reaches below Chpt. This means that everything referred to from below LB :H 0 must be considered non-garbage. <p> This is similar to pointer-reversal techniques [1, 16]. 13. RELATED WORK The first version of this algorithm was developed in the autumn of 1985, and was inspired mostly by the work of Pittomvils, Bruynooghe, and Willems, presented at SLP '85 <ref> [15] </ref>. 10 Appleby, Haridi and Sahlin have recently presented a garbage collection algorithm for WAM, with many similarities to ours [1]. However, they have adapted a pointer reversal technique for the marking phase, instead of using a stack [16].
Reference: [16] <author> H. Schorr, W. M. Waite, </author> <title> An Efficient Machine-Independent Procedure for Garbage Collection in Various List Structures, </title> <journal> Communications of the ACM, </journal> <volume> vol. 10, no. 8, </volume> <pages> pp. 501-506, </pages> <month> Aug. </month> <year> 1967. </year>
Reference-contexts: This is similar to pointer-reversal techniques <ref> [1, 16] </ref>. 13. <p> However, they have adapted a pointer reversal technique for the marking phase, instead of using a stack <ref> [16] </ref>. Their algorithm does not reverse pointers in the choice point stack or save the current state in a choice point.
Reference: [17] <author> T. A. Standish, </author> <title> Data Structure Techniques, </title> <publisher> Addison-Wesley, </publisher> <year> 1980. </year>
Reference-contexts: Assuming that we have this perhaps large amount of virtual memory available, we can make the algorithm more efficient, since we do not have to worry about some complicated and/or time-consuming techniques (e.g., for compaction to keep track of pointers <ref> [13, 17] </ref>). In Cohen's survey, the technique to use a congruent temporary area for marking and updating does not seem to be represented, probably because there are few algorithms written to benefit from the use of a large memory.
Reference: [18] <author> G. L. Steele Jr., </author> <title> Multiprocessing Compactifying Garbage Collection, </title> <journal> Communications of the ACM, </journal> <volume> vol. 18, no. 9, </volume> <pages> pp. 495-508, </pages> <month> Sept. </month> <year> 1975. </year>
Reference-contexts: There may be other reasons than garbage collection to do this [7]. The ideal garbage collection would progress in parallel with the computation, without interfering with it. This is sometimes referred to as real-time garbage collection. It requires using several processors or simulation by time-sharing on one processor <ref> [10, 18] </ref>. The algorithm described below is not a real-time garbage collector. Pittomvils' discussion [15] about the modifications needed for real-time use mostly carries over to our algorithm. One aspect of garbage collection which is rarely discussed is when to do garbage collection.
Reference: [19] <author> D. H. D. Warren, </author> <title> An Abstract Prolog Prolog Instruction Set, </title> <type> SRI Technical Note 309, </type> <month> Oct. </month> <year> 1983. </year> <month> 11 </month>
Reference-contexts: Placing the responsibility of returning garbage on the programmer is a too heavy burden for non-trivial programs so it should be mechanized and invisible to the programmer. In modern abstract Prolog machines, such as WAM <ref> [19] </ref> or ZIP [8] some garbage collection is built into the machine itself. On backtracking, allocated memory in the environment and term stacks is immediately reclaimed. In addition, environment stack memory is reclaimed during deterministic execution and tail-recursive calls. <p> The size k is contained in the data. An object with any other tag is treated exactly like an atom. 2 4. NOTATION We will use the same names of registers in the machine and naming of fields in choice points and environments as Warren <ref> [19] </ref>. By @A we denote the contents of the word pointed to by A. Let GCB be either the choice point which was most recent at the previous garbage collection or the oldest choice point reached since by a trust, trust_me_else or cut operation.
References-found: 19

