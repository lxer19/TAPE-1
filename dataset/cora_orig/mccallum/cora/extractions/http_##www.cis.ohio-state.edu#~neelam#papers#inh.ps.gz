URL: http://www.cis.ohio-state.edu/~neelam/papers/inh.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~neelam/papers/research.html
Root-URL: 
Email: e-mail: fneelam,fridellag@cis.ohio-state.edu  
Title: Inheriting and Modifying Behavior  
Author: Neelam Soundarajan and Stephen Fridella 
Date: November 27, 1996  
Address: Columbus, OH 43210  
Affiliation: Computer and Information Science The Ohio State University  
Abstract: In many languages, the mechanism of protected members is critical to making inheritance work. It allows access to some of the internals of a base class B to the designer of a derived class D, while denying it to clients of B. We develop an axiomatic approach in which class behavior is specified in terms of an abstract specification AND a concrete specification, the former for use by a client, the latter containing information about how the protected members change, for use by a derived class designer. We present proof rules that allow us to establish that a class meets both specifications. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. Abadi, L. Cardelli, </author> <title> On subtyping and matching, </title> <booktitle> ECOOP '95, </booktitle> <volume> LNCS 952, </volume> <pages> pp. 145-167. </pages>
Reference: 2. <author> K. Bruce, A. Schuett, R. van Gent, Polytoil: </author> <title> a type-safe polymorphic object-oriented language, </title> <booktitle> ECOOP '95, </booktitle> <volume> LNCS 952, </volume> <pages> pp. 27-51. </pages>
Reference: 3. <author> W. Cook, W. Hill, P. Canning, </author> <title> Inheritance is not subtyping, </title> <booktitle> POPL, </booktitle> <year> 1990. </year>
Reference: 4. <author> J. Guttag, J. Horning, J. Wing, </author> <title> The Larch family of specificatio languages, </title> <journal> IEEE Software, </journal> <volume> vol. 2, </volume> <year> 1985. </year>
Reference-contexts: So the specification of a class will consist of a number of items. First the conceptual model of the class which can be given, for instance, in terms of a Larch-style <ref> [4] </ref> trait, although in order to keep the presentation simple, we will omit the formal details. Next we need an abstraction or encapsulation function " that maps from the concrete domain (of actual data members) to the conceptual model.
Reference: 5. <author> C. Horstmann, </author> <title> Mastering OO design in C++, </title> <publisher> Wiley, </publisher> <year> 1995. </year>
Reference-contexts: that our approach does not, somewhat surprisingly, require any additional work on the part of the base class designer than would be needed if we didn't allow protected members. 2 2 Protected Members and Reuse The usage of protected members in classes has often been criticized (see, for example, Horstmann <ref> [5] </ref>) because they allow us to break the encapsulation provided by the class.
Reference: 6. <author> G. Leavens, W. Weihl, </author> <title> Specification and verification of object-oriented programs using supertype abstraction, </title> <journal> Acta Informatica, </journal> <volume> vol. 32, </volume> <pages> pp. 705-778, </pages> <year> 1995. </year>
Reference-contexts: Naturally it is important to develop appropriate formalisms that can be used to specify and reason about the behavior of classes defined by inheritance from other classes. Indeed, several such formalisms have been developed, some notable ones being those of Liskov and Wing [8, 7], Leavens <ref> [6] </ref>, Meyer [9], etc. 1 In standard OO languages like C++, the mechanism of protected members of a given class plays a critical role in making inheritance work. <p> Indeed, formalisms such as those of <ref> [6, 8, 7] </ref> can be used to establish the subtype relation between two classes that may have been implemented completely independently of each other, rather than by using inheritance, so these are really orthogonal issues. <p> This is the other side of the orthogonality between inheritance and subtyping. Thus we have three possible cases: 1. Classes B and D are implemented independently of each other and we show that D is a subtype of B using, say, <ref> [6] </ref>. 2. D is implemented by using inheritance from B and there is no subtyping relation. <p> Once this is done, we can proceed to establish any relations, such as behavioral subtyping, between it and any other classes, including the base class, using systems like those of <ref> [8, 6] </ref>. We should also note that our interest has been exclusively on specifying and verifying, using an axiomatic approach, the behaviors of classes defined using inheritance with the derived classes being allowed to access the base classes' protected members.
Reference: 7. <author> B. Liskov, J. Wing, </author> <title> A behavioral notion of subtyping, </title> <journal> ACM TOPLAS, </journal> <volume> vol. 16, </volume> <pages> pp. 1811-1841, </pages> <year> 1994. </year>
Reference-contexts: Naturally it is important to develop appropriate formalisms that can be used to specify and reason about the behavior of classes defined by inheritance from other classes. Indeed, several such formalisms have been developed, some notable ones being those of Liskov and Wing <ref> [8, 7] </ref>, Leavens [6], Meyer [9], etc. 1 In standard OO languages like C++, the mechanism of protected members of a given class plays a critical role in making inheritance work. <p> Indeed, formalisms such as those of <ref> [6, 8, 7] </ref> can be used to establish the subtype relation between two classes that may have been implemented completely independently of each other, rather than by using inheritance, so these are really orthogonal issues.
Reference: 8. <author> B. Liskov, J. Wing, </author> <title> A new definition of the subtype relation, </title> <booktitle> ECOOP '93, </booktitle> <pages> pp. 118-141. </pages>
Reference-contexts: Naturally it is important to develop appropriate formalisms that can be used to specify and reason about the behavior of classes defined by inheritance from other classes. Indeed, several such formalisms have been developed, some notable ones being those of Liskov and Wing <ref> [8, 7] </ref>, Leavens [6], Meyer [9], etc. 1 In standard OO languages like C++, the mechanism of protected members of a given class plays a critical role in making inheritance work. <p> Indeed, formalisms such as those of <ref> [6, 8, 7] </ref> can be used to establish the subtype relation between two classes that may have been implemented completely independently of each other, rather than by using inheritance, so these are really orthogonal issues. <p> Once we have verified the correctness of a derived class D using the formalism developed in this paper, we can, if we so choose, use say the formalism of <ref> [8] </ref>, to show that this class is a (behavioral) subtype of the class B. This will not be always appropriate since not every derived class will be a subtype of its base class. This is the other side of the orthogonality between inheritance and subtyping. <p> The example is taken from <ref> [8] </ref>; Liskov and Wing discuss the subtype-supertype relation between the set class and the bag class but do not present an implementation. <p> This is a reasonable idea since a stack is-a bag, i.e., as <ref> [8] </ref> points out, stack is a (behavioral) subtype of bag. All that is needed to achieve this implementation is to override the Remove and Add operations in the derived class. Instead of choosing an arbitrary element to return, Remove should choose to return the most recently added element. <p> The abstract specification A will be the usual ADT-type specification, in terms of a conceptual, mathematical model of B, with the individual methods of B being specified as pre- and post-conditions in this conceptual model. In formalisms like that of <ref> [8] </ref>, A would essentially be the complete specification of B, and indeed we will borrow notation for this part of our specification from [8]. We can also include an invariant in A although for simplicity we will not do so. <p> In formalisms like that of <ref> [8] </ref>, A would essentially be the complete specification of B, and indeed we will borrow notation for this part of our specification from [8]. We can also include an invariant in A although for simplicity we will not do so. What information should C contain? The key component of C will also be a specification of the methods of B using pre- and post-conditions but there are some important differences with A. <p> f () [I ( t ) ^ c:pre f () ^ c:post f (; 0 )] ) a:post f ("( t ); "( 0 t )) It is perhaps in these final steps (3a) and (3b) that the difference between our formalism for dealing with inheritance and others such as <ref> [8] </ref> that deal with behavioral subtyping shows up most prominently. In our formalism, the derived class designer works with his own conceptual model, and abstract pre- and post-conditions. <p> Once this is done, we can proceed to establish any relations, such as behavioral subtyping, between it and any other classes, including the base class, using systems like those of <ref> [8, 6] </ref>. We should also note that our interest has been exclusively on specifying and verifying, using an axiomatic approach, the behaviors of classes defined using inheritance with the derived classes being allowed to access the base classes' protected members.
Reference: 9. <author> B. Meyer, </author> <title> Object oriented software construction, </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year> <title> 3 In C++ this would require g to have been declared as a virtual function. </title> <type> 15 </type>
Reference-contexts: Naturally it is important to develop appropriate formalisms that can be used to specify and reason about the behavior of classes defined by inheritance from other classes. Indeed, several such formalisms have been developed, some notable ones being those of Liskov and Wing [8, 7], Leavens [6], Meyer <ref> [9] </ref>, etc. 1 In standard OO languages like C++, the mechanism of protected members of a given class plays a critical role in making inheritance work. <p> The focus of much of this work has been to build precise models, in a denotational style, of how these mechanisms are intended work. Once that question is settled, it would be appropriate to investigate specification and verification methods for classes built using these forms of inheritance. Meyer <ref> [9] </ref> in his influential book on the object oriented approach develops a specification and verification method for classes defined using inheritance. Although he generally seems to advocate treating derived classes as subtypes, his formalism seems to be flexible enough to deal with cases where they are not. <p> Since f is not overridden, the designer of D will simply reuse the (concrete) specification of f from the base class B. (The system in <ref> [9] </ref> also seems to suffer from this problem.) To handle this situation correctly, we would have to somehow record in the (concrete) specification of f that there is a call to g, and if g is redefined in a derived class, to have that appropriately change the specification associated with f
References-found: 9

