URL: http://www.cs.arizona.edu/people/gene/PAPERS/twins.ps
Refering-URL: http://www.cs.arizona.edu/people/gene/vita.html
Root-URL: http://www.cs.arizona.edu
Title: AN ALGORITHM FOR LOCATING NON-OVERLAPPING REGIONS OF MAXIMUM ALIGNMENT SCORE  
Author: SAMPATH K. KANNAN AND EUGENE W. MYERS 
Abstract: In this paper we present an O(N 2 log 2 N) algorithm for finding the two non-overlapping substrings of a given string of length N which have the highest-scoring alignment between them. This significantly improves the previously best known bound of O(N 3 ) for the worst-case complexity of this problem. One of the central ideas in the design of this algorithm is that of partitioning a matrix into pieces in such a way that all submatrices of interest for this problem can be put together as the union of very few of these pieces. Other ideas include the use of candidate-lists, an application of the ideas of Apostolico et al.[1] to our problem domain, and divide and conquer techniques. 1. Introduction. Let A = a 1 a 2 :::a N be a sequence of length N , and let A[p::q] denote the sub-string a p a p+1 :::a q of A. The problem we consider is that of finding the score of the best alignment 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Apostolico, M.J. Atallah, L.L. Larmore, and S. McFaddin, </author> <title> "Efficient Parallel Algorithms for String Editing and Related Problems," </title> <journal> SIAM J. Comput. </journal> <volume> 19 (1990), </volume> <pages> 968-988. </pages>
Reference-contexts: This observation leads to the obvious O (N 3 ) algorithm for the twins problem: For each i 2 <ref> [1; N 1] </ref>, run the Smith-Waterman algorithm for A [1::i] versus A [i + 1::N ], and record the best answer over all possible separators i. <p> D [1::x][1::p 1]; O [1::p 1]) Propagate (I [x::n]; D [x::n][p + 1::m]; O [p + 1::m]) g Propagate (C (i; 0::j; z); M [(i; 0::j)][(N::i; j)]; C (N::i; j; z)) A call to Propagate correctly sets O [p] max 1xn I [x] + D [x][p] for every p 2 <ref> [1; m] </ref> by the same observation used by Apostolico et al.[1]. <p> Mesh Partitioning for Preprocessing Step for p b; 2b; 4b; :::; N=4 do for j p; 2p; 3p; :::; i p do f maxp (i; j) p if p = b then Compute D (p; i; j) de novo using the algorithm in <ref> [1] </ref> else Compute D (p; i; j) by fusing the 4 tables D (p=2; i; j), D (p=2; i + p=2; j), D (p=2; i; j p=2), and D (p=2; i + p=2; j p=2) using the algorithm in [1] g In a given iteration of the outer loop, observe that <p> Compute D (p; i; j) de novo using the algorithm in <ref> [1] </ref> else Compute D (p; i; j) by fusing the 4 tables D (p=2; i; j), D (p=2; i + p=2; j), D (p=2; i; j p=2), and D (p=2; i + p=2; j p=2) using the algorithm in [1] g In a given iteration of the outer loop, observe that O ((N=p) 2 ) tables are built, and since p doubles with each iteration, O ((N=b) 2 ) tables are built over the entire algorithm. <p> Thus the total time spent in Mesh propagate is bounded above by O (N log 2 N ). 11 4.2. The K-phase Algorithm. Recall that the basic block size b is N 1=K where K is yet to be chosen. For J 2 <ref> [1; K] </ref>. Let the N=b J intervals [0; b J ], [b J ; 2b J ], [2b J ; 3b J ], :::, [N b J ; N ] constitute the set of J-panels. <p> Note that the general algorithm succeeds in finding every twin as a twin must be a J-panel twin for some J 2 <ref> [1; K] </ref>. Finding the K-panel twins is an easy generalization of Step 1 of the algorithm of Section 3. Namely, for each partition index i = b K1 , 2b K1 , :::, N b K1 run the Smith-Waterman algorithm on A [1::i] versus A [i + 1::N ]. <p> We can afford to build a new p fi p matrix "on-the-fly" using the less-efficient O (p 2 logp) de novo algorithm of Apostolico et al. <ref> [1] </ref>. At any moment the space required during this process is easily seen to be O (N 2 ).
Reference: [2] <author> G. Benson, </author> <title> "A space efficient algorithm for finding the best non-overlapping alignment score," </title> <booktitle> Proc. 5th Symp. on Combinatorial Pattern Matching (Asilomar, CA), Lecture Notes in Computer Science Vol. </booktitle> <volume> 807, </volume> <publisher> (Springer Verlag, </publisher> <year> 1994), </year> <pages> 1-14. </pages>
Reference-contexts: Note that the dominant term comes from the cost of propagation through the mesh. In a conference version of this paper [4] the authors asked if the space complexity of the algorithm could be reduced from O (N 2 logN ). This was subsequently answered affirmatively by Benson <ref> [2] </ref> who gave an O (N 2 ) space algorithm with the same time complexity as ours.
Reference: [3] <author> R.A. Finkel and J.L. Bentley, "Quad-trees: </author> <title> a data structure for retrieval on composite key," </title> <journal> Acta Inform. </journal> <month> 4 </month> <year> (1974) </year> <month> 1-9. </month>
Reference-contexts: Instead we take the O (N ) set of all rectangular regions of the edit graph that candidates need to be propagated across, conceptually construct a quad-tree decomposition (see <ref> [3] </ref> for a description of quad-trees) of these regions, and then build a distance table for each region corresponding to a vertex in the quad-tree decomposition. This permits us to propagate candidates across a region by propagating them through a logarithmic number of precomputed distance tables that partition the region.
Reference: [4] <author> S. Kannan and E. Myers, </author> <title> "An algorithm for locating non-overlapping regions of maximum alignment score," </title> <booktitle> Proc. 4th Symp. Combinatorial Pattern Matching, Springer-Verlag Lecture Notes in Computer Science, </booktitle> <volume> Vol. 648 (1993), </volume> <pages> 74-86. </pages>
Reference-contexts: Choosing K = log N , makes b = N 1=K = 2 and gives us the bound O (N 2 log 2 N ). Note that the dominant term comes from the cost of propagation through the mesh. In a conference version of this paper <ref> [4] </ref> the authors asked if the space complexity of the algorithm could be reduced from O (N 2 logN ). This was subsequently answered affirmatively by Benson [2] who gave an O (N 2 ) space algorithm with the same time complexity as ours.
Reference: [5] <author> G.M. Landau and J.P. Schmidt, </author> <title> "An algorithm for approximate tandem repeats," </title> <booktitle> Proc. 4th Symp. Combi--natorial Pattern Matching Springer-Verlag Lecture Notes in Computer Science, </booktitle> <volume> Vol. 648 (1993), </volume> <pages> 120-133. </pages>
Reference-contexts: The path to the deepest internal node whose smallest and largest index suffixes are sufficiently far apart, gives us the desired repeated substring. In a development parallel to ours, Landau and Schmidt <ref> [5] </ref> have extended the algorithm of Main and Lorentz to find approximate tandem repeats with K-or-less differences: a thresholded variation of the problem considered here restricted to the simple Levenshtein measure of similarity (i.e., unit cost insertion, deletion, and substitution).
Reference: [6] <author> V.I. Levenshtein, </author> <title> "Binary codes of correcting deletions, </title> <journal> insertions and reversals," Soviet Phys. Dokl. </journal> <volume> 10 (1966), </volume> <pages> 707. </pages>
Reference-contexts: The problem we consider is that of finding the score of the best alignment between two substrings A [p::q] and A [r::s] under the the generalized Levenshtein model of alignment <ref> [6, 11] </ref> which permits substitutions, insertions, and deletions of arbitrary score. This problem is a formalization of the problem, encountered by molecular biologists, of automatically detecting repeated regions in DNA and protein sequences. This problem has recently been considered by Miller [8].
Reference: [7] <author> M.G. </author> <title> Main and R.J. Lorentz, "An O(n log n) algorithm for finding all repetitions in a string," </title> <editor> J. </editor> <booktitle> of Algorithms 5 (1984), </booktitle> <pages> 422-432. </pages>
Reference-contexts: When the exactly repeating regions are required to be adjacent or tandem, i.e. when the goal is to find the longest substring of A of the form ww, Main and Lorentz <ref> [7] </ref> provide an O (N log N ) algorithm.
Reference: [8] <author> W. Miller, </author> <title> "An algorithm for locating a repeated region," </title> <type> manuscript. </type>
Reference-contexts: This problem is a formalization of the problem, encountered by molecular biologists, of automatically detecting repeated regions in DNA and protein sequences. This problem has recently been considered by Miller <ref> [8] </ref>. When there is no restriction that the regions be non-overlapping, he points out that the problem can be solved in O (N 2 ) time by a straight-forward modification of the algorithm of Smith and Waterman [10] that finds the highest-scoring local alignment between two sequences. <p> This observation leads to the obvious O (N 3 ) algorithm for the twins problem: For each i 2 [1; N 1], run the Smith-Waterman algorithm for A [1::i] versus A [i + 1::N ], and record the best answer over all possible separators i. Miller <ref> [8] </ref> obtained an algorithm for finding twins that is more efficient in practice by computing C (i; j; k), the best path to (i; j) from row k for each value of k i.
Reference: [9] <author> E.W. Myers, </author> <title> "An O(ND) difference algorithm and its variants," </title> <booktitle> Algorithmica 1 (1986), </booktitle> <pages> 251-266. </pages>
Reference-contexts: In Section 6 we describe open problems mainly concerned with improving the space complexity of our algorithm. 2. Preliminaries. Throughout the paper we wish to think about the problem in terms of finding paths in a weighted edit graph <ref> [9] </ref> and performing the computation over the associated dynamic programming matrix [11].
Reference: [10] <author> T.F. Smith and M.S. Waterman, </author> <title> "Identification of common molecular sequences," </title> <journal> J. Mol. Biol. </journal> <volume> 147 (1981), </volume> <pages> 195-197. </pages>
Reference-contexts: This problem has recently been considered by Miller [8]. When there is no restriction that the regions be non-overlapping, he points out that the problem can be solved in O (N 2 ) time by a straight-forward modification of the algorithm of Smith and Waterman <ref> [10] </ref> that finds the highest-scoring local alignment between two sequences. Miller then goes on to consider the restriction that the regions be non-overlapping and presents a worst-case O (N 3 ) algorithm which runs in O (N 2 ) in practice.
Reference: [11] <author> R.A. Wagner and M.J. Fischer, </author> <title> "The String-to-String Correction Problem," </title> <editor> J. </editor> <booktitle> of ACM 21 (1974), </booktitle> <pages> 168-173. 15 </pages>
Reference-contexts: The problem we consider is that of finding the score of the best alignment between two substrings A [p::q] and A [r::s] under the the generalized Levenshtein model of alignment <ref> [6, 11] </ref> which permits substitutions, insertions, and deletions of arbitrary score. This problem is a formalization of the problem, encountered by molecular biologists, of automatically detecting repeated regions in DNA and protein sequences. This problem has recently been considered by Miller [8]. <p> Preliminaries. Throughout the paper we wish to think about the problem in terms of finding paths in a weighted edit graph [9] and performing the computation over the associated dynamic programming matrix <ref> [11] </ref>.
References-found: 11

