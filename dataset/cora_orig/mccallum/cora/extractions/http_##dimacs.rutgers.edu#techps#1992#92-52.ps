URL: http://dimacs.rutgers.edu/techps/1992/92-52.ps
Refering-URL: http://dimacs.rutgers.edu/TechnicalReports/1992.html
Root-URL: http://www.cs.rutgers.edu
Title: Tight Bound for Edge Guards in Monotone Polygons  
Author: by Iliana Bjorling-Sachs Diane L. Souvaine ; 
Address: New Brunswick, New Jersey 08903  New Brunswick, New Jersey 08903  
Affiliation: Department of Computer Science Rutgers University  Department of Computer Science Rutgers University  
Note: A  2 Permanent Member of DIMACS 3 Supported in part by National Science Foundation Grants #CCR-88-03549 and #CCR-91-04732. DIMACS is a cooperative project of Rutgers University, Princeton University, AT&T Bell Laboratories and Bellcore. DIMACS is an NSF Science and Technology Center, funded under contract STC-88-09648; and also receives support from the New Jersey Commission on Science and Technology.  
Abstract: DIMACS Technical Report 92-52 December 1992 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aggarwal, A. </author> <title> "The Art Gallery Theorem: Its Variations, Applications and Algorithmic Aspects," </title> <type> Ph.D. thesis, </type> <institution> Johns Hopkins University, </institution> <year> 1984. </year>
Reference-contexts: Guards of this type are called line guards. A tight bound of b (n + 2)=5c line guards for monotone polygons has been shown by Aggarwal <ref> [1] </ref>. 2 The lower bound is d (n 2)=5e. The behavior of the d (n 2)=5e bound can be seen in table 1. <p> The variables l; r and cd are the indices of the arrays L; R and CD respectively. - 49 - Algorithm Sort vertices by decreasing y-coordinate, resulting in P [0]; P <ref> [1] </ref>; :::; P [n 1]. For i = 1 to n 1 let ST [i] 0 Push 0. The index of a vertex is pushed, not the vertex itself. Push 1. If P [1] lies on left side then L [0] 1; R [0] 0 and CD [0] 0; 1 else <p> and CD respectively. - 49 - Algorithm Sort vertices by decreasing y-coordinate, resulting in P [0]; P <ref> [1] </ref>; :::; P [n 1]. For i = 1 to n 1 let ST [i] 0 Push 0. The index of a vertex is pushed, not the vertex itself. Push 1. If P [1] lies on left side then L [0] 1; R [0] 0 and CD [0] 0; 1 else L [0] 0; R [0] 1 and CD [0] 0; 1 l r cd 1 while i &lt; n do if P [i] is adjacent to P [v 0 ] then if P <p> For example for the category where exactly one cross-triangle is present we have: category1 if l = 1 then One endpoint is on the left side and two endpoints are on the right. if vertex with index L [0] lies below vertex with index R <ref> [1] </ref> then output edge which ends at vertex with index L [0]; else if vertex L [0] lies below vertex R [0] then output edge above vertex R [1]; else output edge below vertex L [0]; - 51 - else Two endpoints are on the left side and one endpoint on <p> the left side and two endpoints are on the right. if vertex with index L [0] lies below vertex with index R <ref> [1] </ref> then output edge which ends at vertex with index L [0]; else if vertex L [0] lies below vertex R [0] then output edge above vertex R [1]; else output edge below vertex L [0]; - 51 - else Two endpoints are on the left side and one endpoint on the right side. <p> In this category we also need to check entries in the array CD. category2 if l = 1 then if vertex with index L [0] lies below vertex with index R <ref> [1] </ref> then output edge above vertex with index L [0]; lef tovers 0; else if vertex with index L [0] lies below vertex with index R [0] then if lef tovers 2 then output edge below vertex with index R [0]; lef tovers ST [R [2]] 1; else output edge below <p> vertex with index L [0]; lef tovers 0; else if vertex with index L [0] lies below vertex with index R [0] then if lef tovers 2 then output edge below vertex with index R [0]; lef tovers ST [R [2]] 1; else output edge below vertex with index L <ref> [1] </ref>; lef tovers 0; else output edge below vertex with index L [1]; lef tovers 0; else if l = 2 then if CD [1] = 0; 1 then if vertex with index L [0] lies below vertex with index R [1] then if ST [R [1]] 2 then output edge <p> index L [0] lies below vertex with index R [0] then if lef tovers 2 then output edge below vertex with index R [0]; lef tovers ST [R [2]] 1; else output edge below vertex with index L <ref> [1] </ref>; lef tovers 0; else output edge below vertex with index L [1]; lef tovers 0; else if l = 2 then if CD [1] = 0; 1 then if vertex with index L [0] lies below vertex with index R [1] then if ST [R [1]] 2 then output edge above vertex with index L [0]; lef tovers ST [L [1]] 1; <p> lef tovers 2 then output edge below vertex with index R [0]; lef tovers ST [R [2]] 1; else output edge below vertex with index L <ref> [1] </ref>; lef tovers 0; else output edge below vertex with index L [1]; lef tovers 0; else if l = 2 then if CD [1] = 0; 1 then if vertex with index L [0] lies below vertex with index R [1] then if ST [R [1]] 2 then output edge above vertex with index L [0]; lef tovers ST [L [1]] 1; else output edge below vertex with index R [1]]; lef tovers 0; <p> 1; else output edge below vertex with index L <ref> [1] </ref>; lef tovers 0; else output edge below vertex with index L [1]; lef tovers 0; else if l = 2 then if CD [1] = 0; 1 then if vertex with index L [0] lies below vertex with index R [1] then if ST [R [1]] 2 then output edge above vertex with index L [0]; lef tovers ST [L [1]] 1; else output edge below vertex with index R [1]]; lef tovers 0; endif else if vertex with index L [0] lies below vertex with index R [0] then output <p> vertex with index L <ref> [1] </ref>; lef tovers 0; else output edge below vertex with index L [1]; lef tovers 0; else if l = 2 then if CD [1] = 0; 1 then if vertex with index L [0] lies below vertex with index R [1] then if ST [R [1]] 2 then output edge above vertex with index L [0]; lef tovers ST [L [1]] 1; else output edge below vertex with index R [1]]; lef tovers 0; endif else if vertex with index L [0] lies below vertex with index R [0] then output edge above vertex with index <p> L <ref> [1] </ref>; lef tovers 0; else if l = 2 then if CD [1] = 0; 1 then if vertex with index L [0] lies below vertex with index R [1] then if ST [R [1]] 2 then output edge above vertex with index L [0]; lef tovers ST [L [1]] 1; else output edge below vertex with index R [1]]; lef tovers 0; endif else if vertex with index L [0] lies below vertex with index R [0] then output edge above vertex with index R [1]; lef tovers 0; - 52 - else output edge above vertex with index <p> then if CD <ref> [1] </ref> = 0; 1 then if vertex with index L [0] lies below vertex with index R [1] then if ST [R [1]] 2 then output edge above vertex with index L [0]; lef tovers ST [L [1]] 1; else output edge below vertex with index R [1]]; lef tovers 0; endif else if vertex with index L [0] lies below vertex with index R [0] then output edge above vertex with index R [1]; lef tovers 0; - 52 - else output edge above vertex with index L [1]; lef tovers 0; endif else The cross-diagonal runs <p> then output edge above vertex with index L [0]; lef tovers ST [L <ref> [1] </ref>] 1; else output edge below vertex with index R [1]]; lef tovers 0; endif else if vertex with index L [0] lies below vertex with index R [0] then output edge above vertex with index R [1]; lef tovers 0; - 52 - else output edge above vertex with index L [1]; lef tovers 0; endif else The cross-diagonal runs between the vertices with indices L [1] and R [0]. <p> else output edge below vertex with index R <ref> [1] </ref>]; lef tovers 0; endif else if vertex with index L [0] lies below vertex with index R [0] then output edge above vertex with index R [1]; lef tovers 0; - 52 - else output edge above vertex with index L [1]; lef tovers 0; endif else The cross-diagonal runs between the vertices with indices L [1] and R [0]. The cases are symmetric to those above. ... else There are three endpoints on the left side. These cases are symmetric to those for l = 1 above. ... <p> vertex with index L [0] lies below vertex with index R [0] then output edge above vertex with index R <ref> [1] </ref>; lef tovers 0; - 52 - else output edge above vertex with index L [1]; lef tovers 0; endif else The cross-diagonal runs between the vertices with indices L [1] and R [0]. The cases are symmetric to those above. ... else There are three endpoints on the left side. These cases are symmetric to those for l = 1 above. ... The routines for the other categories are similar.
Reference: [2] <author> Bjorling-Sachs, I. </author> <title> "A Tight Bound for Edge Guards in Rectilinear Monotone polygons," </title> <note> In preparation. </note>
Reference-contexts: below vertex with index R [1] then output edge above vertex with index L [0]; lef tovers 0; else if vertex with index L [0] lies below vertex with index R [0] then if lef tovers 2 then output edge below vertex with index R [0]; lef tovers ST [R <ref> [2] </ref>] 1; else output edge below vertex with index L [1]; lef tovers 0; else output edge below vertex with index L [1]; lef tovers 0; else if l = 2 then if CD [1] = 0; 1 then if vertex with index L [0] lies below vertex with index R <p> The algorithm was derived from the constructive proof. The same method, using convex quadrilaterals instead of triangles, has been used to show that d (n 2)=6e is a tight bound on the number of edge guards required to cover any rectilinear monotone polygon <ref> [2] </ref> and to provide a linear time algorithm for placing these guards. The problem of finding a tight bound for the number of edge guards required in any arbitrarily shaped simple polygon remains unsolved. The best known upper bound is bn=3c edge guards.
Reference: [3] <author> Chvatal, V. </author> <title> "A Combinatorial Theorem in Plane Geometry," </title> <editor> J. </editor> <booktitle> Combinatorial Theory Series B 18 (1975), </booktitle> <pages> 39-41. </pages>
Reference-contexts: The polygon is covered if every point inside it is seen by at least one guard. In 1975 Chvatal showed that no polygon with n vertices requires more than bn=3c guards and that polygons exist for which this number of guards is necessary <ref> [3] </ref>. Variations of the original art gallery problem have attracted considerable attention since that time, and numerous results have been the focus of a book by O'Rourke [5] and of an extensive survey paper by Shermer [6].
Reference: [4] <author> Garey, Johnson, Preparata and Tarjan, </author> <title> "Triangulating a Simple Polygon," Info. </title> <booktitle> Proc. Letters 7 (1978), </booktitle> <pages> 175-180. </pages>
Reference-contexts: To establish the upper bound we start by triangulating P . Monotone polygons are easily triangulated - 3 - b d f h k m using an algorithm by Garey, Johnson, Preparata and Tarjan <ref> [4] </ref>. We convert this algorithm into an algorithm for assigning edge guards. The original algorithm starts at the topmost vertex and moves downward creating triangles by drawing internal diagonals between vertices. <p> from section 2, we have the following theorem: Theorem 1 d (n 2)=5e edge guards are sometimes necessary and always sufficient to cover a monotone polygon of n vertices. 4 Algorithmic aspects In the proof of the upper bound the polygon is triangulated using an existing algorithm for monotone polygons <ref> [4] </ref>. This algorithm produces a triangulation with a very predictable structure. Taking advantage of this structure, we modify the algorithm to enable it to assign edge guards. The main modification is the addition of a conditional statement, where each case results in the output of an edge guard.
Reference: [5] <author> O'Rourke, J. </author> <title> "Art gallery problems and algorithms," </title> <publisher> Oxford University Press (1987). </publisher>
Reference-contexts: Variations of the original art gallery problem have attracted considerable attention since that time, and numerous results have been the focus of a book by O'Rourke <ref> [5] </ref> and of an extensive survey paper by Shermer [6]. One variation posed in 1981 by Toussaint and still unsolved asks for the minimum number of guards necessary to cover any polygon of n vertices if the guards are allowed the freedom to move along individual edges of the polygon. <p> This is arrived at by simply taking the bn=3c vertex guards known to cover the polygon and assigning the edges incident to these vertices as edge guards. A general example of a polygon with n vertices that requires as many as bn=4c edge guards is shown in <ref> [5] </ref>. This example is due to Toussaint, who conjectures that bn=4c is a tight bound on the number of guards, with the qualification that certain polygons with a small number of vertices are - 53 - excluded.
Reference: [6] <author> Shermer, T. </author> <title> "Recent Results in Art Galleries," </title> <institution> Simon Fraser University Technical Report, </institution> <month> October </month> <year> 1990. </year>
Reference-contexts: Variations of the original art gallery problem have attracted considerable attention since that time, and numerous results have been the focus of a book by O'Rourke [5] and of an extensive survey paper by Shermer <ref> [6] </ref>. One variation posed in 1981 by Toussaint and still unsolved asks for the minimum number of guards necessary to cover any polygon of n vertices if the guards are allowed the freedom to move along individual edges of the polygon. Guards of this type are called edge guards. <p> This example is due to Toussaint, who conjectures that bn=4c is a tight bound on the number of guards, with the qualification that certain polygons with a small number of vertices are - 53 - excluded. Of the two excluded polygons, discovered by Paige and Shermer <ref> [6] </ref>, one has seven vertices and requires two edge guards while the other has eleven vertices and requires three edge guards. Thus if these polygons are not excluded the lower bound for the number of edge guards required in an arbitrarily shaped simple polygon is b (n + 1)=4c.
References-found: 6

