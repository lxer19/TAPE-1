URL: ftp://ftp.cs.virginia.edu/pub/dissertations/9802.ps.Z
Refering-URL: ftp://ftp.cs.virginia.edu/pub/dissertations/README.html
Root-URL: http://www.cs.virginia.edu
Title: A Dissertation  Process State Capture and Recovery in High-Performance Heterogeneous Distributed Computing Systems  
Author: Adam John Ferrari 
Degree: Presented to the Faculty of the School of Engineering and Applied Science at the University of Virginia In Partial Fulfillment of the Requirements for the Degree Doctor of Philosophy, Computer Science  
Note: by  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. Acharya, M. Ranganathan, J. Saltz, Sumatra: </author> <title> A Language for Resource-aware Mobile Programs, </title> <editor> in Vitek, J., Tschudin, C., eds. </editor> <booktitle> Mobile Object Systems, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: on performance. 1.1 Motivation 1.1.1 High Performance Heterogeneous Distributed Computing Recent developments in software systems and the growing availability of higher-performance computing and networking hardware have made commonplace the use of networks of workstations, personal computers, and supercomputers as virtual, distributed-memory parallel machines, or metasystems, for solving computationally demanding problems <ref> [1, 34, 38, 41] </ref>. The combination of heterogeneous architectures and operating system platforms within a high-performance distributed metasystem gives rise to a number of problems not present in homogenous distributed systems and parallel computers. <p> For example, one straightforward approach is to use an interpreted language, as in mobile process step 1 step 2 program: step 1 step 2 step 3 step 4 restarted process step 3 step 4 checkpoint state capture state recovery restart nodesource node 6 agent systems such as Sumatra <ref> [1] </ref> and Ara [67,68]. In these designs, the interpreter acts as a virtual machine that can artificially homogenize a system composed of heterogeneous elements. <p> Systems such as NOW <ref> [1] </ref> and Condor [54] rely on the ability to capture the state of a process on one node and resume that pro 16 cess on a different node to achieve more equitable distributions of work among the nodes in a metasystem. <p> The growing interest in the area of mobile agents has resulted in a number of state-capture and recovery mechanisms to support migration in mobile agent languages. For example, the Sumatra <ref> [1] </ref> language supports the capture and recovery of Java threads in a heterogeneous environment. State capture and recovery in Sumatra is implemented by a set of modifications to the Java Virtual Machine [35] bytecode interpreter. A more flexible approach is supported by the Ara system [67, 68].
Reference: [2] <author> T.E. Anderson, D.E. Culler, D.A. Patterson, </author> <title> and the NOW team, A Case for NOW (networks of Workstations) IEEE Micro, </title> <journal> vol. </journal> <volume> 15, no. 1, </volume> <pages> pp. 54-64, </pages> <month> February, </month> <year> 1995. </year>
Reference-contexts: Similar collection and integration of separate services architectures are employed in a number other metacomputing systems such as the Berkeley NOW project <ref> [2] </ref>, MOL [71], and ISoft [30]. An alternative approach to metacomputing employed by the Legion project [39, 40] is based on distributed active objects. In Legion, all system and application software components are active objects with logically disjoint address spaces [52].
Reference: [3] <author> R.H. Arpaci, A. Dusseau, A.M. Vahdat, L.T. Liu, T.E. Anderson, and D.A. Patterson, </author> <title> The Interaction of Parallel and Sequential Workloads on a Network of Workstations, </title> <booktitle> in Proceedings of SIGMETRICS '95 , 1995. </booktitle>
Reference-contexts: First, although metacomputing can be beneficial for both computationally intensive jobs and short-running interactive jobs (e.g. through remote execution and load sharing), a key to the effective use of metacomputing environments is the management of large, computationally expensive, possibly parallel applications <ref> [3] </ref>. <p> A performance study performed on the Berkeley NOW system <ref> [3] </ref> determined that not only was adaptive load sharing effective at increasing the performance of both parallel and sequential applications in a shared environment, but the reduction of impact on interactive users by parallel jobs afforded by load sharing was critical to the social acceptance of parallel computing in a shared
Reference: [4] <author> Y. Artsy and R. Finkel, </author> <title> Designing a Process Migration Facility: </title> <booktitle> The Charlotte Experience, IEEE Computer, </booktitle> <pages> pp. 47-56, </pages> <month> September, </month> <year> 1989. </year>
Reference-contexts: is, a high amount of computation performed for each byte of information communicated between tasks [93]. 2.2 The Need for Process State Capture and Recovery Whereas the ability to capture and restore the state of a process has been available for some time in a variety of homogeneous distributed systems <ref> [4, 20, 54, 64, 70, 86] </ref>, this feature has been absent in most metacomputing environments. <p> Most homogeneous state capture mechanisms are implemented inside operating systems at the kernel level due to efficiency concerns and because a processs external state is more readily available at that level. For example, systems such as Charlotte <ref> [4] </ref>, Sprite [20], DEMOS/MP [70], and the V-System [86] utilize kernel-level state capture and recovery mechanisms to support process migration. Although these and other kernel-level homogeneous state capture mechanisms differ in certain performance-related respects, they share a common basic approach to capturing the state of a process.
Reference: [5] <author> D. Bailey, J. Barton, T. Lasinski, and H. Simon, et. al., </author> <title> The NAS Parallel Benchmarks, </title> <type> Technical Report RNR-94-007, </type> <institution> NASA Ames, Moffett Field, California, </institution> <month> March </month> <year> 1994. </year>
Reference-contexts: Although metasystems software is not yet mature, early results on heterogeneous network computing testbeds have been promising. For example, a detailed performance study of the NAS benchmark suite <ref> [5] </ref> using PVM on the HEAT testbed [51] was presented by White, Alund, and Sunderam [93]. Their results showed that relatively small clusters of workstations could provide performance within an order of magnitude of a 1-node Cray Y-MP. <p> would have used big-endian ordering, and thus all would have performed approximately as well as the incompatible recovery operations listed in Table 7.8. 7.4 NAS Benchmark Kernels As a second, more substantial set of applications, we applied the Process Introspection to a subset of the NAS benchmark kernels, described in <ref> [5] </ref>. The four kernels that we used average approximately 370 lines of code each, and like the programs described in Section 7.3, do not rely on separate compilation.
Reference: [6] <author> A. Barak, G. Shai, and R.G. Wheeler, </author> <title> The MOSIX Distributed Operating System: Load Balancing for Unix, </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference: [7] <author> A. Beguelin, E. Seligman, and M. Starkey, Dome: </author> <title> Distributed Object Migration Environment, </title> <institution> Carnegie Mellon University Technical Report CMU-CS-94-153, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: Generality The mechanism should be appropriate for use with a wide variety of programs that are written in a variety of languages, and that solve a wide range of problems. This precludes special purpose toolkits appropriate only for problems of a certain structure such as Dome <ref> [7] </ref>, which provides automatic state capture and recovery for array data types suitable for use in data-parallel applications.
Reference: [8] <author> K.P. Birman, T.A. Joseph, T. Raeuchle, and A. El Abbadi, </author> <title> Implementing Fault-Tolerant Distributed Objects, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 11, no. 6, </volume> <pages> pp. 502-508, </pages> <month> June </month> <year> 1985. </year>
Reference: [9] <author> M. Bishop and M. </author> <title> Valence, Process Migration for Heterogeneous Distributed Systems, </title> <institution> Dartmouth College Technical Report PCS-TR95-264, </institution> <month> August 21, </month> <year> 1995. </year>
Reference: [10] <author> A. Black, N. Hutchinson, E. Jul, H. Levy, and L. Carter, </author> <title> Distribution and Abstract Types in Emerald, </title> <journal> IEEE Transactions on Software Engineering , vol. </journal> <volume> SE-13, no. 1, </volume> <pages> pp. 65-76, </pages> <month> January, </month> <year> 1987. </year>
Reference: [11] <author> F. Bodin, P. Beckman, D. Gannon, J. Gotwals, S. Narayana, S. Srinivas, and B. Winnicka, Sage++: </author> <title> An ObjectOriented Toolkit and Class Library for Building Fortran and C++ Restructuring Tools, </title> <address> OONSKI, </address> <year> 1994. </year>
Reference-contexts: At this level of automation, the programmer is still required to perform code modifications such as poll-point placement and prologue generation manually in order to employ Process Introspection. Fortunately, for platform-independent programs this process can be automated by a source code translator. Using the Sage++ toolkit <ref> [11] </ref>, we have implemented this idea in the APrIL compiler. In this chapter, we examine the design of the APrIL compiler, and the fundamental specific transformations it employs. 6.1 Intermediate Representation The model described in Chapter 3 required that the input to the translator be in a common intermediate representation. <p> Finally, source-to-source translation based on ANSI C meets the third goal of a rich existing tool set. Optimizing back-end compilers are widely available. Front-end source-to-source translation toolkits are also available; for example, the Sage++ library <ref> [11] </ref> (which was used to implement APrIL) provides an objectoriented interface to parsing, manipulating, and transforming C++ (and thus C) using a set of C++ object classes. It should be noted that the use of C as the intermediate representation is not fundamental to the APrIL design.
Reference: [12] <author> L. Cardelli, </author> <title> Oblique: A Language with Distributed Scope, </title> <type> Technical Report, </type> <institution> Digital Equipment Corporation, </institution> <month> May </month> <year> 1995. </year>
Reference: [13] <author> N. Carriero, D. Gelernter, T.G. Mattson, and A.H. Sherman, </author> <title> The Linda Alternative to Message-passing Systems, </title> <journal> Parallel Computing, </journal> <volume> vol. 20, </volume> <pages> pp. 633-655, </pages> <year> 1994. </year>
Reference-contexts: Whereas MPI, PVM, and the large class of systems that is essentially isomorphic to these [88] provide essentially identical message-passing based programming models, a few network heterogeneous systems have supported alternative, higher-level models. For example, Linda <ref> [13] </ref> provides a shared tuple space into which tasks can read and write data in order to cooperate with one another. Mentat [37] supports a C++-based programming model in which the basic units of computation and scheduling are active objects that communicate via asynchronous methods.
Reference: [14] <author> J. Casas, D.L. Clark, R. Konuru, S.W. Otto, R.M. Prouty, J. Walpole, </author> <title> Adaptive Load 181 Migration Systems for PVM, </title> <booktitle> in Proceedings of Supercomputing 94 , pp. </booktitle> <pages> 390-399, </pages> <month> November, </month> <year> 1994. </year>
Reference-contexts: These issues, along with the requirement of support for heterogeneity, strongly suggest the use of user-level state capture mechanisms. 2.3.1.2 User Level Mechanisms A number of systems to date have provided some form of homogeneous process state capture implemented at the user level (i.e. without direct, special kernel support) <ref> [14, 55, 54, 69] </ref>. For example, Condor [55] performs process state capture and recovery in homogeneous environments by using a slightly modified core dump of the process to capture and recover memory and processor state.
Reference: [15] <author> J. Casas, D.L. Clark, R. Konuru, S.W. Otto, R.M. Prouty, J. Walpole, MPVM: </author> <title> A Migration Transparent Version of PVM, </title> <type> Technical Report, </type> <institution> Oregon Graduate Institute of Science and Technology, Portland, Oregon, </institution> <month> February, </month> <year> 1995. </year>
Reference-contexts: For example, some user-level approaches such as Condor and Mandelberg/Sunderam [57] restrict certain forms of intra-process communication mechanisms. However, this argument against user-level state capture mechanisms is largely unfounded, as demonstrated systems such as MIST/MPVM <ref> [15, 16] </ref>, Failsafe PVM [50], and Hector [72]. These systems provide a location-independent communication layer that renders process migrations transparent to message passing operations performed at the application level.
Reference: [16] <author> J. Casas, D.L. Clark, P.S. Galbiati, R. Konuru, S.W. Otto, R.M. Prouty, J. Walpole, MIST: </author> <title> PVM with Transparent Migration and Checkpointing, </title> <booktitle> 3rd Annual PVM Users Group Meeting, </booktitle> <address> Pittsburgh, PA, </address> <month> May 7-9, </month> <year> 1995. </year>
Reference-contexts: For example, some user-level approaches such as Condor and Mandelberg/Sunderam [57] restrict certain forms of intra-process communication mechanisms. However, this argument against user-level state capture mechanisms is largely unfounded, as demonstrated systems such as MIST/MPVM <ref> [15, 16] </ref>, Failsafe PVM [50], and Hector [72]. These systems provide a location-independent communication layer that renders process migrations transparent to message passing operations performed at the application level.
Reference: [17] <author> H. Cejtin, S. Jagannathan, and R. Kelsey, </author> <title> Higher-Order Distributed Objects, </title> <journal> ACM Transactions on Programming Languages and Systems , vol. </journal> <volume> 17, no. 5, </volume> <pages> pp. 704-739, </pages> <address> Sep-tember, </address> <year> 1995. </year>
Reference: [18] <author> K.M. Chandy and L. Lamport, </author> <title> Distributed Snapshots: Determining Global States of Distributed Systems, </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> vol. 3, no. 1, </volume> <pages> pp. 63-75, </pages> <address> Feb-ruary, </address> <year> 1985. </year>
Reference-contexts: For example, systems such as Failsafe PVM [50] rely on this ability. The use of process checkpointing for rollback-recovery protocols typically relies on the ability either to synchronize the checkpoints of cooperating tasks (for example, using the checkpoint coordination algorithms of Chandy and Lamport <ref> [18] </ref> or Mattern [59]), or to propagate the rollback of related tasks to reach a consistent state [89]. <p> Case 1, System Support In some cases, it is desirable or convenient for the processs environment (either the operating system or metasystem software) to provide some system support for checkpointing with respect to external state. For example, the MIST <ref> [18] </ref> system provides system support for checkpointing sets of processes communicating via the PVM interface, and the CoCheck system [84] provides similar functionality for MPI programs. These systems provide the ability to capture network state external to individual processes, allowing the process state capture mechanism to focus on internal state.
Reference: [19] <author> C. Cowan, H.L. Lutfiyya, and M.A. Bauer, </author> <title> Performance Benefits of Optimistic Programming: A Measure of HOPE, </title> <booktitle> in Proceedings of the 4th IEEE Symposium on High Performance Distributed Computing, </booktitle> <pages> pp. 197-204, </pages> <year> 1995. </year>
Reference-contexts: Beyond failure resilience, the ability to roll back a computation afforded by a process state capture and recovery mechanism can be used to implement the semantics of certain programming environments. For example, systems such as Time Warp [43] and Hope <ref> [19] </ref> rely on process state capture and recovery to provide semantic guarantees such as the causal ordering of message deliv 3 ery to a process. Well-documented uses for a process state capture and recovery mechanism such as load sharing and fault tolerance address issues of increasing importance in metacomputing environments.
Reference: [20] <author> F. Douglis and J. Osterhout, </author> <title> Process Migration in the Sprite Operating System, </title> <booktitle> in Proceedings of the 7th International Conference on Distributed Computing, </booktitle> <pages> pp. 18-25, </pages> <year> 1987. </year>
Reference-contexts: is, a high amount of computation performed for each byte of information communicated between tasks [93]. 2.2 The Need for Process State Capture and Recovery Whereas the ability to capture and restore the state of a process has been available for some time in a variety of homogeneous distributed systems <ref> [4, 20, 54, 64, 70, 86] </ref>, this feature has been absent in most metacomputing environments. <p> Most homogeneous state capture mechanisms are implemented inside operating systems at the kernel level due to efficiency concerns and because a processs external state is more readily available at that level. For example, systems such as Charlotte [4], Sprite <ref> [20] </ref>, DEMOS/MP [70], and the V-System [86] utilize kernel-level state capture and recovery mechanisms to support process migration. Although these and other kernel-level homogeneous state capture mechanisms differ in certain performance-related respects, they share a common basic approach to capturing the state of a process.
Reference: [21] <author> F.B. Dubach, </author> <title> R.M. Rutherford, and C.M. Shub, ProcessOriginated Migration in a Heterogeneous Environment, </title> <booktitle> Proceedings of the ACM Computer Science Conference , pp.98-102, </booktitle> <month> February, </month> <year> 1989. </year>
Reference-contexts: In our model, these compatible well-defined states occur when poll points are encountered. Related implementation work done by this group integrated a limited form of heterogeneous process migration into the V system <ref> [21] </ref>. 20 This implementation relied on the operating system to examine and translate the memory state of the process based on type information embedded in the processs program text. The design suffered certain limitations, particularly the requirement that data structures reside at identical addresses in all versions of a process. <p> The act of requesting a checkpoint from the process is thus equivalent to setting the value of CheckpointStatus. This might be accomplished within the process, providing a user directed style of checkpointing <ref> [21] </ref>, or might occur via an interrupt from the processs environment, or via shared memory with the processs environment. The later two forms permit a standard, externally requested process state capture.
Reference: [22] <author> D.L. Eager, E.D. Lazowska, and J. Zahorjan, </author> <title> Adaptive Load Sharing in Homogeneous Distributed Systems, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. SE-12, no. 5, </volume> <pages> pp. 662-675, </pages> <month> May </month> <year> 1986. </year>
Reference-contexts: to a lack of need for such a mechanism. 2.2.1 Load Balancing and Load Sharing It has long been recognized that adaptive load sharing as enabled by a process state capture and recovery mechanism is an effective means of increasing performance (e.g. throughput, response time, etc.) in a distributed system <ref> [22, 63, 73] </ref>. Systems such as NOW [1] and Condor [54] rely on the ability to capture the state of a process on one node and resume that pro 16 cess on a different node to achieve more equitable distributions of work among the nodes in a metasystem.
Reference: [23] <author> D.L. Eager, E.D. Lazowska, and J. Zahorjan, </author> <title> The Limited Performance Benefits from Migrating Active Processes for Load Sharing, </title> <booktitle> ACM SIGMETRICS , pp. </booktitle> <pages> 662-675, </pages> <month> May </month> <year> 1988. </year>
Reference: [24] <author> E.N. Elnozahy, D.B. Johnson, Y.M. Wang, </author> <title> A Survey of Rollback-Recovery Protocols in Message-Passing Systems, </title> <type> Technical Report CMU-CS-96-181, </type> <institution> Carnegie Mellon University, </institution> <month> October, </month> <year> 1996. </year>
Reference-contexts: For example, process migration policies supporting load sharing and/or fault tolerance can be based on a process state capture facility (e.g. Condor [54]). Process state capture and recovery is also the basis of a large class of backward error recovery schemes documented in the fault tolerance literature <ref> [24] </ref>. Beyond failure resilience, the ability to roll back a computation afforded by a process state capture and recovery mechanism can be used to implement the semantics of certain programming environments. <p> this is the shared nature of many metasystems, where interactive users and long-running parallel applications must compete for resources. 2.2.2 Fault Tolerance The ability to capture and later recover the full state of a process is the basis of a large class of backward error recovery techniques for fault tolerance <ref> [24] </ref>. For example, systems such as Failsafe PVM [50] rely on this ability.
Reference: [25] <author> M.M. Eshaghian, </author> <title> An Introduction to Heterogeneous Computing, in Heterogeneous Computing, </title> <editor> M.M. Eshaghian, ed., </editor> <publisher> Artech House Publishers, </publisher> <pages> pp. 1-16, </pages> <year> 1996. </year> <month> 182 </month>
Reference-contexts: This technique, referred to variously as network heterogeneous computing <ref> [25] </ref>, mixed-machine heterogeneous computing [74], or metacomputing [38, 75] is a promising area of research for a variety of reasons.
Reference: [26] <author> M.R. Eskicioglu, </author> <title> Design Issues of Process Migration Facilities in Distributed Systems, </title> <journal> IEEE Technical Committee on Operating Systems Newsletter, </journal> <volume> vol. 4, no. 2, </volume> <pages> pp. 3-13, </pages> <month> Winter, </month> <year> 1989. </year>
Reference-contexts: Although these and other kernel-level homogeneous state capture mechanisms differ in certain performance-related respects, they share a common basic approach to capturing the state of a process. The state of the process is commonly defined to consist of <ref> [26] </ref>: virtual memorycode, stack, and data segments of the processs address space open filesfile descriptors, file pointers, I/O buffers, etc. communication buffersconnection information, message buffer contents, etc. processor statecurrent condition codes, program counter, stack pointer, general pur pose registers, etc. 18 environment dataprocess identifier, user name, etc.
Reference: [27] <author> S.I. Feldman, D.M. Gay, M.W. Maimone, </author> <title> and N.L. Schryer, A Fortran-to-C Converter, </title> <note> Computing Science Technical Report no. 149, </note> <institution> AT&T Bell Laboratories, </institution> <year> 1990. </year>
Reference-contexts: This strategy leads to a number of potential problems. First, the C code generated by alternate language front ends may not be acceptable input for APrIL. For example, f2c , the de-facto standard Fortran to C translator <ref> [27] </ref>, makes use of union data structures (which are not currently supported by APrIL) in some of its transformations. Furthermore, the translated code may make use of libraries that would also need to be modified to include state capture and recovery capabilities.
Reference: [28] <author> A.J. Ferrari and V.S. Sunderam, </author> <title> Multiparadigm Distributed Computing with TPVM, </title> <journal> Journal of Concurrency, Practice and Experience, </journal> <note> (to appear). </note>
Reference: [29] <author> I. Foster, C. Kesselman, S. Tuecke, </author> <title> The Nexus Task-parallel Runtime System, </title> <booktitle> In Proceedings of the 1st International Workshop on Parallel Processing, </booktitle> <year> 1994. </year>
Reference-contexts: One such project, Globus [31], provides support for a number of preexisting parallel computing interfaces (such as MPI) in a metacomputing environment with enhanced resource management tools, security features, and a wide-area-aware communication system, Nexus <ref> [29] </ref>. Similar collection and integration of separate services architectures are employed in a number other metacomputing systems such as the Berkeley NOW project [2], MOL [71], and ISoft [30]. An alternative approach to metacomputing employed by the Legion project [39, 40] is based on distributed active objects.
Reference: [30] <author> I. Foster, J. Geisler, W. Nickless, W. Smith, S. Tuecke, </author> <title> Software Infrastructure for the I-WAY High-Performance Distributed Computing Experiment, </title> <booktitle> in Proceedings of the 5th IEEE Symposium on High Performance Distributed Computing, </booktitle> <pages> pp. 562-570, </pages> <year> 1996. </year>
Reference-contexts: Similar collection and integration of separate services architectures are employed in a number other metacomputing systems such as the Berkeley NOW project [2], MOL [71], and ISoft <ref> [30] </ref>. An alternative approach to metacomputing employed by the Legion project [39, 40] is based on distributed active objects. In Legion, all system and application software components are active objects with logically disjoint address spaces [52].
Reference: [31] <author> I. Foster, C. Kesselman, Globus: </author> <title> A Metacomputing Infrastructure Toolkit, </title> <note> International Journal of Supercomputing Applications (to appear). </note>
Reference-contexts: MPI, PVM, and other first-generation metacomputing systems provide a relatively low-level programming and resource management interface, and thus have been employed most successfully in simple, smallscale environments. Recently, a number of projects have begun to examine the issues involved in larger-scale metacomputing. One such project, Globus <ref> [31] </ref>, provides support for a number of preexisting parallel computing interfaces (such as MPI) in a metacomputing environment with enhanced resource management tools, security features, and a wide-area-aware communication system, Nexus [29].
Reference: [32] <author> R.F. Freund and D. S. Cornwell, Superconcurrency: </author> <title> A Form of Distributed Heterogeneous Supercomputing, </title> <journal> Supercomputing Review, </journal> <volume> vol. 3, </volume> <pages> pp. 47-50, </pages> <month> October, </month> <year> 1990. </year>
Reference-contexts: Despite the added complexity and challenges involved in heterogeneous distributed computing, the promise of increased performance afforded by a larger hardware base, along with the ability to further improve performance by mapping subtasks of a computation to the most appropriate available hardware (called superconcurrency by Freund and Cornwell <ref> [32] </ref>) makes heterogeneous computing a promising area of research. 1.1.2 Process State Capture and Recovery Early experiences with metacomputing systems and applications have demonstrated the need for a process state capture and recovery mechanisma mechanism to automatically checkpoint the state of a running program in some stable form and then later <p> For example, in a metacomputing environment, tasks can be moved to the computing resources best suited for their needs during different phases of computation, an idea termed superconcurrency in Freund and Cornwell <ref> [32] </ref>. Furthermore, metacomputing promises to enable the use of unprecedented amounts of computational power for individual applications. The evolution of computing technology and economics over time results in heterogeneity among the available resources. Even within a single institution, the set of resources available to a user is almost always heterogeneous.
Reference: [33] <author> R.F. Freund and H.J. Siegel, </author> <title> Heterogeneous Procesessing, </title> <journal> IEEE Computer, </journal> <volume> vol. 26, no. 6, </volume> <pages> pp. 13-17, </pages> <month> June, </month> <year> 1993. </year>
Reference: [34] <author> A. Geist, A Beguelin, J. Dongarra, W. Jiang, R. Manchek, </author> <title> and V.S. Sunderam, PVM: Parallel Virtual Machine, </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: on performance. 1.1 Motivation 1.1.1 High Performance Heterogeneous Distributed Computing Recent developments in software systems and the growing availability of higher-performance computing and networking hardware have made commonplace the use of networks of workstations, personal computers, and supercomputers as virtual, distributed-memory parallel machines, or metasystems, for solving computationally demanding problems <ref> [1, 34, 38, 41] </ref>. The combination of heterogeneous architectures and operating system platforms within a high-performance distributed metasystem gives rise to a number of problems not present in homogenous distributed systems and parallel computers. <p> Furthermore, the mechanism should be adaptable to a variety of different heterogeneous environments (e.g., a PVM environment <ref> [34] </ref>, a Condor-like system [54], etc.). 9 1.4 Solution Overview The Process Introspection solution to the heterogeneous process state capture and recovery problem is based on the premise that programs can be modified to incorporate their own checkpoint and restart functionality. <p> Although numerous software systems that support some form of network heterogeneous computing have been documented and/or are available [88], the majority of use has thus far been based on a small set of popular, simple packages such as Parallel Virtual Machine (PVM) <ref> [81, 34] </ref>, and the Message Passing Interface (MPI) [41]. PVM provides the programmer with a library interface that supports an explicit message-passing, distributed memory MIMD programming model. Library routines are provided to create new tasks, marshal vectors of basic data types into buffers, and pass message buffers between tasks asynchronously. <p> A first obvious area for future work is integration into existing distributed systems. We plan to adapt the system for use in the Legion [52] wide-area, objectoriented distributed system, and are also investigating integration into a PVM <ref> [34] </ref> or MPI [41] system. Adaptability to various system environments is supported explicitly by our PIL API, which provides a medium for APrIL-transformed modules and hand-coded system-interface wrapper modules to interoperate.
Reference: [35] <author> J. Gosling and H. McGilton, </author> <title> The Java Language Environment: a White Paper, Sun Microsystems, </title> <address> Mountain View, CA, </address> <month> October, </month> <year> 1995. </year>
Reference-contexts: For example, the Sumatra [1] language supports the capture and recovery of Java threads in a heterogeneous environment. State capture and recovery in Sumatra is implemented by a set of modifications to the Java Virtual Machine <ref> [35] </ref> bytecode interpreter. A more flexible approach is supported by the Ara system [67, 68]. As opposed to Sumatra, which mandates used of the Java language, Ara supports mobile agents in an extensible set of interpreted languages, currently including interpreted C and 22 Tcl [65].
Reference: [36] <author> R. Gray, G. Cybenko, D. Kotz, and D. </author> <title> Rus, Agent TCL, </title> <editor> in Cockayne, W., Zypa, M., eds. </editor> <title> Itinerant Agents: Explanations and Examples with CDROM , Manning Publishing, </title> <year> 1997. </year>
Reference-contexts: To support state capture of a running agent, the interpreters used in the system must be able to capture their own full state (i.e. including the state of the program being interpreted). A primary drawback of these and other mobile agent systems such as TACOMA [44,45], Agent Tcl <ref> [36] </ref>, and Telescript [92] is the use of interpreted execution for agents. In our intended application domain, this model fails to meet the performance requirements of most users. One system that overcomes this limitation is Extended Facile [48], an agent programming system based on the Facile functional programming language.
Reference: [37] <author> A.S. Grimshaw, </author> <title> Easy-to-Use ObjectOriented Parallel Processing with Mentat, </title> <journal> IEEE Computer, </journal> <volume> vol. 26, no. 5, </volume> <pages> pp. 39-51, </pages> <year> 1993. </year>
Reference-contexts: For example, Linda [13] provides a shared tuple space into which tasks can read and write data in order to cooperate with one another. Mentat <ref> [37] </ref> supports a C++-based programming model in which the basic units of computation and scheduling are active objects that communicate via asynchronous methods. In Men-tat, arguments to methods are passed according to their data-dependence graph, thereby 14 minimizing communication.
Reference: [38] <author> A.S. Grimshaw, J.B.Weissman, E.A. West, and E. Loyot, </author> <title> Meta Systems: An Approach Combining Parallel Processing and Heterogeneous Distributed Computing Systems, </title> <journal> Journal of Parallel and Distributed Computing, pp. </journal> <volume> 257-270, vol. 21, no. 3, </volume> <month> June </month> <year> 1994. </year>
Reference-contexts: on performance. 1.1 Motivation 1.1.1 High Performance Heterogeneous Distributed Computing Recent developments in software systems and the growing availability of higher-performance computing and networking hardware have made commonplace the use of networks of workstations, personal computers, and supercomputers as virtual, distributed-memory parallel machines, or metasystems, for solving computationally demanding problems <ref> [1, 34, 38, 41] </ref>. The combination of heterogeneous architectures and operating system platforms within a high-performance distributed metasystem gives rise to a number of problems not present in homogenous distributed systems and parallel computers. <p> However, beyond these existing uses for process state capture and recovery, the availability of a such a mechanism in the metasystem context also opens up new possibilities. For example, a metasystem such as Legion <ref> [38] </ref> could use process state capture and recovery for improved resource management; if the number of active entities in the system became greater than could be efficiently supported, the system could temporarily preempt the execution of some jobs by checkpointing and terminating their processes, then later restarting them when the system <p> This technique, referred to variously as network heterogeneous computing [25], mixed-machine heterogeneous computing [74], or metacomputing <ref> [38, 75] </ref> is a promising area of research for a variety of reasons. For example, in a metacomputing environment, tasks can be moved to the computing resources best suited for their needs during different phases of computation, an idea termed superconcurrency in Freund and Cornwell [32].
Reference: [39] <author> A.S. Grimshaw, </author> <title> W.A. Wulf, and the Legion team, The Legion Vision of a Worldwide Virtual Computer, </title> <journal> Communications of the ACM, </journal> <volume> vol. 40, no. 1, </volume> <month> January, </month> <year> 1997. </year>
Reference-contexts: Similar collection and integration of separate services architectures are employed in a number other metacomputing systems such as the Berkeley NOW project [2], MOL [71], and ISoft [30]. An alternative approach to metacomputing employed by the Legion project <ref> [39, 40] </ref> is based on distributed active objects. In Legion, all system and application software components are active objects with logically disjoint address spaces [52]. These objects interact via non-blocking, data-driven method invocations, in a manner based on the underlying concepts of Mentat.
Reference: [40] <author> A.S. Grimshaw, A. Nguyen-Tuong, M.J. Lewis, and M. Hyett, </author> <title> Campus-Wide Comput 183 ing: Results Using a Legion Prototype at the University of Virginia, </title> <journal> International Journal of Supercomputing Applications, </journal> <note> (to appear). </note>
Reference-contexts: Similar collection and integration of separate services architectures are employed in a number other metacomputing systems such as the Berkeley NOW project [2], MOL [71], and ISoft [30]. An alternative approach to metacomputing employed by the Legion project <ref> [39, 40] </ref> is based on distributed active objects. In Legion, all system and application software components are active objects with logically disjoint address spaces [52]. These objects interact via non-blocking, data-driven method invocations, in a manner based on the underlying concepts of Mentat. <p> Their results showed that relatively small clusters of workstations could provide performance within an order of magnitude of a 1-node Cray Y-MP. The Legion group has reported 15 performance results obtained on a wider area, more significantly heterogeneous campus-wide testbed <ref> [40] </ref>. Using a biological sequencing application [66], they found that a 64 node heterogeneous network of workstations was able to perform as well as a 32-node Intel Paragon. These experiences are just two examples of the growing documented evidence of the excellent results achievable through metacomputing [60]. <p> This observation is importantthe need for fault tolerance in metasystems is significant and is growing with the scale of those systems. In, For example, the Legion group has reported observed fault rates as poor as one node failure per 17 hour on a 64-node campus-wide metasystem testbed <ref> [40] </ref>. 2.3 Process State Capture and Recovery Thus far, we have examined background work in metacomputing systems, and motivated the need for a process state capture mechanism in such environments. We now focus on directly related workdesigns and implementations of systems that support process state capture and recovery.
Reference: [41] <author> W. Gropp, E. Lusk, and A. Skjellum, </author> <title> Using MPI: Portable Parallel Programming with the Message-Passing Interface, </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: on performance. 1.1 Motivation 1.1.1 High Performance Heterogeneous Distributed Computing Recent developments in software systems and the growing availability of higher-performance computing and networking hardware have made commonplace the use of networks of workstations, personal computers, and supercomputers as virtual, distributed-memory parallel machines, or metasystems, for solving computationally demanding problems <ref> [1, 34, 38, 41] </ref>. The combination of heterogeneous architectures and operating system platforms within a high-performance distributed metasystem gives rise to a number of problems not present in homogenous distributed systems and parallel computers. <p> Although numerous software systems that support some form of network heterogeneous computing have been documented and/or are available [88], the majority of use has thus far been based on a small set of popular, simple packages such as Parallel Virtual Machine (PVM) [81, 34], and the Message Passing Interface (MPI) <ref> [41] </ref>. PVM provides the programmer with a library interface that supports an explicit message-passing, distributed memory MIMD programming model. Library routines are provided to create new tasks, marshal vectors of basic data types into buffers, and pass message buffers between tasks asynchronously. <p> A first obvious area for future work is integration into existing distributed systems. We plan to adapt the system for use in the Legion [52] wide-area, objectoriented distributed system, and are also investigating integration into a PVM [34] or MPI <ref> [41] </ref> system. Adaptability to various system environments is supported explicitly by our PIL API, which provides a medium for APrIL-transformed modules and hand-coded system-interface wrapper modules to interoperate.
Reference: [42] <author> M. Harchol-Balter and A.B. Downey, </author> <title> Exploiting Process Lifetime Distributions for Dynamic Load Balancing, </title> <type> Technical Report UCB/CSD-95-887, </type> <institution> University of California at Berkely, </institution> <month> November, </month> <year> 1995. </year>
Reference: [43] <author> D.R. Jefferson, </author> <title> Virtual Time, </title> <journal> ACM Transaction on Programming Languages and Systems, </journal> <volume> vol. 7, no. 3, pp.404-425, </volume> <month> July </month> <year> 1985. </year>
Reference-contexts: Beyond failure resilience, the ability to roll back a computation afforded by a process state capture and recovery mechanism can be used to implement the semantics of certain programming environments. For example, systems such as Time Warp <ref> [43] </ref> and Hope [19] rely on process state capture and recovery to provide semantic guarantees such as the causal ordering of message deliv 3 ery to a process.
Reference: [44] <editor> D. Johansen, N.P. Sudmann, and R. van Renesse, </editor> <booktitle> Performance issues in TACOMA, in Third Workshop on Mobile Object Systems, 11th Europeean Conference on ObjectOri-ented Programming, </booktitle> <address> Jyvaskyla, Finland, </address> <month> June 9-13, </month> <year> 1997. </year>
Reference: [45] <author> D. Johansen, R. van Renesse, and F. Schneider, </author> <title> An Introduction to the TACOMA Distributed System, </title> <note> Version 1.0, Computer Science Technical Report 95-23, </note> <institution> University of Troms, Troms, Norway, </institution> <month> June, </month> <year> 1995. </year>
Reference: [46] <author> B.W. Kernighan and D.M. Ritchie, </author> <title> The C Programming Language, Second Edition, </title> <publisher> Pren-tice Hall, </publisher> <year> 1988. </year>
Reference-contexts: In this chapter and in Chapter 6, we describe a full working implementation of a Process Introspection system. This chapter describes a library interface and implementation that supports the application of Process Introspection transformations to programs written the C programming language <ref> [46] </ref>. This runtime library can be employed by a programmer in order to apply the Process Introspection transformations by hand, or can serve as a target interface for a compiler that applies these transformations automatically. <p> We adopt the definition of expression statement as given by Kernighan and Ritchie in The C Programming Language <ref> [46] </ref> in the grammar for the C language presented in Appendix A. See the expressionstatement production. 81 In an expression statement containing a function call, the function call must be guar anteed to be evaluated before any other subexpressions with side-effects.
Reference: [47] <author> A.A. Khokhar, V.K. Prasanna, M.E. Shaaban, and C. Wang, </author> <title> Heterogeneous Computing: Challenges and Opportunities, </title> <journal> IEEE Computer, </journal> <volume> vol. 26, no. 6, </volume> <pages> pp. 18-27, </pages> <month> June, </month> <year> 1993. </year>
Reference: [48] <author> F.C. Knabe, </author> <title> Language Support for Mobile Agents, </title> <type> PhD Thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <note> available as Technical Report CMU-CS-95-223, </note> <month> December, </month> <year> 1995. </year>
Reference-contexts: In our intended application domain, this model fails to meet the performance requirements of most users. One system that overcomes this limitation is Extended Facile <ref> [48] </ref>, an agent programming system based on the Facile functional programming language. In Extended Facile, agents are first-class functions that may be transferred to remote nodes for execution.
Reference: [49] <author> P. Krueger and M. Livny, </author> <title> A Comparison of Preemptive and Non-Preemptive Load Distributing, </title> <booktitle> in Proceedings of the 8th International Conference on Distributed Computing Systems, </booktitle> <pages> pp. 123-130, </pages> <month> June, </month> <year> 1988. </year>
Reference: [50] <author> J. Leon, A.L. Fisher and P. Steenkiste, </author> <title> Failsafe PVM: A Portable Package for Distributed Programming with Transparent Recovery, </title> <type> Technical Report CMU-CS-93-124, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA 15213, </address> <month> February </month> <year> 1993. </year>
Reference-contexts: For example, systems such as Failsafe PVM <ref> [50] </ref> rely on this ability. <p> For example, some user-level approaches such as Condor and Mandelberg/Sunderam [57] restrict certain forms of intra-process communication mechanisms. However, this argument against user-level state capture mechanisms is largely unfounded, as demonstrated systems such as MIST/MPVM [15, 16], Failsafe PVM <ref> [50] </ref>, and Hector [72]. These systems provide a location-independent communication layer that renders process migrations transparent to message passing operations performed at the application level.
Reference: [51] <author> M.J. Lewis and R.E. Cline, </author> <title> PVM Communication Performance in a Switched FDDI Heterogeneous Distributed Computing Environment, </title> <booktitle> in Proceedings of the IEEE Workshop on Advances in Parallel and Distributed Systems, </booktitle> <address> Princeton, N.J., </address> <month> October, </month> <year> 1993. </year>
Reference-contexts: Although metasystems software is not yet mature, early results on heterogeneous network computing testbeds have been promising. For example, a detailed performance study of the NAS benchmark suite [5] using PVM on the HEAT testbed <ref> [51] </ref> was presented by White, Alund, and Sunderam [93]. Their results showed that relatively small clusters of workstations could provide performance within an order of magnitude of a 1-node Cray Y-MP. The Legion group has reported 15 performance results obtained on a wider area, more significantly heterogeneous campus-wide testbed [40].
Reference: [52] <author> M.J. Lewis and A.S. Grimshaw, </author> <title> The Core Legion Object Model, </title> <booktitle> in Proceedings of 184 IEEE High Performance Distributed Computing 5, </booktitle> <pages> pp. 551-561, </pages> <address> Syracuse, NY, </address> <month> August 6-9, </month> <year> 1996. </year>
Reference-contexts: An alternative approach to metacomputing employed by the Legion project [39, 40] is based on distributed active objects. In Legion, all system and application software components are active objects with logically disjoint address spaces <ref> [52] </ref>. These objects interact via non-blocking, data-driven method invocations, in a manner based on the underlying concepts of Mentat. A primary advantage of the Legion object-based approach is the flexibility to modify or replace both system and application components using a single underlying object model, programming interface, and tool set. <p> A first obvious area for future work is integration into existing distributed systems. We plan to adapt the system for use in the Legion <ref> [52] </ref> wide-area, objectoriented distributed system, and are also investigating integration into a PVM [34] or MPI [41] system. Adaptability to various system environments is supported explicitly by our PIL API, which provides a medium for APrIL-transformed modules and hand-coded system-interface wrapper modules to interoperate.
Reference: [53] <author> C.C. Li and W.K. Fuchs, </author> <title> CATCH: Compiler-assisted Techniques for Checkpointing, </title> <booktitle> in Proceedings of the 20th International Symposium on Fault Tolerant Computing , pp. </booktitle> <pages> 74-81, </pages> <year> 1990. </year>
Reference: [54] <author> M.J. Litzkow, M. Livny, and M.W. </author> <title> Mutka, CondorA Hunter of Idle Workstations, </title> <booktitle> in Proceedings of the Eighth International Conference on Distributed Computing Systems , pp. </booktitle> <pages> 104-111, </pages> <year> 1988. </year>
Reference-contexts: A substantial body of research has already demonstrated the utility and desirability of such a mechanism in homogeneous environments. For example, process migration policies supporting load sharing and/or fault tolerance can be based on a process state capture facility (e.g. Condor <ref> [54] </ref>). Process state capture and recovery is also the basis of a large class of backward error recovery schemes documented in the fault tolerance literature [24]. <p> Furthermore, the mechanism should be adaptable to a variety of different heterogeneous environments (e.g., a PVM environment [34], a Condor-like system <ref> [54] </ref>, etc.). 9 1.4 Solution Overview The Process Introspection solution to the heterogeneous process state capture and recovery problem is based on the premise that programs can be modified to incorporate their own checkpoint and restart functionality. Put simply, programs are modified to be both self-describing and self-recovering. <p> is, a high amount of computation performed for each byte of information communicated between tasks [93]. 2.2 The Need for Process State Capture and Recovery Whereas the ability to capture and restore the state of a process has been available for some time in a variety of homogeneous distributed systems <ref> [4, 20, 54, 64, 70, 86] </ref>, this feature has been absent in most metacomputing environments. <p> Systems such as NOW [1] and Condor <ref> [54] </ref> rely on the ability to capture the state of a process on one node and resume that pro 16 cess on a different node to achieve more equitable distributions of work among the nodes in a metasystem. <p> These issues, along with the requirement of support for heterogeneity, strongly suggest the use of user-level state capture mechanisms. 2.3.1.2 User Level Mechanisms A number of systems to date have provided some form of homogeneous process state capture implemented at the user level (i.e. without direct, special kernel support) <ref> [14, 55, 54, 69] </ref>. For example, Condor [55] performs process state capture and recovery in homogeneous environments by using a slightly modified core dump of the process to capture and recover memory and processor state. <p> Using wrapper routines to capture a processs external state is a technique that has been demonstrated to be effective in projects such as Condor <ref> [54] </ref> and other such loadsharing tools used in homogeneous systems. 37 Chapter 4 Correctness Discussion The Process Introspection mechanism modifies programs to allow them to checkpoint and restart at certain well defined poll points during execution.
Reference: [55] <author> M.J. Litzkow and M. Solomon, </author> <title> Supporting Checkpointing and Process Migration Outside the UNIX Kernel, </title> <booktitle> in Proceedings of USENIX, </booktitle> <pages> pp. 283-290, </pages> <month> January, </month> <year> 1992. </year>
Reference-contexts: These issues, along with the requirement of support for heterogeneity, strongly suggest the use of user-level state capture mechanisms. 2.3.1.2 User Level Mechanisms A number of systems to date have provided some form of homogeneous process state capture implemented at the user level (i.e. without direct, special kernel support) <ref> [14, 55, 54, 69] </ref>. For example, Condor [55] performs process state capture and recovery in homogeneous environments by using a slightly modified core dump of the process to capture and recover memory and processor state. <p> For example, Condor <ref> [55] </ref> performs process state capture and recovery in homogeneous environments by using a slightly modified core dump of the process to capture and recover memory and processor state.
Reference: [56] <author> G. Maguire and J. Smith, </author> <title> Process Migrations: Effects on Scientific Computation, </title> <journal> ACM SIGPLAN, </journal> <volume> vol. 23, no. 2, </volume> <pages> pp. 102-106, </pages> <month> March, </month> <year> 1988. </year>
Reference: [57] <author> K. Mandelberg and V.S. Sunderam, </author> <title> Process Migration in Unix Networks, </title> <booktitle> in Proceedings of the USENIX Winter Conference, </booktitle> <pages> pp. 357-363, </pages> <year> 1988. </year>
Reference-contexts: Condor and libchckpt [69] are highly portable among Unix-based platform). A common argument against user-level state capture schemes is the difficulty involved in capturing and recovering a processs external and kernel-level state. For example, some user-level approaches such as Condor and Mandelberg/Sunderam <ref> [57] </ref> restrict certain forms of intra-process communication mechanisms. However, this argument against user-level state capture mechanisms is largely unfounded, as demonstrated systems such as MIST/MPVM [15, 16], Failsafe PVM [50], and Hector [72].
Reference: [58] <author> F. Mattern, </author> <title> Virtual Time and Global States of Distributed Systems, </title> <booktitle> in Proceedings of the Workshop on Parallel and Distributed Algorithms , Chateeau de Bonas, France, </booktitle> <pages> pp. 215-226, </pages> <month> October, </month> <year> 1988. </year>
Reference: [59] <author> F. Mattern, </author> <title> Efficient Algorithms for Distributed Snapshots and Global Virtual Time Approximation, </title> <journal> Journal of Parallel and Distributed Computing , vol. </journal> <volume> 18, </volume> <pages> pp. 423-434, </pages> <year> 1993. </year>
Reference-contexts: For example, systems such as Failsafe PVM [50] rely on this ability. The use of process checkpointing for rollback-recovery protocols typically relies on the ability either to synchronize the checkpoints of cooperating tasks (for example, using the checkpoint coordination algorithms of Chandy and Lamport [18] or Mattern <ref> [59] </ref>), or to propagate the rollback of related tasks to reach a consistent state [89].
Reference: [60] <author> C.R. Mechoso, J.D. Farrara, and J.A. Spahr, </author> <title> Running a Climate Model in a Heterogeneous Distributed Computer Environment, </title> <booktitle> in Proceedings of the 3rd IEEE Symposium on High Performance Distributed Computing, </booktitle> <pages> pp. 79-84, </pages> <month> April, </month> <year> 1994. </year>
Reference-contexts: Using a biological sequencing application [66], they found that a 64 node heterogeneous network of workstations was able to perform as well as a 32-node Intel Paragon. These experiences are just two examples of the growing documented evidence of the excellent results achievable through metacomputing <ref> [60] </ref>. Applications experiences have lead metacomputing practitioners to a number of general observations about heterogeneous computing.
Reference: [61] <author> Message Passing Interface Forum, </author> <title> MPI-2: Extensions to the Message Passing Interface, </title> <month> July 18, </month> <year> 1997. </year>
Reference-contexts: Similar to PVM, the Message Passing Interface supports an explicit message passing, MIMD programming model through a library interface. In its most recent version (MPI-2 <ref> [61] </ref>), MPI adds to the PVM level of functionality features such as a uniform parallel I/O interface, collective communication operations (library calls that specify communication patterns between more than two tasks, e.g. all-to-all), and one sided communication (or remote memory access, the ability of one task to asynchronously read or write
Reference: [62] <author> D.S. Milojicic, F. Douglis, Y. Paindaveine, R. Wheeler, and S. Zhou, </author> <title> Process Migration, </title> <type> TOG RI Technical Report, </type> <year> 1996. </year>
Reference-contexts: it is worth examining the existing mechanisms designed for use in homogeneous environments. 2.3.1 Homogeneous Systems 2.3.1.1 Kernel Level Mechanisms Process state capture mechanisms to support activities such as process migration and checkpoint/restart have been the subject of a great deal of research, both in terms of mechanisms and policies <ref> [62, 64, 76] </ref>. Most homogeneous state capture mechanisms are implemented inside operating systems at the kernel level due to efficiency concerns and because a processs external state is more readily available at that level.
Reference: [63] <author> R. Mirchandaney, D. Towsley, and J.A. Stankovic, </author> <title> Adaptive Load Sharing in Heterogeneous Distributed Systems, </title> <journal> Journal of Parallel and Distributed Computing , vol. </journal> <volume> 9, </volume> <pages> pp. 331-346, </pages> <year> 1990. </year>
Reference-contexts: to a lack of need for such a mechanism. 2.2.1 Load Balancing and Load Sharing It has long been recognized that adaptive load sharing as enabled by a process state capture and recovery mechanism is an effective means of increasing performance (e.g. throughput, response time, etc.) in a distributed system <ref> [22, 63, 73] </ref>. Systems such as NOW [1] and Condor [54] rely on the ability to capture the state of a process on one node and resume that pro 16 cess on a different node to achieve more equitable distributions of work among the nodes in a metasystem.
Reference: [64] <author> M. Nuttall, </author> <title> Survey of Systems Providing Process or Object Migration, </title> <institution> Imperial College Research Report DoC 94/10, </institution> <month> May, </month> <year> 1994. </year>
Reference-contexts: is, a high amount of computation performed for each byte of information communicated between tasks [93]. 2.2 The Need for Process State Capture and Recovery Whereas the ability to capture and restore the state of a process has been available for some time in a variety of homogeneous distributed systems <ref> [4, 20, 54, 64, 70, 86] </ref>, this feature has been absent in most metacomputing environments. <p> it is worth examining the existing mechanisms designed for use in homogeneous environments. 2.3.1 Homogeneous Systems 2.3.1.1 Kernel Level Mechanisms Process state capture mechanisms to support activities such as process migration and checkpoint/restart have been the subject of a great deal of research, both in terms of mechanisms and policies <ref> [62, 64, 76] </ref>. Most homogeneous state capture mechanisms are implemented inside operating systems at the kernel level due to efficiency concerns and because a processs external state is more readily available at that level.
Reference: [65] <author> J.K. Ousterhout, </author> <title> Tcl and the Tk Toolkit, </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year> <month> 185 </month>
Reference-contexts: A more flexible approach is supported by the Ara system [67, 68]. As opposed to Sumatra, which mandates used of the Java language, Ara supports mobile agents in an extensible set of interpreted languages, currently including interpreted C and 22 Tcl <ref> [65] </ref>. To support state capture of a running agent, the interpreters used in the system must be able to capture their own full state (i.e. including the state of the program being interpreted).
Reference: [66] <author> W.R. Pearson and D. Lipman, </author> <title> Improved Tools for Biological Sequence Analysis, </title> <booktitle> Proc. National Acadamy of Science USA, </booktitle> <volume> vol. 85, </volume> <pages> pp. 2444-2448, </pages> <year> 1988. </year>
Reference-contexts: Their results showed that relatively small clusters of workstations could provide performance within an order of magnitude of a 1-node Cray Y-MP. The Legion group has reported 15 performance results obtained on a wider area, more significantly heterogeneous campus-wide testbed [40]. Using a biological sequencing application <ref> [66] </ref>, they found that a 64 node heterogeneous network of workstations was able to perform as well as a 32-node Intel Paragon. These experiences are just two examples of the growing documented evidence of the excellent results achievable through metacomputing [60]. <p> For each comparison a score is generated. When the full library comparison is complete, the results are presented in nonincreasing order. For this performance study, we examined two sequence comparison programs: sw (smith-waterman [78], and fa (fasta) <ref> [66] </ref>. The sw version of the program performs a rigorous, quadratic linear programing algorithm. The fa version employs a heuristic that maintains a lookup table containing regions of high densities of identity resulting in execution speeds between 20 and 100 times as fast as the rigorous sw version.
Reference: [67] <author> H. Peine, </author> <title> An introduction to mobile agent programming and the Ara system, </title> <type> ZRI-Report 1/97, </type> <institution> Department of Computer Science, University of Kaiserslautern, Germany, </institution> <year> 1997. </year>
Reference-contexts: For example, the Sumatra [1] language supports the capture and recovery of Java threads in a heterogeneous environment. State capture and recovery in Sumatra is implemented by a set of modifications to the Java Virtual Machine [35] bytecode interpreter. A more flexible approach is supported by the Ara system <ref> [67, 68] </ref>. As opposed to Sumatra, which mandates used of the Java language, Ara supports mobile agents in an extensible set of interpreted languages, currently including interpreted C and 22 Tcl [65].
Reference: [68] <author> H. Peine and T. Stolpmann, </author> <title> The Architecture of the Ara Platform for Mobile Agents, </title> <editor> in Rothermel, K., Popescu-Zeletin, R., eds. </editor> <booktitle> Proceedings of the First International Workshop on Mobile Agents: </booktitle> <address> MA97, Berlin, Germany, </address> <month> April 7-8, </month> <year> 1997. </year> <booktitle> Lecture Notes in Computer Science no. </booktitle> <volume> 1219, </volume> <publisher> Springer Verlag, </publisher> <year> 1997. </year>
Reference-contexts: For example, the Sumatra [1] language supports the capture and recovery of Java threads in a heterogeneous environment. State capture and recovery in Sumatra is implemented by a set of modifications to the Java Virtual Machine [35] bytecode interpreter. A more flexible approach is supported by the Ara system <ref> [67, 68] </ref>. As opposed to Sumatra, which mandates used of the Java language, Ara supports mobile agents in an extensible set of interpreted languages, currently including interpreted C and 22 Tcl [65].
Reference: [69] <author> J.S. Plank, M. Beck, G. Kingsley, and K. Li, Libckpt: </author> <title> Transparent Checkpointing under Unix, </title> <booktitle> in Proceedings of USENIX Winter 1995 Technical Conference , New Orleans, </booktitle> <address> LA, </address> <month> January 16-20, </month> <year> 1995. </year>
Reference-contexts: Alternatively, for the purposes of checkpointing, incremental schemes for saving a processs memory, such as periodically capturing only dirty pages, may improve time/space performance <ref> [69] </ref>. Beyond the obvious issue of heterogeneity, kernel-level state capture schemes have a number of undesirable features in metasystem contexts. First, as the number of different architecture and operating system platforms grows, the issue of mechanism portability becomes important in addition to efficiency concerns. <p> These issues, along with the requirement of support for heterogeneity, strongly suggest the use of user-level state capture mechanisms. 2.3.1.2 User Level Mechanisms A number of systems to date have provided some form of homogeneous process state capture implemented at the user level (i.e. without direct, special kernel support) <ref> [14, 55, 54, 69] </ref>. For example, Condor [55] performs process state capture and recovery in homogeneous environments by using a slightly modified core dump of the process to capture and recover memory and processor state. <p> Needed operating system specific information associated with the process is maintained at the user level by tracking the parameters and return values of all system calls via wrapper routines. An alternative approach described by Plank et. al. <ref> [69] </ref> links programs with a special library 19 that contains code to capture a processs internal state. In this design, processor state is captured using the Unix setjmp system call. Although these approaches are typically somewhat less efficient than kernel level implementations, userspace designs are generally more portable (e.g. <p> In this design, processor state is captured using the Unix setjmp system call. Although these approaches are typically somewhat less efficient than kernel level implementations, userspace designs are generally more portable (e.g. Condor and libchckpt <ref> [69] </ref> are highly portable among Unix-based platform). A common argument against user-level state capture schemes is the difficulty involved in capturing and recovering a processs external and kernel-level state. For example, some user-level approaches such as Condor and Mandelberg/Sunderam [57] restrict certain forms of intra-process communication mechanisms.
Reference: [70] <author> M.L. Powell and B.P. Miller, </author> <title> Process Migration in DEMOS/MP, </title> <booktitle> in Proceedings of the Ninth Symposium on Operating Systems Principles in ACM Operating Systems Review , vol. </booktitle> <volume> 17, no. 5, </volume> <pages> pp. 110-118, </pages> <year> 1983. </year>
Reference-contexts: is, a high amount of computation performed for each byte of information communicated between tasks [93]. 2.2 The Need for Process State Capture and Recovery Whereas the ability to capture and restore the state of a process has been available for some time in a variety of homogeneous distributed systems <ref> [4, 20, 54, 64, 70, 86] </ref>, this feature has been absent in most metacomputing environments. <p> Most homogeneous state capture mechanisms are implemented inside operating systems at the kernel level due to efficiency concerns and because a processs external state is more readily available at that level. For example, systems such as Charlotte [4], Sprite [20], DEMOS/MP <ref> [70] </ref>, and the V-System [86] utilize kernel-level state capture and recovery mechanisms to support process migration. Although these and other kernel-level homogeneous state capture mechanisms differ in certain performance-related respects, they share a common basic approach to capturing the state of a process.
Reference: [71] <author> A. Reinefeld, R. Baraglia, T. Decker, J. Gehring, D. Laforenza, F. Ramme, T. Rvmke, and J. Simon, </author> <title> The MOL Project: An Open Extensible Metacomputer, </title> <booktitle> in Proceedings of the Heterogenous Computing Workshop, </booktitle> <publisher> HCW97 , IEEE Computer Society Press, </publisher> <pages> pp. 17-31, </pages> <year> 1997. </year>
Reference-contexts: Similar collection and integration of separate services architectures are employed in a number other metacomputing systems such as the Berkeley NOW project [2], MOL <ref> [71] </ref>, and ISoft [30]. An alternative approach to metacomputing employed by the Legion project [39, 40] is based on distributed active objects. In Legion, all system and application software components are active objects with logically disjoint address spaces [52].
Reference: [72] <author> J. Robinson, S.H. Russ, B. Flachs, and B. Heckel, </author> <title> A Task Migration Implementation for the Message Passing Interface, </title> <booktitle> in Proceedings of the Fifth IEEE International Symposium on High Performance Distributed Systems, </booktitle> <address> Syracuse, NY, </address> <month> August, </month> <year> 1995. </year>
Reference-contexts: For example, some user-level approaches such as Condor and Mandelberg/Sunderam [57] restrict certain forms of intra-process communication mechanisms. However, this argument against user-level state capture mechanisms is largely unfounded, as demonstrated systems such as MIST/MPVM [15, 16], Failsafe PVM [50], and Hector <ref> [72] </ref>. These systems provide a location-independent communication layer that renders process migrations transparent to message passing operations performed at the application level.
Reference: [73] <author> N.G. Shivaratri, P. Krueger, and M. Singhal, </author> <title> Load Distributing for Locally Distributed Systems, </title> <journal> IEEE Computer, </journal> <volume> vol. 25, no. 12, </volume> <pages> pp. 33-44, </pages> <month> December, </month> <year> 1992. </year>
Reference-contexts: to a lack of need for such a mechanism. 2.2.1 Load Balancing and Load Sharing It has long been recognized that adaptive load sharing as enabled by a process state capture and recovery mechanism is an effective means of increasing performance (e.g. throughput, response time, etc.) in a distributed system <ref> [22, 63, 73] </ref>. Systems such as NOW [1] and Condor [54] rely on the ability to capture the state of a process on one node and resume that pro 16 cess on a different node to achieve more equitable distributions of work among the nodes in a metasystem.
Reference: [74] <author> H.J. Siegel, H.G. Dietz, and J.K. Antonio, </author> <title> Software Support for Heterogeneous Computing, in A.B. </title> <editor> Tucker, ed., </editor> <booktitle> The Computer Science and Engineering Handbook, </booktitle> <publisher> CRC Press, </publisher> <pages> pp. 1886-1913, </pages> <year> 1997. </year>
Reference-contexts: The increasing importance of existing uses of process state capture and recovery, together with the new possibilities introduced by metasystems, has made the design of a such a mechanism a key research issue in metacomputing <ref> [74] </ref>. <p> This technique, referred to variously as network heterogeneous computing [25], mixed-machine heterogeneous computing <ref> [74] </ref>, or metacomputing [38, 75] is a promising area of research for a variety of reasons. For example, in a metacomputing environment, tasks can be moved to the computing resources best suited for their needs during different phases of computation, an idea termed superconcurrency in Freund and Cornwell [32].
Reference: [75] <author> L. Smarr and C.E. Catlett, </author> <title> Metacomputing, </title> <journal> Communications of the ACM, </journal> <volume> vol. 35, no. 6, </volume> <pages> pp. 45-52, </pages> <year> 1992. </year>
Reference-contexts: This technique, referred to variously as network heterogeneous computing [25], mixed-machine heterogeneous computing [74], or metacomputing <ref> [38, 75] </ref> is a promising area of research for a variety of reasons. For example, in a metacomputing environment, tasks can be moved to the computing resources best suited for their needs during different phases of computation, an idea termed superconcurrency in Freund and Cornwell [32].
Reference: [76] <author> J.M. Smith, </author> <title> A Survey of Process Migration Mechanisms, </title> <journal> Operating Systems Review , vol. </journal> <volume> 22, no. 3, </volume> <pages> pp. 28-40, </pages> <month> July, </month> <year> 1988. </year>
Reference-contexts: it is worth examining the existing mechanisms designed for use in homogeneous environments. 2.3.1 Homogeneous Systems 2.3.1.1 Kernel Level Mechanisms Process state capture mechanisms to support activities such as process migration and checkpoint/restart have been the subject of a great deal of research, both in terms of mechanisms and policies <ref> [62, 64, 76] </ref>. Most homogeneous state capture mechanisms are implemented inside operating systems at the kernel level due to efficiency concerns and because a processs external state is more readily available at that level.
Reference: [77] <author> P. Smith and N.C. Hutchinson, </author> <title> Heterogeneous Process Migration: The Tui System, </title> <type> Technical Report, </type> <institution> University of British Columbia, </institution> <month> February 28, </month> <year> 1996. </year> <month> 186 </month>
Reference-contexts: Our current implementation requires only that the system interface be accessible from C code, and that it be possible to construct a wrapper interface for system services that maintain external state for processes. A similar approach to that of heterogeneous Emerald, called Tui <ref> [77] </ref>, has been proposed by Smith and Hutchinson. This approach also involves the use of compiler-generated state mapping information in the form of the symbol table typically used by symbolic debuggers.
Reference: [78] <author> T.F. Smith and M.S. Waterman, </author> <title> Identification of Common Molecular Subsequences, </title> <journal> Journal of Molecular Biology, </journal> <volume> vol. 147, </volume> <pages> pp. 195-197, </pages> <year> 1981. </year>
Reference-contexts: For each comparison a score is generated. When the full library comparison is complete, the results are presented in nonincreasing order. For this performance study, we examined two sequence comparison programs: sw (smith-waterman <ref> [78] </ref>, and fa (fasta) [66]. The sw version of the program performs a rigorous, quadratic linear programing algorithm.
Reference: [79] <author> Sun Microsystems, </author> <title> External Data Representation Reference Manual , Sun Microsystems, </title> <month> January, </month> <year> 1985. </year>
Reference-contexts: Sun XDR <ref> [79] </ref>). Of course, this claim is far from obvious, especially given that low-level implementations of the program may be optimized arbitrarily (with the constraint that they preserve the meaning of the program). <p> This O (n 2 ) requirement (where n is the number of different data formats) may initially appear unnecessarily costly; why not instead use a single universal data format for checkpoints (such as Sun XDR <ref> [79] </ref>), and require conversion routines only between native formats and the universal format (reducing the complexity to O (n) conversion routines for n formats)? In fact, the receiver-makes-right protocol makes sense in light of the very small number of data formats actually in use by current computer systems.
Reference: [80] <author> Sun Microsystems, </author> <title> Java Object Serialization Specification, Revision 0.9, </title> <year> 1996. </year>
Reference: [81] <author> V.S. Sunderam, </author> <title> PVM: A framework for parallel distributed computing, </title> <journal> Concurrency: Practice and Experience, </journal> <volume> vol. 2, no. 4, </volume> <pages> pp. 315-339, </pages> <month> December, </month> <year> 1990. </year>
Reference-contexts: Although numerous software systems that support some form of network heterogeneous computing have been documented and/or are available [88], the majority of use has thus far been based on a small set of popular, simple packages such as Parallel Virtual Machine (PVM) <ref> [81, 34] </ref>, and the Message Passing Interface (MPI) [41]. PVM provides the programmer with a library interface that supports an explicit message-passing, distributed memory MIMD programming model. Library routines are provided to create new tasks, marshal vectors of basic data types into buffers, and pass message buffers between tasks asynchronously.
Reference: [82] <author> B. Steensgaard and E. </author> <month> Jul, </month> <title> Object and Native Code Thread Mobility Among Heterogeneous Computers, </title> <booktitle> in Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <month> December, </month> <year> 1995. </year>
Reference-contexts: Poll points are introduced points in execution at which the process determines if a checkpoint should be produced (analogous to Bus Stops in Heterogeneous Emerald <ref> [82] </ref>). At a poll point, if 10 the process determines that a checkpoint should be produced, code is executed to save the state of the current active subroutine and to return immediately to the calling subroutine. <p> Our approach extends this desirable feature of autonomy to include state capture as well as state restore. A more recent and fully implemented approach to the heterogeneous state capture problem was presented by Steensgaard and Jul <ref> [82] </ref>, who developed an extension of the thread and object-mobility capability of the heterogeneous Emerald distributed system to allow native code migration among heterogeneous hosts (previous implementations supported native code mobility for homogeneous hosts, plus heterogeneous mobility for interpreted byte-code programs).
Reference: [83] <author> G. Stellner, </author> <title> Consistent Checkpoints of PVM Applications, </title> <booktitle> in Proceedings of the First European PVM Users Group Meeting, </booktitle> <year> 1994. </year>
Reference: [84] <author> G. Stellner, </author> <title> CoCheck: Checkpointing and Process Migration for MPI, </title> <type> Technical Report, </type> <institution> Institut fr Informatik der Technischen Universitt Mnchen, </institution> <year> 1996. </year>
Reference-contexts: For example, the MIST [18] system provides system support for checkpointing sets of processes communicating via the PVM interface, and the CoCheck system <ref> [84] </ref> provides similar functionality for MPI programs. These systems provide the ability to capture network state external to individual processes, allowing the process state capture mechanism to focus on internal state. Case 2, Wrapper Modules In some environments, system support is neither available nor convenient to implement.
Reference: [85] <author> V. Strumpen and B. Ramkumar, </author> <title> Portable Checkpointing and Recovery in Heterogeneous Environments, </title> <type> Technical Report, </type> <institution> Department of Electrical and Computer Engineering, University of Iowa, </institution> <year> 1996. </year>
Reference: [86] <author> M.M. Theimer, K.A. Lantz, and D.R. Cheriton, </author> <title> Preemptable Remote Execution Facilities for the V-System, </title> <booktitle> in Proceedings of the Tenth ACM Symposium on Operating System Principles, </booktitle> <month> December </month> <year> 1985. </year>
Reference-contexts: is, a high amount of computation performed for each byte of information communicated between tasks [93]. 2.2 The Need for Process State Capture and Recovery Whereas the ability to capture and restore the state of a process has been available for some time in a variety of homogeneous distributed systems <ref> [4, 20, 54, 64, 70, 86] </ref>, this feature has been absent in most metacomputing environments. <p> Most homogeneous state capture mechanisms are implemented inside operating systems at the kernel level due to efficiency concerns and because a processs external state is more readily available at that level. For example, systems such as Charlotte [4], Sprite [20], DEMOS/MP [70], and the V-System <ref> [86] </ref> utilize kernel-level state capture and recovery mechanisms to support process migration. Although these and other kernel-level homogeneous state capture mechanisms differ in certain performance-related respects, they share a common basic approach to capturing the state of a process.
Reference: [87] <author> M.M. Theimer, and B. Hayes, </author> <title> Heterogeneous Process Migration by Recompilation, </title> <booktitle> in Proceedings of the 11th International. Conference on Distributed Computing Systems , Arlington, TX, </booktitle> <pages> pp. 18-25, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: In truly heterogeneous systems, this restriction could not be observed in general, and thus mobility between some nodes would be impossible. A novel approach to the heterogeneous state capture/restore problem was proposed by The-imer and Hayes <ref> [87] </ref>. In their proposed solution, the state of a process is examined and captured using compiler-generated symbol mapping information.
Reference: [88] <author> L.H. Turcotte, </author> <title> A Survey of Software Environments for Exploiting Networked Computing Resources, </title> <type> Technical Report, </type> <institution> Engineering Research Center for Computational Field Simulation, Mississippi State, MS, </institution> <month> June, </month> <year> 1993. </year>
Reference-contexts: The key distinguishing feature of a metacomputing environment is software. Metacomputing software is responsible for providing a unified programming and resource management interface to a complex heterogeneous collection of hardware resources. Although numerous software systems that support some form of network heterogeneous computing have been documented and/or are available <ref> [88] </ref>, the majority of use has thus far been based on a small set of popular, simple packages such as Parallel Virtual Machine (PVM) [81, 34], and the Message Passing Interface (MPI) [41]. <p> Whereas MPI, PVM, and the large class of systems that is essentially isomorphic to these <ref> [88] </ref> provide essentially identical message-passing based programming models, a few network heterogeneous systems have supported alternative, higher-level models. For example, Linda [13] provides a shared tuple space into which tasks can read and write data in order to cooperate with one another.
Reference: [89] <author> S. Venkatesan and T. Juang, </author> <title> Efficient Algorithms for Optimistic Crash Recovery, </title> <journal> Distributed Computing, </journal> <volume> vol. 8, no. 2, </volume> <pages> pp. 105-114, </pages> <year> 1994. </year>
Reference-contexts: The use of process checkpointing for rollback-recovery protocols typically relies on the ability either to synchronize the checkpoints of cooperating tasks (for example, using the checkpoint coordination algorithms of Chandy and Lamport [18] or Mattern [59]), or to propagate the rollback of related tasks to reach a consistent state <ref> [89] </ref>. However, the development of such coordination and propagation schemes is orthogonal to the heterogeneity of the computing nodes involved, and thus we can concentrate on the issue of process state capture and recovery confident that existing higher-level application checkpoint/restart techniques will remain applicable in heterogeneous environments.
Reference: [90] <author> D.G. von Bank, C.M. Shub, and R.W. Sebesta, </author> <title> A Unified Model of Pointwise Equivalence of Procedural Computations, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 16, no. 6, </volume> <pages> pp. 1842-1874, </pages> <month> November, </month> <year> 1994. </year>
Reference-contexts: Perhaps the most general coverage of this topic is presented by von Bank, Shub, and Sebesta <ref> [90] </ref>, who developed the idea that a procedural computation can be modeled as progression through a sequence of compatible well-defined states: points in execution at which the state of a process can be used to fully describe the equivalent state of any other implementation of the process.
Reference: [91] <author> Y. Wang and R.J.T. Morris, </author> <title> Load Sharing in Distributed Systems, </title> <journal> IEEE Transactions on Computers, </journal> <volume> vol. C-94, no. 3, </volume> <pages> pp. 204-217, </pages> <month> March, </month> <year> 1985. </year> <month> 187 </month>
Reference: [92] <author> J. White, </author> <title> Mobile Agents White Paper, General Magic, </title> <address> http://www.genmagic.com/ agents/Whitepaper/whitepaper.html, </address> <year> 1996. </year>
Reference-contexts: A primary drawback of these and other mobile agent systems such as TACOMA [44,45], Agent Tcl [36], and Telescript <ref> [92] </ref> is the use of interpreted execution for agents. In our intended application domain, this model fails to meet the performance requirements of most users. One system that overcomes this limitation is Extended Facile [48], an agent programming system based on the Facile functional programming language.
Reference: [93] <author> S. White, A. lund, </author> <title> and V.S. Sunderam, Performance of the NAS Parallel Benchmarks on PVM Based Networks, </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> vol. 26, no. 1, </volume> <pages> pp. 61-71, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Although metasystems software is not yet mature, early results on heterogeneous network computing testbeds have been promising. For example, a detailed performance study of the NAS benchmark suite [5] using PVM on the HEAT testbed [51] was presented by White, Alund, and Sunderam <ref> [93] </ref>. Their results showed that relatively small clusters of workstations could provide performance within an order of magnitude of a 1-node Cray Y-MP. The Legion group has reported 15 performance results obtained on a wider area, more significantly heterogeneous campus-wide testbed [40]. <p> Secondly, effective parallel programs in a heterogeneous environment will almost always exhibit coarse granularity, that is, a high amount of computation performed for each byte of information communicated between tasks <ref> [93] </ref>. 2.2 The Need for Process State Capture and Recovery Whereas the ability to capture and restore the state of a process has been available for some time in a variety of homogeneous distributed systems [4, 20, 54, 64, 70, 86], this feature has been absent in most metacomputing environments.
Reference: [94] <author> F.I. Woodward, T.M. Smith, and W.R. Emanuel, </author> <title> A Global Land Primary Productivity and Phytogeography Model, Global Biogeochemical Cycles , vol. </title> <journal> 9, </journal> <volume> no. 4, </volume> <pages> pp. 471-490, </pages> <month> December, </month> <year> 1995. </year>
Reference-contexts: In this section and Section 7.6 we describe our experiences and performance results obtained with these applications. The first fullscale application to which we applied the Process Introspection system was a program implementing a global carbon productivity and geographic plant distribution model described by Woodward, Smith, and Emanuel <ref> [94] </ref>. This program, lai, computes the leaf area index for a specified set of geographic locations. The leaf area index for a given region is defined to be the amount of leaf surface area per ground surface area over that region.
Reference: [95] <author> E.R. Zayas, </author> <title> Attacking the Process Migration Bottleneck, </title> <booktitle> in Proceedings of the 22nd ACM Symposium on Operating Systems Principles, </booktitle> <pages> pp. 13-24, </pages> <year> 1987. </year>
Reference-contexts: For example, during process migration, an effort is often made to transfer the minimal state needed to restart the process at its destination first, and to transfer remaining state subsequently to reduce migration latency <ref> [95] </ref>. Alternatively, for the purposes of checkpointing, incremental schemes for saving a processs memory, such as periodically capturing only dirty pages, may improve time/space performance [69]. Beyond the obvious issue of heterogeneity, kernel-level state capture schemes have a number of undesirable features in metasystem contexts.
Reference: [96] <author> H. Zhou and A. </author> <title> Geist Receiver Makes Right Data Conversion in PVM, </title> <booktitle> in Proceedings of 14th International Conference on Computers and Communications, </booktitle> <pages> pp. 458-464, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: Later, when the buffer is used to restart the process, the data it contains is converted from the stored data format to the restarting processors data format automatically as it is read by the restarting process, a protocol known as receiver-makes-right <ref> [96] </ref>. Given this receiver-makes-right approach, the library must contain routines to translate the set of basic data types from every available format to every other available format.
Reference: [97] <author> S. Zhou, J. Wang, X. Zheng, and P. Delisle, </author> <title> Utopia: A Loadsharing Facility for Large Heterogeneous Distributed Computing Systems, </title> <journal> Software Practice and Experience , vol. </journal> <volume> 23, no. 2, </volume> <pages> pp. 1305-1336, </pages> <month> December, </month> <year> 1993. </year>
References-found: 97

