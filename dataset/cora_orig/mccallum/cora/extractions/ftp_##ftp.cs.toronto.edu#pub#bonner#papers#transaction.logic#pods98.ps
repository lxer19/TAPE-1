URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/transaction.logic/pods98.ps
Refering-URL: http://www.cs.toronto.edu/DB/people/bonner/papers.html
Root-URL: 
Email: bonner@db.toronto.edu  
Phone: (416) 978-7441 (phone) (416) 978-4765 (fax)  
Title: The Power of Cooperating Transactions  
Author: Anthony J. Bonner 
Web: www.cs.toronto.edu/~bonner  
Address: Toronto, Ontario, Canada M5S 1A4  
Affiliation: University of Toronto Department of Computer Science  
Abstract: In the classical model of database transactions, large transactions cannot be built out of smaller ones. Instead, transactions are modelled as atomic and isolated units of work. This model has been widely successful in traditional database applications, but is inappropriate for more complex applications in which transactions must be combined and coordinated to achieve a larger goal. Examples include CAD, office automation, collaborative work, manufacturing control, and workflow management. These applications require new transaction models, new methods of transaction management, and new transaction languages. This paper focuses on the latter issue: languages for specifying non-classical transactions, and combining them into complex processes. Our vehicle for this study is Transaction Datalog, a deductive language that integrates queries, updates, and transaction composition in a simple logical framework. This integration captures the features of many new transaction models. These features include subtransaction hierarchies, concurrency within individual transactions, cooperation between concurrent activities, a separation of atomicity and isolation, and fine-grained control over abort and rollback. This paper provides an overview of Transaction Data-log, and develops its computational properties. We first show that the data complexity of sequential programs is complete for EXPTIME, while the data complexity of concurrent programs is complete for RE. This enormous difference in complexity comes entirely from cooperation between concurrent transactions. In particular, unlike other results in the literature, RE-completeness is acheived with a fixed data domain, and a fixed database schema, and thus with databases of polynomial size. In addition, we show that Transaction Datalog is expressively complete. That is, concurrent programs express essentially all the transactions in RE, while sequential programs express essentially all the transactions in EXPTIME. Finally, we show that the language is minimal in that if any database operations are removed from the language, then expressive completeness is lost. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul. </author> <title> Updates, a new frontier. </title> <booktitle> In Intl. Conference on Database Theory, </booktitle> <pages> pages 1-18, </pages> <year> 1988. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [8], which is available on the Web. The comparison includes database update languages <ref> [3, 2, 1, 16, 17, 33, 46, 36, 37] </ref>, languages for expressing intertask dependencies [41, 19, 20, 21, 4, 43, 42], process algebras [34, 27, 32], concurrent dynamic logic [40, 39], and concurrent logic programming [13].
Reference: [2] <author> S. Abiteboul and V. Vianu. </author> <title> Procedural languages for database queries and updates. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 41 </volume> <pages> 181-229, </pages> <year> 1990. </year>
Reference-contexts: We show that this effect is profound, and that a set of interacting programs has a much more complex effect than a single, isolated program. To demonstrate this property, we adapt the notion of data complexity used in <ref> [3, 2] </ref> for classical transactions. We then establish the data complexity of T D with and without concurrency. The first result is that without concurrency, the data complexity of T D is complete for EXPTIME. This result is interesting in itself, since most safe update languages are complete for PSPACE. <p> This enormous increase in complexity, from EXPTIME to RE, comes entirely from the interactions between concurrent update programs. In contrast, other update languages achieve RE-completeness by expanding the data domain during transaction execution <ref> [2, 3, 15] </ref>, or by expanding the database schema [16]. Typically, the proof of RE-completeness involves encoding the tape of a Turing machine in the database. Reading the tape is then a database query, and writing the tape is a database update. <p> That is, with concurrency, T D expresses every transaction in RE, as long as it does not expand the data domain. Likewise, without concurrency, T D expresses every transaction in EXPTIME. In these results, a transaction is defined to be a binary relation on databases, as in <ref> [2, 3] </ref>. Finally, we show that the database operations on which T D is built are minimal: if any operation is removed from T D, then expressive completeness is lost. A detailed comparison of T D with other languages is published in [8], which is available on the Web. <p> A detailed comparison of T D with other languages is published in [8], which is available on the Web. The comparison includes database update languages <ref> [3, 2, 1, 16, 17, 33, 46, 36, 37] </ref>, languages for expressing intertask dependencies [41, 19, 20, 21, 4, 43, 42], process algebras [34, 27, 32], concurrent dynamic logic [40, 39], and concurrent logic programming [13]. <p> term "transaction program." In transaction processing, a transaction is a particular execution of a transaction program [5, 26]; in application programming, it is often the transaction program itself; and in data modelling, it is the effects of a transaction program on the database (i:e:, a mapping from databases to databases) <ref> [3, 2] </ref>. Since this paper bridges all three areas, we shall have cause to use the term "transaction" in all three senses. In each case, however, the appropriate meaning shall be stated explicitly, or should be clear from context. <p> That is, the program transforms an initial database into a final database. Since the program may be non-determinisitic, many final databases are possible, so the transformation is a binary relation, as in <ref> [3, 2] </ref>. Formally, a T D program is defined by a transaction base, P, and a ground goal, . We use the expression P : D 1 D 2 ` fi to mean that the program transforms database D 1 into database D 2 when executed in isolation. <p> In addition, there may be a stored predicate symbol dom of arity 1, whose ground atomic formulas represent the domain of the database; otherwise, the domain is taken to be the set of constant symbols in the database. The next definition is adapted from <ref> [3, 2] </ref>. Definition 3.3 (Generic Transactions) A database transaction of type ff ! fi is a binary relation on databases such that D 1 is of type ff and D 2 is of type fi for every pair hD 1 ; D 2 i in T .
Reference: [3] <author> S. Abiteboul and V. Vianu. </author> <title> Datalog extensions for database queries and updates. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43 </volume> <pages> 62-124, </pages> <year> 1991. </year>
Reference-contexts: We show that this effect is profound, and that a set of interacting programs has a much more complex effect than a single, isolated program. To demonstrate this property, we adapt the notion of data complexity used in <ref> [3, 2] </ref> for classical transactions. We then establish the data complexity of T D with and without concurrency. The first result is that without concurrency, the data complexity of T D is complete for EXPTIME. This result is interesting in itself, since most safe update languages are complete for PSPACE. <p> This enormous increase in complexity, from EXPTIME to RE, comes entirely from the interactions between concurrent update programs. In contrast, other update languages achieve RE-completeness by expanding the data domain during transaction execution <ref> [2, 3, 15] </ref>, or by expanding the database schema [16]. Typically, the proof of RE-completeness involves encoding the tape of a Turing machine in the database. Reading the tape is then a database query, and writing the tape is a database update. <p> That is, with concurrency, T D expresses every transaction in RE, as long as it does not expand the data domain. Likewise, without concurrency, T D expresses every transaction in EXPTIME. In these results, a transaction is defined to be a binary relation on databases, as in <ref> [2, 3] </ref>. Finally, we show that the database operations on which T D is built are minimal: if any operation is removed from T D, then expressive completeness is lost. A detailed comparison of T D with other languages is published in [8], which is available on the Web. <p> A detailed comparison of T D with other languages is published in [8], which is available on the Web. The comparison includes database update languages <ref> [3, 2, 1, 16, 17, 33, 46, 36, 37] </ref>, languages for expressing intertask dependencies [41, 19, 20, 21, 4, 43, 42], process algebras [34, 27, 32], concurrent dynamic logic [40, 39], and concurrent logic programming [13]. <p> term "transaction program." In transaction processing, a transaction is a particular execution of a transaction program [5, 26]; in application programming, it is often the transaction program itself; and in data modelling, it is the effects of a transaction program on the database (i:e:, a mapping from databases to databases) <ref> [3, 2] </ref>. Since this paper bridges all three areas, we shall have cause to use the term "transaction" in all three senses. In each case, however, the appropriate meaning shall be stated explicitly, or should be clear from context. <p> That is, the program transforms an initial database into a final database. Since the program may be non-determinisitic, many final databases are possible, so the transformation is a binary relation, as in <ref> [3, 2] </ref>. Formally, a T D program is defined by a transaction base, P, and a ground goal, . We use the expression P : D 1 D 2 ` fi to mean that the program transforms database D 1 into database D 2 when executed in isolation. <p> In addition, there may be a stored predicate symbol dom of arity 1, whose ground atomic formulas represent the domain of the database; otherwise, the domain is taken to be the set of constant symbols in the database. The next definition is adapted from <ref> [3, 2] </ref>. Definition 3.3 (Generic Transactions) A database transaction of type ff ! fi is a binary relation on databases such that D 1 is of type ff and D 2 is of type fi for every pair hD 1 ; D 2 i in T .
Reference: [4] <author> P. Attie, M. Singh, A. Sheth, and M. Rusinkiewicz. </author> <title> Specifying and enforcing intertask dependencies. </title> <booktitle> In Intl. Conference on Very Large Data Bases, </booktitle> <address> Dublin, Ireland, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [8], which is available on the Web. The comparison includes database update languages [3, 2, 1, 16, 17, 33, 46, 36, 37], languages for expressing intertask dependencies <ref> [41, 19, 20, 21, 4, 43, 42] </ref>, process algebras [34, 27, 32], concurrent dynamic logic [40, 39], and concurrent logic programming [13]. In addition, comparisons with logics of time and action can be found in [11, 12], and a comparison with the pi calculus is given in [13].
Reference: [5] <author> P.A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Con-currency Control and Recovery in Databases. </title> <publisher> Addison Wesley, </publisher> <year> 1987. </year>
Reference-contexts: Unfortunately, the term "transaction" is heavily overloaded in the database literature, and has a variety of relationships to the term "transaction program." In transaction processing, a transaction is a particular execution of a transaction program <ref> [5, 26] </ref>; in application programming, it is often the transaction program itself; and in data modelling, it is the effects of a transaction program on the database (i:e:, a mapping from databases to databases) [3, 2]. <p> In this way, the two subprocesses again communicate (in the reverse direction), and processA is synchronized with processB. 2 Because communication between T D programs can be two-way, as in Example 2.5, the execution of T D programs need not be serializable <ref> [5] </ref>, so they need not be isolated transactions. To specify that a program executes transactionally, a T D programmer uses the modality of isolation, fi. Intuitively, the formula fi means that program executes in isolation from all other concurrent programs.
Reference: [6] <author> A. Bonner, A. Shrufi, and S. Rozen. LabFlow-1: </author> <title> a database benchmark for high-throughput work-flow management. </title> <booktitle> In Intl. Conference on Extending Database Technology, number 1057 in Lecture Notes in Computer Science, </booktitle> <pages> pages 463-478, </pages> <address> Avignon, France, March 25-29 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In fact, cooperation and coordination are sometimes the raison d'^etre of non-classical transactions. A workflow, for instance, is a coordinated execution of many activities <ref> [6, 30] </ref>. Characterizing the complexity of non-classical transactions thus involves characterizing the complexity of their interactions. In this paper, we take a simple approach to the problem: given a set of concurrent programs, we measure the complexity of their interactions by observing its effect on the database.
Reference: [7] <author> A.J. Bonner. </author> <title> The power of cooperating transactions. </title> <note> Long version available at http:// www.cs.toronto.edu/~bonner/papers.html #transaction-logic. </note>
Reference-contexts: We then show that if the transaction base is sequential, then the minimal model is of exponential size and can be computed in exponential time. Additional details are given in a long version of this paper, which is available on the Web <ref> [7] </ref>. The rest of this section looks at concurrent T D. The RE upper-bound is easy. Appendix A defines the semantics of T D in terms of a logical inference system. In any logical inference system, the derivation problem is always in RE. <p> These rules unfold and execute when a process receives a message. Additional details are given in a long version of this paper, which is available on the Web <ref> [7] </ref>. 3.2 Expressive Completeness Theorem 3.1 only guarantees that there is some RE-hard (EXPTIME-hard) transaction that concurrent T D (sequential T D) can express. In fact, statement (3) shows that this transaction has no net effect on the database at all. <p> T D expresses T if some transaction base expresses it. 2 The following theorem is the main result of this section. Details are given in a long version of this paper, which is available on the Web <ref> [7] </ref>. Theorem 3.5 (Expressibility of T D) Every generic transaction in RE that preserves constants can be expressed in concurrent T D.
Reference: [8] <author> A.J. Bonner. </author> <title> Transaction Datalog: a compositional language for transaction programming. </title> <booktitle> In Proceedings of the International Workshop on Database Programming Languages, </booktitle> <address> Estes Park, Col-orado, </address> <month> August </month> <year> 1997. </year> <note> Springer Verlag. Long version available at http://www.cs.toronto.edu/~bonner/ papers.html#transaction-logic. </note>
Reference-contexts: Finally, we show that the database operations on which T D is built are minimal: if any operation is removed from T D, then expressive completeness is lost. A detailed comparison of T D with other languages is published in <ref> [8] </ref>, which is available on the Web. The comparison includes database update languages [3, 2, 1, 16, 17, 33, 46, 36, 37], languages for expressing intertask dependencies [41, 19, 20, 21, 4, 43, 42], process algebras [34, 27, 32], concurrent dynamic logic [40, 39], and concurrent logic programming [13]. <p> This section defines the syntax of the logic, describes its semantics intuitively, and illustrates how it captures the properties of transactions, both classical and non-classical. The formal semantics is developed in Appendix A, and more-involved examples are given in the long version of <ref> [8] </ref>, which is available on the Web. 2.1 Syntax and Semantics The language of Transaction Datalog includes three infinite enumerable sets of symbols: constant symbols (a; b; c; :::), variables (X; Y; Z; :::), and predicate symbols (p; q; r; :::). <p> In contrast, the procedural semantics involves one process waiting for another process to perform an update, as described in the example. A more-involved example of cooperation between processes in T D is given in the long version of <ref> [8] </ref>, where concurrent transactions are combined into a workflow. Example 2.5 (Communication and Synchronization) The rules below define a process and two subpro-cesses.
Reference: [9] <author> A.J. Bonner and M. Kifer. </author> <title> Reasoning about action in transaction logic. In preparation. Presented at the Dagstuhl Seminar on Logic Databases and the Meaning of Change, </title> <month> September 23-27 </month> <year> 1996, </year> <booktitle> International Conference and Research Center for Computer Science, </booktitle> <address> Schloss Dagstuhl, Wadern, Germany. </address>
Reference: [10] <author> A.J. Bonner and M. Kifer. </author> <title> Transaction logic programming. </title> <booktitle> In Intl. Conference on Logic Programming, </booktitle> <pages> pages 257-282, </pages> <address> Budapest, Hungary, June 1993. </address> <publisher> MIT Press. </publisher>
Reference: [11] <author> A.J. Bonner and M. Kifer. </author> <title> An overview of transaction logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 133 </volume> <pages> 205-265, </pages> <month> Oc-tober </month> <year> 1994. </year>
Reference-contexts: In addition, comparisons with logics of time and action can be found in <ref> [11, 12] </ref>, and a comparison with the pi calculus is given in [13].
Reference: [12] <author> A.J. Bonner and M. Kifer. </author> <title> Transaction logic programming (or a logic of declarative and procedural knowledge). </title> <type> Technical Report CSRI-323, </type> <institution> University of Toronto, </institution> <month> November </month> <year> 1995. </year> <note> http://www.cs.toronto.edu/~bonner/ transaction-logic.html. </note>
Reference-contexts: In addition, comparisons with logics of time and action can be found in <ref> [11, 12] </ref>, and a comparison with the pi calculus is given in [13]. <p> This idea is developed in <ref> [14, 12] </ref>, and implemented in [31]. 2 OVERVIEW OF TRANSACTION DATALOG 5 * ( 1 j 2 j j k ) where k 0 and each i is a goal; or * fi where is a goal; where parentheses may be dropped unless needed to resolve ambiguity.
Reference: [13] <author> A.J. Bonner and M. Kifer. </author> <title> Concurrency and communication in transaction logic. </title> <booktitle> In Joint Intl. Conference and Symposium on Logic Programming, </booktitle> <pages> pages 142-156, </pages> <address> Bonn, Germany, September 1996. </address> <publisher> MIT Press. </publisher>
Reference-contexts: The comparison includes database update languages [3, 2, 1, 16, 17, 33, 46, 36, 37], languages for expressing intertask dependencies [41, 19, 20, 21, 4, 43, 42], process algebras [34, 27, 32], concurrent dynamic logic [40, 39], and concurrent logic programming <ref> [13] </ref>. In addition, comparisons with logics of time and action can be found in [11, 12], and a comparison with the pi calculus is given in [13]. <p> expressing intertask dependencies [41, 19, 20, 21, 4, 43, 42], process algebras [34, 27, 32], concurrent dynamic logic [40, 39], and concurrent logic programming <ref> [13] </ref>. In addition, comparisons with logics of time and action can be found in [11, 12], and a comparison with the pi calculus is given in [13]. Papers on the logical foundations of T D, a prototype implementation of sequential T D, and the results of benchmark tests are available at http:// www.cs.toronto.edu/~bonner/transaction-logic.html 2 Overview of Transaction Datalog In Transaction Datalog, programs are represented by logical formulas. <p> In particular, the database can contain structures and access methods designed for efficient communication. For instance, some relations in the database could be a view of a set of message queues or communication channels, as described in <ref> [13] </ref>. 3 COMPLEXITY AND EXPRESSIBILITY 8 These rules define four isolated transactions | sell, transfer, withdraw and deposit | and one subroutine | change. Observe that withdraw and deposit are nested within transfer, and two instances of transfer are nested within sell.
Reference: [14] <author> A.J. Bonner, M. Kifer, and M. Consens. </author> <title> Database programming in transaction logic. </title> <editor> In A. Ohori C. Beeri and D.E. Shasha, editors, </editor> <booktitle> Proceedings of the International Workshop on Database Programming Languages, Workshops in Computing, </booktitle> <pages> pages 309-337. </pages> <publisher> Springer-Verlag, </publisher> <month> February </month> <year> 1994. </year> <booktitle> Workshop held on Aug 30-Sept 1, 1993, </booktitle> <address> New York City, NY. </address>
Reference-contexts: This idea is developed in <ref> [14, 12] </ref>, and implemented in [31]. 2 OVERVIEW OF TRANSACTION DATALOG 5 * ( 1 j 2 j j k ) where k 0 and each i is a goal; or * fi where is a goal; where parentheses may be dropped unless needed to resolve ambiguity.
Reference: [15] <author> A.J. Bonner, L.T. McCarty, and K. Vadaparty. </author> <title> Expressing Database Queries with Intuitionistic Logic. </title> <booktitle> In North American Conference on Logic Programming, </booktitle> <pages> pages 831-850, </pages> <address> Cleveland, Ohio, October 16-20 1989. </address> <publisher> MIT Press. </publisher>
Reference-contexts: This enormous increase in complexity, from EXPTIME to RE, comes entirely from the interactions between concurrent update programs. In contrast, other update languages achieve RE-completeness by expanding the data domain during transaction execution <ref> [2, 3, 15] </ref>, or by expanding the database schema [16]. Typically, the proof of RE-completeness involves encoding the tape of a Turing machine in the database. Reading the tape is then a database query, and writing the tape is a database update.
Reference: [16] <author> A.K. Chandra and D. Harel. </author> <title> Computable queries for relational databases. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 21(2) </volume> <pages> 156-178, </pages> <year> 1980. </year>
Reference-contexts: This enormous increase in complexity, from EXPTIME to RE, comes entirely from the interactions between concurrent update programs. In contrast, other update languages achieve RE-completeness by expanding the data domain during transaction execution [2, 3, 15], or by expanding the database schema <ref> [16] </ref>. Typically, the proof of RE-completeness involves encoding the tape of a Turing machine in the database. Reading the tape is then a database query, and writing the tape is a database update. <p> A detailed comparison of T D with other languages is published in [8], which is available on the Web. The comparison includes database update languages <ref> [3, 2, 1, 16, 17, 33, 46, 36, 37] </ref>, languages for expressing intertask dependencies [41, 19, 20, 21, 4, 43, 42], process algebras [34, 27, 32], concurrent dynamic logic [40, 39], and concurrent logic programming [13]. <p> In particular, we can show that concurrent T D (sequential T D) can express every transaction in RE (EXPTIME) that does not expand the data domain. To make this statement precise, we need some formal definitions. The first one is taken from <ref> [16, 17] </ref>. Definition 3.2 (Relational Databases) Let U be an enumerable set, called the universal data domain, and let ff 1 ; ff 2 ; :::; ff m be non-negative integers.
Reference: [17] <author> A.K. Chandra and D. Harel. </author> <title> Structure and complexity of relational queries. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 25(1) </volume> <pages> 99-128, </pages> <year> 1982. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [8], which is available on the Web. The comparison includes database update languages <ref> [3, 2, 1, 16, 17, 33, 46, 36, 37] </ref>, languages for expressing intertask dependencies [41, 19, 20, 21, 4, 43, 42], process algebras [34, 27, 32], concurrent dynamic logic [40, 39], and concurrent logic programming [13]. <p> In particular, we can show that concurrent T D (sequential T D) can express every transaction in RE (EXPTIME) that does not expand the data domain. To make this statement precise, we need some formal definitions. The first one is taken from <ref> [16, 17] </ref>. Definition 3.2 (Relational Databases) Let U be an enumerable set, called the universal data domain, and let ff 1 ; ff 2 ; :::; ff m be non-negative integers.
Reference: [18] <author> A.K. Chandra, D. Kozen, and L.J. Stockmeyer. </author> <title> Alternation. </title> <journal> Journal of ACM, </journal> <volume> 28 </volume> <pages> 114-133, </pages> <year> 1981. </year>
Reference-contexts: The first result is that without concurrency, the data complexity of T D is complete for EXPTIME. This result is interesting in itself, since most safe update languages are complete for PSPACE. The increased complexity of T D comes from its ability to simulate alternating PSPACE machines <ref> [18] </ref>, which in turn comes from its ability to compose transaction programs recursively. The second result is that with concurrency, the data complexity of T D is complete for RE. This enormous increase in complexity, from EXPTIME to RE, comes entirely from the interactions between concurrent update programs. <p> The EXPTIME lower-bound relies on the ability of sequential T D to compose transaction programs sequentially and non-deterministically, and to do so in a mutually recursive fashion. Using this, we show how to simulate the computations of alternating PSPACE machines. The result follows since alternating PSPACE = EXPTIME <ref> [18] </ref>. To prove the EXPTIME upper-bound, we use the model theory for T D. We first show that every transaction base has a unique minimal model.
Reference: [19] <author> P.K. Chrysanthis and K. Ramamritham. </author> <title> Synthesis of extended transaction models using ACTA. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 19(3) </volume> <pages> 450-491, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [8], which is available on the Web. The comparison includes database update languages [3, 2, 1, 16, 17, 33, 46, 36, 37], languages for expressing intertask dependencies <ref> [41, 19, 20, 21, 4, 43, 42] </ref>, process algebras [34, 27, 32], concurrent dynamic logic [40, 39], and concurrent logic programming [13]. In addition, comparisons with logics of time and action can be found in [11, 12], and a comparison with the pi calculus is given in [13].
Reference: [20] <author> P.K. Chrysanthis and K. Ramamrithm. </author> <title> ACTA: The SAGA continues. </title> <booktitle> In [22], chapter 10, </booktitle> <pages> pages 349-397. </pages> <year> 1992. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [8], which is available on the Web. The comparison includes database update languages [3, 2, 1, 16, 17, 33, 46, 36, 37], languages for expressing intertask dependencies <ref> [41, 19, 20, 21, 4, 43, 42] </ref>, process algebras [34, 27, 32], concurrent dynamic logic [40, 39], and concurrent logic programming [13]. In addition, comparisons with logics of time and action can be found in [11, 12], and a comparison with the pi calculus is given in [13].
Reference: [21] <author> U. Dayal, H. Garcia-Molina, M. Hsu, B. Kao, and M.- C. Shan. </author> <title> Third generation TP monitors: A database challenge. </title> <booktitle> In ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 393-397, </pages> <address> Washington, DD, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [8], which is available on the Web. The comparison includes database update languages [3, 2, 1, 16, 17, 33, 46, 36, 37], languages for expressing intertask dependencies <ref> [41, 19, 20, 21, 4, 43, 42] </ref>, process algebras [34, 27, 32], concurrent dynamic logic [40, 39], and concurrent logic programming [13]. In addition, comparisons with logics of time and action can be found in [11, 12], and a comparison with the pi calculus is given in [13].
Reference: [22] <editor> A.K. Elmagarmid, editor. </editor> <title> Database Transaction Models for Advanced Applications. </title> <publisher> Morgan-Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1992. </year>
Reference: [23] <author> A.K. Elmagarmid, Y. Leu, W. Litwin, and M. Rusinkiewcz. </author> <title> A multidatabase transaction model for interbase. </title> <booktitle> In Intl. Conference on Very Large Data Bases, </booktitle> <pages> pages 507-518, </pages> <address> Brisbane, Australia, </address> <month> August 13-16 </month> <year> 1990. </year>
Reference: [24] <author> H. Garcia-Molina and K. Salem. Sagas. </author> <booktitle> In Intl. Conference on Very Large Data Bases, </booktitle> <pages> pages 249-259, </pages> <month> May </month> <year> 1987. </year>
Reference: [25] <author> J. Gray. </author> <title> The transaction concept: Virtues and limitations. </title> <booktitle> In Intl. Conference on Very Large Data Bases, </booktitle> <pages> pages 144-154, </pages> <address> Cannes, France, </address> <month> September </month> <year> 1981. </year>
Reference: [26] <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1993. </year>
Reference-contexts: Unfortunately, the term "transaction" is heavily overloaded in the database literature, and has a variety of relationships to the term "transaction program." In transaction processing, a transaction is a particular execution of a transaction program <ref> [5, 26] </ref>; in application programming, it is often the transaction program itself; and in data modelling, it is the effects of a transaction program on the database (i:e:, a mapping from databases to databases) [3, 2].
Reference: [27] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1985. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [8], which is available on the Web. The comparison includes database update languages [3, 2, 1, 16, 17, 33, 46, 36, 37], languages for expressing intertask dependencies [41, 19, 20, 21, 4, 43, 42], process algebras <ref> [34, 27, 32] </ref>, concurrent dynamic logic [40, 39], and concurrent logic programming [13]. In addition, comparisons with logics of time and action can be found in [11, 12], and a comparison with the pi calculus is given in [13].
Reference: [28] <author> J.E. Hopcroft and J.D. Ullman. </author> <title> Introduction to Automata Theory, Languages and Computation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1979. </year>
Reference-contexts: In any logical inference system, the derivation problem is always in RE. In particular, the problem of deriving P : D 1 D 2 ` fi is in RE. To prove the RE lower-bound, we use concurrent T D to encode the computations of an arbitrary 2-stack machine <ref> [28] </ref>. A 2-stack machine is like a Turing machine except that instead of a work tape, it has two stacks. It also has a read-only input tape. At each computation step, the machine may push or pop each stack, and it may move the input head left or right.
Reference: [29] <author> M. Hsu, Ed. </author> <title> Special issue on workflow and extended transaction systems. </title> <journal> Bulletin of the Technical Committee on Data Engineering (IEEE Computer Society), </journal> <volume> 16(2), </volume> <month> June </month> <year> 1993. </year>
Reference: [30] <author> M. Hsu, </author> <title> Ed. </title> <journal> Special issue on workflow systems. Bulletin of the Technical Committee on Data Engineering (IEEE Computer Society), </journal> <volume> 18(1), </volume> <month> March </month> <year> 1995. </year>
Reference-contexts: In fact, cooperation and coordination are sometimes the raison d'^etre of non-classical transactions. A workflow, for instance, is a coordinated execution of many activities <ref> [6, 30] </ref>. Characterizing the complexity of non-classical transactions thus involves characterizing the complexity of their interactions. In this paper, we take a simple approach to the problem: given a set of concurrent programs, we measure the complexity of their interactions by observing its effect on the database.
Reference: [31] <author> Samuel Y.K. Hung. </author> <title> Implementation and Performance of Transaction Logic in Prolog. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Toronto, </institution> <year> 1996. </year> <note> http://www.cs.toronto.edu/ ~bonner/transaction-logic.html. </note>
Reference-contexts: This idea is developed in [14, 12], and implemented in <ref> [31] </ref>. 2 OVERVIEW OF TRANSACTION DATALOG 5 * ( 1 j 2 j j k ) where k 0 and each i is a goal; or * fi where is a goal; where parentheses may be dropped unless needed to resolve ambiguity.
Reference: [32] <author> P.E. Lauer and R.H. Campbell. </author> <title> Formal semantics of a class of high-level primitives for co-ordinating concurrent processes. </title> <journal> Acta Informatica, </journal> <volume> 5 </volume> <pages> 297-332, </pages> <year> 1975. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [8], which is available on the Web. The comparison includes database update languages [3, 2, 1, 16, 17, 33, 46, 36, 37], languages for expressing intertask dependencies [41, 19, 20, 21, 4, 43, 42], process algebras <ref> [34, 27, 32] </ref>, concurrent dynamic logic [40, 39], and concurrent logic programming [13]. In addition, comparisons with logics of time and action can be found in [11, 12], and a comparison with the pi calculus is given in [13].
Reference: [33] <author> S. Manchanda and D.S. Warren. </author> <title> A logic-based language for database updates. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 363-394. </pages> <publisher> Morgan-Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [8], which is available on the Web. The comparison includes database update languages <ref> [3, 2, 1, 16, 17, 33, 46, 36, 37] </ref>, languages for expressing intertask dependencies [41, 19, 20, 21, 4, 43, 42], process algebras [34, 27, 32], concurrent dynamic logic [40, 39], and concurrent logic programming [13].
Reference: [34] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [8], which is available on the Web. The comparison includes database update languages [3, 2, 1, 16, 17, 33, 46, 36, 37], languages for expressing intertask dependencies [41, 19, 20, 21, 4, 43, 42], process algebras <ref> [34, 27, 32] </ref>, concurrent dynamic logic [40, 39], and concurrent logic programming [13]. In addition, comparisons with logics of time and action can be found in [11, 12], and a comparison with the pi calculus is given in [13].
Reference: [35] <author> J. E. B. Moss. </author> <title> Nested Transactions: An Approach to Reliable Distributed Computing. </title> <booktitle> Series in Information Systems. </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1985. </year>
Reference: [36] <author> S. Naqvi and R. Krishnamurthy. </author> <title> Database updates in logic programming. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 251-262, </pages> <address> New York, </address> <month> March </month> <year> 1988. </year> <note> ACM. </note>
Reference-contexts: A detailed comparison of T D with other languages is published in [8], which is available on the Web. The comparison includes database update languages <ref> [3, 2, 1, 16, 17, 33, 46, 36, 37] </ref>, languages for expressing intertask dependencies [41, 19, 20, 21, 4, 43, 42], process algebras [34, 27, 32], concurrent dynamic logic [40, 39], and concurrent logic programming [13].
Reference: [37] <author> S. Naqvi and S. Tsur. </author> <title> A Logical Language for Data and Knowledge Bases. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1989. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [8], which is available on the Web. The comparison includes database update languages <ref> [3, 2, 1, 16, 17, 33, 46, 36, 37] </ref>, languages for expressing intertask dependencies [41, 19, 20, 21, 4, 43, 42], process algebras [34, 27, 32], concurrent dynamic logic [40, 39], and concurrent logic programming [13].
Reference: [38] <author> M. H. Nodine, S. Ramaswamy, and S. B. Zdonik. </author> <title> A cooperative transaction model for design databases. </title> <booktitle> In [22], chapter 3, </booktitle> <pages> pages 53-85. </pages> <year> 1992. </year>
Reference: [39] <author> D. Peleg. </author> <title> Communication in concurrent dynamic logic. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 35(1) </volume> <pages> 23-58, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: The comparison includes database update languages [3, 2, 1, 16, 17, 33, 46, 36, 37], languages for expressing intertask dependencies [41, 19, 20, 21, 4, 43, 42], process algebras [34, 27, 32], concurrent dynamic logic <ref> [40, 39] </ref>, and concurrent logic programming [13]. In addition, comparisons with logics of time and action can be found in [11, 12], and a comparison with the pi calculus is given in [13].
Reference: [40] <author> D. </author> <title> Peleg. </title> <journal> Concurrent-dynamic logic. Journal of ACM, </journal> <volume> 34(2):450 - 479, </volume> <month> March </month> <year> 1987. </year>
Reference-contexts: The comparison includes database update languages [3, 2, 1, 16, 17, 33, 46, 36, 37], languages for expressing intertask dependencies [41, 19, 20, 21, 4, 43, 42], process algebras [34, 27, 32], concurrent dynamic logic <ref> [40, 39] </ref>, and concurrent logic programming [13]. In addition, comparisons with logics of time and action can be found in [11, 12], and a comparison with the pi calculus is given in [13].
Reference: [41] <author> M. Rusinkiewicz and A. Sheth. </author> <title> Specification and execution of transactional workflows. </title> <editor> In W. Kim, editor, </editor> <title> Modern Database Systems: The Object Model, Interoperability, and Beyond. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [8], which is available on the Web. The comparison includes database update languages [3, 2, 1, 16, 17, 33, 46, 36, 37], languages for expressing intertask dependencies <ref> [41, 19, 20, 21, 4, 43, 42] </ref>, process algebras [34, 27, 32], concurrent dynamic logic [40, 39], and concurrent logic programming [13]. In addition, comparisons with logics of time and action can be found in [11, 12], and a comparison with the pi calculus is given in [13].
Reference: [42] <author> M.P. Singh. </author> <title> Semantical considerations on workflows: An algebra for intertask dependencies. </title> <booktitle> In Proceedings of the International Workshop on Database Programming Languages, </booktitle> <address> Gubbio, Umbria, Italy, </address> <month> September 6-8 </month> <year> 1995. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [8], which is available on the Web. The comparison includes database update languages [3, 2, 1, 16, 17, 33, 46, 36, 37], languages for expressing intertask dependencies <ref> [41, 19, 20, 21, 4, 43, 42] </ref>, process algebras [34, 27, 32], concurrent dynamic logic [40, 39], and concurrent logic programming [13]. In addition, comparisons with logics of time and action can be found in [11, 12], and a comparison with the pi calculus is given in [13].
Reference: [43] <author> M.P. Singh. </author> <title> Synthesizing distributed constrained events from transactional workflow specifications. </title> <booktitle> In Proceedings of 12-th IEEE Intl. Conference on Data Engineering, </booktitle> <pages> pages 616-623, </pages> <address> New Orleans, LA, </address> <month> Febru-ary </month> <year> 1996. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [8], which is available on the Web. The comparison includes database update languages [3, 2, 1, 16, 17, 33, 46, 36, 37], languages for expressing intertask dependencies <ref> [41, 19, 20, 21, 4, 43, 42] </ref>, process algebras [34, 27, 32], concurrent dynamic logic [40, 39], and concurrent logic programming [13]. In addition, comparisons with logics of time and action can be found in [11, 12], and a comparison with the pi calculus is given in [13].
Reference: [44] <author> Transarc-Encina. </author> <title> Encina Transactional Processing System: Transactional-C Programmers Guide and Reference, </title> <institution> TP-00-D347. Transarc Corp., Pittsburg, </institution> <address> PA, </address> <year> 1991. </year>
Reference: [45] <author> H. Wachter and A. Reuter. </author> <title> The ConTract model. </title> <booktitle> In [22], chapter 7, </booktitle> <pages> pages 220-263. </pages> <year> 1992. </year>
Reference: [46] <author> D.S. Warren. </author> <title> Database Updates in Pure Prolog. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 244-253, </pages> <year> 1984. </year>
Reference-contexts: A detailed comparison of T D with other languages is published in [8], which is available on the Web. The comparison includes database update languages <ref> [3, 2, 1, 16, 17, 33, 46, 36, 37] </ref>, languages for expressing intertask dependencies [41, 19, 20, 21, 4, 43, 42], process algebras [34, 27, 32], concurrent dynamic logic [40, 39], and concurrent logic programming [13].
Reference: [47] <author> G. Weikum and H.-J. Schek. </author> <title> Concepts and applications of multilevel transactions and open nested transactions. </title> <booktitle> In [22], chapter 13, </booktitle> <pages> pages 515-553. </pages> <year> 1992. </year>
References-found: 47

