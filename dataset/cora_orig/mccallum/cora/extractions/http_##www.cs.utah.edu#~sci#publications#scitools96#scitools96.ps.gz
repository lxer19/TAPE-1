URL: http://www.cs.utah.edu/~sci/publications/scitools96/scitools96.ps.gz
Refering-URL: http://www.cs.utah.edu/~sci/publications/
Root-URL: 
Title: Steering Software System  1.1.1 Visual Computing and Interactive Steering  
Author: Steven G. Parker David M. Weinstein Christopher R. Johnson 
Note: This is page 1 Printer: Opaque this The SCIRun Computational  1.1 Introduction  
Abstract: We present the design, implementation and application of SCIRun, a scientific programming environment that allows the interactive construction, debugging, and steering of large-scale scientific computations. Using this "computational workbench," a scientist can design and modify simulations interactively via a dataflow programming model. SCIRun enables scientists to design and modify model geometry, interactively change simulation parameters and boundary conditions, and interactively visualize geometric models and simulation results. We discuss the ubiquitous roles SCIRun plays as a computational tool (e.g. resource manager, thread scheduler, development environment), and how we have applied an object oriented design (implemented in C++) to the scientific computing process. Finally, we demonstrate the application of SCIRun to large scale problems in com In recent years, the scientific computing community has experienced an explosive growth in both the possible size and the possible complexity of numeric computations. One of the significant benefits of this increased computing power is the ability to perform complex three-dimensional simulations. However, such simulations present new challenges for computational scientists. How does one effectively analyze and visualize complex 3D data? How does one solve the problems of working with very large datasets often putational medicine.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> SCIRun. </author> <note> http://www.cs.utah.edu/~sci/. </note>
Reference-contexts: Our efforts, therefore, include a diverse range of techniques, including, among others, the use of scripting languages, existing software, 1. SCIRun 3 visual dataflow programming, and a sophisticated system designed exclusively for computational steering. In this chapter, we focus on the latter, the SCIRun 5 <ref> [1] </ref> computational steering software system. SCIRun is a scientific programming environment that allows the interactive construction, debugging and steering of large-scale scientific computations [3]. SCIRun can be envisioned as a "computational workbench," in which a scientist can design and modify simulations interactively via a dataflow programming model. <p> a new node Pio (stream, node.pt); // read/write the node's location stream.end_cheap_delim (); g void Pio (Piostream& stream, Element* elem) f if (stream.reading ()) // if we're reading... elem=new Element (); // ...allocate a new element stream.begin_cheap_delim (); Pio (stream, elem-&gt;n [0]); // read/write all of the Pio (stream, elem-&gt;n <ref> [1] </ref>); // indices for the four Pio (stream, elem-&gt;n [2]); // nodes composing the Pio (stream, elem-&gt;n [3]); // tetrahedral element stream.end_cheap_delim (); g It is important to remember that these small functions will both read and write the mesh for both binary files and text files.
Reference: [2] <author> T. De Fanti et al. </author> <title> Special issue on visualization in scientific computing. </title> <journal> Computer Graphics, </journal> <volume> 21(6), </volume> <month> November </month> <year> 1987. </year>
Reference-contexts: As a result, the researcher may expend significant effort trying to use a data analysis package only to walk away frustrated. In 1987, the Visualization in Scientific Computing (ViSC) workshop reported <ref> [2] </ref>: Scientists not only want to analyze data that results from super-computations; they also want to interpret what is happening to the data during super-computations. Researchers want to steer calculations in close-to-real-time; they want to be able to change parameters, resolution or representation, and see the effects. <p> node's location stream.end_cheap_delim (); g void Pio (Piostream& stream, Element* elem) f if (stream.reading ()) // if we're reading... elem=new Element (); // ...allocate a new element stream.begin_cheap_delim (); Pio (stream, elem-&gt;n [0]); // read/write all of the Pio (stream, elem-&gt;n [1]); // indices for the four Pio (stream, elem-&gt;n <ref> [2] </ref>); // nodes composing the Pio (stream, elem-&gt;n [3]); // tetrahedral element stream.end_cheap_delim (); g It is important to remember that these small functions will both read and write the mesh for both binary files and text files.
Reference: [3] <author> S.G. Parker and C.R. Johnson. SCIRun: </author> <title> A scientific programming environment for computational steering. </title> <booktitle> In Supercomputing `95. </booktitle> <publisher> IEEE Press, </publisher> <year> 1995. </year> <note> http://www.supercomp.org/sc95/proceedings/499 spar/sc95.htm. </note>
Reference-contexts: SCIRun 3 visual dataflow programming, and a sophisticated system designed exclusively for computational steering. In this chapter, we focus on the latter, the SCIRun 5 [1] computational steering software system. SCIRun is a scientific programming environment that allows the interactive construction, debugging and steering of large-scale scientific computations <ref> [3] </ref>. SCIRun can be envisioned as a "computational workbench," in which a scientist can design and modify simulations interactively via a dataflow programming model. <p> stream, Element* elem) f if (stream.reading ()) // if we're reading... elem=new Element (); // ...allocate a new element stream.begin_cheap_delim (); Pio (stream, elem-&gt;n [0]); // read/write all of the Pio (stream, elem-&gt;n [1]); // indices for the four Pio (stream, elem-&gt;n [2]); // nodes composing the Pio (stream, elem-&gt;n <ref> [3] </ref>); // tetrahedral element stream.end_cheap_delim (); g It is important to remember that these small functions will both read and write the mesh for both binary files and text files. This feature virtually eliminates the potential for incompatibilities between the reading code and the writing code.
Reference: [4] <author> W. Gu, J. Vetter, and K. Schwan. </author> <title> An annotated bibliography of interactive program steering. </title> <institution> Georgia Institute of Technology Technical Report, </institution> <year> 1994. </year>
Reference-contexts: Much work goes into simplifying the programming interfaces to these features so that they will be used, rather than ignored, by module implementors. 1.1.3 Steering The primary purpose of SCIRun is to enable the user to interactively control scientific simulations while the computation is in progress <ref> [4, 5] </ref>. This control allows the user to vary boundary conditions, model geometries, or various computational parameters during simulation. Currently, many debugging systems provide this capability in a very raw, low-level form.
Reference: [5] <author> J. Vetter, G. Eisenhauer, W. Gu, T. Kindler, K. Schwan, and D. Silva. </author> <title> Opportunities and tools for highly interactive distributed and parallel computing. </title> <booktitle> Proceedings of the Workshop On Debugging and Tuning for Parallel Computing Systems, </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: Much work goes into simplifying the programming interfaces to these features so that they will be used, rather than ignored, by module implementors. 1.1.3 Steering The primary purpose of SCIRun is to enable the user to interactively control scientific simulations while the computation is in progress <ref> [4, 5] </ref>. This control allows the user to vary boundary conditions, model geometries, or various computational parameters during simulation. Currently, many debugging systems provide this capability in a very raw, low-level form.
Reference: [6] <author> C.R. Johnson, R.S. MacLeod, and P.R. Ershler. </author> <title> A computer model for the study of electrical current flow in the human thorax. </title> <journal> Computers in Biology and Medicine, </journal> <volume> 22(3) </volume> <pages> 305-323, </pages> <year> 1992. </year> <note> 38 S.G. Parker, D.W. Weinstein, C.R. Johnson </note>
Reference-contexts: Computational steering allows these questions to be answered more efficiently and therefore to guide the investigation as it occurs. 1.2 Requirements of SCIRun as a Computational Steering System Initially we designed SCIRun to solve specific problems in Computational Medicine <ref> [6, 7, 8, 9] </ref>, but we have made extensive efforts to make SCIRun applicable in other computational science and engineering problem domains. In attacking the specific problems, we found that there were a wide range of disparate demands placed on such a system. <p> stats and audit as shown below. class Pool f Pool (); ~Pool (); Mutex lock; void* alloc (size_t size, char* ctag, int itag); void free (void* p); void* realloc (void* p, size_t size); void audit (); void get_stats (size_t statbuf [18]); int nbins (); void get_bin_stats (int bin, size_t statbuf <ref> [6] </ref>); ... Pool represents a pool of memory. At startup, there is a single pool, default pool, from which requests from malloc and new are granted. The implementations of malloc and the new operator simply call the alloc method of the default pool. <p> Because of the complex geometry and inhomogeneous nature of the human thorax and the lack of sophisticated thorax models, most past design work on defibrillation devices has relied on animal studies. We have constructed a large scale model of the human thorax, the Utah Torso Model <ref> [6, 7, 25, 26] </ref>, for simulating both the endogenous fields of the heart and applied current sources (defibrillation devices). Using these computer models, we are also able to simulate the multitude of electrode configurations, electrode sizes, and magnitudes of defibrillation shocks. Figure 1.8 shows the results of such a simulation.
Reference: [7] <author> C.R. Johnson, R.S. MacLeod, and M.A. Matheson. </author> <title> Computational medicine: Bioelectric field problems. </title> <booktitle> IEEE COMPUTER, </booktitle> <pages> pages 59-67, </pages> <month> Oct., </month> <year> 1993. </year>
Reference-contexts: Computational steering allows these questions to be answered more efficiently and therefore to guide the investigation as it occurs. 1.2 Requirements of SCIRun as a Computational Steering System Initially we designed SCIRun to solve specific problems in Computational Medicine <ref> [6, 7, 8, 9] </ref>, but we have made extensive efforts to make SCIRun applicable in other computational science and engineering problem domains. In attacking the specific problems, we found that there were a wide range of disparate demands placed on such a system. <p> Because of the complex geometry and inhomogeneous nature of the human thorax and the lack of sophisticated thorax models, most past design work on defibrillation devices has relied on animal studies. We have constructed a large scale model of the human thorax, the Utah Torso Model <ref> [6, 7, 25, 26] </ref>, for simulating both the endogenous fields of the heart and applied current sources (defibrillation devices). Using these computer models, we are also able to simulate the multitude of electrode configurations, electrode sizes, and magnitudes of defibrillation shocks. Figure 1.8 shows the results of such a simulation.
Reference: [8] <author> C.R. Johnson and S.G. Parker. </author> <title> A computational steering model for problems in medicine. </title> <booktitle> In Supercomputing `94, </booktitle> <pages> pages 540-549. </pages> <publisher> IEEE Press, </publisher> <year> 1994. </year>
Reference-contexts: Computational steering allows these questions to be answered more efficiently and therefore to guide the investigation as it occurs. 1.2 Requirements of SCIRun as a Computational Steering System Initially we designed SCIRun to solve specific problems in Computational Medicine <ref> [6, 7, 8, 9] </ref>, but we have made extensive efforts to make SCIRun applicable in other computational science and engineering problem domains. In attacking the specific problems, we found that there were a wide range of disparate demands placed on such a system.
Reference: [9] <author> C.R. Johnson and S.G. Parker. </author> <title> Applications in computational medicine using SCIRun: A computational steering programming environment. </title> <booktitle> In Supercomputer `95, </booktitle> <pages> pages 2-19. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Computational steering allows these questions to be answered more efficiently and therefore to guide the investigation as it occurs. 1.2 Requirements of SCIRun as a Computational Steering System Initially we designed SCIRun to solve specific problems in Computational Medicine <ref> [6, 7, 8, 9] </ref>, but we have made extensive efforts to make SCIRun applicable in other computational science and engineering problem domains. In attacking the specific problems, we found that there were a wide range of disparate demands placed on such a system.
Reference: [10] <author> H.P. Langtangen. Diffpack: </author> <title> Software for partial differential equations. </title> <booktitle> In Proceedings of the 2nd Annual Conference on Object Oriented Numerics (OON-SKI), </booktitle> <year> 1994. </year>
Reference-contexts: In the first stage of SCIRun, we have concentrated on integrating the computational components that we have used to solve our own computational problems. We have recently expanded focus and are now in the process of integrating popular libraries and tools, such as Diffpack <ref> [10, 11] </ref>, SparseLib++ [12], and PETSc [13, 14] into the SCIRun environment. 6 S.G. Parker, D.W. Weinstein, C.R. Johnson 1.2.3 SCIRun the Development Environment Perhaps the most powerful facet of SCIRun is the ability to use it in the development phases of a simulation.
Reference: [11] <author> A.M. </author> <title> Bruaset and H.P. Langtangen. A comprehensive set of tools for solving partial differential equations: </title> <editor> Diffpack. In M. Daehlen and A. Tveito, editors, </editor> <booktitle> Numerical Methods and Software Tools in Industrial Mathematics. </booktitle> <publisher> Birkhauser, </publisher> <address> Oslo, </address> <year> 1997. </year>
Reference-contexts: In the first stage of SCIRun, we have concentrated on integrating the computational components that we have used to solve our own computational problems. We have recently expanded focus and are now in the process of integrating popular libraries and tools, such as Diffpack <ref> [10, 11] </ref>, SparseLib++ [12], and PETSc [13, 14] into the SCIRun environment. 6 S.G. Parker, D.W. Weinstein, C.R. Johnson 1.2.3 SCIRun the Development Environment Perhaps the most powerful facet of SCIRun is the ability to use it in the development phases of a simulation.
Reference: [12] <author> J. Dongarra, A. Lumsdaine, R. Pozo, and K. Remington. </author> <title> A sparse matrix library in C++ for high performance architectures. </title> <booktitle> In Proceedings of the Second Object Oriented Numerics Conference, </booktitle> <pages> pages 214-218, </pages> <year> 1994. </year>
Reference-contexts: In the first stage of SCIRun, we have concentrated on integrating the computational components that we have used to solve our own computational problems. We have recently expanded focus and are now in the process of integrating popular libraries and tools, such as Diffpack [10, 11], SparseLib++ <ref> [12] </ref>, and PETSc [13, 14] into the SCIRun environment. 6 S.G. Parker, D.W. Weinstein, C.R. Johnson 1.2.3 SCIRun the Development Environment Perhaps the most powerful facet of SCIRun is the ability to use it in the development phases of a simulation. <p> A few other surfaces are provided such as cylinders, spheres, and points (a degenerate surface). 1.4.4 The Matrix Class Matrices: We implement a base class called Matrix, which defines multiply and transpose multiply abstract methods. Instances of this class may be implemented with SparseLib++ <ref> [12] </ref>, or other sparse matrix packages. SCIRun also implements a compressed-row storage matrix which has been highly tuned for the architectures which we use most often.
Reference: [13] <author> W. Gropp and B. Smith. </author> <title> Scalable, extensible, and portable numerical libraries. </title> <booktitle> In Proceedings of the Scalable Parallel Libraries Conference, </booktitle> <pages> pages 87-93. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1994. </year>
Reference-contexts: We have recently expanded focus and are now in the process of integrating popular libraries and tools, such as Diffpack [10, 11], SparseLib++ [12], and PETSc <ref> [13, 14] </ref> into the SCIRun environment. 6 S.G. Parker, D.W. Weinstein, C.R. Johnson 1.2.3 SCIRun the Development Environment Perhaps the most powerful facet of SCIRun is the ability to use it in the development phases of a simulation.
Reference: [14] <institution> See the paper on PETSc in this volume. </institution>
Reference-contexts: We have recently expanded focus and are now in the process of integrating popular libraries and tools, such as Diffpack [10, 11], SparseLib++ [12], and PETSc <ref> [13, 14] </ref> into the SCIRun environment. 6 S.G. Parker, D.W. Weinstein, C.R. Johnson 1.2.3 SCIRun the Development Environment Perhaps the most powerful facet of SCIRun is the ability to use it in the development phases of a simulation.
Reference: [15] <author> A. Silberschatz, J. Peterson, and P. Galvin. </author> <title> Operating Systems Concepts. </title> <publisher> Addison-Wesley, </publisher> <address> California, </address> <year> 1991. </year>
Reference-contexts: This memory allocator can also reveal statistics about its operation. Figure 1.2 shows these statistics displayed by a running program. 1.3.2 The Multitask Library: libMultitask SCIRun derives much of its flexibility from its internal use of threads <ref> [15] </ref>. Threads allow multiple concurrent execution paths in a single program. SCIRun uses threads to facilitate parallel execution, to allow user interaction while computation is in progress, and to allow the system to change variables without interrupting a simulation.
Reference: [16] <author> D. Musser and A. Saini. </author> <title> C++ Programming with the Standard Template Library. </title> <publisher> Addison-Wesley, </publisher> <address> California, </address> <year> 1996. </year>
Reference: [17] <author> B. Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, </address> <year> 1991. </year>
Reference-contexts: A future implementation will provide a mechanism by which trivial allocators can be disabled through an environment variable reducing run time performance, but allowing the consistency checks to be made. Handles and LockingHandles Handles are a "smart pointer" mechanism for automatically maintaining reference counts in objects <ref> [17] </ref>. SCIRun uses these to facilitate the sharing of large data structures between modules. The last Handle to "let go" is responsible for deleting the object. Reference counting provides a simple form of garbage collection, without the high overhead and unpredictability associated with a full garbage collection system.
Reference: [18] <author> T.D. DeRose. </author> <title> A coordinate-free approach to geometric programming. </title> <year> 1989. </year>
Reference-contexts: destructor, as well as the methods alloc, free, realloc, get stats and audit as shown below. class Pool f Pool (); ~Pool (); Mutex lock; void* alloc (size_t size, char* ctag, int itag); void free (void* p); void* realloc (void* p, size_t size); void audit (); void get_stats (size_t statbuf <ref> [18] </ref>); int nbins (); void get_bin_stats (int bin, size_t statbuf [6]); ... Pool represents a pool of memory. At startup, there is a single pool, default pool, from which requests from malloc and new are granted. <p> The addition, subtraction, and multiplication operators have all been implemented to allow these components to be used in a convenient fashion. We have chosen to separate the concept of a Point from the concept of a Vector <ref> [18] </ref>. For the sake of efficiency, these are both specialized for 3 dimensions, with an x, y, and z component. A Point differs from a Vector only in the operations that can be performed on it. A Point indicates position in 3D space, and a Vector indicates direction.
Reference: [19] <author> W.E. Lorensen and H.E. Cline. </author> <title> Marching cubes: A high resolution 3d surface construction algorithm. </title> <journal> Computer Graphics, </journal> <volume> 21(4) </volume> <pages> 163-169, </pages> <year> 1987. </year>
Reference-contexts: While the isosurfacing algorithm could have been implemented this way, we were able to dramatically improve the speed of our algorithm by taking into account (and exploiting) the underlying structure of the data. For example, we have implemented Lorensen and Cline's Marching Cubes algorithm <ref> [19] </ref> as one option for isosurface extraction.
Reference: [20] <author> J.T. Purciful. </author> <title> Three-dimensional widgets for scientific visualization and animation. </title> <type> Master's thesis, </type> <institution> University of Utah, </institution> <year> 1995. </year> <note> 1. SCIRun 39 </note>
Reference-contexts: Weinstein, C.R. Johnson Monitor (multiple reader, single writer) lock described above in libMultiask (1.3.2). In addition to using the Salmon module for visual output, we can also use it for 3D input by allowing the user to interact with specific objects in the scene. These objects, called Widgets <ref> [20] </ref>, allow the user to intuitively augment parameters directly in the 3D scene. For example, in order to provide the starting point for a streamline advection, the user simply drags a SphereWidget around in the scene.
Reference: [21] <author> D.B. Conner, S.S. Snibbe, </author> <title> K.P. Herndon, D.C. Robbins, R.C. </title> <editor> Zeleznik, and A. van Dam. </editor> <title> Three-dimensional widgets. </title> <booktitle> In Computer Graphics (Proceedings of the 1992 Symposium on Interactive 3D Graphics), </booktitle> <pages> pages 183-188. </pages> <publisher> ACM, </publisher> <year> 1992. </year>
Reference-contexts: For example, in order to provide the starting point for a streamline advection, the user simply drags a SphereWidget around in the scene. This interaction is generally more intuitive to a user then typing in numbers or manipulating 2D sliders. This interaction becomes even more powerful when a rake <ref> [21, 22] </ref> is used to specify a line of starting points for streamline advection. 1.7.6 Other Modules We have talked about several of the Modules in SCIRun, but there are many more: * FEMError computes the upper and lower error bounds of a finite element simulation [23, 24]. * MeshRefiner uses
Reference: [22] <author> K.P. Herndon and T. Meyer. </author> <title> 3D widgets for exploratory scientific visualization. </title> <booktitle> In Proceedings of UIST `94, ACM Siggraph, </booktitle> <pages> pages 69-70. </pages> <publisher> ACM, </publisher> <month> November </month> <year> 1994. </year>
Reference-contexts: For example, in order to provide the starting point for a streamline advection, the user simply drags a SphereWidget around in the scene. This interaction is generally more intuitive to a user then typing in numbers or manipulating 2D sliders. This interaction becomes even more powerful when a rake <ref> [21, 22] </ref> is used to specify a line of starting points for streamline advection. 1.7.6 Other Modules We have talked about several of the Modules in SCIRun, but there are many more: * FEMError computes the upper and lower error bounds of a finite element simulation [23, 24]. * MeshRefiner uses <p> The streamlines are ad-vected using a 4th order Runge-Kutta technique. The user may choose between a single streamline or a row of streamlines. Adaptation parameters and step sizes are controlled via the 2D user interface, while the positions of the particle sources are controlled with 3D widgets <ref> [22] </ref>. * Salmon provides the underlying structure for viewing geometry and 3D user interaction for both viewpoint control and control of the 3D widgets described above. As the Streamline module computes streamlines, or as the Isosurface module computes isosurfaces, it will send geometry (lines, triangles or other primitives) to Salmon.
Reference: [23] <author> F. Yu and C.R. Johnson. </author> <title> An automatic adaptive refinement and dere-finement method for elliptic problems. </title> <booktitle> Proceedings of IMACS, </booktitle> <volume> 3 </volume> <pages> 1555-1557, </pages> <year> 1994. </year>
Reference-contexts: powerful when a rake [21, 22] is used to specify a line of starting points for streamline advection. 1.7.6 Other Modules We have talked about several of the Modules in SCIRun, but there are many more: * FEMError computes the upper and lower error bounds of a finite element simulation <ref> [23, 24] </ref>. * MeshRefiner uses the Error fields described above to decide where to add new nodes and remove old nodes in order to refine and derefine the mesh. * Gradient computes a vector field which is the gradient of the given scalar field. * Magnitude computes a scalar field which
Reference: [24] <author> F. Yu, Y. Livnat, and C.R. Johnson. </author> <title> An automatic adaptive refinement and derefinement method for 3D elliptic problems. </title> <note> Applied Numerical Mathematics, 1997 (to appear). </note>
Reference-contexts: powerful when a rake [21, 22] is used to specify a line of starting points for streamline advection. 1.7.6 Other Modules We have talked about several of the Modules in SCIRun, but there are many more: * FEMError computes the upper and lower error bounds of a finite element simulation <ref> [23, 24] </ref>. * MeshRefiner uses the Error fields described above to decide where to add new nodes and remove old nodes in order to refine and derefine the mesh. * Gradient computes a vector field which is the gradient of the given scalar field. * Magnitude computes a scalar field which
Reference: [25] <author> R.S. MacLeod, C.R. Johnson, and M.A. Matheson. </author> <title> Visualization tools for computational electrocardiography. </title> <booktitle> In Visualization in Biomedical Computing, </booktitle> <pages> pages 433-444, </pages> <year> 1992. </year>
Reference-contexts: Because of the complex geometry and inhomogeneous nature of the human thorax and the lack of sophisticated thorax models, most past design work on defibrillation devices has relied on animal studies. We have constructed a large scale model of the human thorax, the Utah Torso Model <ref> [6, 7, 25, 26] </ref>, for simulating both the endogenous fields of the heart and applied current sources (defibrillation devices). Using these computer models, we are also able to simulate the multitude of electrode configurations, electrode sizes, and magnitudes of defibrillation shocks. Figure 1.8 shows the results of such a simulation.
Reference: [26] <author> R.S. MacLeod, C.R. Johnson, and M.A. Matheson. </author> <title> Visualization of cardiac bioelectricity | a case study. </title> <booktitle> In IEEE Visualization `92, </booktitle> <pages> pages 411-418, </pages> <year> 1992. </year>
Reference-contexts: Because of the complex geometry and inhomogeneous nature of the human thorax and the lack of sophisticated thorax models, most past design work on defibrillation devices has relied on animal studies. We have constructed a large scale model of the human thorax, the Utah Torso Model <ref> [6, 7, 25, 26] </ref>, for simulating both the endogenous fields of the heart and applied current sources (defibrillation devices). Using these computer models, we are also able to simulate the multitude of electrode configurations, electrode sizes, and magnitudes of defibrillation shocks. Figure 1.8 shows the results of such a simulation.
Reference: [27] <author> R. Plonsey and R. C. Barr. </author> <title> Bioelectricity. </title> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: Weinstein, C.R. Johnson FIGURE 1.8. Visualization of the electrical current lines and an isovoltage surface from a simulation of a cardiac defibrillator design simulation. Mathematically, these problems are governed by variations of the generalized Poisson's equation for electrical conduction in the physical domain of the thorax or head <ref> [27] </ref>. Thus one solves (1.1) where u = are the electrostatic voltages, f = I V are the electrical current sources and is an electrical conductivity tensor.
Reference: [28] <author> B. Lerman and O. Deale. </author> <title> Relation between transcardiac and transtho-racic current during defibrillation in humans. </title> <journal> Circulation Research, </journal> <volume> 67 </volume> <pages> 1420-1426, </pages> <year> 1990. </year>
Reference-contexts: electrostatic potentials are known, one can calculate the current density J according to: J = r: (1.4) For the defibrillation problem, electrodes are either implanted internally or applied directly to the chest in order to deliver sufficient electric energy to stop the irregular heart rhythms that signify a fibrillating heart <ref> [28, 29] </ref>. 1. SCIRun 33 Mathematically, this can be posed as solving equations (1.1-1.4) with the voltage boundary condition applied on a portion of the torso boundary 2 for external defibrillation or from the surface of the defibrillation electrode (s) within the volume of the thorax for internal defibrillation.
Reference: [29] <author> M. Mirowski. </author> <title> The automatic implantable cardioverter-defibrillation: An overview. </title> <journal> Journal of the American College of Cardiology, </journal> <volume> 6 </volume> <pages> 461-466, </pages> <year> 1985. </year>
Reference-contexts: electrostatic potentials are known, one can calculate the current density J according to: J = r: (1.4) For the defibrillation problem, electrodes are either implanted internally or applied directly to the chest in order to deliver sufficient electric energy to stop the irregular heart rhythms that signify a fibrillating heart <ref> [28, 29] </ref>. 1. SCIRun 33 Mathematically, this can be posed as solving equations (1.1-1.4) with the voltage boundary condition applied on a portion of the torso boundary 2 for external defibrillation or from the surface of the defibrillation electrode (s) within the volume of the thorax for internal defibrillation.
Reference: [30] <author> D. Blilie, J. Fahy, C. Chan, M. Ahmed, and Y. Kim. </author> <title> Efficient solution of three-dimensional finite element models for defibrillation and pacing applications. </title> <booktitle> In Proceedings of the 13th Annual Conference of the IEEE Engineering in Medicine and Biology Society, </booktitle> <volume> volume 13, </volume> <pages> pages 772-773, </pages> <year> 1991. </year>
Reference-contexts: One of our goals is to allow engineers to use SCIRun to assist in determining the optimum electrode placement, size, shape, and strength of shock to terminate fibrillation by solving equations (1.1-1.4) within a detailed model of the human thorax <ref> [30, 31, 32, 33, 34] </ref>. For the neuroscience problem, the epileptic foci are represented as a set of idealized dipole sources situated in the brain.
Reference: [31] <author> S.A. Hutchinson, S. Gao, L. Ai, K.T. Ng, O.C. Deale, P.T. Cahill, and B.B. Lerman. </author> <title> Three-dimensional modeling of electrical defibrillation on a massively parallel computer. </title> <booktitle> In Computers in Cardiology, </booktitle> <pages> pages 343-346. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1992. </year> <note> 40 S.G. Parker, D.W. Weinstein, C.R. Johnson </note>
Reference-contexts: One of our goals is to allow engineers to use SCIRun to assist in determining the optimum electrode placement, size, shape, and strength of shock to terminate fibrillation by solving equations (1.1-1.4) within a detailed model of the human thorax <ref> [30, 31, 32, 33, 34] </ref>. For the neuroscience problem, the epileptic foci are represented as a set of idealized dipole sources situated in the brain.
Reference: [32] <author> S.A. Hutchinson, K.T. Ng, J.N. Shadid, and A. Nadeem. </author> <title> Electrical defibrillation optimization an automated, iterative parallel finite-element approach. </title> <journal> IEEE Trans. Biomed. Eng., </journal> <year> 1995. </year>
Reference-contexts: One of our goals is to allow engineers to use SCIRun to assist in determining the optimum electrode placement, size, shape, and strength of shock to terminate fibrillation by solving equations (1.1-1.4) within a detailed model of the human thorax <ref> [30, 31, 32, 33, 34] </ref>. For the neuroscience problem, the epileptic foci are represented as a set of idealized dipole sources situated in the brain.
Reference: [33] <author> X. Min, L. Wang, M. Hill, J. Lee, and R. Mehra. </author> <title> Detailed human thorax fem model for the cardiac defibrillation study. </title> <booktitle> In Proceedings of the 15th Annual International Conference of the IEEE Engineering in Medicine and Biology Society, </booktitle> <pages> pages 838-839, </pages> <address> Piscataway, New Jersey, 1993. </address> <publisher> IEEE Press. </publisher>
Reference-contexts: One of our goals is to allow engineers to use SCIRun to assist in determining the optimum electrode placement, size, shape, and strength of shock to terminate fibrillation by solving equations (1.1-1.4) within a detailed model of the human thorax <ref> [30, 31, 32, 33, 34] </ref>. For the neuroscience problem, the epileptic foci are represented as a set of idealized dipole sources situated in the brain.
Reference: [34] <author> J.A. Schmidt and C.R. Johnson. Defibsim: </author> <title> An interactive defibrilla-tion device design tool. </title> <booktitle> In IEEE Engineering in Medicine and Biology Society 17th Annual International Conference. </booktitle> <publisher> IEEE Press, </publisher> <year> 1995. </year>
Reference-contexts: One of our goals is to allow engineers to use SCIRun to assist in determining the optimum electrode placement, size, shape, and strength of shock to terminate fibrillation by solving equations (1.1-1.4) within a detailed model of the human thorax <ref> [30, 31, 32, 33, 34] </ref>. For the neuroscience problem, the epileptic foci are represented as a set of idealized dipole sources situated in the brain.
Reference: [35] <institution> ORIGIN2000 and ONYX2 Technical Report. Silicon Graphics, Revision 6.0, </institution> <month> October 4, </month> <year> 1996. </year>
Reference-contexts: In addition, we are continually trying to stretch SCIRun in new directions by applying it to new applications in a range of disciplines. In addition to porting SCIRun to new shared memory architectures <ref> [35] </ref>, we have ideas of how to use SCIRun in a distributed environment. SCIRun's role as a miniature operating system would be greatly expanded in such a scenario.
References-found: 35

