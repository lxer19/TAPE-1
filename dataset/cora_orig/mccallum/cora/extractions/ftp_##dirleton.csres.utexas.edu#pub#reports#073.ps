URL: ftp://dirleton.csres.utexas.edu/pub/reports/073.ps
Refering-URL: http://www.cli.com/reports/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: The Role of Automated Reasoning in Integrated System Verification Environments  
Phone: (512) 322-9951  
Author: Donald I. Good Matt Kaufmann J Strother Moore 
Note: This work was supported in part at Computational Logic, Inc., by the Defense Advanced Research Projects Agency, ARPA Order 7406. The views and conclusions contained in this document are those of the author(s) and should not be interpreted as representing the official policies, either expressed or implied, of Computational Logic, Inc., the Defense Advanced Research Projects Agency or the U.S. Government.  
Address: 1717 W. 6th St. Suite 290 Austin, Texas 78703  
Affiliation: Computational Logic Inc.  
Abstract: Technical Report 73 January, 1992 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. Kaufmann and J Strother Moore, </author> <title> ``Should We Begin a Standardization Process for Interface Logics?'', </title> <type> Tech. report CLI Technical Report 72, </type> <institution> Computational Logic, Inc., 1717 W. </institution> <address> Sixth Street, Suite 290, Austin, TX 78703, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: In our companion submission to this workshop, <ref> [1] </ref>, we discuss the possible use of interface logics in program verification. However, a general theme running throughout this paper is what we will call the Fundamental Admonition: To reason formally about an idea you must formalize the idea. <p> An alternative approach is the adoption of an interface logic. We discuss some perils of that approach in more detail in <ref> [1] </ref>. We do not believe there is much merit in adopting an ``interface logic.'' Suppose there is an interface logic and all theorem proving groups undertake to translate from a subset of it to their particular logic. <p> they have a choice? Turning from Guttman's proposal to the ``deftpi'' online discussion and the purposes of this workshop, it seems to us that the whole interface logic idea has become a sort of coat tree upon which a host of less 13 considered objectives have been hung (considered in <ref> [1] </ref>). In particular, the whole connection between interface logics and system verification is spurious. Interface logics were an attempt to solve the problem faced by formula generators. System verification is an activity that requires supreme integration of verification components across a spectrum of computational paradigms and layers of abstraction.
Reference: 2. <author> R. S. Boyer and J S. Moore, </author> <title> A Computational Logic Handbook, </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: During the period 1985-1988, we and our colleagues at CLI, working concurrently and only loosely coordinated, used the Nqthm (``Boyer-Moore'') logic <ref> [2] </ref> to formalize the semantics of a series of computational engines consisting of a gate-level register transfer machine, a machine code (``FM8502''), an assembly language (``Piton''), and a high-level language (``Micro-Gypsy''). <p> reliability of communication protocols for independently-clocked processors [8], Turing machines [9], Lambda calculus [10], a simple but usable machine code [11], a large part of the machine code for the MC68020 [12], a stack-based assembly language [5], several high level languages including Micro-Gypsy [13], Middle-Gypsy [14], the Nqthm logic itself <ref> [2] </ref>, and a small subset of Ada [15], a home-grown separation kernel (implementing multi-processing on a uniprocessor) [16], 6 a requirements model for the Mach micro-kernel, and the Unity system (a model of the Misra-Chandy language for describing nondeterministic, distributed, concurrent programs) [17]. <p> Our logic is presented in complete detail in pages 93-141 of <ref> [2] </ref>. We currently make available approximately ten megabytes of formal definitions and theorems. Each problem set is documented by a published book, journal article, PhD dissertation, technical report, or extensive comments in the file. This discipline succeeds in fostering valuable collaboration. <p> Lisp command that means ``generate the standard recognizer definition and decomposition lemmas for this module.'' The Piton environment includes the command ``disable all rules except function definitions and the primitives.'' 5.5 Effective Interaction Style We have developed a style of interacting with Nqthm that has been explained at length in <ref> [2] </ref>. The first rule is that you should have a good proof sketch in mind before you present a formula to Nqthm. This forces you to develop the basic lemma decomposition and proof structure.
Reference: 3. <author> Matt Kaufmann, </author> <title> ``A User's Manual for an Interactive Enhancement to the Boyer-Moore Theorem Prover'', </title> <type> Technical Report 19, </type> <institution> Computational Logic, Inc., </institution> <month> May </month> <year> 1988. </year>
Reference-contexts: These transducers were defined as functions in the Nqthm logic. Each transducer was proved to preserve, in a certain sense, the semantics of the appropriate computational models. These proofs were constructed with Nqthm and its interactive proof-checker, Pc-Nqthm <ref> [3] </ref>. These theorems were then combined to obtain a proof of a formula that states, roughly, that if a non-erroneous high-level program is compiled, assembled, linked, loaded, and run on the register-transfer machine, then the answer produced by that machine agrees with that specified by the high-level language.
Reference: 4. <author> W.R. Bevier, W.A. Hunt, J S. Moore, and W.D. Young, </author> <title> ``Special Issue on System Verification'', </title> <journal> Journal of Automated Reasoning, </journal> <volume> Vol. 5, No. 4, </volume> <year> 1989, </year> <pages> pp. 409-530. </pages>
Reference-contexts: This assemblage is called the ``FM8502 short stack.'' See <ref> [4] </ref> for an introduction to our approach and a discussion of each of the components. 1.3 Nqthm: A Verification Shell? As a side-effect of this work, we developed reusable libraries of lemmas in the Nqthm logic that convert the general-purpose Nqthm theorem prover into a special-purpose machine for reasoning about the <p> We offer the work William R. Bevier, of CLI, in which a ``separation kernel'' implemented in binary machine code on a uniprocessor was shown to provide multitasking and interprocess communication via message buffers <ref> [4] </ref>. Finally, we offer the work of David M. Goldschalg, formerly of CLI, who used Nqthm to formalize Misra and Chandy's Unity system for concurrent programming [17].
Reference: 5. <author> J S. Moore, ``Piton: </author> <title> A Verified Assembly Level Language'', </title> <type> Tech. report 22, </type> <institution> Computational Logic, Inc., </institution> <address> 1717 West Sixth Street, Suite 290 Austin, TX 78703, </address> <year> 1988. </year>
Reference-contexts: Indeed, we have used these ``verification environments'' independently of the short stack to verify properties of programs written in the individual languages. See for example <ref> [5] </ref>. We have also derived performance bounds on high-level programs in the sense that the proofs give us a constructive characterization of the number of microcode cycles that must be executed to carry out a 4 high-level computation. <p> gate-level description of a microprocessor [7], a model of asynchrony suitable to proving the reliability of communication protocols for independently-clocked processors [8], Turing machines [9], Lambda calculus [10], a simple but usable machine code [11], a large part of the machine code for the MC68020 [12], a stack-based assembly language <ref> [5] </ref>, several high level languages including Micro-Gypsy [13], Middle-Gypsy [14], the Nqthm logic itself [2], and a small subset of Ada [15], a home-grown separation kernel (implementing multi-processing on a uniprocessor) [16], 6 a requirements model for the Mach micro-kernel, and the Unity system (a model of the Misra-Chandy language for
Reference: 6. <author> J S. Moore, </author> <title> ``Mechanically Verified Hardware Implementing an 8-Bit Parallel IO Byzantine Agreement Processor'', </title> <type> Tech. report Technical Report 69, </type> <institution> Computational Logic, Inc., 1717 W. </institution> <address> Sixth Street, Suite 290, Austin, TX 78703, </address> <month> August </month> <year> 1991. </year>
Reference-contexts: Thus, we added to our tool kit an integrated verification environment for a subset of a commercial hardware description language, including features for analyzing fanout, gate delay, loads and drives. The reusable library for this language has since been used to verify the design of a Byzantine agreement chip <ref> [6] </ref>. Because we formalized LSI Logic's NDL we can also use commercial tools to analyze our hardware designs. We have used Nqthm to verify the logical and some performance properties of chip designs and then used LSI Logic tools to do electrical analysis, layout, schematic liberation, and fabrication. <p> We have used Nqthm to verify the logical and some performance properties of chip designs and then used LSI Logic tools to do electrical analysis, layout, schematic liberation, and fabrication. This is another example of the application of different tools to the same problem. See <ref> [6] </ref> for an example. Upon the fabrication of the FM9001, we ``ported'' the old stack proof to the new machine using Nqthm. This required modifying the linker so as to generate the binary appropriate for the new machine. <p> Nqthm has been used (or is being used) to formalize and explicate a commercial netlist language <ref> [6] </ref>, a gate-level description of a microprocessor [7], a model of asynchrony suitable to proving the reliability of communication protocols for independently-clocked processors [8], Turing machines [9], Lambda calculus [10], a simple but usable machine code [11], a large part of the machine code for the MC68020 [12], a stack-based assembly
Reference: 7. <author> Warren A. Hunt, Jr. </author> <title> and Bishop Brock , ``A Formal HDL and its use in the FM9001 Verification'', </title> <journal> Proceedings of the Royal Society, </journal> <note> 1992, to appear April 1992 </note>
Reference-contexts: Nqthm has been used (or is being used) to formalize and explicate a commercial netlist language [6], a gate-level description of a microprocessor <ref> [7] </ref>, a model of asynchrony suitable to proving the reliability of communication protocols for independently-clocked processors [8], Turing machines [9], Lambda calculus [10], a simple but usable machine code [11], a large part of the machine code for the MC68020 [12], a stack-based assembly language [5], several high level languages including
Reference: 8. <author> J S. Moore, </author> <title> ``A Formal Model of Asynchronous Communication and Its Use in Mechanically Verifying a Biphase Mark Protocol'', </title> <type> Tech. report CLI Technical Report 68, </type> <institution> Computational Logic, Inc., 1717 W. </institution> <address> Sixth Street, Suite 290, Austin, TX 78703, </address> <month> August </month> <year> 1991. </year>
Reference-contexts: Nqthm has been used (or is being used) to formalize and explicate a commercial netlist language [6], a gate-level description of a microprocessor [7], a model of asynchrony suitable to proving the reliability of communication protocols for independently-clocked processors <ref> [8] </ref>, Turing machines [9], Lambda calculus [10], a simple but usable machine code [11], a large part of the machine code for the MC68020 [12], a stack-based assembly language [5], several high level languages including Micro-Gypsy [13], Middle-Gypsy [14], the Nqthm logic itself [2], and a small subset of Ada [15],
Reference: 9. <author> R. S. Boyer and J S. Moore, </author> <title> ``A Mechanical Proof of the Turing Completeness of Pure Lisp'', in Automated Theorem Proving: After 25 Years, W.W. </title> <editor> Bledsoe and D.W. Loveland, eds., </editor> <publisher> American Mathematical Society, </publisher> <address> Providence, R.I., </address> <year> 1984, </year> <pages> pp. 133-167. </pages>
Reference-contexts: Nqthm has been used (or is being used) to formalize and explicate a commercial netlist language [6], a gate-level description of a microprocessor [7], a model of asynchrony suitable to proving the reliability of communication protocols for independently-clocked processors [8], Turing machines <ref> [9] </ref>, Lambda calculus [10], a simple but usable machine code [11], a large part of the machine code for the MC68020 [12], a stack-based assembly language [5], several high level languages including Micro-Gypsy [13], Middle-Gypsy [14], the Nqthm logic itself [2], and a small subset of Ada [15], a home-grown separation
Reference: 10. <author> N. Shankar, </author> <title> ``Towards Mechanical Metamathematics'', </title> <journal> Journal of Automated Reasoning, </journal> <volume> Vol. 1, No. 1, </volume> <year> 1985. </year>
Reference-contexts: Nqthm has been used (or is being used) to formalize and explicate a commercial netlist language [6], a gate-level description of a microprocessor [7], a model of asynchrony suitable to proving the reliability of communication protocols for independently-clocked processors [8], Turing machines [9], Lambda calculus <ref> [10] </ref>, a simple but usable machine code [11], a large part of the machine code for the MC68020 [12], a stack-based assembly language [5], several high level languages including Micro-Gypsy [13], Middle-Gypsy [14], the Nqthm logic itself [2], and a small subset of Ada [15], a home-grown separation kernel (implementing multi-processing <p> We believe that eventually such formal, mechanized metalogical embeddings will permit automated reasoning systems to make the kind of intralogical jumps so common in everyday mathematics. 10 theorem <ref> [10] </ref> and massaged it so that Coq can reproduce the proof. Similarly, Hantoa Zhang and Xin Hua, of the University of Iowa, have massaged our Nqthm proof script for the finite version of Ramsey's theorem [20] into a form suitable for successful processing by the RRL [21].
Reference: 11. <author> W.A. Hunt, ``FM8501: </author> <title> A Verified Microprocessor'', </title> <type> PhD Thesis, </type> <institution> University of Texas at Austin, </institution> <month> December </month> <year> 1985, </year> <note> Also available through Computational Logic, </note> <institution> Inc., </institution> <address> Suite 290, 1717 West Sixth Street, Austin, TX 78703. </address>
Reference-contexts: been used (or is being used) to formalize and explicate a commercial netlist language [6], a gate-level description of a microprocessor [7], a model of asynchrony suitable to proving the reliability of communication protocols for independently-clocked processors [8], Turing machines [9], Lambda calculus [10], a simple but usable machine code <ref> [11] </ref>, a large part of the machine code for the MC68020 [12], a stack-based assembly language [5], several high level languages including Micro-Gypsy [13], Middle-Gypsy [14], the Nqthm logic itself [2], and a small subset of Ada [15], a home-grown separation kernel (implementing multi-processing on a uniprocessor) [16], 6 a requirements
Reference: 12. <author> R.S. Boyer and Y. Yu, </author> <title> ``Automated Correctness Proofs of Machine Code Programs for a Commercial Microprocessor'', </title> <type> Tech. report TR-91-33, </type> <institution> Computer Sciences Department, University of Texas, Austin, </institution> <month> November </month> <year> 1991. </year>
Reference-contexts: commercial netlist language [6], a gate-level description of a microprocessor [7], a model of asynchrony suitable to proving the reliability of communication protocols for independently-clocked processors [8], Turing machines [9], Lambda calculus [10], a simple but usable machine code [11], a large part of the machine code for the MC68020 <ref> [12] </ref>, a stack-based assembly language [5], several high level languages including Micro-Gypsy [13], Middle-Gypsy [14], the Nqthm logic itself [2], and a small subset of Ada [15], a home-grown separation kernel (implementing multi-processing on a uniprocessor) [16], 6 a requirements model for the Mach micro-kernel, and the Unity system (a model <p> The Gnu C compiler and the Verdix Ada compiler were used. Among the programs so verified are Hoare's in situ Quick Sort, binary search, and several C programs from the widely used Berkeley string processing library. See <ref> [12] </ref> for details. To the best of our knowledge, this is the first example of the post hoc verification of commericially produced software for a commercially produced microprocessor. <p> implements a computing machine best described via four successive layers of abstraction (user, two-valued logic, four-valued logic, and netlist); the Piton assembler/linker involves hundreds of functions implementing a transducer described in four successive layers (user, resource model, relocatable symbolic machine code, and absolute binary). 16 We offer Yu's MC68020 work <ref> [12] </ref> as a significant example. We offer the work William R. Bevier, of CLI, in which a ``separation kernel'' implemented in binary machine code on a uniprocessor was shown to provide multitasking and interprocess communication via message buffers [4]. Finally, we offer the work of David M.
Reference: 13. <author> W. Young, </author> <title> ``A Verified Code-Generator for a Subset of Gypsy'', </title> <type> PhD Thesis, </type> <institution> University of Texas at Austin, </institution> <year> 1988, </year> <note> Also available through Computational Logic, </note> <institution> Inc., </institution> <address> Suite 290, 1717 West Sixth Street, Austin, TX 78703. </address>
Reference-contexts: model of asynchrony suitable to proving the reliability of communication protocols for independently-clocked processors [8], Turing machines [9], Lambda calculus [10], a simple but usable machine code [11], a large part of the machine code for the MC68020 [12], a stack-based assembly language [5], several high level languages including Micro-Gypsy <ref> [13] </ref>, Middle-Gypsy [14], the Nqthm logic itself [2], and a small subset of Ada [15], a home-grown separation kernel (implementing multi-processing on a uniprocessor) [16], 6 a requirements model for the Mach micro-kernel, and the Unity system (a model of the Misra-Chandy language for describing nondeterministic, distributed, concurrent programs) [17].
Reference: 14. <author> Donald I. Good, Ann E. Siebert, William D. Young, </author> <title> ``Middle Gypsy 2.05 Definition'', </title> <type> Tech. report CLI Technical Report 59, </type> <institution> Computational Logic, Inc., 1717 W. </institution> <address> Sixth Street, Suite 290, Austin, TX 78703, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: asynchrony suitable to proving the reliability of communication protocols for independently-clocked processors [8], Turing machines [9], Lambda calculus [10], a simple but usable machine code [11], a large part of the machine code for the MC68020 [12], a stack-based assembly language [5], several high level languages including Micro-Gypsy [13], Middle-Gypsy <ref> [14] </ref>, the Nqthm logic itself [2], and a small subset of Ada [15], a home-grown separation kernel (implementing multi-processing on a uniprocessor) [16], 6 a requirements model for the Mach micro-kernel, and the Unity system (a model of the Misra-Chandy language for describing nondeterministic, distributed, concurrent programs) [17].
Reference: 15. <author> Michael K. Smith, Dan Craigen, and Mark Saaltink, </author> <title> ``The nanoAVA Definition'', </title> <type> Tech. report CLI Technical Report 21, </type> <institution> Computational Logic, Inc., 1717 W. </institution> <address> Sixth Street, Suite 290, Austin, TX 78703, </address> <month> May </month> <year> 1988. </year>
Reference-contexts: [8], Turing machines [9], Lambda calculus [10], a simple but usable machine code [11], a large part of the machine code for the MC68020 [12], a stack-based assembly language [5], several high level languages including Micro-Gypsy [13], Middle-Gypsy [14], the Nqthm logic itself [2], and a small subset of Ada <ref> [15] </ref>, a home-grown separation kernel (implementing multi-processing on a uniprocessor) [16], 6 a requirements model for the Mach micro-kernel, and the Unity system (a model of the Misra-Chandy language for describing nondeterministic, distributed, concurrent programs) [17].
Reference: 16. <author> W. Bevier, </author> <title> ``A Verified Operating System Kernel'', </title> <type> PhD Thesis, </type> <institution> University of Texas at Austin, </institution> <year> 1987, </year> <note> Also available through Computational Logic, </note> <institution> Inc., </institution> <address> Suite 290, 1717 West Sixth Street, Austin, TX 78703. </address>
Reference-contexts: usable machine code [11], a large part of the machine code for the MC68020 [12], a stack-based assembly language [5], several high level languages including Micro-Gypsy [13], Middle-Gypsy [14], the Nqthm logic itself [2], and a small subset of Ada [15], a home-grown separation kernel (implementing multi-processing on a uniprocessor) <ref> [16] </ref>, 6 a requirements model for the Mach micro-kernel, and the Unity system (a model of the Misra-Chandy language for describing nondeterministic, distributed, concurrent programs) [17].
Reference: 17. <author> D.M. Goldschlag, </author> <title> ``Mechanizing Unity'', in Programming Concepts and Methods, </title> <editor> M. Broy and C. B. Jones, eds., </editor> <publisher> North Holland, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: Micro-Gypsy [13], Middle-Gypsy [14], the Nqthm logic itself [2], and a small subset of Ada [15], a home-grown separation kernel (implementing multi-processing on a uniprocessor) [16], 6 a requirements model for the Mach micro-kernel, and the Unity system (a model of the Misra-Chandy language for describing nondeterministic, distributed, concurrent programs) <ref> [17] </ref>. All of these computational models are integrated in the sense that we can formally reason about their interactions. (See however the footnote about ``Nthm'' on page 9.) This is not to say that Nqthm's logic or its proof engine are ideal; far from it. <p> Throughout Nqthm's 20 year evolution it has constantly been applied, both by its developers and others. We believe this ``applications driven'' methodology is one of the keys to Nqthm's success and we recommend it to the developers of other mechanized logics. For example, Goldschlag's work on Unity <ref> [17] </ref> was an important driving force in recent major extensions to Nqthm: the provision of two new derived rules of inference permitting ``definition by constraint'' and ``functional instantiation'' (an apparently higher order act) [33] and the nonconstructive allowance for full first-order quantification in function definitions [34]. <p> Finally, we offer the work of David M. Goldschalg, formerly of CLI, who used Nqthm to formalize Misra and Chandy's Unity system for concurrent programming <ref> [17] </ref>. He then developed a reusable library of proof rules, reproducing those in Misra and Chandy's book [36], causing Nqthm to ``become'' a verification engine for Unity.
Reference: 18. <author> Motorola, Inc., </author> <title> MC68020 32-bit Microprocessor User's Manual, </title> <year> 1989. </year>
Reference-contexts: Semantics are formalized for approximately 80 instruction opcodes. Breaking the instructions down into the ten categories of the MC68020 user's manual <ref> [18] </ref>, Yu formalizes all 9 of the data movement instructions, 27 of the 28 integer arithmetic instructions (CMP2 is excluded), all 9 of the logical operations, all 9 of the shift and rotate instructions, all 4 of the bit manipulation instructions, all 8 of the bit field instructions, none of the
Reference: 19. <author> N. Shankar, </author> <title> ``Proof Checking Metamathematics'', </title> <type> PhD Thesis, </type> <institution> University of Texas at Austin, </institution> <note> 19 1986, Also available through Computational Logic, </note> <institution> Inc., </institution> <address> Suite 290, 1717 West Sixth Street, Austin, TX 78703. </address>
Reference-contexts: We also believe that ultimately several different logical systems will be unified by a single formal metalogic. We have already seen this in <ref> [19] </ref>, where propositional calculus, Shoenfield's first-order logic, Church's lambda calculus, and Cohen's hereditarily finite set theory Z2 are all formalized with Nqthm's logic as the metalogic. <p> These layers often include general purpose computing machines or languages. In this section we simply name some significant applications of Nqthm in system development. Our first example is an unusual one: We assert that the formal metamathematical work done by Shankar in <ref> [19] </ref> is an excellent example of system verification. The work involves mind-boggling levels of abstraction and several equivalent computational models. In the work, Shankar uses Nqthm's logic as a metalanguage to formalize propositional calculus, Shoenfield's first-order logic, Church's lambda calculus, and Cohen's hereditarily finite set theory Z2.
Reference: 20. <author> Kaufmann, Matt J. and David Basin, </author> <title> ``The Boyer-Moore Prover and Nuprl: An Experimental Comparison'', </title> <booktitle> Proceedings of Workshop for Basic Research Action, Logical Frameworks, Antibes, </booktitle> <address> France. </address> <note> Also published as CLI Technical Report 58 </note>
Reference-contexts: Similarly, Hantoa Zhang and Xin Hua, of the University of Iowa, have massaged our Nqthm proof script for the finite version of Ramsey's theorem <ref> [20] </ref> into a form suitable for successful processing by the RRL [21]. These are significant examples of data exchange at the research level. In addition, it is easy for us to ``farm out'' the non-inductive parts of our proofs out to a predicate-calculus proof engine.
Reference: 21. <author> D. Kapur and H. Zhang, ``RRL: </author> <title> A Rewrite Rule Laboratory -- A User's Manual'', </title> <type> Tech. report, </type> <institution> General Electric Research and Development Center, Schenectady, </institution> <address> N.Y., </address> <month> June </month> <year> 1987. </year>
Reference-contexts: Similarly, Hantoa Zhang and Xin Hua, of the University of Iowa, have massaged our Nqthm proof script for the finite version of Ramsey's theorem [20] into a form suitable for successful processing by the RRL <ref> [21] </ref>. These are significant examples of data exchange at the research level. In addition, it is easy for us to ``farm out'' the non-inductive parts of our proofs out to a predicate-calculus proof engine. <p> Bundy reports that our heuristic algorithms search the space and generate detailed proof plans about ten times faster than the formal proof checker can check them. Our algorithms or methods contributed to the design of such diverse systems as RRL <ref> [21] </ref>, NEVER [25], and INRIA's Coq. Clear documentation essentially allows the exchange of components even in the face of vast differences in the underlying logical systems and implementation languages. We also have much experience with adapting components written by others.
Reference: 22. <author> J. Rushby and F. von Henke, </author> <title> ``Formal Verification of the Interactive Convergence Clock Synchronization Algorithm using EHDM'', </title> <type> Tech. report, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA 94025, </address> <month> January </month> <year> 1989, </year> <note> Draft </note>
Reference-contexts: We have also been on the receiving end of such scientific exchanges. For example, Bill Young of CLI has taken the EHDM proof of the interactive convergence clock synchronization algorithm by Rushby and von Henke <ref> [22] </ref> and converted it to a successfully processed Nqthm proof script [23]. This script contains 200 definitions and theorems (not counting those in our standard rational arithmetic library) and represents another significant example of data exchange. 3. Exchanging Code 3.
Reference: 23. <author> W.D. Young, </author> <title> ``Verifying the Interactive Convergence Clock Synchronization Algorithm Using the Boyer-Moore Theorem Prover '', Internal Note 199, Computational Logic, </title> <publisher> Inc., 1717 W. </publisher> <address> Sixth Street, Suite 290, Austin, TX 78703, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: We have also been on the receiving end of such scientific exchanges. For example, Bill Young of CLI has taken the EHDM proof of the interactive convergence clock synchronization algorithm by Rushby and von Henke [22] and converted it to a successfully processed Nqthm proof script <ref> [23] </ref>. This script contains 200 definitions and theorems (not counting those in our standard rational arithmetic library) and represents another significant example of data exchange. 3. Exchanging Code 3. Methods for promoting the interchangeability of component parts of automated reasoning tools.
Reference: 24. <author> R. S. Boyer and J S. Moore, </author> <title> A Computational Logic, </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: Unless we wish to standardize on a single implementation language, we believe that interchangeability of components is best achieved via clearly written descriptions of the algorithms and representations. Such methods actually work. Our system is documented so thoroughly in the book <ref> [24] </ref> that it has been reprogrammed from scratch in such remote sites as Amherst, Massachusettes and Bejing, China. Our algorithms are at the heart of Alan Bundy's Oyster/Clam project (Edinburgh, Scotland) where they are used to guide the construction of proofs in a Martin Lof-style type theory.
Reference: 25. <author> B. Pase and S. Kromodimoeljo, </author> <title> ``m-NEVER User's Manual'', </title> <type> Tech. report TR-87-5420-13, I.P. </type> <institution> Sharpe Associates Ltd., </institution> <address> 265 Carling Ave., Ottawa Canada, </address> <month> November </month> <year> 1987. </year>
Reference-contexts: Bundy reports that our heuristic algorithms search the space and generate detailed proof plans about ten times faster than the formal proof checker can check them. Our algorithms or methods contributed to the design of such diverse systems as RRL [21], NEVER <ref> [25] </ref>, and INRIA's Coq. Clear documentation essentially allows the exchange of components even in the face of vast differences in the underlying logical systems and implementation languages. We also have much experience with adapting components written by others.
Reference: 26. <author> R. S. Boyer and J S. Moore, </author> <title> ``Integrating Decision Procedures into Heuristic Theorem Provers: A Case Study with Linear Arithmetic'', </title> <booktitle> in Machine Intelligence 11, </booktitle> <publisher> Oxford University Press, </publisher> <year> 1988, </year> <note> Also available through Computational Logic, </note> <institution> Inc., </institution> <address> Suite 290, 1717 West Sixth Street, Austin, TX 78703. </address>
Reference-contexts: Clear documentation essentially allows the exchange of components even in the face of vast differences in the underlying logical systems and implementation languages. We also have much experience with adapting components written by others. It has led us to understand what we called the ``open black box'' problem. In <ref> [26] </ref> we describe a four-year effort to encorporate linear arithmetic decision procedures into Nqthm. We studied and implemented procedures by Hodes [27], Bledsoe [28], Shostak [29], and Nelson and Oppen [30].
Reference: 27. <author> L. Hodes, </author> <title> ``Solving Problems by Formula Manipulation'', </title> <booktitle> Proc. Second Inter. Joint Conf. on Art. Intell., The British Computer Society, </booktitle> <year> 1971, </year> <pages> pp. 553-559. </pages>
Reference-contexts: We also have much experience with adapting components written by others. It has led us to understand what we called the ``open black box'' problem. In [26] we describe a four-year effort to encorporate linear arithmetic decision procedures into Nqthm. We studied and implemented procedures by Hodes <ref> [27] </ref>, Bledsoe [28], Shostak [29], and Nelson and Oppen [30]. The primary benefit promised by the inclusion of a decision procedure in a general-purpose setting is to relieve the general-purpose device of the need to explore the search space attributable to the decidable fragment.
Reference: 28. <author> W. W. Bledsoe, </author> <title> ``A New Method for Proving Certain Presburger Formulas'', Advance Papers, </title> <booktitle> Fourth Int. Joint Conf. on Art. Intell., </booktitle> <address> Tbilisi, Georgia, U.S.S.R., </address> <month> September </month> <year> 1975, </year> <pages> pp. 15-20. </pages>
Reference-contexts: We also have much experience with adapting components written by others. It has led us to understand what we called the ``open black box'' problem. In [26] we describe a four-year effort to encorporate linear arithmetic decision procedures into Nqthm. We studied and implemented procedures by Hodes [27], Bledsoe <ref> [28] </ref>, Shostak [29], and Nelson and Oppen [30]. The primary benefit promised by the inclusion of a decision procedure in a general-purpose setting is to relieve the general-purpose device of the need to explore the search space attributable to the decidable fragment.
Reference: 29. <author> R. Shostak, </author> <title> ``On the SUP-INF Method for Provign Presburger Formulas'', </title> <journal> JACM, </journal> <volume> Vol. 24, No. 4, </volume> <year> 1977, </year> <pages> pp. 529-543. </pages>
Reference-contexts: It has led us to understand what we called the ``open black box'' problem. In [26] we describe a four-year effort to encorporate linear arithmetic decision procedures into Nqthm. We studied and implemented procedures by Hodes [27], Bledsoe [28], Shostak <ref> [29] </ref>, and Nelson and Oppen [30]. The primary benefit promised by the inclusion of a decision procedure in a general-purpose setting is to relieve the general-purpose device of the need to explore the search space attributable to the decidable fragment.
Reference: 30. <author> G. Nelson and D. C. Oppen, </author> <title> ``Simplification by Cooperating Decision Procedures'', </title> <journal> ACM Transactions of Programming Languages, </journal> <volume> Vol. 1, No. 2, </volume> <year> 1979, </year> <pages> pp. 245-257. </pages>
Reference-contexts: It has led us to understand what we called the ``open black box'' problem. In [26] we describe a four-year effort to encorporate linear arithmetic decision procedures into Nqthm. We studied and implemented procedures by Hodes [27], Bledsoe [28], Shostak [29], and Nelson and Oppen <ref> [30] </ref>. The primary benefit promised by the inclusion of a decision procedure in a general-purpose setting is to relieve the general-purpose device of the need to explore the search space attributable to the decidable fragment.
Reference: 31. <author> Randal E. Bryant, </author> <title> ``Graph-Based Algorithms for Boolean Function Manipulation'', </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. C-35, No. 8, </volume> <month> August </month> <year> 1986, </year> <pages> pp. </pages> <month> 677--691. </month>
Reference-contexts: More recently, we have studied the integration of a binary decision diagram (BDD) algorithm <ref> [31] </ref> into Nqthm. While our work on this topic is still young, the opinions expressed above have been validated by our experiments so far.
Reference: 32. <author> Joshua D. Guttman, </author> <title> ``A Proposed Interface Logic for Verification Environments'', </title> <type> Tech. report M91-19, </type> <institution> The MITRE Corporation, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: Interface Logics 4. Establishing a formal basis for exchanging information among automated reasoning tools and between formal specification processing tools and automated theorem provers. The ``formal basis'' mentioned above has otherwise become known as an ``interface logic.'' In <ref> [32] </ref>, Josh Guttman informally calls an interface logic a lingua franca for verification (page 2 of [32]). <p> The ``formal basis'' mentioned above has otherwise become known as an ``interface logic.'' In <ref> [32] </ref>, Josh Guttman informally calls an interface logic a lingua franca for verification (page 2 of [32]). However in the introduction of the paper Guttman summarizes the most attractive benefits of an interface logic: The goal of this report is to advocate the idea of an interface logic for verification environments.
Reference: 33. <author> R.S. Boyer, D. Goldschlag, M. Kaufmann, J S. Moore, </author> <title> ``Functional Instantiation in First Order Logic'', </title> <booktitle> in Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, </booktitle> <editor> V. Lifschitz, ed., </editor> <publisher> Academic Press, </publisher> <year> 1991, </year> <pages> pp. 7-26. </pages>
Reference-contexts: For example, Goldschlag's work on Unity [17] was an important driving force in recent major extensions to Nqthm: the provision of two new derived rules of inference permitting ``definition by constraint'' and ``functional instantiation'' (an apparently higher order act) <ref> [33] </ref> and the nonconstructive allowance for full first-order quantification in function definitions [34]. In the case of Nqthm, the tension has created a rather weak logic which is balanced somewhat by the power of its proof techniques.
Reference: 34. <author> Matt Kaufmann, </author> <title> ``An Extension of the Boyer-Moore Theorem Prover to Support First-Order Quantification'', </title> <type> Tech. report CLI Technical Report 43, </type> <institution> Computational Logic, Inc., 1717 W. </institution> <address> Sixth Street, Suite 290, Austin, TX 78703, </address> <month> May </month> <year> 1989, </year> <note> To appear in J. of Automated Reasoning </note>
Reference-contexts: example, Goldschlag's work on Unity [17] was an important driving force in recent major extensions to Nqthm: the provision of two new derived rules of inference permitting ``definition by constraint'' and ``functional instantiation'' (an apparently higher order act) [33] and the nonconstructive allowance for full first-order quantification in function definitions <ref> [34] </ref>. In the case of Nqthm, the tension has created a rather weak logic which is balanced somewhat by the power of its proof techniques. The weakness of the logic works in Nqthm's favor for people who stay the course.
Reference: 35. <author> M. Gordon, </author> <title> ``HOL: A Proof Generating System for Higher-Order Logic'', </title> <type> Tech. report 103, </type> <institution> University of Cambridge, Computer Laboratory, </institution> <year> 1987. </year>
Reference-contexts: It should be noted that the explicated strategy worked partly because of the experience of the user who designed it. Less experienced users might have described a less powerful strategy and made the port more painful. ``Tactics'' as provided, for example, in HOL <ref> [35] </ref> offer many of the same advantages and disadvantages. The Nqthm proof checker, Pc-Nqthm, provides users direct control over the construction of a proof of an Nqthm theorem.
Reference: 36. <author> K.M. Chandy and J. Misra, </author> <title> Parallel Program Design: A Foundation, </title> <publisher> Addison Wesley, </publisher> <address> Massachusetts, </address> <year> 1988. </year>
Reference-contexts: Finally, we offer the work of David M. Goldschalg, formerly of CLI, who used Nqthm to formalize Misra and Chandy's Unity system for concurrent programming [17]. He then developed a reusable library of proof rules, reproducing those in Misra and Chandy's book <ref> [36] </ref>, causing Nqthm to ``become'' a verification engine for Unity.
Reference: 37. <author> J. R. Shoenfield, </author> <title> Mathematical Logic, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Ma., </address> <year> 1967. </year>
Reference-contexts: The cost of system verification will drop substantially when there are a 5 It is obtained roughly by throwing out the quantifiers from first order predicate calculus with equality and induction and adding a principle of recursive definition based on Shoenfield's <ref> [37] </ref>. 17 number of verified systems and computational models upon which to build. The biggest obstacle to the successful application of verification technology to commercial systems is the lack of money and trained technicians. The key to the industrialization of formal verification is cost effectiveness.
Reference: 38. <author> Bill Bevier, </author> <title> ``A Library for Hardware Verification'', Internal Note 57, Computational Logic, </title> <publisher> Inc., 1717 W. </publisher> <address> Sixth Street, Suite 290, Austin, TX 78703, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: Our belief that this approach can be ``scaled'' into industrial application is based on the fact that explicated computational models and shared, reusable theories make system verification easier. As time goes on, less work is involved in creating the models because so many components are readily available. <ref> [38, 39, 40] </ref> Less work is involved in proving new theorems because the strategic work done to prove old ones is often directly applicable. This is especially true in the context of ``minor'' modifications to previously verified components.
Reference: 39. <author> Matt Kaufmann, </author> <title> ``An Integer Library for NQTHM'', Internal Note 182, Computational Logic, </title> <publisher> 20 Inc., 1717 W. </publisher> <address> Sixth Street, Suite 290, Austin, TX 78703, </address> <year> 1990. </year>
Reference-contexts: Our belief that this approach can be ``scaled'' into industrial application is based on the fact that explicated computational models and shared, reusable theories make system verification easier. As time goes on, less work is involved in creating the models because so many components are readily available. <ref> [38, 39, 40] </ref> Less work is involved in proving new theorems because the strategic work done to prove old ones is often directly applicable. This is especially true in the context of ``minor'' modifications to previously verified components.
Reference: 40. <author> Matthew Wilding, </author> <title> ``Events for a Reproof of the Search Theorems Using a New Rationals Library'', Internal Note 223, Computational Logic, </title> <publisher> Inc., 1717 W. </publisher> <address> Sixth Street, Suite 290, Austin, TX 78703, </address> <month> March </month> <year> 1991. </year> <title> i Table of Contents Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 </title>
Reference-contexts: Our belief that this approach can be ``scaled'' into industrial application is based on the fact that explicated computational models and shared, reusable theories make system verification easier. As time goes on, less work is involved in creating the models because so many components are readily available. <ref> [38, 39, 40] </ref> Less work is involved in proving new theorems because the strategic work done to prove old ones is often directly applicable. This is especially true in the context of ``minor'' modifications to previously verified components.

Reference: 2. <institution> Exchanging Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 </institution>
Reference-contexts: During the period 1985-1988, we and our colleagues at CLI, working concurrently and only loosely coordinated, used the Nqthm (``Boyer-Moore'') logic <ref> [2] </ref> to formalize the semantics of a series of computational engines consisting of a gate-level register transfer machine, a machine code (``FM8502''), an assembly language (``Piton''), and a high-level language (``Micro-Gypsy''). <p> reliability of communication protocols for independently-clocked processors [8], Turing machines [9], Lambda calculus [10], a simple but usable machine code [11], a large part of the machine code for the MC68020 [12], a stack-based assembly language [5], several high level languages including Micro-Gypsy [13], Middle-Gypsy [14], the Nqthm logic itself <ref> [2] </ref>, and a small subset of Ada [15], a home-grown separation kernel (implementing multi-processing on a uniprocessor) [16], 6 a requirements model for the Mach micro-kernel, and the Unity system (a model of the Misra-Chandy language for describing nondeterministic, distributed, concurrent programs) [17]. <p> Our logic is presented in complete detail in pages 93-141 of <ref> [2] </ref>. We currently make available approximately ten megabytes of formal definitions and theorems. Each problem set is documented by a published book, journal article, PhD dissertation, technical report, or extensive comments in the file. This discipline succeeds in fostering valuable collaboration. <p> Lisp command that means ``generate the standard recognizer definition and decomposition lemmas for this module.'' The Piton environment includes the command ``disable all rules except function definitions and the primitives.'' 5.5 Effective Interaction Style We have developed a style of interacting with Nqthm that has been explained at length in <ref> [2] </ref>. The first rule is that you should have a good proof sketch in mind before you present a formula to Nqthm. This forces you to develop the basic lemma decomposition and proof structure.
Reference: 3. <institution> Exchanging Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 </institution>
Reference-contexts: These transducers were defined as functions in the Nqthm logic. Each transducer was proved to preserve, in a certain sense, the semantics of the appropriate computational models. These proofs were constructed with Nqthm and its interactive proof-checker, Pc-Nqthm <ref> [3] </ref>. These theorems were then combined to obtain a proof of a formula that states, roughly, that if a non-erroneous high-level program is compiled, assembled, linked, loaded, and run on the register-transfer machine, then the answer produced by that machine agrees with that specified by the high-level language.
Reference: 4. <institution> Interface Logics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 </institution>
Reference-contexts: This assemblage is called the ``FM8502 short stack.'' See <ref> [4] </ref> for an introduction to our approach and a discussion of each of the components. 1.3 Nqthm: A Verification Shell? As a side-effect of this work, we developed reusable libraries of lemmas in the Nqthm logic that convert the general-purpose Nqthm theorem prover into a special-purpose machine for reasoning about the <p> We offer the work William R. Bevier, of CLI, in which a ``separation kernel'' implemented in binary machine code on a uniprocessor was shown to provide multitasking and interprocess communication via message buffers <ref> [4] </ref>. Finally, we offer the work of David M. Goldschalg, formerly of CLI, who used Nqthm to formalize Misra and Chandy's Unity system for concurrent programming [17].

Reference: 6. <institution> Significant System Verification Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 </institution>
Reference-contexts: Thus, we added to our tool kit an integrated verification environment for a subset of a commercial hardware description language, including features for analyzing fanout, gate delay, loads and drives. The reusable library for this language has since been used to verify the design of a Byzantine agreement chip <ref> [6] </ref>. Because we formalized LSI Logic's NDL we can also use commercial tools to analyze our hardware designs. We have used Nqthm to verify the logical and some performance properties of chip designs and then used LSI Logic tools to do electrical analysis, layout, schematic liberation, and fabrication. <p> We have used Nqthm to verify the logical and some performance properties of chip designs and then used LSI Logic tools to do electrical analysis, layout, schematic liberation, and fabrication. This is another example of the application of different tools to the same problem. See <ref> [6] </ref> for an example. Upon the fabrication of the FM9001, we ``ported'' the old stack proof to the new machine using Nqthm. This required modifying the linker so as to generate the binary appropriate for the new machine. <p> Nqthm has been used (or is being used) to formalize and explicate a commercial netlist language <ref> [6] </ref>, a gate-level description of a microprocessor [7], a model of asynchrony suitable to proving the reliability of communication protocols for independently-clocked processors [8], Turing machines [9], Lambda calculus [10], a simple but usable machine code [11], a large part of the machine code for the MC68020 [12], a stack-based assembly
Reference: 7. <institution> Verification as an Engineering Exercise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 </institution>
Reference-contexts: Nqthm has been used (or is being used) to formalize and explicate a commercial netlist language [6], a gate-level description of a microprocessor <ref> [7] </ref>, a model of asynchrony suitable to proving the reliability of communication protocols for independently-clocked processors [8], Turing machines [9], Lambda calculus [10], a simple but usable machine code [11], a large part of the machine code for the MC68020 [12], a stack-based assembly language [5], several high level languages including
Reference: 8. <institution> Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 </institution>
Reference-contexts: Nqthm has been used (or is being used) to formalize and explicate a commercial netlist language [6], a gate-level description of a microprocessor [7], a model of asynchrony suitable to proving the reliability of communication protocols for independently-clocked processors <ref> [8] </ref>, Turing machines [9], Lambda calculus [10], a simple but usable machine code [11], a large part of the machine code for the MC68020 [12], a stack-based assembly language [5], several high level languages including Micro-Gypsy [13], Middle-Gypsy [14], the Nqthm logic itself [2], and a small subset of Ada [15],
References-found: 46

