URL: http://theory.lcs.mit.edu/tds/papers/Lynch/PODC87.ps
Refering-URL: http://theory.lcs.mit.edu/tds/papers/Lynch/PODC87.html
Root-URL: 
Title: Hierarchical Correctness Proofs for Distributed Algorithms  
Author: Nancy A. Lynch and Mark R. Tuttle 
Address: Cambridge, Massachusetts 02139  
Affiliation: Laboratory for Computer Science Massachusetts Institute of Technology  
Abstract: We introduce the input-output automaton, a simple but powerful model of computation in asynchronous distributed networks. With this model we are able to construct modular, hierarchical correctness proofs for distributed algorithms. We define this model, and give an interesting example of how it can be used to construct such proofs. 
Abstract-found: 1
Intro-found: 1
Reference: [AS87] <author> Bowen L. Alpern and Fred B. Schneider. </author> <title> Proving boolean combinations of deterministic properties. </title> <booktitle> In Proceedings of the 2nd IEEE Symposium on Logic in Computer Science, </booktitle> <month> June </month> <year> 1987. </year>
Reference-contexts: clear that most verification methods, such as the Hoare-logic of Owicki and Gries in [OG76], the use of invariant assertions advocated by Lamport and Schneider in [LS84b], the temporal logic of Manna and Pnueli in [MP81b] and [MP81a], and the method of deriving proof obligations of Alpern and Schnei-der in <ref> [AS87] </ref>, can be used to verify the correctness of algorithms expressed in terms of input-output automata. We do not fix on a particular methodology for reasoning about the behavior of individual automata.
Reference: [BKP84] <author> Howard Barringer, Ruurd Kuiper, and Amir Pnueli. </author> <title> Now you may compose temporal logic specifications. </title> <booktitle> In Proceedings of the 16th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 51-63. </pages> <publisher> ACM, </publisher> <month> April </month> <year> 1984. </year>
Reference-contexts: Output (the granting of the resource) occurs only under the control of the arbiter. This distinction between internal and external events is extremely important if reasoning about the system is to be decomposed into reasoning about system components in isolation, as was recognized by Barringer, Kuiper, and Pnueli in <ref> [BKP84] </ref>. Furthermore, it is clear that satisfaction of liveness conditions such as the no lockout condition requires that the arbiter be given "fair turns" to produce output, rather than simply being overwhelmed by a flood of input. <p> through a state of S, eventually either the execution passes through a state of T or an action from is performed. 1 More formally, e satisfies the condition S ,! (T; ) if, whenever a i 2 S, 1 This condition may also be expressed in the temporal logic of <ref> [BKP84] </ref>. either a j 2 T for some j i or j 2 for some j &gt; i. As a notational convenience, we will denote the condition S ,! (T; ) by S ,! when the set T is empty.
Reference: [Blo87] <author> Bard Bloom. </author> <title> Constructing two-writer atomic registers. </title> <booktitle> In progress, </booktitle> <year> 1987. </year>
Reference-contexts: Examples of the use of input-output automata differing from the arbiter example discussed in this work include concurrency control algorithms (see [LM86], [HLMW87], [FLMW87], and [GL87]), mutual exclusion algorithms (see [Wel87]), hardware register algorithms (see <ref> [Blo87] </ref>), and dataflow computation (see [Lyn86]). In many of these papers the model has been found to be especially helpful when attempting to identify the interface between system components, and discovering a system's natural decomposition.
Reference: [FLMW87] <author> Alan Fekete, Nancy Lynch, Michael Mer-ritt, and William Weihl. </author> <title> Nested transactions and read/write locking. </title> <booktitle> In Proceedings of the Symposium on Principles of Database Systems, </booktitle> <year> 1987. </year> <note> To appear. </note>
Reference-contexts: Examples of the use of input-output automata differing from the arbiter example discussed in this work include concurrency control algorithms (see [LM86], [HLMW87], <ref> [FLMW87] </ref>, and [GL87]), mutual exclusion algorithms (see [Wel87]), hardware register algorithms (see [Blo87]), and dataflow computation (see [Lyn86]). In many of these papers the model has been found to be especially helpful when attempting to identify the interface between system components, and discovering a system's natural decomposition.
Reference: [FLS87] <author> Alan Fekete, Nancy A. Lynch, and Liuba Shrira. </author> <title> A modular proof of correctness for a network synchronizer. </title> <booktitle> In Proceedings of the 2nd International Workshop on Distributed Algorithms, </booktitle> <month> July </month> <year> 1987. </year>
Reference: [Fra86] <author> Nissim Francez. </author> <title> Fairness. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1986. </year>
Reference-contexts: Unfortunately, neither CCS nor CSP makes such a distinction, and hence neither is able to express this notion of control. As a result, in the case of CCS, for example, notions of fairness considered are typically variants of weak or strong fairness (see <ref> [Fra86] </ref>). Weak fairness requires that an action be performed infinitely often if it is continuously enabled, while strong fairness requires that be performed infinitely often even if it is enabled only infinitely often. These notions of fairness, however, are not satisfactory in event-driven systems such as the networks we consider. <p> If e is infinite, then every process has been given an infinite number of chances to take a step, although it may be that some processes were unable to take steps every time the chance was offered. This notion of fairness is similar to weak fairness (see <ref> [Fra86] </ref>), except that the performance of input actions is never required. We denote the set of fair executions of an automaton A by fair (A), and the execution module of A have fair (A) as its set of executions by Fair (A).
Reference: [GHS83] <author> Robert Gallagher, Pierre Humblet, and Phillip Spira. </author> <title> A distributed algorithm for minimum-weight spanning trees. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(1) </volume> <pages> 66-77, </pages> <month> January </month> <year> 1983. </year>
Reference-contexts: This paper appeared in Proceedings of the 6th Annual ACM Symposium on Principles of Distributed Computing, pages 137-151, ACM, August 1987. an informal understanding of the key ideas behind their algorithms. The distributed minimum spanning tree algorithm of <ref> [GHS83] </ref>, for example, can be understood as several familiar manipulations of a graph. What is needed is a way of formalizing these high-level ideas, and incorporating them into a proof of the detailed algorithm's correctness. One promising approach is to begin by constructing a high-level description of the algorithm.
Reference: [GL87] <author> Kenneth Goldman and Nancy Lynch. </author> <title> Quorum consensus in nested transaction systems. </title> <booktitle> In progress, </booktitle> <year> 1987. </year>
Reference-contexts: Examples of the use of input-output automata differing from the arbiter example discussed in this work include concurrency control algorithms (see [LM86], [HLMW87], [FLMW87], and <ref> [GL87] </ref>), mutual exclusion algorithms (see [Wel87]), hardware register algorithms (see [Blo87]), and dataflow computation (see [Lyn86]). In many of these papers the model has been found to be especially helpful when attempting to identify the interface between system components, and discovering a system's natural decomposition.
Reference: [Har87] <author> David Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <note> To appear in Science of Computer Programming, </note> <year> 1987. </year>
Reference-contexts: Since, however, we are describing algo-rithms at entirely different levels of conceptual abstraction, and not just ignoring certain aspects of the algorithms' behaviors, these techniques are not appropriate for our work. The use of abstraction in Harel's statecharts <ref> [Har87] </ref> is similar, in the sense that system states are grouped together to form superstates. Lamport has also advocated the use of abstraction in the specification of program modules [Lam83].
Reference: [HLMW87] <author> Maurice Herlihy, Nancy Lynch, Michael Merritt, and William Weihl. </author> <title> On the correctness of orphan elimination algorithms. </title> <booktitle> In progress, </booktitle> <year> 1987. </year>
Reference-contexts: Examples of the use of input-output automata differing from the arbiter example discussed in this work include concurrency control algorithms (see [LM86], <ref> [HLMW87] </ref>, [FLMW87], and [GL87]), mutual exclusion algorithms (see [Wel87]), hardware register algorithms (see [Blo87]), and dataflow computation (see [Lyn86]). In many of these papers the model has been found to be especially helpful when attempting to identify the interface between system components, and discovering a system's natural decomposition.
Reference: [Hoa85] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, New Jersey, </address> <year> 1985. </year>
Reference-contexts: The first problem we face is how to express these algorithms describing the arbiter at the various levels of abstraction. Two of the most popular languages are Milner's CCS (see [Mil80]) and Hoare's CSP (see <ref> [Hoa85] </ref>), but certain aspects of the algorithms under consideration make it clear that these languages are not appropriate. In particular, the interaction between the users and the arbiter makes a clear distinction between those events internal and external to the arbiter. <p> Reading between the lines of Hoare's book <ref> [Hoa85] </ref>, it seems that Hoare would prefer to retain for nondeterministic processes the automata-theoretic (trace-theoretic) semantics he develops for deterministic processes.
Reference: [Lam83] <author> Leslie Lamport. </author> <title> Specifying concurrent program modules. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(2) </volume> <pages> 190-222, </pages> <month> April </month> <year> 1983. </year>
Reference-contexts: The use of abstraction in Harel's statecharts [Har87] is similar, in the sense that system states are grouped together to form superstates. Lamport has also advocated the use of abstraction in the specification of program modules <ref> [Lam83] </ref>. Lam-port's specifications consists of a collection of state functions mapping program states into sets of values, a collection of initial values essentially defining the set of states in which the system may begin computation, and a collection of properties describing the safety and liveness conditions required.
Reference: [LM86] <author> Nancy Lynch and Michael Merritt. </author> <title> Introduction to the theory of nested transactions. </title> <type> Technical Report MIT/LCS/TR-367, </type> <institution> Laboratory for Computer Science, Massachusetts Institute of Technology, </institution> <year> 1986. </year>
Reference-contexts: Examples of the use of input-output automata differing from the arbiter example discussed in this work include concurrency control algorithms (see <ref> [LM86] </ref>, [HLMW87], [FLMW87], and [GL87]), mutual exclusion algorithms (see [Wel87]), hardware register algorithms (see [Blo87]), and dataflow computation (see [Lyn86]). In many of these papers the model has been found to be especially helpful when attempting to identify the interface between system components, and discovering a system's natural decomposition. <p> Acknowledgments Much of the preliminary work for this paper (including the conception of the input-output automaton) was done concurrently with the work of the first author and Michael Merritt in <ref> [LM86] </ref>, and that work has greatly influenced this paper. Conversations with and the experience of Alan Fekete, Ken Goldman, and Jennifer Welch as they have used input-output automata in their work have also been very helpful. The presentation of this work was improved by comments from Leslie Lamport and Liuba Shrira.
Reference: [LS84a] <author> Simon S. Lam and A. Udaya Shankar. </author> <title> Protocol verification via projections. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):325-342, </volume> <month> July </month> <year> 1984. </year> <month> 14 </month>
Reference-contexts: Instead, we study the problem of hierarchical decomposition, the problem of relating the algorithms describing the arbiter at different levels of abstraction. Lam and Shankar have successfully used notions of abstraction in their verification work <ref> [LS84a] </ref>. Their notion of abstraction involves the projection of an algorithm with several clearly distinguishable functions onto each function individually, abstracting away the details of the remaining functions. The result is a collection of smaller, simpler algorithms to analyze, allowing each function to be analyzed inde 3 pendently.
Reference: [LS84b] <author> Leslie Lamport and Fred Schneider. </author> <title> The "Hoare logic" of CSP, and all that. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 6(2) </volume> <pages> 281-296, </pages> <month> April </month> <year> 1984. </year>
Reference-contexts: With this partition, we are able to define a simple notion of fair computation. It is clear that most verification methods, such as the Hoare-logic of Owicki and Gries in [OG76], the use of invariant assertions advocated by Lamport and Schneider in <ref> [LS84b] </ref>, the temporal logic of Manna and Pnueli in [MP81b] and [MP81a], and the method of deriving proof obligations of Alpern and Schnei-der in [AS87], can be used to verify the correctness of algorithms expressed in terms of input-output automata.
Reference: [LT87] <author> Nancy A. Lynch and Mark R. Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <type> Technical Report MIT/LCS/TR-387, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> April </month> <year> 1987. </year>
Reference-contexts: These compositions are clearly related. For example, the execution module of a composition of automata is the composition of the execution modules of the automata. Notice that actions shared by several objects are not hidden by these compositions. In the full paper <ref> [LT87] </ref> we define a simple operation to hide such actions, merely relabeling a set of actions as internal actions. Notice also that the compatibility of a collection of objects, and hence whether their composition is defined, depends solely on their action signatures. <p> An important property of this definition of fairness is the fact that the fair executions of a composition are the composition of the fair executions of the components: that is, Fair ( Q Q i Fair (A i ). In the full paper <ref> [LT87] </ref>, we explore several consequences of our definition of fair computation not directly related to algorithm verification, including an interesting notion of process equivalence induced by fair computations. 2.4 Correctness As mentioned in the introduction, we consider an automaton A to simulate an automaton B if the fair behavior of A <p> Timeouts, for instance, are a crucial part of the fault-tolerance of many communications algorithms. Furthermore, the analysis of an algorithm's complexity requires some notion of bounds on processor step times and message delivery times. We give in the full paper <ref> [LT87] </ref> some ad hoc techniques for reasoning about the time complexity of the arbiter discussed in this paper. We analyze the complexity of the arbiter at the intermediate-level of abstraction, and it is not hard to see how this complexity result translates down to the lower level of abstraction.
Reference: [Lyn83] <author> Nancy A. Lynch. </author> <title> Concurrency control for resilient nested transactions. </title> <type> Technical Report MIT/LCS/TR-285, </type> <institution> Laboratory for Computer Science, Massachusetts Institute of Technology, </institution> <month> February </month> <year> 1983. </year>
Reference-contexts: As an aid in doing so, we introduce the notion of a possibilities mapping between automata, relating the states of one automaton to the states of another. The notion of a possibilities mapping was first intro duced by Lynch in <ref> [Lyn83] </ref> for process algebras, and we adapt these mappings for our own purposes. Possibilities mappings are similar in spirit to Lamport's state functions, but automata describing an algorithm at different levels of abstraction are independent of the possibilities mappings relating them.
Reference: [Lyn86] <author> Nancy Lynch. </author> <note> Unpublished notes, </note> <year> 1986. </year>
Reference-contexts: Examples of the use of input-output automata differing from the arbiter example discussed in this work include concurrency control algorithms (see [LM86], [HLMW87], [FLMW87], and [GL87]), mutual exclusion algorithms (see [Wel87]), hardware register algorithms (see [Blo87]), and dataflow computation (see <ref> [Lyn86] </ref>). In many of these papers the model has been found to be especially helpful when attempting to identify the interface between system components, and discovering a system's natural decomposition.
Reference: [Mil80] <author> Robin Milner. </author> <title> A Calculus of Communicating Systems. </title> <booktitle> Lecture Notes in Computer Science 92. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1980. </year>
Reference-contexts: The first problem we face is how to express these algorithms describing the arbiter at the various levels of abstraction. Two of the most popular languages are Milner's CCS (see <ref> [Mil80] </ref>) and Hoare's CSP (see [Hoa85]), but certain aspects of the algorithms under consideration make it clear that these languages are not appropriate. In particular, the interaction between the users and the arbiter makes a clear distinction between those events internal and external to the arbiter. <p> Such a mapping, reminiscent of bisimulation from CCS <ref> [Mil80] </ref>, enables us to relate executions of A to executions of B as follows.
Reference: [MP81a] <author> Zohar Manna and Amir Pnueli. </author> <title> Verification of concurrent programs: Temporal proof principles. </title> <editor> In Dexter Kozen, editor, </editor> <booktitle> Logic of Programs, Lecture Notes in Computer Science 131, </booktitle> <pages> pages 200-252. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: It is clear that most verification methods, such as the Hoare-logic of Owicki and Gries in [OG76], the use of invariant assertions advocated by Lamport and Schneider in [LS84b], the temporal logic of Manna and Pnueli in [MP81b] and <ref> [MP81a] </ref>, and the method of deriving proof obligations of Alpern and Schnei-der in [AS87], can be used to verify the correctness of algorithms expressed in terms of input-output automata. We do not fix on a particular methodology for reasoning about the behavior of individual automata.
Reference: [MP81b] <author> Zohar Manna and Amir Pnueli. </author> <title> Verification of concurrent programs: The temporal framework. </title> <editor> In Robert S. Boyer and J. Strother Moore, editors, </editor> <booktitle> The Correctness Problem in Computer Science, International Lecture Series in Computer Science, </booktitle> <pages> pages 215-273. </pages> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1981. </year>
Reference-contexts: It is clear that most verification methods, such as the Hoare-logic of Owicki and Gries in [OG76], the use of invariant assertions advocated by Lamport and Schneider in [LS84b], the temporal logic of Manna and Pnueli in <ref> [MP81b] </ref> and [MP81a], and the method of deriving proof obligations of Alpern and Schnei-der in [AS87], can be used to verify the correctness of algorithms expressed in terms of input-output automata. We do not fix on a particular methodology for reasoning about the behavior of individual automata.
Reference: [OG76] <author> Susan Owicki and David Gries. </author> <title> An axiomatic proof technique for parallel programs I. </title> <journal> Acta Informatica, </journal> <volume> 6(4) </volume> <pages> 319-340, </pages> <month> August </month> <year> 1976. </year>
Reference-contexts: The interpretation of this partition is that each class consists of the locally-controlled actions of one system component. With this partition, we are able to define a simple notion of fair computation. It is clear that most verification methods, such as the Hoare-logic of Owicki and Gries in <ref> [OG76] </ref>, the use of invariant assertions advocated by Lamport and Schneider in [LS84b], the temporal logic of Manna and Pnueli in [MP81b] and [MP81a], and the method of deriving proof obligations of Alpern and Schnei-der in [AS87], can be used to verify the correctness of algorithms expressed in terms of input-output
Reference: [Sch80] <author> Arnold Schonhage. </author> <type> Personal Communication, </type> <year> 1980. </year>
Reference-contexts: Some time ago, we began to consider this approach of proof by refinement for a simple resource allocation algorithm, an arbiter for a resource in an asynchronous network, originally suggested by Schonhage in <ref> [Sch80] </ref>.
Reference: [Sta84] <author> Eugene W. Stark. </author> <title> Foundations of a Theory of Specification for Distributed Systems. </title> <type> PhD thesis, </type> <institution> Laboratory for Computer Science, Massachusetts Institute of Technology, </institution> <month> August </month> <year> 1984. </year> <note> Available as Technical Report MIT/LCS/TR-342. </note>
Reference-contexts: Possibilities mappings are similar in spirit to Lamport's state functions, but automata describing an algorithm at different levels of abstraction are independent of the possibilities mappings relating them. We remark that Stark has greatly generalized the notion of a possibilities mapping in <ref> [Sta84] </ref>. His model is much more general that ours, but we find ours simpler and easier to use, and expressive enough to describe most systems of interest. The remainder of this paper consists of three parts. In the first part, we define the input-output automaton model.
Reference: [Wel87] <author> Jennifer L. Welch. </author> <title> A synthesis of efficient mutual exclusion algorithms. </title> <booktitle> In progress, </booktitle> <year> 1987. </year>
Reference-contexts: Examples of the use of input-output automata differing from the arbiter example discussed in this work include concurrency control algorithms (see [LM86], [HLMW87], [FLMW87], and [GL87]), mutual exclusion algorithms (see <ref> [Wel87] </ref>), hardware register algorithms (see [Blo87]), and dataflow computation (see [Lyn86]). In many of these papers the model has been found to be especially helpful when attempting to identify the interface between system components, and discovering a system's natural decomposition.
References-found: 25

