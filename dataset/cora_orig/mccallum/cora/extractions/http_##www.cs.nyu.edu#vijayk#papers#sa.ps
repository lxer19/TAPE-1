URL: http://www.cs.nyu.edu/vijayk/papers/sa.ps
Refering-URL: http://www.cs.nyu.edu/vijayk/papers.html
Root-URL: http://www.cs.nyu.edu
Title: Analysis of Dynamic Structures for Efficient Parallel Execution  
Author: John Plevyak Vijay Karamcheti Andrew A. Chien 
Note: Workshop on Lanuguages and Compilers for Parallel Computing of '93.  
Address: Urbana, IL 61801  
Affiliation: Department of Computer Science University of Illinois at Urbana-Champaign  
Abstract: Programs written in high-level programming languages and in particular object-oriented languages make heavy use of references and dynamically allocated structures. As a result, precise analysis of such features is critical for producing efficient implementations. The information produced by this analysis is invaluable for compiling programs for both sequential and parallel machines. This paper presents a new structure analysis technique handling references and dynamic structures which enables precise analysis of infinite recursive data structures. The precise analysis depends on an enhancement of Chase et al.'s Storage Shape Graph (SSG) called the Abstract Storage Graph (ASG) which extends SSG's with choice nodes, identity paths, and specialized storage nodes and references. These extensions allow ASG's to precisely describe singly- and multiply-linked lists as well as a number of other pointer structures such as octrees, and to analyze programs which manipulate them. We describe program analysis to produce the ASG, and focus on the key operations: the transfer functions, summarization and deconstruction. Summarization compresses the ASG in such a way as to capture critical interdependencies between references. Deconstruction uses this information, stored by identity paths and refined references and nodes, to retrieve individual nodes for strong updates.
Abstract-found: 1
Intro-found: 1
Reference: [ASU87] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques and Tools. Computer Science. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1987. </year>
Reference-contexts: We therefore differentiate between two types of updates | strong and weak. When one reference replaces another it is called a strong update [CWZ90] and corresponds to the killing rules of standard dataflow techniques <ref> [ASU87] </ref>. Strong updates can only occur when a location is definitely updated. When a location may or may not be changed this results in a weak update.
Reference: [CBC93] <author> Jong-Deok Choi, Michael Burke, and Paul Carini. </author> <title> Efficient flow-sensative interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Twentieth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245. </pages> <booktitle> ACM SIGPLAN, </booktitle> <year> 1993. </year>
Reference-contexts: The addition of program annotations is orthogonal to the problem of analyzing an unannotated program since for any imprecise algorithm, annotations could be added which guide and assist analysis at the cost of programmer effort. In recent work, access path and graph based approaches have been drawn together <ref> [CBC93] </ref>. With access paths, the aliases at a program point are described by alias relations (pairs of access paths). An access path is a tuple consisting of a cell and a sequence of fields. <p> If the alias relations are stored with only one level of dereferencing, the aliases are precisely the edges of a graph whose vertices are the starting cells of the access paths <ref> [CBC93] </ref>. As a result, access paths are used to implement an essentially graph based algorithm. Current alias and structure analysis algorithms are unable to accurately analyze many common data structures. Structure analysis approaches based on k-limited graphs [JM81, LH88, HPR89] or on k-limited naming schemes [CBC93] are unable to adequately describe <p> cells of the access paths <ref> [CBC93] </ref>. As a result, access paths are used to implement an essentially graph based algorithm. Current alias and structure analysis algorithms are unable to accurately analyze many common data structures. Structure analysis approaches based on k-limited graphs [JM81, LH88, HPR89] or on k-limited naming schemes [CBC93] are unable to adequately describe recursive structures such as lists; in general, structures extend beyond the k-limit and the summary process destroys all structure beyond k nodes.
Reference: [CD90] <author> A. A. Chien and W. J. Dally. </author> <title> Concurrent Aggregates (CA). </title> <booktitle> In Proceedings of Second Symposium on Principles and Practice of Parallel Programming. ACM, </booktitle> <month> March </month> <year> 1990. </year>
Reference-contexts: Uninformed compilation of such languages can result in programs which are several orders of magnitude slower than corresponding fast serial implementations. The Concert system includes a compiler for an extended version of Concurrent Aggregates <ref> [CD90] </ref> and a runtime which exposes the cost hierarchy among the basic operations required for fine grained reactive computation [KC93].
Reference: [CFKP92] <author> A. A. Chien, W. Feng, V. Karamcheti, and J. Plevyak. </author> <title> Techniques for efficient execution of fine-grained concurrent programs. </title> <booktitle> In Proceedings of the Fifth Workshop on Compilers and Languages for Parallel Computing, </booktitle> <pages> pages 103-13, </pages> <address> New Haven, Connecticut, </address> <year> 1992. </year> <note> YALEU/DCS/RR-915, Springer-Verlag Lecture Notes in Computer Science, </note> <year> 1993. </year>
Reference-contexts: Controlling these costs requires determining the runtime shape of program structures and transforming both them and the program to increase the computation grain size. These transformations fall in the general category of optimizations addressed via grain size tuning <ref> [CFKP92] </ref> which seeks to match the amount of serial processing between communication or synchronization points in the program to that efficiently supported by hardware. In parallel programs, merging computational grains requires enhancing data locality.
Reference: [CFR + 91] <author> R. Cytron, J. Ferrante, B. Rosen, M. Wegman, and F. Zadeck. </author> <title> An efficient method of computing static single assignment form and the control dependence graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: For our purposes, the program consists of storage allocation, assignment, conditional and loop statements. Assignments are to and from a variable or a field of an object referenced from a variable. The program is considered to be in Static Single Assignment form <ref> [CFR + 91] </ref>. 7 4.1 Driver The overall structure of the analysis algorithm follows that of conventional iterative dataflow analysis. The solution at every program point is related to the solution at other points. Program points are program statements and the relations are defined on control flow arcs.
Reference: [CKP93] <author> Andrew Chien, Vijay Karamcheti, and John Plevyak. </author> <title> The concert system compiler and runtime support for efficient fine-grained concurrent object-oriented programs. </title> <type> DCS Technical Report UIUCDCS-R-93-1815, </type> <institution> University of Illinois, Department of Computer Science, 1304 W. Springfield Avenue, Urbana, Illinois, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: To remedy these limitations, the ASG incorporates extensions to the SSG (not based on heap reference counts). These extensions are described in detail in Section 3. 2.2 Project Context This work has been done as part of the Concert Project <ref> [CKP93] </ref>. The objective of the Concert system is to achieve efficient, portable implementations of fine-grained concurrent object-oriented languages on parallel machines.
Reference: [CU91] <author> C. Chambers and D. Ungar. </author> <title> Making pure object-oriented languages practical. </title> <booktitle> In OOPSLA '91 Conference Proceedings, </booktitle> <year> 1991. </year>
Reference-contexts: If the ASGs entering a procedure are sufficiently distinct, the path through the procedure can be split incrementally resulting in flow-sensitive analysis. We are considering path nodes as a means to reduce the cost of a splitting operation <ref> [CU91] </ref>. 18
Reference: [CWZ90] <author> D. Chase, M. Wegman, and F. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Three basic approaches to both structure analysis and the alias problem have been explored. These basic approaches are (1) explicit annotation [Lar89] (2) access paths [HN90] and (3) graph based approaches <ref> [CWZ90] </ref>. Explicit annotations allow the user to supply the compiler with information which either cannot be derived, or is more easily verified than derived. In access path approaches, the aliases at each program point are described by pairs of access paths. <p> Larus [LH88] uses graphs to represent the structures reachable from each program variable, but labels the nodes with access paths and uses the labels to identify aliases. In contrast, Chase <ref> [CWZ90] </ref> uses graphs alone in which each node in the graph corresponds to one or more nodes in the runtime heap and the edges correspond to references. In this paper we do not consider annotations. <p> If the list is traversed beyond k elements, the analysis cannot preserve the list structure, losing precision in analysis which leads to missed opportunities for optimization. Chase et al.'s SSG algorithm <ref> [CWZ90] </ref> circumvents the k-limitation by augmenting the basic reference graph with heap reference counts. Thus, for singly-linked structures, SSGs can sometimes obtain a precise analysis of the program. <p> It must safely approximate the pattern so that transformations which use the reference information will preserve program semantics. In this section, we describe our store representation, the Abstract Storage Graph (ASG), and relate it to Chase et al.'s Storage Shape Graph (SSG) <ref> [CWZ90] </ref>. A generic reference graph is a store representation containing nodes which model dynamic program structures, and edges which model references. In order to produce a precise approximation, the reference graph must preserve as much deterministic reference information as possible. <p> This follows from the observation that the graph before the manipulation must match the resulting graph. We therefore differentiate between two types of updates | strong and weak. When one reference replaces another it is called a strong update <ref> [CWZ90] </ref> and corresponds to the killing rules of standard dataflow techniques [ASU87]. Strong updates can only occur when a location is definitely updated. When a location may or may not be changed this results in a weak update. <p> The first heuristic pairs up natural combinations, such as nodes which have not changed. This can be accomplished logically as follows: starting from the set of variables which are not listed in the -functions at the merge point <ref> [CWZ90] </ref> (those that were not assigned in the region of the program for which the merge point is on the post-dominator front), select all nodes referenced only by these variables whose outgoing references have not changed. <p> Should the search fail, the node will be combined with a random node of the same type, but it will be combined after all those for whom the search succeeded since, as was noted in <ref> [CWZ90] </ref>, combining two unrelated nodes will not decrease space usage. It is important to note that the combine criteria must be deterministic.
Reference: [HN90] <author> L. Hendren and A. Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 35-47, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Three basic approaches to both structure analysis and the alias problem have been explored. These basic approaches are (1) explicit annotation [Lar89] (2) access paths <ref> [HN90] </ref> and (3) graph based approaches [CWZ90]. Explicit annotations allow the user to supply the compiler with information which either cannot be derived, or is more easily verified than derived. In access path approaches, the aliases at each program point are described by pairs of access paths.
Reference: [HNH92] <author> L. Hendren, A. Nicolau, and J. Hummel. </author> <title> Abstractions for recursive pointer data structures: Improving the analysis and transformation of imperative programs. </title> <booktitle> In Proceedings of the SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 249-260. </pages> <booktitle> ACM SIGPLAN, </booktitle> <publisher> ACM Press, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: Many algorithms also use a combination of these approaches. For instance, the Abstract Dynamic Data Structure description (ADDS) approach <ref> [HNH92] </ref> combines annotation with access paths and seeks to verify programmer assertions. Larus [LH88] uses graphs to represent the structures reachable from each program variable, but labels the nodes with access paths and uses the labels to identify aliases.
Reference: [HPR89] <author> S. Horwitz, P. Pfeiffer, and T. Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> In Proceedings of the SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 28-40. </pages> <booktitle> ACM SIGPLAN, </booktitle> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: As a result, access paths are used to implement an essentially graph based algorithm. Current alias and structure analysis algorithms are unable to accurately analyze many common data structures. Structure analysis approaches based on k-limited graphs <ref> [JM81, LH88, HPR89] </ref> or on k-limited naming schemes [CBC93] are unable to adequately describe recursive structures such as lists; in general, structures extend beyond the k-limit and the summary process destroys all structure beyond k nodes.
Reference: [JM81] <author> N. Jones and S. Muchnick. </author> <title> Flow analysis and optimization of lisp-like structures. </title> <editor> In S. Much-nick and N. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 102-131. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: As a result, access paths are used to implement an essentially graph based algorithm. Current alias and structure analysis algorithms are unable to accurately analyze many common data structures. Structure analysis approaches based on k-limited graphs <ref> [JM81, LH88, HPR89] </ref> or on k-limited naming schemes [CBC93] are unable to adequately describe recursive structures such as lists; in general, structures extend beyond the k-limit and the summary process destroys all structure beyond k nodes.
Reference: [KC93] <author> Vijay Karamcheti and Andrew Chien. </author> <title> Concert efficient runtime support for concurrent object-oriented programming languages on stock hardware. </title> <note> To appear in the Proceedings of SUPERCOMPUTING'93, </note> <year> 1993. </year>
Reference-contexts: The Concert system includes a compiler for an extended version of Concurrent Aggregates [CD90] and a runtime which exposes the cost hierarchy among the basic operations required for fine grained reactive computation <ref> [KC93] </ref>. Programs compiled with the system execute on uniprocessor workstations and the CM5 [Thi91]. 9 Summary and Future Work Efficient execution of irregular computations containing dynamic structures on parallel architectures requires that the compiler know the shape of the runtime store.
Reference: [Lar89] <author> James Richard Larus. </author> <title> Restructuring symbolic programs for concurrent execution on multiprocessors. </title> <type> Technical Report UCB/CSD 89/502, </type> <institution> University of California at Berkeley, </institution> <year> 1989. </year> <month> 19 </month>
Reference-contexts: Three basic approaches to both structure analysis and the alias problem have been explored. These basic approaches are (1) explicit annotation <ref> [Lar89] </ref> (2) access paths [HN90] and (3) graph based approaches [CWZ90]. Explicit annotations allow the user to supply the compiler with information which either cannot be derived, or is more easily verified than derived.
Reference: [LH88] <author> J. R. Larus and P. N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 21-33. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1988. </year>
Reference-contexts: While the alias information produced by structure analysis suffices for traditional serial optimizations and for dependence analysis based parallelization, the unique structure information is required for other important optimizations. Since determining precise alias information even in a single function is NP-complete <ref> [LH88, Mye81] </ref> practical structure analysis algorithms approximate the program store. 2 Background 2.1 Related Work Most of the work on structure and alias analysis has been based on a data flow analysis framework. <p> Many algorithms also use a combination of these approaches. For instance, the Abstract Dynamic Data Structure description (ADDS) approach [HNH92] combines annotation with access paths and seeks to verify programmer assertions. Larus <ref> [LH88] </ref> uses graphs to represent the structures reachable from each program variable, but labels the nodes with access paths and uses the labels to identify aliases. <p> As a result, access paths are used to implement an essentially graph based algorithm. Current alias and structure analysis algorithms are unable to accurately analyze many common data structures. Structure analysis approaches based on k-limited graphs <ref> [JM81, LH88, HPR89] </ref> or on k-limited naming schemes [CBC93] are unable to adequately describe recursive structures such as lists; in general, structures extend beyond the k-limit and the summary process destroys all structure beyond k nodes.
Reference: [Mye81] <author> E. Myers. </author> <title> A precise interprocedural data flow algorithm. </title> <booktitle> In Eighth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 219-30, </pages> <year> 1981. </year>
Reference-contexts: While the alias information produced by structure analysis suffices for traditional serial optimizations and for dependence analysis based parallelization, the unique structure information is required for other important optimizations. Since determining precise alias information even in a single function is NP-complete <ref> [LH88, Mye81] </ref> practical structure analysis algorithms approximate the program store. 2 Background 2.1 Related Work Most of the work on structure and alias analysis has been based on a data flow analysis framework.
Reference: [Thi91] <institution> Thinking Machines Corporation, </institution> <address> Cambridge, Massachusets. </address> <note> CM5 Technical Summary, Octo-ber 1991. 20 </note>
Reference-contexts: The Concert system includes a compiler for an extended version of Concurrent Aggregates [CD90] and a runtime which exposes the cost hierarchy among the basic operations required for fine grained reactive computation [KC93]. Programs compiled with the system execute on uniprocessor workstations and the CM5 <ref> [Thi91] </ref>. 9 Summary and Future Work Efficient execution of irregular computations containing dynamic structures on parallel architectures requires that the compiler know the shape of the runtime store. The ease of general purpose parallel programming depends on future compilers being able to determine this information without programmer assistance.
References-found: 17

