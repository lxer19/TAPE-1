URL: ftp://ic.eecs.berkeley.edu/pub/Memos_Conference/iccad94.PSA.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu/~vigyan/publications/index.html
Root-URL: http://www.cs.berkeley.edu
Title: Multi-level Synthesis for Safe Replaceability  
Author: Carl Pixley Vigyan Singhal Adnan Aziz Robert K. Brayton 
Address: 6501 Wm Cannon Drive West  Austin, TX 78735 Berkeley, CA 94720  
Affiliation: Motorola Inc., MD OE321 Dept. of Electrical Engineering and Computer Sciences  University of California at Berkeley  
Abstract: We describe the condition that a sequential digital design is a safe replacement for an existing design without making any assumptions about a known initial state of the design or about its environment. We formulate a safe replacement condition which guarantees that if an original design is replaced by a new design, the interacting environment cannot detect the change by observing the input-output behavior of the new design; conversely, if a replacement design does not satisfy our condition an environment can potentially detect the replacement (in this sense the replacement is potentially unsafe). Our condition allows simplification of the state transition diagram of an original design. We use the safe replacement condition to derive a sequential resynthesis method for area reduction of gate-level designs. We have implemented our resynthesis algorithm and we report experimental results. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Lin, H. J. Touati, and A. R. </author> <title> Newton, Don't Care Minimization of Multi-level Sequential Logic Networks, </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 414-417, </pages> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: Many researchers have been able to obtain and exploit sequential flexibility in gate-level designs by using the knowledge of the designated start state. Some of these include using don't care resulting from unreachable states <ref> [1] </ref>, redundant latch removal [2], sequential redundancy removal [3] and equivalence net detection [4]. All these methods rely on the flexibility introduced because many states in the design are not reachable from the start state, and hence we are free to modify the behavior of any unreachable state arbitrarily.
Reference: [2] <author> C. Berthet, O. Coudert, and J. C. Madre, </author> <title> New Ideas on Symbolic Manipulation of Finite State Machines, </title> <booktitle> in Proc. Intl. Conf. on Computer Design, </booktitle> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: Many researchers have been able to obtain and exploit sequential flexibility in gate-level designs by using the knowledge of the designated start state. Some of these include using don't care resulting from unreachable states [1], redundant latch removal <ref> [2] </ref>, sequential redundancy removal [3] and equivalence net detection [4]. All these methods rely on the flexibility introduced because many states in the design are not reachable from the start state, and hence we are free to modify the behavior of any unreachable state arbitrarily.
Reference: [3] <author> H. Cho, G. D. Hachtel, and F. Somenzi, </author> <title> Redundancy Identification and Removal Based on Implicit State Enumeration, </title> <booktitle> in Proc. Intl. Conf. on Computer Design, </booktitle> <pages> pp. 77-80, </pages> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: Many researchers have been able to obtain and exploit sequential flexibility in gate-level designs by using the knowledge of the designated start state. Some of these include using don't care resulting from unreachable states [1], redundant latch removal [2], sequential redundancy removal <ref> [3] </ref> and equivalence net detection [4]. All these methods rely on the flexibility introduced because many states in the design are not reachable from the start state, and hence we are free to modify the behavior of any unreachable state arbitrarily.
Reference: [4] <author> G. Berry and H. J. Touati, </author> <title> Optimized Controller Synthesis Using Esterel, </title> <booktitle> in Workshop Notes of Intl. Workshop on Logic Synthesis, </booktitle> <address> (Tahoe City, CA), </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Many researchers have been able to obtain and exploit sequential flexibility in gate-level designs by using the knowledge of the designated start state. Some of these include using don't care resulting from unreachable states [1], redundant latch removal [2], sequential redundancy removal [3] and equivalence net detection <ref> [4] </ref>. All these methods rely on the flexibility introduced because many states in the design are not reachable from the start state, and hence we are free to modify the behavior of any unreachable state arbitrarily.
Reference: [5] <author> C. Pixley, </author> <title> A Theory and Implementationof Sequential Hardware Equivalence, </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <volume> vol. 11, </volume> <pages> pp. 1469-1494, </pages> <month> Dec. </month> <year> 1992. </year>
Reference-contexts: In this paper, we use our replaceability notion to obtain area reductions without assuming a designated start state. We describe our condition for safe replacement and synthesis techniques which does not assume reset lines. We describe how our condition differs from other notions used to describe sequential equivalence <ref> [5, 6] </ref>. We also discuss how other sequential resynthesis methods, like retiming/resynthesis [7] and synchronous relation minimization [8], which do not directly use the knowledge of a designated start state indirectly rely on the existence of an initial state. <p> ~ t. 3 Previous Work In this section we describe the few known notions of sequential equivalence for circuits which do not have reset lines, and argue why these might cause unsafe replacements in some cases. 3.1 Sequential Hardware Equivalence (SHE) Here we will briefly review the work presented in <ref> [5] </ref> regarding equivalence between two gate-level hardware designs. When the design powers up, the state it powers up in cannot be predicted, and the desired input/output behavior is achieved from the design by driving a fixed initializing sequence of input vectors through the design after power-up. <p> and reflexive, but not symmetric. (The replaced design has fewer or same input/output behaviors as the original design). * A replacement design can have fewer or more latches than the original design (in Figure 4, D 0 has 3 latches whereas D 1 has 2). * Unlike sequential hardware equivalence <ref> [5] </ref>, safe replaceabil-ity also applies to a design which does not have any initializing sequence. * If D 1 D 0 , every initializing sequence for D 0 is an initial izing sequence for D 1 as well. * If D 1 D 0 , then every tSCC in D 1
Reference: [6] <author> K.-T. Cheng, </author> <title> Redundancy Removal for Sequential Circuits Without Reset States, </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <volume> vol. 12, </volume> <pages> pp. 13-24, </pages> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: In this paper, we use our replaceability notion to obtain area reductions without assuming a designated start state. We describe our condition for safe replacement and synthesis techniques which does not assume reset lines. We describe how our condition differs from other notions used to describe sequential equivalence <ref> [5, 6] </ref>. We also discuss how other sequential resynthesis methods, like retiming/resynthesis [7] and synchronous relation minimization [8], which do not directly use the knowledge of a designated start state indirectly rely on the existence of an initial state. <p> Thus, the behavior of this design can be controlled. 3.2 Redundancy Removal Here we briefly describe the sequential equivalence condition used by Cheng <ref> [6] </ref> for resynthesis of circuits by removing redundant lines from the circuits. The basic idea is to check if the input/output behavior of the circuit is acceptable even after an internal line has been set to 0 or 1. <p> This motivates the need for a safe replacement condition a condition so that the environment does not see any new input/output behavior after the replacement. Notice that if the entire design in Figure 3 were considered, the shown fault would no longer be redundant as per the condition in <ref> [6] </ref>. This points to the desirable compositionality property that we would like to see in a replacement condition safe replacements for a sub-design should still be safe replacements when the sub-design is composed with another design. The work in [9] is based on the replacement condition in [6] assuming that if <p> the condition in <ref> [6] </ref>. This points to the desirable compositionality property that we would like to see in a replacement condition safe replacements for a sub-design should still be safe replacements when the sub-design is composed with another design. The work in [9] is based on the replacement condition in [6] assuming that if the fault cannot be propagated to a primary output, then the fault is redundant.
Reference: [7] <author> S. Malik, E. M. Sentovich, R. K. Brayton, and A. L. Sangiovanni-Vincentelli, </author> <title> Retiming and Resynthesis: Optimization of Sequential Networks with Combinational Techniques, </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <volume> vol. 10, </volume> <pages> pp. 74-84, </pages> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: We describe our condition for safe replacement and synthesis techniques which does not assume reset lines. We describe how our condition differs from other notions used to describe sequential equivalence [5, 6]. We also discuss how other sequential resynthesis methods, like retiming/resynthesis <ref> [7] </ref> and synchronous relation minimization [8], which do not directly use the knowledge of a designated start state indirectly rely on the existence of an initial state. We will also show that the synthesis techniques in [9] make implicit assumptions about the environment of the design. <p> Also, in Section 5.4, we show that setting the internal node input lines to constants and verifying the validity of the modified design is a special case; thus the exact solution for our proposed method covers the redundancy removal techniques. 3.3 Retiming and Resynthesis Retiming and resynthesis <ref> [7] </ref> can be used to perform sequential optimization by alternating steps of moving of latches across combinational logic (retiming) and performing combinational resynthesis. Retiming seems to be able to work if latches do not have reset lines. However, consider once again the circuit in Figure 3.
Reference: [8] <author> M. Damiani and G. De Micheli, </author> <title> Synthesis and Optimization of Synchronous Logic Circuits from Recurrence Equations, </title> <booktitle> in Proc. European Conf. on Design Automation, </booktitle> <pages> pp. 226-231, </pages> <month> Mar. </month> <year> 1992. </year>
Reference-contexts: We describe our condition for safe replacement and synthesis techniques which does not assume reset lines. We describe how our condition differs from other notions used to describe sequential equivalence [5, 6]. We also discuss how other sequential resynthesis methods, like retiming/resynthesis [7] and synchronous relation minimization <ref> [8] </ref>, which do not directly use the knowledge of a designated start state indirectly rely on the existence of an initial state. We will also show that the synthesis techniques in [9] make implicit assumptions about the environment of the design. <p> So the reason given in Section 3.2, for searching for a new safe replacement condition, applies here as well. 3.4 Synchronous Relations Damiani and De Micheli <ref> [8] </ref> proposed using synchronous recurrence equations (or synchronous relations) to capture don't care information in sequential circuits. A synchronous relation expresses the flexibility for a sub-circuit in a sequential gate-level design as a Boolean relation on finite sequences of inputs and outputs.
Reference: [9] <author> L. Entrena and K.-T. Cheng, </author> <title> Sequential Logic Optimization by Redundancy Addition and Removal, </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 310-315, </pages> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: We also discuss how other sequential resynthesis methods, like retiming/resynthesis [7] and synchronous relation minimization [8], which do not directly use the knowledge of a designated start state indirectly rely on the existence of an initial state. We will also show that the synthesis techniques in <ref> [9] </ref> make implicit assumptions about the environment of the design. For our safe replacement condition, it is surprising even though the design may power up in any state that we are able to obtain some area reductions beyond combinational resynthesis. <p> This points to the desirable compositionality property that we would like to see in a replacement condition safe replacements for a sub-design should still be safe replacements when the sub-design is composed with another design. The work in <ref> [9] </ref> is based on the replacement condition in [6] assuming that if the fault cannot be propagated to a primary output, then the fault is redundant.
Reference: [10] <author> J. Hartmanis and R. E. Stearns, </author> <title> Algebraic Structure Theory of Sequential Machines. </title> <booktitle> Intl. Series in Applied Mathematics, </booktitle> <address> Englewood Cliffs, N.J.: </address> <publisher> Prentice-Hall, </publisher> <year> 1966. </year>
Reference-contexts: It can be easily shown that if s 0 ~ s 1 , then for any input sequence 2 I fl , ffi D 0 (s 0 ; ) ~ ffi D 1 (s 1 ; ). The classical notion of equivalence between two DFSM's <ref> [10, page 23] </ref> is the following: Definition 3 Two DFSM's M 1 and M 2 are equivalent (M 1 M 2 ) if for each state s in M 1 there is a state t in M 2 such that s ~ t, and for each state t in M 2
Reference: [11] <author> R. Rudell, Synopsys, Inc.. </author> <type> Personal communication, </type> <month> Mar. </month> <year> 1994. </year>
Reference-contexts: From Theorem 3.1, two designs are considered equivalent if there exists a universal aligning sequence. This sequence is an initializing sequence for either design. However, in the design process, often the designers do not (or, can not <ref> [11] </ref>) know the initializing sequence for their designs. Even if they can determine such a sequence for a design, it may not be possible for the environment to generate . So, for a safe replacement we need to preserve all initializing sequences, and not just one.
Reference: [12] <author> C. Pixley, V. Singhal, A. Aziz, and R. K. Brayton, </author> <title> Multi-level Synthesis for Safe Replaceability, </title> <type> Tech. Rep. </type> <institution> UCB/ERL M94/31, Electronics Research Lab, Univ. of California, Berkeley, </institution> <address> CA 94720, </address> <month> Apr. </month> <year> 1994. </year>
Reference-contexts: Although the synchronous relation does not depend on a designated start state, the start state has to be taken into account. For a design without reset lines, we can construct an example <ref> [12] </ref> where two designs satisfy the same synchronous relation but a state of one de sign may exhibit some behavior exhibited by no state of the other design. 4 Safe Replaceability We want a condition for safe replacement which guarantees that if we replace an old design with a new one, <p> Notice that state 10 in D 1 is not equivalent to any 2 If some latches have a reset line, they can be modeled by a latch without a reset line if we treat the reset line as another primary input; see <ref> [12] </ref> for details. state in D 0 ; conversely, no state in D 1 is equivalent to state 001 in D 0 . Definition 8 guarantees that there is no input/output behavior in D 1 which is not present in D 0 .
Reference: [13] <author> V. Singhal and C. Pixley, </author> <title> The Verification Problem for Safe Replaceability, </title> <booktitle> in Proc. of the Conf. on Computer-Aided Verification (D. </booktitle> <editor> L. Dill, ed.), </editor> <volume> vol. </volume> <booktitle> 818 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 311-323, </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: set of states S Q D such that for every pair of states s 0 ; s 1 2 S : there exists an input sequence 2 I fl such that ffi D (s 0 ; ) = s 1 , We have shown other properties of safe replacement in <ref> [13] </ref>: * The relation is transitive and reflexive, but not symmetric. (The replaced design has fewer or same input/output behaviors as the original design). * A replacement design can have fewer or more latches than the original design (in Figure 4, D 0 has 3 latches whereas D 1 has 2).
Reference: [14] <author> H. Savoj and R. K. Brayton, </author> <title> Observability Relations and Observability Don't Cares, </title> <booktitle> in Proc. Intl. Conf. on Computer-AidedDesign, </booktitle> <pages> pp. </pages> <address> 518-521,Nov. </address> <year> 1991. </year>
Reference-contexts: We want to optimize this combinational part while maintaining the safe replacement condition. If we can express the flexibility in Definition 8 by a Boolean relation in ( ~ i; ~x; ~o; ~y), we can use known techniques <ref> [14] </ref> for minimizing multi-level networks given a Boolean relation, in terms of the inputs and outputs of the network. Unfortunately, the flexibility allowed by the safe replacement condition cannot be represented by a Boolean relation between the domain space ( ~ i; ~x) and the range space (~o; ~y). <p> The smallest tSCC is the smallest set which qualifies as a core. However, we are restricted by the requirement that the starting design must itself satisfy the Boolean relation R. The only known method for minimizing multi-level networks under flexibility expressed by a Boolean relation <ref> [14] </ref> requires this restriction, as we shall see later in Section 5.4. <p> The relation can be viewed as a single node with inputs ~ i; ~x; ~o; ~y; this node is referred to as the observability node. Composing this node with the network as shown in Figure 8 yields an observability network N 0 . It is shown in <ref> [20, 14] </ref> that all the don't cares that can be used to optimize the nodes in N are derivable from the ODC of the node in the network N . <p> This means that we automatically remove redundant faults (which satisfy R) from the circuit. Note that we are able to detect these redundanciesbecause we are computing the flexibility of each node just before minimizing it; if we had obtained compatible flexibility (as in <ref> [14] </ref>) for all nodes before minimizing them simultaneously we would not be able to claim this.
Reference: [15] <author> E. M. Sentovich, V. Singhal, and R. K. Brayton, </author> <title> Multiple Boolean Relations, </title> <booktitle> in Workshop Notes of the Intl. Workshop on Logic Synthesis, </booktitle> <address> (Tahoe City, CA), </address> <month> May </month> <year> 1993. </year>
Reference-contexts: One property of Boolean relations is that the flexibility for each point in the domain space is independent of other points <ref> [15] </ref>. So, if the flexibility for safe replacement could be expressed by a Boolean relation, then every design corresponding to a flexibility choice for each of these 6 domain points would be a valid replacement (there are 2 6 such designs). <p> Thus the flexibility for safe replaceable designs with the same number of latches cannot be expressed as a Boolean relation in ( ~ i; ~x) fi (~o; ~y). One way to represent such flexibility would be through Multiple Boolean Relations <ref> [15] </ref>, which are arbitrary sets of Boolean relations. 5.1 Sufficient Condition for a Safe Replacement As we argued in the last section, the complete flexibility for safe replacement can be expressed by a multiple Boolean relation.
Reference: [16] <author> S.-W. Jeong, </author> <title> Binary Decision Diagrams and their Applications to Implicit Enumeration Techniques in Logic Synthesis. </title> <type> PhD thesis, </type> <institution> Department of Electrical and Computer Engineering, University of Colorado, Boulder, </institution> <address> CO 80309, </address> <year> 1992. </year>
Reference-contexts: Some natural choices are: * The set of all states Q D 0 . * Any onion ring <ref> [16] </ref> of the design.
Reference: [17] <author> R. K. Brayton, G. D. Hachtel, and A. L. Sangiovanni-Vincentelli, </author> <title> Multilevel Logic Synthesis, </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> vol. 78, </volume> <pages> pp. 264-300, </pages> <month> Feb. </month> <year> 1990. </year>
Reference-contexts: The nodes of the corresponding Boolean network represent the logical functionality of the modules. It has been observed that the area of the hardware implementation of a design is strongly correlated to the total number of literals in the factored form <ref> [17] </ref> representation of the functions at the logic nodes. Thus minimizing the function (with respect to the literal count) at the node constitutes a powerful synthesis technique. <p> These don't cares arise in several ways: * Because of the structure of the network, only a certain subset of B r may be generated by assignments to the inputs. This gives rise to satisfiability don't care (SDC) points for f i <ref> [17] </ref>. * For certain input assignments, the values taken by the primary outputs of N may be independent of the function computed by a node; these are observability don't care points (ODC) for that node [19]. * For certain input assignments the functionality of the node can be changed without destroying
Reference: [18] <author> R. K. Brayton, G. D. Hachtel, C. T. McMullen, and A. L. Sangiovanni-Vincentelli, </author> <title> Logic Minimization Algorithms for VLSI Synthesis. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1984. </year>
Reference-contexts: At any intermediate node of a network there is a local function f i : B r ! B, where r is the cardinality of the support. Node simplification is the process of optimizing a Boolean network by using don't cares in conjunction with a two level minimizer <ref> [18] </ref> to optimize the functions at the nodes. These don't cares arise in several ways: * Because of the structure of the network, only a certain subset of B r may be generated by assignments to the inputs.
Reference: [19] <author> H. Savoj, R. K. Brayton, and H. Touati, </author> <title> Extracting Local Don't Cares for Network Optimization, </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pp. 514-517, </pages> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: This gives rise to satisfiability don't care (SDC) points for f i [17]. * For certain input assignments, the values taken by the primary outputs of N may be independent of the function computed by a node; these are observability don't care points (ODC) for that node <ref> [19] </ref>. * For certain input assignments the functionality of the node can be changed without destroying safe replaceability; this flexi bility leads to the replaceability don't cares points (RDC). <p> This is in terms of primary inputs; we then project this set into the space comprised of the fan-ins of the node (as in <ref> [19] </ref>). These are used in conjunction with a subset of the satisfiability don't care set to optimize the function at u. We are computing all inputs under which the outputs are independent of the function computed at the node. <p> Then we project these don't cares to the immediate fan-ins of the node using the same techniques used for projecting ODC points <ref> [19] </ref>. We observe that for some examples, ODC gives no literal reductions beyond SDC alone but RDC is able to obtain additional, though modest, reductions. These reductions are of the order of 5% on these circuits. On other circuits RDC gives no additional improvements over SDC and ODC.
Reference: [20] <author> E. Cerny and M. A. Marin, </author> <title> An Approach to Unified Methodology of Combinational Switching Circuits, </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. 27, no. 8, </volume> <year> 1977. </year>
Reference-contexts: Let R ( ~ i; ~x; ~o; ~y) be a Boolean relation expressing all the flexibility in the choice of combinational logic for a sequential circuit. Cerny and Marin <ref> [20] </ref> demonstrate a close relationship between optimizing a Boolean network with respect to a given Boolean relation, and computing observability don't care sets. The starting network N must satisfy the relation R. <p> The relation can be viewed as a single node with inputs ~ i; ~x; ~o; ~y; this node is referred to as the observability node. Composing this node with the network as shown in Figure 8 yields an observability network N 0 . It is shown in <ref> [20, 14] </ref> that all the don't cares that can be used to optimize the nodes in N are derivable from the ODC of the node in the network N .
Reference: [21] <author> E. M. Sentovich, K. J. Singh, C. Moon, H. Savoj, R. K. Brayton, and A. L. Sangiovanni-Vincentelli, </author> <title> Sequential Circuit Design Using Synthesis and Optimization, </title> <booktitle> in Proc. Intl. Conf. on Computer Design, </booktitle> <pages> pp. 328-333, </pages> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: need to simplify nodes on an individual basis, and if the node is simplified, potentially all the BDDs for functions that the node fans out to must be recomputed. 6 Experiments We have implemented the above method for sequential resynthesis presented in this paper in the SIS sequential synthesis system <ref> [21] </ref>. We used BDD's to represent all sets and functions and to perform all the set manipulations implicitly. We have performed experiments on the ISCAS89 benchmark suite (from s344 to s1494).
References-found: 21

