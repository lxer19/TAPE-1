URL: ftp://ftp.ifi.unizh.ch/pub/techreports/other_docs/Schema_Transformations.ps.gz
Refering-URL: http://www.ifi.unizh.ch/staff/fuchs.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: -fuchs, fromherz-@ifi.unizh.ch  
Title: Schema-Based Transformations of Logic Programs  
Author: T. P. CLEMENT, K.-K. LAU Norbert E. Fuchs, Markus P. J. Fromherz 
Address: Switzerland  
Affiliation: Institut fr Informatik Universitt Zrich  
Note: (EDS.), LOGIC PROGRAM SYNTHESIS AND TRANSFORMATION, WORKSHOPS IN COMPUTING, SPRINGER VERLAG, 1992 (PROCEEDINGS LOPSTR '91)  
Abstract: Transformation schemata are predefined abstract transformations of logic programs: input program schemata are transformed into output program schemata. Each transformation schema represents one transformation strategy, for example a particular sequence of applications of the unfold/fold rules, or the introduction of an accumulator data structure. The transformation of logic programs with the help of transformation schemata proceeds in three steps: abstraction of the programs to program schemata, selection of a transformation schema with these schemata as input and a suitable schema as output, and specialization of the output schema to the transformed program. Once the transformation schemata are available, user intervention is required only during the selection step. For standard transformation situations one can even envisage eliminating user interaction altogether by heuristics. 
Abstract-found: 1
Intro-found: 1
Reference: [Brna et al. 88] <author> P. Brna, A. Bundy, T. Dodd, M. Eisenstadt, C.K. Looi, H. Pain, B. Smith, M. van Someren, </author> <title> Prolog Programming Techniques, DAI Research Paper, </title> <type> 403, </type> <institution> Department of Artificial Intelligence, University of Edinburgh, </institution> <year> 1988 </year>
Reference-contexts: Schemata can also be used to abstract from programs which rely on the same programming technique, e.g. on accumulators or on difference lists. <ref> [Brna et al. 88] </ref> defined a large number of these techniques. [Robertson 91] showed how programming techniques can be used to teach the construction of logic programs. [Lakhotia 89] demonstrated that standard programming techniques can be incorporated into initial programs with the help of partial evaluation.
Reference: [Burstall & Darlington 77] <author> R. Burstall, J. Darlington, </author> <title> Transformations for Developing Recursive Programs, </title> <journal> JACM, </journal> <volume> Vol. 24, No. 1, </volume> <year> 1977 </year>
Reference-contexts: Logic programming promises to bridge the apparent conflict by providing means to transform specifications into programs. For this reason transformations of logic programs into equivalent, but more efficient forms have a rather long tradition. Often these transformations are based on unfold/fold rules which were introduced by <ref> [Burstall & Darlington 77] </ref> in the context of functional programs. [Tamaki & Sato 84] defined transformations of definite logic programs based on unfolding and folding.
Reference: [Deville & Burnay 90] <author> Y. Deville, J. Burnay, </author> <title> Generalization and Program Schemata. </title> <booktitle> Proceedings of the North American Conference on Logic Programming 1989, </booktitle> <editor> E. L. Lusk, R. A. Overbeek (eds.), </editor> <publisher> MIT Press, </publisher> <month> October </month> <year> 1989, </year> <pages> pp. 409-425. </pages>
Reference-contexts: Programs Since the beginning of logic programming it has been recognized that many logic programs, e.g. list processing programs, are structured similarly, and can be understood as instances of program schemata. 6 Different sets of schemata have been proposed. [O'Keefe 90] defined a set of schemata for recursive programs, while <ref> [Deville & Burnay 90] </ref> suggested schemata as a basis for program construction derived from structural induction and generalization.
Reference: [Gallagher 90] <author> J. Gallagher, </author> <title> Program Analysis and Transformation, </title> <booktitle> Handout at Logic Programming Summer School LPSS '90, </booktitle> <institution> University of Zurich, </institution> <month> August </month> <year> 1990 </year>
Reference-contexts: We will briefly define these three rules following <ref> [Gallagher 90] </ref> and [Gardner & Shepherdson 89]. Other transformation rules, e.g. goal replacement, more specific clauses, and using laws of the predicates, will not be discussed. New Definition Let P be a normal program and D a set of clauses.
Reference: [Gardner & Shepherdson 89] <author> P. A. Gardner, J. C. Shepherdson, </author> <title> Unfold/Fold Transformations of Logic Programs, </title> <type> Report PM-89-01, </type> <institution> School of Mathematics, University of Bristol, </institution> <year> 1989 </year>
Reference-contexts: Their transformations generate equivalent programs in that the least Herbrand model and the computed answers are preserved. <ref> [Gardner & Shepherdson 89] </ref> introduced slightly modified transformations for normal logic programs which preserve procedural semantics for SLDNF resolution and declarative semantics based on Clark's completion. Though the unfold/fold rules preserve the semantics they cannot be used blindly. Their application requires user intervention and thus prevents transformations to be automated. <p> We will briefly define these three rules following [Gallagher 90] and <ref> [Gardner & Shepherdson 89] </ref>. Other transformation rules, e.g. goal replacement, more specific clauses, and using laws of the predicates, will not be discussed. New Definition Let P be a normal program and D a set of clauses.
Reference: [Gegg-Harrison 89] <author> T. S. Gegg-Harrison, </author> <title> Basic Prolog Schemata, </title> <institution> CS-1989-20, Department of Computer Science, Duke University, </institution> <month> September </month> <year> 1989 </year> <month> 14 </month>
Reference-contexts: Section 4 sketches practical problems with these unfold/fold rules and solutions suggested for some of the problems. In section 5 we introduce schemata for logic programs and briefly describe the set of schemata developed by <ref> [Gegg-Harrison 89] </ref>. Section 6 defines transformation schemata as transformations of program schemata, and shows how programs can be transformed with the help of transformation schemata in the three steps abstraction, selection, and specialization. In section 7 we describe the implementation of an experimental transformation system based on transformation schemata. <p> By far the most comprehensive set of schemata was introduced by <ref> [Gegg-Harrison 89] </ref> in the context of a tutoring system. Based on the notion of the most specific generalization, second-order schemata are produced. Applied to a large number of simple recursive list-processing Prolog programs, a hierarchy of Prolog schemata is created. <p> It is an abstraction of programs which rely on divide-and-conquer, e.g. quicksort/2, mergesort/2, and flatten/2. The remaining twelve basic-level schemata describe other ways of processing the elements of a list, e.g. processing only a subset of the elements, or processing from the tail end. Details can be found in <ref> [Gegg-Harrison 89] </ref>. 6 Transformation Schemata Let us assume that a program to be transformed can be described abstractly by a program schema, and the transformed program by another program schema.
Reference: [Lakhotia 89] <author> A. Lakhotia, </author> <title> Incorporating Programming Techniques into Prolog Programs. </title> <booktitle> Proceedings of the North American Conference on Logic Programming 1989, </booktitle> <editor> E. L. Lusk, R. A. Overbeek (eds.), </editor> <publisher> MIT Press, </publisher> <month> October </month> <year> 1989, </year> <pages> pp. 426-440. </pages>
Reference-contexts: Schemata can also be used to abstract from programs which rely on the same programming technique, e.g. on accumulators or on difference lists. [Brna et al. 88] defined a large number of these techniques. [Robertson 91] showed how programming techniques can be used to teach the construction of logic programs. <ref> [Lakhotia 89] </ref> demonstrated that standard programming techniques can be incorporated into initial programs with the help of partial evaluation. By far the most comprehensive set of schemata was introduced by [Gegg-Harrison 89] in the context of a tutoring system.
Reference: [Lakhotia & Sterling 88] <author> A. Lakhotia, L. Sterling, </author> <title> How to Control Unfolding when Specializing Interpreters, </title> <editor> in L. Sterling (ed.), </editor> <title> The Practice of Prolog, </title> <publisher> MIT Press, </publisher> <year> 1990, </year> <pages> pp. 171 </pages>
Reference-contexts: For the case of specializing an interpreter by unfolding it with respect to an object program two strategies have been proposed. [Pereira & Shieber 87] suggested to divide predicates into evaluable and residual ones. <ref> [Lakhotia & Sterling 88] </ref> proposed to restrict the unfolding of the interpreter to its parsing component and to leave its execution component as residue. These strategies reduce and facilitate human intervention but do not eliminate it. Folding also presents problems.
Reference: [Nielson & Nielson 90] <author> H. R. Nielson, F. Nielson, </author> <title> Eureka Definitions for Free Disagreement Points for Fold/Unfold Transformations, </title> <booktitle> Proceedings of ESOP '90, LNCS 432, </booktitle> <year> 1990, </year> <pages> pp. 291-305 </pages>
Reference-contexts: Recently, attempts have been made to derive eureka definitions in a systematic way. [Proietti & Pettorossi 90] introduced two methods to find eureka predicates. They applied these methods successfully to some classes of logic programs. In the realm of functional programs, <ref> [Nielson & Nielson 90] </ref> showed that type information can be used to derive eureka definitions. Unfolding is often possible in many different ways. In our example we unfolded sumlength/3 on sum/2 and the resulting clauses B1 and B2 on length/2.
Reference: [O'Keefe 90] <author> R. A. O'Keefe, </author> <title> The Craft of Prolog. </title> <publisher> MIT Press, </publisher> <year> 1990 </year>
Reference-contexts: replaced by heuristics leading to automatic transformations. 5 Schemata for Logic Programs Since the beginning of logic programming it has been recognized that many logic programs, e.g. list processing programs, are structured similarly, and can be understood as instances of program schemata. 6 Different sets of schemata have been proposed. <ref> [O'Keefe 90] </ref> defined a set of schemata for recursive programs, while [Deville & Burnay 90] suggested schemata as a basis for program construction derived from structural induction and generalization. <p> Schema variables are denoted by &n. We skip Gegg-Harrison's notation for permutations of arguments and literals. Schema A describes many well-known programs, e.g. append/3, length/2, merge/3, and naive_reverse/2. It is interesting to note that two of O'Keefe's schemata for recursive list processing programs <ref> [O'Keefe 90] </ref> the tower method and the tail recursive linear method are covered by schema A. Schema B resembles schema A, but is doubly recursive. It is an abstraction of programs which rely on divide-and-conquer, e.g. quicksort/2, mergesort/2, and flatten/2.
Reference: [Pereira & Shieber 87] <author> F. C. N. Pereira, S. M. Shieber, </author> <title> Prolog and Natural-Language Analysis, </title> <type> CSLI, Lectures Notes 10, </type> <year> 1987 </year>
Reference-contexts: This means that human intervention is required to control unfolding, and that there is a great need for guidelines. For the case of specializing an interpreter by unfolding it with respect to an object program two strategies have been proposed. <ref> [Pereira & Shieber 87] </ref> suggested to divide predicates into evaluable and residual ones. [Lakhotia & Sterling 88] proposed to restrict the unfolding of the interpreter to its parsing component and to leave its execution component as residue. These strategies reduce and facilitate human intervention but do not eliminate it.
Reference: [Proietti & Pettorossi 90] <author> M. Proietti, A. Pettorossi, </author> <title> Synthesis of Eureka Predicates for Developing Logic Programs, </title> <booktitle> Proceedings of ESOP '90, LNCS 432, </booktitle> <year> 1990, </year> <pages> pp. 306-325 </pages>
Reference-contexts: Introducing the predicate sumlength/3 seems obvious, but how we got the idea in the first place remains unclear. Recently, attempts have been made to derive eureka definitions in a systematic way. <ref> [Proietti & Pettorossi 90] </ref> introduced two methods to find eureka predicates. They applied these methods successfully to some classes of logic programs. In the realm of functional programs, [Nielson & Nielson 90] showed that type information can be used to derive eureka definitions.
Reference: [Robertson 91] <author> D. Robertson, </author> <title> A Simple Prolog Techniques Editor for Novice Users, </title> <booktitle> Proceedings of ALPUK 91, 3rd Annual Conference on Logic Programming, </booktitle> <address> Edinburgh, </address> <month> April </month> <year> 1991 </year>
Reference-contexts: Schemata can also be used to abstract from programs which rely on the same programming technique, e.g. on accumulators or on difference lists. [Brna et al. 88] defined a large number of these techniques. <ref> [Robertson 91] </ref> showed how programming techniques can be used to teach the construction of logic programs. [Lakhotia 89] demonstrated that standard programming techniques can be incorporated into initial programs with the help of partial evaluation.
Reference: [Tamaki & Sato 84] <author> H. Tamaki, T. Sato, </author> <title> Unfold/Fold Transformation of Logic Programs, </title> <booktitle> Proceedings of the Second International Conference on Logic Programming, </booktitle> <address> Uppsala, </address> <year> 1984, </year> <editor> S. - . Trnlund (ed.), </editor> <publisher> University of Uppsala, </publisher> <pages> pp. 127 - 138 </pages>
Reference-contexts: For this reason transformations of logic programs into equivalent, but more efficient forms have a rather long tradition. Often these transformations are based on unfold/fold rules which were introduced by [Burstall & Darlington 77] in the context of functional programs. <ref> [Tamaki & Sato 84] </ref> defined transformations of definite logic programs based on unfolding and folding.
Reference: [Waldau 91] <author> M. Waldau, </author> <title> Formal Validation of Transformation Schemas Using First-Order Proofs, </title> <booktitle> Proceedings of LOPSTR '91, University of Manchester, Springer Workshop in Computing Series (this volume), </booktitle> <year> 1991 </year>
Reference-contexts: Thirdly, as demonstrated transformation schemata need not be derived from unfold/fold rules. Any set of semantics-preserving transformation rules can be used. Fourthly, instead of deriving transformation schemata from transformation rules we could invent transformation schemata and post factum prove them correct. <ref> [Waldau 91] </ref> proposes to validate transformation schemata by formal proofs based on intuitionistic logic.
References-found: 15

