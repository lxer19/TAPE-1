URL: http://www.cs.virginia.edu/~cooper/clock_synch.ps
Refering-URL: http://www.cs.virginia.edu/~cooper/
Root-URL: http://www.cs.virginia.edu
Title: Best Effort Internal Byzantine Clock Synchronization  
Author: David A. Cooper 
Address: Charlottesville, VA 22903  
Affiliation: Department of Computer Science University of Virginia  
Abstract: In this paper, we describe a new variation of clock synchronization which we call best effort clock synchronization. Best effort clock synchronization is similar to failure-aware clock synchronization [2] in that, unlike traditional clock synchronization, it can be implemented in a timed asynchronous system [1]. However, unlike failure-aware clock synchronization, the virtual clocks maintained by correct processes are defined by intervals of time which must remain consistent even when the system is behaving in an "unstable" manner. We also present a protocol which implements best effort clock synchronization in a timed asynchronous system which is vulnerable to arbitrary process and link failures. The protocol maintains clock synchronization as long as fewer than one-third of the processes fail. Our protocol can handle any number of link failures, but the sizes the virtual clocks' intervals will only be bounded when the system is stable.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Cristian and F. Schmuck. </author> <title> Agreeing on processor-group membership in asynchronous distributed systems. </title> <type> Technical Report CSE95-428, </type> <institution> Dept. of Computer Science and Engineering, University of California, </institution> <address> San Diego, </address> <year> 1995. </year>
Reference-contexts: Generally, the lower bound is used for creating timestamps and the upper bound is used to determine if an expiration time has been reached. 3 System Model The model for which we designed our protocol is based on the timed asynchronous system model <ref> [1] </ref>. This model is identical to the asynchronous system model with two exceptions. First, each correct process has access to a local hardware clock with a known maximum drift rate, .
Reference: [2] <author> Christof Fetzer and Flaviu Cristian. </author> <title> Fail-awareness in timed asynchronous systems. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Principles of Distributed Computing, </booktitle> <month> May </month> <year> 1996. </year>
Reference-contexts: More recently, Fetzer and Cristian <ref> [2] </ref> developed the concept of failure-aware clock synchronization. Just as in traditional clock synchronization, failure-aware clock synchronization uses the concept of a synchrony assumption. However, in a manner similar to best effort clock synchronization, failure-aware clock synchronization does not require that the synchrony assumption always hold. <p> A protocol which only satisfied these first three properties could be similar in nature to a failure 5 Throughout this paper, we use P to represent the set of all processes and P 0 to represent the set of all correct processes. 5 aware clock synchronization protocol <ref> [2] </ref>: A correct process, p, whose clock is within t of all other correct processes could set its interval to fi 2 : : : C p (t) + t fl .
Reference: [3] <author> Li Gong. </author> <title> A security risk of depending on synchronized clocks. </title> <journal> Operating Systems Review, </journal> <volume> 26(1) </volume> <pages> 49-53, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: 1 Introduction The availability of synchronized clocks can be very useful in the design of protocols for distributed systems. At the same time, reliance on synchronized clocks exposes an additional avenue of attack against a system <ref> [3] </ref>. A determined intruder may attempt to induce a clock synchronization failure by subverting clock servers, causing clock servers to experience excessive scheduling delays, or by forging, modifying, deleting, duplicating or delaying messages.
Reference: [4] <author> Andrew S. Grimshaw, Wm. A. Wulf, </author> <title> and the Legion team. The Legion vision of a worldwide virtual computer. </title> <journal> Communications of the ACM, </journal> <volume> 40(1) </volume> <pages> 39-45, </pages> <month> January </month> <year> 1997. </year>
Reference-contexts: A determined intruder may attempt to induce a clock synchronization failure by subverting clock servers, causing clock servers to experience excessive scheduling delays, or by forging, modifying, deleting, duplicating or delaying messages. The clock synchronization protocol that is presented in this paper was designed for use in Legion <ref> [4] </ref>, an object-oriented distributed computing system. Since a Legion system may include thousands or even millions of objects, it would be infeasible for every object to be directly involved in an internal clock synchronization scheme.
Reference: [5] <author> Keith Marzullo. </author> <title> Tolerating failures of continuous-valued sensors. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(4) </volume> <pages> 284-304, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: In this paper, we will only describe the protocol that we have designed for the internal clock synchronization of the servers. The clients can use a fault tolerant protocol such as the one described in <ref> [5] </ref>. Since, in Legion, objects may be created or may migrate at any time, the clock synchronization service must be highly available. In order to be both secure and highly available, a fault-tolerant, replicated protocol must be used.
Reference: [6] <author> Keith Marzullo and Susan Owicki. </author> <title> Maintaining the time in a distributed system. </title> <journal> Operating Systems Review, </journal> <volume> 19(3) </volume> <pages> 44-54, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: In order to be able to assure that the clocks do not drift too far apart, certain synchrony assumptions are made about the system. One early exception to the protocols requiring a synchrony assumption is the clock synchronization protocol of Marzullo and Owicki <ref> [6] </ref>. In their protocol, each process maintains a clock interval. Processes periodically poll each others' clock intervals (which are expanded to account for the uncertainty in message delay) and then compute an intersection to create a new, hopefully smaller, clock interval.
Reference: [7] <author> Michael K. Reiter, Kenneth P. Birman, and Robbert van Renesse. </author> <title> A security architecture for fault-tolerant systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 12(4) </volume> <pages> 340-371, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Thus, failure-aware clock synchronization is the closest to best effort clock synchronization. The main difference is that in best effort clock synchronization, processes must maintain a clock which is consistent with all other clocks even when the synchrony assumption does not hold. In <ref> [7] </ref>, Reiter, Birman, and van Renesse describe how synchronized clocks which are defined as intervals can be used in a practical system. In this paper, a clock synchronization protocol which provides properties similar to those of best effort clock synchronization is used. <p> While the system presented in <ref> [7] </ref> demonstrates that best effort clock synchronization has practical applications, we feel that further exploration is necessary in order to ascertain its full potential. Acknowledgements We would like to thank Darrell Kienzle, Mike Nahas, Brett Tjaden, Chenxi Wang, and Bill Wulf for their helpful comments and suggestions.
Reference: [8] <author> F. Schneider. </author> <title> Understanding protocols for Byzantine clock synchronization. </title> <type> Technical Report TR 87-859, </type> <institution> Department of Computer Science, Cornell University, </institution> <month> August </month> <year> 1987. </year> <month> 12 </month>
Reference-contexts: While the problem statement or system model used for each of these protocols may vary, most are designed to solve a very similar problem <ref> [8] </ref>. The goal of most clock synchronization protocols is to solve what we call the traditional clock synchronization problem: There is a group of processes each of which maintains a virtual clock. These virtual clocks are manipulated by the protocol in order to keep them close together.
References-found: 8

