URL: http://www.cse.ogi.edu/~mbs/pub/dyntyping_tr.ps.gz
Refering-URL: http://www.cse.ogi.edu/~mbs/
Root-URL: http://www.cse.ogi.edu
Email: mbs@dcs.glasgow.ac.uk  sheard@cse.ogi.edu  simonpj@dcs.glasgow.ac.uk  
Title: Dynamic Typing as Staged Type Inference  
Author: Mark Shields Tim Sheard Simon Peyton Jones 
Date: August, 1997 Revised October, 1997  
Address: Glasgow  Glasgow  
Affiliation: University of  Oregon Graduate Institute  University of  Glasgow  
Pubnum: Technical Report TR-1997-26  
Abstract: Dynamic typing extends statically typed languages with a universal datatype, simplifying programs which must manipulate other programs as data, such as distributed, persistent, interpretive and generic programs. Current approaches, however, limit the use of polymorphism in dynamic values, and can be syntactically awkward. We introduce a new approach to dynamic typing, based on staged computation, which allows a single type-reconstruction algorithm to execute partly at compile time and partly at run-time. This approach seamlessly extends a single type system to accommodate types that are only known at run-time, while still supporting both type inference and polymor-phism. The system is significantly more expressive than other approaches. Furthermore it can be implemented efficiently; most of the type inference is done at compile-time, leaving only some residual unification for run-time. We demonstrate our approach by examples in a small polymorphic functional language, and present its type system, type reconstruction algorithm, and operational semantics. Our proposal could also be readily adapted to many other programming languages.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi, L. Cardelli, B. Pierce, and G. Plotkin. </author> <title> Dynamic typing in a statically typed language. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(2) </volume> <pages> 237-268, </pages> <month> Apr </month> <year> 1991. </year>
Reference-contexts: If, however, the set of types is not known in advance, or is infinite, a universal datatype is required. This is typically impossible for a user to implement if the universal type embeds functions, especially in the presence of polymorphism. Existing proposals for dynamic typing <ref> [1, 20, 2] </ref> solve this problem by introducing a universal datatype of type Dyn as a language primitive, along with two operations: * dynamic t:t , which constructs a dynamic value containing both term t and a represen tation of its type t . * typecase d of fx 1 : <p> Static types are generally inferred, and may be implicitly polymorphic with little added complexity for the programmer. Dynamic types must be mentioned explicitly within the branches of a typecase, and dynamic polymorphism is either forbidden <ref> [1] </ref>, restricted [20], or requires the complex machinery of functors and higher order unification [2]. * Combining dynamic values together to construct a new dynamic value is tedious and verbose to write, since each constituent value requires a separate typecase, and the result must be wrapped by dynamic. x3 will demonstrate <p> Solutions to the dual problem of adding dynamic types to a statically typed language appear in CLU and Cedar/Mesa (see <ref> [1] </ref> for a discussion), and were first considered for ML in unpublished work of Mycroft [25]. Most proposals to date have been variations on the typecase construct illustrated in the introduction. These vary in their "resolving power": the ability to distinguish dynamic values based on their type within a typecase. <p> Most proposals to date have been variations on the typecase construct illustrated in the introduction. These vary in their "resolving power": the ability to distinguish dynamic values based on their type within a typecase. At the simpler end of the spectrum is the system of Abadi et al <ref> [1] </ref>, which allows typecase patterns to contain type variables in order to express type dependencies within and between dynamic values. This means a family of dynamic values may be matched by a single typecase arm. However all dynamic values must be monomorphic. <p> Their simplest system allows a polymorphic dynamic value to be distinguished from all of its instances, and also allows a polymorphic dynamic value to be type specialised when pattern matching. Their more complex system also allows type variables within patterns much as in <ref> [1] </ref>. Pattern matching within typecase is formalised as first-order unification under a mixed quantifier prefix. Universally quantified variables denote where a pattern may match a family of dynamic values, where as existentially quantified variables denote where a pattern may match only suitably polymorphic dynamic values. <p> Dubois et al [12] allow functions to implicitly bind the types of their arguments, and also provide a typecase construct to support generic programming. The extension of <ref> [1] </ref> to arbitrary polymorphic dynamic values has also been considered by Abadi et al [2]. Their proposal extends patterns with higher order functor variables in order to match dynamic values with arbitrary polymorphic types. <p> We wish to develop a denotational semantics and semantic soundness theorem to complement the purely syntactical presentation of this paper. Models for monomorphic dynamic values <ref> [1] </ref> and two-level languages [24] have been developed in isolation. Their combination and general-isation to polymorphic dynamic values is non-trivial. Note, however, that their generalisation to arbitrary stages instead of just two should not be problematic, as all stages &gt; 0 may be collapsed to a single dynamic stage.
Reference: [2] <author> M. Abadi, L. Cardelli, B. Pierce, and D. Remy. </author> <title> Dynamic typing in polymorphic languages. </title> <journal> Journal of Functional Programming, </journal> <volume> 5(1) </volume> <pages> 111-130, </pages> <month> Jan </month> <year> 1995. </year>
Reference-contexts: If, however, the set of types is not known in advance, or is infinite, a universal datatype is required. This is typically impossible for a user to implement if the universal type embeds functions, especially in the presence of polymorphism. Existing proposals for dynamic typing <ref> [1, 20, 2] </ref> solve this problem by introducing a universal datatype of type Dyn as a language primitive, along with two operations: * dynamic t:t , which constructs a dynamic value containing both term t and a represen tation of its type t . * typecase d of fx 1 : <p> Static types are generally inferred, and may be implicitly polymorphic with little added complexity for the programmer. Dynamic types must be mentioned explicitly within the branches of a typecase, and dynamic polymorphism is either forbidden [1], restricted [20], or requires the complex machinery of functors and higher order unification <ref> [2] </ref>. * Combining dynamic values together to construct a new dynamic value is tedious and verbose to write, since each constituent value requires a separate typecase, and the result must be wrapped by dynamic. x3 will demonstrate many instances where this is required. <p> Abadi et al <ref> [2] </ref> introduced a sufficient syntactic condition on the use of functor variables to guarantee the definiteness of solutions to these unification problems. We argue that our approach, to reject such terms altogether, simplifies our semantics greatly, allows significant implementation optimisations, and does not reduce expressibility critically. <p> Importantly, this restriction only applies to let-bound terms within a defer expression, and not to the way defer expressions are spliced or run. Compare this with the system of Abadi et al <ref> [2] </ref>, which requires higher-order unification to be able to manage dynamic values of polymorphic type. In practice this restriction is too severe; indeed the careful reader will have noticed the let bound expressions in the spectrograph example of x3.2 are not splice-free. <p> Dubois et al [12] allow functions to implicitly bind the types of their arguments, and also provide a typecase construct to support generic programming. The extension of [1] to arbitrary polymorphic dynamic values has also been considered by Abadi et al <ref> [2] </ref>. Their proposal extends patterns with higher order functor variables in order to match dynamic values with arbitrary polymorphic types. This adds a significant complexity to the language, and functors must be syntactically restricted to avoid requiring full higher-order 48 unification. <p> Once polymorphism is introduced the picture is less clear. We argue that our proposal is conceptually much simpler than that of Abadi et al <ref> [2] </ref>. We also argue that the additional expressiveness of our system over that of Leroy and Mauny [20] can be exploited to add features such as pretty-printing (x3.1) and dynamic code linking (x3.2) to a language simply by the addition of a few primitive functions.
Reference: [3] <author> A. Aiken and E. L. Wimmers. </author> <title> Type inclusion constraints and type inference. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 31-41, </pages> <year> 1993. </year>
Reference-contexts: Another is to use a more expressive static type system. For example, ad-hoc polymorphism [31], existential types [27], subtyping polymorphism [8], and set-based types <ref> [3] </ref> all help make writing some of the above programs feasible. A third approach, when the set of types is finite and known at compile-time, is to embed values within a user-defined datatype, effectively tagging them by their type. We call such tagged values dynamic values.
Reference: [4] <author> A. Aiken, E. L. Wimmers, and T. K. Lakshman. </author> <title> Soft typing with conditional types. </title> <booktitle> In Proceedings of the Twenty-First Annual ACM Symposium on Principles of Programming Languages, Portland, Oregon, </booktitle> <pages> pages 163-173, </pages> <year> 1994. </year>
Reference-contexts: One approach is to abandon static type checking altogether, and instead, tag every run-time value with type information to gracefully detect ill-typed code. Some of the benefits of static typing may be regained by "soft typing" static analyses <ref> [4] </ref>, which can identify programs which will always fail with a type error, and elide tag checks which will always succeed. Another is to use a more expressive static type system. <p> For these reasons we prefer to leave the check for closed code within the run rewrite rule. 7 Related Work Much work in dynamic typing has concentrated on soft typing: static analyses which determine when run-time type checks may be safely elided from programs in untyped languages <ref> [9, 4, 15] </ref>. Solutions to the dual problem of adding dynamic types to a statically typed language appear in CLU and Cedar/Mesa (see [1] for a discussion), and were first considered for ML in unpublished work of Mycroft [25].
Reference: [5] <author> M. P. Atkinson, L. Daynes, M. J. Jordan, T. Printezis, and S. Spence. </author> <title> An orthogonally persistent Java. </title> <journal> ACM SIGMOD Record, </journal> <volume> 25(4) </volume> <pages> 68-75, </pages> <month> Dec </month> <year> 1996. </year>
Reference-contexts: true else x 1) 2i 7!! run (hntostr ((x : if x = 0 then true else x 1) 2)i; : : :) 7!! run (hbtostr ((x : if x = 0 then true else x 1) 2)i; "type error") 7!! "type error" 3.4 Persistent Programming Persistent programming languages (e.g., <ref> [5, 17] </ref>) partition memory into two spaces. The live space contains data in its usual in-memory form, while the persistent space stores data in a universal form which persists across program invocations. Data may be moved between the two spaces with varying degrees of transparency.
Reference: [6] <author> H. Barendregt. </author> <title> Introduction to generalized type systems. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(2) </volume> <pages> 125-154, </pages> <year> 1991. </year>
Reference-contexts: = x in (f 1 true; f 2 3) 15 would be annotated as let f :8ff; fi : ff ! fi ! ff = ff; fi:fl : x :ff : y:fi : x in (f Nat Bool 1 true; f Nat Nat 2 3) As in pure type systems <ref> [6] </ref> we use ff : fl : t for type abstraction instead of the usual flff : t, and use fl to denote the kind of all types. <p> As type variables may also be bound at arbitrary stages, we let also map type variables to their kind and stage, much as in pure type systems <ref> [6] </ref>. We abbreviate sequences of type variable bindings within by a single type variable vector binding. must be ordered because a term variable's type may contain a type variable bound at an outer scope. Let n be with all term and type variables at stage &gt; n removed.
Reference: [7] <author> H. P. Barendregt. </author> <title> Lambda calculi with types. </title> <editor> In S. Abramsky, D. M. Gabbay, and T. S. E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> volume 2, chapter 2, </volume> <pages> pages 117-309. </pages> <publisher> Oxford Science Publishers, </publisher> <year> 1992. </year>
Reference-contexts: The previous example is fully annotated as: hff; fi:fl ` x :ff : (x ; ( ~ f :ff ! fi) x ) : (ff; fi)i hFaili denotes an ill-typed deferred expression. Following Barendregt <ref> [7] </ref> we assume all terms and types are hygienic, that is, every bound variable is distinct from every free variable of its context. We also take care to maintain this invariant during reduction. <p> It is defined much as in Barendregt <ref> [7] </ref>, and takes care to rename the bound variables in lambda abstractions, type abstractions, let and letrec expressions, and the type variable list of deferred expressions. This will be important in x5.5.2. Figures 5, 6 and 7 contain the formal definitions.
Reference: [8] <author> L. Cardelli, S. Martini, J. C. Mitchell, and A. Scedrov. </author> <title> An extension of system F with subtyping. </title> <journal> Information and Computation, </journal> 109(1/2):4-56, 1994. <volume> 50 </volume>
Reference-contexts: Another is to use a more expressive static type system. For example, ad-hoc polymorphism [31], existential types [27], subtyping polymorphism <ref> [8] </ref>, and set-based types [3] all help make writing some of the above programs feasible. A third approach, when the set of types is finite and known at compile-time, is to embed values within a user-defined datatype, effectively tagging them by their type. We call such tagged values dynamic values.
Reference: [9] <author> R. Cartwright and M. Fagan. </author> <title> Soft typing. </title> <booktitle> In ACM SIGPLAN-91 Conference on Pro--gramming Language Design and Implementation, </booktitle> <address> Toronto, Ontario, </address> <pages> pages 278-292. </pages> <publisher> ACM Press, </publisher> <month> Jun </month> <year> 1991. </year>
Reference-contexts: For these reasons we prefer to leave the check for closed code within the run rewrite rule. 7 Related Work Much work in dynamic typing has concentrated on soft typing: static analyses which determine when run-time type checks may be safely elided from programs in untyped languages <ref> [9, 4, 15] </ref>. Solutions to the dual problem of adding dynamic types to a statically typed language appear in CLU and Cedar/Mesa (see [1] for a discussion), and were first considered for ML in unpublished work of Mycroft [25].
Reference: [10] <author> R. Davies. </author> <title> A temporal logic approach to binding-time analysis. </title> <editor> In E. Clarke, editor, </editor> <booktitle> Proceedings of the Eleventh Annual IEEE Symposium on Logic in Computer Science, </booktitle> <address> New Brunswick, New Jersey, </address> <pages> pages 184-195. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> Jul </month> <year> 1996. </year>
Reference-contexts: This approach requires the programmer to perform complex type checking explicitly. It is also fairly verbose compared with our solution: apply : hi ! hi ! hi apply df dx = h ~ df ~ dx i Our approach is motivated by the recent work of Davies and Pfenning <ref> [11, 10] </ref> and Taha and Sheard [29] in staged computation. Our hi and ~ operators correspond with the next and prev constructs of [11], extended to allow the cross-stage persistence of [29].
Reference: [11] <author> R. Davies and F. Pfenning. </author> <title> A modal analysis of staged computation. </title> <booktitle> In Proceedings of the 23rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <address> St. Petersburg Beach, Florida, </address> <pages> pages 258-270. </pages> <publisher> ACM Press, </publisher> <month> Jan </month> <year> 1996. </year>
Reference-contexts: Our main contribution is to regard dynamic typing as staged type inference, in which some program expressions have their type inference deferred until sufficient context is known at run-time. This approach builds directly on a general notion of staged computation <ref> [11, 29] </ref>, and is free of the above problems: * We introduce three operators for manipulating values of dynamic type, which make creating, combining and using dynamic values easy and concise (x2.2). <p> Then a run expression is rewritten by: 0 i) ! t 0 The restriction of these rules to splice-free and (for run) closed terms will be explained in x5. These operators have been studied by Davies and Pfenning <ref> [11] </ref> and Taha and Sheard [29], and can be seen as generalising the work of Nielson and Nielson on two level functional languages [26]. <p> This approach requires the programmer to perform complex type checking explicitly. It is also fairly verbose compared with our solution: apply : hi ! hi ! hi apply df dx = h ~ df ~ dx i Our approach is motivated by the recent work of Davies and Pfenning <ref> [11, 10] </ref> and Taha and Sheard [29] in staged computation. Our hi and ~ operators correspond with the next and prev constructs of [11], extended to allow the cross-stage persistence of [29]. <p> Our hi and ~ operators correspond with the next and prev constructs of <ref> [11] </ref>, extended to allow the cross-stage persistence of [29]. Our run operator corresponds to the unbox pop operation of [11], with an appropriate dynamic check for closure. 8 Conclusions and Future Work We presented an approach to dynamic typing which extends staged computation to also stage type inference, and demonstrated its <p> Our hi and ~ operators correspond with the next and prev constructs of <ref> [11] </ref>, extended to allow the cross-stage persistence of [29]. Our run operator corresponds to the unbox pop operation of [11], with an appropriate dynamic check for closure. 8 Conclusions and Future Work We presented an approach to dynamic typing which extends staged computation to also stage type inference, and demonstrated its convenience in programming examples for which type information is difficult (e.g., sprintf x3.1) or impossible (e.g., getCode x3.2) to
Reference: [12] <author> C. Dubois, F. Rouaix, and P. Weis. </author> <title> Extensional polymorphism. </title> <booktitle> In Proceedings of the 22nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, California, </address> <pages> pages 118-129. </pages> <publisher> ACM Press, </publisher> <month> Jan </month> <year> 1995. </year>
Reference-contexts: Pattern matching within typecase is formalised as first-order unification under a mixed quantifier prefix. Universally quantified variables denote where a pattern may match a family of dynamic values, where as existentially quantified variables denote where a pattern may match only suitably polymorphic dynamic values. Dubois et al <ref> [12] </ref> allow functions to implicitly bind the types of their arguments, and also provide a typecase construct to support generic programming. The extension of [1] to arbitrary polymorphic dynamic values has also been considered by Abadi et al [2].
Reference: [13] <author> J.-Y. Girard. </author> <title> The system F of variable types, Fifteen years later. </title> <editor> In G. Huet, editor, </editor> <booktitle> Logical Foundations of Functional Programming, The UT Year of Programming Series, chapter 6. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Thus x : x + 1 is annotated as x : Nat : x + 1. * We make all type generalisation and specialisation explicit using the type abstraction and application of System F <ref> [13] </ref>.
Reference: [14] <author> J. Hatcliff and O. Danvy. </author> <title> Thunks and the lambda-calculus. </title> <journal> Journal of Functional Programming, </journal> <volume> 7(3) </volume> <pages> 303-319, </pages> <month> May </month> <year> 1997. </year>
Reference-contexts: We plan to introduce a new type quantifier for type variables which interact with dynamic values, thus restoring parametricity. Finally, we have presented dyn as a call-by-value calculus. Using the well known embedding of the call-by-name lambda-calculus into the call-by-value calculus <ref> [14] </ref>, we could use dyn as an intermediate language for a call-by-name language in which let-bound expressions (which create thunks or closures, which we represent as deferred expressions) could be tagged as statically or dynamically typed. This could be used to add a simple form of dynamic typing to Haskell.
Reference: [15] <author> F. Henglein and J. Rehof. </author> <title> Safe polymorphic type inference for a dynamically typed language: Translating Scheme to ML. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 192-203. </pages> <publisher> ACM Press, </publisher> <month> Jun </month> <year> 1995. </year>
Reference-contexts: For these reasons we prefer to leave the check for closed code within the run rewrite rule. 7 Related Work Much work in dynamic typing has concentrated on soft typing: static analyses which determine when run-time type checks may be safely elided from programs in untyped languages <ref> [9, 4, 15] </ref>. Solutions to the dual problem of adding dynamic types to a statically typed language appear in CLU and Cedar/Mesa (see [1] for a discussion), and were first considered for ML in unpublished work of Mycroft [25].
Reference: [16] <author> N. D. Jones, C. K. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice Hall International, </publisher> <year> 1993. </year>
Reference-contexts: These operators have been studied by Davies and Pfenning [11] and Taha and Sheard [29], and can be seen as generalising the work of Nielson and Nielson on two level functional languages [26]. They may be used to improve efficiency by allowing programs to be partially evaluated on-line <ref> [16] </ref>. 2.2 Staged Type Inference Our proposal extends these operators to stage the type inference of dynamic expressions along with their evaluation. 4 * hti now defers both the type inference and evaluation of t by one stage: 1 + 1 : Nat inferred at compile-time 1 + 1 7!! 2
Reference: [17] <author> W. Klas and V. Turau. </author> <title> Persistence in the object-oriented database programming language VML. </title> <type> Technical Report TR-92-045, </type> <institution> International Computer Science Institute, Berkeley, </institution> <address> CA, </address> <month> Jul </month> <year> 1992. </year>
Reference-contexts: true else x 1) 2i 7!! run (hntostr ((x : if x = 0 then true else x 1) 2)i; : : :) 7!! run (hbtostr ((x : if x = 0 then true else x 1) 2)i; "type error") 7!! "type error" 3.4 Persistent Programming Persistent programming languages (e.g., <ref> [5, 17] </ref>) partition memory into two spaces. The live space contains data in its usual in-memory form, while the persistent space stores data in a universal form which persists across program invocations. Data may be moved between the two spaces with varying degrees of transparency.
Reference: [18] <author> J. Launchbury and S. Peyton Jones. </author> <title> State in Haskell. </title> <journal> Journal of Lisp and Symbolic Computation, </journal> <volume> 8(4) </volume> <pages> 293-341, </pages> <month> Dec </month> <year> 1995. </year>
Reference-contexts: We intend the judgement j ` n t : to be true when t has type in context at stage n, and all variables free in t's context are tagged by the environment name from corresponding to their stage. Reader's familiar with the work of Launchbury and Peyton Jones <ref> [18] </ref> will recognise our run type as corresponding to the rank-2 polymorphism of the runST operator of the Haskell state monad: runST : 8ff : (8fi : ST fi ff) ! ff and the use of environment names as corresponding to the "dummy" state type variable in the typing rules for
Reference: [19] <author> P. Lee and M. Leone. </author> <title> Optimizing ML with run-time code generation. </title> <booktitle> In ACM SIGPLAN-96 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 137-148, </pages> <address> Philadelphia, Pennsylvania, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: We currently only have an interpreted implementation of a superset of dyn, so its feasibility will only be known once an abstract machine and compiled implementation exist. Implementing code splicing and run-time type unification efficiently are the primary challenges. The work of Lee and Leone on run-time code generation <ref> [19] </ref> suggests the overhead for splicing may be only a small factor, and the extensive body of research on efficient unification for Prolog suggests type unification could also be inexpensive. We wish to develop a denotational semantics and semantic soundness theorem to complement the purely syntactical presentation of this paper.
Reference: [20] <author> X. Leroy and M. Mauny. </author> <title> Dynamics in ML. </title> <journal> Journal of Functional Programming, </journal> <volume> 3(4) </volume> <pages> 431-463, </pages> <year> 1993. </year>
Reference-contexts: If, however, the set of types is not known in advance, or is infinite, a universal datatype is required. This is typically impossible for a user to implement if the universal type embeds functions, especially in the presence of polymorphism. Existing proposals for dynamic typing <ref> [1, 20, 2] </ref> solve this problem by introducing a universal datatype of type Dyn as a language primitive, along with two operations: * dynamic t:t , which constructs a dynamic value containing both term t and a represen tation of its type t . * typecase d of fx 1 : <p> Static types are generally inferred, and may be implicitly polymorphic with little added complexity for the programmer. Dynamic types must be mentioned explicitly within the branches of a typecase, and dynamic polymorphism is either forbidden [1], restricted <ref> [20] </ref>, or requires the complex machinery of functors and higher order unification [2]. * Combining dynamic values together to construct a new dynamic value is tedious and verbose to write, since each constituent value requires a separate typecase, and the result must be wrapped by dynamic. x3 will demonstrate many instances <p> This means a family of dynamic values may be matched by a single typecase arm. However all dynamic values must be monomorphic. Two approaches to supporting polymorphic dynamic values have been explored by Leroy and Mauny <ref> [20] </ref>. Their simplest system allows a polymorphic dynamic value to be distinguished from all of its instances, and also allows a polymorphic dynamic value to be type specialised when pattern matching. Their more complex system also allows type variables within patterns much as in [1]. <p> Once polymorphism is introduced the picture is less clear. We argue that our proposal is conceptually much simpler than that of Abadi et al [2]. We also argue that the additional expressiveness of our system over that of Leroy and Mauny <ref> [20] </ref> can be exploited to add features such as pretty-printing (x3.1) and dynamic code linking (x3.2) to a language simply by the addition of a few primitive functions. There are five main avenues for future research.
Reference: [21] <author> Microsoft. </author> <title> The component object model specification. </title> <type> Technical report, </type> <institution> Microsoft Corporation, </institution> <year> 1995. </year>
Reference-contexts: Using this strategy, a print function may be generated once, and re-applied many times, without the need to re-traverse the format string or re-type-check the resulting code. 3.2 Distributed Computing The distributed programming model popularised by Java and the Microsoft Component Object Model <ref> [21] </ref> allows library code residing on potentially remote machines to be linked, at run-time, into a running program. One challenge is to ensure such distributed programs remain well-typed. We show how our approach supports type-safe distributed programming with little impact on the underlying language.
Reference: [22] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: Rule run ensures t yields a defer expression, and the exception expression u has a type consistent with the run expression's context. Finally, the judgement ` context with rules given in Figure 11, is true when is a well-formed type context. 5.4 Type Annotation W <ref> [22] </ref>. We use the deductive style, motivated by the presentation in [27].
Reference: [23] <author> J. C. Mitchell and G. D. Plotkin. </author> <title> Abstract types have existential type. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(3) </volume> <pages> 470-502, </pages> <month> Jul </month> <year> 1988. </year>
Reference-contexts: The type hi of dynamic expressions corresponds closely to the strong sum type 9ff : ff of dependent type theory [30], which is well known to model abstract data types <ref> [23] </ref>.
Reference: [24] <author> E. Moggi. </author> <title> A categorical account of two-level languages. </title> <booktitle> In Proceedings of the Thirteenth Annual Conference on Mathematical Foundations of Programming Semantics, Electronic Notes in Theoretical Computer Science Volume 6. </booktitle> <publisher> Elsevier Science Publishers, </publisher> <year> 1997. </year>
Reference-contexts: We wish to develop a denotational semantics and semantic soundness theorem to complement the purely syntactical presentation of this paper. Models for monomorphic dynamic values [1] and two-level languages <ref> [24] </ref> have been developed in isolation. Their combination and general-isation to polymorphic dynamic values is non-trivial. Note, however, that their generalisation to arbitrary stages instead of just two should not be problematic, as all stages &gt; 0 may be collapsed to a single dynamic stage.
Reference: [25] <author> A. Mycroft. </author> <title> Dynamic types in ML. </title> <note> (unpublished draft article), 1983. 51 </note>
Reference-contexts: Solutions to the dual problem of adding dynamic types to a statically typed language appear in CLU and Cedar/Mesa (see [1] for a discussion), and were first considered for ML in unpublished work of Mycroft <ref> [25] </ref>. Most proposals to date have been variations on the typecase construct illustrated in the introduction. These vary in their "resolving power": the ability to distinguish dynamic values based on their type within a typecase.
Reference: [26] <author> F. Nielson and H. R. Nielson. </author> <title> Two-level Functional Languages. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: These operators have been studied by Davies and Pfenning [11] and Taha and Sheard [29], and can be seen as generalising the work of Nielson and Nielson on two level functional languages <ref> [26] </ref>.
Reference: [27] <author> M. Odersky and K. Laufer. </author> <title> Putting type annotations to work. </title> <booktitle> In Proceedings of the 23rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <address> St. Petersburg Beach, Florida, </address> <pages> pages 54-67. </pages> <publisher> ACM Press, </publisher> <month> Jan </month> <year> 1996. </year>
Reference-contexts: Another is to use a more expressive static type system. For example, ad-hoc polymorphism [31], existential types <ref> [27] </ref>, subtyping polymorphism [8], and set-based types [3] all help make writing some of the above programs feasible. A third approach, when the set of types is finite and known at compile-time, is to embed values within a user-defined datatype, effectively tagging them by their type. <p> Finally, the judgement ` context with rules given in Figure 11, is true when is a well-formed type context. 5.4 Type Annotation W [22]. We use the deductive style, motivated by the presentation in <ref> [27] </ref>. <p> Thus the rank-2 polymorphism of run very quickly spreads to other functions, requiring their type to be given as an explicit annotation, and requiring a very much more sophisticated type system to deal with them <ref> [27] </ref>. This clearly contradicts our claim that we require "no explicit types".
Reference: [28] <author> J. Peterson and K. Hammond. </author> <title> Report on the Programming Language Haskell (Version 1.4), </title> <month> Apr </month> <year> 1997. </year>
Reference-contexts: graphics routines (newWindow and barGraph): map : (ff ! fi) ! Vector ff ! Vector fi fft : Nat ! Vector Complex ! Vector Complex newWindow : String ! IO Window barGraph : Nat ! Vector Real ! Window ! IO () We will use the monadic IO of Haskell <ref> [28] </ref> throughout this example. Side-effecting computations which yield a value of type t have type IO t , and are constructed using primitive operations and the do construct.
Reference: [29] <author> W. Taha and T. Sheard. </author> <title> Multi-stage programming with explicit annotations. In Partial Evaluation and Semantics Based Program Analysis, </title> <address> pages 203-217. </address> <publisher> ACM Press, </publisher> <year> 1997. </year>
Reference-contexts: Our main contribution is to regard dynamic typing as staged type inference, in which some program expressions have their type inference deferred until sufficient context is known at run-time. This approach builds directly on a general notion of staged computation <ref> [11, 29] </ref>, and is free of the above problems: * We introduce three operators for manipulating values of dynamic type, which make creating, combining and using dynamic values easy and concise (x2.2). <p> Then a run expression is rewritten by: 0 i) ! t 0 The restriction of these rules to splice-free and (for run) closed terms will be explained in x5. These operators have been studied by Davies and Pfenning [11] and Taha and Sheard <ref> [29] </ref>, and can be seen as generalising the work of Nielson and Nielson on two level functional languages [26]. <p> We briefly outline an enhancement to the type system of x5.3 which will reject examples such as these at compile-time instead of run-time. This is based on a type system developed in previous work <ref> [29] </ref>. An environment is a set of free variables, which need not all be bound at the same stage. <p> It is also fairly verbose compared with our solution: apply : hi ! hi ! hi apply df dx = h ~ df ~ dx i Our approach is motivated by the recent work of Davies and Pfenning [11, 10] and Taha and Sheard <ref> [29] </ref> in staged computation. Our hi and ~ operators correspond with the next and prev constructs of [11], extended to allow the cross-stage persistence of [29]. <p> = h ~ df ~ dx i Our approach is motivated by the recent work of Davies and Pfenning [11, 10] and Taha and Sheard <ref> [29] </ref> in staged computation. Our hi and ~ operators correspond with the next and prev constructs of [11], extended to allow the cross-stage persistence of [29].
Reference: [30] <author> S. Thompson. </author> <title> Type Theory and Functional Programming. </title> <booktitle> International Computer Science Series. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: Note, however, that their generalisation to arbitrary stages instead of just two should not be problematic, as all stages &gt; 0 may be collapsed to a single dynamic stage. The type hi of dynamic expressions corresponds closely to the strong sum type 9ff : ff of dependent type theory <ref> [30] </ref>, which is well known to model abstract data types [23].
Reference: [31] <author> P. Wadler and S. Blott. </author> <title> How to make ad-hoc polymorphism less ad hoc. </title> <booktitle> In Proceedings of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 60-76, </pages> <year> 1989. </year>
Reference-contexts: Another is to use a more expressive static type system. For example, ad-hoc polymorphism <ref> [31] </ref>, existential types [27], subtyping polymorphism [8], and set-based types [3] all help make writing some of the above programs feasible. A third approach, when the set of types is finite and known at compile-time, is to embed values within a user-defined datatype, effectively tagging them by their type.
Reference: [32] <author> A. K. Wright and M. Felleisen. </author> <title> A syntactic approach to type soundness. </title> <journal> Information and Computation, </journal> <volume> 115(1) </volume> <pages> 38-94, </pages> <month> Nov </month> <year> 1994. </year> <month> 52 </month>
Reference-contexts: [ ~ E n :t ] : t 0 i j run (E n ; u n :t ) j run (t n1 ; E n :t ) Arbitrary Context C ::= G j E 0 j E 1 j : : : 5.5 Operational Semantics Following Wright and Felleisen <ref> [32] </ref> we present our operational semantics as a rewrite system with explicit redex contexts. This small-step semantics is entirely syntactical and simplifies our proof of type soundness. We distinguish a subset of terms to be values, shown in Figure 13. <p> Our proof technique is based on the work of Wright and Felleisen <ref> [32] </ref>, though is somewhat complicated by the need to reason across multiple stages and with non-closed terms. 5.6.1 Substitution We first show that provable type judgements are closed under substitution of types and terms, and demonstrate some stage invariants.
References-found: 32

