URL: http://www.cs.utexas.edu/users/lorenzo/papers/seuss.ps
Refering-URL: http://www.cs.utexas.edu/users/lorenzo/publications.html
Root-URL: 
Title: Seuss: What the Doctor Ordered  
Author: Lorenzo Alvisi Rajeev Joshi Calvin Lin Jayadev Misra 
Address: Austin, Texas 78712  
Affiliation: Department of Computer Sciences The University of Texas at Austin  
Abstract: Reconciling the conflicting goals of simplicity and efficiency has traditionally been a major challenge in the development of concurrent programs. Seuss [16] is a methodology for concurrent programming that attempts to achieve the right balance between these competing concerns. The goal of Seuss is to permit a disentanglement of the issues of correctness and efficiency. On the one hand, programmers can reason about Seuss programs by assuming a single thread of control; on the other hand, implementation designers can exploit design knowledge in achieving better performance. This paper provides a short overview of the Seuss programming model and describes the main challenges in designing an efficient implementation of Seuss and in applying Seuss to large applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> W. E. Adams. </author> <title> Concurrent programming with a single thread of control. Dissertation Proposal, </title> <institution> University of Texas, De partment of Computer Science, </institution> <year> 1995. </year>
Reference-contexts: We have developed a simple logic for UNITY that is currently being extended to Seuss <ref> [19, 18, 6, 1] </ref>. Seuss also incorporates ideas from serializability theory and atomic transactions in databases [4], object-oriented programming [14], Communicating Sequential Processes (CSP) [9], i/o automata [13, 12], and the Temporal Logic of Actions (TLA) [11].
Reference: [2] <author> Y. Afek, G. Brown, and M. Merritt. </author> <title> Lazy caching. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1):182205, </volume> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: We have expressed several caching algorithms in Seuss, with the goal of proving their correctness. These include the lazy caching algorithm <ref> [2] </ref>, the Sprite cache consistency protocol [20], and the consistency algorithm used in XFS [3]. Design of Manufacturing Control. One particularly promising application appears to be the development of manufacturing controllers. These controllers are configured in a hierarchical manner and are currently designed in a bottom-up manner. <p> We have presented the Seuss programming model and identified some key issues that we are addressing as we attempt to build an efficient Seuss implementation and apply Seuss to large applications. We are currently working on the correctness proofs of existing cache consistency algorithms <ref> [2] </ref>, [20], [3]. We also plan to begin work soon on a more efficient implementation that incorporates some of the optimizations described in Section 4.
Reference: [3] <author> T. Anderson, M. Dahlin, J. Neefe, D. Patterson, D. Roselli, and R. Wang. </author> <title> Serverless network file systems. </title> <journal> ACM Trans actions on Computer Systems, </journal> <month> Feb. </month> <year> 1996. </year>
Reference-contexts: We have expressed several caching algorithms in Seuss, with the goal of proving their correctness. These include the lazy caching algorithm [2], the Sprite cache consistency protocol [20], and the consistency algorithm used in XFS <ref> [3] </ref>. Design of Manufacturing Control. One particularly promising application appears to be the development of manufacturing controllers. These controllers are configured in a hierarchical manner and are currently designed in a bottom-up manner. <p> We have presented the Seuss programming model and identified some key issues that we are addressing as we attempt to build an efficient Seuss implementation and apply Seuss to large applications. We are currently working on the correctness proofs of existing cache consistency algorithms [2], [20], <ref> [3] </ref>. We also plan to begin work soon on a more efficient implementation that incorporates some of the optimizations described in Section 4.
Reference: [4] <author> P. A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concur rency Control and Recovery in Database Systems. </title> <publisher> Addison Wesley, </publisher> <address> Reading, Mass., </address> <year> 1987. </year>
Reference-contexts: We have developed a simple logic for UNITY that is currently being extended to Seuss [19, 18, 6, 1]. Seuss also incorporates ideas from serializability theory and atomic transactions in databases <ref> [4] </ref>, object-oriented programming [14], Communicating Sequential Processes (CSP) [9], i/o automata [13, 12], and the Temporal Logic of Actions (TLA) [11].
Reference: [5] <author> K. M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Related Work Seuss is an outgrowth of earlier work on UNITY <ref> [5] </ref>. A UNITY program contains a set of declarations, which define the state space, and a set of statements, each of which may change the program state. A program execution starts in any of a set of specified initial states.
Reference: [6] <author> K. M. Chandy and B. A. Sanders. </author> <title> Towards compositional specifications for parallel programs. </title> <booktitle> In DIMACS Workshop on Specifications of Parallel Algorithms, </booktitle> <address> Princeton, NJ, </address> <month> May 9-11 </month> <year> 1994. </year>
Reference-contexts: We have developed a simple logic for UNITY that is currently being extended to Seuss <ref> [19, 18, 6, 1] </ref>. Seuss also incorporates ideas from serializability theory and atomic transactions in databases [4], object-oriented programming [14], Communicating Sequential Processes (CSP) [9], i/o automata [13, 12], and the Temporal Logic of Actions (TLA) [11].
Reference: [7] <author> B. Falsafi, A. Lebeck, S. Reinhardt, I. Schoinas, M. D. Hill, J. R. Larus, A. Rogers, and D. Wood. </author> <title> Application-specific protocols for user-level shared memory. </title> <booktitle> In Proceedings of Supercomputing '94, </booktitle> <pages> pages 380389, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Applications One goal of Seuss is to simplify the design of complex distributed programs. We are currently applying Seuss to the following domains. Cache Coherence Protocols. With the performance advantage that application-specific protocols can provide <ref> [7] </ref>, there has been a new demand for designing customized protocols. However, cache coherence protocols are notoriously difficult to debug and serve as prime examples of distributed applications in which all of the complexity is concentrated in small sections of code.
Reference: [8] <author> A. Geist, A. Beguelin, J. Dongarra, W. Jiang, B. Manchek, and V. Sunderam. </author> <title> PVM: Parallel Virtual Machine A User's Guide and Tutorial for Networked Parallel Computing. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Design Issues We have designed and implemented a simple prototype for Seuss on a network of SUN Sparcstations. The sequen tial programs in total procedure bodies are written in C++. A compiler [10] generates C++ code from Seuss programs, introducing calls to the PVM messaging library <ref> [8] </ref> wherever communication between clones is required. Each clone is mapped to a separate process, and each procedure call results in an exchange of messages between processes. Actions are scheduled by a single scheduler, which is also a process in the system.
Reference: [9] <author> C. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall International, </publisher> <address> London, </address> <year> 1984. </year>
Reference-contexts: We have developed a simple logic for UNITY that is currently being extended to Seuss [19, 18, 6, 1]. Seuss also incorporates ideas from serializability theory and atomic transactions in databases [4], object-oriented programming [14], Communicating Sequential Processes (CSP) <ref> [9] </ref>, i/o automata [13, 12], and the Temporal Logic of Actions (TLA) [11]. A partial procedure is similar to a database transaction that may commit or abort; the procedure commits to execute if its precondition holds and its pre-procedure commits, and it aborts (i.e., rejects) otherwise. <p> In Seuss, a partial procedure does not change the program state until it commits, and therefore, there is no need for a rollback. The form of a partial procedure is inspired by Hoare's work on CSP <ref> [9] </ref>. Our model may be viewed as a special case of CSP because we disallow nested partial procedures. Lynch and Tuttle, in their work on i/o automata, have explored similar issues; however, they do not advocate a distinction between partial and total procedures, as we do in Seuss.
Reference: [10] <author> I. H. Kruger. </author> <title> An experiment in compiler design for a con current object-based programming language. </title> <type> Master's the sis, </type> <institution> University of Texas, Department of Computer Science, </institution> <year> 1996. </year>
Reference-contexts: Design Issues We have designed and implemented a simple prototype for Seuss on a network of SUN Sparcstations. The sequen tial programs in total procedure bodies are written in C++. A compiler <ref> [10] </ref> generates C++ code from Seuss programs, introducing calls to the PVM messaging library [8] wherever communication between clones is required. Each clone is mapped to a separate process, and each procedure call results in an exchange of messages between processes.
Reference: [11] <author> L. Lamport. </author> <title> The temporal logic of actions. </title> <journal> ACM Transac--tions on Programming Languages and Systems, </journal> <volume> 16(3):872 923, </volume> <month> May </month> <year> 1994. </year>
Reference-contexts: Seuss also incorporates ideas from serializability theory and atomic transactions in databases [4], object-oriented programming [14], Communicating Sequential Processes (CSP) [9], i/o automata [13, 12], and the Temporal Logic of Actions (TLA) <ref> [11] </ref>. A partial procedure is similar to a database transaction that may commit or abort; the procedure commits to execute if its precondition holds and its pre-procedure commits, and it aborts (i.e., rejects) otherwise. A typical abort of a database transaction requires a rollback to a valid state. <p> Lynch and Tuttle, in their work on i/o automata, have explored similar issues; however, they do not advocate a distinction between partial and total procedures, as we do in Seuss. The design of our logic has been influenced by Lamport's work on TLA <ref> [11] </ref>, and by the action sequences developed by Milner in CCS [15]; Seuss admits both state-based as well as action-based reasoning and we intend to exploit both forms. 4. Design Issues We have designed and implemented a simple prototype for Seuss on a network of SUN Sparcstations.
Reference: [12] <author> N. Lynch, M. Merritt, W. Weihl, and aln Fekete. </author> <title> Atomic Transactions. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1994. </year>
Reference-contexts: We have developed a simple logic for UNITY that is currently being extended to Seuss [19, 18, 6, 1]. Seuss also incorporates ideas from serializability theory and atomic transactions in databases [4], object-oriented programming [14], Communicating Sequential Processes (CSP) [9], i/o automata <ref> [13, 12] </ref>, and the Temporal Logic of Actions (TLA) [11]. A partial procedure is similar to a database transaction that may commit or abort; the procedure commits to execute if its precondition holds and its pre-procedure commits, and it aborts (i.e., rejects) otherwise.
Reference: [13] <author> N. Lynch and M. Tuttle. </author> <title> An introduction to input/output automata. </title> <address> CWI-Quarterly, 2(3):219246, </address> <month> Sept. </month> <year> 1989. </year>
Reference-contexts: We have developed a simple logic for UNITY that is currently being extended to Seuss [19, 18, 6, 1]. Seuss also incorporates ideas from serializability theory and atomic transactions in databases [4], object-oriented programming [14], Communicating Sequential Processes (CSP) [9], i/o automata <ref> [13, 12] </ref>, and the Temporal Logic of Actions (TLA) [11]. A partial procedure is similar to a database transaction that may commit or abort; the procedure commits to execute if its precondition holds and its pre-procedure commits, and it aborts (i.e., rejects) otherwise.
Reference: [14] <author> B. Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall international, </publisher> <address> London, </address> <year> 1988. </year>
Reference-contexts: We have developed a simple logic for UNITY that is currently being extended to Seuss [19, 18, 6, 1]. Seuss also incorporates ideas from serializability theory and atomic transactions in databases [4], object-oriented programming <ref> [14] </ref>, Communicating Sequential Processes (CSP) [9], i/o automata [13, 12], and the Temporal Logic of Actions (TLA) [11].
Reference: [15] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <booktitle> International Series in Computer Science, </booktitle> <editor> C. A. R. </editor> <booktitle> Hoare, Series Editor. Prentice-Hall International, </booktitle> <address> London, </address> <year> 1989. </year>
Reference-contexts: The design of our logic has been influenced by Lamport's work on TLA [11], and by the action sequences developed by Milner in CCS <ref> [15] </ref>; Seuss admits both state-based as well as action-based reasoning and we intend to exploit both forms. 4. Design Issues We have designed and implemented a simple prototype for Seuss on a network of SUN Sparcstations. The sequen tial programs in total procedure bodies are written in C++.
Reference: [16] <author> J. Misra. </author> <title> A discipline of multiprogramming. Work in progress, </title> <note> available online at ftp://ftp.cs.utexas.edu/pub/psp/seuss/discipline.ps.Z </note> . 
Reference-contexts: One of the main challenges has been the development of a programming methodology that allows programmers to retain intellectual control over their programs without having to sacrifice efficiency in implementation. Seuss <ref> [16] </ref> represents a departure from traditional ap proaches by making a fundamental distinction between the concurrent and the sequential aspects of distributed programming: We believe that concurrent programs are best structured as large sequential components that interact only through small but intricate sections of code. <p> At the same time, implementation designers can exploit design knowledge in order to execute programs using multiple threads; this leads to better performance. The theoretical aspects of Seuss have been described elsewhere [17], <ref> [16] </ref>. In this paper, we provide a short overview of Seuss and identify the main challenges in applying Seuss to large distributed applications and in developing efficient implementations of Seuss programs. 2. The Programming Model The programming model of Seuss is simple. <p> Instead, as described below, we impose some restrictions on the structure of partial procedures; these restrictions allow us to understand partial procedures in isolation. In this paper we restrict ourselves to the following simple form of partial procedures (the general case is described elsewhere <ref> [16] </ref>): p ; h ! S where p is the precondition, h is the preprocedure and S is the body of the procedure. The precondition is a predicate on the state of the clone in which the partial procedure is declared. <p> Note that the body does not contain any calls to partial procedures, and there is at most one call in the preprocedure to another partial procedure. (This condition ensures that the execution of a partial procedure always terminates <ref> [16] </ref>.) A partial procedure responds to each call made upon it by accepting or rejecting the call. A partial procedure of the form p ! S , where the preprocedure is absent, responds to a call as follows. <p> A total procedure at a lowest level contains no procedure calls. We have formally described the model and the notation elsewhere and have shown how boxes and clones can be combined to form programs <ref> [16] </ref>. 2.5. Tight Executions Executions of Seuss programs are classified into tight and loose executions. A tight execution is an infinite sequence of steps. In each step, some action of some clone is chosen and executed.
Reference: [17] <author> J. Misra. </author> <title> A discipline of multiprogramming. </title> <editor> In G. E. Blel-loch, K. M. Chandy, and S. Jagannathan, editors, </editor> <booktitle> Specification of Parallel Algorithms, </booktitle> <volume> volume 18, </volume> <pages> pages 357381, </pages> <address> Providence, RI, </address> <year> 1994. </year> <title> DIMACS (Series in Discrete Mathematics), </title> <publisher> American Mathematical Society. </publisher>
Reference-contexts: At the same time, implementation designers can exploit design knowledge in order to execute programs using multiple threads; this leads to better performance. The theoretical aspects of Seuss have been described elsewhere <ref> [17] </ref>, [16]. In this paper, we provide a short overview of Seuss and identify the main challenges in applying Seuss to large distributed applications and in developing efficient implementations of Seuss programs. 2. The Programming Model The programming model of Seuss is simple. <p> The analogue of commuta-tivity in our theory is called compatibility, which, like com-mutativity, is a relation between actions. Compatibility is, however, a weaker notion than traditional commutativity; thus it admits greater concurrency. A formal definition of compatibility, and further discussion of this topic, can be found elsewhere <ref> [17] </ref>. 2.7. Examples In this section, we show two small examples of Seuss programs, which illustrate the concepts described above. Message communication An unbounded FIFO channel is designed as a box with a local variable of type sequence and two methods.
Reference: [18] <author> J. Misra. </author> <title> A logic for concurrent programming: Progress. </title> <journal> Journal of Computer and Software Engineering, </journal> <volume> 3(2):273 300, </volume> <year> 1995. </year>
Reference-contexts: We have developed a simple logic for UNITY that is currently being extended to Seuss <ref> [19, 18, 6, 1] </ref>. Seuss also incorporates ideas from serializability theory and atomic transactions in databases [4], object-oriented programming [14], Communicating Sequential Processes (CSP) [9], i/o automata [13, 12], and the Temporal Logic of Actions (TLA) [11].
Reference: [19] <author> J. Misra. </author> <title> A logic for concurrent programming: Safety. </title> <journal> Journal of Computer and Software Engineering, </journal> <volume> 3(2):239272, </volume> <year> 1995. </year>
Reference-contexts: We have developed a simple logic for UNITY that is currently being extended to Seuss <ref> [19, 18, 6, 1] </ref>. Seuss also incorporates ideas from serializability theory and atomic transactions in databases [4], object-oriented programming [14], Communicating Sequential Processes (CSP) [9], i/o automata [13, 12], and the Temporal Logic of Actions (TLA) [11].
Reference: [20] <author> M. Nelson, B. Welch, and J. Ousterhout. </author> <title> Caching in the Sprite network file system. </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 6(1):134154, </volume> <month> Feb. </month> <year> 1988. </year>
Reference-contexts: We have expressed several caching algorithms in Seuss, with the goal of proving their correctness. These include the lazy caching algorithm [2], the Sprite cache consistency protocol <ref> [20] </ref>, and the consistency algorithm used in XFS [3]. Design of Manufacturing Control. One particularly promising application appears to be the development of manufacturing controllers. These controllers are configured in a hierarchical manner and are currently designed in a bottom-up manner. <p> We have presented the Seuss programming model and identified some key issues that we are addressing as we attempt to build an efficient Seuss implementation and apply Seuss to large applications. We are currently working on the correctness proofs of existing cache consistency algorithms [2], <ref> [20] </ref>, [3]. We also plan to begin work soon on a more efficient implementation that incorporates some of the optimizations described in Section 4.
References-found: 20

