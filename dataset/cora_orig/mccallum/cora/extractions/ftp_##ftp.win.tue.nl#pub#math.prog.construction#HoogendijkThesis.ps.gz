URL: ftp://ftp.win.tue.nl/pub/math.prog.construction/HoogendijkThesis.ps.gz
Refering-URL: http://www.win.tue.nl/cs/wp/papers/papers.html
Root-URL: http://www.win.tue.nl
Title: Acknowledgements Many people serve as a klank-bord. The other members and former members of the
Author: Boiten, Joop van den Eijnde, Netty van Gasteren, Rik van Geldrop, Frans Rietman, Ed Voer-mans, and Jaap van der Woude. committee: Richard Bird, Wim Hesselink, and Lambert Richard Verhoeven 
Note: supported me in preparing this thesis, and their help is gratefully acknowledged. I would like to mention: My fellow Ph.D. student Henk Doornbos for many fruitful discussions and his willingness to  The external members of the Ph.D.  Meertens, for reviewing this thesis and  
Abstract: My Ph.D. supervisor Roland Backhouse, first, for accepting my as an afstudeer-student and later on offering me the possibility of doing research in the challenging area of Mathematics of Program Construction. I want to thank him for his guidance, his patience and the effort he put in improving preliminary versions of this thesis. I owe him a lot. Oege de Moor, for his pleasant cooperation on the field of membership and fans. Although we communicated almost exclusively via email it was as if we were sharing an office and working side-by-side. I enjoyed it a lot. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C.J. Aarts, R.C. Backhouse, P. Hoogendijk, T.S. Voermans, and J. van der Woude. </author> <title> A relational theory of datatypes. </title> <note> Available via World-Wide Web at http://www.win.tue.nl/win/cs/wp/papers, September 1992. </note>
Reference-contexts: The calculus of relations has existed for a very long time. (See e.g. [49, 50, 47].) Our presentation of the calculus is based on the work of Backhouse et. al. <ref> [3, 2, 5, 1] </ref> and the book by Bird and De Moor [7]. The latter is based on the theory of allegories as set out in [17]. <p> In subsection 2.4.9 we give the axioms for the union of relations. 2.4.3 Partial identities Relations below an identity relation, i.e. X id A for some A, we call partial identities (some times called coreflexives [17] or monotypes <ref> [1] </ref>). We use partial identities to represent subsets of object A. In Rel, there is a partial identity on A for every subset B of A. That is to say, for subset B we can define the partial identity X, by b X b j b 2 B. <p> The domain operator is defined by the following universal property <ref> [1] </ref>, R &gt;&gt; A;B X j R &gt; X for each X id B . (2.22) The interpretation of the domain operator is that it represents the set of values for which there exists an image, i.e. x 2 R &gt; j 9 (y :: y R x) : Note that <p> For the domain operator we have R &gt; = (R ffi R) " id (2.24) Again, using the modularity law it is not too difficult to verify that for the closed formula (2.24), the universal property (2.23) holds. For the domain operator, we have the following properties <ref> [1, 7] </ref>, (R S) &gt; = (R &gt; S) &gt; ; (2.25) (R " S) &gt; = (R ffi S) " id (2.27) One of the cancellation laws of the Galois connection for domains is R &gt;&gt; A;B R &gt; . <p> In other words, the definition of relational coproduct and product are in some sense canonical extensions of the categorical definitions for total functions. The way we introduce coproduct and product is inspired by [17] and [7], although we do not assume tabulations for every relation. In <ref> [1] </ref> relational coproduct and product are introduced in a different but equivalent way. Coproducts A coproduct of two objects consists of an object and two injection relations. <p> As a matter of fact, we could have defined relational product equivalently using equation (2.62) together with equation (2.50). It is then possible to derive property (2.49) from it <ref> [1] </ref>. Although this is easier than to derive property (2.63) from our definition of relational product, we have chosen not to do so. The reason for this is that we wanted to show that a unitary tabular allegory has relational products. <p> Cocatamorphism We define the notion of a cocatamorphism as the converse-conjugate of a catamorphism. That is, for coalgebra R : FA A, we define bd (F; R)ce 4 ([F; R ffi ]) : We call the mapping bd ( )ce a cocatamorphism instead of an anamorphism as done in <ref> [1] </ref>. An anamorphism [36] is by definition the dual of catamorphism. The reason why we prefer the term cocatamorphism instead of anamorphism is because bd ( )ce is not the relational extension of the anamorphism operator on functions. <p> In other words, if we first generate an arbitrary F-shape and we feed it together with a value to a copies map, we should get the same result as with the fan. Indeed, this is true for a binary intersection preserving relator F. In <ref> [1] </ref> it has been shown that product and coproduct preserves binary intersections. Furthermore, a tree type relator preserves binary intersections if the base relator preserves binary intersections. Hence, it follows that all regular relators preserves binary intersections.
Reference: [2] <author> R.C. Backhouse, P. de Bruin, P. Hoogendijk, G. Malcolm, </author> <title> T.S. </title> <editor> Voermans, and J. van der Woude. Polynomial relators. In M. Nivat, C.S. Rattray, T. Rus, and G. Scollo, editors, </editor> <booktitle> Proceedings of the 2nd Conference on Algebraic Methodology and Software Technology, AMAST'91, </booktitle> <pages> pages 303-326. </pages> <publisher> Springer-Verlag, Workshops in Computing, </publisher> <year> 1992. </year>
Reference-contexts: The calculus of relations has existed for a very long time. (See e.g. [49, 50, 47].) Our presentation of the calculus is based on the work of Backhouse et. al. <ref> [3, 2, 5, 1] </ref> and the book by Bird and De Moor [7]. The latter is based on the theory of allegories as set out in [17].
Reference: [3] <author> R.C. Backhouse, P. de Bruin, G. Malcolm, </author> <title> T.S. </title> <editor> Voermans, and J. van der Woude. Relational catamorphisms. In Moller B., editor, </editor> <booktitle> Proceedings of the IFIP TC2/WG2.1 Working Conference on Constructing Programs from Specifications, </booktitle> <pages> pages 287-318. </pages> <publisher> Elsevier Science Publishers B.V., </publisher> <year> 1991. </year>
Reference-contexts: The calculus of relations has existed for a very long time. (See e.g. [49, 50, 47].) Our presentation of the calculus is based on the work of Backhouse et. al. <ref> [3, 2, 5, 1] </ref> and the book by Bird and De Moor [7]. The latter is based on the theory of allegories as set out in [17].
Reference: [4] <author> R.C. Backhouse, H. Doornbos, and P. Hoogendijk. </author> <note> Commuting relators. Available via World-Wide Web at http://www.win.tue.nl/win/cs/wp/papers, Septem-ber 1992. </note>
Reference-contexts: The interpretation of mem:Fnid is a relation that holds between an F-structure and a value x such that all values stored in the F-structure are copies of the value x. Such a relation was called a generator in <ref> [4] </ref> (where it was first introduced) because it generates (or creates) F-structures from a given seed value x. <p> Although the theory of slok-properties seems trivial it provided us with a powerful tool for constructing polytypic functions and establishing their properties. The discovery of the higher-order naturality property is a major advance on our earlier work <ref> [4] </ref> in which the commuting requirement was substantially more operational in flavour and 145 146 CHAPTER 7. EPILOGUE hence ad hoc. In our earlier work we only required the slok-properties expressing the requirement that a zip operation should preserve the shape of the data structures.
Reference: [5] <author> R.C. Backhouse and P. Hoogendijk. </author> <title> Elements of a relational theory of datatypes. </title> <editor> In B. Moller, H.A. Partsch, and S.A. Schuman, editors, </editor> <booktitle> Formal Program Development. Proc. IFIP TC2/WG 2.1 State of the Art Seminar, </booktitle> <address> Rio de Janeiro, </address> <month> Jan. </month> <year> 1992, </year> <booktitle> volume 755 of LNCS, </booktitle> <pages> pages 7-42. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The calculus of relations has existed for a very long time. (See e.g. [49, 50, 47].) Our presentation of the calculus is based on the work of Backhouse et. al. <ref> [3, 2, 5, 1] </ref> and the book by Bird and De Moor [7]. The latter is based on the theory of allegories as set out in [17].
Reference: [6] <author> Richard Bird, Oege de Moor, and Paul Hoogendijk. </author> <title> Generic functional programming with types and relations. </title> <journal> J. of Functional Programming, </journal> <volume> 6(1) </volume> <pages> 1-28, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: Malcolm exploited the polytypic notion of a catamorphism and introduced the banana bracket notation which was popularised and extended to the polytypic notions of anamorphism and hylomorphism by Fokkinga, Meijer and Paterson [36]. Since then the theme of polytypy has been explored in a variety ways. Several authors <ref> [6, 27, 35] </ref> have 1.2.
Reference: [7] <author> Richard S. Bird and Oege de Moor. </author> <title> Algebra of Programming. </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1996. </year>
Reference-contexts: Several authors [6, 27, 35] have 1.2. THEOREMS FOR FREE 3 explored polytypic generalisations of existing programming problems, Doornbos [12, 13, 14] has developed a polytypic theory of program termination and the recently published book by Bird and De Moor <ref> [7] </ref> contains a wealth of material in which parameterisation by a datatype constructor plays a central role. Functional programmers have a good intuitive understanding of what it means for a function to be polymorphic. <p> Furthermore, we investigate the free theorem of the membership test and fans. The formal setting in which we conduct our research is introduced in chapter 2. The setup of the theory is based on the book of Bird and de Moor <ref> [7] </ref> although there are differences in detail which we thought were necessary. Readers familiar with that book may skip chapter 2 on first reading except for subsection 2.2.3 and section 2.3. Furthermore, there are some notational differences for the split (fork) and junc (case). <p> Chapter 2 Basic Notions The formal setting in which we conduct our research is introduced in in this chapter. The setup of the theory is based on the book by Bird and De Moor <ref> [7] </ref> although there are differences in detail which we thought were necessary. Readers familiar with that book may skip this chapter on first reading except for subsection 2.2.3 and section 2.3. Furthermore, there are some notational differences for the split (fork) and junc (case). <p> The calculus of relations has existed for a very long time. (See e.g. [49, 50, 47].) Our presentation of the calculus is based on the work of Backhouse et. al. [3, 2, 5, 1] and the book by Bird and De Moor <ref> [7] </ref>. The latter is based on the theory of allegories as set out in [17]. We use allegories too. 2.4.1 Galois connections Before we introduce the notion of an allegory we first introduce the concept of a Galois connection. <p> For the domain operator we have R &gt; = (R ffi R) " id (2.24) Again, using the modularity law it is not too difficult to verify that for the closed formula (2.24), the universal property (2.23) holds. For the domain operator, we have the following properties <ref> [1, 7] </ref>, (R S) &gt; = (R &gt; S) &gt; ; (2.25) (R " S) &gt; = (R ffi S) " id (2.27) One of the cancellation laws of the Galois connection for domains is R &gt;&gt; A;B R &gt; . <p> The way we introduce the relational extensions of categorical concepts is inspired by the way it is done in the book by Bird and de Moor <ref> [7] </ref> although there they assume tabularity. Furthermore, for relational coproduct and relational catamorphisms, they assume the existence of power transpose and membership (see subsection 2.4.8).We will not assume tabularity in general nor the existence of power transpose and membership. 2 and these functions have a straightforward implementation 2.5. <p> If allegory B is tabular, a functor is monotonic iff it commutes with converse <ref> [7] </ref>. So, if we define a relator on a tabular allegory, one has to prove either requirement (2.36) or (2.37). However, since we do not assume tabularity, we prove both properties (2.36) and (2.37) whenever we define a relator. <p> This holds for coproduct too. In other words, the definition of relational coproduct and product are in some sense canonical extensions of the categorical definitions for total functions. The way we introduce coproduct and product is inspired by [17] and <ref> [7] </ref>, although we do not assume tabulations for every relation. In [1] relational coproduct and product are introduced in a different but equivalent way. Coproducts A coproduct of two objects consists of an object and two injection relations. <p> Hence, E is a functor on functions, i.e. E is a functor on the sub-category Map. However, E is not monotonic, nor does it commute with converse. So, E is not a relator. However, in <ref> [7] </ref> it is shown that for a tabular allegory, the restriction of E to functions does have a relational extension. This relational extension, called the power relator, we denote by P. In [7], Bird and De Moor give a closed formula for P, i.e. <p> So, E is not a relator. However, in <ref> [7] </ref> it is shown that for a tabular allegory, the restriction of E to functions does have a relational extension. This relational extension, called the power relator, we denote by P. In [7], Bird and De Moor give a closed formula for P, i.e. PR = 2n (R 2) " (2 ffi R)=2 ffi (2.72) but in order to show that this defines a relator, tabularity is assumed.
Reference: [8] <author> R.S. Bird. </author> <title> An introduction to the theory of lists. </title> <editor> In M. Broy, editor, </editor> <booktitle> Logic of Programming and Calculi of Discrete Design. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1987. </year> <booktitle> NATO ASI Series, </booktitle> <volume> vol. </volume> <month> F36. </month>
Reference-contexts: For this reason the study of datatypes is an important issue. Bird has developed the theory of lists <ref> [8] </ref>, a set of algebraic transformation rules involving operators like map, reduce, filter etc. Meertens calls this kind of program methodology algorithmics. [34]. The theory of lists is polymorphic. <p> We can depict this rule by the following diagram f 5 g f g h 5 k h k Richard Bird calls such a rule an abide law <ref> [8] </ref>, the contraction of the words above and beside.
Reference: [9] <author> R.S. Bird and P. Wadler. </author> <title> Introduction to Functional Programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: Hence, in the case of coproduct, product and projection relators, the relator can be recovered from its fan-function with its membership relation. 90 CHAPTER 4. MEMBERSHIP Chapter 5 A Class of Commuting Relators 5.1 Introduction The zip function is well known to functional programmers <ref> [9] </ref>.
Reference: [10] <author> J.H. Conway. </author> <title> Regular Algebra and Finite Machines. </title> <publisher> Chapman and Hall, </publisher> <address> London, </address> <year> 1971. </year>
Reference-contexts: have ?? ffi = ??, (R [ S) ffi = R ffi [ S ffi , ?? &gt; = ??, and (R [ S) &gt; = R &gt; [ S &gt; . 2.4.10 Division In this section we define the so-called division operators. (Others use the terms residual [11], factor <ref> [10] </ref>, or weakest pre-specification [19].) By definition, we define n and = as the upper-adjoint of composition on the left and on the right, respectively.
Reference: [11] <author> R.P. </author> <title> Dilworth. Non-commutative residuated lattices. </title> <journal> Transactions of the American Mathematical Society, </journal> <volume> 46 </volume> <pages> 426-444, </pages> <year> 1939. </year> <note> 151 152 BIBLIOGRAPHY </note>
Reference-contexts: Specifically, we have ?? ffi = ??, (R [ S) ffi = R ffi [ S ffi , ?? &gt; = ??, and (R [ S) &gt; = R &gt; [ S &gt; . 2.4.10 Division In this section we define the so-called division operators. (Others use the terms residual <ref> [11] </ref>, factor [10], or weakest pre-specification [19].) By definition, we define n and = as the upper-adjoint of composition on the left and on the right, respectively.
Reference: [12] <author> H. Doornbos. </author> <title> Reductivity arguments and program construction. </title> <type> PhD thesis, </type> <institution> Eindhoven University of Technology, Department of Mathematics and Computing Science, </institution> <month> June </month> <year> 1996. </year>
Reference-contexts: Since then the theme of polytypy has been explored in a variety ways. Several authors [6, 27, 35] have 1.2. THEOREMS FOR FREE 3 explored polytypic generalisations of existing programming problems, Doornbos <ref> [12, 13, 14] </ref> has developed a polytypic theory of program termination and the recently published book by Bird and De Moor [7] contains a wealth of material in which parameterisation by a datatype constructor plays a central role.
Reference: [13] <author> Henk Doornbos and Roland Backhouse. </author> <title> Induction and recursion on datatypes. </title> <editor> In B. Moller, editor, </editor> <booktitle> Mathematics of Program Construction, 3rd International Conference, volume 947 of LNCS, </booktitle> <pages> pages 242-256. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1995. </year>
Reference-contexts: Since then the theme of polytypy has been explored in a variety ways. Several authors [6, 27, 35] have 1.2. THEOREMS FOR FREE 3 explored polytypic generalisations of existing programming problems, Doornbos <ref> [12, 13, 14] </ref> has developed a polytypic theory of program termination and the recently published book by Bird and De Moor [7] contains a wealth of material in which parameterisation by a datatype constructor plays a central role.
Reference: [14] <author> Henk Doornbos and Roland Backhouse. Reductivity. </author> <booktitle> Science of Computer Programming, </booktitle> <address> 26(1-3):217-236, </address> <year> 1996. </year>
Reference-contexts: Since then the theme of polytypy has been explored in a variety ways. Several authors [6, 27, 35] have 1.2. THEOREMS FOR FREE 3 explored polytypic generalisations of existing programming problems, Doornbos <ref> [12, 13, 14] </ref> has developed a polytypic theory of program termination and the recently published book by Bird and De Moor [7] contains a wealth of material in which parameterisation by a datatype constructor plays a central role.
Reference: [15] <author> Achim Jung (Editor). </author> <title> Domains and denotational semantics: History, accomplishments and open problems. </title> <journal> Bulletin of the European Association for Computer Science, </journal> <volume> 59 </volume> <pages> 227-256, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: Being able to experiment with the notion by writing and executing polymorphic programs is clearly enormously beneficial to understanding. Nevertheless, an unequivocal formal semantics of parametric polymorphism is still an active area of research <ref> [15] </ref>. The situation with regard to polytypy is worse, the emphasis at the current time being on demonstrating the practicality of the notion [27, 22] with the potential danger of unnecessary complication.
Reference: [16] <author> Maarten M. Fokkinga. </author> <title> Law and Order in Algorithmics. </title> <type> PhD thesis, </type> <institution> Universiteit Twente, </institution> <address> The Netherlands, </address> <year> 1992. </year>
Reference-contexts: We call the theorem the zip-a-dee-doo-dah theorem after the song Zip-a-dee-doo-dah, zip-a-dee-ay because it seemed such a wonderful day when the theorem was first discovered (at least to us anyway)! The inspiration for the theorem came from Fokkinga's Ph.D. thesis <ref> [16, chapter 4, p 90 onwards] </ref>.
Reference: [17] <author> P.J. Freyd and A. Scedrov. </author> <title> Categories, </title> <publisher> Allegories. North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: The latter is based on the theory of allegories as set out in <ref> [17] </ref>. We use allegories too. 2.4.1 Galois connections Before we introduce the notion of an allegory we first introduce the concept of a Galois connection. As we will see, we introduce several allegorical notions as instances of a Galois connection. <p> In subsection 2.4.9 we give the axioms for the union of relations. 2.4.3 Partial identities Relations below an identity relation, i.e. X id A for some A, we call partial identities (some times called coreflexives <ref> [17] </ref> or monotypes [1]). We use partial identities to represent subsets of object A. In Rel, there is a partial identity on A for every subset B of A. <p> This holds for coproduct too. In other words, the definition of relational coproduct and product are in some sense canonical extensions of the categorical definitions for total functions. The way we introduce coproduct and product is inspired by <ref> [17] </ref> and [7], although we do not assume tabulations for every relation. In [1] relational coproduct and product are introduced in a different but equivalent way. Coproducts A coproduct of two objects consists of an object and two injection relations. <p> coproduct, i.e. we have the universal property X = R 5 S j X inl A;B = R ^ X inr A;B = S (2.48) As a matter of fact, we could have defined coproduct equivalently starting with the above universal property and deriving properties (2.39) - (2.41) from it <ref> [17] </ref>. However, since this is not possible for product and we want to see more or less the dual between coproduct and product, we have chosen not to do so.
Reference: [18] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1995. </year>
Reference-contexts: The general question is: is it always possible to derive some uniqueness properties for a polytypic program from its higher-order naturality property? Broader questions concern how the notion of polytypy relates to other notions of generic programming. Design patterns <ref> [18] </ref> have recently attracted substantial interest as a way of categorizing (and reusing) common building blocks in object-oriented programming but we are unable to comment at this stage on whether there is any relation between this work and our own.
Reference: [19] <author> C.A.R. Hoare and Jifeng He. </author> <title> The weakest prespecification. </title> <journal> Fundamenta Informaticae, </journal> <volume> 9 </volume> <pages> 51-84, 217-252, </pages> <year> 1986. </year>
Reference-contexts: ??, (R [ S) ffi = R ffi [ S ffi , ?? &gt; = ??, and (R [ S) &gt; = R &gt; [ S &gt; . 2.4.10 Division In this section we define the so-called division operators. (Others use the terms residual [11], factor [10], or weakest pre-specification <ref> [19] </ref>.) By definition, we define n and = as the upper-adjoint of composition on the left and on the right, respectively.
Reference: [20] <author> Paul Hoogendijk and Oege de Moor. </author> <title> What is a datatype? Technical Report 96/16, </title> <institution> Department of Mathematics and Computing Science, Eindhoven University of Technology, </institution> <year> 1996. </year> <note> Submitted to Science of Computer Programming. Available via World-Wide Web at http://www.win.tue.nl/win/cs/wp/papers. </note>
Reference-contexts: However, in the case of polytypic functions we get some uniqueness results by investigating the higher-order naturality requirement. These uniqueness results we use for the construction of the polytypic function that commutes two datatypes. 1.4 Overview of the thesis Chapter 4 reports on joint work with Oege de Moor <ref> [20] </ref>. We introduce the notion of a membership test for a datatype. We give a non-inductive characterisation of a membership test for an arbitrary datatype and show that it is a good characterisation in the sense that for a datatype there is at most one membership test. <p> We give a non-inductive characterisation of a membership test for an arbitrary datatype and show that it is a good characterisation in the sense that for a datatype there is at most one membership test. A new result, compared with <ref> [20] </ref>, is that we give a more general definition for membership than given in [20]; we include the so-called non-endo datatypes as well. For this generalisation, we use the o- calculus as introduced in the second half of chapter 3. <p> A new result, compared with <ref> [20] </ref>, is that we give a more general definition for membership than given in [20]; we include the so-called non-endo datatypes as well. For this generalisation, we use the o- calculus as introduced in the second half of chapter 3. After that, we give the inductive definition of a membership test for the inductively defined class of the so-called regular datatypes. <p> Furthermore, we tackle the problem of structure multiplication. After that, we give an inductive definition for the zip operations for the class of regular datatypes. In chapter 6 we continue the investigation begun by Oege de Moor <ref> [20] </ref> of the relationship between fans and so-called strengths and copies maps of a datatype. Furthermore, we investigate the free theorem of the membership test and fans. The formal setting in which we conduct our research is introduced in chapter 2. <p> Oege de Moor proposed the idea that a datatype is the combination of a relator and a membership relation. This proposal, summarised by the slogan datatype = relator + membership was investigated jointly by Hoogendijk and De Moor and reported in <ref> [20] </ref>. In this chapter we extend that investigation further in order to include relators of arbitrary arity. Most often, it is not too difficult to come up with a membership relation for a specific relator. For instance, it is possible to define membership relations inductively for the polynomial relators. <p> In chapter 5 on commuting relators we showed that the existence of the canonical fan implies the existence of a strength of F. Thus a relator with membership has a strength, i.e. is strong. This chapter reformulates and extends the work of Hoogendijk and De Moor <ref> [20] </ref>. In [20] an abstract of notion of a fan (satisfied by the canonical fan) is given and it is shown that the fans and strengths of a relator are in one-to-one correspondence. <p> In chapter 5 on commuting relators we showed that the existence of the canonical fan implies the existence of a strength of F. Thus a relator with membership has a strength, i.e. is strong. This chapter reformulates and extends the work of Hoogendijk and De Moor <ref> [20] </ref>. In [20] an abstract of notion of a fan (satisfied by the canonical fan) is given and it is shown that the fans and strengths of a relator are in one-to-one correspondence. <p> It gives some confidence that the definition of a datatype as relator with membership <ref> [20] </ref> is a proper one. First of all, a relator with membership has a strength, i.e. is strong, which Moggi [39] regards fundamental to computa tion.
Reference: [21] <author> P. Jansson. </author> <title> Polytypism and polytypic unification. </title> <type> Master's thesis, </type> <institution> Chalmers University of Technology and University of Goteborg, </institution> <year> 1995. </year>
Reference-contexts: In other words, we consider a function to be truly polytypic if the higher-order free theorem i.e. a higher-order naturality property, predicted by its type holds. The work of Jeuring and Jansson <ref> [27, 21, 22] </ref> differs in this respect from our approach since they consider a polytypic function to be a function which is defined by induction on the structure of the class of type constructors.
Reference: [22] <author> P. Jansson and J. Jeuring. </author> <title> Polyp a polytypic programming language extension. </title> <booktitle> In POPL '97: The 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 470-482. </pages> <publisher> ACM Press, </publisher> <year> 1997. </year>
Reference-contexts: Nevertheless, an unequivocal formal semantics of parametric polymorphism is still an active area of research [15]. The situation with regard to polytypy is worse, the emphasis at the current time being on demonstrating the practicality of the notion <ref> [27, 22] </ref> with the potential danger of unnecessary complication. Parametric polymorphism is a well-defined concept that provides the basis for a well-defined theory of parametric polytypy. 1.2.3 Parametric polymorphism A polymorphic function is parametric if its behaviour does not depend on the type at which it is instantiated [48]. <p> In other words, we consider a function to be truly polytypic if the higher-order free theorem i.e. a higher-order naturality property, predicted by its type holds. The work of Jeuring and Jansson <ref> [27, 21, 22] </ref> differs in this respect from our approach since they consider a polytypic function to be a function which is defined by induction on the structure of the class of type constructors.
Reference: [23] <author> C.B. Jay. </author> <title> Matrices, monads and the fast fourier transform. </title> <type> Technical Report UTS-SOCS-93.13, </type> <institution> University of Technology, </institution> <address> Sydney, </address> <year> 1993. </year>
Reference-contexts: Furthermore, it is shown that the existence of a membership relation implies the existence of a unique fan and (thus) a unique strength. In this chapter we extend this analysis to include Jay's <ref> [23] </ref> notion of a copies map. The interpretation of a copies map is that it takes an F-shape and a value and generates an F-structure by filling the F-shape with copies of the given value. We show that the existence of a strength implies the existence of a copies map. <p> Now, property (6.4) follows by a straightforward calculation using the universal property of product. 6.2 Constructing copies map, fan and strength We start with the definition of a copies map <ref> [23] </ref> and show that having a strength, we can construct a copies map. And we show that for a binary intersection preserving relator, we can construct a fan from a copies map. <p> First of all, a relator with membership has a strength, i.e. is strong, which Moggi [39] regards fundamental to computa tion. Secondly, all natural transformations between two relators with membership are strong too. 6.5 Shapely functors Barry Jay <ref> [23] </ref> defines the notion of a shapely functor and the notion of copyable natural transformation between shapely functors. By definition a shapely functor is a so-called pullback preserving functor equipped with a copies map.
Reference: [24] <author> C.B. Jay. </author> <title> Polynomial polymorphism. </title> <editor> In R. Kotagiri, editor, </editor> <booktitle> Proceedings of the Eighteenth Australasian Computer Science Conference: </booktitle> <address> Glenelg, South Australia 1-3 February, </address> <booktitle> 1995, </booktitle> <volume> volume 17, </volume> <pages> pages 237-243. </pages> <address> A.C.S. Communications, </address> <year> 1995. </year>
Reference-contexts: In other words, it is not necessarily the case that the functions which Jeuring and Jansson define are truly higher-order parametric. Also related to our work, is the theory of shape developed by Jay <ref> [24, 26, 25] </ref>. In the theory of shape, a data structure is separated into its shape and its contents. 1.3 Our contribution In this thesis we try to formulate higher-order parametric characterizations of generic notions and programs instead of giving inductive definitions every time.
Reference: [25] <author> C.B. Jay. </author> <title> A semantics for shape. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 25 </volume> <pages> 251-283, </pages> <year> 1995. </year>
Reference-contexts: In other words, it is not necessarily the case that the functions which Jeuring and Jansson define are truly higher-order parametric. Also related to our work, is the theory of shape developed by Jay <ref> [24, 26, 25] </ref>. In the theory of shape, a data structure is separated into its shape and its contents. 1.3 Our contribution In this thesis we try to formulate higher-order parametric characterizations of generic notions and programs instead of giving inductive definitions every time.
Reference: [26] <author> C.B. Jay and J.R.B. Cockett. </author> <title> Shapely types and shape polymorphism. </title> <editor> In D. Sannella, editor, </editor> <booktitle> Programming Languages and Systems - ESOP '94: 5th European Symposium on Programming, </booktitle> <address> Edinburgh, U.K., </address> <month> April </month> <year> 1994, </year> <booktitle> Proceedings, Lecture Notes in Computer Science, </booktitle> <pages> pages 302-316. </pages> <publisher> Springer Verlag, </publisher> <year> 1994. </year> <note> BIBLIOGRAPHY 153 </note>
Reference-contexts: In other words, it is not necessarily the case that the functions which Jeuring and Jansson define are truly higher-order parametric. Also related to our work, is the theory of shape developed by Jay <ref> [24, 26, 25] </ref>. In the theory of shape, a data structure is separated into its shape and its contents. 1.3 Our contribution In this thesis we try to formulate higher-order parametric characterizations of generic notions and programs instead of giving inductive definitions every time.
Reference: [27] <author> J. Jeuring. </author> <title> Polytypic pattern matching. </title> <booktitle> In Conference Record of FPCA '95, SIGPLAN-SIGARCH-WG2.8 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 238-248, </pages> <year> 1995. </year>
Reference-contexts: Malcolm exploited the polytypic notion of a catamorphism and introduced the banana bracket notation which was popularised and extended to the polytypic notions of anamorphism and hylomorphism by Fokkinga, Meijer and Paterson [36]. Since then the theme of polytypy has been explored in a variety ways. Several authors <ref> [6, 27, 35] </ref> have 1.2. <p> Nevertheless, an unequivocal formal semantics of parametric polymorphism is still an active area of research [15]. The situation with regard to polytypy is worse, the emphasis at the current time being on demonstrating the practicality of the notion <ref> [27, 22] </ref> with the potential danger of unnecessary complication. Parametric polymorphism is a well-defined concept that provides the basis for a well-defined theory of parametric polytypy. 1.2.3 Parametric polymorphism A polymorphic function is parametric if its behaviour does not depend on the type at which it is instantiated [48]. <p> In other words, we consider a function to be truly polytypic if the higher-order free theorem i.e. a higher-order naturality property, predicted by its type holds. The work of Jeuring and Jansson <ref> [27, 21, 22] </ref> differs in this respect from our approach since they consider a polytypic function to be a function which is defined by induction on the structure of the class of type constructors. <p> So, the question remains: are all the polytypic functions considered by Jeuring and others <ref> [27, 28, 35] </ref> higher 147 order natural, and what does the higher-order naturality look like in each of the individual cases? For instance, Jeuring defines a polytypic size function (size:F) A of type Nat FA.
Reference: [28] <author> J. Jeuring and P. Jansson. </author> <title> Polytypic programming. </title> <editor> In J. Launchbury, E. Meijer, and T. Sheard, editors, </editor> <booktitle> Proceedings of the Second International Summer School on Advanced Functional Programming Techniques, </booktitle> <pages> pages 68-114. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year> <note> LNCS 1129. </note>
Reference-contexts: So, the question remains: are all the polytypic functions considered by Jeuring and others <ref> [27, 28, 35] </ref> higher 147 order natural, and what does the higher-order naturality look like in each of the individual cases? For instance, Jeuring defines a polytypic size function (size:F) A of type Nat FA.
Reference: [29] <author> J. Lambek. </author> <title> A fixpoint theorem for complete categories. </title> <journal> Mathematische Zeitschrift, </journal> <volume> 103 </volume> <pages> 151-161, </pages> <year> 1968. </year>
Reference-contexts: this choice of ff the first conjunct of (2.14) is also true: ([Fin]) in = f computation g Fin F ([Fin]) = f F functor g F (in ([Fin])) = f above: in ([Fin]) = id T , F functor g id FT Hence, an initial algebra is an isomorphism <ref> [29] </ref>. This fact we will exploit when we extend catamorphisms to relations. As in Map, a relation is an isomorphism iff it is a bijection. Remark: the use of the term initial is because an initial F-algebra is initial in the category of F-algebras.
Reference: [30] <author> Karl J. Lieberherr, Ignacio Silva-Lepe, and Cun Xiao. </author> <title> Adaptive object-oriented programming using graph-based customization. </title> <journal> Comm.A.C.M., </journal> <volume> 37(5) </volume> <pages> 94-101, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: There does appear, however, to be a close connection to the notion of adaptive object-oriented programming <ref> [30] </ref> which aims to abstract away from the inheritance structure of an object-oriented program.
Reference: [31] <editor> G. Malcolm. Homomorphisms and promotability. In J.L.A. van de Snepscheut, editor, </editor> <booktitle> Conference on the Mathematics of Program Construction, </booktitle> <pages> pages 335-347. </pages> <publisher> Springer-Verlag LNCS 375, </publisher> <year> 1989. </year>
Reference-contexts: However, the theory was restricted only to lists and thus not applicable to arbitrary datatypes. The theory of lists has been extended by Malcolm <ref> [31, 32, 33] </ref> to arbitrary datatypes. For instance, he formulated a theorem expressing when two computations could be fused into one computation.
Reference: [32] <author> G. Malcolm. </author> <title> Algebraic data types and program transformation. </title> <type> PhD thesis, </type> <institution> Groningen University, </institution> <year> 1990. </year>
Reference-contexts: However, the theory was restricted only to lists and thus not applicable to arbitrary datatypes. The theory of lists has been extended by Malcolm <ref> [31, 32, 33] </ref> to arbitrary datatypes. For instance, he formulated a theorem expressing when two computations could be fused into one computation.
Reference: [33] <author> G. Malcolm. </author> <title> Data structures and program transformation. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 14(2-3):255-280, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: However, the theory was restricted only to lists and thus not applicable to arbitrary datatypes. The theory of lists has been extended by Malcolm <ref> [31, 32, 33] </ref> to arbitrary datatypes. For instance, he formulated a theorem expressing when two computations could be fused into one computation.
Reference: [34] <author> L. Meertens. </author> <title> Algorithmics towards programming as a mathematical activity. </title> <booktitle> In Proceedings of the CWI Symposium on Mathematics and Computer Science, </booktitle> <pages> pages 289-334. </pages> <publisher> North-Holland, </publisher> <year> 1986. </year>
Reference-contexts: For this reason the study of datatypes is an important issue. Bird has developed the theory of lists [8], a set of algebraic transformation rules involving operators like map, reduce, filter etc. Meertens calls this kind of program methodology algorithmics. <ref> [34] </ref>. The theory of lists is polymorphic. For instance the map operator is defined irrespective of the type of its argument, i.e. the type of the function that is being mapped over a list. However, the theory was restricted only to lists and thus not applicable to arbitrary datatypes.
Reference: [35] <editor> Lambert Meertens. Calculate polytypically! In Herbert Kuchen and S. Doaitse Swier-stra, editors, </editor> <booktitle> Proceedings of the Eighth International Symposium PLILP '96 Programming Languages: Implementations, Logics and Programs, volume 1140 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-16. </pages> <publisher> Springer Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Examples are overloading, the generic class of ADA, polymorphism in functional languages, and inheritance in object oriented programming. Reusability is not the only reason why generic programs are important. Another is the conceptual unification that they offer. As remarked by Meertens <ref> [35] </ref> Which is more exciting: to find yet another algorithm, or to discover that two familiar algorithms are instances of one more abstract algorithm? It is the latter that sparks new insights and opens the way for finding further connections, that makes it possible to organize and systematize our knowledge and <p> Malcolm exploited the polytypic notion of a catamorphism and introduced the banana bracket notation which was popularised and extended to the polytypic notions of anamorphism and hylomorphism by Fokkinga, Meijer and Paterson [36]. Since then the theme of polytypy has been explored in a variety ways. Several authors <ref> [6, 27, 35] </ref> have 1.2. <p> So, the question remains: are all the polytypic functions considered by Jeuring and others <ref> [27, 28, 35] </ref> higher 147 order natural, and what does the higher-order naturality look like in each of the individual cases? For instance, Jeuring defines a polytypic size function (size:F) A of type Nat FA.
Reference: [36] <author> E. Meijer, M.M. Fokkinga, and R. Paterson. </author> <title> Functional programming with bananas, lenses, envelopes and barbed wire. </title> <booktitle> In FPCA91: Functional Programming Languages and Computer Architecture, volume 523 of LNCS, </booktitle> <pages> pages 124-144. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Malcolm exploited the polytypic notion of a catamorphism and introduced the banana bracket notation which was popularised and extended to the polytypic notions of anamorphism and hylomorphism by Fokkinga, Meijer and Paterson <ref> [36] </ref>. Since then the theme of polytypy has been explored in a variety ways. Several authors [6, 27, 35] have 1.2. <p> That is, for coalgebra R : FA A, we define bd (F; R)ce 4 ([F; R ffi ]) : We call the mapping bd ( )ce a cocatamorphism instead of an anamorphism as done in [1]. An anamorphism <ref> [36] </ref> is by definition the dual of catamorphism. The reason why we prefer the term cocatamorphism instead of anamorphism is because bd ( )ce is not the relational extension of the anamorphism operator on functions. For instance, bd ( )ce does not respect functions in general. 50 CHAPTER 2.
Reference: [37] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> J. Comp. Syst. Scs., </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1977. </year>
Reference-contexts: begin with a discussion of polymorphism in functional programming. 1.2.1 Polymorphism Of the instances of genericity in current programming languages/paradigms mentioned above, one which has a relatively well-developed theoretical basis is the notion of parametric poly-morphism first introduced by Strachey [48] and later incorporated in the language ML by Milner <ref> [37, 38] </ref> (and since then a more or less standard feature of all functional programming languages). The use of parametric polymorphism is one of the major success stories of functional programming since it eliminates the compulsion in languages like Pascal to provide irrelevant type information.
Reference: [38] <author> R. Milner. </author> <title> The standard ML core language. Polymorphism, </title> <address> II(2), </address> <month> October </month> <year> 1985. </year>
Reference-contexts: begin with a discussion of polymorphism in functional programming. 1.2.1 Polymorphism Of the instances of genericity in current programming languages/paradigms mentioned above, one which has a relatively well-developed theoretical basis is the notion of parametric poly-morphism first introduced by Strachey [48] and later incorporated in the language ML by Milner <ref> [37, 38] </ref> (and since then a more or less standard feature of all functional programming languages). The use of parametric polymorphism is one of the major success stories of functional programming since it eliminates the compulsion in languages like Pascal to provide irrelevant type information.
Reference: [39] <author> E. Moggi. </author> <title> Notions of computation and monads. </title> <journal> Information and Computation, </journal> <volume> 93(1) </volume> <pages> 55-92, </pages> <year> 1991. </year>
Reference-contexts: Several scientists have argued that the notion of functor is too general to capture the notion of a datatype as understood by programmers. Moggi <ref> [39] </ref> claims that the notion of strength is fundamental to computation, strength being defined as follows. 102 CHAPTER 5. <p> It gives some confidence that the definition of a datatype as relator with membership [20] is a proper one. First of all, a relator with membership has a strength, i.e. is strong, which Moggi <ref> [39] </ref> regards fundamental to computa tion. Secondly, all natural transformations between two relators with membership are strong too. 6.5 Shapely functors Barry Jay [23] defines the notion of a shapely functor and the notion of copyable natural transformation between shapely functors. <p> So, the preservation of shape was a consequence of the higher-order naturality requirement. We showed that a special class of zips, the broadcast functions, coincide with the notion of a strength a notion which according to Moggi <ref> [39] </ref> is fundamental to computation. Furthermore, we proved that this strength is unique and that every natural transformation between two relators with membership is coherent with the corresponding strengths.
Reference: [40] <author> O. de Moor. </author> <title> Categories, Relations and Dynamic Programming. </title> <type> PhD thesis, </type> <institution> Oxford University Laboratory, Programming Research Group, </institution> <month> April </month> <year> 1992. </year> <note> 154 BIBLIOGRAPHY </note>
Reference-contexts: A relator is a monotonic functor on relations which commutes with converse. A main property of relators is that they preserve functions. Hence, a relator is a relational extension of a functor on functions. As observed by De Moor <ref> [40] </ref>, this extension is unique for a tabular allegory. That is to say, for every functor on functions, there exists at most one relator which agrees on functions with the original functor. We introduce relational coproduct and product and their corresponding relators. <p> Some functors exist for which there is no relational extension. However, all regular functors have a relational extension. A precise condition is given in <ref> [40] </ref> for when a functor has a relational extension in the case that the allegory is tabular. Shapes Another corollary of the fact that relators respect functions, is that the relation FR respects shapes. <p> Surprisingly, the above proof is very long. It is very difficult, only using that P is an extension of E and 2 : Id E, to show that 2 satisfies the defining equation of the membership relation of P. However, in <ref> [40] </ref> the following property is proved using a similar proof technique: 2n2 : P E (4.32) Using this property, the verification that 2 is the membership relation of P is almost trivial. Since flR is a function it follows that 2nR = 2n (2 flR) = 2n2 flR. <p> 2n2 flid = f 2n2 : P E g 2n2 ER flid = f fusion rule: ER flS = fl (R S) g 2n2 flR = f property above g 2nR The way we proved that 2 is the membership relation of P is an adaption of the proof in <ref> [40] </ref> of property (4.32). As a matter of fact, having the fact that 2 is membership of P, naturality of 2n2 follows trivially: PR 2n2 = f 2 membership of P g 2n (R 2) 2n (2 ER) = f ER function, factors g 2n2 ER 4.3. <p> By definition a shapely functor is a so-called pullback preserving functor equipped with a copies map. In <ref> [40] </ref>, Oege de Moor shows that a relator preserves pullbacks precisely when it preserves binary intersections. In other words, it follows that a binary intersection preserving relator with membership is shapely. Hence, all regular relators are shapely.
Reference: [41] <author> Gordon D. Plotkin. </author> <title> Lambda-definability in the full type hierarchy. </title> <editor> In J.P. Seldin and J.R. Hindley, editors, </editor> <booktitle> To H.B. Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism. </booktitle> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1980. </year>
Reference-contexts: AIMS AND MOTIVATION 1.2 Theorems for free The viability of a generic theory of datatypes was made plausible by the pioneering work of Plotkin <ref> [41] </ref> and Reynolds [43] on the semantics of polymorphism, the importance of which was highlighted by Wadler [52] in a paper entitled Theorems for free.
Reference: [42] <editor> B. Randell, G. Ringland, and W.A. Wulf (Eds.). </editor> <booktitle> Software 2000: A View of the Future. European Commission, </booktitle> <address> Brussels, </address> <year> 1994. </year>
Reference-contexts: Examples of such systems are workflow management systems, logistic systems and systems for financial administration. Indeed, Simonyi <ref> [42] </ref> has argued that the cycle of abstraction and customization is the key to success in the computing market. The macro economics of big business is of course not the concern of this thesis. Our concern is at the micro level of programming.
Reference: [43] <author> J.C. Reynolds. </author> <title> Types, abstraction and parametric polymorphism. In R.E. </title> <editor> Mason, editor, </editor> <booktitle> IFIP '83, </booktitle> <pages> pages 513-523. </pages> <publisher> Elsevier Science Publishers, </publisher> <year> 1983. </year>
Reference-contexts: AIMS AND MOTIVATION 1.2 Theorems for free The viability of a generic theory of datatypes was made plausible by the pioneering work of Plotkin [41] and Reynolds <ref> [43] </ref> on the semantics of polymorphism, the importance of which was highlighted by Wadler [52] in a paper entitled Theorems for free. <p> Parametric polymorphism is a well-defined concept that provides the basis for a well-defined theory of parametric polytypy. 1.2.3 Parametric polymorphism A polymorphic function is parametric if its behaviour does not depend on the type at which it is instantiated [48]. Reynolds <ref> [43] </ref> showed for a specific language that any parametrically polymorphic function instantiated at different types behaves in related ways. A polymorphic function satisfies a certain (di)naturality property that is derivable from the type of the function. <p> That is to say, if for some ff, ff : F G ( (ff A : FA GA for each A) : (2.15) 20 CHAPTER 2. BASIC NOTIONS we say that the free theorem predicted by the typing of ff A holds. Reynolds <ref> [43] </ref> proved for a particular language that property (2.15) holds for all polymorphic functions that are definable in that language. He showed that all basic polymorphic functions are natural transformations, and he proved that all the language constructs preserves natural transformations. <p> The nature of our requirements is influenced by Reynolds' insights into the relationship between parametric polymorphism and naturality properties <ref> [43] </ref>. Reynolds' idea as popularised by Wadler [52] is that if a function is parametrically polymorphic in a type then it is possible to derive from its type a property of the function (a theorem for free as Wadler called it).
Reference: [44] <author> F.J. Rietman. </author> <title> A note on extensionality. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Proceedings Computer Science in the Netherlands 91, </booktitle> <pages> pages 468-483, </pages> <year> 1991. </year>
Reference-contexts: In other words, points correspond to the notion of an element of a set. This explains the notation p 2 A. We unify an element and its corresponding point. Now we can state the extensionality <ref> [46, 44] </ref> axiom. That is, we assume, for R ; S : A B, that R S j R p S p for all p 2 B. or, equivalently, R = S j R p = S p for all p 2 B.
Reference: [45] <author> J. Riguet. </author> <title> Relations binaires, </title> <institution> fermetures, correspondances de Galois. Bulletin de la Soci et e Math ematique de France, </institution> <month> 76 </month> <pages> 114-155, </pages> <year> 1948. </year>
Reference-contexts: be suspected, it is the case that id = id ffi since, id = (id ) ffi = (id id) ffi = id (id ) ffi = id id = id : All the three operators of an allegory are connected by the modular law, also known as Dedekind's law <ref> [45] </ref>.
Reference: [46] <author> G. Schmidt and T. Strohlein. </author> <title> Relation algebras: Concept of points and representability. </title> <journal> Discrete Mathematics, </journal> <volume> 54 </volume> <pages> 83-92, </pages> <year> 1985. </year>
Reference-contexts: In other words, points correspond to the notion of an element of a set. This explains the notation p 2 A. We unify an element and its corresponding point. Now we can state the extensionality <ref> [46, 44] </ref> axiom. That is, we assume, for R ; S : A B, that R S j R p S p for all p 2 B. or, equivalently, R = S j R p = S p for all p 2 B.
Reference: [47] <author> G. Schmidt and T. Strohlein. </author> <title> Relations and Graphs, Discrete Mathematics for Computer Scientists. </title> <booktitle> EATCS Monographs on Theoretical Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin Heidelberg, </address> <year> 1993. </year>
Reference-contexts: Since we were already working in a categorical setting, i.e. working without elements (points), the price to pay in order to shift from functions to relations is not that high. The calculus of relations has existed for a very long time. (See e.g. <ref> [49, 50, 47] </ref>.) Our presentation of the calculus is based on the work of Backhouse et. al. [3, 2, 5, 1] and the book by Bird and De Moor [7]. The latter is based on the theory of allegories as set out in [17].
Reference: [48] <author> C. </author> <title> Strachey. </title> <booktitle> Fundamental concepts in programming languages. Lecture Notes, International Summer School in Computer Programming, </booktitle> <address> Copenhagen, </address> <month> August </month> <year> 1967. </year>
Reference-contexts: We begin with a discussion of polymorphism in functional programming. 1.2.1 Polymorphism Of the instances of genericity in current programming languages/paradigms mentioned above, one which has a relatively well-developed theoretical basis is the notion of parametric poly-morphism first introduced by Strachey <ref> [48] </ref> and later incorporated in the language ML by Milner [37, 38] (and since then a more or less standard feature of all functional programming languages). <p> Parametric polymorphism is a well-defined concept that provides the basis for a well-defined theory of parametric polytypy. 1.2.3 Parametric polymorphism A polymorphic function is parametric if its behaviour does not depend on the type at which it is instantiated <ref> [48] </ref>. Reynolds [43] showed for a specific language that any parametrically polymorphic function instantiated at different types behaves in related ways. A polymorphic function satisfies a certain (di)naturality property that is derivable from the type of the function.
Reference: [49] <author> A. Tarski. </author> <title> On the calculus of relations. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 6(3) </volume> <pages> 73-89, </pages> <year> 1941. </year>
Reference-contexts: Since we were already working in a categorical setting, i.e. working without elements (points), the price to pay in order to shift from functions to relations is not that high. The calculus of relations has existed for a very long time. (See e.g. <ref> [49, 50, 47] </ref>.) Our presentation of the calculus is based on the work of Backhouse et. al. [3, 2, 5, 1] and the book by Bird and De Moor [7]. The latter is based on the theory of allegories as set out in [17].
Reference: [50] <author> Alfred Tarski and Steven Givant. </author> <title> A Formalization of Set Theory without Variables, </title> <booktitle> volume 41 of Colloquium Publications. </booktitle> <publisher> American Mathematical Society, </publisher> <address> Providence, Rhode Island, </address> <year> 1987. </year>
Reference-contexts: Since we were already working in a categorical setting, i.e. working without elements (points), the price to pay in order to shift from functions to relations is not that high. The calculus of relations has existed for a very long time. (See e.g. <ref> [49, 50, 47] </ref>.) Our presentation of the calculus is based on the work of Backhouse et. al. [3, 2, 5, 1] and the book by Bird and De Moor [7]. The latter is based on the theory of allegories as set out in [17].
Reference: [51] <author> D. Tuijnman. </author> <title> A Categorical Approach to Functional Programming. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Ulm, Germany, </institution> <year> 1996. </year>
Reference-contexts: However, we defined a datatype as a relator with membership and using this definition we were able to prove in one go that all regular relators have a strength. This in contrast to, for example, Tuijnman <ref> [51] </ref> who established a similar result by giving an inductive definition for the class of regular datatypes. Another example is structure multiplication.

References-found: 51

