URL: ftp://ftp.cis.ohio-state.edu/pub/anish/papers/trees-rings.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~anish/pub.html
Root-URL: 
Title: Fault-Tolerant Reconfiguration of Trees and Rings in Distributed Systems  
Author: Anish Arora Ashish Singhai 
Keyword: Categories and Subject Descriptors C.2.4 [Computer Communication Systems] Distributed Systems D.1.3 [Programming Techniques] Concurrent Programming D.2.4 [Program Verification] Reliability D.2.10 [Program Design] Methodologies D.4.5 [Operating Systems] Fault-tolerance G.2.2 [Discrete Mathematics] Graph Algorithms  
Note: 0 Research supported in part by NSF grant CCR-9308640 and OSU Grant 221506  
Address: Columbus, OH 43210 Urbana-Champaign, IL 61801  
Affiliation: Computer Science Computer Science The Ohio State University University of Illinois  
Abstract: We design two programs that maintain the nodes of any distributed system in a rooted spanning tree and in a unidirectional ring, respectively, in the presence of any finite number of fail-stop failures and repairs of system nodes and communication channels. Our programs are fully distributed, have optimal time and space complexity, and illustrate two different methods for the design of nonmasking fault-tolerant programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Arora and M. G. Gouda, </author> <title> "Closure and convergence: A foundation of fault-tolerant computing", </title> <journal> IEEE Transactions on Software Engineering 19(11) (1993), pp. </journal> <volume> 1015 19 1027. </volume>
Reference: [2] <author> A. Arora, </author> <title> "A foundation of fault-tolerant computing", </title> <type> Ph.D. Dissertation, </type> <institution> The Uni versity of Texas at Austin (1992). </institution>
Reference-contexts: Such a state predicate identifies the "fault-span" of p. Note that the fault-span includes the fault-free states of the program. (Hence S ) T .) Examples showing how to design fault-span predicates appear in <ref> [2] </ref>. These examples take the view that all classes of faults can be represented as actions that change the program state.
Reference: [3] <author> A. Arora, M. G. Gouda, and G. Varghese, </author> <title> "Constraint satisfaction as a basis for designing nonmasking fault-tolerance", Journal of High Speed Networks, </title> <booktitle> (1994 to appear); Proceedings of the 14th International Conference on Distributed Computer Systems (1994), </booktitle> <pages> pp. 424-431. </pages>
Reference: [4] <author> E. W. Dijkstra, </author> <title> "Self-stabilizing systems in spite of distributed control", </title> <journal> Communi cations of the ACM , Vol. </journal> <volume> 17, No. 11, </volume> <pages> pp. </pages> <month> 643-644 </month> <year> (1974). </year>
Reference: [5] <author> F. B. Bastani, I.-L. Yen, and I.-R. Chen, </author> <title> "A class of inherently fault-tolerant dis tributed programs", </title> <journal> IEEE Transactions on Software Engg. </journal> <volume> 14(10) (1988), </volume> <pages> pp. 1431-1442. </pages>
Reference: [6] <author> R. G. Gallagher, P. A. Humblet, and P. M. Spira, </author> <title> "A distributed algorithm for minimum-weight spanning trees", </title> <journal> ACM Transactions on Programming Lang. and Sys. </journal> <volume> 5(1) (1983), </volume> <pages> pp. 66-77. </pages>
Reference-contexts: More specifically, for the case of spanning tree construction, we recall that Gallagher et al <ref> [6] </ref> have presented an elegant solution but their solution is fault-intolerant, i.e., their solution does not solve the spanning tree reconfiguration problem.
Reference: [7] <author> A. Arora and M. G. Gouda, </author> <title> "Distributed reset", </title> <journal> IEEE Transactions on Computers 43(9) (1994). </journal>
Reference-contexts: More specifically, for the case of spanning tree construction, we recall that Gallagher et al [6] have presented an elegant solution but their solution is fault-intolerant, i.e., their solution does not solve the spanning tree reconfiguration problem. Stabilizing algorithms for spanning tree reconfiguration have been presented <ref> [7, 8, 9] </ref>, that tolerate failures as well as repairs of both nodes and edges, but these programs are significantly more complex than our algorithm, since unlike our algorithm they allow for the formation of transient cycles in the graph of the parent variables. <p> Finally, we show that starting from any state where V holds, every computation of RST reaches a state where S holds. 2 We measure the time complexity of convergence to S in terms of rounds <ref> [7] </ref>. A round is a minimal, nonempty sequence of program steps wherein for each node 12 there exists a step where the node either executes an action or has no actions enabled before or after the step.
Reference: [8] <author> G. Varghese, </author> <title> "Self-stabilization by local checking and correction", </title> <type> Ph.D. Dissertation, </type> <institution> Massachusetts Institute of Technology (1992). </institution>
Reference-contexts: More specifically, for the case of spanning tree construction, we recall that Gallagher et al [6] have presented an elegant solution but their solution is fault-intolerant, i.e., their solution does not solve the spanning tree reconfiguration problem. Stabilizing algorithms for spanning tree reconfiguration have been presented <ref> [7, 8, 9] </ref>, that tolerate failures as well as repairs of both nodes and edges, but these programs are significantly more complex than our algorithm, since unlike our algorithm they allow for the formation of transient cycles in the graph of the parent variables.
Reference: [9] <author> R. Perlman, </author> <title> "An algorithm for distributed computation of a spanning tree in an ex tended LAN", </title> <booktitle> Ninth ACM Data Communications Symposium, </booktitle> <volume> Vol. 20, No. 7 (1985), </volume> <pages> pp. 44-52. </pages>
Reference-contexts: More specifically, for the case of spanning tree construction, we recall that Gallagher et al [6] have presented an elegant solution but their solution is fault-intolerant, i.e., their solution does not solve the spanning tree reconfiguration problem. Stabilizing algorithms for spanning tree reconfiguration have been presented <ref> [7, 8, 9] </ref>, that tolerate failures as well as repairs of both nodes and edges, but these programs are significantly more complex than our algorithm, since unlike our algorithm they allow for the formation of transient cycles in the graph of the parent variables. <p> Moreover, these programs converge slower than our algorithm in the average case. Perlman's solution <ref> [9] </ref> additionally 3 uses periodic transmission of messages, which results in significant communication overhead. Other programs we are aware of are at best tolerant only to the failures of edges or only the failures and repairs of nodes.
Reference: [10] <author> J.-M. Helary and M. Raynal, </author> <title> "Virtual ring construction in parallel distributed sys tems", </title> <editor> M. Cosnard (ed.), </editor> <booktitle> Parallel Processing, </booktitle> <publisher> Elsevier Science, </publisher> <year> 1988, </year> <pages> pp. 333-345. </pages>
Reference-contexts: Other programs we are aware of are at best tolerant only to the failures of edges or only the failures and repairs of nodes. For the case of ring embeddings, the distributed solutions we are aware of <ref> [10, 11] </ref> do not tolerate fail-stop failures or repairs. Helary and Raynal [10] have presented an algorithm that enumerates ring nodes, one at a time, in the order of a depth first traversal of a tree. <p> Other programs we are aware of are at best tolerant only to the failures of edges or only the failures and repairs of nodes. For the case of ring embeddings, the distributed solutions we are aware of [10, 11] do not tolerate fail-stop failures or repairs. Helary and Raynal <ref> [10] </ref> have presented an algorithm that enumerates ring nodes, one at a time, in the order of a depth first traversal of a tree. While this limits the length of the embedded ring to 2 (N 1), it allows the dilation to be linear in N .
Reference: [11] <author> P. Rosenstiehl, J. R. Fiksel, and A. Holliger, </author> <title> "Intelligent graphs: networks of finite automata capable of solving graph problems", </title> <editor> R. C. Read (ed.), </editor> <title> Graph Theory and Computing, </title> <publisher> Academic Press, </publisher> <year> 1972, </year> <pages> pp. 219-265. </pages>
Reference-contexts: Other programs we are aware of are at best tolerant only to the failures of edges or only the failures and repairs of nodes. For the case of ring embeddings, the distributed solutions we are aware of <ref> [10, 11] </ref> do not tolerate fail-stop failures or repairs. Helary and Raynal [10] have presented an algorithm that enumerates ring nodes, one at a time, in the order of a depth first traversal of a tree. <p> The message complexity of their algorithm is O (N ), as messages contain a list of nodes already traversed. By way of contrast, a message passing version of our algorithm would use messages of only O (log M ) size. Rosenstiehl et al <ref> [11] </ref> have presented a self-synchronizing tree network of finite state automata that execute in unison from a given initial state to embed a ring of dilation at most three on the tree edges.
Reference: [12] <author> A. Arora and A. Singhai, </author> <title> "Optimal, nonmasking fault-tolerant reconfiguration of trees and rings", </title> <note> OSU Technical Report CISRC-TR09-1994; a preliminary version appears in Proceedings of International Conference on Network Protocols, pp. 221-228, 1994. 20 </note>
Reference-contexts: Stage 1 requires at most N rounds; stage 2 requires at most N rounds; and stage 3 requires at most 2N 3 rounds, where N is the number of up nodes. It follows that the time complexity of RST is O (N ) rounds. We refer the reader to <ref> [12] </ref> for formal proofs of all lemmas and theorems in this paper. 4 Maintaining A Unidirectional Ring In this section, we employ the second of the two design methods discussed in Section 1 to derive a nonmasking fault-tolerant program for maintaining a unidirectional ring.
References-found: 12

