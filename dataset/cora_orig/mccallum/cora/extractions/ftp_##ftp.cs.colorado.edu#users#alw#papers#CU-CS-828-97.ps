URL: ftp://ftp.cs.colorado.edu/users/alw/papers/CU-CS-828-97.ps
Refering-URL: http://www.cs.colorado.edu/serl/arch/Papers.html
Root-URL: http://www.cs.colorado.edu
Email: (fcompare,inverardg@univaq.it) (alw@cs.colorado.edu)  
Title: Uncovering Architectural Mismatch in Component Behavior  
Author: Daniele Compare and Paola Inverardi Alexander L. Wolf 
Address: I-67010 L'Aquila, Italy Boulder, CO 80309 USA  
Affiliation: Dipartimento di Matematica Department of Computer Science Universita di L'Aquila University of Colorado  
Abstract: University of Colorado Department of Computer Science Technical Report CU-CS-828-97 February 1997 ABSTRACT When constructing software systems from existing components, the engineer is faced with the problem of potential conflicts in the interactions among the components. Of particular difficulty is guaranteeing compatibility in the dynamic interaction behavior. Using an architectural description of the system and its intended components, the engineer can reason about the interactions early and at a high level of abstraction. In this paper we give a case study of the Compressing Proxy system, which was first investigated by Garlan, Kindred, and Wing. We present architectural specifications and analyses of two versions of the system. One version is a seemingly obvious melding of the components. The other is a solution to deadlock problems uncovered by formal analyses of the first version. We use the Chemical Abstract Machine as an example of an architectural description formalism that can help uncover architectural mismatches in the behavior of components. c fl 1997 Daniele Compare, Paola Inverardi, and Alexander L. Wolf
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G.D. Abowd, R. Allen, and D. Garlan. </author> <title> Formalizing Style to Understand Descriptions of Software Architecture. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 4(4) </volume> <pages> 319-364, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: A number of researchers have been experimenting with a variety of techniques for describing and analyzing systems at the architectural level of design <ref> [1, 2, 13, 15] </ref>. Each of the techniques is based on a different underlying formalism. For example, Abowd et al. use Z [19] for specifying architectural styles, while the Wright architectural description language [2] is based on CSP [12].
Reference: [2] <author> R. Allen and D. Garlan. </author> <title> Formalizing Architectural Connection. </title> <booktitle> In Proceedings of the 16th International Conference on Software Engineering, </booktitle> <pages> pages 71-80. </pages> <publisher> IEEE Computer Society, </publisher> <month> May </month> <year> 1994. </year>
Reference-contexts: A number of researchers have been experimenting with a variety of techniques for describing and analyzing systems at the architectural level of design <ref> [1, 2, 13, 15] </ref>. Each of the techniques is based on a different underlying formalism. For example, Abowd et al. use Z [19] for specifying architectural styles, while the Wright architectural description language [2] is based on CSP [12]. <p> Each of the techniques is based on a different underlying formalism. For example, Abowd et al. use Z [19] for specifying architectural styles, while the Wright architectural description language <ref> [2] </ref> is based on CSP [12]. The technique developed by Inverardi and Wolf [13] is based on the CHAM (CHemical Abstract Machine) formalism [5].
Reference: [3] <author> J.-P. Ban^atre and D. Le Metayer. </author> <title> The Gamma Model and its Discipline of Programming. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 15 </volume> <pages> 55-77, </pages> <year> 1990. </year>
Reference-contexts: It is built upon the chemical metaphor first proposed by Ban^atre and Le Metayer to illustrate their Gamma () formalism for parallel programming, in which programs can be seen as multiset trans 3 formers <ref> [3] </ref>, [4]. The CHAM formalism provides a powerful set of primitives for computational modeling. Indeed, its generality, power, and utility have been clearly demonstrated by its use in formally capturing the semantics of older, more familiar computational models, such as CSP [12] and the CCS process calculus [16].
Reference: [4] <author> J.-P. Ban^atre and D. Le Metayer. </author> <title> Programming by Multiset Transformation. </title> <journal> Communications of the ACM, </journal> <volume> 36(1) </volume> <pages> 98-111, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: It is built upon the chemical metaphor first proposed by Ban^atre and Le Metayer to illustrate their Gamma () formalism for parallel programming, in which programs can be seen as multiset trans 3 formers [3], <ref> [4] </ref>. The CHAM formalism provides a powerful set of primitives for computational modeling. Indeed, its generality, power, and utility have been clearly demonstrated by its use in formally capturing the semantics of older, more familiar computational models, such as CSP [12] and the CCS process calculus [16].
Reference: [5] <author> G. Berry and G. Boudol. </author> <title> The Chemical Abstract Machine. </title> <journal> Theoretical Computer Science, </journal> <volume> 96 </volume> <pages> 217-248, </pages> <year> 1992. </year>
Reference-contexts: For example, Abowd et al. use Z [19] for specifying architectural styles, while the Wright architectural description language [2] is based on CSP [12]. The technique developed by Inverardi and Wolf [13] is based on the CHAM (CHemical Abstract Machine) formalism <ref> [5] </ref>. CHAM is an operational formalism that leads to a description of an architecture as a set of components (the "molecules") whose states and interactions are governed by transformation rules (the "reactions"). <p> Below we show how analyses performed on CHAM descriptions of the component behaviors can reveal such problems. 3 Background on the CHAM Formalism The CHAM formalism was developed by Berry and Boudol in the domain of theoretical computer science for the principal purpose of defining a generalized computational framework <ref> [5] </ref>. It is built upon the chemical metaphor first proposed by Ban^atre and Le Metayer to illustrate their Gamma () formalism for parallel programming, in which programs can be seen as multiset trans 3 formers [3], [4]. The CHAM formalism provides a powerful set of primitives for computational modeling.
Reference: [6] <author> G. Boudol. </author> <title> Some Chemical Abstract Machines. In A Decade of Concurrency, </title> <booktitle> number 803 in Lecture Notes in Computer Science, </booktitle> <pages> pages 92-123. </pages> <publisher> Springer-Verlag, </publisher> <month> May </month> <year> 1994. </year>
Reference-contexts: The CHAM formalism provides a powerful set of primitives for computational modeling. Indeed, its generality, power, and utility have been clearly demonstrated by its use in formally capturing the semantics of older, more familiar computational models, such as CSP [12] and the CCS process calculus [16]. Boudol <ref> [6] </ref> points out that the CHAM formalism has also been demonstrated as a modeling tool for concurrent-language definition and implementation. Inverardi and Wolf [13] developed a framework for architectural specification and analysis based on the CHAM formalism.
Reference: [7] <author> D. </author> <type> Compare. </type> <institution> Specifica ed Analisi del CERN Compressing Proxy con la CHAM. Technical Report Tesi di Laurea, Dipartimento di Matematica Pura ed Applicata, L'Aquila, Italy, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: However, this can be easily solved by modifying the specification such that the T 2 ; T 2 ; T 1 ; : : : T 2 ; T 2 cycle is suitably constrained to, for example, simulate some bounded buffer <ref> [7, 8] </ref>. In fact, it is important to introduce a constraint such as this only if it is necessary in the description of the system, which for our purposes here it is not. Therefore, we do not consider this situation further.
Reference: [8] <author> D. Compare and P. Inverardi. </author> <title> Modelling Interoperability by CHAM: A Case Study. </title> <booktitle> In Proceedings of the First International Conference on Coordination Models and Languages, number 1061 in Lecture Notes in Computer Science, </booktitle> <pages> pages 428-431. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1996. </year>
Reference-contexts: However, this can be easily solved by modifying the specification such that the T 2 ; T 2 ; T 1 ; : : : T 2 ; T 2 cycle is suitably constrained to, for example, simulate some bounded buffer <ref> [7, 8] </ref>. In fact, it is important to introduce a constraint such as this only if it is necessary in the description of the system, which for our purposes here it is not. Therefore, we do not consider this situation further.
Reference: [9] <author> N. De Francesco and P. Inverardi. </author> <title> Proving Finiteness of CCS Processes by Non-standard Semantics. </title> <journal> Acta Informatica, </journal> <volume> 31(1) </volume> <pages> 55-80, </pages> <year> 1994. </year>
Reference-contexts: First we show how it is possible to generate a transition system from a CHAM description. Basically, we use the usual approach of deriving the transition system from the operational semantics <ref> [9, 16, 20] </ref> by considering that our reaction rules are indeed the operational semantic rules. Note, however, that due to the concurrent operational nature of the CHAM, we must also consider all the transitions in which sets of disjoint redexes can be applied.
Reference: [10] <author> D. Garlan, R. Allen, and J. Ockerbloom. </author> <title> Architectural Mismatch or Why it's Hard to Build Systems Out of Existing Parts. </title> <booktitle> In Proceedings of the 17th International Conference on Software Engineering, </booktitle> <pages> pages 179-185. </pages> <institution> Association for Computer Machinery, </institution> <month> April </month> <year> 1995. </year>
Reference-contexts: Components naturally embody assumptions about the structure and behavior of the larger contexts in which they operate. When constructing software systems from existing components, the engineer is therefore faced with the problem of uncovering and avoiding architectural mismatch <ref> [10] </ref>, which is a conflict in the interaction among an assembly of components. Mismatches can be understood to arise from conflicts at two levels of interaction.
Reference: [11] <author> D. Garlan, D. Kindred, and J.M. Wing. </author> <title> Interoperability: Sample Problems and Solutions. </title> <type> Technical report, </type> <institution> Carnegie Mellon University, Pittsburgh, Pennsylvania, </institution> <note> In preparation. </note>
Reference-contexts: We use as our example a case study of the Compressing Proxy system introduced by Garlan, Kindred, and Wing <ref> [11] </ref>. The Compressing Proxy is designed as a combination of two pre-existing component systems, each individually designed and separately useful. Due to an architectural mismatch problem, it took the designers of the Compressing Proxy two attempts to properly develop the system. <p> We conclude in Section 6 by considering how the two kinds of analysis techniques might be employed in concert. 2 The Compressing Proxy Problem In this section we present the design of the Compressing Proxy system. Our description is derived from that given by Garlan, Kindred, and Wing <ref> [11] </ref>. To improve the performance of UNIX-based World Wide Web browsers over slow networks, one could create an HTTP (Hyper Text Transfer Protocol) server that compresses and uncompresses data that it sends across the network.
Reference: [12] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1985. </year>
Reference-contexts: Each of the techniques is based on a different underlying formalism. For example, Abowd et al. use Z [19] for specifying architectural styles, while the Wright architectural description language [2] is based on CSP <ref> [12] </ref>. The technique developed by Inverardi and Wolf [13] is based on the CHAM (CHemical Abstract Machine) formalism [5]. CHAM is an operational formalism that leads to a description of an architecture as a set of components (the "molecules") whose states and interactions are governed by transformation rules (the "reactions"). <p> The CHAM formalism provides a powerful set of primitives for computational modeling. Indeed, its generality, power, and utility have been clearly demonstrated by its use in formally capturing the semantics of older, more familiar computational models, such as CSP <ref> [12] </ref> and the CCS process calculus [16]. Boudol [6] points out that the CHAM formalism has also been demonstrated as a modeling tool for concurrent-language definition and implementation. Inverardi and Wolf [13] developed a framework for architectural specification and analysis based on the CHAM formalism.
Reference: [13] <author> P. Inverardi and A.L. Wolf. </author> <title> Formal Specification and Analysis of Software Architectures using the Chemical Abstract Machine Model. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4) </volume> <pages> 373-386, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: A number of researchers have been experimenting with a variety of techniques for describing and analyzing systems at the architectural level of design <ref> [1, 2, 13, 15] </ref>. Each of the techniques is based on a different underlying formalism. For example, Abowd et al. use Z [19] for specifying architectural styles, while the Wright architectural description language [2] is based on CSP [12]. <p> Each of the techniques is based on a different underlying formalism. For example, Abowd et al. use Z [19] for specifying architectural styles, while the Wright architectural description language [2] is based on CSP [12]. The technique developed by Inverardi and Wolf <ref> [13] </ref> is based on the CHAM (CHemical Abstract Machine) formalism [5]. CHAM is an operational formalism that leads to a description of an architecture as a set of components (the "molecules") whose states and interactions are governed by transformation rules (the "reactions"). <p> In this paper we demonstrate how designers can use formal architectural specifications and analyses to help uncover architectural mismatch in component behavior. To illustrate the benefits of this approach, we employ the techniques that we developed for the CHAM formalism. Our earlier work <ref> [13] </ref> exploited the algebraic and term-rewriting flavor of the CHAM formalism to introduce the basic algebraic analysis approach to the architectural level of design. <p> Boudol [6] points out that the CHAM formalism has also been demonstrated as a modeling tool for concurrent-language definition and implementation. Inverardi and Wolf <ref> [13] </ref> developed a framework for architectural specification and analysis based on the CHAM formalism. Their goal is to apply the power of the CHAM, not to its original purpose of capturing computational models and defining programming languages, but rather to the design phase of specific software systems. <p> Finally, if no rules can be applied to a solution, then that solution is said to be inert. 3.2 Specifying Software Architectures The CHAM specification of a software architecture consists of three parts <ref> [13] </ref>: 1. a description of the syntax by which components of the architecture (i.e., the molecules) can be represented; 2. a solution representing the initial state of the architecture; and 3. a set of reaction rules describing how the components interact to achieve the dynamic behavior of the system. <p> On the one hand, we exploit the algebraic and equational nature of CHAM to allow us to prove a variety of important properties about an architecture. This was the technique illustrated in general in our earlier work <ref> [13] </ref>. On the other hand, we take advantage of the CHAM formalism's operational flavor by generating transition systems from specifications and then reasoning at the transition-system level. <p> We recall the following definition relevant to all CHAM specifications of software architec tures <ref> [13] </ref>. Definition 1 A reaction derivation S 0 ! S 1 ! ! S n is normalizing if S n is inert. This definition means that a given derivation terminates, since a solution is inert when there are no other reaction rules that can be applied to it.
Reference: [14] <author> P. Inverardi and A.L. Wolf. </author> <title> On the Choice of a Software Architecture: A Guided Tour in the Analysis of Architectural Design. Available from the authors, </title> <month> October </month> <year> 1996. </year>
Reference-contexts: This can be very useful when analysing alternative architectures of the same system that can be characterized by means of invariant properties. In fact, we have already begun to exploit this approach <ref> [14] </ref>. 20
Reference: [15] <author> D.C. Luckham and J. Vera. </author> <title> An Event-based Architecture Definition Language. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(9) </volume> <pages> 717-734, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: A number of researchers have been experimenting with a variety of techniques for describing and analyzing systems at the architectural level of design <ref> [1, 2, 13, 15] </ref>. Each of the techniques is based on a different underlying formalism. For example, Abowd et al. use Z [19] for specifying architectural styles, while the Wright architectural description language [2] is based on CSP [12].
Reference: [16] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1989. </year>
Reference-contexts: Here we extend that work by giving improved structure to the transformation rules and by showing a second kind of analysis based on transition-system generation in the style of Milner <ref> [16] </ref>. We use as our example a case study of the Compressing Proxy system introduced by Garlan, Kindred, and Wing [11]. The Compressing Proxy is designed as a combination of two pre-existing component systems, each individually designed and separately useful. <p> The CHAM formalism provides a powerful set of primitives for computational modeling. Indeed, its generality, power, and utility have been clearly demonstrated by its use in formally capturing the semantics of older, more familiar computational models, such as CSP [12] and the CCS process calculus <ref> [16] </ref>. Boudol [6] points out that the CHAM formalism has also been demonstrated as a modeling tool for concurrent-language definition and implementation. Inverardi and Wolf [13] developed a framework for architectural specification and analysis based on the CHAM formalism. <p> First we show how it is possible to generate a transition system from a CHAM description. Basically, we use the usual approach of deriving the transition system from the operational semantics <ref> [9, 16, 20] </ref> by considering that our reaction rules are indeed the operational semantic rules. Note, however, that due to the concurrent operational nature of the CHAM, we must also consider all the transitions in which sets of disjoint redexes can be applied.
Reference: [17] <author> D.E. Perry and A.L. Wolf. </author> <title> Foundations for the Study of Software Architecture. </title> <booktitle> SIGSOFT Software Engineering Notes, </booktitle> <volume> 17(4) </volume> <pages> 40-52, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: The syntactic description of the components is given by an algebra of molecules or, in other words, a syntax by which molecules can be built. Following Perry and Wolf <ref> [17] </ref>, we distinguish three classes of components: data elements, processing elements, and connecting elements. The processing elements are those components that perform the transformations on the data elements, while the data elements are those that contain the information that is used and transformed.
Reference: [18] <author> A. </author> <month> Rosetti. </month> <institution> Generazione di Test Cases da Specifiche Formali della Architettura Software. Technical Report Tesi di Laurea, Dipartimento di Matematica Pura ed Applicata, L'Aquila, Italy, </institution> <month> March </month> <year> 1997. </year>
Reference-contexts: The arcs are labelled with the transformation rules from Table 1. The graph was produced by a tool that we developed to generate transition systems from CHAM architecture specifications <ref> [18] </ref>. In the figure we see a solution with no outgoing arcs, S 35 . This state represents deadlock in the system.
Reference: [19] <author> J.M. Spivey. </author> <title> Understanding Z: A Specification Language and its Formal Semantics. </title> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: A number of researchers have been experimenting with a variety of techniques for describing and analyzing systems at the architectural level of design [1, 2, 13, 15]. Each of the techniques is based on a different underlying formalism. For example, Abowd et al. use Z <ref> [19] </ref> for specifying architectural styles, while the Wright architectural description language [2] is based on CSP [12]. The technique developed by Inverardi and Wolf [13] is based on the CHAM (CHemical Abstract Machine) formalism [5].
Reference: [20] <author> D. Taubner. </author> <title> Finite Representations of CCS and TCSP Programs by Automata and Petri Nets. </title> <booktitle> Number 369 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1989. </year> <month> 21 </month>
Reference-contexts: First we show how it is possible to generate a transition system from a CHAM description. Basically, we use the usual approach of deriving the transition system from the operational semantics <ref> [9, 16, 20] </ref> by considering that our reaction rules are indeed the operational semantic rules. Note, however, that due to the concurrent operational nature of the CHAM, we must also consider all the transitions in which sets of disjoint redexes can be applied.
References-found: 20

