URL: http://www.cs.utexas.edu/users/pclark/papers/uttr96a.ps
Refering-URL: http://www.cs.utexas.edu/users/pclark/papers/uttr96a.abs.html
Root-URL: 
Email: fpclark,porterg@cs.utexas.edu  
Title: Building Domain Representations from Components 1  
Author: Peter Clark and Bruce Porter 
Address: Austin, TX 78712, USA  
Affiliation: Dept. Computer Science Univ. Texas at Austin  
Abstract: Tech Report AI96-241, Dept CS, Univ Texas at Austin, 1996. http://www.cs.utexas.edu/users/pclark/papers/uttr96a.ps Abstract A major cause of the knowledge-engineering bottleneck is the inability to transfer representational fragments from one knowledge base to another due to the idiosyncratic nature of domain-specific representations. In this paper, we show that representations can be built automatically by composing abstract, reusable components. Moreover, we describe how representations of specific situations, that arise during problem solving, can be assembled `on demand', guided by a query for a particular piece of information. Our work integrates ideas from dynamic memory, conceptual graph theory, compositional modeling and graph unifica tion.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Ait-Kaci and A. </author> <title> Podelski. Towards a meaning of LIFE. </title> <journal> Logic Programming, </journal> <volume> 16 </volume> <pages> 195-234, </pages> <year> 1993. </year> <note> (also available as http://www.isg.sfu.ca/ftp/pub/hak/prl/PRL-RR-11.ps.Z). </note>
Reference: [2] <author> H. Ait-Kaci, A. Podelski, and S. C. Goldstein. </author> <title> Order-sorted feature theory unification. </title> <type> Tech Report PRL-RR-32, </type> <institution> Digital Paris Research Labs, </institution> <month> May </month> <year> 1993. </year> <note> (http://www.isg.sfu.ca/ftp/pub/hak/prl/PRL-RR-32.ps.Z). </note>
Reference-contexts: Conceptual Graphs A final approach to assembling representations, which forms the basis of our approach, is the use of conceptual graphs (CGs) [19] and psi-terms <ref> [2] </ref> to represent components. Both are graph-like data structures containing labeled nodes (concepts) and arcs (relations). Conceptual graph theory provides a variety of logical semantics for different types of graphs. Psi-term theory provides a well-defined syntactic operation called graph unification (or join, in CG terminology) for merging psi-terms together . <p> The main challenge for a component-based representation falls on the composition operator: it must be capable of integrating information from various components, not simply collecting it. We implement this capability with graph unification, defined in Table 1, based on a similar algorithm for psi-term unification <ref> [2] </ref>. Our objective with unification is to syntactically merge graphs in a way that corresponds to merging semantically related information. This requires an additional 5 PROCEDURE UNIFY (Term1, Term2) BEGIN 1.
Reference: [3] <author> D. Batory and S. O'Malley. </author> <title> The design and implementation of hierarchical software systems with reusable components. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <month> Oct </month> <year> 1992. </year>
Reference-contexts: Multiple inheritance would not help because what is needed is an integration, not a concatenation, of the algorithms for deque and guarding. Code repetition is common in libraries [4], and many researchers are studying additional methods for software reuse <ref> [3, 20] </ref>. Cliches Motivated by Minsky's work, Chapman proposed another approach to assembling representations from components [6], which was partially implemented in the Programmer's Apprentice [16]. <p> a RestaurantVisit with ...? [4]-&gt; a RestaurantVisit with diner = John and food = a Lobster? This expression tells the query interpreter to create an initial instance graph representing this restaurant visit, as illustrated in Figure 7. [4]&lt;- RestaurantVisit01 ;; return the new instance Now the interpreter can re-evaluate step <ref> [3] </ref>, substituting in the value of the restaurant visit: [3]-&gt; the script of RestaurantVisit01? The instance graph currently has no script arc from RestaurantVisit01, causing the interpreter to incorporate, with lazy unification, those components of RestaurantVisit that contain a script arc.
Reference: [4] <author> D. Batory, V. Singhal, M. Sirkin, and J. Thomas. </author> <title> Scalable software libraries. </title> <booktitle> In Proceedings ACM SIGSOFT'93 (Symposium on the Foundations of Software Engineering), </booktitle> <month> Dec </month> <year> 1993. </year>
Reference-contexts: What is often needed, however, is some integration of those values into a new, compound value. This shortcoming of inheritance is well recognized in current software engineering, where software components can inherit methods from multiple abstractions, but cannot combine them. Batory <ref> [4] </ref> provides an illustration of this in the Booch C++ component library [5]: in which the guarded bounded ordered deque and guarded unbounded unordered queue classes share only one superclass (deque), even though they also use the same concurrency control method (guarding). <p> Consequently, the component writer must repeat the code for guarding in both classes. Multiple inheritance would not help because what is needed is an integration, not a concatenation, of the algorithms for deque and guarding. Code repetition is common in libraries <ref> [4] </ref>, and many researchers are studying additional methods for software reuse [3, 20]. Cliches Motivated by Minsky's work, Chapman proposed another approach to assembling representations from components [6], which was partially implemented in the Programmer's Apprentice [16].
Reference: [5] <author> G. Booch and M. Vilot. </author> <title> The design of the C++ booch components. </title> <booktitle> In OOPSLA'90, </booktitle> <pages> pages 1-11, </pages> <month> Oct </month> <year> 1990. </year>
Reference-contexts: This shortcoming of inheritance is well recognized in current software engineering, where software components can inherit methods from multiple abstractions, but cannot combine them. Batory [4] provides an illustration of this in the Booch C++ component library <ref> [5] </ref>: in which the guarded bounded ordered deque and guarded unbounded unordered queue classes share only one superclass (deque), even though they also use the same concurrency control method (guarding). Consequently, the component writer must repeat the code for guarding in both classes.
Reference: [6] <author> D. Chapman. </author> <title> Cognitive cliches. AI Working Paper 286, </title> <publisher> MIT, </publisher> <address> MA, </address> <month> Apr </month> <year> 1986. </year>
Reference-contexts: Code repetition is common in libraries [4], and many researchers are studying additional methods for software reuse [3, 20]. Cliches Motivated by Minsky's work, Chapman proposed another approach to assembling representations from components <ref> [6] </ref>, which was partially implemented in the Programmer's Apprentice [16]. Chapman described components, called cliches, as "patterns commonly found in representations" | such as Containment, Propagation, and Resistance | from which more specific representations can be assembled.
Reference: [7] <author> W. J. Clancey. </author> <title> Model construction operators. </title> <journal> AI, </journal> <volume> 53(1) </volume> <pages> 1-116, </pages> <year> 1992. </year>
Reference-contexts: Following Clancey <ref> [7] </ref>, we view question-answering as constructing a situation-specific model, based on initial information and these specifications, about the particular problem being solved.
Reference: [8] <author> J. M. Crawford and B. J. Kuipers. </author> <title> Algernon a tractable system for knowledge-representation. </title> <journal> SIGART Bulletin, </journal> <volume> 2(3) </volume> <pages> 35-44, </pages> <month> June </month> <year> 1991. </year> <month> 14 </month>
Reference-contexts: Of course, this efficiency trades off completeness there could be other sequences of inferences that reach the conclusion, but are not explored because they are "off the path". However, we retain a useful, albeit weakened, type of completeness called Socratic completeness <ref> [8] </ref>. Socratic completeness guarantees that any deductive consequence of the KB is deducible via some sequence of queries.
Reference: [9] <author> M. G. Dyer. </author> <title> $RESTAURANT revisited, or `lunch with boris'. </title> <booktitle> In IJCAI-81, </booktitle> <pages> pages 234-236, </pages> <year> 1981. </year>
Reference-contexts: Although several projects devised representations for MOPS, they largely used existing techniques for composing them. CHEF [12], for example, reverted to standard methods such as inheritance, and 3 BORIS used templates that were manually overlaid on pre-written, detailed scripts <ref> [9] </ref>. Nev--ertheless, Schank's proposal for a memory capable of dynamically assembling representations is important inspiration for our work. <p> We continue with the RestaurantVisit, as this concept is familiar, is rich in structure, and is known to pose problems for composition <ref> [9, 18] </ref>. Figure 4a shows a KM-term representing a simplified `restaurant script', as might typically be encoded in a knowledge base. There is a diner, a waiter, and a meal. During the visit, the diner selects his/her meal, requests it from the waiter, receives it, eats it and finally pays.
Reference: [10] <author> B. Falkenhainer and K. Forbus. </author> <title> Compositional modelling: Finding the right model for the job. </title> <journal> Artificial Intelligence, </journal> <volume> 51 </volume> <pages> 95-143, </pages> <year> 1991. </year>
Reference-contexts: Nev--ertheless, Schank's proposal for a memory capable of dynamically assembling representations is important inspiration for our work. Compositional Modeling A fourth approach to assembling representations comes from work on compositional modeling, the task of building a model of a physical system adequate for answering questions about the system <ref> [10, 13, 17] </ref>. In compositional modeling, a component (called a model fragment) contains a set of constraints 2 with well-defined semantics, rather than being represented in syntactic terms as a partial data structure. <p> Concepts are also organized in a taxonomic hierarchy. The root node of a KM-term (eg. A in Figure 2b), called its head, must be 2 also called a set of `relations' [13] or `behavior conditions' <ref> [10] </ref> 3 for `Knowledge Manager', the name of the software managing our KB. 4 either a concept or a conjunction of concepts | such as fpet&fishg | in the taxonomy.
Reference: [11] <editor> E. A. Feigenbaum. </editor> <booktitle> The art of artificial intelligence: Themes and case studies of knowledge engineering. In IJCAI-77, </booktitle> <pages> pages 1014-1029, </pages> <address> Cambridge, MA, </address> <year> 1977. </year>
Reference-contexts: 1 Introduction A major cause of the knowledge-engineering bottleneck <ref> [11] </ref> is that building one representation contributes little to building the next because each is idiosyncratic. We claim this problem is not inherent to knowledge engineering; rather, it is a limitation of our current technology.
Reference: [12] <author> K. Hammond. CHEF: </author> <title> A model of case-based planning. </title> <booktitle> In AAAI-86, </booktitle> <year> 1986. </year>
Reference-contexts: Under this proposal, scripts are assembled, as needed, from more general components called Memory Organization Packets (MOPS). Although several projects devised representations for MOPS, they largely used existing techniques for composing them. CHEF <ref> [12] </ref>, for example, reverted to standard methods such as inheritance, and 3 BORIS used templates that were manually overlaid on pre-written, detailed scripts [9]. Nev--ertheless, Schank's proposal for a memory capable of dynamically assembling representations is important inspiration for our work.
Reference: [13] <author> A. Y. Levy. </author> <note> Irrelevance reasoning in knowledge-based systems. Tech report STAN-CS-93-1482 (also KSL-93-58), </note> <institution> Dept CS, Stanford Univ., </institution> <address> CA, </address> <month> July </month> <year> 1993. </year> <note> (Chapter 6). </note>
Reference-contexts: Nev--ertheless, Schank's proposal for a memory capable of dynamically assembling representations is important inspiration for our work. Compositional Modeling A fourth approach to assembling representations comes from work on compositional modeling, the task of building a model of a physical system adequate for answering questions about the system <ref> [10, 13, 17] </ref>. In compositional modeling, a component (called a model fragment) contains a set of constraints 2 with well-defined semantics, rather than being represented in syntactic terms as a partial data structure. <p> As with conceptual graphs, KM-terms are graphs of concepts and relations (called sorts and features in psi-terms). Concepts are also organized in a taxonomic hierarchy. The root node of a KM-term (eg. A in Figure 2b), called its head, must be 2 also called a set of `relations' <ref> [13] </ref> or `behavior conditions' [10] 3 for `Knowledge Manager', the name of the software managing our KB. 4 either a concept or a conjunction of concepts | such as fpet&fishg | in the taxonomy.
Reference: [14] <author> M. Minsky. </author> <title> A framework for representing knowledge. </title> <editor> In R. Brachman and H.Levesque, editors, </editor> <booktitle> Readings in Knowledge Representation. </booktitle> <publisher> Kaufmann, </publisher> <address> California, </address> <year> 1985. </year> <title> (originally in The psychology of computer vision, </title> <editor> Ed: P.Winston, NewYork: </editor> <publisher> McGraw-Hill 1975). </publisher>
Reference-contexts: Frames and Inheritance Minsky proposed representing information in frame-systems <ref> [14] </ref>. The components (frames) are organized in a taxonomy, and the composition operator (multiple inheritance) collects the properties of an object, when they are needed, by ascending the hierarchy. However, inheritance does not provide an adequate mechanism for integrating this information.
Reference: [15] <author> B. W. Porter, J. Lester, K. Murray, K. Pittman, A. Souther, L. Acker, and T. Jones. </author> <title> AI research in the context of a multifunctional knowledge base: The botany knowledge base project. </title> <type> Tech Report AI-88-88, </type> <institution> Dept CS, Univ Texas at Austin, </institution> <month> Sept </month> <year> 1988. </year>
Reference-contexts: Our work is motivated by several observations from our eight year experience building a large-scale knowledge base (KB) in botany <ref> [15] </ref>, and more recently another KB about distributed computing systems: 1. Many domain-specific concepts share similar abstractions, reflected by their representations sharing similar substructures. For example, the general pattern describing production recurs in the representation of many concepts in the botany KB, such as photosynthesis, mitosis, growth, and germination.
Reference: [16] <author> C. Rich and R. C. Waters. </author> <title> The Programmer's Apprentice. </title> <address> ACM/Addison-Wesley, Reading, MA, </address> <year> 1990. </year>
Reference-contexts: Code repetition is common in libraries [4], and many researchers are studying additional methods for software reuse [3, 20]. Cliches Motivated by Minsky's work, Chapman proposed another approach to assembling representations from components [6], which was partially implemented in the Programmer's Apprentice <ref> [16] </ref>. Chapman described components, called cliches, as "patterns commonly found in representations" | such as Containment, Propagation, and Resistance | from which more specific representations can be assembled. In the Programmer's Apprentice, cliches were represented as parameterized templates, and composition involved instantiating a template's parameters (called roles) with other templates.
Reference: [17] <author> J. W. Rickel. </author> <title> Automated Modeling of Complex Systems to Answer Prediction Questions. </title> <type> PhD thesis, </type> <institution> Dept CS, Univ. Texas at Austin, </institution> <year> 1995. </year> <note> (Also available as Tech Rept AI-95-234). </note>
Reference-contexts: Nev--ertheless, Schank's proposal for a memory capable of dynamically assembling representations is important inspiration for our work. Compositional Modeling A fourth approach to assembling representations comes from work on compositional modeling, the task of building a model of a physical system adequate for answering questions about the system <ref> [10, 13, 17] </ref>. In compositional modeling, a component (called a model fragment) contains a set of constraints 2 with well-defined semantics, rather than being represented in syntactic terms as a partial data structure.
Reference: [18] <author> R. Schank. </author> <title> Dynamic Memory. </title> <publisher> Cambridge Univ. Press, </publisher> <year> 1982. </year>
Reference-contexts: Although the design and use of templates was complex, and the composition process had to be carefully guided by the user, the Programmer's Apprentice was a significant advance. MOPS A third approach to assembling representations, proposed by Schank, resulted from his dissatisfaction with the rigidity of scripts <ref> [18] </ref>. Under this proposal, scripts are assembled, as needed, from more general components called Memory Organization Packets (MOPS). Although several projects devised representations for MOPS, they largely used existing techniques for composing them. <p> We continue with the RestaurantVisit, as this concept is familiar, is rich in structure, and is known to pose problems for composition <ref> [9, 18] </ref>. Figure 4a shows a KM-term representing a simplified `restaurant script', as might typically be encoded in a knowledge base. There is a diner, a waiter, and a meal. During the visit, the diner selects his/her meal, requests it from the waiter, receives it, eats it and finally pays.
Reference: [19] <author> J. F. Sowa. </author> <title> Conceptual structures: Information processing in mind and machine. </title> <publisher> Addison Wesley, </publisher> <year> 1984. </year>
Reference-contexts: Conceptual Graphs A final approach to assembling representations, which forms the basis of our approach, is the use of conceptual graphs (CGs) <ref> [19] </ref> and psi-terms [2] to represent components. Both are graph-like data structures containing labeled nodes (concepts) and arcs (relations). Conceptual graph theory provides a variety of logical semantics for different types of graphs.
Reference: [20] <author> H. Ossher and W. Harrison. </author> <title> Combination of inheritance hierarchies. </title> <booktitle> In OOPSLA'92, </booktitle> <pages> pages 25-40. </pages> <publisher> ACM, </publisher> <month> Oct </month> <year> 1992. </year> <month> 15 </month>
Reference-contexts: Multiple inheritance would not help because what is needed is an integration, not a concatenation, of the algorithms for deque and guarding. Code repetition is common in libraries [4], and many researchers are studying additional methods for software reuse <ref> [3, 20] </ref>. Cliches Motivated by Minsky's work, Chapman proposed another approach to assembling representations from components [6], which was partially implemented in the Programmer's Apprentice [16].
References-found: 20

