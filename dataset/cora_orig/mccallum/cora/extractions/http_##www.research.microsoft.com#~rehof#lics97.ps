URL: http://www.research.microsoft.com/~rehof/lics97.ps
Refering-URL: http://www.research.microsoft.com/~rehof/publications.html
Root-URL: http://www.research.microsoft.com
Email: fhenglein, rehof g@diku.dk  
Title: The Complexity of Subtype Entailment for Simple Types deciding C j= ff fi for consistent,
Author: Fritz Henglein and Jakob Rehof 
Note: deciding C j= t t 0 is coNP-complete.  
Address: Universitetsparken 1, DK-2100 Copenhagen Denmark  
Affiliation: DIKU, Department of Computer Science University of Copenhagen  
Abstract: A subtyping t t 0 is entailed by a set of subtyping constraints C, written C j= t t 0 , if every valuation (mapping of type variables to ground types) that satisfies C also satisfies t t 0 . We study the complexity of subtype entailment for simple types over lattices of base types. We show that: The structural lower (coNP-hardness) and upper (membership in coNP) bounds as well as the optimal algorithm for atomic entailment are new. The coNP-hardness result indicates that entailment is strictly harder than satisfiability, which is known to be in PTIME for lattices of base types. The proof of coNP-completeness gives an improved algorithm for deciding entailment and puts a precise complexity-theoretic marker on the intuitive exponential explosion in the algorithm. Central to our results is a novel characterization of C j= ff fi for atomic, consistent C. This is the basis for correctness of the linear-time algorithm as well as a complete axiomatization of C j= ff fi for atomic C by extending the usual proof rules for subtype inference. It also incorporates the fundamental insight for understanding the structural complexity bounds in the general case. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aiken, E. Wimmers, and J. Palsberg. </author> <title> Optimal representations of polymorphic types with subtyping. </title> <type> Technical Report UCB/CSD-96-909, </type> <institution> University of California, Berkeley, </institution> <month> July </month> <year> 1996. </year>
Reference-contexts: The problem is now widely recognized and has generated a substantial amount of work that aims at simplifying typings generated by subtype inference algorithms (see, e.g., <ref> [9, 5, 12, 21, 6, 11, 18, 24, 20, 1, 7] </ref>.) Recently, a number of researchers have independently suggested that the problem should be attacked by introducing stronger systems, based on more powerful, model-theoretic notions of entailment (j=) rather than syntactic proof relations such as ` P . <p> Such works include <ref> [18, 24, 7, 1, 8] </ref>. The rationale is that a more powerful subsumption rule allows more typings to be considered equivalent in the system, and hence more succinct representations of principal typings can be found.
Reference: [2] <author> M. Benke. </author> <title> Efficient type reconstruction in the presence of inheritance. </title> <booktitle> In Mathematical Foundations of Computer Science (MFCS), </booktitle> <pages> pages 272-280. </pages> <publisher> Springer Verlag, LNCS 711, </publisher> <year> 1993. </year>
Reference-contexts: The present paper aims at filling this gap for simple types over lattices. Whereas the complexity of subtype entailment is largely unstudied, the complexity of subtype satisfiability is rather well-understood by now (see <ref> [22, 23, 2, 3] </ref>). <p> In particular, Tiuryn [22] has shown that the satisfiability problem for simple types 1 is PSPACE-hard in general but in PTIME if P is a lattice (see also <ref> [2, 3, 19] </ref> for various generalizations.) Since the entailment predicate C j= P t t 0 (does every valuation satisfying C also satisfy t t 0 ?) is at least as hard to decide as satisfiability in any non-trivial poset 2 , the problem is certainly PSPACE-hard in general, and a
Reference: [3] <author> M. Benke. </author> <title> Some complexity bounds for subtype inequalities. </title> <type> Technical Report TR 95-20 (220), </type> <institution> Warsaw University, Institute of Informatics, Warsaw University, Poland, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: The present paper aims at filling this gap for simple types over lattices. Whereas the complexity of subtype entailment is largely unstudied, the complexity of subtype satisfiability is rather well-understood by now (see <ref> [22, 23, 2, 3] </ref>). <p> In particular, Tiuryn [22] has shown that the satisfiability problem for simple types 1 is PSPACE-hard in general but in PTIME if P is a lattice (see also <ref> [2, 3, 19] </ref> for various generalizations.) Since the entailment predicate C j= P t t 0 (does every valuation satisfying C also satisfy t t 0 ?) is at least as hard to decide as satisfiability in any non-trivial poset 2 , the problem is certainly PSPACE-hard in general, and a
Reference: [4] <author> W. Charatonik and A. </author> <title> Podelski. The independence property of a class of set constraints. </title> <booktitle> In Conference on Principles and Practice of Constraint Programming, </booktitle> <pages> pages 76-90. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <pages> 1118. </pages>
Reference-contexts: However, even though several such algorithms have been suggested (see ref erences above), no study has so far addressed the problem of the inherent computational complexity of subtype entailment (see, however, work on set-constraint entailment, such as <ref> [8, 4] </ref>.) Indeed no nontrivial complexity results neither lower bounds nor interesting upper bounds have been given for subtype entailment. The present paper aims at filling this gap for simple types over lattices. <p> Hence, we restrict ourselves in this paper to consideration of predicates of the form C j= L ff fi where L is a lattice. In addition to the references given above, related work on entailment problems in various set constraint theories should be mentioned; recent papers include <ref> [8, 4] </ref>. 1.2. Main results The main results of this paper are as follows: 1.
Reference: [5] <author> P. Curtis. </author> <title> Constrained quantification in polymorphic type analysis. </title> <type> Technical Report CSL-90-1, </type> <note> Xerox Parc, </note> <month> February </month> <year> 1990. </year>
Reference-contexts: The problem is now widely recognized and has generated a substantial amount of work that aims at simplifying typings generated by subtype inference algorithms (see, e.g., <ref> [9, 5, 12, 21, 6, 11, 18, 24, 20, 1, 7] </ref>.) Recently, a number of researchers have independently suggested that the problem should be attacked by introducing stronger systems, based on more powerful, model-theoretic notions of entailment (j=) rather than syntactic proof relations such as ` P .
Reference: [6] <author> J. Eifrig, S. Smith, and V. Trifonov. </author> <title> Sound polymorphic type inference for objects. </title> <booktitle> In Proceedings OOPSLA '95, </booktitle> <year> 1995. </year>
Reference-contexts: The problem is now widely recognized and has generated a substantial amount of work that aims at simplifying typings generated by subtype inference algorithms (see, e.g., <ref> [9, 5, 12, 21, 6, 11, 18, 24, 20, 1, 7] </ref>.) Recently, a number of researchers have independently suggested that the problem should be attacked by introducing stronger systems, based on more powerful, model-theoretic notions of entailment (j=) rather than syntactic proof relations such as ` P .
Reference: [7] <author> M. Fahndrich and A. Aiken. </author> <title> Making set-constraint program analyses scale. In Workshop on Set Constraints, </title> <address> Cambridge MA, </address> <year> 1996. </year>
Reference-contexts: The problem is now widely recognized and has generated a substantial amount of work that aims at simplifying typings generated by subtype inference algorithms (see, e.g., <ref> [9, 5, 12, 21, 6, 11, 18, 24, 20, 1, 7] </ref>.) Recently, a number of researchers have independently suggested that the problem should be attacked by introducing stronger systems, based on more powerful, model-theoretic notions of entailment (j=) rather than syntactic proof relations such as ` P . <p> Such works include <ref> [18, 24, 7, 1, 8] </ref>. The rationale is that a more powerful subsumption rule allows more typings to be considered equivalent in the system, and hence more succinct representations of principal typings can be found.
Reference: [8] <author> C. Flanagan and M. Felleisen. </author> <title> Moduar and polymorphic set-based analsysis: Theory and practice. </title> <institution> Technical Report Rice COMP TR96-266, Rice University, </institution> <month> November </month> <year> 1996. </year>
Reference-contexts: Such works include <ref> [18, 24, 7, 1, 8] </ref>. The rationale is that a more powerful subsumption rule allows more typings to be considered equivalent in the system, and hence more succinct representations of principal typings can be found. <p> However, even though several such algorithms have been suggested (see ref erences above), no study has so far addressed the problem of the inherent computational complexity of subtype entailment (see, however, work on set-constraint entailment, such as <ref> [8, 4] </ref>.) Indeed no nontrivial complexity results neither lower bounds nor interesting upper bounds have been given for subtype entailment. The present paper aims at filling this gap for simple types over lattices. <p> Hence, we restrict ourselves in this paper to consideration of predicates of the form C j= L ff fi where L is a lattice. In addition to the references given above, related work on entailment problems in various set constraint theories should be mentioned; recent papers include <ref> [8, 4] </ref>. 1.2. Main results The main results of this paper are as follows: 1.
Reference: [9] <author> Y. Fuh and P. Mishra. </author> <title> Polymorphic subtype inference: Closing the theory-practice gap. </title> <booktitle> In Proc. Int'l J't Conf. on Theory and Practice of Software Development, </booktitle> <pages> pages 167-183, </pages> <address> Barcelona, Spain, March 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The presence of subtype assumptions C in typings of lambda terms is necessitated by the desire to have principal typings, see <ref> [9, 16] </ref>. <p> The problem is now widely recognized and has generated a substantial amount of work that aims at simplifying typings generated by subtype inference algorithms (see, e.g., <ref> [9, 5, 12, 21, 6, 11, 18, 24, 20, 1, 7] </ref>.) Recently, a number of researchers have independently suggested that the problem should be attacked by introducing stronger systems, based on more powerful, model-theoretic notions of entailment (j=) rather than syntactic proof relations such as ` P .
Reference: [10] <author> M. Garey and D. Johnson. </author> <title> Computers and Intractability A Guide to the Theory of NP-Completeness. </title> <publisher> Freeman, </publisher> <year> 1979. </year>
Reference-contexts: Fix two distinct variables ff and fi. Let NENT be the problem: * Given C, decide whether C 6j= L ff fi We reduce SAT (propositional satisfiability, <ref> [10] </ref>) to NENT. This shows that NENT is NP-hard, which in turn shows that the problem of deciding C j= L ff fi is coNP-hard. The basic idea is that an address p defines a truth assignment of an instance of SAT.
Reference: [11] <author> M. Hoang and J. Mitchell. </author> <title> Lower bounds on type inference with subtypes. </title> <booktitle> In Proc. 22nd Annual ACM Symposium on Principles of Programming Languages (POPL), </booktitle> <pages> pages 176-185. </pages> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: The problem is now widely recognized and has generated a substantial amount of work that aims at simplifying typings generated by subtype inference algorithms (see, e.g., <ref> [9, 5, 12, 21, 6, 11, 18, 24, 20, 1, 7] </ref>.) Recently, a number of researchers have independently suggested that the problem should be attacked by introducing stronger systems, based on more powerful, model-theoretic notions of entailment (j=) rather than syntactic proof relations such as ` P .
Reference: [12] <author> S. Kaes. </author> <title> Type inference in the presence of overloading, sub-typing and recursive types. </title> <booktitle> In Proc. ACM Conf. on LISP and Functional Programming (LFP), </booktitle> <address> San Francisco, </address> <publisher> Cali-fornia, </publisher> <pages> pages 193-204. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1992. </year> <title> also in LISP Pointers, </title> <journal> Vol. V, </journal> <volume> Number 1, </volume> <month> January-March </month> <year> 1992. </year>
Reference-contexts: The problem is now widely recognized and has generated a substantial amount of work that aims at simplifying typings generated by subtype inference algorithms (see, e.g., <ref> [9, 5, 12, 21, 6, 11, 18, 24, 20, 1, 7] </ref>.) Recently, a number of researchers have independently suggested that the problem should be attacked by introducing stronger systems, based on more powerful, model-theoretic notions of entailment (j=) rather than syntactic proof relations such as ` P .
Reference: [13] <author> D. Kozen, J. Palsberg, and M. Schwartzbach. </author> <title> Efficient re-cursive subtyping. </title> <booktitle> In Proc. 20th Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <pages> pages 419-428. </pages> <publisher> ACM, ACM Press, </publisher> <month> January </month> <year> 1993. </year>
Reference-contexts: Here, the provability relation is still decidable in PTIME (we can reduce the problem to closure of a constraint graph, involving essentially transitive closure), whereas we show below that the entailment problem becomes coNP-complete in the presence of compound types. As in <ref> [13, 17, 18] </ref> we consider a type t as a function from strings (called addresses) in ff; s; d; rg fl (fl denotes the empty string) to labels in L = V [ L [ f!; flg.
Reference: [14] <author> P. Lincoln and J. Mitchell. </author> <title> Algorithmic aspects of type inference with subtypes. </title> <booktitle> In Proc. 19th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programmin Languages (POPL), </booktitle> <address> Albuquerque, New Mexico, </address> <pages> pages 293-304. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1992. </year>
Reference-contexts: A general constraint set is satisfiable if and only if it is structural and consistent. PROOF See <ref> [14, 22] </ref> for the first part; the second part is proven in [22]. 2 3. Atomic entailment In this section, we consider the predicate C j= L ff fi with C atomic, i.e., every inequality in C has the form A A 0 .
Reference: [15] <author> J. Mitchell. </author> <title> Coercion and type inference (summary). </title> <booktitle> In Proc. 11th ACM Symp. on Principles of Programming Languages (POPL), </booktitle> <pages> pages 175-185, </pages> <year> 1984. </year>
Reference-contexts: Its basic principles are typically studied in extensions of the simply typed lambda calculus. Following this line of research, the present paper studies a problem in the standard system of structural subtyping defined by Mitchell <ref> [15, 16] </ref> and subsequently studied extensively by many others (see references below.) In structural subtyping a poset P of base types is lifted to an order (subtype) relation on structured types.
Reference: [16] <author> J. Mitchell. </author> <title> Type inference with simple subtypes. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(3) </volume> <pages> 245-285, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Its basic principles are typically studied in extensions of the simply typed lambda calculus. Following this line of research, the present paper studies a problem in the standard system of structural subtyping defined by Mitchell <ref> [15, 16] </ref> and subsequently studied extensively by many others (see references below.) In structural subtyping a poset P of base types is lifted to an order (subtype) relation on structured types. <p> The presence of subtype assumptions C in typings of lambda terms is necessitated by the desire to have principal typings, see <ref> [9, 16] </ref>. <p> If C ` L t t 0 , then S (C) ` L S (t ) S (t 0 ). 2. If C j= L t t 0 , then S (C) j= L S (t ) S (t 0 ) PROOF As for 1, see <ref> [16] </ref>. <p> A matching substitution for C is a substitution S such that S (C) is matching. If there exists a matching substitution for C, then we say that C is structural; in that case there is a most general matching substitution for C (see <ref> [16] </ref> for details), denoted M C , with the property that, whenever R is a matching substitution for C, then there exists a substitution V such that R = V ffi M C ; here the equality is restricted to hold on variables that occur in C. 2 LEMMA 2.5 (Match <p> Assume that C is structural. Then C j= L t t 0 if and only if M C (C) j= L M C (t ) M C (t 0 ). PROOF As for 1, see <ref> [16] </ref>. As for 2, the implication ()) follows from the Substitution Lemma. To see the impli cation ((), assume M C (C) j= L M C (t ) M C (t 0 ) and suppose that j= L C. <p> 2 if and only if C j= L ft 1 t 0 2 g, and C j= L t 1 ! t 2 t 0 2 if and only if C j= L ft 0 1 t 1 ; t 2 t 0 PROOF As for the first part, see <ref> [16] </ref>. As for the second part, the implications from right to left are obvious. <p> Moreover, in case C is structural, we have M C (ff) matching E C (ff), where E C is the most general unifier for C, for any ff 2 Var (C) (see, e.g., <ref> [16, 22] </ref>); it follows that, for any variable ff in Var (C), any maximal address p for ff in C satisfies that jpj is O (n), where jpj is the number of symbols in p.
Reference: [17] <author> J. Palsberg and P. O'Keefe. </author> <title> A type system equivalent to flow analysis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(4) </volume> <pages> 576-599, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: Here, the provability relation is still decidable in PTIME (we can reduce the problem to closure of a constraint graph, involving essentially transitive closure), whereas we show below that the entailment problem becomes coNP-complete in the presence of compound types. As in <ref> [13, 17, 18] </ref> we consider a type t as a function from strings (called addresses) in ff; s; d; rg fl (fl denotes the empty string) to labels in L = V [ L [ f!; flg.
Reference: [18] <author> F. Pottier. </author> <title> Simplifying subtyping constraints. </title> <booktitle> In Proceedings ICFP '96, International Conference on Functional Programming, </booktitle> <pages> pages 122-133. </pages> <publisher> ACM Press, </publisher> <month> May </month> <year> 1996. </year>
Reference-contexts: The problem is now widely recognized and has generated a substantial amount of work that aims at simplifying typings generated by subtype inference algorithms (see, e.g., <ref> [9, 5, 12, 21, 6, 11, 18, 24, 20, 1, 7] </ref>.) Recently, a number of researchers have independently suggested that the problem should be attacked by introducing stronger systems, based on more powerful, model-theoretic notions of entailment (j=) rather than syntactic proof relations such as ` P . <p> Such works include <ref> [18, 24, 7, 1, 8] </ref>. The rationale is that a more powerful subsumption rule allows more typings to be considered equivalent in the system, and hence more succinct representations of principal typings can be found. <p> Here, the provability relation is still decidable in PTIME (we can reduce the problem to closure of a constraint graph, involving essentially transitive closure), whereas we show below that the entailment problem becomes coNP-complete in the presence of compound types. As in <ref> [13, 17, 18] </ref> we consider a type t as a function from strings (called addresses) in ff; s; d; rg fl (fl denotes the empty string) to labels in L = V [ L [ f!; flg.
Reference: [19] <author> V. Pratt and J. Tiuryn. </author> <title> Satisfiability of inequalities in a poset. </title> <note> Studia Logica (to appear). </note>
Reference-contexts: In particular, Tiuryn [22] has shown that the satisfiability problem for simple types 1 is PSPACE-hard in general but in PTIME if P is a lattice (see also <ref> [2, 3, 19] </ref> for various generalizations.) Since the entailment predicate C j= P t t 0 (does every valuation satisfying C also satisfy t t 0 ?) is at least as hard to decide as satisfiability in any non-trivial poset 2 , the problem is certainly PSPACE-hard in general, and a
Reference: [20] <author> J. Rehof. </author> <title> Minimal typings in atomic subtyping. </title> <booktitle> To appear in proceedings POPL '97, 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <address> Paris, France, </address> <month> January </month> <year> 1997. </year>
Reference-contexts: The problem is now widely recognized and has generated a substantial amount of work that aims at simplifying typings generated by subtype inference algorithms (see, e.g., <ref> [9, 5, 12, 21, 6, 11, 18, 24, 20, 1, 7] </ref>.) Recently, a number of researchers have independently suggested that the problem should be attacked by introducing stronger systems, based on more powerful, model-theoretic notions of entailment (j=) rather than syntactic proof relations such as ` P .
Reference: [21] <author> G. S. Smith. </author> <title> Principal type schemes for functional programs with overloading and subtyping. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 23 </volume> <pages> 197-226, </pages> <year> 1994. </year>
Reference-contexts: The problem is now widely recognized and has generated a substantial amount of work that aims at simplifying typings generated by subtype inference algorithms (see, e.g., <ref> [9, 5, 12, 21, 6, 11, 18, 24, 20, 1, 7] </ref>.) Recently, a number of researchers have independently suggested that the problem should be attacked by introducing stronger systems, based on more powerful, model-theoretic notions of entailment (j=) rather than syntactic proof relations such as ` P .
Reference: [22] <author> J. Tiuryn. </author> <title> Subtype inequalities. </title> <booktitle> In Proc. 7th Annual IEEE Symp. on Logic in Computer Science (LICS), </booktitle> <address> Santa Cruz, California, </address> <pages> pages 308-315. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: The present paper aims at filling this gap for simple types over lattices. Whereas the complexity of subtype entailment is largely unstudied, the complexity of subtype satisfiability is rather well-understood by now (see <ref> [22, 23, 2, 3] </ref>). <p> The present paper aims at filling this gap for simple types over lattices. Whereas the complexity of subtype entailment is largely unstudied, the complexity of subtype satisfiability is rather well-understood by now (see [22, 23, 2, 3]). In particular, Tiuryn <ref> [22] </ref> has shown that the satisfiability problem for simple types 1 is PSPACE-hard in general but in PTIME if P is a lattice (see also [2, 3, 19] for various generalizations.) Since the entailment predicate C j= P t t 0 (does every valuation satisfying C also satisfy t t 0 <p> A general constraint set is satisfiable if and only if it is structural and consistent. PROOF See <ref> [14, 22] </ref> for the first part; the second part is proven in [22]. 2 3. Atomic entailment In this section, we consider the predicate C j= L ff fi with C atomic, i.e., every inequality in C has the form A A 0 . <p> A general constraint set is satisfiable if and only if it is structural and consistent. PROOF See [14, 22] for the first part; the second part is proven in <ref> [22] </ref>. 2 3. Atomic entailment In this section, we consider the predicate C j= L ff fi with C atomic, i.e., every inequality in C has the form A A 0 . We aim at a complete axiomatization of entailment with atomic constraint sets. <p> The final step is to show that ( b C ) is consistent (11) This can be proven from (9) by an argument similar to the one employed by Tiuryn in <ref> [22] </ref> to prove that any consistent constraint set (over a lattice of base types) is satisfiable. Since the main ideas can be found in [22] we leave out details here, but we note that the main point in the argument (in our case) is to prove that, since C is consistent <p> show that ( b C ) is consistent (11) This can be proven from (9) by an argument similar to the one employed by Tiuryn in <ref> [22] </ref> to prove that any consistent constraint set (over a lattice of base types) is satisfiable. Since the main ideas can be found in [22] we leave out details here, but we note that the main point in the argument (in our case) is to prove that, since C is consistent and ff and fi are atomic in C, we have b b 0 2 cl (( b C)) if and only if b b <p> By (11) and the equivalence of consistency and satis-fiability shown in <ref> [22] </ref>, can be extended to a satisfying valuation ^ for b C; by (8) we have ^(ff) 6 L ^(fi) which shows b C 6j= L ff fi, thereby proving (6). 2 For any address p, we define special type expressions called p-templates; the idea of a p-template is that it <p> we clearly have ff p and fi p atomic in C p , and therefore Lemma 4.4 shows that we have C p j= L ff p p fi p iff (C p ) a j= at Composing (12) and (13) proves the lemma. 2 As is well known ([16], <ref> [22] </ref>), testing whether a constraint set C is structural is reducible to the problem of unifying the set (regarding inequalities in C as equalities under unification.) It follows that we can test in time O (n) whether C is structural, where n is the number of symbols in C. <p> Moreover, in case C is structural, we have M C (ff) matching E C (ff), where E C is the most general unifier for C, for any ff 2 Var (C) (see, e.g., <ref> [16, 22] </ref>); it follows that, for any variable ff in Var (C), any maximal address p for ff in C satisfies that jpj is O (n), where jpj is the number of symbols in p. <p> We can now show: THEOREM 4.6 Let p be a maximal address for ff and fi in C. Then the predicate C j= p L ff fi is decidable in time O (n 3 ) where n is the number of symbols in C. PROOF Recall from <ref> [22] </ref> that consistency of C is equivalent to satisfiability of C, given that C is structural. To decide C j= L ff fi, we first decide in linear time whether C is structural.
Reference: [23] <author> J. Tiuryn and M. Wand. </author> <title> Type reconstruction with recursive types and atomic subtyping. </title> <editor> In M.-C. Gaudel and J.-P. Jouan-naud, editors, </editor> <booktitle> Proc. Theory and Practice of Software Development (TAPSOFT), Orsay, France, volume 668 of Lecture Notes in Computer Science, </booktitle> <pages> pages 686-701. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1993. </year>
Reference-contexts: The present paper aims at filling this gap for simple types over lattices. Whereas the complexity of subtype entailment is largely unstudied, the complexity of subtype satisfiability is rather well-understood by now (see <ref> [22, 23, 2, 3] </ref>).
Reference: [24] <author> V. Trifonov and S. Smith. </author> <title> Subtyping constrained types. </title> <booktitle> In Proceedings SAS '96, Static Analysis Symposium, </booktitle> <address> Aachen, Germany, </address> <pages> pages 349-365. </pages> <publisher> Springer, </publisher> <year> 1996. </year> <note> Lecture Notes in Computer Science, vol.1145. </note>
Reference-contexts: The problem is now widely recognized and has generated a substantial amount of work that aims at simplifying typings generated by subtype inference algorithms (see, e.g., <ref> [9, 5, 12, 21, 6, 11, 18, 24, 20, 1, 7] </ref>.) Recently, a number of researchers have independently suggested that the problem should be attacked by introducing stronger systems, based on more powerful, model-theoretic notions of entailment (j=) rather than syntactic proof relations such as ` P . <p> Such works include <ref> [18, 24, 7, 1, 8] </ref>. The rationale is that a more powerful subsumption rule allows more typings to be considered equivalent in the system, and hence more succinct representations of principal typings can be found.
References-found: 24

