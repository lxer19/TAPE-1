URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/PCRSOSP.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/
Root-URL: http://www.cs.berkeley.edu
Title: The Portable Common Runtime Approach to Interoperability  
Author: Mark Weiser, Alan Demers and Carl Hauser 
Date: December 1989.  
Note: *email: weiser.pa@Xerox.com This appeared in the Conference Record of the 13th Annual ACM Symposium on Operating Systems Principles,  Copyright 1989 ACM.  
Address: 3333 Coyote Hill Road Palo Alto, California 94304*  
Affiliation: Xerox PARC  
Abstract: Operating system abstractions do not always reach high enough for direct use by a language or applications designer. The gap is filled by language-specific runtime environments, which become more complex for richer languages (CommonLisp needs more than C++, which needs more than C). But language-specific environments inhibit integrated multi-lingual programming, and also make porting hard (for instance, because of operating system dependencies). To help solve these problems, we have built the Portable Common Runtime (PCR), a language-independent and operating-system-independent base for modern languages. PCR offers four interrelated facilities: storage management (including universal garbage collection), symbol binding (including static and dynamic linking and loading), threads (lightweight processes), and low-level I/O (including network sockets). PCR is "common" because these facilities simultaneously support programs in several languages. PCR supports C, Cedar, Scheme, and CommonLisp intercalling and runs pre-existing C and CommonLisp (Kyoto) binaries. PCR is "portable" because it uses only a small set of operating system features. The PCR source code is available for use by other researchers and developers. Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission. 
Abstract-found: 1
Intro-found: 1
Reference: [Accetta et al. 1986] <author> Accetta, J. J., Baron, R. V., Bolosky, W., Golub, D. B., Rashid, R. </author> <title> F. </title>
Reference-contexts: Implementing above the operating system means, in the first place, avoiding changes to operating system kernels, and the second place, not duplicating operating system functions. Therefore, for instance, a PCR implementation on Mach <ref> [Accetta et al. 1986] </ref> maps PCR threads into Mach threads. <p> The following overview highlights noteworthy features of our implementation. Threads implementations fall into two categories: inside or outside the OS kernel. Implementations inside the kernel, such as Mach <ref> [Accetta et al. 1986] </ref> or V [Cheriton and Zwaenepoel 1983], have explicit knowledge of multiple threads per address space, and the OS scheduler treats such threads separately. Implementations outside the kernel generally use coroutines in a single heavyweight process.


References-found: 1

