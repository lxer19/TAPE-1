URL: http://www.cs.wustl.edu/~schmidt/Acceptor.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/new.html
Root-URL: http://www.cs.wustl.edu
Email: schmidt@cs.wustl.edu  
Phone: (314) 935-7538  
Title: Acceptor A Design Pattern for Passively Initializing Network Services  
Author: Douglas C. Schmidt 
Address: St. Louis, MO 63130, USA  
Affiliation: Department of Computer Science Washington University  
Abstract: This paper appeared in the November/December issue of the C++ Report magazine. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: By decoupling service initialization from service processing, this pattern enables the creation of reusable, extensible, and efficient network services. When used in conjunction with related patterns like the Reactor <ref> [1] </ref> and the Connector [2], this pattern enables the creation of highly extensible and efficient communication software frameworks [3]. A companion article [2] examines the Connector pattern, which is the dual of the Acceptor pattern. <p> The two participants at this layer, the Reactor and Event Handler, are reused from the Reactor pattern <ref> [1] </ref>. This pattern encapsulates OS event demultiplexing system calls (such as select, poll [7], and WaitForMultipleObjects [11]) with an extensible and portable callback-driven object-oriented interface. The Reactor pattern enables efficient demultiplexing of multiple types of events from multiple sources within a single thread of control. <p> The behavior of this pure virtual method must be defined by a subclass, which performs service-specific initializations. A subclass of Svc Handler also determines the service's concurrency strategy. For example, a Svc Handler may employ the Reactor <ref> [1] </ref> pattern to process data from peers in a single-thread of control. Conversely, a Svc Handler might use the Active Object pattern [13] to process incoming data in a different thread of control than the one the Acceptor object used to connect it.
Reference: [2] <author> D. C. Schmidt, </author> <title> Connector: a Design Pattern for Actively Initializing Network Services, </title> <journal> C++ Report, </journal> <volume> vol. 8, </volume> <month> January </month> <year> 1996. </year>
Reference-contexts: By decoupling service initialization from service processing, this pattern enables the creation of reusable, extensible, and efficient network services. When used in conjunction with related patterns like the Reactor [1] and the Connector <ref> [2] </ref>, this pattern enables the creation of highly extensible and efficient communication software frameworks [3]. A companion article [2] examines the Connector pattern, which is the dual of the Acceptor pattern. The Connector pattern decouples the active establishment of a connection from the service performed once the connection is established. <p> When used in conjunction with related patterns like the Reactor [1] and the Connector <ref> [2] </ref>, this pattern enables the creation of highly extensible and efficient communication software frameworks [3]. A companion article [2] examines the Connector pattern, which is the dual of the Acceptor pattern. The Connector pattern decouples the active establishment of a connection from the service performed once the connection is established. <p> Section 4 describes the Acceptor pattern in detail. The Connector pattern is described in <ref> [2] </ref>. 4 The Acceptor Pattern 4.1 Intent Decouples the passive initialization of a service from the tasks performed once a service is initialized. 4.2 Also Known As Listener 4.3 Applicability Use the Acceptor pattern when connection-oriented applications have the following characteristics: * The behavior of a network service does not depend <p> This separation of concerns increases the reusability, portability, and extensibility of this implementation of the Acceptor pattern. There is a striking similarity between the structure of the Acceptor class diagram and the Connector class diagram shown in <ref> [2] </ref>. In particular, the Reactive layer is identical in both and the roles of the Svc Handler and Concrete Svc Handler are also very similar. Moreover, the Acceptor and Concrete Acceptor play roles equivalent to the Connector and Concrete Connector classes. <p> The Peers play the passive role in establishing connections with the Gateway (an implementation of the Gateway using the Connector pattern appears in <ref> [2] </ref>). Figure 6 illustrates how participants in the Acceptor pattern are structured in a Peer. 4.8.1 Svc Handlers for Sending and Receiving Routing Messages The classes shown below, Status Handler, Bulk Data Handler, and Command Handler, process routing messages sent and received from a Gateway. <p> Thus, the service is decoupled from the network programming interface and the transport protocol used to establish the connection. 5 Concluding Remarks This article motivates the Acceptor and Connector patterns and gives a detailed example illustrating how to use the Acceptor pattern. A subsequent issue of the C++ Report <ref> [2] </ref> will illustrate how to implement the Connector pattern. UNIX versions of the Acceptor, Connector, and Reactor patterns described in this article are freely available via the World Wide Web at URL http://www.cs.wustl.edu/schmidt/.
Reference: [3] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: By decoupling service initialization from service processing, this pattern enables the creation of reusable, extensible, and efficient network services. When used in conjunction with related patterns like the Reactor [1] and the Connector [2], this pattern enables the creation of highly extensible and efficient communication software frameworks <ref> [3] </ref>. A companion article [2] examines the Connector pattern, which is the dual of the Acceptor pattern. The Connector pattern decouples the active establishment of a connection from the service performed once the connection is established. <p> The implementation described below is based on the ACE OO network programming toolkit <ref> [3] </ref>. <p> While the various *Handlers exchange data with the Gateway, the *Acceptors continue to listen for new connections. 4 4.9 Known Uses The Reactor, Svc Handler, and Acceptor classes described in this article are all provided as reusable components in the ACE toolkit <ref> [3] </ref>. The Acceptor pattern has been used in the following frameworks, toolkits, and systems: * UNIX network superservers such as inetd [7], listen [8], and the Service Configurator daemon from the ASX framework [3]. <p> and Acceptor classes described in this article are all provided as reusable components in the ACE toolkit <ref> [3] </ref>. The Acceptor pattern has been used in the following frameworks, toolkits, and systems: * UNIX network superservers such as inetd [7], listen [8], and the Service Configurator daemon from the ASX framework [3]. These super-servers utilize a master Acceptor process that listens for connections on a set of communication ports. Each port is associated with a communication-related service (such as the standard Internet services ftp, telnet, daytime, and echo). <p> UNIX versions of the Acceptor, Connector, and Reactor patterns described in this article are freely available via the World Wide Web at URL http://www.cs.wustl.edu/schmidt/. This distribution contains complete source code, documentation, and example test drivers for the C++ components developed as part of the ACE object-oriented network programming toolkit <ref> [3] </ref> developed at the University of California, Irvine and Washington University. The ACE toolkit is currently being used on communication software at many companies. Thanks to Venkata-Subbarao Kandru for comments on this paper.
Reference: [4] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: roles can be decoupled from the communication roles performed once connections are established; Section 3 motivates the Acceptor pattern by applying it to a connection-oriented, multi-service, application-level Gateway; Section 4 describes the Acceptor pattern in detail and illustrates how to implement it flexibly and efficiently by combining existing design patterns <ref> [4] </ref> and C++ language features, and Section 5 presents concluding remarks. 2 Background SERVER CLIENT socket () bind () connect () send ()/recv () socket () bind () listen () accept () send ()/recv () 1: PASSIVE ROLE 2: ACTIVE ROLE NETWORK 3: SERVICE PROCESSING Connection-oriented protocols (such as TCP, SPX, <p> These Peers are located throughout local area networks (LANs) and wide-area networks (WANs) and are used to monitor and control a satellite constellation. The Gateway is a Mediator <ref> [4] </ref> that coordinates interactions between its connected Peers. From the Gateway's perspective, these Peer services differ solely by their message framing formats and payload types. The Gateway uses a connection-oriented interprocess communication (IPC) mechanism (such as TCP) to transmit data between its connected Peers. <p> An even more dynamic type of decoupling could be achieved via inheritance and polymorphism by using the Factory Method and Strategy patterns described in <ref> [4] </ref>. Parameterized types improve run-time efficiency at the expense of additional space and time overhead during program compiling and linking. The implementation of the Acceptor's methods is presented below. To save space, most of the error handling has been omitted. Network applications use the open method to initialize an Acceptor. <p> As shown below, handle event is a Template Method <ref> [4] </ref> that implements the strategies for creating a new SVC HANDLER, accepting a connection into it, and activating the service: template &lt;class SH, class PA&gt; int Acceptor&lt;SH, PA&gt;::handle_event (void) - // Create a new SVC_HANDLER. <p> However, subclasses of Acceptor can override this strategy to create SVC HANDLERs using other strategies (such as creating an individual Singleton <ref> [4] </ref> or dynamically linking the SVC HANDLER from a shared library). <p> Acceptor&lt;Command_Handler, SOCK_Acceptor&gt; c_acc; 4.8.3 The main () Function The main program initializes the concrete Acceptor facto ries by calling their open methods with the well-known ports for each service. As shown in Section 4.7.2, the Acceptor::open method registers itself with a Single ton <ref> [4] </ref> instance of the Reactor. The program then enters an event loop that uses the Reactor to detect connection requests from the Gateway. <p> Once connections are established, applications then send and receive multi-megabyte medical images to and from these image stores. 4.10 Related Patterns The Acceptor pattern may be viewed as a variation of the Template Method and Factory Method patterns <ref> [4] </ref>. In the Template Method pattern an algorithm is written such that some steps are supplied by a derived class.
Reference: [5] <author> S. J. Leffler, M. McKusick, M. Karels, and J. Quarterman, </author> <title> The Design and Implementation of the 4.3BSD UNIX Operating System. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: waits passively for the other endpoint (s) to connect with it; * Active role which actively initiates a connection to one or more endpoints that are playing the passive role. interact when a connection is established between an active client and a passive server using the socket network programming interface <ref> [5] </ref> and the TCP transport protocol [6].
Reference: [6] <author> W. R. Stevens, </author> <title> TCP/IP Illustrated, </title> <booktitle> Volume 1. </booktitle> <address> Reading, Mas-sachusetts: </address> <publisher> Addison Wesley, </publisher> <year> 1993. </year>
Reference-contexts: (s) to connect with it; * Active role which actively initiates a connection to one or more endpoints that are playing the passive role. interact when a connection is established between an active client and a passive server using the socket network programming interface [5] and the TCP transport protocol <ref> [6] </ref>.
Reference: [7] <author> W. R. Stevens, </author> <title> UNIX Network Programming. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: This is illustrated in Figure 1 by the peer-to-peer send/recv communication between client and server once a connection is established. * The network programming interfaces and underlying protocols used to establish the connection different network programming interfaces (such as sockets <ref> [7] </ref> or TLI [8]) provide different library calls to establish connections using various underlying transport protocols (such as TCP, TP4, or SPX). <p> The two participants at this layer, the Reactor and Event Handler, are reused from the Reactor pattern [1]. This pattern encapsulates OS event demultiplexing system calls (such as select, poll <ref> [7] </ref>, and WaitForMultipleObjects [11]) with an extensible and portable callback-driven object-oriented interface. The Reactor pattern enables efficient demultiplexing of multiple types of events from multiple sources within a single thread of control. <p> For example, the SOCK Acceptor, SOCK Connector, and SOCK Stream classes used in Section 4.8 are part of the SOCK SAP C++ wrapper library for sockets [14]. Likewise, the corresponding TLI * classes are part of the TLI SAP C++ wrapper library for the Transport Layer Interface <ref> [7] </ref>. 7 SOCK SAP and TLI SAP encapsulate the stream-oriented semantics of connection-oriented protocols like TCP and SPX with a efficient, portable, and type-safe C++ wrappers. <p> The Acceptor pattern has been used in the following frameworks, toolkits, and systems: * UNIX network superservers such as inetd <ref> [7] </ref>, listen [8], and the Service Configurator daemon from the ASX framework [3]. These super-servers utilize a master Acceptor process that listens for connections on a set of communication ports. Each port is associated with a communication-related service (such as the standard Internet services ftp, telnet, daytime, and echo).
Reference: [8] <author> S. Rago, </author> <title> UNIX System V Network Programming. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: This is illustrated in Figure 1 by the peer-to-peer send/recv communication between client and server once a connection is established. * The network programming interfaces and underlying protocols used to establish the connection different network programming interfaces (such as sockets [7] or TLI <ref> [8] </ref>) provide different library calls to establish connections using various underlying transport protocols (such as TCP, TP4, or SPX). <p> The Acceptor pattern has been used in the following frameworks, toolkits, and systems: * UNIX network superservers such as inetd [7], listen <ref> [8] </ref>, and the Service Configurator daemon from the ASX framework [3]. These super-servers utilize a master Acceptor process that listens for connections on a set of communication ports. Each port is associated with a communication-related service (such as the standard Internet services ftp, telnet, daytime, and echo).
Reference: [9] <author> D. C. Schmidt, T. H. Harrison, and E. Al-Shaer, </author> <title> Object-Oriented Components for High-speed Network Programming, </title> <booktitle> in Proceedings of the 1 st Conference on Object-Oriented Technologies, </booktitle> <address> (Monterey, CA), </address> <publisher> USENIX, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: software that implements the service makes it hard to reuse existing services or to extend the Gateway by adding new routing services and enhancing existing services. * Error-prone network programming interfaces low-level network programming (such as sockets or TLI) do not provide adequate type-checking since they utilize low-level I/O handles <ref> [9] </ref>. <p> This eliminates a class of subtle and pernicious errors that can arise when programming with weakly typed network programming in terfaces such as sockets or TLI <ref> [9] </ref>. The Acceptor pattern has the following drawbacks: * Additional instructions compared with overhead of programming to the underlying network programming interfaces directly.
Reference: [10] <author> G. Booch, </author> <title> Object Oriented Analysis and Design with Applications (2 nd Edition). </title> <address> Redwood City, California: Ben-jamin/Cummings, </address> <year> 1993. </year> <month> 10 </month>
Reference-contexts: the steps required to passively initialize a service; * Connections may arrive concurrently from different peers, but blocking or continuous polling for incoming connections on any individual peer is inefficient. 4.4 Structure and Participants The structure of the participants in the Acceptor pattern is illustrated by the Booch class diagram <ref> [10] </ref> in Figure 3 and described below: 2 * Reactor 2 In this diagram dashed clouds indicate classes; dashed boxes in the clouds indicate template parameters; and a solid undirected edge with a hollow circle at one end indicates a uses relation between two classes. 3 A C T I V <p> The Acceptor pattern is a connection factory that uses a template method (handle event) to create handlers for communication channels. The handle event method implements the algorithm that passively listens for connection 4 This diagram uses additional Booch notation <ref> [10] </ref>, where solid clouds indicate objects and undirected edges indicate some type of link (such as a pointer or reference) exists between two objects. requests, then creates, accepts, and activates a handler when the connection is established. The handler performs a service using data exchanged on the connection.
Reference: [11] <author> H. Custer, </author> <title> Inside Windows NT. </title> <address> Redmond, Washington: </address> <publisher> Mi--crosoft Press, </publisher> <year> 1993. </year>
Reference-contexts: The two participants at this layer, the Reactor and Event Handler, are reused from the Reactor pattern [1]. This pattern encapsulates OS event demultiplexing system calls (such as select, poll [7], and WaitForMultipleObjects <ref> [11] </ref>) with an extensible and portable callback-driven object-oriented interface. The Reactor pattern enables efficient demultiplexing of multiple types of events from multiple sources within a single thread of control.
Reference: [12] <author> D. C. Schmidt, </author> <title> The Object-Oriented Design and Implementation of the Reactor: A C++ Wrapper for UNIX I/O Multiplexing (Part 2 of 2), </title> <journal> C++ Report, </journal> <volume> vol. 5, </volume> <month> September </month> <year> 1993. </year>
Reference-contexts: The Reactor pattern enables efficient demultiplexing of multiple types of events from multiple sources within a single thread of control. An implementation of the Reactor pattern is shown in <ref> [12] </ref> and the two main roles in the Reactive layer are describe below. * Reactor: This class defines an interface for registering, removing, and dispatching Event Handler objects (such as the Acceptor and Svc Handler).
Reference: [13] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Object Behavioral Pattern for Concurrent Programming, </title> <booktitle> in Proceedings of the 2 nd Annual Conference on the Pattern Languages of Programs, </booktitle> <address> (Monticello, </address> <publisher> Illinois), </publisher> <pages> pp. 1-7, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: A subclass of Svc Handler also determines the service's concurrency strategy. For example, a Svc Handler may employ the Reactor [1] pattern to process data from peers in a single-thread of control. Conversely, a Svc Handler might use the Active Object pattern <ref> [13] </ref> to process incoming data in a different thread of control than the one the Acceptor object used to connect it. <p> This allows the Reactor to dispatch the SVC HANDLER's handle event method when events occur on its PEER STREAM endpoint of communication. Subclasses can override this strategy to do more sophisticated concurrency activations (such as making the SVC HANDLER an active object <ref> [13] </ref> that processes data using multi-threading or multiprocessing). When an Acceptor terminates, either due to errors or due to the entire application shutting down, the Reactor calls the Acceptor's handle close method to enable it to release dynamically acquired resources.
Reference: [14] <author> D. C. Schmidt, </author> <title> IPC SAP: An Object-Oriented Interface to Interprocess Communication Services, </title> <journal> C++ Report, </journal> <volume> vol. 4, </volume> <month> November/December </month> <year> 1992. </year>
Reference-contexts: The IPC mechanisms are encapsulated in C++ classes to simplify programming, enhance reuse, and to enable wholesale replacement of IPC mechanisms. For example, the SOCK Acceptor, SOCK Connector, and SOCK Stream classes used in Section 4.8 are part of the SOCK SAP C++ wrapper library for sockets <ref> [14] </ref>. Likewise, the corresponding TLI * classes are part of the TLI SAP C++ wrapper library for the Transport Layer Interface [7]. 7 SOCK SAP and TLI SAP encapsulate the stream-oriented semantics of connection-oriented protocols like TCP and SPX with a efficient, portable, and type-safe C++ wrappers.
Reference: [15] <author> D. C. Schmidt and T. Suda, </author> <title> An Object-Oriented Framework for Dynamically Configuring Extensible Distributed Communication Systems, </title> <journal> IEE/BCS Distributed Systems Engineering Journal (Special Issue on Configurable Distributed Systems), </journal> <volume> vol. 2, </volume> <pages> pp. 280-293, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: When a service request arrives on a monitored port, the Acceptor process accepts the request and dispatches an appropriate pre-registered handler to perform the service. * The Ericsson EOS Call Center Management system <ref> [15] </ref> uses the Connector pattern to allow application-level Call Center Manager Gateways to actively establish connections with passive Peer hosts in a distributed system. * The high-speed medical image transfer subsystem of project Spectrum [16] uses the Acceptor pattern to passively establish connections and initialize application services for storing large medical
Reference: [16] <author> G. Blaine, M. Boyd, and S. Crider, </author> <title> Project Spectrum: Scalable Bandwidth for the BJC Health System, </title> <journal> HIMSS, Health Care Communications, </journal> <pages> pp. 71-81, </pages> <year> 1994. </year> <month> 11 </month>
Reference-contexts: an appropriate pre-registered handler to perform the service. * The Ericsson EOS Call Center Management system [15] uses the Connector pattern to allow application-level Call Center Manager Gateways to actively establish connections with passive Peer hosts in a distributed system. * The high-speed medical image transfer subsystem of project Spectrum <ref> [16] </ref> uses the Acceptor pattern to passively establish connections and initialize application services for storing large medical images.
References-found: 16

