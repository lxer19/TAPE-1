URL: http://www.cs.umd.edu/~keleher/papers/tpdsSubmit.ps.gz
Refering-URL: http://www.cs.umd.edu/~keleher/papers.html
Root-URL: 
Title: A Protocol-Centric Approach to On-The-Fly Race Detection  
Author: Dejan Perkovi c and Peter J. Keleher 
Keyword: Index terms: data races, on-the-, DSM, shared memory  
Note: (dejanp|keleher)@cs.umd.edu  
Date: November 12, 1997  
Address: College Park, MD 20742-3255  
Affiliation: Department of Computer Science, University of Maryland  
Abstract: We present the design and evaluation of a low-cost data-race-detection technique. Our technique executes at runtime rather than post-mortem, and handles unmodified shared-memory applications that run on top of CVM, a software distributed shared memory system. We do not assume explicit associations between synchronization and shared data, and use neither compiler support nor program source. Instead, we use a binary code re-writer to instrument instructions that may access shared memory. The most novel aspect of our system is that we are able to use information from the underlying memory system implementation in order to reduce the number of comparisons made at run time. We present an experimental evaluation of our techniques by using our system to look for data races in five common shared-memory programs. Our system correctly found races in three of the five programs, including two from a standard benchmark suite. We show that the overhead of this debugging technique can be as low as 22%. We further studied the impact of four optimizations to the basic technique: data flow analysis, instrumentation batching, runtime code modification, and instrumentation inlining. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Adve and M. Hill. </author> <title> Weak ordering: A new definition. </title> <booktitle> In Proceedings of the 17th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 2-14, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: For example, denoted 2 1 . Each time a process executes a release or an acquire, a new interval begins and the current interval index is incremented. Intervals of different processes are related by a happens-before-1 partial ordering <ref> [1] </ref>: 1. intervals on a single processor are totally ordered by program order, 2. interval i p precedes interval j q if j q begins with the acquire corresponding to the release that concluded interval i p , 3. the transitive closure of the above.
Reference: [2] <author> S. V. Adve, M. D. Hill, B. P. Miller, and R. H. B. Netzer. </author> <title> Detecting data races on weak memory systems. </title> <booktitle> In Proceedings of the 18th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 234-243, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: If global synchronization is either not used, or not used often enough, we can exploit CVM routines that allow global state to be consolidated between synchronizations. Currently, this mechanism is only used in CVM for garbage collection of consistency information in long-running, barrier-free programs. 6.3 Accuracy Adve <ref> [2] </ref> discusses three potential problems in the accuracy of race detection schemes in concert with weak memory systems, or systems that support memory models such as lazy release consistency. <p> Additionally, the work described in this paper includes several optimizations to the basic system (i.e., batching, data-flow analysis, runtime code modification, and inlining). Our work is closely related to work already alluded to in Section 6.3, a technique described (but not implemented) by Adve et al. <ref> [2] </ref>. The authors describe a post-mortem technique that creates trace logs containing synchronization events, information allowing their relative execution order to be derived, and computation events. Computation events correspond roughly to CVM's intervals.
Reference: [3] <author> T. R. Allen and D. A. Padua. </author> <title> Debugging fortran on a shared memory machine. </title> <booktitle> In International Conference on Parallel Processing, </booktitle> <pages> pages 721-727, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: This paper presents the design and evaluation of an on-the-fly race-detection technique for explicitly parallel shared-memory applications. This technique is applicable to shared memory programs written for the lazy-release-consistent (LRC) [11] memory model. Our work differs from previous work <ref> [3, 4, 7, 9, 17, 16] </ref> in that data-race detection is performed both on-the-fly and without compiler support.
Reference: [4] <author> J. Choi and S. L. Min. </author> <title> Race frontier: Reproducing data races in parallel program debugging. </title> <booktitle> In Proceedings of the 1991 Conference on the Principles and Practice of Parallel Programming, </booktitle> <month> April </month> <year> 1991. </year>
Reference-contexts: This paper presents the design and evaluation of an on-the-fly race-detection technique for explicitly parallel shared-memory applications. This technique is applicable to shared memory programs written for the lazy-release-consistent (LRC) [11] memory model. Our work differs from previous work <ref> [3, 4, 7, 9, 17, 16] </ref> in that data-race detection is performed both on-the-fly and without compiler support.
Reference: [5] <author> Robert F. Cmelik and David Keppel. Shade: </author> <title> A fast instruction-set simulator for execution profiling. </title> <type> Technical Report TR-93-12, </type> <institution> Sun Microsystems Lab, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: Although ATOM is currently available only for DEC Alpha systems, a port is currently underway to Intel's x86 architecture. Moreover, tools that provide similar support for other architectures are becoming more common. Examples are EEL [15] (SPARC and MIPS), Shade <ref> [5] </ref> (SPARC), and Etch [21] (x86). 6 The actual instrumentation consists of a procedure call to an analysis routine (in our terminology called access check routine) that checks if the instruction accesses shared memory; if so, it sets a flag of the corresponding page and flips a bit in a per-page
Reference: [6] <author> K. Cooper, M. W. Hall, and K. Kennedy. </author> <title> A methodology for procedure cloning. </title> <journal> Computer Languages, </journal> <volume> 19(2) </volume> <pages> 105-117, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: Nonetheless, we feel that the technique can be useful if applied with caution. We used the modified instrumentation to detect improper behavior in two of our applications. Since only a few procedures were affected, we eliminated the ambiguity by manually cloning <ref> [6] </ref> the offending routines. Our technique consists of identifying instructions that reference non-shared data at runtime, and writing NO-OP instructions over the instrumentation calls. Modifying code at runtime requires that the text segment be writable.
Reference: [7] <author> A. Dinning and E. Schonberg. </author> <title> An empirical comparison of monitoring algorithms for access anomaly detection. </title> <booktitle> In Proceedings of the 1990 Conference on the Principles and Practice of Parallel Programming, </booktitle> <pages> pages 1-10, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: This paper presents the design and evaluation of an on-the-fly race-detection technique for explicitly parallel shared-memory applications. This technique is applicable to shared memory programs written for the lazy-release-consistent (LRC) [11] memory model. Our work differs from previous work <ref> [3, 4, 7, 9, 17, 16] </ref> in that data-race detection is performed both on-the-fly and without compiler support. <p> However, most prior work has dealt with applications and systems in more specialized domains. Bitmaps have been used to track shared accesses before <ref> [7] </ref>, but we know of no other implementation of on-the-fly data-race detection for explicitly-parallel, shared-memory programs without compiler support. We previously [20] described the performance of a preliminary form of our race-detection scheme that ran on top of CVM's single-writer LRC protocol [14].
Reference: [8] <author> K. Gharachorloo, D. Lenoski, J. Laudon, P. Gibbons, A. Gupta, and J. Hennessy. </author> <title> Memory consistency and event ordering in scalable shared-memory multiprocessors. </title> <booktitle> In Proceedings of the 17th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 15-26, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Unless otherwise specified, the term data-race will refer to actual data-races throughout the rest of the paper. 3 Lazy Release Consistency and Data Races 3.1 Lazy Release Consistency Lazy release consistency [11] is a variant of eager release consistency (ERC) <ref> [8] </ref>, a relaxed memory consistency that allows the effects of shared memory accesses to be delayed until selected synchronization accesses occur. Simplifying matters somewhat, shared memory accesses are labeled either as ordinary or as synchronization accesses, with the latter category further divided into acquire and release accesses.
Reference: [9] <author> Robert Hood, Ken Kennedy, and John Mellor-Crummey. </author> <title> Parallel program debugging with on-the-fly anomaly detection. </title> <booktitle> In Proceedings Supercomputing '90, </booktitle> <pages> pages 15-26, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: This paper presents the design and evaluation of an on-the-fly race-detection technique for explicitly parallel shared-memory applications. This technique is applicable to shared memory programs written for the lazy-release-consistent (LRC) [11] memory model. Our work differs from previous work <ref> [3, 4, 7, 9, 17, 16] </ref> in that data-race detection is performed both on-the-fly and without compiler support.
Reference: [10] <author> P. Keleher. </author> <title> Distributed Shared Memory Using Lazy Release Consistency. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <year> 1994. </year>
Reference-contexts: Ideally, the system would be able to incrementally discard data races without global cooperation, but such mechanisms would increase the complexity of the underlying consistency protocol <ref> [10] </ref>. If global synchronization is either not used, or not used often enough, we can exploit CVM routines that allow global state to be consolidated between synchronizations.
Reference: [11] <author> P. Keleher, A. L. Cox, and W. Zwaenepoel. </author> <title> Lazy release consistency for software distributed shared memory. </title> <booktitle> In Proceedings of the 19th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 13-21, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: This paper presents the design and evaluation of an on-the-fly race-detection technique for explicitly parallel shared-memory applications. This technique is applicable to shared memory programs written for the lazy-release-consistent (LRC) <ref> [11] </ref> memory model. Our work differs from previous work [3, 4, 7, 9, 17, 16] in that data-race detection is performed both on-the-fly and without compiler support. <p> Unless otherwise specified, the term data-race will refer to actual data-races throughout the rest of the paper. 3 Lazy Release Consistency and Data Races 3.1 Lazy Release Consistency Lazy release consistency <ref> [11] </ref> is a variant of eager release consistency (ERC) [8], a relaxed memory consistency that allows the effects of shared memory accesses to be delayed until selected synchronization accesses occur.
Reference: [12] <author> P. Keleher, S. Dwarkadas, A. Cox, and W. Zwaenepoel. Treadmarks: </author> <title> Distributed shared memory on standard workstations and operating systems. </title> <booktitle> In Proceedings of the 1994 Winter Usenix Conference, </booktitle> <pages> pages 115-131, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Like commercially available systems such as TreadMarks <ref> [12] </ref>, CVM is written entirely as a user-level library and runs on most UNIX-like systems. Unlike TreadMarks, CVM was created specifically as a platform for protocol experimentation. The system is written in C++, and opaque interfaces are strictly enforced between different functional units of the system whenever possible. <p> CVM was also designed to take advantage of generalized synchronization interfaces, as well as to use multi-threading for latency toleration. Our detection mechanism is based on CVM's multi-writer LRC protocol. This protocol propagates modifications in the form of diffs, which are run-length encodings of modifications to a single page <ref> [12] </ref>.
Reference: [13] <author> Pete Keleher. </author> <title> The Coherent Virtual Machine. </title> <type> Technical Report Maryland TR93-215, </type> <institution> Department of Computer Science, University of Maryland, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: This paper extends this earlier work through the use of a more advanced multi-writer protocol, and through a series of optimizations to the basic technique. We find data races by running applications on a modified version of the Coherent Virtual Memory (CVM) <ref> [13, 14] </ref> software distributed shared memory (DSM) system. DSMs support the abstraction of shared memory for parallel applications running on CPUs connected by general-purpose interconnects, such as networks of workstations or distributed memory machines like the IBM SP-2. <p> an LRC system is said to be first data-race if there is no other actual data-race d x that has both conflicting accesses preceding both accesses of data-race d 0 with respect to happens-before-1. 4 Implementation 4.1 System and its Changes We implemented our race-detection system on top of CVM <ref> [13, 14] </ref>, a software DSM that supports multiple protocols and consistency models. Like commercially available systems such as TreadMarks [12], CVM is written entirely as a user-level library and runs on most UNIX-like systems. Unlike TreadMarks, CVM was created specifically as a platform for protocol experimentation.
Reference: [14] <author> Pete Keleher. </author> <title> The relative importance of concurrent writers and weak consistency models. </title> <booktitle> To appear in The Proceedings of the 16th International Conference on Distributed Computing Systems, </booktitle> <month> May </month> <year> 1996. </year> <month> 24 </month>
Reference-contexts: This paper extends this earlier work through the use of a more advanced multi-writer protocol, and through a series of optimizations to the basic technique. We find data races by running applications on a modified version of the Coherent Virtual Memory (CVM) <ref> [13, 14] </ref> software distributed shared memory (DSM) system. DSMs support the abstraction of shared memory for parallel applications running on CPUs connected by general-purpose interconnects, such as networks of workstations or distributed memory machines like the IBM SP-2. <p> an LRC system is said to be first data-race if there is no other actual data-race d x that has both conflicting accesses preceding both accesses of data-race d 0 with respect to happens-before-1. 4 Implementation 4.1 System and its Changes We implemented our race-detection system on top of CVM <ref> [13, 14] </ref>, a software DSM that supports multiple protocols and consistency models. Like commercially available systems such as TreadMarks [12], CVM is written entirely as a user-level library and runs on most UNIX-like systems. Unlike TreadMarks, CVM was created specifically as a platform for protocol experimentation. <p> We previously [20] described the performance of a preliminary form of our race-detection scheme that ran on top of CVM's single-writer LRC protocol <ref> [14] </ref>. This paper describes the performance of our race-detection scheme on top of CVM's multi-writer protocol. This protocol is a more challenging target because it usually outperforms the single-writer protocol significantly, making it more difficult to hide the race-detection overheads.
Reference: [15] <author> James R. Larus and Eric Schnarr. EEL: </author> <title> Machine-independent executable editing. </title> <booktitle> In Proceedings of the SIGPLAN `95 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: Although ATOM is currently available only for DEC Alpha systems, a port is currently underway to Intel's x86 architecture. Moreover, tools that provide similar support for other architectures are becoming more common. Examples are EEL <ref> [15] </ref> (SPARC and MIPS), Shade [5] (SPARC), and Etch [21] (x86). 6 The actual instrumentation consists of a procedure call to an analysis routine (in our terminology called access check routine) that checks if the instruction accesses shared memory; if so, it sets a flag of the corresponding page and flips
Reference: [16] <author> John Mellor-Crummey. </author> <title> Compile-time support for efficient data race detection in shared-memory parallel programs. </title> <type> Technical Report CRPC-TR92232, </type> <institution> Rice University, </institution> <month> September </month> <year> 1992. </year>
Reference-contexts: This paper presents the design and evaluation of an on-the-fly race-detection technique for explicitly parallel shared-memory applications. This technique is applicable to shared memory programs written for the lazy-release-consistent (LRC) [11] memory model. Our work differs from previous work <ref> [3, 4, 7, 9, 17, 16] </ref> in that data-race detection is performed both on-the-fly and without compiler support.
Reference: [17] <author> R. H. B. Netzer and B. P. Miller. </author> <title> Improving the accuracy of data race detection. </title> <booktitle> In Proceedings of the 1991 Conference on the Principles and Practice of Parallel Programming, </booktitle> <month> April </month> <year> 1991. </year>
Reference-contexts: This paper presents the design and evaluation of an on-the-fly race-detection technique for explicitly parallel shared-memory applications. This technique is applicable to shared memory programs written for the lazy-release-consistent (LRC) [11] memory model. Our work differs from previous work <ref> [3, 4, 7, 9, 17, 16] </ref> in that data-race detection is performed both on-the-fly and without compiler support.
Reference: [18] <author> Robert H. B. Netzer and Barton P. Miller. </author> <title> On the complexity of event ordering for shared-memory parallel program executions. </title> <booktitle> In 1990 International Conference on Parallel Processing, </booktitle> <pages> pages 93-97, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: Part of the problem is surely the restricted domain in which most such mechanisms operate, i.e., parallelizing compilers. Compiler support is usually deemed necessary because race-detection is in general NP-complete <ref> [18] </ref>. 1 The cost of a runtime technique that did not rely on some form of high-level ordering information would clearly be prohibitive. This paper presents the design and evaluation of an on-the-fly race-detection technique for explicitly parallel shared-memory applications. <p> In common with other dynamic systems, we address only the problem of detecting data races that occur in a given execution, not the more general problem of detecting all races allowed by program semantics <ref> [18, 24] </ref>. Earlier work [20] introduced this approach by demonstrating its use on a less complex single-writer protocol. This paper extends this earlier work through the use of a more advanced multi-writer protocol, and through a series of optimizations to the basic technique.
Reference: [19] <author> Robert H. B. Netzer and Barton P. Miller. </author> <title> What are race conditions? In ACM Letters on Programming Languages and Systems. </title> <publisher> ACM, </publisher> <month> March </month> <year> 1992. </year>
Reference-contexts: Lock (L) r 1 (x) w 2 (x) Unlock (L) Unlock (L) w 1 (x) Lock (L) Lock (L) r 1 (x) w 2 (x) Unlock (L) Unlock (L) 2 Problem Definition To define the problem that this work addresses, we will use the following two definitions stated by Netzer <ref> [19] </ref>. Definition 1 An actual data-race is a pair of memory accesses in some execution, such that: 1. Both access the same shared variable, 2. At least one is a write, 3. The accesses are not ordered by system-visible synchronization or program order. <p> While runtime overhead and storage requirements can thereby be drastically reduced, the data race must occur in the second run exactly as in the first. This will happen if the application has no general races <ref> [19] </ref>, i.e., synchronization order is deterministic. This is not the case in Water, the application for which we found data races. A solution is to modify CVM so to save synchronization ordering information from the first run, and to enforce the same ordering in the second run.
Reference: [20] <author> Dejan Perkovic and Peter J. Keleher. </author> <title> Online data-race detection via coherency guarantees. </title> <booktitle> In Proceedings of the Second USENIX Symposium on Operating System Design and Implementation(OSDI'96), </booktitle> <pages> pages 47-58, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: In common with other dynamic systems, we address only the problem of detecting data races that occur in a given execution, not the more general problem of detecting all races allowed by program semantics [18, 24]. Earlier work <ref> [20] </ref> introduced this approach by demonstrating its use on a less complex single-writer protocol. This paper extends this earlier work through the use of a more advanced multi-writer protocol, and through a series of optimizations to the basic technique. <p> However, most prior work has dealt with applications and systems in more specialized domains. Bitmaps have been used to track shared accesses before [7], but we know of no other implementation of on-the-fly data-race detection for explicitly-parallel, shared-memory programs without compiler support. We previously <ref> [20] </ref> described the performance of a preliminary form of our race-detection scheme that ran on top of CVM's single-writer LRC protocol [14]. This paper describes the performance of our race-detection scheme on top of CVM's multi-writer protocol.
Reference: [21] <author> Ted Romer, Geoff Voelker, Dennis Lee, Alec Wolman, Wayne Wong, Hank Levy, and Brian Bershad. </author> <title> Instrumentation and optimization of win32/intel executables using etch. </title> <booktitle> In USENIX Windows NT Workshop, </booktitle> <year> 1997. </year>
Reference-contexts: Although ATOM is currently available only for DEC Alpha systems, a port is currently underway to Intel's x86 architecture. Moreover, tools that provide similar support for other architectures are becoming more common. Examples are EEL [15] (SPARC and MIPS), Shade [5] (SPARC), and Etch <ref> [21] </ref> (x86). 6 The actual instrumentation consists of a procedure call to an analysis routine (in our terminology called access check routine) that checks if the instruction accesses shared memory; if so, it sets a flag of the corresponding page and flips a bit in a per-page bitmap to designate that
Reference: [22] <author> M. A. Ronsse and W. Zwaenepoel. </author> <title> Execution replay for TreadMarks. </title> <note> Submitted for publication, </note> <year> 1996. </year>
Reference-contexts: This is done in the work on execution replay in TreadMarks, which is also Lazy Release Consistent DSM. The approach of the Reconstruction of Lamport Timestamps (ROLT) <ref> [22] </ref> technique keeps track of minimal ordering information saved during an initial run to enforce exactly the same interleaving of shared accesses and synchronization in a second run. <p> We are therefore able to perform all of the analysis on-the-fly as well, and do away with trace logs, post-mortem analysis, and much of the overhead. Work on execution replay in TreadMarks could be used to implement race-detection schemes. The approach of the Reconstruction of Lamport Timestamps (ROLT) <ref> [22] </ref> technique is similar to the technique we described in Section 6.1 for identifying the instructions involved in races. Minimal ordering information saved during an initial run is used to enforce exactly the same interleaving of shared accesses and synchronization in the second run.
Reference: [23] <author> Michiel Ronsse and Koen De Bosschere. </author> <title> Work in progress: An on-the-fly data race detector for recplay, a record/replay system for parallel programs. </title> <booktitle> In 16th ACM Symposium on Operating Systems Principles (Work in progress), </booktitle> <month> October </month> <year> 1997. </year>
Reference-contexts: Furthermore, their technique causes slowdowns on the order of ten to thirty times. Work on detecting data-race detection for non-distributed multi-threaded programs has also been done for RecPlay <ref> [23] </ref>, a Record/Replay system for multi-threaded programs. This work is similar to ROLT approach discussed here, but applied to multi-threaded programs. This work uses the happens-before relation to reconstruct and replay the execution of the initial run, and then in the second run perform access checks.
Reference: [24] <author> Stefan Savage, Michael Burrows, Greg Nelson, Patrick Sobalvarro, and Thomas Anderson. Eraser: </author> <title> A dynamic data race detector for multi-threaded programs. </title> <booktitle> In Proceedings of the 16th ACM Symposium on Operating Systems Principles, </booktitle> <month> October </month> <year> 1997. </year>
Reference-contexts: In common with other dynamic systems, we address only the problem of detecting data races that occur in a given execution, not the more general problem of detecting all races allowed by program semantics <ref> [18, 24] </ref>. Earlier work [20] introduced this approach by demonstrating its use on a less complex single-writer protocol. This paper extends this earlier work through the use of a more advanced multi-writer protocol, and through a series of optimizations to the basic technique. <p> As such, our techniques could be used to improve the performance of the second phase of the ROLT approach. Similarly, our system could be augmented to include an initial synchronization-tracing phase, allowing us to reduce our perturbation of the parallel computation. Recently, work on Eraser <ref> [24] </ref> used ATOM to instrument references for data-race detection in non-distributed multi-threaded programs (does not support a cluster of workstations). Its main advantage is that it can detect more data-races, since it uses a special purpose algorithm instead of the happens-before relation for access ordering.
Reference: [25] <author> Amitabh Srivastava and Alan Eustace. </author> <title> ATOM: A system for building customized program analysis tools. </title> <booktitle> In Proceedings of the SIGPLAN `94 Conference on Programming Language Design and Implementation, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: read and write access information, (ii) we added lists of pages read (read notices) to message types that already carry analogous information about pages written, and (iii) we added an extra message round at barriers in order to retrieve word-level access information, if necessary. 4.2 Instrumentation We use the ATOM <ref> [25] </ref> code-rewriter to instrument shared accesses with calls to analysis routines. ATOM allows executable binaries to be analyzed and modified. We use ATOM to identify and instrument all loads and stores that may access shared memory.
Reference: [26] <author> S. C. Woo, M. Ohara, E. Torrie, J. P. Singh, and A. Gupta. </author> <title> The SPLASH-2 programs: Characterization and methodological considerations. </title> <booktitle> In Proceedings of the 22nd Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 24-37, </pages> <month> June </month> <year> 1995. </year> <month> 25 </month>
Reference-contexts: The task of this last point is made much easier precisely because of the synchronization ordering information maintained by LRC. We used this technique to check for data races in implementations of five common parallel applications. Our system correctly found races in three. Water-Nsquared and Spatial, from the Splash2 <ref> [26] </ref> benchmark suite, had data races that constituted real bugs. These bugs have been reported to the Splash authors and fixed in their current version. While the races could affect correctness, they were unlikely to occur on the platforms for which SPLASH was originally intended. <p> Locations that are overwritten with the same value do not appear in diffs, even though their use might constitute a race. 5 Performance We evaluated the performance of our prototype by searching for data races in five common shared-memory applications: Barnes (Barnes-Hut algorithm the from Splash2 <ref> [26] </ref> benchmark suite) FFT (Fast Fourier Transform), SOR (Jacobi relaxation), Water (a molecular dynamics simulation; from the Splash2 suite, and Spatial (the same problem as Water, but different algorithm; also from Splash2, but optimized for reduced synchronization).
References-found: 26

