URL: ftp://ftp.fas.sfu.ca/pub/cs/han/dood/split95.ps
Refering-URL: http://fas.sfu.ca/cs/research/groups/DB/sections/publication/dood/dood.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Chain-Split Evaluation in Deductive Databases  
Author: Jiawei Han 
Keyword: Index Terms: deductive database, logic programming, query analysis and query optimization, query processing, recursive query evaluation.  
Abstract: Many popularly studied recursions in deductive databases can be compiled into one or a set of highly regular chain generating paths, each of which consists of one or a set of connected predicates. Previous studies on chain-based query evaluation in deductive databases take a chain generating path as an inseparable unit in the evaluation. However, some recursions, especially many functional recursions whose compiled chain consists of infinitely evaluable function(s), should be evaluated by chain-split evaluation, which splits a chain generating path into two portions in the evaluation: an immediately evaluable portion and a delayed-evaluation portion. In this paper, the necessity of chain-split evaluation is examined from the points of view of both efficiency and finite evaluation, and three chain-split evaluation techniques: magic sets, buffered evaluation and partial evaluation, are developed. Our study shows that chain-split evaluation is a primitive recursive query evaluation technique for different kinds of recursions, and it can be implemented efficiently in deductive databases by extensions to the existing recursive query evaluation methods. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Bancilhon, D. Maier, Y. Sagiv, and J. D. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proc. 5th ACM Symp. Principles of Database Systems, </booktitle> <pages> pages 1-15, </pages> <address> Cambridge, MA, </address> <month> March </month> <year> 1986. </year>
Reference-contexts: 1 Introduction Most linear recursions and many other kinds of recursions encountered in practice can be compiled into highly regular chain forms [8, 9, 21]. Interesting recursive query evaluation techniques [2], such as transitive closure algorithms [10], magic sets and counting <ref> [1] </ref>, can be applied to the efficient evaluation of compiled chains in deductive databases. However, it is interesting to observe that some recursions, especially many recursions containing function symbols, may often be evaluated appropriately by a different evaluation technique: chain-split evaluation. <p> This study is focused on the chain-split evaluation of compiled or normalized recursions. 2 1.1 Chain-split for efficient evaluation Usually, a single-chain recursion is evaluated efficiently by a transitive closure algorithm [10], and a multi-chain recursion by magic sets or counting <ref> [1, 2] </ref>. One may have wondered whether queries on multi-chain recursions can be evaluated efficiently by merging multiple chain generating paths into one and then applying transitive closure algorithms [11]. <p> Thus, we have, Algorithm 3.1 Efficiency-based chain-split magic sets evaluation of a function-free linear recursion. Input: A query and a compiled function-free linear recursion. Output: An efficiency-based chain-split magic sets query evaluation plan. Method: 9 * In the derivation of magic sets, the binding propagation rule <ref> [1] </ref> is modified as follows: If the join expansion ratio for hX; Y i is above the chain-split threshold, the binding will not be propagated from X to Y ; if it is below the chain-following threshold, the binding will be propagated from X to Y ; otherwise, a detailed quantitative <p> ; if it is below the chain-following threshold, the binding will be propagated from X to Y ; otherwise, a detailed quantitative analysis is performed to determine whether a chain-split is beneficial. * Based on the modified binding propagation rules, the magic set (s) are derived, and the semi-naive evaluation <ref> [1] </ref> is performed on the sets of relevant facts. 2 Based on the reasoning presented before the example, it is easy to see that Algorithm 3.1 derives a more efficient query evaluation plan than the method which relies on blind binding passing without distinction of strong linkages from weak ones. 3.2 <p> The evaluation terminates at the k-th iteration or when there is no W i1 derivable at an iteration. 2 Remark 3.1 The buffered chain-split evaluation performed by Algorithm 3.2 correctly evaluates a compiled single-chain recursion. Rationale. The algorithm is similar to counting <ref> [1] </ref> except that the values of variable X i 's are buffered in the processing of the being evaluated portion of a chain generating path and reused in the processing of its buffered portion. <p> Similarly, chain-split evaluation should be performed on the recursion insert bbf . The evaluation of query "? isort ([5; 7; 1]; Y s):" proceeds as follows. The evaluation of (4.11) leads to "X = 5" (which is buffered) and "Xs = <ref> [7; 1] </ref>", and then a call "isort ([7; 1]; Zs)" which in turn leads to "X 0 = 7" (which is buffered) and "Xs 0 = [1]", and a call "isort ([1]; Zs 0 )". <p> The evaluation of (4.11) leads to "X = 5" (which is buffered) and "Xs = [7; 1]", and then a call "isort ([7; 1]; Zs)" which in turn leads to "X 0 = 7" (which is buffered) and "Xs 0 = <ref> [1] </ref>", and a call "isort ([1]; Zs 0 )". This leads to "X 00 = 1" (which is also buffered) and "Xs 00 = []", and a call "isort ([]; Zs 00 )". This call executes (4.12) and results in Zs 00 = []. <p> The evaluation of this sequence of calls is performed as follows. First, "insert (1; []; Zs 0 )" results in "Zs 0 = <ref> [1] </ref>" since it can only execute (4.13). Second, "insert (7; [1]; Zs)" leads to "Zs = [1, 7]" since it executes (4.15) which in turn calls "insert (1; [7]; Zs)" and then executes the rule (4.15). <p> The evaluation of this sequence of calls is performed as follows. First, "insert (1; []; Zs 0 )" results in "Zs 0 = <ref> [1] </ref>" since it can only execute (4.13). Second, "insert (7; [1]; Zs)" leads to "Zs = [1, 7]" since it executes (4.15) which in turn calls "insert (1; [7]; Zs)" and then executes the rule (4.15). Third, "insert (5; [1; 7]; Y s)" calls "insert (5; [7]; Zs); cons (1; Zs; Y s)". <p> The evaluation of this sequence of calls is performed as follows. First, "insert (1; []; Zs 0 )" results in "Zs 0 = [1]" since it can only execute (4.13). Second, "insert (7; [1]; Zs)" leads to "Zs = <ref> [1, 7] </ref>" since it executes (4.15) which in turn calls "insert (1; [7]; Zs)" and then executes the rule (4.15). Third, "insert (5; [1; 7]; Y s)" calls "insert (5; [7]; Zs); cons (1; Zs; Y s)". <p> Second, "insert (7; [1]; Zs)" leads to "Zs = [1, 7]" since it executes (4.15) which in turn calls "insert (1; [7]; Zs)" and then executes the rule (4.15). Third, "insert (5; <ref> [1; 7] </ref>; Y s)" calls "insert (5; [7]; Zs); cons (1; Zs; Y s)". This leads to the final answer, "Y s = [1; 5; 7]". 2 This example demonstrates that chain-split evaluation is a popular technique in the evaluation of nested linear recursions. <p> Third, "insert (5; [1; 7]; Y s)" calls "insert (5; [7]; Zs); cons (1; Zs; Y s)". This leads to the final answer, "Y s = <ref> [1; 5; 7] </ref>". 2 This example demonstrates that chain-split evaluation is a popular technique in the evaluation of nested linear recursions.
Reference: [2] <author> F. Bancilhon and R. Ramakrishnan. </author> <title> An amateur's introduction to recursive query processing strategies. </title> <booktitle> In Proc. 1986 ACM-SIGMOD Int. Conf. Management of Data, </booktitle> <pages> pages 16-52, </pages> <address> Washington, DC, </address> <month> May </month> <year> 1986. </year>
Reference-contexts: 1 Introduction Most linear recursions and many other kinds of recursions encountered in practice can be compiled into highly regular chain forms [8, 9, 21]. Interesting recursive query evaluation techniques <ref> [2] </ref>, such as transitive closure algorithms [10], magic sets and counting [1], can be applied to the efficient evaluation of compiled chains in deductive databases. <p> However, it is interesting to observe that some recursions, especially many recursions containing function symbols, may often be evaluated appropriately by a different evaluation technique: chain-split evaluation. Like many researchers <ref> [2, 21] </ref>, we assume that a deductive database consists of three parts: (i) an extensional database (EDB) (a set of data relations), (ii) an intensional database (IDB) (a set of Horn-clause rules), and (iii) a set of integrity constraints (ICs). <p> This study is focused on the chain-split evaluation of compiled or normalized recursions. 2 1.1 Chain-split for efficient evaluation Usually, a single-chain recursion is evaluated efficiently by a transitive closure algorithm [10], and a multi-chain recursion by magic sets or counting <ref> [1, 2] </ref>. One may have wondered whether queries on multi-chain recursions can be evaluated efficiently by merging multiple chain generating paths into one and then applying transitive closure algorithms [11]. <p> Can chain-split improve the performance of query evaluation? We examine an example. Example 1.2 Suppose the recursion scsg (same-country same-generation relatives) is defined by the rule set f (1.5), (1.6), (1.7)g. The definition is similar to sg <ref> [2] </ref> except that the parents of each pair of scsg must be born in the same country. scsg (X; Y ) parent (X; X 1 ); parent (Y; Y 1 ); same country (X 1 ; Y 1 ); scsg (X 1 ; Y 1 ): (1.5) scsg (X; Y ) <p> This can be easily seen from the adorned rules (1.11) and (1.12) <ref> [2] </ref>. 2 scsg bf (X; Y ) parent bf (X; X 1 ); same country bf (X 1 ; Y 1 ); parent fb (Y; Y 1 ); scsg bb (X 1 ; Y 1 ): (1.11) scsg bb (X; Y ) parent bf (X; X 1 ); same country bf <p> Obviously, no chain-split should be performed if the chain is a down-chain (i.e., the chain is being evaluated after the evaluation of the exit portion) <ref> [2] </ref>. Suppose the evaluation starts at a chain with the path "(p; ; q)" with X 0 instantiated and proceeds towards the exit portion e and then the other chains in the compiled recursion. <p> Since query constants may bind some infinite domains of variables to finite ones, the analysis of finite evalua-bility should incorporate query instantiation information. Similar to the notations used in the magic sets transformation <ref> [2, 21] </ref>, a superscript b or f is used to adorn a variable to indicate the variable being bound (finite) or free (infinite), and a string of b's and f's is used to adorn a predicate to indicate the bindings of its corresponding arguments. <p> one subchain represented by "cons (X 1 ; W 1 ; W )" evaluated first and the other "cons (X 1 ; U 1 ; U )" delayed until the exit rule is evaluated. 2 8 3 Chain-Split Evaluation Techniques There are two typical evaluation methods, magic sets and counting <ref> [2] </ref>, in the evaluation of n-chain recursions without chain-split.
Reference: [3] <author> C. Beeri, P. Kanellakis, F. Bancilhon, and R. Ramakrishnan. </author> <title> Bounds on the propagation of selection into logic programs. </title> <booktitle> In Proc. 6th ACM Symp. Principles of Database Systems, </booktitle> <pages> pages 214-226, </pages> <address> San Diego, CA, </address> <month> March </month> <year> 1987. </year> <month> 18 </month>
Reference-contexts: Rationale. Step 1 is necessary since a query must be finitely evaluable and terminate. Step 2 is necessary and correct since the most selective information should be pushed into the compiled chain for initial processing <ref> [3] </ref>. Step 3 is correct since if the chain-split evaluation is to be performed, partial evaluation should be explored.
Reference: [4] <author> D. Chimenti, R. Gamboa, R. Krishnamurthy, S. Naqvi, S. Tsur, and C. Zaniolo. </author> <title> The LDL system prototype. </title> <journal> IEEE Trans. Knowledge and Data Engineering, </journal> <volume> 2 </volume> <pages> 76-90, </pages> <year> 1990. </year>
Reference-contexts: The evaluation of query "? qsort (<ref> [4; 9; 5] </ref>; Y s):" proceeds as follows. * The evaluation of (4.26) leads to qsort ([4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (4.31) * The evaluation of "partition ([9; 5]; 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; [5]; [9; 5]); 9 &gt; 4; <p> It in turn derives "XLs = []" and "Bs = [5]" in (4.33) and "XLs = []" and "XBs = [9; 5]" in (4.32). (4.31) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; <ref> [4; 9; 5] </ref>); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (4.34) * The evaluation of "qsort ([]; Ls)" applying the rule (4.27) derives "Ls = []", and the evaluation of qsort ([9; 5]; Bs) leads <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". 2 From this example, it is not difficult to see that chain-split is a primitive and frequently-applied evaluation technique in the processing of many nonlinear recursions as well. <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". 2 From this example, it is not difficult to see that chain-split is a primitive and frequently-applied evaluation technique in the processing of many nonlinear recursions as well. <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". 2 From this example, it is not difficult to see that chain-split is a primitive and frequently-applied evaluation technique in the processing of many nonlinear recursions as well. <p> Furthermore, the evaluation should be integrated with existence checking and constraint-based query evaluation techniques [6] to achieve high performance in the evaluation of sophisticated logic programs. To the best of our knowledge, no detailed study on chain-split evaluation was performed in previous deductive database research <ref> [4, 16, 21, 23, 22] </ref>. Many deductive database system projects, such as LDL [4], EKS-V1 [23], CORAL [16, 19], etc. have been focused on the evaluation of function-free recursions; whereas chain-split evaluation is frequently encountered in functional recursions, as demonstrated in this study. <p> To the best of our knowledge, no detailed study on chain-split evaluation was performed in previous deductive database research [4, 16, 21, 23, 22]. Many deductive database system projects, such as LDL <ref> [4] </ref>, EKS-V1 [23], CORAL [16, 19], etc. have been focused on the evaluation of function-free recursions; whereas chain-split evaluation is frequently encountered in functional recursions, as demonstrated in this study. <p> Many deductive database system projects, such as LDL [4], EKS-V1 [23], CORAL [16, 19], etc. have been focused on the evaluation of function-free recursions; whereas chain-split evaluation is frequently encountered in functional recursions, as demonstrated in this study. Recent studies <ref> [4, 16, 19] </ref> have extended the Datalog data model to handle function symbols to a limited extent, however, based on our knowledge, no chain-split evaluation has been performed in those projects.
Reference: [5] <author> R. W. Haddad and J. F. Naughton. </author> <title> A counting algorithm for a cyclic binary query. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43 </volume> <pages> 145-169, </pages> <year> 1991. </year>
Reference-contexts: For a function-free recursion, the evaluation terminates easily on acyclic data. For cyclic data, the method can be extended in a way similar to cyclic counting algorithms (such as <ref> [5] </ref>). For a functional recursion, termination is often based on the monotonicity of certain arguments [6]. <p> Third, "insert (5; [1; 7]; Y s)" calls "insert (5; [7]; Zs); cons (1; Zs; Y s)". This leads to the final answer, "Y s = <ref> [1; 5; 7] </ref>". 2 This example demonstrates that chain-split evaluation is a popular technique in the evaluation of nested linear recursions. <p> The evaluation of query "? qsort ([4; 9; 5]; Y s):" proceeds as follows. * The evaluation of (4.26) leads to qsort ([4; 9; 5]; Y s) cons (4; <ref> [9; 5] </ref>; [4; 9; 5]); partition ([9; 5]; 4; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (4.31) * The evaluation of "partition ([9; 5]; 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; [5]; [9; 5]); 9 <p> The evaluation of query "? qsort (<ref> [4; 9; 5] </ref>; Y s):" proceeds as follows. * The evaluation of (4.26) leads to qsort ([4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (4.31) * The evaluation of "partition ([9; 5]; 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; [5]; [9; 5]); 9 &gt; 4; <p> s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (4.31) * The evaluation of "partition ([9; 5]; 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; <ref> [5] </ref>; [9; 5]); 9 &gt; 4; partition ([5]; 4; XLs; Bs); cons (9; Bs; XBs): (4.32) 16 * This leads to the evaluation of "partition bbff ([5]; 4; XLs; Bs)": partition ([5]; 4; XLs; Bs) cons (5; []; [5]); 5 &gt; 4; partition ([]; 4; XLs; Bs 0 ); cons (5; <p> cons (4; <ref> [9; 5] </ref>; [4; 9; 5]); partition ([9; 5]; 4; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (4.31) * The evaluation of "partition ([9; 5]; 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; [5]; [9; 5]); 9 &gt; 4; partition ([5]; 4; XLs; Bs); cons (9; Bs; XBs): (4.32) 16 * This leads to the evaluation of "partition bbff ([5]; 4; XLs; Bs)": partition ([5]; 4; XLs; Bs) cons (5; []; [5]); 5 &gt; 4; partition ([]; 4; XLs; Bs 0 ); cons (5; Bs <p> Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; <ref> [5] </ref>; [9; 5]); 9 &gt; 4; partition ([5]; 4; XLs; Bs); cons (9; Bs; XBs): (4.32) 16 * This leads to the evaluation of "partition bbff ([5]; 4; XLs; Bs)": partition ([5]; 4; XLs; Bs) cons (5; []; [5]); 5 &gt; 4; partition ([]; 4; XLs; Bs 0 ); cons (5; Bs 0 ; Bs): (4.33) * The evaluation of "partition ([]; 4; XLs; Bs 0 )" applying rule (4.30) derives "XLs = []" and "Bs 0 = []". <p> It in turn derives "XLs = []" and "Bs = <ref> [5] </ref>" in (4.33) and "XLs = []" and "XBs = [9; 5]" in (4.32). (4.31) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; XBs); append (Ls; XBs; <p> It in turn derives "XLs = []" and "Bs = [5]" in (4.33) and "XLs = []" and "XBs = <ref> [9; 5] </ref>" in (4.32). (4.31) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (4.34) * The evaluation of "qsort ([]; Ls)" <p> It in turn derives "XLs = []" and "Bs = [5]" in (4.33) and "XLs = []" and "XBs = <ref> [9; 5] </ref>" in (4.32). (4.31) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (4.34) * The evaluation of "qsort ([]; Ls)" applying the rule (4.27) derives "Ls = []", and the evaluation of qsort ([9; 5]; <p> It in turn derives "XLs = []" and "Bs = [5]" in (4.33) and "XLs = []" and "XBs = [9; 5]" in (4.32). (4.31) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; <ref> [4; 9; 5] </ref>); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (4.34) * The evaluation of "qsort ([]; Ls)" applying the rule (4.27) derives "Ls = []", and the evaluation of qsort ([9; 5]; Bs) leads <p> It in turn derives "XLs = []" and "Bs = [5]" in (4.33) and "XLs = []" and "XBs = <ref> [9; 5] </ref>" in (4.32). (4.31) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (4.34) * The evaluation of "qsort ([]; Ls)" applying the rule (4.27) derives "Ls = []", and the evaluation of qsort ([9; 5]; Bs) leads to "Bs = [5; 9]" by a similar <p> ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (4.34) * The evaluation of "qsort ([]; Ls)" applying the rule (4.27) derives "Ls = []", and the evaluation of qsort ([9; 5]; Bs) leads to "Bs = <ref> [5; 9] </ref>" by a similar process applying the rule (4.26). Finally, "cons (4; [5; 9]; [4; 5; 9]), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". 2 From this example, it is not difficult to see that chain-split is a primitive and frequently-applied evaluation <p> cons (4; Bs; XBs); append (Ls; XBs; Y s): (4.34) * The evaluation of "qsort ([]; Ls)" applying the rule (4.27) derives "Ls = []", and the evaluation of qsort ([9; 5]; Bs) leads to "Bs = <ref> [5; 9] </ref>" by a similar process applying the rule (4.26). Finally, "cons (4; [5; 9]; [4; 5; 9]), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". 2 From this example, it is not difficult to see that chain-split is a primitive and frequently-applied evaluation technique in the processing of many nonlinear recursions as well. <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". 2 From this example, it is not difficult to see that chain-split is a primitive and frequently-applied evaluation technique in the processing of many nonlinear recursions as well. <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". 2 From this example, it is not difficult to see that chain-split is a primitive and frequently-applied evaluation technique in the processing of many nonlinear recursions as well. <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". 2 From this example, it is not difficult to see that chain-split is a primitive and frequently-applied evaluation technique in the processing of many nonlinear recursions as well.
Reference: [6] <author> J. Han. </author> <title> Constraint-based reasoning in deductive databases. </title> <booktitle> In Proc. 7th Int. Conf. Data Engineering, </booktitle> <pages> pages 257-265, </pages> <address> Kobe, Japan, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: The justification of finite evaluability relies on both query information and finiteness constraints. A finiteness constraint "X ! Y " over a predicate r implies that each value of attribute X corresponds to a finite set of Y values in r <ref> [6] </ref>. Finiteness constraint is strictly weaker than the functional dependency studied in database theory [21]. It holds trivially for all finite predicates. Since all the EDB relations are finite, all the arguments in EDB relations satisfy the finiteness constraint. <p> For a function-free recursion, the evaluation terminates easily on acyclic data. For cyclic data, the method can be extended in a way similar to cyclic counting algorithms (such as [5]). For a functional recursion, termination is often based on the monotonicity of certain arguments <ref> [6] </ref>. The partial evaluation method also contributes to the termination of chain-split evaluation which will be discussed in the next subsection. 3.3 Chain-split partial evaluation In the buffered chain-split evaluation, every intermediate value shared between the split portions of a chain is buffered. <p> The other constraints, "arrival = ottawa", and "F are 600", will be pushed during the query processing based on the constraint-pushing principles <ref> [6] </ref>. <p> Thus, S 0 = S + S i = S, and L 0 = append (L; L i ) = L. Furthermore, since S and length (L) are monotonic functions, they can be used in the determination of termination and constraint pushing <ref> [6] </ref>. When S &gt; 600, the continued search following this intermediate tuple will be hopeless and such intermediate tuple should be pruned from the intermediate result buffer. <p> Push the termination constraints into the chain for iterative chain evaluation <ref> [6] </ref>. 2 Remark 3.2 Algorithm 3.3 correctly incorporates query constraints and implements chain-split partial evaluation in the evaluation of compiled functional single-chain recursions. Rationale. Step 1 is necessary since a query must be finitely evaluable and terminate. <p> Step 3 is correct since if the chain-split evaluation is to be performed, partial evaluation should be explored. Step 4 is correct based on the study of constraint-based query processing in deductive databases <ref> [6] </ref>. 2 A similar algorithm can be derived for constraint-enforced chain-split partial evaluation of multi-chain recursions. 4 Chain-Split Evaluation of Complex Logic Programs Chain-split evaluation is not confined to (single) linear recursions. <p> Such an analysis demonstrates that chain-split evaluation, together with the chain-following evaluation, forms two primitive evaluation techniques 17 in the evaluation of different classes of recursions. Furthermore, the evaluation should be integrated with existence checking and constraint-based query evaluation techniques <ref> [6] </ref> to achieve high performance in the evaluation of sophisticated logic programs. To the best of our knowledge, no detailed study on chain-split evaluation was performed in previous deductive database research [4, 16, 21, 23, 22].
Reference: [7] <author> J. Han, L. Liu, and Z. Xie. LogicBase: </author> <title> A system prototype for deductive query evaluation. </title> <booktitle> In Proc. 1993 ILPS Workshop on Programming with Logic Databases, </booktitle> <pages> pages 146-160, </pages> <address> Vancouver, Canada, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: Similarly, chain-split evaluation should be performed on the recursion insert bbf . The evaluation of query "? isort ([5; 7; 1]; Y s):" proceeds as follows. The evaluation of (4.11) leads to "X = 5" (which is buffered) and "Xs = <ref> [7; 1] </ref>", and then a call "isort ([7; 1]; Zs)" which in turn leads to "X 0 = 7" (which is buffered) and "Xs 0 = [1]", and a call "isort ([1]; Zs 0 )". <p> The evaluation of this sequence of calls is performed as follows. First, "insert (1; []; Zs 0 )" results in "Zs 0 = [1]" since it can only execute (4.13). Second, "insert (7; [1]; Zs)" leads to "Zs = <ref> [1, 7] </ref>" since it executes (4.15) which in turn calls "insert (1; [7]; Zs)" and then executes the rule (4.15). Third, "insert (5; [1; 7]; Y s)" calls "insert (5; [7]; Zs); cons (1; Zs; Y s)". <p> First, "insert (1; []; Zs 0 )" results in "Zs 0 = [1]" since it can only execute (4.13). Second, "insert (7; [1]; Zs)" leads to "Zs = [1, 7]" since it executes (4.15) which in turn calls "insert (1; <ref> [7] </ref>; Zs)" and then executes the rule (4.15). Third, "insert (5; [1; 7]; Y s)" calls "insert (5; [7]; Zs); cons (1; Zs; Y s)". <p> Second, "insert (7; [1]; Zs)" leads to "Zs = [1, 7]" since it executes (4.15) which in turn calls "insert (1; [7]; Zs)" and then executes the rule (4.15). Third, "insert (5; <ref> [1; 7] </ref>; Y s)" calls "insert (5; [7]; Zs); cons (1; Zs; Y s)". This leads to the final answer, "Y s = [1; 5; 7]". 2 This example demonstrates that chain-split evaluation is a popular technique in the evaluation of nested linear recursions. <p> Second, "insert (7; [1]; Zs)" leads to "Zs = [1, 7]" since it executes (4.15) which in turn calls "insert (1; <ref> [7] </ref>; Zs)" and then executes the rule (4.15). Third, "insert (5; [1; 7]; Y s)" calls "insert (5; [7]; Zs); cons (1; Zs; Y s)". This leads to the final answer, "Y s = [1; 5; 7]". 2 This example demonstrates that chain-split evaluation is a popular technique in the evaluation of nested linear recursions. <p> Third, "insert (5; [1; 7]; Y s)" calls "insert (5; [7]; Zs); cons (1; Zs; Y s)". This leads to the final answer, "Y s = <ref> [1; 5; 7] </ref>". 2 This example demonstrates that chain-split evaluation is a popular technique in the evaluation of nested linear recursions. <p> We are currently implementing a sophisticated query analyzer and query evaluator as a part of the LogicBase project <ref> [7] </ref>. The LogicBase deductive database system consists of two major components: a rule compiler and a query evaluator.
Reference: [8] <author> J. Han and W. Lu. </author> <title> Asynchronous chain recursions. </title> <journal> IEEE Trans. Knowledge and Data Engineering, </journal> <volume> 1 </volume> <pages> 185-195, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction Most linear recursions and many other kinds of recursions encountered in practice can be compiled into highly regular chain forms <ref> [8, 9, 21] </ref>. Interesting recursive query evaluation techniques [2], such as transitive closure algorithms [10], magic sets and counting [1], can be applied to the efficient evaluation of compiled chains in deductive databases. <p> Recursive rules with complex variable connections can be normalized by a compilation process [9]. Normalization greatly facilitates systematic analysis of recursions on their binding propagation and other regularities. Previous studies <ref> [8, 9] </ref> show that a linear recursion can be compiled into a bounded recursion or an n-chain recursion, and many other kinds of recursions can also be compiled into chain forms. A compiled chain form can be viewed alternatively as one or a set of normalized recursions.
Reference: [9] <author> J. Han and K. Zeng. </author> <title> Automatic generation of compiled forms for linear recursions. </title> <journal> Information Systems, </journal> <volume> 17 </volume> <pages> 299-322, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction Most linear recursions and many other kinds of recursions encountered in practice can be compiled into highly regular chain forms <ref> [8, 9, 21] </ref>. Interesting recursive query evaluation techniques [2], such as transitive closure algorithms [10], magic sets and counting [1], can be applied to the efficient evaluation of compiled chains in deductive databases. <p> adopted here are similar to Datalog [21]. sg (X; Y ) parent (X; X 1 ); sg (X 1 ; Y 1 ); parent (Y; Y 1 ): (1.1) sg (X; Y ) sibling (X; Y ): (1.2) The recursion can be compiled into a highly regular compiled chain form <ref> [9] </ref> as shown in (1.3). 2 sg (X 0 ; Y 0 ) = [ 1 i=0 (parent i (X i1 ; X i ); sibling (X i ; Y i ); parent i (Y i1 ; Y i )); (1.3) where [ denotes disjunction, and parent i (X i1 ; <p> It is a single-chain recursion when n = 1, or a multi-chain recursion otherwise. A recursion is bounded if it is equivalent to a set of nonrecursive rules. A compiled n-chain recursion can be rewritten into the form of a normalized linear recursion <ref> [9] </ref>, which consists of a set of exit rules and one normalized recursive rule in the form of (1.4), where X i and Y i (for 1 i n) are variable vectors, and each c i (for 1 i n) is a chain predicate. <p> Recursive rules with complex variable connections can be normalized by a compilation process <ref> [9] </ref>. Normalization greatly facilitates systematic analysis of recursions on their binding propagation and other regularities. Previous studies [8, 9] show that a linear recursion can be compiled into a bounded recursion or an n-chain recursion, and many other kinds of recursions can also be compiled into chain forms. <p> Recursive rules with complex variable connections can be normalized by a compilation process [9]. Normalization greatly facilitates systematic analysis of recursions on their binding propagation and other regularities. Previous studies <ref> [8, 9] </ref> show that a linear recursion can be compiled into a bounded recursion or an n-chain recursion, and many other kinds of recursions can also be compiled into chain forms. A compiled chain form can be viewed alternatively as one or a set of normalized recursions. <p> and L 1 as the remaining of the resulting list. append ([]; L; L): (1.13) append ([XjL 1 ]; L 2 ; [XjL 3 ]) append (L 1 ; L 2 ; L 3 ): (1.14) The rule set can be rectified into f (1.15), (1.16)g and compiled into (1.17) <ref> [9] </ref>, where cons is the functional predicate for the list construction function "[]". Notice that the rectified rule set is also the normalized rule set for this recursion [9]. append (U; V; W ) U = []; V = W: (1.15) append (U; V; W ) append (U 1 ; V; <p> ; L 2 ; L 3 ): (1.14) The rule set can be rectified into f (1.15), (1.16)g and compiled into (1.17) <ref> [9] </ref>, where cons is the functional predicate for the list construction function "[]". Notice that the rectified rule set is also the normalized rule set for this recursion [9]. append (U; V; W ) U = []; V = W: (1.15) append (U; V; W ) append (U 1 ; V; W 1 ); cons (X 1 ; U 1 ; U ); cons (X 1 ; W 1 ; W ): (1.16) append (U; V; W ) = <p> According to <ref> [9] </ref>, the rectified rule set is in the normalized form, and its compiled form is (3.6), which consists of one chain with three connected predicates, flight, sum, and cons. travel (L; D; DT; A; AT; F ) flight (F no; D; DT; A; AT; F ); cons (F no; []; L): <p> []): (4.2) insert (X; []; [X]): (4.3) insert (X; [Y jY s]; [Y jZs]) X &gt; Y; insert (X; Y s; Zs): (4.4) insert (X; [Y jY s]; [X; Y jY s]) X Y: (4.5) It can be rectified into the following program in which every recursive rule is normalized <ref> [9] </ref>. isort (XXs; Y s) cons (X; Xs; XXs); insert (X; Zs; Y s); isort (Xs; Zs): (4.6) isort (XXs; Y s) XXs = []; Y s = []: (4.7) insert (X; Y Y s; Y Zs) Y Y s = []; cons (X; []; Y Zs): (4.8) insert (X; Y <p> The evaluation of query "? qsort ([4; 9; 5]; Y s):" proceeds as follows. * The evaluation of (4.26) leads to qsort ([4; 9; 5]; Y s) cons (4; <ref> [9; 5] </ref>; [4; 9; 5]); partition ([9; 5]; 4; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (4.31) * The evaluation of "partition ([9; 5]; 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; [5]; [9; 5]); 9 <p> The evaluation of query "? qsort (<ref> [4; 9; 5] </ref>; Y s):" proceeds as follows. * The evaluation of (4.26) leads to qsort ([4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (4.31) * The evaluation of "partition ([9; 5]; 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; [5]; [9; 5]); 9 &gt; 4; <p> cons (4; <ref> [9; 5] </ref>; [4; 9; 5]); partition ([9; 5]; 4; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (4.31) * The evaluation of "partition ([9; 5]; 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; [5]; [9; 5]); 9 &gt; 4; partition ([5]; 4; XLs; Bs); cons (9; Bs; XBs): (4.32) 16 * This leads to the evaluation of "partition bbff ([5]; 4; XLs; Bs)": partition ([5]; 4; XLs; Bs) cons (5; []; [5]); 5 &gt; 4; partition ([]; 4; XLs; Bs 0 ); cons (5; Bs <p> It in turn derives "XLs = []" and "Bs = [5]" in (4.33) and "XLs = []" and "XBs = <ref> [9; 5] </ref>" in (4.32). (4.31) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (4.34) * The evaluation of "qsort ([]; Ls)" <p> It in turn derives "XLs = []" and "Bs = [5]" in (4.33) and "XLs = []" and "XBs = <ref> [9; 5] </ref>" in (4.32). (4.31) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (4.34) * The evaluation of "qsort ([]; Ls)" applying the rule (4.27) derives "Ls = []", and the evaluation of qsort ([9; 5]; <p> It in turn derives "XLs = []" and "Bs = [5]" in (4.33) and "XLs = []" and "XBs = [9; 5]" in (4.32). (4.31) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; <ref> [4; 9; 5] </ref>); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (4.34) * The evaluation of "qsort ([]; Ls)" applying the rule (4.27) derives "Ls = []", and the evaluation of qsort ([9; 5]; Bs) leads <p> It in turn derives "XLs = []" and "Bs = [5]" in (4.33) and "XLs = []" and "XBs = <ref> [9; 5] </ref>" in (4.32). (4.31) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (4.34) * The evaluation of "qsort ([]; Ls)" applying the rule (4.27) derives "Ls = []", and the evaluation of qsort ([9; 5]; Bs) leads to "Bs = [5; 9]" by a similar <p> ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (4.34) * The evaluation of "qsort ([]; Ls)" applying the rule (4.27) derives "Ls = []", and the evaluation of qsort ([9; 5]; Bs) leads to "Bs = <ref> [5; 9] </ref>" by a similar process applying the rule (4.26). Finally, "cons (4; [5; 9]; [4; 5; 9]), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". 2 From this example, it is not difficult to see that chain-split is a primitive and frequently-applied evaluation <p> cons (4; Bs; XBs); append (Ls; XBs; Y s): (4.34) * The evaluation of "qsort ([]; Ls)" applying the rule (4.27) derives "Ls = []", and the evaluation of qsort ([9; 5]; Bs) leads to "Bs = <ref> [5; 9] </ref>" by a similar process applying the rule (4.26). Finally, "cons (4; [5; 9]; [4; 5; 9]), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". 2 From this example, it is not difficult to see that chain-split is a primitive and frequently-applied evaluation technique in the processing of many nonlinear recursions as well. <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". 2 From this example, it is not difficult to see that chain-split is a primitive and frequently-applied evaluation technique in the processing of many nonlinear recursions as well. <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". 2 From this example, it is not difficult to see that chain-split is a primitive and frequently-applied evaluation technique in the processing of many nonlinear recursions as well. <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". 2 From this example, it is not difficult to see that chain-split is a primitive and frequently-applied evaluation technique in the processing of many nonlinear recursions as well. <p> The LogicBase deductive database system consists of two major components: a rule compiler and a query evaluator. The former classifies different kinds of recursions and compiles linear and nested linear recursions into their normalized forms <ref> [9] </ref>; whereas the latter integrates chain-following, chain-split and constraint-based evaluation techniques in deductive query evaluation. A preliminary version of the LogicBase system has been implemented in the UNIX system using LEX, YACC and C, and has been successfully tested on many interesting recursions, such as append, travel, isort, nqueens, etc.
Reference: [10] <author> Y. E. Ioannidis and R. Ramakrishnan. </author> <title> Efficient transitive closure algorithms. </title> <booktitle> In Proc. 14th Int. Conf. Very Large Data Bases, </booktitle> <pages> pages 382-394, </pages> <address> Long Beach, CA, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Most linear recursions and many other kinds of recursions encountered in practice can be compiled into highly regular chain forms [8, 9, 21]. Interesting recursive query evaluation techniques [2], such as transitive closure algorithms <ref> [10] </ref>, magic sets and counting [1], can be applied to the efficient evaluation of compiled chains in deductive databases. However, it is interesting to observe that some recursions, especially many recursions containing function symbols, may often be evaluated appropriately by a different evaluation technique: chain-split evaluation. <p> A compiled chain form can be viewed alternatively as one or a set of normalized recursions. This study is focused on the chain-split evaluation of compiled or normalized recursions. 2 1.1 Chain-split for efficient evaluation Usually, a single-chain recursion is evaluated efficiently by a transitive closure algorithm <ref> [10] </ref>, and a multi-chain recursion by magic sets or counting [1, 2]. One may have wondered whether queries on multi-chain recursions can be evaluated efficiently by merging multiple chain generating paths into one and then applying transitive closure algorithms [11].
Reference: [11] <author> H. V. Jagadish, R. Agrawal, and L. Ness. </author> <title> A study of transitive closure as a recursion mechanism. </title> <booktitle> In Proc. 1987 ACM-SIGMOD Int. Conf. Management of Data, </booktitle> <pages> pages 331-344, </pages> <address> San Francisco, CA, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: One may have wondered whether queries on multi-chain recursions can be evaluated efficiently by merging multiple chain generating paths into one and then applying transitive closure algorithms <ref> [11] </ref>. However, since such multiple paths do not share variables, the merge of them implies iterative processing on the cross-product (s) of several relations, each corresponding to a path. It is terribly inefficient to perform iterative evaluation on the cross-product of two or more database relations [14].
Reference: [12] <author> R. Krishnamurthy, R. Ramakrishnan, and O. Shmueli. </author> <title> A framework for testing safety and effective computability of extended datalog. </title> <booktitle> In Proc. 1988 ACM-SIGMOD Int. Conf. Management of Data, </booktitle> <pages> pages 154-163, </pages> <address> Chicago, IL, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: For example, V = f (X 1 ; ; X k ) is transformed to f (X 1 ; ; X k ; V ). A similar transformation has also been discussed by other researchers <ref> [12, 15, 17] </ref>. 3 Since the transformation maps a functional logical rule to a function-free one, the analysis of a functional recursion can be performed in the framework of a function-free one. Notice that the transformation converts constructors to predicates.
Reference: [13] <author> R. Krishnamurthy and C. Zaniolo. </author> <title> Optimization in a logic based language for knowledge and data intensive applications. </title> <booktitle> In Extending Database Technology (EDBT'88) [Lecture Notes in Computer Science 303], </booktitle> <pages> pages 16-33, </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: In general, such a decision should be made based on the quantitative analysis of competitive query evaluation plans (such as chain-following vs. chain-split) based upon the size of potential intermediate relations, the available accessing paths, cost estimation functions and database statistics <ref> [13, 18] </ref>. The following quantitative measurements are introduced in our discussion. <p> This can be accomplished by a quantitative analysis of two expressions with the incorporation of the available accessing structures and database statistics, etc. <ref> [13] </ref>. 2 The heuristic indicates that it is easy to judge in some obvious cases whether a chain-split evaluation should be applied based on the join expansion ratio and the selectivity of the provided query constants. However, detailed quantitative analysis should be performed for most non-obvious cases. <p> However, detailed quantitative analysis should be performed for most non-obvious cases. Such an analysis is similar to the query plan generation and access path selection developed in the studies of relational and deductive query processing <ref> [21, 13] </ref>, which is not to be presented in detail in this study. 2.2 Finiteness-based chain-split In a compiled functional recursion, a chain generating path may contain functions or evaluable predicates defined on infinite domains.
Reference: [14] <author> J. F. Naughton. </author> <title> One-sided recursions. </title> <booktitle> In Proc. 6th ACM Symp. Principles of Database Systems, </booktitle> <pages> pages 340-348, </pages> <address> San Diego, CA, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: However, since such multiple paths do not share variables, the merge of them implies iterative processing on the cross-product (s) of several relations, each corresponding to a path. It is terribly inefficient to perform iterative evaluation on the cross-product of two or more database relations <ref> [14] </ref>. In contrast to merging multiple chains, one may split a chain into multiple chains in the evaluation. Such a split implies that an n-chain recursion will be evaluated by a more sophisticated (n + k)-chain (where k &gt; 0) evaluation technique.
Reference: [15] <author> R. Ramakrishnan, F. Bancilhon, and A. Silberschatz. </author> <title> Safety of recursive Horn clauses with infinite relations. </title> <booktitle> In Proc. 6th ACM Symp. Principles of Database Systems, </booktitle> <pages> pages 328-339, </pages> <address> San Diego, CA, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: For example, V = f (X 1 ; ; X k ) is transformed to f (X 1 ; ; X k ; V ). A similar transformation has also been discussed by other researchers <ref> [12, 15, 17] </ref>. 3 Since the transformation maps a functional logical rule to a function-free one, the analysis of a functional recursion can be performed in the framework of a function-free one. Notice that the transformation converts constructors to predicates.
Reference: [16] <author> R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> Coral control, relations and logic. </title> <booktitle> In Proc. 18th Int. Conf. Very Large Data Bases, </booktitle> <pages> pages 547-559., </pages> <address> Vancouver, Canada, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: Furthermore, the evaluation should be integrated with existence checking and constraint-based query evaluation techniques [6] to achieve high performance in the evaluation of sophisticated logic programs. To the best of our knowledge, no detailed study on chain-split evaluation was performed in previous deductive database research <ref> [4, 16, 21, 23, 22] </ref>. Many deductive database system projects, such as LDL [4], EKS-V1 [23], CORAL [16, 19], etc. have been focused on the evaluation of function-free recursions; whereas chain-split evaluation is frequently encountered in functional recursions, as demonstrated in this study. <p> To the best of our knowledge, no detailed study on chain-split evaluation was performed in previous deductive database research [4, 16, 21, 23, 22]. Many deductive database system projects, such as LDL [4], EKS-V1 [23], CORAL <ref> [16, 19] </ref>, etc. have been focused on the evaluation of function-free recursions; whereas chain-split evaluation is frequently encountered in functional recursions, as demonstrated in this study. <p> Many deductive database system projects, such as LDL [4], EKS-V1 [23], CORAL [16, 19], etc. have been focused on the evaluation of function-free recursions; whereas chain-split evaluation is frequently encountered in functional recursions, as demonstrated in this study. Recent studies <ref> [4, 16, 19] </ref> have extended the Datalog data model to handle function symbols to a limited extent, however, based on our knowledge, no chain-split evaluation has been performed in those projects.
Reference: [17] <author> Y. Sagiv. </author> <title> On testing effective computability of magic programs. </title> <booktitle> In Proc. of 2nd Int. Conf. on Deductive and Object-Oriented Databases, </booktitle> <pages> pages 244-262, </pages> <address> Munich, Germany, </address> <month> Dec. </month> <year> 1991. </year>
Reference-contexts: For example, V = f (X 1 ; ; X k ) is transformed to f (X 1 ; ; X k ; V ). A similar transformation has also been discussed by other researchers <ref> [12, 15, 17] </ref>. 3 Since the transformation maps a functional logical rule to a function-free one, the analysis of a functional recursion can be performed in the framework of a function-free one. Notice that the transformation converts constructors to predicates.
Reference: [18] <author> P. Selinger, D. Astrahan, D. Chamberlin, R. Lorie, and T. Price. </author> <title> Access path selection in a relational database management system. </title> <booktitle> In Proc. 1979 ACM-SIGMOD Int. Conf. Management of Data, </booktitle> <pages> pages 23-34, </pages> <address> Boston, MA, </address> <month> May </month> <year> 1979. </year>
Reference-contexts: In general, such a decision should be made based on the quantitative analysis of competitive query evaluation plans (such as chain-following vs. chain-split) based upon the size of potential intermediate relations, the available accessing paths, cost estimation functions and database statistics <ref> [13, 18] </ref>. The following quantitative measurements are introduced in our discussion.
Reference: [19] <author> D. Srivastava and R. Ramakrishnan. </author> <title> Pushing constraint selections. </title> <journal> Journal of Logic Programming, </journal> <volume> 16 </volume> <pages> 361-414, </pages> <year> 1993. </year>
Reference-contexts: To the best of our knowledge, no detailed study on chain-split evaluation was performed in previous deductive database research [4, 16, 21, 23, 22]. Many deductive database system projects, such as LDL [4], EKS-V1 [23], CORAL <ref> [16, 19] </ref>, etc. have been focused on the evaluation of function-free recursions; whereas chain-split evaluation is frequently encountered in functional recursions, as demonstrated in this study. <p> Many deductive database system projects, such as LDL [4], EKS-V1 [23], CORAL [16, 19], etc. have been focused on the evaluation of function-free recursions; whereas chain-split evaluation is frequently encountered in functional recursions, as demonstrated in this study. Recent studies <ref> [4, 16, 19] </ref> have extended the Datalog data model to handle function symbols to a limited extent, however, based on our knowledge, no chain-split evaluation has been performed in those projects.
Reference: [20] <author> L. Sterling and E. Shapiro. </author> <title> The Art of Prolog. </title> <publisher> The MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: Thus, the recursion at each level can be normalized independently, and query analysis can be performed on each normalized recursion. Example 4.1 The insertion sort recursion, isort, defined by the following program <ref> [20] </ref> is a nested linear recursion because the predicate insert in the body of the recursive rule (4.1) is in turn defined by a linear recursion. isort ([XjXs]; Y s) isort (Xs; Zs); insert (X; Zs; Y s): (4.1) isort ([]; []): (4.2) insert (X; []; [X]): (4.3) insert (X; [Y <p> Thus, it can still be called "chain-split evaluation". One such example is examined in this subsection. Example 4.2 The quick sort recursion, qsort, defined by the following program <ref> [20] </ref> is a nonlinear recursion because the recursive rule (4.16) is a nonlinear recursive rule. qsort ([XjXs]; Y s) partition (Xs; X; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); append (Ls; [XjBs]; Y s): (4.16) qsort ([]; []): (4.17) partition ([XjXs]; Y; [XjLs]; Bs) X Y; partition (Xs; Y; Ls;
Reference: [21] <author> J. D. Ullman. </author> <title> Principles of Database and Knowledge-Base Systems, </title> <journal> Vols. </journal> <volume> 1 & 2. </volume> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction Most linear recursions and many other kinds of recursions encountered in practice can be compiled into highly regular chain forms <ref> [8, 9, 21] </ref>. Interesting recursive query evaluation techniques [2], such as transitive closure algorithms [10], magic sets and counting [1], can be applied to the efficient evaluation of compiled chains in deductive databases. <p> However, it is interesting to observe that some recursions, especially many recursions containing function symbols, may often be evaluated appropriately by a different evaluation technique: chain-split evaluation. Like many researchers <ref> [2, 21] </ref>, we assume that a deductive database consists of three parts: (i) an extensional database (EDB) (a set of data relations), (ii) an intensional database (IDB) (a set of Horn-clause rules), and (iii) a set of integrity constraints (ICs). <p> Example 1.1 The rule set f (1.1), (1.2)g defines a popular function-free linear recursion, sg, which indicates that X and Y are same generation relatives if they are siblings or their parents are same generation relatives. The notations adopted here are similar to Datalog <ref> [21] </ref>. sg (X; Y ) parent (X; X 1 ); sg (X 1 ; Y 1 ); parent (Y; Y 1 ): (1.1) sg (X; Y ) sibling (X; Y ): (1.2) The recursion can be compiled into a highly regular compiled chain form [9] as shown in (1.3). 2 sg <p> The magic sets method encounters the same problem on this recursion. Since same country links two parent-predicates in the body of the recursive rule, the binding propagation merges all the nonrecursive predicates into one <ref> [21] </ref>, and the derivation of magic sets requires iterative computation on the cross-product-like relation, merged parents. <p> Such a relation cannot be represented by a finite EDB relation. Thus the evaluation of a functional predicate still relies on its corresponding function definition. To facilitate the compilation and analysis of logic programs, rules in different forms should be rectified <ref> [21] </ref>. <p> However, detailed quantitative analysis should be performed for most non-obvious cases. Such an analysis is similar to the query plan generation and access path selection developed in the studies of relational and deductive query processing <ref> [21, 13] </ref>, which is not to be presented in detail in this study. 2.2 Finiteness-based chain-split In a compiled functional recursion, a chain generating path may contain functions or evaluable predicates defined on infinite domains. <p> A finiteness constraint "X ! Y " over a predicate r implies that each value of attribute X corresponds to a finite set of Y values in r [6]. Finiteness constraint is strictly weaker than the functional dependency studied in database theory <ref> [21] </ref>. It holds trivially for all finite predicates. Since all the EDB relations are finite, all the arguments in EDB relations satisfy the finiteness constraint. <p> Since query constants may bind some infinite domains of variables to finite ones, the analysis of finite evalua-bility should incorporate query instantiation information. Similar to the notations used in the magic sets transformation <ref> [2, 21] </ref>, a superscript b or f is used to adorn a variable to indicate the variable being bound (finite) or free (infinite), and a string of b's and f's is used to adorn a predicate to indicate the bindings of its corresponding arguments. <p> With appropriate modifications, these methods are applicable to chain-split evaluation. 3.1 Efficiency-based chain-split magic sets evaluation Example 1.2 shows that undesirably large magic sets could be derived by strictly enforcing the binding propagation rules without consideration of the size of intermediate relations <ref> [21] </ref>. <p> Furthermore, the evaluation should be integrated with existence checking and constraint-based query evaluation techniques [6] to achieve high performance in the evaluation of sophisticated logic programs. To the best of our knowledge, no detailed study on chain-split evaluation was performed in previous deductive database research <ref> [4, 16, 21, 23, 22] </ref>. Many deductive database system projects, such as LDL [4], EKS-V1 [23], CORAL [16, 19], etc. have been focused on the evaluation of function-free recursions; whereas chain-split evaluation is frequently encountered in functional recursions, as demonstrated in this study.
Reference: [22] <author> J. Vaghani, K. Ramamohanarao, D. Kemp, Z. Somogyi, and P. Stuckey. </author> <title> An introduction to the ADITI deductive database system. </title> <journal> Australian Computer Journal, </journal> <volume> 23 </volume> <pages> 37-52, </pages> <year> 1991. </year>
Reference-contexts: Furthermore, the evaluation should be integrated with existence checking and constraint-based query evaluation techniques [6] to achieve high performance in the evaluation of sophisticated logic programs. To the best of our knowledge, no detailed study on chain-split evaluation was performed in previous deductive database research <ref> [4, 16, 21, 23, 22] </ref>. Many deductive database system projects, such as LDL [4], EKS-V1 [23], CORAL [16, 19], etc. have been focused on the evaluation of function-free recursions; whereas chain-split evaluation is frequently encountered in functional recursions, as demonstrated in this study.
Reference: [23] <author> L. Vieille, P. Bayer, V. Kuchenhoff, and A. Lefebvre. EKS-V1, </author> <title> a short overview. </title> <booktitle> In AAAI-90 Workshop on Knowledge Base Management Systems, </booktitle> <address> Boston, MA, </address> <month> July </month> <year> 1990. </year> <month> 19 </month>
Reference-contexts: Furthermore, the evaluation should be integrated with existence checking and constraint-based query evaluation techniques [6] to achieve high performance in the evaluation of sophisticated logic programs. To the best of our knowledge, no detailed study on chain-split evaluation was performed in previous deductive database research <ref> [4, 16, 21, 23, 22] </ref>. Many deductive database system projects, such as LDL [4], EKS-V1 [23], CORAL [16, 19], etc. have been focused on the evaluation of function-free recursions; whereas chain-split evaluation is frequently encountered in functional recursions, as demonstrated in this study. <p> To the best of our knowledge, no detailed study on chain-split evaluation was performed in previous deductive database research [4, 16, 21, 23, 22]. Many deductive database system projects, such as LDL [4], EKS-V1 <ref> [23] </ref>, CORAL [16, 19], etc. have been focused on the evaluation of function-free recursions; whereas chain-split evaluation is frequently encountered in functional recursions, as demonstrated in this study.
References-found: 23

