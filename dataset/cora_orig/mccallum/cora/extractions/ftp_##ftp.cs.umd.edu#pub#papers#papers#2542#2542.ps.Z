URL: ftp://ftp.cs.umd.edu/pub/papers/papers/2542/2542.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Title: A PACKAGING SYSTEM FOR HETEROGENEOUS EXECUTION ENVIRONMENTS  
Author: John R. Callahan James M. Purtilo 
Keyword: Stub generation, heterogeneous systems, configuration management, module interconnection language, interface extraction.  
Address: College Park, Maryland 20742  
Affiliation: Computer Science Department University of Maryland,  
Abstract: In many execution environments software components cannot interoperate easily because of differences in their interfaces and implementations. Additional software is often required to integrate such components and implement the interfacing decisions between them. For example, a procedure call across architectures may require extensive software to relocate data and coerce parameters. Even when powerful integration facilities are available, application programs need some additional software | often called `stubs' | so they can access the available communication media. Interface software can be more expensive to program that other software, since its creation requires knowledge of the machine architectures and communication mechanisms. Moreover, it must be rewritten whenever components are reused in different configurations. This paper describes a way to automatically generate custom interface software for heterogeneous configurations. Whereas previous research focused on `stub generation' alone, our approach generates stubs as well as the configuration methods needed to integrate an application. Using this approach, developers may build support tools that hide the details of how software configurations are `packaged' into executables. This approach is implemented within the Unix environment in a system called Polygen, which we have used for evaluation and demonstration. This research is sponsored by Office of Naval Research under contract N0014-90-J4091. The results are currently being applied to prototyping problems in a project is supported by the DARPA/ISTO Common Prototyping Language initiative, in collaboration with Honeywell Sys- tems and Research Center. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Allen and S. Lee. </author> <title> A Knowledge-Based Environment for the Development of Software Parts Composition Systems. </title> <booktitle> Proceedings of the IEEE 11th International Conference on Software Engineering (May 1989), </booktitle> <pages> pp. 104-112. </pages>
Reference-contexts: Also, the Conic [10] and Durra [2] projects have recently addressed the same problems as Polylith with a similar "toolkit" approach, but without the aid of composition abstractions like the software bus. A number of rule-based software composition models have been constructed for specific programming languages and environments <ref> [1] </ref>. They establish rules for composing objects and producing the infrastructure needed to construct applications in particular environments. The XCON-in-RIME project [16], for example, also addresses software reuse problems by describing components and composition methods using assertions and rules.
Reference: [2] <author> M. Barbacci, D. Doubleday, C. Weinstock and J. Wing. </author> <title> Developing Applications for Heterogeneous Mechina Networks: The Durra Environment. </title> <booktitle> USENIX Computing Systems, </booktitle> <volume> vol. 2, </volume> <year> (1989), </year> <pages> pp. 7-35. </pages>
Reference-contexts: The Inscape project [11] is an alternate MIL approach, which primarily focuses on the semantics of module composition processes. Also, the Conic [10] and Durra <ref> [2] </ref> projects have recently addressed the same problems as Polylith with a similar "toolkit" approach, but without the aid of composition abstractions like the software bus. A number of rule-based software composition models have been constructed for specific programming languages and environments [1].
Reference: [3] <author> B. Bershad. </author> <title> High Performance Cross-Address Space Communication. </title> <type> Ph.D. Dissertation, </type> <institution> University of Washington, Seattle, </institution> <type> Technical Report 06-02, </type> <year> (1990). </year>
Reference-contexts: As an alternative to static generation of stubs, some projects have designed efficient remote evaluation mechanisms for heterogeneous applications. Distributed applications gain substantial performance improvements through the use of customized interface mechanisms like RPC or REV stubs <ref> [3, 14, 17, 6] </ref>. Stubs in these projects are often handwritten or rewritten from those generated automatically because their performance is critical in many systems and their design if often dependent upon the context of use in a configuration.
Reference: [4] <author> B. Bershad, D. Ching, E. Lazowska, J. Sanislo and M. Schwartz. </author> <title> A Remote Procedure Call Facility for Interconnecting Heterogeneous Computer Systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 13, </volume> <month> (August </month> <year> 1987), </year> <pages> pp. 880-894. </pages>
Reference-contexts: The Matchmaker [9], Courier [21], SunRPC [19], and XDR [18] RPC compilers, for example, are stub generators. Such compilers must be ported manually in some cases to handle environment-specific details. The HRPC <ref> [4] </ref> and HORUS RPC compilers [8] are notable exceptions. The HORUS stub generator is parameterized with system and language schema files, while the HRPC project extends this parameterization to include RPC protocols. The Interface Description Language (IDL) [15] project also implements a stub generator.
Reference: [5] <author> F. DeRemer and H. Kron. </author> <title> Programming-in-the-Large Versus Programming-in-theSmall. </title> <journal> IEEE Trans on Software Engineering, </journal> <volume> vol. 2, </volume> <month> (June </month> <year> 1976), </year> <pages> pp. 80-86. </pages>
Reference-contexts: One way to increase the potential for software reuse is to limit the growth of dependencies between components. For example, module interconnection languages (MILs) have been effective in managing structural dependencies, i.e., those concerning visibility or compatibility of variables and interface names <ref> [5] </ref>. However, the availability of heterogeneous systems increases the likelihood for geometric coupling, which are dependencies due to the relation between components and where they execute in the underlying architecture.
Reference: [6] <author> J. Falcone. </author> <title> A Programmable Interface Language for Heterogeneous Distributed Systems, </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> vol. 5, </volume> <month> (November </month> <year> 1987), </year> <pages> pp. 330-351. </pages>
Reference-contexts: As an alternative to static generation of stubs, some projects have designed efficient remote evaluation mechanisms for heterogeneous applications. Distributed applications gain substantial performance improvements through the use of customized interface mechanisms like RPC or REV stubs <ref> [3, 14, 17, 6] </ref>. Stubs in these projects are often handwritten or rewritten from those generated automatically because their performance is critical in many systems and their design if often dependent upon the context of use in a configuration.
Reference: [7] <author> S. Feldman. </author> <title> Make: A Program for Maintaining Computer Programs, UNIX Programmer's Manual, </title> <booktitle> USENIX, </booktitle> <year> (1984). </year>
Reference-contexts: Programmers also need assistance with more than just the generation of stubs themselves. Each desired configuration requires different communication mechanisms and integration strategies. Once the stubs have been generated and the commands needed to integrate the new files have been enumerated, tools such as makefiles <ref> [7] </ref> can help programmers obtain executables reliably | the problem is identifying the program units and generating the appropriate commands (e.g., generating the makefile for mixed language programs) in the first place. This can be a tedious task that no programmer is interested in performing manually. <p> In our execution environment (a UNIX environment on a local area network), these correspond to the source files, stubs, and commands needed to build executable objects. The commands are part of a configuration program | a UNIX makefile <ref> [7] </ref>. It is produced by the package tool along with the interface descriptions. We wish to create an executable application given the code shown in Figure 1.
Reference: [8] <author> P. Gibbons. </author> <title> A Stub Generator for Multilanguage RPC in Heterogeneous Environments. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 13, </volume> <month> (January </month> <year> 1987), </year> <pages> pp. 7787. </pages>
Reference-contexts: The Matchmaker [9], Courier [21], SunRPC [19], and XDR [18] RPC compilers, for example, are stub generators. Such compilers must be ported manually in some cases to handle environment-specific details. The HRPC [4] and HORUS RPC compilers <ref> [8] </ref> are notable exceptions. The HORUS stub generator is parameterized with system and language schema files, while the HRPC project extends this parameterization to include RPC protocols. The Interface Description Language (IDL) [15] project also implements a stub generator.
Reference: [9] <author> J. Jones, R. Rashid, and M. Thompson. Matchmaker: </author> <title> An Interface Specification Language for distributed processing. </title> <booktitle> Proceedings of the 12th ACM Symposium on Principles of Programming Languages, </booktitle> <month> (January </month> <year> 1985), </year> <pages> pp. 225-235. </pages>
Reference-contexts: The Matchmaker <ref> [9] </ref>, Courier [21], SunRPC [19], and XDR [18] RPC compilers, for example, are stub generators. Such compilers must be ported manually in some cases to handle environment-specific details. The HRPC [4] and HORUS RPC compilers [8] are notable exceptions.
Reference: [10] <author> J. Magee, J. Kramer and M. Sloman. </author> <title> Constructing Distributed Systems in Conic, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 15, </volume> <month> (June </month> <year> 1989), </year> <pages> pp. 663-675. </pages>
Reference-contexts: This is the particular communication system we have chosen to generate stubs for within Polygen, since Polylith simplifies many of the data coercion and relocation requirements. The Inscape project [11] is an alternate MIL approach, which primarily focuses on the semantics of module composition processes. Also, the Conic <ref> [10] </ref> and Durra [2] projects have recently addressed the same problems as Polylith with a similar "toolkit" approach, but without the aid of composition abstractions like the software bus. A number of rule-based software composition models have been constructed for specific programming languages and environments [1].
Reference: [11] <author> D. Perry. </author> <title> The Inscape Environment. </title> <booktitle> Proceedings of the IEEE 11th International Conference on Software Engineering, </booktitle> <month> (May </month> <year> 1989), </year> <pages> pp. 2-12. </pages>
Reference-contexts: This is the particular communication system we have chosen to generate stubs for within Polygen, since Polylith simplifies many of the data coercion and relocation requirements. The Inscape project <ref> [11] </ref> is an alternate MIL approach, which primarily focuses on the semantics of module composition processes. Also, the Conic [10] and Durra [2] projects have recently addressed the same problems as Polylith with a similar "toolkit" approach, but without the aid of composition abstractions like the software bus.
Reference: [12] <author> J. Purtilo and J. Callahan. </author> <title> Parse Tree Annotations, </title> <journal> Communications of the ACM, </journal> <volume> vol. 32, </volume> <month> (December </month> <year> 1989), </year> <pages> pp. 1467-1477. </pages>
Reference-contexts: An extraction tool transforms source code into abstract structural descriptions, a collection of assertions about the properties and interfaces of a module. This signature can be created automatically by compilers, parsing tools <ref> [12] </ref>, or manually in cases where extraction tools are unavailable. In Polygen, the scan tool is used to extract such information from source modules.
Reference: [13] <author> J. Purtilo. </author> <title> The Polylith Software Bus. </title> <note> University of Maryland CSD Technical Report 2469, (1990). Submitted for publication. </note>
Reference-contexts: Polygen also relies upon technology from the module interconnection language community. In the past, MIL projects have focused primarily upon issues of interface and module compatibility. More recently, the Polylith system showed how MILs could be employed to control communication issues in a distributed network <ref> [13] </ref>. Polylith introduced a software bus organization to encapsulate interfacing decisions, and, in this way, software components that do not interface directly can interoperate efficiently. <p> NULL, NULL, &r); return r; g ======================= (defun mh-dispatcher () (do* ( (message (mh-readselect) (mh-readselect)) (interface (car message) (car message)) ) (nil 'neverreturned) (cond ((equal interface ``lookup'') (mh-write ``lookup'' (lookup (car (cadr message))) ) (t (mh-error message)) ) ) (mh-initialize) (mh-dispatcher) terconnection system for its communication and mixed-language programming requirements <ref> [13] </ref>. However, our inference capability is not limited to only Polylith. Polygen can generate packages for other execution environments if the compatibility rules and methods for them are expressed to our inference engine. <p> Hence, Polygen users may base their design decisions (in the composition phase) upon a single type system (the Polylith 11 MIL), using techniques described in <ref> [13] </ref>. An ability to transmit abstract data types across Polygen-created interfaces is similarly dependent upon what interconnection rules to characterize compatibility have been installed in the underlying inference engine. 4 THE PARTITIONING METHOD A package depends upon the integration capabilities of an environment.
Reference: [14] <author> M. Schroeder and M. Burrows. </author> <title> Performance of the Firefly RPC, </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> vol. 16, </volume> <month> (February </month> <year> 1990), </year> <pages> pp. 1-17. 17 </pages>
Reference-contexts: As an alternative to static generation of stubs, some projects have designed efficient remote evaluation mechanisms for heterogeneous applications. Distributed applications gain substantial performance improvements through the use of customized interface mechanisms like RPC or REV stubs <ref> [3, 14, 17, 6] </ref>. Stubs in these projects are often handwritten or rewritten from those generated automatically because their performance is critical in many systems and their design if often dependent upon the context of use in a configuration.
Reference: [15] <author> R. Snodgrass. </author> <title> The Interface Description Language, </title> <publisher> Computer Science Press, </publisher> <year> (1989). </year>
Reference-contexts: The HRPC [4] and HORUS RPC compilers [8] are notable exceptions. The HORUS stub generator is parameterized with system and language schema files, while the HRPC project extends this parameterization to include RPC protocols. The Interface Description Language (IDL) <ref> [15] </ref> project also implements a stub generator. In all cases, integration of stubs, source components, and existing servers is left to the designer. As an alternative to static generation of stubs, some projects have designed efficient remote evaluation mechanisms for heterogeneous applications.
Reference: [16] <author> E. Soloway, J. Bachant and K. Jensen. </author> <title> Assessing the Maintainability of XCON-inRIME: Coping with the Problems of a Very Large Rule Base. </title> <booktitle> Proceedings of the National Conference on Artificial Intelligence, </booktitle> <month> (July </month> <year> 1987). </year>
Reference-contexts: A number of rule-based software composition models have been constructed for specific programming languages and environments [1]. They establish rules for composing objects and producing the infrastructure needed to construct applications in particular environments. The XCON-in-RIME project <ref> [16] </ref>, for example, also addresses software reuse problems by describing components and composition methods using assertions and rules.
Reference: [17] <author> J. Stamos and D. Gifford. </author> <title> Implementing Remote Evaluation, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 16, </volume> <month> (July </month> <year> 1990), </year> <pages> pp. 710-722. </pages>
Reference-contexts: As an alternative to static generation of stubs, some projects have designed efficient remote evaluation mechanisms for heterogeneous applications. Distributed applications gain substantial performance improvements through the use of customized interface mechanisms like RPC or REV stubs <ref> [3, 14, 17, 6] </ref>. Stubs in these projects are often handwritten or rewritten from those generated automatically because their performance is critical in many systems and their design if often dependent upon the context of use in a configuration.
Reference: [18] <author> Sun Microsystems, </author> <title> External Data Representation Reference Manual, Sun Microsystems, </title> <month> (January </month> <year> 1985). </year>
Reference-contexts: The Matchmaker [9], Courier [21], SunRPC [19], and XDR <ref> [18] </ref> RPC compilers, for example, are stub generators. Such compilers must be ported manually in some cases to handle environment-specific details. The HRPC [4] and HORUS RPC compilers [8] are notable exceptions.
Reference: [19] <author> Sun Microsystems, </author> <title> Remote Procedure Call Protocol Specification, Sun Microsystems, </title> <month> (January </month> <year> 1985). </year>
Reference-contexts: The Matchmaker [9], Courier [21], SunRPC <ref> [19] </ref>, and XDR [18] RPC compilers, for example, are stub generators. Such compilers must be ported manually in some cases to handle environment-specific details. The HRPC [4] and HORUS RPC compilers [8] are notable exceptions.
Reference: [20] <author> M. Tiemann. </author> <title> Solving the RPC Problem in GNU C++, </title> <booktitle> Proceedings of the 1988 USENIX C++ Conference, </booktitle> <year> (1988), </year> <pages> pp. 343-361. </pages>
Reference: [21] <institution> Xerox Special Information Systems, </institution> <month> Courier: </month> <title> The Remote Procedure Call Protocol, </title> <institution> Xerox Corporation, </institution> <year> (1981). </year> <title> ACKNOWLEDGEMENTS We are grateful to John Gannon, Dewayne Perry and Marv Zelkowitz for their many helpful comments and suggestions concerning both our packaging system itself and this paper concerning it. Thanks to the hearty users | in particular, Jorma Taramaa | who bravely tried predecessors of Polygen and, through their suffering, inspired us to construct a packager that really works. </title> <type> 18 </type>
Reference-contexts: The Matchmaker [9], Courier <ref> [21] </ref>, SunRPC [19], and XDR [18] RPC compilers, for example, are stub generators. Such compilers must be ported manually in some cases to handle environment-specific details. The HRPC [4] and HORUS RPC compilers [8] are notable exceptions.
References-found: 21

