URL: ftp://ic.eecs.berkeley.edu/pub/Memos_ERL/erl94-12.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu/~vigyan/publications/index.html
Root-URL: http://www.cs.berkeley.edu
Title: Edge-Streett/Edge-Rabin Automata Environment for Formal Verification Using Language Containment  
Author: Ramin Hojati Vigyan Singhal and Robert K. Brayton 
Address: Berkeley, CA 94720, USA  
Affiliation: Department of Electrical Engineering and Computer Sciences University of California,  
Abstract: We present the edge-Streett/edge-Rabin environment for doing verification using language containment. This environment has a number of desirable properties compared with the L-process/L-automaton environment ([Kur87b]), which is a practical language-containment-based formal verification environ ment: * It contains the L-environment as a subset. * It can be exponentially more compact than the L-environment. * We present BDD-based algorithms for main verification functions in this environment, and argue that they are efficient. Furthermore, if the specifications come from the L-environment, our algorithms reduce to the algorithms of [HTKB92] and [HBK93] for the L-environment. * It is in some sense maximal, i.e. language containment check for the next natural extension to our environment is NP-complete (as opposed to polynomial). We have implemented our algorithms in our verification tool, and will present a flexible user interface to this environment.
Abstract-found: 1
Intro-found: 1
Reference: [BHMSV84] <author> R.K. Brayton, G.D. Hachtel, C.T. McMullen, and A.L. Sangiovanni-Vincentelli. </author> <title> Logic Minimization Algorithms for VLSI Synthesis. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1984. </year> <month> 18 </month>
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference: [EL85] <author> E.A. Emerson and C.L. Lei. </author> <title> Modalities for Model Checking: Branching Time Strikes Back. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 84-96, </pages> <year> 1985. </year>
Reference-contexts: First, note that sum of a set of F 1 (S i )'s is just equivalent to F 1 ( S i (S i )). So, only one F 1 suffices. It remains to ask whether allowing more G 1 's will sacrifice the efficiency. <ref> [EL85] </ref> basically answered this question (they were looking at a slightly different problem). Theorem 3.2 The problem of determining whether the language of an automaton with acceptance conditions of the form Q i (G 1 (S i ) + G 1 (T i )) is empty, is NP-complete. <p> Just guess this set of states, and check that this set is contained in S i or T i for all i. To prove the problem is NP-complete, just use the reduction of <ref> [EL85] </ref> to show the fair state problem with fairness constraints of the above type is NP-complete. [EL85] reduces 3SAT to a graph with fairness constraints of above type. Now, the language of the automaton is non-empty iff the original formula was satisfiable. <p> Just guess this set of states, and check that this set is contained in S i or T i for all i. To prove the problem is NP-complete, just use the reduction of <ref> [EL85] </ref> to show the fair state problem with fairness constraints of the above type is NP-complete. [EL85] reduces 3SAT to a graph with fairness constraints of above type. Now, the language of the automaton is non-empty iff the original formula was satisfiable. Note that the language emptiness check for Streett automata is done in (small) polynomial-time. <p> Hence, the proof by contradiction. Remark <ref> [EL85] </ref> provides a practical example of when strong fairness constraints are needed. We now show that edge-Streett automata specifications contain L-process specifications.
Reference: [HBK93] <author> R. Hojati, R.K. Brayton, and R.P. Kurshan. </author> <title> BDD-Based Debugging of Design Using Language Containment and Fair CTL. </title> <booktitle> In Proceedings of the Conference on Computer-Aided Verification, </booktitle> <address> Elounda, Crete, Greece, </address> <month> June </month> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: Based on this paradigm, the first software tool for automatic verification of finite-state systems using language containment was built ([HK90]). The advent of BDD's allows for handling of very large state spaces. [HTKB92] and <ref> [HBK93] </ref> gave various efficient BDD-based algorithms for language containment and debugging in the L-environment. In this paper, we introduce a new language containment based formal verification environment. The system is modeled using what we call edge-Streett automata, whereas the properties are modeled using edge-Rabin automata. <p> Edge-Streett and edge-Rabin automata have complementary acceptance conditions. Hence, the complementation task remains trivial for deterministic edge-Rabin automata. We present efficient BDD-based algorithms for language containment and debugging in the RS-environment which are extensions of the algorithms for the L-environment presented in [HTKB92] and <ref> [HBK93] </ref>. The RS-environment has several desirable features: * It contains the L-environment as a subset. Moreover, all algorithms are designed in a manner, so that if the specifications are from the L-environment, the algorithms reduce to their counter-parts in the L-environment. <p> each with polynomial number of states in n and h and polynomial cycle sets in n and h, such that s is polynomial in n and h and L (R) = T s 4 Computations in Edge-Streett/Edge-Rabin Environment In this section, we show how to generalize computations of [HTKB92] and <ref> [HBK93] </ref>, which are BDD-based algorithms for the L-environment, to the RS-environment. All algorithms have the very desirable characteristics that if the specifications are from the L-environment, the computations are the same as [HTKB92] and [HBK93]'s. If not, the computations still remain efficient. <p> Proof: Similar to the proof for Theorem 4.2. 4.3 Debugging In this section, we generalize the techniques of <ref> [HBK93] </ref> for debugging in the L-environment. The problem is to find a "good" debug trace, i.e a string accepted by an edge-Streett automaton, which is short. A debug trace consists of a path to a fair cycle, and the fair cycle itself. <p> A debug trace consists of a path to a fair cycle, and the fair cycle itself. We would like to minimize both the path and the cycle. We assume that a set of states containing some fair state is passed to the debugger. <ref> [HBK93] </ref> presents techniques which guarantee the path to the fair cycle is minimum if a set containing all fair states is passed to the debugger. <p> Given the set T passed to the debugger, we start with the set of initial states, and do a breadth-first search until some state x 2 T is encountered. If the strongly-connected component containing x (denoted by SCC (x), and computed as in <ref> [HBK93] </ref>) is fair, we are done. Otherwise we take out SCC (x) from T and continue the search. The algorithm can be summarized as follows: 0. Let T be the set passed to the debugger. 1. <p> Set frontier set and cur reached to the intersection of cur T and the set of states reachable from cur reached in one step. Return to step 2. The check for a fair SCC is more complicated than that of <ref> [HBK93] </ref>, and will be described below. The idea is to check, for each CFC F 1 (S i ) + G 1 (T i ), whether the SCC W intersects S i . If not, we restrict W to T i and continue until all CFC's can be satisfied. <p> Hence, we can restrict our attention to S i 's of active ones. Now, we need to find a short cycle which visits a state in each S i . The algorithm of <ref> [HBK93] </ref> finds a fair cycle, when the fairness constraints are of the form Q F 1 (S i ). <p> Our algorithm will return the cycle (1; 2), whereas the cycle consisting of the self-loop on 1 is a shorter fair cycle. Also, the positive edge constraints may not be satisfied by the solution returned by the algorithm of <ref> [HBK93] </ref>. To satisfy a given positive edge constraint (consisting of the set of edges E i (x; y)), if C = (c 0 ; : : : ; c m1 ) is the fair cycle returned by [HBK93]'s algorithm, we look for a closest state c j in C to the <p> We repeat this process for all positive edge constraints. 14 The algorithm to find a fair cycle is, thus, summarized as: 1. Take all the active F 1 (S i ) + G 1 (T i )'s. 2. Find a cycle by calling algorithms of <ref> [HBK93] </ref> on S i 's of active F 1 (S i ) + G 1 (T i )'s. 3. Keep patching the cycle with respect to each positive edge constraint until all such constraints are satisfied. 4.4 Hierarchical Development We look at the design process as a hierarchical activity.
Reference: [HK90] <author> Z. Har'El and R.P. Kurshan. </author> <title> Software for Analytical Development of Communication Protocols. </title> <journal> AT&T Technical Journal, </journal> <pages> pages 45-59, </pages> <month> January </month> <year> 1990. </year>
Reference: [HTKB92] <author> R. Hojati, H. Touati, R.P. Kurshan, and R.K. Brayton. </author> <title> Efficient !-Regular Language Containment. </title> <booktitle> In Proceedings of the Fourth Workshop on Computer-Aided Verification, </booktitle> <pages> pages 371-382, </pages> <address> Montreal, Quebec, Canada, </address> <year> 1992. </year>
Reference-contexts: Based on this paradigm, the first software tool for automatic verification of finite-state systems using language containment was built ([HK90]). The advent of BDD's allows for handling of very large state spaces. <ref> [HTKB92] </ref> and [HBK93] gave various efficient BDD-based algorithms for language containment and debugging in the L-environment. In this paper, we introduce a new language containment based formal verification environment. The system is modeled using what we call edge-Streett automata, whereas the properties are modeled using edge-Rabin automata. <p> Edge-Streett and edge-Rabin automata have complementary acceptance conditions. Hence, the complementation task remains trivial for deterministic edge-Rabin automata. We present efficient BDD-based algorithms for language containment and debugging in the RS-environment which are extensions of the algorithms for the L-environment presented in <ref> [HTKB92] </ref> and [HBK93]. The RS-environment has several desirable features: * It contains the L-environment as a subset. Moreover, all algorithms are designed in a manner, so that if the specifications are from the L-environment, the algorithms reduce to their counter-parts in the L-environment. <p> s , each with polynomial number of states in n and h and polynomial cycle sets in n and h, such that s is polynomial in n and h and L (R) = T s 4 Computations in Edge-Streett/Edge-Rabin Environment In this section, we show how to generalize computations of <ref> [HTKB92] </ref> and [HBK93], which are BDD-based algorithms for the L-environment, to the RS-environment. All algorithms have the very desirable characteristics that if the specifications are from the L-environment, the computations are the same as [HTKB92] and [HBK93]'s. If not, the computations still remain efficient. <p> s 4 Computations in Edge-Streett/Edge-Rabin Environment In this section, we show how to generalize computations of <ref> [HTKB92] </ref> and [HBK93], which are BDD-based algorithms for the L-environment, to the RS-environment. All algorithms have the very desirable characteristics that if the specifications are from the L-environment, the computations are the same as [HTKB92] and [HBK93]'s. If not, the computations still remain efficient. In other words, if we don't use the extra power, we don't pay for it; if we do, the price is small. 4.1 Language Emptiness for Edge-Streett Automata This is the main verification computation. <p> The system is given in terms of edge-Streett automata. The property is given in terms of a deterministic edge-Rabin automaton. The edge-Rabin automaton can be easily and efficiently complemented into an edge-Streett automaton. Then, the language containment check reduces to checking emptiness of the combined edge-Streett automata. <ref> [HTKB92] </ref> presented several algorithms for this task in the L-environment. In this paper, we concentrate on their most efficient algorithm and generalize it to the RS-environment. This algorithm depended on several graph operators. We present generalization of each one of these to the case of edge-Streett automata. <p> We assume that the negative fair edges have been removed, and all sets are restricted to the set of reachable 9 states. The task is reduced to finding a fair path in the automaton, (called a bad path in <ref> [HTKB92] </ref>). By following this path, we obtain a string which is accepted by the automaton. This means the language of the automaton is not empty, and hence can act as a counter-example, which is reported to the user. 1. The forward stable set operator. <p> For each set of positive edges f (a i ; b i ); : : : ; (a k ; b k )g, if P P b i can only reach itself, let S = S " ( P P g The final algorithm of <ref> [HTKB92] </ref> consisted of an initial check for easy failures, and then some main computation. The main part of the algorithm remains unchanged, i.e. Start with reachable states. Repeat until convergence: 1. Apply forward bad-path. 2. Apply forward stable set. 3. Apply backward bad-path. 4. Apply backward stable set. <p> Hence, fl is fair. But this is a contradiction to x not being able to reach any fair cycles. 11 Theorem 4.2 When the system is described by an L-process and the property by an L-automaton, then above computation reduces to that of <ref> [HTKB92] </ref>. Proof: This is immediate by noticing, 1. T i = , for all T i in G 1 (T i ) + F 1 (S i ), and S i 's are the complement of cycle sets. 2. There are no positive edge constraints. <p> In our environment, a failure translates into an !-string accepted by an edge-Streett automaton. Again, assume we are given the automaton with negative fair edges removed. Following the same basic hierarchy as <ref> [HTKB92] </ref>, we define the following cycles: 1. Cycles of the first kind. These are cycles contained either in T T i (T i ), and satisfying the positive edge constraints. 2. Cycles of the second kind. <p> However, because there are no cycles of first or second kind, there cannot be any fair cycles involving states in T 12 Theorem 4.4 In case our specification is an L-environment specification, early failure detection reduces to that of <ref> [HTKB92] </ref>. Proof: Similar to the proof for Theorem 4.2. 4.3 Debugging In this section, we generalize the techniques of [HBK93] for debugging in the L-environment. The problem is to find a "good" debug trace, i.e a string accepted by an edge-Streett automaton, which is short.
Reference: [Kur87a] <author> R.P. Kurshan. </author> <title> Complementing Deterministic Buchi Automata in Polynomial Time. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 35 </volume> <pages> 59-71, </pages> <year> 1987. </year>
Reference-contexts: Remark One can translate the edge-Streett (edge-Rabin) automata into Streett (Rabin) automata, which are automata with all fairness constraints expressed as CFC's, with a factor of 2 blow-up in the state space size. The transformation is known as the node-recur transform, and was first described in <ref> [Kur87a] </ref>. Theorem 3.1 For every deterministic edge-Rabin automaton R, there is an edge-Streett automaton S, which accepts the complement of the language of R and has at most the same number of fairness constraints.
Reference: [Kur87b] <author> R.P. Kurshan. </author> <title> Reducibility in Analysis of Coordination. In Discrete Event Systems: Models and Applications, </title> <booktitle> volume 103 of LNCIS, </booktitle> <pages> pages 19-39. </pages> <publisher> Springer Verlag, </publisher> <year> 1987. </year>
Reference-contexts: However, complementing an !-automaton is a PSPACE-complete problem, and the best known algorithms have exponential complexity ([SVW87], [Saf89]). The contribution of <ref> [Kur87b] </ref> was to introduce an environment, where the acceptance conditions of the system and the property are complementary. The system is modeled by an L-process, whereas the property is modeled by a deterministic L-automaton.
Reference: [Kur93] <author> R.P. Kurshan. </author> <title> Automata-Theoretic Verification of Coordinating Processes. </title> <publisher> Princeton University Press, </publisher> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: This means that language of the lower level implementation must be contained in the language of the higher level specification. Since systems are specified using edge-Streett automata, this means that we need to check language containment between two edge-Streett automata. <ref> [Kur93] </ref> presents an algorithm for language containment of two L-processes (this comes up in the environment described in [Kur93] because of application of homomorphic reductions). We present an algorithm with the same flavor for our problem. Assume two edge-Streett automata S 1 and S 2 are given. <p> Since systems are specified using edge-Streett automata, this means that we need to check language containment between two edge-Streett automata. <ref> [Kur93] </ref> presents an algorithm for language containment of two L-processes (this comes up in the environment described in [Kur93] because of application of homomorphic reductions). We present an algorithm with the same flavor for our problem. Assume two edge-Streett automata S 1 and S 2 are given. We assume that S 2 is deterministic.
Reference: [Rab72] <author> M.O. Rabin. </author> <title> Automata on Infinite Objects and Church's Problem, </title> <booktitle> volume 13 of Regional Conference Series in Mathematics. </booktitle> <publisher> American Mathematical Society, </publisher> <address> Providence, Rhode Island, </address> <year> 1972. </year>
Reference: [Saf89] <author> Shmuel Safra. </author> <title> Complexity of Automata on Infinite Objects. </title> <type> PhD thesis, </type> <institution> The Weizmann Institute of Science, Rehovot, Israel, </institution> <month> March </month> <year> 1989. </year>
Reference-contexts: However, complementing an !-automaton is a PSPACE-complete problem, and the best known algorithms have exponential complexity ([SVW87], <ref> [Saf89] </ref>). The contribution of [Kur87b] was to introduce an environment, where the acceptance conditions of the system and the property are complementary. The system is modeled by an L-process, whereas the property is modeled by a deterministic L-automaton. <p> However, it has been shown in <ref> [Saf89] </ref> that conversion of a deterministic Rabin automaton to a deterministic Muller automaton incurs a blow-up, the lower bound of which is exponential.
Reference: [Saf92] <author> S. Safra. </author> <title> Exponential Determinization for !-Automata with Strong-Fairness Acceptance Condition. </title> <booktitle> In Proceedings of the ACM Symposium on the Theory of Computing, </booktitle> <year> 1992. </year>
Reference-contexts: Since, these fairness constraint are given by the user, we expect their number to be small. Remark One can also use the algorithm reported in <ref> [Saf92] </ref> for the above task. Given a deterministic Streett automaton with n states and h CFC's, [Saf92]'s algorithm returns a deterministic Rabin automaton with n2 h log h states and h + 1 CFC's accepting the same language. Note that this algorithm is exponential in the number of CFC's. <p> Note that this algorithm is exponential in the number of CFC's. If this number of small, as it is expected to be in practice, this algorithm may be practical. If S 2 is non-deterministic, then the procedure is more expensive. <ref> [Saf92] </ref> proposed an algorithm for de-terminizing a non-deterministic Streett automaton. This algorithm returns a deterministic Rabin automata. Then, the following algorithm decides whether L (S 1 ) is contained in L (S 2 ), when S 2 is non-deterministic. 1. <p> Proof: This follows from the fact that step 1 increases the state space size by a factor of 2, and the complexity result of <ref> [Saf92] </ref>. 5 User Interface Given that our final environment is the edge-Streett/edge-Rabin environment, we can create a more flexible user interface. The users specify their processes, using finite state machines. They can attach various kinds of fairness constraints to their FSM's.
Reference: [Str82] <author> R.S. Streett. </author> <title> Propositional Dynamic Logic of Looping and Converse is Elementary Decidable. </title> <journal> Information and Control, </journal> <volume> 54 </volume> <pages> 121-141, </pages> <year> 1982. </year>
Reference: [SVW87] <author> A.P. Sistla, M.Y. Vardi, and P.L. Wolper. </author> <title> The Complementation Problem for Buchi Automata, with Applications to Temporal Logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 49 </volume> <pages> 217-237, </pages> <year> 1987. </year>
Reference: [Tho90] <author> W. Thomas. </author> <title> Automata on Infinite Objects. </title> <editor> In J. van Leeuwen, editor, </editor> <title> Formal Models and Semantics, </title> <booktitle> volume B of Handbook of Theoretical Computer Science, </booktitle> <pages> pages 133-191. </pages> <publisher> Elsevier Science, </publisher> <year> 1990. </year>
Reference: [VW86] <author> M.Y. Vardi and P.L. Wolper. </author> <title> An Automata-Theoretic Approach to Program Verification. </title> <booktitle> In Proceedings of the IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 332-334, </pages> <year> 1986. </year> <month> 19 </month>
Reference-contexts: The above scheme for doing formal verification first appeared in literature in <ref> [VW86] </ref>. [VW86] suggested specifying both the system and the property using Buchi automata, and went on to give an algorithm for language containment in this environment. <p> The above scheme for doing formal verification first appeared in literature in <ref> [VW86] </ref>. [VW86] suggested specifying both the system and the property using Buchi automata, and went on to give an algorithm for language containment in this environment.
References-found: 16

