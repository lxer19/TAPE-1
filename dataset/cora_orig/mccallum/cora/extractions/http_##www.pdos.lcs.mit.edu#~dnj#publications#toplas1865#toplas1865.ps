URL: http://www.pdos.lcs.mit.edu/~dnj/publications/toplas1865/toplas1865.ps
Refering-URL: http://www.pdos.lcs.mit.edu/~dnj/publications.htm
Root-URL: 
Title: Isomorph-free Model Enumeration: A New Method for Checking Relational Specifications So as fast as you
Author: Daniel Jackson, Somesh Jha and Craig A. Damon 
Degree: Dr. Seuss (1957)  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract-found: 0
Intro-found: 1
Reference: [B+95] <author> S. Bensalem, A. Bouajjani, C. Loiseaux and J. Sifakis. </author> <title> P roperty pre serving simulations. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> Volume 6, No. 1, </volume> <month> January </month> <year> 1995. </year>
Reference-contexts: An infi nite space of interpretations is reduced to a fi nite space in such a way that establishing a property on the fi nite space suffices. This approach is well developed in the context of model checking <ref> [CGL92, B+95, DGR96] </ref>. In our previous work, we have shown how similar ideas can be applied to relational specifications [Jac94], but it seems that, in practice, it is often hard (or impossible) to fi nd appropriate abstractions.
Reference: [BG94] <author> J. Bowen and M.J.C. Gordon. </author> <title> Z and HOL. Z User W orkshop, </title> <address> Cambridge, England, </address> <year> 1994, </year> <booktitle> Springer -Verlag W orkshops in Computing, </booktitle> <pages> pp. 141167. </pages>
Reference-contexts: Recently, with the development of theorem provers such as PVS [OR+95] that 5 incorporate powerful decision procedures, the analysis of realistic designs has become possible. A number of theorem provers have been developed specifically for Z [Jon92, SM96] or have been applied to it <ref> [BG94, ES94] </ref>; there are also specialized theorem provers for the relational calculus [BH94]. The labour cost of interactive theorem proving is still high enough, however , to rule out its use in everyday software development.
Reference: [BH94] <institution> Rudolf Berghammer and Claudia Hattensperger . Computer-Aided Manipulation of R elational Expr essions and F ormulae Using RALF . Technical Report, Institut fur Informatik und Praktische Mathematik, Christian-Albrechts Universitat Zu Kiel, Kiel, Germany, </institution> <year> 1994. </year>
Reference-contexts: A number of theorem provers have been developed specifically for Z [Jon92, SM96] or have been applied to it [BG94, ES94]; there are also specialized theorem provers for the relational calculus <ref> [BH94] </ref>. The labour cost of interactive theorem proving is still high enough, however , to rule out its use in everyday software development. For safety critical systems or components, on the other hand, especially those involving subtle distributed algorithms, the cost appears to be justified.
Reference: [BJR96] <author> Grady Booch, Ivar Jacobson, James Rumbaugh. </author> <title> The Unified Modelling 32 Language for ObjectOriented Development. Documentation set, version 0.9, Rational Software Corporation, </title> <address> Santa Clare, CA (http://www.rational.com). </address>
Reference-contexts: This aspect of Z is shared with the style of specifi cation known as object modelling, central to almost all of the objectoriented methods popular in commercial circles (eg, <ref> [SM88, R+91, BJR96] </ref>), in which the state space is described with an entity-relationship diagram [Che76], sometimes with additional textual constraints. Analyzing Relational Specifications This paper describes a technique for analyzing relational specifi cations. The underlying idea is very simple.
Reference: [Bry92] <author> R. E. Bryant. </author> <title> Symbolic Boolean Manipulation with Ordered Binary Decision Diagrams. </title> <journal> ACM Computing Sur veys, </journal> <volume> vol. 24, no. 3, </volume> <pages> pp. 293318, </pages> <year> 1992. </year>
Reference-contexts: We have experimented [DJJ96] with a version of Nitpick based on Bryants ordered binary decision diagrams (BBDs) <ref> [Bry92] </ref>. Very large boolean formulae can often be represented with small BDDs. Using iterative squaring, closures can be computed reasonably effi ciently. F or checking some specifi cations the boolean method works better , but usually isomorph elimination gives a reduction large enough to make the explicit method preferable.
Reference: [BS92] <editor> Belaid Benhamou and Lakhdar Sais. </editor> <title> Theoretical study of symmetries in propositional calculus and applications. </title> <booktitle> Automated Deduction (CADE-11): Proc. 11th Inter national Confer ence on A utomated Deduction, </booktitle> <address> Saratoga Springs, NY , June 1992. </address> <booktitle> Lecture Notes in Artificial Intelligence, </booktitle> <volume> Vol. 607, </volume> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: For hard cases, local search techniques work surprisingly well [SLM92]. Symmetries involving permutation of boolean variables have been exploited in the analysis of first-order formulae <ref> [BS92, Cra92] </ref>. But as far as we know, ours is the only method to use symmetry in the assignable values themselves. The FINDER tool [Sla94] uses backtracking search to find models of a logic with functions and equality.
Reference: [C+96] <author> E.M. Clarke, R. Enders, T. Filkorn and S. Jha. </author> <title> Exploiting symmetry in temporal logic model checking. </title> <booktitle> in [FMSD96]. </booktitle>
Reference-contexts: A recent journal issue on the topic of symme try in automatic verifi cation [FMSD96] includes expanded versions of these papers <ref> [C+96, ES96, ID96] </ref> and others. These methods exploit different subsets of the automorphisms of the transition relation. Ip and Dills method [ID96] uses a special construct in the specification language, called a scalarset, to represent an uninterpreted type. <p> During exploration of the state space, the checker not only avoids visiting states that have been previously visited, but also avoids those in the same orbit as that is, equivalent under symmetry to a visited state. The methods of Clarke, Enders, F ilkhorn and Jha <ref> [C+96] </ref>, and of Emerson and Sistla [ES96], accommodate a more general class of automorphism groups, but require the user to specify the group. Moreover, these methods can, to some degree, take advantage of the structure of the property being checked.
Reference: [CFJ93] <author> E.M. Clarke, T. Filkorn and S. Jha. </author> <title> Exploiting symmetry in temporal logic model checking. </title> <booktitle> Fifth Inter national Confer ence on Computer Aided Verification, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: Symmetry in Model Checking Symmetry in the transition relation of a state machine has been exploited in check ing methods for Petri nets [Sta91], for reachability analysis [ID93], and for temporal logic model checking <ref> [CFJ93, ES93] </ref>. A recent journal issue on the topic of symme try in automatic verifi cation [FMSD96] includes expanded versions of these papers [C+96, ES96, ID96] and others. These methods exploit different subsets of the automorphisms of the transition relation. <p> The problem can be shown to be harder than graph isomorphism [Jha96], and in practice an appro ximation is used that sometimes distin -guishes states in the same orbit (but never equates states in distinct orbits). Although our method was inspired by <ref> [CFJ93] </ref>, it actually has little in common with it or [ID93].
Reference: [CGL92] <author> E.M. Clarke, O . Grumberg and D.E. </author> <title> Long. Model Checking and Abstraction. </title> <booktitle> Proc. ACM Symposium of Principles of Programming Languages, </booktitle> <month> January </month> <year> 1992. </year>
Reference-contexts: An infi nite space of interpretations is reduced to a fi nite space in such a way that establishing a property on the fi nite space suffices. This approach is well developed in the context of model checking <ref> [CGL92, B+95, DGR96] </ref>. In our previous work, we have shown how similar ideas can be applied to relational specifications [Jac94], but it seems that, in practice, it is often hard (or impossible) to fi nd appropriate abstractions.
Reference: [Che76] <author> Peter Chen. </author> <title> The entity relationship modeltoward a unifi ed view of data. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> vol. 1, no. 1, </volume> <pages> pp. 9-36, </pages> <year> 1976. </year>
Reference-contexts: This aspect of Z is shared with the style of specifi cation known as object modelling, central to almost all of the objectoriented methods popular in commercial circles (eg, [SM88, R+91, BJR96]), in which the state space is described with an entity-relationship diagram <ref> [Che76] </ref>, sometimes with additional textual constraints. Analyzing Relational Specifications This paper describes a technique for analyzing relational specifi cations. The underlying idea is very simple. Both simulation and checking amount to finding models of a relational formula, that is, assignments for which the formula is true.
Reference: [Cra92] <author> James Crawford. </author> <title> A theoretical analysis of reasoning by symmetry in first-order logic (extended abstract). </title> <booktitle> AAAI-92 Workshop on Tractable Reasoning, </booktitle> <year> 1992, </year> <pages> pp. 1722. </pages>
Reference-contexts: For hard cases, local search techniques work surprisingly well [SLM92]. Symmetries involving permutation of boolean variables have been exploited in the analysis of first-order formulae <ref> [BS92, Cra92] </ref>. But as far as we know, ours is the only method to use symmetry in the assignable values themselves. The FINDER tool [Sla94] uses backtracking search to find models of a logic with functions and equality.
Reference: [DGR96] <author> D. Dams, O . Grumberg and R . Gerth. </author> <title> Abstract Interpretation of Reactive Systems. </title> <journal> ACM Transactions on Programming L anguages and Systems, </journal> <note> to appear. </note>
Reference-contexts: An infi nite space of interpretations is reduced to a fi nite space in such a way that establishing a property on the fi nite space suffices. This approach is well developed in the context of model checking <ref> [CGL92, B+95, DGR96] </ref>. In our previous work, we have shown how similar ideas can be applied to relational specifications [Jac94], but it seems that, in practice, it is often hard (or impossible) to fi nd appropriate abstractions.
Reference: [DJ96] <author> Craig A. Damon and Daniel Jackson. </author> <title> Effi cient Search as a Means of Executing Specifi cations. </title> <booktitle> Proc. Second Inter national W orkshop on Tools and Algorithms for the Constr uction and Analysis of Systems (TACAS 96), </booktitle> <address> Passau, Germany, </address> <month> March </month> <year> 1996. </year>
Reference-contexts: Although Nitpicks suite of reductions allow many realistic specifi cations to be analyzed, the problem is still fundamentally intractable. Isomorph elimination alone is rarely suffi cient to make checking feasible. W ith the addition of short circuiting <ref> [DJ96] </ref>, however, we have been able to enumerate interpretations across a tree with 10 20 leaves, obtaining reductions of 15 orders of magnitude. Isomorph elimination regularly contributes 6 orders of magnitude, and sometimes more. <p> Nitpicks derived variable analysis [JD95] ensures that when a variable of the poststate of an operation is defined constructively, no search is actually performed; the equation is essentially converted into an assignment statement. Consequently , Nitpick will execute specifications as fast as any simulation tool. And due to short-circuiting <ref> [DJ96] </ref> and isomorph elimination, it can focus on executions that are likely to expose errors. The equivalence classes into which our method partitions the formulas interpretations are revealing subdomains in the jargon of testing theory [WO80]. <p> This short circuiting prunes the interpretation tree further, often by a factor even greater than that achieved by the isomorph elimination method <ref> [DJ96] </ref>. Sections 7 and 8 explain the two observations underlying the method. Section 9 justifies the incremental approach, and Section 10 explains the colouring scheme used to express the symmetries. Section 11 presents a refi nement of the method. <p> The first phase of the analysis is static: 1. The formula is checked for syntax and type errors. 2. An appropriate variable ordering is selected; currently we use an ordering heuristic designed for short-circuiting <ref> [DJ96] </ref>. 3. The most general typing is computed by type inference. <p> Term symmetry can only be effective with a good variable ordering. The smaller the set of relevant variables, the coarser the colouring equivalence. A simple but effective ordering attempts to close as many terms as possible at a given stage. Fortunately, the ordering selected for short-circuiting <ref> [DJ96] </ref> also appears to be reasonable. The refined enumerate function, enumerateR, is shown in Figure 9.
Reference: [DJJ96] <author> Craig A. Damon, Daniel Jackson and Somesh Jha. </author> <title> Checking Relational Specifi cations with Binary Decision Diagrams. </title> <booktitle> Proc. 4th ACM SIGSOF T Conf. on F oundations of Softwar e Engineering , San Francisco, </booktitle> <address> CA, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: We have experimented <ref> [DJJ96] </ref> with a version of Nitpick based on Bryants ordered binary decision diagrams (BBDs) [Bry92]. Very large boolean formulae can often be represented with small BDDs. Using iterative squaring, closures can be computed reasonably effi ciently.
Reference: [DKC89] <author> A.J.J. Dick, P.J. Krause and J. Cozens. </author> <title> Computer-aided transformation of Z into P rolog. Z User W orkshop, </title> <publisher> Oxford, </publisher> <year> 1989, </year> <title> J.E. Nicholls, </title> <booktitle> ed.,Workshops in Computing, </booktitle> <publisher> Springer Verlag, </publisher> <year> 1990, </year> <pages> pp. 7185. </pages>
Reference: [ES93] <author> E. Allen Emerson and A. P rasad Sistla. </author> <title> Symmetry and Model Checking. </title> <booktitle> Fifth Inter national Confer ence on Computer Aided Verification, </booktitle> <month> June </month> <year> 1993. </year> <month> 33 </month>
Reference-contexts: Symmetry in Model Checking Symmetry in the transition relation of a state machine has been exploited in check ing methods for Petri nets [Sta91], for reachability analysis [ID93], and for temporal logic model checking <ref> [CFJ93, ES93] </ref>. A recent journal issue on the topic of symme try in automatic verifi cation [FMSD96] includes expanded versions of these papers [C+96, ES96, ID96] and others. These methods exploit different subsets of the automorphisms of the transition relation.
Reference: [ES94] <author> Marcin Engel and Jens Ulrik Skakkebaek. </author> <title> Applying PVS to Z . Technical R eport ID/DTU ME 3/1, P roCos P roject, </title> <institution> Department of Computer Science, T echnical University of Denmark, L yngby, Denmark. </institution>
Reference-contexts: Recently, with the development of theorem provers such as PVS [OR+95] that 5 incorporate powerful decision procedures, the analysis of realistic designs has become possible. A number of theorem provers have been developed specifically for Z [Jon92, SM96] or have been applied to it <ref> [BG94, ES94] </ref>; there are also specialized theorem provers for the relational calculus [BH94]. The labour cost of interactive theorem proving is still high enough, however , to rule out its use in everyday software development.
Reference: [ES96] <author> E. Allen Emerson and A. Prasad Sistla. </author> <title> Symmetry and model checking. </title> <booktitle> in [FMSD96]. </booktitle>
Reference-contexts: A recent journal issue on the topic of symme try in automatic verifi cation [FMSD96] includes expanded versions of these papers <ref> [C+96, ES96, ID96] </ref> and others. These methods exploit different subsets of the automorphisms of the transition relation. Ip and Dills method [ID96] uses a special construct in the specification language, called a scalarset, to represent an uninterpreted type. <p> The methods of Clarke, Enders, F ilkhorn and Jha [C+96], and of Emerson and Sistla <ref> [ES96] </ref>, accommodate a more general class of automorphism groups, but require the user to specify the group. Moreover, these methods can, to some degree, take advantage of the structure of the property being checked.
Reference: [FMSD96] <editor> Formal Methods in System Design, </editor> <title> V olume 9, Numbers 1/2, </title> <publisher> Kluwer Academic Publishers, </publisher> <month> August </month> <year> 1996. </year>
Reference-contexts: A recent journal issue on the topic of symme try in automatic verifi cation <ref> [FMSD96] </ref> includes expanded versions of these papers [C+96, ES96, ID96] and others. These methods exploit different subsets of the automorphisms of the transition relation. Ip and Dills method [ID96] uses a special construct in the specification language, called a scalarset, to represent an uninterpreted type.
Reference: [Giv88] <author> Steven Givant. </author> <title> Tarskis development of logic and mathematics based on the calculus of relations. Colloquia Mathematica Societatis Janos Bolyai 54, Algebraic Logic, </title> <address> Budapest, Hungary, </address> <year> 1988. </year>
Reference-contexts: Moreover , it can be shown that if an operator can be defined in terms of first-order predicate calculus, it must be logical; and if not, it seems unlikely that it could be included in a practical specification language anyway. (The notion of logicality is due to T arski <ref> [Tar41, Giv88] </ref>. His calculus is less expressive than fi rst-order logic; it can be shown that although any fi rst-order formula with at most three variables can be expressed, there are trivial formulae with 13 four variables that are not expressible.
Reference: [ID93] <author> C. Ip and D. Dill. </author> <title> Better verifi cation through symmetry . Proc. </title> <booktitle> 11th International Symposium on Computer Har dware Description Languages and their Applications, </booktitle> <month> April </month> <year> 1993. </year>
Reference-contexts: Symmetry in Model Checking Symmetry in the transition relation of a state machine has been exploited in check ing methods for Petri nets [Sta91], for reachability analysis <ref> [ID93] </ref>, and for temporal logic model checking [CFJ93, ES93]. A recent journal issue on the topic of symme try in automatic verifi cation [FMSD96] includes expanded versions of these papers [C+96, ES96, ID96] and others. These methods exploit different subsets of the automorphisms of the transition relation. <p> Although our method was inspired by [CFJ93], it actually has little in common with it or <ref> [ID93] </ref>. These methods are concerned with the equivalence of two states induced by the symmetries of the transition relation to which they belong; ours is concerned with the equivalence of two interpretations, and exploits symmetry dur ing the construction of an interpretation. <p> Our types, derived from the given types of Z [Spi92], are all uninterpreted, and are thus scalarsets in the jargon of <ref> [ID93] </ref>. Our method requires no orbit test; the only isomorph checking that occurs is limited to the internals of the graph generation subroutine.
Reference: [ID96] <author> C. Norris Ip and David L. Dill. </author> <title> Better verifi cation through symmetry. </title> <booktitle> in [FMSD96]. </booktitle>
Reference-contexts: A recent journal issue on the topic of symme try in automatic verifi cation [FMSD96] includes expanded versions of these papers <ref> [C+96, ES96, ID96] </ref> and others. These methods exploit different subsets of the automorphisms of the transition relation. Ip and Dills method [ID96] uses a special construct in the specification language, called a scalarset, to represent an uninterpreted type. <p> A recent journal issue on the topic of symme try in automatic verifi cation [FMSD96] includes expanded versions of these papers [C+96, ES96, ID96] and others. These methods exploit different subsets of the automorphisms of the transition relation. Ip and Dills method <ref> [ID96] </ref> uses a special construct in the specification language, called a scalarset, to represent an uninterpreted type. A specification involving an array of processors, for example, might declare the process identifiers used to index the array as belonging to such a scalarset.
Reference: [Jac94] <author> Daniel Jackson. </author> <title> Abstract model checking of infi nite specifi cations. </title> <booktitle> Proc. Formal Methods Europe , Barcelona, </booktitle> <address> Spain, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: This approach is well developed in the context of model checking [CGL92, B+95, DGR96]. In our previous work, we have shown how similar ideas can be applied to relational specifications <ref> [Jac94] </ref>, but it seems that, in practice, it is often hard (or impossible) to fi nd appropriate abstractions. Simulators Existing simulation tools require the specification to be constructive; suitable subsets of Z [V al91] and VDM [LL91] have been defi ned.
Reference: [Jac96] <author> Daniel Jackson. Nitpick: </author> <title> A Checkable Specifi cation Language. Proc.Workshop on F ormal Methods in Softwar e Practice , San Diego, </title> <address> CA, </address> <month> January </month> <year> 1996. </year>
Reference: [Jac97] <author> Jonathan Jacky. </author> <title> The Way of Z: Practical Programming with F ormal Methods. </title> <publisher> Cambridge University Press, </publisher> <year> 1997. </year>
Reference-contexts: This style of specifi cation is central to model-based languages such as VDM [Jon86] and Z <ref> [Spi92, WD96, Jac97] </ref>. Specifi cations in these languages have been called relational since the execution of an operation is modelled as a binary relation between pre and poststates.
Reference: [JD95] <author> Daniel Jackson and Craig A. Damon. </author> <title> Semi-Executable Specifications. </title> <institution> Technical R eport CMU-C S-95-216, School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: Closer to our approach, there have been attempts to analyze Z specifi cations with a P rolog interpreter [DK C89, WE92], but these do not appear to be practical yet. Nitpicks derived variable analysis <ref> [JD95] </ref> ensures that when a variable of the poststate of an operation is defined constructively, no search is actually performed; the equation is essentially converted into an assignment statement. Consequently , Nitpick will execute specifications as fast as any simulation tool.
Reference: [JD96a] <author> Daniel Jackson and Craig A. Damon. Nitpick: </author> <title> A Checker for Software Specifications (R eference Manual). </title> <institution> Technical R eport CMU-C S-96-109, School of Computer Science, Carnegie Mellon University , Pittsburgh, </institution> <address> PA, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: Completeness would rule out automation, since specification languages are invariably more expressive than the relational calculus, which is known to be undecidable [Sch79]. The technique has been implemented in a tool called Nitpick, whose specification language NP <ref> [JD96a] </ref> is roughly a subset of Z. NP may be viewed as a typed rela tional calculus [Tar41, SS93], with the addition of transitive closure and various syntactic structuring mechanisms. The example above is shown later (in Figure 10) as it would appear in NP.
Reference: [JD96b] <author> Daniel Jackson and Craig A. Damon. </author> <title> Elements of Style: Analyzing a Software Design F eature with a Counterexample Detector . IEEE Transactions on Softwar e Engineering, </title> <journal> July 1996, </journal> <volume> Vol. 22, No. 7, </volume> <pages> pp. 484495. </pages>
Reference-contexts: Experience with Nitpick/NP Nitpick has been used in a variety of settings. In the Masters of Software Engineering program at Carnegie Mellon, students have used Nitpick on class pro -jects to analyze several small but realistic designs. Nitpick has been applied to func tional specifications (see <ref> [JD96b] </ref> for an application to the paragraph style mecha -nism of Microsoft Word); to checking existing proofs (finding a aw in the proof of correctness of a handoff algorithm designed for the FAAs new air-traffic control system); to abstract designs (finding a bug in the first version of IPv6, a mobile <p> Although this example is clearly a toy, a realistic specifi cation of telephone switching can be constructed in a similar style [MZ94]. A more interesting application of Nitpick is described in <ref> [JD96b] </ref>. The first line declares a type Phone representing an abstract set of telephones. The system state is declared in the schema Switch; it consists of a single relation variable conns whose interpretation is that (p, q) @ conns when a call from p to q is active.
Reference: [Jha96] <author> Somesh Jha. </author> <title> Symmetry and induction in model checking. </title> <type> Doctoral thesis, </type> <institution> School of Computer Science, Carnegie Mellon University , Pittsburgh, </institution> <address> PA, </address> <month> December </month> <year> 1996. </year>
Reference-contexts: All of these methods involve, explicitly or implicitly , an orbit test: given two states, one must determine whether they fall into the same orbit and can thus be treated as indistinguishable. The problem can be shown to be harder than graph isomorphism <ref> [Jha96] </ref>, and in practice an appro ximation is used that sometimes distin -guishes states in the same orbit (but never equates states in distinct orbits). Although our method was inspired by [CFJ93], it actually has little in common with it or [ID93].
Reference: [Jip92] <author> Peter Jipsen. </author> <title> Computer-aided investigations of Relation Algebras. </title> <type> PhD thesis, </type> <institution> Dept. of Mathematics, V anderbuilt University , Nashville, Tennessee, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: Our method might have some application in testing of code also, although resource boundaries introduce discontinuities in behaviour where many bugs reside. Consequently, an enumeration that is confined to a small scope is unlikely to expose errors. Model Finders In his thesis on abstract relational algebras <ref> [Jip92] </ref>, Jipsen gives an algorithm for 6 finding models of relational formulae. His purpose differs from ours; he uses the algorithm to prove theorems by demonstrating that the negation of an inference has no models. It is not clear whether Jipsens algorithm could be applied to specification checking.
Reference: [JJD96] <author> Daniel Jackson, Somesh Jha and Craig A. Damon. </author> <title> Faster Checking of Software Specifications by Eliminating Isomorphs. </title> <booktitle> Proc. ACM Symp. 34 on Principles of Programming L anguages, </booktitle> <address> St. P etersburg Beach, FL, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: In model checking, for example, a factor of 10 or 100 is typical, while we often see reductions of 10 5 or more. An earlier version of our isomorph elimination method is described in <ref> [JJD96] </ref>. To avoid the generation of graphs under arbitrary colourings, it introduced explicit 8 bijections called wirings between the sides of one relation and another . This allowed us to generate an entire isomorph-free set of relations just once, and then vary the bijections according to the colouring context. <p> Skipping non-models speeds up the search for models; this is the primary motivation. Skipping models is good for simulation, because it means that the user is not bar raged with cases that are uninteresting relabellings of cases already seen. Like our previous isomorph elimination method <ref> [JJD96] </ref>, the method exploits the 9 structure of the formula being checked as well as the structure of the enumerated relation values.
Reference: [Jon86] <author> Cliff B. Jones, </author> <title> Systematic Software Development Using VDM, </title> <publisher> Prentice Hall International, </publisher> <year> 1986. </year>
Reference-contexts: This style of specifi cation is central to model-based languages such as VDM <ref> [Jon86] </ref> and Z [Spi92, WD96, Jac97]. Specifi cations in these languages have been called relational since the execution of an operation is modelled as a binary relation between pre and poststates.
Reference: [Jon92] <author> R.B. Jones. </author> <title> ICL ProofPower. </title> <journal> British Computer Society Formal Aspects of Computer Science, </journal> <volume> Series 3, 1(1), </volume> <year> 1992, </year> <pages> pp. 1013. </pages>
Reference-contexts: R esearch efforts have therefore focused mainly on syntactic analyses. Recently, with the development of theorem provers such as PVS [OR+95] that 5 incorporate powerful decision procedures, the analysis of realistic designs has become possible. A number of theorem provers have been developed specifically for Z <ref> [Jon92, SM96] </ref> or have been applied to it [BG94, ES94]; there are also specialized theorem provers for the relational calculus [BH94]. The labour cost of interactive theorem proving is still high enough, however , to rule out its use in everyday software development.
Reference: [LL91] <author> Peter Gorm Larsen and P oul Bogh Lassen. </author> <title> An ex ecutable subset of Meta-IV with loose specifi cation. </title> <editor> In S. P rehn, W.J. Toetenel (eds.), VDM91: </editor> <title> F ormal Softwar e Development Methods , V ol. </title> <booktitle> 1, Lecture Notes in Computer Science 551, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Simulators Existing simulation tools require the specification to be constructive; suitable subsets of Z [V al91] and VDM <ref> [LL91] </ref> have been defi ned. Closer to our approach, there have been attempts to analyze Z specifi cations with a P rolog interpreter [DK C89, WE92], but these do not appear to be practical yet.
Reference: [McK81] <author> Brendan D. </author> <title> McKay . P ractical graph isomorphism. </title> <booktitle> Congressus Numerantium 21 (1981), </booktitle> <pages> pp. 499517. </pages>
Reference-contexts: Our current implementation of the iterator (described in Section 11) is not minimal: it overgenerates by about 10%, thus in ating the size of the search. In our previous version of Nitpick, we used a minimal iterator provided by McKay (based on the ideas of <ref> [McK81, McK94, McK96] </ref>). We hope eventually either to adapt this to the new setting, or improve our own algorithm. There are many other open questions.
Reference: [McK94] <author> Brendan D. </author> <title> McKay . Nauty User s Guide , version 1.5. </title> <institution> Computer Science Department, Australian National University, </institution> <address> GPO Box 4, ACT 2601, Australia. </address>
Reference-contexts: Our current implementation of the iterator (described in Section 11) is not minimal: it overgenerates by about 10%, thus in ating the size of the search. In our previous version of Nitpick, we used a minimal iterator provided by McKay (based on the ideas of <ref> [McK81, McK94, McK96] </ref>). We hope eventually either to adapt this to the new setting, or improve our own algorithm. There are many other open questions.
Reference: [McK96] <author> Brendan D. McKay. </author> <title> Isomorph-free exhaustive generation. </title> <type> Unpublished manuscript. </type> <institution> Computer Science Department, A ustralian National University, </institution> <address> GPO Box 4, ACT 2601, Australia. </address>
Reference-contexts: A minimal gen iterator that never yields a super uous value can be constructed using the techniques described in <ref> [McK96] </ref>. Generating graphs up to isomorphism is a surprisingly difficult problem; in our implementation, it occupies a significant part of the code. 13 Refined Algorithm Term symmetry (Section 11) complicates the algorithm. <p> Our current implementation of the iterator (described in Section 11) is not minimal: it overgenerates by about 10%, thus in ating the size of the search. In our previous version of Nitpick, we used a minimal iterator provided by McKay (based on the ideas of <ref> [McK81, McK94, McK96] </ref>). We hope eventually either to adapt this to the new setting, or improve our own algorithm. There are many other open questions.
Reference: [MZ94] <author> Peter Mataga and Pamela Zave. </author> <title> Formal specification of telephone fea tures. </title> <booktitle> Proc. 8th Z Users Meeting, </booktitle> <pages> pp. 2950, </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Although this example is clearly a toy, a realistic specifi cation of telephone switching can be constructed in a similar style <ref> [MZ94] </ref>. A more interesting application of Nitpick is described in [JD96b]. The first line declares a type Phone representing an abstract set of telephones.
Reference: [Ng97] <author> Yu-Chung Ng. </author> <title> A Nitpick Specification of IPv6. </title> <type> Senior Honors Thesis, </type> <institution> Computer Science Department, Carnegie Mellon University , May 1997. </institution>
Reference-contexts: -nism of Microsoft Word); to checking existing proofs (finding a aw in the proof of correctness of a handoff algorithm designed for the FAAs new air-traffic control system); to abstract designs (finding a bug in the first version of IPv6, a mobile host protocol due to become an Internet standard <ref> [Ng97] </ref>); and to software architectures (exposing cycles and races in the implicit invocation mechanisms used in many development environments). Contrary to our initial expectations, we have found simulation to be invaluable.
Reference: [OR+95] <author> Sam Owre, John R ushby, Natarajan Shankar and F riedrich von Henke. </author> <title> F ormal V erification for F ault-Tolerant Architectures: Prolegomena to the Design of PVS. </title> <journal> IEEE Transactions on Softwar e Engineering, </journal> <volume> 21(2), </volume> <month> February </month> <year> 1995, </year> <pages> pp. 107125. </pages>
Reference-contexts: Theorem Provers Small data structures have huge numbers of values. F or this reason, enumerative analysis of software specifi cations has been regarded as infeasible. R esearch efforts have therefore focused mainly on syntactic analyses. Recently, with the development of theorem provers such as PVS <ref> [OR+95] </ref> that 5 incorporate powerful decision procedures, the analysis of realistic designs has become possible. A number of theorem provers have been developed specifically for Z [Jon92, SM96] or have been applied to it [BG94, ES94]; there are also specialized theorem provers for the relational calculus [BH94].
Reference: [R+91] <author> James Rumbaugh, Michael Blaha, William Premerlani, Frederick Eddy and W illiam Lorensen. </author> <title> ObjectOriented Modeling and Design. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: This aspect of Z is shared with the style of specifi cation known as object modelling, central to almost all of the objectoriented methods popular in commercial circles (eg, <ref> [SM88, R+91, BJR96] </ref>), in which the state space is described with an entity-relationship diagram [Che76], sometimes with additional textual constraints. Analyzing Relational Specifications This paper describes a technique for analyzing relational specifi cations. The underlying idea is very simple.
Reference: [Sch79] <author> Wolfgang Schoenfeld. </author> <title> An undecidability result for relational algebras. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 44(1), </volume> <month> March </month> <year> 1979. </year>
Reference-contexts: The technique as a whole is not complete, since the search is only conducted over a finite universe of atoms. Completeness would rule out automation, since specification languages are invariably more expressive than the relational calculus, which is known to be undecidable <ref> [Sch79] </ref>. The technique has been implemented in a tool called Nitpick, whose specification language NP [JD96a] is roughly a subset of Z. NP may be viewed as a typed rela tional calculus [Tar41, SS93], with the addition of transitive closure and various syntactic structuring mechanisms.
Reference: [Sla94] <author> John K. Slaney . F inder: </author> <title> F inite Domain Enumerator , System Description. </title> <booktitle> Proc. 12th Inter national Confer ence on A utomated Deduction, Lecture Notes in Artifi cial Intelligence series, </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1994, </year> <pages> pp. 798801. </pages>
Reference-contexts: For hard cases, local search techniques work surprisingly well [SLM92]. Symmetries involving permutation of boolean variables have been exploited in the analysis of first-order formulae [BS92, Cra92]. But as far as we know, ours is the only method to use symmetry in the assignable values themselves. The FINDER tool <ref> [Sla94] </ref> uses backtracking search to find models of a logic with functions and equality. Its author graciously translated some of our examples into its input language, and was able to obtain very good results.
Reference: [SLM92] <author> Bart Selman, Hector Levesque and David Mitchell. </author> <title> A new method for solving hard satisfi ability problems. </title> <booktitle> Proc. 10th National Confer ence on Ar tificial Intelligence (AAAI-92) , San Jose, </booktitle> <address> CA, </address> <month> July </month> <year> 1992, </year> <pages> pp. 440446. </pages>
Reference-contexts: The satisfi ability problem for boolean formulae has been espe -cially well studied because of its wide applicability , and because, despite being NP complete, it appears to be easy to solve in practice. For hard cases, local search techniques work surprisingly well <ref> [SLM92] </ref>. Symmetries involving permutation of boolean variables have been exploited in the analysis of first-order formulae [BS92, Cra92]. But as far as we know, ours is the only method to use symmetry in the assignable values themselves.
Reference: [SM88] <author> Sally Shlaer and Stephen Mellor . Objectoriented Systems Analysis: </author> <title> Modeling the World in Data. </title> <publisher> Yourdon Press/Prentice-Hall, </publisher> <year> 1988. </year> <month> 35 </month>
Reference-contexts: This aspect of Z is shared with the style of specifi cation known as object modelling, central to almost all of the objectoriented methods popular in commercial circles (eg, <ref> [SM88, R+91, BJR96] </ref>), in which the state space is described with an entity-relationship diagram [Che76], sometimes with additional textual constraints. Analyzing Relational Specifications This paper describes a technique for analyzing relational specifi cations. The underlying idea is very simple.
Reference: [SM96] <author> Mark Saaltink and Irwin Meisels. </author> <title> The Z/EVES R eference Manual (draft). T echnical R eport TR -96-5493-03, </title> <address> OR A Canada, Ottawa, Ontario, Canada, </address> <month> December </month> <year> 1995; </year> <month> revised April </month> <year> 1996, </year> <pages> 104 pp. </pages>
Reference-contexts: R esearch efforts have therefore focused mainly on syntactic analyses. Recently, with the development of theorem provers such as PVS [OR+95] that 5 incorporate powerful decision procedures, the analysis of realistic designs has become possible. A number of theorem provers have been developed specifically for Z <ref> [Jon92, SM96] </ref> or have been applied to it [BG94, ES94]; there are also specialized theorem provers for the relational calculus [BH94]. The labour cost of interactive theorem proving is still high enough, however , to rule out its use in everyday software development.
Reference: [Spi92] <author> J. M. </author> <title> Spivey . The Z Notation: A R eference Manual , Second ed, </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: This style of specifi cation is central to model-based languages such as VDM [Jon86] and Z <ref> [Spi92, WD96, Jac97] </ref>. Specifi cations in these languages have been called relational since the execution of an operation is modelled as a binary relation between pre and poststates. <p> Our types, derived from the given types of Z <ref> [Spi92] </ref>, are all uninterpreted, and are thus scalarsets in the jargon of [ID93]. Our method requires no orbit test; the only isomorph checking that occurs is limited to the internals of the graph generation subroutine. <p> Our notation, NP see Figure 10 for an example is more elaborate, primarily in three respects. First, its concrete syntax is richer . Using a form of Zs schema mechanism <ref> [Spi92] </ref> tailored to the description of abstract state machines as a structuring mechanism, it allows operation and state descriptions to be constructed incrementally, with commonalities factored out. It also distinguishes claims to be checked from the specification proper. Second, NP admits variables of scalar and set type.
Reference: [SS93] <author> Gunther Schmidt and Thomas Strhlein. </author> <title> Relations and Graphs . EATCS Monographs in Theoretical Computer Science, </title> <publisher> Springer -Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The technique has been implemented in a tool called Nitpick, whose specification language NP [JD96a] is roughly a subset of Z. NP may be viewed as a typed rela tional calculus <ref> [Tar41, SS93] </ref>, with the addition of transitive closure and various syntactic structuring mechanisms. The example above is shown later (in Figure 10) as it would appear in NP. <p> More surprisingly, perhaps, the omission of scalars and sets is also insignificant. A formula involving scalars and sets can be translated into an equivalent formula involving only relations by the following scheme <ref> [SS93] </ref>.
Reference: [Sta91] <author> P. Starke. </author> <title> R eachability analysis of P etri nets using symmetry . Syst. Anal. Model. </title> <journal> Simul., </journal> <volume> 8 (4/5), </volume> <pages> pp. 293303, </pages> <year> 1991. </year>
Reference-contexts: Symmetry in Model Checking Symmetry in the transition relation of a state machine has been exploited in check ing methods for Petri nets <ref> [Sta91] </ref>, for reachability analysis [ID93], and for temporal logic model checking [CFJ93, ES93]. A recent journal issue on the topic of symme try in automatic verifi cation [FMSD96] includes expanded versions of these papers [C+96, ES96, ID96] and others.
Reference: [Tar41] <author> Alfred Tarski. </author> <title> On the calculus of relations. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 6 (1941), </volume> <pages> pp. 7389. </pages>
Reference-contexts: The technique has been implemented in a tool called Nitpick, whose specification language NP [JD96a] is roughly a subset of Z. NP may be viewed as a typed rela tional calculus <ref> [Tar41, SS93] </ref>, with the addition of transitive closure and various syntactic structuring mechanisms. The example above is shown later (in Figure 10) as it would appear in NP. <p> Moreover , it can be shown that if an operator can be defined in terms of first-order predicate calculus, it must be logical; and if not, it seems unlikely that it could be included in a practical specification language anyway. (The notion of logicality is due to T arski <ref> [Tar41, Giv88] </ref>. His calculus is less expressive than fi rst-order logic; it can be shown that although any fi rst-order formula with at most three variables can be expressed, there are trivial formulae with 13 four variables that are not expressible.
Reference: [Val91] <author> Samuel H. Valentine. </author> <title> Z -, an ex ecutable subset of Z. In J.E. Nicholls (ed.), Z User W orkshop, </title> <address> York, 1991. </address> <publisher> Springer -Verlag Workshops in Computing, </publisher> <year> 1992. </year>
Reference: [WD96] <author> Jim Woodcock and Jim Davies. </author> <title> Using Z: </title> <booktitle> Specifi cation, R efinement, and Proof . Prentice Hall International Series in Computer Science, </booktitle> <year> 1996. </year>
Reference-contexts: This style of specifi cation is central to model-based languages such as VDM [Jon86] and Z <ref> [Spi92, WD96, Jac97] </ref>. Specifi cations in these languages have been called relational since the execution of an operation is modelled as a binary relation between pre and poststates.
Reference: [WE92] <author> M.M. W est and B.M. Eaglestone. </author> <title> Software development: two approaches to animations of Z specifi cations using P rolog. </title> <journal> Software Engineering Journal, </journal> <volume> 7(4), </volume> <pages> pp. 264276, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Simulators Existing simulation tools require the specification to be constructive; suitable subsets of Z [V al91] and VDM [LL91] have been defi ned. Closer to our approach, there have been attempts to analyze Z specifi cations with a P rolog interpreter <ref> [DK C89, WE92] </ref>, but these do not appear to be practical yet. Nitpicks derived variable analysis [JD95] ensures that when a variable of the poststate of an operation is defined constructively, no search is actually performed; the equation is essentially converted into an assignment statement.
Reference: [WO80] <author> E.J. Weyuker and T.J. </author> <title> Ostrand. Theories of program testing and the application of revealing subdomains. </title> <journal> IEEE T rans. on Softwar e Engineering, </journal> <volume> vol. SE-6, </volume> <pages> pp. 236245, </pages> <month> May </month> <year> 1980. </year>
Reference-contexts: And due to short-circuiting [DJ96] and isomorph elimination, it can focus on executions that are likely to expose errors. The equivalence classes into which our method partitions the formulas interpretations are revealing subdomains in the jargon of testing theory <ref> [WO80] </ref>. Our method might have some application in testing of code also, although resource boundaries introduce discontinuities in behaviour where many bugs reside. Consequently, an enumeration that is confined to a small scope is unlikely to expose errors.

References-found: 54

