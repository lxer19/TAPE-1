URL: http://www.cs.wustl.edu/~schmidt/ISS-97.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/TAO-status.html
Root-URL: 
Email: fgokhale,schmidtg@cs.wustl.edu  stanm@bellcore.com  
Title: Software Tools for Automating the Migration From DCE to CORBA  
Author: Aniruddha Gokhale and Douglas C. Schmidt Stanley Moyer 
Keyword: CORBA, DCE, Interoperability, Software migration tools.  
Address: St. Louis, Missouri, 63130  445 South Street Morristown, NJ, 07960  
Affiliation: Department of Computer Science Washington University  Bellcore  
Abstract: A subset of this paper appeared in the proceedings of ISS 97: World Telecommunications Congress, IEEE Toronto, Canada, September, 1997. Abstract Next-generation telecommunication software must be flexible and reusable. These requirements motivate the use of object-oriented (OO) middleware like the Common Object Request Broker Architecture (CORBA). However, many existing telecommunication software products have already been written using the Distributed Computing Environment (DCE) RPC toolkit. To reduce porting effort and to minimize unnecessary rework, it is essential to provide a smooth migration path from DCE to CORBA. This paper provides two contributions to the study of migration strategies from DCE to CORBA. First, we describe a migration tool we developed that provides source-level interoperability between DCE RPC and CORBA. Our tool automatically translates DCE Interface Definition Language (IDL) into CORBA IDL and generates code that integrates existing DCE-based code with stubs and skeletons generated by CORBA IDL compilers. Second, we present our lessons learned applying this migration tool to a project at Bellcore. Our experience using the tool on existing applications at Bellcore indicates that source-level interoperability provides a low-cost, yet powerful solution. In addition, the time required to develop the tool (about 9 person months) was substantially less compared to developing a full scale DCE-CIOP protocol. We also found out that minimal human intervention was necessary to achieve interoperability. The disadvantages of using source-level interoperability arise from the fact that not all constructs in the source domain can be mapped onto the target domain. Therefore, source-level interoperability may provide solutions to only a subset of constructs of the source domain (DCE in our case). In practice, this was not a problem as long as programmers followed certain development guidelines. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> Bellcore. </institution> <note> dceObjects Developer's Guide, Bellcore Document BD-DCEO-DG-R140-001 edition, </note> <month> November </month> <year> 1995. </year>
Reference-contexts: Note that the difference between DCE's procedural programming model and CORBA's OO programming model is often overstated. In particular, there are extensions to DCE that provide an OO veneer (such as OODCE [4] and DCE Objects <ref> [1] </ref>). There are, however, a number of restrictions inherent in using DCE in an OO manner.
Reference: [2] <author> Kenneth Birman and Robbert van Renesse. </author> <title> Reliable Distributed Computing with the Isis Toolkit. </title> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <year> 1994. </year>
Reference-contexts: In theory, synchronous request/response communication helps shield client applications from knowledge of whether the target object implementation is local or remote. In practice, it is often difficult to completely hide the use of distribution from clients due to differences in performance and reliability <ref> [2] </ref>. 2 * Oneway communication: CORBA supports oneway (send-only) calls, where the server does not return any information to the client (e.g., as part of the operation's return value or inout/out parameters).
Reference: [3] <author> Thomas J. Brando. </author> <title> Comparing DCE and CORBA. </title> <type> Technical Report MP 95B-93, </type> <institution> MITRE, </institution> <month> March </month> <year> 1995. </year> <note> URL : http://www.mitre.org/research/domis/reports/DCEvCORBA.html. </note>
Reference-contexts: This section summarizes the main features of DCE and CORBA, comparing and contrasting their key similarities and differences <ref> [3] </ref>. 2.1 Key DCE/CORBA Similarities The key similarities between DCE and CORBA are outlined below: * Simplify common network programming tasks: DCE and CORBA simplify common tasks of building distributed applications such as service registration, location, and activation, demultiplexing, framing and error-handling, parameter (de)marshaling, and operation dispatching. * Support for heterogeneous
Reference: [4] <author> John Dilley. OODCE: </author> <title> A C++ Framework for the OSF Distributed Computing Environment. </title> <booktitle> In Proceedings of the Winter Usenix Conference. USENIX Association, </booktitle> <month> January </month> <year> 1995. </year>
Reference-contexts: Note that the difference between DCE's procedural programming model and CORBA's OO programming model is often overstated. In particular, there are extensions to DCE that provide an OO veneer (such as OODCE <ref> [4] </ref> and DCE Objects [1]). There are, however, a number of restrictions inherent in using DCE in an OO manner.
Reference: [5] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1995. </year>
Reference-contexts: Stubs are proxies <ref> [5] </ref> that interact with the underlying run-time systems to allow clients to access services defined by servers. Skeletons integrate application-specific code with automatically generated code that performs demarshaling, demultiplexing, and dispatching of client requests to target object implementations. * Synchronous request/response communication: Both DCE and CORBA support synchronous request/response communication.
Reference: [6] <author> Aniruddha Gokhale and Douglas C. Schmidt. </author> <title> Measuring the Performance of Communication Middleware on High-Speed Networks. </title> <booktitle> In Proceedings of SIGCOMM '96, </booktitle> <pages> pages 306317, </pages> <address> Stanford, CA, </address> <month> August </month> <year> 1996. </year> <note> ACM. </note>
Reference-contexts: the use of DCE pipes since CORBA doesn't provide an equivalent mechanism (yet). 4 To implement this feature in CORBA requires the use of either (1) external mechanisms (e.g., ACE wrappers for socket streams) or (2) defining IDL classes for streaming, which incurs very high overhead on many existing ORBs <ref> [14, 12, 6] </ref>. * Avoid the use of pointers in DCE interfaces since CORBA doesn't provide a mechanism for specifying this in a portable and transparent manner. To pass pointers in CORBA requires additional explicit marshaling code and/or the use of CORBA IDL structures.
Reference: [7] <author> Aniruddha Gokhale and Douglas C. Schmidt. </author> <title> Evaluating Latency and Scalability of CORBA Over High-Speed ATM Networks. </title> <booktitle> In Proceedings of the International Conference on Distributed Computing Systems, </booktitle> <address> Baltimore, Maryland, </address> <month> May </month> <year> 1997. </year> <note> IEEE. </note>
Reference-contexts: In contrast, the original CORBA 1.x specification did not ensure interoperability and portability of CORBA implementations. Although CORBA 2.0 addresses this weakness, many CORBA implementations do not yet implement interoperability robustly <ref> [7] </ref>.
Reference: [8] <author> William Harrison. </author> <title> The Importance of Using Object References as Identifiers of Objects: Comparison of CORBA Object. IBM, OMG Document 94-06-12 edition, </title> <month> June </month> <year> 1994. </year>
Reference-contexts: CORBA has no notion of a UUID. Instead, components in CORBA are identified via Object References, which grant applications access to CORBA objects, but provide no guarantees of unique identity. For more information on the pros and cons of this issue see [11] and <ref> [8] </ref>, respectively. * Infrastructure services: DCE defines a multi-threading API that is part of its core executive infrastructure. In contrast, CORBA does not define a standard API for multi-threading. Therefore, it is not possible to write portable CORBA multi-threaded applications.
Reference: [9] <author> Silvano Maffeis and Douglas C. Schmidt. </author> <title> Constructing Reliable Distributed Communication Systems with CORBA. </title> <journal> IEEE Communications Magazine, </journal> <volume> 14(2), </volume> <month> February </month> <year> 1997. </year>
Reference-contexts: This is not a fault of the tool, per se, but rather a shortcoming of current CORBA products. 5 Concluding Remarks Currently, there is significant momentum in the telecommunication industry to move to CORBA-based middleware solutions <ref> [13, 9] </ref>. However, many existing distributed applications are developed with DCE. It is not cost-effective to reimplement these applications from scratch using CORBA. Therefore, it is essential to develop automated techniques and tools that can enable existing DCE applications to in-teroperate with, and incrementally migrate to, CORBA.
Reference: [10] <author> Object Management Group. </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <address> 2.0 edition, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: 1 Motivation CORBA is an emerging standard for distributed object computing <ref> [10] </ref>. CORBA enhances application flexibility and portability by automating many common development tasks such as object location, parameter marshaling, and object activation.
Reference: [11] <author> Michael L. Powell. </author> <title> Objects, References, Identifiers, and Equality White Paper. SunSoft, </title> <publisher> Inc., </publisher> <address> OMG Document 93-07-05 edition, </address> <month> July </month> <year> 1993. </year>
Reference-contexts: CORBA has no notion of a UUID. Instead, components in CORBA are identified via Object References, which grant applications access to CORBA objects, but provide no guarantees of unique identity. For more information on the pros and cons of this issue see <ref> [11] </ref> and [8], respectively. * Infrastructure services: DCE defines a multi-threading API that is part of its core executive infrastructure. In contrast, CORBA does not define a standard API for multi-threading. Therefore, it is not possible to write portable CORBA multi-threaded applications.
Reference: [12] <author> Irfan Pyarali, Timothy H. Harrison, and Douglas C. Schmidt. </author> <title> Design and Performance of an Object-Oriented Framework for High-Performance Electronic Medical Imaging. </title> <booktitle> In Proceedings of the 2 nd Conference on Object-Oriented Technologies and Systems, </booktitle> <address> Toronto, Canada, June 1996. </address> <publisher> USENIX. </publisher>
Reference-contexts: the use of DCE pipes since CORBA doesn't provide an equivalent mechanism (yet). 4 To implement this feature in CORBA requires the use of either (1) external mechanisms (e.g., ACE wrappers for socket streams) or (2) defining IDL classes for streaming, which incurs very high overhead on many existing ORBs <ref> [14, 12, 6] </ref>. * Avoid the use of pointers in DCE interfaces since CORBA doesn't provide a mechanism for specifying this in a portable and transparent manner. To pass pointers in CORBA requires additional explicit marshaling code and/or the use of CORBA IDL structures. <p> CORBA only supports the ISO Latin-1 character set. Using a different character set will require external marshaling/demarshaling routines. * Pipes: CORBA does not support the notion of pipe operations. To support pipes, a mechanism (such as Blob Streaming framework in <ref> [12] </ref>) that integrates CORBA with TCP stream sockets could be used. Code 3.2 Client-side and Server-side Adapters This section describes the client-side and server-side interface code generated by our migration tool.
Reference: [13] <author> Douglas C. Schmidt, Aniruddha Gokhale, Tim Harrison, and Guru Parulkar. </author> <title> A High-Performance Endsystem Architecture for Real-time CORBA. </title> <journal> IEEE Communications Magazine, </journal> <volume> 14(2), </volume> <month> February </month> <year> 1997. </year>
Reference-contexts: This is not a fault of the tool, per se, but rather a shortcoming of current CORBA products. 5 Concluding Remarks Currently, there is significant momentum in the telecommunication industry to move to CORBA-based middleware solutions <ref> [13, 9] </ref>. However, many existing distributed applications are developed with DCE. It is not cost-effective to reimplement these applications from scratch using CORBA. Therefore, it is essential to develop automated techniques and tools that can enable existing DCE applications to in-teroperate with, and incrementally migrate to, CORBA.
Reference: [14] <author> Douglas C. Schmidt, Timothy H. Harrison, and Ehab Al-Shaer. </author> <title> Object-Oriented Components for High-speed Network Programming. </title> <booktitle> In Proceedings of the 1 st Conference on Object-Oriented Technologies and Systems, </booktitle> <address> Monterey, CA, June 1995. </address> <publisher> USENIX. </publisher>
Reference-contexts: the use of DCE pipes since CORBA doesn't provide an equivalent mechanism (yet). 4 To implement this feature in CORBA requires the use of either (1) external mechanisms (e.g., ACE wrappers for socket streams) or (2) defining IDL classes for streaming, which incurs very high overhead on many existing ORBs <ref> [14, 12, 6] </ref>. * Avoid the use of pointers in DCE interfaces since CORBA doesn't provide a mechanism for specifying this in a portable and transparent manner. To pass pointers in CORBA requires additional explicit marshaling code and/or the use of CORBA IDL structures.
Reference: [15] <author> Steve Vinoski. </author> <title> CORBA: Integrating Diverse Applications Within Distributed Heterogeneous Environments. </title> <journal> IEEE Communications Magazine, </journal> <volume> 14(2), </volume> <month> February </month> <year> 1997. </year>
Reference-contexts: DCE does not provide this degree of flexibility without additional programming effort. * Object-style vs. RPC-style communication Figure 2 illustrates the difference between RPC-style communication (supported by DCE) and Object-style communication (supported by CORBA) <ref> [15] </ref>. 1 There are several benefits to using Object-style communication: 1 Note that CORBA can also be used in a manner that supports RPC-style communication. 3 Customized quality of service Clients can use factories to create different types of product objects that support a range of functionality or performance characteristics (such
Reference: [16] <author> Andreas Vogel and Brett Gray. </author> <title> Translating DCE IDL in OMG IDL and vice versa. </title> <type> Technical Report 22, </type> <institution> CRC for Distributed Systems Technology, </institution> <year> 1995. </year>
Reference-contexts: In addition, our tool did not handle the following DCE IDL constructs since they were not used by the domain of applications for which the tool was designed. * unions; * hyper integers; * conformant arrays. 3.1 Mapping DCE IDL to CORBA IDL <ref> [16, 17] </ref> describe techniques to map a number of DCE IDL constructs to CORBA IDL. Our tool uses many of these techniques to map DCE IDL to CORBA IDL. In addition, we devised other techniques for our tool to handle a wider range of cases than described in [16, 17]. <p> CORBA IDL <ref> [16, 17] </ref> describe techniques to map a number of DCE IDL constructs to CORBA IDL. Our tool uses many of these techniques to map DCE IDL to CORBA IDL. In addition, we devised other techniques for our tool to handle a wider range of cases than described in [16, 17]. <p> Including such a file inside an interface causes nested interface definitions, which are not supported in CORBA. <ref> [16, 17] </ref> describe a technique where the IDL files are included using interface inheritance. 6 * Constants: The DCE to CORBA mapping for constants is straightforward. <p> Hence, our CORBA mapping uses bounded sequences, along with some additional information that keeps track of the lower and upper bounds of the array being transmitted. <ref> [16, 17] </ref> suggest a similar approach, but their prototype uses CORBA constant arrays. typedef sequence &lt;info_t, MAX_ARRAY_LEN&gt; seq_info_t; typedef struct info_array short first; short len; struct varying_array short lower; short upper; long length; seq_info_t var_arr; - info_arr; -; The seq info t sequence in the above declaration defines a bounded sequence <p> Since these pointers can take NULL values and do not represent linked lists, full pointers can be mapped to a CORBA sequence of size one <ref> [16, 17] </ref>. <p> IDL, if any member of a struct is of a sequence type, then that sequence type must be typedef'd before the struct definition. * Reference Pointers: Since DCE reference pointers cannot assume a NULL value, a DCE declaration of a reference pointer can be mapped to a CORBA type declaration <ref> [16, 17] </ref>. An example of this mapping is shown below. /* DCE Ref Ptr declaration */ typedef [ref] short *xyz; // CORBA mapping typedef short xyz; * error status t: The DCE methods returning error status t are mapped to CORBA methods returning unsigned long [16, 17]. <p> to a CORBA type declaration <ref> [16, 17] </ref>. An example of this mapping is shown below. /* DCE Ref Ptr declaration */ typedef [ref] short *xyz; // CORBA mapping typedef short xyz; * error status t: The DCE methods returning error status t are mapped to CORBA methods returning unsigned long [16, 17]. <p> The CORBA mapping for linked lists or binary trees is provided in <ref> [16, 17] </ref>. <p> The CORBA mapping for DCE union is given below: typedef sequence&lt;NodeType,1&gt; NodeType_seq; typedef sequence&lt;Link,Type,1&gt; LinkType_seq; typedef sequence&lt;xbbMsgOutput_t,1&gt; xbbMsgOutput_t_seq; union PtrUnion switch (ObjectClass) - case NODE: NodeType_seq nodep; case LINK: Linktype_seq linkp; default: xbbMsgOutput_t_seq error; -; typedef PtrUnion AnyPtr; * Conformant Arrays: DCE conformant arrays are mapped to CORBA unbounded sequences <ref> [16, 17] </ref>.
Reference: [17] <author> Andreas Vogel, Brett Gray, and Keith Duddy. </author> <title> Understanding any IDL-Lesson one: DCE and CORBA. </title> <editor> In P. Honey-man, editor, </editor> <booktitle> Proceedings of Second International Workshop on Services in Distributed and Networked Environments, </booktitle> <address> Los Alamitos, CA, 1996. </address> <publisher> IEEE Computer Society Press. In Press. 11 Tool </publisher>
Reference-contexts: In addition, our tool did not handle the following DCE IDL constructs since they were not used by the domain of applications for which the tool was designed. * unions; * hyper integers; * conformant arrays. 3.1 Mapping DCE IDL to CORBA IDL <ref> [16, 17] </ref> describe techniques to map a number of DCE IDL constructs to CORBA IDL. Our tool uses many of these techniques to map DCE IDL to CORBA IDL. In addition, we devised other techniques for our tool to handle a wider range of cases than described in [16, 17]. <p> CORBA IDL <ref> [16, 17] </ref> describe techniques to map a number of DCE IDL constructs to CORBA IDL. Our tool uses many of these techniques to map DCE IDL to CORBA IDL. In addition, we devised other techniques for our tool to handle a wider range of cases than described in [16, 17]. <p> Including such a file inside an interface causes nested interface definitions, which are not supported in CORBA. <ref> [16, 17] </ref> describe a technique where the IDL files are included using interface inheritance. 6 * Constants: The DCE to CORBA mapping for constants is straightforward. <p> Hence, our CORBA mapping uses bounded sequences, along with some additional information that keeps track of the lower and upper bounds of the array being transmitted. <ref> [16, 17] </ref> suggest a similar approach, but their prototype uses CORBA constant arrays. typedef sequence &lt;info_t, MAX_ARRAY_LEN&gt; seq_info_t; typedef struct info_array short first; short len; struct varying_array short lower; short upper; long length; seq_info_t var_arr; - info_arr; -; The seq info t sequence in the above declaration defines a bounded sequence <p> Since these pointers can take NULL values and do not represent linked lists, full pointers can be mapped to a CORBA sequence of size one <ref> [16, 17] </ref>. <p> IDL, if any member of a struct is of a sequence type, then that sequence type must be typedef'd before the struct definition. * Reference Pointers: Since DCE reference pointers cannot assume a NULL value, a DCE declaration of a reference pointer can be mapped to a CORBA type declaration <ref> [16, 17] </ref>. An example of this mapping is shown below. /* DCE Ref Ptr declaration */ typedef [ref] short *xyz; // CORBA mapping typedef short xyz; * error status t: The DCE methods returning error status t are mapped to CORBA methods returning unsigned long [16, 17]. <p> to a CORBA type declaration <ref> [16, 17] </ref>. An example of this mapping is shown below. /* DCE Ref Ptr declaration */ typedef [ref] short *xyz; // CORBA mapping typedef short xyz; * error status t: The DCE methods returning error status t are mapped to CORBA methods returning unsigned long [16, 17]. <p> The CORBA mapping for linked lists or binary trees is provided in <ref> [16, 17] </ref>. <p> The CORBA mapping for DCE union is given below: typedef sequence&lt;NodeType,1&gt; NodeType_seq; typedef sequence&lt;Link,Type,1&gt; LinkType_seq; typedef sequence&lt;xbbMsgOutput_t,1&gt; xbbMsgOutput_t_seq; union PtrUnion switch (ObjectClass) - case NODE: NodeType_seq nodep; case LINK: Linktype_seq linkp; default: xbbMsgOutput_t_seq error; -; typedef PtrUnion AnyPtr; * Conformant Arrays: DCE conformant arrays are mapped to CORBA unbounded sequences <ref> [16, 17] </ref>.
References-found: 17

