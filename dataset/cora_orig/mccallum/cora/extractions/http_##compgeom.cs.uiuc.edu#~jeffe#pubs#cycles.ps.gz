URL: http://compgeom.cs.uiuc.edu/~jeffe/pubs/cycles.ps.gz
Refering-URL: http://compgeom.cs.uiuc.edu/~jeffe/pubs/cycles.html
Root-URL: http://www.cs.uiuc.edu
Email: epp-stein@ics.uci.edu;  jeffe@cs.duke.edu;  
Title: Raising Roofs, Crashing Cycles, and Playing Pool: Applications of a Data Structure for Finding Pairwise Interactions  
Author: David Eppstein Jeff Erickson 
Web: http://www:ics:uci:edu/ eppstein.  http://www:cs:duke:edu/ jeffe.  
Address: Irvine, CA 92697, USA;  Box 90129, Durham, NC 27708-0129, USA;  
Affiliation: Department of Information and Computer Science, University of California,  Center for Geometric Computing, Department of Computer Science, Duke University,  
Date: July 1, 1998  
Note: Submitted to Discrete Computational Geometry  Research partially supported by NSF grant CCR-9258355 and by matching funds from Xerox Corporation.  Research supported by NSF grant DMS-9627683 and by U. S. Army Research Office MURI grant DAAH04-96-1-0013.  
Abstract: The straight skeleton of a polygon is a variant of the medial axis, introduced by Aichholzer et al., defined by a shrinking process in which each edge of the polygon moves inward at a fixed rate. We construct the straight skeleton of an n-gon with r reflex vertices in time O(n 1+" + n 8=11+" r 9=11+" ), for any fixed " &gt; 0, improving the previous best upper bound of O(nr log n). Our algorithm simulates the sequence of collisions between edges and vertices during the shrinking process, using a technique of Eppstein for maintaining extrema of binary functions to reduce the problem of finding successive interactions to two dynamic range query problems: (1) maintain a changing set of triangles in IR 3 and answer queries asking which triangle would be first hit by a query ray, and (2) maintain a changing set of rays in IR 3 and answer queries asking for the lowest intersection of any ray with a query triangle. We also exploit a novel characterization of the straight skeleton as a lower envelope of triangles in IR 3 . The same time bounds apply to constructing non-self-intersecting offset curves with mitered or beveled corners, and similar methods extend to other problems of simulating collisions and other pairwise interactions among sets of moving objects. fl An extended abstract of this paper was presented at the 14th Annual ACM Symposium on Computational Geometry [29]. See http://www:cs:duke:edu/ ~ jeffe/pubs/cycles:html for the most recent version of this paper. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> P. K. Agarwal and J. Matousek. </author> <title> Dynamic half-space range reporting and its applications. </title> <journal> Algorithmica 13 </journal> <pages> 325-345, </pages> <year> 1995. </year>
Reference-contexts: All the data structures we describe can be constructed in time O (s 1+" ) and can be modified to support insertions and deletions in time O (s 1+" =n), at the expense of at most an O (n " ) factor in both the preprocessing and query times <ref> [1, 5, 43] </ref>. We also Raising Roofs, Crashing Cycles, and Playing Pool 5 use the standard technique of composing several geometric range searching data structures into a single multi-level data structure.
Reference: [2] <author> P. K. Agarwal and J. Erickson. </author> <title> Geometric range searching and its relatives. </title> <type> Technical report CS-1997-11, </type> <institution> Duke University, </institution> <month> May </month> <year> 1997. </year> <note> hhttp://www:cs:duke:edu/ ~ jeffe/pubs/survey:htmli. To appear in Advances in Discrete and Computational Geometry, </note> <editor> B. Chazelle, J. E. Good-man, and R. Pollack, editors, </editor> <publisher> AMS Press, </publisher> <year> 1998. </year>
Reference-contexts: For further details on space-time tradeoffs, dynamization, multilevel data structures, and other geometric range searching techniques, see the survey by Agarwal and Erickson <ref> [2] </ref>. Theorem 3.1. Given n rays in IR 3 , we can answer lowest intersection queries for triangles in time O (n 1+" =s 1=4 ). Proof: We follow the same pattern used to construct ray shooting data structures for halfplanes and triangles in IR 3 [3, 4, 5, 13].
Reference: [3] <author> P. K. Agarwal and J. Matousek. </author> <title> Ray shooting and parametric search. </title> <journal> SIAM J. Comput. </journal> <volume> 22(4) </volume> <pages> 794-806, </pages> <year> 1993. </year>
Reference-contexts: Theorem 3.1. Given n rays in IR 3 , we can answer lowest intersection queries for triangles in time O (n 1+" =s 1=4 ). Proof: We follow the same pattern used to construct ray shooting data structures for halfplanes and triangles in IR 3 <ref> [3, 4, 5, 13] </ref>. It suffices to construct a data structure that supports queries asking whether any of the rays intersects a query quadrilateral.
Reference: [4] <author> P. K. Agarwal and J. Matousek. </author> <title> On range searching with semialgebraic sets. </title> <journal> Discrete Comput. Geom. </journal> <volume> 11 </volume> <pages> 393-418, </pages> <year> 1994. </year>
Reference-contexts: Theorem 3.1. Given n rays in IR 3 , we can answer lowest intersection queries for triangles in time O (n 1+" =s 1=4 ). Proof: We follow the same pattern used to construct ray shooting data structures for halfplanes and triangles in IR 3 <ref> [3, 4, 5, 13] </ref>. It suffices to construct a data structure that supports queries asking whether any of the rays intersects a query quadrilateral. <p> Each of the first three levels is used to find the lines oriented correctly with respect to one of the ` i . We use a data structure of Agarwal and Matousek <ref> [4] </ref> that supports such queries in time O (n 1+" =s 1=4 ). Finally, for the last level, we only need to know whether a query line ` 4 lies entirely above a set of lines. <p> Line queries are also the bottleneck in answering ray shooting queries among triangles <ref> [4, 5] </ref>. Let the slope of a line in IR 3 denote the tangent of its angle from the xy-plane. In some of our our applications of ray shooting and lowest intersection queries, every ray has the same slope, or every triangle has edges with the same slope, or both. <p> One halfspace of this surface contains the fixed-slope lines oriented positively with respect to `. Thus, preprocessing a set of lines, all with the same slope, for arbitrary line queries is equivalent to preprocessing a set of points in IR 3 for semialgebraic range queries. Agarwal and Matousek <ref> [4] </ref> describe a linear-space data structure that supports such queries in time O (n 2=3+" ). <p> Chazelle et al. [19] describe a data structure of size O (n 3+" ) that supports such queries in O (log n) time. Agarwal and Matousek <ref> [4] </ref> describe a linear-size data structure that supports arbitrary line queries in O (n 3=4+" ) time. Combining these two data structures, we achieve the following space-time tradeoff. Lemma 3.3. <p> We can make a similar improvement for the standard ray shooting problem. Agarwal and Matousek <ref> [4] </ref> and Agarwal and Sharir [5] describe data structures for ray shooting among triangles. The bottleneck in both of their data structures is answering line queries. <p> Theorem 2.1 reduces this to two range-searching problems: (1) maintain a set of triangles and answer ray shooting queries, and (2) maintain a set of rays and answer lowest-intersection queries. To answer ray-shooting queries, we use a data structure of Agarwal and Matousek <ref> [4] </ref>, and to answer lowest-intersection queries, we use Theorem 3.1. Both data structures support queries in time O (n 1+" =s 1=4 ) and updates in time Raising Roofs, Crashing Cycles, and Playing Pool 9 (a) (b) O (s 1+" =n). <p> Using a technique similar to Mohaban and Sharir's algorithm for ray shooting among spheres [48], we express each cylinder ray shooting query as a composition of several four- and five-dimensional semialgebraic range queries, which we can answer using techniques of Agarwal and Matousek <ref> [4] </ref>. We omit further details. fl Using trivial ray-shooting data structures, we also immediately obtain practical algorithms for the billiard problem that use O (n log 2 n) time per collision using linear space, or O (n) time per collision using quadratic space.
Reference: [5] <author> P. K. Agarwal and M. Sharir. </author> <title> Applications of a new space-partitioning technique. </title> <journal> Discrete Comput. Geom. </journal> <volume> 9 </volume> <pages> 11-38, </pages> <year> 1993. </year>
Reference-contexts: All the data structures we describe can be constructed in time O (s 1+" ) and can be modified to support insertions and deletions in time O (s 1+" =n), at the expense of at most an O (n " ) factor in both the preprocessing and query times <ref> [1, 5, 43] </ref>. We also Raising Roofs, Crashing Cycles, and Playing Pool 5 use the standard technique of composing several geometric range searching data structures into a single multi-level data structure. <p> Theorem 3.1. Given n rays in IR 3 , we can answer lowest intersection queries for triangles in time O (n 1+" =s 1=4 ). Proof: We follow the same pattern used to construct ray shooting data structures for halfplanes and triangles in IR 3 <ref> [3, 4, 5, 13] </ref>. It suffices to construct a data structure that supports queries asking whether any of the rays intersects a query quadrilateral. <p> Line queries are also the bottleneck in answering ray shooting queries among triangles <ref> [4, 5] </ref>. Let the slope of a line in IR 3 denote the tangent of its angle from the xy-plane. In some of our our applications of ray shooting and lowest intersection queries, every ray has the same slope, or every triangle has edges with the same slope, or both. <p> Agarwal and Matousek [4] describe a linear-space data structure that supports such queries in time O (n 2=3+" ). Combining this with a data structure of Agarwal and Sharir <ref> [5] </ref> that supports line queries among an arbitrary set of lines in O (log n) time, using O (n 4+" ) space and preprocessing, we obtain the following tradeoff between space and query time. Lemma 3.2. <p> We can make a similar improvement for the standard ray shooting problem. Agarwal and Matousek [4] and Agarwal and Sharir <ref> [5] </ref> describe data structures for ray shooting among triangles. The bottleneck in both of their data structures is answering line queries.
Reference: [6] <author> A. Aggarwal, L. J. Guibas, J. Saxe, and P. W. Shor. </author> <title> A linear-time algorithm for computing the Voronoi diagram of a convex polygon. </title> <journal> Discrete Comput. Geom. </journal> <volume> 4(6) </volume> <pages> 591-604, </pages> <year> 1989. </year>
Reference-contexts: Finally, if the input polygon is convex, the straight skeleton is identical to the (Euclidean) medial axis; consequently, we can construct it in linear time <ref> [6, 21] </ref>. Once we compute the straight skeleton, we can compute any desired mitered offset polygon from it in linear time.
Reference: [7] <author> O. Aichholzer and F. Aurenhammer. </author> <title> Straight skeletons for general polygonal figures in the plane. </title> <booktitle> Proc. 2nd Annu. Internat. Conf. Computing and Combinatorics, </booktitle> <pages> pp. 117-126. </pages> <booktitle> Lecture Notes in Computer Science 1090, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction Suppose we are given the floor plan of a building, and a specification for the slope of its roof planes. How can we design a roof, meeting all the walls at a consistent height, with no dips or flat spots where rainwater can accumulate? Aichholzer et al. <ref> [8, 7] </ref> determined an answer: the straight skeleton. The straight skeleton of a polygon P is, as its name implies, a skeleton (one-dimensional topological retract) of the polygon formed from straight line segments. <p> The straight skeleton has several applications, including architecture, where it describes the shape of a fixed-slope roof rising over a given set of walls [8, 50], and geographic information systems, where it can be used to reconstruct terrains from a given set of rivers and coastlines <ref> [7] </ref>. The straight skeleton can be used to reconstruct the offset polygons from which it was defined, and form a consistent family of non-self-intersecting mitered-corner offset polygons (unlike those formed by, e.g., Adobe Illustrator, in which crossings must be removed manually). <p> The fastest previously published algorithms both use O (n 2 log n) time in the worst case <ref> [7, 8] </ref>; a more careful analysis shows that the running time of one of these algorithms [8] is actually O (nr log n), where r is the number of reflex vertices. <p> The definition of straight skeleton generalizes easily to disconnected polygons, polygons with holes, and even arbitrary planar straight-line graphs (although some care must be taken with vertices of degree less than two) <ref> [7] </ref>. <p> Raising Roofs, Crashing Cycles, and Playing Pool 8 (a) (b) polygon's straight skeleton; consequently, our algorithms must handle vertex events directly. See 4.2 A Subquadratic Algorithm Like earlier algorithms <ref> [8, 7] </ref>, our basic approach is to simulate the sequence of edge, split, and vertex events that define the skeleton. We view time as a third spatial dimension, so that the shrinking process becomes an upward sweep of the roof of the polygon with a horizontal plane. <p> The running time of Aichholzer and Aurenhammer's linear-space algorithm derives from the number of topological changes in a triangulation (or trapezoidal decomposition) of the shrinking polygon <ref> [7] </ref>. Although there can be fi (n 2 ) such changes in the worst case, "typical" inputs require much less work. Even for polygons specially constructed to make their algorithm run slowly, our algorithm would be slower for reasonable values of n. <p> In the unweighted case, we can improve the space bound to O (n + r 2 ) by using brute force ray-shooting to find the potential edge splits and Eppstein's quadtree to maintain reflex splits. Alternately, if we use Aichholzer and Aurenhammer's triangulation-based algorithm <ref> [7] </ref> to find reflex splits, we obtain a practical linear-space algorithm that runs in time O (n log n + nr + r 2 log r). <p> This non-locality may also prevent straight skeletons from being as useful as medial axes in applications such as mesh generation and motion planning. Aichholzer and Aurenhammer <ref> [7] </ref> observe that if the polygon contains no acute angles, then the resulting skeleton shares several properties with Voronoi diagrams.
Reference: [8] <author> O. Aichholzer, F. Aurenhammer, D. Alberts, and B. Gartner. </author> <title> A novel type of skeleton for polygons. </title> <journal> J. Universal Comput. Sci. </journal> <volume> 1(12) </volume> <pages> 752-761, </pages> <year> 1995. </year> <title> hhttp://www:iicm:edu/jucs 1 12/ a novel type ofi. </title>
Reference-contexts: 1 Introduction Suppose we are given the floor plan of a building, and a specification for the slope of its roof planes. How can we design a roof, meeting all the walls at a consistent height, with no dips or flat spots where rainwater can accumulate? Aichholzer et al. <ref> [8, 7] </ref> determined an answer: the straight skeleton. The straight skeleton of a polygon P is, as its name implies, a skeleton (one-dimensional topological retract) of the polygon formed from straight line segments. <p> See Figure 1 (b). The straight skeleton has several applications, including architecture, where it describes the shape of a fixed-slope roof rising over a given set of walls <ref> [8, 50] </ref>, and geographic information systems, where it can be used to reconstruct terrains from a given set of rivers and coastlines [7]. <p> The fastest previously published algorithms both use O (n 2 log n) time in the worst case <ref> [7, 8] </ref>; a more careful analysis shows that the running time of one of these algorithms [8] is actually O (nr log n), where r is the number of reflex vertices. <p> The fastest previously published algorithms both use O (n 2 log n) time in the worst case [7, 8]; a more careful analysis shows that the running time of one of these algorithms <ref> [8] </ref> is actually O (nr log n), where r is the number of reflex vertices. This can be further improved to O (nr + n log n) = O (n 2 ) using a quadtree-like data structure of size O (nr), which we describe in Section 2. <p> We also present a novel characterization of the unweighted straight skeleton as the projection of the lower envelope of n + O (r) triangles in IR 3 . These triangles are not (and cannot be <ref> [8] </ref>) locally defined. Nevertheless, we can exploit the structure of these triangles to obtain a "reflex-sensitive" algorithm that runs in time and space O (n 1+" +n 8=11+" r 9=11+" ) = O (n 17=11+" ). <p> Raising Roofs, Crashing Cycles, and Playing Pool 8 (a) (b) polygon's straight skeleton; consequently, our algorithms must handle vertex events directly. See 4.2 A Subquadratic Algorithm Like earlier algorithms <ref> [8, 7] </ref>, our basic approach is to simulate the sequence of edge, split, and vertex events that define the skeleton. We view time as a third spatial dimension, so that the shrinking process becomes an upward sweep of the roof of the polygon with a horizontal plane. <p> There are only two ways that a point can reenter the polygon after it leaves: either a slab endpoint overtakes an edge of the polygon, or a slab overtakes a convex vertex of the polygon. See these transitions can occur. fl Aichholzer et al. <ref> [8] </ref> show that the roof cannot be expressed as the lower envelope of partial linear functions, each function locally defined by a small neighborhood of an edge. Our reflex slabs are not locally defined. We emphasize that Lemma 4.2 holds only for unweighted straight skeletons. <p> All of these algorithms improve the previously best time bound O (nr log n), obtained by computing a sorted list of all O (nr) potential split events <ref> [8] </ref>. If the input polygon is c-oriented, we can compute its straight skeleton in time O (c 4 n polylog n).
Reference: [9] <author> M. J. Atallah, P. Callahan, and M. T. Goodrich. </author> <title> P-complete geometric problems. </title> <journal> Internat. J. Comput. Geom. Appl. </journal> <volume> 3 </volume> <pages> 443-462, </pages> <year> 1993. </year>
Reference-contexts: It seems especially unlikely that O (n 17=11 ) is the best possible time bound for constructing a motorcycle graph or a single offset polygon. Atallah et al. <ref> [9] </ref> show that the construction of weighted planar partitions is P-complete. A similar technique was used by Griffeath and Moore to prove the P-completeness of certain two-dimensional cellular automata [32].
Reference: [10] <author> D. Baraff. </author> <title> Interactive simulation of solid rigid bodies. </title> <booktitle> CGA 15(3) </booktitle> <pages> 63-75, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: These algorithms perform quite badly if the balls are very far apart or if there are few collisions. Several other collision-detection algorithms are known that are efficient, at least in practice, for many types of objects; see, for example, <ref> [10, 24, 30, 37] </ref>. Almost none of these have theoretical guarantees on their performance. In fact, like the algorithms in [38, 47], most perform well only in dense environments. Our methods yield the first known collision-detection algorithm with a guaranteed sublinear time bound per collision. Theorem 6.1.
Reference: [11] <author> J. Basch, L. J. Guibas, and J. Hershberger. </author> <title> Data structures for mobile data. </title> <booktitle> Proc. 8th ACM-SIAM Sympos. Discrete Algorithms, </booktitle> <pages> pp. 747-756. </pages> <year> 1997. </year>
Reference-contexts: Several variations of this problem have been surveyed by Shamos [51]. Basch et al. [12] observe that only the closest pair of balls can collide, and suggest simulating collisions using a kinetic data structure to efficiently maintain the closest pair. (See also <ref> [11, 33] </ref>.) In the worst case, however, the closest pair changes fi (n 2 ) times without a single collision, which makes this approach less efficient than even the most nave algorithm that simply checks every pair of balls.
Reference: [12] <author> J. Basch, L. J. Guibas, and L. Zhang. </author> <title> Proximity problems on moving points. </title> <booktitle> Proc. 13th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pp. 344-351. </pages> <year> 1997. </year>
Reference-contexts: Several variations of this problem have been surveyed by Shamos [51]. Basch et al. <ref> [12] </ref> observe that only the closest pair of balls can collide, and suggest simulating collisions using a kinetic data structure to efficiently maintain the closest pair. (See also [11, 33].) In the worst case, however, the closest pair changes fi (n 2 ) times without a single collision, which makes this
Reference: [13] <author> M. de Berg, D. Halperin, M. Overmars, J. Snoeyink, and M. van Kreveld. </author> <title> Efficient ray shooting and hidden surface removal. </title> <journal> Algorithmica 12 </journal> <pages> 30-53, </pages> <year> 1994. </year>
Reference-contexts: Theorem 3.1. Given n rays in IR 3 , we can answer lowest intersection queries for triangles in time O (n 1+" =s 1=4 ). Proof: We follow the same pattern used to construct ray shooting data structures for halfplanes and triangles in IR 3 <ref> [3, 4, 5, 13] </ref>. It suffices to construct a data structure that supports queries asking whether any of the rays intersects a query quadrilateral. <p> De Berg et al. <ref> [13] </ref> describe a data structure that supports ray shooting queries among curtains with query and update time O (n 1=3+" ).
Reference: [14] <author> M. Bern, E. Demaine, D. Eppstein, and B. Hayes. </author> <title> A disk-packing algorithm for an origami magic trick. </title> <note> To appear in Int. Conf. Fun with Algorithms, </note> <year> 1998. </year>
Reference-contexts: Techniques related to straight skeletons have also been used in origami constructions <ref> [14, 40] </ref>. Several theoretically and practically efficient algorithms are known for constructing medial axes [41, 26, 23, 35].
Reference: [15] <author> H. Blum. </author> <title> A transformation for extracting new descriptors of shape. Models for the Perception of Speech and Visual Form, </title> <journal> pp. </journal> <pages> 362-380. </pages> <publisher> MIT Press, </publisher> <year> 1967. </year>
Reference-contexts: subset of the Voronoi diagram of the vertices and edges of the polygon and consists of line segments and parabolic arcs. (Voronoi edges that meet reflex vertices of the polygon are technically not part of the medial axis.) Medial axes are used in several applications, including shape recognition and reconstruction <ref> [15, 17, 57] </ref>, mesh generation [34, 52, 55, 56], motion planning [49, 54], and computer-aided manufacturing [35, 36, 55].
Reference: [16] <author> F. L. Bookstein. </author> <title> The line-skeleton. Comput. Graph. </title> <journal> Image Process. </journal> <volume> 11 </volume> <pages> 123-137, </pages> <year> 1979. </year> <title> Raising Roofs, Crashing Cycles, and Playing Pool 17 </title>
Reference-contexts: Despite these many uses of medial axes, their curved arcs have been considered a shortcoming and have led several researchers to form piecewise-linear approximations by sampling the input [55], rectilinear Voronoi diagrams [55], or other techniques <ref> [16, 45] </ref>. The straight skeleton provides an alternate piecewise linear construction, which unlike these other approaches is not sensitive to sampling rates or to the polygon's orientation.
Reference: [17] <author> L. Calabi and W. E. Hartnett. </author> <title> Shape recognition, prairie fires, convex deficiencies and skeletons. </title> <journal> Amer. Math. </journal> <volume> Monthly 75 </volume> <pages> 335-342, </pages> <year> 1968. </year>
Reference-contexts: subset of the Voronoi diagram of the vertices and edges of the polygon and consists of line segments and parabolic arcs. (Voronoi edges that meet reflex vertices of the polygon are technically not part of the medial axis.) Medial axes are used in several applications, including shape recognition and reconstruction <ref> [15, 17, 57] </ref>, mesh generation [34, 52, 55, 56], motion planning [49, 54], and computer-aided manufacturing [35, 36, 55].
Reference: [18] <author> T. M. Chan. </author> <title> Geometric applications of a randomized optimization technique. </title> <booktitle> Proc. 14th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pp. 269-278. </pages> <year> 1998. </year>
Reference-contexts: It suffices to construct a data structure that supports queries asking whether any of the rays intersects a query quadrilateral. To answer a lowest intersection query using this data structure, we apply parametric search [46] or Chan's recent randomized reduction technique <ref> [18] </ref> to find the largest value z fl so that no ray crosses the intersection of the query triangle and the halfspace z z fl .
Reference: [19] <author> B. Chazelle, H. Edelsbrunner, L. J. Guibas, and M. Sharir. </author> <title> A singly-exponential stratification scheme for real semi-algebraic varieties and its applications. </title> <journal> Theoret. Comput. Sci. </journal> <volume> 84 </volume> <pages> 77-105, </pages> <year> 1991. </year>
Reference-contexts: Conversely, preprocessing a set of arbitrary lines for fixed-slope line queries (that is, every query line has the same slope, which is specified in advance) is equivalent to preprocessing a set of algebraic surfaces in IR 3 for point location queries. Chazelle et al. <ref> [19] </ref> describe a data structure of size O (n 3+" ) that supports such queries in O (log n) time. Agarwal and Matousek [4] describe a linear-size data structure that supports arbitrary line queries in O (n 3=4+" ) time.
Reference: [20] <author> B. Chazelle, H. Edelsbrunner, L. J. Guibas, M. Sharir, and J. Stolfi. </author> <title> Lines in space: Combinatorics and algorithms. </title> <journal> Algorithmica 15 </journal> <pages> 428-447, </pages> <year> 1996. </year>
Reference-contexts: Equivalently, the relative orientation is given by the inner product of the Plucker coordinates of the two lines <ref> [20, 53] </ref>. To determine whether any line intersects q, we use a four-level data structure, one for each edge of q. Each of the first three levels is used to find the lines oriented correctly with respect to one of the ` i . <p> We use a data structure of Agarwal and Matousek [4] that supports such queries in time O (n 1+" =s 1=4 ). Finally, for the last level, we only need to know whether a query line ` 4 lies entirely above a set of lines. Chazelle et al. <ref> [20] </ref> describe a data structure that supports such queries in time O (n 1+" =s 1=2 ). fl 3.1 Fixed-Slope Lines and Nice Triangles The most time-consuming part of answering a lowest-intersection query is finding the lines oriented positively with respect to a query line; in the remainder of this section,
Reference: [21] <author> L. P. Chew. </author> <title> Building Voronoi diagrams for convex polygons in linear expected time. </title> <type> Technical Report PCS-TR90-147, </type> <institution> Dept. Math. Comput. Sci., Dartmouth College, </institution> <year> 1986. </year>
Reference-contexts: Finally, if the input polygon is convex, the straight skeleton is identical to the (Euclidean) medial axis; consequently, we can construct it in linear time <ref> [6, 21] </ref>. Once we compute the straight skeleton, we can compute any desired mitered offset polygon from it in linear time.
Reference: [22] <author> P. </author> <title> Chew. </title> <type> personal communication, </type> <year> 1998. </year>
Reference-contexts: If c = 2, the straight skeleton is actually the medial axis Raising Roofs, Crashing Cycles, and Playing Pool 12 of the polygon in a metric whose unit circle is a rhombus; in particular, the straight skeleton of an orthogonal polygon is its L 1 medial axis <ref> [22] </ref>. In this case, we can compute the skeleton in O (n log fl n) expected time using a randomized incremental algorithm [26] or in O (n log n) worst-case time using a divide-and-conquer algorithm [41].
Reference: [23] <author> F. Chin, J. Snoeyink, and C.-A. Wang. </author> <title> Finding the medial axis of a simple polygon in linear time. </title> <booktitle> Proc. 6th Annu. Internat. Sympos. Algorithms Comput., </booktitle> <pages> pp. 382-391. </pages> <publisher> Lecture Notes Comput. Sci. 1004, Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Techniques related to straight skeletons have also been used in origami constructions [14, 40]. Several theoretically and practically efficient algorithms are known for constructing medial axes <ref> [41, 26, 23, 35] </ref>.
Reference: [24] <author> J. D. Cohen, M. C. Lin, D. Manocha, and M. K. Ponamgi. I-collide: </author> <title> An interactive and exact collision detection system for large-scale environments. </title> <booktitle> Proc. ACM Interactive 3D Graphics Conf., </booktitle> <pages> pp. 189-196. </pages> <year> 1995. </year>
Reference-contexts: These algorithms perform quite badly if the balls are very far apart or if there are few collisions. Several other collision-detection algorithms are known that are efficient, at least in practice, for many types of objects; see, for example, <ref> [10, 24, 30, 37] </ref>. Almost none of these have theoretical guarantees on their performance. In fact, like the algorithms in [38, 47], most perform well only in dense environments. Our methods yield the first known collision-detection algorithm with a guaranteed sublinear time bound per collision. Theorem 6.1.
Reference: [25] <author> J. Czyzowicz, I. Rival, and J. Urrutia. Galleries, </author> <title> light matchings and visibility graphs. </title> <booktitle> Proc. 1st Workshop Algorithms Data Struct., </booktitle> <pages> pp. 316-324. </pages> <publisher> Lecture Notes Comput. Sci. 382, Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: Motorcycle graphs are also a generalization of the weighted planar partitions introduced by Czyzowicz et al. as a tool to solve certain art gallery problems <ref> [25] </ref>. Given a sequence of n non-intersecting line segments in the plane, the weighted planar partition is obtained by extending each segment, one at a time in the order Raising Roofs, Crashing Cycles, and Playing Pool 13 presented, until each endpoint reaches another (possibly extended) segment.
Reference: [26] <author> O. Devillers. </author> <title> Randomization yields simple O(n log fl n) algorithms for difficult (n) problems. </title> <journal> Internat. J. Comput. Geom. Appl. </journal> <volume> 2(1) </volume> <pages> 97-111, </pages> <year> 1992. </year>
Reference-contexts: Techniques related to straight skeletons have also been used in origami constructions [14, 40]. Several theoretically and practically efficient algorithms are known for constructing medial axes <ref> [41, 26, 23, 35] </ref>. <p> In this case, we can compute the skeleton in O (n log fl n) expected time using a randomized incremental algorithm <ref> [26] </ref> or in O (n log n) worst-case time using a divide-and-conquer algorithm [41]. Finally, if the input polygon is convex, the straight skeleton is identical to the (Euclidean) medial axis; consequently, we can construct it in linear time [6, 21].
Reference: [27] <author> D. Eppstein. </author> <title> Dynamic Euclidean minimum spanning trees and extrema of binary functions. </title> <journal> Discrete Comput. Geom. </journal> <volume> 13 </volume> <pages> 111-122, </pages> <year> 1995. </year>
Reference-contexts: As an immediate application, we also obtain the first subquadratic algorithm for computing mitered offset polygons. Like earlier algorithms, our algorithm simulates the sequence of interactions between edges and vertices in the shrinking process described above. A technique of Eppstein <ref> [27, 28] </ref> for maintaining closest pairs reduces the problem of finding the next interaction to two dynamic range query problems: (1) Maintain a changing set of triangles in IR 3 and answer queries asking which triangle would be first hit by a query ray. (2) Maintain a changing set of rays <p> Our algorithm uses a data structure that efficiently maintains a "closest" pair of objects r 2 R and b 2 B minimizing d (r; b) as objects are inserted and deleted, using a dynamic data structure for minimization queries as a black box. Theorem 2.1 (Eppstein <ref> [27, 28] </ref>). Suppose that after P (n) preprocessing time, we can maintain a data structure of size S (n) that supports insertions, deletions, and minimization queries, each in amortized time T (n). <p> Then after O (P (n) + nT (n)) preprocessing time, we can maintain the closest pair between R and B in O (S (n)) space, O (T (n) log n) amortized insertion time, and O (T (n) log 2 n) amortized deletion time. The original statement of the theorem <ref> [27] </ref> required T (n) to be a worst-case bound on the query and update times for the minimization query structure, but the proof only requires T (n) to be an amortized time bound. (Conversely, the amortized bound given by the theorem can almost certainly be made worst-case, but this is unnecessary <p> almost certainly be made worst-case, but this is unnecessary for our results.) Eppstein previously used this technique to maintain closest and furthest bichromatic pairs among a changing set of red and blue points, and for maintaining the Euclidean minimum spanning tree of a changing set of points in the plane <ref> [27] </ref>. In our straight skeleton application, R and B will be sets of offset curve features, and d will describe the time at which some pair of features interacts. The closest pair in this setting will give us the time of the earliest interaction.
Reference: [28] <author> D. Eppstein. </author> <title> Fast hierarchical clustering and other applications of dynamic closest pairs. </title> <booktitle> Proc. 9th Annu. ACM-SIAM Sympos. Discrete Algorithms, </booktitle> <pages> pp. 619-628. </pages> <year> 1998. </year>
Reference-contexts: As an immediate application, we also obtain the first subquadratic algorithm for computing mitered offset polygons. Like earlier algorithms, our algorithm simulates the sequence of interactions between edges and vertices in the shrinking process described above. A technique of Eppstein <ref> [27, 28] </ref> for maintaining closest pairs reduces the problem of finding the next interaction to two dynamic range query problems: (1) Maintain a changing set of triangles in IR 3 and answer queries asking which triangle would be first hit by a query ray. (2) Maintain a changing set of rays <p> Our algorithm uses a data structure that efficiently maintains a "closest" pair of objects r 2 R and b 2 B minimizing d (r; b) as objects are inserted and deleted, using a dynamic data structure for minimization queries as a black box. Theorem 2.1 (Eppstein <ref> [27, 28] </ref>). Suppose that after P (n) preprocessing time, we can maintain a data structure of size S (n) that supports insertions, deletions, and minimization queries, each in amortized time T (n). <p> A simplified version of this data structure for maintaining closest pairs from non-geometric sets (for which T (n) is the trivial O (n) bound for sequential search) is described, along with other non-geometric closest pair algorithms, applications, and experiments, in a companion paper <ref> [28] </ref>. That paper also contains a special case (with r = n) of the following result, which we use later as part of a more practical simplification of our algorithm. Theorem 2.2. Suppose jRj r and jBj n for some r n.
Reference: [29] <author> D. Eppstein and J. Erickson. </author> <title> Raising roofs, crashing cycles, and playing pool: Applications of a data structure for finding pairwise interactions. </title> <booktitle> Proc. 14th Annu. ACM. Sympos. Comput. Geom., </booktitle> <pages> pp. 58-67. </pages> <year> 1998. </year>
Reference: [30] <author> A. Foisy, V. Hayward, and S. Aubry. </author> <title> The use of awareness in collision prediction. </title> <booktitle> Proc. 1990 IEEE Internat. Conf. Robotics and Automation, </booktitle> <pages> pp. 338-343. </pages> <year> 1990. </year>
Reference-contexts: These algorithms perform quite badly if the balls are very far apart or if there are few collisions. Several other collision-detection algorithms are known that are efficient, at least in practice, for many types of objects; see, for example, <ref> [10, 24, 30, 37] </ref>. Almost none of these have theoretical guarantees on their performance. In fact, like the algorithms in [38, 47], most perform well only in dense environments. Our methods yield the first known collision-detection algorithm with a guaranteed sublinear time bound per collision. Theorem 6.1.
Reference: [31] <author> E. Fredkin and T. Toffoli. </author> <title> Conservative logic. </title> <journal> Internat. J. Theoret. Phys. </journal> <volume> 21 </volume> <pages> 219-253, </pages> <booktitle> 1981/82. Proceedings of Conference on Physics of Computation, </booktitle> <address> Dedham, Mass., </address> <year> 1981. </year> <title> Raising Roofs, Crashing Cycles, and Playing Pool 18 </title>
Reference-contexts: of stationary line segments|the sides of a pool table, for example|with the same asymptotic space and time bounds. (Deciding whether a system of moving unit balls and stationary line segments undergoes a finite number of collisions is PSPACE-complete, since a polynomial-space Turing machine can be simulated by such a system <ref> [31] </ref>.) 7 Open Problems The most obvious open problem is to improve the running times of our algorithms.
Reference: [32] <author> D. Griffeath and C. Moore. </author> <title> Life Without Death is P-complete. </title> <note> Working Paper 97-05-044, </note> <institution> Santa Fe Institute, </institution> <year> 1997. </year> <note> hhttp://excite:math:wisc:edu/java/lwodpc/lwodpc:htmli. To appear in Complex Systems. </note>
Reference-contexts: Atallah et al. [9] show that the construction of weighted planar partitions is P-complete. A similar technique was used by Griffeath and Moore to prove the P-completeness of certain two-dimensional cellular automata <ref> [32] </ref>.
Reference: [33] <author> L. J. Guibas. </author> <title> Kinetic data structures: A state of the art report. </title> <booktitle> Robotics: The Algorithmic Perspective (Proc. 1998 WAFR), </booktitle> <pages> pp. </pages> ??-?? <editor> A. K. Peters, </editor> <year> 1998. </year>
Reference-contexts: Several variations of this problem have been surveyed by Shamos [51]. Basch et al. [12] observe that only the closest pair of balls can collide, and suggest simulating collisions using a kinetic data structure to efficiently maintain the closest pair. (See also <ref> [11, 33] </ref>.) In the worst case, however, the closest pair changes fi (n 2 ) times without a single collision, which makes this approach less efficient than even the most nave algorithm that simply checks every pair of balls.
Reference: [34] <author> H. N. Gursoy and N. M. Patrikalakis. </author> <title> An automatic coarse and fine surface mesh generation scheme based on medial axis transform, Part I: Algorithm. </title> <booktitle> Engineering with Computers 8 </booktitle> <pages> 121-137, </pages> <year> 1992. </year>
Reference-contexts: of the vertices and edges of the polygon and consists of line segments and parabolic arcs. (Voronoi edges that meet reflex vertices of the polygon are technically not part of the medial axis.) Medial axes are used in several applications, including shape recognition and reconstruction [15, 17, 57], mesh generation <ref> [34, 52, 55, 56] </ref>, motion planning [49, 54], and computer-aided manufacturing [35, 36, 55].
Reference: [35] <author> M. </author> <title> Held. Voronoi diagrams and offset curves of curvilinear polygons. </title> <booktitle> Comput. Aided Design 30(4) </booktitle> <pages> 287-300, </pages> <year> 1998. </year>
Reference-contexts: line segments and parabolic arcs. (Voronoi edges that meet reflex vertices of the polygon are technically not part of the medial axis.) Medial axes are used in several applications, including shape recognition and reconstruction [15, 17, 57], mesh generation [34, 52, 55, 56], motion planning [49, 54], and computer-aided manufacturing <ref> [35, 36, 55] </ref>. Despite these many uses of medial axes, their curved arcs have been considered a shortcoming and have led several researchers to form piecewise-linear approximations by sampling the input [55], rectilinear Voronoi diagrams [55], or other techniques [16, 45]. <p> The breakpoints between consecutive line segments and circular arcs in the offset curve trace out edges of the Voronoi diagram of the polygon, and the medial axis can be defined as the locus traced out by a subset of these breakpoints <ref> [35] </ref>. See Figure 1 (a). A generalization of offset curves (available for instance in drawing programs such as Adobe Illustrator) again has straight segments paralleling the polygon edges at a fixed distance, but allows the circular arcs connecting these segments to be replaced by other types of caps. <p> Techniques related to straight skeletons have also been used in origami constructions [14, 40]. Several theoretically and practically efficient algorithms are known for constructing medial axes <ref> [41, 26, 23, 35] </ref>.
Reference: [36] <author> M. Held, G. Lukacs, and L. Andor. </author> <title> Pocket machining based on contour-parallel tool paths generated by means of proximity maps. </title> <booktitle> Comput. Aided Design 26(3) </booktitle> <pages> 189-203, </pages> <month> Mar. </month> <year> 1994. </year>
Reference-contexts: line segments and parabolic arcs. (Voronoi edges that meet reflex vertices of the polygon are technically not part of the medial axis.) Medial axes are used in several applications, including shape recognition and reconstruction [15, 17, 57], mesh generation [34, 52, 55, 56], motion planning [49, 54], and computer-aided manufacturing <ref> [35, 36, 55] </ref>. Despite these many uses of medial axes, their curved arcs have been considered a shortcoming and have led several researchers to form piecewise-linear approximations by sampling the input [55], rectilinear Voronoi diagrams [55], or other techniques [16, 45].
Reference: [37] <author> P. M. Hubbard. </author> <title> Collision detection for interactive graphics applications. </title> <journal> IEEE Trans. Visualization and Computer Graphics 1(3) </journal> <pages> 218-230, </pages> <month> Sept. </month> <year> 1995. </year>
Reference-contexts: These algorithms perform quite badly if the balls are very far apart or if there are few collisions. Several other collision-detection algorithms are known that are efficient, at least in practice, for many types of objects; see, for example, <ref> [10, 24, 30, 37] </ref>. Almost none of these have theoretical guarantees on their performance. In fact, like the algorithms in [38, 47], most perform well only in dense environments. Our methods yield the first known collision-detection algorithm with a guaranteed sublinear time bound per collision. Theorem 6.1.
Reference: [38] <author> D. Kim, L. J. Guibas, and S. Shin. </author> <title> Fast collision detection among multiple moving spheres. </title> <booktitle> Proc. 13th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pp. 373-375. </pages> <year> 1997. </year>
Reference-contexts: Kim et al. <ref> [38] </ref> describe an event-driven algorithm that divides space into a uniform grid of cells and uses O (log n) time whenever a ball enters a cell, leaves a cell, or collides with another ball in the same cell; a similar approach (but for more general objects) is described by Mirtich and <p> Several other collision-detection algorithms are known that are efficient, at least in practice, for many types of objects; see, for example, [10, 24, 30, 37]. Almost none of these have theoretical guarantees on their performance. In fact, like the algorithms in <ref> [38, 47] </ref>, most perform well only in dense environments. Our methods yield the first known collision-detection algorithm with a guaranteed sublinear time bound per collision. Theorem 6.1.
Reference: [39] <author> R. Klein. </author> <title> Concrete and Abstract Voronoi Diagrams. </title> <journal> Lecture Notes Comput. Sci. </journal> <volume> 400. </volume> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: Several theoretically and practically efficient algorithms are known for constructing medial axes [41, 26, 23, 35]. Unlike the medial axis, however, the straight skeleton cannot be defined by a distance measure or as an abstract Voronoi diagram <ref> [39] </ref> (except in a few special cases, which Raising Roofs, Crashing Cycles, and Playing Pool 2 (a) (b) and dotted), and a rounded offset curve. (b) The straight skeleton and a mitered offset polygon. we describe in Section 4); consequently, its construction is considerably more difficult.
Reference: [40] <author> R. J. Lang. </author> <title> A computational algorithm for origami design. </title> <booktitle> Proc. 12th Annu. ACM Sympos. Comput. Geom., </booktitle> <pages> pp. 98-105. </pages> <year> 1996. </year>
Reference-contexts: Techniques related to straight skeletons have also been used in origami constructions <ref> [14, 40] </ref>. Several theoretically and practically efficient algorithms are known for constructing medial axes [41, 26, 23, 35].
Reference: [41] <author> D. T. Lee. </author> <title> Medial axis transformation of a planar shape. </title> <journal> IEEE Trans. Pattern Anal. Mach. Intell. </journal> <volume> PAMI-4:363-369, </volume> <year> 1982. </year>
Reference-contexts: Techniques related to straight skeletons have also been used in origami constructions [14, 40]. Several theoretically and practically efficient algorithms are known for constructing medial axes <ref> [41, 26, 23, 35] </ref>. <p> In this case, we can compute the skeleton in O (n log fl n) expected time using a randomized incremental algorithm [26] or in O (n log n) worst-case time using a divide-and-conquer algorithm <ref> [41] </ref>. Finally, if the input polygon is convex, the straight skeleton is identical to the (Euclidean) medial axis; consequently, we can construct it in linear time [6, 21]. Once we compute the straight skeleton, we can compute any desired mitered offset polygon from it in linear time.
Reference: [42] <author> S. Lisberger, director. Tron. Walt Disney Productions, </author> <year> 1982. </year> <title> Motion picture, </title> <address> 96 minutes. </address>
Reference-contexts: After all the bikes either crash or escape to infinity, their tracks form a planar directed graph, which we call the motorcycle graph. See Figure 7. The problem is to construct this graph as quickly as possible. A similar problem was previously considered by Lisberger et al. <ref> [42] </ref>. If we form a non-simple polygon in which each motorcycle is replaced by a small hole in the form of a sharp isosceles triangle, the straight skeleton edges traced out by the sharp reflex vertices of these triangles will approximate the motorcycle graph.
Reference: [43] <author> J. Matousek. </author> <title> Reporting points in halfspaces. </title> <journal> Comput. Geom. Theory Appl. </journal> <volume> 2(3) </volume> <pages> 169-186, </pages> <year> 1992. </year>
Reference-contexts: All the data structures we describe can be constructed in time O (s 1+" ) and can be modified to support insertions and deletions in time O (s 1+" =n), at the expense of at most an O (n " ) factor in both the preprocessing and query times <ref> [1, 5, 43] </ref>. We also Raising Roofs, Crashing Cycles, and Playing Pool 5 use the standard technique of composing several geometric range searching data structures into a single multi-level data structure.
Reference: [44] <author> J. Matousek. </author> <title> Range searching with efficient hierarchical cuttings. </title> <journal> Discrete Comput. Geom. </journal> <volume> 10(2) </volume> <pages> 157-182, </pages> <year> 1993. </year>
Reference-contexts: To detect intersections, we preprocess the rays into a multi-level data structure. The first level is a halfspace range searching data structure of Matousek <ref> [44] </ref> that lets us (implicitly) find the rays intersecting the plane containing the query quadrilateral q, in time O (n 1+" =s 1=3 ). This reduces the problem to detecting intersections between q and a set of lines. <p> This technique was previously used by Matousek for other o*ine range searching problems <ref> [44] </ref>.
Reference: [45] <author> M. McAllister, D. Kirkpatrick, and J. Snoeyink. </author> <title> A compact piecewise-linear Voronoi diagram for convex sites in the plane. </title> <journal> Discrete Comput. Geom. </journal> <volume> 15 </volume> <pages> 73-105, </pages> <year> 1996. </year>
Reference-contexts: Despite these many uses of medial axes, their curved arcs have been considered a shortcoming and have led several researchers to form piecewise-linear approximations by sampling the input [55], rectilinear Voronoi diagrams [55], or other techniques <ref> [16, 45] </ref>. The straight skeleton provides an alternate piecewise linear construction, which unlike these other approaches is not sensitive to sampling rates or to the polygon's orientation.
Reference: [46] <author> N. Megiddo. </author> <title> Applying parallel computation algorithms in the design of serial algorithms. </title> <editor> J. </editor> <booktitle> ACM 30 </booktitle> <pages> 852-865, </pages> <year> 1983. </year>
Reference-contexts: It suffices to construct a data structure that supports queries asking whether any of the rays intersects a query quadrilateral. To answer a lowest intersection query using this data structure, we apply parametric search <ref> [46] </ref> or Chan's recent randomized reduction technique [18] to find the largest value z fl so that no ray crosses the intersection of the query triangle and the halfspace z z fl .
Reference: [47] <author> B. Mirtich and J. Canny. </author> <title> Impulse-based simulation of rigid bodies. Symposium on Interactive 3D Graphics. </title> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: an event-driven algorithm that divides space into a uniform grid of cells and uses O (log n) time whenever a ball enters a cell, leaves a cell, or collides with another ball in the same cell; a similar approach (but for more general objects) is described by Mirtich and Canny <ref> [47] </ref>. These algorithms perform quite badly if the balls are very far apart or if there are few collisions. Several other collision-detection algorithms are known that are efficient, at least in practice, for many types of objects; see, for example, [10, 24, 30, 37]. <p> Several other collision-detection algorithms are known that are efficient, at least in practice, for many types of objects; see, for example, [10, 24, 30, 37]. Almost none of these have theoretical guarantees on their performance. In fact, like the algorithms in <ref> [38, 47] </ref>, most perform well only in dense environments. Our methods yield the first known collision-detection algorithm with a guaranteed sublinear time bound per collision. Theorem 6.1.
Reference: [48] <author> S. Mohaban and M. Sharir. </author> <title> Ray shooting amidst spheres in three dimensions and related problems. </title> <journal> SIAM J. Comput. </journal> <volume> 26 </volume> <pages> 654-674, </pages> <year> 1997. </year> <title> Raising Roofs, Crashing Cycles, and Playing Pool 19 </title>
Reference-contexts: Proof sketch: Theorem 2.1 reduces the billiard problem to maintaining a ray shooting data structure for a changing set of elliptical cylinders in IR 3 with circular horizontal cross-sections. Using a technique similar to Mohaban and Sharir's algorithm for ray shooting among spheres <ref> [48] </ref>, we express each cylinder ray shooting query as a composition of several four- and five-dimensional semialgebraic range queries, which we can answer using techniques of Agarwal and Matousek [4].
Reference: [49] <author> C. O'Dunlaing and C. K. Yap. </author> <title> A "retraction" method for planning the motion of a disk. </title> <journal> J. </journal> <volume> Algorithms 6 </volume> <pages> 104-111, </pages> <year> 1985. </year>
Reference-contexts: the polygon and consists of line segments and parabolic arcs. (Voronoi edges that meet reflex vertices of the polygon are technically not part of the medial axis.) Medial axes are used in several applications, including shape recognition and reconstruction [15, 17, 57], mesh generation [34, 52, 55, 56], motion planning <ref> [49, 54] </ref>, and computer-aided manufacturing [35, 36, 55]. Despite these many uses of medial axes, their curved arcs have been considered a shortcoming and have led several researchers to form piecewise-linear approximations by sampling the input [55], rectilinear Voronoi diagrams [55], or other techniques [16, 45].
Reference: [50] <author> A. Recuaero and J. P. </author> <title> Gutierrez. </title> <booktitle> Sloped roofs for architectural CAD systems. Microcomputers in Civil Engineering 8 </booktitle> <pages> 147-159, </pages> <year> 1993. </year>
Reference-contexts: See Figure 1 (b). The straight skeleton has several applications, including architecture, where it describes the shape of a fixed-slope roof rising over a given set of walls <ref> [8, 50] </ref>, and geographic information systems, where it can be used to reconstruct terrains from a given set of rivers and coastlines [7].
Reference: [51] <author> M. I. Shamos. </author> <title> The Illustrated Encyclopedia of Billiards. </title> <publisher> Lyons and Burford Publishers, </publisher> <year> 1993. </year>
Reference-contexts: Several variations of this problem have been surveyed by Shamos <ref> [51] </ref>.
Reference: [52] <author> V. Srinivasan, L. R. Nackman, J.-M. Tang, and S. N. Meshkat. </author> <title> Automatic mesh generation using the symmetric axis transform of polygonal domains. </title> <booktitle> Proc. IEEE 80(9) </booktitle> <pages> 1485-1501, </pages> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: of the vertices and edges of the polygon and consists of line segments and parabolic arcs. (Voronoi edges that meet reflex vertices of the polygon are technically not part of the medial axis.) Medial axes are used in several applications, including shape recognition and reconstruction [15, 17, 57], mesh generation <ref> [34, 52, 55, 56] </ref>, motion planning [49, 54], and computer-aided manufacturing [35, 36, 55].
Reference: [53] <author> J. Stolfi. </author> <title> Oriented Projective Geometry: A Framework for Geometric Computations. </title> <publisher> Academic Press, </publisher> <address> New York, NY, </address> <year> 1991. </year>
Reference-contexts: Equivalently, the relative orientation is given by the inner product of the Plucker coordinates of the two lines <ref> [20, 53] </ref>. To determine whether any line intersects q, we use a four-level data structure, one for each edge of q. Each of the first three levels is used to find the lines oriented correctly with respect to one of the ` i .
Reference: [54] <author> J. A. Storer and J. H. Reif. </author> <title> Shortest paths in the plane with polygonal obstacles. </title> <editor> J. </editor> <booktitle> ACM 41(5) </booktitle> <pages> 982-1012, </pages> <year> 1994. </year>
Reference-contexts: the polygon and consists of line segments and parabolic arcs. (Voronoi edges that meet reflex vertices of the polygon are technically not part of the medial axis.) Medial axes are used in several applications, including shape recognition and reconstruction [15, 17, 57], mesh generation [34, 52, 55, 56], motion planning <ref> [49, 54] </ref>, and computer-aided manufacturing [35, 36, 55]. Despite these many uses of medial axes, their curved arcs have been considered a shortcoming and have led several researchers to form piecewise-linear approximations by sampling the input [55], rectilinear Voronoi diagrams [55], or other techniques [16, 45].
Reference: [55] <author> A. Sudhalkar, L. Gursoz, and F. Prinz. </author> <title> Box-skeletons of discrete solids. </title> <booktitle> Comput. Aided Design 28 </booktitle> <pages> 507-517, </pages> <year> 1996. </year>
Reference-contexts: of the vertices and edges of the polygon and consists of line segments and parabolic arcs. (Voronoi edges that meet reflex vertices of the polygon are technically not part of the medial axis.) Medial axes are used in several applications, including shape recognition and reconstruction [15, 17, 57], mesh generation <ref> [34, 52, 55, 56] </ref>, motion planning [49, 54], and computer-aided manufacturing [35, 36, 55]. <p> line segments and parabolic arcs. (Voronoi edges that meet reflex vertices of the polygon are technically not part of the medial axis.) Medial axes are used in several applications, including shape recognition and reconstruction [15, 17, 57], mesh generation [34, 52, 55, 56], motion planning [49, 54], and computer-aided manufacturing <ref> [35, 36, 55] </ref>. Despite these many uses of medial axes, their curved arcs have been considered a shortcoming and have led several researchers to form piecewise-linear approximations by sampling the input [55], rectilinear Voronoi diagrams [55], or other techniques [16, 45]. <p> Despite these many uses of medial axes, their curved arcs have been considered a shortcoming and have led several researchers to form piecewise-linear approximations by sampling the input <ref> [55] </ref>, rectilinear Voronoi diagrams [55], or other techniques [16, 45]. The straight skeleton provides an alternate piecewise linear construction, which unlike these other approaches is not sensitive to sampling rates or to the polygon's orientation. <p> Despite these many uses of medial axes, their curved arcs have been considered a shortcoming and have led several researchers to form piecewise-linear approximations by sampling the input <ref> [55] </ref>, rectilinear Voronoi diagrams [55], or other techniques [16, 45]. The straight skeleton provides an alternate piecewise linear construction, which unlike these other approaches is not sensitive to sampling rates or to the polygon's orientation.
Reference: [56] <author> T. K. H. Tam and C. G. Armstrong. </author> <title> 2D finite element mesh generation by medial axis subdivision. </title> <booktitle> Advances in Engineering Software and Workstations 13(5-6):313-324, </booktitle> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: of the vertices and edges of the polygon and consists of line segments and parabolic arcs. (Voronoi edges that meet reflex vertices of the polygon are technically not part of the medial axis.) Medial axes are used in several applications, including shape recognition and reconstruction [15, 17, 57], mesh generation <ref> [34, 52, 55, 56] </ref>, motion planning [49, 54], and computer-aided manufacturing [35, 36, 55].
Reference: [57] <author> P. J. Vermeer. </author> <title> Medial Axis Transform to Boundary Representation Conversion. </title> <type> Ph.D. thesis, </type> <institution> CS Dept., Purdue University, West Lafayette, Indiana 47907-1398, USA, </institution> <year> 1994. </year>
Reference-contexts: subset of the Voronoi diagram of the vertices and edges of the polygon and consists of line segments and parabolic arcs. (Voronoi edges that meet reflex vertices of the polygon are technically not part of the medial axis.) Medial axes are used in several applications, including shape recognition and reconstruction <ref> [15, 17, 57] </ref>, mesh generation [34, 52, 55, 56], motion planning [49, 54], and computer-aided manufacturing [35, 36, 55].
References-found: 57

