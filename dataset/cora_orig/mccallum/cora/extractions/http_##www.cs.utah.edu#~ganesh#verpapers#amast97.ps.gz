URL: http://www.cs.utah.edu/~ganesh/verpapers/amast97.ps.gz
Refering-URL: http://www.cs.utah.edu/~ganesh/verpapers.html
Root-URL: 
Email: ganesh@cs.utah.edu  
Title: Teaching Formal Methods to Computer System Designers  
Author: Ganesh Gopalakrishnan 
Address: Salt Lake City, UT 84112  
Affiliation: Department of Computer Science University of Utah,  
Abstract: The push to take advantage of the seemingly ever-growing VLSI fabrication densities has resulted in extremely complex processor, memory, and I/O structures over short periods of time which, on one hand, make cheap and fast computing available for general use but, on the other hand, make the complexity barrier a designer has to climb progressively higher and higher. This makes the understanding of, and proper design involving even the simplest of computing components a chore that is hinged on trial and error, requiring a steep learning curve to be ascented, with very little reusable knowledge acquired in the process. Formal Methods (FM) are aimed at putting computer system design on a sure-footing, much like other engineering professions have conquered complexity by developing sound principles for design. However, unless formal methods are taught to designers in a manner that they can employ in real designs, the adoption and improvement of these methods will be considerably hampered. Unfortunately, teaching formal methods to system designers who often have very little formal training in the short time periods that they typically have available is a serious challenge to be overcome. In this paper, we discuss the organization for a short course that addresses these issues. We point out the extreme importance of: (i) selecting a variety of examples that relate to real-life situations, (ii) taking the time to revisit time-tested ideas in FM, and developing straightforward (and much more easily accessible) explanations for them, (iii) giving designers tools that are very easy to learn from, and provide immediate and significant rewards, and (iv) pointing designers to the `right set of papers' that are well suited to their background and learning intent. An actual graduate level course that was taught with these objectives, and the result from our experience are reported in this paper. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Francisco Corella, Robert Shaw, and Cui Zhang. </author> <title> A formal proof of absence of deadlock for any acyclic network of pci buses. </title> <booktitle> In Hardware Description Languages and their Applications, </booktitle> <pages> pages 134-156. </pages> <publisher> Chapman Hall, </publisher> <year> 1997. </year>
Reference-contexts: Detrimental effects of this situation can be seen everywhere; for examples, system design projects slip their schedule due to bugs that persist, system specifications emerge flawed (e.g. <ref> [1] </ref>), and in extreme cases (and Supported in part by DARPA under contract #DABT6396C0094 (UV), and NSF MIP MIP-9321836. 1 often in dramatic fashions) systems fail! The understanding of, and proper design involving even the simplest of computing components becomes a chore that is hinged on trial and error, requiring a <p> We emphasize taking much simpler examples such as pipelined FIFO queues in the context of which the basic ideas are far easier to present. The topic of memory models is growing in importance for system designers (e.g., see <ref> [1] </ref>). Yet, the literature in this area is suffering from the lack of formal rigor. For example, reference textbooks often contain flawed information, and papers often call different things by the same name. <p> It is also important that designers try to agree on standard terminology, for the number of applications where these concepts are needed is growing, for example in processor designs [36, Appendix G] and in I/O subsystems <ref> [1, 37] </ref>. Last, but not least, concepts in memory models can be intuitively understood through experimentation using explicit enumeration tools. See [34] for details.
Reference: [2] <author> David Dill and John Rushby. </author> <title> Acceptance of formal methods: Lessons from hardware design. </title> <journal> IEEE Computer, </journal> (4):23-24, April 1996. 
Reference-contexts: Formal Methods are aimed at putting computer system design on a sure-footing, much like other engineering professions have conquered complexity by developing sound principles for design. Formal Methods are enjoying a growing success in the CAD and computer industry <ref> [2] </ref>. However, unless formal methods are taught to practising designers in a manner that they can employ in their real designs, serious adoption and improvement of these methods will be considerably hampered.
Reference: [3] <author> Vaughan Pratt. </author> <title> Anatomy of the pentium bug. </title> <booktitle> In TAPSOFT'95: Theory and Practice of Software Development, </booktitle> <pages> pages 97-107, </pages> <address> 1995. </address> <publisher> Springer Verlag LNCS 915. </publisher>
Reference-contexts: We will also examine related techniques for reasoning about iterative programs, notably subgoal induction, again in an example-driven fashion. Arithmetic circuit verification forms an important and timely topic, especially prompted by recent errors in commercial products <ref> [3, 4] </ref>. In Section 6, we will examine intuitive descriptions of these errors. The importance of presenting complex situations employing very intuitive analogies 2 that have nearly the same information content as formal mathematical notations about the actual problem will be emphasized in this section. <p> However, any attempt to describe what actually went wrong with the Intel Pentium processor in a short amount of time proves to be a challenge. After much searching around, we located the two references <ref> [3, 27] </ref> that describe the problem very well. These are described in Sections 6.1 and 6.2 respectively. 6.1 A high-level description of SRT division and its invariants The SRT division algorithm is very similar to the paper and pencil method for division learnt in high-school. <p> The main tricks are to hide the delay of quotient selection by optimistically predicting the next quotient digit through simple table lookup and correcting for possible "over-estimations" to the selected quotient digit in the subsequent iteration. The clearest presentation we have seen is that from Pratt <ref> [3] </ref> in which the author models the problem using an analogy. A robot called 2 Try running the program with input 2 2 1. <p> As the number of cycles of iteration approaches infinity, Robbie's abscissa asymptotically approaches 3 (R L). Further details are in <ref> [3] </ref>. 6.2 Uncovering flaws in the Pentium quotient lookup table One nice aspect of the gist of [3] given above is that it motivates all the loop invariants involved in the Pentium SRT algorithm at a "gut level". <p> As the number of cycles of iteration approaches infinity, Robbie's abscissa asymptotically approaches 3 (R L). Further details are in <ref> [3] </ref>. 6.2 Uncovering flaws in the Pentium quotient lookup table One nice aspect of the gist of [3] given above is that it motivates all the loop invariants involved in the Pentium SRT algorithm at a "gut level".
Reference: [4] <institution> URL of Pentium 2 Error, </institution> <note> http://www.x86.org/secrets/Dan0411.html. </note>
Reference-contexts: We will also examine related techniques for reasoning about iterative programs, notably subgoal induction, again in an example-driven fashion. Arithmetic circuit verification forms an important and timely topic, especially prompted by recent errors in commercial products <ref> [3, 4] </ref>. In Section 6, we will examine intuitive descriptions of these errors. The importance of presenting complex situations employing very intuitive analogies 2 that have nearly the same information content as formal mathematical notations about the actual problem will be emphasized in this section.
Reference: [5] <author> Randy Bryant. </author> <title> Symbolic boolean manipulation with ordered binary decision diagrams. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 40(2) </volume> <pages> 293-318, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: We will conclude the paper in Section 9 with a summary of other topics that were covered as well as those that were omitted. One notable omission is that of Binary Decision Diagram (BDD, <ref> [5] </ref>)- based methods: most courses on formal methods would be considered incomplete without it.
Reference: [6] <author> Gerard J. Holzmann. </author> <title> Tutorial: Design and validation of protocols. </title> <journal> Computer Networks and ISDN Systems, </journal> <volume> 25(9) </volume> <pages> 981-1017, </pages> <year> 1993. </year> <month> 14 </month>
Reference-contexts: The importance of creating verification models ("building prototypes" as Holzmann terms it <ref> [6] </ref>) cannot be over-emphasized. It must come well before any specific logics or verification procedures are discussed. <p> An example such as the distributed list protocol also serves other useful purposes. One can teach how to write simple properties using Never automata <ref> [6] </ref> (Buchi automata that express the complement of the property being checked). At first, it may be prudent to teach the use of Never automata merely for specifying invariance properties and simple liveness properties. This approach is superior to that using monitor processes [6] as it considerably reduces the generated state <p> to write simple properties using Never automata <ref> [6] </ref> (Buchi automata that express the complement of the property being checked). At first, it may be prudent to teach the use of Never automata merely for specifying invariance properties and simple liveness properties. This approach is superior to that using monitor processes [6] as it considerably reduces the generated state space. We have found that postponing discussions about linear-time temporal logic (LTL) is a good idea, as automatons are more familiar than formal logic to most designers.
Reference: [7] <author> John Rushby. </author> <title> Formal methods and their role in the certification of critical systems. </title> <type> Technical Report CSL-95-1, </type> <institution> SRI International, </institution> <address> Menlo Park, </address> <month> March </month> <year> 1995. </year>
Reference-contexts: In addition to discussing realistic problems and emphasizing the creation of verification models, one must choose classes of examples that do arise in practice and that tend to clearly illustrate the futility of conventional methods. As Rushby points out <ref> [7] </ref>, formal methods are ideally applied to situations where conventional methods do not fare well. The domain that I chose for this was the design of concurrent reactive protocols.
Reference: [8] <author> Gerard J. Holzmann. </author> <title> What's new in spin version 2.0, </title> <month> January </month> <year> 1995. </year> <title> AT&T Internal Report that comes with the SPIN distribution. </title>
Reference-contexts: A simple example of this nature de-mystifies explicit enumeration, introduces the idea of storing states in hash-tables, and sets the stage for more advanced topics (to be discussed in the following sections). It is also important to experiment early with tools such as xspin <ref> [8] </ref> which provides an intuitive grasp of explicit enumeration by providing visual feedback of the execution as well as of error-traces through message sequence charts and other mechanisms. <p> LTL translator in xspin: At this stage, students will be ready to experiment with simple LTL formulas that can be typed into the xspin <ref> [8] </ref> system and see the translated Never automaton code generated. 5 On teaching first-order reasoning 5.1 Rudiments of classical first-order logic Teaching the rudiments of first-order logic and the notions of validity, satisfiability, models, and semi-decidability can be accomplished in a very time efficient and motivating fashion by following [21, Chapter
Reference: [9] <author> Seungjoon Park and David L. Dill. </author> <title> Protocol verification by aggregation of distributed transactions. </title> <booktitle> In Computer Aided Verification, </booktitle> <pages> pages 300-309, </pages> <address> New Brunswick, NJ, USA, </address> <month> July </month> <year> 1996. </year>
Reference-contexts: A useful contribution yet to be made by researchers in this area is to systematically catalog such all tricks. In our example course, the first large example taken up was a distributed link list management protocol from <ref> [9] </ref>. This example has considerable conceptual complexity in terms of the many possible concurrent interleavings, and is also realistic (arises in many distributed cache coherence protocols). In the context of this example, other tool-specific modeling tricks also came to light. For example, the modeling in [9] was action centric in that <p> link list management protocol from <ref> [9] </ref>. This example has considerable conceptual complexity in terms of the many possible concurrent interleavings, and is also realistic (arises in many distributed cache coherence protocols). In the context of this example, other tool-specific modeling tricks also came to light. For example, the modeling in [9] was action centric in that each action is captured as a Murphi rule. In the context of SPIN, it was discovered that a process centric approach where each linked list cell is modeled by one process is significantly more efficient in terms of reduced state vector sizes. <p> Discussing this approach on simple contrived examples such as simple pipelined FIFO queues facilitates easy understanding of the key ideas. The use of completion functions introduced in [29] is a basic idea that finds many applications in the area of concurrent system verification; see <ref> [9] </ref> for other examples. An exhaustive survey of processor verification methods would take far too much time to cover in a course. Fortunately, many excellent references are available in this area (for example [30]). 8 Memory models The area of memory models is growing in importance for system-level designers.
Reference: [10] <author> Norris Ip and David Dill. </author> <title> Verifying systems with replicated components in murphi. </title> <booktitle> In Computer Aided Verification, </booktitle> <pages> pages 147-158, </pages> <address> New Brunswick, NJ, USA, </address> <month> July </month> <year> 1996. </year>
Reference-contexts: Another valuable exercise to assign in this context is to determine the minimum number of distributed linked list cells to include in the model before a saturation <ref> [10] </ref> of all observable properties is attained. Such an exercise forces designers to consider the nature of multiple event interactions, alerting them to the non-trivial nature of the problem of finding finite network invariants [11].
Reference: [11] <author> Kenneth L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Press, </publisher> <year> 1993. </year>
Reference-contexts: Such an exercise forces designers to consider the nature of multiple event interactions, alerting them to the non-trivial nature of the problem of finding finite network invariants <ref> [11] </ref>.
Reference: [12] <author> C. Norris Ip and David L. Dill. </author> <title> Better verification through symmetry. </title> <booktitle> In Int'l Conference on Computer Hardware Description Language, </booktitle> <year> 1993. </year>
Reference-contexts: Among these, the topics of symmetry reduction <ref> [12, 13] </ref> and partial-order reduction [14-16] are important to cover in detail.
Reference: [13] <author> Ratan Nalumasu and Ganesh Gopalakrishnan. </author> <title> Explicit-enumeration based verification made memory-efficient. </title> <booktitle> In Proceedings of the 1995 Conference on Computer Hardware Description Languages (CHDL'95), Chiba, Japan, </booktitle> <pages> pages 617-622, </pages> <year> 1995. </year>
Reference-contexts: Among these, the topics of symmetry reduction <ref> [12, 13] </ref> and partial-order reduction [14-16] are important to cover in detail. <p> It is necessary to canonicalize every un-normalized state (such as "philosopher #2 grabs fork") and continue the search from the normalized state vector. To illustrate this subtle point, a simple example such as discussed in <ref> [13] </ref> suffices. 4.2 Partial order reduction The basic ideas behind partial order reduction are fundamental in nature, arising in many contexts| for example, even in compilers for parallel execution [17]. Seminal ideas behind partial-order reduction can be found even in papers written before those commonly cited nowadays [18].
Reference: [14] <author> Patrice Godefroid. </author> <title> Partial-Order Methods for the Verification of Concurrent Systems: An approach to the State-Explosion Problem. </title> <type> PhD thesis, </type> <institution> Univerite De Liege, </institution> <year> 1994-95. </year>
Reference: [15] <author> Gerard Holzmann and Doron Peled. </author> <title> An improvement in formal verification. </title> <booktitle> In FORTE, </booktitle> <address> Bern, Switzerland, </address> <month> October </month> <year> 1994. </year>
Reference: [16] <author> Ratan Nalumasu and Ganesh Gopalakrishnan. </author> <title> A new partial order reduction algorithm for concurrent system verification. </title> <booktitle> In Proceedings of the 1997 Computer Hardware Description Languages, </booktitle> <address> Toledo, Spain, </address> <month> April </month> <year> 1997. </year>
Reference-contexts: The algorithm of pursuing moves from persistent sets sometimes ends up ignoring certain processes. The ignoring problem, as well as two solutions to the problem discussed in <ref> [16] </ref> are worth presenting at this stage.
Reference: [17] <author> Martin Rinard and Pedro Diniz. </author> <title> Commutativity analysis: A new analysis framework for parallelizing compilers. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI'96), </booktitle> <pages> pages 54-67, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: To illustrate this subtle point, a simple example such as discussed in [13] suffices. 4.2 Partial order reduction The basic ideas behind partial order reduction are fundamental in nature, arising in many contexts| for example, even in compilers for parallel execution <ref> [17] </ref>. Seminal ideas behind partial-order reduction can be found even in papers written before those commonly cited nowadays [18].
Reference: [18] <author> Richard J. Lipton. </author> <title> Reduction: A method of proving properties of parallel programs. </title> <journal> CACM, </journal> <volume> 18(12) </volume> <pages> 717-721, </pages> <month> December </month> <year> 1975. </year>
Reference-contexts: Seminal ideas behind partial-order reduction can be found even in papers written before those commonly cited nowadays <ref> [18] </ref>. The idea behind partial-order reduction is to detect, at run-time, multiple interleavings of actions that can arise, and examine only some of these interleavings, without changing the truth-value of the properties being checked.
Reference: [19] <author> Moshe Vardi. </author> <title> An automata-theoretic approach to linear temporal logic. </title> <booktitle> In Logics for Concur-rency: Structure versus Automata, </booktitle> <pages> pages 238-266, </pages> <year> 1995. </year> <note> LNCS 1043. </note>
Reference-contexts: Three topics can be discussed: Automata on infinite words (excerpts from <ref> [19] </ref>:) This paper discusses the basic differences between deterministic finite automata (DFA) and automata on infinite words (especially Buchi automata). Although covering the whole paper may not be possible, going through its initial sections can be very helpful.
Reference: [20] <author> C. Courcoubetis, M. Vardi, P. Wolper, and M. Yannakakis. </author> <title> Memory-efficient algorithms for the verification of temporal properties. </title> <booktitle> Formal Methods in System Design, </booktitle> (1):275-288, 1992. 
Reference-contexts: One can go further by extending the analogy into the realm of product construction as in Figures 5 (b) and (c), of incorrect and correct solutions respectively. On-the-fly liveness checking algorithm <ref> [20] </ref>: This paper provides a very interesting discussion of Buchi acceptance checking using the idea of a cycle-detection depth first search (DFS) nested inside the regular depth first search of explicit enumeration. The nested DFS is carried out starting from "seed" states enumerated in post order.
Reference: [21] <author> Zohar Manna. </author> <title> Mathematical Theory of Computation. </title> <publisher> McGraw-Hill, </publisher> <year> 1974. </year>
Reference-contexts: xspin [8] system and see the translated Never automaton code generated. 5 On teaching first-order reasoning 5.1 Rudiments of classical first-order logic Teaching the rudiments of first-order logic and the notions of validity, satisfiability, models, and semi-decidability can be accomplished in a very time efficient and motivating fashion by following <ref> [21, Chapter 2] </ref>. A very satisfying proof to do in class would be the semi-decidability of first-order logic by reducing the Post correspondence problem to the semi-decidability problem, as discussed in this reference.
Reference: [22] <author> Jon Bentley. </author> <title> Programming Pearls. </title> <publisher> Addison Wesley, </publisher> <year> 1986. </year> <month> 15 </month>
Reference-contexts: Such a proof introduces some of the basic tricks used to construct falsifying interpretations. 10 5.2 Rudiments of Floyd/Hoare logic Knowing the rudiments of first-order logic sets the stage for appreciating program logics. One treatment we have found particularly satisfying is the chapter from Bentley's book <ref> [22, Chapter 4] </ref> (reprinted from his popular column "Programming Pearls"). With respect to the Binary search example discussed in this book, one can very easily motivate the construction of loop invariants. We found it easier to discuss this subject with respect to a flow-chart representation of Binary search.
Reference: [23] <author> Robert Sedgewick. </author> <title> Algorithms. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year> <note> Reprinted with Corrections, </note> <month> August </month> <year> 1984. </year>
Reference-contexts: A homework assigned to prove a bubble sort program presented in <ref> [23, Page 99] </ref> proved to be very educational: the program is flawed! 2 The fact that a very unusual version of bubble sort that is hard to understand in the first place, and even harder to analyze using Floyd/Hoare logic turns out to be flawed holds a valuable lesson, indeed! 5.3
Reference: [24] <author> James Morris and Benjamin Wegbreit. </author> <title> Subgoal induction. </title> <journal> Communications of the ACM, </journal> <volume> 20(4) </volume> <pages> 209-222, </pages> <month> April </month> <year> 1977. </year>
Reference-contexts: fact that a very unusual version of bubble sort that is hard to understand in the first place, and even harder to analyze using Floyd/Hoare logic turns out to be flawed holds a valuable lesson, indeed! 5.3 Subgoal induction The subgoal induction proof technique is discussed in many references (e.g. <ref> [24, 25] </ref>) and forms a topic that is easily taught and whose benefits are easily appreciated.
Reference: [25] <author> Steven D. Johnson. </author> <title> Synthesis of Digital Designs from Recursion Equations. </title> <publisher> MIT Press, </publisher> <year> 1983. </year> <note> An ACM Distinguished Dissertation. </note>
Reference-contexts: fact that a very unusual version of bubble sort that is hard to understand in the first place, and even harder to analyze using Floyd/Hoare logic turns out to be flawed holds a valuable lesson, indeed! 5.3 Subgoal induction The subgoal induction proof technique is discussed in many references (e.g. <ref> [24, 25] </ref>) and forms a topic that is easily taught and whose benefits are easily appreciated.
Reference: [26] <author> Michael Gordon. </author> <title> Programming Language Theory and its Implementation. </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: In our course, we took a non-trivial example|the pattern matching function matchfn of <ref> [26, Page 183] </ref>|and worked out a hand-proof of the function using subgoal induction. 6 Arithmetic circuit verification examples Arithmetic circuit verification is a timely topic to discuss in order to motivate formal methods.
Reference: [27] <author> Randy Bryant. </author> <title> Bit-level analysis of an srt divider circuit. </title> <type> Technical Report CMU-CS-95-140, </type> <institution> Carnegie Mellon University, </institution> <month> April </month> <year> 1995. </year>
Reference-contexts: However, any attempt to describe what actually went wrong with the Intel Pentium processor in a short amount of time proves to be a challenge. After much searching around, we located the two references <ref> [3, 27] </ref> that describe the problem very well. These are described in Sections 6.1 and 6.2 respectively. 6.1 A high-level description of SRT division and its invariants The SRT division algorithm is very similar to the paper and pencil method for division learnt in high-school.
Reference: [28] <institution> URL http://www.cs.cmu.edu:8001/afs/cs.cmu.edu/user/bryant/www/home.html. </institution>
Reference: [29] <author> Jerry Burch and David Dill. </author> <title> Pipelined processor verification. </title> <booktitle> In Proceedings of Computer-Aided Verification, </booktitle> <year> 1994. </year>
Reference-contexts: One paper that has received wide interest is that of Burch and Dill <ref> [29] </ref>. Their verification criterion (Figure 6) is 12 based on induction on the length of instruction traces. <p> Discussing this approach on simple contrived examples such as simple pipelined FIFO queues facilitates easy understanding of the key ideas. The use of completion functions introduced in <ref> [29] </ref> is a basic idea that finds many applications in the area of concurrent system verification; see [9] for other examples. An exhaustive survey of processor verification methods would take far too much time to cover in a course.
Reference: [30] <author> Mandayam Srivas and Steven Miller. </author> <title> Formal verification of an avionics microprocessor. </title> <type> Technical Report SRI-CSL-95-4, </type> <institution> SRI International, </institution> <address> Menlo Park, CA, </address> <year> 1995. </year>
Reference-contexts: An exhaustive survey of processor verification methods would take far too much time to cover in a course. Fortunately, many excellent references are available in this area (for example <ref> [30] </ref>). 8 Memory models The area of memory models is growing in importance for system-level designers. This is an area where not using formal notation can lead to many ambiguities. For example, there are many nonequivalent memory models that are all called processor consistency [31, 32] in published literature.
Reference: [31] <author> Mustaq Ahamad, Rida Bazzi, Ranjit John, Prince Kohli, and Gil Neiger. </author> <title> The power of processor consistency. </title> <type> Technical Report GIT-CC-92/34, </type> <institution> Georgia Institute of Technology, </institution> <year> 1992. </year> <note> Revised 1993; FTP path: ftp.cc.gatech.edu/pub/tech reports. </note>
Reference-contexts: This is an area where not using formal notation can lead to many ambiguities. For example, there are many nonequivalent memory models that are all called processor consistency <ref> [31, 32] </ref> in published literature. <p> A very famous reference textbook [33] goes further to claim that a well-defined memory model called TSO (total store ordering) and processor consistency are the same, when in fact these are different <ref> [31] </ref>! Once the basic issues in this area are well understood, one can consult detailed references such as [34, 35]. <p> all throw/look actions such that if each look in S returned color C, then the most recent throw in S directed at the same pigeon-hole did infact throw color C." In the same fashion, many other much more complicated memory models can be introduced, taking the formal definitions from, e.g., <ref> [31] </ref> and casting them into our "game" analogy. 9 Conclusions and future work In this paper, we discuss how a course on formal methods can be offered to either computer systems designers or graduate students with a "systems orientation".
Reference: [32] <institution> Personal Communication with Corella, </institution> <year> 1997. </year>
Reference-contexts: This is an area where not using formal notation can lead to many ambiguities. For example, there are many nonequivalent memory models that are all called processor consistency <ref> [31, 32] </ref> in published literature.
Reference: [33] <author> John Hennessy and David Patterson. </author> <title> Computer Architecture: A Quantitative Approach (Second Edition). </title> <publisher> Morgan Kaufman, </publisher> <year> 1995. </year>
Reference-contexts: This is an area where not using formal notation can lead to many ambiguities. For example, there are many nonequivalent memory models that are all called processor consistency [31, 32] in published literature. A very famous reference textbook <ref> [33] </ref> goes further to claim that a well-defined memory model called TSO (total store ordering) and processor consistency are the same, when in fact these are different [31]! Once the basic issues in this area are well understood, one can consult detailed references such as [34, 35].
Reference: [34] <author> Seungjoon Park. </author> <title> Computer Assisted Analysis of Multiprocessor Memory Systems. </title> <type> PhD thesis, </type> <institution> Stanford University, Computer Science, </institution> <month> June </month> <year> 1996. </year>
Reference-contexts: A very famous reference textbook [33] goes further to claim that a well-defined memory model called TSO (total store ordering) and processor consistency are the same, when in fact these are different [31]! Once the basic issues in this area are well understood, one can consult detailed references such as <ref> [34, 35] </ref>. It is also important that designers try to agree on standard terminology, for the number of applications where these concepts are needed is growing, for example in processor designs [36, Appendix G] and in I/O subsystems [1, 37]. <p> Last, but not least, concepts in memory models can be intuitively understood through experimentation using explicit enumeration tools. See <ref> [34] </ref> for details. An informal introduction to memory models A very informal introduction to the topic of memory models was given along the following lines in our course, taking sequential consistency as an example. "N very nimble-handed people are playing a new game which works as follows.
Reference: [35] <author> Sarida Adve and Kourosh Gharachorloo. </author> <title> Shared memory consistency models: A tutorial. </title> <type> Technical Report Rice University ECE Technical Report 9512, </type> <institution> Rice University and Western Research Laboratory, </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: A very famous reference textbook [33] goes further to claim that a well-defined memory model called TSO (total store ordering) and processor consistency are the same, when in fact these are different [31]! Once the basic issues in this area are well understood, one can consult detailed references such as <ref> [34, 35] </ref>. It is also important that designers try to agree on standard terminology, for the number of applications where these concepts are needed is growing, for example in processor designs [36, Appendix G] and in I/O subsystems [1, 37].
Reference: [36] <author> Gerry Kane. </author> <title> PA-RISC 2.0 Architecture. </title> <publisher> Prentice Hall, </publisher> <year> 1996. </year> <title> ISBN 0-13-182734-0. [37] "PCI Local Bus Specification", Revision 2.1, </title> <booktitle> PCI Special Interest Group, </booktitle> <month> June </month> <year> 1995. </year> <title> Phone: </title> <publisher> 1-800-433-5177. </publisher>
Reference-contexts: It is also important that designers try to agree on standard terminology, for the number of applications where these concepts are needed is growing, for example in processor designs <ref> [36, Appendix G] </ref> and in I/O subsystems [1, 37]. Last, but not least, concepts in memory models can be intuitively understood through experimentation using explicit enumeration tools. See [34] for details.
Reference: [38] <author> Patrick Tullman, Jeff Turner, John McCorquodale, Jay Lepreau, Ajay Chitturi, and Godmar Back. </author> <title> Formal methods: A practical tool for os implementors. </title> <booktitle> In Proceedings of the 6th Workshop on Hot Topics in Operating Systems (HOTOS'96). </booktitle>
Reference-contexts: Most of the projects pertained to the use of explicit enumeration in various contexts, while some involved theorem proving also. One of the projects involving the formal verification of critical parts of an actual microkernel operating system was reported in <ref> [38] </ref>, demonstrating that formal methods taught along the lines we outline can, in a matter of about 10 weeks, be transferred into actual practice.
Reference: [39] <institution> See http://www.cs.utah.edu/projects/formal verification/. </institution> <month> 16 </month>
Reference-contexts: In our future work, we hope to repeat our "teaching experiments" many more times and improve upon our ability to impart a much-needed skill to system designers. Ideas stemming from a contemporaneous research project <ref> [39] </ref> would fuel what we would end up teaching.
References-found: 38

