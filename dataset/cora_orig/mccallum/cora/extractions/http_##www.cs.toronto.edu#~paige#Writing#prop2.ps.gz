URL: http://www.cs.toronto.edu/~paige/Writing/prop2.ps.gz
Refering-URL: http://www.cs.toronto.edu/~paige/research.html
Root-URL: 
Email: paige@cs.utoronto.ca,  
Title: Heterogeneous Specifications and their Application to Software Development A Research Proposal  
Author: Richard F. Paige 
Date: October 12, 1995  
Web: http://www.cs.utoronto.ca/~paige  
Address: Toronto  
Affiliation: Department of Computer Science, University of  
Abstract: We describe a course of research examining formal and semiformal heterogeneous specifications, i.e., compositions of partial specifications written in different textual and visual notations. We describe why we believe this to be an interesting topic for further inquiry, and suggest why such specifications might prove beneficial for use in software development.
Abstract-found: 1
Intro-found: 1
Reference: [AbLa93] <author> M. Abadi and L. Lamport. </author> <title> Composing Specifications, </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 15(1), </volume> <month> January </month> <year> 1993. </year> <title> 18 Of course, homogeneous specifications are just a special case of heterogeneous specifications! 39 </title>
Reference-contexts: The terms compositional specification and multi-paradigm specification (both of which are closely related to our heterogeneous specification) received recent notice with the work of Wing [Wing90] and Zave and Jackson [ZaJa93]. Abadi and Lam-port's <ref> [AbLa93] </ref> transition-axiom method offers an approach similar to Zave and Jackson's-in that both offer a common semantics that can serve as a framework for many different notations-but the former's efforts are focused on concurrent systems, and are not intended to facilitate multiparadigm specification.
Reference: [AsCe93] <author> E. Astesiano and M. Cerioli. </author> <title> Multiparadigm Specification Languages: a first attempt at foundations. </title> <booktitle> In Proc. Semantics of Specification Languages, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Abadi and Lam-port's [AbLa93] transition-axiom method offers an approach similar to Zave and Jackson's-in that both offer a common semantics that can serve as a framework for many different notations-but the former's efforts are focused on concurrent systems, and are not intended to facilitate multiparadigm specification. Astesiano and Cerioli <ref> [AsCe93] </ref> describe an initial attempt at providing a foundation for multiparadigm specification.
Reference: [Back78] <author> R.J.R. </author> <title> Back. On the correctness of refinement steps in program development, </title> <type> PhD thesis, </type> <institution> Dept. of Computer Science, University of Helsinki, </institution> <year> 1978. </year>
Reference: [Back90] <author> R.J.R. </author> <title> Back. Refinement calculus II: parallel and reactive programs. In Stepwise Refinement of Distributed Systems, </title> <publisher> LNCS 430, Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: We will need to evaluate the utility of the operator when compared with, for instance, action systems <ref> [Back90] </ref>. * We are examining how to use a topovisual formalism (inspired by higraphs) to depict both large and small formal specifications.
Reference: [BaVo89] <author> R.J.R. Back and J. von Wright. </author> <title> A Lattice-Theoretical Basis for a Specification Language. In Mathematics of Program Construction, </title> <publisher> LNCS 375, Springer-Verlag, </publisher> <year> 1989. </year>
Reference: [DeMa79] <author> T. DeMarco. </author> <title> Structured Analysis and System Specification, </title> <publisher> Yourdon Press, </publisher> <year> 1979. </year>
Reference-contexts: And predicative programming [Hehn93] is an alternative to the refinement calculus with a simpler semantics and definition of refinement. There have been at least as many semiformal specification notations (and methods) as formal ones described in the literature. Examples include data flow diagrams, structure charts, Structured Analysis and Design <ref> [DeMa79] </ref>, Jackson Structured Design [Jack81], and so on. It is our suggestion that much can be gained from using both formal and semiformal notations and techniques in composition when constructing programs. <p> We wish to develop a solution for this problem using heterogeneous specifications, guided by the Structured Analysis and Design development method <ref> [DeMa79] </ref>. Our heterogeneous speci fications will be based on predicates, combined with structure text, data flow diagrams, structure charts, and programming language code. Compositions between these different notations are jus tified by the framework (and translations) developed and described in Appendix A. <p> This is refined into a modular presentation (in the design phase). Then, structure text is generated, and finally, an implementation (which we shall describe in the programming language C) is constructed. See <ref> [DeMa79] </ref> for more detail. The first stage in our development is to generate a data flow diagram (DFD). In this example, our diagram will be heterogeneous, since we feel most comfortable constructing a solution using multiple notations. Our first (context-level) DFD appears as shown in Figure 2.
Reference: [Dijk76] <author> E.W. Dijkstra. </author> <title> A Discipline of Programming, </title> <publisher> Prentice-Hall, </publisher> <year> 1976. </year>
Reference-contexts: There have been many formal specification notations (and formal methods) described in the literature. The first usable formal method was Hoare logic [Hoar69]. Weakest preconditions <ref> [Dijk76] </ref> have been used for program verification with success. The refinement calculus ([Back78], [Morg94]) is a rigorous approach to program design, based on a mathematical notion of refinement. Z [Spiv89] and VDM [Jone90] have met with some success in both subsidiary support and central construction programming roles.
Reference: [Dijk93] <author> E.W. Dijkstra. </author> <title> The Unification of Three Calculi. In Program Design Calculi, </title> <booktitle> Proceedings of the NATO ASI on Program Design Calculi, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Three fairly simple examples are presented in Appendix B. 3 Of course, predicated on other design constraints. 6 3 Related Work Our notion of heterogeneous specification might have first arisen with the work of Hehner and Malton [HeMa88] on comparative semantics, and Dijkstra <ref> [Dijk93] </ref> and Hoare's [Hoar94] work on theory unification. In turn, these works have their roots with multiparadigm languages [Hail86], and wide-spectrum languages (e.g., see [Part90]).
Reference: [Grie81] <editor> D. Gries. </editor> <booktitle> The Science of Programming, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference: [Gutt93] <author> J.V. Guttag and J.J. Horning. </author> <title> Larch: Languages and Tools for Formal Specification, </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Identify a collection of formal and semiformal notations for study. We propose to examine selections from the following: * formal: the refinement calculus, Z, VDM, the predicative notation, weakest preconditions, CSP [Hoar85], Hoare logic, functional notations (e.g., CIP-L [Part90]), algebraic specifications and Larch <ref> [Gutt93] </ref>. * semiformal: data flow diagrams, entity-relationship models, transition diagrams, Jackson diagrams, program description languages, subsets of programming languages, structure diagrams, object-oriented notations, and decision tables. It is expected that the emphasis of our work will be on the italicized notations. 2.
Reference: [Hail86] <author> B. Hailpern. </author> <title> Multiparadigm languages and environments (guest editor's introduction to a special issue), </title> <journal> IEEE Software, </journal> <volume> 3(1), </volume> <month> January </month> <year> 1986. </year>
Reference-contexts: In turn, these works have their roots with multiparadigm languages <ref> [Hail86] </ref>, and wide-spectrum languages (e.g., see [Part90]). The terms compositional specification and multi-paradigm specification (both of which are closely related to our heterogeneous specification) received recent notice with the work of Wing [Wing90] and Zave and Jackson [ZaJa93].
Reference: [HarD88] <author> D. Harel. </author> <title> On Visual Formalisms, </title> <journal> Comm. ACM, </journal> <volume> 31(5), </volume> <month> May </month> <year> 1988. </year>
Reference-contexts: For the diagram-based notations, examine the notion of "diagrammatic composition" (i.e., if we have a formal 4 semantics for a diagram, we can, theoretically, compose it with another diagram. How should we denote such compositions?) * Examine the construction of a small visual notation (e.g., see <ref> [HarD88] </ref>) for representing formal specifications. Such a facility will be important for facilitating the composition of diagrams and formal specifications, and may be useful in itself for its capability of expressing formal specifications visually. We will consider the use of a higraph-like notation here. ASIDE.
Reference: [HarJ90] <author> J.S. Hares. </author> <title> SSADM for the Advanced Practitioner, </title> <publisher> Wiley, </publisher> <year> 1990. </year>
Reference: [HeMa88] <author> E.C.R. Hehner and A.J. Malton. </author> <title> Termination Conventions and Comparative Semantics, </title> <journal> Acta Informatica, </journal> <month> 25 </month> <year> (1988). </year>
Reference-contexts: Three fairly simple examples are presented in Appendix B. 3 Of course, predicated on other design constraints. 6 3 Related Work Our notion of heterogeneous specification might have first arisen with the work of Hehner and Malton <ref> [HeMa88] </ref> on comparative semantics, and Dijkstra [Dijk93] and Hoare's [Hoar94] work on theory unification. In turn, these works have their roots with multiparadigm languages [Hail86], and wide-spectrum languages (e.g., see [Part90]). <p> A.1.2 Refinement calculus and weakest preconditions The mapping from specification statements to weakest precondition predicate transformers is well-known: Morgan gives a weakest precondition definition of specification statements in [Morg94]. The reverse transformation is somewhat more complex and is derived from <ref> [HeMa88] </ref>.
Reference: [Hehn93] <author> E.C.R. Hehner. </author> <title> A Practical Theory of Programming, </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The refinement calculus ([Back78], [Morg94]) is a rigorous approach to program design, based on a mathematical notion of refinement. Z [Spiv89] and VDM [Jone90] have met with some success in both subsidiary support and central construction programming roles. And predicative programming <ref> [Hehn93] </ref> is an alternative to the refinement calculus with a simpler semantics and definition of refinement. There have been at least as many semiformal specification notations (and methods) as formal ones described in the literature. <p> Our research plan includes further examination and development of this material. We also plan to extend the comparative semantics to other domains, including both formal and semiformal notations. A.1.1 Predicates and specification statements Let frame w * P be a predicate specification (as in <ref> [Hehn93] </ref>) not involving time, i.e., there will be no references to the time variables t and t 0 in P . We require that the programmer specify the frame w.
Reference: [Hoar69] <author> C.A.R. Hoare. </author> <title> An Axiomatic Basis for Computer Programming, </title> <journal> Comm. ACM, </journal> <volume> 12, </volume> <month> Oct. </month> <year> 1969. </year>
Reference-contexts: There have been many formal specification notations (and formal methods) described in the literature. The first usable formal method was Hoare logic <ref> [Hoar69] </ref>. Weakest preconditions [Dijk76] have been used for program verification with success. The refinement calculus ([Back78], [Morg94]) is a rigorous approach to program design, based on a mathematical notion of refinement. Z [Spiv89] and VDM [Jone90] have met with some success in both subsidiary support and central construction programming roles.
Reference: [Hoar85] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes, </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: The most significant part of the work will be tied up in Parts 2 and 3. 1. Identify a collection of formal and semiformal notations for study. We propose to examine selections from the following: * formal: the refinement calculus, Z, VDM, the predicative notation, weakest preconditions, CSP <ref> [Hoar85] </ref>, Hoare logic, functional notations (e.g., CIP-L [Part90]), algebraic specifications and Larch [Gutt93]. * semiformal: data flow diagrams, entity-relationship models, transition diagrams, Jackson diagrams, program description languages, subsets of programming languages, structure diagrams, object-oriented notations, and decision tables.
Reference: [Hoar94] <author> C.A.R. Hoare. </author> <title> Unified Theories of Programming, </title> <type> Technical Paper, </type> <institution> Oxford Computing Laboratory, </institution> <month> July </month> <year> 1994. </year>
Reference-contexts: Three fairly simple examples are presented in Appendix B. 3 Of course, predicated on other design constraints. 6 3 Related Work Our notion of heterogeneous specification might have first arisen with the work of Hehner and Malton [HeMa88] on comparative semantics, and Dijkstra [Dijk93] and Hoare's <ref> [Hoar94] </ref> work on theory unification. In turn, these works have their roots with multiparadigm languages [Hail86], and wide-spectrum languages (e.g., see [Part90]).
Reference: [Jack81] <author> M.A. Jackson. </author> <title> System Development, </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: There have been at least as many semiformal specification notations (and methods) as formal ones described in the literature. Examples include data flow diagrams, structure charts, Structured Analysis and Design [DeMa79], Jackson Structured Design <ref> [Jack81] </ref>, and so on. It is our suggestion that much can be gained from using both formal and semiformal notations and techniques in composition when constructing programs. <p> formalize (although some of the loop-constructs result in complex specifications). * Work remains to be done on exploring the changes to JSD that occur after adding heterogeneous formal specifications at both the visual and textual levels, especially with respect to how the interface with the "real world" (as described in <ref> [Jack81] </ref>) must be dealt with. A.3.3 Programming languages and PDL results We have commenced the determination of a formal semantics for various programming language subsets. Our goal is to allow the use of subsets of certain real programming languages in composition with formal specifications.
Reference: [Jone90] <author> C.B. Jones. </author> <title> Systematic Software Development using VDM, </title> <booktitle> Prentice-Hall, Second Edition, </booktitle> <year> 1990. </year>
Reference-contexts: The first usable formal method was Hoare logic [Hoar69]. Weakest preconditions [Dijk76] have been used for program verification with success. The refinement calculus ([Back78], [Morg94]) is a rigorous approach to program design, based on a mathematical notion of refinement. Z [Spiv89] and VDM <ref> [Jone90] </ref> have met with some success in both subsidiary support and central construction programming roles. And predicative programming [Hehn93] is an alternative to the refinement calculus with a simpler semantics and definition of refinement.
Reference: [King90] <author> S. King. </author> <title> Z and the refinement calculus. In VDM '90: VDM and Z Formal Methods in Software Development, </title> <booktitle> Third international symposium of VDM Europe, </booktitle> <publisher> LNCS 428, Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: A.1.4 Z and the refinement calculus The final set of translations we describe are between Z and the refinement calculus. One direction of the translation has been noted in the past <ref> [King90] </ref>; we merely summarize these results here. The mapping from a Z schema to a refinement calculus specification statement is quite straightforward and was described in [King90]. There is first a syntax-directed translation from Z schemas to an intermediate form (mapping primed variables to unprimed variables, etc.). <p> One direction of the translation has been noted in the past <ref> [King90] </ref>; we merely summarize these results here. The mapping from a Z schema to a refinement calculus specification statement is quite straightforward and was described in [King90]. There is first a syntax-directed translation from Z schemas to an intermediate form (mapping primed variables to unprimed variables, etc.). <p> See <ref> [King90] </ref> for more details. The reverse mapping (from the refinement calculus to Z) is less straightforward, since it has to be left to the programmer to decide how to decorate variables (as input or output) in the resulting schema, which variables to declare in the current schema, etcetera.
Reference: [Kron93] <author> K. Kronlof, ed. </author> <title> Method Integration: Concepts and Case Studies, </title> <publisher> Wiley, </publisher> <year> 1993. </year> <month> 40 </month>
Reference-contexts: Related to the compositional or heterogeneous specification notion is the concept of method integration-combining two or more methods to form a new, hopefully more useful technique. [SFD92] contains a good overview of (informal) integrations of Structured Analysis with VDM, Z, and other formal notations. <ref> [Kron93] </ref> is a general overview of method integration.
Reference: [Morg94] <author> C.C. Morgan. </author> <title> Programming from Specifications, Second Edition, </title> <publisher> Prentice-Hall, </publisher> <year> 1994. </year>
Reference-contexts: There have been many formal specification notations (and formal methods) described in the literature. The first usable formal method was Hoare logic [Hoar69]. Weakest preconditions [Dijk76] have been used for program verification with success. The refinement calculus ([Back78], <ref> [Morg94] </ref>) is a rigorous approach to program design, based on a mathematical notion of refinement. Z [Spiv89] and VDM [Jone90] have met with some success in both subsidiary support and central construction programming roles. <p> A.1.2 Refinement calculus and weakest preconditions The mapping from specification statements to weakest precondition predicate transformers is well-known: Morgan gives a weakest precondition definition of specification statements in <ref> [Morg94] </ref>. The reverse transformation is somewhat more complex and is derived from [HeMa88]. <p> Before presenting them, we make a definition, taken from [Ward93]. Definition 4 A specification statement is frame complete if its frame consists of all variables mentioned in the pre- and postcondition. It is easy to make a specification statement frame complete by using the law Expand Frame from <ref> [Morg94] </ref>. With this definition in mind, we now present some theorems (omitting all proofs). In the following, let S = w : [ pre w ; post w ] and T = x : [ pre x ; post x ]. <p> The particular example we consider is one of computing the natural square root of a natural number s (see <ref> [Morg94] </ref> for a detailed examination of this problem and its solution developed with the refinement calculus). For our notations, we use specification statements and predicates. <p> Our development will use the refinement relations v and ( as necessary, and we will use the theorems of Appendix A to justify refinement steps where needed. We do not present a detailed description of our algorithmic approach to solving the problem; it will be similar to that of <ref> [Morg94] </ref>, so we refer the reader there for further details. Our initial specification is the specification statement r : [ r 02 s &lt; (r 0 + 1) 2 ]; and as in Appendix A we use the primed-unprimed variable conventions of predicative programming for the sake of simplicity. <p> Our first refinement will be identical to the initial step in <ref> [Morg94] </ref>: v var q : nat * Next, setting I (an invariant) to r 2 s &lt; q 2 (and, accordingly, I 0 = r 02 s &lt; q 02 ), we introduce an initialization through a sequential composition, using the law Leading Assignment of the refinement calculus. v frame q;
Reference: [Paig94] <author> R.F. Paige. </author> <title> Formal specifications and theories of programming. </title> <type> Depth Paper, </type> <institution> Department of Computer Science, University of Toronto, </institution> <month> October </month> <year> 1994. </year>
Reference-contexts: In a second Appendix, we present several examples of heterogeneous specifications and show how they might be used in development. We assume enough of a familiarity with the formal and semiformal methods described above to understand a fairly high-level discussion. We suggest consulting <ref> [Paig94] </ref> and the other references for further details. Formal methods have experienced only limited use in "realistic" programming situations.
Reference: [Paig95] <author> R.F. Paige. </author> <title> Higraph-based Predicate and Heterogeneous Specification, </title> <month> March </month> <year> 1995. </year>
Reference-contexts: Our notation allows us to depict data and control flow (along with more abstract relationships), as well as structure and hierarchy, and permits us to abstract away as much detail in the specification as is necessary. See <ref> [Paig95] </ref> for more details. * We are studying how to use heterogeneous specifications in nonlinear development processes (e.g., see [PHG91]). In such situations, it may be easier to "reverse engineer" specifications from implementations, due to the heterogeneous nature of the final specification. <p> Generate structure text as per JSP usual, but the text for the higraph parts should be their text equivalents. This latter generation is a form of syntactic translation, mapping from higraph predicates to predicates. The mapping is described in <ref> [Paig95] </ref>. 4. Further refinement and code generation may proceed, as per heterogeneous specification usual. The JSP implementation process is applied to the JSP structure text parts. Implementation of the formal parts proceeds as per predicative programming usual. 5.
Reference: [Part90] <author> H.A. Partsch. </author> <title> Specification and Transformation of Programs, </title> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Identify a collection of formal and semiformal notations for study. We propose to examine selections from the following: * formal: the refinement calculus, Z, VDM, the predicative notation, weakest preconditions, CSP [Hoar85], Hoare logic, functional notations (e.g., CIP-L <ref> [Part90] </ref>), algebraic specifications and Larch [Gutt93]. * semiformal: data flow diagrams, entity-relationship models, transition diagrams, Jackson diagrams, program description languages, subsets of programming languages, structure diagrams, object-oriented notations, and decision tables. It is expected that the emphasis of our work will be on the italicized notations. 2. <p> In turn, these works have their roots with multiparadigm languages [Hail86], and wide-spectrum languages (e.g., see <ref> [Part90] </ref>). The terms compositional specification and multi-paradigm specification (both of which are closely related to our heterogeneous specification) received recent notice with the work of Wing [Wing90] and Zave and Jackson [ZaJa93].
Reference: [PHG91] <author> D.A. Penny, R.C. Holt, and M.W. Godfrey. </author> <title> Formal Specifications in Metamorphic Programming. In VDM `91: Formal Software Development Methods, </title> <booktitle> Fourth International Symposium of VDM Europe, </booktitle> <publisher> LNCS 551, Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: different notations. 1 The benefits of studying such approaches to specification would include the potential for: * obtaining more flexibility in the application of both formal and semiformal notations and techniques to software development; * smoothing the integration of formal specification notations into development methods; * reducing the semantic gaps <ref> [PHG91] </ref> that arise in a development due to the use of an integrated formal notation; * constructing a "catalogue" of the relative expressiveness and limitations (both syntactic and semantic) of notations. <p> answer two important questions: (a) How can we integrate a formal method into a software development method? (b) How can we obtain more flexibility in using a formal method in realistic software con struction situations? Question (a) has been considered to a degree by others; for example, see [SFD92] or <ref> [PHG91] </ref>. The former work examines formal and informal integrations of Z, VDM, and algebraic specifications with Structured Analysis and Design. The latter paper considers metamorphic 2 The method need only be used when desired (or necessary) in a particular problem. 5 programming. <p> See [Paig95] for more details. * We are studying how to use heterogeneous specifications in nonlinear development processes (e.g., see <ref> [PHG91] </ref>). In such situations, it may be easier to "reverse engineer" specifications from implementations, due to the heterogeneous nature of the final specification. This might prove to be useful in allowing designers more flexibility in developing software.
Reference: [ScRo77] <author> K. Schoman and D. Ross. </author> <title> Structured Analysis for requirements definition, </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 3(1), </volume> <year> 1977. </year>
Reference: [SFD92] <author> L.T. Semmens, R.B. France, and T.W. Docker. </author> <title> Integrated Structured Analysis and Formal Specification Techniques, </title> <journal> The Computer Journal 35(6), </journal> <month> June </month> <year> 1992. </year>
Reference-contexts: attempt to answer two important questions: (a) How can we integrate a formal method into a software development method? (b) How can we obtain more flexibility in using a formal method in realistic software con struction situations? Question (a) has been considered to a degree by others; for example, see <ref> [SFD92] </ref> or [PHG91]. The former work examines formal and informal integrations of Z, VDM, and algebraic specifications with Structured Analysis and Design. The latter paper considers metamorphic 2 The method need only be used when desired (or necessary) in a particular problem. 5 programming. <p> ASIDE. One perspective on the work we are describing is that it is part of an attempt to fit program design calculi into software development processes. This problem (which is closely related to formal specification integration <ref> [SFD92] </ref>) has received limited discussion in the literature. There are several ways in which one might think of carrying out such an integration. The ideal place in a standard model of software development to perform the process is in the specification and design phase. <p> Astesiano and Cerioli [AsCe93] describe an initial attempt at providing a foundation for multiparadigm specification. Related to the compositional or heterogeneous specification notion is the concept of method integration-combining two or more methods to form a new, hopefully more useful technique. <ref> [SFD92] </ref> contains a good overview of (informal) integrations of Structured Analysis with VDM, Z, and other formal notations. [Kron93] is a general overview of method integration. <p> Our descriptions are necessarily brief and omit all of the formal details. A.3.1 Structured Analysis/Design-related Results * Data flow diagrams can be formalized in Z <ref> [SFD92] </ref> or in the predicative notation (placing an interpretation on the diagram as operations on a state). This can typically be done in combination with control flow diagrams and the data dictionary. <p> We have also considered extending this notion to extraction of higraph-based specifications, or dependency trees based on Z schema interconnections, so as to reduce the information loss in the process. * Entity-relationship diagrams can be expressed in Z <ref> [SFD92] </ref> or in the predicative notation.
Reference: [Spiv89] <author> J.M. Spivey. </author> <title> The Z Notation: A Reference Manual, </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: The first usable formal method was Hoare logic [Hoar69]. Weakest preconditions [Dijk76] have been used for program verification with success. The refinement calculus ([Back78], [Morg94]) is a rigorous approach to program design, based on a mathematical notion of refinement. Z <ref> [Spiv89] </ref> and VDM [Jone90] have met with some success in both subsidiary support and central construction programming roles. And predicative programming [Hehn93] is an alternative to the refinement calculus with a simpler semantics and definition of refinement.
Reference: [Ward93] <author> N. Ward. </author> <title> Adding Specification Constructors to the Refinement Calculus. </title> <booktitle> In Proc. FME `93: Industrial-strength Formal Methods, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: We now briefly consider an interesting special case of formal heterogeneous specifications in order to explore some of their features. To be more specific, we consider the problem of adding so-called specification constructors to the refinement calculus. This problem was examined by Ward <ref> [Ward93] </ref>, who considered adding generalizations of Z schema conjunction and disjunction operators to the refinement calculus. The rationale for considering this extension was to facilitate the construction of large specifications from smaller ones. <p> We perform manipulations and then reverse the transformation. By doing so, we obtain some useful results. Before presenting them, we make a definition, taken from <ref> [Ward93] </ref>. Definition 4 A specification statement is frame complete if its frame consists of all variables mentioned in the pre- and postcondition. It is easy to make a specification statement frame complete by using the law Expand Frame from [Morg94]. <p> Theorem 11 If S is frame complete and not angelic then :S = w : [ pre ) 9w 0 * post; pre ^ :post ]: Further theorems and properties have been determined (especially regarding partwise refinement), and we plan to compare our results with those of <ref> [Ward93] </ref> to discover respective strengths and weaknesses. ASIDE. In work we do not present here we investigate a simpler (yet slightly less expressive) translation of predicates into specification statements. This translation leads to results different from those presented above. Part of our work will entail an evaluation of both translations.
Reference: [Wing90] <author> J.M. Wing. </author> <title> A specifier's introduction to formal methods. </title> <journal> IEEE Computer, </journal> <volume> 23(9), </volume> <month> September </month> <year> 1990. </year>
Reference-contexts: In turn, these works have their roots with multiparadigm languages [Hail86], and wide-spectrum languages (e.g., see [Part90]). The terms compositional specification and multi-paradigm specification (both of which are closely related to our heterogeneous specification) received recent notice with the work of Wing <ref> [Wing90] </ref> and Zave and Jackson [ZaJa93].
Reference: [WiZa92] <author> J.M. Wing and A.M. Zaremski. </author> <title> Unintrusive ways to integrate formal specifications in practice. In VDM `91: Formal Software Development Methods, </title> <booktitle> Fourth International Symposium of VDM Europe, </booktitle> <publisher> LNCS 551, Springer-Verlag, </publisher> <year> 1992. </year>
Reference: [ZaJa93] <author> P. Zave and M. Jackson. </author> <title> Conjunction as Composition, </title> <journal> ACM Trans. on Software Engineering and Methodology, </journal> <volume> 2(4), </volume> <month> October </month> <year> 1993. </year> <month> 41 </month>
Reference-contexts: In turn, these works have their roots with multiparadigm languages [Hail86], and wide-spectrum languages (e.g., see [Part90]). The terms compositional specification and multi-paradigm specification (both of which are closely related to our heterogeneous specification) received recent notice with the work of Wing [Wing90] and Zave and Jackson <ref> [ZaJa93] </ref>. Abadi and Lam-port's [AbLa93] transition-axiom method offers an approach similar to Zave and Jackson's-in that both offer a common semantics that can serve as a framework for many different notations-but the former's efforts are focused on concurrent systems, and are not intended to facilitate multiparadigm specification.
References-found: 34

