URL: http://larch-www.lcs.mit.edu:8001/~garland/publications/ioaPaper.ps
Refering-URL: http://larch-www.lcs.mit.edu:8001/~garland/publications/index.html
Root-URL: 
Title: The IOA Language and Toolset: Support for Mathematics-Based Distributed Programming  
Author: Stephen J. Garland and Nancy A. Lynch 
Keyword: Distributed systems, I/O automata, software tools, verification, model checking, simulation, code generation.  
Affiliation: MIT Laboratory for Computer Science  
Abstract: This paper presents a new language for distributed programming, the IOA language, together with a design for a suite of tools, the IOA toolset, that support the production of high-quality distributed software. The language and tools are based on the I/O automaton model, which has been used extensively to describe and verify distributed algorithms. The toolset supports a development process that begins with a high-level specification, refines that specification via successively more detailed designs, and ends by automatically generating efficient distributed programs. The toolset encourages system decomposition, which helps make distributed programs understandable and easy to modify. Most importantly, it provides a variety of validation methods (theorem proving, model checking, and simulation), which can be used to ensure that the generated programs are correct, subject to stated assumptions about externally-provided system services (e.g., communication services). 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Myla Archer. </author> <type> Personal communication. </type>
Reference-contexts: The paper illustrates these features via an extended example. 2 Related work The earliest automated proof for an I/O-automaton-based design seems to be one by Nipkow, using the Isabelle prover [31]. Subsequently, several proofs have been carried out using LP [37, 21, 32], and PVS <ref> [1] </ref>. Goldman's Spectrum system [13] included a programming language for describing I/O automata and a simulator for that language.
Reference: [2] <author> Elizabeth Borowsky, Eli Gafni, Nancy Lynch, and Sergio Rajsbaum. </author> <title> The BG distributed simulation algorithm, </title> <month> December </month> <year> 1997. </year> <note> Submitted for journal publication. </note>
Reference-contexts: 1 Introduction I/O automata [26, 27] have been used to model and verify many distributed algorithms and distributed system designs. and also to express many impossibility results. See, for example, <ref> [22, 23, 2, 3, 16, 35] </ref>.
Reference: [3] <author> S. Chaudhuri and P. Reiners. </author> <title> Understanding the set consensus partial order using the Borowsky-Gafni simulation. </title> <booktitle> 10th International Workshop on Distributed Algorithms, </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: 1 Introduction I/O automata [26, 27] have been used to model and verify many distributed algorithms and distributed system designs. and also to express many impossibility results. See, for example, <ref> [22, 23, 2, 3, 16, 35] </ref>.
Reference: [4] <author> Anna Chefter. </author> <title> A simulator for the IOA language. </title> <type> Master's thesis, </type> <institution> MIT Department of Electrical Engineering and Computer Science, </institution> <note> in preparation. 16 </note>
Reference-contexts: In this respect, our experience confirms our belief that a user-provided step correspondence is just what is needed to allow theorem provers to establish simulation relations with a minimum of user interaction. 5.3 Simulator The simulator <ref> [4] </ref> is required to run selected executions of an IOA program on a single machine. The user should be able to help select the executions that are run.
Reference: [5] <author> Gregory V. Chockler. </author> <title> An adaptive totally ordered multicast protocol that tolerates partitions. </title> <type> Master's thesis, </type> <institution> Institute of Computer Science, The Hebrew University of Jerusalem, </institution> <month> August </month> <year> 1997. </year>
Reference-contexts: The model and proof methods were originally developed for reasoning about theoretical distributed algorithms. In the past few years, they have been applied increasingly to practical system services such as distributed shared memory services [9], group communication services <ref> [10, 5] </ref>, and standard communication services [36]. For these services, the theory has contributed descriptions and proofs, plus important by-products such as interface specifications, invariants, and simulation relations. Ambiguities have been resolved, and at least one significant logical error has been discovered and repaired [9].
Reference: [6] <author> R. Cleaveland, J. N. Gada, P. M. Lewis, S. A. Smolka, O. Sokolsky, and S. Zhang. </author> <title> The Concurrency Factory practical tools for specification, simulation, verification and implementation of concurrent systems. </title> <booktitle> Specification of Parallel Algorithms, </booktitle> <pages> 75-89, </pages> <publisher> American Mathematical Society, </publisher> <year> 1994. </year>
Reference-contexts: Other work, although not directly based on I/O automata, is related to ours in one way or another. Many researchers have toolkits for validating distributed system designs. The Concurrency Factory <ref> [6] </ref> uses a process-algebraic language (CCS) with a very different syntax and style from ours.
Reference: [7] <author> Danny Dolev and Nir Shavit. </author> <title> Bounded time stamping. </title> <journal> SIAM Journal on Computing, </journal> <volume> 26(2) </volume> <pages> 418-455, </pages> <month> April </month> <year> 1997. </year>
Reference-contexts: For example, we have proved the correctness of the Dolev-Shavit Bounded Concurrent Timestamp protocol <ref> [7] </ref> using the Larch Prover (LP) [32]. Of course, many other researchers have also used theorem provers to prove invariants and simulation relations, using other state-machine models and theorem provers as well as I/O automata and LP.
Reference: [8] <author> Urban Engberg, Peter Grtnning, and Leslie Lamport. </author> <title> Mechanical verification of concurrent systems with TLA. </title> <booktitle> Proceedings of the Fourth International Conference on Computer Aided Verification, Springer-Verlag Lecture Notes in Computer Science 663 </booktitle> <pages> 44-55, </pages> <year> 1992. </year>
Reference-contexts: Neither the Concurrency Factory nor STeP provides a code-generation tool. Lamport's TLA language [20] has similarities to IOA, but differs in its treatment of composition. Furthermore, the only tool support for TLA is the TLP theorem prover <ref> [8] </ref>. The programming language Occam [19] also uses a process-algebraic language (CSP) [17]. Occam code can be compiled to run on Transputers, but there are no verification tools for Occam programs. 3 The IOA language The IOA language [12] is based on the I/O automaton model [26, 27].
Reference: [9] <author> Alan Fekete, M. Frans Kaashoek, and Nancy Lynch. </author> <title> Implementing sequentially consistent shared objects using broadcast and point-to-point communication. </title> <journal> Journal of the ACM, </journal> <note> 1998. To appear. </note>
Reference-contexts: The model and proof methods were originally developed for reasoning about theoretical distributed algorithms. In the past few years, they have been applied increasingly to practical system services such as distributed shared memory services <ref> [9] </ref>, group communication services [10, 5], and standard communication services [36]. For these services, the theory has contributed descriptions and proofs, plus important by-products such as interface specifications, invariants, and simulation relations. Ambiguities have been resolved, and at least one significant logical error has been discovered and repaired [9]. <p> memory services <ref> [9] </ref>, group communication services [10, 5], and standard communication services [36]. For these services, the theory has contributed descriptions and proofs, plus important by-products such as interface specifications, invariants, and simulation relations. Ambiguities have been resolved, and at least one significant logical error has been discovered and repaired [9]. Most of fl Submitted as a research paper to FORTE/PSTV '98, March 27, 1998. Contact author: Stephen J.
Reference: [10] <author> Alan Fekete, Nancy Lynch, and Alex Shvartsman. </author> <title> Specifying and using a partitionable group communication service. </title> <booktitle> Proceedings of the Sixteenth Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 53-62, </pages> <month> August </month> <year> 1997. </year>
Reference-contexts: The model and proof methods were originally developed for reasoning about theoretical distributed algorithms. In the past few years, they have been applied increasingly to practical system services such as distributed shared memory services [9], group communication services <ref> [10, 5] </ref>, and standard communication services [36]. For these services, the theory has contributed descriptions and proofs, plus important by-products such as interface specifications, invariants, and simulation relations. Ambiguities have been resolved, and at least one significant logical error has been discovered and repaired [9].
Reference: [11] <author> Stephen J. Garland and John V. Guttag. </author> <title> A guide to LP, the Larch Prover. </title> <type> Research Report 82, </type> <institution> Digital Systems Research Center, </institution> <address> 130 Lytton Avenue, Palo Alto, CA 94301, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: Contact author: Stephen J. Garland, MIT Laboratory for Computer Science, Cambridge, MA 02139 (garland@lcs.mit.edu) 1 this work has been done by hand; however, much of it (primarily, invariant and forward simulation proofs) is sufficiently stylized to admit computer assistance using interactive theorem provers such as the Larch Prover (LP) <ref> [11] </ref> or PVS [34]. For example, we have proved the correctness of the Dolev-Shavit Bounded Concurrent Timestamp protocol [7] using the Larch Prover (LP) [32]. <p> The IOA toolset will contain interfaces to a number of existing theorem provers. The first such interface is targeted to the Larch Prover (LP) <ref> [11] </ref>; Devillers and Vaandrager have begun working on a interface to PVS. These interfaces translate IOA descriptions of automata into axioms that can be used by the targeted theorem provers.
Reference: [12] <author> Stephen J. Garland, Nancy A. Lynch, and Mandana Vaziri. IOA: </author> <title> A Language for Specifying, Programming, and Validating Distributed Systems. </title> <institution> MIT Laboratory for Computer Science, </institution> <month> December </month> <year> 1997. </year>
Reference-contexts: The programming language Occam [19] also uses a process-algebraic language (CSP) [17]. Occam code can be compiled to run on Transputers, but there are no verification tools for Occam programs. 3 The IOA language The IOA language <ref> [12] </ref> is based on the I/O automaton model [26, 27].
Reference: [13] <author> Kenneth J. Goldman. </author> <title> Distributed Algorithm Simulation using Input/Output Automata. </title> <type> PhD thesis, </type> <institution> MIT Department of Electrical Engineering and Computer Science, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: The paper illustrates these features via an extended example. 2 Related work The earliest automated proof for an I/O-automaton-based design seems to be one by Nipkow, using the Isabelle prover [31]. Subsequently, several proofs have been carried out using LP [37, 21, 32], and PVS [1]. Goldman's Spectrum system <ref> [13] </ref> included a programming language for describing I/O automata and a simulator for that language.
Reference: [14] <author> Kenneth J. Goldman, Bala Swaminathan, T. Paul McCartney, Michael D. Anderson, and Ram Sethuraman. </author> <title> The Programmers' Playground: I/O abstraction for user-configurable distributed applications. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(9) </volume> <pages> 735-746, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: The language was not connected to a theorem prover or a code generator, although a strategy for distributed simulation was suggested. This strategy was different from ours, e.g., it involved non-local synchronization for implementing some transitions. Goldman's more recent work on the Programmer's Playground <ref> [14] </ref> also includes a language with formal semantics in terms of I/O automata; again, it has no facilities for proofs. Other work, although not directly based on I/O automata, is related to ours in one way or another. Many researchers have toolkits for validating distributed system designs.
Reference: [15] <author> William Gropp, Ewing Lusk, and Anthony Skjellum. </author> <title> Using MPI: Portable Parallel Programming with the Message-Passing Interface. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: Then each node automaton should be translated automatically into actual code that, in a precise sense, implements the node automaton. Each channel automaton should be implemented by an externally-provided service such as TCP [33] or MPI <ref> [15] </ref>. This process can be used to 11 ensure that the final system provably implements higher-level IOA descriptions, subject to assumed properties of the externally-provided services and the underlying hardware.
Reference: [16] <author> Maurice Herlihy. </author> <title> Wait-free synchronization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(1) </volume> <pages> 124-149, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: 1 Introduction I/O automata [26, 27] have been used to model and verify many distributed algorithms and distributed system designs. and also to express many impossibility results. See, for example, <ref> [22, 23, 2, 3, 16, 35] </ref>.
Reference: [17] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> Prentice-Hall International, </booktitle> <address> United Kingdom, </address> <year> 1985. </year>
Reference-contexts: Neither the Concurrency Factory nor STeP provides a code-generation tool. Lamport's TLA language [20] has similarities to IOA, but differs in its treatment of composition. Furthermore, the only tool support for TLA is the TLP theorem prover [8]. The programming language Occam [19] also uses a process-algebraic language (CSP) <ref> [17] </ref>. Occam code can be compiled to run on Transputers, but there are no verification tools for Occam programs. 3 The IOA language The IOA language [12] is based on the I/O automaton model [26, 27].
Reference: [18] <author> Gerard J. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice Hall Software Series, </publisher> <address> New Jersey, </address> <year> 1991. </year>
Reference-contexts: We are working on extending our notion of paired simulations to a model-checking technique for simulation relations. The first model checking interface is targeted to SPIN <ref> [18] </ref>. As does the simulator, the model checker interface restricts IOA programs to be in a special form. Programs must be closed, in primitive form, and described operationally. Nondeterminism is allowed.
Reference: [19] <author> INMOS Ltd: </author> <title> OCCAM 2 Reference Manual, </title> <year> 1988. </year>
Reference-contexts: Neither the Concurrency Factory nor STeP provides a code-generation tool. Lamport's TLA language [20] has similarities to IOA, but differs in its treatment of composition. Furthermore, the only tool support for TLA is the TLP theorem prover [8]. The programming language Occam <ref> [19] </ref> also uses a process-algebraic language (CSP) [17]. Occam code can be compiled to run on Transputers, but there are no verification tools for Occam programs. 3 The IOA language The IOA language [12] is based on the I/O automaton model [26, 27].
Reference: [20] <author> Leslie Lamport. </author> <title> The temporal logic of actions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 872-923, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Neither the Concurrency Factory nor STeP provides a code-generation tool. Lamport's TLA language <ref> [20] </ref> has similarities to IOA, but differs in its treatment of composition. Furthermore, the only tool support for TLA is the TLP theorem prover [8]. The programming language Occam [19] also uses a process-algebraic language (CSP) [17].
Reference: [21] <author> Victor Luchangco, Ekrem Soylemez, Stephen Garland, and Nancy Lynch. </author> <title> Verifying timing properties of concurrent algorithms. </title> <booktitle> Formal Description Techniques VII (FORTE '94), </booktitle> <pages> pages 259-273. </pages> <publisher> Chapman and Hall, </publisher> <year> 1995. </year>
Reference-contexts: The paper illustrates these features via an extended example. 2 Related work The earliest automated proof for an I/O-automaton-based design seems to be one by Nipkow, using the Isabelle prover [31]. Subsequently, several proofs have been carried out using LP <ref> [37, 21, 32] </ref>, and PVS [1]. Goldman's Spectrum system [13] included a programming language for describing I/O automata and a simulator for that language.
Reference: [22] <author> Nancy Lynch. </author> <title> Distributed Algorithms. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo, CA, </address> <month> March </month> <year> 1996. </year>
Reference-contexts: 1 Introduction I/O automata [26, 27] have been used to model and verify many distributed algorithms and distributed system designs. and also to express many impossibility results. See, for example, <ref> [22, 23, 2, 3, 16, 35] </ref>. <p> Proofs for I/O automata typically involve compositional reasoning, invari-ants (i.e., predicates that are true in all reachable states), and (forward and backward) simulation relations. An exposition of the model appears in Chapter 8 of <ref> [22] </ref>; simulation relations are presented in [24]. Requirements. Our first requirement is that our language must allow precise and direct descriptions of I/O automata. The I/O automaton model is a reactive system model rather than a sequential programming model. <p> We need a language that (somehow) satisfies both sets of requirements. Design of IOA. The starting point for our design is the pseudocode used to describe I/O automata. This pseudocode has evolved in two distinct forms: an axiomatic style [23] and an operational style <ref> [22] </ref>. To convert this pseudocode into a real programming language, we made several key design decisions. (1) We chose to define data types axiomatically. <p> Prior to using the code generator, it is often helpful to describe a system design as a composition of node automata A i and abstract channel automata C i;j , as illustrated in channels (see, e.g., the reliable send/receive channels defined in <ref> [22] </ref>, Example 8.1.1). At a lower level of design, illustrated in Figure 2, each abstract channel automaton C i;j is implemented in terms of automata D i;j and D j;i representing real channels, together with protocol automata attached to the node automata.
Reference: [23] <author> Nancy Lynch, Michael Merritt, William Weihl, and Alan Fekete. </author> <title> Atomic Transactions. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Mateo, CA, </address> <year> 1994. </year>
Reference-contexts: 1 Introduction I/O automata [26, 27] have been used to model and verify many distributed algorithms and distributed system designs. and also to express many impossibility results. See, for example, <ref> [22, 23, 2, 3, 16, 35] </ref>. <p> We need a language that (somehow) satisfies both sets of requirements. Design of IOA. The starting point for our design is the pseudocode used to describe I/O automata. This pseudocode has evolved in two distinct forms: an axiomatic style <ref> [23] </ref> and an operational style [22]. To convert this pseudocode into a real programming language, we made several key design decisions. (1) We chose to define data types axiomatically.
Reference: [24] <author> Nancy Lynch and Frits Vaandrager. </author> <title> Forward and backward simulations | Part I: </title> <journal> Untimed systems. Information and Computation, </journal> <volume> 121(2) </volume> <pages> 214-233, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: Proofs for I/O automata typically involve compositional reasoning, invari-ants (i.e., predicates that are true in all reachable states), and (forward and backward) simulation relations. An exposition of the model appears in Chapter 8 of [22]; simulation relations are presented in <ref> [24] </ref>. Requirements. Our first requirement is that our language must allow precise and direct descriptions of I/O automata. The I/O automaton model is a reactive system model rather than a sequential programming model.
Reference: [25] <author> Nancy Lynch and Frits Vaandrager. </author> <title> Forward and backward simulations | Part II: </title> <journal> Timing-based systems. Information and Computation, </journal> <volume> 128(1) </volume> <pages> 1-25, </pages> <month> July </month> <year> 1996. </year> <month> 17 </month>
Reference-contexts: Currently, the IOA tools deal only with safety properties. Instead of liveness properties, we plan to consider time bounds, which can be treated as safety properties. This will involve a future extension of our system to timed I/O automata <ref> [25, 28] </ref>. 5.1 Basic support tools The IOA language has a working parser and static semantic checker, which produce an internal representation suitable for use by other tools.
Reference: [26] <author> Nancy A. Lynch and Mark R. Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> Proceedings of the Sixth Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 137-151, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: 1 Introduction I/O automata <ref> [26, 27] </ref> have been used to model and verify many distributed algorithms and distributed system designs. and also to express many impossibility results. See, for example, [22, 23, 2, 3, 16, 35]. <p> The programming language Occam [19] also uses a process-algebraic language (CSP) [17]. Occam code can be compiled to run on Transputers, but there are no verification tools for Occam programs. 3 The IOA language The IOA language [12] is based on the I/O automaton model <ref> [26, 27] </ref>. An I/O automaton consists of a set of actions, classified as input, output, or internal, a set of states (including a nonempty subset of start states), a set of transitions, which are (state, action, state) triples, and a set of tasks, which are sets of non-input actions.
Reference: [27] <author> Nancy A. Lynch and Mark R. Tuttle. </author> <title> An introduction to input/output automata. </title> <journal> CWI-Quarterly, </journal> <volume> 2(3) </volume> <pages> 219-246, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: 1 Introduction I/O automata <ref> [26, 27] </ref> have been used to model and verify many distributed algorithms and distributed system designs. and also to express many impossibility results. See, for example, [22, 23, 2, 3, 16, 35]. <p> The programming language Occam [19] also uses a process-algebraic language (CSP) [17]. Occam code can be compiled to run on Transputers, but there are no verification tools for Occam programs. 3 The IOA language The IOA language [12] is based on the I/O automaton model <ref> [26, 27] </ref>. An I/O automaton consists of a set of actions, classified as input, output, or internal, a set of states (including a nonempty subset of start states), a set of transitions, which are (state, action, state) triples, and a set of tasks, which are sets of non-input actions.
Reference: [28] <author> Nancy A. Lynch and Frits W. Vaandrager. </author> <title> Action transducers and timed automata. </title> <journal> Formal Aspects of Computing, </journal> <volume> 8(5) </volume> <pages> 499-538, </pages> <year> 1996. </year>
Reference-contexts: Currently, the IOA tools deal only with safety properties. Instead of liveness properties, we plan to consider time bounds, which can be treated as safety properties. This will involve a future extension of our system to timed I/O automata <ref> [25, 28] </ref>. 5.1 Basic support tools The IOA language has a working parser and static semantic checker, which produce an internal representation suitable for use by other tools.
Reference: [29] <author> Zohar Manna et al. </author> <title> STeP: the Stanford Temporal Prover. </title> <type> Technical Report STAN-CS-TR-94-1518, </type> <institution> Department of Computer Science, Stanford University, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: Other work, although not directly based on I/O automata, is related to ours in one way or another. Many researchers have toolkits for validating distributed system designs. The Concurrency Factory [6] uses a process-algebraic language (CCS) with a very different syntax and style from ours. The STeP project <ref> [29] </ref> uses Manna and Pnueli's SPL language [30], which, despite its richer and more complicated syntax and semantics, provides neither a simple trace semantics nor a simple notion of composition, both of which are central to our project. Neither the Concurrency Factory nor STeP provides a code-generation tool.
Reference: [30] <author> Zohar Manna and Amir Pnueli. </author> <title> Temporal Verification of Reactive Systems: Safety. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1995. </year>
Reference-contexts: Many researchers have toolkits for validating distributed system designs. The Concurrency Factory [6] uses a process-algebraic language (CCS) with a very different syntax and style from ours. The STeP project [29] uses Manna and Pnueli's SPL language <ref> [30] </ref>, which, despite its richer and more complicated syntax and semantics, provides neither a simple trace semantics nor a simple notion of composition, both of which are central to our project. Neither the Concurrency Factory nor STeP provides a code-generation tool.
Reference: [31] <author> Tobias Nipkow. </author> <title> Formal verification of data type refinement: Theory and practice. Stepwise Refinement of Distributed Systems: Models, Formalisms, Correctness, </title> <booktitle> Springer-Verlag Lecture Notes in Computer Science 430 </booktitle> <pages> 561-591, </pages> <year> 1990. </year>
Reference-contexts: The paper illustrates these features via an extended example. 2 Related work The earliest automated proof for an I/O-automaton-based design seems to be one by Nipkow, using the Isabelle prover <ref> [31] </ref>. Subsequently, several proofs have been carried out using LP [37, 21, 32], and PVS [1]. Goldman's Spectrum system [13] included a programming language for describing I/O automata and a simulator for that language.
Reference: [32] <author> Tsvetomir P. Petrov, Anna Pogosyants, Stephen J. Garland, Victor Luchangco, and Nancy A. Lynch. </author> <title> Computer-assisted verification of an algorithm for concurrent timestamps. Formal Description Techniques IX: Theory, </title> <booktitle> Applications, and Tools (FORTE/PSTV'96), </booktitle> <pages> pages 29-44, </pages> <publisher> Chapman & Hall, </publisher> <year> 1996. </year>
Reference-contexts: For example, we have proved the correctness of the Dolev-Shavit Bounded Concurrent Timestamp protocol [7] using the Larch Prover (LP) <ref> [32] </ref>. Of course, many other researchers have also used theorem provers to prove invariants and simulation relations, using other state-machine models and theorem provers as well as I/O automata and LP. <p> The paper illustrates these features via an extended example. 2 Related work The earliest automated proof for an I/O-automaton-based design seems to be one by Nipkow, using the Isabelle prover [31]. Subsequently, several proofs have been carried out using LP <ref> [37, 21, 32] </ref>, and PVS [1]. Goldman's Spectrum system [13] included a programming language for describing I/O automata and a simulator for that language.
Reference: [33] <author> J. Postel. </author> <title> Transmission Control Protocol | DARPA Internet Program Specification (Internet Standard STC-007). </title> <institution> Internet RFC-793, </institution> <month> September </month> <year> 1981. </year>
Reference-contexts: Then each node automaton should be translated automatically into actual code that, in a precise sense, implements the node automaton. Each channel automaton should be implemented by an externally-provided service such as TCP <ref> [33] </ref> or MPI [15]. This process can be used to 11 ensure that the final system provably implements higher-level IOA descriptions, subject to assumed properties of the externally-provided services and the underlying hardware.
Reference: [34] <author> N. Shankar, Sam Owre, and John Rushby. </author> <title> The PVS proof checker: A reference manual. </title> <type> Technical report, </type> <institution> Computer Science Lab, SRI Intl., </institution> <address> Menlo Park, CA, </address> <year> 1993. </year>
Reference-contexts: Garland, MIT Laboratory for Computer Science, Cambridge, MA 02139 (garland@lcs.mit.edu) 1 this work has been done by hand; however, much of it (primarily, invariant and forward simulation proofs) is sufficiently stylized to admit computer assistance using interactive theorem provers such as the Larch Prover (LP) [11] or PVS <ref> [34] </ref>. For example, we have proved the correctness of the Dolev-Shavit Bounded Concurrent Timestamp protocol [7] using the Larch Prover (LP) [32].
Reference: [35] <author> Mark Smith. </author> <title> Formal verification of communication protocols. Formal Description Techniques IX: Theory, </title> <booktitle> Applications, and Tools (FORTE/PSTV'96), </booktitle> <pages> pages 129-144, </pages> <publisher> Chapman & Hall, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction I/O automata [26, 27] have been used to model and verify many distributed algorithms and distributed system designs. and also to express many impossibility results. See, for example, <ref> [22, 23, 2, 3, 16, 35] </ref>.
Reference: [36] <author> Mark Smith. </author> <title> Formal Verification of TCP and T/TCP. </title> <type> PhD thesis, </type> <institution> MIT Department of Electrical Engineering and Computer Science, </institution> <month> September </month> <year> 1997. </year>
Reference-contexts: The model and proof methods were originally developed for reasoning about theoretical distributed algorithms. In the past few years, they have been applied increasingly to practical system services such as distributed shared memory services [9], group communication services [10, 5], and standard communication services <ref> [36] </ref>. For these services, the theory has contributed descriptions and proofs, plus important by-products such as interface specifications, invariants, and simulation relations. Ambiguities have been resolved, and at least one significant logical error has been discovered and repaired [9].
Reference: [37] <author> Jtrgen F. Stgaard-Andersen, Stephen J. Garland, John V. Guttag, Nancy A. Lynch, and Anna Pogosyants. </author> <title> Computer-assisted simulation proofs. Computer-Aided Verification, </title> <booktitle> CAV'93, Springer-Verlag Lecture Notes in Computer Science 697 </booktitle> <pages> 305-319, </pages> <year> 1993. </year> <month> 18 </month>
Reference-contexts: The paper illustrates these features via an extended example. 2 Related work The earliest automated proof for an I/O-automaton-based design seems to be one by Nipkow, using the Isabelle prover [31]. Subsequently, several proofs have been carried out using LP <ref> [37, 21, 32] </ref>, and PVS [1]. Goldman's Spectrum system [13] included a programming language for describing I/O automata and a simulator for that language.
References-found: 37

