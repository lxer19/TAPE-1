URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1994/UM-CS-1994-023.ps
Refering-URL: http://laser.cs.umass.edu/abstracts/94-023.html
Root-URL: 
Email: song@scr.siemens.com ljo@cs.umass.edu  
Title: Engineering Software Design Processes to Guide Process Execution  
Author: Xiping Song Leon J. Osterweil 
Address: 755 College Road East  Princeton, NJ 08540 Amherst, MA 01003  
Affiliation: Siemens Corporate Research Inc. Computer Science Department  Univ. of Massachusetts  
Abstract: Using systematic development processes is an important characteristic of any mature engineering discipline. In current software practice, Software Design Methodologies (SDMs) are intended to be used to help design software more systematically. This paper explicitly shows, however, that one well-known example of such an SDM, Booch Object-Oriented Design (BOOD), as described in the literature is far too vague to provide specific guidance to designers, and is too imprecise and incomplete to be considered as a fully systematic process for specific projects. To provide more effective and appropriate guidance and control in software design processes, we applied the process programming concept to the design process. Given two different sets of plausible process requirements, we elaborated two more detailed and precise design processes that are responsive to these requirements. We have also implemented, experimented with, and evaluated a prototype (called Debus-Booch) that supports the execution of these detailed processes. 
Abstract-found: 1
Intro-found: 1
Reference: [ACM90] <author> V. Ambriola, P. Ciamcarini, and C. Montangero. </author> <title> Software process enactment in Oikos. In Proc. 1 This paper was not published at that conference and has not been published at any other conferences or journals. </title> <booktitle> of the 4th ACM SIGSOFT/PLAN Software Engineering Symposium on Practical SDE, </booktitle> <pages> pages 183192, </pages> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: However, without studying specific generic and instantiated processes as we did in this work, the value of these mechanisms is hard to evaluate. This work is related to other projects aimed at developing a process-centered software environment, like those reported in <ref> [MS92, KF87, MR88, Phi89, ACM90, FO91, MGDS90, DG90] </ref>.
Reference: [AWM89] <author> P. Pircher A. Wasserman and R. Muller. </author> <title> An object-oriented structured design method for code generation. </title> <booktitle> ACM SIGSOFT, </booktitle> <volume> 14(1) </volume> <pages> 32-55, </pages> <month> Jan. </month> <year> 1989. </year>
Reference-contexts: Comparisons of our formalisms (e.g., APPL/A) to others can be found in [SHDH + 91, SHO90b]. 14 6 Status and Future Work The current prototype version of Debus-Booch is implemented using C++, Guide (a user interface development tool), and APPL/A. It incorporates StP <ref> [AWM89] </ref> and Arcadia prototypes. The whole prototype consists of about 34 UNIX processes. Each of them supports a console, driver, panel, and other tools. It was also demonstrated at the tools fair of the Fifth International Conference on Software Develop- ment Environments 1 .
Reference: [BN93] <author> R. Balzer and K. Narayanaswamy. </author> <title> Mechanisms for generic process support. </title> <editor> In D. Notkin, editor, </editor> <booktitle> The 1st International Conference on the Foundations of Software Engineering, </booktitle> <pages> pages 21-32. </pages> <publisher> ACM Press, </publisher> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: A more precisely defined SDM process is more likely to be effectively supported and thus provides more effective guidance. This experiment encourages us to be more confident in using the project-domain-specific process programming approach to solving many problems in sharpening and supporting software processes. Some work (e.g., <ref> [BN93] </ref>) studied mechanisms for supporting generic software processes. However, without studying specific generic and instantiated processes as we did in this work, the value of these mechanisms is hard to evaluate.
Reference: [Boo91] <author> G. Booch. </author> <title> Object-Oriented Design with Applications. </title> <publisher> The Benjamin/Commings Publishing Company. Inc., </publisher> <year> 1991. </year>
Reference-contexts: This paper concentrates on the Booch Object Oriented De <p>- 1 sign Methodology (BOOD) <ref> [Boo91] </ref> in order to pro-vide specificity and focus. The paper shows, however, that BOOD, as described and defined in the literature, is far too vague to provide specific guidance to designers, and is too imprecise and incomplete to be considered a very systematic process for the needs of specific projects. <p> A detailed description of BOOD can be found in <ref> [Boo91] </ref>. In this section, we present only a brief description of the architecture of the BOOD process. We believe that it can be summarized as consisting of the following steps: 1. <p> As shown later, these dynamic models of BOOD processes are sufficient to demonstrate this point. Thus, we did not develop OMT's object models and function models for BOOD processes. 2.3 Modeling the BOOD Architecture Fig. 1 represents an OMT model of the original BOOD process architecture, as described in <ref> [Boo91] </ref>. In this architecture, we merged step 2 and 3 of the original BOOD process because our experience shows that it is hard to separate those steps in practice (Booch himself also considers that step 3 is an extension of step 2 [Boo91]). <p> the original BOOD process architecture, as described in <ref> [Boo91] </ref>. In this architecture, we merged step 2 and 3 of the original BOOD process because our experience shows that it is hard to separate those steps in practice (Booch himself also considers that step 3 is an extension of step 2 [Boo91]). We believe that this model is considerably more precise than the informal description originally provided. It is still quite vague and imprecise on many important issues, however. Booch [Boo91] claims that this vagueness is necessary in order to assure that users will be able to tailor and modify it as <p> is hard to separate those steps in practice (Booch himself also considers that step 3 is an extension of step 2 <ref> [Boo91] </ref>). We believe that this model is considerably more precise than the informal description originally provided. It is still quite vague and imprecise on many important issues, however. Booch [Boo91] claims that this vagueness is necessary in order to assure that users will be able to tailor and modify it as dictated by the specifics of particular design situations. For example, step 2 of Fig. 1 does not define the order for editing various BOOD diagrams and templates. <p> It does not define clearly which of the diagrams or templates must be specified in order to move from step 2 to step 3. Booch claims that different designers might have important and legitimate needs to elaborate these details in different ways (Chapters 8-12 of <ref> [Boo91] </ref> provide a few examples). We found that there are indeed many ways in which these details might be elaborated precisely and that many of these different variants might offer better guidance. <p> Schedule should be established for completing corrective action. Quick fixes should be prohibited." This certainly affects how an SDM should be applied to a specific project. The application examples described in <ref> [Boo91] </ref> also provide us with some details that seemed likely to be useful in employing these parameters to help us to derive these BOOD-based design processes. <p> For example, one of Booch's examples indicates that if C++ is to be the eventual application coding language, then class/object diagrams would not need to be translated into module diagrams. In addition, Booch's problem report application example <ref> [Boo91] </ref> helps us to understand the process requirements for developing an information processing system. For instance, that example shows that the method must be tailored to support the design of database schemas. <p> We have also included the possibility of incorporating a prototyping subprocess into this process. We refer to our second elaborated process as the Diagram Oriented Process (DOP), as it emphasizes specifying BOOD diagrams. We derived this process from Booch's Home Heating System example <ref> [Boo91] </ref>. In the DOP we hypothesized that there are only weak requirements in the area of documentation, and we, therefore, do not design in the need for designers to specify BOOD's templates (see Figures 4). <p> These example methods support different degrees of the control over the design process. In the second experiment we used Debus-Booch to develop a design for the problem reporting system as described in <ref> [Boo91] </ref>. This project fits five characteristics of the Diagram Oriented Example (See Table 1). The system is to be coded in C++, has minimum document requirements, and is not safety-critical. It is an information processing system and well-understood.
Reference: [Boo92] <author> Grady Booch. </author> <title> The booch method: Process and pragmatics. </title> <booktitle> Computer Language, </booktitle> <month> July </month> <year> 1992. </year>
Reference: [CKO92] <author> B. Curtis, M. I. Kellner, and J. </author> <title> Over. Process modeling. </title> <journal> Comm. of ACM, </journal> <volume> 35(9), </volume> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: These are to be filled in by others who, we claim, then become design process designers (e.g., the authors of [HKK93]) and implementors when the method is applied to specific projects or organizations. 2.2 Process Definition Formalism Earlier experiences <ref> [KH88, CKO92] </ref> have shown that the State-Charts formalism [HLN + 90] is a powerful vehicle for modeling software processes.
Reference: [Con87] <author> J. Conklin. </author> <title> Hypertext: An introduction and sur-vey. </title> <booktitle> IEEE Computer, </booktitle> <month> Sept </month> <year> 1987. </year>
Reference-contexts: This problem is similar to the "getting lost in hyperspace" problem found in hypertext system <ref> [Con87] </ref>. 2) Need to minimize the time overhead from transiting between various tools that support various design steps. These suggestions clearly reinforce our observations about the problem of mental and resource overhead [SO93].
Reference: [DG90] <author> W. Deiters and V. Gruhn. </author> <title> Managing software pro-cesses in the environment melmac. </title> <booktitle> In Proc. of the 4th ACM SIGSOFT/PLAN Software Engineering Symposium on Practical SDE, </booktitle> <pages> pages 193-205, </pages> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: However, without studying specific generic and instantiated processes as we did in this work, the value of these mechanisms is hard to evaluate. This work is related to other projects aimed at developing a process-centered software environment, like those reported in <ref> [MS92, KF87, MR88, Phi89, ACM90, FO91, MGDS90, DG90] </ref>.
Reference: [FDA89] <institution> Preproduction quality assurance planning: Recommendations for medical device manufacturers. </institution> <type> Technical report, </type> <institution> Office of Compliance and Surveillance, Food and Drug Administration, </institution> <year> 1989. </year>
Reference-contexts: For example, when consulting with Siemens medical companies, we found that the U.S. Food and Drug Administration (FDA). has specific documentation requirements, and requires control and monitoring of corrective actions on the product design. <ref> [FDA89] </ref> says that "when corrective action is required, the action should be appropriately monitored... Schedule should be established for completing corrective action. Quick fixes should be prohibited." This certainly affects how an SDM should be applied to a specific project. <p> These processes resulting from the tailoring, and supported by the appropriate tools, provide more effective guidance and help implement various recommended practices (e.g, those recommended by FDA <ref> [FDA89] </ref>).
Reference: [FO91] <author> C. Fernstrom and L Ohlsson. </author> <title> Integration needs in process enacted environments. </title> <booktitle> In The Proc. of the 1st Int. Conf. on the Software Process, </booktitle> <pages> pages 128-141. </pages> <publisher> IEEE CS, </publisher> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: However, without studying specific generic and instantiated processes as we did in this work, the value of these mechanisms is hard to evaluate. This work is related to other projects aimed at developing a process-centered software environment, like those reported in <ref> [MS92, KF87, MR88, Phi89, ACM90, FO91, MGDS90, DG90] </ref>. <p> Another difference is that our work focuses on evaluating varied external behaviors of the system while other work focuses on the study of implementation mechanisms and process representation formalisms (e.g., <ref> [FO91] </ref>). The study of these mechanisms and formalisms is not the focus of our paper.
Reference: [HKK93] <author> S. Honiden, N. Kotaka, and Y. Kishimoto. </author> <title> Formalizing specification modeling in ooa. </title> <journal> IEEE Software, </journal> <month> Jan </month> <year> 1993. </year>
Reference-contexts: On the other hand, it provides no specific guidance, details or procedures. These are to be filled in by others who, we claim, then become design process designers (e.g., the authors of <ref> [HKK93] </ref>) and implementors when the method is applied to specific projects or organizations. 2.2 Process Definition Formalism Earlier experiences [KH88, CKO92] have shown that the State-Charts formalism [HLN + 90] is a powerful vehicle for modeling software processes.
Reference: [HLN + 90] <author> D. Harel, H. Lachover, A. Naamad, A. Pnuell, M. Politi, R. Sherman, A. Shtull-Trauring, and M. Trakhtenbrot. Statemate: </author> <title> a working environ-ment for the development of complex reactive sys-tems. </title> <journal> IEEE Transaction on SE, </journal> <volume> 16(4) </volume> <pages> 403-414, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: These are to be filled in by others who, we claim, then become design process designers (e.g., the authors of [HKK93]) and implementors when the method is applied to specific projects or organizations. 2.2 Process Definition Formalism Earlier experiences [KH88, CKO92] have shown that the State-Charts formalism <ref> [HLN + 90] </ref> is a powerful vehicle for modeling software processes. Thus, we use a variant of State-Charts [HLN + 90], the dynamic modeling notation of the Object Modeling Technique (OMT) [RBP + 91], to model the processes that we will elaborate from BOOD. <p> designers (e.g., the authors of [HKK93]) and implementors when the method is applied to specific projects or organizations. 2.2 Process Definition Formalism Earlier experiences [KH88, CKO92] have shown that the State-Charts formalism <ref> [HLN + 90] </ref> is a powerful vehicle for modeling software processes. Thus, we use a variant of State-Charts [HLN + 90], the dynamic modeling notation of the Object Modeling Technique (OMT) [RBP + 91], to model the processes that we will elaborate from BOOD.
Reference: [Hum93] <author> W. S. Humphrey. </author> <title> Using the personal software pro-cess. </title> <type> Private communication, </type> <year> 1993. </year>
Reference-contexts: As design is perhaps the most crucial task in software development, it seems particularly crucial that software design processes be clearly defined in such a way as to be more systematic. Humphrey <ref> [Hum93] </ref> says that "one of the great misconceptions about creative work is that it is all creative. Even the most advanced research and development involves a lot of routine. ...
Reference: [ISP88] <editor> In C. Potts, editor, </editor> <booktitle> Proc of the 4th International Workshop on the Software Process, </booktitle> <month> May </month> <year> 1988. </year>
Reference: [JKLW90] <author> Jr J. Kirby, R. C. Lai, and D. M. Weiss. </author> <title> A for-malization of a design process. </title> <booktitle> In Proc of the 1990 Pacific Software Quality Conference, </booktitle> <year> 1990. </year>
Reference: [KF87] <author> G. E. Kaiser and P. H. Feiler. </author> <title> An architecture for intelligent assistence in software development. </title> <booktitle> In Proc. of 9th International Conference on Software Engineering, </booktitle> <pages> pages 180-188, </pages> <year> 1987. </year>
Reference-contexts: However, without studying specific generic and instantiated processes as we did in this work, the value of these mechanisms is hard to evaluate. This work is related to other projects aimed at developing a process-centered software environment, like those reported in <ref> [MS92, KF87, MR88, Phi89, ACM90, FO91, MGDS90, DG90] </ref>. <p> For example, we provide very specific interface architecture and tool access methods for supporting SDMs and their various users. In contrast, most work in developing process-centered environments is aimed at developing general-purpose software development environments. For instance, [MR88] supports specifying any software development rules. Marvel <ref> [KF87] </ref> is a general purpose programming environment. It does not describe specifically how to provide effective guidance for using specific development method on specific kinds of projects.
Reference: [KH88] <author> M. I. Kellner and G. A. Hansen. </author> <title> Software pro-cess modeling. </title> <type> Technical report, Technical Report CMU/SEI-88-TR-9, </type> <month> May </month> <year> 1988. </year>
Reference-contexts: These are to be filled in by others who, we claim, then become design process designers (e.g., the authors of [HKK93]) and implementors when the method is applied to specific projects or organizations. 2.2 Process Definition Formalism Earlier experiences <ref> [KH88, CKO92] </ref> have shown that the State-Charts formalism [HLN + 90] is a powerful vehicle for modeling software processes.
Reference: [MGDS90] <author> N. H. Madhavji, V. Gruhn, W. Deiters, and W. Schafer. </author> <title> Prism = methodology + processoriented environment. </title> <booktitle> In Proc. of 12th International Conference on Software Engineering, </booktitle> <month> March </month> <year> 1990. </year>
Reference-contexts: However, without studying specific generic and instantiated processes as we did in this work, the value of these mechanisms is hard to evaluate. This work is related to other projects aimed at developing a process-centered software environment, like those reported in <ref> [MS92, KF87, MR88, Phi89, ACM90, FO91, MGDS90, DG90] </ref>.
Reference: [MR88] <author> N. Minsky and D. Rozenshtein. </author> <title> Software devel--opment environment for law-governed systems. </title> <booktitle> In Proc. of the ACM SIGSOFT/PLAN Software Engineering Symposium on Practical SDE, </booktitle> <pages> pages 6575, </pages> <month> Nov. </month> <year> 1988. </year>
Reference-contexts: However, without studying specific generic and instantiated processes as we did in this work, the value of these mechanisms is hard to evaluate. This work is related to other projects aimed at developing a process-centered software environment, like those reported in <ref> [MS92, KF87, MR88, Phi89, ACM90, FO91, MGDS90, DG90] </ref>. <p> For example, we provide very specific interface architecture and tool access methods for supporting SDMs and their various users. In contrast, most work in developing process-centered environments is aimed at developing general-purpose software development environments. For instance, <ref> [MR88] </ref> supports specifying any software development rules. Marvel [KF87] is a general purpose programming environment. It does not describe specifically how to provide effective guidance for using specific development method on specific kinds of projects.
Reference: [MS92] <author> P. Mi and W. Scacchi. </author> <title> Process integration in CASE environments. </title> <journal> IEEE Software, </journal> <volume> 8(2), </volume> <month> March </month> <year> 1992. </year>
Reference-contexts: However, without studying specific generic and instantiated processes as we did in this work, the value of these mechanisms is hard to evaluate. This work is related to other projects aimed at developing a process-centered software environment, like those reported in <ref> [MS92, KF87, MR88, Phi89, ACM90, FO91, MGDS90, DG90] </ref>.
Reference: [Ost87] <author> Leon J. Osterweil. </author> <title> Software processes are soft-ware too. </title> <booktitle> In Proceedings of the 9th International Conference on Software Engineering, </booktitle> <pages> pages 2-13, </pages> <month> March </month> <year> 1987. </year>
Reference-contexts: On the other hand, we did find that BOOD could be considered to be a methodological framework for a family of such processes. Our work builds upon the basic ideas of process programming <ref> [Ost87] </ref>, which suggest that software processes should be thought of as software themselves, and that software processes should be designed, coded, and executed.
Reference: [Phi89] <author> R. W. Phillips. </author> <title> State change architecture: A pro-totype for executable process models. </title> <booktitle> In Proc of the 22nd Annual Hawaii International Conference on Software Engineering, Vol II. Software Track, </booktitle> <pages> pages 154-164, </pages> <month> Jan. </month> <year> 1989. </year>
Reference-contexts: However, without studying specific generic and instantiated processes as we did in this work, the value of these mechanisms is hard to evaluate. This work is related to other projects aimed at developing a process-centered software environment, like those reported in <ref> [MS92, KF87, MR88, Phi89, ACM90, FO91, MGDS90, DG90] </ref>.
Reference: [RBP + 91] <author> J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, and W. Lorensen. </author> <title> Object Oriented Modeling and Design. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: We show that these elaborations can be defined very precisely through the use of such accepted software design representations as OMT <ref> [RBP + 91] </ref>, and through the use of process coding languages such as APPL/A. Indeed, this paper shows that the use of such formalisms is exactly what is needed in order to render these elaborations sufficiently complete and precise that they can be considered to be systematic. <p> Thus, we use a variant of State-Charts [HLN + 90], the dynamic modeling notation of the Object Modeling Technique (OMT) <ref> [RBP + 91] </ref>, to model the processes that we will elaborate from BOOD.
Reference: [RC92] <author> D.J. Richardson and J. Chang. </author> <note> Rebus require-ments on elevator control system. Available upon request, </note> <month> Dec. </month> <year> 1992. </year>
Reference-contexts: In the 10 11 first experiment, we used the prototype to develop a design example: an elevator control system. This is a real-time system that controls the moving of elevators in response to requests of users <ref> [RC92] </ref>. It was used as an example for demonstrating how the Arcadia consortium supports the whole software development life- cycle. The system requires full documentation, and is to be implemented in Ada. It is safety-critical and device-embedded.
Reference: [RG92] <author> K. S. Rubin and A. Goldberg. </author> <title> Object behav-ior analysis. </title> <journal> Communication of ACM, </journal> (9):48-62, Sept. 1992. 
Reference: [SHDH + 91] <author> S. M. Sutton, Ziv H, H. E. Yessayan D. Heimbigner, M. Maybee, L. J. Osterweil, and X. Song. </author> <title> Programming a software requirementsspecification process. </title> <booktitle> In The Proc. of the 1st Int. Conf. on the Software Process, </booktitle> <pages> pages 68-89. </pages> <publisher> IEEE CS, </publisher> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: As most designers must work in teams, and are often engaged in multiple projects simultaneously, a practical system for support of such users must do more than simply execute straightforward encodings of BOOD elaborations. Our Debus-Booch prototype adapts an architecture used in a previous research prototype (Rebus <ref> [SHDH + 91] </ref>). The architecture lets developers post (to be done) and submit (finished) tasks to a whiteboard to coordinate their task assignments. <p> Then, designers must enter the name of the subsystem to be designed. This subsystem can be assigned to them from a management process or a high-level system decomposition process (e.g., in our case, it is on the whiteboard <ref> [SHDH + 91] </ref>). 3. <p> It is clearly unrealistic to assume that this is the mode in which most designers work, and that, therefore, support for this mode of work is sufficient. In our work we adapted an architecture <ref> [SHDH + 91] </ref> that is capable of supporting group development. <p> The study of these mechanisms and formalisms is not the focus of our paper. Comparisons of our formalisms (e.g., APPL/A) to others can be found in <ref> [SHDH + 91, SHO90b] </ref>. 14 6 Status and Future Work The current prototype version of Debus-Booch is implemented using C++, Guide (a user interface development tool), and APPL/A. It incorporates StP [AWM89] and Arcadia prototypes. The whole prototype consists of about 34 UNIX processes.
Reference: [SHO90a] <author> S. Sutton, D. Heimbigner, and L. J. Osterweil. </author> <title> Language constructs for managing change in process centerd environments. </title> <booktitle> In Proc. of the 4th ACM SIGSOFT/PLAN Software Engineering Symposium on Practical SDE, </booktitle> <pages> pages 206-217, </pages> <month> Dec. </month> <year> 1990. </year>
Reference: [SHO90b] <author> S. M. Sutton, D. Heimbigner, and L. J. Osterweil. </author> <title> Language constructs for managing change in process-centered environments. </title> <booktitle> In Proceedings of the Fourth ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <pages> pages 206-216, </pages> <address> Irvine, </address> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: Specification of this order might well be the basis for important guidance to a designer about which design issues ought to be considered before which others. Thus, we found it necessary to supplement OMT, by using a process coding language called APPL/A <ref> [SHO90b] </ref> to model such details. APPL/A is a superset of Ada that supports many features that we found to be useful. Some examples of APPL/A code are also provided in subsequent sections of this paper. <p> The study of these mechanisms and formalisms is not the focus of our paper. Comparisons of our formalisms (e.g., APPL/A) to others can be found in <ref> [SHDH + 91, SHO90b] </ref>. 14 6 Status and Future Work The current prototype version of Debus-Booch is implemented using C++, Guide (a user interface development tool), and APPL/A. It incorporates StP [AWM89] and Arcadia prototypes. The whole prototype consists of about 34 UNIX processes.
Reference: [SM92] <author> S. Shlaer and S. J. Mellor. </author> <title> Real time recursive design. Available from authors, </title> <year> 1992. </year>
Reference: [SMOH91] <author> X. Song, M. Maybee, L. J. Osterweil, and D. Heimbigner. Rebus: </author> <title> A requirement specification pro-cess program. </title> <type> Technical Report 91-17, </type> <institution> ICS Dept. University of California, Irvine, </institution> <month> April </month> <year> 1991. </year>
Reference: [SO89] <author> X. Song and L. J. Osterweil. Debus: </author> <title> a software de-sign process program. </title> <type> Technical report, </type> <institution> Arcadiadocument, UCI-89-02, </institution> <month> April </month> <year> 1989. </year>
Reference: [SO92] <author> X. Song and L. J. Osterweil. </author> <title> Towards objective, systematic design-method comparison. </title> <journal> IEEE Software, </journal> <pages> pages 43-53, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Documenation and Help Support (Ac-- cessed through Displays): This support can be obtained in conjunction with the use of tools that support atomic activities. The displays that are made available convey a variety of information, such as the criteria, guidelines, examples, and measures <ref> [SO92] </ref> to be used to help designers understand how to carry out the activity. Debus-Booch provides the flexibility that is needed for experienced designers. Designers can use a console display to access all of the supports listed above.
Reference: [SO93] <author> X. Song and L. Osterweil. </author> <title> Challenges in execut-ing design process. </title> <booktitle> In Preprints of the 8th International Software Process Workshop, </booktitle> <month> March </month> <year> 1993. </year> <note> Available from the authors upon request. </note>
Reference-contexts: This problem is similar to the "getting lost in hyperspace" problem found in hypertext system [Con87]. 2) Need to minimize the time overhead from transiting between various tools that support various design steps. These suggestions clearly reinforce our observations about the problem of mental and resource overhead <ref> [SO93] </ref>. Novice designers are more willing to accept the overhead to trade for more guidance while skilled designers are not. However, 12 the evaluation seems to indicate that even for the novice designers, the process execution tree cannot be too deep.
References-found: 33

