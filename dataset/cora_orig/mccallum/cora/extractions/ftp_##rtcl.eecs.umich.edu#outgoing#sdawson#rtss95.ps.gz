URL: ftp://rtcl.eecs.umich.edu/outgoing/sdawson/rtss95.ps.gz
Refering-URL: http://www.eecs.umich.edu/~farnam/papers/pubs.html
Root-URL: http://www.cs.umich.edu
Email: fsdawson,farnam,mittong@eecs.umich.edu  
Title: A Software Fault Injection Tool on Real-Time Mach  
Author: Scott Dawson, Farnam Jahanian, and Todd Mitton 
Address: Ann Arbor, MI 48109-2122 USA  
Affiliation: Real-Time Computing Laboratory Electrical Engineering and Computer Science Department University of Michigan  
Abstract: Ensuring that a distributed real-time system with strict dependability constraints meets its prescribed specification is a growing challenge that confronts software developers and system engineers. This paper reports on a software fault injection tool, called SockPFI, for testing the fault tolerance and timing behavior of distributed real-time applications. SockPFI, developed on Real-Time Mach, can be used to test socket-based distributed real-time applications on this platform without modifying the source code of the target protocol. The SockPFI tool is based on the concept of script-driven probing and fault injection [1]. It is explicitly designed to address some of the intrusiveness associated with fault injection of distributed systems, and in particular, with real-time protocols. The paper describes the design and implementation of SockPFI on Real Time Mach, and a demonstration of the tool on a real-time primary-backup replication protocol. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Scott Dawson and Farnam Jahanian, </author> <title> "Deterministic Fault Injection of Distributed Systems," </title> <booktitle> in Lecture Notes in Computer Science: Unifying Theory and Practice of Distributed Computing. </booktitle> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1994. </year>
Reference-contexts: This paper reports on a software fault injection tool, developed on Real-Time Mach 3.0, for testing the fault tolerance and timing behavior of distributed real-time applications. This tool is based on a simple yet powerful framework, called script-driven probing and fault injection <ref> [1] </ref>, for the evaluation and validation of distributed applications and communication protocols. The emphasis of this approach is on experimental techniques intended to identify specific "problems" in a protocol or its implementation rather than the evaluation of system dependability through statistical metrics such as fault coverage (e.g. [2]).
Reference: [2] <author> Jean Arlat and Martine Aguera and Yves Crouzet and Jean-Charles Fabre and Eliane Martins and David Powell, </author> <title> "Experimental evaluation of the fault tolerance of an atomic multicast system," </title> <journal> IEEE Trans. Reliability, </journal> <volume> vol. 39, no. 4, </volume> <pages> pp. 455-467, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: The emphasis of this approach is on experimental techniques intended to identify specific "problems" in a protocol or its implementation rather than the evaluation of system dependability through statistical metrics such as fault coverage (e.g. <ref> [2] </ref>). This work will appear in the Proceedings of IEEE Real-Time Systems Symposium, Dec. 1995. This work is supported in part by a research grant from the U.S. Office of Naval Research, N0014-95-1-0261, and a research grant from the National Science Foundation, CCR-9502341. <p> However, fault-injection and testing dependability of distributed systems has received very little attention until recently [18-21]. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. For example, the work reported in <ref> [2] </ref> calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol [22] in the presence of faults. Other work can be characterized as probabilistic approaches to test generation [18, 20].
Reference: [3] <author> Seth A. Hutchinson and Avinash C. Kak, "Spar: </author> <title> A Planner That Satisfies Operational and Geometric Goals in Uncertain Environmnents," </title> <journal> AI Magazine, </journal> <pages> pp. 30-61, </pages> <month> Spring </month> <year> 1990. </year>
Reference-contexts: In the model underlying script-driven probing and fault injection, a distributed protocol can be viewed as an abstraction through which a collection of participants communicate by exchanging a set of messages, in the same spirit as the x-kernel <ref> [3] </ref>. Hence, no distinction is made between application-level protocols, communication protocols, or device layer protocols. In this approach, a probe/fault injection (PFI) layer is inserted below a target protocol to filter and manipulate the messages that are exchanged between participants. <p> The last subsection discusses the intrusiveness of this fault injection approach on real-time protocols. 2.1 Overview In script-driven probing and fault injection, a distributed protocol can be viewed as an abstraction through which a collection of participants communicate by exchanging a set of messages, as in the x-kernel <ref> [3] </ref>. Each layer provides an abstract communication service to higher layers, and there is no dis tinction made between particular layers of the protocol stack.
Reference: [4] <author> Scott Dawson and Farnam Jahanian, </author> <title> "Probing and Fault Injection of Protocol Implementations," </title> <booktitle> Proc. Int. Conf. on Distributed Computer Systems, </booktitle> <month> May </month> <year> 1995. </year>
Reference-contexts: This tool was developed first on the x-kernel and later ported to SunOS. We have used this (relatively simple) tool to conduct extensive experimental studies of several commercial and prototype implementations of distributed applications and communication protocols. A recent report <ref> [4] </ref> presents a detailed discussion on a number of surprising results from experimental studies of several asynchronous protocols including four commercial implementations of TCP on SunOS, Sun Solaris 1 , AIX 2 , and NextStep 3 without having access to the vendors' source code. <p> This is particularly useful when testing protocols for which the source code is unavailable. As described in another paper, we have been successful in demonstrating this approach on four commercial implementations of TCP without access to the source code, i.e., the target machines were not instrumented <ref> [4] </ref>. performed with the PFI tool. In Figure 2 (a), all protocol stacks in the system are given a modified protocol stack containing the PFI layer. <p> A more detailed comparison on fault injection of the TCP protocol appears in <ref> [4] </ref>. (b) Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection (e.g. [12, 13]) and simulation approaches for injecting hardware failures (e.g. [14, 15]) have received much attention in the past. <p> Although our implementation of SockPFI described in this paper is fixed at the socket layer, the protocol independent nature of the PFICore should allow the PFI layer to be moved around the protocol stack fairly easily. In a previous paper <ref> [4] </ref> we describe an x-kernel layer implementation which can be placed anywhere in an x-kernel protocol stack. In addition, the EFA fault injector requires each node to be instrumented with a fault injection layer. In our PFI system, it is possible that some nodes do not contain fault injection layers.
Reference: [5] <author> Clifford W. Mercer and Jim Zelenka and Ragunathan Rajkumar, </author> <title> "On Predictable Operating System Protocol Processing," </title> <type> Technical Report CMU-CS-94-165, </type> <institution> Carnegie Mellon University, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: The tool was developed on Real-Time Mach from CMU, and it can be used to test socket-based distributed applications on this platform. The SockPFI tool allows the exploitation of some of the features of Real Time Mach, such as "scheduler feedback and capacity reservation" <ref> [5] </ref>, to quantify intrusiveness on a target protocol and to compensate for it whenever possible. A novel aspect of this tool is that it does not require the application programmer to instrument the target protocol implementation. <p> First, since most of the intrusiveness of the proposed fault injection and probing technique will manifest itself as additional communication overhead, the capacity reservation facility <ref> [5] </ref> in Real-Time Mach is an effective mechanism for compensating for this overhead by allocating extra CPU resources to schedule communication activities. <p> In Real-Time Mach, user level sock-ets have been used along with processor reserves to achieve predictable protocol processing <ref> [5] </ref>. Protocol processing is made predictable by binding the protocol processing thread to a processor reserve so that sufficient time is set aside for communication.
Reference: [6] <author> C. Maeda and B. N. Bershad, </author> <title> "Protocol service decomposition for high-performance networking," </title> <booktitle> in Proc. ACM Symp. on Operating Systems Principles, </booktitle> <pages> pp. 244-255, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: In Mach 3.0, these operations are implemented in the UX server. In addition to having socket support in the UX server, Mach 3.0 also provides a user level socket library (libsockets.a) <ref> [6] </ref>, which performs protocol operations such as send and receive. In the socket library, an additional thread is created in the application which takes care of marshalling packets up and down the protocol stack. The protocol stack itself resides inside the application's address space. <p> For applications which are simply sending and receiving data, significant speedup has been achieved by using the user level library thread and bypassing 4 UNIX is a registered trademark of UNIX System Laboratories, Inc. the UX server <ref> [6] </ref>. In Real-Time Mach, user level sock-ets have been used along with processor reserves to achieve predictable protocol processing [5]. Protocol processing is made predictable by binding the protocol processing thread to a processor reserve so that sufficient time is set aside for communication.
Reference: [7] <author> John K. Ousterhout, </author> <title> "Tcl: An Embeddable Command Language," </title> <booktitle> in Winter USENIX Conference, </booktitle> <pages> pp. 133-146, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Our experiments have shown this feature of our tool to be very useful. In order to inject faults into a message, the PFICore invokes a filter on the message. In our implementation, the filter is a Tcl interpreter <ref> [7] </ref> which interprets Tcl scripts. The scripts are able to recognize and generate messages through the use of routines which are registered with the Tcl interpreter as Tcl commands. These routines are written in C, and have access to data structures in the SockPFI layer.
Reference: [8] <author> Ashish Mehra and Jennifer Rexford and Hock-Siong Ang and Farnam Jahanian, </author> <title> "Design and evaluation of a window-consistent replication service," </title> <booktitle> in Proc. IEEE Real-Time Technology and Applications Symposium, </booktitle> <pages> pp. 182-191, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: GUI. The test which is being generated is testing how a backup server in the real-time primary backup protocol (described more fully in Section 4 and in <ref> [8] </ref>), responds to bursty network behavior. The backup server expects to see UPDATE OBJECT messages for objects before the object becomes window-inconsistent. By withholding packets, and sending them out in a burst, we are delaying UPDATE OBJECT messages. <p> When the backup detected this, it would declare the primary dead, and would take over as the new primary. The protocol behaved as expected. Performance Metric Calculation: Several performance results for the window-consistent replication service were reported in <ref> [8] </ref>. All results required dropping UPDATE OBJECT messages from the primary server to the backup server with certain probabilities, and collecting data about what percentage of objects would become inconsistent.
Reference: [9] <author> H. Tokuda, T. Nakajima, and P. Rao, </author> <title> "Real-time Mach: Towards a predictable real-time system," </title> <booktitle> in Proc. of USENIX Mach Workshop, </booktitle> <pages> pp. 1-10, </pages> <month> Octo-ber </month> <year> 1990. </year>
Reference-contexts: The experiments were conducted to demonstrate the capabilities of the SockPFI tool as described in Section 3, and were run on the SockPFI layer running on the Real-Time Mach platform <ref> [9] </ref>. The purpose of the window-consistent primary backup protocol is to provide a replication service that provides timely availability of data by relaxing the consistency of the replicated data.
Reference: [10] <author> J. Mogul, R. Rashid, and M. Accetta, </author> <title> "The packet filter: An efficient mechanism for user-level network code," </title> <booktitle> in Proc. ACM Symp. on Operating Systems Principles, </booktitle> <pages> pp. 39-51, </pages> <address> Austin, TX, </address> <month> November </month> <year> 1987, </year> <note> ACM. </note>
Reference-contexts: To minimize data copying across kernel/user-space protection boundaries, a kernel agent, called a packet filter, is often used to discard unwanted packets as early as possible (e.g. <ref> [10, 11] </ref>). In the same spirit as packet filtration methods for network monitoring, our approach inserts a filter to intercept messages that arrive from the network.
Reference: [11] <author> Steven McCanne and Van Jacobson, </author> <title> "The BSD Packet Filter: A New Architecture for User-level Packet Capture," </title> <booktitle> in Winter USENIX Conference, </booktitle> <pages> pp. 259-269, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: To minimize data copying across kernel/user-space protection boundaries, a kernel agent, called a packet filter, is often used to discard unwanted packets as early as possible (e.g. <ref> [10, 11] </ref>). In the same spirit as packet filtration methods for network monitoring, our approach inserts a filter to intercept messages that arrive from the network.
Reference: [12] <author> K. G. Shin and Y. H. Lee, </author> <title> "Measurement and application of fault latency," </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. C-35, no. 4, </volume> <pages> pp. 370-375, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: A more detailed comparison on fault injection of the TCP protocol appears in [4]. (b) Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection (e.g. <ref> [12, 13] </ref>) and simulation approaches for injecting hardware failures (e.g. [14, 15]) have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [16, 17].
Reference: [13] <author> J. Arlat, Y. Crouzet, and J.-C. Laprie, </author> <title> "Fault injection for dependability validation of fault-tolerant computing systems.," </title> <booktitle> in Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pp. 348-355, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: A more detailed comparison on fault injection of the TCP protocol appears in [4]. (b) Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection (e.g. <ref> [12, 13] </ref>) and simulation approaches for injecting hardware failures (e.g. [14, 15]) have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [16, 17].
Reference: [14] <author> K. Goswami and R. Iyer, </author> <title> "Simulation of software be-haviour under hardware faults," </title> <booktitle> in Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pp. 218-227. </pages> <publisher> IEEE, </publisher> <year> 1993. </year>
Reference-contexts: A more detailed comparison on fault injection of the TCP protocol appears in [4]. (b) Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection (e.g. [12, 13]) and simulation approaches for injecting hardware failures (e.g. <ref> [14, 15] </ref>) have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [16, 17]. However, fault-injection and testing dependability of distributed systems has received very little attention until recently [18-21].
Reference: [15] <author> E. Czeck and D. Siewiorek, </author> <title> "Effects of transient gate-level faults on program behaviour," </title> <booktitle> in Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pp. 236-243. </pages> <publisher> IEEE, </publisher> <year> 1990. </year>
Reference-contexts: A more detailed comparison on fault injection of the TCP protocol appears in [4]. (b) Fault injection approaches: Various techniques based on fault-injection have been proposed to test fault-tolerance capabilities of systems. Hardware fault-injection (e.g. [12, 13]) and simulation approaches for injecting hardware failures (e.g. <ref> [14, 15] </ref>) have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors [16, 17]. However, fault-injection and testing dependability of distributed systems has received very little attention until recently [18-21].
Reference: [16] <author> R. Chillarege and N. S. Bowen, </author> <title> "Understanding large system failures | a fault injection experiment," </title> <booktitle> in Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pp. 356-363, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Hardware fault-injection (e.g. [12, 13]) and simulation approaches for injecting hardware failures (e.g. [14, 15]) have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors <ref> [16, 17] </ref>. However, fault-injection and testing dependability of distributed systems has received very little attention until recently [18-21]. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics.
Reference: [17] <author> Z. Segall et al., </author> <title> "Fiat fault injection based automated testing environment," </title> <booktitle> in FTCS-18, </booktitle> <pages> pp. 102-107, </pages> <year> 1988. </year>
Reference-contexts: Hardware fault-injection (e.g. [12, 13]) and simulation approaches for injecting hardware failures (e.g. [14, 15]) have received much attention in the past. Recent efforts have focused on software fault-injection by inserting faults into system memory to emulate errors <ref> [16, 17] </ref>. However, fault-injection and testing dependability of distributed systems has received very little attention until recently [18-21]. Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics.
Reference: [18] <author> K. Echtle and Y. Chen, </author> <title> "Evaluation of deterministic fault injection for fault-tolerant protocol testing," </title> <booktitle> in Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pp. 418-425. </pages> <publisher> IEEE, </publisher> <year> 1991. </year>
Reference-contexts: For example, the work reported in [2] calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol [22] in the presence of faults. Other work can be characterized as probabilistic approaches to test generation <ref> [18, 20] </ref>. The work reported in [21] focuses on CPU and memory fault injection into a distributed real-time system; this approach also allows inducing communication faults with a given statistical distribution that is specified by the system implementor. <p> The tool is used mainly for emulating a wide-area network in a local network development environment and allows the user to specify delays on certain paths which the application is using. This work and the EFA fault injection environment reported in <ref> [18] </ref> are closest to the approach described here. The EFA fault injector proposes inserting a fault injection layer below the fault tolerant-target protocol layer. Their work differs from ours on several key points.
Reference: [19] <author> Klaus Echtle and Martin Leu, </author> <title> "The EFA Fault Injector for Fault-Tolerant Distributed System Testing," </title> <booktitle> in Workshop on Fault-Tolerant Parallel and Distributed Systems, </booktitle> <pages> pp. 28-35. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference: [20] <author> D. Avresky, J. Arlat, J. Laprie, and Y. Crouzet, </author> <title> "Fault injection for the formal testing of fault tolerance," </title> <booktitle> in Proc. Int'l Symp. on Fault-Tolerant Computing, </booktitle> <pages> pp. 345-354. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: For example, the work reported in [2] calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol [22] in the presence of faults. Other work can be characterized as probabilistic approaches to test generation <ref> [18, 20] </ref>. The work reported in [21] focuses on CPU and memory fault injection into a distributed real-time system; this approach also allows inducing communication faults with a given statistical distribution that is specified by the system implementor.
Reference: [21] <author> Seungjae Han and Harold A. Rosenberg and Kang G. Shin, "DOCTOR: </author> <title> An integrateD SOftware fault injeCTOn enviRonment," </title> <type> Technical report, </type> <year> 1993. </year>
Reference-contexts: Other work can be characterized as probabilistic approaches to test generation [18, 20]. The work reported in <ref> [21] </ref> focuses on CPU and memory fault injection into a distributed real-time system; this approach also allows inducing communication faults with a given statistical distribution that is specified by the system implementor.
Reference: [22] <author> P. Verissimo, L. Rodrigues, and M. Batista, </author> <title> "Amp: A highly parallel atomic multicast protocol," </title> <booktitle> in Proc. of ACM SIGCOMM, </booktitle> <pages> pp. 83-93, </pages> <address> Austin, TX, </address> <month> September </month> <year> 1990. </year>
Reference-contexts: Most of the recent work in this area have focused on evaluating dependability of distributed protocol implementations through statistical metrics. For example, the work reported in [2] calculates fault coverages of a communication network server by injecting physical faults, and it tests certain properties of an atomic multicast protocol <ref> [22] </ref> in the presence of faults. Other work can be characterized as probabilistic approaches to test generation [18, 20]. <p> The effectiveness of this approach for evaluating dependability of real-time protocols can only be demonstrated through extensive experiments. The SockPFI tool on a RT-Mach-based testbed currently serves as a platform for performing ongoing experiments on commercial and prototype real-time protocols (e.g., <ref> [22] </ref>). Specification of PFI scripts: In the approach described in this paper, probe and fault injection scripts are hand-crafted for a given protocol. As described in Section 3, the SockPFI tool also provides a state transition-based graphical user interface for specifying scripts and for composing them into more complex filters.
Reference: [23] <author> David B. Ingham and Graham D. Parrington, "Delay-line: </author> <title> A Wide-Area Network Emulation Tool," </title> <journal> Computing Systems, </journal> <volume> vol. 7, no. 3, </volume> <pages> pp. 313-332, </pages> <month> Summer </month> <year> 1994. </year>
Reference-contexts: Hence, deterministic control on ordering of certain concurrent messages is a key to this approach. Finally, one significant distinguishing characteristic of our approach is the focus on real-time as well as fault tolerance characteristics of distributed systems. The Delayline tool presented in <ref> [23] </ref> allows the user to introduce delays into user-level protocols. The tool is used mainly for emulating a wide-area network in a local network development environment and allows the user to specify delays on certain paths which the application is using.
Reference: [24] <author> O. Babaoglu and K. Marzullo, </author> <title> "Consistent global states of distributed systems: Fundamental concepts and mechanism," in Distributed Systems, </title> <editor> S. Mullen-der, editor, </editor> <publisher> Addison Wesley, </publisher> <year> 1993. </year> <note> Second Edition. </note>
Reference-contexts: Methodology or formal framework for orchestrating a computation: Although script-driven probing and fault injection has been applied to several complex communication protocols and distributed applications, we need to develop a formal framework for orchestrating a computation. Past work on global snapshots or global predicate detection <ref> [24] </ref> is closely related to this problem. Furthermore, we need to identify a minimal set of primitives for injecting faults given a certain failure model.
References-found: 24

