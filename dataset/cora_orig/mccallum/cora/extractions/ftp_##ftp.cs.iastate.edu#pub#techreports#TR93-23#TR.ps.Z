URL: ftp://ftp.cs.iastate.edu/pub/techreports/TR93-23/TR.ps.Z
Refering-URL: http://www.cs.iastate.edu/~leavens/main.html
Root-URL: http://www.cs.iastate.edu
Title: Inheritance of Interface Specifications (Extended Abstract) Languages; F.3.1 [Logics and Meanings of Programs] Specifying and
Author: Gary T. Leavens c Gary T. Leavens, 
Keyword: specification, inheritance, subtype, subclass, modularity, object-oriented, abstract data type.  
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa Sate University  
Note: TR #93-23 September 1993  1992 CR Categories: D.2.1 [Software Engineering] Requirements/Specifications  1993. All rights reserved.  
Abstract-found: 0
Intro-found: 1
Reference: [Ame87] <author> Pierre America. </author> <title> Inheritance and Subtyping in a Parallel Object-Oriented Language. </title> <editor> In Jean Bezivin et al., editors, </editor> <booktitle> ECOOP '87, Eu-ropean Conference on Object-Oriented Programming, Paris, France, </booktitle> <pages> pages 234-242, </pages> <address> New York, N.Y., </address> <month> June </month> <year> 1987. </year> <title> Springer-Verlag. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 276. </volume>
Reference-contexts: of type T in such a way that for all instance operations of the supertype and for all x of the subtype S, SuperPreCond (f S;T (x)) ) SubPreCond (x) (1) SuperPostCond (f S;T (x)) ( SubPostCond (x) (2) where "SuperPreCond" is the precondition of the supertype's instance operation, etc. <ref> [Ame87] </ref> [Ame89] [Ame91] [LW93a] [LW93b]. 1.3 Plan In the following we discuss inheritance of specifications in ISLs. <p> Since the abstract values of the types are the same, there is no problem in interpreting the parent type's specification. 2. Define a homomorphic 1 coercion function that maps the abstract values of the inheriting type to the abstract values of the parent type <ref> [Ame87] </ref> [Ame89] [Ame91] [LW93a] [LW93b].
Reference: [Ame89] <author> Pierre America. </author> <title> A Behavioural Approach to Subtyping in Object-Oriented Programming Languages. </title> <type> Technical Report 443, </type> <institution> Philips 10 Research Laboratories, Nederlandse Philips Bedrijven B. V., </institution> <month> April </month> <year> 1989. </year> <note> Revised from the January 1989 version. </note>
Reference-contexts: type T in such a way that for all instance operations of the supertype and for all x of the subtype S, SuperPreCond (f S;T (x)) ) SubPreCond (x) (1) SuperPostCond (f S;T (x)) ( SubPostCond (x) (2) where "SuperPreCond" is the precondition of the supertype's instance operation, etc. [Ame87] <ref> [Ame89] </ref> [Ame91] [LW93a] [LW93b]. 1.3 Plan In the following we discuss inheritance of specifications in ISLs. <p> Since the abstract values of the types are the same, there is no problem in interpreting the parent type's specification. 2. Define a homomorphic 1 coercion function that maps the abstract values of the inheriting type to the abstract values of the parent type [Ame87] <ref> [Ame89] </ref> [Ame91] [LW93a] [LW93b].
Reference: [Ame91] <author> Pierre America. </author> <title> Designing an Object-Oriented Programming Language with Behavioural Subtyping. </title> <editor> In J. W. de Bakker, W. P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Foundations of Object-Oriented Languages, REX School/Workshop, Noordwijkerhout, The Netherlands, May/June 1990, volume 489 of Lecture Notes in Computer Science, </booktitle> <pages> pages 60-90. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: T in such a way that for all instance operations of the supertype and for all x of the subtype S, SuperPreCond (f S;T (x)) ) SubPreCond (x) (1) SuperPostCond (f S;T (x)) ( SubPostCond (x) (2) where "SuperPreCond" is the precondition of the supertype's instance operation, etc. [Ame87] [Ame89] <ref> [Ame91] </ref> [LW93a] [LW93b]. 1.3 Plan In the following we discuss inheritance of specifications in ISLs. <p> Since the abstract values of the types are the same, there is no problem in interpreting the parent type's specification. 2. Define a homomorphic 1 coercion function that maps the abstract values of the inheriting type to the abstract values of the parent type [Ame87] [Ame89] <ref> [Ame91] </ref> [LW93a] [LW93b].
Reference: [BMR93] <author> Alex Borgida, John Mylopoulos, and Raymond Reiter. </author> `... <title> And Nothing Else Changes': The Frame Problem in Procedure Specification. </title> <booktitle> In Proceedings Fifteenth International Conference on Software Engineering, </booktitle> <address> Baltimore, </address> <month> May </month> <year> 1993. </year> <note> Preliminary version obtained from the authors. </note>
Reference-contexts: no reason to limit such shorthands to the specification of subtypes. 9 The information loss problem may also be amenable to solutions similar to those proposed for the frame problem (see below). 4 The Frame Problem The frame problem is how to say "and nothing else changes" in a specification <ref> [BMR93] </ref>. In Larch/C ++ , a function specification has a modifies clause that says what objects the function is allowed to change. However, when a modifies clause of the form modifies self is inherited, it means that the abstract value as a whole may change. <p> This may be less restrictive than intended, as extra information that in the subtype's abstract values may or may not be intended to change. The approach advocated in <ref> [BMR93] </ref> looks promising as a way to solve this. 5 Summary Position For each inheriting type, the specifier should state a coercion function (or relation). This avoids all modularity problems.
Reference: [CDD + 89] <author> D. Carrington, D. Duke, R. Duke, P. King, G. Rose, and G. Smith. Object-Z: </author> <title> An object-oriented extension to Z. In Formal Description Techniques (FORTE '89), </title> <booktitle> Vancouver, </booktitle> <pages> pages 281-296. </pages> <publisher> North-Holland Publishing Co., </publisher> <month> December </month> <year> 1989. </year>
Reference-contexts: + rational (amt), 1/100) ^ checking (self') = checking (self^); - done without using inheritance. 2.2 Possible Semantics of Specification Inheritance A little reflection is enough to convince one that what should be done is to copy each inherited operation specification from the parent specification to the inheriting type's specification <ref> [CDD + 89] </ref> [DD90] [Cus91] [LC93b].
Reference: [Che91] <author> Yoonsik Cheon. Larch/Smalltalk: </author> <title> A Specification Language for Smalltalk. </title> <type> Technical Report 91-15, </type> <institution> Department of Computer Science, Iowa State University, Ames, IA, </institution> <month> June </month> <year> 1991. </year> <note> Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: Our ideas come from our work on the ISLs Larch/Smalltalk (for Smalltalk) <ref> [Che91] </ref> and Larch/C ++ (for C ++ ) [LC93b] [CL93] [LC93a], and our work on the semantics of subtyping in OOPLs [Lea89] [LW90] [Lea90] [LP91] [LW92]. 2 Inheritance of Specifications For an example, consider the types BankAccount and PlusAccount. The super-type, BankAccount, has just a savings account.
Reference: [CL93] <author> Yoonsik Cheon and Gary T. Leavens. </author> <title> A Quick Overview of Larch/C++. </title> <type> Technical Report 93-18, </type> <institution> Department of Computer Science, Iowa State University, </institution> <month> June </month> <year> 1993. </year> <note> To appear in the Journal of Object-Oriented Programming . Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: Our ideas come from our work on the ISLs Larch/Smalltalk (for Smalltalk) [Che91] and Larch/C ++ (for C ++ ) [LC93b] <ref> [CL93] </ref> [LC93a], and our work on the semantics of subtyping in OOPLs [Lea89] [LW90] [Lea90] [LP91] [LW92]. 2 Inheritance of Specifications For an example, consider the types BankAccount and PlusAccount. The super-type, BankAccount, has just a savings account. The subtype, PlusAccount, also has a ("free") checking account. <p> So the specifier of UndirectedGraph is forced to specify the abstract values without making this identification, which certainly complicates the specification of UndirectedGraph (see <ref> [CL93] </ref> for how this is done). Note, however, that this is not a modularity problem. 2.2.3 Using a Coercion Relation A homomorphic relation is a generalization of a homomorphic function.
Reference: [Cus91] <author> Elspeth Cusack. </author> <title> Object Oriented Modelling in Z For Open Distributed Systems. </title> <booktitle> In International Workshop on Open Distributed Processing, </booktitle> <month> October </month> <year> 1991. </year> <title> Obtained from the author. </title>
Reference-contexts: ^ checking (self') = checking (self^); - done without using inheritance. 2.2 Possible Semantics of Specification Inheritance A little reflection is enough to convince one that what should be done is to copy each inherited operation specification from the parent specification to the inheriting type's specification [CDD + 89] [DD90] <ref> [Cus91] </ref> [LC93b].
Reference: [DD90] <author> D. Duke and R. Duke. </author> <title> Towards a Semantics for Object-Z. </title> <editor> In D. Bjorner, C. A. R. Hoare, and H. Langmaack, editors, </editor> <title> VDM '90: VDM and Z | Formal Methods in Software Development, </title> <booktitle> Third International Symposium of VDM Europe, Kiel, FRG, volume 428 of Lecture Notes in Computer Science, </booktitle> <pages> pages 244-261. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1990. </year>
Reference-contexts: 1/100) ^ checking (self') = checking (self^); - done without using inheritance. 2.2 Possible Semantics of Specification Inheritance A little reflection is enough to convince one that what should be done is to copy each inherited operation specification from the parent specification to the inheriting type's specification [CDD + 89] <ref> [DD90] </ref> [Cus91] [LC93b].
Reference: [GHG + 93] <author> John V. Guttag, James J. Horning, S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1993. </year> <month> 11 </month>
Reference-contexts: 1 Introduction An interface specification language (ISL) defines both how to call a module and its (functional) behavior [Win83] [Win87] [Lam89] <ref> [GHG + 93] </ref>. The details of how to call a module and some aspects its behavior are specific to the particular programming language; hence in the Larch approach to interface specification [GHG + 93], each ISL is tailored to a particular programming language. <p> An interface specification language (ISL) defines both how to call a module and its (functional) behavior [Win83] [Win87] [Lam89] <ref> [GHG + 93] </ref>. The details of how to call a module and some aspects its behavior are specific to the particular programming language; hence in the Larch approach to interface specification [GHG + 93], each ISL is tailored to a particular programming language. What does this tailoring involve? * The syntax for specifying interfaces is a subset of the syntax for the programming language, so it can be directly compared to the interface of a candidate implementation. <p> The subtype, PlusAccount, also has a ("free") checking account. We want to specify instance operations such as balance and pay interest, for BankAccount and have these specifications be inherited by PlusAccount. The Larch/C ++ interface specification of BankAccount is given in Figure 1. The LSL <ref> [GHG + 93] </ref> trait BankAccountTrait it uses is presented in Figure 2. The trait Rational which is included by BankAccountTrait, is found in the Larch Shared Language Handbook [GHG + 93, Appendix A.16]. <p> The Larch/C ++ interface specification of BankAccount is given in Figure 1. The LSL [GHG + 93] trait BankAccountTrait it uses is presented in Figure 2. The trait Rational which is included by BankAccountTrait, is found in the Larch Shared Language Handbook <ref> [GHG + 93, Appendix A.16] </ref>. The member functions are specified as virtual, which means that the code executed in a call such as ba-&gt;pay interest () will execute code determined by the dynamic class of the object pointed to by ba.
Reference: [GM87] <author> Joseph A. Goguen and Jose Meseguer. </author> <title> Order-Sorted Algebra Solves the Constructor-Selector, Multiple Representation and Coercion Problems. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <address> Ithaca, NY, </address> <pages> pages 18-29. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: Use the same sort of abstract values (i.e., extending the same LSL trait) for the subtype as for the supertype <ref> [GM87] </ref> [MOM90]. Since the abstract values of the types are the same, there is no problem in interpreting the parent type's specification. 2.
Reference: [Lam89] <author> Leslie Lamport. </author> <title> A Simple Approach to Specifying Concurrent Systems. </title> <journal> Communications of the ACM, </journal> <volume> 32(1) </volume> <pages> 32-45, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: 1 Introduction An interface specification language (ISL) defines both how to call a module and its (functional) behavior [Win83] [Win87] <ref> [Lam89] </ref> [GHG + 93]. The details of how to call a module and some aspects its behavior are specific to the particular programming language; hence in the Larch approach to interface specification [GHG + 93], each ISL is tailored to a particular programming language.
Reference: [LC93a] <author> Gary T. Leavens and Yoonsik Cheon. </author> <note> Larch/C++ Reference Manual. Available by anonymous ftp from ftp.cs.iastate.edu., </note> <year> 1993. </year>
Reference-contexts: Our ideas come from our work on the ISLs Larch/Smalltalk (for Smalltalk) [Che91] and Larch/C ++ (for C ++ ) [LC93b] [CL93] <ref> [LC93a] </ref>, and our work on the semantics of subtyping in OOPLs [Lea89] [LW90] [Lea90] [LP91] [LW92]. 2 Inheritance of Specifications For an example, consider the types BankAccount and PlusAccount. The super-type, BankAccount, has just a savings account. The subtype, PlusAccount, also has a ("free") checking account.
Reference: [LC93b] <author> Gary T. Leavens and Yoonsik Cheon. </author> <title> Preliminary Design of Larch/C++. </title> <editor> In U. Martin and J. Wing, editors, </editor> <booktitle> Proceedings of the First International Workshop on Larch, </booktitle> <month> July, </month> <year> 1992, </year> <title> Workshops in Computing. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1993. </year>
Reference-contexts: Our ideas come from our work on the ISLs Larch/Smalltalk (for Smalltalk) [Che91] and Larch/C ++ (for C ++ ) <ref> [LC93b] </ref> [CL93] [LC93a], and our work on the semantics of subtyping in OOPLs [Lea89] [LW90] [Lea90] [LP91] [LW92]. 2 Inheritance of Specifications For an example, consider the types BankAccount and PlusAccount. The super-type, BankAccount, has just a savings account. The subtype, PlusAccount, also has a ("free") checking account. <p> checking (self') = checking (self^); - done without using inheritance. 2.2 Possible Semantics of Specification Inheritance A little reflection is enough to convince one that what should be done is to copy each inherited operation specification from the parent specification to the inheriting type's specification [CDD + 89] [DD90] [Cus91] <ref> [LC93b] </ref>.
Reference: [Lea89] <author> Gary Todd Leavens. </author> <title> Verifying Object-Oriented Programs that use Subtypes. </title> <type> Technical Report 439, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <month> February </month> <year> 1989. </year> <title> The author's Ph.D. </title> <type> thesis. </type>
Reference-contexts: This certainly implies that each object of type S acts like some object of type T [Sny86] [SCB + 86] <ref> [Lea89] </ref>. <p> Our ideas come from our work on the ISLs Larch/Smalltalk (for Smalltalk) [Che91] and Larch/C ++ (for C ++ ) [LC93b] [CL93] [LC93a], and our work on the semantics of subtyping in OOPLs <ref> [Lea89] </ref> [LW90] [Lea90] [LP91] [LW92]. 2 Inheritance of Specifications For an example, consider the types BankAccount and PlusAccount. The super-type, BankAccount, has just a savings account. The subtype, PlusAccount, also has a ("free") checking account. <p> Define a homomorphic relation that relates each inheriting type's abstract value to at least one parent type abstract value, which is used to coerce the abstract values of the inheriting type to the parent type <ref> [Lea89] </ref>. The parent type's specification is interpreted by using this relation to obtain a set of parent type abstract values, and these are all used to interpret the parent type's specification. 4. <p> However the disadvantage of homomorphic relations is that there is much to prove before one is convinced that assertion evaluation is well-defined, because of the possible ambiguity in dealing with sets of abstract values <ref> [Lea89] </ref> [Lea90]. 2.2.4 Overloading the Trait Functions This approach attacks the problem of how to interpret the parent type's specification directly.
Reference: [Lea90] <author> Gary T. Leavens. </author> <title> Modular Verification of Object-Oriented Programs with Subtypes. </title> <type> Technical Report 90-09, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, July </month> <year> 1990. </year> <note> Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: Our ideas come from our work on the ISLs Larch/Smalltalk (for Smalltalk) [Che91] and Larch/C ++ (for C ++ ) [LC93b] [CL93] [LC93a], and our work on the semantics of subtyping in OOPLs [Lea89] [LW90] <ref> [Lea90] </ref> [LP91] [LW92]. 2 Inheritance of Specifications For an example, consider the types BankAccount and PlusAccount. The super-type, BankAccount, has just a savings account. The subtype, PlusAccount, also has a ("free") checking account. <p> However the disadvantage of homomorphic relations is that there is much to prove before one is convinced that assertion evaluation is well-defined, because of the possible ambiguity in dealing with sets of abstract values [Lea89] <ref> [Lea90] </ref>. 2.2.4 Overloading the Trait Functions This approach attacks the problem of how to interpret the parent type's specification directly.
Reference: [Lea91] <author> Gary T. Leavens. </author> <title> Modular Specification and Verification of Object-Oriented Programs. </title> <journal> IEEE Software, </journal> <volume> 8(4) </volume> <pages> 72-80, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Overload each trait function that takes an argument of the parent type's abstract values so that it is defined on abstract values of the inheriting type [LW90] <ref> [Lea91] </ref> [LW92]. For the abstract values of an inheriting type, these overloaded trait functions are used to interpret the inherited specification.
Reference: [LP91] <author> Gary T. Leavens and Don Pigozzi. </author> <title> Typed Homomorphic Relations Extended with Subtypes. </title> <type> Technical Report 91-14, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, June </month> <year> 1991. </year> <booktitle> Appears in the proceedings of Mathematical Foundations of Programming Semantics '91, Springer-Verlag, Lecture Notes in Computer Science, </booktitle> <volume> volume 598, </volume> <pages> pages 144-167, </pages> <year> 1992. </year>
Reference-contexts: Our ideas come from our work on the ISLs Larch/Smalltalk (for Smalltalk) [Che91] and Larch/C ++ (for C ++ ) [LC93b] [CL93] [LC93a], and our work on the semantics of subtyping in OOPLs [Lea89] [LW90] [Lea90] <ref> [LP91] </ref> [LW92]. 2 Inheritance of Specifications For an example, consider the types BankAccount and PlusAccount. The super-type, BankAccount, has just a savings account. The subtype, PlusAccount, also has a ("free") checking account.
Reference: [LW90] <author> Gary T. Leavens and William E. Weihl. </author> <title> Reasoning about Object-oriented Programs that use Subtypes (extended abstract). </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 25(10) </volume> <pages> 212-223, </pages> <month> October </month> <year> 1990. </year> <booktitle> OOPSLA ECOOP '90 Proceedings, N. Meyrowitz (editor). </booktitle>
Reference-contexts: For example, an ISL for an OOPL should ease reasoning that uses supertype abstraction (thinking only about the types written in the program, not about the dynamically possible subtype that expressions may denote <ref> [LW90] </ref>). It follows that when one is designing an ISL for an OOPL, one must consider both subtyping and inheritance. 1.1 Modularity The last point in the list of ways to tailor an ISL is especially important in an object-oriented context. <p> Our ideas come from our work on the ISLs Larch/Smalltalk (for Smalltalk) [Che91] and Larch/C ++ (for C ++ ) [LC93b] [CL93] [LC93a], and our work on the semantics of subtyping in OOPLs [Lea89] <ref> [LW90] </ref> [Lea90] [LP91] [LW92]. 2 Inheritance of Specifications For an example, consider the types BankAccount and PlusAccount. The super-type, BankAccount, has just a savings account. The subtype, PlusAccount, also has a ("free") checking account. <p> Overload each trait function that takes an argument of the parent type's abstract values so that it is defined on abstract values of the inheriting type <ref> [LW90] </ref> [Lea91] [LW92]. For the abstract values of an inheriting type, these overloaded trait functions are used to interpret the inherited specification.
Reference: [LW92] <author> Gary T. Leavens and William E. Weihl. </author> <title> Subtyping, Modular Specification, and Modular Verification for Applicative Object-Oriented Programs. </title> <type> Technical Report 92-28, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, September </month> <year> 1992. </year> <note> Submitted for publication. Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. 12 </note>
Reference-contexts: Our ideas come from our work on the ISLs Larch/Smalltalk (for Smalltalk) [Che91] and Larch/C ++ (for C ++ ) [LC93b] [CL93] [LC93a], and our work on the semantics of subtyping in OOPLs [Lea89] [LW90] [Lea90] [LP91] <ref> [LW92] </ref>. 2 Inheritance of Specifications For an example, consider the types BankAccount and PlusAccount. The super-type, BankAccount, has just a savings account. The subtype, PlusAccount, also has a ("free") checking account. <p> Overload each trait function that takes an argument of the parent type's abstract values so that it is defined on abstract values of the inheriting type [LW90] [Lea91] <ref> [LW92] </ref>. For the abstract values of an inheriting type, these overloaded trait functions are used to interpret the inherited specification.
Reference: [LW93a] <author> Barbara Liskov and Jeannette M. Wing. </author> <title> A New Definition of the Subtype Relation. Programming Methodology Group Memo 76, </title> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <month> May </month> <year> 1993. </year> <note> To appear in the proceedings of ECOOP '93. </note>
Reference-contexts: in such a way that for all instance operations of the supertype and for all x of the subtype S, SuperPreCond (f S;T (x)) ) SubPreCond (x) (1) SuperPostCond (f S;T (x)) ( SubPostCond (x) (2) where "SuperPreCond" is the precondition of the supertype's instance operation, etc. [Ame87] [Ame89] [Ame91] <ref> [LW93a] </ref> [LW93b]. 1.3 Plan In the following we discuss inheritance of specifications in ISLs. <p> Since the abstract values of the types are the same, there is no problem in interpreting the parent type's specification. 2. Define a homomorphic 1 coercion function that maps the abstract values of the inheriting type to the abstract values of the parent type [Ame87] [Ame89] [Ame91] <ref> [LW93a] </ref> [LW93b].
Reference: [LW93b] <author> Barbara Liskov and Jeannette M. Wing. </author> <title> Specifications and Their Use in Defining Subtypes. </title> <booktitle> To appear in the proceedings of OOPSLA '93. Obtained from the Authors, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: such a way that for all instance operations of the supertype and for all x of the subtype S, SuperPreCond (f S;T (x)) ) SubPreCond (x) (1) SuperPostCond (f S;T (x)) ( SubPostCond (x) (2) where "SuperPreCond" is the precondition of the supertype's instance operation, etc. [Ame87] [Ame89] [Ame91] [LW93a] <ref> [LW93b] </ref>. 1.3 Plan In the following we discuss inheritance of specifications in ISLs. <p> Since the abstract values of the types are the same, there is no problem in interpreting the parent type's specification. 2. Define a homomorphic 1 coercion function that maps the abstract values of the inheriting type to the abstract values of the parent type [Ame87] [Ame89] [Ame91] [LW93a] <ref> [LW93b] </ref>.
Reference: [Mey92] <author> Bertrand Meyer. </author> <title> Eiffel: The Language. Object-Oriented Series. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: So overloading the trait functions is not a general solution. Meyer's OOPL Eiffel has a way to avoid information loss without resorting to complete respecification. In subtypes, the Eiffel specifier can (only) conjoin an additional assertion to the post-condition using the keyword then <ref> [Mey92] </ref>.
Reference: [MOM90] <author> Narciso Marti-Oliet and Jose Meseguer. </author> <title> Inclusions and Subtypes. </title> <type> Technical Report SRI-CSL-90-16, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> 333 Ravenswood Ave., Menlo Park, Calif., </address> <month> De-cember </month> <year> 1990. </year>
Reference-contexts: Use the same sort of abstract values (i.e., extending the same LSL trait) for the subtype as for the supertype [GM87] <ref> [MOM90] </ref>. Since the abstract values of the types are the same, there is no problem in interpreting the parent type's specification. 2. Define a homomorphic 1 coercion function that maps the abstract values of the inheriting type to the abstract values of the parent type [Ame87] [Ame89] [Ame91] [LW93a] [LW93b].
Reference: [SCB + 86] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Car-rie Wilpolt. </author> <title> An Introduction to Trellis/Owl. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 9-16, </pages> <month> November </month> <year> 1986. </year> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <editor> Norman Meyrowitz (editor), </editor> <month> September </month> <year> 1986, </year> <institution> Portland, Oregon. </institution>
Reference-contexts: More precisely, a type S is a subtype of T if one can use objects of type S in a program where objects of type T are expected without any surprising results. This certainly implies that each object of type S acts like some object of type T [Sny86] <ref> [SCB + 86] </ref> [Lea89].
Reference: [Sny86] <author> Alan Snyder. </author> <title> Encapsulation and Inheritance in Object-Oriented Programming Languages. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 38-45, </pages> <month> November </month> <year> 1986. </year> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <editor> Norman Meyrowitz (editor), </editor> <month> September </month> <year> 1986, </year> <institution> Portland, Oregon. </institution>
Reference-contexts: For example the class IntStack may be a subclass of IntDEQueue, although a IntStack object cannot respond to all the messages that one would want to send to a IntDEQueue <ref> [Sny86] </ref>. If one were to make an analogy between the notions of subtype and subclass, one would say that, by contrast, a subtype is formed from another ADT by inheritance of specifications, not code. <p> More precisely, a type S is a subtype of T if one can use objects of type S in a program where objects of type T are expected without any surprising results. This certainly implies that each object of type S acts like some object of type T <ref> [Sny86] </ref> [SCB + 86] [Lea89].
Reference: [Win83] <author> Jeannette Marie Wing. </author> <title> A Two-Tiered Approach to Specifying Programs. </title> <type> Technical Report TR-299, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <year> 1983. </year>
Reference-contexts: 1 Introduction An interface specification language (ISL) defines both how to call a module and its (functional) behavior <ref> [Win83] </ref> [Win87] [Lam89] [GHG + 93]. The details of how to call a module and some aspects its behavior are specific to the particular programming language; hence in the Larch approach to interface specification [GHG + 93], each ISL is tailored to a particular programming language.
Reference: [Win87] <author> Jeannette M. Wing. </author> <title> Writing Larch Interface Language Specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(1) </volume> <pages> 1-24, </pages> <month> January </month> <year> 1987. </year> <month> 13 </month>
Reference-contexts: 1 Introduction An interface specification language (ISL) defines both how to call a module and its (functional) behavior [Win83] <ref> [Win87] </ref> [Lam89] [GHG + 93]. The details of how to call a module and some aspects its behavior are specific to the particular programming language; hence in the Larch approach to interface specification [GHG + 93], each ISL is tailored to a particular programming language.
References-found: 28

