URL: http://wwwis.win.tue.nl/~wsinwa/lcipn.ps
Refering-URL: http://wwwis.win.tue.nl/~wsinwa/publications.html
Root-URL: http://www.win.tue.nl
Email: email: fwsinwa,tbasteng@win.tue.nl  
Title: Life-Cycle Inheritance A Petri-Net-Based Approach  
Author: W.M.P. van der Aalst and T. Basten 
Keyword: Object orientation, Petri nets, Inheritance, Workflow management, Object life cycle.  
Address: Netherlands  
Affiliation: Department of Mathematics and Computing Science Eindhoven University of Technology, The  
Abstract: Inheritance is one of the key issues of object-orientation. The inheritance mechanism allows for the definition of a subclass which inherits the features of a specific super-class. This means that methods and attributes defined for the superclass are also available for objects of the subclass. Existing methods for object-oriented modeling and design abstract from the dynamic behavior of objects when defining inheritance. Nevertheless, it would be useful to have a mechanism which allows for the inheritance of dynamic behavior. This paper describes a Petri-net-based approach to the formal specification and verification of this type of inheritance. We use Petri nets to specify the dynamics of an object class. The Petri-net formalism allows for a graphical representation of the life cycle of objects which belong to a specific object class. Four possible inheritance relations are defined. These inheritance relations can be verified automatically. Moreover, four powerful transformation rules which preserve specific inheritance relations are given. To illustrate the relevance of these results, the application to workflow management is demonstrated. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> W.M.P. van der Aalst. </author> <title> A Class of Petri Nets for Modeling and Analyzing Business Processes. </title> <institution> Computing Science Report 95/26, Eindhoven University of Technology, Department of Mathematics and Computing Science, Eindhoven, </institution> <address> The Netherlands, </address> <year> 1995. </year>
Reference-contexts: It is possible to terminate successfully from s 0 , i.e., .N ; s 0 / [fli .N ; 0/. If we restrict ourselves to free-choice Petri nets, then there is a polynomial-time algorithm to verify the requirements in Definition 3.1 <ref> [1] </ref>. Moreover, for most object life cycles it is easy to see whether these requirements hold. Petri nets satisfying the requirements stated in Definition 3.1 have a number of nice properties. One of them is bound-edness, i.e., the number of reachable states is finite. Property 3.2.
Reference: 2. <author> W.M.P. van der Aalst. </author> <title> Petri-Net-based Workflow Management Software. </title> <editor> In A. Sheth, editor, </editor> <booktitle> Proceedings of the NFS Workshop on Workflow and Process Automation in Information Systems, </booktitle> <pages> pages 114-118, </pages> <address> Athens, Georgia, USA, </address> <month> May </month> <year> 1996. </year>
Reference: 3. <author> J.C.M. Baeten and W.P. Weijland. </author> <title> Process Algebra, </title> <booktitle> volume 18 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> Cambridge, UK, </address> <year> 1990. </year>
Reference-contexts: In this paper, we tackle the problem of deciding whether the object life cycle of one class inherits the life cycle of another class. In [5], we investigate this problem using a simple ACP-like process algebra (Algebra of Communicating Processes, <ref> [3] </ref>). In that paper, encapsulation and abstraction turn out to be important concepts for the characterization of life-cycle inheritance. Based on these concepts, four inheritance relations are defined.
Reference: 4. <author> T. Basten. </author> <title> Branching Bisimilarity is an Equivalence indeed! Information Processing Letters, </title> <booktitle> 58(3) </booktitle> <pages> 141-147, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: Property 4.2. Branching bisimulation, b , is a congruence for encapsulation and abstraction. Proof. It is straightforward to verify that branching bisimulation, b , is an equivalence relation <ref> [4] </ref>.
Reference: 5. <author> T. Basten and W.M.P. van der Aalst. </author> <title> A Process-Algebraic Approach to Life-Cycle Inheri--tance: Inheritance = Encapsulation + Abstraction. </title> <institution> Computing Science Report 96/05, Eind-hoven University of Technology, Department of Mathematics and Computing Science, </institution> <address> Eind-hoven, The Netherlands, </address> <month> March </month> <year> 1996. </year>
Reference-contexts: In this paper, we tackle the problem of deciding whether the object life cycle of one class inherits the life cycle of another class. In <ref> [5] </ref>, we investigate this problem using a simple ACP-like process algebra (Algebra of Communicating Processes, [3]). In that paper, encapsulation and abstraction turn out to be important concepts for the characterization of life-cycle inheritance. Based on these concepts, four inheritance relations are defined. The process-algebraic character-ization of life-cycle inheritance in [5] <p> <ref> [5] </ref>, we investigate this problem using a simple ACP-like process algebra (Algebra of Communicating Processes, [3]). In that paper, encapsulation and abstraction turn out to be important concepts for the characterization of life-cycle inheritance. Based on these concepts, four inheritance relations are defined. The process-algebraic character-ization of life-cycle inheritance in [5] is rather straightforward because encapsulation and abstraction are well investigated in process algebra and because, in contrast to state-transition diagrams and Petri nets, states are not represented explicitly. It is quite easy to show that the inheritance relations have a number of desirable properties. <p> Inspired by the process-algebraic concepts of encapsulation and abstraction, two basic forms of inheritance seem to be appropriate <ref> [5] </ref>. The first one corresponds to encapsulation. Let .N 0 ; [i]/ and .N 1 ; [i]/ be two object life cycles. <p> It is also easy to see that .N 1 ; [i]/ in Figure 1 is a subclass of .N 0 ; [i]/ with respect to projection inheritance. If we hide the method birthday, then the observable behaviors are identical. Analogously to <ref> [5] </ref>, we define two other forms of inheritance by combining the two basic forms just presented. But first, we define the encapsulation operator @ H and the abstraction operator o I on Petri nets. <p> Life-cycle inheritance is the weakest form of inheritance. If an object life cycle is a subclass with respect to any of the four forms of inheritance, then it is also a subclass with respect to life-cycle inheritance. In <ref> [5] </ref>, it is shown that the inclusion relations in Figure 3 are strict and that there are no inclusion relations between protocol inheritance and projection inheritance. 4 b 0 4 a 4 N 3 5 N 2 i i i i b 0 b 1 b 1 Example 4.4. <p> Moreover, it is possible to choose H; H 0 ; I; and I 0 such that .H [ I / " .H 0 [ I 0 / D (see <ref> [5] </ref>). <p> Hence, lc is also transitive. 2 Analogously to the result in <ref> [5] </ref> we can also show that subclass equivalence coincides with branching-bisimulation equivalence, i.e., given two object life cycles and one of the four inheritance relations, if the first life cycle is a subclass of the second life cycle and vice versa, then the two life cycles are branching bisimilar. <p> It follows from this rule that .N 1 ; [i]/ in Figure 4 is a subclass of .N 0 ; [i]/. The transformation rule described by Theorem 5.1 is inspired by an axiom presented in <ref> [5] </ref>. To show the relation between the transformation rules in this paper and some of the algebraic rules in [5], we give an intermezzo for those familiar with process algebra. Intermezzo 5.2. In [5], we presented an algebraic theory for studying life-cycle inheritance. <p> The transformation rule described by Theorem 5.1 is inspired by an axiom presented in <ref> [5] </ref>. To show the relation between the transformation rules in this paper and some of the algebraic rules in [5], we give an intermezzo for those familiar with process algebra. Intermezzo 5.2. In [5], we presented an algebraic theory for studying life-cycle inheritance. In this context, an object life cycle is a closed term in the algebra. Analogous to Definition 4.3, we defined four forms of inheritance. <p> The transformation rule described by Theorem 5.1 is inspired by an axiom presented in <ref> [5] </ref>. To show the relation between the transformation rules in this paper and some of the algebraic rules in [5], we give an intermezzo for those familiar with process algebra. Intermezzo 5.2. In [5], we presented an algebraic theory for studying life-cycle inheritance. In this context, an object life cycle is a closed term in the algebra. Analogous to Definition 4.3, we defined four forms of inheritance. <p> In contrast to <ref> [5] </ref>, we did not provide rules for the preservation of life-cycle inheritance, because these rules are combinations of the rules for protocol and projection inheritance (See Example 5.5). The fact that the rules in [5] correspond to elegant transformation rules in a Petri-net context is encouraging. <p> In contrast to <ref> [5] </ref>, we did not provide rules for the preservation of life-cycle inheritance, because these rules are combinations of the rules for protocol and projection inheritance (See Example 5.5). The fact that the rules in [5] correspond to elegant transformation rules in a Petri-net context is encouraging. It appears that the inheritance concepts presented in this paper are quite universal and transcend the two formalisms. 6 An Application to Workflow Management Workflow management. To date, over 250 workflow management tools are commercially available. <p> The framework is based on Petri nets and, therefore, close to the professional experience of system developers engaged in object-oriented design. Four inheritance relations have been presented, inspired by the process-algebraic concepts of encapsulation and abstraction <ref> [5] </ref>. Encapsulation corresponds to blocking method calls, whereas abstraction conforms to hiding method calls. By identifying four forms of inheritance with different characteristics, designers can choose approriate inheritance relations at design time. It has been shown that in principle all four inheritance relations can be checked automatically.
Reference: 6. <author> G. Booch. </author> <title> Object-Oriented Analysis and Design: With Applications. </title> <address> Benjamin/Cummings, Redwood City, CA, USA, </address> <year> 1994. </year>
Reference-contexts: 1 Introduction Although object-oriented design is a relatively young practice, it is considered to be the most promising approach to software development. Within a few years the two leading object-oriented methodologies, OMT [16] and OOD <ref> [6] </ref>, have conquered the world of software engineering. Both methodologies use state-transition diagrams for specifying the dynamic behavior of objects. Typically, for each object class, one state-transition diagram is specified. <p> Inheritance is one of the key issues in object-orientation. Unfortunately, inheritance is often limited to sharing attributes and methods among object classes. Until now, a good concept for life-cycle inheritance was lacking. Existing object-oriented methodologies such as OMT [16] and OOD <ref> [6] </ref> do not give a clear definition of inheritance with respect to the dynamics of an object class. In this paper, we tackle the problem of deciding whether the object life cycle of one class inherits the life cycle of another class.
Reference: 7. <author> J. Desel and J. Esparza. </author> <title> Free Choice Petri Nets, </title> <booktitle> volume 40 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <address> Cambridge, UK, </address> <year> 1995. </year>
Reference-contexts: P q n f p fl g/ D v jJ. P q n f p fl g/ ^ v jJf p fl g is a home-marking of .N 0 r ; u jJP r /g. Using the theory of free-choice nets (Home-marking theorem, liveness and boundedness results, see <ref> [7] </ref>), in combination with the life-cycle properties of Definition 3.1, it is possible to show that R satisfies the three requirements stated in Definition 2.6. 2 Example 5.5. Figure 8 illustrates the three transformation rules presented thus far. <p> P q n f p fl g/ ^ v jJf p fl g is a home-marking of .N r ; u jJ P r /g. As in Theorem 5.4, the theory of free-choice nets (Home-marking theorem, liveness and bound-edness results, see <ref> [7] </ref>), in combination with the life-cycle properties of Definition 3.1, can be used to show that R satisfies the three requirements stated in Definition 2.6. 2 The four transformation rules presented in this section give a good characterization of the various forms of inheritance.
Reference: 8. <author> C.A. Ellis and G.J. Nutt. </author> <title> Modelling and Enactment of Workflow Systems. </title> <editor> In M. Ajmone Marsan, editor, </editor> <booktitle> Application and Theory of Petri Nets 1993, 14th. International Conference, Proceedings, volume 691 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-16, </pages> <address> Chicago, USA, June 1993. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1993. </year>
Reference: 9. <author> R.J. van Glabbeek. </author> <title> What is Branching Time Semantics and Why to Use It? In Bulletin of the EATCS, </title> <booktitle> number 53, </booktitle> <pages> pages 191-198. </pages> <institution> European Association for Theoretical Computer Science, </institution> <month> June </month> <year> 1994. </year>
Reference: 10. <author> R.J. van Glabbeek and W.P. Weijland. </author> <title> Branching Time and Abstraction in Bisimulation Semantics. </title> <journal> Journal of the ACM, </journal> <volume> 43(3) </volume> <pages> 555-600, </pages> <year> 1996. </year>
Reference: 11. <author> K.M. van Hee. </author> <title> Information Systems Engineering: A Formal Approach. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, UK, </address> <year> 1994. </year>
Reference: 12. <author> K. Jensen. </author> <title> Coloured Petri Nets. Basic Concepts, Analysis Methods and Practical Use, volume 1, Basic Concepts. </title> <booktitle> EATCS monographs on Theoretical Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1992. </year>
Reference: 13. <author> T.M. Koulopoulos. </author> <title> The Workflow Imperative. </title> <publisher> Van Nostrand Reinhold, </publisher> <address> New York, USA, </address> <year> 1995. </year>
Reference: 14. <author> C.A. Lakos. </author> <title> Pragmatic Inheritance Issues for Object Petri Nets. </title> <booktitle> In TOOLS Pacific 1995, Proceedings, </booktitle> <pages> pages 309-321, </pages> <address> Melbourne, Australia, 1995. </address> <publisher> Prentice-Hall. </publisher>
Reference-contexts: A very strict interpretation is the substitutability principle of Wegner and Zdonik [17] which says that an object of some subclass can always be used in a context where an object of its superclass is expected. As we will see, protocol inheritance adheres to this principle. However, in <ref> [14] </ref>, Lakos informally discusses inheritance of dynamic behavior in a practical context. He investigates four case studies and concludes that substitutability is in practice often too strong a requirement.
Reference: 15. <author> W. Reisig. </author> <title> Petri Nets: An Introduction, </title> <booktitle> volume 4 of EATCS monographs on Theoretical Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1985. </year>
Reference-contexts: Typically, for each object class, one state-transition diagram is specified. Such a state-transition diagram shows the state space of a class and the methods that cause a transition from one state to another. In this paper, we use Petri nets (See for example <ref> [15] </ref>) for specifying the dynamics of an object class. There are several reasons for using Petri nets. First of all, Petri nets provide a graphical description technique which is easy to understand and close to state-transition diagrams.
Reference: 16. <author> J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, and W. Lorensen. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, USA, </address> <year> 1991. </year>
Reference-contexts: 1 Introduction Although object-oriented design is a relatively young practice, it is considered to be the most promising approach to software development. Within a few years the two leading object-oriented methodologies, OMT <ref> [16] </ref> and OOD [6], have conquered the world of software engineering. Both methodologies use state-transition diagrams for specifying the dynamic behavior of objects. Typically, for each object class, one state-transition diagram is specified. <p> Inheritance is one of the key issues in object-orientation. Unfortunately, inheritance is often limited to sharing attributes and methods among object classes. Until now, a good concept for life-cycle inheritance was lacking. Existing object-oriented methodologies such as OMT <ref> [16] </ref> and OOD [6] do not give a clear definition of inheritance with respect to the dynamics of an object class. In this paper, we tackle the problem of deciding whether the object life cycle of one class inherits the life cycle of another class.
Reference: 17. <author> P. Wegner and S.B. Zdonik. </author> <title> Inheritance as an Incremental Modification Mechanism or What like is and isn't like. </title> <editor> In S. Gjessing and K. Nygaard, editors, </editor> <booktitle> ECOOP '88, European Conference on Object-Oriented Programming, Proceedings, volume 322 of Lecture Notes in Computer Science, </booktitle> <pages> pages 55-77, </pages> <address> Oslo, Norway, August 1988. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1988. </year>
Reference-contexts: Depending on how strict we interpret this requirement, we get different inheritance relations. A very strict interpretation is the substitutability principle of Wegner and Zdonik <ref> [17] </ref> which says that an object of some subclass can always be used in a context where an object of its superclass is expected. As we will see, protocol inheritance adheres to this principle. However, in [14], Lakos informally discusses inheritance of dynamic behavior in a practical context.
References-found: 17

