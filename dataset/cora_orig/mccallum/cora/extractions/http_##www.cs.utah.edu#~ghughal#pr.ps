URL: http://www.cs.utah.edu/~ghughal/pr.ps
Refering-URL: http://www.cs.utah.edu/~ghughal/
Root-URL: 
Title: Test Model-checking Approach to Verification of Formal Memory Models  
Author: Prof. Ganesh Gopalakrishnan 
Keyword: Formal memory models, shared memory multiprocessors, formal testing, model-checking, weaker memory consistency models.  
Address: Salt Lake City, UT 84112-9205  
Affiliation: Department of Computer Science, University of Utah,  
Note: Under the guidance of  
Email: Contact email: ghughal@cs.utah.edu  
Degree: Masters Thesis Proposal Rajnish Ghughal  
Date: June 1, 1998  
Abstract: We consider the problem of verifying shared memory multiprocessor memory systems for formal memory models. We have proposed a solution to this problem in the form of a new technique `Test model-checking' which can be used to verify memory systems for sequential consistency memory model. Sequential consistency is the strongest memory model proposed for multiprocessors, which prohibits the use of various architectural optimizations usually employed in memory systems. Hence, many modern-day multiprocessors adapt various weaker memory models to achieve higher performance. My proposed thesis is to consider the problem of verifying memory systems for various weaker memory models and to extend test model-checking for these weaker models.
Abstract-found: 1
Intro-found: 1
Reference: [ABJ + 93] <author> M. Ahamad, R. A. Bazzi, R. John, P. Kohli, and G. Neiger. </author> <title> The power of processor consistency (extended abstract). </title> <booktitle> In Proc. of the 5th ACM Annual Symp. on Parallel Algorithms and Architectures (SPAA'93), </booktitle> <pages> pages 251-260, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: memory model Processor consistency in an attempt to combine ease of programmability with high performance implementations. [AH90] presented the Weak Ordering memory model with an implementation for cache-based systems. [ANK + 95] proposed Causal Memory model which is intermediate between sequential consistency and other earlier proposed weaker memory modelPRAM [LS88]. <ref> [ABJ + 93] </ref> have also proposed a weaker memory model called Processor Consistency, however their definition differs from processor consistency definition of [GW88]. Various weaker memory models have been proposed which relax sequential consistency a great deal providing selective ordering among memory operations as necessary.
Reference: [ABM93] <author> Yehuda Afek, Geoffrey Brown, and Michael Merritt. </author> <title> Lazy caching. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 182-205, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: The lazy caching protocol <ref> [ABM93, Ger95] </ref>, (Figure 4 in [Ger95] describes the transition system of the protocol), also implements sequential consistency, and is geared towards a bus based architecture. Each processor P i on bus maintains in cache C i a part of the memory M em.
Reference: [AG96] <author> S. V. Adve and K. Gharachorloo. </author> <title> Shared memory consistency models: A tutorial. </title> <journal> IEEE Computer, </journal> <volume> 29(12) </volume> <pages> 66-76, </pages> <month> December </month> <year> 1996. </year>
Reference-contexts: Sequential consistency is the strongest memory model proposed for multiprocessor memory systems. It has been long realized that it restricts the use of many commonly used optimizations in the design of memory systems 1 [Goo89]. Hence, various weaker memory models <ref> [AG96] </ref> have been proposed as an alternative to sequential consistency to achieve better performance. 1 For example, read or write operations on different addresses cannot be reordered. 1 With the growing gap between processor and memory system performances memory system architects are employing more and more aggressive optimization techniques. <p> The SPARC V8 architecture [WG94] proposed Total Store Ordering (TSO) and Partial Store Ordering (PSO) weaker memory models which can be selectively implemented. Alpha architecture [Sit92] proposed a Alpha Consistency model which uses explicit fence instructions for ordering in between two instructions in a program. <ref> [Mos93, AG96] </ref> present a survey of various weaker memory models and related issues. Among the various weaker memory models described above, cache consistency is the weakest.
Reference: [AH90] <author> S. V. Adve and M. D. Hill. </author> <title> Weak ordering|a new definition. </title> <booktitle> In Proc. of the 17th Annual Int'l Symp. on Computer Architecture (ISCA'90), </booktitle> <pages> pages 2-14, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Cache Consistency [Goo89] was one of the early weaker memory models proposed which relaxes many of sequential consistency requirements significantly. [Goo89] also presented an intermediate weaker memory model Processor consistency in an attempt to combine ease of programmability with high performance implementations. <ref> [AH90] </ref> presented the Weak Ordering memory model with an implementation for cache-based systems. [ANK + 95] proposed Causal Memory model which is intermediate between sequential consistency and other earlier proposed weaker memory modelPRAM [LS88]. [ABJ + 93] have also proposed a weaker memory model called Processor Consistency, however their definition differs
Reference: [AMP96] <author> Rajeev Alur, Ken McMillan, and Doron Peled. </author> <title> Model-checking of correctness conditions for concurrent objects. </title> <booktitle> In 11th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 219-228, </pages> <month> July </month> <year> 1996. </year>
Reference-contexts: One of our contributions is that we answer these questions by elaborating on the theoretical as well as practical aspects of test model-checking. Alur et al <ref> [AMP96] </ref> showed that the problem of finding if there is a sequentially consistent string in a regular expression r is undecidable.
Reference: [ANK + 95] <author> M. Ahamad, G. Neiger, P. Kohli, J. E. Burns, and P. W. Hutto. </author> <title> Casual memory: Definitions, implementation and programming. </title> <journal> Distributed Computing, </journal> <volume> 9 </volume> <pages> 37-49, </pages> <year> 1995. </year>
Reference-contexts: of the early weaker memory models proposed which relaxes many of sequential consistency requirements significantly. [Goo89] also presented an intermediate weaker memory model Processor consistency in an attempt to combine ease of programmability with high performance implementations. [AH90] presented the Weak Ordering memory model with an implementation for cache-based systems. <ref> [ANK + 95] </ref> proposed Causal Memory model which is intermediate between sequential consistency and other earlier proposed weaker memory modelPRAM [LS88]. [ABJ + 93] have also proposed a weaker memory model called Processor Consistency, however their definition differs from processor consistency definition of [GW88].
Reference: [BCS96] <author> William R. Bryg, Kenneth K. Chan, and Nicholas S.Fiduccia. </author> <title> A high-performance, low-cost multiprocessor bus for workstations and midrange servers. </title> <journal> Hewlett-Packard Journal, </journal> <pages> pages 18-24, </pages> <month> February </month> <year> 1996. </year>
Reference-contexts: Utah Runway Model (URM) Our third example, called URM, is modeled after a Hewlett-Packard commercial bus Runway connection used to interconnect HP PA 8000 processors and memory controller together to form a multiprocessor system. The behavior of this memory system is described in some detail in <ref> [BCS96, Cam97, Kan96] </ref>.
Reference: [BZS93] <author> B. N. Bershad, M. J. Zekauskas, and W. A. Sawdon. </author> <title> The midway distributed shared memory system. </title> <booktitle> In Proc. of the 38th IEEE Int'l Computer Conf. (COMPCON Spring'93), </booktitle> <pages> pages 528-537, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: For example, a typical critical section code which executes correctly under sequential consistency may not execute as expected under a weaker memory model. Most weaker memory models, e.g. <ref> [BZS93] </ref>, provide ways to program the proposed weaker memory model. [GAG + 92] describes how various weaker memory models such as TSO, PSO, etc. could be programmed. [Fri94] shows how can Lamport's Bakery algorithm and Peterson's algorithm for critical section can be programmed under Alpha memory model.
Reference: [Cam97] <author> Albert Camilleri. </author> <title> A hybrid approach to verifying liveness in a symmetric multi processor. In Theorem Proving in Higher Order Logics, </title> <booktitle> 10th International Conference, </booktitle> <address> TPHOLs'97, Murray Hill, NJ, </address> <pages> pages 49-67, </pages> <month> August </month> <year> 1997. </year> <note> Springer-Verlag LNCS 1275. </note>
Reference-contexts: Utah Runway Model (URM) Our third example, called URM, is modeled after a Hewlett-Packard commercial bus Runway connection used to interconnect HP PA 8000 processors and memory controller together to form a multiprocessor system. The behavior of this memory system is described in some detail in <ref> [BCS96, Cam97, Kan96] </ref>.
Reference: [CC77] <author> P. Cousot and R. Cousot. </author> <title> Abstract intepretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Proceedings of 4th POPL, </booktitle> <pages> pages 238-252, </pages> <address> Los Angeles, CA, </address> <publisher> ACM Press, </publisher> <year> 1977. </year> <month> 16 </month>
Reference-contexts: In Section 4, I describe the problem I propose to study, consider related issues and present my plans to approach the problem. In Section 4.2, a time-line for the proposed work is given. Related Works In [Gra94], abstract interpretation <ref> [CC77] </ref> is employed to reduce infinite-system verification to finite 8CTL fl model-checking. They apply this technique to verify the sequential consistency of lazy caching with unbounded queues.
Reference: [Col] <author> W. W. Collier. </author> <title> Multiprocessor diagnostics. </title> <address> http://www.infomall.org/diagnostics/archtest.html. </address>
Reference-contexts: In the first phase of this work, we have developed an approach, called test model-checking for verifying memory systems for sequential consistency . Test model-checking combines the strengths of two already known powerful techniques: testing and model-checking. It formally adapts an architectural testing method called Archtest <ref> [Col] </ref> to the context of model-checking. Archtest is a suite of testing programs which can be run on multi-processors to detect their violation of memory ordering rules. Archtest has been successfully applied to many commercial multiprocessors [Col]. <p> It formally adapts an architectural testing method called Archtest <ref> [Col] </ref> to the context of model-checking. Archtest is a suite of testing programs which can be run on multi-processors to detect their violation of memory ordering rules. Archtest has been successfully applied to many commercial multiprocessors [Col]. We have successfully applied test model-checking technique to three memory systems one of them of considerable complexity to check for sequential consistency [GNMG98, NGMG98a].
Reference: [Col92] <author> W. W. Collier. </author> <title> Reasoning About Parallel Architectures. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1992. </year>
Reference-contexts: fashion? We still have not found a satisfactory answer to the first question because the test in [McM93] uses only one location which then couldn't make it a test for sequential consistency; it could plausibly be a test for coherence|which again does not correspond to what Collier formally proves in <ref> [Col92] </ref>. One of our contributions is that we answer these questions by elaborating on the theoretical as well as practical aspects of test model-checking. Alur et al [AMP96] showed that the problem of finding if there is a sequentially consistent string in a regular expression r is undecidable. <p> = 0 P rocessP 1 P rocessP 2 L 1 : A := 1; X [1] := A; L 3 : A := 3; X [3] := A; L k : A := k X [k] := A; 2 Overview of Archtest Archtest is based on the theory presented in <ref> [Col92] </ref> that formally defines and characterizes architectural rules obeyed by memory subsystems of multiprocessors. Although these rules are elemental, in realistic memory systems the rules manifest in compound form. <p> These three memory systems are briefly described below, refer [NGMG98b] for more details. VIS details of all our experiments can be obtained from the Web [Mok] or by contacting the authors. How to check for Sequential Consistency? As suggested in <ref> [Col92] </ref>, one's intuition about sequential consistency matches the behaviour described by A (CM P; P O; W A). As [Col92] does not list a single compound test to check for A (CM P; P O; W A), we can use the following two tests that are available: T est WA which <p> VIS details of all our experiments can be obtained from the Web [Mok] or by contacting the authors. How to check for Sequential Consistency? As suggested in <ref> [Col92] </ref>, one's intuition about sequential consistency matches the behaviour described by A (CM P; P O; W A). As [Col92] does not list a single compound test to check for A (CM P; P O; W A), we can use the following two tests that are available: T est WA which tests for A (CM P; RO; W O; W A) and T est PO which tests for A (CM <p> This combination is exactly equivalent to testing for sequential consistency because P O implies RO and W O (as formally defined in <ref> [Col92] </ref>). While sequential consistency matches the behavior described by A (CM P; P O; W A), successful test model-checking outcomes are only necessary but not sufficient conditions to ensure sequential consistency. <p> Similarly, violation by T est WA test automata for memory systems supposed to obey a typical weaker memory model cannot detect whether a weaker memory model is violated or not. Also the rules presented in Archtest <ref> [Col92] </ref> are not adequate for capturing all weaker memory models. Many weaker memory models in prevalent architectures differ from each other in subtle ways which can often not be captured using Archtest rules.
Reference: [DPN93] <author> David L. Dill, Seungjoon Park, and Andreas Nowatzyk. </author> <title> Formal specification of abstract memory models. </title> <editor> In Gaetano Borriello and Carl Ebeling, editors, </editor> <booktitle> Research on Integrated Systems, </booktitle> <pages> pages 38-52. </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: This is detailed in Section 3.1. In [PD96], the authors use a method called aggregation on a distributed shared memory coherence protocol used in an experimental multiprocessor, to arrive at a simplified model of system behavior. Their technique involves manual theorem proving. The work in [HMTLB95] as well as <ref> [DPN93] </ref> are aimed at verifying that synchronization routines work correctly under various memory models, where the memory models themselves are described using finite-state operational models. They do not address the problem of establishing the memory models provided by detailed memory subsystem designs, which is our contribution.
Reference: [FL98] <author> M. Frigo and V. Luncangco. </author> <title> Computation-centric memory models. </title> <booktitle> In Proc. of the 10th ACM Annual Symp. on Parallel Algorithms and Architectures (SPAA'98), </booktitle> <month> June </month> <year> 1998. </year>
Reference-contexts: There have been many approaches presenting a formal framework to define and compare various weaker memory models <ref> [HKV97, HST98, Gha95, RS95, KNA93, FL98, Fri94] </ref>. Approaches such as [Gha95] adopt a hardware-centric view: they define memory models in terms of how memory accesses can be executed by the system. Approaches such as [HKV97, KNA93, RS95] define memory models in terms of partial orders on memory access events. <p> Approaches such as [HKV97, KNA93, RS95] define memory models in terms of partial orders on memory access events. In contrast to hardware-centric view, approaches such as <ref> [FL98, HST98] </ref> adopt a programmer-centric view 4 and define memory models in terms of the interface provided to the programmer by specifying possible results of an execution.
Reference: [Fri94] <author> R. Friedman. </author> <title> Consistency Conditions for Distributed Shared Memories. </title> <type> PhD thesis, </type> <institution> Computer Science Department, Technion-Israel Institute of Technology, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: There have been many approaches presenting a formal framework to define and compare various weaker memory models <ref> [HKV97, HST98, Gha95, RS95, KNA93, FL98, Fri94] </ref>. Approaches such as [Gha95] adopt a hardware-centric view: they define memory models in terms of how memory accesses can be executed by the system. Approaches such as [HKV97, KNA93, RS95] define memory models in terms of partial orders on memory access events. <p> Most weaker memory models, e.g. [BZS93], provide ways to program the proposed weaker memory model. [GAG + 92] describes how various weaker memory models such as TSO, PSO, etc. could be programmed. <ref> [Fri94] </ref> shows how can Lamport's Bakery algorithm and Peterson's algorithm for critical section can be programmed under Alpha memory model. Friendman describes several techniques for turning programs written for sequential consistency into programs that work for the weaker memory model proposed.
Reference: [Fri98] <author> M. Frigo. </author> <title> The weakest reasonable memory. </title> <type> Master's thesis, </type> <institution> Department of Electrical Engineering and Computer Science, MIT, </institution> <year> 1998. </year>
Reference-contexts: Among the various weaker memory models described above, cache consistency is the weakest. It has been shown that cache consistency is the weakest reasonable memory model <ref> [Fri98] </ref> (under an intuitive notion of reasonable-ness) 2 . [GS93] proposed a memory model weaker than cache consistency, named Location Consistency 3 . However, it was shown that [GS93]-location consistency does not meet the reasonable-ness criteria of [Fri98] and hence in practice we should adopt cache consistency as the memory model <p> It has been shown that cache consistency is the weakest reasonable memory model <ref> [Fri98] </ref> (under an intuitive notion of reasonable-ness) 2 . [GS93] proposed a memory model weaker than cache consistency, named Location Consistency 3 . However, it was shown that [GS93]-location consistency does not meet the reasonable-ness criteria of [Fri98] and hence in practice we should adopt cache consistency as the memory model for a realistic implementation of [GS93]-location consistency [Fri98]. There have been many approaches presenting a formal framework to define and compare various weaker memory models [HKV97, HST98, Gha95, RS95, KNA93, FL98, Fri94]. <p> However, it was shown that [GS93]-location consistency does not meet the reasonable-ness criteria of <ref> [Fri98] </ref> and hence in practice we should adopt cache consistency as the memory model for a realistic implementation of [GS93]-location consistency [Fri98]. There have been many approaches presenting a formal framework to define and compare various weaker memory models [HKV97, HST98, Gha95, RS95, KNA93, FL98, Fri94]. Approaches such as [Gha95] adopt a hardware-centric view: they define memory models in terms of how memory accesses can be executed by the system. <p> Considering the emerging trend of weaker memory models and increasing complexity of memory system designs which implement these memory models, verification of memory systems for weaker memory models is becoming critical and deserves a detailed study. 2 It is referred as Location Consistency in <ref> [Fri98] </ref>. 3 Of course, [GS93]-location consistency is different from [Fri98]-location consistency.
Reference: [GAG + 92] <author> K. Gharachorloo, S. V. Adve, A. Gupta, J. L. Hennessy, and M. D. Hill. </author> <title> Program ming for different memory consistency models. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 15(4) </volume> <pages> 399-407, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: For example, a typical critical section code which executes correctly under sequential consistency may not execute as expected under a weaker memory model. Most weaker memory models, e.g. [BZS93], provide ways to program the proposed weaker memory model. <ref> [GAG + 92] </ref> describes how various weaker memory models such as TSO, PSO, etc. could be programmed. [Fri94] shows how can Lamport's Bakery algorithm and Peterson's algorithm for critical section can be programmed under Alpha memory model.
Reference: [Ger95] <author> Rob Gerth. </author> <title> Introduction to sequential consistency and the lazy caching algorithm. </title> <booktitle> Distributed Computing, </booktitle> <year> 1995. </year> <note> Also can be found in http://www.research.digital.com/SRC/tla/papers.html#Lazy. </note>
Reference-contexts: The lazy caching protocol <ref> [ABM93, Ger95] </ref>, (Figure 4 in [Ger95] describes the transition system of the protocol), also implements sequential consistency, and is geared towards a bus based architecture. Each processor P i on bus maintains in cache C i a part of the memory M em. <p> The lazy caching protocol [ABM93, Ger95], (Figure 4 in <ref> [Ger95] </ref> describes the transition system of the protocol), also implements sequential consistency, and is geared towards a bus based architecture. Each processor P i on bus maintains in cache C i a part of the memory M em.
Reference: [GGH93] <author> K. Gharachorloo, A. Gupta, and J. L. Hennessy. </author> <title> Revision to "memory consistency and event ordering in scalable shared-memory multiprocessors". </title> <type> Technical Report CSL-TR-93-568, </type> <institution> Computer Systems Laboratory, Stanford University, </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: Various weaker memory models have been proposed which relax sequential consistency a great deal providing selective ordering among memory operations as necessary. Release consistency <ref> [GLL + 90, GGH93] </ref>, Lazy Release Consistency [KCZ92], Scope Consistency [ISL96] are some examples. 4 Many weaker memory models have been proposed by commercial architectures also. The SPARC V8 architecture [WG94] proposed Total Store Ordering (TSO) and Partial Store Ordering (PSO) weaker memory models which can be selectively implemented.
Reference: [Gha95] <author> K. Gharachorloo. </author> <title> Memory Consistency Models for Shared-Memory Multiprocessors. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1995. </year>
Reference-contexts: There have been many approaches presenting a formal framework to define and compare various weaker memory models <ref> [HKV97, HST98, Gha95, RS95, KNA93, FL98, Fri94] </ref>. Approaches such as [Gha95] adopt a hardware-centric view: they define memory models in terms of how memory accesses can be executed by the system. Approaches such as [HKV97, KNA93, RS95] define memory models in terms of partial orders on memory access events. <p> There have been many approaches presenting a formal framework to define and compare various weaker memory models [HKV97, HST98, Gha95, RS95, KNA93, FL98, Fri94]. Approaches such as <ref> [Gha95] </ref> adopt a hardware-centric view: they define memory models in terms of how memory accesses can be executed by the system. Approaches such as [HKV97, KNA93, RS95] define memory models in terms of partial orders on memory access events.
Reference: [GK94] <author> Phillip B. Gibbons and Ephraim Korach. </author> <title> On testing cache-coherent shared memories. </title> <booktitle> In Proceedings of the 6th Annual Symposium on Parallel Algorithms and Architectures, </booktitle> <pages> pages 177-188, </pages> <address> New York, NY, USA, June 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: They do not address the problem of establishing the memory models provided by detailed memory subsystem designs, which is our contribution. In <ref> [GK97, GK94] </ref>, the authors analyze the problem of deciding whether a given set of traces are sequentially consistent. Our approach differs in two respects.
Reference: [GK97] <author> Phillip B. Gibbons and Ephraim Korach. </author> <title> Testing shared memories. </title> <journal> SIAM Journal on Computing, </journal> <volume> 26(4) </volume> <pages> 1208-1244, </pages> <month> August </month> <year> 1997. </year>
Reference-contexts: They do not address the problem of establishing the memory models provided by detailed memory subsystem designs, which is our contribution. In <ref> [GK97, GK94] </ref>, the authors analyze the problem of deciding whether a given set of traces are sequentially consistent. Our approach differs in two respects.
Reference: [GLL + 90] <author> K. Gharachorloo, D. E. Lenoski, J. Laudon, P. Gibbons, A. Gupta, and J. L. Hennessy. </author> <title> Memory consistency and event ordering in scalable shared-memory multiprocessors. </title> <booktitle> In Proc. of the 17th Annual Int'l Symp. on Computer Architecture (ISCA'90), </booktitle> <pages> pages 15-26, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Various weaker memory models have been proposed which relax sequential consistency a great deal providing selective ordering among memory operations as necessary. Release consistency <ref> [GLL + 90, GGH93] </ref>, Lazy Release Consistency [KCZ92], Scope Consistency [ISL96] are some examples. 4 Many weaker memory models have been proposed by commercial architectures also. The SPARC V8 architecture [WG94] proposed Total Store Ordering (TSO) and Partial Store Ordering (PSO) weaker memory models which can be selectively implemented.
Reference: [GNMG98] <author> R. Ghughal, R. Nalumasu, A. Mokkedem, and G. Gopalakrishnan. </author> <title> Using "test model checking" to verify the Runway-PA8000 memory model. </title> <booktitle> In Tenth Annual ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <address> Puerto Vallarta, Mexico, </address> <month> June </month> <year> 1998. </year>
Reference-contexts: Archtest has been successfully applied to many commercial multiprocessors [Col]. We have successfully applied test model-checking technique to three memory systems one of them of considerable complexity to check for sequential consistency <ref> [GNMG98, NGMG98a] </ref>. Our experiments so far indicates that this technique could be a helpful tool to real system designers for debugging their memory system models during early stages of design cycle. However, the technique developed so far cannot be applied to check memory systems for weaker memory models. <p> This work has also been published in <ref> [GNMG98] </ref> and [NGMG98a]. Test model-checking converts the tests of Archtest to corresponding memory rule test automata ("test automata") that drive the model of the memory system being examined.
Reference: [Goo89] <author> J. R. Goodman. </author> <title> Cache consistency and sequential consistency. </title> <type> Technical Report 61, </type> <institution> IEEE Scalable Coherence Interface Working Group, </institution> <month> March </month> <year> 1989. </year>
Reference-contexts: Sequential consistency is the strongest memory model proposed for multiprocessor memory systems. It has been long realized that it restricts the use of many commonly used optimizations in the design of memory systems 1 <ref> [Goo89] </ref>. <p> Though most works presenting new weaker memory models suggest various hardware optimizations that could be implemented to improve the performance without violating the memory model, they do not address the problem of verifying a detailed HDL-level implementation for the intended memory model. Cache Consistency <ref> [Goo89] </ref> was one of the early weaker memory models proposed which relaxes many of sequential consistency requirements significantly. [Goo89] also presented an intermediate weaker memory model Processor consistency in an attempt to combine ease of programmability with high performance implementations. [AH90] presented the Weak Ordering memory model with an implementation for <p> Cache Consistency <ref> [Goo89] </ref> was one of the early weaker memory models proposed which relaxes many of sequential consistency requirements significantly. [Goo89] also presented an intermediate weaker memory model Processor consistency in an attempt to combine ease of programmability with high performance implementations. [AH90] presented the Weak Ordering memory model with an implementation for cache-based systems. [ANK + 95] proposed Causal Memory model which is intermediate between sequential consistency and other earlier
Reference: [Gra94] <author> S. Graf. </author> <title> Verification of a distributed cache memory by using abstractions. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <address> 818:207-??, </address> <year> 1994. </year> <month> 17 </month>
Reference-contexts: In Section 4, I describe the problem I propose to study, consider related issues and present my plans to approach the problem. In Section 4.2, a time-line for the proposed work is given. Related Works In <ref> [Gra94] </ref>, abstract interpretation [CC77] is employed to reduce infinite-system verification to finite 8CTL fl model-checking. They apply this technique to verify the sequential consistency of lazy caching with unbounded queues. <p> They apply this technique to verify the sequential consistency of lazy caching with unbounded queues. They recognize that to get an exact characterization of sequential consistency involving only the observable event names, one needs full second order logic <ref> [Gra94] </ref>. To be able to express sequential consistency in 8CTL fl , they give a stronger characterization of sequential consistency. For this stronger characterization, the expression of sequential consistency is very complex which results in a few pages of complex temporal logic formulas.
Reference: [GS93] <author> G. R. Gao and V. Sarkar. </author> <title> Location consistency: Stepping beyond the barriers of memory coherence and serializability. </title> <type> Technical Report ACAPS Technical Memo 78, </type> <institution> School of Computer Science, McGill University, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: Among the various weaker memory models described above, cache consistency is the weakest. It has been shown that cache consistency is the weakest reasonable memory model [Fri98] (under an intuitive notion of reasonable-ness) 2 . <ref> [GS93] </ref> proposed a memory model weaker than cache consistency, named Location Consistency 3 . However, it was shown that [GS93]-location consistency does not meet the reasonable-ness criteria of [Fri98] and hence in practice we should adopt cache consistency as the memory model for a realistic implementation of [GS93]-location consistency [Fri98].
Reference: [GW88] <author> J. R. Goodman and P. J. Woest. </author> <title> The wisconsin multicube: A new large-scale cache coherent multiprocessor. </title> <booktitle> In Proc. of the 15th Annual Int'l Symp. on Computer Architecture (ISCA'88), </booktitle> <pages> pages 422-431, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: model with an implementation for cache-based systems. [ANK + 95] proposed Causal Memory model which is intermediate between sequential consistency and other earlier proposed weaker memory modelPRAM [LS88]. [ABJ + 93] have also proposed a weaker memory model called Processor Consistency, however their definition differs from processor consistency definition of <ref> [GW88] </ref>. Various weaker memory models have been proposed which relax sequential consistency a great deal providing selective ordering among memory operations as necessary.
Reference: [HB95] <author> R. Hojati and R. Brayton. </author> <title> Automatic datapath abstraction of hardware systems. </title> <booktitle> In Conference on Computer-Aided Verification, </booktitle> <year> 1995. </year>
Reference-contexts: We also assume that the system is address semi-dependent <ref> [HB95] </ref>, i.e. the control logic can at most compare two addresses for equality or inequality and base its actions on the outcome of this test.
Reference: [HKV97] <author> L. Higham, J. Kawash, and N. Verwaal. </author> <title> Defining and comparing memory consistency models. </title> <booktitle> In Proc. of the 10th Int'l Conf. on Parallel and Distributed Computing Systems (PDCS-97), </booktitle> <month> October </month> <year> 1997. </year>
Reference-contexts: There have been many approaches presenting a formal framework to define and compare various weaker memory models <ref> [HKV97, HST98, Gha95, RS95, KNA93, FL98, Fri94] </ref>. Approaches such as [Gha95] adopt a hardware-centric view: they define memory models in terms of how memory accesses can be executed by the system. Approaches such as [HKV97, KNA93, RS95] define memory models in terms of partial orders on memory access events. <p> Approaches such as [Gha95] adopt a hardware-centric view: they define memory models in terms of how memory accesses can be executed by the system. Approaches such as <ref> [HKV97, KNA93, RS95] </ref> define memory models in terms of partial orders on memory access events. In contrast to hardware-centric view, approaches such as [FL98, HST98] adopt a programmer-centric view 4 and define memory models in terms of the interface provided to the programmer by specifying possible results of an execution.
Reference: [HMTLB95] <author> R. Hojati, R. Mueller-Thuns, P. Loewenstein, and R. Brayton. </author> <title> Automatic verification of memory systems which service their requests out of order. </title> <booktitle> In CHDL, </booktitle> <pages> pages 623-639, </pages> <year> 1995. </year>
Reference-contexts: This is detailed in Section 3.1. In [PD96], the authors use a method called aggregation on a distributed shared memory coherence protocol used in an experimental multiprocessor, to arrive at a simplified model of system behavior. Their technique involves manual theorem proving. The work in <ref> [HMTLB95] </ref> as well as [DPN93] are aimed at verifying that synchronization routines work correctly under various memory models, where the memory models themselves are described using finite-state operational models. They do not address the problem of establishing the memory models provided by detailed memory subsystem designs, which is our contribution.
Reference: [HST98] <author> W. Hu, W. Shi, and Z. Tang. </author> <title> A framework of memory consistency models. </title> <journal> Journal of Computer Science and Technology, </journal> <volume> 13(2) </volume> <pages> 110-124, </pages> <month> March </month> <year> 1998. </year>
Reference-contexts: There have been many approaches presenting a formal framework to define and compare various weaker memory models <ref> [HKV97, HST98, Gha95, RS95, KNA93, FL98, Fri94] </ref>. Approaches such as [Gha95] adopt a hardware-centric view: they define memory models in terms of how memory accesses can be executed by the system. Approaches such as [HKV97, KNA93, RS95] define memory models in terms of partial orders on memory access events. <p> Approaches such as [HKV97, KNA93, RS95] define memory models in terms of partial orders on memory access events. In contrast to hardware-centric view, approaches such as <ref> [FL98, HST98] </ref> adopt a programmer-centric view 4 and define memory models in terms of the interface provided to the programmer by specifying possible results of an execution.
Reference: [ISL96] <author> L. Iftode, J. P. Singh, and K. Li. </author> <title> Scope consistency: A bridge between release con sistency and entry consistency. </title> <booktitle> In Proc. of the 8th ACM Annual Symp. on Parallel Algorithms and Architectures (SPAA'96), </booktitle> <pages> pages 277-287, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: Various weaker memory models have been proposed which relax sequential consistency a great deal providing selective ordering among memory operations as necessary. Release consistency [GLL + 90, GGH93], Lazy Release Consistency [KCZ92], Scope Consistency <ref> [ISL96] </ref> are some examples. 4 Many weaker memory models have been proposed by commercial architectures also. The SPARC V8 architecture [WG94] proposed Total Store Ordering (TSO) and Partial Store Ordering (PSO) weaker memory models which can be selectively implemented.
Reference: [Kan96] <author> Gerry Kane. </author> <title> PA-RISC 2.0 Architecture. </title> <publisher> Prentice Hall, </publisher> <year> 1996. </year> <note> ISBN 0-13-182734-0. </note>
Reference-contexts: Utah Runway Model (URM) Our third example, called URM, is modeled after a Hewlett-Packard commercial bus Runway connection used to interconnect HP PA 8000 processors and memory controller together to form a multiprocessor system. The behavior of this memory system is described in some detail in <ref> [BCS96, Cam97, Kan96] </ref>.
Reference: [KCZ92] <author> P. Keleher, A. L. Cox, and W. Zwaenepoel. </author> <title> Lazy release consistency for software distributed shared memory. </title> <booktitle> In Proc. of the 19th Annual Int'l Symp. on Computer Architecture (ISCA'92), </booktitle> <pages> pages 13-21, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Various weaker memory models have been proposed which relax sequential consistency a great deal providing selective ordering among memory operations as necessary. Release consistency [GLL + 90, GGH93], Lazy Release Consistency <ref> [KCZ92] </ref>, Scope Consistency [ISL96] are some examples. 4 Many weaker memory models have been proposed by commercial architectures also. The SPARC V8 architecture [WG94] proposed Total Store Ordering (TSO) and Partial Store Ordering (PSO) weaker memory models which can be selectively implemented.
Reference: [KNA93] <author> P. Kohli, G. Neiger, and M. Ahamad. </author> <title> A characterization of scalable shared memories. </title> <booktitle> In Proc. of the 1993 Int'l Conf. on Parallel Processing (ICPP'93), </booktitle> <month> August </month> <year> 1993. </year>
Reference-contexts: There have been many approaches presenting a formal framework to define and compare various weaker memory models <ref> [HKV97, HST98, Gha95, RS95, KNA93, FL98, Fri94] </ref>. Approaches such as [Gha95] adopt a hardware-centric view: they define memory models in terms of how memory accesses can be executed by the system. Approaches such as [HKV97, KNA93, RS95] define memory models in terms of partial orders on memory access events. <p> Approaches such as [Gha95] adopt a hardware-centric view: they define memory models in terms of how memory accesses can be executed by the system. Approaches such as <ref> [HKV97, KNA93, RS95] </ref> define memory models in terms of partial orders on memory access events. In contrast to hardware-centric view, approaches such as [FL98, HST98] adopt a programmer-centric view 4 and define memory models in terms of the interface provided to the programmer by specifying possible results of an execution.
Reference: [Lam79a] <author> L. Lamport. </author> <title> How to make a multiprocessor computer that correctly executes mul tiprocess programs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-28(9):690-691, </volume> <month> September </month> <year> 1979. </year>
Reference-contexts: Memory models for multiprocessors are usually much more involved because of complex interactions between memory operations on different processors. One of the first memory models proposed for multiprocessors is sequential consistency <ref> [Lam79a] </ref> which extends the uniprocessor memory model for multiprocessors in a natural and intuitive way. Sequential consistency is the strongest memory model proposed for multiprocessor memory systems. It has been long realized that it restricts the use of many commonly used optimizations in the design of memory systems 1 [Goo89]. <p> Why weaker memory models ? Sequential consistency extends the classical von Neumann uniprocessor memory model to multiprocessors in a natural and intuitive way. It was formally defined by Lamport <ref> [Lam79a] </ref> as follows. [A multiprocessor system is sequential consistent if] the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program.
Reference: [Lam79b] <author> Leslie Lamport. </author> <title> How to make a multiprocessor computer that correctly executes mul tiprocess programs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 9(29) </volume> <pages> 690-691, </pages> <year> 1979. </year>
Reference-contexts: The Conditions corresponding to each compound memory rule being tested are turned into corresponding memory rule safety properties that are checked by the VIS tool. The reader may take a peek at Section 3.6 to know which compound rules define sequential consistency <ref> [Lam79b] </ref>.
Reference: [LS88] <author> R. J. Lipton and J. S. Sandberg. </author> <title> Pram: A scalable shared memory. </title> <type> Technical Report CS-TR-180-88, </type> <institution> Dept. of Computer Science, Princeton University, </institution> <month> September </month> <year> 1988. </year>
Reference-contexts: weaker memory model Processor consistency in an attempt to combine ease of programmability with high performance implementations. [AH90] presented the Weak Ordering memory model with an implementation for cache-based systems. [ANK + 95] proposed Causal Memory model which is intermediate between sequential consistency and other earlier proposed weaker memory modelPRAM <ref> [LS88] </ref>. [ABJ + 93] have also proposed a weaker memory model called Processor Consistency, however their definition differs from processor consistency definition of [GW88]. Various weaker memory models have been proposed which relax sequential consistency a great deal providing selective ordering among memory operations as necessary.
Reference: [McM93] <author> Kenneth L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Press, </publisher> <year> 1993. </year>
Reference-contexts: These formulas are heavily dependent on the memory system being verified and need to be changed as the memory system model change in the process of debugging. A technique very similar to test model-checking was proposed in <ref> [McM93] </ref> under the section heading `Sequential Consistency'. To give a historic perspective, our test model-checking idea originated 3 in our attempt to answer the following two questions: (i) which memory ordering rule (s) is [McM93] really verifying? (ii) is this a general technique? i.e. can other memory ordering rules be verified <p> A technique very similar to test model-checking was proposed in <ref> [McM93] </ref> under the section heading `Sequential Consistency'. To give a historic perspective, our test model-checking idea originated 3 in our attempt to answer the following two questions: (i) which memory ordering rule (s) is [McM93] really verifying? (ii) is this a general technique? i.e. can other memory ordering rules be verified in the same fashion? We still have not found a satisfactory answer to the first question because the test in [McM93] uses only one location which then couldn't make it a test for sequential <p> to answer the following two questions: (i) which memory ordering rule (s) is <ref> [McM93] </ref> really verifying? (ii) is this a general technique? i.e. can other memory ordering rules be verified in the same fashion? We still have not found a satisfactory answer to the first question because the test in [McM93] uses only one location which then couldn't make it a test for sequential consistency; it could plausibly be a test for coherence|which again does not correspond to what Collier formally proves in [Col92].
Reference: [Mok] <author> A. Mokkedem. </author> <title> Verification of three memory systems using test model-checking. </title> <address> http://www.cs.utah.edu/~mokkedem/vis/vis.html. </address>
Reference-contexts: These three memory systems are briefly described below, refer [NGMG98b] for more details. VIS details of all our experiments can be obtained from the Web <ref> [Mok] </ref> or by contacting the authors. How to check for Sequential Consistency? As suggested in [Col92], one's intuition about sequential consistency matches the behaviour described by A (CM P; P O; W A). <p> We did not try to model each of these features in their full glory, but we did include a modicum of these aggressive features into our URM, which in fact occupies more than 2,000 lines of VIS Verilog code (see <ref> [Mok] </ref>).
Reference: [Mos93] <author> D. Mosberger. </author> <title> Memory consistency models. </title> <journal> ACM Operating Systems Review, </journal> <volume> 27(1):18 26, </volume> <month> January </month> <year> 1993. </year> <month> 18 </month>
Reference-contexts: The SPARC V8 architecture [WG94] proposed Total Store Ordering (TSO) and Partial Store Ordering (PSO) weaker memory models which can be selectively implemented. Alpha architecture [Sit92] proposed a Alpha Consistency model which uses explicit fence instructions for ordering in between two instructions in a program. <ref> [Mos93, AG96] </ref> present a survey of various weaker memory models and related issues. Among the various weaker memory models described above, cache consistency is the weakest.
Reference: [NGMG98a] <author> R. Nalumasu, R. Ghughal, A. Mokkedem, and G. Gopalakrishnan. </author> <title> The `test model checking' approach to the verification of formal memory models of multiprocessors. </title> <booktitle> In International Conference on Computer-Aided Verification , Vancouver, </booktitle> <address> Canada, </address> <month> June </month> <year> 1998. </year>
Reference-contexts: Archtest has been successfully applied to many commercial multiprocessors [Col]. We have successfully applied test model-checking technique to three memory systems one of them of considerable complexity to check for sequential consistency <ref> [GNMG98, NGMG98a] </ref>. Our experiments so far indicates that this technique could be a helpful tool to real system designers for debugging their memory system models during early stages of design cycle. However, the technique developed so far cannot be applied to check memory systems for weaker memory models. <p> This work has also been published in [GNMG98] and <ref> [NGMG98a] </ref>. Test model-checking converts the tests of Archtest to corresponding memory rule test automata ("test automata") that drive the model of the memory system being examined. In our experiments, we use the Verilog language supported by VIS [Ver] to capture the memory system models as well as the test automata.
Reference: [NGMG98b] <author> R. Nalumasu, R. Ghughal, A. Mokkedem, and G. Gopalakrishnan. </author> <title> The `test model checking' approach to the verification of formal memory models of multiprocessors. </title> <type> Technical Report UUCS-98-008, </type> <institution> University of Utah, </institution> <year> 1998. </year> <note> also available in http://www.cs.utah.edu/~mokkedem/frames/tr98.ps.gz. </note>
Reference-contexts: These three memory systems are briefly described below, refer <ref> [NGMG98b] </ref> for more details. VIS details of all our experiments can be obtained from the Web [Mok] or by contacting the authors. How to check for Sequential Consistency? As suggested in [Col92], one's intuition about sequential consistency matches the behaviour described by A (CM P; P O; W A). <p> Whenever a condition failed, model-checking finished in a reasonable time (in order of few minutes) with a counter-example demonstrating the scenario of violation pointing to the source of bug. Details on the descriptions of bug found are available from <ref> [NGMG98b] </ref>.
Reference: [PD96] <author> Seungjoon Park and David L. Dill. </author> <title> Verification of FLASH cache coherence protocol by aggregation of distributed transactions. </title> <booktitle> In SPAA, </booktitle> <pages> pages 288-296, </pages> <address> Padua, Italy, </address> <month> June 24-26, </month> <year> 1996. </year>
Reference-contexts: This result is not applicable in our case, because the models we consider do not make decisions based on the value returned by a read instruction. This is detailed in Section 3.1. In <ref> [PD96] </ref>, the authors use a method called aggregation on a distributed shared memory coherence protocol used in an experimental multiprocessor, to arrive at a simplified model of system behavior. Their technique involves manual theorem proving.
Reference: [RS95] <author> M. Raynal and A. Schiper. </author> <title> A suite of formal definitions for consistency criteria in shared memories. </title> <type> Technical Report PI-968, </type> <institution> IRISA, France, </institution> <month> May </month> <year> 1995. </year>
Reference-contexts: There have been many approaches presenting a formal framework to define and compare various weaker memory models <ref> [HKV97, HST98, Gha95, RS95, KNA93, FL98, Fri94] </ref>. Approaches such as [Gha95] adopt a hardware-centric view: they define memory models in terms of how memory accesses can be executed by the system. Approaches such as [HKV97, KNA93, RS95] define memory models in terms of partial orders on memory access events. <p> Approaches such as [Gha95] adopt a hardware-centric view: they define memory models in terms of how memory accesses can be executed by the system. Approaches such as <ref> [HKV97, KNA93, RS95] </ref> define memory models in terms of partial orders on memory access events. In contrast to hardware-centric view, approaches such as [FL98, HST98] adopt a programmer-centric view 4 and define memory models in terms of the interface provided to the programmer by specifying possible results of an execution.
Reference: [Sit92] <author> Richard L. </author> <title> Sites. Alpha Architecture Reference Manual. </title> <publisher> Digital Press and Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: The SPARC V8 architecture [WG94] proposed Total Store Ordering (TSO) and Partial Store Ordering (PSO) weaker memory models which can be selectively implemented. Alpha architecture <ref> [Sit92] </ref> proposed a Alpha Consistency model which uses explicit fence instructions for ordering in between two instructions in a program. [Mos93, AG96] present a survey of various weaker memory models and related issues. Among the various weaker memory models described above, cache consistency is the weakest.
Reference: [Ver] <author> Vis-1.2 release. </author> <note> http://www-cad.eecs.berkeley.edu/Respep/Research/vis/. </note>
Reference-contexts: This work has also been published in [GNMG98] and [NGMG98a]. Test model-checking converts the tests of Archtest to corresponding memory rule test automata ("test automata") that drive the model of the memory system being examined. In our experiments, we use the Verilog language supported by VIS <ref> [Ver] </ref> to capture the memory system models as well as the test automata. Precisely, the automata are modeled as (Verilog) processes which run in parallel with the memory system and simply enqueue test automata instructions in the instruction stream of the processors. <p> PO Cross by an argument similar to that for T est ROWO and T est WA . 3.6 Case Studies and Experimental Results To demonstrate the effectiveness of our approach, we verified three different memory systems, namely serial memory, lazy caching, and URM, all using a symbolic model-checker VIS (See <ref> [Ver] </ref> for more information on VIS). These three memory systems are briefly described below, refer [NGMG98b] for more details. VIS details of all our experiments can be obtained from the Web [Mok] or by contacting the authors.
Reference: [WG94] <author> David L. Weaver and Tom Germond. </author> <title> The SPARC Architecture Manual Version 9. P T R Prentice-Hall, </title> <address> Englewood Cliffs, NJ 07632, USA, </address> <year> 1994. </year> <month> 19 </month>
Reference-contexts: Release consistency [GLL + 90, GGH93], Lazy Release Consistency [KCZ92], Scope Consistency [ISL96] are some examples. 4 Many weaker memory models have been proposed by commercial architectures also. The SPARC V8 architecture <ref> [WG94] </ref> proposed Total Store Ordering (TSO) and Partial Store Ordering (PSO) weaker memory models which can be selectively implemented.
References-found: 49

