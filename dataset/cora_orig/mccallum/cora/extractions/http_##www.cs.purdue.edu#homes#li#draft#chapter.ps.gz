URL: http://www.cs.purdue.edu/homes/li/draft/chapter.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/li/publications.html
Root-URL: http://www.cs.purdue.edu
Phone: 2  
Title: Interprocedural Analysis Based on Guarded Array Regions  
Author: Zhiyuan Li Junjie Gu and Gyungho Lee 
Keyword: Key words: Parallelizing compilers, array data flow analysis, interprocedural analysis, array privatization, guarded array regions, symbolic analysis.  
Address: 200 Union Street S.E., Minneapolis, MN 55455, USA  nio, 6900 North Loop 1604 West, San Antonio, Texas 78249-0665, USA  
Affiliation: 1 Department of Computer Science, University of Minnesota,  Electrical Engineering, Division of Engineering, University of Texas San Anto  
Abstract: Summary. Array data flow information plays an important role for successful automatic parallelization of Fortran programs. This chapter proposes a powerful symbolic array data flow summary scheme to support array privatization and loop parallelization for programs with arbitrary control flow graphs and acyclic call graphs. Our approach summarizes array access information interprocedurally, using guarded array regions. The use of guards allows us to use the information in IF conditions to do path-sensitive data flow summary and thereby to handle difficult cases. We also provide a mechanism to overcome the disadvantages of non-closed union and difference operations. This improves not only the exactness of summaries, but also the efficiency of the summarizing procedure. Our preliminary result on array privatization shows that our summary scheme is fast and powerful. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Aho, A.V., Sethi, R., Ullman, J.D. </author> <year> (1986). </year> <title> Compilers: Principles, Techniques, and Tools. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass. </address>
Reference-contexts: It performs parsing, construction of a hierarchical supergraph (HSG) and interprocedural scalar UD/DU chains <ref> [1] </ref>, conventional data dependence tests, array data flow analysis and other analyses which support memory performance enhancement, and parallel code generation.
Reference: 2. <author> Balasundaram, V. </author> <year> (1990). </year> <title> A Mechanism for Keeping Useful Internal Information in Parallel Programming Tools: The Data Access Descriptor. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 9 </volume> <pages> 154-170. </pages>
Reference-contexts: Data dependences involving routine calls can be tested by intersecting these sets. Existing approaches can be categorized according to methods of set representation. Convex regions [27, 28] and data access descriptors <ref> [2] </ref> define sets by a system of inequalities and equalities, while bounded regular sections [5, 15] use range tuples to represent sets. Even though bounded regular sections are less precise than convex regions and data access descriptors, they are much simpler and are easy to implement. <p> To understand these summary schemes, we will briefly discuss the following two aspects: set representations and summaries of multiple array references over multiple control branches. A. Set representations Several set representations have been proposed so far, including convex regions [27, 28], data access descriptors <ref> [2] </ref> and bounded regular sections (for simplicity, we refer to this as regular sections when there is no confusion) [5, 15]. Although data access descriptors are more restrictive than convex regions, they basically define sets by a system of inequalities and equalities just as convex regions do. <p> Similarly, if either P is F alse or R is ;, we say [P; R] is ;. The regular array region defined above is more restrictive than the original regular section used in the ParaScope environment at Rice University <ref> [5, 2, 15] </ref>. This basic unit, however, will be able to cover the most frequent cases in real programs and it seems to have an advantage in efficiency when dealing with the common cases. <p> This class extends data structures designed by the early works for flow-insensitive array problems, such as regular array sections [5, 15], convex regions [27, 28], and data access descriptors <ref> [2] </ref>. Array data flow analysis in this class includes works done by Gross and Steenkiste [11], Rosene [25], Li [17], Tu and Padua [29], Creusillet and Irigoin [7], and M. Hall, et al. [14]).
Reference: 3. <author> Blume, W., Eigenmann, R. </author> <year> (1994). </year> <title> Symbolic Analysis Techniques Needed for the Effective Parallelization of Perfect Benchmarks. </title> <type> Technical report, </type> <institution> Dept. of Computer Science, University of Illinois. </institution>
Reference-contexts: Must sets are calculated by intersecting summary sets for different branches at branching statements. The meet operations for must sets are closed. However, difference operations, which are introduced by computing U E sets, are not closed. Previous experiments <ref> [3, 21] </ref> as well as our experience indicate that the path-insensitive MUST/MAY array data flow summary is not enough; IF conditions need to be considered in order to handle certain important cases in real programs. Take Figure 2.1 as an example. <p> We then present preliminary experimental results to show both the capability and the efficiency of our analysis. 6.1 Array Privatization Array privatization has been shown to be one of the most important techniques to improve the performance of parallelizing compilers <ref> [3, 4, 12, 21] </ref>. This technique creates a distinct copy of an array for each processor such that storage conflicts can be eliminated without violating program semantics. Pri-vatizable arrays appear in real programs quite often and usually serve as temporary working spaces.
Reference: 4. <author> Blume, W., Eigenman, R. </author> <year> (1992). </year> <title> Performance Analysis of Parallelizing Compilers on the Perfect Benchmarks Programs. </title> <journal> IEEE Trans. on Parallel and Distributed Systems, November, </journal> <volume> 3(6) </volume> <pages> 643-656. 24 </pages>
Reference-contexts: We then present preliminary experimental results to show both the capability and the efficiency of our analysis. 6.1 Array Privatization Array privatization has been shown to be one of the most important techniques to improve the performance of parallelizing compilers <ref> [3, 4, 12, 21] </ref>. This technique creates a distinct copy of an array for each processor such that storage conflicts can be eliminated without violating program semantics. Pri-vatizable arrays appear in real programs quite often and usually serve as temporary working spaces.
Reference: 5. <author> Callahan, D., Kennedy, K. </author> <year> (1986). </year> <title> Analysis of interprocedural side effects in a parallel programming environment. </title> <booktitle> ACM SIGPLAN '86 Symp. Compiler Construction, </booktitle> <month> June, </month> <pages> 162-175. </pages>
Reference-contexts: Data dependences involving routine calls can be tested by intersecting these sets. Existing approaches can be categorized according to methods of set representation. Convex regions [27, 28] and data access descriptors [2] define sets by a system of inequalities and equalities, while bounded regular sections <ref> [5, 15] </ref> use range tuples to represent sets. Even though bounded regular sections are less precise than convex regions and data access descriptors, they are much simpler and are easy to implement. The commonalities of these previous methods are as follows. <p> A. Set representations Several set representations have been proposed so far, including convex regions [27, 28], data access descriptors [2] and bounded regular sections (for simplicity, we refer to this as regular sections when there is no confusion) <ref> [5, 15] </ref>. Although data access descriptors are more restrictive than convex regions, they basically define sets by a system of inequalities and equalities just as convex regions do. Data access descriptors also contain additional information besides the shapes of array accesses. <p> Our basic unit of array reference representation is a regular array region, which is also called a bounded regular section [15]. It is a reduced form of the original regular sections proposed by Callahan and Kennedy <ref> [5] </ref>. On the other hand, we extend original regular sections in the following ways to meet our need to represent U E and M OD sets. <p> Similarly, if either P is F alse or R is ;, we say [P; R] is ;. The regular array region defined above is more restrictive than the original regular section used in the ParaScope environment at Rice University <ref> [5, 2, 15] </ref>. This basic unit, however, will be able to cover the most frequent cases in real programs and it seems to have an advantage in efficiency when dealing with the common cases. <p> The other class of approaches summarizes the array elements accessed by a set of array references instead of analyzing individual array references. This class extends data structures designed by the early works for flow-insensitive array problems, such as regular array sections <ref> [5, 15] </ref>, convex regions [27, 28], and data access descriptors [2]. Array data flow analysis in this class includes works done by Gross and Steenkiste [11], Rosene [25], Li [17], Tu and Padua [29], Creusillet and Irigoin [7], and M. Hall, et al. [14]).
Reference: 6. <author> Clarke, L.A., Richardson, D.J. </author> <year> (1985). </year> <title> Applications of Symbolic Evaluation. </title> <journal> The Journal of Systems and Software, </journal> <volume> 5(1) </volume> <pages> 15-35 </pages>
Reference-contexts: We define a new canonical form to represent predicates in order to simplify pattern matching needed to check whether two predicates are identical. Both conjunctive normal form (CNF) and disjunctive normal form (DNF) have been widely used in program analysis <ref> [26, 6] </ref>. These cited works show that negation operations are expensive with both CNF and DNF. Our previous experiments using CNF [12] also confirm their observations. Negation operations occur not only due to ELSE branches, but also due to GAR and GARWD operations elsewhere. <p> It is widely used in symbolic evaluation and abstract interpretation techniques to discover program properties such as values of expressions, relationships between symbolic expressions, etc. Symbolic analysis requires to represent and manipulate unknown symbolic terms. A symbolic analyzer can adopt a certain normalized form to represent expressions <ref> [26, 6, 13] </ref>. The advantage of such a normalized form is that it gives the same representation for two congruent expressions, i.e. they always have the same value. For example, x (x + 1) and x + x 2 are congruent expressions.
Reference: 7. <author> Creusillet, B., Irigoin, F. </author> <year> (1995). </year> <title> Interprocedural Array Region Analyses. </title> <booktitle> Proceedings of the 8th Workshop on Languages and Compilers for Parallel Computing, held in Columbus, </booktitle> <address> Ohio, </address> <month> August, </month> <title> No. </title> <booktitle> 1033, In Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, Berlin, </publisher> <pages> 46-60. </pages>
Reference-contexts: Therefore, these methods are insufficient for optimization such as array privatization. Recently, flow-sensitive summary, or array data flow summary, has been a focus in the parallelizing compiler area. The most essential information in array data flow summary is the upward exposed use (UE) set <ref> [7, 29, 17, 14, 12] </ref>. Our work [12] and that of M. <p> Our work is unique in its use of guarded array regions (GAR's), providing the conditions under which an array region is modified or upward-exposedly used. This is in contrast to path-insensitive summaries which do not distinguish summary sets for different program paths. Compared to other approaches <ref> [7] </ref> which handle more restricted cases of IF conditions, our approach seems to be more general. In this chapter, we will describe our array data flow summary based on guarded array regions in the context of parallelizing compilers. <p> Some previous approaches such as [18] use a list of references as a set representation to avoid union operations and thus maintain exact summary information. 4 2.2 Array Data Flow Summaries Recently, array data flow summaries, which analyze the intervening array kills, have been investigated <ref> [11, 25, 17, 29, 14, 7] </ref>. In these array data flow summaries, sets of upward exposed array uses (UE sets), which cannot be calculated without considering the effects of array kills, are calculated in addition to MOD and USE sets. <p> Array data flow analysis in this class includes works done by Gross and Steenkiste [11], Rosene [25], Li [17], Tu and Padua [29], Creusillet and Irigoin <ref> [7] </ref>, and M. Hall, et al. [14]). The 23 work described in this chapter seems to be the only one which considers the effect of IF conditions in a general way, although some previous works also handle IF conditions under more limited circumstances.
Reference: 8. <author> Duesterwald, E., Gupta, R., Soffa, </author> <title> M.L. (1993). A Practical Data Flow Framework for Array Reference Analysis and its Use in Optimizations. </title> <booktitle> ACM SIG-PLAN '93 Conf. on Programming Language Design and Implementation, </booktitle> <month> June, </month> <pages> 68-77. </pages>
Reference-contexts: Feautrier [10] calculates the source function which represents the precise array definition points for each array use. Maydan, et al. [20, 21] simplify Feautrier's method by computing a Last-Write-Tree (LWT). Duesterwald, et al., compute the dependence distance for each reaching definition within a loop <ref> [8] </ref>. Pugh and Wonnacott [24] use a set of constraints to describe array data flow problems and solve them by an extented Fourier-Motzkin variable elimination. Maslov [19], as well as Pugh and Wonnacott [24], extends the previous work in this category by handling certain IF conditions.
Reference: 9. <author> Eigenmann, R., Hoeflinger, J., Li, Z., Padua, D. </author> <year> (1992). </year> <title> Experience in the Automatic Parallelization of Four Perfect Benchmark Programs. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 589, </volume> <publisher> Springer-Verlag. </publisher>
Reference: 10. <author> Feautrier, P. </author> <year> (1991). </year> <title> Dataflow Analysis of Array and Scalar References. </title> <journal> International Journal of Parallel Programming, February, </journal> <volume> 2(1) </volume> <pages> 23-53. </pages>
Reference-contexts: Related Works There exist a number of approaches to array data flow analysis. As far as we know, no work has particularly addressed the efficiency issue or has presented efficiency data. One class of approaches attempt to gather flow information for each individual array reference. Feautrier <ref> [10] </ref> calculates the source function which represents the precise array definition points for each array use. Maydan, et al. [20, 21] simplify Feautrier's method by computing a Last-Write-Tree (LWT). Duesterwald, et al., compute the dependence distance for each reaching definition within a loop [8].
Reference: 11. <author> Gross, T., Steenkiste, P. </author> <year> (1990). </year> <title> Structured dataflow analysis for arrays and its use in an optimizing compiler. </title> <journal> Software Practice and Experience, February, </journal> <volume> 20(2) </volume> <pages> 133-155. </pages>
Reference-contexts: Some previous approaches such as [18] use a list of references as a set representation to avoid union operations and thus maintain exact summary information. 4 2.2 Array Data Flow Summaries Recently, array data flow summaries, which analyze the intervening array kills, have been investigated <ref> [11, 25, 17, 29, 14, 7] </ref>. In these array data flow summaries, sets of upward exposed array uses (UE sets), which cannot be calculated without considering the effects of array kills, are calculated in addition to MOD and USE sets. <p> This class extends data structures designed by the early works for flow-insensitive array problems, such as regular array sections [5, 15], convex regions [27, 28], and data access descriptors [2]. Array data flow analysis in this class includes works done by Gross and Steenkiste <ref> [11] </ref>, Rosene [25], Li [17], Tu and Padua [29], Creusillet and Irigoin [7], and M. Hall, et al. [14]).
Reference: 12. <author> Gu, J., Li, Z., Lee, G. </author> <year> (1995). </year> <title> Symbolic Array Dataflow Analysis for Array Privatization and Program Parallelization. Supercomputing'95, December, </title> <address> San Diego, CA. </address>
Reference-contexts: Therefore, these methods are insufficient for optimization such as array privatization. Recently, flow-sensitive summary, or array data flow summary, has been a focus in the parallelizing compiler area. The most essential information in array data flow summary is the upward exposed use (UE) set <ref> [7, 29, 17, 14, 12] </ref>. Our work [12] and that of M. <p> Recently, flow-sensitive summary, or array data flow summary, has been a focus in the parallelizing compiler area. The most essential information in array data flow summary is the upward exposed use (UE) set [7, 29, 17, 14, 12]. Our work <ref> [12] </ref> and that of M. Hall, et al. [14] use either a list of regular sections or a list of convex regions to summarize each array in order to obtain more precise information than that provided by a single regular section or convex region. <p> However, the IF condition (:N OT:p) is loop-invariant, which guarantees that no loop-carried flow dependence exists in the outer loop, and therefore array A is privatizable. (We will discuss array privatization in section 6.) In the next section, we propose a path-sensitive summary scheme which uses guarded array regions <ref> [12] </ref> to handle IF conditions. In order to preserve 5 DO I = 1, 4 DO J = jlow, jup A (J) = . ENDDO ... A (jmax) = . ENDIF ... DO J = jlow, jup . = A (J) + A (jmax) ENDDO ENDDO Fig. 2.1. <p> We use a list of GAR's to represent a M OD set. However, using a list of GAR's for a U E set could introduce either more predicate operations <ref> [12] </ref> or unnecessary sacrifice of the exactness of difference operation results. Our solution to this problem is to define a data structure called a GAR with a difference list (GARWD). A U E set is represented by a list of GARWD's. <p> The validity of this union result can be guaranteed by inserting validity predicates into guards <ref> [12] </ref>. <p> Both conjunctive normal form (CNF) and disjunctive normal form (DNF) have been widely used in program analysis [26, 6]. These cited works show that negation operations are expensive with both CNF and DNF. Our previous experiments using CNF <ref> [12] </ref> also confirm their observations. Negation operations occur not only due to ELSE branches, but also due to GAR and GARWD operations elsewhere. Hence, we design a new canonical form such that negation operations can be reduced significantly. We use a two-level hierarchical approach to predicate handling. <p> We then present preliminary experimental results to show both the capability and the efficiency of our analysis. 6.1 Array Privatization Array privatization has been shown to be one of the most important techniques to improve the performance of parallelizing compilers <ref> [3, 4, 12, 21] </ref>. This technique creates a distinct copy of an array for each processor such that storage conflicts can be eliminated without violating program semantics. Pri-vatizable arrays appear in real programs quite often and usually serve as temporary working spaces. <p> All arrays listed in Table 6.1 can be privatized under our scheme except array RL in the MDG program. This case needs to handle predicates involving subscript variables, which our current implementation is unable to deal with <ref> [12] </ref>. Table 6.1.
Reference: 13. <author> Haghighat, </author> <title> M.R., Polychronopoulos, C.D. (1994). Symbolic analysis for Par-allelizing Compilers. </title> <type> Technical report, CSRD Report No. 1355, </type> <institution> University of Illinois. </institution>
Reference-contexts: It is widely used in symbolic evaluation and abstract interpretation techniques to discover program properties such as values of expressions, relationships between symbolic expressions, etc. Symbolic analysis requires to represent and manipulate unknown symbolic terms. A symbolic analyzer can adopt a certain normalized form to represent expressions <ref> [26, 6, 13] </ref>. The advantage of such a normalized form is that it gives the same representation for two congruent expressions, i.e. they always have the same value. For example, x (x + 1) and x + x 2 are congruent expressions.
Reference: 14. <author> Hall,M, Murphy, B., Amarasinghe, S., Liao, S., Lam, M. </author> <year> (1995). </year> <title> Interprocedural Analysis for Parallelization. </title> <booktitle> Proceedings of the 8th Workshop on Languages and Compilers for Parallel Computing, held in Columbus, </booktitle> <address> Ohio, </address> <month> August, </month> <title> No. </title> <booktitle> 1033, In Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, Berlin, </publisher> <pages> 61-80. </pages>
Reference-contexts: Therefore, these methods are insufficient for optimization such as array privatization. Recently, flow-sensitive summary, or array data flow summary, has been a focus in the parallelizing compiler area. The most essential information in array data flow summary is the upward exposed use (UE) set <ref> [7, 29, 17, 14, 12] </ref>. Our work [12] and that of M. <p> Recently, flow-sensitive summary, or array data flow summary, has been a focus in the parallelizing compiler area. The most essential information in array data flow summary is the upward exposed use (UE) set [7, 29, 17, 14, 12]. Our work [12] and that of M. Hall, et al. <ref> [14] </ref> use either a list of regular sections or a list of convex regions to summarize each array in order to obtain more precise information than that provided by a single regular section or convex region. <p> Some previous approaches such as [18] use a list of references as a set representation to avoid union operations and thus maintain exact summary information. 4 2.2 Array Data Flow Summaries Recently, array data flow summaries, which analyze the intervening array kills, have been investigated <ref> [11, 25, 17, 29, 14, 7] </ref>. In these array data flow summaries, sets of upward exposed array uses (UE sets), which cannot be calculated without considering the effects of array kills, are calculated in addition to MOD and USE sets. <p> Array data flow analysis in this class includes works done by Gross and Steenkiste [11], Rosene [25], Li [17], Tu and Padua [29], Creusillet and Irigoin [7], and M. Hall, et al. <ref> [14] </ref>). The 23 work described in this chapter seems to be the only one which considers the effect of IF conditions in a general way, although some previous works also handle IF conditions under more limited circumstances.
Reference: 15. <author> Havlak, P., Kennedy, K. </author> <year> (1991). </year> <title> An implementation of interprocedural bounded regular section analysis. </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> 2(3) </volume> <pages> 350-360. </pages>
Reference-contexts: Data dependences involving routine calls can be tested by intersecting these sets. Existing approaches can be categorized according to methods of set representation. Convex regions [27, 28] and data access descriptors [2] define sets by a system of inequalities and equalities, while bounded regular sections <ref> [5, 15] </ref> use range tuples to represent sets. Even though bounded regular sections are less precise than convex regions and data access descriptors, they are much simpler and are easy to implement. The commonalities of these previous methods are as follows. <p> A. Set representations Several set representations have been proposed so far, including convex regions [27, 28], data access descriptors [2] and bounded regular sections (for simplicity, we refer to this as regular sections when there is no confusion) <ref> [5, 15] </ref>. Although data access descriptors are more restrictive than convex regions, they basically define sets by a system of inequalities and equalities just as convex regions do. Data access descriptors also contain additional information besides the shapes of array accesses. <p> The M OD set is the set of array elements written within a given program segment. Our basic unit of array reference representation is a regular array region, which is also called a bounded regular section <ref> [15] </ref>. It is a reduced form of the original regular sections proposed by Callahan and Kennedy [5]. On the other hand, we extend original regular sections in the following ways to meet our need to represent U E and M OD sets. <p> Similarly, if either P is F alse or R is ;, we say [P; R] is ;. The regular array region defined above is more restrictive than the original regular section used in the ParaScope environment at Rice University <ref> [5, 2, 15] </ref>. This basic unit, however, will be able to cover the most frequent cases in real programs and it seems to have an advantage in efficiency when dealing with the common cases. <p> The other class of approaches summarizes the array elements accessed by a set of array references instead of analyzing individual array references. This class extends data structures designed by the early works for flow-insensitive array problems, such as regular array sections <ref> [5, 15] </ref>, convex regions [27, 28], and data access descriptors [2]. Array data flow analysis in this class includes works done by Gross and Steenkiste [11], Rosene [25], Li [17], Tu and Padua [29], Creusillet and Irigoin [7], and M. Hall, et al. [14]).
Reference: 16. <author> Irigoin, F., Jouvelot, P., Triolet, R. </author> <year> (1991). </year> <title> Semantical Interprocedural Paral-lelization: An overview of the PIPS Project. </title> <booktitle> International Conference on Supercomputing, </booktitle> <pages> 244-251. </pages>
Reference-contexts: Due to the nested structures of DO loops and routines, a hierarchy is derived among the HSG nodes, with the flow subgraph at the highest level representing the main program. The HSG resembles the HSCG used by the PIPS project <ref> [16] </ref>. Figure 4.1 shows a HSG example. Note that the flow subgraph of a routine is never duplicated for different calls to the same routine unless the called routine is duplicated to enhance its potential parallelism. We assume that the program contains no recursive calls.
Reference: 17. <author> Li, Z. </author> <year> (1992). </year> <title> Array Privatization for Parallel Execution of Loops. </title> <booktitle> ACM Int. Conf. on Supercomputing, </booktitle> <month> July, </month> <pages> 313-322. </pages>
Reference-contexts: Therefore, these methods are insufficient for optimization such as array privatization. Recently, flow-sensitive summary, or array data flow summary, has been a focus in the parallelizing compiler area. The most essential information in array data flow summary is the upward exposed use (UE) set <ref> [7, 29, 17, 14, 12] </ref>. Our work [12] and that of M. <p> Some previous approaches such as [18] use a list of references as a set representation to avoid union operations and thus maintain exact summary information. 4 2.2 Array Data Flow Summaries Recently, array data flow summaries, which analyze the intervening array kills, have been investigated <ref> [11, 25, 17, 29, 14, 7] </ref>. In these array data flow summaries, sets of upward exposed array uses (UE sets), which cannot be calculated without considering the effects of array kills, are calculated in addition to MOD and USE sets. <p> In contrast, data flow analysis, when supported by IF condition handling, symbolic analysis, and interprocedural analysis, allows a powerful compiler to recognize privatizable arrays. An array A is a privatization candidate in a loop L if its elements are overwritten in different iterations of L (see <ref> [17] </ref>). Such a candidacy can be established by examining the summary array M OD i set: If the intersection of M OD i and M OD &lt;i is nonempty, then A is a candidate. A privatization candidate is privatizable if there exist no loop-carried flow dependences in L. <p> This class extends data structures designed by the early works for flow-insensitive array problems, such as regular array sections [5, 15], convex regions [27, 28], and data access descriptors [2]. Array data flow analysis in this class includes works done by Gross and Steenkiste [11], Rosene [25], Li <ref> [17] </ref>, Tu and Padua [29], Creusillet and Irigoin [7], and M. Hall, et al. [14]).
Reference: 18. <author> Li, Z., Yew, </author> <title> P.C. (1988). Efficient interprocedural analysis for program paral-lelization and restructuring. </title> <booktitle> ACM SIGPLAN Conf. on Parallel Programming: Experience with Applications, Languages and Systems, </booktitle> <month> September, </month> <pages> 85-99. </pages>
Reference-contexts: In addition, attempting to represent the summary in a single convex region or a single regular section can also cause may sets because union operations are not closed. Some previous approaches such as <ref> [18] </ref> use a list of references as a set representation to avoid union operations and thus maintain exact summary information. 4 2.2 Array Data Flow Summaries Recently, array data flow summaries, which analyze the intervening array kills, have been investigated [11, 25, 17, 29, 14, 7].
Reference: 19. <author> Maslov, V. </author> <year> (1994). </year> <title> Lazy Array Data-Flow Dependence Analysis. </title> <booktitle> Proceedings of Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January, </month> <title> Portland, </title> <booktitle> Oregon, </booktitle> <pages> 331-325. </pages>
Reference-contexts: Duesterwald, et al., compute the dependence distance for each reaching definition within a loop [8]. Pugh and Wonnacott [24] use a set of constraints to describe array data flow problems and solve them by an extented Fourier-Motzkin variable elimination. Maslov <ref> [19] </ref>, as well as Pugh and Wonnacott [24], extends the previous work in this category by handling certain IF conditions. Generally, these approaches are intraprocedural and do not seem easy to extend interprocedurally.
Reference: 20. <author> Maydan, D.E., Amarasinghe, S.P., Lam, M.S. </author> <year> (1993). </year> <title> Array Data-Flow Analysis and its Use in Array Privatization. </title> <booktitle> Proc. of the 20th ACM Symp. on Principles of Programming Languages, </booktitle> <month> January, </month> <pages> 2-15. </pages>
Reference-contexts: One class of approaches attempt to gather flow information for each individual array reference. Feautrier [10] calculates the source function which represents the precise array definition points for each array use. Maydan, et al. <ref> [20, 21] </ref> simplify Feautrier's method by computing a Last-Write-Tree (LWT). Duesterwald, et al., compute the dependence distance for each reaching definition within a loop [8]. Pugh and Wonnacott [24] use a set of constraints to describe array data flow problems and solve them by an extented Fourier-Motzkin variable elimination.
Reference: 21. <author> Maydan, D.E. </author> <year> (1992). </year> <title> Accurate Analysis of Array References. </title> <type> PhD thesis, </type> <institution> Oc-tober, Stanford University. </institution>
Reference-contexts: The drawbacks of inlining are twofold. First, even if the program size does not increase after inline expansion, the loop body containing routine calls may grow dramatically. This often results in much longer compile time and much larger consumption of memory resources <ref> [21] </ref> because many compiler algorithms dealing with loops have non-linear complexity with respect to the loop body's size. Because a routine is analyzed each time it is inlined, duplicate analysis can also cause paral-lelizing compilers to be inefficient. <p> Must sets are calculated by intersecting summary sets for different branches at branching statements. The meet operations for must sets are closed. However, difference operations, which are introduced by computing U E sets, are not closed. Previous experiments <ref> [3, 21] </ref> as well as our experience indicate that the path-insensitive MUST/MAY array data flow summary is not enough; IF conditions need to be considered in order to handle certain important cases in real programs. Take Figure 2.1 as an example. <p> We then present preliminary experimental results to show both the capability and the efficiency of our analysis. 6.1 Array Privatization Array privatization has been shown to be one of the most important techniques to improve the performance of parallelizing compilers <ref> [3, 4, 12, 21] </ref>. This technique creates a distinct copy of an array for each processor such that storage conflicts can be eliminated without violating program semantics. Pri-vatizable arrays appear in real programs quite often and usually serve as temporary working spaces. <p> One class of approaches attempt to gather flow information for each individual array reference. Feautrier [10] calculates the source function which represents the precise array definition points for each array use. Maydan, et al. <ref> [20, 21] </ref> simplify Feautrier's method by computing a Last-Write-Tree (LWT). Duesterwald, et al., compute the dependence distance for each reaching definition within a loop [8]. Pugh and Wonnacott [24] use a set of constraints to describe array data flow problems and solve them by an extented Fourier-Motzkin variable elimination.
Reference: 22. <author> Myers, E. W. </author> <year> (1981). </year> <title> A Precise Interprocedural Data-Flow Algorithm. </title> <booktitle> Proceedings of 8th Annual ACM Symposium on Principles of Programming Languages. </booktitle> <month> January, </month> <pages> 219-230. 25 </pages>
Reference-contexts: Predicate Operations 4. Constructing Summary GAR's Interprocedurally 4.1 Hierarchical Supergraph In this section, we present algorithms to calculate the M OD and U E information by propagating the GAR's and the GARWD's over a hierarchical supergraph (HSG). The HSG in this paper is an enhancement of Myers' su-pergraph <ref> [22] </ref> which is a composite of the flow subgraphs of all routines in a program.
Reference: 23. <author> Nguyen, T., Gu, J., Li, Z. </author> <year> (1995). </year> <title> An Interprocedural Parallelizing Compiler and its support for Memory Hierarchy Research. </title> <booktitle> Lecture Notes in Computer Science 1033: 8th International Workshop on Languages and Compilers for Parallel Computing, </booktitle> <address> Columbus, Ohio, </address> <month> August, </month> <pages> 96-110. </pages>
Reference-contexts: The fact of U E i " M OD &lt;i being empty guarantees that array A is privatizable. 6.2 Preliminary Experimental Results We have implemented our array data flow analysis in a prototyping paralleliz-ing compiler, Panorama, which is a multiple-pass, source-to-source, Fortran 21 program restructurer <ref> [23] </ref>. It performs parsing, construction of a hierarchical supergraph (HSG) and interprocedural scalar UD/DU chains [1], conventional data dependence tests, array data flow analysis and other analyses which support memory performance enhancement, and parallel code generation.
Reference: 24. <author> Pugh, W., Wonnacott, D. </author> <year> (1993). </year> <title> An Exact Method for Analysis of Value-based Array Data Dependences. </title> <booktitle> Lecture Notes in Computer Science 768: Sixth Annual Workshop on Programming Languages and Compilers for Parallel Computing, </booktitle> <address> Portland, OR, </address> <month> August. </month>
Reference-contexts: Feautrier [10] calculates the source function which represents the precise array definition points for each array use. Maydan, et al. [20, 21] simplify Feautrier's method by computing a Last-Write-Tree (LWT). Duesterwald, et al., compute the dependence distance for each reaching definition within a loop [8]. Pugh and Wonnacott <ref> [24] </ref> use a set of constraints to describe array data flow problems and solve them by an extented Fourier-Motzkin variable elimination. Maslov [19], as well as Pugh and Wonnacott [24], extends the previous work in this category by handling certain IF conditions. <p> Duesterwald, et al., compute the dependence distance for each reaching definition within a loop [8]. Pugh and Wonnacott <ref> [24] </ref> use a set of constraints to describe array data flow problems and solve them by an extented Fourier-Motzkin variable elimination. Maslov [19], as well as Pugh and Wonnacott [24], extends the previous work in this category by handling certain IF conditions. Generally, these approaches are intraprocedural and do not seem easy to extend interprocedurally. The other class of approaches summarizes the array elements accessed by a set of array references instead of analyzing individual array references.
Reference: 25. <author> Rosene, C. </author> <year> (1990). </year> <title> Incremental Dependence Analysis. </title> <type> Technical report, CRPC-TR90044, PhD thesis, </type> <institution> Computer Science Department, Rice University. </institution>
Reference-contexts: Some previous approaches such as [18] use a list of references as a set representation to avoid union operations and thus maintain exact summary information. 4 2.2 Array Data Flow Summaries Recently, array data flow summaries, which analyze the intervening array kills, have been investigated <ref> [11, 25, 17, 29, 14, 7] </ref>. In these array data flow summaries, sets of upward exposed array uses (UE sets), which cannot be calculated without considering the effects of array kills, are calculated in addition to MOD and USE sets. <p> This class extends data structures designed by the early works for flow-insensitive array problems, such as regular array sections [5, 15], convex regions [27, 28], and data access descriptors [2]. Array data flow analysis in this class includes works done by Gross and Steenkiste [11], Rosene <ref> [25] </ref>, Li [17], Tu and Padua [29], Creusillet and Irigoin [7], and M. Hall, et al. [14]).
Reference: 26. <author> Cheatham, T.E. Jr, Holloway, G.H., Townley, J.A. </author> <year> (1979). </year> <title> Symbolic Evaluation and the Analysis of Programs. </title> <journal> IEEE Trans.on Software Engineering, July, </journal> <volume> 5(4) </volume> <pages> 402-417. </pages>
Reference-contexts: We define a new canonical form to represent predicates in order to simplify pattern matching needed to check whether two predicates are identical. Both conjunctive normal form (CNF) and disjunctive normal form (DNF) have been widely used in program analysis <ref> [26, 6] </ref>. These cited works show that negation operations are expensive with both CNF and DNF. Our previous experiments using CNF [12] also confirm their observations. Negation operations occur not only due to ELSE branches, but also due to GAR and GARWD operations elsewhere. <p> It is widely used in symbolic evaluation and abstract interpretation techniques to discover program properties such as values of expressions, relationships between symbolic expressions, etc. Symbolic analysis requires to represent and manipulate unknown symbolic terms. A symbolic analyzer can adopt a certain normalized form to represent expressions <ref> [26, 6, 13] </ref>. The advantage of such a normalized form is that it gives the same representation for two congruent expressions, i.e. they always have the same value. For example, x (x + 1) and x + x 2 are congruent expressions.
Reference: 27. <author> Triolet, R., Irigoin, F., Feautrier, P. </author> <year> (1986). </year> <title> Direct Parallelization of CALL Statments. </title> <booktitle> ACM SIGPLAN'86 Sym. on Compiler Construction, </booktitle> <address> Palo Alto, CA, </address> <month> July, </month> <pages> 176-185. </pages>
Reference-contexts: Data dependences involving routine calls can be tested by intersecting these sets. Existing approaches can be categorized according to methods of set representation. Convex regions <ref> [27, 28] </ref> and data access descriptors [2] define sets by a system of inequalities and equalities, while bounded regular sections [5, 15] use range tuples to represent sets. <p> Such an over-approximation set is also called a may set. To understand these summary schemes, we will briefly discuss the following two aspects: set representations and summaries of multiple array references over multiple control branches. A. Set representations Several set representations have been proposed so far, including convex regions <ref> [27, 28] </ref>, data access descriptors [2] and bounded regular sections (for simplicity, we refer to this as regular sections when there is no confusion) [5, 15]. <p> The other class of approaches summarizes the array elements accessed by a set of array references instead of analyzing individual array references. This class extends data structures designed by the early works for flow-insensitive array problems, such as regular array sections [5, 15], convex regions <ref> [27, 28] </ref>, and data access descriptors [2]. Array data flow analysis in this class includes works done by Gross and Steenkiste [11], Rosene [25], Li [17], Tu and Padua [29], Creusillet and Irigoin [7], and M. Hall, et al. [14]).
Reference: 28. <author> Triolet, R. </author> <year> (1985). </year> <title> Interprocedural Analysis for Program Restructuring with Parafrase. </title> <type> Technical report, </type> <institution> Center for Supercomputing Research and Development, University of Illinois at Urbana-Champaign. </institution>
Reference-contexts: Data dependences involving routine calls can be tested by intersecting these sets. Existing approaches can be categorized according to methods of set representation. Convex regions <ref> [27, 28] </ref> and data access descriptors [2] define sets by a system of inequalities and equalities, while bounded regular sections [5, 15] use range tuples to represent sets. <p> Such an over-approximation set is also called a may set. To understand these summary schemes, we will briefly discuss the following two aspects: set representations and summaries of multiple array references over multiple control branches. A. Set representations Several set representations have been proposed so far, including convex regions <ref> [27, 28] </ref>, data access descriptors [2] and bounded regular sections (for simplicity, we refer to this as regular sections when there is no confusion) [5, 15]. <p> The other class of approaches summarizes the array elements accessed by a set of array references instead of analyzing individual array references. This class extends data structures designed by the early works for flow-insensitive array problems, such as regular array sections [5, 15], convex regions <ref> [27, 28] </ref>, and data access descriptors [2]. Array data flow analysis in this class includes works done by Gross and Steenkiste [11], Rosene [25], Li [17], Tu and Padua [29], Creusillet and Irigoin [7], and M. Hall, et al. [14]).
Reference: 29. <author> Tu, P., Padua, D. </author> <year> (1993). </year> <title> Automatic Array Privatization. </title> <booktitle> Proceedings of Sixth Workshop on Languages and Compilers for Parallel Computing, </booktitle> <address> Portland, OR, </address> <month> August, </month> <pages> 500-521. </pages>
Reference-contexts: Therefore, these methods are insufficient for optimization such as array privatization. Recently, flow-sensitive summary, or array data flow summary, has been a focus in the parallelizing compiler area. The most essential information in array data flow summary is the upward exposed use (UE) set <ref> [7, 29, 17, 14, 12] </ref>. Our work [12] and that of M. <p> Some previous approaches such as [18] use a list of references as a set representation to avoid union operations and thus maintain exact summary information. 4 2.2 Array Data Flow Summaries Recently, array data flow summaries, which analyze the intervening array kills, have been investigated <ref> [11, 25, 17, 29, 14, 7] </ref>. In these array data flow summaries, sets of upward exposed array uses (UE sets), which cannot be calculated without considering the effects of array kills, are calculated in addition to MOD and USE sets. <p> Array data flow analysis in this class includes works done by Gross and Steenkiste [11], Rosene [25], Li [17], Tu and Padua <ref> [29] </ref>, Creusillet and Irigoin [7], and M. Hall, et al. [14]). The 23 work described in this chapter seems to be the only one which considers the effect of IF conditions in a general way, although some previous works also handle IF conditions under more limited circumstances.
Reference: 30. <author> Wolfe, M. </author> <year> (1996). </year> <title> High Performance Compilers for Parallel Computing. </title> <publisher> Addison-Wesley Publishing Company. </publisher> <pages> 26 </pages>
Reference-contexts: Let M OD s be the set of all elements of A that are modified by S and U SE s the set of all elements of A that are used by S. The dependences between S 1 and S 2 can be determined by the following set operations <ref> [30] </ref>: flow dependence: iff M OD s1 " U SE s2 6= ;. anti- dependence: iff M OD s2 " U SE s1 6= ;. output dependence: iff M OD s1 " M OD s2 6= ;.
References-found: 30

