URL: http://www.cs.toronto.edu/~chechik/pubs/diss.ps
Refering-URL: http://www.cs.toronto.edu/~chechik/publications.html
Root-URL: 
Title: AUTOMATIC ANALYSIS OF CONSISTENCY BETWEEN REQUIREMENTS AND DESIGNS  
Author: Maria "Marsha" A. Chechik, 
Degree: Doctor of Philosophy, 1996 Dissertation directed by: Professor John Gannon  
Affiliation: Department of Computer Science  
Note: ABSTRACT Title of Dissertation:  
Abstract: Writing requirements in a formal notation permits automatic assessment of such properties as ambiguity, consistency, and completeness. However, verifying that the properties expressed in requirements are preserved in other software life cycle artifacts remains difficult. This dissertation describes methods and tools for automatically analyzing the consistency of software requirements and detailed designs. Requirements describe systems as state machines with event-driven transitions using a specification language that is easy to read and scalable to large systems. We have defined consistency between requirements and detailed designs to be that exactly the same transitions and global safety properties specified in the requirements are preserved in the designs. To judge global properties like these, we determine the possible system states which exist at different points in designs. The detailed bookkeeping necessary to do this exceeds the capabilities of human reviewers for all but small systems. 
Abstract-found: 1
Intro-found: 1
Reference: [ABB + 96] <author> Richard J. Anderson, Paul Beame, Steve Burns, William Chan, Frances-mary Modugno, David Notkin, and Jon Reese. </author> <title> "Model Checking Large Software Specifications". </title> <booktitle> In Proceedings of FSE'96 Foundations on Software Engineering, </booktitle> <month> October </month> <year> 1996. </year> <note> (To appear). </note>
Reference-contexts: However, the entire state space of the model is constructed before the fixed point algorithms can be applied. Various improvements to the original technology allows for efficient checking of large systems [BCM + 90, CGL92, McM93]. The problems successfully solved by model checking are mostly specifications 68 of systems <ref> [Jac94, SA96, ABB + 96] </ref> and hardware designs [CES86, CGH + 93, BCDM86, MS92, Bar95].
Reference: [AFB + 88] <author> T. Alspaugh, S. Faulk, K. Britton, R. Parker, D. Parnas, and J. Shore. </author> <title> "Software Requirements for the A-7E Aircraft". </title> <type> Technical report, </type> <institution> Naval Research Laboratory, </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: Formal methods play a big role in this effort. A number of formal requirements notations (e.g. the Software Cost Reduction (SCR) notation <ref> [AFB + 88, Hen80] </ref> and the Requirements State Machine Language (RSML)[JLHM91]) have been used to write requirements for realistic applications and analyze their completeness and consistency [HBGL95, RPRL96, HL95]. Verifying that designs and implementations preserve the "correctness" of requirements is not easy. <p> Another way to represent requirements is to describe how control and data should flow among components of the system. The SCR requirements notation was developed by a research group at the Naval Research Laboratory as part of the Software Cost Reduction project <ref> [AFB + 88, Hen80] </ref>. The project resulted in SCR requirements and design standards, as well as guidelines for software development using SCR. <p> These types of user-specified properties frequently appear in requirements documents, and during our case studies we did not need to verify any other types of properties. Requirements specifications of realistic size and complexity (like <ref> [AFB + 88] </ref>), however, contain global properties which cannot be expressed using only these assertions. We defer a further discussion of this issue until Chapter 4. 25 2.5 Example - SWLMS Consider a simple Water-Level Monitoring System (SWLMS). A switch controls whether the system is on or off. <p> Numbers in parentheses indicate the number of modes in each modeclass, e.g. 2 (4, 3) indicates that the problem consists of two modeclasses, with 4 and 3 modes each. The variables in specification of A-7E aircraft <ref> [AFB + 88] </ref> refer to just monitored variables. 60 Boolean variables 5 10 25 50 69 Modeclasses 1 (3) 2 (2, 3) 2 (4, 3) 3 (4, 5, 6) 3 (6, 17, 18) Comments SWLMS WLMS A-7 Spec (Chapter 5) H exact 729 708588 1:69 fi 10 13 1:5 fi 10
Reference: [AG93] <author> J.M. Atlee and J. Gannon. </author> <title> "State-Based Model Checking of Event-Driven System Requirements". </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 22-40, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Automated techniques have been used to derive a finite-state representation of a set of tabular requirements, and determine if it is a model for system safety properties expressed as temporal logic assertions <ref> [AG93] </ref>. This dissertation presents a complementary technique which automatically compares properties derived from a set of requirements with a finite state representation of a system's detailed design. <p> The requirements included four user-defined safety properties, identical to those 102 used in <ref> [AG93] </ref>: U 1 = cause (SlfTstPressed500, Normal (Test)) U 2 = wmi (Normal=Standby, :SlfTstPressed500) U 3 = wmi (Normal=Operating, (:SlfTstPressed500 ^ (WithinLimits _ SlfTstPressed))) U 4 = wmi (Normal=Shutdown, (:SlfTstPressed500 ^ ((:InsideHysR ^ :ShutdownLockTime200) _ :SlfTstPressed))) If the SelfTest button has been pressed for 500ms or more, the system is either
Reference: [All83] <author> J.F. Allen. </author> <title> "Maintaining Knowledge about Temporal Intervals". </title> <journal> Communications of ACM, </journal> <volume> 26(11), </volume> <month> November </month> <year> 1983. </year>
Reference-contexts: RTL has been further extended (to RTTL) to describe temporal distance [Ost89b]. Several temporal logics have been developed to describe real-time systems. Linear-time semantics (e.g., [Pnu77, MP90, MP92]) describe particular executions of a system, whereas branching-time semantics (e.g., [EH86, CES86]) describe all possible executions. Interval-time semantics (e.g., <ref> [SMS82, All83] </ref>) are used to express conditions that hold for some nonzero time interval. UNITY [CM88] is a framework for specification and verification that uses extended state-transition systems to model abstract programs in a similar logic.
Reference: [ASU88] <author> A. Aho, R. Sethi, and J. Ulman. </author> <booktitle> Compilers: Principles, Techniques, and Tools, Chapter 10. </booktitle> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference-contexts: do not keep track of previous values of conditions. 3.2 Creating a Design Flow Graph 3.2.1 Overview of the Approach We construct a Design-Flow Graph (DFG) from annotations and control-flow information of the design and then propagate the state information throughout the DFG, in a manner similar to data-flow analysis <ref> [ASU88] </ref>. The rest of this section describes the pro 45 cess we use to construct a set-based approximation of attainable values of requirements variables for each node of a DFG. <p> computation of system states at each node of the DFG is similar to that of constant propagation a compiler technique whose goal is to discover values that are constant for all possible executions of a program and to propagate these constant values as far forward through the program as possible <ref> [WZ91, ASU88] </ref>. <p> Computation of system states at each node of the CDFG is performed using dataflow techniques <ref> [ASU88, GS93, 120 LC91] </ref> similar to those described in Section 3.2. We extend these techniques to include synchronization information. First, we compute information generated and known at every node. Read and Write nodes do not generate new information, and thus their gen and known sets are EMPTY.
Reference: [Atl92] <author> J. Atlee. </author> <title> "Automated Analysis of Software Requirements". </title> <type> PhD thesis, </type> <institution> University of Maryland, College Park, Maryland, </institution> <month> December </month> <year> 1992. </year>
Reference-contexts: The specification language is precise, can be understood by engineers and software developers, and is easy to use and modify. The initial language lacked an underlying formal semantics. A number of semantics have been proposed <ref> [Atl92, HLK95, Fau89, PM91, van90] </ref>, some of which [HLK95, PM95] became bases of tools automating consistency and completeness checks [HL93] and simulations [CHLR93, PW94] of requirements. <p> As such, assumptions are invariant constraints that must hold in all system states. For example, the water in a container cannot be too high and too low at the same time, and buttons can be either pressed or released but not both. <ref> [Atl92] </ref> identified several types of assumptions on environmental conditions and described their syntax and semantics. <p> Some of the relations that an enumeration a 0 j a 1 j a 2 results in are shown below: a 1 ! (:a 2 ^ :a 3 ) a 3 ! (:a 1 ^ :a 2 ) For an algorithm to enforce these relations, please refer to Section 3.2.5. <ref> [Atl92] </ref> also identified a number of other relations. The assumptions about environmental conditions can be found in the section of an SCR requirements document that describes the system's controlled and monitored variables. <p> These goals may be mode invariants or reachability information, express global behavioral requirements on the occurrence of an event, or represent temporal properties. <ref> [Atl92] </ref> introduces a simple language for capturing some of these global properties compactly. <p> Analyzer's user interface automatically translates the tabular specifications, the condition relationships and the global properties into an ASCII representation acceptable by the analysis engine (see Appendix A.2). 3. Tools like tcart <ref> [Atl92] </ref> are used to verify that the global properties hold in the requirements. 4. A (human) designer provides a detailed design of the system using a special program design language (see Appendix B). 5. <p> The rest of this appendix is organized as follows: Section A.1 describes the front-end to Analyzer and uses SWLMS to show how the interface looks like. Section A.2 gives the BNF grammar of SCR. This grammar was largely borrowed from <ref> [Atl92] </ref> and modified to process controlled variables. Finally, Section A.3 gives ASCII representations of requirements of systems described in this dissertation. A.1 Tool Interface Front-end for Analyzer was created to specify requirements for systems to be processed.
Reference: [Bar89] <author> Geoff Barrett. </author> <title> "Formal Methods Applied to a Floating-Point Number System". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(5) </volume> <pages> 611-621, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: IBM used Z in the development of a major new release of its transaction processing system CICS [HK91]. A semiconductor manufacturer Inmos used formal methods in the development of a floating point unit for the T800 Transputer <ref> [Bar89] </ref>. A formal specification and verification effort [MSS82] was associated with the Software Implemented Fault Tolerance (SIFT) project [ea78], aimed at development of a fault-tolerant computer for fly-by-wire passenger aircraft.
Reference: [Bar95] <author> G. Barrett. </author> <title> "Model Checking in Practice: The t9000 Virtual Channel Processor". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 69-78, </pages> <month> Febru-ary </month> <year> 1995. </year>
Reference-contexts: LOTOS languages and tools were used to specify and model software for the Flight Warning Computer (FWC) of the Airbus 330 and 340 aircraft [GH93a]. 10 In a more recent project, model-checking techniques have been applied to verify the t900 Virtual Channel Processor <ref> [Bar95] </ref>. 1.5 Overview of Dissertation Software quality can be improved by eliminating errors arising from inconsistencies within the description of a system or between two different descriptions of a system. <p> Various improvements to the original technology allows for efficient checking of large systems [BCM + 90, CGL92, McM93]. The problems successfully solved by model checking are mostly specifications 68 of systems [Jac94, SA96, ABB + 96] and hardware designs <ref> [CES86, CGH + 93, BCDM86, MS92, Bar95] </ref>.
Reference: [BB87] <author> T. Bolognesi and E. Brinksma. </author> <title> "Introduction to the ISO specification language LOTOS". </title> <journal> Computer Networks and ISDN Systems, </journal> <volume> 14 </volume> <pages> 25-59, </pages> <year> 1987. </year>
Reference-contexts: This technique is called bisimulation. Process algebras able to express timing properties include: CSR [Ger91, GL92] and ACSR [PGJI93], which adds time to CCS; Timed CSP [RR87], an extension of CSP; 7 Timed LOTOS <ref> [BB87] </ref>, an extension of the ISO standard LOTOS; and a timed version of ACP [JJ91]. 1.3.2 Analysis Techniques Common analysis techniques can be divided into three broad classes: model-theoretic reasoning, proof-theoretic reasoning, and simulation.
Reference: [BCDM86] <author> M.C. Browne, E.M. Clarke, D.L. Dill, and B. Mishra. </author> <title> "Automatic Verification of Sequential Circuits using Temporal Logic". </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(12):1035-1044, </volume> <year> 1986. </year>
Reference-contexts: Various improvements to the original technology allows for efficient checking of large systems [BCM + 90, CGL92, McM93]. The problems successfully solved by model checking are mostly specifications 68 of systems [Jac94, SA96, ABB + 96] and hardware designs <ref> [CES86, CGH + 93, BCDM86, MS92, Bar95] </ref>.
Reference: [BCM + 90] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.J. Dill, and L.J. Hwang. </author> <title> "Symbolic Model Checking: 10 20 States and Beyond". </title> <booktitle> In Proceedings of the Fifth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Unfortunately, models of real systems have very large numbers of states. A number of approaches have been developed to handle the "state explosion problem". Unreachable and impossible states are pruned [CG87], large sets of states are described symbolically <ref> [BCM + 90] </ref>, data-structures like Binary Decision Diagrams (BDDs)[Bry86, Bry92] are used to store and analyze complex boolean formulae efficiently, and techniques are created to analyze subsets of the model and then combine the results of the analysis [CLM89]. <p> <ref> [BCM + 90] </ref>, data-structures like Binary Decision Diagrams (BDDs)[Bry86, Bry92] are used to store and analyze complex boolean formulae efficiently, and techniques are created to analyze subsets of the model and then combine the results of the analysis [CLM89]. Current model checkers can verify some systems with 10 130 states [BCM + 90]. Model checkers have been most effectively applied to verification of hardware and protocol specifications. For example, a Symbolic Logic Verifier (SMV) [McM93] was used to detect several errors in the Futurebus+ Cache Coherency Protocol, an IEEE standard. A number of model-theoretic approaches incorporated analysis of real-time properties. <p> However, the entire state space of the model is constructed before the fixed point algorithms can be applied. Various improvements to the original technology allows for efficient checking of large systems <ref> [BCM + 90, CGL92, McM93] </ref>. The problems successfully solved by model checking are mostly specifications 68 of systems [Jac94, SA96, ABB + 96] and hardware designs [CES86, CGH + 93, BCDM86, MS92, Bar95].
Reference: [BD91] <author> B. Berthomieu and M. Diaz. </author> <title> "Modeling and Verification of Time Dependent Systems Using Time Petri Nets". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(3) </volume> <pages> 259-273, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: A Petri net is an operational formalism, supporting a notion of state and its evolution. Specifications expressed in this notation are executable, and verification is based on building a reachability graph (as in the Berthomieu-Diaz algorithm <ref> [BD91] </ref>). Two extensions, time Petri nets [MS76] and timed Petri nets (TPNs) [Ram74] were introduced for modeling time. Levenson and Stolzy [LS87] use TPNs for safety analysis, without having to generate the entire reachability graph, by working backward from hazardous states to determine if these states are reachable.
Reference: [BdS91] <author> F. Boussinot and R. de Simone. </author> <title> "The Estrel Language". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 79(9) </volume> <pages> 1293-1304, </pages> <month> September </month> <year> 1991. </year> <month> 186 </month>
Reference-contexts: Other systems are described by textual notations. The Timed Automaton Model [LT88, LV91, MMT91] extends state machines with a notion of dense time. This 6 model has an infinite number of states, where time is added to the usual state machine model via a special "time passage" action. Estrel <ref> [BdS91, BG92] </ref> is one of the family of languages used to describe real-time systems using the state machine model. These languages have been applied to a number of industrial projects, especially in the fields of nuclear plant safety and avionics [LRD95].
Reference: [BF91] <author> R. Butler and G. Finelli. </author> <title> "The Infeasibility of Experimental Quantifica--tion of Life-Critical Software Reliability". </title> <booktitle> In Proceedings of the ACM SIG-SOFT'91 Conference on Software for Critical Systems, </booktitle> <pages> pages 66-76, </pages> <year> 1991. </year>
Reference-contexts: This technique allows the user to ensure that the specification captures the intended system behavior. Unfortunately, evaluating software requirements via execution has the same drawbacks as testing; namely, the 9 number of test cases needed to cover a specification is unmanageably large for all but the smallest systems <ref> [BF91] </ref>. 1.4 Industrial Applications of Formal Methods Formal methods can contribute to the development of systems in two ways [Rus93]: 1. they can improve the development process, leading to a better product, and/or reduced time and cost; or 2. they can contribute to the assurance and certification of a system.
Reference: [BG92] <author> G. Berry and G. Gonthier. </author> <title> "The Estrel Synchronous Programming Language: Design, Semantics, </title> <booktitle> Implementation". Science of Computer Programming, </booktitle> <volume> 19(2), </volume> <year> 1992. </year>
Reference-contexts: Other systems are described by textual notations. The Timed Automaton Model [LT88, LV91, MMT91] extends state machines with a notion of dense time. This 6 model has an infinite number of states, where time is added to the usual state machine model via a special "time passage" action. Estrel <ref> [BdS91, BG92] </ref> is one of the family of languages used to describe real-time systems using the state machine model. These languages have been applied to a number of industrial projects, especially in the fields of nuclear plant safety and avionics [LRD95].
Reference: [BK85] <author> J. Bergstra and J. Klop. </author> <title> "Algebra of Communicating Processes with Abstraction". </title> <journal> Journal of Theoretical Computer Science, </journal> <volume> 37 </volume> <pages> 77-121, </pages> <year> 1985. </year>
Reference-contexts: These languages have been applied to a number of industrial projects, especially in the fields of nuclear plant safety and avionics [LRD95]. Process algebras Process algebras were developed to specify and analyze concurrent systems. The original versions, such as CCS [Mil89], CSP [Hoa85] and ACP <ref> [BK85] </ref>, were untimed.
Reference: [BM88] <author> R. Boyer and J. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: Proof-theoretic techniques can handle more abstract models and produce more general results than model-checking. Deductive reasoning can be applied to any model, not necessarily a finite-state machine. A number of mechanical proof systems have been developed: the Boyer-Moore theorem prover <ref> [BM88] </ref>, EVES [KPS + 93], and the Larch Prover (LP) [GHW85, GH93b] are based on first-order logic; and HOL [Gor88] and PVS [OSR93] are based on higher-order logic. These systems do some proofs automatically, although most non-trivial proofs require user guidance.
Reference: [Bro87] <author> Frederick P. Brooks. </author> <title> "No Silver Bullet: Essence and Accidents of Software Engineering". </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 10-19, </pages> <month> April </month> <year> 1987. </year>
Reference-contexts: Our PDL was motivated by a number of factors: * Designs should look like real programs, i.e. specify control flow via programming language constructs for sequence, selection, and iteration. * Designs should capture the essence of what is happening in the code, rather than details <ref> [Bro87] </ref>.
Reference: [Bry86] <author> R. E. Bryant. </author> <title> "Graph-based algorithms for boolean function manipulation.". </title> <journal> Transactions on Computers, </journal> <volume> 8(C-35):677-691, </volume> <year> 1986. </year>
Reference: [Bry92] <author> Randal E. Bryant. </author> <title> "Symbolic Boolean manipulation with ordered binary-decision diagrams". </title> <journal> Computing Surveys, </journal> <volume> 24(3) </volume> <pages> 293-318, </pages> <month> September </month> <year> 1992. </year>
Reference: [BS93] <author> J. Bowen and V. Stavridou. </author> <title> "Safety-Critical Systems, Formal Methods and Standards". </title> <journal> Software Engineering Journal, </journal> <volume> 8(6) </volume> <pages> 189-209, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: Although useful for specifying a variety of types of computer systems, precise documentation is essential for safety-critical systems <ref> [BS93] </ref>. 1.1 Safety-Critical Systems Safety-critical systems are "systems where compelling evidence is required that the system delivers its services in manner that satisfies certain critical properties"[HBGL95].
Reference: [CC76] <author> Patrick Cousot and Radhia Cousot. </author> <title> "Static Determination of Dynamic Properties of Programs". </title> <booktitle> In Proceedings of the "Colloque sur la Program-mation", </booktitle> <month> April </month> <year> 1976. </year>
Reference-contexts: 2 E iff v 2 can immediately follow v 1 in some execution sequence; and V 0 2 V is an entry node. 3.2.2 Set-Based Approach We interpret annotations in the design to create a set-based approximation of attainable values for each requirements' variable at each node of the DFG <ref> [CC76, CC77a] </ref>. This means that we are interested in only those variables which are specified in the requirements, and that each variable is associated with a set of values it may attain if the control reaches that node. <p> If the system could have an infinite increasing chain of values, the fixed point could not be achieved in a finite number of steps using data-flow techniques. This problem can be solved using another technique, abstract interpretation <ref> [CC76, CC77b] </ref>. We assume that all variables are initialized by the Initial annotation.
Reference: [CC77a] <author> Patrick Cousot and Radhia Cousot. </author> <title> "Abstract Interpretation: A Unified Lattice Model For Static Analysis of Programs by Construction or Approximation of Fixpoints". </title> <booktitle> In Proceedings of the 4th POPL, </booktitle> <pages> pages 238-252, </pages> <address> Los Angeles, California, </address> <year> 1977. </year>
Reference-contexts: 2 E iff v 2 can immediately follow v 1 in some execution sequence; and V 0 2 V is an entry node. 3.2.2 Set-Based Approach We interpret annotations in the design to create a set-based approximation of attainable values for each requirements' variable at each node of the DFG <ref> [CC76, CC77a] </ref>. This means that we are interested in only those variables which are specified in the requirements, and that each variable is associated with a set of values it may attain if the control reaches that node.
Reference: [CC77b] <author> Patrick Cousot and Radhia Cousot. </author> <title> "Static Determination of Dynamic Properties of Generalized Type Unions". </title> <journal> SIGPLAN Notices, </journal> <volume> 12(3), </volume> <month> March </month> <year> 1977. </year>
Reference-contexts: If the system could have an infinite increasing chain of values, the fixed point could not be achieved in a finite number of steps using data-flow techniques. This problem can be solved using another technique, abstract interpretation <ref> [CC76, CC77b] </ref>. We assume that all variables are initialized by the Initial annotation.
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. "Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications". </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: RTL has been further extended (to RTTL) to describe temporal distance [Ost89b]. Several temporal logics have been developed to describe real-time systems. Linear-time semantics (e.g., [Pnu77, MP90, MP92]) describe particular executions of a system, whereas branching-time semantics (e.g., <ref> [EH86, CES86] </ref>) describe all possible executions. Interval-time semantics (e.g., [SMS82, All83]) are used to express conditions that hold for some nonzero time interval. UNITY [CM88] is a framework for specification and verification that uses extended state-transition systems to model abstract programs in a similar logic. <p> Model-checking Model checkers <ref> [CES86] </ref> take a finite state machine model of a system and a temporal logic formula and determine if the formula holds in the model. The advantage of this approach is that the analysis is fully-automatic and does not require a user to understand sophisticated mathematical techniques like induction. <p> In this chapter we describe how to use the FSM to verify properties generated from SCR specifications. Verification is done by a model-checking algorithm. 4.1 Overview of Model-Checking Introduced by Clarke and Emerson <ref> [CES86] </ref> and by Quielle and Sifakis [QS81], model checking determines the value of a formula f , typically expressed in temporal logic, for a particular system by building its reachability graph M and computing the set of states in which the formula is true, i.e., fs j M; s j= f <p> Various improvements to the original technology allows for efficient checking of large systems [BCM + 90, CGL92, McM93]. The problems successfully solved by model checking are mostly specifications 68 of systems [Jac94, SA96, ABB + 96] and hardware designs <ref> [CES86, CGH + 93, BCDM86, MS92, Bar95] </ref>.
Reference: [CG75] <author> S.H. Caine and E.K. Gordon. </author> <title> "PDL: A Tool for Software Design". </title> <booktitle> In Proceedings of the National Computer Conference, </booktitle> <volume> volume 44, </volume> <pages> pages 271-276, </pages> <year> 1975. </year>
Reference-contexts: When writing designs, we want to reason about requirements-level variables rather than implementation-level structures. * Finally, designs should be able to deal with sensors and actuators of the system, i.e., with IN and OUT relations (see Chapter 2 and [PM95]). 38 3.1.1 Design Constructs Typically, control-flow-based PDLs <ref> [CG75] </ref> are defined by an outer syntax of control structures and inner syntax of other statements. Our PDL's outer syntax is a set of 39 C-like control structures. Our inner syntax consists of annotations special statements describing values of requirements variables.
Reference: [CG87] <author> E.M. Clarke and O. Grumberg. </author> <title> "Avoiding The State Explosion Problem in Temporal Logic Model Checking Algorithms". </title> <booktitle> In ??, pages 293-303, </booktitle> <year> 1987. </year> <month> 187 </month>
Reference-contexts: Unfortunately, models of real systems have very large numbers of states. A number of approaches have been developed to handle the "state explosion problem". Unreachable and impossible states are pruned <ref> [CG87] </ref>, large sets of states are described symbolically [BCM + 90], data-structures like Binary Decision Diagrams (BDDs)[Bry86, Bry92] are used to store and analyze complex boolean formulae efficiently, and techniques are created to analyze subsets of the model and then combine the results of the analysis [CLM89].
Reference: [CG94] <author> M. Chechik and J. Gannon. </author> <title> "Automatic Verification of Requirements Im--plementations". </title> <booktitle> In Proceedings of the 1994 International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <pages> pages 1-14, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: In this paper, we define a notation which can be used as a PDL and describe a prototype tool, called Analyzer <ref> [CG94, CG95] </ref>, which automatically determines if a 11 design written in PDL is consistent with its requirements. The inputs to our tool are a tabular requirements specification and a detailed design written in PDL.
Reference: [CG95] <author> M. Chechik and J. Gannon. </author> <title> "Automatic Analysis of Consistency Between Implementations and Requirements: A Case Study". </title> <booktitle> In Proceedings of 10th Annual Conference on Computer Assurance, </booktitle> <pages> pages 123-131, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: In this paper, we define a notation which can be used as a PDL and describe a prototype tool, called Analyzer <ref> [CG94, CG95] </ref>, which automatically determines if a 11 design written in PDL is consistent with its requirements. The inputs to our tool are a tabular requirements specification and a detailed design written in PDL.
Reference: [CGH + 93] <author> E.M. Clarke, O. Grumberg, H. Hiraishi, S. Jha, D. Long, K.L. McMillan, and L.A. Ness. </author> <title> "Verification of the Futurebus+ Cache Coherence Protocol". </title> <booktitle> In Proceedings of CHDL, </booktitle> <year> 1993. </year>
Reference-contexts: Various improvements to the original technology allows for efficient checking of large systems [BCM + 90, CGL92, McM93]. The problems successfully solved by model checking are mostly specifications 68 of systems [Jac94, SA96, ABB + 96] and hardware designs <ref> [CES86, CGH + 93, BCDM86, MS92, Bar95] </ref>.
Reference: [CGL92] <author> Edmind M. Clarke, Orna Grumberg, and David E. </author> <title> Long. "Model Checking and Abstraction". </title> <booktitle> In Proceedings of the Ninth Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 343-354, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: However, the entire state space of the model is constructed before the fixed point algorithms can be applied. Various improvements to the original technology allows for efficient checking of large systems <ref> [BCM + 90, CGL92, McM93] </ref>. The problems successfully solved by model checking are mostly specifications 68 of systems [Jac94, SA96, ABB + 96] and hardware designs [CES86, CGH + 93, BCDM86, MS92, Bar95]. <p> Aspect's [Jac92, Jac93a, Jac93b] specification notation permits users to write pre-and postconditions about the data dependencies of an operation. Dataflow analysis is used to compute an upper bound on the data dependencies of the implementation. If an asserted dependency is missing, an error is reported. Clarke et al. <ref> [CGL92] </ref> also create abstract, finite state models of programs, and use model checking techniques to verify formulas. Programs written in a special finite-state programming language are translated into relational expressions characterizing the program's initial state and transition relation.
Reference: [CGR95] <author> D. Craigen, S. Gerhart, and T. Ralston. </author> <title> "Formal Methods Reality Check: Industrial Usage". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 90-98, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: Several industrial projects successfully used formal methods <ref> [CGR95] </ref>. For example, SCR methods have been applied to A-7 Operational Flight Control Program [Hen80], a submarine communication system [HM83] and safety-critical components of the Dar-lington nuclear power plant in Canada [vPM93]. The SACEM project used Hoare-style proofs to verify a one-line commuter train network in Paris [GH90] .
Reference: [CHK92] <author> Keith D. Cooper, Mary W. Hall, and Ken Kennedy. </author> <title> "Procedure Cloning". </title> <booktitle> In Proceedings of IEEE International Conference on Computer Languages, </booktitle> <pages> pages 96-105, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: However, since designs usually consist of several procedures, we need to extend our analysis technique to process these designs. We perform interprocedural analysis using an adaptation of a technique called cloning <ref> [CHK92] </ref>. A similar algorithm was described in [Weg75]. This technique enables Analyzer to analyze each called function only a constant number of times, and to achieve reasonable precision in the analysis.
Reference: [CHLR93] <author> P. Clements, C. Heitmeyer, B. Labaw, and A. Rose. </author> <title> "MT: A Toolset for Specifying and Analyzing Real-time Systems". </title> <booktitle> In Proceedings of Real-Time Systems Symposium, </booktitle> <address> Raleigh, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: These systems do some proofs automatically, although most non-trivial proofs require user guidance. Mechanical proof systems can be very useful in checking hand-proofs, though. Simulation Simulation <ref> [CHLR93] </ref> or specification testing [Kem85] is a form of testing applied to formal requirements. Users experiment with the system specification by providing a set of inputs to the system, and a simulator uses the specification to show how the state of the system changes based on the input. <p> The initial language lacked an underlying formal semantics. A number of semantics have been proposed [Atl92, HLK95, Fau89, PM91, van90], some of which [HLK95, PM95] became bases of tools automating consistency and completeness checks [HL93] and simulations <ref> [CHLR93, PW94] </ref> of requirements.
Reference: [CLM89] <author> E. M. Clarke, D. E. Long, and K. L. McMillan. </author> <title> "Compositional Model Checking". </title> <booktitle> In Proceedings of the Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 464-475, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: impossible states are pruned [CG87], large sets of states are described symbolically [BCM + 90], data-structures like Binary Decision Diagrams (BDDs)[Bry86, Bry92] are used to store and analyze complex boolean formulae efficiently, and techniques are created to analyze subsets of the model and then combine the results of the analysis <ref> [CLM89] </ref>. Current model checkers can verify some systems with 10 130 states [BCM + 90]. Model checkers have been most effectively applied to verification of hardware and protocol specifications.
Reference: [CM88] <author> K.M. Chandy and J. Mishra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <year> 1988. </year>
Reference-contexts: Linear-time semantics (e.g., [Pnu77, MP90, MP92]) describe particular executions of a system, whereas branching-time semantics (e.g., [EH86, CES86]) describe all possible executions. Interval-time semantics (e.g., [SMS82, All83]) are used to express conditions that hold for some nonzero time interval. UNITY <ref> [CM88] </ref> is a framework for specification and verification that uses extended state-transition systems to model abstract programs in a similar logic.
Reference: [CPKM94] <author> A. Coen-Porisini, R. Kemmerer, and D. Mandrioli. </author> <title> "A Formal Framework for ASTRAL Intralevel Proof Obligations". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(8) </volume> <pages> 548-561, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: Most real-time logics describe systems in terms of events, i.e., points of time when something significant occurs. Examples of such systems include Real-Time Logic or RTL [JM86], TRIO [GMM90] and ASTRAL <ref> [CPKM94] </ref>. RTL has been further extended (to RTTL) to describe temporal distance [Ost89b]. Several temporal logics have been developed to describe real-time systems. Linear-time semantics (e.g., [Pnu77, MP90, MP92]) describe particular executions of a system, whereas branching-time semantics (e.g., [EH86, CES86]) describe all possible executions.
Reference: [DC94] <author> Matthew B. Dwyer and Lori A. Clarke. </author> <title> "Data Flow Analysis for Verifying Properties of Concurrent Programs". </title> <booktitle> In Proceedings of the Second ACM SIGSOFT Symposium on Foundations of Software Engineering, </booktitle> <pages> pages 62-75, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: Thus, we are interested in extending our analysis methods to process designs of concurrent programs. Most of the previous approaches to analysis of concurrent programs have generally abstracted away data values and their effects on control flow to concentrate on task interactions (e.g., <ref> [DC94, FG94, LC91, GL92, Tay83, MR91] </ref>). We perform dataflow analysis on values of requirements variables and include them in the property verification, without building a global reachability graph. In this chapter we use a simple example to introduce new extensions to the requirements and the design languages.
Reference: [ea78] <editor> John H. Wensley et al. "SIFT: </editor> <title> Design and Analysis of a Fault-Tolerant Computer for Aircraft Control". </title> <booktitle> Proceedings of IEEE, </booktitle> <volume> 66(10) </volume> <pages> 1240-1255, </pages> <month> October </month> <year> 1978. </year>
Reference-contexts: A semiconductor manufacturer Inmos used formal methods in the development of a floating point unit for the T800 Transputer [Bar89]. A formal specification and verification effort [MSS82] was associated with the Software Implemented Fault Tolerance (SIFT) project <ref> [ea78] </ref>, aimed at development of a fault-tolerant computer for fly-by-wire passenger aircraft.
Reference: [EH86] <author> E. Allen Emerson and Joseph Y. Halpern. </author> <title> ""Sometimes" and "Not Never" Revisited: On Branching versus Linear Time Temporal Logic". </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 33(1) </volume> <pages> 151-178, </pages> <month> January </month> <year> 1986. </year> <month> 188 </month>
Reference-contexts: RTL has been further extended (to RTTL) to describe temporal distance [Ost89b]. Several temporal logics have been developed to describe real-time systems. Linear-time semantics (e.g., [Pnu77, MP90, MP92]) describe particular executions of a system, whereas branching-time semantics (e.g., <ref> [EH86, CES86] </ref>) describe all possible executions. Interval-time semantics (e.g., [SMS82, All83]) are used to express conditions that hold for some nonzero time interval. UNITY [CM88] is a framework for specification and verification that uses extended state-transition systems to model abstract programs in a similar logic.
Reference: [Fau89] <author> Stuart Faulk. </author> <title> "State Determination in Hard-Embedded Systems". </title> <type> PhD thesis, </type> <institution> University of North Carolina, Chapel Hill, </institution> <year> 1989. </year>
Reference-contexts: The specification language is precise, can be understood by engineers and software developers, and is easy to use and modify. The initial language lacked an underlying formal semantics. A number of semantics have been proposed <ref> [Atl92, HLK95, Fau89, PM91, van90] </ref>, some of which [HLK95, PM95] became bases of tools automating consistency and completeness checks [HL93] and simulations [CHLR93, PW94] of requirements.
Reference: [FG94] <author> Jeffrey Fischer and Richard Gerber. </author> <title> "Compositional Model Checking of Ada Tasking Programs". </title> <booktitle> In Proceedings of the Ninth Annual IEEE Conference on Computer Assurance, </booktitle> <month> June </month> <year> 1994. </year>
Reference-contexts: Thus, we are interested in extending our analysis methods to process designs of concurrent programs. Most of the previous approaches to analysis of concurrent programs have generally abstracted away data values and their effects on control flow to concentrate on task interactions (e.g., <ref> [DC94, FG94, LC91, GL92, Tay83, MR91] </ref>). We perform dataflow analysis on values of requirements variables and include them in the property verification, without building a global reachability graph. In this chapter we use a simple example to introduce new extensions to the requirements and the design languages.
Reference: [Flo67] <author> R. Floyd. </author> <title> "Assigning Meanings to Programs". </title> <editor> In J. Schwartz, editor, </editor> <booktitle> Symposium on Applied Mathematics: Mathematical Aspects of Computer Science, </booktitle> <volume> volume 19, </volume> <pages> pages 254-255. </pages> <publisher> American Mathematical Society, </publisher> <address> New York, </address> <year> 1967. </year>
Reference-contexts: Logic-based models Mathematical logic has been used to specify and prove properties about programs <ref> [Hoa69, Flo67] </ref>. Using logic, one can describe the behavior of the system without building it first, as well as specify requirements completely and precisely. Most real-time logics describe systems in terms of events, i.e., points of time when something significant occurs.
Reference: [FM91] <author> M. Felder and A. Morzenti. </author> <title> "Validating Real-Time Systems by Executing Logic Specifications in TRIO". </title> <booktitle> In Proceedings of TAV4: the Symposium on testing, Analysis and Verification, </booktitle> <year> 1991. </year>
Reference-contexts: For example, a Symbolic Logic Verifier (SMV) [McM93] was used to detect several errors in the Futurebus+ Cache Coherency Protocol, an IEEE standard. A number of model-theoretic approaches incorporated analysis of real-time properties. Examples of such systems are TRIO <ref> [GMM90, FM91] </ref> and the Modechart verifier 8 [JS88]. In another approach [YMW93], SMV was extended to verify larger systems, by incorporating an efficient technique for timing and event counting.
Reference: [Ger91] <author> R. Gerber. </author> <title> Communicating Shared Resources: A Model for Distributed Real-Time Systems. </title> <type> PhD thesis, </type> <institution> University of Pennsylvania, </institution> <year> 1991. </year>
Reference-contexts: This technique is called bisimulation. Process algebras able to express timing properties include: CSR <ref> [Ger91, GL92] </ref> and ACSR [PGJI93], which adds time to CCS; Timed CSP [RR87], an extension of CSP; 7 Timed LOTOS [BB87], an extension of the ISO standard LOTOS; and a timed version of ACP [JJ91]. 1.3.2 Analysis Techniques Common analysis techniques can be divided into three broad classes: model-theoretic reasoning, proof-theoretic
Reference: [GF88] <author> A. Gabrielian and M.K. Franklin. </author> <title> "State-based Specification of Complex Real-time Systems". </title> <booktitle> In Proceedings of the 9th Real-Time Systems Symposium, </booktitle> <pages> pages 2-11, </pages> <year> 1988. </year>
Reference-contexts: State-machine models Statecharts [Har87] and its commercial version STATEMATE [HLN + 90] exploit the nature and simplicity of the classical finite state machine, enhancing it with hier 5 archical and compositional features. A set of associated tools performs reachability analysis and simulation. <ref> [GF88] </ref> use methods similar to Statecharts. However, the real-time aspects of Statecharts semantics are underdeveloped [MLJ88]. A number of other notations, based on Statecharts, address this problem. Both Modecharts [JM86] and TTM [Ost89b] use similar representations, allowing expression of timing and logical properties expressed in RTL and RTTL, respectively.
Reference: [GH90] <author> G. Guiho and C. </author> <title> Hennebert. </title> <booktitle> "SACEM Software Validation". In 12th International Conference on Software Engineering, </booktitle> <pages> pages 186-191, </pages> <address> Nice, France, </address> <month> March </month> <year> 1990. </year>
Reference-contexts: For example, SCR methods have been applied to A-7 Operational Flight Control Program [Hen80], a submarine communication system [HM83] and safety-critical components of the Dar-lington nuclear power plant in Canada [vPM93]. The SACEM project used Hoare-style proofs to verify a one-line commuter train network in Paris <ref> [GH90] </ref> . The Traffic Alert and Collision Avoidance System (TCAS II) project used the Requirements State Machine Language [JLHM91] to express the system's requirements. IBM used Z in the development of a major new release of its transaction processing system CICS [HK91].
Reference: [GH93a] <author> Hubert Garavel and Rene-Pierre Hautbois. </author> <title> "An Experience with the LO-TOS Formal Description Technique on the Flight Warning Computer of the Airbus 330/340 Aircraft". </title> <booktitle> In First AMAST International Workshop on Real-Time Systems, </booktitle> <address> Iowa City, IA, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: LOTOS languages and tools were used to specify and model software for the Flight Warning Computer (FWC) of the Airbus 330 and 340 aircraft <ref> [GH93a] </ref>. 10 In a more recent project, model-checking techniques have been applied to verify the t900 Virtual Channel Processor [Bar95]. 1.5 Overview of Dissertation Software quality can be improved by eliminating errors arising from inconsistencies within the description of a system or between two different descriptions of a system.
Reference: [GH93b] <author> J.V. Guttag and J.J. Horning. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Deductive reasoning can be applied to any model, not necessarily a finite-state machine. A number of mechanical proof systems have been developed: the Boyer-Moore theorem prover [BM88], EVES [KPS + 93], and the Larch Prover (LP) <ref> [GHW85, GH93b] </ref> are based on first-order logic; and HOL [Gor88] and PVS [OSR93] are based on higher-order logic. These systems do some proofs automatically, although most non-trivial proofs require user guidance. Mechanical proof systems can be very useful in checking hand-proofs, though.
Reference: [GHW85] <author> J. Guttag, J. Horning, and J. Wing. </author> <title> "Larch in Five Easy Pieces". </title> <type> Technical Report 5, </type> <institution> Systems Research Center, </institution> <year> 1985. </year>
Reference-contexts: Deductive reasoning can be applied to any model, not necessarily a finite-state machine. A number of mechanical proof systems have been developed: the Boyer-Moore theorem prover [BM88], EVES [KPS + 93], and the Larch Prover (LP) <ref> [GHW85, GH93b] </ref> are based on first-order logic; and HOL [Gor88] and PVS [OSR93] are based on higher-order logic. These systems do some proofs automatically, although most non-trivial proofs require user guidance. Mechanical proof systems can be very useful in checking hand-proofs, though.
Reference: [GL91] <author> O. Grumberg and D.E. </author> <title> Long. "Model Checking and Modular Verification". </title> <booktitle> In Proceedings of CONCUR'91: 2nd International Conference on Concur-rency Theory, </booktitle> <year> 1991. </year>
Reference: [GL92] <author> R. Gerber and I. Lee. </author> <title> "A Layered Approach to Automating the Verification of Real-Time Systems". </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> 18(9) </volume> <pages> 768-784, </pages> <year> 1992. </year>
Reference-contexts: This technique is called bisimulation. Process algebras able to express timing properties include: CSR <ref> [Ger91, GL92] </ref> and ACSR [PGJI93], which adds time to CCS; Timed CSP [RR87], an extension of CSP; 7 Timed LOTOS [BB87], an extension of the ISO standard LOTOS; and a timed version of ACP [JJ91]. 1.3.2 Analysis Techniques Common analysis techniques can be divided into three broad classes: model-theoretic reasoning, proof-theoretic <p> Thus, we are interested in extending our analysis methods to process designs of concurrent programs. Most of the previous approaches to analysis of concurrent programs have generally abstracted away data values and their effects on control flow to concentrate on task interactions (e.g., <ref> [DC94, FG94, LC91, GL92, Tay83, MR91] </ref>). We perform dataflow analysis on values of requirements variables and include them in the property verification, without building a global reachability graph. In this chapter we use a simple example to introduce new extensions to the requirements and the design languages.
Reference: [GMM90] <author> Carlo Ghezzi, Dino Mandrioli, and Angelo Morzenti. </author> <title> "TRIO: A Logic Language for Executable Specifications of Real-Time Systems". </title> <journal> Journal of Systems and Software, </journal> <volume> 12(2) </volume> <pages> 107-123, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Most real-time logics describe systems in terms of events, i.e., points of time when something significant occurs. Examples of such systems include Real-Time Logic or RTL [JM86], TRIO <ref> [GMM90] </ref> and ASTRAL [CPKM94]. RTL has been further extended (to RTTL) to describe temporal distance [Ost89b]. Several temporal logics have been developed to describe real-time systems. Linear-time semantics (e.g., [Pnu77, MP90, MP92]) describe particular executions of a system, whereas branching-time semantics (e.g., [EH86, CES86]) describe all possible executions. <p> For example, a Symbolic Logic Verifier (SMV) [McM93] was used to detect several errors in the Futurebus+ Cache Coherency Protocol, an IEEE standard. A number of model-theoretic approaches incorporated analysis of real-time properties. Examples of such systems are TRIO <ref> [GMM90, FM91] </ref> and the Modechart verifier 8 [JS88]. In another approach [YMW93], SMV was extended to verify larger systems, by incorporating an efficient technique for timing and event counting.
Reference: [Gor88] <author> M. Gordon. </author> <title> "Mechanizing Programming Logics in Higher Order Logic". </title> <type> Technical Report 145, </type> <institution> University of Cambridge, </institution> <address> Cambridge, UK, </address> <year> 1988. </year> <month> 189 </month>
Reference-contexts: Deductive reasoning can be applied to any model, not necessarily a finite-state machine. A number of mechanical proof systems have been developed: the Boyer-Moore theorem prover [BM88], EVES [KPS + 93], and the Larch Prover (LP) [GHW85, GH93b] are based on first-order logic; and HOL <ref> [Gor88] </ref> and PVS [OSR93] are based on higher-order logic. These systems do some proofs automatically, although most non-trivial proofs require user guidance. Mechanical proof systems can be very useful in checking hand-proofs, though. Simulation Simulation [CHLR93] or specification testing [Kem85] is a form of testing applied to formal requirements.
Reference: [GS93] <author> Dirk Grunwald and Harini Srinivasan. </author> <title> "Data Flow Equations for Explicitly Parallel Programs". </title> <booktitle> In Proceedings of 4th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 159-167, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: A buffer, however, can have several incoming and outgoing edges. Let pred seq (n) and pred sync (n) be sets of all predecessors of n (n can be either a node or a buffer) via sequential and synchronization edges, respectively. are identified in the figure following the convention of <ref> [GS93] </ref>. Computation of system states at each node of the CDFG is performed using dataflow techniques [ASU88, GS93, 120 LC91] similar to those described in Section 3.2. We extend these techniques to include synchronization information. First, we compute information generated and known at every node. <p> Computation of system states at each node of the CDFG is performed using dataflow techniques <ref> [ASU88, GS93, 120 LC91] </ref> similar to those described in Section 3.2. We extend these techniques to include synchronization information. First, we compute information generated and known at every node. Read and Write nodes do not generate new information, and thus their gen and known sets are EMPTY.
Reference: [Har87] <author> David Harel. "StateCharts: </author> <title> A Visual Formalism for Complex Systems". </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 231-274, </pages> <year> 1987. </year>
Reference-contexts: Interval-time semantics (e.g., [SMS82, All83]) are used to express conditions that hold for some nonzero time interval. UNITY [CM88] is a framework for specification and verification that uses extended state-transition systems to model abstract programs in a similar logic. State-machine models Statecharts <ref> [Har87] </ref> and its commercial version STATEMATE [HLN + 90] exploit the nature and simplicity of the classical finite state machine, enhancing it with hier 5 archical and compositional features. A set of associated tools performs reachability analysis and simulation. [GF88] use methods similar to Statecharts. <p> We need to be able to specify requirements for these systems using SCR without enumerating all of them. It would be more convenient to use arrays of modes and mode classes, as in <ref> [JLHM91, Har87] </ref>. * A useful and general semantics of communication between processes needs further investigation.
Reference: [HBGL95] <author> Constance Heitmeyer, Alan Bull, Carolyn Gasarch, and Bruch Labaw. "SCR*: </author> <title> A Toolset for Specifying and Analyzing Requirements". </title> <booktitle> In Proceedings of 10th Annual Conference on Computer Assurance, </booktitle> <pages> pages 109-122, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Formal methods play a big role in this effort. A number of formal requirements notations (e.g. the Software Cost Reduction (SCR) notation [AFB + 88, Hen80] and the Requirements State Machine Language (RSML)[JLHM91]) have been used to write requirements for realistic applications and analyze their completeness and consistency <ref> [HBGL95, RPRL96, HL95] </ref>. Verifying that designs and implementations preserve the "correctness" of requirements is not easy. Usually, this is achieved via testing, which can provide only partial coverage of the range of behaviors of the system. The behavior of software is determined by a succession of discrete state changes. <p> If "current" is the state of the system at time t, then "previous" is the state at time t * for some well-defined * a unit of measurement of time. The logical statement represented by a conditioned event is defined by <ref> [HBGL95] </ref>: @T (a) when [b] = : a ^ a0 ^ b, where the unprimed version of a condition a denotes the value of a in the previous state and the primed version denotes the value of a in the current state. b is called the event's when condition. 2.2.2 Modes <p> Environmental assumptions allow us to express first-order predicates (by a finite number of related boolean conditions), like integer ranges. However, we are not able to process a richer type system. The model presented above is somewhat different from the one recently proposed by Naval Research Lab <ref> [HLK95, HBGL95] </ref>. Their model has a rich type system, so there is no need for environmental assumptions. They also make a "One Input Assumption", i.e., only one monitored variable can change value at one time, so no simultaneous events occur.
Reference: [Hei96] <author> Constance Heitmeyer. </author> <title> Private communication, </title> <year> 1996. </year>
Reference-contexts: We would not have to forbid simultaneous Updates to avoid race conditions if we required that SCR variables have a partial order of dependencies i.e., two mode classes cannot receive events from each other. <ref> [Hei96] </ref> suggested that processes should not react to events in other processes at all, but only treat them as when conditions.
Reference: [Hen80] <author> K. Heninger. </author> <title> "Specifying Software Requirements for Complex Systems: New Techniques and Their Applications". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(1):2-12, </volume> <month> January </month> <year> 1980. </year>
Reference-contexts: Formal methods play a big role in this effort. A number of formal requirements notations (e.g. the Software Cost Reduction (SCR) notation <ref> [AFB + 88, Hen80] </ref> and the Requirements State Machine Language (RSML)[JLHM91]) have been used to write requirements for realistic applications and analyze their completeness and consistency [HBGL95, RPRL96, HL95]. Verifying that designs and implementations preserve the "correctness" of requirements is not easy. <p> Several industrial projects successfully used formal methods [CGR95]. For example, SCR methods have been applied to A-7 Operational Flight Control Program <ref> [Hen80] </ref>, a submarine communication system [HM83] and safety-critical components of the Dar-lington nuclear power plant in Canada [vPM93]. The SACEM project used Hoare-style proofs to verify a one-line commuter train network in Paris [GH90] . <p> Another way to represent requirements is to describe how control and data should flow among components of the system. The SCR requirements notation was developed by a research group at the Naval Research Laboratory as part of the Software Cost Reduction project <ref> [AFB + 88, Hen80] </ref>. The project resulted in SCR requirements and design standards, as well as guidelines for software development using SCR.
Reference: [HK91] <author> Iain Houston and Steve King. </author> <title> "CICS Project Report: Experiences and Results from the Use of Z in IBM". </title> <editor> In Prehn and Toetenel, editors, VDM'91: </editor> <booktitle> Formal Software Development Methods, volume 551 of Lecture Notes in Computer Science, </booktitle> <pages> pages 588-596. </pages> <publisher> Springer-Verlag, </publisher> <month> October </month> <year> 1991. </year>
Reference-contexts: The Traffic Alert and Collision Avoidance System (TCAS II) project used the Requirements State Machine Language [JLHM91] to express the system's requirements. IBM used Z in the development of a major new release of its transaction processing system CICS <ref> [HK91] </ref>. A semiconductor manufacturer Inmos used formal methods in the development of a floating point unit for the T800 Transputer [Bar89]. A formal specification and verification effort [MSS82] was associated with the Software Implemented Fault Tolerance (SIFT) project [ea78], aimed at development of a fault-tolerant computer for fly-by-wire passenger aircraft.
Reference: [HL85] <author> David Helmbold and David Luckham. </author> <title> "Debugging Ada Tasking Programs". </title> <journal> IEEE Software, </journal> <volume> 2(2), </volume> <month> March </month> <year> 1985. </year>
Reference-contexts: However, this approach works well only with systems with complicated control-flow and infrequent communications. Our modeling of synchronization is rather awkward, and attempts to look at typical benchmark problems, e.g., the gas station example <ref> [HL85] </ref>, did not result in interesting analyses. These problems are stripped of all but the communications information (rendezvous between Ada processes in [HL85]), and thus Analyzer does not perform very well. <p> Our modeling of synchronization is rather awkward, and attempts to look at typical benchmark problems, e.g., the gas station example <ref> [HL85] </ref>, did not result in interesting analyses. These problems are stripped of all but the communications information (rendezvous between Ada processes in [HL85]), and thus Analyzer does not perform very well. To verify a wider range of systems, we would need to make several modifications to our approach: 137 * Many concurrent applications consist of several identical processes.
Reference: [HL93] <author> C. Heitmeyer and B. Labaw. </author> <title> "Consistency Checks for SCR-Style Requirements Specifications". </title> <type> Technical Report NRL Report 93-9586, </type> <institution> Naval Research Laboratory, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: The initial language lacked an underlying formal semantics. A number of semantics have been proposed [Atl92, HLK95, Fau89, PM91, van90], some of which [HLK95, PM95] became bases of tools automating consistency and completeness checks <ref> [HL93] </ref> and simulations [CHLR93, PW94] of requirements.
Reference: [HL95] <author> M.P.E. Heimdahl and N.G. Levenson. </author> <title> "Completeness and Consistency Analysis of State-Based Requirements". </title> <booktitle> In Proceedings of the 17th International Conference on Software Engineering, </booktitle> <address> Seattle, WA, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: Formal methods play a big role in this effort. A number of formal requirements notations (e.g. the Software Cost Reduction (SCR) notation [AFB + 88, Hen80] and the Requirements State Machine Language (RSML)[JLHM91]) have been used to write requirements for realistic applications and analyze their completeness and consistency <ref> [HBGL95, RPRL96, HL95] </ref>. Verifying that designs and implementations preserve the "correctness" of requirements is not easy. Usually, this is achieved via testing, which can provide only partial coverage of the range of behaviors of the system. The behavior of software is determined by a succession of discrete state changes.
Reference: [HLK95] <author> C. Heitmeyer, B. Labaw, and D. Kiskis. </author> <title> "Consistency Checking of SCR-Style Requirements Specifications". </title> <booktitle> In Proceedings of RE'95 International Symposium of Requirements Engineering, </booktitle> <month> March </month> <year> 1995. </year>
Reference-contexts: The specification language is precise, can be understood by engineers and software developers, and is easy to use and modify. The initial language lacked an underlying formal semantics. A number of semantics have been proposed <ref> [Atl92, HLK95, Fau89, PM91, van90] </ref>, some of which [HLK95, PM95] became bases of tools automating consistency and completeness checks [HL93] and simulations [CHLR93, PW94] of requirements. <p> The specification language is precise, can be understood by engineers and software developers, and is easy to use and modify. The initial language lacked an underlying formal semantics. A number of semantics have been proposed [Atl92, HLK95, Fau89, PM91, van90], some of which <ref> [HLK95, PM95] </ref> became bases of tools automating consistency and completeness checks [HL93] and simulations [CHLR93, PW94] of requirements. <p> The second formula describes two simultaneous events occurring at the point of time when both conditions become true. Immediately before the event, neither condition is true. Some formal semantics, e.g. 17 <ref> [HLK95] </ref>, exclude simultaneous events. <p> Environmental assumptions allow us to express first-order predicates (by a finite number of related boolean conditions), like integer ranges. However, we are not able to process a richer type system. The model presented above is somewhat different from the one recently proposed by Naval Research Lab <ref> [HLK95, HBGL95] </ref>. Their model has a rich type system, so there is no need for environmental assumptions. They also make a "One Input Assumption", i.e., only one monitored variable can change value at one time, so no simultaneous events occur. <p> We express these properties as first-order logic formulas. 2.7.1 Formal model of SCR Before expressing the consistency properties in a formal logic, we need to define the meaning of a mode transition and a change of value of a controlled variable. <ref> [HLK95] </ref> describes a mode change as a transition between two states, i.e. a transition between modes m i and m j of modeclass m triggered by @T (a) when [b] is formalized as (m = m i ) ^ (a = false) ^ (b = true) ^ (a0 = true) ^ <p> So, COM = mc j 2MC Note that we do not ensure that there are no circular definitions, i.e., a partial order of dependencies between variables and mode classes in each requirements document can be constructed (as in <ref> [HLK95] </ref>).
Reference: [HLN + 90] <author> D. Harel, H. Lachover, A. Naamad, A. Pnueli, M. Politi, R. Sherman, A. Shtull-Trauring, and M. Trakhtenbrot. "STATEMATE: </author> <title> A Working Environment for the Development of Complex Reactive Systems". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(4) </volume> <pages> 403-414, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: Interval-time semantics (e.g., [SMS82, All83]) are used to express conditions that hold for some nonzero time interval. UNITY [CM88] is a framework for specification and verification that uses extended state-transition systems to model abstract programs in a similar logic. State-machine models Statecharts [Har87] and its commercial version STATEMATE <ref> [HLN + 90] </ref> exploit the nature and simplicity of the classical finite state machine, enhancing it with hier 5 archical and compositional features. A set of associated tools performs reachability analysis and simulation. [GF88] use methods similar to Statecharts. However, the real-time aspects of Statecharts semantics are underdeveloped [MLJ88].
Reference: [HM83] <author> C. Heitmeyer and J. McLean. </author> <title> "Abstract Requirements Specification: A New Approach and Its Applications". </title> <journal> IEEE Transactions of Software Engineering, </journal> <volume> SE-6(6):580-589, </volume> <month> September </month> <year> 1983. </year>
Reference-contexts: Several industrial projects successfully used formal methods [CGR95]. For example, SCR methods have been applied to A-7 Operational Flight Control Program [Hen80], a submarine communication system <ref> [HM83] </ref> and safety-critical components of the Dar-lington nuclear power plant in Canada [vPM93]. The SACEM project used Hoare-style proofs to verify a one-line commuter train network in Paris [GH90] .
Reference: [HM96] <author> Constance Heitmeyer and Dino Mandrioli. </author> <title> "Formal Methods for Real-Time Computing: An Overview". </title> <editor> In Constance Heitmeyer and Dino Mandrioli, editors, </editor> <title> Formal Methods for Real-Time Computing. </title> <publisher> John Wiley & Sons Ltd, </publisher> <year> 1996. </year>
Reference-contexts: Many formal methods lack adequate tool support. To be useful in developing practical systems, formal methods must increase software quality, produce readable documents, scale to large applications, keep development costs under control and be supported by tools <ref> [HM96] </ref>: * Readability. A formal requirements document should be understood by users of the system, who usually have little technical background. One way to enhance readability is to "hide" precise mathematical notation under a layer of more intuitive graphical and/or tabular notations and to add explanatory comments. * Scalability.
Reference: [Hoa69] <author> C.A.R. Hoare. </author> <title> "An Axiomatic Basis for Computer Programming". </title> <journal> Com--munications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-580, </pages> <month> October </month> <year> 1969. </year>
Reference-contexts: Logic-based models Mathematical logic has been used to specify and prove properties about programs <ref> [Hoa69, Flo67] </ref>. Using logic, one can describe the behavior of the system without building it first, as well as specify requirements completely and precisely. Most real-time logics describe systems in terms of events, i.e., points of time when something significant occurs.
Reference: [Hoa85] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <address> New York, </address> <year> 1985. </year>
Reference-contexts: These languages have been applied to a number of industrial projects, especially in the fields of nuclear plant safety and avionics [LRD95]. Process algebras Process algebras were developed to specify and analyze concurrent systems. The original versions, such as CCS [Mil89], CSP <ref> [Hoa85] </ref> and ACP [BK85], were untimed.
Reference: [How90] <author> W.E. Howden. </author> <title> "Comments Analysis and Programming Errors". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(1) </volume> <pages> 72-81, </pages> <month> January </month> <year> 1990. </year>
Reference: [HS95] <author> W.E. Howden and G.M. Shi. </author> <title> "Linear and Structural Event Sequence Analysis". </title> <note> Submitted to ISSTA'96, </note> <month> June </month> <year> 1995. </year>
Reference-contexts: Other com 144 ments contain assertions about properties of objects. An interpreter builds an abstract model of the implementation from the assertions and the implementation's control flow graph. Hypotheses are verified with respect to this model. More recent work <ref> [HS95] </ref> enriches QDA's specification language so assertions also describe event occurrences and hypotheses assert that the implementation's events occur in certain sequences.
Reference: [HW94] <author> W.E. Howden and B. Wieand. </author> <title> "QDA A Method for Systematic Informal Program Analysis". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(6) </volume> <pages> 445-462, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Our PDL's outer syntax is a set of 39 C-like control structures. Our inner syntax consists of annotations special statements describing values of requirements variables. Our use of annotations was inspired by William Howden's work on QDA <ref> [HW94, Vai91] </ref>. For sequential designs, we defined three types of annotations: * An Initial annotation indicates the starting state of each mode class. It unconditionally assigns values to variables.
Reference: [Jac92] <author> D. Jackson. </author> <title> Aspect: A Formal Specification Language for Detecting Bugs. </title> <type> PhD thesis, </type> <institution> MIT, Cambridge, Massachusetts, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: After a user specifies a mapping from programming language constructs to Cecil events, the Cesar analyzer uses dataflow analysis techniques to determine if the implementation meets Cecil constraints. Aspect's <ref> [Jac92, Jac93a, Jac93b] </ref> specification notation permits users to write pre-and postconditions about the data dependencies of an operation. Dataflow analysis is used to compute an upper bound on the data dependencies of the implementation. If an asserted dependency is missing, an error is reported.
Reference: [Jac93a] <author> Daniel Jackson. </author> <title> "Abstract Analysis with Aspect". </title> <booktitle> In Proceedings of the 1993 International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <pages> pages 19-27, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: After a user specifies a mapping from programming language constructs to Cecil events, the Cesar analyzer uses dataflow analysis techniques to determine if the implementation meets Cecil constraints. Aspect's <ref> [Jac92, Jac93a, Jac93b] </ref> specification notation permits users to write pre-and postconditions about the data dependencies of an operation. Dataflow analysis is used to compute an upper bound on the data dependencies of the implementation. If an asserted dependency is missing, an error is reported.
Reference: [Jac93b] <author> Daniel Jackson. </author> <title> "Aspect: Detecting Bugs with Abstract Dependences". </title> <note> (submitted to Transactions on Software Engineering and Methodology), </note> <month> November </month> <year> 1993. </year>
Reference-contexts: After a user specifies a mapping from programming language constructs to Cecil events, the Cesar analyzer uses dataflow analysis techniques to determine if the implementation meets Cecil constraints. Aspect's <ref> [Jac92, Jac93a, Jac93b] </ref> specification notation permits users to write pre-and postconditions about the data dependencies of an operation. Dataflow analysis is used to compute an upper bound on the data dependencies of the implementation. If an asserted dependency is missing, an error is reported.
Reference: [Jac94] <author> Daniel Jackson. </author> <title> "Abstract Model Checking of Infinite Specifications". </title> <booktitle> In Proceedings of FME'94: Industrial Benefit of Formal Methods, Second International Symposium of Formal Methods Europe, </booktitle> <pages> pages 519-531, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: However, the entire state space of the model is constructed before the fixed point algorithms can be applied. Various improvements to the original technology allows for efficient checking of large systems [BCM + 90, CGL92, McM93]. The problems successfully solved by model checking are mostly specifications 68 of systems <ref> [Jac94, SA96, ABB + 96] </ref> and hardware designs [CES86, CGH + 93, BCDM86, MS92, Bar95].
Reference: [JJ91] <author> J.Baeten and J.Bergstra. </author> <title> "Real-Time Process Algebra". </title> <journal> Formal Aspects of Computing, </journal> <volume> 3(2) </volume> <pages> 142-188, </pages> <year> 1991. </year>
Reference-contexts: This technique is called bisimulation. Process algebras able to express timing properties include: CSR [Ger91, GL92] and ACSR [PGJI93], which adds time to CCS; Timed CSP [RR87], an extension of CSP; 7 Timed LOTOS [BB87], an extension of the ISO standard LOTOS; and a timed version of ACP <ref> [JJ91] </ref>. 1.3.2 Analysis Techniques Common analysis techniques can be divided into three broad classes: model-theoretic reasoning, proof-theoretic reasoning, and simulation. Model-checking Model checkers [CES86] take a finite state machine model of a system and a temporal logic formula and determine if the formula holds in the model.
Reference: [JLHM91] <author> Matthew S. Jaffe, Nancy G. Levenson, Mats P.E. Heimdahl, and Bonnie E. Melhart. </author> <title> "Software Requirements Analysis for Real-Time Process-Control Systems". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(3), </volume> <month> March </month> <year> 1991. </year>
Reference-contexts: The SACEM project used Hoare-style proofs to verify a one-line commuter train network in Paris [GH90] . The Traffic Alert and Collision Avoidance System (TCAS II) project used the Requirements State Machine Language <ref> [JLHM91] </ref> to express the system's requirements. IBM used Z in the development of a major new release of its transaction processing system CICS [HK91]. A semiconductor manufacturer Inmos used formal methods in the development of a floating point unit for the T800 Transputer [Bar89]. <p> We need to be able to specify requirements for these systems using SCR without enumerating all of them. It would be more convenient to use arrays of modes and mode classes, as in <ref> [JLHM91, Har87] </ref>. * A useful and general semantics of communication between processes needs further investigation.
Reference: [JM86] <author> F. Jahanian and A. Mok. </author> <title> "Safety Analysis of Timing Properties in Real-Time Systems". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(9):890-904, </volume> <month> September </month> <year> 1986. </year>
Reference-contexts: Using logic, one can describe the behavior of the system without building it first, as well as specify requirements completely and precisely. Most real-time logics describe systems in terms of events, i.e., points of time when something significant occurs. Examples of such systems include Real-Time Logic or RTL <ref> [JM86] </ref>, TRIO [GMM90] and ASTRAL [CPKM94]. RTL has been further extended (to RTTL) to describe temporal distance [Ost89b]. Several temporal logics have been developed to describe real-time systems. Linear-time semantics (e.g., [Pnu77, MP90, MP92]) describe particular executions of a system, whereas branching-time semantics (e.g., [EH86, CES86]) describe all possible executions. <p> A set of associated tools performs reachability analysis and simulation. [GF88] use methods similar to Statecharts. However, the real-time aspects of Statecharts semantics are underdeveloped [MLJ88]. A number of other notations, based on Statecharts, address this problem. Both Modecharts <ref> [JM86] </ref> and TTM [Ost89b] use similar representations, allowing expression of timing and logical properties expressed in RTL and RTTL, respectively. Both approaches are supported with a suite of tools, including verifiers based on model-theoretic reasoning.
Reference: [JM87] <author> Farnam Jahanian and Aloysius K.-L. Mok. </author> <title> "A Graph-Theoretic Approach for Timing Analysis and Its Implementation". </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(8):961-975, </volume> <month> August </month> <year> 1987. </year>
Reference-contexts: then we allow mc 1 to react to changes of state of mc 2 , and for mc 2 to react to changes of state of mc 1 . 6.1.2 Example Mutual Exclusion System We illustrate the SCR model using a simple example, abstracted from a Nuclear Control Rod system <ref> [JM87] </ref> to preserve communication problems. We call it a Mutual Exclusion system (MES). Assume that we want to specify a system where two identical processes have critical sections, and mutual exclusion is guaranteed by having a separate process, Manager, give out permissions to the other processes.
Reference: [JS88] <author> F. Jahanian and D. Stuart. </author> <title> "A Method for Verifying Properties of Mod-echart Specifications". </title> <booktitle> In Proceedings of the Real-Time Systems Symposium, </booktitle> <pages> pages 12-21, </pages> <year> 1988. </year> <month> 191 </month>
Reference-contexts: For example, a Symbolic Logic Verifier (SMV) [McM93] was used to detect several errors in the Futurebus+ Cache Coherency Protocol, an IEEE standard. A number of model-theoretic approaches incorporated analysis of real-time properties. Examples of such systems are TRIO [GMM90, FM91] and the Modechart verifier 8 <ref> [JS88] </ref>. In another approach [YMW93], SMV was extended to verify larger systems, by incorporating an efficient technique for timing and event counting.
Reference: [Kem85] <author> R.A. Kemmerer. </author> <title> "Testing Formal Specifications to Detect Design Er--rors". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(1):32-43, </volume> <month> Jan-uary </month> <year> 1985. </year>
Reference-contexts: These systems do some proofs automatically, although most non-trivial proofs require user guidance. Mechanical proof systems can be very useful in checking hand-proofs, though. Simulation Simulation [CHLR93] or specification testing <ref> [Kem85] </ref> is a form of testing applied to formal requirements. Users experiment with the system specification by providing a set of inputs to the system, and a simulator uses the specification to show how the state of the system changes based on the input.
Reference: [KPS + 93] <author> S. Kromodimoeljo, W. Pase, M. Saalttink, D. Craigen, and I. Meisels. </author> <title> "A Tutorial on EVES". </title> <type> Technical report, </type> <institution> Odyssey Research Associates, </institution> <address> Ot-tawa, Ontario, </address> <year> 1993. </year>
Reference-contexts: Proof-theoretic techniques can handle more abstract models and produce more general results than model-checking. Deductive reasoning can be applied to any model, not necessarily a finite-state machine. A number of mechanical proof systems have been developed: the Boyer-Moore theorem prover [BM88], EVES <ref> [KPS + 93] </ref>, and the Larch Prover (LP) [GHW85, GH93b] are based on first-order logic; and HOL [Gor88] and PVS [OSR93] are based on higher-order logic. These systems do some proofs automatically, although most non-trivial proofs require user guidance. Mechanical proof systems can be very useful in checking hand-proofs, though.
Reference: [Lam88] <author> D.A. Lamb. </author> <title> Software Engineering: Planning for Change. </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: Designs are often expressed in a program design language (PDL)[CG75] consisting of a concrete outer syntax of basic statement types, and an inner syntax of comments. Design reviews seek to establish that the design is consistent with the requirements <ref> [Lam88] </ref>. We define a design to be consistent with its requirements if the design's state transitions are enabled by the same events as those of the requirements, all the requirement's state transitions appear in the design, and the requirement's safety properties hold in the design.
Reference: [LC91] <author> Douglas Long and Lori A. Clarke. </author> <title> "Data Flow Analysis of Concurrent Systems That Use the Rendezvous Model of Synchronization". </title> <type> Technical Report COINS 91-31, </type> <institution> Univ. </institution> <address> Mass. Amherst, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: Thus, we are interested in extending our analysis methods to process designs of concurrent programs. Most of the previous approaches to analysis of concurrent programs have generally abstracted away data values and their effects on control flow to concentrate on task interactions (e.g., <ref> [DC94, FG94, LC91, GL92, Tay83, MR91] </ref>). We perform dataflow analysis on values of requirements variables and include them in the property verification, without building a global reachability graph. In this chapter we use a simple example to introduce new extensions to the requirements and the design languages.
Reference: [Lev86] <author> Nancy G. Levenson. </author> <title> "Software Safety: Why, What, and How". </title> <journal> Computing Surveys, </journal> <volume> 18(2) </volume> <pages> 125-163, </pages> <month> June </month> <year> 1986. </year>
Reference: [LRD95] <author> F. Lagnier, P. Raymond, and C. Dubois. </author> <title> "Formal Verification of a Critical System Written in Saga/LUSTRE". </title> <booktitle> In Workshop on Formal Methods, Modelling and Simulation for System Engineering, </booktitle> <month> February </month> <year> 1995. </year>
Reference-contexts: Estrel [BdS91, BG92] is one of the family of languages used to describe real-time systems using the state machine model. These languages have been applied to a number of industrial projects, especially in the fields of nuclear plant safety and avionics <ref> [LRD95] </ref>. Process algebras Process algebras were developed to specify and analyze concurrent systems. The original versions, such as CCS [Mil89], CSP [Hoa85] and ACP [BK85], were untimed.
Reference: [LS87] <author> Nancy G. Levenson and Janice L. Stolzy. </author> <title> "Safety Analysis Using Petri Nets". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-13(3):386-397, </volume> <month> March </month> <year> 1987. </year>
Reference-contexts: Specifications expressed in this notation are executable, and verification is based on building a reachability graph (as in the Berthomieu-Diaz algorithm [BD91]). Two extensions, time Petri nets [MS76] and timed Petri nets (TPNs) [Ram74] were introduced for modeling time. Levenson and Stolzy <ref> [LS87] </ref> use TPNs for safety analysis, without having to generate the entire reachability graph, by working backward from hazardous states to determine if these states are reachable.
Reference: [LT88] <author> N. Lynch and M. Tuttle. </author> <title> "An Introduction to Input/Output Automata". </title> <type> Technical Report MIT/LCS/TM-373, </type> <institution> Laboratory for Computer Science, Massachusetts Institute of Technology, </institution> <year> 1988. </year>
Reference-contexts: This approach is called fault tree analysis. A similar backward approach is used in the real-time temporal logic approach to controller design [Ost89a, Ost91]. The systems described above are graphical notations, with formal underlying semantics. Other systems are described by textual notations. The Timed Automaton Model <ref> [LT88, LV91, MMT91] </ref> extends state machines with a notion of dense time. This 6 model has an infinite number of states, where time is added to the usual state machine model via a special "time passage" action.
Reference: [LV91] <author> N. Lynch and F. Vaandrager. </author> <title> "Forward and backward simulations for timing-based systems". </title> <booktitle> In Proceedings of the REX Workshop "Real-Time: Theory in Practice", </booktitle> <publisher> LNCS 600. Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: This approach is called fault tree analysis. A similar backward approach is used in the real-time temporal logic approach to controller design [Ost89a, Ost91]. The systems described above are graphical notations, with formal underlying semantics. Other systems are described by textual notations. The Timed Automaton Model <ref> [LT88, LV91, MMT91] </ref> extends state machines with a notion of dense time. This 6 model has an infinite number of states, where time is added to the usual state machine model via a special "time passage" action.
Reference: [McM93] <author> K.L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic, </publisher> <year> 1993. </year>
Reference-contexts: Current model checkers can verify some systems with 10 130 states [BCM + 90]. Model checkers have been most effectively applied to verification of hardware and protocol specifications. For example, a Symbolic Logic Verifier (SMV) <ref> [McM93] </ref> was used to detect several errors in the Futurebus+ Cache Coherency Protocol, an IEEE standard. A number of model-theoretic approaches incorporated analysis of real-time properties. Examples of such systems are TRIO [GMM90, FM91] and the Modechart verifier 8 [JS88]. <p> However, the entire state space of the model is constructed before the fixed point algorithms can be applied. Various improvements to the original technology allows for efficient checking of large systems <ref> [BCM + 90, CGL92, McM93] </ref>. The problems successfully solved by model checking are mostly specifications 68 of systems [Jac94, SA96, ABB + 96] and hardware designs [CES86, CGH + 93, BCDM86, MS92, Bar95].
Reference: [Mil89] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <address> Prantice-Hall, New York, </address> <year> 1989. </year>
Reference-contexts: These languages have been applied to a number of industrial projects, especially in the fields of nuclear plant safety and avionics [LRD95]. Process algebras Process algebras were developed to specify and analyze concurrent systems. The original versions, such as CCS <ref> [Mil89] </ref>, CSP [Hoa85] and ACP [BK85], were untimed.
Reference: [MLJ88] <author> B.E. Melhart, N.G. Levenson, </author> <title> and M.S. Jaffe. "Analysis Capabilities for Requirements Specified in Statecharts". </title> <type> Technical report, </type> <institution> University of California, Irvine, California, </institution> <year> 1988. </year>
Reference-contexts: A set of associated tools performs reachability analysis and simulation. [GF88] use methods similar to Statecharts. However, the real-time aspects of Statecharts semantics are underdeveloped <ref> [MLJ88] </ref>. A number of other notations, based on Statecharts, address this problem. Both Modecharts [JM86] and TTM [Ost89b] use similar representations, allowing expression of timing and logical properties expressed in RTL and RTTL, respectively. Both approaches are supported with a suite of tools, including verifiers based on model-theoretic reasoning.
Reference: [MMT91] <author> M. Merritt, F. Modugno, and M. Tuttle. </author> <title> "Time Constrained Automata". </title> <booktitle> In Proceedings of CONCUR'91: 2nd International Conference on Concurrency Theory, </booktitle> <address> Amsterdam, The Netherlands, </address> <month> August </month> <year> 1991. </year>
Reference-contexts: This approach is called fault tree analysis. A similar backward approach is used in the real-time temporal logic approach to controller design [Ost89a, Ost91]. The systems described above are graphical notations, with formal underlying semantics. Other systems are described by textual notations. The Timed Automaton Model <ref> [LT88, LV91, MMT91] </ref> extends state machines with a notion of dense time. This 6 model has an infinite number of states, where time is added to the usual state machine model via a special "time passage" action.
Reference: [MP90] <author> Z. Manna and A. Pnueli. </author> <title> "Tools and Rules for the Practicing Verifier". </title> <type> Technical Report STAN-CS-90-1321, </type> <institution> Department of Computer Science, Stanford University, </institution> <year> 1990. </year> <month> 192 </month>
Reference-contexts: Examples of such systems include Real-Time Logic or RTL [JM86], TRIO [GMM90] and ASTRAL [CPKM94]. RTL has been further extended (to RTTL) to describe temporal distance [Ost89b]. Several temporal logics have been developed to describe real-time systems. Linear-time semantics (e.g., <ref> [Pnu77, MP90, MP92] </ref>) describe particular executions of a system, whereas branching-time semantics (e.g., [EH86, CES86]) describe all possible executions. Interval-time semantics (e.g., [SMS82, All83]) are used to express conditions that hold for some nonzero time interval.
Reference: [MP92] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems. </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Examples of such systems include Real-Time Logic or RTL [JM86], TRIO [GMM90] and ASTRAL [CPKM94]. RTL has been further extended (to RTTL) to describe temporal distance [Ost89b]. Several temporal logics have been developed to describe real-time systems. Linear-time semantics (e.g., <ref> [Pnu77, MP90, MP92] </ref>) describe particular executions of a system, whereas branching-time semantics (e.g., [EH86, CES86]) describe all possible executions. Interval-time semantics (e.g., [SMS82, All83]) are used to express conditions that hold for some nonzero time interval.
Reference: [MR91] <author> S.P. Masticola and B.G. Ryder. </author> <title> "A Model for Ada Programs for Static Deadlock Detection in Polynomial Time". </title> <booktitle> Proceedings of ACM SIGPLAN Programming Languages Design and Implementation, ACM SIGPLAN Notices, </booktitle> <volume> 26(12) </volume> <pages> 97-107, </pages> <year> 1991. </year>
Reference-contexts: Thus, we are interested in extending our analysis methods to process designs of concurrent programs. Most of the previous approaches to analysis of concurrent programs have generally abstracted away data values and their effects on control flow to concentrate on task interactions (e.g., <ref> [DC94, FG94, LC91, GL92, Tay83, MR91] </ref>). We perform dataflow analysis on values of requirements variables and include them in the property verification, without building a global reachability graph. In this chapter we use a simple example to introduce new extensions to the requirements and the design languages.
Reference: [MS76] <author> P.M. Merlin and A. Segall. </author> <title> "Recoverability of Communication Protocols - Implications of a Theoretical Study". </title> <journal> IEEE Transactions on Communications, </journal> <pages> pages 1036-1043, </pages> <year> 1976. </year>
Reference-contexts: A Petri net is an operational formalism, supporting a notion of state and its evolution. Specifications expressed in this notation are executable, and verification is based on building a reachability graph (as in the Berthomieu-Diaz algorithm [BD91]). Two extensions, time Petri nets <ref> [MS76] </ref> and timed Petri nets (TPNs) [Ram74] were introduced for modeling time. Levenson and Stolzy [LS87] use TPNs for safety analysis, without having to generate the entire reachability graph, by working backward from hazardous states to determine if these states are reachable.
Reference: [MS92] <author> K.L. McMillan and J. Schwalbe. </author> <title> "Formal Verification of the Gigamax Cache Consistency Protocol". </title> <editor> In N. Suzuki, editor, </editor> <booktitle> Shared Memory Multiprocessing. </booktitle> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: Various improvements to the original technology allows for efficient checking of large systems [BCM + 90, CGL92, McM93]. The problems successfully solved by model checking are mostly specifications 68 of systems [Jac94, SA96, ABB + 96] and hardware designs <ref> [CES86, CGH + 93, BCDM86, MS92, Bar95] </ref>.
Reference: [MSS82] <author> P.M. Melliar-Smith and R.L. Schwartz. </author> <title> "Formal Specification and Verification of SIFT: A Fault Tolerant Flight Control System". </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-31(7):616-630, </volume> <month> July </month> <year> 1982. </year>
Reference-contexts: IBM used Z in the development of a major new release of its transaction processing system CICS [HK91]. A semiconductor manufacturer Inmos used formal methods in the development of a floating point unit for the T800 Transputer [Bar89]. A formal specification and verification effort <ref> [MSS82] </ref> was associated with the Software Implemented Fault Tolerance (SIFT) project [ea78], aimed at development of a fault-tolerant computer for fly-by-wire passenger aircraft.
Reference: [oD84] <author> U.S. </author> <title> Department of Defense. "System Safety Program Requirements". </title> <type> Technical Report MIL-STD-882B, U.S. </type> <institution> Government Printing Office, </institution> <address> Wash-ington, D.C., </address> <month> March </month> <year> 1984. </year>
Reference: [Off92] <author> U.S. </author> <title> General Accounting Office. "Mission Critical Systems: Defense Attempting to Address Major Software Challenges". </title> <type> Technical Report TR 90-276, U.S. </type> <institution> General Accounting Office, </institution> <address> Washington, DC, </address> <month> December </month> <year> 1992. </year>
Reference-contexts: For example, one can verify that a formal design specification is a refinement of a formal requirement specification. Most software errors are introduced during the requirements phase <ref> [Off92] </ref>. Since there is a growing evidence that requirements errors can lead to serious accidents, and that fixing requirements errors can be extremely costly when done late in the software life-cycle, techniques for improving the quality of requirements documents are crucial. Formal methods play a big role in this effort.
Reference: [OO89] <author> Kurt M. Olender and Leon J. Osterweil. </author> <title> "Cesar: A Static Sequencing Constraint Analyzer". </title> <booktitle> In Proceedings of the ACM SIGSOFT '89 Third Symposium on Software Testing, Analysis, and Verification (TAV3), </booktitle> <pages> pages 66-74, </pages> <month> December </month> <year> 1989. </year>
Reference: [OO90] <author> Kurt M. Olender and Leon J. Osterweil. "Cecil: </author> <title> A Sequencing Constraint Language for Automatic Static Analysis Generation". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(3) </volume> <pages> 268-280, </pages> <month> March </month> <year> 1990. </year>
Reference: [OO92] <author> Kurt M. Olender and Leon K. Osterweil. </author> <title> "Interprocedural Static Analysis of Sequencing Constraints". </title> <journal> ACM Transactions of Software Engineering and Methodology, </journal> <volume> 1(1) </volume> <pages> 21-52, </pages> <month> January </month> <year> 1992. </year>
Reference: [OSR93] <author> S. Owre, N. Shankar, and J. Rushby. </author> <title> "User Guide for the PVS Specification and Verification System (Draft)". </title> <type> Technical report, </type> <institution> Computer Science Lab, SRI International, </institution> <address> Menlo Park, CA, </address> <year> 1993. </year>
Reference-contexts: Deductive reasoning can be applied to any model, not necessarily a finite-state machine. A number of mechanical proof systems have been developed: the Boyer-Moore theorem prover [BM88], EVES [KPS + 93], and the Larch Prover (LP) [GHW85, GH93b] are based on first-order logic; and HOL [Gor88] and PVS <ref> [OSR93] </ref> are based on higher-order logic. These systems do some proofs automatically, although most non-trivial proofs require user guidance. Mechanical proof systems can be very useful in checking hand-proofs, though. Simulation Simulation [CHLR93] or specification testing [Kem85] is a form of testing applied to formal requirements.
Reference: [Ost89a] <author> J. Ostroff. </author> <title> "Synthesis of Controllers for Real-time Discrete Event Systems". </title> <booktitle> In Proceedings of the 28th IEEE Conference on Decision and Control, </booktitle> <year> 1989. </year>
Reference-contexts: This approach is called fault tree analysis. A similar backward approach is used in the real-time temporal logic approach to controller design <ref> [Ost89a, Ost91] </ref>. The systems described above are graphical notations, with formal underlying semantics. Other systems are described by textual notations. The Timed Automaton Model [LT88, LV91, MMT91] extends state machines with a notion of dense time.
Reference: [Ost89b] <author> J. Ostroff. </author> <title> Temporal Logic For Real-Time Systems. </title> <publisher> Research Studies Press LTD, </publisher> <address> Taunton, Somerset, England, </address> <year> 1989. </year> <month> 193 </month>
Reference-contexts: Most real-time logics describe systems in terms of events, i.e., points of time when something significant occurs. Examples of such systems include Real-Time Logic or RTL [JM86], TRIO [GMM90] and ASTRAL [CPKM94]. RTL has been further extended (to RTTL) to describe temporal distance <ref> [Ost89b] </ref>. Several temporal logics have been developed to describe real-time systems. Linear-time semantics (e.g., [Pnu77, MP90, MP92]) describe particular executions of a system, whereas branching-time semantics (e.g., [EH86, CES86]) describe all possible executions. Interval-time semantics (e.g., [SMS82, All83]) are used to express conditions that hold for some nonzero time interval. <p> A set of associated tools performs reachability analysis and simulation. [GF88] use methods similar to Statecharts. However, the real-time aspects of Statecharts semantics are underdeveloped [MLJ88]. A number of other notations, based on Statecharts, address this problem. Both Modecharts [JM86] and TTM <ref> [Ost89b] </ref> use similar representations, allowing expression of timing and logical properties expressed in RTL and RTTL, respectively. Both approaches are supported with a suite of tools, including verifiers based on model-theoretic reasoning.
Reference: [Ost91] <author> J. Ostroff. </author> <title> "Systematic Development of Real-time Discrete Event Systems". </title> <booktitle> In Proceedings of the ECC91 European Control Conference, </booktitle> <pages> pages 522-533, </pages> <address> Paris, </address> <year> 1991. </year>
Reference-contexts: This approach is called fault tree analysis. A similar backward approach is used in the real-time temporal logic approach to controller design <ref> [Ost89a, Ost91] </ref>. The systems described above are graphical notations, with formal underlying semantics. Other systems are described by textual notations. The Timed Automaton Model [LT88, LV91, MMT91] extends state machines with a notion of dense time.
Reference: [Par85] <author> David Lorge Parnas. </author> <title> "Software Aspects of Strategic Defense Systems". </title> <journal> American Scientist, </journal> <volume> 73 </volume> <pages> 432-440, </pages> <month> September-October </month> <year> 1985. </year>
Reference-contexts: One way to enhance readability is to "hide" precise mathematical notation under a layer of more intuitive graphical and/or tabular notations and to add explanatory comments. * Scalability. Verification techniques have been criticized <ref> [Par85] </ref> for not being able to analyze anything but toy systems. A skilled designer can create a good abstraction of a system so that the analysis is tractable but the results obtained also hold in the actual system. * Reasonable costs.
Reference: [Par93] <author> D.L. Parnas. </author> <title> "Some Theorems We Should Prove". </title> <booktitle> In Proceedings of 1993 International Conference on HOL Theorem Proving and Its Applications, </booktitle> <address> Vancouver, BC, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: Precise documentation of software requirements has several potential benefits: designers know what they are to build; reviewers can check that customers' intentions are met; testers can formulate test cases independently from the system's implementation; and maintainers can use the original requirements to learn about the system before making their changes <ref> [Par93] </ref>. Although useful for specifying a variety of types of computer systems, precise documentation is essential for safety-critical systems [BS93]. 1.1 Safety-Critical Systems Safety-critical systems are "systems where compelling evidence is required that the system delivers its services in manner that satisfies certain critical properties"[HBGL95].
Reference: [Per87] <author> Dewayne E. Perry. </author> <title> "Software Interconnection Models". </title> <booktitle> In Proceedings of the 9th International Conference on Software Engineering, </booktitle> <pages> pages 61-69. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1987. </year>
Reference-contexts: To simplify the verification of properties of programs, these systems restrict the forms of their formal specification notations or create abstract models from programs that could be analyzed with state-exploration rather than theorem-proving techniques. In Inscape <ref> [Per87, Per89a, Per89b] </ref>, complex logical formulas are abstracted to simple predicates which may be primitive or defined in terms of other predicates (like our relationships). Predicates form pre- and postconditions used to specify implementations.
Reference: [Per89a] <author> Dewayne E. Perry. </author> <booktitle> "The Inscape Environment.". In Proceedings of the 11th International Conference on Software Engineering, </booktitle> <pages> pages 60-68, </pages> <address> Pittsburgh PA, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: To simplify the verification of properties of programs, these systems restrict the forms of their formal specification notations or create abstract models from programs that could be analyzed with state-exploration rather than theorem-proving techniques. In Inscape <ref> [Per87, Per89a, Per89b] </ref>, complex logical formulas are abstracted to simple predicates which may be primitive or defined in terms of other predicates (like our relationships). Predicates form pre- and postconditions used to specify implementations.
Reference: [Per89b] <author> Dewayne E. Perry. </author> <title> "The Logic of Propagation in The Inscape Environment". </title> <booktitle> In Proceedings of the 3rd Symposium on Software Testing, Analysis, and Verification (TAV3), </booktitle> <pages> pages 114-121, </pages> <address> Key West, Florida, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: To simplify the verification of properties of programs, these systems restrict the forms of their formal specification notations or create abstract models from programs that could be analyzed with state-exploration rather than theorem-proving techniques. In Inscape <ref> [Per87, Per89a, Per89b] </ref>, complex logical formulas are abstracted to simple predicates which may be primitive or defined in terms of other predicates (like our relationships). Predicates form pre- and postconditions used to specify implementations.
Reference: [Pet81] <author> J. Peterson. </author> <title> Petri Net Theory and the Modeling of Systems. </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: Both Modecharts [JM86] and TTM [Ost89b] use similar representations, allowing expression of timing and logical properties expressed in RTL and RTTL, respectively. Both approaches are supported with a suite of tools, including verifiers based on model-theoretic reasoning. Petri nets <ref> [Pet81, Rei85] </ref> are used to reason about execution of concurrent processes with a number of (limited) resources. A Petri net is an operational formalism, supporting a notion of state and its evolution.
Reference: [PGJI93] <author> P.Bremond-Gregoire, J.Y.Choi, and I.Lee. </author> <title> "The Soundness and Completeness of ACSR". </title> <type> Technical Report MS-CIS-93-59, </type> <institution> University of Pennsylva-nia, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: This technique is called bisimulation. Process algebras able to express timing properties include: CSR [Ger91, GL92] and ACSR <ref> [PGJI93] </ref>, which adds time to CCS; Timed CSP [RR87], an extension of CSP; 7 Timed LOTOS [BB87], an extension of the ISO standard LOTOS; and a timed version of ACP [JJ91]. 1.3.2 Analysis Techniques Common analysis techniques can be divided into three broad classes: model-theoretic reasoning, proof-theoretic reasoning, and simulation.
Reference: [PM91] <author> D. Parnas and J. Madey. </author> <title> "Functional Documentation for Computer Systems Engineering(Version 2)". </title> <type> Technical Report CRL Report 237, </type> <institution> McMas-ter University, Department of Electrical and Computer Engineering, </institution> <year> 1991. </year>
Reference-contexts: The specification language is precise, can be understood by engineers and software developers, and is easy to use and modify. The initial language lacked an underlying formal semantics. A number of semantics have been proposed <ref> [Atl92, HLK95, Fau89, PM91, van90] </ref>, some of which [HLK95, PM95] became bases of tools automating consistency and completeness checks [HL93] and simulations [CHLR93, PW94] of requirements. <p> The requirements may also be used to generate test oracles for testing program artifacts derived from requirements [PP94]. 14 In this chapter, we describe SCR behavioral requirements and environmental assumptions, and the system goals they are meant to ensure. 2.1 Four Variable Model The Four Variable Model <ref> [PM91, PM95] </ref> describes required system functions, timing, and accuracy as a set of mathematical relations on four sets of variables: monitored and controlled variables, and input and output data items. Figure 2.1 illustrates the approach.
Reference: [PM95] <author> David Lorge Parnas and Jan Madey. </author> <title> "Functional Documents for Computer Systems". </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 25 </volume> <pages> 41-61, </pages> <year> 1995. </year>
Reference-contexts: The specification language is precise, can be understood by engineers and software developers, and is easy to use and modify. The initial language lacked an underlying formal semantics. A number of semantics have been proposed [Atl92, HLK95, Fau89, PM91, van90], some of which <ref> [HLK95, PM95] </ref> became bases of tools automating consistency and completeness checks [HL93] and simulations [CHLR93, PW94] of requirements. <p> The requirements may also be used to generate test oracles for testing program artifacts derived from requirements [PP94]. 14 In this chapter, we describe SCR behavioral requirements and environmental assumptions, and the system goals they are meant to ensure. 2.1 Four Variable Model The Four Variable Model <ref> [PM91, PM95] </ref> describes required system functions, timing, and accuracy as a set of mathematical relations on four sets of variables: monitored and controlled variables, and input and output data items. Figure 2.1 illustrates the approach. <p> When writing designs, we want to reason about requirements-level variables rather than implementation-level structures. * Finally, designs should be able to deal with sensors and actuators of the system, i.e., with IN and OUT relations (see Chapter 2 and <ref> [PM95] </ref>). 38 3.1.1 Design Constructs Typically, control-flow-based PDLs [CG75] are defined by an outer syntax of control structures and inner syntax of other statements. Our PDL's outer syntax is a set of 39 C-like control structures. Our inner syntax consists of annotations special statements describing values of requirements variables.
Reference: [Pnu77] <author> A. Pnueli. </author> <title> "The Temporal Logic of Programs". </title> <booktitle> In Proceedings of 18th Annual Symposium on the Foundations of Computer Science, </booktitle> <pages> pages 46-57, </pages> <year> 1977. </year>
Reference-contexts: Examples of such systems include Real-Time Logic or RTL [JM86], TRIO [GMM90] and ASTRAL [CPKM94]. RTL has been further extended (to RTTL) to describe temporal distance [Ost89b]. Several temporal logics have been developed to describe real-time systems. Linear-time semantics (e.g., <ref> [Pnu77, MP90, MP92] </ref>) describe particular executions of a system, whereas branching-time semantics (e.g., [EH86, CES86]) describe all possible executions. Interval-time semantics (e.g., [SMS82, All83]) are used to express conditions that hold for some nonzero time interval.
Reference: [PP94] <author> D. Peters and D.L. Parnas. </author> <title> "Generating a Test Oracle from Program Documentation". </title> <booktitle> In Proceedings of the 1994 International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <pages> pages 58-65, </pages> <address> Seattle, WA, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: The requirements may also be used to generate test oracles for testing program artifacts derived from requirements <ref> [PP94] </ref>. 14 In this chapter, we describe SCR behavioral requirements and environmental assumptions, and the system goals they are meant to ensure. 2.1 Four Variable Model The Four Variable Model [PM91, PM95] describes required system functions, timing, and accuracy as a set of mathematical relations on four sets of variables: monitored
Reference: [PW94] <author> D.L. Parnas and Y. Wang. </author> <title> "Simulating the Behaviour of Software Modules by Trace Rewriting Systems". </title> <journal> IEEE Transactions on Software Engineering, </journal> 20(10) 750-759, 1994. 
Reference-contexts: The initial language lacked an underlying formal semantics. A number of semantics have been proposed [Atl92, HLK95, Fau89, PM91, van90], some of which [HLK95, PM95] became bases of tools automating consistency and completeness checks [HL93] and simulations <ref> [CHLR93, PW94] </ref> of requirements.
Reference: [QS81] <author> J.P. Quielle and J. Sifakis. </author> <title> "Specification and Verification of Concurrent Systems in CESAR". </title> <booktitle> In Proceedings of the Fifth International Symposium in Programming, </booktitle> <year> 1981. </year>
Reference-contexts: In this chapter we describe how to use the FSM to verify properties generated from SCR specifications. Verification is done by a model-checking algorithm. 4.1 Overview of Model-Checking Introduced by Clarke and Emerson [CES86] and by Quielle and Sifakis <ref> [QS81] </ref>, model checking determines the value of a formula f , typically expressed in temporal logic, for a particular system by building its reachability graph M and computing the set of states in which the formula is true, i.e., fs j M; s j= f g.
Reference: [Ram74] <author> C. Ramchandani. </author> <title> "Analysis of Asynchronous Concurrent Systems by Timed Petri Nets". </title> <type> Technical report, </type> <institution> Massachusetts Institute of Technology, Cam-bridge, Massachusetts, </institution> <year> 1974. </year>
Reference-contexts: A Petri net is an operational formalism, supporting a notion of state and its evolution. Specifications expressed in this notation are executable, and verification is based on building a reachability graph (as in the Berthomieu-Diaz algorithm [BD91]). Two extensions, time Petri nets [MS76] and timed Petri nets (TPNs) <ref> [Ram74] </ref> were introduced for modeling time. Levenson and Stolzy [LS87] use TPNs for safety analysis, without having to generate the entire reachability graph, by working backward from hazardous states to determine if these states are reachable.
Reference: [Rei85] <author> W. Reisig. </author> <title> Petri Nets: An Introduction. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: Both Modecharts [JM86] and TTM [Ost89b] use similar representations, allowing expression of timing and logical properties expressed in RTL and RTTL, respectively. Both approaches are supported with a suite of tools, including verifiers based on model-theoretic reasoning. Petri nets <ref> [Pet81, Rei85] </ref> are used to reason about execution of concurrent processes with a number of (limited) resources. A Petri net is an operational formalism, supporting a notion of state and its evolution.
Reference: [RPRL96] <author> Vivek Ratan, Kurt Partridge, Jon Reese, and Nancy Levenson. </author> <title> "Safety Analysis Tools for Requirements Specifications". </title> <booktitle> In Proceedings of COMPASS'96, </booktitle> <address> Gathersburg, Maryland, </address> <month> June </month> <year> 1996. </year> <note> (to appear). </note>
Reference-contexts: Formal methods play a big role in this effort. A number of formal requirements notations (e.g. the Software Cost Reduction (SCR) notation [AFB + 88, Hen80] and the Requirements State Machine Language (RSML)[JLHM91]) have been used to write requirements for realistic applications and analyze their completeness and consistency <ref> [HBGL95, RPRL96, HL95] </ref>. Verifying that designs and implementations preserve the "correctness" of requirements is not easy. Usually, this is achieved via testing, which can provide only partial coverage of the range of behaviors of the system. The behavior of software is determined by a succession of discrete state changes.
Reference: [RR87] <author> G. Reed and A. Roscoe. </author> <title> "Metric Spaces as Models for Real-Time Concur-rency". </title> <booktitle> In Proceedings of Mathematical Foundations of Computer Science, LNCS, volume 298, </booktitle> <address> New York, 1987. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: This technique is called bisimulation. Process algebras able to express timing properties include: CSR [Ger91, GL92] and ACSR [PGJI93], which adds time to CCS; Timed CSP <ref> [RR87] </ref>, an extension of CSP; 7 Timed LOTOS [BB87], an extension of the ISO standard LOTOS; and a timed version of ACP [JJ91]. 1.3.2 Analysis Techniques Common analysis techniques can be divided into three broad classes: model-theoretic reasoning, proof-theoretic reasoning, and simulation.
Reference: [Rus93] <author> John Rushby. </author> <title> "Formal Methods and the Certification of Critical Systems". </title> <type> Technical Report CSL-93-7, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: Without an assumption of continuity (i.e., that if two "close" tests cases behave correctly, then all intermediate test cases will also behave correctly) there is little reason to suppose the behavior of untested sequences 3 will succeed if the test cases succeed <ref> [Rus93] </ref>. Formal methods can be used to calculate properties of systems for all legal inputs. Formal methods, however, are not frequently used on industrial applications. Applying formal methods requires a level of mathematical sophistication beyond that possessed by many software developers. Many formal methods lack adequate tool support. <p> software requirements via execution has the same drawbacks as testing; namely, the 9 number of test cases needed to cover a specification is unmanageably large for all but the smallest systems [BF91]. 1.4 Industrial Applications of Formal Methods Formal methods can contribute to the development of systems in two ways <ref> [Rus93] </ref>: 1. they can improve the development process, leading to a better product, and/or reduced time and cost; or 2. they can contribute to the assurance and certification of a system. Several industrial projects successfully used formal methods [CGR95].
Reference: [SA96] <author> Tirumale Sreemani and Joanne M. Atlee. </author> <title> "Feasibility of Model Checking Software Requirements: A Case Study". </title> <booktitle> In Proceedings of COMPASS'96, </booktitle> <address> Gathersburg, Maryland, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: However, the entire state space of the model is constructed before the fixed point algorithms can be applied. Various improvements to the original technology allows for efficient checking of large systems [BCM + 90, CGL92, McM93]. The problems successfully solved by model checking are mostly specifications 68 of systems <ref> [Jac94, SA96, ABB + 96] </ref> and hardware designs [CES86, CGH + 93, BCDM86, MS92, Bar95].
Reference: [SMS82] <author> R.L. Schwartz and P.M. Melliar-Smith. </author> <title> "From State Machines to Temporal Logic: Specification Methods for Protocol Standards". </title> <journal> IEEE Transactions on Communications, </journal> <volume> Com-30, </volume> <year> 1982. </year>
Reference-contexts: RTL has been further extended (to RTTL) to describe temporal distance [Ost89b]. Several temporal logics have been developed to describe real-time systems. Linear-time semantics (e.g., [Pnu77, MP90, MP92]) describe particular executions of a system, whereas branching-time semantics (e.g., [EH86, CES86]) describe all possible executions. Interval-time semantics (e.g., <ref> [SMS82, All83] </ref>) are used to express conditions that hold for some nonzero time interval. UNITY [CM88] is a framework for specification and verification that uses extended state-transition systems to model abstract programs in a similar logic.
Reference: [Tay83] <author> Richard N. Taylor. </author> <title> "A General-Purpose Algorithm for Analyzing Concurrent Programs". </title> <journal> Communications of the ACM, </journal> <volume> 26(5) </volume> <pages> 362-376, </pages> <month> May </month> <year> 1983. </year>
Reference-contexts: Thus, we are interested in extending our analysis methods to process designs of concurrent programs. Most of the previous approaches to analysis of concurrent programs have generally abstracted away data values and their effects on control flow to concentrate on task interactions (e.g., <ref> [DC94, FG94, LC91, GL92, Tay83, MR91] </ref>). We perform dataflow analysis on values of requirements variables and include them in the property verification, without building a global reachability graph. In this chapter we use a simple example to introduce new extensions to the requirements and the design languages.
Reference: [Vai91] <author> C. </author> <title> Vail. "Program Verification via Abstraction using Incremental Operational Specifications". </title> <type> PhD thesis, </type> <institution> University of California, </institution> <address> San Diego, </address> <year> 1991. </year>
Reference-contexts: Our PDL's outer syntax is a set of 39 C-like control structures. Our inner syntax consists of annotations special statements describing values of requirements variables. Our use of annotations was inspired by William Howden's work on QDA <ref> [HW94, Vai91] </ref>. For sequential designs, we defined three types of annotations: * An Initial annotation indicates the starting state of each mode class. It unconditionally assigns values to variables.
Reference: [van90] <author> A. J. van Schouwen. </author> <title> "The A-7 Requirements Model: Re-examination for Real-Time Systems and an Application to Monitoring Systems". </title> <type> Technical Report TR-90-276, </type> <institution> Queen's University, Kingston, </institution> <address> Ontario, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: The specification language is precise, can be understood by engineers and software developers, and is easy to use and modify. The initial language lacked an underlying formal semantics. A number of semantics have been proposed <ref> [Atl92, HLK95, Fau89, PM91, van90] </ref>, some of which [HLK95, PM95] became bases of tools automating consistency and completeness checks [HL93] and simulations [CHLR93, PW94] of requirements. <p> Each table entry e i;j represents a conditioned event, so a typical entry is @T (a) when [b]. To indicate that the transition can be triggered when the system enters a particular mode, we use the InMode () function <ref> [van90] </ref>. For example, if e 1;1 were an event @T (InMode), then the change in r j 's values is triggered by the system entering mode m 1 . Below the event table is a starting value for the controlled variable. <p> Verify USER properties of the system. 98 Chapter 5 Case-Study To demonstrate our analysis technique (described in Chapters 2-4) on a more realistic application, we conducted a case study of a Water-Level Monitoring System (WLMS) which had been specified using SCR requirements and subsequently implemented <ref> [van90] </ref>. To create the design, we reversed engineered an existing implementation of WLMS in order to determine what, if any, errors might be detected with our methods. 5.1 The Application A Water-Level Monitoring System (WLMS) is a safety monitoring device, which serves as a component of a steam generator application. <p> A complete description of this system can be found in <ref> [van90] </ref>. WLMS has two mode classes, Normal and Failure. Modeclass Normal is comprised of four modes: Operating The system is running properly. Shutdown The water level is out of range and the system will be shutdown unless conditions change.
Reference: [vPM93] <author> A.J. vanShouwen, D.L. Parnas, and J. Madey. </author> <title> "Documentation of Requirements for Computer Systems". </title> <booktitle> In Proceedings of RE'93 International Symposium on Requirements Engineering, </booktitle> <address> San Diego, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: Several industrial projects successfully used formal methods [CGR95]. For example, SCR methods have been applied to A-7 Operational Flight Control Program [Hen80], a submarine communication system [HM83] and safety-critical components of the Dar-lington nuclear power plant in Canada <ref> [vPM93] </ref>. The SACEM project used Hoare-style proofs to verify a one-line commuter train network in Paris [GH90] . The Traffic Alert and Collision Avoidance System (TCAS II) project used the Requirements State Machine Language [JLHM91] to express the system's requirements.
Reference: [Weg75] <author> Ben Wegbreit. </author> <title> "Property Extraction in Well-Founded Property Sets". </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 1(3) </volume> <pages> 270-285, </pages> <month> September </month> <year> 1975. </year>
Reference-contexts: However, since designs usually consist of several procedures, we need to extend our analysis technique to process these designs. We perform interprocedural analysis using an adaptation of a technique called cloning [CHK92]. A similar algorithm was described in <ref> [Weg75] </ref>. This technique enables Analyzer to analyze each called function only a constant number of times, and to achieve reasonable precision in the analysis. Our algorithm clones a control-flow graph (DFG) of a design of a function each time it is called in a new calling context.
Reference: [WVF95] <author> Jeannette Wing and Mandana Vaziri-Farahani. </author> <title> "Model Checking Software Systems: A Case Study". </title> <booktitle> In Proceedings of the 3rd Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 128-139, </pages> <month> October </month> <year> 1995. </year> <month> 195 </month>
Reference-contexts: Software systems are typically result in a very large state space, and thus some abstractions have to be used to analyze these systems <ref> [WVF95] </ref>. 4.2 Motivation: Why Build Our Own Model-checker? Our methods for constructing finite-state abstractions produced sets of values for each program variable. Set-based approximation stored such sets for every variable, and exact analysis kept snapshots of values of variables for each path to the given node.
Reference: [WZ91] <author> Mark N. Wegman and Kenneth Zadeck. </author> <title> "Constant Propagation". </title> <editor> In Fran Allen, Barry Rosen, and Kenneth Zadeck, editors, </editor> <booktitle> Optimization in Compilers. </booktitle> <publisher> ACM Press, </publisher> <year> 1991. </year> <month> (forthcoming). </month>
Reference-contexts: computation of system states at each node of the DFG is similar to that of constant propagation a compiler technique whose goal is to discover values that are constant for all possible executions of a program and to propagate these constant values as far forward through the program as possible <ref> [WZ91, ASU88] </ref>.
Reference: [YMW93] <author> J. Yang, A.K. Mok, and F. Wang. </author> <title> "Symbolic Model Checking for Event-Driven Real-Time Systems". </title> <booktitle> In Proceedings of the 14th IEEE Real-Time Systems Symposium, </booktitle> <address> Raleigh-Durham, NC, </address> <month> December </month> <year> 1993. </year> <month> 196 </month>
Reference-contexts: A number of model-theoretic approaches incorporated analysis of real-time properties. Examples of such systems are TRIO [GMM90, FM91] and the Modechart verifier 8 [JS88]. In another approach <ref> [YMW93] </ref>, SMV was extended to verify larger systems, by incorporating an efficient technique for timing and event counting. Theorem-proving Proof-theoretic reasoning uses logical rules of deduction to formally prove that a specification satisfies a property of interest or that one system specification is equivalent to another system description.
References-found: 137

