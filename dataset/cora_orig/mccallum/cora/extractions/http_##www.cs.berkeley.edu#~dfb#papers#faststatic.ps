URL: http://www.cs.berkeley.edu/~dfb/papers/faststatic.ps
Refering-URL: http://www.cs.berkeley.edu/~dfb/publist.html
Root-URL: 
Title: Fast Static Analysis of C++ Virtual Function Calls  
Author: David F. Bacon and Peter F. Sweeney 
Abstract: Virtual functions make code easier for programmers to reuse but also make it harder for compilers to analyze. We investigate the ability of three static analysis algorithms to improve C++ programs by resolving virtual function calls, reducing compiled code size, and reducing program complexity so as to improve both human and automated program understanding and analysis. In measurements of 5 programs of significant size (5000 to 20000 lines of code each) we found that the most precise of the three algorithms resolved 60% of the virtual function calls and reduced compiled code size by 22%. Because of its accuracy and speed (2500 lines per second), this algorithm is an excellent candidate for inclusion in production C++ compilers. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Agesen, O. </author> <title> Constraint-based type inference and parametric polymorphism. </title> <booktitle> In Proceedings of the First International Static Analysis Symposium (Namur, </booktitle> <address> Belgium, </address> <month> Sept. </month> <year> 1994), </year> <editor> B. Le Charlier, Ed., </editor> <publisher> Springer-Verlag, </publisher> <pages> pp. 78-100. </pages>
Reference-contexts: Measured speedups for benchmarks of significant size were on the order of 25%, and code size reduction was also on the order of 25%. There has been considerable work on type inference for dynamically typed languages <ref> [20, 8, 1, 17] </ref>. In a recent paper [2], Agesen and Holzle showed that type inference can do as well or better than dynamic receiver predic tion in the self compiler, and proceeded to extrapolate from these results to C++ by excluding dispatches for control structures and primitive types.
Reference: [2] <author> Agesen, O., and H olzle, U. </author> <title> Type feedback vs. concrete type inference: A comparison of optimization techniques for object-oriented languages. </title> <booktitle> In Proceedings of the 1995 ACM Conference on Object Oriented Programming Systems, Languages, and Applications (OOPSLA) (Austin, </booktitle> <address> Texas, Oct. 1995), </address> <publisher> ACM Press, </publisher> <address> New York, New York, </address> <pages> pp. 91-107. </pages>
Reference-contexts: Measured speedups for benchmarks of significant size were on the order of 25%, and code size reduction was also on the order of 25%. There has been considerable work on type inference for dynamically typed languages [20, 8, 1, 17]. In a recent paper <ref> [2] </ref>, Agesen and Holzle showed that type inference can do as well or better than dynamic receiver predic tion in the self compiler, and proceeded to extrapolate from these results to C++ by excluding dispatches for control structures and primitive types.
Reference: [3] <author> Aigner, G., and H olzle, U. </author> <title> Eliminating virtual function calls in C++ programs. </title> <type> Tech. Rep. </type> <institution> TRCS 95-22, University of California, Santa Barbara, </institution> <month> Dec. </month> <year> 1995. </year> <note> URL http://www.cs.ucsb.edu/oocsb. </note>
Reference-contexts: Therefore, unless compilers are improved, the overhead due to virtual function calls is likely to increase as programmers make more extensive use of this feature. Other researchers have shown that virtual function call resolution can result in significant performance improvements in execution time performance for C++ programs <ref> [6, 3, 16] </ref>; in this paper we concentrate on comparing algorithms for resolving virtual function calls, and investigating the reasons for their success or failure. Another opportunity associated with virtual functions is code size reduction. <p> The presence of these language features may or may not have a significant effect on the results this is an area for further study. In addition, our results differ, in some cases substantially, from those reported in two previous studies of C++ virtual function call resolution <ref> [6, 3] </ref>. This would seem to indicate that there is considerable dependence on the benchmark suite. <p> No optimization or tuning has been performed yet. Even without improvement, 2500 lines per second is fast enough to include in a production compiler without significantly increasing compile times. 4 Related Work 4.1 Type Prediction for C++ Aigner and Holzle <ref> [3] </ref> compared the execution time performance improvements due to elimination of virtual function calls via class hierarchy analysis and profile-based type prediction.
Reference: [4] <author> Bacon, D. F., Wegman, M., and Zadeck, K. </author> <title> Rapid type analysis for C++. </title> <type> Tech. Rep. </type> <institution> RC number pending, IBM Thomas J. Watson Research Center, </institution> <year> 1996. </year>
Reference-contexts: Section 4 describes related work, and Section 5 presents our conclusions. 2 Static Analysis In this paper we will be comparing three static analysis algorithms, called Unique Name [6], Class Hierarchy Analysis [11, 13], and Rapid Type Analysis <ref> [4] </ref> (we will sometimes abbreviate them as UN, CHA, and RTA, re-specively). In this section we give a brief overview of the three algorithms, and use a small example program to illustrate the differences between them. <p> Programmers often use type casts that appear to be unsafe in a disciplined and safe manner, as will be seen in the results for one of our benchmarks. 2.3 Rapid Type Analysis Rapid Type Analysis <ref> [4] </ref> starts with a call graph generated by performing Class Hierarchy Analysis. It uses information about instantiated classes to further reduce the set of executable virtual functions, thereby reducing the size of the call graph.
Reference: [5] <author> Burke, M., Carini, P., Choi, J.-D., and Hind, M. </author> <title> Flow-insensitive interprocedural alias analysis in the presence of pointers. </title> <booktitle> In Proceedings of the Seventh International Workshop on Languages and Compilers for Parallel Computing (Ithaca, </booktitle> <address> New York, </address> <month> Aug. </month> <year> 1994), </year> <editor> K. Pingali, U. Banerjee, D. Gel-ernter, A. Nicolau, and D. Padua, Eds., </editor> <volume> vol. </volume> <booktitle> 892 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany, </address> <pages> pp. 234-250. </pages>
Reference-contexts: In a similar vein as Pande and Ryder, Carini et al. [7] have also devised an alias analysis algorithm for C++ based on an algorithm for C and Fortran <ref> [10, 5] </ref>. We are currently collaborating with them on an implementation of their algorithm within our analysis framework.
Reference: [6] <author> Calder, B., and Grunwald, D. </author> <title> Reducing indirect function call overhead in C++ programs. </title> <booktitle> In Conference Record of the Twenty-First ACM Symposium on Principles of Programming Languages (POPL) (Portland, </booktitle> <address> Oregon, Jan. 1994), </address> <publisher> ACM Press, </publisher> <address> New York, New York, </address> <pages> pp. 397-408. </pages>
Reference-contexts: Therefore, unless compilers are improved, the overhead due to virtual function calls is likely to increase as programmers make more extensive use of this feature. Other researchers have shown that virtual function call resolution can result in significant performance improvements in execution time performance for C++ programs <ref> [6, 3, 16] </ref>; in this paper we concentrate on comparing algorithms for resolving virtual function calls, and investigating the reasons for their success or failure. Another opportunity associated with virtual functions is code size reduction. <p> Section 4 describes related work, and Section 5 presents our conclusions. 2 Static Analysis In this paper we will be comparing three static analysis algorithms, called Unique Name <ref> [6] </ref>, Class Hierarchy Analysis [11, 13], and Rapid Type Analysis [4] (we will sometimes abbreviate them as UN, CHA, and RTA, re-specively). In this section we give a brief overview of the three algorithms, and use a small example program to illustrate the differences between them. <p> We then briefly compare them in power to other static analyses, and discuss the interaction of type safety and analysis. 2.1 Unique Name The first published study of virtual function call resolution for C++ was by Calder and Grunwald <ref> [6] </ref>. They were attempting to optimize C++ programs at link time, and therefore had to confine themselves to information available in the object files. <p> The presence of these language features may or may not have a significant effect on the results this is an area for further study. In addition, our results differ, in some cases substantially, from those reported in two previous studies of C++ virtual function call resolution <ref> [6, 3] </ref>. This would seem to indicate that there is considerable dependence on the benchmark suite. <p> We are currently collaborating with them on an implementation of their algorithm within our analysis framework. This will allow a direct comparison of both the precision and the efficiency of alias analysis. 4.3 Other Work in C++ Calder and Grunwald's Unique Name algorithm <ref> [6] </ref> (which might more accurately be called "Unique Signature") is very fast, since it only requires a linear scan over the method declarations in the program. Calder and Grunwald implemented Unique Name as a link-time analysis, and found it to be quite effective.
Reference: [7] <author> Carini, P., Hind, M., and Srinivasan, H. </author> <title> Type analysis algorithm for C++. </title> <type> Tech. Rep. </type> <institution> RC 20267, IBM Thomas J. Watson Research Center, </institution> <year> 1995. </year>
Reference-contexts: In a similar vein as Pande and Ryder, Carini et al. <ref> [7] </ref> have also devised an alias analysis algorithm for C++ based on an algorithm for C and Fortran [10, 5]. We are currently collaborating with them on an implementation of their algorithm within our analysis framework.
Reference: [8] <author> Chambers, C., and Ungar, D. </author> <title> Iterative type analysis and extended message splitting: optimizing dynamically-typed object-oriented programs. </title> <booktitle> LISP and Symbolic Computation 4, </booktitle> <month> 3 (July </month> <year> 1991), </year> <pages> 283-310. </pages>
Reference-contexts: Measured speedups for benchmarks of significant size were on the order of 25%, and code size reduction was also on the order of 25%. There has been considerable work on type inference for dynamically typed languages <ref> [20, 8, 1, 17] </ref>. In a recent paper [2], Agesen and Holzle showed that type inference can do as well or better than dynamic receiver predic tion in the self compiler, and proceeded to extrapolate from these results to C++ by excluding dispatches for control structures and primitive types.
Reference: [9] <author> Chambers, C., Ungar, D., and Lee, E. </author> <title> An efficient implementation of SELF, a dynamically-typed object-oriented language based on prototypes. </title> <booktitle> LISP and Symbolic Computation 4, </booktitle> <month> 3 (July </month> <year> 1991), </year> <pages> 243-281. </pages>
Reference-contexts: The most important language feature that supports abstraction is the dynamic dispatch of methods based on the run-time type of an object. In dynamically typed languages like SmallTalk and SELF, all dispatches are considered dynamic, and eliminating these dynamic dispatches has been essential to obtaining high performance <ref> [9, 14, 22] </ref>. C++ is a more cautiously designed language, and programmers must explicitly request dynamic dispatch by declaring a method to be virtual. C++ programs therefore suffer less of an initial performance penalty, at the cost of reduced flexibility and increased programmer effort.
Reference: [10] <author> Choi, J.-D., Burke, M., and Carini, P. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Conference Record of the Twentieth ACM Symposium on Principles of Programming Languages (POPL) (Charleston, </booktitle> <address> South Carolina, Jan. 1993), </address> <publisher> ACM Press, </publisher> <address> New York, New York, </address> <pages> pp. 232-245. </pages>
Reference-contexts: In a similar vein as Pande and Ryder, Carini et al. [7] have also devised an alias analysis algorithm for C++ based on an algorithm for C and Fortran <ref> [10, 5] </ref>. We are currently collaborating with them on an implementation of their algorithm within our analysis framework.
Reference: [11] <author> Dean, J., Grove, D., and Chambers, C. </author> <title> Optimization of object-oriented programs using static class hierarchy analysis. </title> <booktitle> In Proceedings of the Ninth European Conference on Object-Oriented Programming - ECOOP'95 (Aarhus, </booktitle> <address> Denmark, </address> <month> Aug. </month> <year> 1995), </year> <editor> W. Olthoff, Ed., </editor> <publisher> Springer-Verlag, </publisher> <pages> pp. 77-101. </pages>
Reference-contexts: Section 4 describes related work, and Section 5 presents our conclusions. 2 Static Analysis In this paper we will be comparing three static analysis algorithms, called Unique Name [6], Class Hierarchy Analysis <ref> [11, 13] </ref>, and Rapid Type Analysis [4] (we will sometimes abbreviate them as UN, CHA, and RTA, re-specively). In this section we give a brief overview of the three algorithms, and use a small example program to illustrate the differences between them. <p> There are many foo functions that take no parameters, so it can not resolve the other calls. 2.2 Class Hierarchy Analysis Class Hierarchy Analysis <ref> [11, 13] </ref> uses the combination of the statically declared type of an object with the class hierarchy of the program to determine the set of possible targets of a virtual function call. In Figure 1, p is a 2 pointer whose static type is B*. <p> This is interesting because we found several cases in which Rapid Type Analysis was significantly better than Class Hierarchy Analysis this may indicate that class instantia-tion information is more important than the flow-based information. Dean et al. <ref> [11] </ref> studied virtual method call elimination for the pure object-oriented language Cecil, which includes support for multi-methods. They analyzed the class hierarchy as we do to determine the set of type-correct targets of a virtual method call, and used this information to drive an intraprocedural flow analysis of the methods.
Reference: [12] <author> Diwan, A., Moss, J. E. B., and McKinley, K. S. </author> <title> Analyzing statically-typed object-oriented programs for modern processors. </title> <note> Submitted for publication, </note> <year> 1995. </year>
Reference-contexts: Fernandez [13] implemented virtual function call elimination as part of her study on reducing the cost of opaque types in Modula-3. She essentially implemented Class Hierarchy Analysis, although only for the purpose of resolving virtual calls, and not for eliminating dead code. Diwan et al <ref> [12] </ref> have investigated a number of algorithms for Modula-3, including one similar to Dean et al's, as well as an interprocedural uni-directional flow-sensitive technique, and a "name-sensitive" technique.
Reference: [13] <author> Fernandez, M. F. </author> <title> Simple and effective link-time optimization of Modula-3 programs. </title> <booktitle> In Proceedings of the SIGPLAN Conference on Programming Language Design and Implementation (PLDI) (La Jolla, </booktitle> <address> California, June 1995), </address> <publisher> ACM Press, </publisher> <address> New York, New York, </address> <pages> pp. 103-115. </pages>
Reference-contexts: Section 4 describes related work, and Section 5 presents our conclusions. 2 Static Analysis In this paper we will be comparing three static analysis algorithms, called Unique Name [6], Class Hierarchy Analysis <ref> [11, 13] </ref>, and Rapid Type Analysis [4] (we will sometimes abbreviate them as UN, CHA, and RTA, re-specively). In this section we give a brief overview of the three algorithms, and use a small example program to illustrate the differences between them. <p> There are many foo functions that take no parameters, so it can not resolve the other calls. 2.2 Class Hierarchy Analysis Class Hierarchy Analysis <ref> [11, 13] </ref> uses the combination of the statically declared type of an object with the class hierarchy of the program to determine the set of possible targets of a virtual function call. In Figure 1, p is a 2 pointer whose static type is B*. <p> Of those, Modula-3 is the most similar to C++. Fernandez <ref> [13] </ref> implemented virtual function call elimination as part of her study on reducing the cost of opaque types in Modula-3. She essentially implemented Class Hierarchy Analysis, although only for the purpose of resolving virtual calls, and not for eliminating dead code.
Reference: [14] <author> H olzle, U., Chambers, C., and Ungar, D. </author> <title> Optimizing dynamically-types object-oriented languages with polymorphic inline caches. </title> <booktitle> In Proceedings of the European Conference on Object-Oriented Programming - ECOOP'91 (Geneva, </booktitle> <address> Switzerland, </address> <month> July </month> <year> 1991), </year> <editor> P. America, Ed., </editor> <publisher> Springer-Verlag, </publisher> <pages> pp. 21-38. </pages>
Reference-contexts: The most important language feature that supports abstraction is the dynamic dispatch of methods based on the run-time type of an object. In dynamically typed languages like SmallTalk and SELF, all dispatches are considered dynamic, and eliminating these dynamic dispatches has been essential to obtaining high performance <ref> [9, 14, 22] </ref>. C++ is a more cautiously designed language, and programmers must explicitly request dynamic dispatch by declaring a method to be virtual. C++ programs therefore suffer less of an initial performance penalty, at the cost of reduced flexibility and increased programmer effort.
Reference: [15] <author> Landi, W., Ryder, B. G., and Zhang, S. </author> <title> In-terprocedural modification side effect analysis with pointer aliasing. </title> <booktitle> In Proceedings of the SIGPLAN Conference on Programming Language Design and Implementation (PLDI) (Albuquerque, </booktitle> <address> New Mex-ico, June 1993), </address> <publisher> ACM Press, </publisher> <address> New York, New York, </address> <pages> pp. 56-67. </pages>
Reference-contexts: Pande and Ryder [19, 18] have implemented an alias analysis algorithm for C++ based on Landi et al.'s algorithm for C <ref> [15] </ref>. This analysis is then used to drive virtual function elimination. They give preliminary results for a set of 19 benchmark programs, ranging in size from 31 to 968 lines of code.
Reference: [16] <author> Lee, Y., and Serrano, M. J. </author> <title> Dynamic measurements of C++ program characteristics. </title> <type> Tech. Rep. </type> <institution> ADTI-1995-001, IBM Santa Teresa Laboratory, </institution> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: Box 704, Yorktown Heights, NY 10598, dfb@watson.ibm.com The most obvious opportunity, and the one on which most attention has been focused, is execution time overhead. Even with programmers specifying virtual functions explicitly, the execution time overhead of virtual function calls has been measured to be as high as 40% <ref> [16] </ref>. In addition, as programmers become familiar with the advantages of truly object-oriented design, use of virtual functions increases. The costs associated with developing software are so high that the performance penalty of virtual functions is not sufficient to deter their use. <p> Therefore, unless compilers are improved, the overhead due to virtual function calls is likely to increase as programmers make more extensive use of this feature. Other researchers have shown that virtual function call resolution can result in significant performance improvements in execution time performance for C++ programs <ref> [6, 3, 16] </ref>; in this paper we concentrate on comparing algorithms for resolving virtual function calls, and investigating the reasons for their success or failure. Another opportunity associated with virtual functions is code size reduction.
Reference: [17] <author> Oxhtj, N., Palsberg, J., and Schwartzbach, M. I. </author> <title> Making type inference practical. </title> <booktitle> In Proceedings of the European Conference on Object-Oriented Programming - ECOOP'92 (Utrecht, </booktitle> <address> Netherlands, </address> <month> June </month> <year> 1992), </year> <editor> O. L. Madsen, Ed., </editor> <publisher> Springer-Verlag, </publisher> <pages> pp. 329-349. 13 </pages>
Reference-contexts: Measured speedups for benchmarks of significant size were on the order of 25%, and code size reduction was also on the order of 25%. There has been considerable work on type inference for dynamically typed languages <ref> [20, 8, 1, 17] </ref>. In a recent paper [2], Agesen and Holzle showed that type inference can do as well or better than dynamic receiver predic tion in the self compiler, and proceeded to extrapolate from these results to C++ by excluding dispatches for control structures and primitive types.
Reference: [18] <author> Pande, H. D., and Ryder, B. G. </author> <title> Static type de-termination for C++. </title> <booktitle> In Proceedings of the Sixth Usenix C++ Technical Conference (Apr. </booktitle> <year> 1994), </year> <pages> pp. 85-97. </pages>
Reference-contexts: Pande and Ryder <ref> [19, 18] </ref> have implemented an alias analysis algorithm for C++ based on Landi et al.'s algorithm for C [15]. This analysis is then used to drive virtual function elimination. They give preliminary results for a set of 19 benchmark programs, ranging in size from 31 to 968 lines of code.
Reference: [19] <author> Pande, H. D., and Ryder, B. G. </author> <title> Static type determination and aliasing for C++. </title> <type> Tech. Rep. </type> <institution> LCSR-TR-250, Department of Computer Science, Rutgers University, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: The structure of lcom is more complex, and it seems less likely that it will benefit from more powerful static analysis. We have run our analysis on some of the benchmarks used by Pande and Ryder in their alias analysis work for C++ <ref> [19] </ref>; the results are discussed in detail in Section 4.2. However, their benchmarks are too small to draw any conclusions about real-life performance. Our measurements certainly indicate that alias analysis should not be used until a simpler algorithm like CHA or RTA has been run. <p> Pande and Ryder <ref> [19, 18] </ref> have implemented an alias analysis algorithm for C++ based on Landi et al.'s algorithm for C [15]. This analysis is then used to drive virtual function elimination. They give preliminary results for a set of 19 benchmark programs, ranging in size from 31 to 968 lines of code. <p> So for four out of nine, RTA does as well as alias analysis. Of the remaining five benchmarks, RTA resolved 33% of the virtual call sites in objects, compared to about 50% by alias analysis (for comparative data, see their paper <ref> [19] </ref>). For the remaining four (deriv1, deriv2, family, and office) fast static analysis did not resolve any virtual call sites, and significant fractions of the call sites were dynamically monomorphic.
Reference: [20] <author> Plevyak, J., and Chien, A. A. </author> <title> Precise concrete type inference for object-oriented languages. </title> <booktitle> In Proceedings of the 1994 ACM Conference on Object Oriented Programming Systems, Languages, and Applications (OOPSLA) (Portland, </booktitle> <address> OR, Oct. 1994), </address> <publisher> ACM Press, </publisher> <address> New York, New York, </address> <pages> pp. 324-340. </pages>
Reference-contexts: Measured speedups for benchmarks of significant size were on the order of 25%, and code size reduction was also on the order of 25%. There has been considerable work on type inference for dynamically typed languages <ref> [20, 8, 1, 17] </ref>. In a recent paper [2], Agesen and Holzle showed that type inference can do as well or better than dynamic receiver predic tion in the self compiler, and proceeded to extrapolate from these results to C++ by excluding dispatches for control structures and primitive types.
Reference: [21] <author> Srivastava, A. </author> <title> Unreachable procedures in object-oriented programming. </title> <journal> ACM Letters on Programming Languages and Systems 1, </journal> <month> 4 (December </month> <year> 1992), </year> <pages> 355-364. </pages>
Reference-contexts: With their benchmarks, it resolved anywhere from 2.9% to 70.3% of the virtual calls executed by the program. We found it to be not nearly so effective on our benchmarks, and it was significantly outperformed by Rapid Type Analysis. Srivastava <ref> [21] </ref> developed an analysis technique with the sole object of eliminating unused procedures from C++ programs. He builds a graph starting at the root of the call graph.
Reference: [22] <author> Ungar, D., Smith, R. B., Chambers, C., and Holzle, U. </author> <title> Object, message, and performance: how they coexist in Self. </title> <booktitle> Computer 25, </booktitle> <address> 10 (Oct. </address> <year> 1992), </year> <pages> 53-64. 15 </pages>
Reference-contexts: The most important language feature that supports abstraction is the dynamic dispatch of methods based on the run-time type of an object. In dynamically typed languages like SmallTalk and SELF, all dispatches are considered dynamic, and eliminating these dynamic dispatches has been essential to obtaining high performance <ref> [9, 14, 22] </ref>. C++ is a more cautiously designed language, and programmers must explicitly request dynamic dispatch by declaring a method to be virtual. C++ programs therefore suffer less of an initial performance penalty, at the cost of reduced flexibility and increased programmer effort.
References-found: 22

