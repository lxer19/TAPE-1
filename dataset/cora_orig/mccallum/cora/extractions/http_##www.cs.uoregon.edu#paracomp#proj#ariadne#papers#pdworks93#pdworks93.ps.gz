URL: http://www.cs.uoregon.edu/paracomp/proj/ariadne/papers/pdworks93/pdworks93.ps.gz
Refering-URL: http://www.cs.uoregon.edu/paracomp/proj/ariadne/publications.html
Root-URL: http://www.cs.uoregon.edu
Title: The Ariadne Debugger: Scalable Application of Event-Based Abstraction 1  
Author: Janice Cuny, George Forman, Alfred Hough, Joydip Kundu, Calvin Lin, Lawrence Snyder, and David Stemple 
Date: Revised June 1993  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> G. Alverson, W. Griswold, D. Notkin and L. Snyder. </author> <title> A flexible communication abstraction for nonshared memory parallel computing. </title> <booktitle> Proceedings of Supercomputing '90, </booktitle> <year> 1990. </year>
Reference-contexts: They are described by extensions of regular expressions. When they are matched against an execution history graph, all events in the chain must occur exactly in the order specified with the exception of communication events that are not physically realized because of "edge effects" on process array boundaries <ref> [1] </ref>. * p-Chains are patterns representing the concurrent execution of a chain by a set of processes. They are described by binding a chain to a process set. <p> To ascertain that the correct number of broadcasts were performed, we attempted to match a set of P broadcasts with ? BCseries = match (Broadcast [])^P The missing index in Broadcast [] indicates that any element can be used, making it a shorthand for (Broadcast [0] + Broadcast <ref> [1] </ref> + ... + Broadcast [255]) where + means alternation in our expressions. The match was successful, resulting in Match succeeded. Found 256 p-chains on f0..255g; using 256 processes.
Reference: [2] <author> F. Baiardi, N. De Fransesco and G. Vaglini. </author> <title> Development of a debugger for a concurrent language. </title> <journal> In IEEE Transactions on Software Engineering, </journal> <volume> SE-12(4):547-553, </volume> <month> Apr. </month> <year> 1986. </year>
Reference-contexts: Users are often overwhelmed by large amounts of trace data and confused by the effects of asynchrony. Event-based behavioral abstraction provides a mechanism for managing the volume of data by allowing users to specify models of intended program behavior that are automatically compared to actual program behavior <ref> [2, 3, 5, 14, 16] </ref>. Transformations of logical time ameliorate the difficulties of coping with asynchrony by allowing users to see behavior from a variety of temporal perspectives [7, 15, 19, 21].
Reference: [3] <author> P. C. Bates. </author> <title> Debugging Programs in a Distributed System Environment. </title> <type> PhD thesis, </type> <institution> University of Massachusetts, </institution> <address> Amherst, MA 01003, </address> <year> 1986. </year> <note> Also COINS Technical Report 86-05. </note>
Reference-contexts: Users are often overwhelmed by large amounts of trace data and confused by the effects of asynchrony. Event-based behavioral abstraction provides a mechanism for managing the volume of data by allowing users to specify models of intended program behavior that are automatically compared to actual program behavior <ref> [2, 3, 5, 14, 16] </ref>. Transformations of logical time ameliorate the difficulties of coping with asynchrony by allowing users to see behavior from a variety of temporal perspectives [7, 15, 19, 21]. <p> The matching algorithm for our language is straightforward: a pt-chain is recognized by a finite state machine that invokes copies of other finite state machines to recognize chains on specific processes. This matching can be done efficiently, avoiding the costliness of pattern matching approaches <ref> [3, 13] </ref> and the expensive implementations of previous languages [16]. <p> We had better success in debugging this program with our previous animating debugger, Belvedere [14]. In using Belvedere, we also defined an abstract event that matched the entire set of messages associated with a query; the query itself was much more complex (Belvedere uses the EDL modeling language <ref> [3] </ref>). Initially, the animation was incomprehensible, as shown in Figure 1a because the Query events overlapped in logical time: each query follows data-dependent paths through the cube, arriving in different orders at different processes.
Reference: [4] <author> A. Bowyer. </author> <title> Computing Dirichlet Tesselations. </title> <journal> The Computer Journal, </journal> <volume> 24(2), </volume> <pages> pages 162-166, </pages> <month> Feb. </month> <year> 1981. </year>
Reference-contexts: This observation led us to the bug: a missing synchronization between broadcasts. 3.3 Delaunay Triangulation This example demonstrates that Ariadne can model complex behaviors. The program is a parallel version of Bowyer's algorithm to construct a Delaunay Triangulation <ref> [4] </ref>. In Bowyer's algorithm, points are inserted into an existing mesh one at a time; in our version, they are inserted in parallel. Each point is managed by its own process which communicates with surrounding processes looking for triangles with circumcircles 10 that contain its point.
Reference: [5] <author> B. Bruegge and P. Hibbard. </author> <title> Generalized path expressions: A high level debugging mechanism. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium in High-Level Debugging, </booktitle> <pages> pages 34-44, </pages> <year> 1983. </year>
Reference-contexts: Users are often overwhelmed by large amounts of trace data and confused by the effects of asynchrony. Event-based behavioral abstraction provides a mechanism for managing the volume of data by allowing users to specify models of intended program behavior that are automatically compared to actual program behavior <ref> [2, 3, 5, 14, 16] </ref>. Transformations of logical time ameliorate the difficulties of coping with asynchrony by allowing users to see behavior from a variety of temporal perspectives [7, 15, 19, 21].
Reference: [6] <author> R. Cooper and K. Marzullo. </author> <title> Consistent detection of global predicates. </title> <booktitle> In Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 167-174, </pages> <year> 1991. </year>
Reference-contexts: Instead, the programmer is concerned with the logical ordering of events. At the primitive event level, this ordering is captured by Lamport's happened before relation. Other debuggers have used temporal logic to express assertions about happened before <ref> [6, 10] </ref> but they do not use behavioral abstraction. We extend the relation to abstract events, defining three relations: precedes, parallels, and overlaps [15].
Reference: [7] <author> J. E. Cuny, A. Hough, and J. Kundu. </author> <title> Logical time in visualizations produced by parallel programs. </title> <booktitle> Proceedings of Visualization '92, </booktitle> <pages> pages 186-193 (1992). </pages>
Reference-contexts: Transformations of logical time ameliorate the difficulties of coping with asynchrony by allowing users to see behavior from a variety of temporal perspectives <ref> [7, 15, 19, 21] </ref>. Previously, we combined these features in a debugger that automatically constructed animations of user-defined abstract events in logical time [14]. However, our debugger, like many others, did not always provide sufficient feedback nor did it effectively scale up for massive parallelism. <p> When we asked the debugger to ignore all orderings except those imposed by accesses to queue locations, we were able to correctly interpret the behavior of the program <ref> [7] </ref>.
Reference: [8] <author> C. J. Fidge. </author> <title> Partial orders for parallel debugging. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(1), </volume> <pages> pages 183-194, </pages> <year> 1989. </year>
Reference-contexts: Similar extensions have been proposed <ref> [8, 16, 18] </ref> but we have found our definitions to be more appropriate for debugging.
Reference: [9] <author> R. J. Fowler, T. J. Leblanc, and J. M. Mellor-Crummey. </author> <title> An integrated approach to parallel program debugging and performance analysis on large-scale multiprocessors. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(1), </volume> <pages> pages 163-173, </pages> <year> 1989. </year>
Reference-contexts: A number of debuggers provide visualizations of execution history graphs <ref> [9, 11, 12, 21] </ref> but such visualizations do not scale well for massively parallel systems. Ariadne allows the user to view the graph but it does not rely on visualization. Instead, it supports interactive, textual explorations of the graph.
Reference: [10] <author> G. S. Goldszmidt, S. Katz, and S. Yemini. </author> <title> High level language for debugging concurrent programs. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(4), </volume> <pages> pages 311-336, </pages> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: Instead, the programmer is concerned with the logical ordering of events. At the primitive event level, this ordering is captured by Lamport's happened before relation. Other debuggers have used temporal logic to express assertions about happened before <ref> [6, 10] </ref> but they do not use behavioral abstraction. We extend the relation to abstract events, defining three relations: precedes, parallels, and overlaps [15].
Reference: [11] <author> P. K. Harter, D. M. Heimbigner and R. King. IDD: </author> <title> an interactive distributed debugger. </title> <booktitle> In Proceedings of the 5th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 498-506, </pages> <year> 1985. </year>
Reference-contexts: A number of debuggers provide visualizations of execution history graphs <ref> [9, 11, 12, 21] </ref> but such visualizations do not scale well for massively parallel systems. Ariadne allows the user to view the graph but it does not rely on visualization. Instead, it supports interactive, textual explorations of the graph.
Reference: [12] <author> M. Heath and J. Etheridge. </author> <title> Visualizing the performance of parallel programs. </title> <journal> IEEE Software, </journal> <volume> 8(5) </volume> <pages> 29-39, </pages> <year> 1991. </year>
Reference-contexts: A number of debuggers provide visualizations of execution history graphs <ref> [9, 11, 12, 21] </ref> but such visualizations do not scale well for massively parallel systems. Ariadne allows the user to view the graph but it does not rely on visualization. Instead, it supports interactive, textual explorations of the graph.
Reference: [13] <author> D. Hembold and D. Luckham. </author> <title> Debugging Ada tasking programs. </title> <journal> IEEE Software, </journal> <volume> 2(2), </volume> <pages> pages 47-57, </pages> <month> Mar. </month> <year> 1985. </year>
Reference-contexts: The matching algorithm for our language is straightforward: a pt-chain is recognized by a finite state machine that invokes copies of other finite state machines to recognize chains on specific processes. This matching can be done efficiently, avoiding the costliness of pattern matching approaches <ref> [3, 13] </ref> and the expensive implementations of previous languages [16]. <p> We hypothesized that there must have been some interference between insertions. To check this, we used the following query, looking just at the "successful" portion of the matched additions. ? e_non_overlaps (Triangulation WRT fstart,endg) Assertion Failed. AddPoint [17] overlaps AddPoint <ref> [13] </ref> AddPoint [55] overlaps AddPoint [54] AddPoint [100] overlaps AddPoint [98] The feedback on the failure of this assertion led us to investigate the pairs of points that had overlapping insertions. We discovered that processes in each pair shared common triangle vertices.
Reference: [14] <author> A. A. Hough. </author> <title> Debugging Parallel Programs Using Abstract Visualizations. </title> <type> PhD thesis, </type> <institution> University of Massachusetts, </institution> <address> Amherst, MA 01003, </address> <year> 1991. </year> <note> Also COINS Technical Report 91-53. </note>
Reference-contexts: Users are often overwhelmed by large amounts of trace data and confused by the effects of asynchrony. Event-based behavioral abstraction provides a mechanism for managing the volume of data by allowing users to specify models of intended program behavior that are automatically compared to actual program behavior <ref> [2, 3, 5, 14, 16] </ref>. Transformations of logical time ameliorate the difficulties of coping with asynchrony by allowing users to see behavior from a variety of temporal perspectives [7, 15, 19, 21]. <p> Transformations of logical time ameliorate the difficulties of coping with asynchrony by allowing users to see behavior from a variety of temporal perspectives [7, 15, 19, 21]. Previously, we combined these features in a debugger that automatically constructed animations of user-defined abstract events in logical time <ref> [14] </ref>. However, our debugger, like many others, did not always provide sufficient feedback nor did it effectively scale up for massive parallelism. Our modeling language required complex recognition algorithms which precluded informative feedback on abstractions that did not correspond to observed behavior. <p> Found 2 p-chains on f8g; using 8 processes. The match succeeds but it does not give us any information about the error. Further investigations using Ariadne did not help. We had better success in debugging this program with our previous animating debugger, Belvedere <ref> [14] </ref>. In using Belvedere, we also defined an abstract event that matched the entire set of messages associated with a query; the query itself was much more complex (Belvedere uses the EDL modeling language [3]).
Reference: [15] <author> A. A. Hough and J. E. Cuny. </author> <title> Perspective views: A technique for enchancing visualizations of parallel programs. </title> <booktitle> In 1990 International Conference on Parallel Processing, </booktitle> <pages> pages II 124-132, </pages> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: Transformations of logical time ameliorate the difficulties of coping with asynchrony by allowing users to see behavior from a variety of temporal perspectives <ref> [7, 15, 19, 21] </ref>. Previously, we combined these features in a debugger that automatically constructed animations of user-defined abstract events in logical time [14]. However, our debugger, like many others, did not always provide sufficient feedback nor did it effectively scale up for massive parallelism. <p> At the primitive event level, this ordering is captured by Lamport's happened before relation. Other debuggers have used temporal logic to express assertions about happened before [6, 10] but they do not use behavioral abstraction. We extend the relation to abstract events, defining three relations: precedes, parallels, and overlaps <ref> [15] </ref>. <p> Ariadne, like our previous debugger, allows the user to selectively ignore some logical orderings and thus manipulate logical time to create different perspectives on program behavior <ref> [15] </ref>. 2.3 Ariadne Queries In the design of our language, we traded expressivity for simplicity, so we cannot always describe the intended behaviors precisely. To compensate, Ariadne provides a set of functions that return characteristics of a match.
Reference: [16] <author> W. Hseush and G. E. Kaiser. </author> <title> Modeling concurrency in parallel debugging. </title> <booktitle> In Proceedings of the Second ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 11-20, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Users are often overwhelmed by large amounts of trace data and confused by the effects of asynchrony. Event-based behavioral abstraction provides a mechanism for managing the volume of data by allowing users to specify models of intended program behavior that are automatically compared to actual program behavior <ref> [2, 3, 5, 14, 16] </ref>. Transformations of logical time ameliorate the difficulties of coping with asynchrony by allowing users to see behavior from a variety of temporal perspectives [7, 15, 19, 21]. <p> This matching can be done efficiently, avoiding the costliness of pattern matching approaches [3, 13] and the expensive implementations of previous languages <ref> [16] </ref>. At the same time, our matching algorithm can provide precise information on the reasons for a match failure. 2.2 Logical Time Manipulation in Ariadne Programmers are often confused by the results of asynchronous executions because they can not foresee all possible interleavings of events. <p> Similar extensions have been proposed <ref> [8, 16, 18] </ref> but we have found our definitions to be more appropriate for debugging.
Reference: [17] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-565, </pages> <year> 1978. </year>
Reference-contexts: 5 In Greek mythology, Ariadne provided Theseus with the thread that enabled him to find his way through the Labyrinth to slay the Minotaur. 6 Currently our traces are taken from a simulator or generated by hand. represent communication events; from these traces we can derive Lamport's happened before relation <ref> [17] </ref>. A number of debuggers provide visualizations of execution history graphs [9, 11, 12, 21] but such visualizations do not scale well for massively parallel systems. Ariadne allows the user to view the graph but it does not rely on visualization. Instead, it supports interactive, textual explorations of the graph. <p> We hypothesized that there must have been some interference between insertions. To check this, we used the following query, looking just at the "successful" portion of the matched additions. ? e_non_overlaps (Triangulation WRT fstart,endg) Assertion Failed. AddPoint <ref> [17] </ref> overlaps AddPoint [13] AddPoint [55] overlaps AddPoint [54] AddPoint [100] overlaps AddPoint [98] The feedback on the failure of this assertion led us to investigate the pairs of points that had overlapping insertions. We discovered that processes in each pair shared common triangle vertices.
Reference: [18] <author> L. Lamport. </author> <title> The mutual exclusion problem: Part I-A theory of interprocess communication. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 33(2) </volume> <pages> 313-326, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: Similar extensions have been proposed <ref> [8, 16, 18] </ref> but we have found our definitions to be more appropriate for debugging.
Reference: [19] <author> R. J. LeBlanc and A. D. Robbins. </author> <title> Event-driven monitoring of distributed programs. </title> <booktitle> In Proceedings of the 5th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 515-522, </pages> <year> 1985. </year>
Reference-contexts: Transformations of logical time ameliorate the difficulties of coping with asynchrony by allowing users to see behavior from a variety of temporal perspectives <ref> [7, 15, 19, 21] </ref>. Previously, we combined these features in a debugger that automatically constructed animations of user-defined abstract events in logical time [14]. However, our debugger, like many others, did not always provide sufficient feedback nor did it effectively scale up for massive parallelism.
Reference: [20] <author> T. J. LeBlanc and J. M. Mellor-Crummey. </author> <title> Debugging parallel programs with instant replay. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36(4):471-482, </volume> <month> Apr. </month> <year> 1987. </year>
Reference-contexts: Debugging Session In the current version of Ariadne, we do not have access to the contents of a message or its type. It is not practical to include the contents of all messages in every trace, but it is possible to use a replay mechanism <ref> [20, 23] </ref> to acquire additional trace information. We expect to include access to such information in future versions of our debugger. For purposes of this example, we achieved the same affect by modifying the program so it sends different message types on different, named channels.
Reference: [21] <author> T. J. LeBlanc, J. M. Mellor-Crummey, and R. J. Fowler. </author> <title> Analyzing parallel program executions using multiple views. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 9 </volume> <pages> 203-217, </pages> <year> 1990. </year>
Reference-contexts: Transformations of logical time ameliorate the difficulties of coping with asynchrony by allowing users to see behavior from a variety of temporal perspectives <ref> [7, 15, 19, 21] </ref>. Previously, we combined these features in a debugger that automatically constructed animations of user-defined abstract events in logical time [14]. However, our debugger, like many others, did not always provide sufficient feedback nor did it effectively scale up for massive parallelism. <p> A number of debuggers provide visualizations of execution history graphs <ref> [9, 11, 12, 21] </ref> but such visualizations do not scale well for massively parallel systems. Ariadne allows the user to view the graph but it does not rely on visualization. Instead, it supports interactive, textual explorations of the graph.
Reference: [22] <author> V. M. Lo, S. Rajopadhye, M. A. Mohamed, S. Gupta, B. Nitzberg, J. A. Telle, X. X. Zhong. LaRCS: </author> <title> A language for describing parallel computations for the purpose of mapping. </title> <type> Technical Report CIS-TR-90-16, </type> <institution> University of Oregon Dept. of Computer Science, </institution> <year> 1990. </year>
Reference-contexts: These three definitional levels appear to form a natural mechanism for describing parallel systems, as evidenced by their use in other contexts such as the XYZ levels of Phase Abstractions [24] and the LaRCS specification language <ref> [22] </ref>. The matching algorithm for our language is straightforward: a pt-chain is recognized by a finite state machine that invokes copies of other finite state machines to recognize chains on specific processes.
Reference: [23] <author> B. Miller and J.-D. Choi. </author> <title> A mechanism for efficient debugging of parallel programs. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(1), </volume> <pages> pages 141-150, </pages> <year> 1989. </year>
Reference-contexts: Debugging Session In the current version of Ariadne, we do not have access to the contents of a message or its type. It is not practical to include the contents of all messages in every trace, but it is possible to use a replay mechanism <ref> [20, 23] </ref> to acquire additional trace information. We expect to include access to such information in future versions of our debugger. For purposes of this example, we achieved the same affect by modifying the program so it sends different message types on different, named channels.
Reference: [24] <author> L. Snyder. </author> <title> The XYZ abstraction levels of Poker-like languages. Languages and Compilers for Parallel Computing, </title> <editor> David Gelernter and Alexandru Nicolau and David Padua(eds.), </editor> <publisher> MIT Press, </publisher> <pages> pages 470-489, </pages> <year> 1990. </year>
Reference-contexts: These three definitional levels appear to form a natural mechanism for describing parallel systems, as evidenced by their use in other contexts such as the XYZ levels of Phase Abstractions <ref> [24] </ref> and the LaRCS specification language [22]. The matching algorithm for our language is straightforward: a pt-chain is recognized by a finite state machine that invokes copies of other finite state machines to recognize chains on specific processes.
References-found: 24

