URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/user/fp/www/courses/comp-ded/notes/chap1-2.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/user/fp/www/courses/comp-ded/notes.html
Root-URL: http://www.cs.cmu.edu
Title: Computation and Deduction  
Author: Frank Pfenning 
Date: January 14, 1997  
Note: Draft of  Copyright c Frank Pfenning 1992-1996  
Affiliation: Carnegie Mellon University  
Abstract: Draft notes for a course given at Carnegie Mellon University during the fall semester of 1994. Please send comments to fp@cs.cmu.edu. Do not cite, copy, or distribute without the express written consent of Frank Pfenning and the National Football League. 
Abstract-found: 1
Intro-found: 1
Reference: [ACCL91] <author> Martn Abadi, Luca Cardelli, Pierre-Louis Curien, and Jean-Jacques Levy. </author> <title> Explicit substitutions. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(4) </volume> <pages> 375-416, </pages> <month> October </month> <year> 1991. </year>
Reference: [AINP88] <author> Peter B. Andrews, Sunil Issar, Daniel Nesmith, and Frank Pfenning. </author> <title> The TPS theorem proving system. </title> <editor> In Ewing Lusk and Russ Overbeek, editors, </editor> <booktitle> 9th International Conference on Automated Deduction, </booktitle> <address> Argonne, </address> <publisher> Illinois, </publisher> <pages> pages 760-761, </pages> <address> Berlin, </address> <month> May </month> <year> 1988. </year> <note> Springer-Verlag LNCS 310. System abstract. </note>
Reference: [All75] <editor> William Allingham. In Fairy Land. Longmans, Green, </editor> <publisher> and Co., </publisher> <address> London, England, </address> <month> 1875. </month>
Reference: [And93] <author> Penny Anderson. </author> <title> Program Derivation by Proof Transformation. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <month> October </month> <year> 1993. </year> <note> Available as Technical Report CMU-CS-93-206. </note>
Reference: [Avr87] <author> Arnon Avron. </author> <title> Simple consequence relations. </title> <type> Technical report, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, Edinburgh, </institution> <address> Scotland, </address> <year> 1987. </year>
Reference: [CCM87] <editor> Guy Cousineau, Pierre-Louis Curien, and Michel Mauny. </editor> <booktitle> The categorical abstract machine. Science of Computer Programming, </booktitle> <volume> 8, </volume> <month> May </month> <year> 1987. </year>
Reference: [CDDK86] <author> Dominique Clement, Joelle Despeyroux, Thierry Despeyroux, and Gilles Kahn. </author> <title> A simple applicative language: </title> <booktitle> Mini-ML. In Proceedings of the 1986 Conference on LISP and Functional Programming, </booktitle> <pages> pages 13-27. </pages> <publisher> ACM Press, </publisher> <year> 1986. </year>
Reference-contexts: The version of Mini-ML we present here lies in between the language introduced in <ref> [CDDK86] </ref> and call-by-value PCF [Plo75, Plo77]. The description consists of three parts: (1) the abstract syntax, (2) the operational semantics, and (3) the type system.
Reference: [CF58] <author> H. B. Curry and R. Feys. </author> <title> Combinatory Logic. </title> <publisher> North-Holland, </publisher> <address> Amster-dam, </address> <year> 1958. </year>
Reference-contexts: The study of deductive systems since the pioneering work of Gentzen has arrived at various styles of calculi, each with its own concepts and methods independent of any particular logical interpretation of the formalism. Systems in the style of Hilbert [HB34] have a close connection to combinatory calculi <ref> [CF58] </ref>. They are characterized by many axioms and a small number of inference rules. Systems of natural deduction [Gen35, Pra65] are most relevant to these notes, since they directly define the meaning of logical symbols via inference rules. <p> Thus types are external to the language of expressions and a judgment such as . e : t may be considered as establishing a property of the (untyped) expression e. This view of types has been associated with Curry <ref> [Cur34, CF58] </ref>, and systems of this style are often called type assignment systems. An alternative is a system in the style of Church [Chu32, Chu33, Chu41], in which types are included within expressions, and every well-typed expression has a unique type.
Reference: [CH88] <author> Thierry Coquand and Gerard Huet. </author> <title> The Calculus of Constructions. </title> <journal> Information and Computation, </journal> 76(2/3):95-120, February/March 1988. <volume> 277 </volume> 278 BIBLIOGRAPHY 
Reference: [Chu32] <author> A. Church. </author> <title> A set of postulates for the foundation of logic I. </title> <journal> Annals of Mathematics, </journal> <volume> 33 </volume> <pages> 346-366, </pages> <year> 1932. </year>
Reference-contexts: This view of types has been associated with Curry [Cur34, CF58], and systems of this style are often called type assignment systems. An alternative is a system in the style of Church <ref> [Chu32, Chu33, Chu41] </ref>, in which types are included within expressions, and every well-typed expression has a unique type. We will discuss such a system in Section 9.1. 2.5.
Reference: [Chu33] <author> A. Church. </author> <title> A set of postulates for the foundation of logic II. </title> <journal> Annals of Mathematics, </journal> <volume> 34 </volume> <pages> 839-864, </pages> <year> 1933. </year>
Reference-contexts: This view of types has been associated with Curry [Cur34, CF58], and systems of this style are often called type assignment systems. An alternative is a system in the style of Church <ref> [Chu32, Chu33, Chu41] </ref>, in which types are included within expressions, and every well-typed expression has a unique type. We will discuss such a system in Section 9.1. 2.5.
Reference: [Chu40] <author> Alonzo Church. </author> <title> A formulation of the simple theory of types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 5 </volume> <pages> 56-68, </pages> <year> 1940. </year>
Reference: [Chu41] <author> Alonzo Church. </author> <title> The Calculi of Lambda-Conversion. </title> <publisher> Princeton University Press, </publisher> <address> Princeton, New Jersey, </address> <year> 1941. </year>
Reference-contexts: This view of types has been associated with Curry [Cur34, CF58], and systems of this style are often called type assignment systems. An alternative is a system in the style of Church <ref> [Chu32, Chu33, Chu41] </ref>, in which types are included within expressions, and every well-typed expression has a unique type. We will discuss such a system in Section 9.1. 2.5.
Reference: [Coq91] <author> Thierry Coquand. </author> <title> An algorithm for testing conversion in type theory. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 255-279. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference: [CP88] <author> Thierry Coquand and Christine Paulin. </author> <title> Inductively defined types. </title> <editor> In P. Martin-Lof and G. Mints, editors, </editor> <booktitle> COLOG-88, </booktitle> <pages> pages 50-66. </pages> <publisher> Springer-Verlag LNCS 417, </publisher> <month> December </month> <year> 1988. </year>
Reference: [Cur34] <author> H. B. Curry. </author> <title> Functionality in combinatory logic. </title> <booktitle> Proceedings of the National Academy of Sciences, U.S.A., </booktitle> <volume> 20 </volume> <pages> 584-590, </pages> <year> 1934. </year>
Reference-contexts: Thus types are external to the language of expressions and a judgment such as . e : t may be considered as establishing a property of the (untyped) expression e. This view of types has been associated with Curry <ref> [Cur34, CF58] </ref>, and systems of this style are often called type assignment systems. An alternative is a system in the style of Church [Chu32, Chu33, Chu41], in which types are included within expressions, and every well-typed expression has a unique type.
Reference: [dB72] <author> N. G. de Bruijn. </author> <title> Lambda-calculus notation with nameless dummies: a tool for automatic formula manipulation with application to the Church-Rosser theorem. </title> <journal> Indag. Math., </journal> <volume> 34(5) </volume> <pages> 381-392, </pages> <year> 1972. </year>
Reference: [dB80] <author> N. G. de Bruijn. </author> <title> A survey of the project Automath. </title> <editor> In J. P. Seldin and J. R. Hindley, editors, To H. B. </editor> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 579-606. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference: [DM82] <author> Luis Damas and Robin Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Proceedings of the 9th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-212. </pages> <publisher> ACM SIGPLAN/SIGACT, </publisher> <year> 1982. </year>
Reference-contexts: THE TYPE SYSTEM 21 Mini-ML as presented by Clement et al. is a language with some limited poly-morphism, in that it explicitly distinguishes simple types and type schemes with some restrictions on the use of type schemes. This notion of polymorphism was introduced by Milner <ref> [Mil78, DM82] </ref>. We will refer to it as schematic polymor-phism. In our formulation, we will be able to avoid using type schemes completely by distinguishing two forms of definitions via let, one of which is polymorphic. A formulation in this style orginates with Hannan and Miller [HM89, Han91].
Reference: [Dow93] <author> Gilles Dowek. </author> <title> The undecidability of typability in the lambda-pi-calculus. </title> <editor> In M. Bezem and J.F. Groote, editors, </editor> <booktitle> Proceedings of the International Conference on Typed Lambda Calculi and Applications, </booktitle> <pages> pages 139-145, </pages> <address> Utrecht, The Netherlands, March 1993. </address> <publisher> Springer-Verlag LNCS 664. </publisher>
Reference: [DP91] <author> Scott Dietzen and Frank Pfenning. </author> <title> A declarative alternative to assert in logic programming. </title> <editor> In Vijay Saraswat and Kazunori Ueda, editors, </editor> <booktitle> International Logic Programming Symposium, </booktitle> <pages> pages 372-386. </pages> <publisher> MIT Press, </publisher> <month> October </month> <year> 1991. </year> <note> BIBLIOGRAPHY 279 </note>
Reference: [Ell89] <author> Conal Elliott. </author> <title> Higher-order unification with dependent types. </title> <editor> In N. Der-showitz, editor, </editor> <booktitle> Rewriting Techniques and Applications, </booktitle> <pages> pages 121-136, </pages> <address> Chapel Hill, North Carolina, April 1989. </address> <publisher> Springer-Verlag LNCS 355. </publisher>
Reference: [Ell90] <author> Conal M. Elliott. </author> <title> Extensions and Applications of Higher-Order Unification. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> May </month> <year> 1990. </year> <note> Available as Technical Report CMU-CS-90-134. </note>
Reference: [EP89] <author> Conal Elliott and Frank Pfenning. eLP: </author> <title> A Common Lisp implementation of Prolog in the Ergo Support System. Available via ftp over the Internet, </title> <month> October </month> <year> 1989. </year> <title> Send mail to elp-request@cs.cmu.edu on the Internet for further information. </title>
Reference: [FP91] <author> Tim Freeman and Frank Pfenning. </author> <title> Refinement types for ML. </title> <booktitle> In Proceedings of the SIGPLAN '91 Symposium on Language Design and Implementation, </booktitle> <address> Toronto, Ontario, </address> <pages> pages 268-277. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1991. </year>
Reference: [Gar92] <author> Philippa Gardner. </author> <title> Representing Logics in Type Theory. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <month> July </month> <year> 1992. </year> <note> Available as Technical Report CST-93-92. </note>
Reference: [Gen35] <author> Gerhard Gentzen. </author> <title> Untersuchungen uber das logische Schlieen. </title> <journal> Math-ematische Zeitschrift, </journal> <volume> 39 </volume> <pages> 176-210, 405-431, </pages> <year> 1935. </year>
Reference-contexts: Alternatively we might say that the set of derivable judgments is the least set of judgments containing the axioms and closed under the rules of inference. The underlying view that axioms and inference rules provide a semantic definition for a language was also advanced by Gentzen <ref> [Gen35] </ref> and is sometimes referred to as proof-theoretic semantics. A study of deductive systems is then a semantic investigation with syntactic means. <p> Systems in the style of Hilbert [HB34] have a close connection to combinatory calculi [CF58]. They are characterized by many axioms and a small number of inference rules. Systems of natural deduction <ref> [Gen35, Pra65] </ref> are most relevant to these notes, since they directly define the meaning of logical symbols via inference rules. They are also closely related to typed -calculi and thus programming languages via the so-called Curry-Howard isomorphism [How69].
Reference: [Geu92] <author> Herman Geuvers. </author> <title> The Church-Rosser property for fi-reduction in typed -calculi. </title> <editor> In A. Scedrov, editor, </editor> <booktitle> Seventh Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 453-460, </pages> <address> Santa Cruz, California, </address> <month> June </month> <year> 1992. </year>
Reference: [God90] <author> Kurt Godel. </author> <title> On an extension of finitary mathematics which has not yet been used. In Kurt Godel, Collected Works, </title> <booktitle> Volume II, </booktitle> <pages> pages 271-280. </pages> <publisher> Oxford University Press, </publisher> <year> 1990. </year>
Reference: [Gol81] <author> Warren D. Goldfarb. </author> <title> The undecidability of the second-order unification problem. </title> <journal> Theoretical Computer Science, </journal> <volume> 13 </volume> <pages> 225-230, </pages> <year> 1981. </year>
Reference: [GS84] <author> Ferenc Gecseg and Magnus Steinby. </author> <title> Tree Automata. </title> <publisher> Akademiai Kiado, </publisher> <address> Budapest, </address> <year> 1984. </year>
Reference: [Gun92] <author> Carl A. Gunter. </author> <title> Semantics of Programming Languages. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1992. </year>
Reference-contexts: This is not the case: there are many choices. Especially the mathematical domains we use to interpret expressions and the structure we impose on them leave open many possibilites. For more on the subject of denotational semantics see, for example, <ref> [Gun92] </ref>. In the approach above, the meaning of an expression depends on its type. For example, for the expression id = lam x: x we have . id : nat ! nat and by the reasoning above we can interpret it as a function from natural numbers to natural numbers.
Reference: [Han91] <author> John Hannan. </author> <title> Investigating a Proof-Theoretic Meta-Language for Functional Programs. </title> <type> PhD thesis, </type> <institution> University of Pennsylvania, </institution> <month> January </month> <year> 1991. </year> <note> Available as MS-CIS-91-09. 280 BIBLIOGRAPHY </note>
Reference-contexts: We will refer to it as schematic polymor-phism. In our formulation, we will be able to avoid using type schemes completely by distinguishing two forms of definitions via let, one of which is polymorphic. A formulation in this style orginates with Hannan and Miller <ref> [HM89, Han91] </ref>. See also ??. Types t ::= nat j t 1 fi t 2 j t 1 ! t 2 j ff Here, ff stands for type variables. We also need a notion of context which assigns types to free variables in an expression.
Reference: [Har90] <author> Robert Harper. </author> <title> Systems of polymorphic type assignment in LF. </title> <type> Technical Report CMU-CS-90-144, </type> <institution> Carnegie Mellon University, Pittsburgh, Pennsylvania, </institution> <month> June </month> <year> 1990. </year>
Reference: [HB34] <author> David Hilbert and Paul Bernays. </author> <title> Grundlagen der Mathematik. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1934. </year>
Reference-contexts: The study of deductive systems since the pioneering work of Gentzen has arrived at various styles of calculi, each with its own concepts and methods independent of any particular logical interpretation of the formalism. Systems in the style of Hilbert <ref> [HB34] </ref> have a close connection to combinatory calculi [CF58]. They are characterized by many axioms and a small number of inference rules. Systems of natural deduction [Gen35, Pra65] are most relevant to these notes, since they directly define the meaning of logical symbols via inference rules.
Reference: [Her30] <author> Jacques Herbrand. </author> <title> Recherches sur la theorie de la demonstration. </title> <institution> Travaux de la Societe des Sciences et de Lettres de Varsovic, </institution> <month> 33, </month> <year> 1930. </year>
Reference: [HHP93] <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 40(1) </volume> <pages> 143-184, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Informally, the meta-language is centered on the notions of judgment and deductive system explained below. They have been formalized in a logical framework (LF) <ref> [HHP93] </ref> in which judgments can be specified at a high level of abstraction, consistent with informal practice in computer science. LF has been given an operational interpretation in the Elf meta-programming language [Pfe91a], thus providing means for a computational meta-theory. <p> Meta-theory based on deductive systems requires surprisingly few principles: induction over the structure of derivations is by far the most common technique. Thirdly, we would like the reader to understand how to employ the LF logical framework <ref> [HHP93] </ref> and its implementation in Elf [Pfe91a] in order to implement these definitions and related algorithms. This serves several purposes. Perhaps the most important is that it allows hands-on experimentation with otherwise dry definitions and theorems.
Reference: [HM89] <author> John Hannan and Dale Miller. </author> <title> A meta-logic for functional programming. </title> <editor> In H. Abramson and M. Rogers, editors, </editor> <booktitle> Meta-Programming in Logic Programming, </booktitle> <pages> pages 453-476. </pages> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: We will refer to it as schematic polymor-phism. In our formulation, we will be able to avoid using type schemes completely by distinguishing two forms of definitions via let, one of which is polymorphic. A formulation in this style orginates with Hannan and Miller <ref> [HM89, Han91] </ref>. See also ??. Types t ::= nat j t 1 fi t 2 j t 1 ! t 2 j ff Here, ff stands for type variables. We also need a notion of context which assigns types to free variables in an expression.
Reference: [HM90] <author> John Hannan and Dale Miller. </author> <title> From operational semantics to abstract machines: Preliminary results. </title> <editor> In M. Wand, editor, </editor> <booktitle> Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 323-332, </pages> <address> Nice, France, </address> <year> 1990. </year>
Reference: [How69] <author> W. A. Howard. </author> <title> The formulae-as-types notion of construction. </title> <type> Unpublished manuscript, </type> <year> 1969. </year> <note> Reprinted in To H. </note> <editor> B. </editor> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <year> 1980. </year>
Reference-contexts: Systems of natural deduction [Gen35, Pra65] are most relevant to these notes, since they directly define the meaning of logical symbols via inference rules. They are also closely related to typed -calculi and thus programming languages via the so-called Curry-Howard isomorphism <ref> [How69] </ref>. Gentzen's sequent calculus can be considered a calculus of proof search and is thus relevant to logic programming, where computation is realized as proof search according to a fixed strategy.
Reference: [How80] <author> W. A. Howard. </author> <title> The formulae-as-types notion of construction. </title> <editor> In J. P. Seldin and J. R. Hindley, editors, To H. B. </editor> <booktitle> Curry: Essays on Combi-natory Logic, Lambda Calculus and Formalism, </booktitle> <year> 1980, </year> <pages> pages 479-490. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year> <note> Hitherto unpublished note of 1969, rearranged, corrected, and annotated by Howard, </note> <year> 1979. </year>
Reference: [HP99] <author> Robert Harper and Frank Pfenning. </author> <title> A module system for a programming language based on the LF logical framework. </title> <journal> Journal of Functional Programming, </journal> <note> 199? To appear. </note>
Reference: [HP92] <author> John Hannan and Frank Pfenning. </author> <title> Compiler verification in LF. </title> <editor> In Andre Scedrov, editor, </editor> <booktitle> Seventh Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 407-418, </pages> <address> Santa Cruz, California, June 1992. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [Hue73] <author> Gerard Huet. </author> <title> The undecidability of unification in third order logic. </title> <journal> Information and Control, </journal> <volume> 22(3) </volume> <pages> 257-267, </pages> <year> 1973. </year> <note> BIBLIOGRAPHY 281 </note>
Reference: [Hue75] <author> Gerard Huet. </author> <title> A unification algorithm for typed -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 27-57, </pages> <year> 1975. </year>
Reference: [Hue89] <author> Gerard Huet. </author> <title> The calculus of constructions, documentation and user's guide. Rapport technique 110, </title> <institution> INRIA, Rocquencourt, France, </institution> <year> 1989. </year>
Reference: [JL87] <author> Joxan Jaffar and Jean-Louis Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proceedings of the Fourteenth Annual ACM Symposium on Principles of Programming Languages, Munich, </booktitle> <pages> pages 111-119. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1987. </year>
Reference: [Kah87] <author> Gilles Kahn. </author> <title> Natural semantics. </title> <booktitle> In Proceedings of the Symposium on Theoretical Aspects of Computer Science, </booktitle> <pages> pages 22-39. </pages> <publisher> Springer-Verlag LNCS 247, </publisher> <year> 1987. </year>
Reference-contexts: We will make use of this inductive structure of deductions throughout these notes in order to prove properties of deductive systems. This approach to the description of the operational semantics of programming languages goes back to Plotkin [Plo75, Plo81] under the name of structured operational semantics and Kahn <ref> [Kah87] </ref>, who calls his approach natural semantics. Our presentation follows the style of natural semantics. 14 CHAPTER 2.
Reference: [KP93] <author> Michael Kohlhase and Frank Pfenning. </author> <title> Unification in a -calculus with intersection types. </title> <editor> In Dale Miller, editor, </editor> <booktitle> Proceedings of the International Logic Programming Symposium, </booktitle> <pages> pages 488-505, </pages> <address> Vancouver, Canada, October 1993. </address> <publisher> MIT Press. </publisher>
Reference: [Lan64] <author> P. J. Landin. </author> <title> The mechanical evaluation of expressions. </title> <journal> Computer Journal, </journal> <volume> 6 </volume> <pages> 308-320, </pages> <year> 1964. </year>
Reference: [Lia95] <author> Chuck Liang. </author> <title> Object-Level Substitutions, Unification and Generalization in Meta Logic. </title> <type> PhD thesis, </type> <institution> University of Pennsylvania, </institution> <month> December </month> <year> 1995. </year>
Reference: [Mil78] <author> Robin Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <month> August </month> <year> 1978. </year>
Reference-contexts: [languages which impose no discipline of types] in the time taken to find rather inscrutable bugs|anyone who mistakenly applies CDR to an atom in LISP and finds himself absurdly adding a property list to an integer, will know the symptoms. | Robin Milner A Theory of Type Polymorphism in Programming <ref> [Mil78] </ref> In preparation for the formalization of Mini-ML in a logical framework, we begin with a description of the language in a common mathematical style. The version of Mini-ML we present here lies in between the language introduced in [CDDK86] and call-by-value PCF [Plo75, Plo77]. <p> THE TYPE SYSTEM 21 Mini-ML as presented by Clement et al. is a language with some limited poly-morphism, in that it explicitly distinguishes simple types and type schemes with some restrictions on the use of type schemes. This notion of polymorphism was introduced by Milner <ref> [Mil78, DM82] </ref>. We will refer to it as schematic polymor-phism. In our formulation, we will be able to avoid using type schemes completely by distinguishing two forms of definitions via let, one of which is polymorphic. A formulation in this style orginates with Hannan and Miller [HM89, Han91]. <p> Even though types in our formulation of Mini-ML are not unique, every well-typed expression has a principal type <ref> [Mil78] </ref>. Write Mini-ML programs satisfying the following informal specifications and determine their principal types. 1. compose f g to compute the composition of two functions f and g. 2. iterate n f x to iterate the function f n times over x.
Reference: [Mil91] <author> Dale Miller. </author> <title> A logic programming language with lambda-abstraction, function variables, and simple unification. </title> <editor> In Peter Schroeder-Heister, editor, </editor> <booktitle> Extensions of Logic Programming: International Workshop, Tubingen FRG, </booktitle> <month> December </month> <year> 1989, </year> <pages> pages 253-281. </pages> <publisher> Springer-Verlag LNCS 475, </publisher> <year> 1991. </year>
Reference: [ML80] <author> Per Martin-Lof. </author> <title> Constructive mathematics and computer programming. </title> <booktitle> In Logic, Methodology and Philosophy of Science VI, </booktitle> <pages> pages 153-175. </pages> <publisher> North-Holland, </publisher> <year> 1980. </year>
Reference: [ML85a] <author> Per Martin-Lof. </author> <title> On the meanings of the logical constants and the justifications of the logical laws. </title> <type> Technical Report 2, </type> <institution> Scuola di Specializ-zazione in Logica Matematica, Dipartimento di Matematica, Universita di Siena, </institution> <year> 1985. </year>
Reference-contexts: judgement is just about the first of all the notions of logic, the one that has to be explained before all the others, before even the notions of proposition and truth, for instance. | Per Martin-Lof On the Meanings of the Logical Constants and the Justifications of the Logical Laws <ref> [ML85a] </ref> In everyday computing we deal with a variety of different languages. Some of them such as C, C++, Ada, ML, or Prolog are intended as general purpose languages. <p> A difficulty with this general approach is that it requires the mathematical notion of a model, which is complex and not immediately computational. An alternative is provided by Martin-Lof <ref> [ML85a, ML85b] </ref> who introduces the notion of a judgment (such as "A is true") as something we may know by virtue of a proof. For him the notions of judgment and proof are thus more basic than the notions of proposition and truth.
Reference: [ML85b] <author> Per Martin-Lof. </author> <title> Truth of a propositions, evidence of a judgement, validity of a proof. Notes to a talk given at the workshop Theory of Meaning, </title> <institution> Centro Fiorentino di Storia e Filosofia della Scienza., </institution> <month> June </month> <year> 1985. </year> <note> 282 BIBLIOGRAPHY </note>
Reference-contexts: A difficulty with this general approach is that it requires the mathematical notion of a model, which is complex and not immediately computational. An alternative is provided by Martin-Lof <ref> [ML85a, ML85b] </ref> who introduces the notion of a judgment (such as "A is true") as something we may know by virtue of a proof. For him the notions of judgment and proof are thus more basic than the notions of proposition and truth.
Reference: [MNPS91] <author> Dale Miller, Gopalan Nadathur, Frank Pfenning, and Andre Scedrov. </author> <title> Uniform proofs as a foundation for logic programming. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 51 </volume> <pages> 125-157, </pages> <year> 1991. </year>
Reference: [MTH90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: A related phrase is that in statically typed languages "no type-errors can occur at runtime." Discuss how these properties might be expressed in the framework presented here and to what extent they are already reflected in the type preservation theorem. Exercise 2.10 In the language Standard ML <ref> [MTH90] </ref>, occurrences of fixpoint expressions are syntactially restricted to the form fix x: lam y: e. This means that evaluation of a fixpoint expression always terminates in one step with the value lam y: [fix x: lam y: e=x]e.
Reference: [New65] <author> Allen Newell. </author> <title> Limitations of the current stock of ideas about problem solving. </title> <editor> In A. Kent and O. E. Taulbee, editors, </editor> <booktitle> Electronic Information Handling, </booktitle> <pages> pages 195-208, </pages> <address> Washington, D.C., 1965. </address> <publisher> Spartan Books. </publisher>
Reference: [NM88] <author> Gopalan Nadathur and Dale Miller. </author> <title> An overview of Prolog. </title> <editor> In Ken-neth A. Bowen and Robert A. Kowalski, editors, </editor> <booktitle> Fifth International Logic Programming Conference, </booktitle> <pages> pages 810-827, </pages> <address> Seattle, Washington, August 1988. </address> <publisher> MIT Press. </publisher>
Reference: [NM90] <author> Gopalan Nadathur and Dale Miller. </author> <title> Higher-order Horn clauses. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 37(4) </volume> <pages> 777-814, </pages> <month> October </month> <year> 1990. </year>
Reference: [Pau87] <author> Lawrence C. Paulson. </author> <title> The representation of logics in higher-order logic. </title> <type> Technical Report 113, </type> <institution> University of Cambridge, </institution> <address> Cambridge, England, </address> <month> August </month> <year> 1987. </year>
Reference: [Pfe91a] <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: They have been formalized in a logical framework (LF) [HHP93] in which judgments can be specified at a high level of abstraction, consistent with informal practice in computer science. LF has been given an operational interpretation in the Elf meta-programming language <ref> [Pfe91a] </ref>, thus providing means for a computational meta-theory. Elf implementations of the languages we discuss and proofs of the meta-theorems (except where explicitly noted) are available electronically and constitute an important supplement to these notes. <p> Meta-theory based on deductive systems requires surprisingly few principles: induction over the structure of derivations is by far the most common technique. Thirdly, we would like the reader to understand how to employ the LF logical framework [HHP93] and its implementation in Elf <ref> [Pfe91a] </ref> in order to implement these definitions and related algorithms. This serves several purposes. Perhaps the most important is that it allows hands-on experimentation with otherwise dry definitions and theorems. Students can get immediate feedback on their understanding of the course material and their ideas about exercises.
Reference: [Pfe91b] <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference: [Pfe91c] <author> Frank Pfenning. </author> <title> Unification and anti-unification in the Calculus of Constructions. </title> <booktitle> In Sixth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 74-85, </pages> <address> Amsterdam, The Netherlands, </address> <month> July </month> <year> 1991. </year>
Reference: [Pfe92] <author> Frank Pfenning, </author> <title> editor. Types in Logic Programming. </title> <publisher> MIT Press, </publisher> <address> Cam-bridge, Massachusetts, </address> <year> 1992. </year>
Reference: [Pfe93] <author> Frank Pfenning. </author> <title> Refinement types for logical frameworks. </title> <editor> In Herman Geuvers, editor, </editor> <booktitle> Informal Proceedings of the 1993 Workshop on Types for Proofs and Programs, </booktitle> <pages> pages 285-299, </pages> <address> Nijmegen, The Netherlands, </address> <month> May </month> <year> 1993. </year> <institution> University of Nijmegen. </institution> <address> BIBLIOGRAPHY 283 </address>
Reference: [Pfe94] <author> Frank Pfenning. </author> <title> Elf: A meta-language for deductive systems. </title> <editor> In A. Bundy, editor, </editor> <booktitle> Proceedings of the 12th International Conference on Automated Deduction, </booktitle> <pages> pages 811-815, </pages> <address> Nancy, France, </address> <month> June </month> <year> 1994. </year> <note> Springer-Verlag LNAI 814. System abstract. </note>
Reference: [Plo75] <author> G. D. Plotkin. </author> <title> Call-by-name, call-by-value and the -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: The version of Mini-ML we present here lies in between the language introduced in [CDDK86] and call-by-value PCF <ref> [Plo75, Plo77] </ref>. The description consists of three parts: (1) the abstract syntax, (2) the operational semantics, and (3) the type system. <p> We will make use of this inductive structure of deductions throughout these notes in order to prove properties of deductive systems. This approach to the description of the operational semantics of programming languages goes back to Plotkin <ref> [Plo75, Plo81] </ref> under the name of structured operational semantics and Kahn [Kah87], who calls his approach natural semantics. Our presentation follows the style of natural semantics. 14 CHAPTER 2.
Reference: [Plo77] <author> G. D. Plotkin. </author> <title> LCF considered as a programming language. </title> <journal> Theoretical Computer Science, </journal> <volume> 5(3) </volume> <pages> 223-255, </pages> <year> 1977. </year>
Reference-contexts: The version of Mini-ML we present here lies in between the language introduced in [CDDK86] and call-by-value PCF <ref> [Plo75, Plo77] </ref>. The description consists of three parts: (1) the abstract syntax, (2) the operational semantics, and (3) the type system.
Reference: [Plo81] <author> Gordon D. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI FN-19, </type> <institution> Computer Science Department, Aarhus University, Aarhus, Denmark, </institution> <month> September </month> <year> 1981. </year>
Reference-contexts: We will make use of this inductive structure of deductions throughout these notes in order to prove properties of deductive systems. This approach to the description of the operational semantics of programming languages goes back to Plotkin <ref> [Plo75, Plo81] </ref> under the name of structured operational semantics and Kahn [Kah87], who calls his approach natural semantics. Our presentation follows the style of natural semantics. 14 CHAPTER 2.
Reference: [PN90] <author> Lawrence C. Paulson and Tobias Nipkow. </author> <title> Isabelle tutorial and user's manual. </title> <type> Technical Report 189, </type> <institution> Computer Laboratory, University of Cambridge, </institution> <month> January </month> <year> 1990. </year>
Reference: [PR92] <author> Frank Pfenning and Ekkehard Rohwedder. </author> <title> Implementing the meta-theory of deductive systems. </title> <editor> In D. Kapur, editor, </editor> <booktitle> Proceedings of the 11th International Conference on Automated Deduction, </booktitle> <pages> pages 537-551, </pages> <address> Saratoga Springs, New York, June 1992. </address> <publisher> Springer-Verlag LNAI 607. </publisher>
Reference: [Pra65] <author> Dag Prawitz. </author> <title> Natural Deduction. </title> <publisher> Almquist & Wiksell, </publisher> <address> Stockholm, </address> <year> 1965. </year>
Reference-contexts: Systems in the style of Hilbert [HB34] have a close connection to combinatory calculi [CF58]. They are characterized by many axioms and a small number of inference rules. Systems of natural deduction <ref> [Gen35, Pra65] </ref> are most relevant to these notes, since they directly define the meaning of logical symbols via inference rules. They are also closely related to typed -calculi and thus programming languages via the so-called Curry-Howard isomorphism [How69].
Reference: [PW90] <author> David Pym and Lincoln Wallen. </author> <title> Investigations into proof-search in a system of first-order dependent function types. In M.E. </title> <editor> Stickel, editor, </editor> <booktitle> 10th International Conference on Automated Deduction, </booktitle> <pages> pages 236-250, </pages> <address> Kaiserslautern, Germany, </address> <month> July </month> <year> 1990. </year> <note> Springer-Verlag LNCS 449. </note>
Reference: [PW91] <author> David Pym and Lincoln A. Wallen. </author> <title> Proof search in the -calculus. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 309-340. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference: [Pym90] <author> David Pym. </author> <title> Proofs, Search and Computation in General Logic. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1990. </year> <note> Available as CST-69-90, also published as ECS-LFCS-90-125. </note>
Reference: [Rey83] <author> John Reynolds. </author> <title> Types, abstraction and parametric polymorphism. </title> <editor> In R. E. A. Mason, editor, </editor> <booktitle> Information Processing 83, </booktitle> <pages> pages 513-523. </pages> <publisher> El-sevier Science Publishers B. V., </publisher> <year> 1983. </year>
Reference: [Rob65] <author> J. A. Robinson. </author> <title> A machine-oriented logic based on the resolution principle. </title> <journal> Journal of the ACM, </journal> <volume> 12(1) </volume> <pages> 23-41, </pages> <month> January </month> <year> 1965. </year> <note> 284 BIBLIOGRAPHY </note>
Reference: [Roh96] <author> Ekkehard Rohwedder. </author> <title> Verifying the Meta-Theory of Deductive Systems. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1996. </year> <month> Forthcoming. </month>
Reference: [Sal90] <author> Anne Salvesen. </author> <title> The Church-Rosser theorem for LF with fi-reduction. Unpublished notes to a talk given at the First Workshop on Logical Frameworks in Antibes, </title> <address> France, </address> <month> May </month> <year> 1990. </year>
Reference: [Sal92] <author> Anne Salvesen. </author> <title> The Church-Rosser property for pure type systems with fi-reduction. </title> <type> Technical report, </type> <institution> University of Oslo, Oslo, Norway, </institution> <year> 1992. </year> <note> In preparation. </note>
Reference: [SH84] <author> Peter Schroeder-Heister. </author> <title> A natural extension of natural deduction. </title> <journal> The Journal of Symbolic Logic, </journal> <volume> 49(4) </volume> <pages> 1284-1300, </pages> <month> December </month> <year> 1984. </year>
Reference: [SS86] <author> Leon Sterling and Ehud Shapiro. </author> <title> The Art of Prolog. </title> <publisher> MIT Press, </publisher> <address> Cam-bridge, Massachusetts, </address> <year> 1986. </year>
Reference: [Tho91] <author> Simon Thompson. </author> <title> Type Theory and Functional Programming. </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference: [Wol91] <author> David A. Wolfram. </author> <title> Rewriting, and equational unification: The higher-order cases. </title> <editor> In Ronald V. Book, editor, </editor> <booktitle> Proceedings of the Fourth International Conference on Rewriting Techniques and Applications, </booktitle> <pages> pages 25-36, </pages> <address> Como, Italy, April 1991. </address> <publisher> Springer-Verlag LNCS 488. </publisher>
References-found: 86

