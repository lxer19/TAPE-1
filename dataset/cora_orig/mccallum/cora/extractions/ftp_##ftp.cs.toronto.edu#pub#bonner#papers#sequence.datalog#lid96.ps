URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/sequence.datalog/lid96.ps
Refering-URL: http://www.cs.toronto.edu/DB/people/bonner/papers.html
Root-URL: 
Email: bonner@db.toronto.edu  mecca@dis.uniroma1.it  
Phone: 1  2  
Title: Sequence Datalog: Declarative String Manipulation in Databases  
Author: Anthony Bonner Giansalvatore Mecca 
Address: Canada  via della Tecnica, 3 85100 Potenza, Italy  
Affiliation: Department of Computer Science University of Toronto Toronto, Ont.  D.I.F.A. Universita della Basilicata  
Abstract: We investigate logic-based query languages for sequence databases, that is, databases in which strings of symbols over a fixed alphabet can occur. We discuss different approaches to querying strings, including Prolog and Datalog with function symbols, and argue that all of them have important limitations. We then present the semantics of Sequence Datalog, a logic for querying sequence databases, and show how this language can be used to perform structural recursion over sequences.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> S. Abiteboul, R. Hull, and V. Vianu. </author> <title> Foundations of databases. </title> <publisher> Addison Wesley Publ. Co., </publisher> <address> Reading, Massachussetts, </address> <year> 1994. </year>
Reference-contexts: program, where * is the empty sequence: fl 1 : answer (X) r (X); abc n (X [1:N 1 ]; X [N 1 + 1:N 2 ]; X [N 2 + 1:end]): fl 2 : abc n (*; *; *) true. fl 3 : abc n (X; Y; Z) X <ref> [1] </ref> = a; Y [1] = b; Z [1] = c; For each sequence X in r, the formula answer (X) is true if it is possible to split X into three parts such that abc n is true. <p> the empty sequence: fl 1 : answer (X) r (X); abc n (X [1:N 1 ]; X [N 1 + 1:N 2 ]; X [N 2 + 1:end]): fl 2 : abc n (*; *; *) true. fl 3 : abc n (X; Y; Z) X <ref> [1] </ref> = a; Y [1] = b; Z [1] = c; For each sequence X in r, the formula answer (X) is true if it is possible to split X into three parts such that abc n is true. <p> 1 : answer (X) r (X); abc n (X [1:N 1 ]; X [N 1 + 1:N 2 ]; X [N 2 + 1:end]): fl 2 : abc n (*; *; *) true. fl 3 : abc n (X; Y; Z) X <ref> [1] </ref> = a; Y [1] = b; Z [1] = c; For each sequence X in r, the formula answer (X) is true if it is possible to split X into three parts such that abc n is true. <p> by using safe, structural recursion over one argument of a predicate to control constructive recursion over the other argument (s). fl 1 : answer (Y ) r 1 (X); complement (X; Y ): fl 2 : complement (*; *) true. fl 3 : complement (X; Y * Z) compl (X <ref> [1] </ref>; Y ); complement (X [2:end]; Z). fl 4 : compl (0; 1) true: fl 5 : compl (1; 0) true: In this case, predicate complement constructs the complement of every sequence in the extended active domain of the database.
Reference: 2. <author> S. Abiteboul and V. Vianu. </author> <title> Datalog extensions for database queries and updates. </title> <journal> Journal of Computing and System Sciences, </journal> <volume> 43(1) </volume> <pages> 62-124, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: The extended active domain of the least fixpoint is therefore larger than the extended active domain of the database. Observe that our semantics for sequence creation resembles the semantics of value invention in <ref> [2] </ref> in that sequences are added to the active domain as a side-effect of rule evaluation. In Sequence Datalog, however, the addition is purely declarative and deterministic, since the least fixpoint is unique. Compared to Datalog with function symbols, or Prolog, several differences are apparent.
Reference: 3. <author> K. Apt and M. H. Van Emden. </author> <title> Contributions to the theory of logic programming. </title> <journal> Journal of the ACM, </journal> <volume> 29(3) </volume> <pages> 841-862, </pages> <year> 1982. </year>
Reference: 4. <author> M. Atkinson, F. Bancilhon, D. DeWitt, K. Dittrich, D. Maier, and Z. Zdonik. </author> <title> The object-oriented database manifesto. </title> <booktitle> In First Intern. Conference on Deductive and Object Oriented Databases (DOOD'89), </booktitle> <address> Kyoto, Japan, </address> <pages> pages 40-57, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction In the last decade, new applications (e.g. CAD and CASE) have been a powerful driving force in the development of new database technology. New paradigms have arisen (e.g. object oriented databases <ref> [4] </ref>) that provide greater flexibility than the traditional relational model. However, in some application areas, such as genome databases [14] and text databases [16], there is still a need for greater flexibility, both in data representation and manipulation. <p> Thus, if S 1 and S 2 are sequence variables, and N is an index variable, then S 1 <ref> [4] </ref>, S 1 [1:N ] and ccgt * S 1 [1:end 3] * S 2 are all sequence terms. A term is ground if it contains no variables.
Reference: 5. <editor> P. Atzeni, editor. LOGIDATA+: </editor> <title> Deductive Databases with Complex Objects, </title> <booktitle> Lecture Notes in Computer Science 701. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference: 6. <author> A. J. Bonner. </author> <title> Hypothetical Datalog: complexity and expressibility. </title> <journal> Theoretical Computer Science, </journal> <volume> 76 </volume> <pages> 3-51, </pages> <year> 1990. </year>
Reference: 7. <author> V. Breazu-Tannen, P. Buneman, and S. Naqvi. </author> <title> Structural recursion as a query language. </title> <booktitle> In Third Intern. Workshop on Database Programming Languages (DBPL'91), </booktitle> <pages> pages 9-19, </pages> <year> 1991. </year>
Reference: 8. <author> V. Breazu-Tannen, P. Buneman, and L. Wong. </author> <title> Naturally embedded query languages. </title> <booktitle> In Fourth International Conference on Data Base Theory, (ICDT'92), Lecture Notes in Computer Science, </booktitle> <pages> pages 140-154, </pages> <year> 1992. </year>
Reference: 9. <author> S. Ceri, G. Gottlob, and L. Tanca. </author> <title> Logic Programming and Data Bases. </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference: 10. <author> S. Ceri, G. Gottlob, and L. Tanca. </author> <title> What you always wanted to know about Dat--alog (and never dared to ask). </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 1(1) </volume> <pages> 146-166, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: However, the top-down evaluation strategy of Prolog is widely regarded as inadequate for database applications, since it implies a procedural, "tuple-at-a-time" mode of computation; whereas, a non-procedural, set-oriented evaluation strategy is considered an essential feature of database query languages. To solve this problem, one might consider adopting Datalog <ref> [10] </ref> and its bottom-up, set-oriented evaluation strategy, and enriching it with function symbols to model lists. Unfortunately, coupling function symbols with bottom-up evaluation can lead to extremely inefficient computations, as the next example shows.
Reference: 11. <author> A. K. Chandra and D. Harel. </author> <title> Computable queries for relational databases. </title> <journal> Journal of Computing and System Sciences, </journal> <volume> 21 </volume> <pages> 333-347, </pages> <year> 1980. </year>
Reference-contexts: We assign a distinct predicate symbol, r, of appropriate arity to each relation in a database. A sequence query is a partial mapping from the databases over to the relations over . As usual, we assume fixed input and answer schema for queries <ref> [11] </ref>. 5 Sequence Datalog: Syntax and Semantics This section introduces the syntax and semantics of the language. We first discuss the syntax informally, and then present two different semantics; the first is a fixpoint semantics, and the second is a model-theoretic semantics.
Reference: 12. <author> W. Clocksin and C. Mellish. </author> <title> Programming in Prolog. </title> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: In particular, because of existential quantification over the infinite universe of sequences, it is not easy to determine the maximum length of the sequences in a query answer, even when the query is known to be safe. There is also the traditional logic-programming approach [19]. For example, in Prolog <ref> [12] </ref>, lists can be used to represent strings, and the language provides a natural "head-tail" constructor for manipulating them. It is also well known [19] that this language is computationally complete on lists.
Reference: 13. <author> L. S. Colby, E. L. Robertson, L. V. Saxton, and D. Van Gucht. </author> <title> A query language for list-based complex objects. </title> <booktitle> In Thirteenth ACM SIGMOD Intern. Symposium on Principles of Database Systems (PODS'94), </booktitle> <pages> pages 179-189, </pages> <year> 1994. </year>
Reference-contexts: Section 4 provides preliminary definitions. finally, Section 5, develops the formal semantics of the language. 2 Background In recent years, several query languages for sequence databases have been proposed in the literature. On one hand, there are languages based on functional and algebraic programming <ref> [13, 18] </ref>. In this context, some sophisticated and expressive languages have been proposed, and great care has been devoted to the development of tractable languages, that is, languages whose complexity is in ptime. On the other hand, there are languages based on predicate logic [24, 15, 17].
Reference: 14. <institution> Communications of the ACM. </institution> <note> Special issue on the Human Genome project. vol. 34(11), </note> <month> November </month> <year> 1991. </year>
Reference-contexts: CAD and CASE) have been a powerful driving force in the development of new database technology. New paradigms have arisen (e.g. object oriented databases [4]) that provide greater flexibility than the traditional relational model. However, in some application areas, such as genome databases <ref> [14] </ref> and text databases [16], there is still a need for greater flexibility, both in data representation and manipulation. These applications are characterized by a need to store, manipulate and transform strings. Strings are a particularly interesting domain for query languages.
Reference: 15. <author> S. Ginsburg and X. Wang. </author> <title> Pattern matching by RS-operations: towards a unified approach to querying sequence data. </title> <booktitle> In Eleventh ACM SIGACT SIGMOD SIGART Symp. on Principles of Database Systems (PODS'92), </booktitle> <pages> pages 293-300, </pages> <year> 1992. </year>
Reference-contexts: In this context, some sophisticated and expressive languages have been proposed, and great care has been devoted to the development of tractable languages, that is, languages whose complexity is in ptime. On the other hand, there are languages based on predicate logic <ref> [24, 15, 17] </ref>. In this context, powerful logics for expressing string transformations have been proposed, but many of them suffer from the difficult trade-off between expressiveness, finiteness and effective computability. In some cases, a great part of the expressive power of the language has to be sacrificed to achieve finiteness. <p> In some cases, a great part of the expressive power of the language has to be sacrificed to achieve finiteness. In other cases, both expressiveness and finiteness are achieved, but at expense of an effective procedure for evaluating queries, i:e:, at the expense of an operational semantics. In <ref> [15, 27] </ref>, for example, an extended relational model is defined, where each relation is a set of tuples of sequences over a fixed alphabet. A sequence logic [15] is then developed based on the notion of rs-operations. Each rs-operation is either a merger or an extractor. <p> In [15, 27], for example, an extended relational model is defined, where each relation is a set of tuples of sequences over a fixed alphabet. A sequence logic <ref> [15] </ref> is then developed based on the notion of rs-operations. Each rs-operation is either a merger or an extractor. Intuitively, given a set of patterns, an associated merger uses the patterns to "combine" a set of sequences. Likewise, an extractor "retrieves" subsequences of a given sequence. <p> to body." In the following sections, we introduce Sequence Datalog [21], a query language designed to overcome these limitations, by supporting a safe and efficient form of structural recursion over strings. 3 Overview of Sequence Datalog We use a data model that is a simple extension of the relational model <ref> [15, 17] </ref>. In this model, we fix a finite set of symbols, , called the alphabet. Database tuples may contain finite sequences of symbols over this alphabet, instead of just single symbols. <p> For example, the contiguous subsequences of the sequence abc are: *; a; b; c; ab; bc; abc. The data model for Sequence Datalog is an extension of the relational model in the spirit of <ref> [15, 17] </ref>. The model allows for tuples containing sequences of symbols, instead of just constant symbols. Formally, a relation of arity k over is a finite subset of the k-fold cartesian product of fl with itself.
Reference: 16. <author> G. H. Gonnet. </author> <title> Text dominated databases: Theory, practice and experience. </title> <booktitle> Tutorial presented at PODS, </booktitle> <year> 1994. </year>
Reference-contexts: CAD and CASE) have been a powerful driving force in the development of new database technology. New paradigms have arisen (e.g. object oriented databases [4]) that provide greater flexibility than the traditional relational model. However, in some application areas, such as genome databases [14] and text databases <ref> [16] </ref>, there is still a need for greater flexibility, both in data representation and manipulation. These applications are characterized by a need to store, manipulate and transform strings. Strings are a particularly interesting domain for query languages.
Reference: 17. <author> G. Grahne, M. Nykanen, and E. Ukkonen. </author> <title> Reasoning about strings in databases. </title> <booktitle> In Thirteenth ACM SIGMOD Intern. Symposium on Principles of Database Systems (PODS'94), </booktitle> <pages> pages 303-312, </pages> <year> 1994. </year>
Reference-contexts: In this context, some sophisticated and expressive languages have been proposed, and great care has been devoted to the development of tractable languages, that is, languages whose complexity is in ptime. On the other hand, there are languages based on predicate logic <ref> [24, 15, 17] </ref>. In this context, powerful logics for expressing string transformations have been proposed, but many of them suffer from the difficult trade-off between expressiveness, finiteness and effective computability. In some cases, a great part of the expressive power of the language has to be sacrificed to achieve finiteness. <p> Unfortunately, this safe sublanguage cannot express many queries for which the length of the result depends on the database. These include natural queries such as the reverse and complement of a sequence. This problem is partially solved by the alignment logic of <ref> [17] </ref>, an elegant and expressive first-order logic for a relational model with sequences. The computational counterpart of the logic is the class of multi-tape, nondeterministic, two-way, finite-state automata, which are used to accept or reject tuples of se quences. <p> to body." In the following sections, we introduce Sequence Datalog [21], a query language designed to overcome these limitations, by supporting a safe and efficient form of structural recursion over strings. 3 Overview of Sequence Datalog We use a data model that is a simple extension of the relational model <ref> [15, 17] </ref>. In this model, we fix a finite set of symbols, , called the alphabet. Database tuples may contain finite sequences of symbols over this alphabet, instead of just single symbols. <p> For example, the contiguous subsequences of the sequence abc are: *; a; b; c; ab; bc; abc. The data model for Sequence Datalog is an extension of the relational model in the spirit of <ref> [15, 17] </ref>. The model allows for tuples containing sequences of symbols, instead of just constant symbols. Formally, a relation of arity k over is a finite subset of the k-fold cartesian product of fl with itself.
Reference: 18. <author> S. Grumbach and T. Milo. </author> <title> An algebra for POMSETS. </title> <booktitle> In Fifth International Conference on Data Base Theory, (ICDT'95), Prague, Lecture Notes in Computer Science, </booktitle> <pages> pages 191-207, </pages> <year> 1995. </year>
Reference-contexts: Section 4 provides preliminary definitions. finally, Section 5, develops the formal semantics of the language. 2 Background In recent years, several query languages for sequence databases have been proposed in the literature. On one hand, there are languages based on functional and algebraic programming <ref> [13, 18] </ref>. In this context, some sophisticated and expressive languages have been proposed, and great care has been devoted to the development of tractable languages, that is, languages whose complexity is in ptime. On the other hand, there are languages based on predicate logic [24, 15, 17].
Reference: 19. <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> second edition, </address> <year> 1987. </year>
Reference-contexts: Sequence Datalog is a Horn-like logic with special, interpreted function symbols that allow for structural recursion over strings. Sequence Datalog has both a clear declarative semantics and an operational semantics. The semantics are based on fixpoint theory, as in classical logic programming <ref> [19] </ref>, and on a new notion of active domain, called the extended active domain, introduced to ? The first author was partially supported by an operating grant from the Natural Sciences and Engineering Research Council of Canada (NSERC). <p> In particular, because of existential quantification over the infinite universe of sequences, it is not easy to determine the maximum length of the sequences in a query answer, even when the query is known to be safe. There is also the traditional logic-programming approach <ref> [19] </ref>. For example, in Prolog [12], lists can be used to represent strings, and the language provides a natural "head-tail" constructor for manipulating them. It is also well known [19] that this language is computationally complete on lists. <p> There is also the traditional logic-programming approach <ref> [19] </ref>. For example, in Prolog [12], lists can be used to represent strings, and the language provides a natural "head-tail" constructor for manipulating them. It is also well known [19] that this language is computationally complete on lists. However, the top-down evaluation strategy of Prolog is widely regarded as inadequate for database applications, since it implies a procedural, "tuple-at-a-time" mode of computation; whereas, a non-procedural, set-oriented evaluation strategy is considered an essential feature of database query languages. <p> By convention, we interpret the keyword end as the last position in a sequence. The semantics of Sequence Datalog is based on a fixpoint theory, as in classical Logic Programming <ref> [19] </ref>. Thus, each Sequence Datalog program P has an associated "T-operator" that maps databases to databases. Each application of the operator may create new atomic formulas and new sequences. The operator is monotonic and continuous, and thus has a least fixpoint. <p> Moreover, if s 1 and s 2 are sequence terms, then the formulas s 1 = s 2 and s 1 6= s 2 are also atoms. From atoms, we build facts and clauses in the usual way <ref> [19] </ref>. The head and body of a clause fl are denoted head (fl) and body (fl), respectively. A clause that contains a constructive term in its head is called a constructive clause. <p> Likewise, (q 0 q 1 ; : : : ; q k ) is defined if and only if each (q i ) is defined. 5.3 Fixpoint Semantics The semantics of clauses is defined in terms of a least fixpoint theory. As in classical logic programming <ref> [19] </ref>, each Sequence Datalog program P and database db has an associated operator T P;db that maps Herbrand interpretations to Herbrand interpretations. Each application of T P;db may create new atoms, which may contain new sequences. <p> The least fixpoint <ref> [19] </ref> of operator T P;db is computed in a bottom-up fashion, by starting at the empty interpretation and applying T P;db repeatedly until a fixpoint is reached. <p> At each step, and for each ground instantiation of each clause in P , if each premise of the clause has been derived, then the head of the clause is added to the set of derived facts. Because T P;db is continuous, this process is complete <ref> [19] </ref>; that is, any atom in the least fixpoint will eventually be derived. At each step, if a derived fact contains a new sequence (i:e:, a sequence not currently in the extended active domain), then it is added to the active domain. <p> Thus ff 2 S Given a program P and database db, we define the following sequence of interpretations: T P;db " 0 = f g T P;db " ! = i=0 Because T P;db is monotonic and continuous, we can invoke the Knaster-Tarsky fixpoint theorem <ref> [19] </ref>. T P;db thus has a least fixpoint, which is equal to T P;db " !. We say that T P;db " ! is the fixpoint semantics of program P over database db.
Reference: 20. <author> G. Mecca and A. J. Bonner. </author> <title> Finite query languages for sequence databases. </title> <booktitle> In Fifth Intern. Workshop on Database Programming Languages (DBPL'95), </booktitle> <address> Gubbio, Italy, </address> <year> 1995. </year>
Reference: 21. <author> G. Mecca and A. J. Bonner. </author> <title> Sequences, Datalog and Transducers. </title> <booktitle> In Fourteenth ACM SIGMOD Intern. Symposium on Principles of Database Systems (PODS'95), </booktitle> <address> San Jose, California, </address> <pages> pages 23-35, </pages> <year> 1995. </year>
Reference-contexts: The researcher thus faces an interesting challenge: on the one hand, the language should provide powerful primitives for restructuring strings; on the other hand, the expressive power of the language should be carefully limited, to avoid infinite computations. In <ref> [21] </ref>, we introduced a logic called Sequence Datalog for querying sequence databases. Sequence Datalog is a Horn-like logic with special, interpreted function symbols that allow for structural recursion over strings. Sequence Datalog has both a clear declarative semantics and an operational semantics. <p> The language has considerable power to manipulate strings. In fact, Sequence Datalog with stratified negation can express any computable query on sequence databases [22]. In this paper, we discuss in detail the semantics of Sequence Datalog, comparing and contrasting it to traditional logic-based languages. Whereas <ref> [21] </ref> introduced semantics of Sequence Datalog informally, this paper provides the formal development. The paper is organized as follows. Section 2 discusses other approaches to string manipulation based on logic. Section 3 introduces Sequence Datalog, discussing its syntax and semantics. <p> This problem arises because, unlike Prolog, rules in Datalog are evaluated "from body to head," instead of "from head to body." In the following sections, we introduce Sequence Datalog <ref> [21] </ref>, a query language designed to overcome these limitations, by supporting a safe and efficient form of structural recursion over strings. 3 Overview of Sequence Datalog We use a data model that is a simple extension of the relational model [15, 17].
Reference: 22. <author> G. Mecca and A. J. Bonner. </author> <title> Sequences, Datalog and Negation. </title> <note> In preparation, </note> <year> 1996. </year>
Reference-contexts: The second author was partially supported by MURST and Consiglio Nazionale delle Ricerche (CNR). allow for a bottom-up evaluation of rules. The language has considerable power to manipulate strings. In fact, Sequence Datalog with stratified negation can express any computable query on sequence databases <ref> [22] </ref>. In this paper, we discuss in detail the semantics of Sequence Datalog, comparing and contrasting it to traditional logic-based languages. Whereas [21] introduced semantics of Sequence Datalog informally, this paper provides the formal development. The paper is organized as follows.
Reference: 23. <author> C. Papadimitriou. </author> <title> Computational Complexity. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: The computational counterpart of the logic is the class of multi-tape, nondeterministic, two-way, finite-state automata, which are used to accept or reject tuples of se quences. In its full version, alignment logic has the power of recursively enumer-able sets <ref> [23] </ref>. A subset of the language called right restricted formulas is then developed. For this sublanguage, the safety problem is shown to be decidable, and complexity results related to the polynomial-time hierarchy are presented. Unfortunately, the non-deterministic nature of the computational model makes the evaluation of queries problematic.
Reference: 24. <author> J. Richardson. </author> <title> Supporting lists in a data model (a timely approach). </title> <booktitle> In Eighteenth International Conference on Very Large Data Bases (VLDB'92), </booktitle> <address> Vancouver, Canada, </address> <pages> pages 127-138, </pages> <year> 1992. </year>
Reference-contexts: In this context, some sophisticated and expressive languages have been proposed, and great care has been devoted to the development of tractable languages, that is, languages whose complexity is in ptime. On the other hand, there are languages based on predicate logic <ref> [24, 15, 17] </ref>. In this context, powerful logics for expressing string transformations have been proposed, but many of them suffer from the difficult trade-off between expressiveness, finiteness and effective computability. In some cases, a great part of the expressive power of the language has to be sacrificed to achieve finiteness.
Reference: 25. <author> D. B. </author> <title> Searls. String Variable Grammars: a logic grammar formalism for dna sequences. </title> <type> Technical report, </type> <institution> University of Pennsylvania, School of Medicine, </institution> <year> 1993. </year>
Reference-contexts: Recursion starts with the empty sequence, and proceeds until the complement of every sequence in the extended active domain has been generated. Thus, unlike Example 1, recursion stops after 6 Repetitive patterns are of great importance in Molecular Biology <ref> [25] </ref>. a finite amount of time, since the active domain semantics prevents the genera-tion of sequences of unbounded length. (ii) Although they have a finite semantics, rules fl 1 to fl 5 are still highly inefficient, since they compute the complement of every sequence in the extended active domain of the
Reference: 26. <author> D. Stott Parker, E. Simon, and P. Valduriez. </author> <title> SVP a model capturing sets, streams and parallelism. </title> <booktitle> In Eighteenth International Conference on Very Large Data Bases (VLDB'92), </booktitle> <address> Vancouver, Canada, </address> <pages> pages 115-126, </pages> <year> 1992. </year>
Reference: 27. <author> X. Wang. </author> <title> Pattern matching by RS-operations: Towards a unified approach to querying sequence data. </title> <type> PhD thesis, </type> <institution> University of Southern California, </institution> <year> 1992. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: In some cases, a great part of the expressive power of the language has to be sacrificed to achieve finiteness. In other cases, both expressiveness and finiteness are achieved, but at expense of an effective procedure for evaluating queries, i:e:, at the expense of an operational semantics. In <ref> [15, 27] </ref>, for example, an extended relational model is defined, where each relation is a set of tuples of sequences over a fixed alphabet. A sequence logic [15] is then developed based on the notion of rs-operations. Each rs-operation is either a merger or an extractor.
References-found: 27

