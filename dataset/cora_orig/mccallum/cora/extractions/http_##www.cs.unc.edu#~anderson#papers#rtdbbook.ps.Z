URL: http://www.cs.unc.edu/~anderson/papers/rtdbbook.ps.Z
Refering-URL: http://www.cs.unc.edu/~anderson/papers.html
Root-URL: http://www.cs.unc.edu
Title: LOCK-FREE TRANSACTIONS FOR REAL-TIME SYSTEMS  
Author: James H. Anderson, Srikanth Ramamurthy, Mark Moir and Kevin Jeffay 
Affiliation: University of North Carolina, Chapel Hill, North Carolina, USA  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> J. Anderson and M. Moir, </author> <title> "Universal Constructions for Multi-Object Operations", </title> <booktitle> Proceedings of the 14th Annual ACM Symposium on Principles of Distributed Computing , 1995, </booktitle> <pages> pp. 184-193. </pages>
Reference-contexts: To enable such implementations to be used on systems that do not provide these primitives, Ramamurthy, Moir, and Anderson present two implementations of an object that supports CAS. (LL/SC can be implemented using CAS in constant time <ref> [1] </ref>.) These implementations, which are summarized in the following theorems, use read/write and memory-to-memory Move instructions, respectively. Move is widely available on uniprocessors. <p> We assume that transactions are invoked by a collection of prioritized tasks executing on the same processor. Our implementation is based on universal lock-free constructions by Anderson and Moir for implementing large objects and for implementing multi-object operations <ref> [1, 2] </ref>. The implementation uses a multi-word compare-and-swap (MWCAS) primitive for real-time systems proposed by Anderson and Ramamurthy [3]. 3.1 Transaction Routines Our transaction implementation, which is shown in Figure 3, consists of three procedures, TR Read, TR Write, and TR Exec. <p> These routines are called within the programmer's transaction code in order to read or write a word of the MEM array. Thus, instead of writing "MEM <ref> [1] </ref> := MEM [10]", the programmer would write "TR Write (1; TR Read (10))". Figure 4 shows a simple example transaction, which updates the temperature display of a boiler. This transaction would be executed by calling TR Exec (update display). <p> Unfortunately, MWCAS is exceedingly difficult to implement efficiently in truly asynchronous systems <ref> [1, 6, 9, 22] </ref>. The most efficient known wait-free implementation [1] requires fi (N 3 M ) time complexity to implement M words that can be accessed by N tasks. <p> Unfortunately, MWCAS is exceedingly difficult to implement efficiently in truly asynchronous systems [1, 6, 9, 22]. The most efficient known wait-free implementation <ref> [1] </ref> requires fi (N 3 M ) time complexity to implement M words that can be accessed by N tasks. Fortunately, as shown by Anderson and Ramamurthy in [3], a W -word MWCAS can be implemented on a real-time uniprocessor in only O (W ) time (which is clearly optimal). <p> The current value 16 Chapter 1 val count valid pid x: 12 2 true 2 cv (x) = 12 y: 3 1 false 3 cv (y) = 22 z: 8 3 true 4 cv (z) = 8 Save <ref> [3; 1] </ref>: 22 Status [3]: 0 (a) val count valid pid x: 5 0 false 4 cv (x) = 12 y: 10 1 false 4 cv (y) = 22 z: 17 2 false 4 cv (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; <p> 22 z: 8 3 true 4 cv (z) = 8 Save <ref> [3; 1] </ref>: 22 Status [3]: 0 (a) val count valid pid x: 5 0 false 4 cv (x) = 12 y: 10 1 false 4 cv (y) = 22 z: 17 2 false 4 cv (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; 1]: 22 Save [4; 2]: 8 Status [4]: 0 (b) val count valid pid x: 5 0 true 4 cv (x) = 5 y: 10 0 true 4 cv (y) = 10 z: 17 0 true 4 cv (z) <p> [3; 1]: 22 Status [3]: 0 (a) val count valid pid x: 5 0 false 4 cv (x) = 12 y: 10 1 false 4 cv (y) = 22 z: 17 2 false 4 cv (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save <ref> [4; 1] </ref>: 22 Save [4; 2]: 8 Status [4]: 0 (b) val count valid pid x: 5 0 true 4 cv (x) = 5 y: 10 0 true 4 cv (y) = 10 z: 17 0 true 4 cv (z) = 17 Status [4]: 2 (c) val count valid pid x: <p> 4 cv (y) = 10 z: 17 0 true 4 cv (z) = 17 Status [4]: 2 (c) val count valid pid x: 12 2 true 2 cv (x) = 12 y: 3 1 false 3 cv (y) = 22 z: 56 4 true 9 cv (z) = 56 Save <ref> [3; 1] </ref>: 22 Status [3]: 1 Status [4]: 1 (d) (f) with old/new values 12/5, 22/10, and 8/17, respectively.
Reference: [2] <author> J. Anderson and M. Moir, </author> <title> "Universal Constructions for Large Objects", </title> <booktitle> Proceedings of the Ninth International Workshop on Distributed Algorithms, Lecture Notes in Computer Science 972, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995, </year> <pages> pp. 168-182. </pages>
Reference-contexts: We assume that transactions are invoked by a collection of prioritized tasks executing on the same processor. Our implementation is based on universal lock-free constructions by Anderson and Moir for implementing large objects and for implementing multi-object operations <ref> [1, 2] </ref>. The implementation uses a multi-word compare-and-swap (MWCAS) primitive for real-time systems proposed by Anderson and Ramamurthy [3]. 3.1 Transaction Routines Our transaction implementation, which is shown in Figure 3, consists of three procedures, TR Read, TR Write, and TR Exec. <p> [3]: 0 (a) val count valid pid x: 5 0 false 4 cv (x) = 12 y: 10 1 false 4 cv (y) = 22 z: 17 2 false 4 cv (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; 1]: 22 Save <ref> [4; 2] </ref>: 8 Status [4]: 0 (b) val count valid pid x: 5 0 true 4 cv (x) = 5 y: 10 0 true 4 cv (y) = 10 z: 17 0 true 4 cv (z) = 17 Status [4]: 2 (c) val count valid pid x: 12 2 true 2
Reference: [3] <author> J. Anderson and S. Ramamurthy, </author> <title> "A Framework for Implementing Objects and Scheduling Tasks in Lock-Free Real-Time Systems", </title> <booktitle> to be presented at the 17th IEEE Real-Time Systems Symposium, </booktitle> <month> December </month> <year> 1996. </year> <note> Available at the URL "http://www.cs.unc.edu/~anderson/papers.html". </note>
Reference-contexts: In several related papers, we have presented general techniques that can be used to implement lock-free objects in real-time uniprocessor systems <ref> [3, 18] </ref> and to schedule tasks that share such objects [3, 4]. Related research includes work on techniques for implementing specific lock-free objects (such as read/write buffers) [13, 19, 20], and work on synchronization mechanisms that are similar to lock-free objects but are implemented using kernel support [12, 19, 20]. <p> In several related papers, we have presented general techniques that can be used to implement lock-free objects in real-time uniprocessor systems [3, 18] and to schedule tasks that share such objects <ref> [3, 4] </ref>. Related research includes work on techniques for implementing specific lock-free objects (such as read/write buffers) [13, 19, 20], and work on synchronization mechanisms that are similar to lock-free objects but are implemented using kernel support [12, 19, 20]. Operations on lock-free objects are usually implemented using "retry loops". <p> For cases in which large variations in loop costs exist, Anderson and Ramamurthy have shown that linear programming can be applied to obtain much tighter scheduling conditions <ref> [3] </ref>. <p> Our implementation is based on universal lock-free constructions by Anderson and Moir for implementing large objects and for implementing multi-object operations [1, 2]. The implementation uses a multi-word compare-and-swap (MWCAS) primitive for real-time systems proposed by Anderson and Ramamurthy <ref> [3] </ref>. 3.1 Transaction Routines Our transaction implementation, which is shown in Figure 3, consists of three procedures, TR Read, TR Write, and TR Exec. These procedures support the "illusion" of a contiguous shared array MEM of memory words. <p> The most efficient known wait-free implementation [1] requires fi (N 3 M ) time complexity to implement M words that can be accessed by N tasks. Fortunately, as shown by Anderson and Ramamurthy in <ref> [3] </ref>, a W -word MWCAS can be implemented on a real-time uniprocessor in only O (W ) time (which is clearly optimal). In the remainder of this subsection, we present a brief overview of Anderson and Ramamurthy's implementation. The code for implementing MWCAS and READ is shown in Figure 6. <p> The current value 16 Chapter 1 val count valid pid x: 12 2 true 2 cv (x) = 12 y: 3 1 false 3 cv (y) = 22 z: 8 3 true 4 cv (z) = 8 Save <ref> [3; 1] </ref>: 22 Status [3]: 0 (a) val count valid pid x: 5 0 false 4 cv (x) = 12 y: 10 1 false 4 cv (y) = 22 z: 17 2 false 4 cv (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; <p> The current value 16 Chapter 1 val count valid pid x: 12 2 true 2 cv (x) = 12 y: 3 1 false 3 cv (y) = 22 z: 8 3 true 4 cv (z) = 8 Save [3; 1]: 22 Status <ref> [3] </ref>: 0 (a) val count valid pid x: 5 0 false 4 cv (x) = 12 y: 10 1 false 4 cv (y) = 22 z: 17 2 false 4 cv (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; 1]: 22 Save [4; <p> 22 z: 8 3 true 4 cv (z) = 8 Save <ref> [3; 1] </ref>: 22 Status [3]: 0 (a) val count valid pid x: 5 0 false 4 cv (x) = 12 y: 10 1 false 4 cv (y) = 22 z: 17 2 false 4 cv (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; 1]: 22 Save [4; 2]: 8 Status [4]: 0 (b) val count valid pid x: 5 0 true 4 cv (x) = 5 y: 10 0 true 4 cv (y) = 10 z: 17 0 true 4 cv (z) <p> true 4 cv (z) = 8 Save [3; 1]: 22 Status <ref> [3] </ref>: 0 (a) val count valid pid x: 5 0 false 4 cv (x) = 12 y: 10 1 false 4 cv (y) = 22 z: 17 2 false 4 cv (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; 1]: 22 Save [4; 2]: 8 Status [4]: 0 (b) val count valid pid x: 5 0 true 4 cv (x) = 5 y: 10 0 true 4 cv (y) = 10 z: 17 0 true 4 cv (z) = 17 Status [4]: <p> 4 cv (y) = 10 z: 17 0 true 4 cv (z) = 17 Status [4]: 2 (c) val count valid pid x: 12 2 true 2 cv (x) = 12 y: 3 1 false 3 cv (y) = 22 z: 56 4 true 9 cv (z) = 56 Save <ref> [3; 1] </ref>: 22 Status [3]: 1 Status [4]: 1 (d) (f) with old/new values 12/5, 22/10, and 8/17, respectively. <p> 10 z: 17 0 true 4 cv (z) = 17 Status [4]: 2 (c) val count valid pid x: 12 2 true 2 cv (x) = 12 y: 3 1 false 3 cv (y) = 22 z: 56 4 true 9 cv (z) = 56 Save [3; 1]: 22 Status <ref> [3] </ref>: 1 Status [4]: 1 (d) (f) with old/new values 12/5, 22/10, and 8/17, respectively. <p> The operation interleaving that results in (c) is shown in (e) (t 4 preempts t 3 ). The operation interleaving that results in (d) is shown in (f) (t 4 preempts t 3 , and t 9 preempts t 4 ). of each word is unchanged. Also, Status <ref> [3] </ref> has been updated to indicate that task t 3 (which must be of lower priority) has been interfered with. <p> Inset (d) shows relevant variables at the termination of Lock-Free Transactions for Real-Time Systems 17 m, assuming an interference on word z by task t 9 (which must be of higher-priority) with new value 56. Status [4] is now 1, indicating the failure of t 4 's operation. Status <ref> [3] </ref> is still 1, indicating that t 3 's operation has also failed. Observe that t 4 has successfully restored the original values of words x and y. <p> Although the above description conveys the basic idea of the implementation, there are some subtleties that have been omitted for brevity. A more complete discussion that addresses these subtleties can be found in <ref> [3] </ref>. The results of this subsection yield the following theorem. <p> These experiments were conducted to determine achievable processor utilizations under the various transaction implementations that were tested. This was done by checking the schedulability of randomly generating task sets. A detailed description of the experimental methodology that was followed can be found in <ref> [3] </ref>. When comparing lock-free and lock-based implementations, the main conclusion to be drawn from the experiments is as follows: if lock-free loop costs are (on average) less than corresponding lock-based access costs (i.e., the cost of a lock/object-access/unlock sequence), then lock-free implementations perform better.
Reference: [4] <author> J. Anderson, S. Ramamurthy, and K. </author> <title> Jeffay "Real-Time Computing with Lock-Free Shared Objects", </title> <booktitle> Proceedings of the 16th IEEE Real-Time Systems Symposium, </booktitle> <year> 1995, </year> <pages> pp. 28-37. </pages>
Reference-contexts: In several related papers, we have presented general techniques that can be used to implement lock-free objects in real-time uniprocessor systems [3, 18] and to schedule tasks that share such objects <ref> [3, 4] </ref>. Related research includes work on techniques for implementing specific lock-free objects (such as read/write buffers) [13, 19, 20], and work on synchronization mechanisms that are similar to lock-free objects but are implemented using kernel support [12, 19, 20]. Operations on lock-free objects are usually implemented using "retry loops". <p> In particular, repeated interferences can cause a given operation to take an arbitrarily long time to complete. Fortunately, such interferences can be bounded by scheduling tasks appropriately <ref> [4] </ref>. As explained in the next section, the key to scheduling such tasks is to allow enough spare processor time to accommodate the failed object updates due to interferences that can occur over any interval. <p> Nonetheless, Anderson et al. have shown that if tasks on a uniprocessor are scheduled appropriately, then such loops are indeed bounded <ref> [4] </ref>. We now explain why such bounds exist. For the sake of explanation, let us call an iteration of a retry loop a successful update if it successfully updates an object, and a failed update otherwise. <p> This gives a bound on the number of failed updates in that interval. A 4 Chapter 1 task set is schedulable if there is enough free processor time to accommodate the failed updates that can occur over any interval. In <ref> [4] </ref>, scheduling conditions are established for the DM [14] and EDF [15] priority assignments. In order to state these conditions, we must first define some notation. Each condition applies to a collection of N periodic tasks ft 1 ; : : :; t N g. <p> (z) = 8 Save [3; 1]: 22 Status [3]: 0 (a) val count valid pid x: 5 0 false 4 cv (x) = 12 y: 10 1 false 4 cv (y) = 22 z: 17 2 false 4 cv (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save <ref> [4; 0] </ref>: 12 Save [4; 1]: 22 Save [4; 2]: 8 Status [4]: 0 (b) val count valid pid x: 5 0 true 4 cv (x) = 5 y: 10 0 true 4 cv (y) = 10 z: 17 0 true 4 cv (z) = 17 Status [4]: 2 (c) val <p> [3; 1]: 22 Status [3]: 0 (a) val count valid pid x: 5 0 false 4 cv (x) = 12 y: 10 1 false 4 cv (y) = 22 z: 17 2 false 4 cv (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save <ref> [4; 1] </ref>: 22 Save [4; 2]: 8 Status [4]: 0 (b) val count valid pid x: 5 0 true 4 cv (x) = 5 y: 10 0 true 4 cv (y) = 10 z: 17 0 true 4 cv (z) = 17 Status [4]: 2 (c) val count valid pid x: <p> [3]: 0 (a) val count valid pid x: 5 0 false 4 cv (x) = 12 y: 10 1 false 4 cv (y) = 22 z: 17 2 false 4 cv (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; 1]: 22 Save <ref> [4; 2] </ref>: 8 Status [4]: 0 (b) val count valid pid x: 5 0 true 4 cv (x) = 5 y: 10 0 true 4 cv (y) = 10 z: 17 0 true 4 cv (z) = 17 Status [4]: 2 (c) val count valid pid x: 12 2 true 2 <p> count valid pid x: 5 0 false 4 cv (x) = 12 y: 10 1 false 4 cv (y) = 22 z: 17 2 false 4 cv (z) = 8 Save [3; 1]: 22 Status [3]: 1 Save [4; 0]: 12 Save [4; 1]: 22 Save [4; 2]: 8 Status <ref> [4] </ref>: 0 (b) val count valid pid x: 5 0 true 4 cv (x) = 5 y: 10 0 true 4 cv (y) = 10 z: 17 0 true 4 cv (z) = 17 Status [4]: 2 (c) val count valid pid x: 12 2 true 2 cv (x) = 12 <p> [3]: 1 Save [4; 0]: 12 Save [4; 1]: 22 Save [4; 2]: 8 Status <ref> [4] </ref>: 0 (b) val count valid pid x: 5 0 true 4 cv (x) = 5 y: 10 0 true 4 cv (y) = 10 z: 17 0 true 4 cv (z) = 17 Status [4]: 2 (c) val count valid pid x: 12 2 true 2 cv (x) = 12 y: 3 1 false 3 cv (y) = 22 z: 56 4 true 9 cv (z) = 56 Save [3; 1]: 22 Status [3]: 1 Status [4]: 1 (d) (f) with old/new values 12/5, 22/10, <p> 0 true 4 cv (z) = 17 Status <ref> [4] </ref>: 2 (c) val count valid pid x: 12 2 true 2 cv (x) = 12 y: 3 1 false 3 cv (y) = 22 z: 56 4 true 9 cv (z) = 56 Save [3; 1]: 22 Status [3]: 1 Status [4]: 1 (d) (f) with old/new values 12/5, 22/10, and 8/17, respectively. <p> Also, Status [3] has been updated to indicate that task t 3 (which must be of lower priority) has been interfered with. Note that changing the value of Status <ref> [4] </ref> from 0 to 2 in inset (b) would have the effect of atomically changing the current value of each of x, y, and z to the desired new value. Inset (c) shows relevant variables at the termination of m, assuming no interferences by higher-priority tasks. <p> Inset (c) shows relevant variables at the termination of m, assuming no interferences by higher-priority tasks. The current value of each word is now the desired new value, and all valid fields are true (so the value of Status <ref> [4] </ref> is no longer relevant). Inset (d) shows relevant variables at the termination of Lock-Free Transactions for Real-Time Systems 17 m, assuming an interference on word z by task t 9 (which must be of higher-priority) with new value 56. Status [4] is now 1, indicating the failure of t 4 <p> valid fields are true (so the value of Status <ref> [4] </ref> is no longer relevant). Inset (d) shows relevant variables at the termination of Lock-Free Transactions for Real-Time Systems 17 m, assuming an interference on word z by task t 9 (which must be of higher-priority) with new value 56. Status [4] is now 1, indicating the failure of t 4 's operation. Status [3] is still 1, indicating that t 3 's operation has also failed. Observe that t 4 has successfully restored the original values of words x and y.
Reference: [5] <author> N. Audsley, A. Burns, M. Richardson, and A. Wellings, </author> <title> "Hard Real-Time Scheduling: The Deadline Monotonic Approach", </title> <booktitle> Proceedings of the 8th IEEE Workshop on Real-Time Operating Systems and Software, </booktitle> <year> 1992, </year> <pages> pp. 127-132. </pages>
Reference-contexts: In comparing the above condition to the DM condition for independent tasks given in <ref> [5] </ref>, we see that the above condition essentially requires that the computation time of each task be "dilated" by the time it takes for one lock-free loop iteration.
Reference: [6] <author> G. Barnes, </author> <title> "A Method for Implementing Lock-Free Shared Data Structures", </title> <booktitle> Proceedings of the fifth Annual ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <year> 1993, </year> <pages> pp. 261-270. </pages>
Reference-contexts: Unfortunately, MWCAS is exceedingly difficult to implement efficiently in truly asynchronous systems <ref> [1, 6, 9, 22] </ref>. The most efficient known wait-free implementation [1] requires fi (N 3 M ) time complexity to implement M words that can be accessed by N tasks.
Reference: [7] <author> M. Herlihy, </author> <title> "Wait-Free Synchronization", </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 13, No. 1, </volume> <year> 1991, </year> <pages> pp. 124-149. </pages>
Reference-contexts: The fact that many lock-free object implementations are based on such primitives is no accident. Herlihy has shown that strong primitives are, in general, necessary for these implementations <ref> [7] </ref>. Nonetheless, Ramamurthy, Moir, and Anderson have shown that simple read and write instructions can be used to implement any strong synchronization primitive in a wait-free manner on a uniprocessor real-time system [18].
Reference: [8] <author> M. Herlihy, </author> <title> "A Methodology for Implementing Highly Concurrent Data Objects", </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 15, No. 5, </volume> <year> 1993, </year> <pages> pp. 745-770. </pages>
Reference-contexts: The only common scheduling policy that we know of that violates Axiom 2 is least-laxity-first scheduling [16]. Lock-Free Transactions for Real-Time Systems 7 Most practical implementations of lock-free objects are based on compare-and-swap (CAS) and related primitives like load-linked/store-conditional (LL/SC) <ref> [8] </ref>.
Reference: [9] <author> A. Israeli and L. Rappoport, </author> <title> "Disjoint-Access-Parallel Implementations of Strong Shared Memory Primitives", </title> <booktitle> Proceedings of the 13th Annual ACM Symposium on Principles of Distributed Computing , 1994, </booktitle> <pages> pp. 151-160. </pages>
Reference-contexts: Unfortunately, MWCAS is exceedingly difficult to implement efficiently in truly asynchronous systems <ref> [1, 6, 9, 22] </ref>. The most efficient known wait-free implementation [1] requires fi (N 3 M ) time complexity to implement M words that can be accessed by N tasks.
Reference: [10] <author> J. Harista, M. Carey, and M. Livny, </author> <title> "On Being Optimistic about Real-Time Constraints", </title> <booktitle> Proceedings of the Ninth ACM Symposium on Principles of Database Systems, </booktitle> <year> 1990, </year> <pages> pp. 331-343. </pages> <note> 20 Chapter 1 </note>
Reference-contexts: In this chapter, we show that previous work on lock-free objects can be extended to apply to lock-free transactions on memory-resident databases. Compared to conventional optimistic concurrency control schemes, our lock-free transaction implementation is most similar to optimistic concurrency control with broadcast commit <ref> [10] </ref>. The main difference between our implementation and conventional schemes is that we use a strong synchronization primitive at the user level to validate and commit transactions. The strong primitive used in our implementation is a multi-word compare-and-swap (MWCAS). <p> These routines are called within the programmer's transaction code in order to read or write a word of the MEM array. Thus, instead of writing "MEM [1] := MEM <ref> [10] </ref>", the programmer would write "TR Write (1; TR Read (10))". Figure 4 shows a simple example transaction, which updates the temperature display of a boiler. This transaction would be executed by calling TR Exec (update display).
Reference: [11] <author> M. Herlihy and J. Wing, </author> <title> "Linearizability: A Correctness Condition for Concurrent Objects," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 12, No. 3, </volume> <year> 1990, </year> <pages> pp. 463-492. </pages>
Reference-contexts: Also, objects such as queues can be incorporated into the implementation without using a copy-based solution. The techniques shown here can potentially simplify transaction abort/recovery. In particular, each lock-free transaction execution has a distinct linearization step <ref> [11] </ref>, and a transaction does not affect other transactions before it executes this step. Thus, complicated recovery procedures for undoing the effects of partially completed transactions are not required. (The ability to stop and restart a transaction arbitrarily would require some additional "clean up" code.
Reference: [12] <author> T. Johnson and K. Harathi, </author> <title> "Interruptible Critical Sections", </title> <type> Technical Report TR94-007, </type> <institution> Department of Computer Science, University of Florida, </institution> <year> 1994. </year>
Reference-contexts: Related research includes work on techniques for implementing specific lock-free objects (such as read/write buffers) [13, 19, 20], and work on synchronization mechanisms that are similar to lock-free objects but are implemented using kernel support <ref> [12, 19, 20] </ref>. Operations on lock-free objects are usually implemented using "retry loops".
Reference: [13] <author> H. Kopetz and J. Reisinger, </author> <title> "The Non-Blocking Write Protocol NBW: </title>
Reference-contexts: In several related papers, we have presented general techniques that can be used to implement lock-free objects in real-time uniprocessor systems [3, 18] and to schedule tasks that share such objects [3, 4]. Related research includes work on techniques for implementing specific lock-free objects (such as read/write buffers) <ref> [13, 19, 20] </ref>, and work on synchronization mechanisms that are similar to lock-free objects but are implemented using kernel support [12, 19, 20]. Operations on lock-free objects are usually implemented using "retry loops".
References-found: 13

