URL: http://www.cs.pitt.edu/~gupta/research/Comp/lcpc98.ps
Refering-URL: http://www.cs.pitt.edu/~gupta/research/scheduling.html
Root-URL: http://www.cs.pitt.edu
Phone: 2  
Title: Integrated Instruction Scheduling and Register Allocation Techniques  
Author: David A. Berson Rajiv Gupta Mary Lou Soffa 
Address: 2200 Mission College Blvd., Santa Clara, CA 95052  Pittsburgh, Pittsburgh, PA 15260, USA  
Affiliation: 1 Intel Corporation, Microcomputer Research Lab,  Dept. of Computer Science, Univ. of  
Abstract: An algorithm for integrating instruction scheduling and register allocation must support mechanisms for detecting excessive register and functional unit demands and applying reductions for lessening these demands. The excessive demands for functional units can be detected by identifying the instructions that can execute in parallel, and can be reduced by scheduling some of these instructions sequentially. The excessive demands for registers can be detected on-the-fly while scheduling by maintaining register pressure values or may be detected prior to scheduling using an appropriate representation such as parallel interference graphs or register reuse dags. Reductions in excessive register demands can be achieved by live range spilling or live range splitting. However, existing integrated algorithms that are based upon mechanisms other than register reuse dags do not employ live range splitting. In this paper, we demonstrate that for integrated algorithms, register reuse dags are more effective than either on-the-fly computation of register pressure or interference graphs and that live range splitting is more effective than live range spilling. Moreover the choice of mechanisms greatly impacts on the performance of an integrated algorithm.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> David A. Berson, </author> <title> Unification of register allocation and instruction scheduling in compilers for fine grain architectures. </title> <type> Ph.D. Thesis, </type> <institution> Dept. of Computer Science, University of Pittsburgh, </institution> <address> Pittsburgh, PA, </address> <month> November </month> <year> 1996. </year>
Reference-contexts: The unified resource allocation (URSA) approach developed by us is based upon the measure-and-reduce paradigm for both registers and functional units [4]. Using the reuse dags, this approach identifies excessive sets that represent groups of instructions whose parallel scheduling requires more resources than are available <ref> [1] </ref>. The excessive sets are then used to drive re ductions of the excessive demands for resources. Live range splitting is used to reduce register demands. This algorithm performs better than the algorithms based upon the on-the-fly approach and interference graphs and also has the lowest compilation times. <p> Instruction scheduling is viewed as the allocation of functional units in this approach. Integration is achieved by simultaneously allocating both functional unit and register resources to an instruction. Due to its unified treatment of resources, this approach is referred to as the unified resource allocation approach or URSA <ref> [1, 3, 2, 4] </ref>. Algorithms that use the URSA approach are based upon the measure-and-reduce paradigm. In this approach the areas of the program with excessive resource requirements are located and reductions are performed by transforming the intermediate representation of the program.
Reference: 2. <author> David A. Berson, Rajiv Gupta, and Mary Lou Soffa. GURRR: </author> <title> A global unified resource requirements representation. </title> <booktitle> In Proc. of ACM Workshop on Intermediate Representations, Sigplan Notices, </booktitle> <volume> vol. 30, </volume> <pages> pages 23-34, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Instruction scheduling is viewed as the allocation of functional units in this approach. Integration is achieved by simultaneously allocating both functional unit and register resources to an instruction. Due to its unified treatment of resources, this approach is referred to as the unified resource allocation approach or URSA <ref> [1, 3, 2, 4] </ref>. Algorithms that use the URSA approach are based upon the measure-and-reduce paradigm. In this approach the areas of the program with excessive resource requirements are located and reductions are performed by transforming the intermediate representation of the program. <p> The areas of overutilization are referred to excessive sets and the areas of underutilization are called resource holes. The GURRR intermediate representation has been developed to explicitly incorporate maximum resource requirements, excessive sets and resource holes <ref> [2] </ref>. This representation used in URSA combines information about a program's requirements for both registers and functional units with scheduling information in a single DAG-based representation.
Reference: 3. <author> David A. Berson, Rajiv Gupta, and Mary Lou Soffa. </author> <title> Resource Spackling: A framework for integrating register allocation in local and global schedulers. </title> <booktitle> In Proc. of IFIP WG 10.3 Working Conference on Parallel Architectures and Compilation Tech--niques, </booktitle> <pages> pages 135-146, </pages> <year> 1994. </year>
Reference-contexts: Instruction scheduling is viewed as the allocation of functional units in this approach. Integration is achieved by simultaneously allocating both functional unit and register resources to an instruction. Due to its unified treatment of resources, this approach is referred to as the unified resource allocation approach or URSA <ref> [1, 3, 2, 4] </ref>. Algorithms that use the URSA approach are based upon the measure-and-reduce paradigm. In this approach the areas of the program with excessive resource requirements are located and reductions are performed by transforming the intermediate representation of the program. <p> The URSA framework supports a set of techniques to perform the allocation of resources to instructions. The techniques utilize the resource holes in GURRR during this process. These techniques are referred to as resource spackling techniques because they perform allocations by trying to fill the resource holes with instructions <ref> [3] </ref>. Register holes represent the cases where a register can be assigned to hold a value. There are two such cases: when the register is unoccupied and when the register is occupied but the value in it is not currently being referenced, and so, the live range can be split.
Reference: 4. <author> David A. Berson, Rajiv Gupta, and Mary Lou Soffa. </author> <title> URSA: A Unified ReSource Allocator for registers and functional units in VLIW architectures. </title> <booktitle> In Proc. of IFIP WG 10.3 Working Conference on Architectures and Compilation Techniques for Fine and Medium Grain Parallelism, </booktitle> <pages> pages 243-254, </pages> <year> 1993. </year>
Reference-contexts: By comparing the performances of the above algorithms we conclude that register reuse dags are superior to interference graphs. The unified resource allocation (URSA) approach developed by us is based upon the measure-and-reduce paradigm for both registers and functional units <ref> [4] </ref>. Using the reuse dags, this approach identifies excessive sets that represent groups of instructions whose parallel scheduling requires more resources than are available [1]. The excessive sets are then used to drive re ductions of the excessive demands for resources. Live range splitting is used to reduce register demands. <p> Instruction scheduling is viewed as the allocation of functional units in this approach. Integration is achieved by simultaneously allocating both functional unit and register resources to an instruction. Due to its unified treatment of resources, this approach is referred to as the unified resource allocation approach or URSA <ref> [1, 3, 2, 4] </ref>. Algorithms that use the URSA approach are based upon the measure-and-reduce paradigm. In this approach the areas of the program with excessive resource requirements are located and reductions are performed by transforming the intermediate representation of the program.
Reference: 5. <author> Preston Briggs. </author> <title> Register allocation via graph coloring. </title> <type> Ph.D. Thesis, </type> <institution> Dept. of Computer Science, Rice University, Houston, TX, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: The results that were obtained show that the amount of spill code generated in RRD was significantly less than the amount generated in PIR (see Figure 2). We examined numerous cases to verify the results and found a common occurrence mentioned in Briggs' dissertation <ref> [5] </ref>. Although all nodes in the reduced interference graph interfere with at least K other values, those K values may not need all K colors. Excessive set mea-surement computations realize when such a situation occurs and count fewer interferences.
Reference: 6. <author> David Bradlee, Susan Eggers, and Robert Henry. </author> <title> Integrating register allocation and instruction scheduling for riscs. </title> <booktitle> In Proceedings of ASPLOS, </booktitle> <month> April </month> <year> 1991. </year>
Reference-contexts: This is because the higher the register pressure the greater is need for effective integration of register allocation and instruction scheduling. Results of two additional studies that have considered the interaction between instruction scheduling and register allocation were reported by Bradlee et al. <ref> [6] </ref> and Norris et al. [13]. In contrast to these studies, our study shows a greater degree of variation in the performance of different algorithms and thus indicating a greater significance of the impact of integration on performance.
Reference: 7. <author> Claude-Nicholas Fiechter, </author> <title> PDG C Compiler. </title> <type> Technical Report, </type> <institution> Dept. of Computer Science, University of Pittsburgh, </institution> <address> Pittsburgh, PA, </address> <year> 1993. </year>
Reference: 8. <author> G. J. Chaitin, M. A. Auslander, A. K. Chandra, J. Cocke, M. E. Hopkins, and P. W. Markstein. </author> <title> Register allocation via coloring. </title> <journal> Computer Languages, </journal> <volume> 6(1) </volume> <pages> 47-58, </pages> <year> 1981. </year>
Reference-contexts: A postpass register allocation via coloring is performed to handle any register allocation problems that the scheduler is unable to address. This register allocator uses a traditional priority based coloring approach to select candidate live ranges for spilling <ref> [8] </ref>. The ILS algorithm eliminates the need for the spilling postpass by using live range splitting during instruction scheduling to ensure that the register pressure never exceeds the maximum allowable value. <p> This trend indicates that the effectiveness of integration strategy has a greater impact on performance for higher register pressures. 4 Parallel Interference Graphs vs Register Reuse Dags A more sophisticated approach for global register allocation is based upon the coloring of interference graphs <ref> [9, 8] </ref>. This approach was extended to make the process of register allocation schedule sensitive through the construction of a parallel interference graph [14, 15]. <p> This approach was extended to make the process of register allocation schedule sensitive through the construction of a parallel interference graph [14, 15]. The algorithm (PIR) we implemented is based on a parallel interference graph proposed by Norris and Pollock [14] and uses a Chaitin <ref> [8] </ref> style register allocator which relies upon live range spilling. The parallel interference graph represents all interferences that can occur in legal schedules.
Reference: 9. <author> F. Chow and J. Hennessy. </author> <title> Register allocation by priority-based coloring. </title> <journal> ACM Trans. Prog. Lang. and Systems, </journal> <volume> 12(4) </volume> <pages> 501-536, </pages> <year> 1990. </year>
Reference-contexts: This trend indicates that the effectiveness of integration strategy has a greater impact on performance for higher register pressures. 4 Parallel Interference Graphs vs Register Reuse Dags A more sophisticated approach for global register allocation is based upon the coloring of interference graphs <ref> [9, 8] </ref>. This approach was extended to make the process of register allocation schedule sensitive through the construction of a parallel interference graph [14, 15]. <p> The remaining nodes are then processed to reduce the register requirements. Reductions are achieved using both sequentialization and spilling. While live range splitting has been incorporated into traditional coloring based register allocators <ref> [9] </ref>, it has not been incorporated in schedule sensitive allocators based upon parallel interference graphs due to the lack of a complete ordering of the instructions. Without a complete ordering, it cannot be guaranteed that a particular splitting of a live range will reduce the number of interferences.
Reference: 10. <author> Jeanne Ferrante, Karl J. Ottenstein, and Joe D. Warren. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Trans. Prog. Lang. and Systems, </journal> <volume> 9(3) </volume> <pages> 319-349, </pages> <year> 1987. </year>
Reference-contexts: Previous studies have been limited to single issue pipelined machines and therefore do not reveal the true significance of integration. In our algorithms, both instruction scheduling and register allocation are performed hierarchically over the program dependence graph (PDG) <ref> [10] </ref>; that is, each algorithm traverses the control dependence graph in a bottom-up fashion, performing integrated instruction scheduling and register allocation in each region and then using the results at the next higher control dependence level.
Reference: 11. <author> James R. Goodman and Wie-Chung Hsu. </author> <title> Code scheduling and register allocation in large basic blocks. </title> <booktitle> In Proc. of ACM Supercomputing Conf., </booktitle> <pages> pages 442-452, </pages> <year> 1988. </year>
Reference-contexts: However, none of the existing integrated algorithms are based upon these mechanisms. We implemented newly developed integrated algorithms as well as existing algorithms to obtain the above results as follows. The on-the-fly approach (IPS) developed by Goodman and Hsu <ref> [11] </ref> performs local register allocation within extended basic blocks during instruction scheduling. It tracks register pressure to detect excessive register demands and uses live range spilling to reduce register pressure. We extended this technique to incorporate live range splitting (ILS). <p> If register pressure exceeds the maximum number of registers available, register spilling is required. The two algorithms based upon this approach that were implemented differ in their treatment of excessive register requirements. The IPS algorithm proposed by Goodman and Hsu <ref> [11] </ref> addresses the excessive requirements for registers through live range spilling which is carried out during a separate pass following the scheduling prepass using extended basic blocks. <p> We also found that the priority function which considers instructions with most slack time first (i.e., URSA-1) does consistently better than the one that considers instructions with least slack time first (i.e., URSA-2). This result was a bit unexpected due to the fact that Goodman and Hsu <ref> [11] </ref> recommend the scheduling of instructions with the least amount of slack time first. This experiment suggests that scheduling the instructions with the most slack first achieves better performance because these instructions are most likely to be moved beyond the range of the excessive set. <p> Compile-time costs of various approaches. approach. When only considering on-the-fly register allocation with scheduling technique, we show that the ILS technique proposed by us that uses live range splitting performs much better than Goodman and Hsu's IPS technique <ref> [11] </ref> that uses live range spilling. Finally a general trend was observed in all the experiments. The difference in the performances of different heuristics grew smaller as greater numbers of registers were made available.
Reference: 12. <author> Cindy Norris and Lori L. Pollock. </author> <title> Register allocation over the program dependence graph. </title> <booktitle> In Proc. of Sigplan '94 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 266-277, </pages> <year> 1994. </year>
Reference: 13. <author> Cindy Norris and Lori L. Pollock. </author> <title> An experimental study of several cooperative register allocation and instruction scheduling strategies. </title> <booktitle> Proceedings of MICRO-28, </booktitle> <month> Nov. </month> <year> 1995. </year>
Reference-contexts: This is because the higher the register pressure the greater is need for effective integration of register allocation and instruction scheduling. Results of two additional studies that have considered the interaction between instruction scheduling and register allocation were reported by Bradlee et al. [6] and Norris et al. <ref> [13] </ref>. In contrast to these studies, our study shows a greater degree of variation in the performance of different algorithms and thus indicating a greater significance of the impact of integration on performance.
Reference: 14. <author> Cindy Norris and Lori L. Pollock. </author> <title> A scheduler-sensitive global register allocator. </title> <booktitle> Proceedings of Supercomputing'93, </booktitle> <pages> pages 804-813, </pages> <address> Portland, Oregon, </address> <year> 1993. </year>
Reference-contexts: Based upon the performances of the original and extended versions of the algorithm we conclude that live range splitting is far superior to live range spilling when developing an integrated resource allocator. The parallel interference graph approach developed by Norris and Pollock <ref> [14] </ref> uses an extended interference graph to detect excessive register demands and guide schedule sensitive register allocation (PIR). The reduction in register demands is achieved through live range spilling. <p> This approach was extended to make the process of register allocation schedule sensitive through the construction of a parallel interference graph <ref> [14, 15] </ref>. The algorithm (PIR) we implemented is based on a parallel interference graph proposed by Norris and Pollock [14] and uses a Chaitin [8] style register allocator which relies upon live range spilling. The parallel interference graph represents all interferences that can occur in legal schedules. <p> This approach was extended to make the process of register allocation schedule sensitive through the construction of a parallel interference graph [14, 15]. The algorithm (PIR) we implemented is based on a parallel interference graph proposed by Norris and Pollock <ref> [14] </ref> and uses a Chaitin [8] style register allocator which relies upon live range spilling. The parallel interference graph represents all interferences that can occur in legal schedules.
Reference: 15. <author> Shlomit S. Pinter. </author> <title> Register allocation with instruction scheduling: A new approach. </title> <booktitle> In Proc. of Sigplan '93 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 248-257, </pages> <year> 1993. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: This approach was extended to make the process of register allocation schedule sensitive through the construction of a parallel interference graph <ref> [14, 15] </ref>. The algorithm (PIR) we implemented is based on a parallel interference graph proposed by Norris and Pollock [14] and uses a Chaitin [8] style register allocator which relies upon live range spilling. The parallel interference graph represents all interferences that can occur in legal schedules.
References-found: 15

