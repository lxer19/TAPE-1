URL: http://kirmes.inferenzsysteme.informatik.th-darmstadt.de/~giesl/RTA97-report.ps
Refering-URL: http://www.inferenzsysteme.informatik.tu-darmstadt.de/~giesl/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: E-mail: thomas@cs.ruu.nl  E-mail: giesl@inferenzsysteme.informatik.th-darmstadt.de  
Phone: 2  
Title: Proving Innermost Normalisation Automatically  
Author: Thomas Arts and Jurgen Giesl 
Address: P.O. Box 80.089, 3508 TB Utrecht, The Netherlands,  Alexanderstr. 10, 64283 Darmstadt, Germany,  
Affiliation: 1 Dept. of Computer Science, Utrecht University,  FB Informatik, TH Darmstadt,  
Abstract: We present a technique to prove innermost normalisation of term rewriting systems (TRSs) automatically. In contrast to previous methods, our technique is able to prove innermost normalisation of TRSs that are not terminating. Our technique can also be used for termination proofs of all TRSs where innermost normalisation implies termination, such as non-overlapping TRSs or locally confluent overlay systems. In this way, termination of many (also non-simply terminating) TRSs can be verified automatically.
Abstract-found: 1
Intro-found: 1
Reference: [AG96a] <author> T. Arts and J. Giesl. </author> <title> Termination of constructor systems. </title> <type> Technical Report UU-CS-1996-07, </type> <institution> Utrecht University, </institution> <address> PO box 80.089, 3508 TB Utrecht, </address> <month> February </month> <year> 1996. </year> <note> http://www.cs.ruu.nl/. 44 </note>
Reference-contexts: In the examples, termination of R 0 is always easy to show (either by applying our method again or by standard techniques, i.e. R 0 is usually simply terminating). First, our technique is used to prove termination of all examples of <ref> [AG96a] </ref> (Ex. 8.1 - 8.14). While the method of [AG96a, AG96b] was only applicable to a restricted class of constructor systems (without nested recursion), the present technique can be used for termination proofs of arbitrary locally confluent overlay systems. <p> R 0 is usually simply terminating). First, our technique is used to prove termination of all examples of [AG96a] (Ex. 8.1 - 8.14). While the method of <ref> [AG96a, AG96b] </ref> was only applicable to a restricted class of constructor systems (without nested recursion), the present technique can be used for termination proofs of arbitrary locally confluent overlay systems.
Reference: [AG96b] <author> T. Arts and J. Giesl. </author> <title> Termination of constructor systems. </title> <editor> In H. Ganzinger, editor, </editor> <booktitle> Proceedings of the 7th International Conference on Rewriting Techniques and Applications, RTA-96, volume 1103 of Lecture Notes in Computer Science, </booktitle> <pages> pages 63-77, </pages> <address> New Brunswick, NJ, USA, July 1996. </address> <publisher> Springer Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: TRSs from different areas of computer science (such as arithmetical operations, several sorting algorithms, a reachability algorithm on graphs, a TRS for substitutions in the lambda calculus etc.). 14 The concept of dependency pairs has been introduced in [Art96] and a first automation of this concept can be found in <ref> [AG96b] </ref>. However, these approaches were restricted to non-overlapping constructor systems without nested recursion, whereas in the present paper we dealt with arbitrary rewrite systems. <p> Finally, the introduction of innermost dependency graphs led to a considerably more powerful technique than the method proposed in <ref> [AG96b] </ref>. Dependency pairs have a connection to semantic labelling [Zan95] (resp. to self -labelling [MOZ96]). However, compared to semantic labelling the dependency pair approach is better suited for automation, because here one does not have to find an appropriate semantic interpretation. <p> In particular, this collection also includes several systems that are not simply terminating, cf. [Der79, Ste95b]. As mentioned in Sect. 1, in contrast to termination there exist several modularity results for innermost normalisation, e.g. [Kri95, Art96]. In particular, we can use the following result for hierarchical combinations, cf. <ref> [AG96b] </ref>. A TRS is a hierarchical combination of two subsystems if defined symbols of the first system occur as constructors in the second system, but not vice versa. <p> R 0 is usually simply terminating). First, our technique is used to prove termination of all examples of [AG96a] (Ex. 8.1 - 8.14). While the method of <ref> [AG96a, AG96b] </ref> was only applicable to a restricted class of constructor systems (without nested recursion), the present technique can be used for termination proofs of arbitrary locally confluent overlay systems. <p> hand, there are also (overlapping) TRSs, where the method of [AG97a] can prove termination, but the method of the present paper cannot be used for that purpose, because for these systems innermost normalisation is not sufficient for termination. 8.1 Division, Version 1 This is the running example of the article <ref> [AG96b] </ref>, which is not simply termi nating. minus (x; 0) ! x 22 minus (s (x); s (y)) ! minus (x; y) quot (0; s (y)) ! 0 quot (s (x); s (y)) ! s (quot (minus (x; y); s (y))) In the termination proof of this example one can apply
Reference: [AG96c] <author> T. Arts and J. Giesl. </author> <title> Automatically proving termination where simplification orderings fail. </title> <type> Technical Report UU-CS-1996-44, </type> <institution> Utrecht University, </institution> <month> October </month> <year> 1996. </year> <note> http://www.cs.ruu.nl/. </note>
Reference-contexts: In [AG97a] however, we have also developed a method for termination proofs of arbitrary TRSs (i.e. there, they do not have to be locally confluent overlay systems). Termination of the examples 8.15 - 8.27 can also be proved by the method of <ref> [AG96c, AG97a] </ref>. However, as innermost normalisation is essentially easier to prove than termination, when using the method of the present paper, we often obtain considerably less constraints than when using the technique of [AG97a].
Reference: [AG97a] <author> T. Arts and J. Giesl. </author> <title> Automatically proving termination where simplification orderings fail. </title> <editor> In M. Dauchet, editor, </editor> <booktitle> Proceedings of the 22nd International Colloquium on Trees in Algebra and Programming, CAAP'97, Lecture Notes in Computer Science, </booktitle> <address> Lille, France, April 1997. </address> <publisher> Springer Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: A sequence of dependency pairs is a chain if there exists a substitution such that for all consecutive pairs hs j ; t j i and hs j+1 ; t j+1 i in the sequence we have t j ! fl R s j+1 (cf. <ref> [AG97a] </ref>). In this way, the right-hand side of every dependency pair can be seen as the newly introduced redex that should be traced and the reductions t j ! fl R s j+1 are necessary to normalize the arguments of the redex that is traced. <p> As our technique can only be applied for termination proofs if the TRS is non-overlapping (or at least an overlay system with joinable critical pairs), in <ref> [AG97a] </ref> we also showed how dependency pairs can be used for termination proofs of arbitrary TRSs. However, as long as the system is non-overlapping, it is always advantageous to prove innermost normalisation only (instead of termination). <p> However, as long as the system is non-overlapping, it is always advantageous to prove innermost normalisation only (instead of termination). For instance, termination of the quot system can easily be proved with the technique introduced in the present paper, whereas the constraints generated by the method of <ref> [AG97a] </ref> are not satisfied by any quasi-ordering which is amenable to automation (i.e. by any total or quasi-simplification ordering). Most previous methods developed for automatic termination proofs are based on simplification orderings. <p> In this paper we have presented a method for innermost normalisation which can also be used for termination proofs if the TRS is non-overlapping or at least a locally confluent overlay system. In <ref> [AG97a] </ref> however, we have also developed a method for termination proofs of arbitrary TRSs (i.e. there, they do not have to be locally confluent overlay systems). Termination of the examples 8.15 - 8.27 can also be proved by the method of [AG96c, AG97a]. <p> In [AG97a] however, we have also developed a method for termination proofs of arbitrary TRSs (i.e. there, they do not have to be locally confluent overlay systems). Termination of the examples 8.15 - 8.27 can also be proved by the method of <ref> [AG96c, AG97a] </ref>. However, as innermost normalisation is essentially easier to prove than termination, when using the method of the present paper, we often obtain considerably less constraints than when using the technique of [AG97a]. <p> Termination of the examples 8.15 - 8.27 can also be proved by the method of [AG96c, AG97a]. However, as innermost normalisation is essentially easier to prove than termination, when using the method of the present paper, we often obtain considerably less constraints than when using the technique of <ref> [AG97a] </ref>. For that reason, termination of the Examples 8.31 - 8.35 cannot be shown automatically by the method of [AG97a] whereas with the technique of the present paper we can prove innermost normal-isation (and thereby termination) automatically. On the other hand, there are also (overlapping) TRSs, where the method of [AG97a] <p> However, as innermost normalisation is essentially easier to prove than termination, when using the method of the present paper, we often obtain considerably less constraints than when using the technique of <ref> [AG97a] </ref>. For that reason, termination of the Examples 8.31 - 8.35 cannot be shown automatically by the method of [AG97a] whereas with the technique of the present paper we can prove innermost normal-isation (and thereby termination) automatically. On the other hand, there are also (overlapping) TRSs, where the method of [AG97a] can prove termination, but the method of the present paper cannot be used for that purpose, because for these <p> <ref> [AG97a] </ref>. For that reason, termination of the Examples 8.31 - 8.35 cannot be shown automatically by the method of [AG97a] whereas with the technique of the present paper we can prove innermost normal-isation (and thereby termination) automatically. On the other hand, there are also (overlapping) TRSs, where the method of [AG97a] can prove termination, but the method of the present paper cannot be used for that purpose, because for these systems innermost normalisation is not sufficient for termination. 8.1 Division, Version 1 This is the running example of the article [AG96b], which is not simply termi nating. minus (x; 0) ! <p> Termination of this system cannot be proved automatically using the method of <ref> [AG97a] </ref>, as the constraints generated by the technique of [AG97a] are not satisfied by any total or quasi-simplification ordering. <p> Termination of this system cannot be proved automatically using the method of <ref> [AG97a] </ref>, as the constraints generated by the technique of [AG97a] are not satisfied by any total or quasi-simplification ordering. <p> Hence, the TRS is terminating. 8.33 A non-totally terminating TRS The following example is from [Ste95a]. f (x; x) ! f (a; b) This TRS is not totally terminating (and the constraints generated by the method of <ref> [AG97a] </ref> are not satisfied by any total well-founded quasi-ordering). However, with our method innermost normalisation (and thereby, termination) can easily be proved. The reason is that after applying one narrowing step to f (a; b) we obtain f (a; c) which is not unifiable with f (x; x). <p> Thus, the TRS is terminating. Again, termination of this system cannot be proved automatically using the method of <ref> [AG97a] </ref>. 8.35 Renaming in the Lambda Calculus The following system is a variation of an algorithm from [MA96]. The purpose of the function ren (x; y; t) is to replace every free occurrence of the variable x in the term t by the variable y. <p> Note that the modularity result of Thm. 12 is essential for this termination proof. If termination of the whole system would have to be proved at once, then the resulting inequalities would not be satisfied by any polynomial or path ordering. For that reason the method of <ref> [AG97a] </ref> (for termination instead of innermost normalisation) cannot handle this example automatically. Acknowledgements We would like to thank Hans Zantema, Aart Middeldorp, Thomas Kolbe, and the referees for constructive criticism and many helpful comments.
Reference: [AG97b] <author> T. Arts and J. Giesl. </author> <title> Proving Innermost Normalisation Automatically. </title> <booktitle> In Proceedings of the 8th International Conference on Rewriting Techniques and Applications, RTA-97, Lecture Notes in Computer Science, </booktitle> <address> Sitges, Spain, June 1997. </address> <publisher> Springer Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: Therefore, none of the techniques could prove innermost normalisation of non-terminating systems. ? Technical Report IBN 96/39, Technische Hochschule Darmstadt. This is an extended version of an article with the same title presented at RTA-97 <ref> [AG97b] </ref>. This work was partially supported by the Deutsche Forschungsgemeinschaft under grant no. Wa 652/7-1 as part of the focus program "Deduktion". In the following we present a technique for innermost normalisation proofs. For that purpose, in Sect. 2 we introduce a criterion for innermost normalisa-tion.
Reference: [Art96] <author> T. </author> <title> Arts. Termination by absence of infinite chains of dependency pairs. </title> <editor> In H. Kirchner, editor, </editor> <booktitle> Proceedings of the 21st International Colloquium on Trees in Algebra and Programming, CAAP'96, volume 1059 of Lecture Notes in Computer Science, </booktitle> <pages> pages 196-210, </pages> <address> Linkoping, Sweden, April 1996. </address> <publisher> Springer Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: In Sect. 4 and 5 our technique is refined further and in Sect. 6 we give a summary and comment on connections and possible combinations with related approaches. For several classes of TRSs, innermost normalisation already suffices for termination [Gra95, Gra96]. Moreover, several modularity results exist for innermost normalisation <ref> [Kri95, Art96] </ref>, which do not hold for termination. Therefore, for those classes of TRSs termination can be proved by splitting the TRS and proving innermost normalisation of the subsystems separately. <p> non-simply terminating challenge problems from literature as well as many practically relevant TRSs from different areas of computer science (such as arithmetical operations, several sorting algorithms, a reachability algorithm on graphs, a TRS for substitutions in the lambda calculus etc.). 14 The concept of dependency pairs has been introduced in <ref> [Art96] </ref> and a first automation of this concept can be found in [AG96b]. However, these approaches were restricted to non-overlapping constructor systems without nested recursion, whereas in the present paper we dealt with arbitrary rewrite systems. <p> Moreover, in contrast to these first approaches, in this paper we developed a complete criterion for innermost normalisation and proved its soundness in a short and easy way (while the corresponding proof in <ref> [Art96] </ref> was based on semantic labelling [Zan95]). Finally, the introduction of innermost dependency graphs led to a considerably more powerful technique than the method proposed in [AG96b]. Dependency pairs have a connection to semantic labelling [Zan95] (resp. to self -labelling [MOZ96]). <p> In particular, this collection also includes several systems that are not simply terminating, cf. [Der79, Ste95b]. As mentioned in Sect. 1, in contrast to termination there exist several modularity results for innermost normalisation, e.g. <ref> [Kri95, Art96] </ref>. In particular, we can use the following result for hierarchical combinations, cf. [AG96b]. A TRS is a hierarchical combination of two subsystems if defined symbols of the first system occur as constructors in the second system, but not vice versa.
Reference: [AZ95] <author> T. Arts and H. Zantema. </author> <title> Termination of logic programs using semantic unification. </title> <editor> In M. Proietti, editor, </editor> <booktitle> Proceedings of the 5th International Workshop on Logic Program Synthesis and Transformation, volume 1048 of Lecture Notes in Computer Science, </booktitle> <pages> pages 219-233, </pages> <address> Utrecht, September 1995. </address> <publisher> Springer Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: Techniques for proving innermost normalisation can for example be utilized for termination proofs of functional programs (modelled by TRSs) or of logic programs. (When transforming logic programs into TRSs, innermost normalisation of the TRS implies termination of the logic program <ref> [AZ95] </ref>.) While both termination and innermost normalisation are undecidable properties [HL78], several techniques have been developed for proving termination of TRSs automatically (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a] etc. | for surveys see
Reference: [BD86] <author> L. Bachmair and N. Dershowitz. </author> <title> Commutation, transformation and termination. </title> <editor> In J.H. Siekmann, editor, </editor> <booktitle> Proceedings of the 8th International Conference on Automated Deduction, volume 230 of Lecture Notes in Computer Science, </booktitle> <pages> pages 5-20, </pages> <address> Oxford, England, July 1986. </address> <publisher> Springer Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: TRS implies termination of the logic program [AZ95].) While both termination and innermost normalisation are undecidable properties [HL78], several techniques have been developed for proving termination of TRSs automatically (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings <ref> [BD86, BL90, Ste95a] </ref> etc. | for surveys see e.g. [Der87, Ste95b]). However, there has not been any specific method for innermost normalisation, i.e. the only way to prove innermost nor-malisation automatically was by showing termination of the TRS.
Reference: [BL87] <author> A. Ben Cherifa and P. Lescanne. </author> <title> Termination of rewriting systems by polynomial interpretations and its implementation. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 9 </volume> <pages> 137-159, </pages> <year> 1987. </year>
Reference-contexts: logic programs into TRSs, innermost normalisation of the TRS implies termination of the logic program [AZ95].) While both termination and innermost normalisation are undecidable properties [HL78], several techniques have been developed for proving termination of TRSs automatically (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], semantic interpretations <ref> [Lan79, BL87, BL93, Ste94, Zan94, Gie95b] </ref>, transformation orderings [BD86, BL90, Ste95a] etc. | for surveys see e.g. [Der87, Ste95b]). However, there has not been any specific method for innermost normalisation, i.e. the only way to prove innermost nor-malisation automatically was by showing termination of the TRS.
Reference: [BL90] <author> F. Bellegarde and P. Lescanne. </author> <title> Termination by completion. Applicable Algebra in Engineering, </title> <journal> Communication and Computing, </journal> <volume> 1 </volume> <pages> 79-96, </pages> <year> 1990. </year>
Reference-contexts: TRS implies termination of the logic program [AZ95].) While both termination and innermost normalisation are undecidable properties [HL78], several techniques have been developed for proving termination of TRSs automatically (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings <ref> [BD86, BL90, Ste95a] </ref> etc. | for surveys see e.g. [Der87, Ste95b]). However, there has not been any specific method for innermost normalisation, i.e. the only way to prove innermost nor-malisation automatically was by showing termination of the TRS. <p> Moreover, whenever a direct termination proof is possible with a simplification ordering, then this simplification ordering also satisfies the constraints resulting from our technique. The only other approach for automated termination proofs of non-simply terminating systems is a technique for generating transformation orderings <ref> [BL90] </ref> by Steinbach [Ste95a].
Reference: [BL93] <author> E. Bevers and J. Lewi. </author> <title> Proving termination of (conditional) rewrite systems. </title> <journal> Acta Informatica, </journal> <volume> 30 </volume> <pages> 537-568, </pages> <year> 1993. </year>
Reference-contexts: logic programs into TRSs, innermost normalisation of the TRS implies termination of the logic program [AZ95].) While both termination and innermost normalisation are undecidable properties [HL78], several techniques have been developed for proving termination of TRSs automatically (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], semantic interpretations <ref> [Lan79, BL87, BL93, Ste94, Zan94, Gie95b] </ref>, transformation orderings [BD86, BL90, Ste95a] etc. | for surveys see e.g. [Der87, Ste95b]). However, there has not been any specific method for innermost normalisation, i.e. the only way to prove innermost nor-malisation automatically was by showing termination of the TRS.
Reference: [BM79] <author> R.S. Boyer and J S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <year> 1979. </year>
Reference-contexts: A suitable mapping is given by pred (x) 7! x minus (x; y) 7! x IF gcd (b; x; y) 7! IF gcd (x; y): The interpreted inequalities are satisfied by the recursive path ordering. This example was taken from <ref> [BM79] </ref> resp. [Wal91]. <p> This example is inspired by an algorithm from <ref> [BM79] </ref> and [Wal94]. In the corresponding example from [Ste95a] the rules for le, eq, if rm , and if min were missing. 8.11 Quicksort The following TRS is used to sort a list by the well-known quicksort-algorithm.
Reference: [Der79] <author> N. Dershowitz. </author> <title> A note on simplification orderings. </title> <journal> Information Processing Letters, </journal> <volume> 9(5) </volume> <pages> 212-215, </pages> <year> 1979. </year>
Reference-contexts: quot (0; s (y); s (z)) ! 0 quot (s (x); s (y); z) ! quot (x; y; z) quot (x; 0; s (z)) ! s (quot (x; s (z); s (z))) A problem with virtually all automatic approaches for termination proofs is that they are restricted to simplification orderings <ref> [Der79, Ste95b] </ref> and therefore can only prove termination of TRS that are simply terminating. However, there are numerous relevant and important terminating TRSs where simplification orderings fail. <p> For these TRSs innermost normalisation implies termination. Therefore, applying our technique to prove innermost normalisation to these TRSs results in an automatic approach for termination proofs. In particular, this collection also includes several systems that are not simply terminating, cf. <ref> [Der79, Ste95b] </ref>. As mentioned in Sect. 1, in contrast to termination there exist several modularity results for innermost normalisation, e.g. [Kri95, Art96]. In particular, we can use the following result for hierarchical combinations, cf. [AG96b].
Reference: [Der82] <author> N. Dershowitz. </author> <title> Orderings for term-rewriting systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 17 </volume> <pages> 279-301, </pages> <year> 1982. </year>
Reference-contexts: programs (modelled by TRSs) or of logic programs. (When transforming logic programs into TRSs, innermost normalisation of the TRS implies termination of the logic program [AZ95].) While both termination and innermost normalisation are undecidable properties [HL78], several techniques have been developed for proving termination of TRSs automatically (e.g. path orderings <ref> [Pla78, Der82, DH95, Ste95b] </ref>, Knuth-Bendix orderings [KB70, DKM90], semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a] etc. | for surveys see e.g. [Der87, Ste95b]). <p> Moreover, we can map any function symbol to a constant. The second approach is based on path orderings (e.g. recursive or lexicographic path orderings) <ref> [Pla78, Der82, DH95, Ste95b] </ref>. Path orderings are simplification orderings that are easily generated automatically. Note that path orderings are always strictly monotonic, whereas in our method we only need a weakly monotonic ordering.
Reference: [Der87] <author> N. Dershowitz. </author> <title> Termination of rewriting. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 3(1 and </volume> 2):69-116, 1987. 
Reference-contexts: both termination and innermost normalisation are undecidable properties [HL78], several techniques have been developed for proving termination of TRSs automatically (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a] etc. | for surveys see e.g. <ref> [Der87, Ste95b] </ref>). However, there has not been any specific method for innermost normalisation, i.e. the only way to prove innermost nor-malisation automatically was by showing termination of the TRS. Therefore, none of the techniques could prove innermost normalisation of non-terminating systems. ? Technical Report IBN 96/39, Technische Hochschule Darmstadt. <p> this polynomial ordering cannot be used for a direct termination proof, but it nevertheless satisfies the constraints generated by our method. (Here all rules are usable.) In this way, innermost normalisation (and thereby, termination) can easily be proved. 35 8.18 Multiplication and Addition The following (non-overlapping) system is taken from <ref> [Der87, p. 101] </ref>. x fi (y + 1) ! (x fi (y + (1 fi 0))) + x x + 0 ! x The only inequalities resulting from a dependency pair on a cycle of the innermost dependency graph is TIMES (x; y + 1) TIMES (x; y + (1 fi <p> Moreover, TIMES must be weakly monotonic on its second argument. This system is not simply terminating (and in <ref> [Der87] </ref> it is used to illustrate the use of the semantic path ordering). However, with our method termination of this example can be proved automatically. <p> with F (g (x)), the only inequality to satisfy is F (g (x)) F (x) which is easily satisfied by the recursive path ordering. 8.25 A TRS which is not totally terminating 1 The most famous example of a TRS that is terminating, but not totally terminating is the following <ref> [Der87] </ref>. f (a) ! f (b) With our approach, innermost normalisation (resp. termination) of this system is again obvious, because the innermost dependency graph does not contain any cycles (as F (b) does not unify with F (a) and G (a) does not unify with G (b)).
Reference: [DH95] <author> N. Dershowitz and C. Hoot. </author> <title> Natural termination. </title> <journal> Theoretical Computer Science, </journal> <volume> 142(2) </volume> <pages> 179-207, </pages> <year> 1995. </year>
Reference-contexts: programs (modelled by TRSs) or of logic programs. (When transforming logic programs into TRSs, innermost normalisation of the TRS implies termination of the logic program [AZ95].) While both termination and innermost normalisation are undecidable properties [HL78], several techniques have been developed for proving termination of TRSs automatically (e.g. path orderings <ref> [Pla78, Der82, DH95, Ste95b] </ref>, Knuth-Bendix orderings [KB70, DKM90], semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a] etc. | for surveys see e.g. [Der87, Ste95b]). <p> However, compared to semantic labelling the dependency pair approach is better suited for automation, because here one does not have to find an appropriate semantic interpretation. At first sight, there also seems to be a similarity between innermost chains and innermost forward closures <ref> [LM78, DH95] </ref>, but it turns out that these approaches are fundamentally different. While forward closures restrict the application of rules (to that part of a term created by previous rewrites), the dependency pair approach restricts the examination of terms (to those subterms that may possibly be reduced further). <p> Moreover, we can map any function symbol to a constant. The second approach is based on path orderings (e.g. recursive or lexicographic path orderings) <ref> [Pla78, Der82, DH95, Ste95b] </ref>. Path orderings are simplification orderings that are easily generated automatically. Note that path orderings are always strictly monotonic, whereas in our method we only need a weakly monotonic ordering. <p> argument of less leaves (in the right-hand side of the last rule) would be replaced by an appropriate argument, we would obtain a non-simply terminating TRS whose termination could be proved in the same way. 8.15 Average of Naturals The following overlay system, which computes the average of two numbers <ref> [DH95] </ref>, is locally confluent and therefore innermost normalisation suffices for proving termination. average (s (x); y) ! average (x; s (y)) average (x; s (s (s (y)))) ! s (average (s (x); y)) average (0; 0) ! 0 average (0; s (0)) ! 0 average (0; s (s (0))) ! s <p> s (y)) AVERAGE (x; s (s (s (y)))) AVERAGE (s (x); y)): (There are no usable rules.) In this way, termination of this TRS is easily proved by mapping s (x) to x + 1, and AVERAGE (x; y) to 2x + y. 8.16 Plus and Times The following TRS <ref> [DH95] </ref> is again a locally confluent overlay system.
Reference: [DKM90] <author> J. Dick, J. Kalmus, and U. Martin. </author> <title> Automating the Knuth Bendix ordering. </title> <journal> Acta Informatica, </journal> <volume> 28 </volume> <pages> 95-119, </pages> <year> 1990. </year>
Reference-contexts: logic programs. (When transforming logic programs into TRSs, innermost normalisation of the TRS implies termination of the logic program [AZ95].) While both termination and innermost normalisation are undecidable properties [HL78], several techniques have been developed for proving termination of TRSs automatically (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings <ref> [KB70, DKM90] </ref>, semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a] etc. | for surveys see e.g. [Der87, Ste95b]). However, there has not been any specific method for innermost normalisation, i.e. the only way to prove innermost nor-malisation automatically was by showing termination of the TRS.
Reference: [Dro89] <editor> K. Drosten. Termersetzungssysteme: Grundlagen der Prototyp-Generierung algebraischer Spezifikationen. </editor> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1989. </year> <note> In German. 45 </note>
Reference-contexts: Note that the constraints obtained in this example are not satisfied by any weakly monotonic total well-founded quasi-ordering. For that reason we used a polynomial ordering with negative coefficients. 20 7.11 Drosten example A confluent and innermost normalising TRS that is not terminating was given by Drosten <ref> [Dro89] </ref>. f (0; 1; x) ! f (x; x; x) 0 ! 2 g (x; x; y) ! y As there exists no cycle in the innermost dependency graph, the TRS is innermost normalising. 8 Examples of Termination Proofs In this section a collection of non-overlapping resp. of locally confluent overlay
Reference: [Fer95] <author> M. Ferreira. </author> <title> Termination of Term Rewriting,Well-foundedness, Totality and Transformations. </title> <type> PhD thesis, </type> <institution> Utrecht University, </institution> <address> PO Box 80.089, 3508 TB Utrecht, The Netherlands, </address> <year> 1995. </year>
Reference-contexts: (x) to x, h (x) to 0 and g (x) to x + 1. 8.22 A System which is not left-linear The following TRS, originally from Geerling [Gee91], cannot be proved terminating by the recursive path ordering (but one needs a generalization of the recursive path ordering as defined in <ref> [Fer95] </ref>). <p> Hence, innermost normalisation is proved. 8.26 A TRS which is not totally terminating 2 A TRS introduced in <ref> [Fer95] </ref> as an example of a TRS that is not totally terminating and in particular for which the recursive path ordering and the Knuth-Bendix ordering cannot be used to prove termination, is given by: p (f (f (x))) ! q (f (g (x))) q (f (f (x))) ! p (f (g
Reference: [FZ93] <author> M. Ferreira and H. Zantema. </author> <title> Total termination of term rewriting. </title> <editor> In C. Kirchner, editor, </editor> <booktitle> Proceedings of the 5th Conference on Rewrite Techniques and Applications, RTA-93, volume 690 of Lecture Notes in Computer Science, </booktitle> <pages> pages 213-227, </pages> <address> Montreal, Canada, June 1993. </address> <publisher> Springer Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: mapped to the constant 1, F (x) is mapped to x, and where 0 and s are interpreted as usual. 36 8.21 Nested Recursion 3 As an example of a string rewriting system with minimal ordinal ! ! associated to it, Hans Zantema and Maria Ferreira presented the following TRS <ref> [FZ93] </ref>. f (g (x)) ! g (f (f (x))) The inequalities corresponding to this system, except for the inequalities corresponding to the two rules (as both of them are usable), are F (g (x)) F (f (x)) and F must be weakly monotonic.
Reference: [FZ95] <author> M. Ferreira and H. Zantema. </author> <title> Dummy elimination: making termination easier. </title> <editor> In H. Reichel, editor, </editor> <booktitle> Proceedings of the 10th International Conference on Fundamentals of Computation Theory, FCT'95, volume 965 of Lecture Notes in Computer Science, </booktitle> <pages> pages 243-252, </pages> <address> Dresden, Germany, August 1995. </address> <publisher> Springer Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: not unify with F (a; b) or F (c; d), neither does F (b; d) unify with F (a; b) or F (c; d). 37 8.24 Determining Cycles in Innermost Dependency Graphs 2 Another example in which the innermost dependency graph plays an important role is a TRS introduced in <ref> [FZ95] </ref> to demonstrate the technique of `dummy elimination'. f (g (x)) ! f (a (g (g (f (x))); g (f (x)))) Since F (a (: : :)) does not unify with F (g (x)), the only inequality to satisfy is F (g (x)) F (x) which is easily satisfied by the
Reference: [Gee91] <author> M. Geerling. </author> <title> Termination of term rewriting systems. </title> <type> Master's thesis, </type> <institution> Utrecht University, </institution> <address> PO Box 80.089, 3508 TB Utrecht, The Netherlands, </address> <year> 1991. </year>
Reference-contexts: All constraints are satisfied by the polynomial interpretation mapping f (x) and F (x) to x, h (x) to 0 and g (x) to x + 1. 8.22 A System which is not left-linear The following TRS, originally from Geerling <ref> [Gee91] </ref>, cannot be proved terminating by the recursive path ordering (but one needs a generalization of the recursive path ordering as defined in [Fer95]).
Reference: [Gie95a] <author> J. Giesl. </author> <title> Automatisierung von Terminierungsbeweisen fur rekursiv definierte Algorithmen. </title> <type> PhD thesis, </type> <institution> Technische Hochschule Darmstadt, Germany, </institution> <note> Jan-uary 1995. In German. </note>
Reference-contexts: + y. 32 8.13 Reachability on Directed Graphs To check whether there is a path from the node x to the node y in a directed graph g, the term reach (x; y; g; *) must be reducible to true with the rules of the TRS of this example from <ref> [Gie95a] </ref>. The fourth argument of reach is used to store edges that have already been examined but that are not included in the actual solution path. If an edge from u to v (with x 6= u) is found, then it is rejected at first.
Reference: [Gie95b] <author> J. Giesl. </author> <title> Generating polynomial orderings for termination proofs. </title> <editor> In J. Hsiang, editor, </editor> <booktitle> Proceedings of the 6th International Conference on Rewriting Techniques and Applications, RTA-95, volume 914 of Lecture Notes in Computer Science, </booktitle> <pages> pages 426-431, </pages> <address> Kaiserslautern, Germany, April 1995. </address> <publisher> Springer Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: logic programs into TRSs, innermost normalisation of the TRS implies termination of the logic program [AZ95].) While both termination and innermost normalisation are undecidable properties [HL78], several techniques have been developed for proving termination of TRSs automatically (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], semantic interpretations <ref> [Lan79, BL87, BL93, Ste94, Zan94, Gie95b] </ref>, transformation orderings [BD86, BL90, Ste95a] etc. | for surveys see e.g. [Der87, Ste95b]). However, there has not been any specific method for innermost normalisation, i.e. the only way to prove innermost nor-malisation automatically was by showing termination of the TRS. <p> Methods to synthesize polynomial orderings automatically have for instance been developed in <ref> [Ste94, Gie95b] </ref>. Note that for our technique we do not require the quasi-ordering to be weakly monotonic on tuple symbols. <p> For instance, if F is mapped to some polynomial [F], then instead of (7) one could demand that the partial derivative of [F](y; y; x) with respect to x should be non-negative, i.e. @[F](y;y;x) @x 0, cf. <ref> [Gie95b] </ref>. If one uses other techniques (e.g. path orderings) which can only generate monotonic orderings, then of course one may drop the monotonicity constraint (c). 8 are decreasing. <p> In the following collection of examples we use two different methods for that purpose. The first approach is the well-known approach of synthesizing polynomial orderings [Lan79]. Several techniques exist to derive polynomial interpretations automatically, e.g. <ref> [Ste94, Gie95b] </ref>. In contrast to the use of polynomial orderings for direct termination proofs, we can use polynomial interpretations with weakly monotonic polynomials (and tuple symbols may be mapped to polynomials that are not even weakly monotonic on all arguments).
Reference: [Gie96] <author> J. Giesl. </author> <title> Termination of nested and mutually recursive algorithms. </title> <journal> Journal of Automated Reasoning, </journal> <note> 1996. To appear. </note>
Reference-contexts: However, with our method termination of this example can be proved automatically. The constraints obtained are satisfied by the natural polynomial ordering, where TIMES (x; y) is mapped to y. 8.19 Nested Recursion 1 The following non-overlapping system was introduced in <ref> [Gie96, `nest2'] </ref> as an example for a small TRS with nested recursion where all simplification orderings fail. f (0; y) ! 0 With our approach, however, an automated innermost normalisation (and hence, termination) proof is directly possible. <p> Such rewrite systems are often obtained when transforming mutually recursive functions into one function without mutual recursion, cf. <ref> [Gie96] </ref>.) not (true) ! false not (false) ! true evenodd (x; 0) ! not (evenodd (x; s (0))) evenodd (0; s (0)) ! false evenodd (s (x); s (0)) ! evenodd (x; 0) We obtain the following constraints for innermost normalisation (and hence, termination) of R.
Reference: [Gra95] <author> B. Gramlich. </author> <title> Abstract relations between restricted termination and confluence properties of rewrite systems. </title> <journal> Fundamenta Informaticae, </journal> <volume> 24 </volume> <pages> 3-23, </pages> <year> 1995. </year>
Reference-contexts: In this way, innermost nor-malisation can be proved automatically. In Sect. 4 and 5 our technique is refined further and in Sect. 6 we give a summary and comment on connections and possible combinations with related approaches. For several classes of TRSs, innermost normalisation already suffices for termination <ref> [Gra95, Gra96] </ref>. Moreover, several modularity results exist for innermost normalisation [Kri95, Art96], which do not hold for termination. Therefore, for those classes of TRSs termination can be proved by splitting the TRS and proving innermost normalisation of the subsystems separately. <p> However, this polynomial is not weakly monotonic in x or y. In this way, innermost normalisation of our example can be proved automatically, i.e. this technique allows the application of standard techniques for innermost normalisation proofs, even if the TRS is not terminating. Moreover, using the results of <ref> [Gra95] </ref>, Thm. 6 can also be applied for proving termination of TRSs that are non-overlapping (or for locally confluent overlay systems). As an example regard the following TRS by T. <p> It is shown how our method can automatically derive innermost normalisation of these term rewriting systems. The examples in the next section are term rewriting systems for which innermost normalisation suffices to guarantee termination by the results of Gramlich <ref> [Gra95, Gra96] </ref>. Many of these examples are term rewriting systems that are not simply terminating. Therefore, their termination cannot be shown by most other automatic methods. However, by our approach they can be proved terminating.
Reference: [Gra96] <author> B. Gramlich. </author> <title> On proving termination by innermost termination. </title> <editor> In H. Ganzinger, editor, </editor> <booktitle> Proceedings of the 7th International Conference on Rewriting Techniques and Applications, RTA-96, volume 1103 of Lecture Notes in Computer Science, </booktitle> <pages> pages 93-107, </pages> <address> New Brunswick, NJ, USA, July 1996. </address> <publisher> Springer Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: In this way, innermost nor-malisation can be proved automatically. In Sect. 4 and 5 our technique is refined further and in Sect. 6 we give a summary and comment on connections and possible combinations with related approaches. For several classes of TRSs, innermost normalisation already suffices for termination <ref> [Gra95, Gra96] </ref>. Moreover, several modularity results exist for innermost normalisation [Kri95, Art96], which do not hold for termination. Therefore, for those classes of TRSs termination can be proved by splitting the TRS and proving innermost normalisation of the subsystems separately. <p> It is shown how our method can automatically derive innermost normalisation of these term rewriting systems. The examples in the next section are term rewriting systems for which innermost normalisation suffices to guarantee termination by the results of Gramlich <ref> [Gra95, Gra96] </ref>. Many of these examples are term rewriting systems that are not simply terminating. Therefore, their termination cannot be shown by most other automatic methods. However, by our approach they can be proved terminating.
Reference: [HH82] <author> G. Huet and J.-M. Hullot. </author> <title> Proofs by induction in equational theories with constructors. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 25 </volume> <pages> 239-299, </pages> <year> 1982. </year>
Reference-contexts: (f (f (x))) ! q (f (g (x))) q (f (f (x))) ! p (f (g (x))) Termination is trivially concluded from the fact that there are no cycles in the innermost dependency graph. 38 8.27 Reversing Lists The following system is a slight variant of a TRS proposed in <ref> [HH82, `brev'] </ref>. Here, "x.l" represents the insertion of an element x in front of the list l and "x.y.l" abbreviates "x.(y.l)".
Reference: [HL78] <author> G. Huet and D. Lankford. </author> <title> On the uniform halting problem for term rewriting systems. </title> <type> Technical Report 283, </type> <institution> INRIA, Le Chesnay, France, </institution> <year> 1978. </year>
Reference-contexts: Techniques for proving innermost normalisation can for example be utilized for termination proofs of functional programs (modelled by TRSs) or of logic programs. (When transforming logic programs into TRSs, innermost normalisation of the TRS implies termination of the logic program [AZ95].) While both termination and innermost normalisation are undecidable properties <ref> [HL78] </ref>, several techniques have been developed for proving termination of TRSs automatically (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a] etc. | for surveys see e.g. [Der87, Ste95b]).
Reference: [Hul80] <author> J.M. Hullot. </author> <title> Canonical forms and unification. </title> <editor> In W. Bibel and R. Kowalski, editors, </editor> <booktitle> Proceedings of the 5th International Conference on Automated Deduction, volume 87 of Lecture Notes in Computer Science, </booktitle> <pages> pages 318-334, </pages> <address> Les Arcs, France, July 1980. </address> <publisher> Springer Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: Hence, we present a better technique to determine whether for two terms t and v there exists a normal substitution such that t reduces innermost to the normal form v. For this purpose we use narrowing (cf. e.g. <ref> [Hul80] </ref>). Definition 10 (Narrowing). Let R be a TRS.
Reference: [KB70] <author> D.E. Knuth and P.B. Bendix. </author> <title> Simple word problems in universal algebras. </title> <booktitle> Computational problems in abstract algebra, </booktitle> <pages> pages 263-297, </pages> <year> 1970. </year>
Reference-contexts: logic programs. (When transforming logic programs into TRSs, innermost normalisation of the TRS implies termination of the logic program [AZ95].) While both termination and innermost normalisation are undecidable properties [HL78], several techniques have been developed for proving termination of TRSs automatically (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings <ref> [KB70, DKM90] </ref>, semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a] etc. | for surveys see e.g. [Der87, Ste95b]). However, there has not been any specific method for innermost normalisation, i.e. the only way to prove innermost nor-malisation automatically was by showing termination of the TRS.
Reference: [Kri95] <author> M.R.K. Krishna Rao. </author> <title> Modular proofs for completeness of hierarchical term rewriting systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 151 </volume> <pages> 487-512, </pages> <year> 1995. </year>
Reference-contexts: In Sect. 4 and 5 our technique is refined further and in Sect. 6 we give a summary and comment on connections and possible combinations with related approaches. For several classes of TRSs, innermost normalisation already suffices for termination [Gra95, Gra96]. Moreover, several modularity results exist for innermost normalisation <ref> [Kri95, Art96] </ref>, which do not hold for termination. Therefore, for those classes of TRSs termination can be proved by splitting the TRS and proving innermost normalisation of the subsystems separately. <p> In particular, this collection also includes several systems that are not simply terminating, cf. [Der79, Ste95b]. As mentioned in Sect. 1, in contrast to termination there exist several modularity results for innermost normalisation, e.g. <ref> [Kri95, Art96] </ref>. In particular, we can use the following result for hierarchical combinations, cf. [AG96b]. A TRS is a hierarchical combination of two subsystems if defined symbols of the first system occur as constructors in the second system, but not vice versa.
Reference: [Lan79] <author> D.S. Lankford. </author> <title> On proving term rewriting systems are Noetherian. </title> <type> Technical Report Memo MTP-3, </type> <institution> Louisiana Technical University, Ruston, LA, </institution> <year> 1979. </year>
Reference-contexts: logic programs into TRSs, innermost normalisation of the TRS implies termination of the logic program [AZ95].) While both termination and innermost normalisation are undecidable properties [HL78], several techniques have been developed for proving termination of TRSs automatically (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], semantic interpretations <ref> [Lan79, BL87, BL93, Ste94, Zan94, Gie95b] </ref>, transformation orderings [BD86, BL90, Ste95a] etc. | for surveys see e.g. [Der87, Ste95b]). However, there has not been any specific method for innermost normalisation, i.e. the only way to prove innermost nor-malisation automatically was by showing termination of the TRS. <p> For that purpose one may for instance use the well-known technique of synthesizing 7 polynomial orderings <ref> [Lan79] </ref>. <p> In the following collection of examples we use two different methods for that purpose. The first approach is the well-known approach of synthesizing polynomial orderings <ref> [Lan79] </ref>. Several techniques exist to derive polynomial interpretations automatically, e.g. [Ste94, Gie95b]. In contrast to the use of polynomial orderings for direct termination proofs, we can use polynomial interpretations with weakly monotonic polynomials (and tuple symbols may be mapped to polynomials that are not even weakly monotonic on all arguments).
Reference: [LM78] <author> D.S. Lankford and D.R. Musser. </author> <title> A finite termination criterion, </title> <year> 1978. </year>
Reference-contexts: However, compared to semantic labelling the dependency pair approach is better suited for automation, because here one does not have to find an appropriate semantic interpretation. At first sight, there also seems to be a similarity between innermost chains and innermost forward closures <ref> [LM78, DH95] </ref>, but it turns out that these approaches are fundamentally different. While forward closures restrict the application of rules (to that part of a term created by previous rewrites), the dependency pair approach restricts the examination of terms (to those subterms that may possibly be reduced further).
Reference: [MA96] <author> D. McAllester and K. Arkoudas. </author> <title> Walther recursion. In M.A. </title> <editor> McRobbie and J.K. Slaney, editors, </editor> <booktitle> Proceedings of the 13th International Conference on Automated Deduction, CADE-13, volume 1104 of Lecture Notes in Com 46 puter Science, </booktitle> <pages> pages 643-657, </pages> <address> New Brunswick, NJ, USA, July/August 1996. </address> <publisher> Springer Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: Thus, the TRS is terminating. Again, termination of this system cannot be proved automatically using the method of [AG97a]. 8.35 Renaming in the Lambda Calculus The following system is a variation of an algorithm from <ref> [MA96] </ref>. The purpose of the function ren (x; y; t) is to replace every free occurrence of the variable x in the term t by the variable y.
Reference: [MOZ96] <author> A. Middeldorp, H. Ohsaki, and H. Zantema. </author> <title> Transforming termination by self-labelling. In M.A. </title> <editor> McRobbie and J.K. Slaney, editors, </editor> <booktitle> Proceedings of the 13th International Conference on Automated Deduction, CADE-13, volume 1104 of Lecture Notes in Computer Science, </booktitle> <pages> pages 373-387, </pages> <address> New Brunswick, NJ, USA, July/August 1996. </address> <publisher> Springer Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: Finally, the introduction of innermost dependency graphs led to a considerably more powerful technique than the method proposed in [AG96b]. Dependency pairs have a connection to semantic labelling [Zan95] (resp. to self -labelling <ref> [MOZ96] </ref>). However, compared to semantic labelling the dependency pair approach is better suited for automation, because here one does not have to find an appropriate semantic interpretation.
Reference: [MT91] <author> A. Middeldorp and Y. Toyama. </author> <title> Completeness of combinations of constructor systems. </title> <editor> In R.V. Book, editor, </editor> <booktitle> Proceedings of the 4th International Conference on Rewriting Techniques and Applications, RTA-91, volume 488 of Lecture Notes in Computer Science, </booktitle> <pages> pages 188-199, </pages> <address> Como, Italy, April 1991. </address> <publisher> Springer Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: (x; 0) By mapping EVENODD (x; y) to x, the recursive path ordering satisfies these constraints. 8.29 Modularity, Version 1 The following example demonstrates the usefulness of modularity results. f (c (x; s (y))) ! f (c (s (x); y)) Modularity results (such as Thm. 12 or a result from <ref> [MT91] </ref> stating that completeness is modular for constructor systems with disjoint sets of defined symbols) allow us to prove innermost normalisation (and thereby, termination) of both rules separately.
Reference: [Pla78] <author> D. A. Plaisted. </author> <title> A recursively defined ordering for proving termination of term rewriting systems. </title> <type> Technical Report R-78-943, </type> <institution> Department of Computer Science, University of Illinois, Urbana-Champaign, IL, </institution> <year> 1978. </year>
Reference-contexts: programs (modelled by TRSs) or of logic programs. (When transforming logic programs into TRSs, innermost normalisation of the TRS implies termination of the logic program [AZ95].) While both termination and innermost normalisation are undecidable properties [HL78], several techniques have been developed for proving termination of TRSs automatically (e.g. path orderings <ref> [Pla78, Der82, DH95, Ste95b] </ref>, Knuth-Bendix orderings [KB70, DKM90], semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a] etc. | for surveys see e.g. [Der87, Ste95b]). <p> Moreover, we can map any function symbol to a constant. The second approach is based on path orderings (e.g. recursive or lexicographic path orderings) <ref> [Pla78, Der82, DH95, Ste95b] </ref>. Path orderings are simplification orderings that are easily generated automatically. Note that path orderings are always strictly monotonic, whereas in our method we only need a weakly monotonic ordering.
Reference: [Ste94] <author> J. Steinbach. </author> <title> Generating polynomial orderings. </title> <journal> Information Processing Letters, </journal> <volume> 49 </volume> <pages> 85-93, </pages> <year> 1994. </year>
Reference-contexts: logic programs into TRSs, innermost normalisation of the TRS implies termination of the logic program [AZ95].) While both termination and innermost normalisation are undecidable properties [HL78], several techniques have been developed for proving termination of TRSs automatically (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], semantic interpretations <ref> [Lan79, BL87, BL93, Ste94, Zan94, Gie95b] </ref>, transformation orderings [BD86, BL90, Ste95a] etc. | for surveys see e.g. [Der87, Ste95b]). However, there has not been any specific method for innermost normalisation, i.e. the only way to prove innermost nor-malisation automatically was by showing termination of the TRS. <p> Methods to synthesize polynomial orderings automatically have for instance been developed in <ref> [Ste94, Gie95b] </ref>. Note that for our technique we do not require the quasi-ordering to be weakly monotonic on tuple symbols. <p> In the following collection of examples we use two different methods for that purpose. The first approach is the well-known approach of synthesizing polynomial orderings [Lan79]. Several techniques exist to derive polynomial interpretations automatically, e.g. <ref> [Ste94, Gie95b] </ref>. In contrast to the use of polynomial orderings for direct termination proofs, we can use polynomial interpretations with weakly monotonic polynomials (and tuple symbols may be mapped to polynomials that are not even weakly monotonic on all arguments).
Reference: [Ste95a] <author> J. Steinbach. </author> <title> Automatic termination proofs with transformation orderings. </title> <editor> In J. Hsiang, editor, </editor> <booktitle> Proceedings of the 6th International Conference on Rewriting Techniques and Applications, RTA-95, volume 914 of Lecture Notes in Computer Science, </booktitle> <pages> pages 11-25, </pages> <address> Kaiserslautern, Germany, April 1995. </address> <publisher> Springer Verlag, </publisher> <address> Berlin. </address> <note> Long version also appeared as Technical Report SR-92-23, </note> <institution> Universitat Kaiserslautern, Germany, </institution> <year> 1992. </year>
Reference-contexts: TRS implies termination of the logic program [AZ95].) While both termination and innermost normalisation are undecidable properties [HL78], several techniques have been developed for proving termination of TRSs automatically (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings <ref> [BD86, BL90, Ste95a] </ref> etc. | for surveys see e.g. [Der87, Ste95b]). However, there has not been any specific method for innermost normalisation, i.e. the only way to prove innermost nor-malisation automatically was by showing termination of the TRS. <p> Moreover, whenever a direct termination proof is possible with a simplification ordering, then this simplification ordering also satisfies the constraints resulting from our technique. The only other approach for automated termination proofs of non-simply terminating systems is a technique for generating transformation orderings [BL90] by Steinbach <ref> [Ste95a] </ref>. <p> This example was taken from [BM79] resp. [Wal91]. A variant of this example could be proved terminating using Steinbach's method for the automated generation of transformation orderings <ref> [Ste95a] </ref>, but there the rules for le and minus were missing. 8.6 Logarithm, Version 1 The following TRS computes the dual logarithm. half (0) ! 0 half (s (s (x))) ! s (half (x)) log (0) ! 0 log (s (s (x))) ! s (log (s (half (x)))) The TRS R <p> A suitable mapping is rm (n; x) 7! x With this interpretation the inequalities are satisfied by the recursive path ordering. This example comes from [Wal91] and a similar example was mentioned in <ref> [Ste95a] </ref>, but in Steinbach's version the rules for eq and if rm were missing. <p> This example is inspired by an algorithm from [BM79] and [Wal94]. In the corresponding example from <ref> [Ste95a] </ref> the rules for le, eq, if rm , and if min were missing. 8.11 Quicksort The following TRS is used to sort a list by the well-known quicksort-algorithm. <p> Steinbach could prove termination of a corresponding example with transformation orderings <ref> [Ste95a] </ref>, but in his example the rules for le, if low , if high , and app were omitted. <p> For R 1 we obtain TIMES (x; s (y)) TIMES (x; y) which is also satisfied by the recursive path ordering. 8.17 Addition with Nested Recursion The following (non-overlapping) TRS for addition from <ref> [Ste95a] </ref> has nested recursion. 0 + y ! y s (x) + s (y) ! s (s (x) + (y + 0)) The `natural' polynomial interpretation (where + is mapped to the addition) maps left and right-hand sides of the rules to the same numbers. <p> For instance, we may use a polynomial ordering where 0 and s are interpreted as usual and both f (x; y) and F (x; y) are mapped to x. 8.20 Nested Recursion 2 This system (by Christoph Walther), which is similar to the preceding one, has been examined in <ref> [Ste95a] </ref>. f (0) ! s (0) f (s (s (x))) ! f (f (s (x))) The constraints resulting from our technique are satisfied by the polynomial ordering, where f (x) is mapped to the constant 1, F (x) is mapped to x, and where 0 and s are interpreted as usual. <p> by the automatic technique described in this paper. f (s (x); y; y) ! f (y; x; s (x)) The mapping of F (x; y; z) to x + y satisfies the inequality obtained by the technique. 8.23 Determining Cycles in Innermost Dependency Graphs 1 The following system is from <ref> [Ste95a] </ref>. f (a; b) ! f (a; c) With our method, the termination proof for this system is trivial, because its innermost dependency graph does not contain any cycles. <p> Hence, the TRS is terminating. 8.33 A non-totally terminating TRS The following example is from <ref> [Ste95a] </ref>. f (x; x) ! f (a; b) This TRS is not totally terminating (and the constraints generated by the method of [AG97a] are not satisfied by any total well-founded quasi-ordering). However, with our method innermost normalisation (and thereby, termination) can easily be proved. <p> The reason is that after applying one narrowing step to f (a; b) we obtain f (a; c) which is not unifiable with f (x; x). Hence, there is no cycle in the innermost dependency graph. 8.34 Intervals of Natural Numbers The following TRS from <ref> [Ste95a] </ref> intlist (nil) ! nil intlist (x.y) ! s (x).intlist (y) int (0; 0) ! 0.nil int (s (x); 0) ! nil int (s (x); s (y)) ! intlist (int (x; y)) 42 is non-overlapping, too.
Reference: [Ste95b] <author> J. Steinbach. </author> <title> Simplification orderings: history of results. </title> <journal> Fundamenta Infor-maticae, </journal> <volume> 24 </volume> <pages> 47-87, </pages> <year> 1995. </year>
Reference-contexts: programs (modelled by TRSs) or of logic programs. (When transforming logic programs into TRSs, innermost normalisation of the TRS implies termination of the logic program [AZ95].) While both termination and innermost normalisation are undecidable properties [HL78], several techniques have been developed for proving termination of TRSs automatically (e.g. path orderings <ref> [Pla78, Der82, DH95, Ste95b] </ref>, Knuth-Bendix orderings [KB70, DKM90], semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a] etc. | for surveys see e.g. [Der87, Ste95b]). <p> both termination and innermost normalisation are undecidable properties [HL78], several techniques have been developed for proving termination of TRSs automatically (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], semantic interpretations [Lan79, BL87, BL93, Ste94, Zan94, Gie95b], transformation orderings [BD86, BL90, Ste95a] etc. | for surveys see e.g. <ref> [Der87, Ste95b] </ref>). However, there has not been any specific method for innermost normalisation, i.e. the only way to prove innermost nor-malisation automatically was by showing termination of the TRS. Therefore, none of the techniques could prove innermost normalisation of non-terminating systems. ? Technical Report IBN 96/39, Technische Hochschule Darmstadt. <p> quot (0; s (y); s (z)) ! 0 quot (s (x); s (y); z) ! quot (x; y; z) quot (x; 0; s (z)) ! s (quot (x; s (z); s (z))) A problem with virtually all automatic approaches for termination proofs is that they are restricted to simplification orderings <ref> [Der79, Ste95b] </ref> and therefore can only prove termination of TRS that are simply terminating. However, there are numerous relevant and important terminating TRSs where simplification orderings fail. <p> Moreover, we can map any function symbol to a constant. The second approach is based on path orderings (e.g. recursive or lexicographic path orderings) <ref> [Pla78, Der82, DH95, Ste95b] </ref>. Path orderings are simplification orderings that are easily generated automatically. Note that path orderings are always strictly monotonic, whereas in our method we only need a weakly monotonic ordering. <p> For these TRSs innermost normalisation implies termination. Therefore, applying our technique to prove innermost normalisation to these TRSs results in an automatic approach for termination proofs. In particular, this collection also includes several systems that are not simply terminating, cf. <ref> [Der79, Ste95b] </ref>. As mentioned in Sect. 1, in contrast to termination there exist several modularity results for innermost normalisation, e.g. [Kri95, Art96]. In particular, we can use the following result for hierarchical combinations, cf. [AG96b].
Reference: [Toy87] <author> Y. Toyama. </author> <title> Counterexamples to the termination for the direct sum of term rewriting systems. </title> <journal> Information Processing Letters, </journal> <volume> 25 </volume> <pages> 141-143, </pages> <year> 1987. </year>
Reference-contexts: Therefore, the only constraint on the ordering is given by G (s (x)) G (x) which is easily satisfied by the recursive path ordering. 7.2 Toyama Example The most famous example of a TRS that is innermost normalising, but not terminating, is the following system from <ref> [Toy87] </ref>. f (0; 1; x) ! f (x; x; x) g (x; y) ! y The TRS has only one dependency pair, viz. hF (0; 1; x); F (x; x; x)i.
Reference: [Wal91] <author> C. Walther. </author> <title> Automatisierung von Terminierungsbeweisen. </title> <publisher> Vieweg Verlag, </publisher> <address> Braunschweig, </address> <year> 1991. </year>
Reference-contexts: A suitable mapping is given by pred (x) 7! x minus (x; y) 7! x IF gcd (b; x; y) 7! IF gcd (x; y): The interpreted inequalities are satisfied by the recursive path ordering. This example was taken from [BM79] resp. <ref> [Wal91] </ref>. <p> A suitable mapping is rm (n; x) 7! x With this interpretation the inequalities are satisfied by the recursive path ordering. This example comes from <ref> [Wal91] </ref> and a similar example was mentioned in [Ste95a], but in Steinbach's version the rules for eq and if rm were missing.
Reference: [Wal94] <author> C. Walther. </author> <title> On proving the termination of algorithms by machine. </title> <journal> Artificial Intelligence, </journal> <volume> 71(1) </volume> <pages> 101-157, </pages> <year> 1994. </year>
Reference-contexts: But this version here is even more difficult: Termination of the corresponding algorithm cannot be proved by the method of <ref> [Wal94] </ref>, because this method cannot deal with permutations of arguments.) Termination of R 0 can be proved by our approach. <p> side of the last rule, add (n; purge (rm (n; x))), the n would be replaced by a term containing add (n; x) then we would obtain a non-simply terminating TRS, but termination could still be proved with our technique in the same way. 8.9 Selection Sort This TRS from <ref> [Wal94] </ref> is obviously not simply terminating. The TRS can be used to sort a list by repeatedly replacing the minimum of the list by the head of the list. <p> This example is inspired by an algorithm from [BM79] and <ref> [Wal94] </ref>. In the corresponding example from [Ste95a] the rules for le, eq, if rm , and if min were missing. 8.11 Quicksort The following TRS is used to sort a list by the well-known quicksort-algorithm. <p> With our method, termination could still be proved in the same way. 8.12 Permutation of Lists This example is a TRS from <ref> [Wal94] </ref> to compute a permutation of a list.
Reference: [Zan94] <author> H. Zantema. </author> <title> Termination of term rewriting: interpretation and type elimination. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 17 </volume> <pages> 23-50, </pages> <year> 1994. </year>
Reference-contexts: logic programs into TRSs, innermost normalisation of the TRS implies termination of the logic program [AZ95].) While both termination and innermost normalisation are undecidable properties [HL78], several techniques have been developed for proving termination of TRSs automatically (e.g. path orderings [Pla78, Der82, DH95, Ste95b], Knuth-Bendix orderings [KB70, DKM90], semantic interpretations <ref> [Lan79, BL87, BL93, Ste94, Zan94, Gie95b] </ref>, transformation orderings [BD86, BL90, Ste95a] etc. | for surveys see e.g. [Der87, Ste95b]). However, there has not been any specific method for innermost normalisation, i.e. the only way to prove innermost nor-malisation automatically was by showing termination of the TRS.
Reference: [Zan95] <author> H. Zantema. </author> <title> Termination of term rewriting by semantic labelling. </title> <journal> Funda-menta Informaticae, </journal> <volume> 24 </volume> <pages> 89-105, </pages> <year> 1995. </year> <month> 47 </month>
Reference-contexts: Moreover, in contrast to these first approaches, in this paper we developed a complete criterion for innermost normalisation and proved its soundness in a short and easy way (while the corresponding proof in [Art96] was based on semantic labelling <ref> [Zan95] </ref>). Finally, the introduction of innermost dependency graphs led to a considerably more powerful technique than the method proposed in [AG96b]. Dependency pairs have a connection to semantic labelling [Zan95] (resp. to self -labelling [MOZ96]). <p> and proved its soundness in a short and easy way (while the corresponding proof in [Art96] was based on semantic labelling <ref> [Zan95] </ref>). Finally, the introduction of innermost dependency graphs led to a considerably more powerful technique than the method proposed in [AG96b]. Dependency pairs have a connection to semantic labelling [Zan95] (resp. to self -labelling [MOZ96]). However, compared to semantic labelling the dependency pair approach is better suited for automation, because here one does not have to find an appropriate semantic interpretation.
References-found: 46

