URL: ftp://ftp.cs.man.ac.uk/pub/fac/FACj_6E_p71.ps.Z
Refering-URL: http://www.cs.man.ac.uk/fmethods/facj/e-papers/index.html
Root-URL: http://www.cs.man.ac.uk
Title: of Computing The Weakest Precondition Calculus: Recursion and Duality  
Author: Marcello M. Bonsangue and Joost N. Kok 
Keyword: Weakest (liberal) preconditions; Refinement; Fixed point transformations; Smyth power domain; Egli-Milner power domain; Recursion; Denota-tional semantics  
Address: NL  
Affiliation: 1 Department of Computer Science, Vrije Universiteit Amsterdam, NL 2 Department of Computer Science, Utrecht University,  
Note: Formal Aspects of Computing (1994) 6E: 71-101 c 1994 BCS Formal Aspects  
Abstract: An extension of Dijkstra's guarded command language is studied, including unbounded demonic choice and a backtrack operator. We consider three orderings on this language: a refinement ordering defined by Back, a new deadlock ordering, and an approximation ordering of Nelson. The deadlock ordering is in between the two other orderings. All operators are monotonic in the Nelson ordering, but backtracking is not monotonic in the Back ordering and sequential composition is not monotonic for the deadlock ordering. At first sight recursion can only be added using the Nelson ordering. We show that, under certain circumstances, least fixed points for non-monotonic functions can be obtained by iteration from the least element. This permits the addition of recursion even using the Back ordering or the deadlock ordering in a fully compositional way. In order to give a semantic characterization of the three orderings in terms of semantics that relate initial states to possible outcomes of the computation, the relation between predicate transformers and discrete power domains is studied. We consider (two versions of) the Smyth power domain and the Egli-Milner power domain. 
Abstract-found: 1
Intro-found: 1
Reference: [APP81] <author> Apt, K.R. and Plotkin, G.: </author> <title> A Cook's Tour of Countable Nondeterminism. </title> <editor> In S. Evens and O. Kariv, editors, </editor> <booktitle> Proc. 8th ICALP, Lecture Notes in Computer Science 115, </booktitle> <address> Akko, Israel, 1981. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: This result was extended by Hitchcock and Park [HiP72] showing that also a monotone function from a complete partial order to itself has a least fixed point. Then Apt and Ploktin <ref> [APP81, APP86] </ref> showed that the least fixed point property can be transferred, via a commutative diagram, to monotone functions from a poset (not necessarily complete) to itself. This transfer lemma is explored in detail by Meyer in [Mey85]. <p> If P is a pointed dcpo and f is monotone then f &lt;&gt; always exists. In this case there is an ordinal k such that whenever k we have f &lt;&gt; = f &lt;k&gt; [HiP72]. The following theorem, taken from <ref> [APP81, APP86] </ref>, shows that under certain circumstances g &lt;&gt; always exists and stabilizes for a monotone function g : Q ! Q even if Q is not a directed complete partial order. Theorem 4.2.
Reference: [APP86] <author> Apt, K.R. and Plotkin, G.: </author> <title> Countable Nondeterminism and Random Assignment. </title> <journal> Journal of the ACM, </journal> <volume> 33(4) </volume> <pages> 724-767, </pages> <month> October </month> <year> 1986. </year> <note> 100 M. </note> <editor> M. Bonsangue and J. N. </editor> <publisher> Kok </publisher>
Reference-contexts: An early treatment of recursion, based on continuity of the weakest preconditions (and hence based on finite nondeterminism), is given in [Roe76]. More detailed treatments are given in [Heh79] and [Bak80]. Recursion together with countable nondeterminism is studied in <ref> [APP86] </ref>, and recursion with unbounded nondeterminism in [DiG86, Hes89]. Recursion is added in a fully compositional way by Nelson in [Nel89]: the guarded command language is embedded in a language with sequential composition, binary demonic choice and a backtrack operator in which the operators can be used freely. <p> This result was extended by Hitchcock and Park [HiP72] showing that also a monotone function from a complete partial order to itself has a least fixed point. Then Apt and Ploktin <ref> [APP81, APP86] </ref> showed that the least fixed point property can be transferred, via a commutative diagram, to monotone functions from a poset (not necessarily complete) to itself. This transfer lemma is explored in detail by Meyer in [Mey85]. <p> One of the aims of this paper is to match the predicate transformer view of a program to the state transformer view by extending the duality which relates the discrete version of the Smyth power domain [Smy78] and Dijkstra's The Weakest Precondition Calculus 73 predicate transformers <ref> [Wan77, Plo79, Bac81, Smy83, Bes83, APP86] </ref>. The duality states that there is an order isomorphism between functions to the Smyth power domain (ordered pointwise) and the predicate transformers (ordered by the refinement order). <p> In [Wan77, Plo79] predicate transformers satisfy the properties 1, 2, 4 and 5. For countable nonde-terminism predicate transformers are required to satisfy the properties 1, 2 and 6 in [Bes83] and <ref> [APP86] </ref>. Finally, for a rich specification language with both unbounded angelic and demonic choice in [BaW90] predicate transformers are required to satisfy only property 3. Multiplicative predicate transformers are of special interest for our purpose because of the following lemma. This lemma is a variation of the stability lemma in [APP86]: <p> <ref> [APP86] </ref>. Finally, for a rich specification language with both unbounded angelic and demonic choice in [BaW90] predicate transformers are required to satisfy only property 3. Multiplicative predicate transformers are of special interest for our purpose because of the following lemma. This lemma is a variation of the stability lemma in [APP86]: Lemma 3.3. Let : Pred ! Pred be a -multiplicative predicate transformer and let oe 2 be such that oe 2 (true). Then there is a set min (; oe) such that 8Q 2 Pred : oe 2 (Q) , (min (; oe) ) Q): Proof. <p> If P is a pointed dcpo and f is monotone then f &lt;&gt; always exists. In this case there is an ordinal k such that whenever k we have f &lt;&gt; = f &lt;k&gt; [HiP72]. The following theorem, taken from <ref> [APP81, APP86] </ref>, shows that under certain circumstances g &lt;&gt; always exists and stabilizes for a monotone function g : Q ! Q even if Q is not a directed complete partial order. Theorem 4.2. <p> We have g &lt;ff&gt; = h (f &lt;ff&gt; ) = h (f &lt;ff+1&gt; ) = h (f (f &lt;ff&gt; )) = g (h (f &lt;ff&gt; )) = g (g &lt;ff&gt; ): So g &lt;ff&gt; is a fixed point of g. In <ref> [APP86] </ref> this is enough to prove that g &lt;ff&gt; = g because g is monotone. In our case, we still have to prove it. Let y 2 Q be another fixed point for g, that is, g (y) = y, and consider the partial order generated by h 1 (y). <p> Relationships between the domains. 5. Duality In this section we relate the predicate transformers with functions to power domains. We generalize the relationship between the Smyth power domain and the predicate transformers <ref> [Wan77, Plo79, Bac81, Bes83, APP86, Smy83] </ref> to the new versions of the Smyth power domain. Moreover, we introduce a relationship between the Egli-Milner power domain and pairs of predicate transformers (see also [Nel89]). For further reference, the diagram in Fig. 2 summarizes the relationships. <p> For example, let N be the set of natural numbers and consider in S ffi (N ? ) the following directed set which has no upper bound: N v N n f0g v N n f0; 1g v :::; (this example is taken from <ref> [APP86] </ref>). We denote by STran ffi the state transformers ! S ffi ( ? ), ordered pointwise. The identity function from STran ffi to STran is trivially onto, continuous, and the inverse image has finite upper fringe, lower fringe and finite antichains for every A 2 S ( ? ).
Reference: [Bac78] <author> Back, R.-J.R.: </author> <title> On the Correctness of Refinement Steps in Program Development. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Helsinki, </institution> <year> 1978. </year> <note> Report A-1978-4. </note>
Reference-contexts: M. Bonsangue and J. N. Kok thesis from specifications is supported. The language was extended to use it as a vehicle for program refinement. Specification constructs, like unbounded demonic choice and angelic choice, were added and a refinement ordering was defined. This approach was introduced in <ref> [Bac78, Bac80] </ref> and is suited for refinement (see [BaW90, Bac90] and also [MRG88, Mor87]). The ordering can be used to add recursion to the language, but not in a fully compositional way in which all the operators can be used freely. <p> Orderings In this section we introduce three pre-orders on Stat. The first pre-order v B was proposed by Back <ref> [Bac78, Bac80] </ref> and is suited for refinement (see [Bac90] and 78 M. M. Bonsangue and J. N. Kok also [Mor87, MRG88]). The second pre-order v D is a new ordering which preserves deadlocks: a non-miraculous statement can not be refined by a miraculous one. <p> Conclusion and Future Work At least four different, but related, topics have been treated in this paper: 1. We proposed an extension of Dijkstra's Weakest Precondition Calculus in order to treat recursion in a fully compositional way with respect to three different orders: a refinement order as introduced in <ref> [Bac78] </ref>, a new refinement order that respects deadlock, and an approximation order as introduced in [Nel89]. 2. We showed that (under certain circumstances), least fixed points of functions (even non-monotone) between posets exist and that they can be obtained by iteration from the least element. 3.
Reference: [Bac80] <author> Back, R.-J.R.: </author> <title> Correctness Preserving Program Refinements: Proof Theory and Applications, </title> <publisher> Mathematical Centre Tracts vol. 131 Mathematical Centre, </publisher> <address> Ams-terdam, </address> <year> 1980. </year>
Reference-contexts: M. Bonsangue and J. N. Kok thesis from specifications is supported. The language was extended to use it as a vehicle for program refinement. Specification constructs, like unbounded demonic choice and angelic choice, were added and a refinement ordering was defined. This approach was introduced in <ref> [Bac78, Bac80] </ref> and is suited for refinement (see [BaW90, Bac90] and also [MRG88, Mor87]). The ordering can be used to add recursion to the language, but not in a fully compositional way in which all the operators can be used freely. <p> Orderings In this section we introduce three pre-orders on Stat. The first pre-order v B was proposed by Back <ref> [Bac78, Bac80] </ref> and is suited for refinement (see [Bac90] and 78 M. M. Bonsangue and J. N. Kok also [Mor87, MRG88]). The second pre-order v D is a new ordering which preserves deadlocks: a non-miraculous statement can not be refined by a miraculous one.
Reference: [Bac81] <author> Back, R.-J.R.: </author> <title> On Correct Refinement of Programs. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 23(1) </volume> <pages> 49-68, </pages> <year> 1981. </year>
Reference-contexts: One of the aims of this paper is to match the predicate transformer view of a program to the state transformer view by extending the duality which relates the discrete version of the Smyth power domain [Smy78] and Dijkstra's The Weakest Precondition Calculus 73 predicate transformers <ref> [Wan77, Plo79, Bac81, Smy83, Bes83, APP86] </ref>. The duality states that there is an order isomorphism between functions to the Smyth power domain (ordered pointwise) and the predicate transformers (ordered by the refinement order). <p> Relationships between the domains. 5. Duality In this section we relate the predicate transformers with functions to power domains. We generalize the relationship between the Smyth power domain and the predicate transformers <ref> [Wan77, Plo79, Bac81, Bes83, APP86, Smy83] </ref> to the new versions of the Smyth power domain. Moreover, we introduce a relationship between the Egli-Milner power domain and pairs of predicate transformers (see also [Nel89]). For further reference, the diagram in Fig. 2 summarizes the relationships.
Reference: [Bac90] <author> Back, R.-J.R.: </author> <title> Refinement Calculus, part II: Parallel and Reactive Programs. </title> <editor> In J.W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> Stepwise Refinement of Distributed Systems: Models, Formalisms, Correctness, </title> <booktitle> Lecture Notes in Computer Science 430, </booktitle> <pages> pp. 67-93. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Kok thesis from specifications is supported. The language was extended to use it as a vehicle for program refinement. Specification constructs, like unbounded demonic choice and angelic choice, were added and a refinement ordering was defined. This approach was introduced in [Bac78, Bac80] and is suited for refinement (see <ref> [BaW90, Bac90] </ref> and also [MRG88, Mor87]). The ordering can be used to add recursion to the language, but not in a fully compositional way in which all the operators can be used freely. For example, for each set of guards there is a different conditional command. <p> Orderings In this section we introduce three pre-orders on Stat. The first pre-order v B was proposed by Back [Bac78, Bac80] and is suited for refinement (see <ref> [Bac90] </ref> and 78 M. M. Bonsangue and J. N. Kok also [Mor87, MRG88]). The second pre-order v D is a new ordering which preserves deadlocks: a non-miraculous statement can not be refined by a miraculous one.
Reference: [Bak80] <author> Bakker, J.W. de: </author> <title> Mathematical Theory of Program Correctness. </title> <publisher> Prentice-Hall, </publisher> <year> 1980. </year>
Reference-contexts: For example, for each set of guards there is a different conditional command. An early treatment of recursion, based on continuity of the weakest preconditions (and hence based on finite nondeterminism), is given in [Roe76]. More detailed treatments are given in [Heh79] and <ref> [Bak80] </ref>. Recursion together with countable nondeterminism is studied in [APP86], and recursion with unbounded nondeterminism in [DiG86, Hes89]. <p> The proof proceeds by structural induction on S 2 Stat. We treat only the case S = S 1 3S 2 , since the other cases are standard and can be found, The Weakest Precondition Calculus 77 for example, in <ref> [Bak80] </ref>. Let S 1 ; S 2 be two statements.
Reference: [Bes83] <author> Best, E.: </author> <title> Relational Semantic of Concurrent Programs (with some Applications). </title> <editor> In D. Bjorner, editor, </editor> <booktitle> Proc. of the IFIP Working Conference on on Formal Description of Programming Concepts - II, </booktitle> <pages> pp. 431-452, </pages> <address> Garmisch-Partenkirchen, FRG, 1983. </address> <publisher> North-Holland Publishing Company. </publisher>
Reference-contexts: One of the aims of this paper is to match the predicate transformer view of a program to the state transformer view by extending the duality which relates the discrete version of the Smyth power domain [Smy78] and Dijkstra's The Weakest Precondition Calculus 73 predicate transformers <ref> [Wan77, Plo79, Bac81, Smy83, Bes83, APP86] </ref>. The duality states that there is an order isomorphism between functions to the Smyth power domain (ordered pointwise) and the predicate transformers (ordered by the refinement order). <p> In [Wan77, Plo79] predicate transformers satisfy the properties 1, 2, 4 and 5. For countable nonde-terminism predicate transformers are required to satisfy the properties 1, 2 and 6 in <ref> [Bes83] </ref> and [APP86]. Finally, for a rich specification language with both unbounded angelic and demonic choice in [BaW90] predicate transformers are required to satisfy only property 3. Multiplicative predicate transformers are of special interest for our purpose because of the following lemma. <p> Lemma 3.4. Let be a countable set of states and let 1. - 8. be the list of properties defined above. Then we have (4: ^ 5:) ) 6: , 7: , 8: ) 3: Proof. For a proof of (4: ^ 5:) ) 8 see <ref> [Bes83] </ref>. We prove only 7: ) 8. The other implications are clear and are left to the reader. <p> Relationships between the domains. 5. Duality In this section we relate the predicate transformers with functions to power domains. We generalize the relationship between the Smyth power domain and the predicate transformers <ref> [Wan77, Plo79, Bac81, Bes83, APP86, Smy83] </ref> to the new versions of the Smyth power domain. Moreover, we introduce a relationship between the Egli-Milner power domain and pairs of predicate transformers (see also [Nel89]). For further reference, the diagram in Fig. 2 summarizes the relationships.
Reference: [BoK93] <author> Bonsangue, M.M. and Kok, J.N.: </author> <title> Isomorphisms between State and Predicate Transformers. </title> <editor> In A.M. Borzyszkowski and S. Sokolowoski, editors, </editor> <booktitle> Proc. MFCS '93, Gdansk, Poland, Lecture Notes in Computer Science 711, </booktitle> <pages> pp. 301-310. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> Extended version available through anonymous ftp from ftp.cs.vu.nl as /pub/bonsangue/isomorph.ps.Z. </note>
Reference-contexts: Therefore V i2I (P i ) ) ( i2I P i ). Notice that if is uncountable then (4: ^ 5:) ) 8: , 7: ) 6: ) 3: and that in this case the first implication needs the axiom of choice <ref> [BoK93] </ref>. Next we define the three domains of predicate transformers (with associated orders) which we will use in the rest of the paper. Definition 3.5.
Reference: [BaW90] <author> Back, R.-J.R. and Wright, J. von: </author> <title> Refinement Calculus, part I: Sequential Nondeterministic Programs. </title> <editor> In J.W. de Bakker, W.-P. de Roever, and G. Rozen-berg, editors, </editor> <title> Stepwise Refinement of Distributed Systems: Models, Formalisms, Correctness, </title> <booktitle> Lecture Notes in Computer Science 430, </booktitle> <pages> pp. 42-66. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Kok thesis from specifications is supported. The language was extended to use it as a vehicle for program refinement. Specification constructs, like unbounded demonic choice and angelic choice, were added and a refinement ordering was defined. This approach was introduced in [Bac78, Bac80] and is suited for refinement (see <ref> [BaW90, Bac90] </ref> and also [MRG88, Mor87]). The ordering can be used to add recursion to the language, but not in a fully compositional way in which all the operators can be used freely. For example, for each set of guards there is a different conditional command. <p> The ordering uses the additional notion of weakest liberal precondition, and is an approximation ordering of the kind used in denotational semantics. It is not suited for refinement in the sense of <ref> [BaW90] </ref>. Our starting point is the language of [Nel89]. In this language there is a form of infinite behavior (a divergence construct) and atomic actions that can deadlock (to initiate backtracking). The main operators present in the language are sequential composition, unbounded demonic choice and a backtrack operator. <p> If we identify statements with their weakest preconditions then we have that our language is a subset of the monotonic predicate transformers of <ref> [BaW90, Wri90] </ref> because we do not consider angelic choice and multiple assignment statements. The guard statement [b] is b ! and the assert statement fbg is b ! 3div . <p> For the pre-orders v B and v N we refer to <ref> [BaW90] </ref> and [Nel89], respec tively. We prove only (ii) and (v). Let I be a non-empty index set and let S i ; S 0 i 2 Stat be statements for each i 2 I such that S i v D S 0 i . <p> In [Wan77, Plo79] predicate transformers satisfy the properties 1, 2, 4 and 5. For countable nonde-terminism predicate transformers are required to satisfy the properties 1, 2 and 6 in [Bes83] and [APP86]. Finally, for a rich specification language with both unbounded angelic and demonic choice in <ref> [BaW90] </ref> predicate transformers are required to satisfy only property 3. Multiplicative predicate transformers are of special interest for our purpose because of the following lemma. This lemma is a variation of the stability lemma in [APP86]: Lemma 3.3.
Reference: [DiG86] <author> Dijkstra, E.W. and Gasteren, A.J.M. van: </author> <title> A Simple Fixpoint Argument without the Restriction to Continuity. </title> <journal> Acta Informatica, </journal> <volume> 23 </volume> <pages> 1-7, </pages> <year> 1986. </year>
Reference-contexts: An early treatment of recursion, based on continuity of the weakest preconditions (and hence based on finite nondeterminism), is given in [Roe76]. More detailed treatments are given in [Heh79] and [Bak80]. Recursion together with countable nondeterminism is studied in [APP86], and recursion with unbounded nondeterminism in <ref> [DiG86, Hes89] </ref>. Recursion is added in a fully compositional way by Nelson in [Nel89]: the guarded command language is embedded in a language with sequential composition, binary demonic choice and a backtrack operator in which the operators can be used freely.
Reference: [Dij76] <author> Dijkstra, </author> <title> E.W.: A Discipline of Programming. </title> <publisher> Prentice-Hall, </publisher> <year> 1976. </year>
Reference-contexts: 1. Introduction The weakest precondition calculus of Dijkstra identifies statements in the guarded command language with predicate transformers <ref> [Dij76] </ref> such that program syn Correspondence and offprint requests to: Marcello M. Bonsangue, Department of Computer Science, Vrije Universiteit, De Boelelaan 1081a, 1081 HV Amsterdam, The Netherlands. Email: marcello@cs.vu.nl. 72 M. M. Bonsangue and J. N. Kok thesis from specifications is supported. <p> Another difference is that we allow unbounded demonic choice. 74 M. M. Bonsangue and J. N. Kok Dijkstra's guarded command language <ref> [Dij76, DiS90] </ref> can be seen as a subset of this language, except for the do od construct which will be handled when we add recursion. <p> The kind of restrictions depends on the kind of (specification) language one wants to model. For example in <ref> [Dij76] </ref> predicate transformers satisfy the properties 1-5 and are used to model a language with at most a countable number of states and with finite nondeterministic demonic choice. In [Wan77, Plo79] predicate transformers satisfy the properties 1, 2, 4 and 5.
Reference: [DiS90] <author> Dijkstra, </author> <title> E.W. and Scholten, C.S.: Predicate Calculus and Program Semantics. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: Another difference is that we allow unbounded demonic choice. 74 M. M. Bonsangue and J. N. Kok Dijkstra's guarded command language <ref> [Dij76, DiS90] </ref> can be seen as a subset of this language, except for the do od construct which will be handled when we add recursion.
Reference: [EhM85] <author> Ehrig, H. and Mahr, B.: </author> <title> Fundamentals of Algebraic Specification I, </title> <journal> EATCS Monographs vol. </journal> <volume> 6. </volume> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: In this section we study sufficient conditions on functions that relate semantic domains such that compositionality and least fixed point properties of semantic functions are preserved. We start by giving some general definitions (cf. [GTW77], <ref> [EhM85] </ref> and references contained in these papers). A signature S = (F; r) consists of function names (f 2)F , and a rank function r, giving for each function symbol its arity. Function names with arity 0 are called constants. <p> v 1 ; :::; v r (f) (81 i r (f ) : u i j v i ) f (u 1 ; ::; u r (f) ) j f (v 1 ; :::; v r (f) )): The following lemma is standard, and can be found for example in <ref> [EhM85] </ref>. Lemma 6.2. Let S = (F; r) be a signature such that F is a set and every function symbol has finite arity.
Reference: [GTW77] <author> Goguen, J.A., Thatcher, J.W., Wagner, E.G. and Wright, J.B.: </author> <title> Initial Algebra Semantics and Continuous Algebras. </title> <journal> Journal of the ACM, </journal> <volume> 24 </volume> <pages> 68-95, </pages> <year> 1977. </year>
Reference-contexts: In this section we study sufficient conditions on functions that relate semantic domains such that compositionality and least fixed point properties of semantic functions are preserved. We start by giving some general definitions (cf. <ref> [GTW77] </ref>, [EhM85] and references contained in these papers). A signature S = (F; r) consists of function names (f 2)F , and a rank function r, giving for each function symbol its arity. Function names with arity 0 are called constants.
Reference: [Heh79] <author> Hehner, E.C.R.: </author> <title> do considered od: a Contribution to Programming Calculus. </title> <journal> Acta Informatica, </journal> <volume> 11 </volume> <pages> 287-304, </pages> <year> 1979. </year>
Reference-contexts: For example, for each set of guards there is a different conditional command. An early treatment of recursion, based on continuity of the weakest preconditions (and hence based on finite nondeterminism), is given in [Roe76]. More detailed treatments are given in <ref> [Heh79] </ref> and [Bak80]. Recursion together with countable nondeterminism is studied in [APP86], and recursion with unbounded nondeterminism in [DiG86, Hes89].
Reference: [Hes89] <author> Hesselink, </author> <title> W.H.: Predicate Transformer Semantics of General Recursion. </title> <journal> Acta Informatica, </journal> <volume> 26 </volume> <pages> 309-332, </pages> <year> 1989. </year>
Reference-contexts: An early treatment of recursion, based on continuity of the weakest preconditions (and hence based on finite nondeterminism), is given in [Roe76]. More detailed treatments are given in [Heh79] and [Bak80]. Recursion together with countable nondeterminism is studied in [APP86], and recursion with unbounded nondeterminism in <ref> [DiG86, Hes89] </ref>. Recursion is added in a fully compositional way by Nelson in [Nel89]: the guarded command language is embedded in a language with sequential composition, binary demonic choice and a backtrack operator in which the operators can be used freely.
Reference: [HiP72] <author> Hitchcock, P. and Park, D.: </author> <title> Induction Rules and Termination Proofs. </title> <editor> In M. Nivat, editor, </editor> <booktitle> Proc. 1st ICALP, </booktitle> <address> Rocquencourt, France, 1972. </address> <publisher> North-Holland. </publisher>
Reference-contexts: This result is proved using an extension of fixed point theory. It is well known that a continuous function from a complete partial order to itself has a least fixed point that can be obtained by iteration from the least element. This result was extended by Hitchcock and Park <ref> [HiP72] </ref> showing that also a monotone function from a complete partial order to itself has a least fixed point. Then Apt and Ploktin [APP81, APP86] showed that the least fixed point property can be transferred, via a commutative diagram, to monotone functions from a poset (not necessarily complete) to itself. <p> If P is a pointed dcpo and f is monotone then f &lt;&gt; always exists. In this case there is an ordinal k such that whenever k we have f &lt;&gt; = f &lt;k&gt; <ref> [HiP72] </ref>. The following theorem, taken from [APP81, APP86], shows that under certain circumstances g &lt;&gt; always exists and stabilizes for a monotone function g : Q ! Q even if Q is not a directed complete partial order. Theorem 4.2.
Reference: [Mey85] <author> Meyer, J.-J.Ch.: </author> <title> Programming Calculi Based on Fixed Point Transformations: Semantics and Applications. </title> <type> PhD thesis, </type> <institution> Vrije Universiteit, </institution> <address> Amsterdam, </address> <year> 1985. </year>
Reference-contexts: Then Apt and Ploktin [APP81, APP86] showed that the least fixed point property can be transferred, via a commutative diagram, to monotone functions from a poset (not necessarily complete) to itself. This transfer lemma is explored in detail by Meyer in <ref> [Mey85] </ref>. We show that the least fixed point property can be transferred to arbitrary functions from a partial order to itself. We also provide state transformer models for three weakest precondition semantics. The state transformer models relate initial states to sets of possible outcomes of the computation. <p> In particular if f exists (and hence f = f &lt;&gt; for some ordinal ) then so does g and g = h (f). 2 Several generalizations, where g is always a monotone function, and applications of this theorem (often called transfer lemma) can be found in <ref> [Mey85] </ref>. In the next theorem we show that we can drop the condition of g to be monotone provided that h satisfies some extra conditions. Theorem 4.3. Let P be a pointed dcpo and Q be poset.
Reference: [Mor87] <author> Morris, J.: </author> <title> A Theoretical Basis for Stepwise Refinement and the Programming Calculus. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 9 </volume> <pages> 287-306, </pages> <year> 1987. </year>
Reference-contexts: The language was extended to use it as a vehicle for program refinement. Specification constructs, like unbounded demonic choice and angelic choice, were added and a refinement ordering was defined. This approach was introduced in [Bac78, Bac80] and is suited for refinement (see [BaW90, Bac90] and also <ref> [MRG88, Mor87] </ref>). The ordering can be used to add recursion to the language, but not in a fully compositional way in which all the operators can be used freely. For example, for each set of guards there is a different conditional command. <p> Orderings In this section we introduce three pre-orders on Stat. The first pre-order v B was proposed by Back [Bac78, Bac80] and is suited for refinement (see [Bac90] and 78 M. M. Bonsangue and J. N. Kok also <ref> [Mor87, MRG88] </ref>). The second pre-order v D is a new ordering which preserves deadlocks: a non-miraculous statement can not be refined by a miraculous one.
Reference: [MRG88] <author> Morgan, C.C., Robinson, K.A. and Gardiner, P.H.B.: </author> <title> On the Refinement Calculus. </title> <type> Technical Report PRG-70, </type> <institution> Programming Research Group, </institution> <year> 1988. </year>
Reference-contexts: The language was extended to use it as a vehicle for program refinement. Specification constructs, like unbounded demonic choice and angelic choice, were added and a refinement ordering was defined. This approach was introduced in [Bac78, Bac80] and is suited for refinement (see [BaW90, Bac90] and also <ref> [MRG88, Mor87] </ref>). The ordering can be used to add recursion to the language, but not in a fully compositional way in which all the operators can be used freely. For example, for each set of guards there is a different conditional command. <p> Orderings In this section we introduce three pre-orders on Stat. The first pre-order v B was proposed by Back [Bac78, Bac80] and is suited for refinement (see [Bac90] and 78 M. M. Bonsangue and J. N. Kok also <ref> [Mor87, MRG88] </ref>). The second pre-order v D is a new ordering which preserves deadlocks: a non-miraculous statement can not be refined by a miraculous one.
Reference: [Nel89] <author> Nelson, G.: </author> <title> A Generalization of Dijkstra's Calculus. </title> <journal> ACM Transaction on Programming Languages and Systems, </journal> <volume> 11(4) </volume> <pages> 517-561, </pages> <year> 1989. </year>
Reference-contexts: More detailed treatments are given in [Heh79] and [Bak80]. Recursion together with countable nondeterminism is studied in [APP86], and recursion with unbounded nondeterminism in [DiG86, Hes89]. Recursion is added in a fully compositional way by Nelson in <ref> [Nel89] </ref>: the guarded command language is embedded in a language with sequential composition, binary demonic choice and a backtrack operator in which the operators can be used freely. An ordering on predicate transformers is given, and all the operators are monotonic with respect to this ordering. <p> The ordering uses the additional notion of weakest liberal precondition, and is an approximation ordering of the kind used in denotational semantics. It is not suited for refinement in the sense of [BaW90]. Our starting point is the language of <ref> [Nel89] </ref>. In this language there is a form of infinite behavior (a divergence construct) and atomic actions that can deadlock (to initiate backtracking). The main operators present in the language are sequential composition, unbounded demonic choice and a backtrack operator. <p> This gives semantic models for the Back and the deadlock ordering. The Egli-Milner power domain (extended with the empty set too, in order to treat deadlock) is treated by giving an isomorphism between the Egli-Milner state transformers and the Nelson predicate transformers (cf. <ref> [Nel89] </ref>). For the state transformer models we define operations that are isomorphic to the corresponding operations between predicate transformers. 2. <p> The backtrack operator backtracks to the second component if the first component deadlocks. The only atomic action that can deadlock is b !: it deadlocks in a state in which the boolean expression b does not evaluate to true. One difference with the language studied in <ref> [Nel89] </ref> is that there are two kinds of atomic actions: the assignment action v := t and the test action b !. Another difference is that we allow unbounded demonic choice. 74 M. M. Bonsangue and J. N. <p> is similar to that of wp given in Definition 2.3, except for the cases wlp (div )(Q) = true; and wlp (S 1 3S 2 )(Q) = wlp (S 1 )(Q) ^ (wp (S 1 )(false) ) wlp (S 2 )(Q)): The next lemma, which proof can be found in <ref> [Nel89] </ref>, relates wp and wlp. It states the familiar termination law of Dijkstra. Lemma 3.1. <p> Now we can define the third pre-order, which was introduced in <ref> [Nel89] </ref>: S 1 v N S 2 , def S 1 v B S 2 ^ 8Q 2 Pred : wlp (S 2 )(Q) ) wlp (S 1 )(Q): By definition we have that the Nelson pre-order v N is included in the deadlock pre-order v D , which in turn <p> For the pre-orders v B and v N we refer to [BaW90] and <ref> [Nel89] </ref>, respec tively. We prove only (ii) and (v). Let I be a non-empty index set and let S i ; S 0 i 2 Stat be statements for each i 2 I such that S i v D S 0 i . <p> We generalize the relationship between the Smyth power domain and the predicate transformers [Wan77, Plo79, Bac81, Bes83, APP86, Smy83] to the new versions of the Smyth power domain. Moreover, we introduce a relationship between the Egli-Milner power domain and pairs of predicate transformers (see also <ref> [Nel89] </ref>). For further reference, the diagram in Fig. 2 summarizes the relationships. All the arrows in this diagram are monotone functions. <p> We proposed an extension of Dijkstra's Weakest Precondition Calculus in order to treat recursion in a fully compositional way with respect to three different orders: a refinement order as introduced in [Bac78], a new refinement order that respects deadlock, and an approximation order as introduced in <ref> [Nel89] </ref>. 2. We showed that (under certain circumstances), least fixed points of functions (even non-monotone) between posets exist and that they can be obtained by iteration from the least element. 3. We gave three isomorphisms between domains of predicate transformers and domains of state transformers.
Reference: [Plo79] <author> Plotkin, G.D.: </author> <title> Dijkstra's Predicate Transformer and Smyth's Powerdomain. </title> <booktitle> In Proc. of the Winter School on Abstract Software Specification, Lecture Notes in Computer Science 86, </booktitle> <pages> pp. 527-553. </pages> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: One of the aims of this paper is to match the predicate transformer view of a program to the state transformer view by extending the duality which relates the discrete version of the Smyth power domain [Smy78] and Dijkstra's The Weakest Precondition Calculus 73 predicate transformers <ref> [Wan77, Plo79, Bac81, Smy83, Bes83, APP86] </ref>. The duality states that there is an order isomorphism between functions to the Smyth power domain (ordered pointwise) and the predicate transformers (ordered by the refinement order). <p> The kind of restrictions depends on the kind of (specification) language one wants to model. For example in [Dij76] predicate transformers satisfy the properties 1-5 and are used to model a language with at most a countable number of states and with finite nondeterministic demonic choice. In <ref> [Wan77, Plo79] </ref> predicate transformers satisfy the properties 1, 2, 4 and 5. For countable nonde-terminism predicate transformers are required to satisfy the properties 1, 2 and 6 in [Bes83] and [APP86]. <p> Relationships between the domains. 5. Duality In this section we relate the predicate transformers with functions to power domains. We generalize the relationship between the Smyth power domain and the predicate transformers <ref> [Wan77, Plo79, Bac81, Bes83, APP86, Smy83] </ref> to the new versions of the Smyth power domain. Moreover, we introduce a relationship between the Egli-Milner power domain and pairs of predicate transformers (see also [Nel89]). For further reference, the diagram in Fig. 2 summarizes the relationships.
Reference: [Plo81] <editor> Plotkin, G.D.: </editor> <booktitle> Post-Graduate Lecture Notes in Advanced Domain Theory (incorporating the "Pisa Notes"). </booktitle> <institution> Department of Computer Science, Univ. of Edinburgh, </institution> <year> 1981. </year>
Reference-contexts: M. Bonsangue and J. N. Kok 4.1. Order Theory We first recall some of the standard notions in domain theory. A good reference for domain theory is <ref> [Plo81] </ref>. Let P be a poset and S be a non-empty subset of P . Then S is said to be directed if every finite subset of S has an upper bound. <p> by E (X ? ) the poset whose elements are subsets of X ? ordered as follows: A v B , (? 62 A ^ A = B) _ (? 2 A ^ (A n f?g) B): Note that this differs from the usual definition of the Egli-Milner power domain <ref> [Plo81] </ref> because we add the empty set and we have no restriction on the cardinality of subsets of X ? . The poset E (X ? ) is pointed and directed com plete.
Reference: [Roe76] <author> Roever, </author> <title> W.P. de: Dijkstra's Predicate Transformer, Non-Determinism, Recursion, </title> <booktitle> and Terminations. In Proc. 5th MFCS, Lecture Notes in Computer Science 45, </booktitle> <pages> pp. 472-481. </pages> <publisher> Springer-Verlag, </publisher> <year> 1976. </year>
Reference-contexts: For example, for each set of guards there is a different conditional command. An early treatment of recursion, based on continuity of the weakest preconditions (and hence based on finite nondeterminism), is given in <ref> [Roe76] </ref>. More detailed treatments are given in [Heh79] and [Bak80]. Recursion together with countable nondeterminism is studied in [APP86], and recursion with unbounded nondeterminism in [DiG86, Hes89].
Reference: [Smy78] <author> Smyth, </author> <title> M.B.: Power Domains. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 16(1) </volume> <pages> 23-36, </pages> <year> 1978. </year> <title> The Weakest Precondition Calculus 101 </title>
Reference-contexts: Programs are hence represented by state transforming functions. One of the aims of this paper is to match the predicate transformer view of a program to the state transformer view by extending the duality which relates the discrete version of the Smyth power domain <ref> [Smy78] </ref> and Dijkstra's The Weakest Precondition Calculus 73 predicate transformers [Wan77, Plo79, Bac81, Smy83, Bes83, APP86]. The duality states that there is an order isomorphism between functions to the Smyth power domain (ordered pointwise) and the predicate transformers (ordered by the refinement order). <p> This definition differs from the original definition of the Smyth power domain <ref> [Smy78] </ref> because we add the empty set as a top element and there is no restriction on the cardinality of the subsets of X.
Reference: [Smy83] <author> Smyth, </author> <title> M.B.: Power Domains and Predicate Transformers: A Topological View. </title> <editor> In J. Diaz, editor, </editor> <booktitle> Proc. 10th ICALP, Lecture Notes in Computer Science 154, </booktitle> <pages> pp. 662-675, </pages> <address> Barcelona, Spain, 1983. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: One of the aims of this paper is to match the predicate transformer view of a program to the state transformer view by extending the duality which relates the discrete version of the Smyth power domain [Smy78] and Dijkstra's The Weakest Precondition Calculus 73 predicate transformers <ref> [Wan77, Plo79, Bac81, Smy83, Bes83, APP86] </ref>. The duality states that there is an order isomorphism between functions to the Smyth power domain (ordered pointwise) and the predicate transformers (ordered by the refinement order). <p> Relationships between the domains. 5. Duality In this section we relate the predicate transformers with functions to power domains. We generalize the relationship between the Smyth power domain and the predicate transformers <ref> [Wan77, Plo79, Bac81, Bes83, APP86, Smy83] </ref> to the new versions of the Smyth power domain. Moreover, we introduce a relationship between the Egli-Milner power domain and pairs of predicate transformers (see also [Nel89]). For further reference, the diagram in Fig. 2 summarizes the relationships.
Reference: [Wan77] <author> Wand, M.: </author> <title> A Characterisation of Weakest Preconditions. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 15 </volume> <pages> 209-212, </pages> <year> 1977. </year>
Reference-contexts: One of the aims of this paper is to match the predicate transformer view of a program to the state transformer view by extending the duality which relates the discrete version of the Smyth power domain [Smy78] and Dijkstra's The Weakest Precondition Calculus 73 predicate transformers <ref> [Wan77, Plo79, Bac81, Smy83, Bes83, APP86] </ref>. The duality states that there is an order isomorphism between functions to the Smyth power domain (ordered pointwise) and the predicate transformers (ordered by the refinement order). <p> The kind of restrictions depends on the kind of (specification) language one wants to model. For example in [Dij76] predicate transformers satisfy the properties 1-5 and are used to model a language with at most a countable number of states and with finite nondeterministic demonic choice. In <ref> [Wan77, Plo79] </ref> predicate transformers satisfy the properties 1, 2, 4 and 5. For countable nonde-terminism predicate transformers are required to satisfy the properties 1, 2 and 6 in [Bes83] and [APP86]. <p> Relationships between the domains. 5. Duality In this section we relate the predicate transformers with functions to power domains. We generalize the relationship between the Smyth power domain and the predicate transformers <ref> [Wan77, Plo79, Bac81, Bes83, APP86, Smy83] </ref> to the new versions of the Smyth power domain. Moreover, we introduce a relationship between the Egli-Milner power domain and pairs of predicate transformers (see also [Nel89]). For further reference, the diagram in Fig. 2 summarizes the relationships.
Reference: [Wri90] <author> Wright, J. von: </author> <title> A Lattice-theoretical Basis for Program Refinement. </title> <type> PhD thesis, </type> <institution> Abo Akademi, </institution> <year> 1990. </year> <note> Received June 1993 Accepted in revised form in July 1994 </note>
Reference-contexts: If we identify statements with their weakest preconditions then we have that our language is a subset of the monotonic predicate transformers of <ref> [BaW90, Wri90] </ref> because we do not consider angelic choice and multiple assignment statements. The guard statement [b] is b ! and the assert statement fbg is b ! 3div . <p> Moreover, if we extend the language with multiple assignment statements, then it is possible to prove that for every multiplicative predicate transformer 2 MPTran there exists a statement S such that = wp (S) <ref> [Wri90] </ref>. A number of different restrictions on predicate transformers can be found in the literature.
References-found: 29

