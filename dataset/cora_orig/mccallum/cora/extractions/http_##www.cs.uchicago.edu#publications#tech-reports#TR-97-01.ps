URL: http://www.cs.uchicago.edu/publications/tech-reports/TR-97-01.ps
Refering-URL: http://cs-www.uchicago.edu/publications/tech-reports/
Root-URL: 
Email: gopalan@cs.uchicago.edu debwilson@vnet.ibm.com  
Title: A Notation for Lambda Terms: A Generalization of Environments  
Author: Gopalan Nadathur Debra Sue Wilson 
Address: Ryerson Hall, 1100 E 58th Street TCJA/B631 D106  Chicago 4102 S. Miami Blvd. Chicago, IL 60637 Research Triangle Park, NC 27706  
Affiliation: Department of Computer Science IBM Corporation  University of  
Abstract: A notation for lambda terms is described that is useful in contexts where the intensions of these terms need to be manipulated. The scheme of de Bruijn is used for eliminating variable names, thus obviating ff-conversion in comparing terms. A category of terms is provided that can encode other terms together with substitutions to be performed on them. The notion of an environment is used to realize this `delaying' of substitutions. However, the precise environment mechanism employed here is more complex than the usual one because the ability to examine subterms embedded under abstractions has to be supported. The representation presented permits a fi-contraction to be realized via an atomic step that generates a substitution and associated steps that percolate this substitution over the structure of a term. Operations on terms are provided that allow for the combination and hence the simultaneous performance of substitutions. Our notation eventually provides a basis for efficient realizations of fi-reduction and also serves as a means for interleaving steps inherent in this operation with steps in other operations such as higher-order unification. Manipulations on our terms are described through a system of rewrite rules whose correspondence to the usual notion of fi-reduction is exhibited and exploited in establishing confluence and other similar properties. Our notation is similar in spirit to recent proposals deriving from the Categorical Combinators of Curien, and the relationship to these is discussed. Refinements to our notation and their use in describing manipulations on lambda terms are considered in a companion paper. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martn Abadi, Luca Cardelli, Pierre-Louis Curien, and Jean-Jacques Levy. </author> <title> Explicit substitutions. </title> <booktitle> In Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> 48 pages 31-46. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1990. </year>
Reference-contexts: At a level of detail, our proposal shares features with the data structures used in [2] in implementing a normalization procedure. However, in a manner akin to other recent proposals deriving from the Categorical Combinators of Curien <ref> [1, 10, 13] </ref>, it has the characteristic of reflecting the idea of an environment into the notation itself. There are two advantages to adopting this course. <p> In the concluding section of this paper, we discuss the relationship of our work to that of others, especially that in <ref> [1] </ref> and [13]. 2 Logical preliminaries We are concerned in this paper with systems for rewriting expressions. Each such rewrite system is specified by a set of rule schemata. <p> The enhanced syntax for terms that we have outlined up to this point can be used to realize fi-contraction through a genuinely atomic step. For example, suppose we wish to rewrite the fi-redex (( t) s). Such a rewriting might consist of producing the term <ref> [[t; 1; 0; (s; 0) :: nil] </ref>]; an environment whose first element is et and whose remaining elements are given by e is denoted here by the expression et :: e. <p> The case when t is a constant is also easily handled. If t is a term of the form (t 1 t 2 ), the substitution can be distributed over t 1 and t 2 by generating the term ([[t 1 ; 1; 0; (s; 0) :: nil]] <ref> [[t 2 ; 1; 0; (s; 0) :: nil] </ref>]). Finally, in the case that t is of the form ( t 1 ), the suspended substitution can be lowered into the abstraction by generating the term ( [[t 1 ; 2; 1; @0 :: (s; 0) :: nil]]). <p> Finally, in the case that t is of the form ( t 1 ), the suspended substitution can be lowered into the abstraction by generating the term ( <ref> [[t 1 ; 2; 1; @0 :: (s; 0) :: nil] </ref>]). It is interesting to contrast the treatment of abstraction here with that in Definition 3.2. <p> Depending on the order chosen (and assuming only the minimal propagation of substitutions) we obtain one of the two terms <ref> [[[[t 1 ; 1; 0; (t 2 ; 0) :: nil] </ref>]; 1; 0; (t 3 ; 0) :: nil]] or 13 Reducing either of these terms to a de Bruijn term based on the approach just suggested is tanta-mount to substituting t 3 and (a possibly modified version of ) t <p> Finally, it is easily observed that the index of this entry should be l 0 , normalized as before in the case that nl 1 is greater than ol 2 . We provide a concrete illustration of the combination of suspensions by considering the term <ref> [[[[t 1 ; 1; 0; (t 2 ; 0) :: nil] </ref>]; 1; 0; (t 3 ; 0) :: nil]] that results through fi-contraction from the term (( (( t 1 ) t 2 )) t 3 ). <p> Now, the abstraction height of (t 2 ; 0) is 0 and so the term component of the value of hh (t 2 ; 0); 0; 1; (t 3 ; 0) :: nilii should be <ref> [[t 2 ; 1; 0; (t 3 ; 0) :: nil] </ref>]; intuitively, the effect of the entire outer environment must be reflected on t 2 in computing the relevant term in the merged environment. The index of this environment element must be identical to that of (t 3 ; 0). <p> The details are straightforward and hence omitted. 2 We henceforth consider only well formed expressions and this qualification is assumed implicitly whenever we speak of terms, environments, environment terms or expressions. 18 (fi s ) (( t 1 ) t 2 ) ! <ref> [[t 1 ; 1; 0; (t 2 ; 0) :: nil] </ref>] (r1) [[c; ol; nl; e]] ! c, provided c is a constant. (r2) [[#i; 0; nl; nil]] ! #j, where j = i + nl. (r3) [[#1; ol; nl; @l :: e]] ! #j, where j = nl l. (r4) <p> abstraction by using a reading rule to yield the term ( [[((#1 #2) #3); 3; 1; @0 :: ([[t 2 ; 1; 0; (t 3 ; 0) :: nil]]; 0) :: (t 3 ; 0) :: nil]]): A repeated application of reading rules transforms the last term into ( ((#1 <ref> [[[[t 2 ; 1; 0; (t 3 ; 0) :: nil] </ref>]; 0; 1; nil]]) [[t 3 ; 0; 1; nil]])). The application of merging rules to this term yields ( ((#1 [[t 2 ; 1; 1; (t 3 ; 0) :: nil]]) [[t 3 ; 0; 1; nil]])). <p> 3; 1; @0 :: ([[t 2 ; 1; 0; (t 3 ; 0) :: nil]]; 0) :: (t 3 ; 0) :: nil]]): A repeated application of reading rules transforms the last term into ( ((#1 [[[[t 2 ; 1; 0; (t 3 ; 0) :: nil]]; 0; 1; nil]]) <ref> [[t 3 ; 0; 1; nil] </ref>])). The application of merging rules to this term yields ( ((#1 [[t 2 ; 1; 1; (t 3 ; 0) :: nil]]) [[t 3 ; 0; 1; nil]])). <p> The application of merging rules to this term yields ( ((#1 <ref> [[t 2 ; 1; 1; (t 3 ; 0) :: nil] </ref>]) [[t 3 ; 0; 1; nil]])). <p> rules transforms the last term into ( ((#1 [[[[t 2 ; 1; 0; (t 3 ; 0) :: nil]]; 0; 1; nil]]) <ref> [[t 3 ; 0; 1; nil] </ref>])). The application of merging rules to this term yields ( ((#1 [[t 2 ; 1; 1; (t 3 ; 0) :: nil]]) [[t 3 ; 0; 1; nil]])). <p> Base Case: t is the fi-redex rewritten by a fi-contraction rule. Let t = (( t 1 ) t 2 ). By definition, 39 s = S (t 1 ; t 2 ; #1; #2; : : :): (1) Now let r = <ref> [[t 1 ; 1; 0; (t 2 ; 0) :: nil] </ref>]. <p> We analyze each possibility separately. In the first subcase, t has the form (( t 1 ) t 2 ). We note first that jtj = (( jt 1 j) jt 2 j). Further, s = <ref> [[t 1 ; 1; 0; (t 2 ; 0) :: nil] </ref>]. Using Theorem 6.16, it can be seen that jsj = S (jt 1 j; jt 2 j; #1; #2; : : :), i.e., that jtjfl fi 0 jsj. <p> While the CCL system has several desirable features, its relationship to the lambda calculus is a somewhat complex one. More recently, the general ideas embedded in CCL have been used in conjunction with notations that are more directly based on the lambda calculus in <ref> [1] </ref> and [13]. The resulting systems are very similar to the one described here and our work, in fact, represents a concurrent and independent development of these general ideas. 6 At a level of detail, the notations in [1] and [13] are practically indistinguishable. <p> with notations that are more directly based on the lambda calculus in <ref> [1] </ref> and [13]. The resulting systems are very similar to the one described here and our work, in fact, represents a concurrent and independent development of these general ideas. 6 At a level of detail, the notations in [1] and [13] are practically indistinguishable. However, they differ from our notation in two respects. The first of these is in the manner in which variables are represented. In our notation, these are represented directly by de Bruijn numbers. <p> Thus, as observed in Theorem 8.3, the rules for merging 6 The ideas described here are an outgrowth of those contained in [32]. The present exposition of these ideas has, however, been influenced by <ref> [1] </ref>. 46 environments can be omitted from our system without losing the ability to simulate fi-reduction. A similar observation cannot be made about the other systems being discussed. 7 The second respect in which our notation differs from the ones in [1] and [13] is the manner in which it encodes <p> exposition of these ideas has, however, been influenced by <ref> [1] </ref>. 46 environments can be omitted from our system without losing the ability to simulate fi-reduction. A similar observation cannot be made about the other systems being discussed. 7 The second respect in which our notation differs from the ones in [1] and [13] is the manner in which it encodes the adjustment that must be made to indices of terms in an environment. <p> The representation used in <ref> [1] </ref> and [13] have the benefit of parsimony: no special syntax is required for environment terms and rules that are used for manipulating terms can also be used for manipulating terms in the environment. <p> In particular, fi-contraction is described in [17] by means of a binary function n and a unary func 7 We note in this context that the remark in <ref> [1] </ref> to the effect that the rule for merging environments (labelled (Clos)) can be eliminated is incorrect. However, as pointed out to us by P.-L.
Reference: [2] <author> L. Aiello and G. Prini. </author> <title> An efficient interpreter for the lambda-calculus. </title> <journal> The Journal of Computer and System Sciences, </journal> <volume> 23 </volume> <pages> 383-425, </pages> <year> 1981. </year>
Reference-contexts: The notation we describe embellishes the notion of an environment in a manner designed to overcome this difficulty. At a level of detail, our proposal shares features with the data structures used in <ref> [2] </ref> in implementing a normalization procedure. However, in a manner akin to other recent proposals deriving from the Categorical Combinators of Curien [1, 10, 13], it has the characteristic of reflecting the idea of an environment into the notation itself. There are two advantages to adopting this course. <p> All these substitutions can be achieved in one traversal over the structure of t 1 provided we have a fine-grained control over the way each substitution is carried out. An observation of this kind is, in fact, exploited in the implementation of fi-reduction in <ref> [2] </ref>. In contexts where the lambda calculus is employed as a vehicle for computation, the use of an environment that describes bindings for free variables suffices for delaying substitutions. <p> Finally, in the case that t is of the form ( t 1 ), the suspended substitution can be lowered into the abstraction by generating the term ( <ref> [[t 1 ; 2; 1; @0 :: (s; 0) :: nil] </ref>]). It is interesting to contrast the treatment of abstraction here with that in Definition 3.2.
Reference: [3] <author> N. de Bruijn. </author> <title> Lambda calculus notation with nameless dummies, a tool for automatic formula manipulation, with application to the Church-Rosser Theorem. </title> <journal> Indag. Math., </journal> <volume> 34(5) </volume> <pages> 381-392, </pages> <year> 1972. </year>
Reference-contexts: We describe a notation for lambda terms in this paper that provides a basis for meeting these various requirements. The starting point for our notation is a scheme suggested by de Bruijn <ref> [3] </ref> for eliminating variable names from terms. To provide a means for delaying substitutions, we utilize the notion of an environment. <p> Second, the determination of identity of two terms is complicated by the need to consider renamings for bound variables. The `nameless' notation proposed by de Bruijn <ref> [3] </ref> provides an elegant way of dealing with the first problem and it eliminates the second by rendering lambda terms in the conventional notation that differ only in the names of bound variables into a common 6 form. <p> Further, the index #1 must remain unchanged within t and it is the indices #2,#3,: : : that must be substituted for. We will need to consider the effect of cascading substitutions of the above kind. An observation made in <ref> [3] </ref> is useful in this context. <p> Thus the s 0 i terms will only be substituted into occurrences of the s j terms, and the effect of this substitution can be precomputed. This is formalized in the following proposition taken from <ref> [3] </ref>. <p> Then S (t 0 ; t 1 ; t 2 ; t 3 ; : : :)fl fl 0 ; t 0 2 ; t 0 Finally, we observe the celebrated Church-Rosser Theorem for fi-reduction. A proof of it in the context of the de Bruijn notation appears in <ref> [3] </ref>. Proposition 3.7 The relation fl fi is confluent. 2 This corollary generalizes a theorem in [3] that is used in proving the Church-Rosser Theorem for fi-reduction. 9 4 Incorporating environments into terms The de Bruijn notation is useful in contexts where the intensions of lambda terms have to be examined <p> A proof of it in the context of the de Bruijn notation appears in <ref> [3] </ref>. Proposition 3.7 The relation fl fi is confluent. 2 This corollary generalizes a theorem in [3] that is used in proving the Church-Rosser Theorem for fi-reduction. 9 4 Incorporating environments into terms The de Bruijn notation is useful in contexts where the intensions of lambda terms have to be examined because it makes it unnecessary to consider ff-conversion. <p> However, our representation seems to have an advantage if a simpler rewriting system, such as that obtained by eliminating the merging rules, is used. In a different direction, the general idea of delaying substitutions appears to have been anticipated by de Bruijn in <ref> [3] </ref> and [4]. In the latter paper, de Bruijn actually presents a notation for lambda terms that includes mappings for transforming variable indices within terms. The specific notation presented in [4] is quite cumbersome and, in addition, does not include any mechanisms for encoding the substitution operation needed for fi-contraction.
Reference: [4] <author> N. de Bruijn. </author> <title> Lambda-calculus notation with namefree formulas involving symbols that represent reference transforming mappings. </title> <journal> Indag. Math., </journal> <volume> 40 </volume> <pages> 348-356, </pages> <year> 1978. </year>
Reference-contexts: However, our representation seems to have an advantage if a simpler rewriting system, such as that obtained by eliminating the merging rules, is used. In a different direction, the general idea of delaying substitutions appears to have been anticipated by de Bruijn in [3] and <ref> [4] </ref>. In the latter paper, de Bruijn actually presents a notation for lambda terms that includes mappings for transforming variable indices within terms. The specific notation presented in [4] is quite cumbersome and, in addition, does not include any mechanisms for encoding the substitution operation needed for fi-contraction. <p> In a different direction, the general idea of delaying substitutions appears to have been anticipated by de Bruijn in [3] and <ref> [4] </ref>. In the latter paper, de Bruijn actually presents a notation for lambda terms that includes mappings for transforming variable indices within terms. The specific notation presented in [4] is quite cumbersome and, in addition, does not include any mechanisms for encoding the substitution operation needed for fi-contraction.
Reference: [5] <author> N. de Bruijn. </author> <title> A survey of the project AUTOMATH. </title> <editor> In J. P. Seldin and J. R. Hindley, editors, To H. B. </editor> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 579-606. </pages> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: We believe, however, that this issue is of wider concern, given the number of computer systems and programming languages in existence today that use some variety of the lambda calculus in representing and manipulating formal objects such as formulas, programs and proofs <ref> [5, 7, 8, 15, 18, 28, 35, 36] </ref>. Lambda terms have been found to be useful as data structures because of their ability to represent naturally the notion of binding that is part of the syntax of several kinds of objects [6, 23, 28, 34, 37].
Reference: [6] <author> Alonzo Church. </author> <title> A formulation of the simple theory of types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 5 </volume> <pages> 56-68, </pages> <year> 1940. </year>
Reference-contexts: Lambda terms have been found to be useful as data structures because of their ability to represent naturally the notion of binding that is part of the syntax of several kinds of objects <ref> [6, 23, 28, 34, 37] </ref>. Consider, for instance, the task of representing the quantified formula 8x ((p x)_ (q x)) in which p and q are predicate names.
Reference: [7] <author> R. L. Constable, S. F. Allen, H. M. Bromley, W. R. Cleaveland, J. F. Cremer, R. W. Harper, D. J. Howe, T. B. Knoblock, N. P. Mendler, P. Panangaden, J. T. Sasaki, and S. F. Smith. </author> <title> Implementing Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: We believe, however, that this issue is of wider concern, given the number of computer systems and programming languages in existence today that use some variety of the lambda calculus in representing and manipulating formal objects such as formulas, programs and proofs <ref> [5, 7, 8, 15, 18, 28, 35, 36] </ref>. Lambda terms have been found to be useful as data structures because of their ability to represent naturally the notion of binding that is part of the syntax of several kinds of objects [6, 23, 28, 34, 37].
Reference: [8] <author> Thierry Coquand and Gerard Huet. </author> <title> The calculus of constructions. </title> <journal> Information and Computation, </journal> 76(2/3):95-120, February/March 1988. 
Reference-contexts: We believe, however, that this issue is of wider concern, given the number of computer systems and programming languages in existence today that use some variety of the lambda calculus in representing and manipulating formal objects such as formulas, programs and proofs <ref> [5, 7, 8, 15, 18, 28, 35, 36] </ref>. Lambda terms have been found to be useful as data structures because of their ability to represent naturally the notion of binding that is part of the syntax of several kinds of objects [6, 23, 28, 34, 37].
Reference: [9] <author> G. Cousineau, P-L. Curien, and M. Mauny. </author> <title> The categorical abstract machine. </title> <booktitle> The Science of Programming, </booktitle> <volume> 8(2) </volume> <pages> 173-202, </pages> <year> 1987. </year>
Reference-contexts: Thus, if a term is produced in the course of fi-reduction that has an abstraction at the outermost level, then the term may be combined with its environment and returned as a closure; this idea is used, for instance, in <ref> [9] </ref>. However, this assumption is not appropriate in contexts where lambda terms are used as a means for representation.
Reference: [10] <author> P-L. Curien. </author> <title> Categorical combinators. </title> <journal> Information and Control, </journal> <volume> 69 </volume> <pages> 188-254, </pages> <year> 1986. </year>
Reference-contexts: At a level of detail, our proposal shares features with the data structures used in [2] in implementing a normalization procedure. However, in a manner akin to other recent proposals deriving from the Categorical Combinators of Curien <ref> [1, 10, 13] </ref>, it has the characteristic of reflecting the idea of an environment into the notation itself. There are two advantages to adopting this course. <p> Moreover, as discussed already, this is not an assumption that is valid in all contexts. In our knowledge, the first serious consideration of a notation and a calculus that incorporate a fine-grained control over substitutions appears in the work of P-L. Curien <ref> [10, 11] </ref>. In this work, a categorical combinatory logic called CCL is described.
Reference: [11] <author> P-L. Curien. </author> <title> Categorical Combinators, Sequential Algorithms and Functional Programming. </title> <publisher> Pitman, </publisher> <year> 1986. </year>
Reference-contexts: Moreover, as discussed already, this is not an assumption that is valid in all contexts. In our knowledge, the first serious consideration of a notation and a calculus that incorporate a fine-grained control over substitutions appears in the work of P-L. Curien <ref> [10, 11] </ref>. In this work, a categorical combinatory logic called CCL is described.
Reference: [12] <author> Nachum Dershowitz. </author> <title> Orderings for term-rewriting systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 17(3) </volume> <pages> 279-301, </pages> <year> 1982. </year>
Reference-contexts: However, an alternative proof can be provided by invoking Kruskal's tree theorem [14, 26], thereby exhibiting relationships between and the notions of simplification orderings <ref> [12] </ref> and Kamin and Levy's extended recursive path orderings (described, for example, in [22]).
Reference: [13] <author> John Field. </author> <title> On laziness and optimality in lambda interpreters: Tools for specification and analysis. </title> <booktitle> In Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-15. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1990. </year>
Reference-contexts: At a level of detail, our proposal shares features with the data structures used in [2] in implementing a normalization procedure. However, in a manner akin to other recent proposals deriving from the Categorical Combinators of Curien <ref> [1, 10, 13] </ref>, it has the characteristic of reflecting the idea of an environment into the notation itself. There are two advantages to adopting this course. <p> In the concluding section of this paper, we discuss the relationship of our work to that of others, especially that in [1] and <ref> [13] </ref>. 2 Logical preliminaries We are concerned in this paper with systems for rewriting expressions. Each such rewrite system is specified by a set of rule schemata. <p> While the CCL system has several desirable features, its relationship to the lambda calculus is a somewhat complex one. More recently, the general ideas embedded in CCL have been used in conjunction with notations that are more directly based on the lambda calculus in [1] and <ref> [13] </ref>. The resulting systems are very similar to the one described here and our work, in fact, represents a concurrent and independent development of these general ideas. 6 At a level of detail, the notations in [1] and [13] are practically indistinguishable. <p> that are more directly based on the lambda calculus in [1] and <ref> [13] </ref>. The resulting systems are very similar to the one described here and our work, in fact, represents a concurrent and independent development of these general ideas. 6 At a level of detail, the notations in [1] and [13] are practically indistinguishable. However, they differ from our notation in two respects. The first of these is in the manner in which variables are represented. In our notation, these are represented directly by de Bruijn numbers. <p> A similar observation cannot be made about the other systems being discussed. 7 The second respect in which our notation differs from the ones in [1] and <ref> [13] </ref> is the manner in which it encodes the adjustment that must be made to indices of terms in an environment. <p> The representation used in [1] and <ref> [13] </ref> have the benefit of parsimony: no special syntax is required for environment terms and rules that are used for manipulating terms can also be used for manipulating terms in the environment.
Reference: [14] <author> Jean H. Gallier. </author> <title> What's so special about Kruskal's theorem and the ordinal 0 ? A survey of some results in proof theory. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 53 </volume> <pages> 199-260, </pages> <year> 1991. </year> <month> 49 </month>
Reference-contexts: However, an alternative proof can be provided by invoking Kruskal's tree theorem <ref> [14, 26] </ref>, thereby exhibiting relationships between and the notions of simplification orderings [12] and Kamin and Levy's extended recursive path orderings (described, for example, in [22]).
Reference: [15] <author> Michael J. Gordon, Arthur J. Milner, and Christopher P. Wadsworth. </author> <title> Edinburgh LCF: A Mechanised Logic of Computation, </title> <booktitle> volume 78 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: We believe, however, that this issue is of wider concern, given the number of computer systems and programming languages in existence today that use some variety of the lambda calculus in representing and manipulating formal objects such as formulas, programs and proofs <ref> [5, 7, 8, 15, 18, 28, 35, 36] </ref>. Lambda terms have been found to be useful as data structures because of their ability to represent naturally the notion of binding that is part of the syntax of several kinds of objects [6, 23, 28, 34, 37].
Reference: [16] <author> Paul R. Halmos. </author> <title> Naive Set Theory. </title> <address> D. </address> <publisher> Van Nostrand Company, Inc., </publisher> <year> 1960. </year>
Reference-contexts: There are, therefore, no infinite 5 A partial ordering relation has been described in the literature to be one that is irreflexive and transitive [27] as well as to be one that is reflexive, transitive and antisymmetric <ref> [16] </ref>. It is the former definition that we use here. 26 descending sequences from s 1 or e 1 .
Reference: [17] <author> Therese Hardin. </author> <title> Confluence results for the pure strong categorical logic CCL. -calculi as subsystems of CCL. </title> <journal> Theoretical Computer Science, </journal> <volume> 65 </volume> <pages> 291-342, </pages> <year> 1989. </year>
Reference-contexts: In Section 8, we utilize the projection onto de Bruijn terms to show the 3 confluence of our rewrite system. The method of proof we use is similar in spirit to that referred to as the interpretation method in <ref> [17] </ref> and used in [17] and [39] in establishing confluence properties of a combinator calculus. <p> In Section 8, we utilize the projection onto de Bruijn terms to show the 3 confluence of our rewrite system. The method of proof we use is similar in spirit to that referred to as the interpretation method in <ref> [17] </ref> and used in [17] and [39] in establishing confluence properties of a combinator calculus. In the concluding section of this paper, we discuss the relationship of our work to that of others, especially that in [1] and [13]. 2 Logical preliminaries We are concerned in this paper with systems for rewriting expressions. <p> This method of argument is similar in spirit to the one referred to as the interpretation method in <ref> [17] </ref> and used in [17] and [39] in proving confluence properties of a combinator calculus. We use this method again in [29]. 9 Conclusion We have described in this paper a notation for the terms in a lambda calculus and a system for rewriting expressions in this notation. <p> This method of argument is similar in spirit to the one referred to as the interpretation method in <ref> [17] </ref> and used in [17] and [39] in proving confluence properties of a combinator calculus. We use this method again in [29]. 9 Conclusion We have described in this paper a notation for the terms in a lambda calculus and a system for rewriting expressions in this notation. <p> Unfortunately, the rewrite rules that constitute CCL are not confluent <ref> [17] </ref>; this result might be anticipated from the fact that the lambda calculus with the pairing function is not confluent [24]. However, a subset of CCL terms can be exhibited on which the rewrite rules are confluent [17, 39]. <p> Unfortunately, the rewrite rules that constitute CCL are not confluent [17]; this result might be anticipated from the fact that the lambda calculus with the pairing function is not confluent [24]. However, a subset of CCL terms can be exhibited on which the rewrite rules are confluent <ref> [17, 39] </ref>. Moreover, a subclass of this class of terms is isomorphic to the class of lambda calculus terms and this isomorphism can be extended to one between a subset of CCL rules and fi-reduction [17]. <p> Moreover, a subclass of this class of terms is isomorphic to the class of lambda calculus terms and this isomorphism can be extended to one between a subset of CCL rules and fi-reduction <ref> [17] </ref>. An interesting characteristic of this subsystem is that it permits `fi-contraction' to be factored into the generation of a substitution and the subsequent percolation of this substitution in much the spirit of the system described in this paper. <p> However, a special form of the general substitution operation that suffices for fi-contraction has been described in the literature, and using laziness in its implementation results in a notation close to the one presented here. In particular, fi-contraction is described in <ref> [17] </ref> by means of a binary function n and a unary func 7 We note in this context that the remark in [1] to the effect that the rule for merging environments (labelled (Clos)) can be eliminated is incorrect. However, as pointed out to us by P.-L.
Reference: [18] <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <journal> Journal of the ACM, </journal> <volume> 40(1) </volume> <pages> 143-184, </pages> <year> 1993. </year>
Reference-contexts: We believe, however, that this issue is of wider concern, given the number of computer systems and programming languages in existence today that use some variety of the lambda calculus in representing and manipulating formal objects such as formulas, programs and proofs <ref> [5, 7, 8, 15, 18, 28, 35, 36] </ref>. Lambda terms have been found to be useful as data structures because of their ability to represent naturally the notion of binding that is part of the syntax of several kinds of objects [6, 23, 28, 34, 37].
Reference: [19] <author> J. Roger Hindley and Jonathan P. Seldin. </author> <title> Introduction to Combinatory Logic and Lambda Calculus. </title> <publisher> Cambridge University Press, </publisher> <year> 1986. </year>
Reference-contexts: It must then be the case that t 1 fl fl r and t 2 fl fl r. 2 3 The de Bruijn notation Conventional presentations of the lambda calculus utilize a scheme that requires names for bound (and free) variables (e.g. see <ref> [19] </ref>). This choice is well-motivated from the perspective of human readability but is not well-suited to machine implementations for at least two reasons.
Reference: [20] <author> Gerard Huet. </author> <title> A unification algorithm for typed -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 27-57, </pages> <year> 1975. </year>
Reference-contexts: Second, using such a notation makes it possible to intermingle what are traditionally conceived of as steps within fi-contraction with other operations such as those needed in higher-order unification <ref> [20] </ref>. There is, in fact, a concrete realization of the second idea: the notation developed here is actually being used in this fashion in an implementation of Prolog [30]. The remainder of this paper is organized as follows.
Reference: [21] <author> Gerard Huet. </author> <title> Confluent reductions: Abstract properties and applications to term rewriting systems. </title> <journal> Journal of the ACM, </journal> <volume> 27(4) </volume> <pages> 797-821, </pages> <month> October </month> <year> 1980. </year>
Reference-contexts: Local confluence is related to confluence by the following proposition, a proof for which may be found in <ref> [21] </ref>. Proposition 2.2 A noetherian reduction relation is confluent if and only if it is locally confluent. In showing that a reduction relation is locally confluent, an observation in [25] that is generalized in [21] may be used. To describe this observation, we need the following definition. <p> is related to confluence by the following proposition, a proof for which may be found in <ref> [21] </ref>. Proposition 2.2 A noetherian reduction relation is confluent if and only if it is locally confluent. In showing that a reduction relation is locally confluent, an observation in [25] that is generalized in [21] may be used. To describe this observation, we need the following definition. <p> The conflict pairs as defined here constitute all the ground instances of the critical pairs of a rewrite system in the sense of <ref> [21] </ref>. We use the notion of critical pairs only at a metalanguage level to avoid a consideration of expressions containing variables. <p> Then fl is locally confluent if and only if for every conflict pair hr 1 ; r 2 i of R there is some expression s such that r 1 fl fl s and r 2 fl fl s. Proof. (Adapted from <ref> [21] </ref>.) Only the `if ' part in nontrivial and needs argument. Let t be any expression and let t 1 and t 2 be the result of rewriting, respectively, the subexpressions s 1 and s 2 in t using the members R 1 and R 2 of R.
Reference: [22] <author> Gerard Huet. </author> <title> Formal structures for computation and deduction. Unpublished course notes, </title> <institution> Carnegie Mellon University, </institution> <year> 1986. </year>
Reference-contexts: However, an alternative proof can be provided by invoking Kruskal's tree theorem [14, 26], thereby exhibiting relationships between and the notions of simplification orderings [12] and Kamin and Levy's extended recursive path orderings (described, for example, in <ref> [22] </ref>).
Reference: [23] <author> Gerard Huet and Bernard Lang. </author> <title> Proving and applying program transformations expressed with second-order patterns. </title> <journal> Acta Informatica, </journal> <volume> 11 </volume> <pages> 31-55, </pages> <year> 1978. </year>
Reference-contexts: Lambda terms have been found to be useful as data structures because of their ability to represent naturally the notion of binding that is part of the syntax of several kinds of objects <ref> [6, 23, 28, 34, 37] </ref>. Consider, for instance, the task of representing the quantified formula 8x ((p x)_ (q x)) in which p and q are predicate names.
Reference: [24] <author> J.W. Klop. </author> <title> Combinatory Reduction Systems. </title> <publisher> Mathematisch Centrum, </publisher> <address> Amsterdam, </address> <year> 1980. </year>
Reference-contexts: Unfortunately, the rewrite rules that constitute CCL are not confluent [17]; this result might be anticipated from the fact that the lambda calculus with the pairing function is not confluent <ref> [24] </ref>. However, a subset of CCL terms can be exhibited on which the rewrite rules are confluent [17, 39].
Reference: [25] <author> Donald E. Knuth and Peter B. Bendix. </author> <title> Simple word problems in universal algebras. </title> <editor> In J. Leech, editor, </editor> <booktitle> Computational Problems in Abstract Algebra, </booktitle> <pages> pages 263-297. </pages> <publisher> Pergamon Press, </publisher> <year> 1970. </year>
Reference-contexts: Local confluence is related to confluence by the following proposition, a proof for which may be found in [21]. Proposition 2.2 A noetherian reduction relation is confluent if and only if it is locally confluent. In showing that a reduction relation is locally confluent, an observation in <ref> [25] </ref> that is generalized in [21] may be used. To describe this observation, we need the following definition.
Reference: [26] <author> J.B. Kruskal. </author> <title> Well-quasi-ordering, the tree theorem and Vazsonyi's conjecture. </title> <journal> Trans. Amer. Math. Soc., </journal> <volume> 95 </volume> <pages> 210-225, </pages> <year> 1960. </year>
Reference-contexts: However, an alternative proof can be provided by invoking Kruskal's tree theorem <ref> [14, 26] </ref>, thereby exhibiting relationships between and the notions of simplification orderings [12] and Kamin and Levy's extended recursive path orderings (described, for example, in [22]).
Reference: [27] <author> Azriel Levy. </author> <title> Basic Set Theory. </title> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: We use now an additional induction on (s 1 ). By Lemma 5.2, (x) &gt; (s 1 ) and (x) &gt; (e 1 ). There are, therefore, no infinite 5 A partial ordering relation has been described in the literature to be one that is irreflexive and transitive <ref> [27] </ref> as well as to be one that is reflexive, transitive and antisymmetric [16]. It is the former definition that we use here. 26 descending sequences from s 1 or e 1 .
Reference: [28] <author> Dale Miller and Gopalan Nadathur. </author> <title> A logic programming approach to manipulating formulas and programs. </title> <editor> In Seif Haridi, editor, </editor> <booktitle> IEEE Symposium on Logic Programming, </booktitle> <pages> pages 379-388, </pages> <address> San Francisco, </address> <month> September </month> <year> 1987. </year>
Reference-contexts: We believe, however, that this issue is of wider concern, given the number of computer systems and programming languages in existence today that use some variety of the lambda calculus in representing and manipulating formal objects such as formulas, programs and proofs <ref> [5, 7, 8, 15, 18, 28, 35, 36] </ref>. Lambda terms have been found to be useful as data structures because of their ability to represent naturally the notion of binding that is part of the syntax of several kinds of objects [6, 23, 28, 34, 37]. <p> Lambda terms have been found to be useful as data structures because of their ability to represent naturally the notion of binding that is part of the syntax of several kinds of objects <ref> [6, 23, 28, 34, 37] </ref>. Consider, for instance, the task of representing the quantified formula 8x ((p x)_ (q x)) in which p and q are predicate names.
Reference: [29] <author> Gopalan Nadathur. </author> <title> A notation for lambda terms II: Refinements and applications. </title> <type> Technical Report CS-1994-01, </type> <institution> Department of Computer Science, Duke University, </institution> <month> January </month> <year> 1994. </year> <month> 50 </month>
Reference-contexts: A compilation of this kind can be achieved through the identification of derived or admissible rules for our notation. This matter is discussed in <ref> [29] </ref>. 4.2 A modified syntax for terms At a formal level, the main addition to the syntax of de Bruijn terms that yields our notation is that of a suspension. In presenting this category of terms, it is necessary to also explain the structure of environments and environment terms. <p> This method of argument is similar in spirit to the one referred to as the interpretation method in [17] and used in [17] and [39] in proving confluence properties of a combinator calculus. We use this method again in <ref> [29] </ref>. 9 Conclusion We have described in this paper a notation for the terms in a lambda calculus and a system for rewriting expressions in this notation. <p> The notation studied in this paper is intended to have practical utility. Our particular desire is that this notation serve as a substrate upon which coarser-grained representations for lambda terms may be developed that are eventually used in actual implementations. We explore this issue in a companion paper <ref> [29] </ref>. One particular refinement we consider is that of eliminating the merging rules. These rules have a practical advantage in that it is only through them that substitution walks over the structure of a term can be combined. However, implementing these rules in their full generality can be cumbersome.
Reference: [30] <author> Gopalan Nadathur, Bharat Jayaraman, and Debra Sue Wilson. </author> <title> Implementation considerations for higher-order features in logic programming. </title> <type> Technical Report CS-1993-16, </type> <institution> Department of Computer Science, Duke University, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: There is, in fact, a concrete realization of the second idea: the notation developed here is actually being used in this fashion in an implementation of Prolog <ref> [30] </ref>. The remainder of this paper is organized as follows. The next section summarizes prior logical notions that are used in this paper. Section 3 reviews the de Bruijn notation for lambda terms. <p> We then use the refined notation to describe manipulations to lambda terms and to prove properties of such manipulations. It is this work that directly underlies the implementation that is being developed for Prolog <ref> [30] </ref>. Acknowledgements We are grateful to P.-L. Curien for comments on an earlier version of this paper. Suggestions from reviewers have lead to significant improvements in presentation. John Hannan and an reviewer of an early presentation of the ideas here (in [32]) made us aware of related research.
Reference: [31] <author> Gopalan Nadathur and Dale Miller. </author> <title> An overview of Prolog. </title> <editor> In Kenneth A. Bowen and Robert A. Kowalski, editors, </editor> <booktitle> Fifth International Logic Programming Conference, </booktitle> <pages> pages 810-827, </pages> <address> Seattle, Washington, August 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Our interest, however, is in a situation where lambda terms are used as a representational device. This interest is motivated primarily by implementation questions pertaining to Prolog, a logic programming language that employs the terms of a typed lambda calculus as its data structures <ref> [31] </ref>.
Reference: [32] <author> Gopalan Nadathur and Debra Sue Wilson. </author> <title> A representation of lambda terms suitable for operations on their intensions. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 341-348. </pages> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: Thus, as observed in Theorem 8.3, the rules for merging 6 The ideas described here are an outgrowth of those contained in <ref> [32] </ref>. The present exposition of these ideas has, however, been influenced by [1]. 46 environments can be omitted from our system without losing the ability to simulate fi-reduction. <p> Acknowledgements We are grateful to P.-L. Curien for comments on an earlier version of this paper. Suggestions from reviewers have lead to significant improvements in presentation. John Hannan and an reviewer of an early presentation of the ideas here (in <ref> [32] </ref>) made us aware of related research. Stimulus was provided to the first author by Mike O'Donnell and his students by their participation in an exposition of these ideas in Spring 1991. Work on this paper has been supported by NSF grants CCR-89-05825 and CCR-92-08465.
Reference: [33] <author> Michael J. O'Donnell and Robert I. Strandh. </author> <title> Towards a fully parallel implementation of the lambda calculus. </title> <type> Technical Report JHU/EECS-84/13, </type> <institution> Johns Hopkins University, </institution> <year> 1984. </year>
Reference-contexts: It is interesting to note that two indices ol and nl are needed in a term of the form [[t; ol; nl; e]] to achieve this objective; an attempt to use only one index was made in <ref> [33] </ref> but could not be carried out to completion. We also observe that our notation actually generalizes the mentioned functions by allowing for environments that represent multiple non-dummy substitutions that are to be performed simultaneously. The notation studied in this paper is intended to have practical utility.
Reference: [34] <author> Lawrence C. Paulson. </author> <title> The representation of logics in higher-order logic. </title> <type> Technical Report Number 113, </type> <institution> University of Cambridge, Computer Laboratory, </institution> <month> August </month> <year> 1987. </year>
Reference-contexts: Lambda terms have been found to be useful as data structures because of their ability to represent naturally the notion of binding that is part of the syntax of several kinds of objects <ref> [6, 23, 28, 34, 37] </ref>. Consider, for instance, the task of representing the quantified formula 8x ((p x)_ (q x)) in which p and q are predicate names.
Reference: [35] <author> Lawrence C. Paulson. </author> <title> The foundations of a generic theorem prover. </title> <type> Technical Report Number 130, </type> <institution> University of Cambridge, Computer Laboratory, </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: We believe, however, that this issue is of wider concern, given the number of computer systems and programming languages in existence today that use some variety of the lambda calculus in representing and manipulating formal objects such as formulas, programs and proofs <ref> [5, 7, 8, 15, 18, 28, 35, 36] </ref>. Lambda terms have been found to be useful as data structures because of their ability to represent naturally the notion of binding that is part of the syntax of several kinds of objects [6, 23, 28, 34, 37].
Reference: [36] <author> Frank Pfenning. </author> <title> Elf: A language for logic definition and verified metaprogramming. </title> <booktitle> In Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 313-322, </pages> <address> Pacific Grove, California, June 1989. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: We believe, however, that this issue is of wider concern, given the number of computer systems and programming languages in existence today that use some variety of the lambda calculus in representing and manipulating formal objects such as formulas, programs and proofs <ref> [5, 7, 8, 15, 18, 28, 35, 36] </ref>. Lambda terms have been found to be useful as data structures because of their ability to represent naturally the notion of binding that is part of the syntax of several kinds of objects [6, 23, 28, 34, 37].
Reference: [37] <author> Frank Pfenning and Conal Elliott. </author> <title> Higher-order abstract syntax. </title> <booktitle> In Proceedings of the ACM-SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 199-208. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1988. </year>
Reference-contexts: Lambda terms have been found to be useful as data structures because of their ability to represent naturally the notion of binding that is part of the syntax of several kinds of objects <ref> [6, 23, 28, 34, 37] </ref>. Consider, for instance, the task of representing the quantified formula 8x ((p x)_ (q x)) in which p and q are predicate names.
Reference: [38] <author> John Staples. </author> <title> A new technique for analysing parameter passing, applied to the lambda calculus. </title> <journal> Australian Computer Science Communications, </journal> <volume> 3(1) </volume> <pages> 201-210, </pages> <month> May </month> <year> 1981. </year>
Reference-contexts: A similar set of functions is described by Staples in <ref> [38] </ref>. Our notion of a suspension collapses these two functions into a common form and captures the effect of evaluating them in a delayed fashion.
Reference: [39] <author> Hirofumi Yokouchi. </author> <title> Church-Rosser Theorem for a rewriting system on categorical combinators. </title> <journal> Theoretical Computer Science, </journal> <volume> 65 </volume> <pages> 271-290, </pages> <year> 1989. </year> <month> 51 </month>
Reference-contexts: In Section 8, we utilize the projection onto de Bruijn terms to show the 3 confluence of our rewrite system. The method of proof we use is similar in spirit to that referred to as the interpretation method in [17] and used in [17] and <ref> [39] </ref> in establishing confluence properties of a combinator calculus. In the concluding section of this paper, we discuss the relationship of our work to that of others, especially that in [1] and [13]. 2 Logical preliminaries We are concerned in this paper with systems for rewriting expressions. <p> This method of argument is similar in spirit to the one referred to as the interpretation method in [17] and used in [17] and <ref> [39] </ref> in proving confluence properties of a combinator calculus. We use this method again in [29]. 9 Conclusion We have described in this paper a notation for the terms in a lambda calculus and a system for rewriting expressions in this notation. <p> Unfortunately, the rewrite rules that constitute CCL are not confluent [17]; this result might be anticipated from the fact that the lambda calculus with the pairing function is not confluent [24]. However, a subset of CCL terms can be exhibited on which the rewrite rules are confluent <ref> [17, 39] </ref>. Moreover, a subclass of this class of terms is isomorphic to the class of lambda calculus terms and this isomorphism can be extended to one between a subset of CCL rules and fi-reduction [17].
References-found: 39

