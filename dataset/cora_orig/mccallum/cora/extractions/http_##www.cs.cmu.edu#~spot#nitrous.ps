URL: http://www.cs.cmu.edu/~spot/nitrous.ps
Refering-URL: http://www.cs.cmu.edu/~spot/dag/dag.html
Root-URL: 
Title: Compiler Generation for Interactive Graphics using Intermediate Code  
Author: Scott Draves 
Web: http://www.cs.cmu.edu/spot  
Note: Home page:  
Address: 5000 Forbes Avenue, Pitsburgh, PA 15213, USA  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: This paper describes a compiler generator (cogen) designed for interactive graphics, and presents preliminary results of its application to pixel-level code. The cogen accepts and produces a reflective intermediate code in continuation-passing, closure-passing style. This allows low overhead run-time code generation as well as multi-stage compiler generation. We extend partial evaluation techniques by allowing partially static integers, conservative early equality, and unrestricted lifting. In addition to some standard examples, we examine graphics ker nels such as one-dimensional finite filtering and packed pixel access.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A V Aho, R Sethi, J D Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley 1986. </publisher>
Reference-contexts: Fig. 2. System Diagram root is a simple abstract machine code, like quad-code <ref> [1] </ref> with an unlimited number of registers but in continuation-passing closure-passing style (CPS-CPS) [3]. Thus the stack and closures are explicit data structures and all values are named uniformly.
Reference: 2. <author> Lars Ole Andersen. </author> <title> Program Analysis and Specialization for the C Programming Language. </title> <institution> DIKU 1994. </institution>
Reference-contexts: The ratio of static instructions used per dynamic instruction produced is 300 to 1000. `C [15] augments C with backquote-like syntax to support manual RTCG. It provides a nice interface to DCG, and can handle complex interpreters (eg Tiny-C). By re-targetting C-mix <ref> [2] </ref> to `C one might be able to combine the strengths of these systems (constraint-based BTA, fast code generation, a popular language). Fabius [35] is a compiler generator for a simplified first-order ML-like language. The programmer uses curry notation to specify the program division, and a BTA completes it.
Reference: 3. <author> Andrew Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press 1992. </publisher>
Reference-contexts: Fig. 2. System Diagram root is a simple abstract machine code, like quad-code [1] with an unlimited number of registers but in continuation-passing closure-passing style (CPS-CPS) <ref> [3] </ref>. Thus the stack and closures are explicit data structures and all values are named uniformly. The model includes reflection and reification [17], simple data structures, arithmetic, an open set of primitive functions, and represents higher-order values with closures. recur is a sample front end. <p> instr ! (prim v prim . args) | (const v constant) | (if v true-branch) | (jump v . args) v ! variable instrs ! instr list args ! variable list true-branch ! instrs prim ! primitive operation Fig. 3. root syntax Structured higher-order control flow is managed with closure-passing <ref> [3] </ref>. A closure pairs a code pointer with its bound variables, and is invoked by jumping to its car and passing itself as the first argument. Normal procedure call passes the stack as the next argument. The stack is just the continuation, which is represented with a closure.
Reference: 4. <author> A Bondorf, O Danvy. </author> <title> Automatic Autoprojection of Recursive Equations with Global Variables and Abstract Data Types. </title> <institution> Science of Computer Programming16:151-195. </institution>
Reference-contexts: The effect of variable splitting is that the members of a structure can be kept in several registers, instead of allocated on the heap (abstracted into one register). Inlining is controlled by the dynamic conditional heuristic <ref> [4] </ref>, but setting the special $inline variable overrides the heuristic at the next jump. In CPS-CPS continuations appear as arguments, so static contexts are naturally prop-agated. Figure 5 shows the translation of (+ S (if D 2 3)) into root. <p> However, note that the Alpha [47] doesn't support byte pointers, and DSP chips sometimes provide an addressing mode for on-chip SRAM bank, rather than a cache. This is an application of RISC philosophy (factoring from hardware into the compiler to increase the clock rate). Similix <ref> [4] </ref> is a sophisticated, freely-available compiler generator. It uses a type-inference BTA, supports higher order Scheme-like language with datatypes and an open set of prims. It supports partially static structs, simple manual lifts, and is monovariant. It produces small programs and runs fairly quickly.
Reference: 5. <author> William Clinger, Jonathan Rees. </author> <title> Revised 4 Report on the Algorithmic Language Scheme. </title> <booktitle> LISP PointersIV:1-55. </booktitle>
Reference-contexts: With these systems, one writes programs that create programs. Generating rare cases and fused, one-pass loops as needed directly addresses the program size and latency trace-offs outlined above. However, RTCG has suffered from a lack of portable, easy-to-use interfaces. Lisp's quasi-quote, Scheme's syntax-rules <ref> [5] </ref>, and parser generators such as YACC [27] automate the mechanics of constructing certain classes of programs, but it remains unclear how we can build an RTCG system that is effective on a wide-range of problems, and is automatic enough that design time and programmer effort can really be reduced.
Reference: 6. <author> Charles Consel. </author> <title> Binding Time Analysis for Higher Order Untyped Functional Languages. </title> <booktitle> ACM Conference on Lisp and Functional Programming, </booktitle> <year> 1990. </year>
Reference-contexts: Figure 7 depicts several useful examples. For example, a value with BT D list has no static value, but its shape is a list of variable names. The dynamic values are placed in registers as space permits. As in Schism <ref> [6] </ref>, control flow information appears in the binding times. cogen supports arbitrary values in the binding times, including code pointers, the empty list, and other type tags. Such a BT is denoted ( ^ const c), or just c.
Reference: 7. <author> Charles Consel. </author> <title> New Insights into Partial Evaluation: The Schism Experiment. </title> <booktitle> European Symposium on Programming, </booktitle> <year> 1988. </year>
Reference-contexts: It supports partially static structs, simple manual lifts, and is monovariant. It produces small programs and runs fairly quickly. It's file-based interface could be combined with a Scheme compiler (provided it had the right interface) to do RTCG. Schism <ref> [7] </ref> is similar but nicer. DCG [14] and [33] provide C-callable libraries for RTCG. They use typical C-compiler intermediate language for portable construction and fast compilation with `rudimentary optimization'.
Reference: 8. <author> Charles Consel, Luke Hornof, Francois Noel, Jacque Noye, Nicolae Volanschi. </author> <title> A Uniform Approach for Compile-Time and Run-Time Specialization. </title> <booktitle> Dagstuhl Workshop on Partial Evaluation, </booktitle> <year> 1996. </year>
Reference-contexts: Binding times manage program division, memoization handles circularities, and the specializer creates variable names and the rest of the mechanics of code construction. The programmer concentrates on higher-level issues such as staging and generalization. Other current attempts to apply PE to RTCG are Fabius [35] and Tempo <ref> [8] </ref>. This paper explores the application of a directly implemented compiler generator for an intermediate language to pixel-level graphics kernels. The nature of graphics loops is exploited with cyclic integers, which make the remainder (eg modulo 32) of an integer static. <p> The programmer uses curry notation to specify the program division, and a BTA completes it. This is a very natural means of annotation. The compilers produce machine code directly, thus they are very fast; its ratio is about 7. Tempo <ref> [8] </ref> is a off-line, template-based specializer for C aimed at operating systems code. It contains sophisticated pointer analyses and other features to make it work on `real' systems. So far no results are available.
Reference: 9. <author> N Dershowitz, U Reddy. </author> <title> Deductive and Inductive Synthesis of Equational Programs. </title> <journal> Journal of Symbolic Computation15:467-494. </journal>
Reference-contexts: Tempo [8] is a off-line, template-based specializer for C aimed at operating systems code. It contains sophisticated pointer analyses and other features to make it work on `real' systems. So far no results are available. Staging transformations [26], ordered rewriting <ref> [9] </ref>, program slicing [23], and metaob-ject protocols [34] contain related ideas from other parts of the language research community. 7 Conclusion and Future Directions We have described Nitrous, a run-time code generation system for interactive graphics. It uses compiler generation of intermediate code to provide sophisticated transformations with low overhead.
Reference: 10. <author> DOOM. </author> <note> id Software 1993. </note>
Reference-contexts: 1 Introduction Interactive graphics is a growing application domain where the demands of latency, bandwidth, and software engineering collide. The state of the art, represented by systems such as QuickDraw GX (R) [44], Photoshop (tm) [42], RenderMan (tm) [52], Explorer (R) [25], and DOOM (tm) <ref> [10] </ref>, is to write in C and assembly language.
Reference: 11. <author> Scott Draves. </author> <title> Lightweight Languages for Interactive Graphics. </title> <publisher> CMU-CS-95-148. </publisher>
Reference-contexts: Sections 6 and 7 place the system in context and conclude. Readers not interested in the intermediate language and its effect on cogen might read only Sections 2, 4.1, and 4.2.2 before skipping to the examples in Section 5. More discussion but few details can be found in <ref> [11] </ref>. <p> Streams always terminate with a jump instruction, which transfers control to the code bound to the first argument and passes the rest. Formal semantics can be found in <ref> [11] </ref>. code ! (code name args instrs) instr ! (prim v prim . args) | (const v constant) | (if v true-branch) | (jump v . args) v ! variable instrs ! instr list args ! variable list true-branch ! instrs prim ! primitive operation Fig. 3. root syntax Structured higher-order
Reference: 12. <author> Fnord: </author> <title> a Visualization System for Differential Geometry. </title> <institution> Brown University 1991. </institution>
Reference-contexts: Usually compile to C and run on stock hardware. dynamic linking Photoshop (tm) [42], Netscape (tm) [39]. Known as `plug-ins'. The ap plication dynamically loads code modules adhering to published interfaces. batching/buffering APL, RenderMan (tm) [52], fnord <ref> [12] </ref>. Rather than applying an in-terpreter and one program to each of many data, a batch interpreter sequences vector primitives over the data, thus reducing interpreter overhead.
Reference: 13. <author> Cellang. </author> ? <year> 1995. </year>
Reference-contexts: Provides the highest performance at the highest price with the greatest design time and least flexibility. programmable hardware DSP chips, MediaProcessor (tm) [38]. Require assembly lan guage and special tools to fully utilize them, but they can run C. application specific compilers MINT [53], Apply [20], Cellang <ref> [13] </ref>. Usually compile to C and run on stock hardware. dynamic linking Photoshop (tm) [42], Netscape (tm) [39]. Known as `plug-ins'. The ap plication dynamically loads code modules adhering to published interfaces. batching/buffering APL, RenderMan (tm) [52], fnord [12].
Reference: 14. <author> Dawson Englar, Todd Proebsting. </author> <title> DCG: An Efficient, Retargetable Dynamic Code Generation System. </title> <booktitle> ASPLOS, </booktitle> <year> 1994. </year>
Reference-contexts: It supports partially static structs, simple manual lifts, and is monovariant. It produces small programs and runs fairly quickly. It's file-based interface could be combined with a Scheme compiler (provided it had the right interface) to do RTCG. Schism [7] is similar but nicer. DCG <ref> [14] </ref> and [33] provide C-callable libraries for RTCG. They use typical C-compiler intermediate language for portable construction and fast compilation with `rudimentary optimization'. The ratio of static instructions used per dynamic instruction produced is 300 to 1000. `C [15] augments C with backquote-like syntax to support manual RTCG.
Reference: 15. <author> Dawson Engler, Wilson Hsieh, M Frans Kaashoek. </author> <title> `C: A Language for High-Level, Efficient, and Machine-independent Dynamic Code Generation. </title> <booktitle> Conference on Programming Language Design and Implementation, </booktitle> <year> 1995. </year>
Reference-contexts: Schism [7] is similar but nicer. DCG [14] and [33] provide C-callable libraries for RTCG. They use typical C-compiler intermediate language for portable construction and fast compilation with `rudimentary optimization'. The ratio of static instructions used per dynamic instruction produced is 300 to 1000. `C <ref> [15] </ref> augments C with backquote-like syntax to support manual RTCG. It provides a nice interface to DCG, and can handle complex interpreters (eg Tiny-C). By re-targetting C-mix [2] to `C one might be able to combine the strengths of these systems (constraint-based BTA, fast code generation, a popular language).
Reference: 16. <author> Foley, Feiner, Andries van Dam, John Hughes. </author> <title> Computer Graphics: </title> <booktitle> Principles and Practice. </booktitle> <publisher> Addison-Wesley 1990. </publisher>
Reference-contexts: More discussion but few details can be found in [11]. This paper assumes the reader is familiar with binding times, C compilers, LISP macros, caches, and pixels. <ref> [16] </ref> provides a good introduction to graphics and [22] to chip architecture. 2 System Overview Our system is called Nitrous; within it, we identify three kinds of program transformers (see Figure 1): front ends (traditional and generated) which produce root programs from programs in user-defined languages. a compiler generator cogen for
Reference: 17. <author> Daniel P Friedman, Mitchell Wand. </author> <title> Reification: Reflection without Metaphysics. </title> <booktitle> ACM Conference on Lisp and Functional Programming, </booktitle> <year> 1984. </year>
Reference-contexts: Fig. 2. System Diagram root is a simple abstract machine code, like quad-code [1] with an unlimited number of registers but in continuation-passing closure-passing style (CPS-CPS) [3]. Thus the stack and closures are explicit data structures and all values are named uniformly. The model includes reflection and reification <ref> [17] </ref>, simple data structures, arithmetic, an open set of primitive functions, and represents higher-order values with closures. recur is a sample front end. It is a simple recursive equations language with parallel let, if, and multi-argument procedures. The cogen-created compiler produces straightforward code.
Reference: 18. <author> R Gluck, J Jrgensen. </author> <title> Generating Optimizing Specializers. </title> <booktitle> IEEE Computer Society International Conference on Computer Languages, </booktitle> <year> 1994. </year>
Reference-contexts: The lift compiler (see Section 4.2) works this way; other possibilities include using recur to create input for cogen, or providing a compiler generator as a primitive in the recur language. Such multi-stage application requires that the generated compilers create correctly annotated programs, which can be difficult. In <ref> [18] </ref> and [19] Gluck and Jrgensen present more rigourous and automatic treatments of layered systems using specializer projections and multi-stage binding-time analysis. 3 The Intermediate Language The core of the system is the intermediate language root.
Reference: 19. <author> R Gluck, J Jrgensen. </author> <title> Efficient Multi-Level Generating Extensions for Program Specialization. </title> <booktitle> Programming Language Implementation and Logic Programming, </booktitle> <year> 1995. </year>
Reference-contexts: Such multi-stage application requires that the generated compilers create correctly annotated programs, which can be difficult. In [18] and <ref> [19] </ref> Gluck and Jrgensen present more rigourous and automatic treatments of layered systems using specializer projections and multi-stage binding-time analysis. 3 The Intermediate Language The core of the system is the intermediate language root. Its formal syntax appears in its formal parameter list is bound to the actual arguments.
Reference: 20. <author> L G C Hamey, J A Webb, I-Chien Wu. </author> <title> An Architecture Independent Programming Language for Low-Level Vision. Computer Vision, Graphics, and Image Processing48?:. </title>
Reference-contexts: Provides the highest performance at the highest price with the greatest design time and least flexibility. programmable hardware DSP chips, MediaProcessor (tm) [38]. Require assembly lan guage and special tools to fully utilize them, but they can run C. application specific compilers MINT [53], Apply <ref> [20] </ref>, Cellang [13]. Usually compile to C and run on stock hardware. dynamic linking Photoshop (tm) [42], Netscape (tm) [39]. Known as `plug-ins'. The ap plication dynamically loads code modules adhering to published interfaces. batching/buffering APL, RenderMan (tm) [52], fnord [12].
Reference: 21. <author> Fritz Henglein. </author> <title> Efficient Type Inference for Higher-Order Binding-Time Analysis. </title> <booktitle> International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <year> 1991. </year>
Reference-contexts: A compiler generator transforms an interpreter into a compiler. That is, cogen transforms a root program and binding times (BTs) for its arguments into a generating extension. The BTs categorize each argument as static program or dynamic data; essentially they are types <ref> [21] </ref>. The extension consists of a memo table, followed by the static parts of the computation interleaved with instructions that generate residual code (ie do RTCG). The backend executes root programs. We examine current and future backends in Section 5.3. By supporting reflection we make code-producing functions first class.
Reference: 22. <author> John L Hennessy, David A Patterson. </author> <title> Computer Architecture: A Quantitative Approach. </title> <publisher> Mor-gan Kaufmann 1990. </publisher>
Reference-contexts: More discussion but few details can be found in [11]. This paper assumes the reader is familiar with binding times, C compilers, LISP macros, caches, and pixels. [16] provides a good introduction to graphics and <ref> [22] </ref> to chip architecture. 2 System Overview Our system is called Nitrous; within it, we identify three kinds of program transformers (see Figure 1): front ends (traditional and generated) which produce root programs from programs in user-defined languages. a compiler generator cogen for an untyped intermediate language root. a backend for
Reference: 23. <author> Susan Horwitz, Thomas Reps. </author> <title> The Use of Program Dependence Graphs in Software Engineering. </title> <address> ICSE, </address> <year> 1992. </year>
Reference-contexts: Tempo [8] is a off-line, template-based specializer for C aimed at operating systems code. It contains sophisticated pointer analyses and other features to make it work on `real' systems. So far no results are available. Staging transformations [26], ordered rewriting [9], program slicing <ref> [23] </ref>, and metaob-ject protocols [34] contain related ideas from other parts of the language research community. 7 Conclusion and Future Directions We have described Nitrous, a run-time code generation system for interactive graphics. It uses compiler generation of intermediate code to provide sophisticated transformations with low overhead.
Reference: 24. <author> Adobe Systems, Inc. </author> <title> PostScript Language Reference Manual. </title> <publisher> Addison-Wesley 1990. </publisher>
Reference-contexts: Strip-mining and tiling [55] is necessary if the data don't fit in the cache. embedded/dynamic languages Emacs lisp [50], Tcl/Tk [40], Microsoft's Visual Ba sic (tm) [54], PostScript (tm) <ref> [24] </ref>, ScriptX [45], etc. The dynamic language sequences routines implemented with a static languages. Hardware support for byte-pointers and an on-chip cache have similar effect as our loop optimizations (the hardware repeats the computation, but the hardware is very fast).
Reference: 25. <author> IRIS Explorer. </author> <title> Numerical Algorithms Group, </title> <publisher> Ltd 1995. </publisher>
Reference-contexts: 1 Introduction Interactive graphics is a growing application domain where the demands of latency, bandwidth, and software engineering collide. The state of the art, represented by systems such as QuickDraw GX (R) [44], Photoshop (tm) [42], RenderMan (tm) [52], Explorer (R) <ref> [25] </ref>, and DOOM (tm) [10], is to write in C and assembly language.
Reference: 26. <author> Ulric Jrring, William Scherlis. </author> <title> Compilers and Staging Transformations. </title> <booktitle> Principles of Programming Languages, </booktitle> <year> 1986. </year>
Reference-contexts: Tempo [8] is a off-line, template-based specializer for C aimed at operating systems code. It contains sophisticated pointer analyses and other features to make it work on `real' systems. So far no results are available. Staging transformations <ref> [26] </ref>, ordered rewriting [9], program slicing [23], and metaob-ject protocols [34] contain related ideas from other parts of the language research community. 7 Conclusion and Future Directions We have described Nitrous, a run-time code generation system for interactive graphics.
Reference: 27. <author> Stephen C Johnson. </author> <title> YACC Yet Another Compiler-Compiler. </title> <institution> Bell Labs 1975. </institution>
Reference-contexts: Generating rare cases and fused, one-pass loops as needed directly addresses the program size and latency trace-offs outlined above. However, RTCG has suffered from a lack of portable, easy-to-use interfaces. Lisp's quasi-quote, Scheme's syntax-rules [5], and parser generators such as YACC <ref> [27] </ref> automate the mechanics of constructing certain classes of programs, but it remains unclear how we can build an RTCG system that is effective on a wide-range of problems, and is automatic enough that design time and programmer effort can really be reduced.
Reference: 28. <author> N Jones, C K Gomard, P Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice-Hall 1993. </publisher>
Reference-contexts: Partial evaluation (PE) as described in <ref> [28] </ref> is a semantics-based program transfor-mation. With the cogen approach the programmer can type-check and debug a one-stage interpreter, then by annotation and tweeking, produce an efficient two-stage procedure (a compiler).
Reference: 29. <editor> Simon L Peyton Jones. </editor> <booktitle> The Implementation of Functional Programming Languages. Prentice-Hall 1987. </booktitle>
Reference-contexts: And against: 1) types would simplify the implementation and formalization; 2) good loops (eg PC-relative addressing) are difficult to produce; 3) explicit stacks and exceptions would reduce consistency requirements and make optimization easier; 4) using a language like GCC [49], OmniVM [48], or the G-machine <ref> [29] </ref> would leverage existing research. 4 The Compiler Generator cogen is directly implemented (rather than produced by self-application), polyvariant (allows multiple binding time patterns per source procedure), handles higher-order control flow, and is based on abstract interpretation. This section summarizes how cogen and its extensions work, in theory and practice.
Reference: 30. <author> Richard Kelsey, Jonathan Rees. </author> <title> A Tractable Scheme Implementation. </title> <booktitle> Lisp and Symbolic Computation?:?. </booktitle>
Reference-contexts: This example was the motivation for the late normalization described above. The address p is kept premultiplied to avoid a dynamic multiplication when it is lifted at every load. 5.3 Implementation, Backend, and Benchmarks cogen is written in Scheme48 <ref> [30] </ref>, which compiles an extended Scheme to bytecode 4 . cogen is 2000 lines, supported by 4000 lines of utilities, the virutal root backend, the compiler to GCC, examples, test cases, etc. It has not yet been optimized for speed (eg it doesn't use hashing or union-find).
Reference: 31. <author> Richard Kelsey. Pre-Scheme: </author> <title> A Scheme Dialect for Systems Programming. </title> ?. 
Reference-contexts: It has not yet been optimized for speed (eg it doesn't use hashing or union-find). The source code and transcripts of sample runs are available from http://www.cs.cmu.edu/ spot/nitrous.html. 4 In fact the bytecode interpreter is written in Pre-Scheme <ref> [31] </ref> and compiled to C. stride = S; kernel = S p = cyc; q = D; klen = S while (p) f dp = dot (0 p kernel klen) store word (q dp) p -= stride q-- dot (sum i j n) f while (n--) sum += load-word c (i++)
Reference: 32. <author> D Keppel, S J Eggers, R R Henry. </author> <title> A Case for Runtime Code Generation. </title> <publisher> UW-CSE-91-11-04. </publisher>
Reference-contexts: Run-time code generation (RTCG), as exemplified by Common LISP [51], Pike's Blit terminal [43], Masselin's Synthesis operating system [36], researchers at the University of Washington <ref> [32] </ref>, and elsewhere [14][35] is one way to attack this problem. With these systems, one writes programs that create programs. Generating rare cases and fused, one-pass loops as needed directly addresses the program size and latency trace-offs outlined above. However, RTCG has suffered from a lack of portable, easy-to-use interfaces.
Reference: 33. <author> D Keppel, S J Eggers, R R Henry. </author> <title> Evaluating Runtime-Compiled Value-Specific Optimizations. </title> <publisher> UW-CSE-91-11-04. </publisher>
Reference-contexts: It supports partially static structs, simple manual lifts, and is monovariant. It produces small programs and runs fairly quickly. It's file-based interface could be combined with a Scheme compiler (provided it had the right interface) to do RTCG. Schism [7] is similar but nicer. DCG [14] and <ref> [33] </ref> provide C-callable libraries for RTCG. They use typical C-compiler intermediate language for portable construction and fast compilation with `rudimentary optimization'. The ratio of static instructions used per dynamic instruction produced is 300 to 1000. `C [15] augments C with backquote-like syntax to support manual RTCG.
Reference: 34. <author> Gregor Kiczales. </author> <title> Towards a New Model of Abstraction in the Engineering of Software. </title> <address> IMSA, </address> <year> 1992. </year>
Reference-contexts: Tempo [8] is a off-line, template-based specializer for C aimed at operating systems code. It contains sophisticated pointer analyses and other features to make it work on `real' systems. So far no results are available. Staging transformations [26], ordered rewriting [9], program slicing [23], and metaob-ject protocols <ref> [34] </ref> contain related ideas from other parts of the language research community. 7 Conclusion and Future Directions We have described Nitrous, a run-time code generation system for interactive graphics. It uses compiler generation of intermediate code to provide sophisticated transformations with low overhead.
Reference: 35. <author> Mark Leone, Peter Lee. </author> <title> Lightweight Run-Time Code Generation. Partial Evaluation and Semantics-Based Program Manipulation, </title> <year> 1994. </year>
Reference-contexts: Binding times manage program division, memoization handles circularities, and the specializer creates variable names and the rest of the mechanics of code construction. The programmer concentrates on higher-level issues such as staging and generalization. Other current attempts to apply PE to RTCG are Fabius <ref> [35] </ref> and Tempo [8]. This paper explores the application of a directly implemented compiler generator for an intermediate language to pixel-level graphics kernels. The nature of graphics loops is exploited with cyclic integers, which make the remainder (eg modulo 32) of an integer static. <p> It provides a nice interface to DCG, and can handle complex interpreters (eg Tiny-C). By re-targetting C-mix [2] to `C one might be able to combine the strengths of these systems (constraint-based BTA, fast code generation, a popular language). Fabius <ref> [35] </ref> is a compiler generator for a simplified first-order ML-like language. The programmer uses curry notation to specify the program division, and a BTA completes it. This is a very natural means of annotation. The compilers produce machine code directly, thus they are very fast; its ratio is about 7.
Reference: 36. <author> Henry Massalin. </author> <title> Efficient Implementation of Fundamental Operating System Services. </title> <address> Columbia 1992. </address>
Reference-contexts: Run-time code generation (RTCG), as exemplified by Common LISP [51], Pike's Blit terminal [43], Masselin's Synthesis operating system <ref> [36] </ref>, researchers at the University of Washington [32], and elsewhere [14][35] is one way to attack this problem. With these systems, one writes programs that create programs. Generating rare cases and fused, one-pass loops as needed directly addresses the program size and latency trace-offs outlined above.
Reference: 37. <author> Torben Mogensen. </author> <title> Binding Time Aspects of Partial Evaluation. </title> <institution> DIKU 1989. </institution>
Reference-contexts: Fig. 6. Lattice Order. ( ^ const c)@S@cyc@D cogen's binding-time lattice appears in Figure 6. Cons cells are handled with graph grammars as in Mogensen <ref> [37] </ref>: pairs in binding times are labeled with a `cons point'. If the same label appears on a pair and a descendant of that pair then the graph is collapsed, perhaps forming a circularity. An annotation may provide the label, much like a type declaration.
Reference: 38. <author> John Moussouris, Craig Hansen. </author> <title> Architecture of a Broadband Media Processor. Microprocessor Forum?:?. </title>
Reference-contexts: First, we list the standard approaches to the generality/performance trade-off with a collection of examples of each. custom hardware Blitters, MPEG codec chips. Provides the highest performance at the highest price with the greatest design time and least flexibility. programmable hardware DSP chips, MediaProcessor (tm) <ref> [38] </ref>. Require assembly lan guage and special tools to fully utilize them, but they can run C. application specific compilers MINT [53], Apply [20], Cellang [13]. Usually compile to C and run on stock hardware. dynamic linking Photoshop (tm) [42], Netscape (tm) [39]. Known as `plug-ins'.
Reference: 39. <institution> Netscape Navigator. Netscape Communications Corporation 1995. </institution>
Reference-contexts: Require assembly lan guage and special tools to fully utilize them, but they can run C. application specific compilers MINT [53], Apply [20], Cellang [13]. Usually compile to C and run on stock hardware. dynamic linking Photoshop (tm) [42], Netscape (tm) <ref> [39] </ref>. Known as `plug-ins'. The ap plication dynamically loads code modules adhering to published interfaces. batching/buffering APL, RenderMan (tm) [52], fnord [12]. Rather than applying an in-terpreter and one program to each of many data, a batch interpreter sequences vector primitives over the data, thus reducing interpreter overhead.
Reference: 40. <author> John Ousterhout. </author> <title> Tcl and the Tk Toolkit. </title> <publisher> Addison-Wesley 1994. </publisher>
Reference-contexts: Rather than applying an in-terpreter and one program to each of many data, a batch interpreter sequences vector primitives over the data, thus reducing interpreter overhead. Strip-mining and tiling [55] is necessary if the data don't fit in the cache. embedded/dynamic languages Emacs lisp [50], Tcl/Tk <ref> [40] </ref>, Microsoft's Visual Ba sic (tm) [54], PostScript (tm) [24], ScriptX [45], etc. The dynamic language sequences routines implemented with a static languages. Hardware support for byte-pointers and an on-chip cache have similar effect as our loop optimizations (the hardware repeats the computation, but the hardware is very fast).
Reference: 41. <author> Frank Pfenning. </author> <title> Logic Programming in the LF Logical Framework. Logical Frameworks, </title> <year> 1991. </year>
Reference-contexts: While the preliminary results from the graphics kernels are promising, the front and backend are still too incomplete to conclusively demonstrate the utility of this approach. Besides the immediate goals of fleshing out the system and scaling up the experiments, we hope to formalize the binding-time lattice in Elf <ref> [41] </ref> and develop a constraint based analy sis. merge the static and shape environments, if possible. reduce unnecessary memoization. reduce the size of the extensions by improving lifting. return to self-application. bootstrap the system by compiling the experiments (and ultimately itself) with a generated compiler. when shape un/lifting data, use vectors
Reference: 42. <author> PhotoShop 3.0. </author> <title> Adobe Systems, </title> <publisher> Inc 1995. </publisher>
Reference-contexts: 1 Introduction Interactive graphics is a growing application domain where the demands of latency, bandwidth, and software engineering collide. The state of the art, represented by systems such as QuickDraw GX (R) [44], Photoshop (tm) <ref> [42] </ref>, RenderMan (tm) [52], Explorer (R) [25], and DOOM (tm) [10], is to write in C and assembly language. <p> Require assembly lan guage and special tools to fully utilize them, but they can run C. application specific compilers MINT [53], Apply [20], Cellang [13]. Usually compile to C and run on stock hardware. dynamic linking Photoshop (tm) <ref> [42] </ref>, Netscape (tm) [39]. Known as `plug-ins'. The ap plication dynamically loads code modules adhering to published interfaces. batching/buffering APL, RenderMan (tm) [52], fnord [12].
Reference: 43. <author> Rob Pike, Bart Locanthi, John Reiser. </author> <title> Hardware/Software Trade-offs for Bitmap Graphics on the Blit. </title> <journal> Software-Practice and Experience15:131-151. </journal>
Reference-contexts: Run-time code generation (RTCG), as exemplified by Common LISP [51], Pike's Blit terminal <ref> [43] </ref>, Masselin's Synthesis operating system [36], researchers at the University of Washington [32], and elsewhere [14][35] is one way to attack this problem. With these systems, one writes programs that create programs.
Reference: 44. <institution> QuickDraw GX. Apple Computer, Inc 1995. </institution>
Reference-contexts: 1 Introduction Interactive graphics is a growing application domain where the demands of latency, bandwidth, and software engineering collide. The state of the art, represented by systems such as QuickDraw GX (R) <ref> [44] </ref>, Photoshop (tm) [42], RenderMan (tm) [52], Explorer (R) [25], and DOOM (tm) [10], is to write in C and assembly language.
Reference: 45. <institution> ScriptX. Kaleida Labs, Inc 1995. </institution>
Reference-contexts: Strip-mining and tiling [55] is necessary if the data don't fit in the cache. embedded/dynamic languages Emacs lisp [50], Tcl/Tk [40], Microsoft's Visual Ba sic (tm) [54], PostScript (tm) [24], ScriptX <ref> [45] </ref>, etc. The dynamic language sequences routines implemented with a static languages. Hardware support for byte-pointers and an on-chip cache have similar effect as our loop optimizations (the hardware repeats the computation, but the hardware is very fast).
Reference: 46. <author> Jay M Sipelstein, Guy E Blelloch. </author> <booktitle> Collection-Oriented Languages. Proceedings of the IEEE?:?. </booktitle>
Reference-contexts: The state of the art, represented by systems such as QuickDraw GX (R) [44], Photoshop (tm) [42], RenderMan (tm) [52], Explorer (R) [25], and DOOM (tm) [10], is to write in C and assembly language. Programmers use hand-specialized routines, buffering, collection-oriented languages <ref> [46] </ref>, and embedded/dynamic languages, but inevitably we face trade-offs in program size Large libraries with many specialized but infrequently used routines waste space. latency and memory Using larger batches/buffers reduces interpreter overhead but in creases latency and memory traffic. design time Optimization requires time and planning that are unavailable to exploratory
Reference: 47. <author> Richard L Sites. </author> <title> Alpha AXP architecture. </title> <publisher> CACM36:?. </publisher>
Reference-contexts: The dynamic language sequences routines implemented with a static languages. Hardware support for byte-pointers and an on-chip cache have similar effect as our loop optimizations (the hardware repeats the computation, but the hardware is very fast). However, note that the Alpha <ref> [47] </ref> doesn't support byte pointers, and DSP chips sometimes provide an addressing mode for on-chip SRAM bank, rather than a cache. This is an application of RISC philosophy (factoring from hardware into the compiler to increase the clock rate). Similix [4] is a sophisticated, freely-available compiler generator.
Reference: 48. <author> Colusa Software. Omniware: </author> <title> A Universal Substrate for Mobile Code. </title> <note> WWW, 1995. </note>
Reference-contexts: And against: 1) types would simplify the implementation and formalization; 2) good loops (eg PC-relative addressing) are difficult to produce; 3) explicit stacks and exceptions would reduce consistency requirements and make optimization easier; 4) using a language like GCC [49], OmniVM <ref> [48] </ref>, or the G-machine [29] would leverage existing research. 4 The Compiler Generator cogen is directly implemented (rather than produced by self-application), polyvariant (allows multiple binding time patterns per source procedure), handles higher-order control flow, and is based on abstract interpretation.
Reference: 49. <author> R M Stallman. </author> <title> Using and Porting GNU CC. Free Software Foundation 1989. </title>
Reference-contexts: And against: 1) types would simplify the implementation and formalization; 2) good loops (eg PC-relative addressing) are difficult to produce; 3) explicit stacks and exceptions would reduce consistency requirements and make optimization easier; 4) using a language like GCC <ref> [49] </ref>, OmniVM [48], or the G-machine [29] would leverage existing research. 4 The Compiler Generator cogen is directly implemented (rather than produced by self-application), polyvariant (allows multiple binding time patterns per source procedure), handles higher-order control flow, and is based on abstract interpretation. <p> I am budgeting about 2000 instructions to produce each dynamic instruction. The backend used to produce these benchmarks translates a whole root program to a single GCC <ref> [49] </ref> function which is compiled, run, and timed using ordinary Unix (tm) tools. The run-time is just 350 lines of C and does not support garbage collection. These times are on a 486DX4/75 running linux (x86), and a 150Mhz R4400 SGI Indy (mips).
Reference: 50. <author> Richard Stallman. </author> <title> GNU Emacs Manual. Free Software Foundation 1987. </title>
Reference-contexts: Rather than applying an in-terpreter and one program to each of many data, a batch interpreter sequences vector primitives over the data, thus reducing interpreter overhead. Strip-mining and tiling [55] is necessary if the data don't fit in the cache. embedded/dynamic languages Emacs lisp <ref> [50] </ref>, Tcl/Tk [40], Microsoft's Visual Ba sic (tm) [54], PostScript (tm) [24], ScriptX [45], etc. The dynamic language sequences routines implemented with a static languages.
Reference: 51. <author> Guy Steele. </author> <title> Common Lisp the Language. </title> <publisher> Digital Press 1990. </publisher>
Reference-contexts: Run-time code generation (RTCG), as exemplified by Common LISP <ref> [51] </ref>, Pike's Blit terminal [43], Masselin's Synthesis operating system [36], researchers at the University of Washington [32], and elsewhere [14][35] is one way to attack this problem. With these systems, one writes programs that create programs.
Reference: 52. <author> Steve Upstill. </author> <title> The RenderMan Companion: A Programmer's Guide to Realistic Computer Graphics. </title> <publisher> Addison-Wesley 1989. </publisher>
Reference-contexts: 1 Introduction Interactive graphics is a growing application domain where the demands of latency, bandwidth, and software engineering collide. The state of the art, represented by systems such as QuickDraw GX (R) [44], Photoshop (tm) [42], RenderMan (tm) <ref> [52] </ref>, Explorer (R) [25], and DOOM (tm) [10], is to write in C and assembly language. <p> Usually compile to C and run on stock hardware. dynamic linking Photoshop (tm) [42], Netscape (tm) [39]. Known as `plug-ins'. The ap plication dynamically loads code modules adhering to published interfaces. batching/buffering APL, RenderMan (tm) <ref> [52] </ref>, fnord [12]. Rather than applying an in-terpreter and one program to each of many data, a batch interpreter sequences vector primitives over the data, thus reducing interpreter overhead.
Reference: 53. <author> J E Veenstra, R J Fowler. MINT: </author> <title> a front end for efficient simulation of shared-memory multiprocessors. </title> <booktitle> Modeling and Simulation of Computers and Tlecommunications Systems, </booktitle> <year> 1994. </year>
Reference-contexts: Provides the highest performance at the highest price with the greatest design time and least flexibility. programmable hardware DSP chips, MediaProcessor (tm) [38]. Require assembly lan guage and special tools to fully utilize them, but they can run C. application specific compilers MINT <ref> [53] </ref>, Apply [20], Cellang [13]. Usually compile to C and run on stock hardware. dynamic linking Photoshop (tm) [42], Netscape (tm) [39]. Known as `plug-ins'. The ap plication dynamically loads code modules adhering to published interfaces. batching/buffering APL, RenderMan (tm) [52], fnord [12].
Reference: 54. <institution> Visual Basic v3.0 for Windows. Microsoft 1995. </institution>
Reference-contexts: Strip-mining and tiling [55] is necessary if the data don't fit in the cache. embedded/dynamic languages Emacs lisp [50], Tcl/Tk [40], Microsoft's Visual Ba sic (tm) <ref> [54] </ref>, PostScript (tm) [24], ScriptX [45], etc. The dynamic language sequences routines implemented with a static languages. Hardware support for byte-pointers and an on-chip cache have similar effect as our loop optimizations (the hardware repeats the computation, but the hardware is very fast).
Reference: 55. <author> Michael Wolf, Monica Lam. </author> <title> A Data Locality Optimizing Algorithm. </title> <booktitle> Conference on Programming Language Design and Implementation, </booktitle> <year> 1991. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: The ap plication dynamically loads code modules adhering to published interfaces. batching/buffering APL, RenderMan (tm) [52], fnord [12]. Rather than applying an in-terpreter and one program to each of many data, a batch interpreter sequences vector primitives over the data, thus reducing interpreter overhead. Strip-mining and tiling <ref> [55] </ref> is necessary if the data don't fit in the cache. embedded/dynamic languages Emacs lisp [50], Tcl/Tk [40], Microsoft's Visual Ba sic (tm) [54], PostScript (tm) [24], ScriptX [45], etc. The dynamic language sequences routines implemented with a static languages.
References-found: 55

