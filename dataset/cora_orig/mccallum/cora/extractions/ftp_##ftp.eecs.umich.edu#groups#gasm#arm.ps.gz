URL: ftp://ftp.eecs.umich.edu/groups/gasm/arm.ps.gz
Refering-URL: http://www.eecs.umich.edu/gasm/arch.html
Root-URL: http://www.eecs.umich.edu
Title: Specification and Verification of Pipelining in the ARM2 RISC Microprocessor  
Author: James K. Huggins David Van Campenhout 
Date: August 14, 1998  
Address: Flint, Michigan  Ann Arbor, Michigan  
Affiliation: Kettering University  University of Michigan  
Abstract: Gurevich Abstract State Machines (ASMs) provide a sound mathematical basis for the specification and verification of systems. An application of the ASM methodology to the verification of a pipelined microprocessor (an ARM2 implementation) is described. Both the sequential execution model and final pipelined model are formalized using ASMs. A series of intermediate models are introduced that gradually expose the complications of pipelining. The first intermediate model is proven equivalent to the sequential model in the absence of structural, control, and data hazards. In the following steps, these simplifying assumptions are lifted one by one, and the original proof is refined to establish the equivalence of each intermediate model with the sequential model, leading ultimately to a full proof of equivalence of the sequential and pipelined models. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B orger, E., and Huggins, J. K. </author> <title> Abstract State Machines 1988-1998: Commented ASM Bibliography. </title> <journal> Bulletin of EATCS 64 (Feb. </journal> <year> 1998), </year> <pages> 105-127. </pages>
Reference-contexts: ASMs have been applied to a wide variety of software and hardware systems: programming languages, distributed protocols, architectures, and so on. See <ref> [1, 10] </ref> for numerous examples. In this paper we apply the ASM methodology to the verification of a pipelined implementation of the ARM2 microprocessor (hereafter ARM). The ARM is an early commercial RISC microprocessor [16, 3]. <p> Based upon this thesis, members of the ASM community have sought to develop a methodology based upon mathematics which would allow such systems to be modeled naturally; that is, described at their natural abstraction levels. See <ref> [1, 10] </ref> for a number of examples of ASMs applied to various real-world systems. Sequential ASMs (under their former name, evolving algebras) are described in [5]; a more detailed description of ASMs (including distributed characteristics) is given in [6].
Reference: [2] <author> B orger, E., and Mazzanti, S. </author> <title> A practical method for rigorously controllable hardware design. In ZUM'97: The Z Formal Specification Notation: </title> <booktitle> 10th International Conference of Z Users (1997), </booktitle> <editor> J. Bowen, M. Hinchey, and D. Till, Eds., </editor> <booktitle> Springer Lecture Notes in Computer Science 1212, </booktitle> <pages> pp. 151-187. </pages>
Reference-contexts: The induction hypothesis is derived automatically and is checked automatically with a validity checker [12]. Once a proper description of the pipelined and sequential model in terms of uninterpreted functions has been written, the method is highly automatic. Borger and Mazzanti <ref> [2] </ref> applied the ASM methodology for the first time to microprocessor verification. They proved the correctness of a pipelined version of the DLX processor [8] with respect to the sequential specification.
Reference: [3] <author> Furber, S. B. </author> <title> VLSI RISC architecture and organization. </title> <editor> M. </editor> <publisher> Dekker, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: See [1, 10] for numerous examples. In this paper we apply the ASM methodology to the verification of a pipelined implementation of the ARM2 microprocessor (hereafter ARM). The ARM is an early commercial RISC microprocessor <ref> [16, 3] </ref>. Key features of this processor include a load/store architecture, a 32-bit datapath, conditional execution of every instruction, and a small but powerful instruction set. Our starting point is a register transfer level description of the pipelined implementation and a textual description of the instruction set architecture (sequential model).
Reference: [4] <author> Gurevich, Y. </author> <booktitle> Logic and the challenge of computer science. In Current Trends in Theoretical Computer Science, </booktitle> <editor> E. Borger, Ed. </editor> <publisher> Computer Science Press, </publisher> <year> 1988, </year> <pages> pp. 1-57. </pages>
Reference-contexts: 1 Introduction The Gurevich Abstract State Machine (ASM) methodology, formerly known as the evolving algebra methodology and first proposed in <ref> [4] </ref>, is a simple yet powerful methodology for specifying and verifying software and hardware systems. ASMs have been applied to a wide variety of software and hardware systems: programming languages, distributed protocols, architectures, and so on. See [1, 10] for numerous examples.
Reference: [5] <author> Gurevich, Y. </author> <title> Evolving algebras: An attempt to discover semantics. </title> <booktitle> In Current Trends in Theoretical Computer Science, </booktitle> <editor> G. Rozenberg and A. Salomaa, Eds. </editor> <publisher> World Scientific, </publisher> <year> 1993, </year> <pages> pp. 266-292. </pages> <note> (First published in Bulletin of EATCS 43 (Feb.), 264-284.). </note>
Reference-contexts: See [1, 10] for a number of examples of ASMs applied to various real-world systems. Sequential ASMs (under their former name, evolving algebras) are described in <ref> [5] </ref>; a more detailed description of ASMs (including distributed characteristics) is given in [6]. We present here only those features of sequential ASMs necessary to understand this paper.
Reference: [6] <author> Gurevich, Y. </author> <title> Evolving algebras 1993: Lipari guide. In Specification and Validation Methods, </title> <editor> E. Borger, Ed. </editor> <publisher> Oxford University Press, </publisher> <year> 1995, </year> <pages> pp. 9-36. </pages>
Reference-contexts: See [1, 10] for a number of examples of ASMs applied to various real-world systems. Sequential ASMs (under their former name, evolving algebras) are described in [5]; a more detailed description of ASMs (including distributed characteristics) is given in <ref> [6] </ref>. We present here only those features of sequential ASMs necessary to understand this paper.
Reference: [7] <author> Gurevich, Y. Platonism, </author> <title> constructivism, and computer proofs vs. proofs by hand. </title> <journal> Bulletin of EATCS 47 (Oct. </journal> <year> 1995), </year> <pages> 145-166. </pages>
Reference-contexts: Machine-verified proofs are certainly of great value; it may be more difficult, however, for readers to understand a machine-oriented proof than a human-oriented proof (since a different audience is addressed by such a proof) <ref> [7] </ref>. There is no automated proof assistant specifically designed for ASMs; however, ASM specifications have been used as the starting point for mechanical verification using proof assistants such as KIV [15], PVS [18], and SMV [17].
Reference: [8] <author> Hennessy, J., and Patterson, D. </author> <title> Computer Architecture: A quantitative Approach. </title> <publisher> Morgan Kauf-man Publishers, </publisher> <address> San Mateo, Calif., </address> <year> 1990. </year> <note> Revised second edition, </note> <year> 1996. </year>
Reference-contexts: Borger and Mazzanti [2] applied the ASM methodology for the first time to microprocessor verification. They proved the correctness of a pipelined version of the DLX processor <ref> [8] </ref> with respect to the sequential specification. The overall structure of the approach is similar to our work, although the architecture and the micro-architecture (pipeline) of the DLX and the ARM differ significantly.
Reference: [9] <author> Hooman, J. </author> <title> Using PVS for an assertional verification of the RPC-memory specification problem. In Formal Systems Specification; The RPC-Memory Specification Case Study. </title> <booktitle> Springer Lecture Notes in Computer Science 1169, </booktitle> <year> 1996, </year> <pages> pp. 275-304. </pages>
Reference-contexts: In fact, when using certain interactive proof assistants such as PVS, it is often important to have a clear outline of the proof before beginning verification <ref> [9] </ref>; a hand-oriented specification and proof such as that presented here more than fulfills that need. Conclusion We applied the ASM methodology to the verification of a pipelined microprocessor, the ARM.
Reference: [10] <author> Huggins, J. K., Ed. </author> <title> Abstract State Machine Home Page. </title> <institution> EECS Department, University of Michigan, </institution> <note> http://www.eecs.umich.edu/gasm/, 1998. </note>
Reference-contexts: ASMs have been applied to a wide variety of software and hardware systems: programming languages, distributed protocols, architectures, and so on. See <ref> [1, 10] </ref> for numerous examples. In this paper we apply the ASM methodology to the verification of a pipelined implementation of the ARM2 microprocessor (hereafter ARM). The ARM is an early commercial RISC microprocessor [16, 3]. <p> Based upon this thesis, members of the ASM community have sought to develop a methodology based upon mathematics which would allow such systems to be modeled naturally; that is, described at their natural abstraction levels. See <ref> [1, 10] </ref> for a number of examples of ASMs applied to various real-world systems. Sequential ASMs (under their former name, evolving algebras) are described in [5]; a more detailed description of ASMs (including distributed characteristics) is given in [6].
Reference: [11] <author> Huggins, J. K., and Van Campenhout, D. </author> <title> Specification and verification of pipelining in the ARM2 RISC microprocessor. </title> <booktitle> In Digest IEEE Int. High Level Design Validation and Test Workshop (1997), </booktitle> <pages> pp. 186-193. </pages>
Reference-contexts: Section 3 introduces the ARM microprocessor in greater detail. In section 4 we present the ASM of a non-pipelined version of fl A version of this paper was presented in <ref> [11] </ref> at the 1997 IEEE International High Level Design Validation and Test Workshop, Oakland, California, November 14-15, 1997. y J. K. Huggins was partially supported by ONR grant N00014-94-1-1182 and NSF grant CCR-95-04375. z D.
Reference: [12] <author> Jones, R., Dill, D., and Burch, J. </author> <title> Efficient validity checking for processor verification. </title> <booktitle> In IEEE International Conference on Computer Aided Design (Nov. </booktitle> <year> 1995), </year> <pages> pp. 2-6. </pages>
Reference-contexts: In each iteration, the equivalence between the old pipeline and the new pipeline is proved. As in our work, the proof is by induction on the number of execution cycles. The induction hypothesis is derived automatically and is checked automatically with a validity checker <ref> [12] </ref>. Once a proper description of the pipelined and sequential model in terms of uninterpreted functions has been written, the method is highly automatic. Borger and Mazzanti [2] applied the ASM methodology for the first time to microprocessor verification.
Reference: [13] <author> Levitt, J., and Olukotun, K. </author> <title> Scalable formal verification methodology for pipelined microprocessors. </title> <booktitle> In 33rd ACM/IEEE Design Automation Conference (1996), </booktitle> <pages> pp. 558-563. </pages>
Reference-contexts: These methods also tend to fail on real-life sized systems unless an abstracted system model is used, which often must be derived manually. On the opposite end, there are methods that require substantial user assistance, but offer richer expressiveness and facilitate hierarchical analysis. Levitt and Olukotun <ref> [13] </ref> proposed a methodology for verifying pipelined processors. The datapath functional units are assumed to be correct and are represented by uninterpreted functions. The methodology iteratively merges the two deepest pipeline stages until the sequential model is obtained.
Reference: [14] <author> McFarland, M. C. </author> <title> Formal verification of sequential hardware. a tutorial. </title> <journal> IEEE Transactions on Computer-Aided Design 12 (May 1993), </journal> <pages> 633-654. </pages>
Reference-contexts: The complete set of rules of E 6 are given in Appendix 7. The universes that appear in E 6 are listed in Table 1. 7 Discussion Automated formal verification for microprocessors has become a popular area of research. The spectrum of methods <ref> [14] </ref> can be characterized as follows. On the one end, there are highly automated methods whose power is limited in the type of properties that can be expressed and handled.
Reference: [15] <author> Schellhorn, G., and Ahrendt, W. </author> <title> Reasoning about abstract state machines: The WAM case study. </title> <journal> Journal of Universal Computer Science 3, </journal> <volume> 4 (1997), </volume> <pages> 377-413. </pages>
Reference-contexts: There is no automated proof assistant specifically designed for ASMs; however, ASM specifications have been used as the starting point for mechanical verification using proof assistants such as KIV <ref> [15] </ref>, PVS [18], and SMV [17]. In fact, when using certain interactive proof assistants such as PVS, it is often important to have a clear outline of the proof before beginning verification [9]; a hand-oriented specification and proof such as that presented here more than fulfills that need.
Reference: [16] <author> VLSI Technology, I. </author> <title> Acorn RISC machine (ARM) family data manual. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Clifs, N.J., </address> <year> 1990. </year>
Reference-contexts: See [1, 10] for numerous examples. In this paper we apply the ASM methodology to the verification of a pipelined implementation of the ARM2 microprocessor (hereafter ARM). The ARM is an early commercial RISC microprocessor <ref> [16, 3] </ref>. Key features of this processor include a load/store architecture, a 32-bit datapath, conditional execution of every instruction, and a small but powerful instruction set. Our starting point is a register transfer level description of the pipelined implementation and a textual description of the instruction set architecture (sequential model). <p> We formalize the sequential model in an ASM called E 1 . The ASM was derived from the textual instruction set architecture (ISA) <ref> [16] </ref>. Anticipating the pipelined implementation, the processing of each instruction is divided into three stages: fetch, decode, and execute. We also make use of certain intermediate registers that cannot be found in the ISA description. The ASM can be seen as an interpreter for the ARM instruction set.
Reference: [17] <author> Winter, K. </author> <title> Model checking for abstract state machines. </title> <journal> Journal of Universal Computer Science 3, </journal> <volume> 5 (1997), </volume> <pages> 689-701. </pages>
Reference-contexts: There is no automated proof assistant specifically designed for ASMs; however, ASM specifications have been used as the starting point for mechanical verification using proof assistants such as KIV [15], PVS [18], and SMV <ref> [17] </ref>. In fact, when using certain interactive proof assistants such as PVS, it is often important to have a clear outline of the proof before beginning verification [9]; a hand-oriented specification and proof such as that presented here more than fulfills that need.
Reference: [18] <author> Zimmerman, W., and Gaul, T. </author> <title> On the construction of correct compiler back-ends: An ASM approach. </title> <journal> Journal of Universal Computer Science 3, </journal> <volume> 5 (1997), </volume> <pages> 504-567. </pages> <month> CSE-TR-371-98: </month> <title> Specification and Verification of Pipelining in the ARM2 RISC Microprocessor 33 </title>
Reference-contexts: There is no automated proof assistant specifically designed for ASMs; however, ASM specifications have been used as the starting point for mechanical verification using proof assistants such as KIV [15], PVS <ref> [18] </ref>, and SMV [17]. In fact, when using certain interactive proof assistants such as PVS, it is often important to have a clear outline of the proof before beginning verification [9]; a hand-oriented specification and proof such as that presented here more than fulfills that need.
References-found: 18

