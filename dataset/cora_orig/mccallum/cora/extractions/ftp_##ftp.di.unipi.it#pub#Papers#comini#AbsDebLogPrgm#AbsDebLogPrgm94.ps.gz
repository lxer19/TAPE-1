URL: ftp://ftp.di.unipi.it/pub/Papers/comini/AbsDebLogPrgm/AbsDebLogPrgm94.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Title: Abstract Debugging of Logic Programs  
Author: Marco Comini Giorgio Levi and Giuliana Vitiello 
Address: Pisa, Corso Italia 40, 56125 Pisa, Italy  
Affiliation: 1 Dipartimento di Informatica, Universita di  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> K. R. Apt. </author> <title> Introduction to Logic Programming. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, </booktitle> <pages> pages 495-574. </pages> <publisher> Elsevier, Amsterdam and The MIT Press, </publisher> <address> Cambridge, </address> <year> 1990. </year>
Reference-contexts: We assume the reader to be familiar with the notions of SLD -resolution and SLD-tree (see <ref> [23, 1] </ref>). We represent, for notational convenience, SLD-trees as sets of nodes. Let T be an SLD-tree rooted at the goal G.
Reference: 2. <author> A. Bossi, M. Bugliesi, and M. Fabris. </author> <title> Fixpoint semantics for PROLOG. </title> <editor> In D. S. Warren, editor, </editor> <booktitle> Proc. Tenth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 374-389. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1993. </year>
Reference-contexts: Abstract debugging can be based on a PROLOG version of the semantic framework in [8], which was recently defined in [24]. The framework generalizes the computed answer semantics for PROLOG given in <ref> [2] </ref> and introduces a new abstract compilation method, where each constraint is abstracted by a pair of abstract constraints (upper and lower approximations). Abstract debugging can be viewed as yet another program verification method, where we are concerned with partial correctness properties and the specification is extensional.
Reference: 3. <author> A. Bossi, M. Gabbrielli, G. Levi, and M. Martelli. </author> <title> The s-semantics approach: </title> <journal> Theory and applications. Journal of Logic Programming, </journal> <volume> 19-20:149-197, </volume> <year> 1994. </year>
Reference-contexts: 1 Introduction Abstract debugging of logic programs is a novel combination of three known techniques, i.e. algorithmic (declarative) debugging [25, 15, 22], the s-semantics approach to the definition of program denotations modeling various observable behaviors <ref> [13, 14, 16, 4, 3] </ref>, and abstract interpretation [10, 11, 12]. A similar approach was developed in [5] for imperative languages. The debugging problem can formally be defined as follows. <p> As we will show in Section 5, abstract debugging can be reformulated in much simpler terms for s-observables. 4 s-observables s-observables are observables for which we can define a denotation, which generalizes the properties of the s-semantics <ref> [3] </ref>. The program denotation is defined by collecting the behaviors for most general atomic goals, i.e. goals of the form p ( ~ X) consisting of the application of a predicate symbol to a tuple of distinct variables. This property holds for our basic observable, i.e. SLD-trees.
Reference: 4. <author> A. Bossi, M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> A Compositional Semantics for Logic Programs. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 122(1-2):3-47, </address> <year> 1994. </year>
Reference-contexts: 1 Introduction Abstract debugging of logic programs is a novel combination of three known techniques, i.e. algorithmic (declarative) debugging [25, 15, 22], the s-semantics approach to the definition of program denotations modeling various observable behaviors <ref> [13, 14, 16, 4, 3] </ref>, and abstract interpretation [10, 11, 12]. A similar approach was developed in [5] for imperative languages. The debugging problem can formally be defined as follows.
Reference: 5. <author> F. Bourdoncle. </author> <title> Abstract debugging of higher-order imperative languages. </title> <booktitle> In PLDI'93, </booktitle> <pages> pages 46-55, </pages> <year> 1993. </year>
Reference-contexts: A similar approach was developed in <ref> [5] </ref> for imperative languages. The debugging problem can formally be defined as follows. Let P be a program, [[P ]] ff be the behavior of P w.r.t. the observable property ff, and I ff be the specification of the intended behavior of P w.r.t. ff.
Reference: 6. <author> K. L. Clark. </author> <title> Predicate logic as a computational formalism. Res. </title> <type> Report DOC 79/59, </type> <institution> Imperial College, Dept. of Computing, </institution> <address> London, </address> <year> 1979. </year>
Reference-contexts: In particular, - T P; is the ground operator defined in [26] (and O (P ) is the least Herbrand model). - T P; is the non-ground operator first defined in <ref> [6] </ref> (and O (P ) is the least term model). - T P;~ is the s-semantics operator defined in [13]. - T P; is the call patterns operator defined in [16].
Reference: 7. <author> P. Codognet and G. </author> <title> File. Computations, Abstractions and Constraints. </title> <booktitle> In Proc. Fourth IEEE Int'l Conference on Computer Languages. </booktitle> <publisher> IEEE Press, </publisher> <year> 1992. </year>
Reference-contexts: This amounts to a fixpoint computation or to the construction of the SLD -trees for all the most general atomic goals. 6 Abstract debugging w.r.t. i-observables i-observables are meant to model the abstraction involved in abstract interpretation. According to the approach in <ref> [7, 19, 20] </ref>, the abstraction process is performed by defining a semi-morphism from the concrete constraint system to a suitable abstract constraint system. This abstraction has to be combined with the usual abstraction of SLD-trees to generate an i-observable.
Reference: 8. <author> M. Comini and G. Levi. </author> <title> An algebraic theory of observables. </title> <editor> In M. Bruynooghe, editor, </editor> <booktitle> Proc. 1994 Int'l Symposium on Logic Programming. </booktitle> <publisher> The MIT Press, </publisher> <address> Cam-bridge, Mass., </address> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: This approach is feasible even in abstract debugging. However, since our method can handle abstractions, we can easily come out with finite observable behaviors and specify them in an extensional way. Our theory of abstract debugging is built on an algebraic semantic framework for positive logic programs <ref> [8] </ref>, based on the formalization of observables as abstractions. A complete description of the framework is outside the scope of this paper. In Section 2 we summarize the main properties of the framework. <p> Finally section 6 discusses a weaker class of observables (i-observables), which are meant to model the abstraction involved in program analysis and we show that only the completeness diagnosis algorithm is applicable. 2 Observables Following <ref> [8] </ref>, we consider Constraint Logic Programs (CLP) [21] with the PRO-LOG (leftmost) selection rule. We assume the reader to be familiar with the notions of SLD -resolution and SLD-tree (see [23, 1]). We represent, for notational convenience, SLD-trees as sets of nodes. <p> The SLD -trees denotation O (P ) of a program P is the set of all the nodes of SLD -trees of most general atomic goals. SLD-trees have the following properties, first proved in [16, 17] and later formalized in algebraic terms <ref> [8] </ref>: AND -compositionality, i.e. the SLD-tree of any (conjunctive) goal can be determined from O (P ). <p> O ff (P ) and T P;ff are meaningful only for observables which satisfy suitable conditions formally stated in <ref> [8] </ref>. Informally, an s-observable is an abstraction ff of SLD -trees, for which we have a lifting (to more general goals) property and which is AND-compositional. <p> Finite failures are not even i-observables. For all the observables ff in this class, we have to consider a stronger s-observable fi (ff fi). The corresponding denotation O fi (P ) is correct and AND-compositional w.r.t. ff, yet it is not fully abstract <ref> [8] </ref>. In the case of abstract debugging, we are forced to specify the behavior w.r.t. fi. 5 Abstract debugging w.r.t. s-observables Let P be a program and ff be an s-observable. <p> All our results can easily be extended to local selection rules [27]. A more interesting extension is related to the overall PROLOG computation rule, including the depth-first search based on the clause ordering. Abstract debugging can be based on a PROLOG version of the semantic framework in <ref> [8] </ref>, which was recently defined in [24]. The framework generalizes the computed answer semantics for PROLOG given in [2] and introduces a new abstract compilation method, where each constraint is abstracted by a pair of abstract constraints (upper and lower approximations).
Reference: 9. <author> A. Cortesi, G. File, and W. Winsborough. </author> <title> Prop revisited: Propositional Formula as Abstract Domain for Groundness Analysis. </title> <booktitle> In Proc. Sixth IEEE Symp. on Logic In Computer Science, </booktitle> <pages> pages 322-327. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: set of nodes in containing G as first element is finite, non-empty and does not contain nodes of the form hg; c; true; ki g. - (ground dependencies in answer constraints) The ground dependencies among the variables occurring in the goal are represented as propositional formulas (see the domain Prop <ref> [9] </ref>). We assume the answer constraints to be equalities of the form X = t. Abstract constraints are given by the function defined as follows: -(c 1 ^ c 2 ) = -(c 1 ) ^ -(c 2 ); ^ X i s.t.
Reference: 10. <author> P. Cousot and R. Cousot. </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. </title> <booktitle> In Proc. Fourth ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 238-252, </pages> <year> 1977. </year>
Reference-contexts: 1 Introduction Abstract debugging of logic programs is a novel combination of three known techniques, i.e. algorithmic (declarative) debugging [25, 15, 22], the s-semantics approach to the definition of program denotations modeling various observable behaviors [13, 14, 16, 4, 3], and abstract interpretation <ref> [10, 11, 12] </ref>. A similar approach was developed in [5] for imperative languages. The debugging problem can formally be defined as follows.
Reference: 11. <author> P. Cousot and R. Cousot. </author> <title> Systematic Design of Program Analysis Frameworks. </title> <booktitle> In Proc. Sixth ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 269-282, </pages> <year> 1979. </year>
Reference-contexts: 1 Introduction Abstract debugging of logic programs is a novel combination of three known techniques, i.e. algorithmic (declarative) debugging [25, 15, 22], the s-semantics approach to the definition of program denotations modeling various observable behaviors [13, 14, 16, 4, 3], and abstract interpretation <ref> [10, 11, 12] </ref>. A similar approach was developed in [5] for imperative languages. The debugging problem can formally be defined as follows.
Reference: 12. <author> P. Cousot and R. Cousot. </author> <title> Abstract Interpretation and Applications to Logic Programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 13(2 </volume> & 3):103-179, 1992. 
Reference-contexts: 1 Introduction Abstract debugging of logic programs is a novel combination of three known techniques, i.e. algorithmic (declarative) debugging [25, 15, 22], the s-semantics approach to the definition of program denotations modeling various observable behaviors [13, 14, 16, 4, 3], and abstract interpretation <ref> [10, 11, 12] </ref>. A similar approach was developed in [5] for imperative languages. The debugging problem can formally be defined as follows.
Reference: 13. <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative Modeling of the Operational Behavior of Logic Languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction Abstract debugging of logic programs is a novel combination of three known techniques, i.e. algorithmic (declarative) debugging [25, 15, 22], the s-semantics approach to the definition of program denotations modeling various observable behaviors <ref> [13, 14, 16, 4, 3] </ref>, and abstract interpretation [10, 11, 12]. A similar approach was developed in [5] for imperative languages. The debugging problem can formally be defined as follows. <p> In particular, - T P; is the ground operator defined in [26] (and O (P ) is the least Herbrand model). - T P; is the non-ground operator first defined in [6] (and O (P ) is the least term model). - T P;~ is the s-semantics operator defined in <ref> [13] </ref>. - T P; is the call patterns operator defined in [16].
Reference: 14. <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> A Model-Theoretic Reconstruction of the Operational Semantics of Logic Programs. </title> <journal> Information and Computation, </journal> <volume> 102(1) </volume> <pages> 86-113, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction Abstract debugging of logic programs is a novel combination of three known techniques, i.e. algorithmic (declarative) debugging [25, 15, 22], the s-semantics approach to the definition of program denotations modeling various observable behaviors <ref> [13, 14, 16, 4, 3] </ref>, and abstract interpretation [10, 11, 12]. A similar approach was developed in [5] for imperative languages. The debugging problem can formally be defined as follows.
Reference: 15. <author> G. Ferrand. </author> <title> Error Diagnosis in Logic Programming, an Adaptation of E. Y. Shapiro's Method. </title> <journal> Journal of Logic Programming, </journal> <volume> 4 </volume> <pages> 177-198, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Abstract debugging of logic programs is a novel combination of three known techniques, i.e. algorithmic (declarative) debugging <ref> [25, 15, 22] </ref>, the s-semantics approach to the definition of program denotations modeling various observable behaviors [13, 14, 16, 4, 3], and abstract interpretation [10, 11, 12]. A similar approach was developed in [5] for imperative languages. The debugging problem can formally be defined as follows. <p> Declarative debugging is concerned with model-theoretic properties rather than with the operational behavior. The specification is therefore the intended declarative semantics of the program, which is the least Herbrand model in [25, 22], and the set of atomic logical consequences in <ref> [15] </ref>. Abstract debugging is a generalization of declarative debugging, where we consider operational properties. An observable is any property which can be extracted from a goal computation, i.e. observables are abstractions of SLD - trees. <p> The following definitions are straightforward extensions of the definitions given in the case of declarative debugging <ref> [25, 15, 22] </ref>. Pis partially correct w.r.t. I ff , if [[P ]] ff I ff . Pis complete w.r.t. I ff , if I ff [[P ]] ff . Pis totally correct w.r.t. I ff , if [[P ]] ff = I ff . <p> In particular, the observable (solutions of answer constraints) gives us the declarative debugging based on the least Herbrand model [25, 22]; the observable (correct answer constraints) gives us the declarative debug ging based on the atomic logical consequences <ref> [15] </ref>. If P is not totally correct, we are left with the problem of determining the errors, which are based, following [25, 15, 22], on the symptoms. <p> If P is not totally correct, we are left with the problem of determining the errors, which are based, following <ref> [25, 15, 22] </ref>, on the symptoms. Namely, an incorrectness symptom is an element in O ff (P ) I ff , an incompleteness symptom is an element in I ff O ff (P ). Note that our incompleteness symptoms are different from the insufficiency symptoms used in [25, 15, 22]. <p> are based, following <ref> [25, 15, 22] </ref>, on the symptoms. Namely, an incorrectness symptom is an element in O ff (P ) I ff , an incompleteness symptom is an element in I ff O ff (P ). Note that our incompleteness symptoms are different from the insufficiency symptoms used in [25, 15, 22]. As we will show in the following, our definitions lead to a symmetric diagnosis for incorrectness and incompleteness. It is straightforward to realize that an element may sometimes be an (incorrectness or incompleteness) symptom, just because of another symptom.
Reference: 16. <author> M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> Observational Equivalences for Logic Programs. </title> <editor> In K. Apt, editor, </editor> <booktitle> Proc. Joint Int'l Conf. and Symposium on Logic Programming, </booktitle> <pages> pages 131-145. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1992. </year> <note> Extended version to appear in Information and Computation. </note>
Reference-contexts: 1 Introduction Abstract debugging of logic programs is a novel combination of three known techniques, i.e. algorithmic (declarative) debugging [25, 15, 22], the s-semantics approach to the definition of program denotations modeling various observable behaviors <ref> [13, 14, 16, 4, 3] </ref>, and abstract interpretation [10, 11, 12]. A similar approach was developed in [5] for imperative languages. The debugging problem can formally be defined as follows. <p> The SLD -trees denotation O (P ) of a program P is the set of all the nodes of SLD -trees of most general atomic goals. SLD-trees have the following properties, first proved in <ref> [16, 17] </ref> and later formalized in algebraic terms [8]: AND -compositionality, i.e. the SLD-tree of any (conjunctive) goal can be determined from O (P ). <p> [26] (and O (P ) is the least Herbrand model). - T P; is the non-ground operator first defined in [6] (and O (P ) is the least term model). - T P;~ is the s-semantics operator defined in [13]. - T P; is the call patterns operator defined in <ref> [16] </ref>.
Reference: 17. <author> M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> A resultants semantics for PROLOG. </title> <type> Technical report, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1994. </year>
Reference-contexts: The SLD -trees denotation O (P ) of a program P is the set of all the nodes of SLD -trees of most general atomic goals. SLD-trees have the following properties, first proved in <ref> [16, 17] </ref> and later formalized in algebraic terms [8]: AND -compositionality, i.e. the SLD-tree of any (conjunctive) goal can be determined from O (P ).
Reference: 18. <author> R. Giacobazzi. </author> <title> On the Collecting Semantics of Logic Programs. </title> <editor> In F. S. de Boer and M. Gabbrielli, editors, </editor> <booktitle> Verification and Analysis of Logic Languages, Proc. of the Post-Conference ICLP Workshop, </booktitle> <pages> pages 159-174, </pages> <year> 1994. </year>
Reference-contexts: As we will discuss later, the relation among the observables can naturally be understood in terms of abstract interpretation. A similar approach to the semantics of logic programs can be found in <ref> [18] </ref>. Here are some motivations for abstract debugging. The most natural abstract debugging for positive logic programs is debugging w.r.t. computed answers, which leads to a more precise analysis, since declarative debugging is related to correct answers only.
Reference: 19. <author> R. Giacobazzi, S. K. Debray, and G. Levi. </author> <title> A Generalized Semantics for Constraint Logic Programs. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems 1992, </booktitle> <pages> pages 581-591, </pages> <year> 1992. </year>
Reference-contexts: This amounts to a fixpoint computation or to the construction of the SLD -trees for all the most general atomic goals. 6 Abstract debugging w.r.t. i-observables i-observables are meant to model the abstraction involved in abstract interpretation. According to the approach in <ref> [7, 19, 20] </ref>, the abstraction process is performed by defining a semi-morphism from the concrete constraint system to a suitable abstract constraint system. This abstraction has to be combined with the usual abstraction of SLD-trees to generate an i-observable. <p> Namely, an i-observable ff = ff ffi is the composition of an s-observable ff with the function , obtained by extending to nodes the constraint semimorphism . Note that in general ff is not an s-observable. We follow the so-called "generalized semantics" approach of <ref> [19, 20] </ref>, which is a kind of abstract compilation, where the program P is transformed into an abstract program (P ), obtained by applying to the concrete constraints in P .
Reference: 20. <author> R. Giacobazzi, G. Levi, and S. K. Debray. </author> <title> Joining Abstract and Concrete Computations in Constraint Logic Programming. </title> <editor> In M. Nivat, C. Rattray, T. Rus, and G. Scollo, editors, </editor> <booktitle> Algebraic Methodology and Software Technology (AMAST'93), Proceedings of the Third International Conference on Algebraic Methodology and Software Technology, Workshops in Computing, </booktitle> <pages> pages 111-127. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: This amounts to a fixpoint computation or to the construction of the SLD -trees for all the most general atomic goals. 6 Abstract debugging w.r.t. i-observables i-observables are meant to model the abstraction involved in abstract interpretation. According to the approach in <ref> [7, 19, 20] </ref>, the abstraction process is performed by defining a semi-morphism from the concrete constraint system to a suitable abstract constraint system. This abstraction has to be combined with the usual abstraction of SLD-trees to generate an i-observable. <p> Namely, an i-observable ff = ff ffi is the composition of an s-observable ff with the function , obtained by extending to nodes the constraint semimorphism . Note that in general ff is not an s-observable. We follow the so-called "generalized semantics" approach of <ref> [19, 20] </ref>, which is a kind of abstract compilation, where the program P is transformed into an abstract program (P ), obtained by applying to the concrete constraints in P .
Reference: 21. <author> J. Jaffar and J. L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proc. Fourteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 111-119. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference-contexts: Finally section 6 discusses a weaker class of observables (i-observables), which are meant to model the abstraction involved in program analysis and we show that only the completeness diagnosis algorithm is applicable. 2 Observables Following [8], we consider Constraint Logic Programs (CLP) <ref> [21] </ref> with the PRO-LOG (leftmost) selection rule. We assume the reader to be familiar with the notions of SLD -resolution and SLD-tree (see [23, 1]). We represent, for notational convenience, SLD-trees as sets of nodes. Let T be an SLD-tree rooted at the goal G.
Reference: 22. <author> J. W. Lloyd. </author> <title> Declarative error diagnosis. </title> <journal> New Generation Computing, </journal> <volume> 5(2) </volume> <pages> 133-154, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Abstract debugging of logic programs is a novel combination of three known techniques, i.e. algorithmic (declarative) debugging <ref> [25, 15, 22] </ref>, the s-semantics approach to the definition of program denotations modeling various observable behaviors [13, 14, 16, 4, 3], and abstract interpretation [10, 11, 12]. A similar approach was developed in [5] for imperative languages. The debugging problem can formally be defined as follows. <p> Declarative debugging is concerned with model-theoretic properties rather than with the operational behavior. The specification is therefore the intended declarative semantics of the program, which is the least Herbrand model in <ref> [25, 22] </ref>, and the set of atomic logical consequences in [15]. Abstract debugging is a generalization of declarative debugging, where we consider operational properties. An observable is any property which can be extracted from a goal computation, i.e. observables are abstractions of SLD - trees. <p> The following definitions are straightforward extensions of the definitions given in the case of declarative debugging <ref> [25, 15, 22] </ref>. Pis partially correct w.r.t. I ff , if [[P ]] ff I ff . Pis complete w.r.t. I ff , if I ff [[P ]] ff . Pis totally correct w.r.t. I ff , if [[P ]] ff = I ff . <p> In particular, the observable (solutions of answer constraints) gives us the declarative debugging based on the least Herbrand model <ref> [25, 22] </ref>; the observable (correct answer constraints) gives us the declarative debug ging based on the atomic logical consequences [15]. If P is not totally correct, we are left with the problem of determining the errors, which are based, following [25, 15, 22], on the symptoms. <p> If P is not totally correct, we are left with the problem of determining the errors, which are based, following <ref> [25, 15, 22] </ref>, on the symptoms. Namely, an incorrectness symptom is an element in O ff (P ) I ff , an incompleteness symptom is an element in I ff O ff (P ). Note that our incompleteness symptoms are different from the insufficiency symptoms used in [25, 15, 22]. <p> are based, following <ref> [25, 15, 22] </ref>, on the symptoms. Namely, an incorrectness symptom is an element in O ff (P ) I ff , an incompleteness symptom is an element in I ff O ff (P ). Note that our incompleteness symptoms are different from the insufficiency symptoms used in [25, 15, 22]. As we will show in the following, our definitions lead to a symmetric diagnosis for incorrectness and incompleteness. It is straightforward to realize that an element may sometimes be an (incorrectness or incompleteness) symptom, just because of another symptom.
Reference: 23. <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year> <note> Second edition. </note>
Reference-contexts: We assume the reader to be familiar with the notions of SLD -resolution and SLD-tree (see <ref> [23, 1] </ref>). We represent, for notational convenience, SLD-trees as sets of nodes. Let T be an SLD-tree rooted at the goal G.
Reference: 24. <author> D. </author> <month> Micciancio. </month> <institution> Interpretazione astratta di programmi logici con il controllo di PROLOG. </institution> <type> Master's thesis, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1994. </year> <note> in italian. </note>
Reference-contexts: A more interesting extension is related to the overall PROLOG computation rule, including the depth-first search based on the clause ordering. Abstract debugging can be based on a PROLOG version of the semantic framework in [8], which was recently defined in <ref> [24] </ref>. The framework generalizes the computed answer semantics for PROLOG given in [2] and introduces a new abstract compilation method, where each constraint is abstracted by a pair of abstract constraints (upper and lower approximations).
Reference: 25. <author> E. Y. Shapiro. </author> <title> Algorithmic program debugging. </title> <booktitle> In Proc. Ninth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 412-531. </pages> <publisher> ACM Press, </publisher> <year> 1982. </year>
Reference-contexts: 1 Introduction Abstract debugging of logic programs is a novel combination of three known techniques, i.e. algorithmic (declarative) debugging <ref> [25, 15, 22] </ref>, the s-semantics approach to the definition of program denotations modeling various observable behaviors [13, 14, 16, 4, 3], and abstract interpretation [10, 11, 12]. A similar approach was developed in [5] for imperative languages. The debugging problem can formally be defined as follows. <p> Declarative debugging is concerned with model-theoretic properties rather than with the operational behavior. The specification is therefore the intended declarative semantics of the program, which is the least Herbrand model in <ref> [25, 22] </ref>, and the set of atomic logical consequences in [15]. Abstract debugging is a generalization of declarative debugging, where we consider operational properties. An observable is any property which can be extracted from a goal computation, i.e. observables are abstractions of SLD - trees. <p> The following definitions are straightforward extensions of the definitions given in the case of declarative debugging <ref> [25, 15, 22] </ref>. Pis partially correct w.r.t. I ff , if [[P ]] ff I ff . Pis complete w.r.t. I ff , if I ff [[P ]] ff . Pis totally correct w.r.t. I ff , if [[P ]] ff = I ff . <p> In particular, the observable (solutions of answer constraints) gives us the declarative debugging based on the least Herbrand model <ref> [25, 22] </ref>; the observable (correct answer constraints) gives us the declarative debug ging based on the atomic logical consequences [15]. If P is not totally correct, we are left with the problem of determining the errors, which are based, following [25, 15, 22], on the symptoms. <p> If P is not totally correct, we are left with the problem of determining the errors, which are based, following <ref> [25, 15, 22] </ref>, on the symptoms. Namely, an incorrectness symptom is an element in O ff (P ) I ff , an incompleteness symptom is an element in I ff O ff (P ). Note that our incompleteness symptoms are different from the insufficiency symptoms used in [25, 15, 22]. <p> are based, following <ref> [25, 15, 22] </ref>, on the symptoms. Namely, an incorrectness symptom is an element in O ff (P ) I ff , an incompleteness symptom is an element in I ff O ff (P ). Note that our incompleteness symptoms are different from the insufficiency symptoms used in [25, 15, 22]. As we will show in the following, our definitions lead to a symmetric diagnosis for incorrectness and incompleteness. It is straightforward to realize that an element may sometimes be an (incorrectness or incompleteness) symptom, just because of another symptom.
Reference: 26. <author> M. H. van Emden and R. A. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year>
Reference-contexts: Some of the specialized bottom-up operators T P;ff = ff ffi T P ffi fl are the CLP versions of existing "immediate consequences operators". In particular, - T P; is the ground operator defined in <ref> [26] </ref> (and O (P ) is the least Herbrand model). - T P; is the non-ground operator first defined in [6] (and O (P ) is the least term model). - T P;~ is the s-semantics operator defined in [13]. - T P; is the call patterns operator defined in [16].
Reference: 27. <author> L. Vieille. </author> <title> Recursive query processing: the power of logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 69 </volume> <pages> 1-53, </pages> <year> 1989. </year>
Reference-contexts: All our results can easily be extended to local selection rules <ref> [27] </ref>. A more interesting extension is related to the overall PROLOG computation rule, including the depth-first search based on the clause ordering. Abstract debugging can be based on a PROLOG version of the semantic framework in [8], which was recently defined in [24].
References-found: 27

