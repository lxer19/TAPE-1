URL: http://www.cs.nmsu.edu/lldap/jicslp98/p6.ps.gz
Refering-URL: http://www.cs.nmsu.edu/lldap/jicslp98/accepted.html
Root-URL: http://www.cs.nmsu.edu
Email: email: ducasse@irisa.fr  email: noye@emn.fr  
Title: Tracing Prolog Programs by Source Instrumentation is Efficient Enough  
Author: Mireille Ducasse Jacques Noye 
Address: F 35042 Rennes Cedex, France,  Nantes, 4, rue Alfred Kastler, La Chantrerie F- 44307 Nantes Cedex 03, France,  
Affiliation: IRISA/INSA, Campus Universitaire de Beaulieu  Ecole des Mines de  
Abstract: Tracing by automatic program source instrumentation has major advantages over compiled code instrumentation: it is more portable, it benefits from many compiler optimizations, it produces traces in terms of the original program, and it can be tailored to specific debugging needs. The usual argument in favor of compiled code instrumentation is its supposed efficiency. We have compared the performance of two operational low-level Prolog tracers with source instrumentation. We have executed classical Prolog benchmark programs, collecting trace information without displaying it. On average, collecting trace information by program instrumentation is about as fast as using a low-level tracer in one case, and only twice slower in the other. This is a minor penalty to pay, compared to the advantages of the approach. To our knowledge, this is the first time that a quantitative comparison of both approaches is made for any programming language.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. Byrd. </author> <title> Understanding the control flow of Prolog programs. </title> <editor> In S.-A. Tarnlund, editor, </editor> <booktitle> Logic Programming Workshop, </booktitle> <address> Debrecen, Hungary, </address> <year> 1980. </year>
Reference-contexts: The methodology is described followed by some of the results and a discussion. 2 Modeling Prolog executions A Prolog trace is a sequence of events which gives a picture of a program execution. We use an execution model close to the classical box model of Byrd <ref> [1] </ref> in which execution events are bound to goals. There are different types of events, called ports. A call event tells that g is invoked and gives the instantiation of its arguments at the moment of the invocation. A f ail event tells that g fails.
Reference: [2] <author> M. Calejo. </author> <title> A framework for declarative Prolog debugging. </title> <type> PhD thesis, </type> <institution> New University of Lisbon, Portugal, </institution> <month> March </month> <year> 1992. </year> <month> 12 </month>
Reference-contexts: The instrumentation can be adapted to directly trace at the abstract level. While source instrumentation has advantages over compiled code instrumentation, the usual argument in favor of compiled code instrumentation is its efficiency. Beside Specht, Calejo <ref> [2] </ref> uses source instrumentation by program transformation to trace logic programs. No performance measurements are available for any of the systems. Tolmach and Appel [14] designed and implemented a tracer for Standard ML based on automatic program source instrumentation. The resulting code runs only 3 times slower than optimized code.
Reference: [3] <author> M. Ducasse. Opium: </author> <title> An extendable trace analyser for prolog. </title> <journal> The Journal of Logic program-ming, </journal> <note> 1999. To appear in the special issue on Synthesis, Transformation and Analysis of Logic Programs, </note> <author> A. Bossi and Y. Deville (eds), </author> <note> Also Rapport Technique INRIA 3257. </note>
Reference-contexts: In an exhaustive trace, the events related to a given goal are not necessarily consecutive. They are intertwined with events related to subgoals and siblings. A more detailed description of the trace model can be found in <ref> [3] </ref>. 3 Informal presentation of the instrumentation The first subsection presents a transformation which is basically the one of the advice package of the DEC10 Prolog library, extended in order to deal with the unify port. The next subsection extends the transformation to deal with skipped predicates. <p> This predicate calls the body of the original predicate mem/4. The predicates trace/2/3 can, for example, display their arguments on the standard output or they can send them to a trace analyser such as Opium <ref> [3] </ref>. The three important properties of the predicates trace/2/3 are that they (1) succeed exactly once, (2) bind no variable of the original program and, (3) have no side effect on the original program. <p> The portion of trace equivalent to the lines 18-26 of Figure 2 with skipped predicates and counters is now 5 <ref> [3] </ref> call mem (5,[2,4],Y,Z) 5 [3] unify (1) mem (5,[2,4],2,4) 6 [4] call 5 is 2 + 4 6 [4] fail 5 is 2 + 4 5 [3] unify (2) mem (5,[_,4],Y,Z) 7 [4] call mem (5,[4],Y,Z) 7 [4] unify (2) mem (5,[_],Y,Z) 8 [5] call mem (5,[],Y,Z) 8 [5] fail <p> The portion of trace equivalent to the lines 18-26 of Figure 2 with skipped predicates and counters is now 5 <ref> [3] </ref> call mem (5,[2,4],Y,Z) 5 [3] unify (1) mem (5,[2,4],2,4) 6 [4] call 5 is 2 + 4 6 [4] fail 5 is 2 + 4 5 [3] unify (2) mem (5,[_,4],Y,Z) 7 [4] call mem (5,[4],Y,Z) 7 [4] unify (2) mem (5,[_],Y,Z) 8 [5] call mem (5,[],Y,Z) 8 [5] fail mem (5,[],Y,Z) 7 [4] fail <p> The portion of trace equivalent to the lines 18-26 of Figure 2 with skipped predicates and counters is now 5 <ref> [3] </ref> call mem (5,[2,4],Y,Z) 5 [3] unify (1) mem (5,[2,4],2,4) 6 [4] call 5 is 2 + 4 6 [4] fail 5 is 2 + 4 5 [3] unify (2) mem (5,[_,4],Y,Z) 7 [4] call mem (5,[4],Y,Z) 7 [4] unify (2) mem (5,[_],Y,Z) 8 [5] call mem (5,[],Y,Z) 8 [5] fail mem (5,[],Y,Z) 7 [4] fail mem (5,[4],Y,Z) 5 [3] fail mem (5,[2,4],Y,Z) portion of the trace with counters and skipped predicates. tus is concerned, we have used <p> (5,[2,4],2,4) 6 [4] call 5 is 2 + 4 6 [4] fail 5 is 2 + 4 5 <ref> [3] </ref> unify (2) mem (5,[_,4],Y,Z) 7 [4] call mem (5,[4],Y,Z) 7 [4] unify (2) mem (5,[_],Y,Z) 8 [5] call mem (5,[],Y,Z) 8 [5] fail mem (5,[],Y,Z) 7 [4] fail mem (5,[4],Y,Z) 5 [3] fail mem (5,[2,4],Y,Z) portion of the trace with counters and skipped predicates. tus is concerned, we have used SICStus version 3.7 beta [12]. This version makes it possible to trace compiled code (previous versions were relying on interpreted code for debugging) but debugging support is hidden to the compiler. <p> When used together with a trace analyzer such as Opium <ref> [3] </ref>, the context is different. The whole trace may have to be examined by the trace analyzer before the user sees any result. Thus the time taken by the tracing mechanism may be an issue. <p> Considering the advantages in terms of portability and versatility, this slowdown is quite acceptable. We do not expect it to be significant when dealing with "standard" tracing, dominated by input/output. This may be more of an issue when connecting tracing to a trace analyser such as Opium <ref> [3] </ref>. Indeed, large fractions of the execution may need to be analysed and therefore traced. We are currently extending our first prototype with a connection to Opium to check the issue.
Reference: [4] <author> M. Ducasse and J. </author> <title> Noye. Logic programming environments: Dynamic program analysis and debugging. </title> <journal> The Journal of Logic Programming, </journal> 19/20:351-384, May/July 1994. 
Reference-contexts: 1 Introduction There are four basic ways to trace executions <ref> [4] </ref>: manual program source instrumentation, automatic program source instrumentation, instrumentation of meta-interpreters, and compiled code instrumentation. Manual program source instrumentation is tedious and error-prone, and instrumentation of meta-interpreters is notoriously too inefficient. No comparison of automatic program source instrumentation and compiled code instrumentation exists. <p> The portion of trace equivalent to the lines 18-26 of Figure 2 with skipped predicates and counters is now 5 [3] call mem (5,[2,4],Y,Z) 5 [3] unify (1) mem (5,[2,4],2,4) 6 <ref> [4] </ref> call 5 is 2 + 4 6 [4] fail 5 is 2 + 4 5 [3] unify (2) mem (5,[_,4],Y,Z) 7 [4] call mem (5,[4],Y,Z) 7 [4] unify (2) mem (5,[_],Y,Z) 8 [5] call mem (5,[],Y,Z) 8 [5] fail mem (5,[],Y,Z) 7 [4] fail mem (5,[4],Y,Z) 5 [3] fail mem <p> The portion of trace equivalent to the lines 18-26 of Figure 2 with skipped predicates and counters is now 5 [3] call mem (5,[2,4],Y,Z) 5 [3] unify (1) mem (5,[2,4],2,4) 6 <ref> [4] </ref> call 5 is 2 + 4 6 [4] fail 5 is 2 + 4 5 [3] unify (2) mem (5,[_,4],Y,Z) 7 [4] call mem (5,[4],Y,Z) 7 [4] unify (2) mem (5,[_],Y,Z) 8 [5] call mem (5,[],Y,Z) 8 [5] fail mem (5,[],Y,Z) 7 [4] fail mem (5,[4],Y,Z) 5 [3] fail mem (5,[2,4],Y,Z) portion of the trace with counters and <p> trace equivalent to the lines 18-26 of Figure 2 with skipped predicates and counters is now 5 [3] call mem (5,[2,4],Y,Z) 5 [3] unify (1) mem (5,[2,4],2,4) 6 <ref> [4] </ref> call 5 is 2 + 4 6 [4] fail 5 is 2 + 4 5 [3] unify (2) mem (5,[_,4],Y,Z) 7 [4] call mem (5,[4],Y,Z) 7 [4] unify (2) mem (5,[_],Y,Z) 8 [5] call mem (5,[],Y,Z) 8 [5] fail mem (5,[],Y,Z) 7 [4] fail mem (5,[4],Y,Z) 5 [3] fail mem (5,[2,4],Y,Z) portion of the trace with counters and skipped predicates. tus is concerned, we have used SICStus version 3.7 beta [12]. <p> 18-26 of Figure 2 with skipped predicates and counters is now 5 [3] call mem (5,[2,4],Y,Z) 5 [3] unify (1) mem (5,[2,4],2,4) 6 <ref> [4] </ref> call 5 is 2 + 4 6 [4] fail 5 is 2 + 4 5 [3] unify (2) mem (5,[_,4],Y,Z) 7 [4] call mem (5,[4],Y,Z) 7 [4] unify (2) mem (5,[_],Y,Z) 8 [5] call mem (5,[],Y,Z) 8 [5] fail mem (5,[],Y,Z) 7 [4] fail mem (5,[4],Y,Z) 5 [3] fail mem (5,[2,4],Y,Z) portion of the trace with counters and skipped predicates. tus is concerned, we have used SICStus version 3.7 beta [12]. <p> 5 [3] unify (1) mem (5,[2,4],2,4) 6 <ref> [4] </ref> call 5 is 2 + 4 6 [4] fail 5 is 2 + 4 5 [3] unify (2) mem (5,[_,4],Y,Z) 7 [4] call mem (5,[4],Y,Z) 7 [4] unify (2) mem (5,[_],Y,Z) 8 [5] call mem (5,[],Y,Z) 8 [5] fail mem (5,[],Y,Z) 7 [4] fail mem (5,[4],Y,Z) 5 [3] fail mem (5,[2,4],Y,Z) portion of the trace with counters and skipped predicates. tus is concerned, we have used SICStus version 3.7 beta [12].
Reference: [5] <institution> ECRC, Munich, Germany. ECLiPSe 3.5 User Manual, </institution> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: They conjectured that a low-level tracer would run at about the same speed. However they had no reasonable low-level tracer at their disposal with which they could compare their results. We have performed such a comparison in the context of Prolog, using two quite different systems: ECLiPSe <ref> [8, 5] </ref>, and SICStus [12]. As far as source instrumentation is concerned, it is based on an extension of O'Keefe's advice utility 1 . The instrumentation takes built-in predicates into account and provides the user with a more complete trace model. <p> predicates and counters is now 5 [3] call mem (5,[2,4],Y,Z) 5 [3] unify (1) mem (5,[2,4],2,4) 6 [4] call 5 is 2 + 4 6 [4] fail 5 is 2 + 4 5 [3] unify (2) mem (5,[_,4],Y,Z) 7 [4] call mem (5,[4],Y,Z) 7 [4] unify (2) mem (5,[_],Y,Z) 8 <ref> [5] </ref> call mem (5,[],Y,Z) 8 [5] fail mem (5,[],Y,Z) 7 [4] fail mem (5,[4],Y,Z) 5 [3] fail mem (5,[2,4],Y,Z) portion of the trace with counters and skipped predicates. tus is concerned, we have used SICStus version 3.7 beta [12]. <p> 5 [3] call mem (5,[2,4],Y,Z) 5 [3] unify (1) mem (5,[2,4],2,4) 6 [4] call 5 is 2 + 4 6 [4] fail 5 is 2 + 4 5 [3] unify (2) mem (5,[_,4],Y,Z) 7 [4] call mem (5,[4],Y,Z) 7 [4] unify (2) mem (5,[_],Y,Z) 8 <ref> [5] </ref> call mem (5,[],Y,Z) 8 [5] fail mem (5,[],Y,Z) 7 [4] fail mem (5,[4],Y,Z) 5 [3] fail mem (5,[2,4],Y,Z) portion of the trace with counters and skipped predicates. tus is concerned, we have used SICStus version 3.7 beta [12].
Reference: [6] <author> M. </author> <title> Eisenstadt. A powerful Prolog trace package. </title> <booktitle> In Proceedings of the 6th European Conference on Artificial Intelligence. </booktitle> <publisher> North-Holland, </publisher> <year> 1985, </year> <month> September </month> <year> 1984. </year>
Reference-contexts: A f ail event tells that g fails. An exit event tells that g succeeds and gives the resulting instantiation of the arguments. A redo event tells that the execution is backtracking either to g or to one of its subgoals. We have added the unif y event <ref> [6] </ref> which tells when the execution finds a clause that unifies with g and gives the resulting instantiation of the arguments, it also gives the unified clause. 1 The advice utility is part of the DEC10 Prolog library, available by anonymous ftp from the AIAI of the University of Edinburg (aiai.edinburgh.ac.uk).
Reference: [7] <author> B. Holmer, B. Sano, M. Carlton, P. Van Roy, R. Haygood, W. Bush, and A. Despain. </author> <title> Fast Prolog with an extended general purpose architecture. </title> <booktitle> In Proceedings of the 17 th Annual International Conference on Computer Architecture. IEEE/ACM, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> May </month> <year> 1990. </year>
Reference-contexts: This is a set of benchmark programs put together, from a number of different sources, as part of the Aquarius project (University of California, at Berkeley). This suite is well known in the Prolog community; it has, among others, been used to assess the performance of the BAM processor <ref> [7] </ref>, the KCM machine [9], the Aquarius Prolog Compiler [10], and Parma [13], a Prolog compiler for the MIPS RISC architecture.
Reference: [8] <author> M. Meier, A. Aggoun, D. Chan, P. Dufresne, R. Enders, D. Henry de Villeneuve, A. Herold, P. Kay, B. Perez, E. van Rossum, and J. Schimpf. </author> <title> SEPIA an extendible Prolog system. </title> <booktitle> In Proceedings of the IFIP '89, </booktitle> <year> 1989. </year>
Reference-contexts: They conjectured that a low-level tracer would run at about the same speed. However they had no reasonable low-level tracer at their disposal with which they could compare their results. We have performed such a comparison in the context of Prolog, using two quite different systems: ECLiPSe <ref> [8, 5] </ref>, and SICStus [12]. As far as source instrumentation is concerned, it is based on an extension of O'Keefe's advice utility 1 . The instrumentation takes built-in predicates into account and provides the user with a more complete trace model.
Reference: [9] <author> J. </author> <title> Noye. An overview of the Knowledge Crunching Machine. </title> <editor> In M. Abdelguerfi and S. Lav-ington, editors, </editor> <title> Emerging Trends in Database and Knowledge-base Machines. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1994. </year>
Reference-contexts: This suite is well known in the Prolog community; it has, among others, been used to assess the performance of the BAM processor [7], the KCM machine <ref> [9] </ref>, the Aquarius Prolog Compiler [10], and Parma [13], a Prolog compiler for the MIPS RISC architecture.
Reference: [10] <author> P. V. Roy and A. M. Despain. </author> <title> High-performance logic programming with the Aquarius Prolog compiler. </title> <journal> Computer, </journal> <volume> 25(1) </volume> <pages> 54-68, </pages> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: As far as source instrumentation is concerned, it is based on an extension of O'Keefe's advice utility 1 . The instrumentation takes built-in predicates into account and provides the user with a more complete trace model. We have executed classical Prolog benchmark programs <ref> [10] </ref> collecting trace information without displaying it. On average, collecting trace information by program instrumentation is only about twice slower than using a low-level tracer when using ECLiPSe and has similar performance when using SICStus. <p> This suite is well known in the Prolog community; it has, among others, been used to assess the performance of the BAM processor [7], the KCM machine [9], the Aquarius Prolog Compiler <ref> [10] </ref>, and Parma [13], a Prolog compiler for the MIPS RISC architecture.
Reference: [11] <author> G. Specht. </author> <title> Source-to-source Transformationen zur Erklarung des Programmverhaltens bei de-duktiven Datenbanken. </title> <type> PhD thesis, </type> <institution> Technischen Universitat Munchen, </institution> <note> Juni 1992. In German. </note>
Reference-contexts: Secondly, the instrumented programs are compiled and therefore they can benefit from many of the available compiler optimizations. Thirdly, the instrumented program is traced at the level of the original program. Specht <ref> [11] </ref> showed that this feature is particularly adapted to tracing deductive databases programs as they are heavily transformed during compilation. This is also the case for plain Prolog. Indeed, many optimizations are made at compile time and the resulting code is quite different from the original one.
Reference: [12] <institution> Swedish Institute of Computer Science. </institution> <note> SICStus Prolog User's Manual, </note> <month> march </month> <year> 1998. </year> <note> Release 3.7 beta. </note>
Reference-contexts: However they had no reasonable low-level tracer at their disposal with which they could compare their results. We have performed such a comparison in the context of Prolog, using two quite different systems: ECLiPSe [8, 5], and SICStus <ref> [12] </ref>. As far as source instrumentation is concerned, it is based on an extension of O'Keefe's advice utility 1 . The instrumentation takes built-in predicates into account and provides the user with a more complete trace model. <p> 7 [4] call mem (5,[4],Y,Z) 7 [4] unify (2) mem (5,[_],Y,Z) 8 [5] call mem (5,[],Y,Z) 8 [5] fail mem (5,[],Y,Z) 7 [4] fail mem (5,[4],Y,Z) 5 [3] fail mem (5,[2,4],Y,Z) portion of the trace with counters and skipped predicates. tus is concerned, we have used SICStus version 3.7 beta <ref> [12] </ref>. This version makes it possible to trace compiled code (previous versions were relying on interpreted code for debugging) but debugging support is hidden to the compiler. In order to use source code instrumentation, the program is first instrumented through program transformation. <p> The relative slowness of Poppy on SICStus comes, at least partly, from the slowness of the blackboard (see <ref> [12] </ref>), compared to the global variables of ECLiPSe. Indeed, the blackboard in SICStus and global variables in ECLiPSe are used to implement the call number, whose handling has, according to preliminary profiling, a significant weight.
Reference: [13] <author> A. Taylor. </author> <title> High performance Prolog on a RISC. </title> <journal> New Generation Computing, </journal> <volume> 9 </volume> <pages> 221-232, </pages> <year> 1991. </year>
Reference-contexts: This suite is well known in the Prolog community; it has, among others, been used to assess the performance of the BAM processor [7], the KCM machine [9], the Aquarius Prolog Compiler [10], and Parma <ref> [13] </ref>, a Prolog compiler for the MIPS RISC architecture. It is also interesting in that it includes programs of different sizes and programming styles and does not discard the use of important built-in predicates such as arg/3, functor/3, or write/1, which often represent an important share of the execution time.
Reference: [14] <author> A. Tolmach and A. Appel. </author> <title> A debugger for Standard ML. </title> <journal> Journal of Functional Programming, </journal> <volume> 5(2) </volume> <pages> 155-200, </pages> <month> April </month> <year> 1995. </year> <month> 13 </month>
Reference-contexts: While source instrumentation has advantages over compiled code instrumentation, the usual argument in favor of compiled code instrumentation is its efficiency. Beside Specht, Calejo [2] uses source instrumentation by program transformation to trace logic programs. No performance measurements are available for any of the systems. Tolmach and Appel <ref> [14] </ref> designed and implemented a tracer for Standard ML based on automatic program source instrumentation. The resulting code runs only 3 times slower than optimized code. They conjectured that a low-level tracer would run at about the same speed.
References-found: 14

