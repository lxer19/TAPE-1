URL: http://www.cs.sunysb.edu/~juliana/schedformal.ps.gz
Refering-URL: http://www.cs.sunysb.edu/~juliana/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: A Formal Framework to Model Scheduling in Tabled Evaluations  
Author: Juliana Freire Terrance Swift David S. Warren 
Abstract: Tabled evaluation ensures termination for a large class of programs by keeping track of which subgoals have been called. Given several variant subgoals in an evaluation, only the first one encountered will use program clause resolution; the rest will resolve with the answers generated by the first subgoal. This use of answer resolution prevents infinite looping which sometimes happens in SLD. Because answers that are produced in one path of the computation may be consumed, asynchronously, in others, tabling systems face an important scheduling choice not present in traditional top-down evaluation: when to schedule answer resolution. Various scheduling strategies have been developed and implemented in the XSB tabling system. Experiments have shown that the efficiency of an evaluation is highly sensitive to the order in which operations are performed. However, the lack of a formal structure made it difficult to define these strategies more precisely, prove their correctness and compare different strategies. Here, we address this problem by proposing SLG sched , an extension of SLG that provides a formal framework to model scheduling strategies
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Boulanger. </author> <title> Fine-grained goal-directed declarative analysis of logic programs. </title> <booktitle> Proceedings of the International Workshop on Verification, Model Checking and Abstract Interpretation, </booktitle> <year> 1997. </year> <note> Available at http://www.dsi.unive.it/bossi/VMCAI.html. </note>
Reference-contexts: 1 Introduction Applications of Tabled Logic Programming are becoming common. Many abstract interpreters use tabling (or magic) to determine properties of programs <ref> [10, 3, 1] </ref>. Tabling is also used for model checking [13], for natural language analysis [12, 11], and for medical diagnosis [9].
Reference: [2] <author> W. Chen and D.S. Warren. </author> <title> Tabled Evaluation with Delaying for General Logic Programs. </title> <journal> JACM, </journal> <volume> 43(1):2074, </volume> <month> January </month> <year> 1996. </year>
Reference-contexts: Various formulations either rely implicitly on a given scheduling strategy, such as OLDT [20] or WFOS [17], or do not formulate scheduling at all as in SLG <ref> [2] </ref>. fl Bell Laboratories, 600 Mountain Avenue, Murray Hill, NJ 07974. Email: juliana@research.bell-labs.com y Department of Computer Science, University of Maryland, College Park, MD. Email: tswift@cs.umd.edu z Department of Computer Science, SUNY at Stony Brook, Stony Brook, NY 11794-4400. <p> The structure of the paper is as follows. Section 2 reviews SLG evaluation, which has been formally presented in <ref> [2] </ref>. In Section 3 we introduce SLG sched , an extension of SLG that takes scheduling into account, and show how SLG sched evaluations can be parameterized by their manipulation of the scheduling sequence. <p> section, we also show how the formalization can be used to compare Breadth-First Scheduling to magic-style evaluations, and to compare the efficiency of local to non-local evaluations when answer subsumption is used. 2 SLG: A Brief Review of Terminology SLG resolution (Linear resolution with Selection function for General logic programs) <ref> [2] </ref> is a tabled evaluation method that is sound and search space complete with respect to the well-founded partial model for all non-floundering queries. In this section we review certain definitions of SLG resolution from [2] that will be used in Section 3 to define SLG sched . <p> Brief Review of Terminology SLG resolution (Linear resolution with Selection function for General logic programs) <ref> [2] </ref> is a tabled evaluation method that is sound and search space complete with respect to the well-founded partial model for all non-floundering queries. In this section we review certain definitions of SLG resolution from [2] that will be used in Section 3 to define SLG sched . Because of space limitations, we cannot provide all definitions here, but refer the reader to [2] and to the full version of this paper. 1 Unless otherwise noted, throughout this document we restrict ourselves to non-floundering finite programs. <p> In this section we review certain definitions of SLG resolution from <ref> [2] </ref> that will be used in Section 3 to define SLG sched . Because of space limitations, we cannot provide all definitions here, but refer the reader to [2] and to the full version of this paper. 1 Unless otherwise noted, throughout this document we restrict ourselves to non-floundering finite programs. We also assume, without loss of generality, that all negative subgoals are tabled, and that a left-to-right computation rule is used. <p> subgoals fp (3,Y)g, fp (2,Y),p (3,Y)g, and fp (1,Y), p (2,Y), p (3,Y)g are all completely evaluated the evaluation has produced all possible answers for subgoals in these sets and the COMPLETION operation can be applied to any of these sets of subgoals. 2 Correctness of SLG was shown in <ref> [2] </ref>. To restate this result, we briefly review some terminology. Let F be a forest in an SLG evaluation of a program P and query Q. The partial interpretation of F , I (F ), is a set of ground atoms constructed as follows.
Reference: [3] <author> S. Dawson, C.R. Ramakrishnan, and D.S. Warren. </author> <title> Practical Program Analysis Using General Purpose Logic Programming Systems A Case Study. </title> <booktitle> In Proceedings of the ACM Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 117125. </pages> <publisher> ACM, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction Applications of Tabled Logic Programming are becoming common. Many abstract interpreters use tabling (or magic) to determine properties of programs <ref> [10, 3, 1] </ref>. Tabling is also used for model checking [13], for natural language analysis [12, 11], and for medical diagnosis [9].
Reference: [4] <author> J. Freire. </author> <title> Scheduling Strategies for Evaluation of Recursive Queries over Memory and Disk-Resident Data. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, State University of New York at Stony Brook, </institution> <year> 1997. </year>
Reference-contexts: Previous work <ref> [4, 6, 7] </ref> has shown that the scheduling strategy used can radically affect memory usage, execution time, or disk access patterns (this work is briefly summarized in Section 4). <p> As a result, it seems likely that tabling systems of the future will evaluate large programs using a mixture of scheduling strategies <ref> [4] </ref> determined by analysis of a program's requirements. Questions about scheduling also arise when comparisons are made between implementations.
Reference: [5] <author> J. Freire, R. Hu, T. Swift, and D.S. Warren. </author> <title> Exploiting Parallelism in Tabled Evaluations. </title> <booktitle> In 7th International Symposium PLILP, </booktitle> <pages> pages 115132, </pages> <year> 1995. </year>
Reference-contexts: Similar questions about scheduling occur when tabling is combined with parallelism <ref> [5, 15] </ref>. Work on both of these questions on mixing scheduling strategies and on comparing evaluation methods has been made difficult by the lack of a formal basis for scheduling in tabled evaluations.
Reference: [6] <author> J. Freire, T. Swift, and D.S. Warren. </author> <title> Beyond Depth-First: Improving tabled logic programs through alternative scheduling strategies. </title> <journal> Journal of Functional and Logic Programming, </journal> <note> 1997. To appear (An earlier version appeared in Proceedings of the 8th International Symposium PLILP, </note> <year> 1996). </year>
Reference-contexts: Previous work <ref> [4, 6, 7] </ref> has shown that the scheduling strategy used can radically affect memory usage, execution time, or disk access patterns (this work is briefly summarized in Section 4). <p> Proof: For the convenience of the referees, the proof is given in Appendix B.2. - 4 Defining Scheduling Strategies We now illustrate how the framework described in Section 3 can be used, by explaining how Single Stack Scheduling Batched Scheduling, Local Scheduling and Breadth-First Scheduling <ref> [19, 6, 7] </ref> are formulated under SLG sched . 4 We note that each of these scheduling strategies was formulated for implementation purposes, and often were driven by low-level design decisions. 4.1 Single Stack Scheduling Single Stack Scheduling was the first scheduling strategy implemented for SLG. <p> and proof of fairness for these sequence combinators can be found in the full version of this paper. 4.2 Batched Scheduling Even though Single Stack Scheduling is conceptually simple, a WAM-based implementation of Single Stack Scheduling has a number of drawbacks, most notably in memory usage (for more details see <ref> [6] </ref>). Batched Scheduling addresses these drawbacks by taking advantage of engine-level optimizations to reduce stack freezes, and trailing and untrailing. Because of this motivation, it might at first sight appear difficult to derive a sequence combinator to describe Batched Scheduling. <p> This scheduling change results, at the implementation level, in a more efficient evaluation engine than Single Stack Scheduling. 4.3 Local Scheduling As presented in <ref> [6] </ref>, Local Scheduling can be thought of as a variation of Batched Scheduling that evaluates one strongly connected component at a time. <p> It achieves this order of evaluation by ensuring that answers for a subgoal S are only returned to its calling environment either after S is completely evaluated, or after S is found not to be the leader of its SCC. In <ref> [6] </ref> we have shown that because Local Scheduling is able to avoid non-productive computation in the presence of answer subsumption: it can perform exponentially better than Batched Scheduling for problems such as aggregate computation and program analysis. Local Scheduling can also benefit the evaluation of programs with negation. <p> Proof: The proof is given in Appendix B.3. - 5 Conclusions and Future Work Scheduling has been recently recognized as a crucial component of tabled evaluations, since the efficiency of an evaluation is highly sensitive to the order in which operations are performed. The empiric results of <ref> [6] </ref>, [7] and [8] highlighted some of the characteristics of specific scheduling strategies. However, the lack of a formal structure made it difficult to define these strategies more precisely, prove their correctness and compare different strategies.
Reference: [7] <author> J. Freire, T. Swift, and D.S. Warren. </author> <title> Taking I/O seriously: Resolution reconsidered for disk. </title> <booktitle> In Proceedings of the International Conference on Logic Programming (ICLP), </booktitle> <pages> pages 198212, </pages> <year> 1997. </year>
Reference-contexts: Previous work <ref> [4, 6, 7] </ref> has shown that the scheduling strategy used can radically affect memory usage, execution time, or disk access patterns (this work is briefly summarized in Section 4). <p> As a result, it seems likely that tabling systems of the future will evaluate large programs using a mixture of scheduling strategies [4] determined by analysis of a program's requirements. Questions about scheduling also arise when comparisons are made between implementations. While <ref> [7] </ref> has demonstrated that for definite programs, relevant properties of magic-style evaluations can be captured by a special scheduling strategy for tabling, the question of comparing tabled evaluations with magic-based evaluations that include negation, such as well-founded ordered search [17] or the method of [22] remains open. <p> Proof: For the convenience of the referees, the proof is given in Appendix B.2. - 4 Defining Scheduling Strategies We now illustrate how the framework described in Section 3 can be used, by explaining how Single Stack Scheduling Batched Scheduling, Local Scheduling and Breadth-First Scheduling <ref> [19, 6, 7] </ref> are formulated under SLG sched . 4 We note that each of these scheduling strategies was formulated for implementation purposes, and often were driven by low-level design decisions. 4.1 Single Stack Scheduling Single Stack Scheduling was the first scheduling strategy implemented for SLG. <p> Because Local Scheduling delays the return of answers out of an SCC until the SCC is completely evaluated, only the most general answers are returned out of the SCC and non-productive computation (using non-optimal answers) is thus avoided. 4.4 Breadth-First Scheduling As described in <ref> [7] </ref>, Breadth-First Scheduling enforces fairness across fixpoint iterations of an evaluation, that is, subgoals called in an iteration i can only be executed in iteration i + 1, and answers created in iteration i can only be returned in iteration i + 1. <p> new otherwise, if AnswerNumber 62 ffiAnswers, BreadthF irst (op new ; ) = op new ; * If op new 2 fSC; ACR ce ; Complg, BreadthF irst (op new ; ) = op 1 ; : : : ; op n1 ; Compl (bf leader); op new 2 In <ref> [7] </ref> we presented an implementation of Breadth-First Scheduling, which was proved to be iteration equivalent to the semi-naive evaluation of a Magic-transformed (SNMT) [14] program, that is, each iteration Breadth-First Scheduling produces the same information as SNMT. Here we re-state that result using the SLG sched definition of Breadth-First Scheduling. <p> Proof: The proof is given in Appendix B.3. - 5 Conclusions and Future Work Scheduling has been recently recognized as a crucial component of tabled evaluations, since the efficiency of an evaluation is highly sensitive to the order in which operations are performed. The empiric results of [6], <ref> [7] </ref> and [8] highlighted some of the characteristics of specific scheduling strategies. However, the lack of a formal structure made it difficult to define these strategies more precisely, prove their correctness and compare different strategies.
Reference: [8] <author> J. Freire and D.S. Warren. </author> <title> Combining scheduling strategies in tabled evaluation. </title> <booktitle> In Workshop on Parallelism and Implementation Technology for Logic Programming, </booktitle> <year> 1997. </year> <note> Available at http://www.cs.nmsu.edu/lldap/ilps97. </note>
Reference-contexts: The empiric results of [6], [7] and <ref> [8] </ref> highlighted some of the characteristics of specific scheduling strategies. However, the lack of a formal structure made it difficult to define these strategies more precisely, prove their correctness and compare different strategies. Here, we address this problem by proposing a formal framework to model scheduling strategies, SLG sched .
Reference: [9] <institution> Medicine Rules Inc. Diagnostica. </institution> <type> Technical report. </type> <note> http://medicinerules.com. </note>
Reference-contexts: 1 Introduction Applications of Tabled Logic Programming are becoming common. Many abstract interpreters use tabling (or magic) to determine properties of programs [10, 3, 1]. Tabling is also used for model checking [13], for natural language analysis [12, 11], and for medical diagnosis <ref> [9] </ref>.
Reference: [10] <author> G. Janssens, M. Bruynooghe, and V. Dumortier. </author> <title> A Blueprint for an Abstract Machine for Abstract Interpretation of (Constraint) Logic Programs. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming (ILPS), </booktitle> <pages> pages 336350, </pages> <year> 1995. </year>
Reference-contexts: 1 Introduction Applications of Tabled Logic Programming are becoming common. Many abstract interpreters use tabling (or magic) to determine properties of programs <ref> [10, 3, 1] </ref>. Tabling is also used for model checking [13], for natural language analysis [12, 11], and for medical diagnosis [9].
Reference: [11] <author> R.K. Larson, D.S. Warren, J. Freire, P. Gomez, and K. </author> <title> Sagonas. </title> <publisher> Semantica. MIT Press, </publisher> <year> 1997. </year>
Reference-contexts: 1 Introduction Applications of Tabled Logic Programming are becoming common. Many abstract interpreters use tabling (or magic) to determine properties of programs [10, 3, 1]. Tabling is also used for model checking [13], for natural language analysis <ref> [12, 11] </ref>, and for medical diagnosis [9].
Reference: [12] <author> R.K. Larson, D.S. Warren, J. Freire, and K. </author> <title> Sagonas. </title> <publisher> Syntactica. MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction Applications of Tabled Logic Programming are becoming common. Many abstract interpreters use tabling (or magic) to determine properties of programs [10, 3, 1]. Tabling is also used for model checking [13], for natural language analysis <ref> [12, 11] </ref>, and for medical diagnosis [9].
Reference: [13] <author> Y. Ramakrishna, C.R. Ramakrishnan, I.V. Ramakrishnan, S. Smolka, T. Swift, and D. Warren. </author> <title> Efficient model checking using tabled resolution. </title> <booktitle> In Proceedings of Computer Aided Verification (CAV), </booktitle> <year> 1997. </year>
Reference-contexts: 1 Introduction Applications of Tabled Logic Programming are becoming common. Many abstract interpreters use tabling (or magic) to determine properties of programs [10, 3, 1]. Tabling is also used for model checking <ref> [13] </ref>, for natural language analysis [12, 11], and for medical diagnosis [9].
Reference: [14] <author> R. Ramakrishnan. </author> <title> Magic templates: A spellbinding approach to logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 11(3&4):189216, </volume> <year> 1991. </year>
Reference-contexts: ce ; Complg, BreadthF irst (op new ; ) = op 1 ; : : : ; op n1 ; Compl (bf leader); op new 2 In [7] we presented an implementation of Breadth-First Scheduling, which was proved to be iteration equivalent to the semi-naive evaluation of a Magic-transformed (SNMT) <ref> [14] </ref> program, that is, each iteration Breadth-First Scheduling produces the same information as SNMT. Here we re-state that result using the SLG sched definition of Breadth-First Scheduling.
Reference: [15] <author> R. Rocha, F. Silva, </author> <title> and V.S. Costa. On applying or-parallelism to tabled evaluations. </title> <booktitle> In Proceedings of the First International Workshop on Tabling in Logic Programming, </booktitle> <year> 1997. </year>
Reference-contexts: Similar questions about scheduling occur when tabling is combined with parallelism <ref> [5, 15] </ref>. Work on both of these questions on mixing scheduling strategies and on comparing evaluation methods has been made difficult by the lack of a formal basis for scheduling in tabled evaluations.
Reference: [16] <author> K. Sagonas, T. Swift, D.S. Warren, J. Freire, and P. Rao. </author> <title> The XSB Programmer's Manual, </title> <note> 1997. Available at http://www.cs.sunysb.edu/sbprolog. </note>
Reference-contexts: Several reasons account for this profusion of applications, among them the fact that tabled logic programs have a clear declarative semantics in the Well-Founded Semantics, several well-defined operational semantics, and high-quality implementations such as the XSB system <ref> [16] </ref> among others Experience has indicated that tabled evaluations can be highly sensitive to the order in which operations are performed, or the scheduling strategy for an evaluation.
Reference: [17] <author> P. Stuckey and S. Sudarshan. </author> <title> Well-Founded Ordered Search: Goal Directed Bottom-Up Evaluation of Well-Founded Models. </title> <journal> Journal of Logic Programming, </journal> <volume> 32(3):171205, </volume> <year> 1997. </year>
Reference-contexts: While [7] has demonstrated that for definite programs, relevant properties of magic-style evaluations can be captured by a special scheduling strategy for tabling, the question of comparing tabled evaluations with magic-based evaluations that include negation, such as well-founded ordered search <ref> [17] </ref> or the method of [22] remains open. Similar questions about scheduling occur when tabling is combined with parallelism [5, 15]. <p> Work on both of these questions on mixing scheduling strategies and on comparing evaluation methods has been made difficult by the lack of a formal basis for scheduling in tabled evaluations. Various formulations either rely implicitly on a given scheduling strategy, such as OLDT [20] or WFOS <ref> [17] </ref>, or do not formulate scheduling at all as in SLG [2]. fl Bell Laboratories, 600 Mountain Avenue, Murray Hill, NJ 07974. Email: juliana@research.bell-labs.com y Department of Computer Science, University of Maryland, College Park, MD. Email: tswift@cs.umd.edu z Department of Computer Science, SUNY at Stony Brook, Stony Brook, NY 11794-4400.
Reference: [18] <author> S. Sudarshan. </author> <title> Optimizing Bottom-up Query Evaluation for Deductive Databases. </title> <type> PhD thesis, </type> <institution> University of Wisconsin, </institution> <year> 1992. </year>
Reference: [19] <author> T. Swift and D.S. Warren. </author> <title> An Abstract Machine for SLG Resolution: Definite Programs. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming (ILPS), </booktitle> <pages> pages 633654, </pages> <year> 1994. </year>
Reference-contexts: Proof: For the convenience of the referees, the proof is given in Appendix B.2. - 4 Defining Scheduling Strategies We now illustrate how the framework described in Section 3 can be used, by explaining how Single Stack Scheduling Batched Scheduling, Local Scheduling and Breadth-First Scheduling <ref> [19, 6, 7] </ref> are formulated under SLG sched . 4 We note that each of these scheduling strategies was formulated for implementation purposes, and often were driven by low-level design decisions. 4.1 Single Stack Scheduling Single Stack Scheduling was the first scheduling strategy implemented for SLG.
Reference: [20] <author> H. Tamaki and T. Sato. </author> <title> OLDT resolution with tabulation. </title> <booktitle> In Proceedings of the International Conference on Logic Programming (ICLP), </booktitle> <pages> pages 8498, </pages> <year> 1986. </year>
Reference-contexts: Work on both of these questions on mixing scheduling strategies and on comparing evaluation methods has been made difficult by the lack of a formal basis for scheduling in tabled evaluations. Various formulations either rely implicitly on a given scheduling strategy, such as OLDT <ref> [20] </ref> or WFOS [17], or do not formulate scheduling at all as in SLG [2]. fl Bell Laboratories, 600 Mountain Avenue, Murray Hill, NJ 07974. Email: juliana@research.bell-labs.com y Department of Computer Science, University of Maryland, College Park, MD.
Reference: [21] <author> A. van Gelder, K.A. Ross, and J.S. Schlipf. </author> <title> Unfounded sets and well-founded semantics for general logic programs. </title> <journal> JACM, </journal> <volume> 38(3):620650, </volume> <year> 1991. </year>
Reference: [22] <author> U. Zukowski and B. Freitag. </author> <title> Adding flexibility to query evaluation for modularly stratified databases. </title> <booktitle> In Proceedings of the Joint International Conference and Symposium on Logic Programming (JICSLP), </booktitle> <pages> pages 304318, </pages> <year> 1996. </year> <month> 13 </month>
Reference-contexts: While [7] has demonstrated that for definite programs, relevant properties of magic-style evaluations can be captured by a special scheduling strategy for tabling, the question of comparing tabled evaluations with magic-based evaluations that include negation, such as well-founded ordered search [17] or the method of <ref> [22] </ref> remains open. Similar questions about scheduling occur when tabling is combined with parallelism [5, 15]. Work on both of these questions on mixing scheduling strategies and on comparing evaluation methods has been made difficult by the lack of a formal basis for scheduling in tabled evaluations.
References-found: 22

