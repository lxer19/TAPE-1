URL: http://www.cs.utah.edu/~mjones/papers/DamsThesis.ps
Refering-URL: http://www.cs.utah.edu/~mjones/papers/
Root-URL: 
Title: ABSTRACT INTERPRETATION AND PARTITION REFINEMENT FOR MODEL CHECKING Lint, voor een commissie aangewezen door het
Author: PROEFSCHRIFT ter verkrijging van de graad van doctor aan de van de Rector Magnificus, prof.dr. J.H. van DENNIS REN E DAMS geboren te Voorburg (ZH) 
Date: 1996 om 16.00 uur  
Note: gezag  
Affiliation: Technische Universiteit Eindhoven, op  
Pubnum: 1 juli  
Abstract-found: 0
Intro-found: 0
Reference: [ABH C 92] <author> C.J. Aarts, R.C. Backhouse, P. Hoogendijk, T.S. Voermans, and J. van der Woude. </author> <title> A relational theory of datatypes. </title> <note> Available from ftp.win.tue.nl/pub/math.prog.construction, Septem-ber 1992. </note>
Reference-contexts: Galois connections have many properties, of which we mention a few. The interested reader is referred to <ref> [Ore44, Pic52, MSS86, CC92a, ABH C 92] </ref>.
Reference: [ACD93] <author> Rajeev Alur, Costas Courcoubetis, and David Dill. </author> <title> Model-checking in dense real-time. Information and Computation, </title> <address> 104:234, </address> <year> 1993. </year>
Reference-contexts: We are currently preparing a publication on the results of these investigations 5 . Another possible extension of Chapter 4 is to consider real-time systems. Verification of such systems (see <ref> [ACD93, HNSY94] </ref> for entrances) poses a challenge as the dis-cretisation of time adds yet another dimension (besides the possible interleavings and state-space factors that cause a blow-up) to the state explosion.
Reference: [ACH C 92] <author> R. Alur, C. Courcoubetis, N. Halbwachs, D. Dill, and H. Wong-Toi. </author> <title> Minimization of timed transition systems. </title> <booktitle> In Cleaveland [Cle92], </booktitle> <pages> pages 341354. </pages>
Reference: [ACH94] <author> Rajeev Alur, Costas Courcoubetis, and Thomas A. Henzinger. </author> <title> The observational power of clocks. </title> <booktitle> In Jonsson and Parrow [JP94], </booktitle> <pages> pages 162177. </pages>
Reference-contexts: Also, in some places (e.g. <ref> [ACH94] </ref>) adequacy is defined/used as what we call fineness. 3 These quotient systems may indeed be viewed as Abstract Kripke structures, introduced in Chapter 4 (Definition 4.2.3.7). <p> Another solution consists in parametrising the Next operator with the state variable whose alteration it refers to, allowing to express for example that at the next moment that p changes, ' will hold. The operator fl of <ref> [ACH94] </ref> takes such an approach. In that framework, which considers actions, it is the occurrence of the next input symbol ( ) that determines the notion of step. A variation on this idea is found in the definition of the timed -calculus T [HNSY94].
Reference: [AH87] <editor> S. Abramsky and C. Hankin, editors. </editor> <title> Abstract Interpretation of Declarative Languages. </title> <publisher> Ellis Horwood, </publisher> <address> Chicester, </address> <year> 1987. </year>
Reference-contexts: Furthermore, in the field of program correctness it has been used, for example, to prove termination and discover inductive 1.4] Related Work 9 invariants. Literature on these subjects can be found through the bibliographies provided in [CC77] and <ref> [AH87] </ref>. [CC77] is the seminal paper that introduced Abstract Interpretation as a unifying framework for data-flow analyses. <p> A main issue in functional programming seems to be strictness analysis, while in logic programming properties of logical variables, like groundness, sharing and freeness are intensively studied. Besides that, also various applications relating to program correctness, like debugging and type checking, have been formulated as abstract interpretations. See <ref> [AH87] </ref>, [CC92a], and [JN95] for references. <p> Galois insertions A situation that occurs in many applications (e.g. see [CC77], <ref> [AH87] </ref> and also Chapter 4 of this thesis) is that .ff; fl / forms a Galois connection from C to A, while in addition fl ff is the identity function. <p> clearly be avoided; hence a criterion for reasoning about the quality of abstractions is introduced. 3.4 Related Work For an overview of various examples of, and approaches to, program analysis before the conception of the unifying framework of Abstract Interpretation the reader is referred to the bibliographies in [CC77], [MJ81], <ref> [AH87] </ref> and [AU77]. A more recent overview article is [JN95]. The idea of viewing a program analysis as an approximate computation operating on descriptions of data appears in computer science as early as 1963 in the work of Naur ([Nau63]). Another early example of the idea is given in [Sin72]. <p> See the extensive bibliography of <ref> [AH87] </ref> for pointers to applications of Abstract Interpretation in the realm of declarative programming languages. 20 Note that for the function g D ff ffi f ffi fl , the equality ff ffi f D g ffi ff does not necessarily hold. 3.5] Concluding Remarks 55 Papers presenting comparative studies of
Reference: [AO91] <author> Krzysztof R. Apt and Ernst-Rudiger Olderog. </author> <title> Verification of Sequential and Concurrent Programs. Texts and monographs in computer science. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: A more extensive overview and comparison can be found in Section 4.9. 1.4.2 Program verification For proof-based methods, introductions as well as bibliographies may be found in <ref> [AO91] </ref>, [Fra92] or [MP92, MP95] for example. The latter books are also recommended for an overview of temporal logic. Model checking was introduced independently in [QS82] and [CE81]. It has led to a large stream of both practically and theoretically oriented articles.
Reference: [ASB C 94] <author> Adnan Aziz, Vigyan Singhal, Felice Balarin, Robert K. Brayton, and Alberto L. Sangiovanni-Vincentelli. </author> <title> Equivalences for fair Kripke structures. </title> <editor> In Serge Abiteboul and Eli Shamir, editors, </editor> <booktitle> Automata, Languages and Programming, number 820 in LNCS, </booktitle> <pages> pages 364375. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1994. </year>
Reference-contexts: In [Jos90], the results of [BCG88] are generalised by considering Kripke structures together with constraints on the interaction with the environment. In particular this answers the question how to characterise fairness. <ref> [ASB C 94] </ref> also studies the equivalences that are induced by CTL and CTL fl on Kripke structures with fairness constraints. Partition refinement algorithms originate in automata theory. Algorithms for minimisation of automata (see [Hop71]) form a precursor; optimisations and adaptations have been presented in [PT87, KS90, BFH C 92].
Reference: [ASSSV94] <author> Adnan Aziz, Thomas R. Shiple, Vigyan Singhal, and Alberto L. Sangiovanni-Vincentelli. </author> <title> Formula-dependent equivalence for compositional CTL model checking. </title> <booktitle> In Dill [Dil94], </booktitle> <pages> pages 324337. 191 192 Bibliography </pages>
Reference-contexts: The partition refinement algorithm for arbitrary finite subsets of 8CTL is novel; however, the iterative computation of characteristic predicates is common in symbolic model checking, e.g. [BCM C 92]. A paper that is closely related to the idea of splitting for a single formula (Section 5.6) is <ref> [ASSSV94] </ref>. It studies the behavioural equivalence that is induced by a single CTL formula. This equivalence is used to reduce the size of automata in a compositional framework.
Reference: [AU77] <author> A.V. Aho and J.D. Ullman. </author> <title> Principles of Compiler Design. </title> <publisher> Addison-Wesley, </publisher> <address> Amsterdam, </address> <year> 1977. </year>
Reference-contexts: avoided; hence a criterion for reasoning about the quality of abstractions is introduced. 3.4 Related Work For an overview of various examples of, and approaches to, program analysis before the conception of the unifying framework of Abstract Interpretation the reader is referred to the bibliographies in [CC77], [MJ81], [AH87] and <ref> [AU77] </ref>. A more recent overview article is [JN95]. The idea of viewing a program analysis as an approximate computation operating on descriptions of data appears in computer science as early as 1963 in the work of Naur ([Nau63]). Another early example of the idea is given in [Sin72].
Reference: [BBLS92] <author> S. Bensalem, A. Bouajjani, C. Loiseaux, and J. Sifakis. </author> <title> Property preserving simulations. </title> <booktitle> In von Bochmann and Probst [vBP92], </booktitle> <pages> pages 251 263. </pages>
Reference-contexts: Preservation of full CTL fl is shown in the context of strong preservation only. The preservation results are based on the properties of homomorphic functions, which have a long history in property preservation; see also Section 4.9. <ref> [BBLS92] </ref> generalises some of these results by presenting preservation results in the setting of simulations, which may be considered a generalisation of homomorphisms, and the -calculus, which exceeds CTL fl in expressivity. <p> The theory about preservation between, and the construction of, transition systems presented in Chapter 4 of this thesis is based on [DGG94], presenting material that was developed independently from <ref> [BBLS92, Loi94] </ref>. That paper focusses on the definition of a notion of abstraction of transition systems that preserves properties from full CTL fl . <p> Section 3.3). This is then formally justified 1 The notions of universality and safety of a property are not always distinguished as explicitly as we do in this thesis. What we call universal safety is often just termed safety or invariance elsewhere. 2 <ref> [Kur90, CGL92, BBLS92, Loi94, DGG94, CR94, CIY95, Kel95] </ref>; see Section 4.9 for a more complete overview and comparison. 4.2] Abstract Kripke Structures 59 in Section 4.4. <p> Some of the first papers that consider the (strong) preservation of full CTL fl and L are [CGL92] and <ref> [BBLS92] </ref>. Following [Kur90], [CGL92] defines the relation between the concrete and abstract model by means of a homomorphism h, which induces an equivalence relation ~ on the concrete states, defined by c ~ d , h.c/ D h.d/. The abstract states are then representations of the equivalence classes of ~. <p> A journal version appeared as [CGL94]. [Lon93] also contains these results, presented in a slightly more general setting. <ref> [BBLS92] </ref> presents similar ideas in a more general setting by considering simulation relations to connect the concrete and abstract transition systems. Also, properties are preserved in the -calculus, L , which is a more powerful logic than CTL fl . <p> Again, preservation of the full -calculus is only shown for abstractions that are bisimilar to C. The construction of abstract models, which is only briefly touched upon in <ref> [BBLS92] </ref>, is worked out further in the journal version, [LGS C 95], where it is shown in addition how the abstraction of a concurrent system can be constructed composi-tionally from the abstractions of the individual components. <p> This is further discussed in Section 4.9.1 below. [Kel95] also discusses the preservation of universal and existential -calculus properties within the framework of Abstract Interpretation. As in <ref> [BBLS92] </ref>, the relation between abstract and concrete systems is defined through simulations cast in the form of Galois connections. The interpretation of a -calculus formula, which is a set of states, is approximated from below and above. <p> Of a more fundamental nature is the investigation of a framework that enables the comparison and unification of the theories presented in <ref> [BBLS92] </ref>, [Kel95], and Chapter 4. Also regarding Chapter 6, a possible direction for future work is to extend the results, in particular the definition of flat logics and the corresponding adequacy results, to real-time versions of those logics.
Reference: [BCG88] <author> M.C. Browne, E.M. Clarke, and O. Grumberg. </author> <title> Characterizing finite Kripke structures in propositional temporal logic. </title> <journal> Journal of Theoretical Computer Science, </journal> <volume> 59:115131, </volume> <year> 1988. </year>
Reference-contexts: DiVerent instances of the idea consider variations like weak and branching bisimulation (the latter equivalence coincides with the equivalences induced by CTL fl .U/ and CTL.U/; also see the next chapter), see <ref> [BCG88, GV90, FKM93] </ref>. Such algorithms may be used to reduce the size of a transition system while strongly preserving the corresponding logics. Below, we first briefly recall a simple version of the PRA for bisimulation, which underlies most of the mentioned algorithms. <p> Partition refinement algorithms that divide out the equivalence classes of some behavioural equivalence by successive refinement of the blocks of a partition have been presented for bisimu-lation (e.g. in [PT87, BFH C 92]) and stuttering (or branching) equivalence (e.g. in <ref> [BCG88, GV90] </ref>). These equivalences both correspond to logics that are closed under negation, namely CTL fl and CTL fl .U/ (also see the next chapter). For simulation equivalence, the only previous decision algorithm that we know of is [CC95], which does not fit the partition refinement scheme. <p> Furthermore, partition refinement algorithms have been developed for a number of such behavioural equivalences. For example, the partition refinement algorithm developed in [BFH C 92] computes the equivalence classes under bisimulation equivalence. Another example is the partition refinement algorithm for stuttering equivalence (branching bisimulation) of [GV90]. In <ref> [BCG88] </ref>, stuttering equivalence has been shown to coincide with the equivalences induced by CTL.U/ and CTL fl .U/. In those cases, these algorithms may be used to construct abstract models that strongly preserve the corresponding logic. <p> It turns out that a silent move is observable iV it coincides with a CTL fl step (Section 2.3.1) in the sense that we discussed above. This follows from the 6.3] Nextless CTL fl and CTL 155 results of <ref> [BCG88] </ref> and [DNV90b], which imply that, roughly 8 , branching equivalence is adequate for CTL fl .U/. Adding back the Next operator to CTL fl .U/ results in a logic whose induced equivalence is finer than branching equivalence and thus too fine according to [vG93b]. <p> It is this fact that justifies the definition of stuttering equivalence as dbs-equivalence in the livelock extension ([DNV90b]). Historical note Stuttering equivalence was first defined in <ref> [BCG88] </ref> on finite Kripke structures. <p> Another disadvantage of Definition 6.3.2.17 is that the development of a partition refinement algorithm for stuttering equivalence seems to require an alternative 6.4] Partition Refinement Algorithms 163 definition in terms of finite prefixes anyway (see Section 5 of <ref> [BCG88] </ref>). <p> Indeed, for both bisimulation and stuttering equivalence such algorithms have been developed, see [BFH C 92], <ref> [BCG88] </ref> and [GV90]. In this section, we generalise the common concepts that underly both algorithms, and present a generic scheme of which they are instantiations that are induced by the format of the definition of the behavioural equivalence. <p> Comparing Definition 6.2.0.1 of bis to Definition 6.3.2.3 of dbs , we see that each equivalence is defined as the largest symmetric equivalence such that: 1. 0 . 11 The loop predicate in <ref> [BCG88] </ref> is actually stronger than our infstut . However, it follows from the Stuttering Lemma (Lemma 6.3.2.15) that also in [BCG88] it may be weakened. 164 Logics, Equivalences and Behavioural Partition Refinement [6.4 2. <p> of bis to Definition 6.3.2.3 of dbs , we see that each equivalence is defined as the largest symmetric equivalence such that: 1. 0 . 11 The loop predicate in <ref> [BCG88] </ref> is actually stronger than our infstut . However, it follows from the Stuttering Lemma (Lemma 6.3.2.15) that also in [BCG88] it may be weakened. 164 Logics, Equivalences and Behavioural Partition Refinement [6.4 2. If s t , then for every s-prefix s of a certain form, there exists a t -prefix t of similar form. <p> Several later studies have investigated the links between bisimulation and the equivalences induced by these logics ([HM80, GS84, HM85, Sti89, BCG88, LGS C 95, Cho95]) as well as between variations on these notions ([BR83, BCG88, DNV90b, BFG C 91, GKP92, vBvES94]). In [Jos90], the results of <ref> [BCG88] </ref> are generalised by considering Kripke structures together with constraints on the interaction with the environment. In particular this answers the question how to characterise fairness. [ASB C 94] also studies the equivalences that are induced by CTL and CTL fl on Kripke structures with fairness constraints. <p> Algorithms for minimisation of automata (see [Hop71]) form a precursor; optimisations and adaptations have been presented in [PT87, KS90, BFH C 92]. For the case of CTL fl .U//stut 180 Logics, Equivalences and Behavioural Partition Refinement [6.8 tering equivalence, partition refinement algorithms can be found in <ref> [BCG88, GV90] </ref>. The reader who is interested in game characterisations of equivalences could have a look at [Ehr61, Fra54, IK87, Tho93, NC94]. 6.8 Concluding Remarks We have investiged the correspondences between a number of temporal logics and behavioural equivalences, and also between behavioural equivalences and partition refinement algorithms. <p> Although most of these results are not new, there are a few places where we have established generalisations of older results. Most notably, we did not require finiteness of the transition system, while this is an essential condition in both <ref> [BCG88] </ref> and [DNV90b]. Indeed, in those papers a stronger correspondence between stuttering equivalence and CTL.U/ is proven, namely that every (finite) Kripke structure can be characterised (up to stuttering equivalence) by a single CTL.U/ formula 15 . For adequacy, only a certain form of finite branchingness is needed.
Reference: [BCM C 92] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, D. L. Dill, and L. J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. Information and Computation, </title> <address> 98:142170, </address> <year> 1992. </year>
Reference-contexts: This is a tree-like structure that is used to, often compactly, represent a set of bitstrings; BDDs have gained popularity in the field of verification lately see e.g. [DJS95, McM93]. That this approach may lead to spectacular results is evidenced by papers like <ref> [BCM C 92, MS92b, CGH C 93] </ref>. Although symbolic model checking has actually found its way into industry on an extensive scale, it is not a panacea. <p> The partition refinement algorithm for arbitrary finite subsets of 8CTL is novel; however, the iterative computation of characteristic predicates is common in symbolic model checking, e.g. <ref> [BCM C 92] </ref>. A paper that is closely related to the idea of splitting for a single formula (Section 5.6) is [ASSSV94]. It studies the behavioural equivalence that is induced by a single CTL formula. This equivalence is used to reduce the size of automata in a compositional framework.
Reference: [BCM95] <author> Maurice Bruynooghe, Michael Codish, and Anne Mulkers. </author> <title> Abstract unification: A key step in the design of logic programs. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Computer Science Today, number 1000 in LNCS, </booktitle> <pages> pages 406425. </pages> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1995. </year>
Reference-contexts: This is the case with the unification operator in logic programs for example (see <ref> [BCM95] </ref>). 188 In Conclusion [7.2 A third diVerence is that in the partition-refinement approach, the abstract states are always disjoint 2 .
Reference: [Ben76] <author> J.F.A.K. van Benthem. </author> <title> Modal Correspondence Theory. </title> <type> PhD thesis, </type> <institution> Insti-tuut voor Grondslagenonderzoek, University of Amsterdam, </institution> <year> 1976. </year>
Reference-contexts: If T is finite, this boils down to detecting cycles within dbflat classes. 6.7 Related Work In modal logic, bisimulation-like concepts have been around for a long time, e.g. the zig-zag relations introduced in the 60s (a survey can be found in [Ben94]), and the p-relations in <ref> [Ben76] </ref>. In computer science, bisimulation is usually attributed to Park, who introduced the term in [Par81], in the context of automata. Milner introduced the notion of simulation in [Mil71] and observational equivalence in [Mil80].
Reference: [Ben94] <author> Johan van Benthem. </author> <title> Correspondence theory. </title> <editor> In D. Gabbay and F. Guenthner, editors, </editor> <booktitle> Handbook of Philosophical Logic, volume 2 of Syn-these Library. Studies in Epistemology, Logic, Methodology, and Philosophy of Science, chapter II.4, </booktitle> <pages> pages 167247. </pages> <publisher> Kluwer Academic Publishers, </publisher> <address> Dordrecht, </address> <year> 1994. </year>
Reference-contexts: If T is finite, this boils down to detecting cycles within dbflat classes. 6.7 Related Work In modal logic, bisimulation-like concepts have been around for a long time, e.g. the zig-zag relations introduced in the 60s (a survey can be found in <ref> [Ben94] </ref>), and the p-relations in [Ben76]. In computer science, bisimulation is usually attributed to Park, who introduced the term in [Par81], in the context of automata. Milner introduced the notion of simulation in [Mil71] and observational equivalence in [Mil80].
Reference: [BFG C 91] <author> A. Bouajjani, J.C. Fernandez, S. Graf, C. Rodriguez, and J. Sifakis. </author> <title> Safety for branching time semantics. </title> <editor> In J. Leach Albert, B. Monien, and M. Rodr guez Artalejo, editors, </editor> <booktitle> Automata, Languages and Programming, number 510 in LNCS, </booktitle> <pages> pages 7692. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1991. </year>
Reference: [BFH90] <author> A. Bouajjani, J. C. Fernandez, and N. Halbwachs. </author> <title> On the verification of safety properties. </title> <type> Technical Report SPECTRE L12, </type> <institution> Laboratoire d'Informatique et de Mathematiques Appliqees de Grenoble, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: For an overview see [CGL93]. On-the-fly (or: on-line) techniques minimise the memory demands of model checkers by only expanding those parts of the program that are needed to verify the given property. Being exposed in e.g. <ref> [JJ89, BFH90, FM91] </ref>, these techniques have indeed been used before in many verifiers developed by G. Holzmann; see e.g. [Hol84, Hol91]. An approach from the second category is formed by the partial-order techniques, which abstract from diVerent interleavings of actions originating from concurrent components of a program.
Reference: [BFH C 92] <author> A. Bouajjani, J.-C. Fernandez, N. Halbwachs, P. Raymond, and C. Ra-tel. </author> <title> Minimal state graph generation. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 18:247269, </address> <year> 1992. </year> <note> Bibliography 193 </note>
Reference-contexts: In contrast, reductions with respect to bisimulation equivalence (e.g. <ref> [BFH C 92] </ref>) only allow a limited reduction, in the sense that only states that are bisimilar may be identified by the abstraction. <p> The question is how we can detect this situation. We cannot take ready :D . P D P 0 / as a criterion: the program will then never terminate as every stratum contains new formulae. In similar partition refinement algorithms, e.g. the algorithm of <ref> [BFH C 92] </ref> that splits for CTL, or the algorithms for preorder checking in [CC95], one-step-stability is used as a termination criterion: if the constructed model (or, relation in [CC95]) remains unchanged during one step of the while loop, it may be concluded that no subsequent steps will cause changes anymore. <p> Partition refinement algorithms that divide out the equivalence classes of some behavioural equivalence by successive refinement of the blocks of a partition have been presented for bisimu-lation (e.g. in <ref> [PT87, BFH C 92] </ref>) and stuttering (or branching) equivalence (e.g. in [BCG88, GV90]). These equivalences both correspond to logics that are closed under negation, namely CTL fl and CTL fl .U/ (also see the next chapter). <p> Furthermore, partition refinement algorithms have been developed for a number of such behavioural equivalences. For example, the partition refinement algorithm developed in <ref> [BFH C 92] </ref> computes the equivalence classes under bisimulation equivalence. Another example is the partition refinement algorithm for stuttering equivalence (branching bisimulation) of [GV90]. In [BCG88], stuttering equivalence has been shown to coincide with the equivalences induced by CTL.U/ and CTL fl .U/. <p> Indeed, for both bisimulation and stuttering equivalence such algorithms have been developed, see <ref> [BFH C 92] </ref>, [BCG88] and [GV90]. In this section, we generalise the common concepts that underly both algorithms, and present a generic scheme of which they are instantiations that are induced by the format of the definition of the behavioural equivalence. <p> Partition refinement algorithms originate in automata theory. Algorithms for minimisation of automata (see [Hop71]) form a precursor; optimisations and adaptations have been presented in <ref> [PT87, KS90, BFH C 92] </ref>. For the case of CTL fl .U//stut 180 Logics, Equivalences and Behavioural Partition Refinement [6.8 tering equivalence, partition refinement algorithms can be found in [BCG88, GV90].
Reference: [BG87] <author> J. C. M. Baeten and R. J. van Glabbeek. </author> <title> Another look at abstraction in process algebra (extended abstract). </title> <editor> In Thomas Ottmann, editor, </editor> <booktitle> Automata, Languages and Programming, number 267 in LNCS, </booktitle> <pages> pages 8494. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year>
Reference-contexts: Several observational or weak equivalences have been proposed to more faithfully capture the notion of equivalence in the presence of silent moves: observational equivalence in the sense of [HM85], observation equivalence (called t -bisimulation equivalence in [BK85]) of [Mil80], -bisimulation of <ref> [BG87] </ref>, delay bisimulation of [Mil83], and branching bisimulation of [GW89]. In [vG93b], van Glabbeek convincingly argues that, in a sense, branching bisimulation equivalence (branching equivalence for short) is the coarsest equivalence that respects the branching structure of a process with silent moves.
Reference: [BG93] <author> Orna Bernholtz and Orna Grumberg. </author> <title> Branching time temporal logic and amorphous tree automata. In Eike Best, editor, </title> <booktitle> CONCUR '93, number 715 in LNCS, </booktitle> <pages> pages 262277. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: Recently, much research has concentrated on tackling the state-explosion problem, see the two subsections below. In connection 1.4] Related Work 11 with the automata-theoretic approach to model checking ([VW86, Kur90, Kur94]), we should mention the recent developments of <ref> [BG93, BVW94] </ref>, which extend the method to branching-time temporal logics. In process algebraic theories ([Mil80, Hoa85, BW90]), the specification of a program is usually expressed by another (simpler) program that it has to be behavioural-ly equivalent to. Thus, this is closer to the full verification of programs. <p> Traditionally, automata-theoretic algorithms are used for linear-time temporal logic, while the graph-traversal algorithms were devised in the context of CTL and the -calculus. Indeed, the first model-checking algorithm for CTL fl , which subsumes both LTL and CTL, combines both techniques in one algorithm (see [EL87]). Recent work, <ref> [BG93, BVW94, Kup95] </ref>, shows that eYcient branching-time model checking can be captured in the automata-theoretic framework too, using alternating-tree automata. The complexity of model checking increases with the expressivity of the temporal logic.
Reference: [BHA86] <author> G. Burn, C. Hankin, and S. Abramsky. </author> <title> Strictness analysis for higher order functions. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 7:249278, </address> <year> 1986. </year>
Reference-contexts: This is illustrated by a unified analysis that captures many analyses used in the field of functional languages. Adaptations of the original Galois-connection framework in the realm of various programming paradigms are: <ref> [BHA86, Nie88] </ref> in the context of functional programs, which drop the requirement of best concretisations; [MS89a, MS92a] in the context of logic programs, which drop the requirement of best descriptions; and [MJ86] in the context of non-recursive programs, which drops both the requirements of best concretisations and best descriptions.
Reference: [Bir67] <author> Garrett BirkhoV. </author> <title> Lattice Theory, </title> <booktitle> volume 25 of American Mathematical Society Colloquium Publications. </booktitle> <publisher> American Mathematical Society, </publisher> <address> Providence, Rhode Island, third edition, </address> <year> 1967. </year>
Reference-contexts: The set of partitions of A is partially ordered by the refinement order E defined by 5 1 E 5 2 iV 8 B 1 25 1 9 B 2 25 2 B 1 B 2 . With this order, the partitions of A form a lattice (see e.g. <ref> [Bir67] </ref>); in particular, its glb 4 is defined by 5 1 45 2 D fB 1 " B 2 j B 1 2 5 1 ; B 2 2 5 2 ; B 1 " B 2 6D ;g.
Reference: [BK85] <author> J.A. Bergstra and J.W. Klop. </author> <title> Algebra of communicating processes with abstraction. </title> <journal> Journal of Theoretical Computer Science, </journal> <volume> 37(1):77121, </volume> <year> 1985. </year>
Reference-contexts: Several observational or weak equivalences have been proposed to more faithfully capture the notion of equivalence in the presence of silent moves: observational equivalence in the sense of [HM85], observation equivalence (called t -bisimulation equivalence in <ref> [BK85] </ref>) of [Mil80], -bisimulation of [BG87], delay bisimulation of [Mil83], and branching bisimulation of [GW89]. In [vG93b], van Glabbeek convincingly argues that, in a sense, branching bisimulation equivalence (branching equivalence for short) is the coarsest equivalence that respects the branching structure of a process with silent moves.
Reference: [BK90] <editor> J.C.M. Baeten and J.W. Klop, editors. </editor> <title> CONCUR '90. Theories of Con-currency: Unification and Extension, </title> <booktitle> number 458 in LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: Branching bisim-ulation has been proposed as an alternative to observational equivalence in, among others, [GW89, vG90a, vG93a, vG93b]. A large variety of behavioural equivalences has been defined and studied over the past ten years; see [DN87] for a discussion. Also <ref> [BK90] </ref> contains a lot of material on this topic. The conception of bisimulation took place independent of the development of branching-time temporal logics like CTL ([CE81]), CTL fl ([EH86]), -calculus ([Koz83]) and Hennessy-Milner Logic ([HM85]).
Reference: [BK95] <author> J.A. Bergstra and P. Klint. </author> <title> The disrete time toolbus. </title> <type> Technical Report P9502, </type> <institution> Dept. of Math. and Comp. Sc., University of Amsterdam, </institution> <month> March </month> <year> 1995. </year>
Reference: [BKS83] <author> R. J. R. Back and R. Kurki-Suonio. </author> <title> Decentralization of process nets with centralized control. </title> <booktitle> In 2nd ACM SIGACTSIGOPS Symp. on Principles of Distributed Computing, </booktitle> <pages> pages 131142. </pages> <publisher> ACM, </publisher> <address> New York, </address> <year> 1983. </year>
Reference-contexts: In that case, abstract interpretation is a non-standard interpretation over a domain of data descriptions. To illustrate this, we need to fix a programming language . We use a language that is based on action systems <ref> [BKS83] </ref>, that, although being very simple, will help 11 denotes the programming language; below, we will become more specific about the syntax of programs. 12 Ideally, ff I.P/ equals ff M .I.P//; indeed, we will later identify conditions under which this is the case for any P. 68 Abstract Interpretation of
Reference: [Bou92] <author> Francois Bourdoncle. </author> <title> Abstract interpretation by dynamic partitioning. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(4):407435, </volume> <year> 1992. </year>
Reference-contexts: Indeed, Abstract Interpretation, in a narrow sense, is often understood to be the analysis of programs by approximating the (least) solution to a system of recursive equations representing the behaviour of a (repetitive or recursive) program, see for example <ref> [CC92c, Bou92, LV92] </ref>. * The third motivation is closely related to the second one. In computer science applications, the concrete objects are usually semantic models of programs. In most traditional approaches to semantics, models are partially ordered (sometimes for diVerent reasons than the existence of fixpoints).
Reference: [Bou50] <author> Nicolas Bourbaki. Sur le theoreme de Zorn. </author> <title> Archiv Der Mathematik, </title> <publisher> 2:435437, 1949/50. </publisher>
Reference: [BR83] <author> Stephen D. Brookes and William C. </author> <title> Rounds. Behavioural equivalence relations induced by programming logics. </title> <editor> In J. Diaz, editor, </editor> <booktitle> Automata, Languages and Programming, number 154 in LNCS, </booktitle> <pages> pages 97108. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1983. </year> <note> 194 Bibliography </note>
Reference: [Bry86] <author> Randal E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(8):677691, </volume> <year> 1986. </year>
Reference-contexts: A very popular approach in the first category is symbolic model checking, in which the transition graph is represented by a reduced, ordered binary decision diagram (see <ref> [Bry86] </ref>). This is a tree-like structure that is used to, often compactly, represent a set of bitstrings; BDDs have gained popularity in the field of verification lately see e.g. [DJS95, McM93]. <p> It relies on the availability of the pre-image function pre R (Definition 2.1.0.1) of the transition relation R, which may be viewed as an implicit or symbolic representation of the transition system. Hence, such algorithms are often termed symbolic. Recently, reduced ordered binary decision diagrams (BDDs, see <ref> [Bry86] </ref>) have been proposed as eYcient representations of both sets of states and transition relations ([BCM C 92, CBM89]), leading to a renewed interest in this symbolic approach.
Reference: [Bur92] <author> Jerry R. Burch. </author> <title> Trace Algebra for Automatic Verification of Real-Time Concurrent Systems. </title> <type> PhD thesis, </type> <institution> School of Comp. Sc., Carnegie Mellon University, </institution> <address> Pittsburgh, PA 15213, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: Our approach treats data and control in a uniform way and hence has a more general applicability. Other general frameworks for abstraction in the context of model checking, besides those already mentioned above, are presented in [Sif82, Sif83] (containing much pioneering research), [Kur90] (homomorphic reductions), <ref> [Bur92] </ref> (in the context of trace theory, mainly in a real-time setting) and [Lon93] (combined with compositional techniques). In Chapters 5 and 6 of this thesis, we study partition refinement algorithms, which reduce the size of a transition system by constructing the quotient under some equivalence relation.
Reference: [BVW94] <author> Orna Bernholtz, Moshe Y. Vardi, and Pierre Wolper. </author> <title> An automata-theoretic approach to branching-time model checking (extended abstract). </title> <booktitle> In Dill [Dil94], </booktitle> <pages> pages 142155. </pages>
Reference-contexts: Recently, much research has concentrated on tackling the state-explosion problem, see the two subsections below. In connection 1.4] Related Work 11 with the automata-theoretic approach to model checking ([VW86, Kur90, Kur94]), we should mention the recent developments of <ref> [BG93, BVW94] </ref>, which extend the method to branching-time temporal logics. In process algebraic theories ([Mil80, Hoa85, BW90]), the specification of a program is usually expressed by another (simpler) program that it has to be behavioural-ly equivalent to. Thus, this is closer to the full verification of programs. <p> Traditionally, automata-theoretic algorithms are used for linear-time temporal logic, while the graph-traversal algorithms were devised in the context of CTL and the -calculus. Indeed, the first model-checking algorithm for CTL fl , which subsumes both LTL and CTL, combines both techniques in one algorithm (see [EL87]). Recent work, <ref> [BG93, BVW94, Kup95] </ref>, shows that eYcient branching-time model checking can be captured in the automata-theoretic framework too, using alternating-tree automata. The complexity of model checking increases with the expressivity of the temporal logic.
Reference: [BW90] <author> J.C.M. Baeten and W.P. Weijland. </author> <title> Process Algebra. </title> <booktitle> Number 18 in Cam-bridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1990. </year>
Reference: [CBM89] <author> Olivier Coudert, Christian Berthet, and Jean Christophe Madre. </author> <title> Verification of synchronous sequential machines based on symbolic execution. </title> <booktitle> In Sifakis [Sif89], </booktitle> <pages> pages 365373. </pages>
Reference: [CC77] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Proc. 4th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 238252, </pages> <address> Los Angeles, California, </address> <year> 1977. </year>
Reference-contexts: Although their goals may be more diverse, data-flow analyses can be given a place in the taxonomy presented above. They are a-posteriori, model-based, automatic and property-aimed. In <ref> [CC77] </ref>, a unified formal framework for data-flow analyses is proposed, called Abstract Interpretation. <p> Furthermore, in the field of program correctness it has been used, for example, to prove termination and discover inductive 1.4] Related Work 9 invariants. Literature on these subjects can be found through the bibliographies provided in <ref> [CC77] </ref> and [AH87]. [CC77] is the seminal paper that introduced Abstract Interpretation as a unifying framework for data-flow analyses. <p> Furthermore, in the field of program correctness it has been used, for example, to prove termination and discover inductive 1.4] Related Work 9 invariants. Literature on these subjects can be found through the bibliographies provided in <ref> [CC77] </ref> and [AH87]. [CC77] is the seminal paper that introduced Abstract Interpretation as a unifying framework for data-flow analyses. <p> Furthermore, the section on power construction exposes and formalises a common dilemma in Abstract Interpretation, giving a number of theoretical results. 3.1.1 Abstract Interpretation The term Abstract Interpretation was introduced in <ref> [CC77] </ref> and denotes a unified approach to program analysis (also called data-flow, static or compile-time analysis) by formalising an analysis as an approximate computation operating on descriptions of data. The following informal definition is given in that paper. A program denotes computations in some universe of objects. <p> This shift of attention from single elements to sets is indeed explicitly made in much of the Cousots' work, where it occurs through the lifting of the standard semantics to the collecting semantics see e.g. [CC92b] or <ref> [CC77] </ref>, where the term static semantics is used instead of collecting semantics. Alternatively, we may specify the relation between concrete and abstract objects through an abstraction function ff 2 P.Z/ ! fneg; posg. <p> The term abstract interpretation, written 3.1] Introduction 33 in lower case, is used with this connotation in this thesis. The capitalised term Abstract Interpretation, on the other hand, denotes a particular theory (or: collection of theories), which will be presented in Section 3.2.1. In the definition from <ref> [CC77] </ref> quoted above, as well as in the example, the main concern of Abstract Interpretation is the construction of descriptions of concrete objects by mimicking the eVect of concrete operations with suitable (safe) abstract operations defined over descriptions. <p> It turns out that in many applications of abstraction theories, this order coincides with the orderings as meant under the other points (see also Section 3.3.1). In fact, the framework described in the seminal <ref> [CC77] </ref> does not distinguish between those orderings; [CC92b] does. <p> Galois insertions A situation that occurs in many applications (e.g. see <ref> [CC77] </ref>, [AH87] and also Chapter 4 of this thesis) is that .ff; fl / forms a Galois connection from C to A, while in addition fl ff is the identity function. <p> look for abstract counterparts ff lfp and ff f such that ff.lfp. f // ff lfp. ff f / (3.16) We choose to take for ff lfp the least fixpoint operator on the abstract domain (although diVerent choices exist, for example in the form of widening and narrowing techniques, see <ref> [CC77, CC92c, CC92b] </ref>). The following result specifies a condition on ff f in order for 3.16 to hold. It appears in many of the papers by the Cousots and is sometimes referred to as the fundamental theorem 18 . <p> Proof. ff ffi f ff f ffi ff ) f fl is monotonic g fl ffi ff ffi f ffi fl v fl ffi ff f ffi ff ffi fl 18 The earliest place it is hinted at is paragraph 8.1 of <ref> [CC77] </ref>, as far as we know. Theorem 7.1.0.4 of [CC79] contains an explicit statement of the result. <p> solutions should clearly be avoided; hence a criterion for reasoning about the quality of abstractions is introduced. 3.4 Related Work For an overview of various examples of, and approaches to, program analysis before the conception of the unifying framework of Abstract Interpretation the reader is referred to the bibliographies in <ref> [CC77] </ref>, [MJ81], [AH87] and [AU77]. A more recent overview article is [JN95]. The idea of viewing a program analysis as an approximate computation operating on descriptions of data appears in computer science as early as 1963 in the work of Naur ([Nau63]). <p> Another early example of the idea is given in [Sin72]. The Cousots are the first to relate standard to non-standard semantics by a Galois insertion <ref> [CC77] </ref>.
Reference: [CC79] <author> P. Cousot and R. Cousot. </author> <title> Systematic design of program analysis frameworks. </title> <booktitle> In Proc. 6th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 269282, </pages> <address> San Antonio, Texas, </address> <year> 1979. </year>
Reference-contexts: Each solution has its pros and cons, which we will not discuss here. The interested reader is referred to <ref> [CC79] </ref>, [Mar93] and [CC92b]. Another point is whether ; should have an ff image. One may claim that this is not necessary because there is no need for a description of it. <p> The approximation relation between abstract transition systems defined there is a preorder but not a partial order. 7 A diVerent choice would be to identify the description relation () with the safety relation (8 '2L [c jD ' ( a jD ff ']); see e.g. <ref> [CC79, CC92b] </ref>. All abstract objects that are safe for c are then captured in post * .c/. <p> E.g. in <ref> [CC79] </ref> and [CC94], where abstract objects are identified with properties, the precision order on abstract objects coincides with logical implication. 40 Abstraction and Preservation [3.2 An alternative way of specifying an approximative description is through an abstraction relation ff that associates a concrete object with descriptions for it, and a concretisation <p> Thus, the abstract domain may be normalised to ff.fl .A//. This is called reduction in [CC92a]. In [Ore44], such a Galois connection is called perfect in A, [CC92a] calls it a Galois surjection and [MSS86] a Galois insertion from A to C. 3.2.1.10 Lemma (Theorem 5.3.0.6 in <ref> [CC79 ] </ref>) Let .ff; fl / be a Galois connec tion from .C; v/ to .A; /. Then the following are equivalent. 1. fl ff D id . 44 Abstraction and Preservation [3.2 2. fl is an embedding. 3. ff is surjective. 4. fl is injective. <p> Theorem 7.1.0.4 of <ref> [CC79] </ref> contains an explicit statement of the result. <p> It is this observation on which the condition in Lemma 4.5.1.2 below is based. Now consider the step from 4.19 to 4.16 more precisely, the replacement of subformula 4.18 by 4.17. In 4.18, the minimality of Y is determined globally over 22 See <ref> [CC79] </ref> for a variety of techniques for the construction of suitable abstract domains. 4.5] Optimal Abstract Interpretations 85 all actions, while in 4.17 all Y s that are minimal relative to a single action i 2 J are taken. <p> This approach corresponds to the merge over all paths analysis of <ref> [CC79] </ref>. 4.6 Computing Approximations One may deliberately choose to compute non-optimal abstractions by specifying approximations to the abstract interpretations of the c i and t i .
Reference: [CC82] <author> A. Cardon and M. Crochemore. </author> <title> Partitioning a graph in O.j Aj log 2 jV j/. </title> <journal> Journal of Theoretical Computer Science, </journal> <volume> 19:8598, </volume> <year> 1982. </year>
Reference: [CC84] <author> Patrick Cousot and Radhia Cousot. </author> <title> Invariance proof methods and analysis techniques for parallel programs. </title> <editor> In Alan W. Biermann, Gerard Guiho, and Yves KodratoV, editors, </editor> <title> Automatic Program Construction Techniques, </title> <booktitle> chapter 12, </booktitle> <pages> pages 243271. </pages> <publisher> Macmillan Publishing Company, </publisher> <address> New York, </address> <year> 1984. </year>
Reference-contexts: The Cousots are the first to relate standard to non-standard semantics by a Galois insertion [CC77]. They published many papers on the subject around the end of the 70s (see the bibliography of [CC92b]), and, after a period of relative silence (but see <ref> [CC84] </ref>), displayed a renewed interest in the subject at the beginning of the 90s: [CC92a, CC92c, CC92b]. [CC92a] contains a wealth of examples of everyday abstract interpretations, as well as more advanced program analyses.
Reference: [CC92a] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation and application to logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 13:103179, </volume> <year> 1992. </year>
Reference-contexts: A main issue in functional programming seems to be strictness analysis, while in logic programming properties of logical variables, like groundness, sharing and freeness are intensively studied. Besides that, also various applications relating to program correctness, like debugging and type checking, have been formulated as abstract interpretations. See [AH87], <ref> [CC92a] </ref>, and [JN95] for references. <p> Galois connections have many properties, of which we mention a few. The interested reader is referred to <ref> [Ore44, Pic52, MSS86, CC92a, ABH C 92] </ref>. <p> The approach that we follow in this chapter has been influenced by the (successful) eVorts of Marriott and Sndergaard to give an orderly account of the theory and some of its applications: [MS89b, Sn90], and especially [Mar93]. More recently, the Cousots' overview articles <ref> [CC92a] </ref> and [CC92b] take a similar systematic approach in their presentation. Although many of the results concerning Abstract Interpretation in this chapter are well-known, we do have a number of contributions that are new, to the best of our knowledge. <p> Another motivation is based on the observation that descriptions a may always safely be replaced by ff.fl .a//, which yields the same or a better description. Thus, the abstract domain may be normalised to ff.fl .A//. This is called reduction in <ref> [CC92a] </ref>. In [Ore44], such a Galois connection is called perfect in A, [CC92a] calls it a Galois surjection and [MSS86] a Galois insertion from A to C. 3.2.1.10 Lemma (Theorem 5.3.0.6 in [CC79 ]) Let .ff; fl / be a Galois connec tion from .C; v/ to .A; /. <p> Thus, the abstract domain may be normalised to ff.fl .A//. This is called reduction in <ref> [CC92a] </ref>. In [Ore44], such a Galois connection is called perfect in A, [CC92a] calls it a Galois surjection and [MSS86] a Galois insertion from A to C. 3.2.1.10 Lemma (Theorem 5.3.0.6 in [CC79 ]) Let .ff; fl / be a Galois connec tion from .C; v/ to .A; /. <p> Theorem 7.1.0.4 of [CC79] contains an explicit statement of the result. Proofs, be it of slight variations, appear in <ref> [CC92a] </ref> (before Proposition 23) and [CC92b] (Proposition 6.12). 3.3] Abstract Semantics 53 ) f fl ffi ff is extensive; ff ffi fl is reductive g f ffi fl v fl ffi ff f ) f instantiate pointwise ordering g f .fl .lfp. ff f /// v fl . ff f .lfp. <p> They published many papers on the subject around the end of the 70s (see the bibliography of [CC92b]), and, after a period of relative silence (but see [CC84]), displayed a renewed interest in the subject at the beginning of the 90s: <ref> [CC92a, CC92c, CC92b] </ref>. [CC92a] contains a wealth of examples of everyday abstract interpretations, as well as more advanced program analyses. <p> They published many papers on the subject around the end of the 70s (see the bibliography of [CC92b]), and, after a period of relative silence (but see [CC84]), displayed a renewed interest in the subject at the beginning of the 90s: [CC92a, CC92c, CC92b]. <ref> [CC92a] </ref> contains a wealth of examples of everyday abstract interpretations, as well as more advanced program analyses. <p> On the other hand, Abstract Interpretation is a relatively young activity that was developed as a unifying theory for a variety of pre-existing applications, and a more fundamental study of the underlying choices seems to be justified (see e.g. <ref> [Mar93, CC92a, CC92b] </ref>). We think that Section 3.2.1 of this thesis oVers an answer to the question why Galois connections are so intimately related to Abstract Interpretation. The subsection on the power construction (page 44) should also be viewed in this light.
Reference: [CC92b] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation frameworks. </title> <journal> Journal of Logic and Computation, </journal> <note> 2(4):511547, 1992. Bibliography 195 </note>
Reference-contexts: The approach that we follow in this chapter has been influenced by the (successful) eVorts of Marriott and Sndergaard to give an orderly account of the theory and some of its applications: [MS89b, Sn90], and especially [Mar93]. More recently, the Cousots' overview articles [CC92a] and <ref> [CC92b] </ref> take a similar systematic approach in their presentation. Although many of the results concerning Abstract Interpretation in this chapter are well-known, we do have a number of contributions that are new, to the best of our knowledge. <p> This shift of attention from single elements to sets is indeed explicitly made in much of the Cousots' work, where it occurs through the lifting of the standard semantics to the collecting semantics see e.g. <ref> [CC92b] </ref> or [CC77], where the term static semantics is used instead of collecting semantics. Alternatively, we may specify the relation between concrete and abstract objects through an abstraction function ff 2 P.Z/ ! fneg; posg. <p> Each solution has its pros and cons, which we will not discuss here. The interested reader is referred to [CC79], [Mar93] and <ref> [CC92b] </ref>. Another point is whether ; should have an ff image. One may claim that this is not necessary because there is no need for a description of it. <p> This set-up is equivalent to the current, with a jD ff ' defined by a jD 0 t .'/. 4 cf. condition 4.5 in <ref> [CC92b] </ref>. 5 There might be a use in having such objects around, though. It could be that A can easily be defined, but the restriction to the range of is diYcult or impossible. <p> The approximation relation between abstract transition systems defined there is a preorder but not a partial order. 7 A diVerent choice would be to identify the description relation () with the safety relation (8 '2L [c jD ' ( a jD ff ']); see e.g. <ref> [CC79, CC92b] </ref>. All abstract objects that are safe for c are then captured in post * .c/. <p> Distinguishing the notions of description and safety yields a more general setup, which allows to ignore some of the safe elements when defining which elements may be used as descriptions. 8 cf. condition 4.19 in <ref> [CC92b] </ref>. 3.2] Preservation Results 37 Of course any preorder can be turned into a partial order by identifying equivalent elements, in the usual way. In the following, we assume that .A; / a poset. <p> It turns out that in many applications of abstraction theories, this order coincides with the orderings as meant under the other points (see also Section 3.3.1). In fact, the framework described in the seminal [CC77] does not distinguish between those orderings; <ref> [CC92b] </ref> does. <p> In the Cousots' work, this shifting from C to P.C/ is referred to as the construction of the collecting semantics 13 , see e.g. <ref> [CC92b] </ref>. [CC94] discusses a large variety of possibilities to lift elementary domains to power sets (see Section 3.4). <p> The interpretation that we gave to the new elements corresponds to the disjunctive completion from <ref> [CC92b] </ref>; we refer to that paper for a discussion of this particular and similar constructions. 46 Abstraction and Preservation [3.2 a; the definitions of 0 , 0 and ff 0 are adapted in the usual way 15 . <p> look for abstract counterparts ff lfp and ff f such that ff.lfp. f // ff lfp. ff f / (3.16) We choose to take for ff lfp the least fixpoint operator on the abstract domain (although diVerent choices exist, for example in the form of widening and narrowing techniques, see <ref> [CC77, CC92c, CC92b] </ref>). The following result specifies a condition on ff f in order for 3.16 to hold. It appears in many of the papers by the Cousots and is sometimes referred to as the fundamental theorem 18 . <p> Theorem 7.1.0.4 of [CC79] contains an explicit statement of the result. Proofs, be it of slight variations, appear in [CC92a] (before Proposition 23) and <ref> [CC92b] </ref> (Proposition 6.12). 3.3] Abstract Semantics 53 ) f fl ffi ff is extensive; ff ffi fl is reductive g f ffi fl v fl ffi ff f ) f instantiate pointwise ordering g f .fl .lfp. ff f /// v fl . ff f .lfp. ff f /// f by <p> Another early example of the idea is given in [Sin72]. The Cousots are the first to relate standard to non-standard semantics by a Galois insertion [CC77]. They published many papers on the subject around the end of the 70s (see the bibliography of <ref> [CC92b] </ref>), and, after a period of relative silence (but see [CC84]), displayed a renewed interest in the subject at the beginning of the 90s: [CC92a, CC92c, CC92b]. [CC92a] contains a wealth of examples of everyday abstract interpretations, as well as more advanced program analyses. <p> They published many papers on the subject around the end of the 70s (see the bibliography of [CC92b]), and, after a period of relative silence (but see [CC84]), displayed a renewed interest in the subject at the beginning of the 90s: <ref> [CC92a, CC92c, CC92b] </ref>. [CC92a] contains a wealth of examples of everyday abstract interpretations, as well as more advanced program analyses. <p> Interpretation in the realm of declarative programming languages. 20 Note that for the function g D ff ffi f ffi fl , the equality ff ffi f D g ffi ff does not necessarily hold. 3.5] Concluding Remarks 55 Papers presenting comparative studies of the various frameworks are [Mar93] and <ref> [CC92b] </ref>. In [Mar93], Marriott elaborates a framework that we only sketched superficially in Section 3.3 above. <p> On the other hand, Abstract Interpretation is a relatively young activity that was developed as a unifying theory for a variety of pre-existing applications, and a more fundamental study of the underlying choices seems to be justified (see e.g. <ref> [Mar93, CC92a, CC92b] </ref>). We think that Section 3.2.1 of this thesis oVers an answer to the question why Galois connections are so intimately related to Abstract Interpretation. The subsection on the power construction (page 44) should also be viewed in this light.
Reference: [CC92c] <author> Patrick Cousot and Radhia Cousot. </author> <title> Comparing the Galois connection and widening/narrowing approaches to abstract interpretation. </title> <editor> In M. Bruynooghe and M. Wirsing, editors, </editor> <booktitle> Programming Language Implementation and Logic Programming, number 631 in LNCS, </booktitle> <pages> pages 269 295. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: Indeed, Abstract Interpretation, in a narrow sense, is often understood to be the analysis of programs by approximating the (least) solution to a system of recursive equations representing the behaviour of a (repetitive or recursive) program, see for example <ref> [CC92c, Bou92, LV92] </ref>. * The third motivation is closely related to the second one. In computer science applications, the concrete objects are usually semantic models of programs. In most traditional approaches to semantics, models are partially ordered (sometimes for diVerent reasons than the existence of fixpoints). <p> look for abstract counterparts ff lfp and ff f such that ff.lfp. f // ff lfp. ff f / (3.16) We choose to take for ff lfp the least fixpoint operator on the abstract domain (although diVerent choices exist, for example in the form of widening and narrowing techniques, see <ref> [CC77, CC92c, CC92b] </ref>). The following result specifies a condition on ff f in order for 3.16 to hold. It appears in many of the papers by the Cousots and is sometimes referred to as the fundamental theorem 18 . <p> They published many papers on the subject around the end of the 70s (see the bibliography of [CC92b]), and, after a period of relative silence (but see [CC84]), displayed a renewed interest in the subject at the beginning of the 90s: <ref> [CC92a, CC92c, CC92b] </ref>. [CC92a] contains a wealth of examples of everyday abstract interpretations, as well as more advanced program analyses.
Reference: [CC94] <author> Patrick Cousot and Radhia Cousot. </author> <title> Higher-order abstract interpretation (and application to comportment analysis generalizing strictness, termination, projection and PER analysis of functional languages). </title> <booktitle> In 1994 International Conference on Computer Languages, </booktitle> <pages> pages 95112, </pages> <address> Los Alamitos, CA. </address> <publisher> IEEE Computer Society Press, </publisher> <year> 1994. </year>
Reference-contexts: E.g. in [CC79] and <ref> [CC94] </ref>, where abstract objects are identified with properties, the precision order on abstract objects coincides with logical implication. 40 Abstraction and Preservation [3.2 An alternative way of specifying an approximative description is through an abstraction relation ff that associates a concrete object with descriptions for it, and a concretisation relation fl <p> In the Cousots' work, this shifting from C to P.C/ is referred to as the construction of the collecting semantics 13 , see e.g. [CC92b]. <ref> [CC94] </ref> discusses a large variety of possibilities to lift elementary domains to power sets (see Section 3.4). <p> In <ref> [CC94] </ref>, many results from their older articles as well as from others' works are combined and extended, resulting in an abundance of constructions suggesting how to lift relations, functions, pairs, etc. from elementary domains to domains consisting of sets (cf. our power construction).
Reference: [CC95] <author> U. Celikkan and R. Cleaveland. </author> <title> Generating diagnostic information for behavioral preorders. </title> <booktitle> Distributed Computing, </booktitle> <address> 9:6175, </address> <year> 1995. </year>
Reference-contexts: We cannot take ready :D . P D P 0 / as a criterion: the program will then never terminate as every stratum contains new formulae. In similar partition refinement algorithms, e.g. the algorithm of [BFH C 92] that splits for CTL, or the algorithms for preorder checking in <ref> [CC95] </ref>, one-step-stability is used as a termination criterion: if the constructed model (or, relation in [CC95]) remains unchanged during one step of the while loop, it may be concluded that no subsequent steps will cause changes anymore. <p> In similar partition refinement algorithms, e.g. the algorithm of [BFH C 92] that splits for CTL, or the algorithms for preorder checking in <ref> [CC95] </ref>, one-step-stability is used as a termination criterion: if the constructed model (or, relation in [CC95]) remains unchanged during one step of the while loop, it may be concluded that no subsequent steps will cause changes anymore. <p> The notion of companion is similar to that of Fischer-Ladner closure ([FL79, Gol92]) while splitting is reminiscent of filtration ([HC84, Gol92]). Our splitting algorithm for 8CTL can be viewed as a partition refinement algorithm for simulation equivalence. Such an algorithm has been developed before in <ref> [CC95] </ref>; recently, the topic has enjoyed new interest in the context of hybrid systems see [HHK95]. The partition refinement algorithm for arbitrary finite subsets of 8CTL is novel; however, the iterative computation of characteristic predicates is common in symbolic model checking, e.g. [BCM C 92]. <p> These equivalences both correspond to logics that are closed under negation, namely CTL fl and CTL fl .U/ (also see the next chapter). For simulation equivalence, the only previous decision algorithm that we know of is <ref> [CC95] </ref>, which does not fit the partition refinement scheme. More recently, [HHK95] presents an algorithm that indeed uses ideas from [PT87].
Reference: [CDY91] <author> M. Codish, D. Dams, and E. Yardeni. </author> <title> Derivation and safety of an abstract unification algorithm for groundness and sharing analysis. </title> <editor> In K. Furukawa, editor, </editor> <booktitle> Proceedings of the 8th International Conference of Logic Programming and Symposium of Logic Programming, </booktitle> <pages> pages 7993. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference-contexts: Such a symmetry is needed for example when abstractions are to be composed, allowing for a stepwise design of an analysis. Examples of such composed abstractions may be found in [Mer90], <ref> [CDY91] </ref> and also in Section 4.8.1 in this thesis. In general, several orderings on the concrete objects may be introduced, one for each of these reasons.
Reference: [CE81] <author> E.M. Clarke and E.A. Emerson. </author> <title> Synthesis of synchronization skeletons for branching time temporal logic. </title> <editor> In Dexter Kozen, editor, </editor> <booktitle> Logics of Programs: Workshop, number 131 in LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1981. </year>
Reference-contexts: One assumption is that model checking is used to establish the validity of properties over programs; this is an a-posteriori, model-based, automatic method for property verification and was introduced by Queille and Sifakis in [QS82] and independently by Clarke and Emerson in <ref> [CE81] </ref>. An alternative approach, often called model checking as well, based on inclusion between automata over infinite words, was developed by Vardi and Wolper ([VW86]) and by Kurshan ([Kur90], also see [Kur94]). A closely related method is the tableau-based approach, see [LP85, PZ86]. <p> The latter books are also recommended for an overview of temporal logic. Model checking was introduced independently in [QS82] and <ref> [CE81] </ref>. It has led to a large stream of both practically and theoretically oriented articles. Recently, much research has concentrated on tackling the state-explosion problem, see the two subsections below.
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2):244 263, </volume> <year> 1986. </year>
Reference-contexts: In particular, we want to be able to express typical properties of reactive systems also called reactive properties. To this purpose, we use temporal logic. Examples are LTL (linear temporal logic, see [Pnu77]), CTL (computation tree logic, see <ref> [CES86] </ref>), CTL fl ([EH86, EL87]), HML (Henessy-Milner Logic, see [HM85]) and L (the -calculus, see [Koz83]). <p> Another approach, taken in [DNV90b] for example, interprets formulae along maximal prefixes, i.e. prefixes that cannot be extended because either they are infinite, or their last state has no outgoing transitions. In yet other articles 24 Preliminaries <ref> [2.4 (e.g. [EC82, CES86] </ref>), transition relations are required to be total : every state must have an outgoing transition. This requirement avoids the type of misinterpretations discussed above, but imposes the obligation to ensure that every system being defined has a total transition relation. This may be cumbersome. <p> Another approach, taken in [DNV90b] for example, interprets formulae along maximal prefixes, i.e. prefixes that cannot be extended because either they are infinite, or their last state has no outgoing transitions. In yet other articles 24 Preliminaries [2.4 (e.g. <ref> [EC82, CES86] </ref>), transition relations are required to be total : every state must have an outgoing transition. This requirement avoids the type of misinterpretations discussed above, but imposes the obligation to ensure that every system being defined has a total transition relation. This may be cumbersome. <p> In the graph-traversal approach, ' is checked over K in a more direct fashion. For example, the states of K are labelled with subformulae of ' in an iterative fashion, starting with propositions and labelling with longer formulae in every subsequent step. Such an algorithm is presented in <ref> [CES86] </ref>. Another approach is presented in [QS82], in which a fix-point algorithm is used to compute sets of states satisfying the subformulae of '.
Reference: [CGH C 93] <author> E. M. Clarke, O. Grumberg, H. Hiraishi, S. Jha, D. E. Long, K. L. McMillan, and L. A. Ness. </author> <title> Verification of the FuturebusC cache coherence protocol. </title> <editor> In L. Claesen, editor, </editor> <booktitle> Proceedings of the Eleventh International Symposium on Computer Hardware Description Languages and their Applications. </booktitle> <publisher> North-Holland, </publisher> <year> 1993. </year>
Reference-contexts: This is a tree-like structure that is used to, often compactly, represent a set of bitstrings; BDDs have gained popularity in the field of verification lately see e.g. [DJS95, McM93]. That this approach may lead to spectacular results is evidenced by papers like <ref> [BCM C 92, MS92b, CGH C 93] </ref>. Although symbolic model checking has actually found its way into industry on an extensive scale, it is not a panacea.
Reference: [CGL92] <author> E.M. Clarke, O. Grumberg, and D.E. </author> <title> Long. Model checking and abstraction. </title> <booktitle> In Nineteenth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. </booktitle> <year> 1992. </year> <note> 196 Bibliography </note>
Reference-contexts: Besides that, also various applications relating to program correctness, like debugging and type checking, have been formulated as abstract interpretations. See [AH87], [CC92a], and [JN95] for references. Recently, ideas from Abstract Interpretation have been applied to correctness of reactive programs in a number of studies. <ref> [CGL92] </ref> 3 shows how to construct abstract models that weakly preserve universal 4 safety and liveness 5 properties expressed in (a fragment of ) the temporal logic CTL fl . Preservation of full CTL fl is shown in the context of strong preservation only. <p> Section 3.3). This is then formally justified 1 The notions of universality and safety of a property are not always distinguished as explicitly as we do in this thesis. What we call universal safety is often just termed safety or invariance elsewhere. 2 <ref> [Kur90, CGL92, BBLS92, Loi94, DGG94, CR94, CIY95, Kel95] </ref>; see Section 4.9 for a more complete overview and comparison. 4.2] Abstract Kripke Structures 59 in Section 4.4. <p> Some of the first papers that consider the (strong) preservation of full CTL fl and L are <ref> [CGL92] </ref> and [BBLS92]. Following [Kur90], [CGL92] defines the relation between the concrete and abstract model by means of a homomorphism h, which induces an equivalence relation ~ on the concrete states, defined by c ~ d , h.c/ D h.d/. <p> Some of the first papers that consider the (strong) preservation of full CTL fl and L are <ref> [CGL92] </ref> and [BBLS92]. Following [Kur90], [CGL92] defines the relation between the concrete and abstract model by means of a homomorphism h, which induces an equivalence relation ~ on the concrete states, defined by c ~ d , h.c/ D h.d/. The abstract states are then representations of the equivalence classes of ~. <p> Our approach to defining approximations in Section 4.4 is a generalisation of this see Lemma 4.4.0.3 and the last sentence of that subsection. Furthermore, our notion of abstract Kripke structure does allow proper approximations in the context of weak preservation of full CTL fl . <ref> [CGL92] </ref> also explains the construction of abstract models and approximations thereof, by abstract interpretation of elementary operations (called abstract compilation), and illustrates this with a number of examples.
Reference: [CGL93] <author> E. Clarke, O. Grumberg, and D. </author> <title> Long. Verification tools for finite-state concurrent systems. </title> <editor> In J.W. de Bakker, W.-P. de Roever, and G. Rozen-berg, editors, </editor> <title> A Decade of Concurrency: Reflections and Perspectives, </title> <booktitle> number 803 in LNCS, </booktitle> <pages> pages 124175. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: At best, it pushes forward the block that is formed by the state explosion which indeed 12 Program Analysis and Verification [1.4 holds for all reduction/abstraction methods. For an overview see <ref> [CGL93] </ref>. On-the-fly (or: on-line) techniques minimise the memory demands of model checkers by only expanding those parts of the program that are needed to verify the given property. Being exposed in e.g. [JJ89, BFH90, FM91], these techniques have indeed been used before in many verifiers developed by G. <p> Although this thesis is about techniques that aim to extend of the applicability of model checking, the particular model-checking approach that is chosen and the details of the algorithms are immaterial. The interested reader is referred to the articles mentioned above. Furthermore, a number of overviews have recently appeared: <ref> [Eme90, Sti92, CGL93, Kur94] </ref>. Chapter 3 Abstraction and Preservation Besides introducing abstraction and Abstract Interpretation, this chapter presents a systematic reconstruction of several frameworks for abstraction that occur in the literature. We formalise the notion of property preservation, and investigate how weak and strong preservation lead to diVerent frameworks.
Reference: [CGL94] <author> E.M. Clarke, O. Grumberg, and D.E. </author> <title> Long. Model checking and abstraction. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5):15121542, </volume> <year> 1994. </year>
Reference-contexts: The relation between a concrete and abstract systems is defined in terms of a Galois insertion, in a way that is less general than the approach based on simulation relations, but more general than homomorphic functions. The ad 3 A journal version appears as <ref> [CGL94] </ref>. 4 A property is called universal iV it expresses that something holds along all possible executions of a program. 5 A liveness property expresses that something happens eventually. 10 Program Analysis and Verification [1.4 vantage of this Galois-insertion approach is that notions of precision and optimality can be captured, allowing <p> Although in the original definition of CTL fl in [EH86] also finite computations are taken into consideration, both [EL87] and the recent overview article [Eme90] revise the original definition by quantifying over (full-)paths only. A similar definition is given in <ref> [CGL94] </ref>. As a consequence, this version of CTL fl cannot express properties of computations that end in a deadlock state (i.e. a state from which no transitions are possible) and hence some care has to be taken in (intuitively) interpreting the formulae. <p> A journal version appeared as <ref> [CGL94] </ref>. [Lon93] also contains these results, presented in a slightly more general setting. [BBLS92] presents similar ideas in a more general setting by considering simulation relations to connect the concrete and abstract transition systems.
Reference: [Cho95] <author> Ching-Tsun Chou. </author> <title> A simple treatment of property preservation via simulation. </title> <type> Technical Report 950014, </type> <institution> Comp. Sc. Dept., University of California at Los Angeles, </institution> <month> March </month> <year> 1995. </year>
Reference: [CIY94] <author> R. Cleaveland, S. P. Iyer, and D. Yankelevich. </author> <title> Abstractions for preserving all CTL fl formulae. </title> <type> Technical Report 94-03, </type> <institution> Dept. of Comp. Sc., North Carolina State University, </institution> <address> Raleigh, NC 27695, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: A strong point of Kelb's thesis is the integration of these theoretical results with symbolic (BDD-based) representations. Indeed, [Kel95] proceeds by decribing practical experiments on the symbolic verification of StateChart programs, including part of the material from [KDG95], which was discussed in Section 4.9.2. <ref> [CIY94] </ref> is based on an early version, [DGG93b], of [DGG94] and independently develops the idea of mixing both free and constrained abstractions in a single abstract system to attain preservation of full CTL fl . More recently, [CIY95] focusses on the issue of optimality.
Reference: [CIY95] <author> Rance Cleaveland, Purush Iyer, and Daniel Yankelevich. </author> <title> Optimality in abstractions of model checking. </title> <editor> In Alan Mycroft, editor, </editor> <title> Static Analysis, </title> <booktitle> number 983 in LNCS, </booktitle> <pages> pages 5163. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1995. </year>
Reference-contexts: Part of that work was carried out jointly; see [KDG95]. An extensive discussion of the results will be given in Section 4.9.2. Another interesting point in [Kel95] is the generalisation of preservation results to stutter-insensitive specifications, by forbidding an explicit next-step operator. <ref> [CIY95] </ref> also develops preservation results for CTL fl which are similar to ours. However, the focus of that paper is on the optimality of abstractions. As the notion of optimality defined there is a refined version of the one used in this thesis, the obtained results improve on ours. <p> However, the focus of that paper is on the optimality of abstractions. As the notion of optimality defined there is a refined version of the one used in this thesis, the obtained results improve on ours. Another diVerence is that the construction of abstract models is not considered in <ref> [CIY95] </ref>. Application of Abstract Interpretation to verify properties of CCS is described in [DFFGI95]. A recent paper, [KDG95], reports on progress in the practical application of Abstract Interpretation techniques to compositionally construct abstractions preserving the full -calculus. <p> ordering on Abstract Kripke structures, this would constitute a proof obligation that we prefer to view as a separate concern. (Indeed, this proof would not be straightforward and would probably only be valid for a restricted class of structures see the remarks in Section 4.4 on page 78 and cf. <ref> [CIY95] </ref>.) Other authors sometimes identify the precision () and property orderings. <p> Section 3.3). This is then formally justified 1 The notions of universality and safety of a property are not always distinguished as explicitly as we do in this thesis. What we call universal safety is often just termed safety or invariance elsewhere. 2 <ref> [Kur90, CGL92, BBLS92, Loi94, DGG94, CR94, CIY95, Kel95] </ref>; see Section 4.9 for a more complete overview and comparison. 4.2] Abstract Kripke Structures 59 in Section 4.4. <p> A similar result is established in a slightly diVerent framework in <ref> [CIY95] </ref>, based on a result from [Lar89]. The first condition above is similar to the requirement of precision of [CIY95] (Definition 20). For a further discussion see Section 4.9 (page 102). The following lemma, which is easily proven, gives suYcient conditions for - and --pseudo-simulation. <p> A similar result is established in a slightly diVerent framework in <ref> [CIY95] </ref>, based on a result from [Lar89]. The first condition above is similar to the requirement of precision of [CIY95] (Definition 20). For a further discussion see Section 4.9 (page 102). The following lemma, which is easily proven, gives suYcient conditions for - and --pseudo-simulation. It will be used in the following sections. 4.4.0.3 Lemma Let R 0 and R 00 be transition relations over ff 6. 1. <p> More recently, <ref> [CIY95] </ref> focusses on the issue of optimality. An approximation ordering _ h (relative to a homomorphism h) on abstract transition systems is defined and shown to coincide with the CTL fl -property ordering, i.e. <p> This should be compared to our approach in which the notion of approximation on Abstract Kripke structures, , is more loosely related to the CTL fl -property ordering: see Theorem 4.4.0.2 and also the footnote on page 39. <ref> [CIY95] </ref> defines an abstraction function (cf. our ff M ) that maps transition systems to _ h -optimal 30 abstractions. This approach ensures that the formal notion of optimality corresponds more to the intuition of usefulness. <p> This approach ensures that the formal notion of optimality corresponds more to the intuition of usefulness. It would be interesting to investigate how similar results can be obtained in our case. As shown in <ref> [CIY95] </ref>, it requires certain restrictions on the class of transition systems. Furthermore, the framework of [CIY95], being based on homomorphic functions h, is slightly less general than ours so that the results do not translate immediately. [CR94] presents a framework for the abstract interpretation of processes that pass values. <p> This approach ensures that the formal notion of optimality corresponds more to the intuition of usefulness. It would be interesting to investigate how similar results can be obtained in our case. As shown in <ref> [CIY95] </ref>, it requires certain restrictions on the class of transition systems. Furthermore, the framework of [CIY95], being based on homomorphic functions h, is slightly less general than ours so that the results do not translate immediately. [CR94] presents a framework for the abstract interpretation of processes that pass values. Application of Abstract Interpretation to verify properties of CCS is described in [DFFGI95]. <p> Application of Abstract Interpretation to verify properties of CCS is described in [DFFGI95]. While developed independently, and from a diVerent perspective, Abstract Krip-ke structures bear some resemblance to the modal transition systems of [LT88], which also combine two types of transition relations (may and must-transitions) in one 30 In <ref> [CIY95] </ref>, a diVerent notation is used for this. 4.9] Related Work 103 system. Modal transition systems have been developed in the area of specification. Must-transitions specify what is required while may-transitions specify what is admissible.
Reference: [CK90] <editor> E.M. Clarke and R.P. Kurshan, editors. </editor> <booktitle> Computer-Aided Verification, number 531 in LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: A closely related method is the tableau-based approach, see [LP85, PZ86]. Model checking has been quite successful in the verification of finite-state programs like protocols and controllers. Some reports may be found in the Applications sessions of the CAV conferences ([Sif89], <ref> [CK90] </ref>, [LS91], [vBP92], [Cou93], [Dil94], [Wol95]). Model checking a program (in the narrow sense) involves two distinct phases, depicted in Figure 1.1a. First, a given notation 2 P of the program has to be unfolded into a model C this is called (model) construction.
Reference: [Cle92] <editor> W.R. Cleaveland, editor. </editor> <booktitle> CONCUR '92, number 630 in LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference: [Cou93] <editor> Costas Courcoubetis, editor. </editor> <booktitle> Computer Aided Verification, number 697 in LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: A closely related method is the tableau-based approach, see [LP85, PZ86]. Model checking has been quite successful in the verification of finite-state programs like protocols and controllers. Some reports may be found in the Applications sessions of the CAV conferences ([Sif89], [CK90], [LS91], [vBP92], <ref> [Cou93] </ref>, [Dil94], [Wol95]). Model checking a program (in the narrow sense) involves two distinct phases, depicted in Figure 1.1a. First, a given notation 2 P of the program has to be unfolded into a model C this is called (model) construction. This is formalised by a mapping I called interpretation.
Reference: [CR94] <author> R. Cleaveland and J. Riely. </author> <title> Testing-based abstractions for value-passing systems. </title> <booktitle> In Jonsson and Parrow [JP94], </booktitle> <pages> pages 417432. </pages>
Reference-contexts: Section 3.3). This is then formally justified 1 The notions of universality and safety of a property are not always distinguished as explicitly as we do in this thesis. What we call universal safety is often just termed safety or invariance elsewhere. 2 <ref> [Kur90, CGL92, BBLS92, Loi94, DGG94, CR94, CIY95, Kel95] </ref>; see Section 4.9 for a more complete overview and comparison. 4.2] Abstract Kripke Structures 59 in Section 4.4. <p> As shown in [CIY95], it requires certain restrictions on the class of transition systems. Furthermore, the framework of [CIY95], being based on homomorphic functions h, is slightly less general than ours so that the results do not translate immediately. <ref> [CR94] </ref> presents a framework for the abstract interpretation of processes that pass values. Application of Abstract Interpretation to verify properties of CCS is described in [DFFGI95].
Reference: [Dam94] <author> Mads Dam. </author> <title> CTL fl and ECTL fl as fragments of the modal -calculus. </title> <journal> Journal of Theoretical Computer Science, </journal> <volume> 126:7796, </volume> <year> 1994. </year>
Reference-contexts: A natural question is whether also the splitting algorithm for a single ' 2 8CTL may be generalised for ' 2 8CTL fl . The results in <ref> [Dam94] </ref> imply that every formula in 8CTL fl can be expressed in terms of the modality 8X and a fixpoint construct (indeed, expressed in the -calculus). Based on this observation, we expect that a similar splitting algorithm for ' 2 8CTL fl exists.
Reference: [DFFGI95] <author> N. De Francesco, A. Fantechi, S. Gnesi, and P. Inverardi. </author> <title> Model checking of non-finite state processes by finite approximations. </title> <editor> In E. Brinksma, W. R. Cleaveland, K. G. Larsen, T. Margaria, and B. Stef-fen, editors, </editor> <booktitle> Tools and Algorithms for the Construction and Analysis of Systems, number 1019 in LNCS, pages 195215. </booktitle> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1995. </year> <note> Bibliography 197 </note>
Reference-contexts: Another diVerence is that the construction of abstract models is not considered in [CIY95]. Application of Abstract Interpretation to verify properties of CCS is described in <ref> [DFFGI95] </ref>. A recent paper, [KDG95], reports on progress in the practical application of Abstract Interpretation techniques to compositionally construct abstractions preserving the full -calculus. <p> Application of Abstract Interpretation to verify properties of CCS is described in <ref> [DFFGI95] </ref>. While developed independently, and from a diVerent perspective, Abstract Krip-ke structures bear some resemblance to the modal transition systems of [LT88], which also combine two types of transition relations (may and must-transitions) in one 30 In [CIY95], a diVerent notation is used for this. 4.9] Related Work 103 system.
Reference: [DG95] <author> D. Dams and J.F. Groote. </author> <title> Specification and implementation of components of a CRL toolbox. Logic Group Preprint Series 152, </title> <institution> Dept. of Philosophy, Utrecht University, </institution> <address> The Netherlands, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: A major concern is keeping the project manageable, now and in the long run. We hope to achieve this by a modular approach, connecting tools that each oVer a limited functionality via the ToolBus ([BK95]), and furthermore by 3 <ref> [DG95] </ref> reports on a pilot study. 4 Stichting Informatica-Onderzoek in Nederland is the computer science branch of the Dutch national science foundation (NWO). 190 In Conclusion [7.3 taking a strict attitude towards specification, verification and documentation.
Reference: [DGD C 94] <author> D. Dams, R. Gerth, G. Dohmen, R. Herrmann, P. Kelb, and H. Pargmann. </author> <title> Model checking using adaptive state and data abstraction. </title> <booktitle> In Dill [Dil94], </booktitle> <pages> pages 455467. </pages>
Reference-contexts: Abstract Interpretation of Nondeterministic Systems 2. Preliminaries Weak Preservation/Analysis Strong Preservation/Verification 1. Program Analysis and Verification 7. In Conclusion ter 4, with the exception of Section 4.8, is based on [DGG94]. Chapter 5 is a revision of [DGG93a] and contains some material from <ref> [DGD C 94] </ref> as well, while another part of [DGD C 94] is worked out in Section 4.8. Chapter 6 covers more recent research that has not yet been published. Chapter 3 summarises a series of unfinished notes that attempt to set up a systematic introduction to Abstract Interpretation. <p> Preliminaries Weak Preservation/Analysis Strong Preservation/Verification 1. Program Analysis and Verification 7. In Conclusion ter 4, with the exception of Section 4.8, is based on [DGG94]. Chapter 5 is a revision of [DGG93a] and contains some material from <ref> [DGD C 94] </ref> as well, while another part of [DGD C 94] is worked out in Section 4.8. Chapter 6 covers more recent research that has not yet been published. Chapter 3 summarises a series of unfinished notes that attempt to set up a systematic introduction to Abstract Interpretation. <p> Another advantage is that weak preservation of both universal and existential properties can be combined within a single notion of abstraction, without necessarily having strong preservation, which would limit the maximal reduction possible. [DGG93a] and <ref> [DGD C 94] </ref> investigate approaches to the construction of strongly preserving abstractions for fragments of CTL fl , the former from a more theoretical and the latter from a more practical point of view. <p> and <ref> [DGD C 94] </ref> investigate approaches to the construction of strongly preserving abstractions for fragments of CTL fl , the former from a more theoretical and the latter from a more practical point of view. Chapter 5 of this thesis is based on [DGG93a], while part of the material in [DGD C 94] is worked out at the end of Chapter 4. [Kel95] develops preservation results for the -calculus in the context of symbolic model checking (see Section 1.4.2 below and 2.4.3). The interpretation of a -calculus formula, which is a set of states, is approximated from below and above. <p> The proofs for the abstract operators may form a diYcult step in the method. In [KDG95], approximations to the transition relation of StateCharts ([Har87]) are used to verify -calculus properties of a production cell ([DHKS95]) in a compositional fashion. In [DGG93a] and <ref> [DGD C 94] </ref>, a method is developed that aims at full automation of these steps. We return to this method in the next chapter. <p> Such a concrete domain may occur in the context of binary decision diagrams. The elements of the abstract domain P.B fi B k / can then be used as approximations that can be represented by BDDs of limited height, see e.g. <ref> [DGD C 94] </ref>. An element of B fi B k is represented as .e; fl b/ where e 2 B is called the overflow and fl b is in B k . The abstraction is formally captured by the following abstraction and concretisation functions. <p> This fact causes stabilisation of the abstract model, allowing the verification of 4.5. Note that the verification of the other two properties was performed independent of N . 5.7 Related Work This chapter is based on [DGG93a] and partly on <ref> [DGD C 94] </ref>. The notion of companion is similar to that of Fischer-Ladner closure ([FL79, Gol92]) while splitting is reminiscent of filtration ([HC84, Gol92]). Our splitting algorithm for 8CTL can be viewed as a partition refinement algorithm for simulation equivalence. <p> One answer is that we envisage applications in combination with symbolic methods, where sets of states and transition relations are represented by BDDs for example. Such symbolic methods may often be combined with approximation techniques, see e.g. <ref> [DGD C 94, DWT95] </ref>. The techniques presented in Chapter 5 may then oVer an interesting alternative to symbolic model checking: in addition to computing the set of states satisfying the specification, an abstract model is also constructed.
Reference: [DGG] <author> D. Dams, O. Grumberg, and R. Gerth. </author> <title> Abstract interpretation of reactive systems. </title> <note> Submitted to ACM Transactions on Programming Languages and Systems. </note>
Reference-contexts: This approach is followed 92 Abstract Interpretation of Nondeterministic Systems [4.8 in <ref> [DGG] </ref>. Although the model checking procedure itself is an automated process, it is not obvious how the choice of an appropriate abstract domain with corresponding abstract operations, as well as the proofs that these operations satisfy the conditions of Definition 4.3.0.2, can be performed in an automated fashion. <p> We model such systems by Kripke structures, while the properties that should be verified are expressed in CTL fl (although our results remain true if we would have taken the more expressive -calculus as our property language instead see <ref> [DGG] </ref>). The main result of Sections 4.2 through 4.7 is that weak preservation of full CTL fl is possible if we take mixed transition systems as descriptions of Kripke structures. Such mixed transition systems accommodate two dual transition relations.
Reference: [DGG93a] <author> D. Dams, R. Gerth, and O. Grumberg. </author> <title> Generation of reduced models for checking fragments of CTL. </title> <booktitle> In Courcoubetis [Cou93], </booktitle> <pages> pages 479 490. </pages>
Reference-contexts: Logical Partition Refinement 6. Logics, Equivalences and Behavioural Partition Refinement 4. Abstract Interpretation of Nondeterministic Systems 2. Preliminaries Weak Preservation/Analysis Strong Preservation/Verification 1. Program Analysis and Verification 7. In Conclusion ter 4, with the exception of Section 4.8, is based on [DGG94]. Chapter 5 is a revision of <ref> [DGG93a] </ref> and contains some material from [DGD C 94] as well, while another part of [DGD C 94] is worked out in Section 4.8. Chapter 6 covers more recent research that has not yet been published. <p> Another advantage is that weak preservation of both universal and existential properties can be combined within a single notion of abstraction, without necessarily having strong preservation, which would limit the maximal reduction possible. <ref> [DGG93a] </ref> and [DGD C 94] investigate approaches to the construction of strongly preserving abstractions for fragments of CTL fl , the former from a more theoretical and the latter from a more practical point of view. Chapter 5 of this thesis is based on [DGG93a], while part of the material in <p> would limit the maximal reduction possible. <ref> [DGG93a] </ref> and [DGD C 94] investigate approaches to the construction of strongly preserving abstractions for fragments of CTL fl , the former from a more theoretical and the latter from a more practical point of view. Chapter 5 of this thesis is based on [DGG93a], while part of the material in [DGD C 94] is worked out at the end of Chapter 4. [Kel95] develops preservation results for the -calculus in the context of symbolic model checking (see Section 1.4.2 below and 2.4.3). <p> The proofs for the abstract operators may form a diYcult step in the method. In [KDG95], approximations to the transition relation of StateCharts ([Har87]) are used to verify -calculus properties of a production cell ([DHKS95]) in a compositional fashion. In <ref> [DGG93a] </ref> and [DGD C 94], a method is developed that aims at full automation of these steps. We return to this method in the next chapter. <p> This fact causes stabilisation of the abstract model, allowing the verification of 4.5. Note that the verification of the other two properties was performed independent of N . 5.7 Related Work This chapter is based on <ref> [DGG93a] </ref> and partly on [DGD C 94]. The notion of companion is similar to that of Fischer-Ladner closure ([FL79, Gol92]) while splitting is reminiscent of filtration ([HC84, Gol92]). Our splitting algorithm for 8CTL can be viewed as a partition refinement algorithm for simulation equivalence.
Reference: [DGG93b] <author> D. Dams, O. Grumberg, and R. Gerth. </author> <title> Abstract interpretation of reactive systems: </title> <address> Abstractions preserving ACTL fl , ECTL fl and CTL fl . Draft, </address> <month> July </month> <year> 1993. </year>
Reference-contexts: Indeed, [Kel95] proceeds by decribing practical experiments on the symbolic verification of StateChart programs, including part of the material from [KDG95], which was discussed in Section 4.9.2. [CIY94] is based on an early version, <ref> [DGG93b] </ref>, of [DGG94] and independently develops the idea of mixing both free and constrained abstractions in a single abstract system to attain preservation of full CTL fl . More recently, [CIY95] focusses on the issue of optimality.
Reference: [DGG94] <author> D. Dams, O. Grumberg, and R. Gerth. </author> <title> Abstract interpretation of reactive systems: Abstractions preserving 8CTL fl , 9CTL fl and CTL fl . In E.-R. </title> <editor> Olderog, editor, </editor> <booktitle> Proceedings of the IFIP WG2.1/WG2.2/WG2.3 Working Conference on Programming Concepts, Methods and Calculi (PROCOMET), IFIP Transactions. </booktitle> <address> North-Holland/Elsevier, Amster-dam, </address> <year> 1994. </year>
Reference-contexts: Abstraction and Preservation 5. Logical Partition Refinement 6. Logics, Equivalences and Behavioural Partition Refinement 4. Abstract Interpretation of Nondeterministic Systems 2. Preliminaries Weak Preservation/Analysis Strong Preservation/Verification 1. Program Analysis and Verification 7. In Conclusion ter 4, with the exception of Section 4.8, is based on <ref> [DGG94] </ref>. Chapter 5 is a revision of [DGG93a] and contains some material from [DGD C 94] as well, while another part of [DGD C 94] is worked out in Section 4.8. Chapter 6 covers more recent research that has not yet been published. <p> In [Loi94], this theory is not only worked out in full detail, the implementation of a tool based on it is described and analysed too. The theory about preservation between, and the construction of, transition systems presented in Chapter 4 of this thesis is based on <ref> [DGG94] </ref>, presenting material that was developed independently from [BBLS92, Loi94]. That paper focusses on the definition of a notion of abstraction of transition systems that preserves properties from full CTL fl . <p> By combining these dual approximate interpretations, using one for the 2-operator and the other for the 3, weak preservation of arbitrary -calculus formulae is obtained. This technique is similar to the mixed abstractions of <ref> [DGG94] </ref> that will be presented in Chapter 4. Kelb presents an application of these techniques to the verification of StateChart programs. Part of that work was carried out jointly; see [KDG95]. An extensive discussion of the results will be given in Section 4.9.2. <p> This is refected by a stream of publications 2 showing a revived interest in preservation results and Abstract-Interpretation techniques. The theory described in this chapter is based on <ref> [DGG94] </ref>. Several definitions of descriptions that weakly preserve reactive properties have been proposed in literature before the abovementioned revival, but these are limited to universal properties only, or they only concentrate on the definition of abstract models without indicating how such descriptions can be constructed. <p> Section 3.3). This is then formally justified 1 The notions of universality and safety of a property are not always distinguished as explicitly as we do in this thesis. What we call universal safety is often just termed safety or invariance elsewhere. 2 <ref> [Kur90, CGL92, BBLS92, Loi94, DGG94, CR94, CIY95, Kel95] </ref>; see Section 4.9 for a more complete overview and comparison. 4.2] Abstract Kripke Structures 59 in Section 4.4. <p> Indeed, [Kel95] proceeds by decribing practical experiments on the symbolic verification of StateChart programs, including part of the material from [KDG95], which was discussed in Section 4.9.2. [CIY94] is based on an early version, [DGG93b], of <ref> [DGG94] </ref> and independently develops the idea of mixing both free and constrained abstractions in a single abstract system to attain preservation of full CTL fl . More recently, [CIY95] focusses on the issue of optimality.
Reference: [DHKS95] <author> Werner Damm, Hardi Hungar, Peter Kelb, and Rainer Schlor. Stat-echarts: </author> <title> Using graphical specification languages and symbolic model checking in the verification of a production cell. </title> <booktitle> In Lewerenz and Lind-ner [LL95], </booktitle> <pages> pages 131149. </pages>
Reference: [Dil89] <author> D.L. Dill. </author> <title> Trace Theory for Automatic Hierarchical Verification of Speed-Independent Circuits. </title> <publisher> ACM Distinguished Dissertations. The MIT Press, </publisher> <address> London, </address> <year> 1989. </year>
Reference-contexts: In [Mil71], Milner introduced the term simulation to denote a homomorphism between deterministic systems. Since then, it has been re-adapted to nondeterministic transition systems and has become popular in the areas of program refinement and verification; [Sif82], [Sif83] and [HM80] are some early papers on this topic. <ref> [Dil89] </ref> and [Kur90] focus on trace (linear time) semantics and universal safety and liveness properties. Some of the first papers that consider the (strong) preservation of full CTL fl and L are [CGL92] and [BBLS92].
Reference: [Dil94] <editor> David L. Dill, editor. </editor> <booktitle> Computer Aided Verification, number 818 in LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1994. </year>
Reference-contexts: A closely related method is the tableau-based approach, see [LP85, PZ86]. Model checking has been quite successful in the verification of finite-state programs like protocols and controllers. Some reports may be found in the Applications sessions of the CAV conferences ([Sif89], [CK90], [LS91], [vBP92], [Cou93], <ref> [Dil94] </ref>, [Wol95]). Model checking a program (in the narrow sense) involves two distinct phases, depicted in Figure 1.1a. First, a given notation 2 P of the program has to be unfolded into a model C this is called (model) construction. This is formalised by a mapping I called interpretation.
Reference: [DJS95] <author> Werner Damm, Bernhard Josko, and Rainer Schlor. </author> <title> Specification and verification of VHDL-based system-level hardware designs. </title> <editor> In Egon Borger, editor, </editor> <title> Specification and Validation Methods, International 198 Bibliography Schools for Computer Scientists, pages 331409. </title> <publisher> Oxford University Press, Oxford, </publisher> <year> 1995. </year>
Reference-contexts: This is a tree-like structure that is used to, often compactly, represent a set of bitstrings; BDDs have gained popularity in the field of verification lately see e.g. <ref> [DJS95, McM93] </ref>. That this approach may lead to spectacular results is evidenced by papers like [BCM C 92, MS92b, CGH C 93]. Although symbolic model checking has actually found its way into industry on an extensive scale, it is not a panacea.
Reference: [DN87] <author> Rocco De Nicola. </author> <title> Extensional equivalences for transition systems. </title> <journal> Acta Informatica, </journal> <volume> 24:211237, </volume> <year> 1987. </year>
Reference-contexts: Milner introduced the notion of simulation in [Mil71] and observational equivalence in [Mil80]. Branching bisim-ulation has been proposed as an alternative to observational equivalence in, among others, [GW89, vG90a, vG93a, vG93b]. A large variety of behavioural equivalences has been defined and studied over the past ten years; see <ref> [DN87] </ref> for a discussion. Also [BK90] contains a lot of material on this topic. The conception of bisimulation took place independent of the development of branching-time temporal logics like CTL ([CE81]), CTL fl ([EH86]), -calculus ([Koz83]) and Hennessy-Milner Logic ([HM85]).
Reference: [DNV90a] <author> Rocco De Nicola and Frits Vaandrager. </author> <title> Action versus state based logics for transition systems. </title> <editor> In I. Guessarian, editor, </editor> <booktitle> Semantics of Systems of Concurrent Processes, number 469 in LNCS, </booktitle> <pages> pages 407419. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: This equivalence is similar to that of delay bisimulation introduced in [Mil83]. The only diVerence is that the latter is defined over edge-labelled transition systems. So, when flat CTL.U/ is reinterpreted over such transition systems (for details of the diVerence between the state and action-based approaches see <ref> [DNV90a] </ref>), its 15 [Pnu86], which defines a number of compatibility types between logics and equivalences, calls this expressivity. 6.8] Concluding Remarks 181 induced equivalence will probably coincide with delay equivalence. To the best of our knowledge, no modal characterisation of this equivalence has been given before.
Reference: [DNV90b] <author> Rocco De Nicola and Frits Vaandrager. </author> <title> Three logics for branching bisimulation. </title> <booktitle> In 1990 IEEE Fifth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 118129. </pages> <publisher> IEEE Computer Society Press, </publisher> <address> Los Alami-tos, CA, </address> <year> 1990. </year> <note> Full version available as Report CS-R9012, </note> <institution> Centre for Math. and Comp. </institution> <address> Sc., Amsterdam. </address>
Reference-contexts: Negation also allows to express 8U in terms of 9U and 9G (see Lemma 2.4.1.2), suggesting another way to obtain a functionally complete set of operators. A third possibility is to allow the negation symbol to occur in between a quantifier and a temporal operator; see e.g. <ref> [DNV90b] </ref>. <p> Another approach, taken in <ref> [DNV90b] </ref> for example, interprets formulae along maximal prefixes, i.e. prefixes that cannot be extended because either they are infinite, or their last state has no outgoing transitions. <p> One may wonder whether it is not possible instead to extend the definition of CTL fl 's interpretation to finite computations, by interpreting the path quantifiers over maximal prefixes (cf. <ref> [DNV90b] </ref> for example), i.e. prefixes that cannot be extended because either they are infinite, or their last state has no outgoing transitions. The answer is that this would require a revision of the results developed in this chapter. <p> It turns out that a silent move is observable iV it coincides with a CTL fl step (Section 2.3.1) in the sense that we discussed above. This follows from the 6.3] Nextless CTL fl and CTL 155 results of [BCG88] and <ref> [DNV90b] </ref>, which imply that, roughly 8 , branching equivalence is adequate for CTL fl .U/. Adding back the Next operator to CTL fl .U/ results in a logic whose induced equivalence is finer than branching equivalence and thus too fine according to [vG93b]. <p> Before presenting stuttering equivalence, which is the behavioural equivalence adequate for CTL ffi .U/, we give the definition of divergence blind stuttering equivalence (dbs-equivalence) <ref> [DNV90b, GV90] </ref>, both on states and on paths. 6.3.2.3 Definition Let 6 fi 6 be a symmetric relation such that for every s; t 2 6, s t implies: 1. .s/ D .t /. 2. <p> So, although for every s-path there exists a dbs-equivalent t prefix, this is not necessarily a t path. It is this point that makes the equivalence blind to divergence. For example, the states s and t in Figure 6.2 cannot be distinguished. In <ref> [DNV90b] </ref> it is proven that if the interpretation of CTL ffi .U/ path formulae is altered in such a way that 8 and 9 quantify over all prefixes, then the equivalence induced by CTL ffi .U/ coincides with dbs-equivalence. Here, we adapt the behavioural equivalence instead of the logic. <p> It is now easily seen that for the path fl t formed by C 0 ; C 1 ; : : : ; C k , we have fl s stut fl t. 2 The above definition of stuttering equivalence is diVerent from that given in <ref> [DNV90b] </ref>. In that paper, the transition relation of a Kripke structure does not have to be total. s-equivalence of states is defined as dbs-equivalence in the so-called live-lock extension, which is obtained by the applying the following transformation to the transition system. <p> For each state that has no outgoing transitions or occurs on a cycle of states that all have the same labels, a new outgoing transition is added. This transition leads to a new state (called s 0 in <ref> [DNV90b] </ref>) that is labelled by a new proposition that occurs in no other label. Another diVerence is that in [DNV90b], Kripke structures are assumed to be finite. <p> This transition leads to a new state (called s 0 in <ref> [DNV90b] </ref>) that is labelled by a new proposition that occurs in no other label. Another diVerence is that in [DNV90b], Kripke structures are assumed to be finite. For finite structures, the condition infstut stut .s/ is true iV s occurs on a cycle of states that all have the same label. Therefore, condition 2 of Definition 6.3.2.5 is not needed in the setting of [DNV90b]. <p> Another diVerence is that in <ref> [DNV90b] </ref>, Kripke structures are assumed to be finite. For finite structures, the condition infstut stut .s/ is true iV s occurs on a cycle of states that all have the same label. Therefore, condition 2 of Definition 6.3.2.5 is not needed in the setting of [DNV90b]. These variations cause some diVerences between the proof of Lemma 6.3.2.6 above and the proof 9 of Lemma 3.13 in [DNV90b]. However, having established Lemma 6.3.2.6, fineness of stut for CTL ffi .U/, stated in the following lemma, can be proven in the same way as Lemma 3.14 in [DNV90b]. <p> Therefore, condition 2 of Definition 6.3.2.5 is not needed in the setting of <ref> [DNV90b] </ref>. These variations cause some diVerences between the proof of Lemma 6.3.2.6 above and the proof 9 of Lemma 3.13 in [DNV90b]. However, having established Lemma 6.3.2.6, fineness of stut for CTL ffi .U/, stated in the following lemma, can be proven in the same way as Lemma 3.14 in [DNV90b]. 6.3.2.7 Lemma If s stut t , then 8 '2CTL ffi .U/ s jD ' , t jD '. <p> <ref> [DNV90b] </ref>. These variations cause some diVerences between the proof of Lemma 6.3.2.6 above and the proof 9 of Lemma 3.13 in [DNV90b]. However, having established Lemma 6.3.2.6, fineness of stut for CTL ffi .U/, stated in the following lemma, can be proven in the same way as Lemma 3.14 in [DNV90b]. 6.3.2.7 Lemma If s stut t , then 8 '2CTL ffi .U/ s jD ' , t jD '. The converse, abstractness, again only holds for Kripke structures that satisfy a certain (strong) form of finite-branchingness. 6.3.2.8 Definition Let be an equivalence relation on 6. <p> Then stut is adequate for both CTL fl .U/ and CTL.U/. Simplifications of stuttering equivalence In <ref> [DNV90b] </ref>, de Nicola and Vaandrager prove adequacy of CTL ffi .U/ for a notion of stuttering equivalence on KSs that is defined slightly diVerently. That their definition (Definition 6.3.2.12 below) yields the same equivalence as stut from Definition 6.3.2.5 (on finite KSs without deadlock) is stated by Lemma 6.3.2.13. <p> Although most of these results are not new, there are a few places where we have established generalisations of older results. Most notably, we did not require finiteness of the transition system, while this is an essential condition in both [BCG88] and <ref> [DNV90b] </ref>. Indeed, in those papers a stronger correspondence between stuttering equivalence and CTL.U/ is proven, namely that every (finite) Kripke structure can be characterised (up to stuttering equivalence) by a single CTL.U/ formula 15 . For adequacy, only a certain form of finite branchingness is needed.
Reference: [DP90] <author> B. A. Davey and H. A. Priestley. </author> <title> Introduction to Lattices and Order. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1990. </year>
Reference-contexts: Property 2.2 can be proven using the Fundamental Lemma of Bourbaki ([Bou50]): see e.g. Exercise 14 in <ref> [DP90] </ref>. Note that 2.2 implies that lfp. f / is below any fixpoint of f .
Reference: [DWT95] <author> David L. Dill and Howard Wong-Toi. </author> <title> Verification of real-time systems by successive over and under approximation. </title> <booktitle> In Wolper [Wol95], </booktitle> <pages> pages 409422. </pages>
Reference-contexts: One answer is that we envisage applications in combination with symbolic methods, where sets of states and transition relations are represented by BDDs for example. Such symbolic methods may often be combined with approximation techniques, see e.g. <ref> [DGD C 94, DWT95] </ref>. The techniques presented in Chapter 5 may then oVer an interesting alternative to symbolic model checking: in addition to computing the set of states satisfying the specification, an abstract model is also constructed.
Reference: [EC82] <author> E. Allen Emerson and Edmund M. Clarke. </author> <title> Using branching time temporal logic to synthesize synchronization skeletons. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 2:241266, </address> <year> 1982. </year>
Reference-contexts: Another approach, taken in [DNV90b] for example, interprets formulae along maximal prefixes, i.e. prefixes that cannot be extended because either they are infinite, or their last state has no outgoing transitions. In yet other articles 24 Preliminaries [2.4 (e.g. <ref> [EC82, CES86] </ref>), transition relations are required to be total : every state must have an outgoing transition. This requirement avoids the type of misinterpretations discussed above, but imposes the obligation to ensure that every system being defined has a total transition relation. This may be cumbersome.
Reference: [EH86] <author> E.A. Emerson and J.Y. Halpern. </author> <title> Sometimes and not never revisited: On branching versus linear time. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 33(1):151178, </volume> <year> 1986. </year>
Reference-contexts: Note that CTL fl formulae containing path quantifiers express properties about the infinite computations of a system only, because the quantifiers are interpreted over paths (which are infinite computations by definition). Although in the original definition of CTL fl in <ref> [EH86] </ref> also finite computations are taken into consideration, both [EL87] and the recent overview article [Eme90] revise the original definition by quantifying over (full-)paths only. A similar definition is given in [CGL94].
Reference: [Ehr61] <author> A. Ehrenfeucht. </author> <title> An application of games to the completeness problem of formalised theories. </title> <journal> Fundamenta Mathematicae, </journal> <volume> 49:129141, </volume> <year> 1961. </year>
Reference-contexts: For the case of CTL fl .U//stut 180 Logics, Equivalences and Behavioural Partition Refinement [6.8 tering equivalence, partition refinement algorithms can be found in [BCG88, GV90]. The reader who is interested in game characterisations of equivalences could have a look at <ref> [Ehr61, Fra54, IK87, Tho93, NC94] </ref>. 6.8 Concluding Remarks We have investiged the correspondences between a number of temporal logics and behavioural equivalences, and also between behavioural equivalences and partition refinement algorithms.
Reference: [EL87] <author> E. Allen Emerson and Chin-Laung Lei. </author> <title> Modalities for model checking: Branching time logic strikes back. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 8:275306, </address> <year> 1987. </year>
Reference-contexts: Note that CTL fl formulae containing path quantifiers express properties about the infinite computations of a system only, because the quantifiers are interpreted over paths (which are infinite computations by definition). Although in the original definition of CTL fl in [EH86] also finite computations are taken into consideration, both <ref> [EL87] </ref> and the recent overview article [Eme90] revise the original definition by quantifying over (full-)paths only. A similar definition is given in [CGL94]. <p> Traditionally, automata-theoretic algorithms are used for linear-time temporal logic, while the graph-traversal algorithms were devised in the context of CTL and the -calculus. Indeed, the first model-checking algorithm for CTL fl , which subsumes both LTL and CTL, combines both techniques in one algorithm (see <ref> [EL87] </ref>). Recent work, [BG93, BVW94, Kup95], shows that eYcient branching-time model checking can be captured in the automata-theoretic framework too, using alternating-tree automata. The complexity of model checking increases with the expressivity of the temporal logic.
Reference: [Eme90] <author> E. Allen Emerson. </author> <title> Temporal and modal logic. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Formal Models and Semantic, volume B of Handbook of Theoretical Computer Science, chapter 16, </booktitle> <pages> pages 9951072. </pages> <publisher> Elsevier/The MIT Press, </publisher> <address> Amsterdam, </address> <year> 1990. </year> <note> Bibliography 199 </note>
Reference-contexts: Although in the original definition of CTL fl in [EH86] also finite computations are taken into consideration, both [EL87] and the recent overview article <ref> [Eme90] </ref> revise the original definition by quantifying over (full-)paths only. A similar definition is given in [CGL94]. <p> Although this thesis is about techniques that aim to extend of the applicability of model checking, the particular model-checking approach that is chosen and the details of the algorithms are immaterial. The interested reader is referred to the articles mentioned above. Furthermore, a number of overviews have recently appeared: <ref> [Eme90, Sti92, CGL93, Kur94] </ref>. Chapter 3 Abstraction and Preservation Besides introducing abstraction and Abstract Interpretation, this chapter presents a systematic reconstruction of several frameworks for abstraction that occur in the literature. We formalise the notion of property preservation, and investigate how weak and strong preservation lead to diVerent frameworks. <p> The search for the 4 However, one should also keep in mind that diVerent expressive power may come at the cost of a more expensive model checking algorithm. For example, although CTL fl induces the same equivalence as CTL (see Section 6.2), it is known (see e.g. <ref> [Eme90] </ref>, pp. 10441045) to have a higher model-checking complexity. 6.2] CTL fl , CTL, and Bisimulation 149 corresponding adequate fragment of CTL fl brings along some surprises. Section 6.6 presents the appropriate instance of the partition refinement scheme.
Reference: [FKM93] <author> J.-C. Fernandez, A. Kerbrat, and L. Mounier. </author> <title> Symbolic equivalence checking. </title> <booktitle> In Courcoubetis [Cou93], </booktitle> <pages> pages 8596. </pages>
Reference-contexts: DiVerent instances of the idea consider variations like weak and branching bisimulation (the latter equivalence coincides with the equivalences induced by CTL fl .U/ and CTL.U/; also see the next chapter), see <ref> [BCG88, GV90, FKM93] </ref>. Such algorithms may be used to reduce the size of a transition system while strongly preserving the corresponding logics. Below, we first briefly recall a simple version of the PRA for bisimulation, which underlies most of the mentioned algorithms.
Reference: [FL79] <author> Michael J. Fischer and Richard E. Ladner. </author> <title> Propositional dynamic logic of regular programs. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 18:194 211, </volume> <year> 1979. </year>
Reference: [FM91] <author> Jean-Claude Fernandez and Laurent Mounier. </author> <title> On the fly verification of behavioural equivalences and preorders. </title> <booktitle> In Larsen and Skou [LS91], </booktitle> <pages> pages 181191. </pages>
Reference-contexts: For an overview see [CGL93]. On-the-fly (or: on-line) techniques minimise the memory demands of model checkers by only expanding those parts of the program that are needed to verify the given property. Being exposed in e.g. <ref> [JJ89, BFH90, FM91] </ref>, these techniques have indeed been used before in many verifiers developed by G. Holzmann; see e.g. [Hol84, Hol91]. An approach from the second category is formed by the partial-order techniques, which abstract from diVerent interleavings of actions originating from concurrent components of a program.
Reference: [Fra54] <author> R. Fra sse. </author> <title> Sur quelques classifications des systemes de relations. </title> <journal> Publ. Sci. Univ. Alger. </journal> <volume> I, volume 1, </volume> <pages> pages 35182. </pages> <year> 1954. </year>
Reference-contexts: For the case of CTL fl .U//stut 180 Logics, Equivalences and Behavioural Partition Refinement [6.8 tering equivalence, partition refinement algorithms can be found in [BCG88, GV90]. The reader who is interested in game characterisations of equivalences could have a look at <ref> [Ehr61, Fra54, IK87, Tho93, NC94] </ref>. 6.8 Concluding Remarks We have investiged the correspondences between a number of temporal logics and behavioural equivalences, and also between behavioural equivalences and partition refinement algorithms.
Reference: [Fra92] <author> Nissim Francez. </author> <title> Program Verification. </title> <booktitle> International Computer Science Series. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Wokingham, England, </address> <year> 1992. </year>
Reference-contexts: A more extensive overview and comparison can be found in Section 4.9. 1.4.2 Program verification For proof-based methods, introductions as well as bibliographies may be found in [AO91], <ref> [Fra92] </ref> or [MP92, MP95] for example. The latter books are also recommended for an overview of temporal logic. Model checking was introduced independently in [QS82] and [CE81]. It has led to a large stream of both practically and theoretically oriented articles.
Reference: [Gin68] <author> A. Ginzburg. </author> <title> Algebraic Theory of Automata. </title> <booktitle> ACM Monograph Series. </booktitle> <publisher> Academic Press, </publisher> <address> New York/London, </address> <year> 1968. </year>
Reference-contexts: Most of these eVorts are based on the notion of simulation (Definition 2.4.2.1). Homomorphisms (see e.g. <ref> [Gin68] </ref>), used in automata theory to construct language preserving reductions of automata, can be viewed as a precursor of this.
Reference: [GKP92] <author> Ursula Goltz, Ruurd Kuiper, and Wojciech Penczek. </author> <title> Propositional temporal logics and equivalences. </title> <booktitle> In Cleaveland [Cle92], </booktitle> <pages> pages 222236. </pages>
Reference: [GKPP95] <author> Rob Gerth, Ruurd Kuiper, Doron Peled, and Wojciech Penczek. </author> <title> A partial order approach to branching time logic model checking. </title> <booktitle> In Third Israel Symposium on the Theory of Computing and Systems, </booktitle> <pages> pages 130 139. </pages> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1995. </year>
Reference-contexts: Originally developed for verification of linear-time temporal logic properties ([PL90, Val90, GW91, JK90, KP92, God96]), this technique has recently been extended for branching-time properties in <ref> [GKPP95] </ref>. Chapter 2 Preliminaries This chapter introduces the mathematical machinery and reviews some specific notions from computing science that will be used in the rest of this thesis. The reader may choose to skip (parts of ) it and only return here if necessary.
Reference: [GL93] <author> Susanne Graf and Claire Loiseaux. </author> <title> A tool for symbolic program verification and abstraction. </title> <booktitle> In Courcoubetis [Cou93], </booktitle> <pages> pages 7184. </pages>
Reference-contexts: In [Loi94], this theory is not only worked out in full detail, but the implementation of a tool based on it is described and analysed too. A closely related paper is <ref> [GL93] </ref>. The approach is similar to that taken in Section 4.3, although the results deviate because the underlying frameworks are slightly diVerent. In [LGS C 95], Loiseaux et al. also use Galois connections to relate concrete and abstract states spaces, but in a diVerent way than we do.
Reference: [God96] <author> Patrice Godefroid. </author> <title> Partial-Order Methods for the Verification of Concurrent Systems. </title> <booktitle> Number 1032 in LNCS. </booktitle> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1996. </year>
Reference: [Gol92] <author> Robert Goldblatt. </author> <title> Logics of Time and Computation. </title> <booktitle> Number 7 in CSLI Lecture Notes. Center for the Study of Language and Information, Stanford, second edition, </booktitle> <year> 1992. </year>
Reference: [GP95] <author> Jan Friso Groote and Alban Ponse. </author> <title> The syntax and semantics of CRL. </title> <editor> In A. Ponse, C. Verhoef, and S.F.M. van Vlijmen, editors, </editor> <title> Algebra of Communicating Processes, </title> <booktitle> Utrecht 1994, Workshops in Computing, </booktitle> <pages> pages 2662. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1995. </year> <note> 200 Bibliography </note>
Reference: [Gra94] <author> Susanne Graf. </author> <title> Verification of a distributed cache memory by using abstractions. </title> <booktitle> In Dill [Dil94], </booktitle> <pages> pages 207219. </pages> <note> To appear in Distributed Computing. </note>
Reference-contexts: program operations, although based on a diVerent theoretical framework ([LGS C 95, 25 Recall (Definition 2.3.0.1) that :' is the abbreviation of a CTL fl formula in negation-normal form. 90 Abstract Interpretation of Nondeterministic Systems [4.7 Loi94], see Section 4.9 for a comparison), is applied to a real-life example in <ref> [Gra94] </ref>. Graf shows in that paper how a distributed cache memory, which is in principle an infinite state system because request queues are unbounded, can be verified by providing a finite abstract domain and corresponding abstract operations. <p> So far we have assumed that the abstract domain is provided by the user of the method; an example of this may be found in <ref> [Gra94] </ref>. The proofs for the abstract operators may form a diYcult step in the method. In [KDG95], approximations to the transition relation of StateCharts ([Har87]) are used to verify -calculus properties of a production cell ([DHKS95]) in a compositional fashion. <p> While we think that the presented framework oVers a stable theoretical foundation for the application of abstract interpretation in model checking, further research has to be performed to confirm this belief. Section 4.9.2 on [KDG95] already mentioned one line of on-going research. Also, the experiments described in e.g. <ref> [Gra94] </ref> show that the marriage between Abstract Interpretation and model checking is a fruitful one. 35 Also called false negatives sometimes. Chapter 5 Logical Partition Refinement We now turn to strong preservation and investigate the consequences for the relation between Kripke structures and their descriptions.
Reference: [GS84] <author> S. Graf and J. Sifakis. </author> <title> A modal characterization of observational congruence on finite terms of CCS. </title> <editor> In Jan Paredaens, editor, </editor> <booktitle> Proc. of the Eleventh International Colloquium on Automata Languages and Programming (ICALP), number 172 in LNCS, </booktitle> <pages> pages 222234. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1984. </year>
Reference: [GV90] <author> Jan Friso Groote and Frits Vaandrager. </author> <title> An eYcient algorithm for branching bisimulation and stuttering equivalence. </title> <editor> In M. S. Paterson, editor, </editor> <booktitle> Automata, Languages and Programming, number 443 in LNCS, </booktitle> <pages> pages 626638. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: DiVerent instances of the idea consider variations like weak and branching bisimulation (the latter equivalence coincides with the equivalences induced by CTL fl .U/ and CTL.U/; also see the next chapter), see <ref> [BCG88, GV90, FKM93] </ref>. Such algorithms may be used to reduce the size of a transition system while strongly preserving the corresponding logics. Below, we first briefly recall a simple version of the PRA for bisimulation, which underlies most of the mentioned algorithms. <p> Partition refinement algorithms that divide out the equivalence classes of some behavioural equivalence by successive refinement of the blocks of a partition have been presented for bisimu-lation (e.g. in [PT87, BFH C 92]) and stuttering (or branching) equivalence (e.g. in <ref> [BCG88, GV90] </ref>). These equivalences both correspond to logics that are closed under negation, namely CTL fl and CTL fl .U/ (also see the next chapter). For simulation equivalence, the only previous decision algorithm that we know of is [CC95], which does not fit the partition refinement scheme. <p> Furthermore, partition refinement algorithms have been developed for a number of such behavioural equivalences. For example, the partition refinement algorithm developed in [BFH C 92] computes the equivalence classes under bisimulation equivalence. Another example is the partition refinement algorithm for stuttering equivalence (branching bisimulation) of <ref> [GV90] </ref>. In [BCG88], stuttering equivalence has been shown to coincide with the equivalences induced by CTL.U/ and CTL fl .U/. In those cases, these algorithms may be used to construct abstract models that strongly preserve the corresponding logic. <p> Before presenting stuttering equivalence, which is the behavioural equivalence adequate for CTL ffi .U/, we give the definition of divergence blind stuttering equivalence (dbs-equivalence) <ref> [DNV90b, GV90] </ref>, both on states and on paths. 6.3.2.3 Definition Let 6 fi 6 be a symmetric relation such that for every s; t 2 6, s t implies: 1. .s/ D .t /. 2. <p> Indeed, for both bisimulation and stuttering equivalence such algorithms have been developed, see [BFH C 92], [BCG88] and <ref> [GV90] </ref>. In this section, we generalise the common concepts that underly both algorithms, and present a generic scheme of which they are instantiations that are induced by the format of the definition of the behavioural equivalence. <p> To begin with, we drop the requirement about infinite stuttering, i.e. we consider in fact Definition 6.3.2.3 of divergence blind stuttering equivalence. The results in <ref> [GV90] </ref> indicate that a PRA for (divergence sensitive) stuttering equivalence can be obtained by adding a simple preprocessing phase to a PRA for divergence blind stuttering equivalence. <p> Algorithms for minimisation of automata (see [Hop71]) form a precursor; optimisations and adaptations have been presented in [PT87, KS90, BFH C 92]. For the case of CTL fl .U//stut 180 Logics, Equivalences and Behavioural Partition Refinement [6.8 tering equivalence, partition refinement algorithms can be found in <ref> [BCG88, GV90] </ref>. The reader who is interested in game characterisations of equivalences could have a look at [Ehr61, Fra54, IK87, Tho93, NC94]. 6.8 Concluding Remarks We have investiged the correspondences between a number of temporal logics and behavioural equivalences, and also between behavioural equivalences and partition refinement algorithms.
Reference: [GW89] <author> R. J. van Glabbeek and W. P. Weijland. </author> <title> Branching time and abstraction in bisimulation semantics (extended abstract). </title> <editor> In G. X. Ritter, editor, </editor> <booktitle> Information Processing 89, </booktitle> <pages> pages 613618. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1989. </year> <note> Full version available as Report CS-R9120, </note> <institution> Center for Math. and Comp. </institution> <address> Sc., Amsterdam, </address> <year> 1991. </year>
Reference-contexts: Several observational or weak equivalences have been proposed to more faithfully capture the notion of equivalence in the presence of silent moves: observational equivalence in the sense of [HM85], observation equivalence (called t -bisimulation equivalence in [BK85]) of [Mil80], -bisimulation of [BG87], delay bisimulation of [Mil83], and branching bisimulation of <ref> [GW89] </ref>. In [vG93b], van Glabbeek convincingly argues that, in a sense, branching bisimulation equivalence (branching equivalence for short) is the coarsest equivalence that respects the branching structure of a process with silent moves. <p> In computer science, bisimulation is usually attributed to Park, who introduced the term in [Par81], in the context of automata. Milner introduced the notion of simulation in [Mil71] and observational equivalence in [Mil80]. Branching bisim-ulation has been proposed as an alternative to observational equivalence in, among others, <ref> [GW89, vG90a, vG93a, vG93b] </ref>. A large variety of behavioural equivalences has been defined and studied over the past ten years; see [DN87] for a discussion. Also [BK90] contains a lot of material on this topic.
Reference: [GW91] <author> P. Godefroid and P. Wolper. </author> <title> Using partial orders for the eYcient verification of deadlock freedom and safety properties. </title> <booktitle> In Larsen and Skou [LS91], </booktitle> <pages> pages 332342. </pages>
Reference: [Har80] <author> David Harel. </author> <title> On folk theorems. </title> <journal> Communications of the ACM, </journal> <volume> 23(7):379389, </volume> <year> 1980. </year>
Reference-contexts: The latter is the case iV g distributes over glbs and the set fy j x v g.y/g has a glb for every x 2 P; 6 The investigations reported in [LNS82] suggest that this lemma is a folk theorem in the sense of <ref> [Har80] </ref>. 7 In fact, Galois connections as defined here are semi-dual with respect to the original definition of [Ore44]: the definition given there requires f and g to be antitone ( f is antitone if x v y ) f .x/ - f .y/) and both f ffi g and g
Reference: [Har87] <author> David Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 8:231274, </address> <year> 1987. </year>
Reference: [HC84] <author> G.E. Hughes and M.J. Cresswell. </author> <title> A Companion to Modal Logic. </title> <publisher> Methuen, </publisher> <address> London, </address> <month> 1884. </month>
Reference: [HHK95] <author> Monika R. Henzinger, Thomas A. Henzinger, and Peter W. Kopke. </author> <title> Computing simulations on finite and infinite graphs. </title> <booktitle> In 36th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 453462. </pages> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1995. </year>
Reference-contexts: Our splitting algorithm for 8CTL can be viewed as a partition refinement algorithm for simulation equivalence. Such an algorithm has been developed before in [CC95]; recently, the topic has enjoyed new interest in the context of hybrid systems see <ref> [HHK95] </ref>. The partition refinement algorithm for arbitrary finite subsets of 8CTL is novel; however, the iterative computation of characteristic predicates is common in symbolic model checking, e.g. [BCM C 92]. A paper that is closely related to the idea of splitting for a single formula (Section 5.6) is [ASSSV94]. <p> These equivalences both correspond to logics that are closed under negation, namely CTL fl and CTL fl .U/ (also see the next chapter). For simulation equivalence, the only previous decision algorithm that we know of is [CC95], which does not fit the partition refinement scheme. More recently, <ref> [HHK95] </ref> presents an algorithm that indeed uses ideas from [PT87]. In general, the behavioural equivalence corresponding to a property set that is an arbitrary subset of a temporal logic will not have a nice regular form like bisimula-tion, simulation equivalence or stuttering equivalence.
Reference: [HK94] <author> J. Helbig and P. Kelb. </author> <title> An OBDD-representation of StateCharts. </title> <booktitle> In Proceedings. The European Design and Test Conference, </booktitle> <pages> pages 142149. </pages> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1994. </year> <note> Bibliography 201 </note>
Reference-contexts: To this purpose, the system is modelled in StateCharts ([Har87]), a graphical specification language for reactive systems. It is based on automata theory and allows the specification of automata that are composed in parallel. It permits a straightforward translation into (lists of implicitly intersected) BDDs; see <ref> [HK94] </ref>. The general 4.10] Related Work 111 structure of the StateChart specification of the production cell is a parallel composition, where each process corresponds to one of the components mentioned above.
Reference: [HM80] <author> Matthew Hennessy and Robin Milner. </author> <title> On observing nondetermin-ism and concurrency. </title> <editor> In J.W. de Bakker and J. van Leeuwen, editors, </editor> <booktitle> Proc. of the Seventh International Colloquium on Automata Languages and Programming (ICALP), number 85 in LNCS, </booktitle> <pages> pages 299309. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1980. </year>
Reference-contexts: In [Mil71], Milner introduced the term simulation to denote a homomorphism between deterministic systems. Since then, it has been re-adapted to nondeterministic transition systems and has become popular in the areas of program refinement and verification; [Sif82], [Sif83] and <ref> [HM80] </ref> are some early papers on this topic. [Dil89] and [Kur90] focus on trace (linear time) semantics and universal safety and liveness properties. Some of the first papers that consider the (strong) preservation of full CTL fl and L are [CGL92] and [BBLS92].
Reference: [HM85] <author> Matthew Hennessy and Robin Milner. </author> <title> Algebraic laws for nondetermin-ism and concurrency. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 32(1):137161, </volume> <year> 1985. </year>
Reference-contexts: In particular, we want to be able to express typical properties of reactive systems also called reactive properties. To this purpose, we use temporal logic. Examples are LTL (linear temporal logic, see [Pnu77]), CTL (computation tree logic, see [CES86]), CTL fl ([EH86, EL87]), HML (Henessy-Milner Logic, see <ref> [HM85] </ref>) and L (the -calculus, see [Koz83]). <p> Proof Like, e.g., the proof of a similar property of bisimulation (see Definition 2.4.2.7 below) in <ref> [HM85] </ref>. 2 2.4.2.5 Property If sim kC1 D sim k for some k 0, then for all j 0, sim kC j D sim k . 13 When confusion about the domain and range of a simulation may occur, we attach the type as a subscript. 14 The intuition is that <p> Several observational or weak equivalences have been proposed to more faithfully capture the notion of equivalence in the presence of silent moves: observational equivalence in the sense of <ref> [HM85] </ref>, observation equivalence (called t -bisimulation equivalence in [BK85]) of [Mil80], -bisimulation of [BG87], delay bisimulation of [Mil83], and branching bisimulation of [GW89]. <p> Then s bis t iV 8 n2N s n bis t . 2. Assume that T is finitely branching and also finitely branching under Lit stuttering. Then s dbs t iV 8 n2N s n dbs t . Proof Point 1 is standard, see e.g. <ref> [HM85] </ref>. Point 2 is similar. 2 166 Logics, Equivalences and Behavioural Partition Refinement [6.4 The notion of refining a block with respect to a set of splitters is formalised as follows. 6.4.0.7 Definition Let B 6 and S a set of splitters. split.B; S/ D Part .B; S /.
Reference: [HNSY94] <author> Thomas A. Henzinger, Xavier Nicollin, Joseph Sifakis, and Sergio Yovine. </author> <title> Symbolic model checking for real-time systems. Information and Computation, </title> <address> 111(1):193244, </address> <year> 1994. </year>
Reference-contexts: The operator fl of [ACH94] takes such an approach. In that framework, which considers actions, it is the occurrence of the next input symbol ( ) that determines the notion of step. A variation on this idea is found in the definition of the timed -calculus T <ref> [HNSY94] </ref>. When the interpretation of the -calculus is extended to systems with continuous time, the Next operator of the untimed -calculus becomes meaningless because the notion of next moment is not well-defined any more. In the timed version it is replaced by the binary operator F called single-step Until. <p> We are currently preparing a publication on the results of these investigations 5 . Another possible extension of Chapter 4 is to consider real-time systems. Verification of such systems (see <ref> [ACD93, HNSY94] </ref> for entrances) poses a challenge as the dis-cretisation of time adds yet another dimension (besides the possible interleavings and state-space factors that cause a blow-up) to the state explosion.
Reference: [Hoa85] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <address> En-glewood CliVs, NJ, </address> <year> 1985. </year>
Reference: [Hol84] <author> Gerard J. Holzmann. </author> <title> Backward symbolic execution of protocols. </title> <editor> In Yechiam Yemini, Robert Strom, and Yemini Shaula, editors, </editor> <title> Protocol Specification, Testing, and Verification, </title> <booktitle> pages 1930. </booktitle> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1984. </year>
Reference-contexts: Being exposed in e.g. [JJ89, BFH90, FM91], these techniques have indeed been used before in many verifiers developed by G. Holzmann; see e.g. <ref> [Hol84, Hol91] </ref>. An approach from the second category is formed by the partial-order techniques, which abstract from diVerent interleavings of actions originating from concurrent components of a program.
Reference: [Hol91] <author> Gerard J. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <booktitle> Pren-tice Hall Software Series. Prentice-Hall International, </booktitle> <address> London, </address> <year> 1991. </year>
Reference-contexts: Being exposed in e.g. [JJ89, BFH90, FM91], these techniques have indeed been used before in many verifiers developed by G. Holzmann; see e.g. <ref> [Hol84, Hol91] </ref>. An approach from the second category is formed by the partial-order techniques, which abstract from diVerent interleavings of actions originating from concurrent components of a program.
Reference: [Hol96] <author> Marco Hollenberg, </author> <month> May </month> <year> 1996. </year> <title> Private communication. </title>
Reference: [Hop71] <author> John Hopcroft. </author> <title> An n log n algorithm for minimizing states in a finite automaton. </title> <editor> In Zvi Kohavi and Azaria Paz, editors, </editor> <booktitle> Theory of Machines and Computations, </booktitle> <pages> pages 189196. </pages> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1971. </year>
Reference-contexts: In particular this answers the question how to characterise fairness. [ASB C 94] also studies the equivalences that are induced by CTL and CTL fl on Kripke structures with fairness constraints. Partition refinement algorithms originate in automata theory. Algorithms for minimisation of automata (see <ref> [Hop71] </ref>) form a precursor; optimisations and adaptations have been presented in [PT87, KS90, BFH C 92]. For the case of CTL fl .U//stut 180 Logics, Equivalences and Behavioural Partition Refinement [6.8 tering equivalence, partition refinement algorithms can be found in [BCG88, GV90].
Reference: [IK87] <author> Neil Immerman and Dexter Kozen. </author> <title> Definability with bounded number of bound variables. </title> <booktitle> In Logic in Computer Science, </booktitle> <pages> pages 236244. </pages> <publisher> IEEE Computer Society Press, </publisher> <address> Washington DC, </address> <year> 1987. </year>
Reference-contexts: For the case of CTL fl .U//stut 180 Logics, Equivalences and Behavioural Partition Refinement [6.8 tering equivalence, partition refinement algorithms can be found in [BCG88, GV90]. The reader who is interested in game characterisations of equivalences could have a look at <ref> [Ehr61, Fra54, IK87, Tho93, NC94] </ref>. 6.8 Concluding Remarks We have investiged the correspondences between a number of temporal logics and behavioural equivalences, and also between behavioural equivalences and partition refinement algorithms.
Reference: [JJ89] <author> Claude Jard and Thierry Jeron. </author> <title> On-line model-checking for finite linear temporal logic specifications. </title> <booktitle> In Sifakis [Sif89], </booktitle> <pages> pages 189196. </pages>
Reference-contexts: For an overview see [CGL93]. On-the-fly (or: on-line) techniques minimise the memory demands of model checkers by only expanding those parts of the program that are needed to verify the given property. Being exposed in e.g. <ref> [JJ89, BFH90, FM91] </ref>, these techniques have indeed been used before in many verifiers developed by G. Holzmann; see e.g. [Hol84, Hol91]. An approach from the second category is formed by the partial-order techniques, which abstract from diVerent interleavings of actions originating from concurrent components of a program.
Reference: [JK90] <author> Ryszard Janicki and Maciej Koutny. </author> <title> Using optimal simulations to reduce reachability graphs. </title> <editor> In Clarke and Kurshan [CK90], </editor> <volume> pages 166 175. </volume> <pages> 202 Bibliography </pages>
Reference: [JN95] <author> Neil D. Jones and Flemming Nielson. </author> <title> Abstract interpretation: a semantics-based tool for program analysis. </title> <editor> In S. Abramsky, Dov M. Gabbay, and T. S. E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science. Semantic Modelling, </booktitle> <volume> volume 4, </volume> <pages> pages 527636. </pages> <publisher> Oxford University Press, Oxford, </publisher> <year> 1995. </year>
Reference-contexts: Besides that, also various applications relating to program correctness, like debugging and type checking, have been formulated as abstract interpretations. See [AH87], [CC92a], and <ref> [JN95] </ref> for references. <p> A more recent overview article is <ref> [JN95] </ref>. The idea of viewing a program analysis as an approximate computation operating on descriptions of data appears in computer science as early as 1963 in the work of Naur ([Nau63]). Another early example of the idea is given in [Sin72].
Reference: [Jos90] <author> Bernhard Josko. </author> <title> A context dependent equivalence relation between Kripke structures. </title> <editor> In Clarke and Kurshan [CK90], </editor> <address> pages 204213. </address> <note> An extended version appeared in B. </note> <author> Josko, </author> <title> Modular Specification and Verification of Reactive Systems, </title> <institution> Habilitationsschrift, Carl von Ossietzky University of Oldenburg, Germany, </institution> <year> 1993. </year>
Reference-contexts: Several later studies have investigated the links between bisimulation and the equivalences induced by these logics ([HM80, GS84, HM85, Sti89, BCG88, LGS C 95, Cho95]) as well as between variations on these notions ([BR83, BCG88, DNV90b, BFG C 91, GKP92, vBvES94]). In <ref> [Jos90] </ref>, the results of [BCG88] are generalised by considering Kripke structures together with constraints on the interaction with the environment.
Reference: [JP94] <author> B. Jonsson and J. Parrow, </author> <title> editors. </title> <booktitle> CONCUR '94: Concurrency Theory, number 836 in LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1994. </year>
Reference: [KDG95] <author> Peter Kelb, Dennis Dams, and Rob Gerth. </author> <title> EYcient symbolic model checking of the full -calculus using compositional abstractions. </title> <institution> Computing Science Reports 95/31, Eindhoven University of Technology, </institution> <address> The Netherlands, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: . . . . . . . . . . . 100 4.9.1 Comparing the simulation-based and Galois-insertion ap proach . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103 4.9.2 <ref> [KDG95] </ref>: An application . . . . . . . . . . . . . . . . . . 107 4.10 Concluding Remarks . . . . . . . . . . . . . . . . . . . . . . . . 112 5 <p> This technique is similar to the mixed abstractions of [DGG94] that will be presented in Chapter 4. Kelb presents an application of these techniques to the verification of StateChart programs. Part of that work was carried out jointly; see <ref> [KDG95] </ref>. An extensive discussion of the results will be given in Section 4.9.2. Another interesting point in [Kel95] is the generalisation of preservation results to stutter-insensitive specifications, by forbidding an explicit next-step operator. [CIY95] also develops preservation results for CTL fl which are similar to ours. <p> Another diVerence is that the construction of abstract models is not considered in [CIY95]. Application of Abstract Interpretation to verify properties of CCS is described in [DFFGI95]. A recent paper, <ref> [KDG95] </ref>, reports on progress in the practical application of Abstract Interpretation techniques to compositionally construct abstractions preserving the full -calculus. <p> So, whether this trick to resolve negative answers is successful, depends on how the dual abstractions (in the sense of free vs. constrained) are chosen. We do not further investigate this point here; the interested reader is referred to <ref> [KDG95] </ref>. <p> So far we have assumed that the abstract domain is provided by the user of the method; an example of this may be found in [Gra94]. The proofs for the abstract operators may form a diYcult step in the method. In <ref> [KDG95] </ref>, approximations to the transition relation of StateCharts ([Har87]) are used to verify -calculus properties of a production cell ([DHKS95]) in a compositional fashion. In [DGG93a] and [DGD C 94], a method is developed that aims at full automation of these steps. <p> This technique is similar to the mixed abstractions presented in this chapter. A strong point of Kelb's thesis is the integration of these theoretical results with symbolic (BDD-based) representations. Indeed, [Kel95] proceeds by decribing practical experiments on the symbolic verification of StateChart programs, including part of the material from <ref> [KDG95] </ref>, which was discussed in Section 4.9.2. [CIY94] is based on an early version, [DGG93b], of [DGG94] and independently develops the idea of mixing both free and constrained abstractions in a single abstract system to attain preservation of full CTL fl . <p> This is similar to our definition of approximation between Abstract Kripke structures (Definition 4.2.3.7). On the other hand, in modal transition systems, the must-relation is required to be a subset of the may-relation. Also, there is no notion of approximation ordering between states. A recent paper, <ref> [KDG95] </ref>, reports on an application of abstract interpretation techniques to the verification of properties of a production cell. Section 4.9.2 below contains an account on the findings. <p> Taking ff R to be ff R F as specified by Definition 4.2.3.3 yields b 1 as the only successor of a, as desired. 4.9.2 <ref> [KDG95] </ref>: An application In a recent paper, [KDG95], we report on an application of abstract-interpretation techniques to the verification of universal and existential properties of an industrial production cell. This section gives a summary. <p> Taking ff R to be ff R F as specified by Definition 4.2.3.3 yields b 1 as the only successor of a, as desired. 4.9.2 <ref> [KDG95] </ref>: An application In a recent paper, [KDG95], we report on an application of abstract-interpretation techniques to the verification of universal and existential properties of an industrial production cell. This section gives a summary. The cell, depicted in Figure 4.16, has served as a case study for the evaluation of a number of formal methods, see [LL95]. <p> K is the synchronous product of the K i : its transition relation is the intersection of the transition relations of the individual K i . The size of this global Kripke structure may be prohibitively large for model checking. In <ref> [KDG95] </ref>, a symbolic model checking algorithm (Section 2.4.3) is used, in which sets of states and transition relations are represented by BDDs. The global transition relation R of K is not represented by a single BDD. <p> Accordingly, the idea behind the abstractions used in <ref> [KDG95] </ref> is to reduce such interactions. This is achieved by maintaining both overapproximations R 2 i R i and underapproximations R 3 i R i to the tran sition relations R i . <p> In the symbolic model-checking approach, this set of states is the characteristic set 34 of the formula being checked. Hence, this approximation is safe in the sense that any state in the set that is obtained, is guaranteed to satisfy the formula being checked. 33 The results of <ref> [KDG95] </ref> are presented in the setting of the -calculus. f pre is needed to evaluate universal (2-)properties, while pre is needed for existential (3-)properties. 34 The characteristic set of a formula ' is the set of all states satifying '; cf. <p> The eVect of this is that it tends to be easier to find an overapproximation that preserves the truth of a universal property than it is to find a usable underapproximation that preserves an existential property. This problem is overcome in <ref> [KDG95] </ref> by using the overapproximations R 2 i in computing an underapproximation to pre R i .S/. The key observation is that under a certain condition on a set S of global states, called independence (see Definition 6.6 in [KDG95]), we have pre R 2 i .S/ (even though R 2 <p> This problem is overcome in <ref> [KDG95] </ref> by using the overapproximations R 2 i in computing an underapproximation to pre R i .S/. The key observation is that under a certain condition on a set S of global states, called independence (see Definition 6.6 in [KDG95]), we have pre R 2 i .S/ (even though R 2 i R i ). A closure operator 0 is defined that maps each set of global states to its largest independent subset; we then have pre R 2 i .S/ for every S. <p> While we think that the presented framework oVers a stable theoretical foundation for the application of abstract interpretation in model checking, further research has to be performed to confirm this belief. Section 4.9.2 on <ref> [KDG95] </ref> already mentioned one line of on-going research. Also, the experiments described in e.g. [Gra94] show that the marriage between Abstract Interpretation and model checking is a fruitful one. 35 Also called false negatives sometimes.
Reference: [Kel95] <author> Peter Kelb. Abstraktionstechniken f ur automatische Verifikationsmethoden. </author> <type> PhD thesis, </type> <institution> Carl von Ossietzky University of Oldenburg, Germany, </institution> <month> De-cember </month> <year> 1995. </year>
Reference-contexts: Chapter 5 of this thesis is based on [DGG93a], while part of the material in [DGD C 94] is worked out at the end of Chapter 4. <ref> [Kel95] </ref> develops preservation results for the -calculus in the context of symbolic model checking (see Section 1.4.2 below and 2.4.3). The interpretation of a -calculus formula, which is a set of states, is approximated from below and above. <p> Kelb presents an application of these techniques to the verification of StateChart programs. Part of that work was carried out jointly; see [KDG95]. An extensive discussion of the results will be given in Section 4.9.2. Another interesting point in <ref> [Kel95] </ref> is the generalisation of preservation results to stutter-insensitive specifications, by forbidding an explicit next-step operator. [CIY95] also develops preservation results for CTL fl which are similar to ours. However, the focus of that paper is on the optimality of abstractions. <p> Section 3.3). This is then formally justified 1 The notions of universality and safety of a property are not always distinguished as explicitly as we do in this thesis. What we call universal safety is often just termed safety or invariance elsewhere. 2 <ref> [Kur90, CGL92, BBLS92, Loi94, DGG94, CR94, CIY95, Kel95] </ref>; see Section 4.9 for a more complete overview and comparison. 4.2] Abstract Kripke Structures 59 in Section 4.4. <p> This is further discussed in Section 4.9.1 below. <ref> [Kel95] </ref> also discusses the preservation of universal and existential -calculus properties within the framework of Abstract Interpretation. As in [BBLS92], the relation between abstract and concrete systems is defined through simulations cast in the form of Galois connections. <p> This technique is similar to the mixed abstractions presented in this chapter. A strong point of Kelb's thesis is the integration of these theoretical results with symbolic (BDD-based) representations. Indeed, <ref> [Kel95] </ref> proceeds by decribing practical experiments on the symbolic verification of StateChart programs, including part of the material from [KDG95], which was discussed in Section 4.9.2. [CIY94] is based on an early version, [DGG93b], of [DGG94] and independently develops the idea of mixing both free and constrained abstractions in a single <p> Of a more fundamental nature is the investigation of a framework that enables the comparison and unification of the theories presented in [BBLS92], <ref> [Kel95] </ref>, and Chapter 4. Also regarding Chapter 6, a possible direction for future work is to extend the results, in particular the definition of flat logics and the corresponding adequacy results, to real-time versions of those logics.
Reference: [Koz83] <author> Dexter Kozen. </author> <title> Results on the propositional -calculus. </title> <journal> Journal of Theoretical Computer Science, </journal> <volume> 27:333354, </volume> <year> 1983. </year>
Reference-contexts: To this purpose, we use temporal logic. Examples are LTL (linear temporal logic, see [Pnu77]), CTL (computation tree logic, see [CES86]), CTL fl ([EH86, EL87]), HML (Henessy-Milner Logic, see [HM85]) and L (the -calculus, see <ref> [Koz83] </ref>).
Reference: [KP92] <author> Shmuel Katz and Doron Peled. </author> <title> Verification of distributed programs using representative interleaving sequences. </title> <booktitle> Distributed Computing, </booktitle> <address> 6:107120, </address> <year> 1992. </year>
Reference: [Kri63] <author> S. Kripke. </author> <title> A semantical analysis of modal logic I: normal modal propositional calculi. </title> <journal> Zeitschrift f ur Mathematische Logik und Grundlagen der Mathematik, </journal> <volume> 9:6796, </volume> <year> 1963. </year>
Reference: [KS90] <author> P.C. Kanellakis and S.A. Smolka. </author> <title> CCS expressions, finite state processes, and three problems of equivalence. Information and Computation, </title> <address> 86:4368, </address> <year> 1990. </year>
Reference-contexts: Partition refinement algorithms originate in automata theory. Algorithms for minimisation of automata (see [Hop71]) form a precursor; optimisations and adaptations have been presented in <ref> [PT87, KS90, BFH C 92] </ref>. For the case of CTL fl .U//stut 180 Logics, Equivalences and Behavioural Partition Refinement [6.8 tering equivalence, partition refinement algorithms can be found in [BCG88, GV90].
Reference: [Kup95] <author> Orna Kupferman. </author> <title> Model Checking for Branching-Time Temporal Logics. </title> <type> PhD thesis, </type> <institution> Technion Israel Institute of Technology, Haifa, Israel, </institution> <month> June </month> <year> 1995. </year> <note> Bibliography 203 </note>
Reference-contexts: Traditionally, automata-theoretic algorithms are used for linear-time temporal logic, while the graph-traversal algorithms were devised in the context of CTL and the -calculus. Indeed, the first model-checking algorithm for CTL fl , which subsumes both LTL and CTL, combines both techniques in one algorithm (see [EL87]). Recent work, <ref> [BG93, BVW94, Kup95] </ref>, shows that eYcient branching-time model checking can be captured in the automata-theoretic framework too, using alternating-tree automata. The complexity of model checking increases with the expressivity of the temporal logic.
Reference: [Kur90] <author> R. P. Kurshan. </author> <title> Analysis of discrete event coordination. </title> <editor> In J. W. de Bakker, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> Stepwise Refinement of Distributed Systems: Models, Formalisms, Correctness, </title> <booktitle> number 430 in LNCS, </booktitle> <pages> pages 414453. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: Our approach treats data and control in a uniform way and hence has a more general applicability. Other general frameworks for abstraction in the context of model checking, besides those already mentioned above, are presented in [Sif82, Sif83] (containing much pioneering research), <ref> [Kur90] </ref> (homomorphic reductions), [Bur92] (in the context of trace theory, mainly in a real-time setting) and [Lon93] (combined with compositional techniques). In Chapters 5 and 6 of this thesis, we study partition refinement algorithms, which reduce the size of a transition system by constructing the quotient under some equivalence relation. <p> Section 3.3). This is then formally justified 1 The notions of universality and safety of a property are not always distinguished as explicitly as we do in this thesis. What we call universal safety is often just termed safety or invariance elsewhere. 2 <ref> [Kur90, CGL92, BBLS92, Loi94, DGG94, CR94, CIY95, Kel95] </ref>; see Section 4.9 for a more complete overview and comparison. 4.2] Abstract Kripke Structures 59 in Section 4.4. <p> In [Mil71], Milner introduced the term simulation to denote a homomorphism between deterministic systems. Since then, it has been re-adapted to nondeterministic transition systems and has become popular in the areas of program refinement and verification; [Sif82], [Sif83] and [HM80] are some early papers on this topic. [Dil89] and <ref> [Kur90] </ref> focus on trace (linear time) semantics and universal safety and liveness properties. Some of the first papers that consider the (strong) preservation of full CTL fl and L are [CGL92] and [BBLS92]. Following [Kur90], [CGL92] defines the relation between the concrete and abstract model by means of a homomorphism h, <p> refinement and verification; [Sif82], [Sif83] and [HM80] are some early papers on this topic. [Dil89] and <ref> [Kur90] </ref> focus on trace (linear time) semantics and universal safety and liveness properties. Some of the first papers that consider the (strong) preservation of full CTL fl and L are [CGL92] and [BBLS92]. Following [Kur90], [CGL92] defines the relation between the concrete and abstract model by means of a homomorphism h, which induces an equivalence relation ~ on the concrete states, defined by c ~ d , h.c/ D h.d/. The abstract states are then representations of the equivalence classes of ~.
Reference: [Kur94] <author> Robert P. Kurshan. </author> <title> Computer-Aided Verification of Coordinating Processes: The Automata-Theoretic Approach. </title> <booktitle> Princeton Series in Computer Science. </booktitle> <publisher> Princeton University Press, </publisher> <address> Princeton, NJ, </address> <year> 1994. </year>
Reference-contexts: An alternative approach, often called model checking as well, based on inclusion between automata over infinite words, was developed by Vardi and Wolper ([VW86]) and by Kurshan ([Kur90], also see <ref> [Kur94] </ref>). A closely related method is the tableau-based approach, see [LP85, PZ86]. Model checking has been quite successful in the verification of finite-state programs like protocols and controllers. Some reports may be found in the Applications sessions of the CAV conferences ([Sif89], [CK90], [LS91], [vBP92], [Cou93], [Dil94], [Wol95]). <p> This automaton is then multiplied with the transition system K. The resulting automaton accepts the behaviours in the intersection of K and :'. Thus, if (and only if ) this intersection is empty, K jD ' holds. See e.g. <ref> [VW86, Kur94] </ref>. 28 Preliminaries [2.4 Related is the tableau-based appoach see e.g. [LP85, PZ86]. In the graph-traversal approach, ' is checked over K in a more direct fashion. <p> Although this thesis is about techniques that aim to extend of the applicability of model checking, the particular model-checking approach that is chosen and the details of the algorithms are immaterial. The interested reader is referred to the articles mentioned above. Furthermore, a number of overviews have recently appeared: <ref> [Eme90, Sti92, CGL93, Kur94] </ref>. Chapter 3 Abstraction and Preservation Besides introducing abstraction and Abstract Interpretation, this chapter presents a systematic reconstruction of several frameworks for abstraction that occur in the literature. We formalise the notion of property preservation, and investigate how weak and strong preservation lead to diVerent frameworks.
Reference: [Lam83] <author> L. Lamport. </author> <title> What good is temporal logic? In R.E.A. </title> <editor> Mason, editor, </editor> <booktitle> Information Processing 83, </booktitle> <pages> pages 657668. </pages> <publisher> IFIP, Elsevier Science Publishers B.V. (North-Holland), </publisher> <year> 1983. </year>
Reference-contexts: For this reason, we use the more general term abstraction theory to capture this case too. In conclusion, we give the following working definition: 2 An invariance property states that nothing bad can happen (cf. <ref> [Lam83] </ref>). <p> A number of solutions have been proposed. In <ref> [Lam83] </ref>, Lamport simply drops the Next operator from the logic. This approach, as well as a closely related development in the field of process equivalences, is discussed in the following section. <p> Dropping the Next One of the early pleas against the Next operator is found in <ref> [Lam83] </ref>. The objection there is that inclusion of the Next operator renders a temporal logic too expressive for the goal it has been conceived for, to wit, the specification of (concurrent) computer programs at any level between an abstract specification and a concrete implementation.
Reference: [Lar89] <author> Kim Guldstrand Larsen. </author> <title> Modal specifications. </title> <booktitle> In Sifakis [Sif89], </booktitle> <pages> pages 232246. </pages>
Reference-contexts: A similar result is established in a slightly diVerent framework in [CIY95], based on a result from <ref> [Lar89] </ref>. The first condition above is similar to the requirement of precision of [CIY95] (Definition 20). For a further discussion see Section 4.9 (page 102). The following lemma, which is easily proven, gives suYcient conditions for - and --pseudo-simulation.
Reference: [LGS C 95] <author> C. Loiseaux, S. Graf, J. Sifakis, A. Bouajjani, and S. Bensalem. </author> <title> Property preserving abstractions for the verification of concurrent systems. Formal Methods in System Design, </title> <address> 6:1144, </address> <year> 1995. </year>
Reference-contexts: Weak-preservation results are presented for the universal and existential fragments of the -calculus, while for the full -calculus only a strong-preservation result is given. The topic of constructing abstract models, which is briefly illustrated in that paper, is worked out further in the journal version, <ref> [LGS C 95] </ref>, where it is also shown how the abstraction of a parallel system can be constructed compositionally from the abstractions of the individual components. <p> In particular, if C D A, then this means that coincides with the equivalence that is induced by L (page 25). , being a subset of , need not be a difunctional in general. However, it is easily seen that it has to be consistent (cf. Definition 9 in <ref> [LGS C 95] </ref>) with L: 3.2.2.2 Definition is consistent with L in a 2 A iV for all ' 2 L, 8 c2C [.c; a/ ) c jD '] or 8 c [.c; a/ ) c 6jD ']. is consistent with L iV it is consistent with L in every a <p> Again, preservation of the full -calculus is only shown for abstractions that are bisimilar to C. The construction of abstract models, which is only briefly touched upon in [BBLS92], is worked out further in the journal version, <ref> [LGS C 95] </ref>, where it is shown in addition how the abstraction of a concurrent system can be constructed composi-tionally from the abstractions of the individual components. <p> A closely related paper is [GL93]. The approach is similar to that taken in Section 4.3, although the results deviate because the underlying frameworks are slightly diVerent. In <ref> [LGS C 95] </ref>, Loiseaux et al. also use Galois connections to relate concrete and abstract states spaces, but in a diVerent way than we do. It is shown that in their case, this is equivalent to using simulation relations. <p> A recent paper, [KDG95], reports on an application of abstract interpretation techniques to the verification of properties of a production cell. Section 4.9.2 below contains an account on the findings. First, we discuss in some more depth the relation between our Galois-insertion approach and the simulation-based approach taken in <ref> [LGS C 95] </ref> for example. 4.9.1 Comparing the simulation-based and Galois-insertion approach The conditions under which CTL fl is preserved from a mixed transition system A 0 D .6 0 ; F 0 ; C 0 ; I 0 / to the concrete system C D .6; R; I/ may be <p> This point is discussed in the following comparison of our work with that of <ref> [LGS C 95, Loi94] </ref>. We focus on the free abstract transition relation. <p> The -minimal solutions are obtained by taking either b 1 or b 2 as successor (but not both). However, choosing b 1 will generally give better property preservation, as it describes fewer concrete states. Instead of exploring this freedom to refine the notion of quality of abstract transition relations, <ref> [LGS C 95] </ref> proposes a condition under which all minimal solutions are bisimilar to each other. This condition is D (4.32) i.e. should be a difunctional (Definition 2.1.0.2). Expressed in words, it says that if two concrete states share a description (abstract state), then they share all descriptions. <p> It is easy to see that the generality of simulations over Galois insertions is eliminated by this condition. In fact, requirement 4.32 implies that it is useless to have a that is not functional. This is expressed in the following lemma (which can be found in <ref> [LGS C 95] </ref>). It implies that whenever .c; a/ and .c; a 0 / (a 6D a 0 ) for some c i.e, is not functional then a and a 0 are bisimilar. <p> Because any minimal solution ff R satisfies ff R D 1 R (see <ref> [LGS C 95] </ref>), (*) is equivalent to 1 1 R 1 R 1 . <p> Because 1 D and therefore also 1 1 D 1 (apply the inverse, ./ 1 , to both sides), this is equivalent to 1 R 1 R , which is obviously true. 2 So, to distinguish optimal abstractions from approximations, <ref> [LGS C 95] </ref> make assumption 4.32, which renders their framework less general than the Galois-insertion approach, because, under the reasonable assumption that the abstract system does not contain bisimilar states, it forces to be functional. Consider Figure 4.15 again.
Reference: [LIC86] <institution> Logic in Computer Science. IEEE Computer Society Press, </institution> <year> 1986. </year>
Reference: [LL95] <author> Claus Lewerenz and Thomas Lindner, </author> <title> editors. Formal Development of Reactive Systems: Case Study Production Cell. </title> <booktitle> Number 891 in LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1995. </year>
Reference-contexts: This section gives a summary. The cell, depicted in Figure 4.16, has served as a case study for the evaluation of a number of formal methods, see <ref> [LL95] </ref>.
Reference: [LNS82] <author> J.-L. Lassez, V. L. Nguyen, and E. A. Sonenberg. </author> <title> Fixed point theorems and semantics: A folk tale. </title> <journal> Information Processing Letters, </journal> <volume> 14(3):112 116, </volume> <year> 1982. </year>
Reference-contexts: The latter is the case iV g distributes over glbs and the set fy j x v g.y/g has a glb for every x 2 P; 6 The investigations reported in <ref> [LNS82] </ref> suggest that this lemma is a folk theorem in the sense of [Har80]. 7 In fact, Galois connections as defined here are semi-dual with respect to the original definition of [Ore44]: the definition given there requires f and g to be antitone ( f is antitone if x v y
Reference: [Loi94] <author> Claire Loiseaux. </author> <title> V erification symbolique de syst emes r eactifs a l'aide d'abstractions. </title> <type> PhD thesis, </type> <institution> Universite Joseph Fourier Grenoble I, Grenoble, France, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: The topic of constructing abstract models, which is briefly illustrated in that paper, is worked out further in the journal version, [LGS C 95], where it is also shown how the abstraction of a parallel system can be constructed compositionally from the abstractions of the individual components. In <ref> [Loi94] </ref>, this theory is not only worked out in full detail, the implementation of a tool based on it is described and analysed too. <p> The theory about preservation between, and the construction of, transition systems presented in Chapter 4 of this thesis is based on [DGG94], presenting material that was developed independently from <ref> [BBLS92, Loi94] </ref>. That paper focusses on the definition of a notion of abstraction of transition systems that preserves properties from full CTL fl . <p> Section 3.3). This is then formally justified 1 The notions of universality and safety of a property are not always distinguished as explicitly as we do in this thesis. What we call universal safety is often just termed safety or invariance elsewhere. 2 <ref> [Kur90, CGL92, BBLS92, Loi94, DGG94, CR94, CIY95, Kel95] </ref>; see Section 4.9 for a more complete overview and comparison. 4.2] Abstract Kripke Structures 59 in Section 4.4. <p> The construction of abstract models, which is only briefly touched upon in [BBLS92], is worked out further in the journal version, [LGS C 95], where it is shown in addition how the abstraction of a concurrent system can be constructed composi-tionally from the abstractions of the individual components. In <ref> [Loi94] </ref>, this theory is not only worked out in full detail, but the implementation of a tool based on it is described and analysed too. A closely related paper is [GL93]. <p> This point is discussed in the following comparison of our work with that of <ref> [LGS C 95, Loi94] </ref>. We focus on the free abstract transition relation.
Reference: [Lon93] <author> David E. </author> <title> Long. Model Checking, Abstraction, and Compositional Verification. </title> <type> PhD thesis, </type> <institution> School of Comp. Sc., Carnegie Mellon University, </institution> <address> Pittsburgh, PA 15213, </address> <month> July </month> <year> 1993. </year>
Reference-contexts: Other general frameworks for abstraction in the context of model checking, besides those already mentioned above, are presented in [Sif82, Sif83] (containing much pioneering research), [Kur90] (homomorphic reductions), [Bur92] (in the context of trace theory, mainly in a real-time setting) and <ref> [Lon93] </ref> (combined with compositional techniques). In Chapters 5 and 6 of this thesis, we study partition refinement algorithms, which reduce the size of a transition system by constructing the quotient under some equivalence relation. An overview of other research in this field is given at the end of those chapters. <p> A journal version appeared as [CGL94]. <ref> [Lon93] </ref> also contains these results, presented in a slightly more general setting. [BBLS92] presents similar ideas in a more general setting by considering simulation relations to connect the concrete and abstract transition systems.
Reference: [LP85] <author> Orna Lichtenstein and Amir Pnueli. </author> <title> Checking that finite state concurrent programs satisfy their linear specification. </title> <booktitle> In Twelfth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 97107. </pages> <year> 1985. </year> <note> 204 Bibliography </note>
Reference-contexts: An alternative approach, often called model checking as well, based on inclusion between automata over infinite words, was developed by Vardi and Wolper ([VW86]) and by Kurshan ([Kur90], also see [Kur94]). A closely related method is the tableau-based approach, see <ref> [LP85, PZ86] </ref>. Model checking has been quite successful in the verification of finite-state programs like protocols and controllers. Some reports may be found in the Applications sessions of the CAV conferences ([Sif89], [CK90], [LS91], [vBP92], [Cou93], [Dil94], [Wol95]). <p> The resulting automaton accepts the behaviours in the intersection of K and :'. Thus, if (and only if ) this intersection is empty, K jD ' holds. See e.g. [VW86, Kur94]. 28 Preliminaries [2.4 Related is the tableau-based appoach see e.g. <ref> [LP85, PZ86] </ref>. In the graph-traversal approach, ' is checked over K in a more direct fashion. For example, the states of K are labelled with subformulae of ' in an iterative fashion, starting with propositions and labelling with longer formulae in every subsequent step.
Reference: [LS91] <editor> K.G. Larsen and A. Skou, editors. </editor> <booktitle> Computer Aided Verification, number 575 in LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference-contexts: A closely related method is the tableau-based approach, see [LP85, PZ86]. Model checking has been quite successful in the verification of finite-state programs like protocols and controllers. Some reports may be found in the Applications sessions of the CAV conferences ([Sif89], [CK90], <ref> [LS91] </ref>, [vBP92], [Cou93], [Dil94], [Wol95]). Model checking a program (in the narrow sense) involves two distinct phases, depicted in Figure 1.1a. First, a given notation 2 P of the program has to be unfolded into a model C this is called (model) construction.
Reference: [LT88] <author> Kim G. Larsen and Bent Thomsen. </author> <title> A modal process logic. </title> <booktitle> In 1988 IEEE Symposium on Logic in Computer Science, pages 203210. </booktitle> <publisher> Computer Society Press, </publisher> <address> Washington, </address> <year> 1988. </year>
Reference-contexts: Application of Abstract Interpretation to verify properties of CCS is described in [DFFGI95]. While developed independently, and from a diVerent perspective, Abstract Krip-ke structures bear some resemblance to the modal transition systems of <ref> [LT88] </ref>, which also combine two types of transition relations (may and must-transitions) in one 30 In [CIY95], a diVerent notation is used for this. 4.9] Related Work 103 system. Modal transition systems have been developed in the area of specification. <p> Modal transition systems have been developed in the area of specification. Must-transitions specify what is required while may-transitions specify what is admissible. In <ref> [LT88] </ref>, a notion of refinement is defined such that the must-transitions in the specification simulate those in the refined system, while the may-transitions in the refined system simulate those in the specification. This is similar to our definition of approximation between Abstract Kripke structures (Definition 4.2.3.7).
Reference: [LV92] <author> B. Le Charlier and P. Van Hentenryck. </author> <title> On the design of generic abstract interpretation frameworks. </title> <editor> In M. Billaud, P. Casteran, M.-M. Corsini, K. Musumbu, and A. Rauzy, editors, </editor> <booktitle> Actes WSA'92 Workshop on Static Analysis (Bordeaux), volume 8182 of Bigre, </booktitle> <institution> Laboratoire Bordelais de Recherche en Informatique, </institution> <month> September </month> <year> 1992. </year>
Reference-contexts: Indeed, Abstract Interpretation, in a narrow sense, is often understood to be the analysis of programs by approximating the (least) solution to a system of recursive equations representing the behaviour of a (repetitive or recursive) program, see for example <ref> [CC92c, Bou92, LV92] </ref>. * The third motivation is closely related to the second one. In computer science applications, the concrete objects are usually semantic models of programs. In most traditional approaches to semantics, models are partially ordered (sometimes for diVerent reasons than the existence of fixpoints).
Reference: [LY92] <author> D. Lee and M. Yannakakis. </author> <title> Online minimization of transition systems. </title> <booktitle> In Proc. ACM Symp. on Theory of Computing, </booktitle> <pages> pages 264274, </pages> <year> 1992. </year>
Reference: [Mal73] <author> A.I. Mal'cev. </author> <title> Algebraic Systems. Number 192 in Die Grundlehren der mathematischen Wissenschaften in Einzeldarstellungen. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1973. </year>
Reference: [Mar93] <author> K. Marriott. </author> <title> Frameworks for abstract interpretation. </title> <journal> Acta Informatica, </journal> <volume> 30(2):103129, </volume> <year> 1993. </year>
Reference-contexts: The approach that we follow in this chapter has been influenced by the (successful) eVorts of Marriott and Sndergaard to give an orderly account of the theory and some of its applications: [MS89b, Sn90], and especially <ref> [Mar93] </ref>. More recently, the Cousots' overview articles [CC92a] and [CC92b] take a similar systematic approach in their presentation. Although many of the results concerning Abstract Interpretation in this chapter are well-known, we do have a number of contributions that are new, to the best of our knowledge. <p> Each solution has its pros and cons, which we will not discuss here. The interested reader is referred to [CC79], <ref> [Mar93] </ref> and [CC92b]. Another point is whether ; should have an ff image. One may claim that this is not necessary because there is no need for a description of it. <p> It implies that the posets .A; / and .C; v/ are isomorphic. The goal of abstraction, to reason on a less complex model, can clearly not be attained in such a setting. Abstraction and concretisation frameworks Following terminology of <ref> [Mar93] </ref>, we refer to the case in which an abstraction function exists as the abstraction framework, and the case in which a concretisation function exists as the concretisation framework. If none exists, we speak of the relational framework. <p> of Abstract Interpretation in the realm of declarative programming languages. 20 Note that for the function g D ff ffi f ffi fl , the equality ff ffi f D g ffi ff does not necessarily hold. 3.5] Concluding Remarks 55 Papers presenting comparative studies of the various frameworks are <ref> [Mar93] </ref> and [CC92b]. In [Mar93], Marriott elaborates a framework that we only sketched superficially in Section 3.3 above. <p> the realm of declarative programming languages. 20 Note that for the function g D ff ffi f ffi fl , the equality ff ffi f D g ffi ff does not necessarily hold. 3.5] Concluding Remarks 55 Papers presenting comparative studies of the various frameworks are <ref> [Mar93] </ref> and [CC92b]. In [Mar93], Marriott elaborates a framework that we only sketched superficially in Section 3.3 above. <p> On the other hand, Abstract Interpretation is a relatively young activity that was developed as a unifying theory for a variety of pre-existing applications, and a more fundamental study of the underlying choices seems to be justified (see e.g. <ref> [Mar93, CC92a, CC92b] </ref>). We think that Section 3.2.1 of this thesis oVers an answer to the question why Galois connections are so intimately related to Abstract Interpretation. The subsection on the power construction (page 44) should also be viewed in this light.
Reference: [Mat94] <institution> Mathematics of Program Construction Group. </institution> <type> Fixed-point calculus. Technical Report 9448, </type> <institution> Eindhoven University of Technology, Dept. of Computing Science, </institution> <month> October </month> <year> 1994. </year>
Reference-contexts: The following result specifies a condition on ff f in order for 3.16 to hold. It appears in many of the papers by the Cousots and is sometimes referred to as the fundamental theorem 18 . The elegant proof included below is reproduced from <ref> [Mat94] </ref>, where the fundamental theorem is called -fusion. 3.3.1.1 Lemma Let .C; v/ be a cpo and f : C ! C a monotonic function. <p> f // lfp. ff f / 2 Note that similar to the third through fifth steps in this proof, it can be shown that also ff ffi f - ff f ffi ff implies ff.lfp. f // - lfp. ff f /; this result is called simple - fusion in <ref> [Mat94] </ref>. A function ff f for which 3.17 holds is said to be safe for f , or a safe approximation of f . Indeed, the description relation may be lifted to the function spaces over C and A, e.g. by defining . f; ff f / as 3.17.
Reference: [McM93] <author> Kenneth L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Dordrecht, The Netherlands, </address> <year> 1993. </year>
Reference-contexts: This is a tree-like structure that is used to, often compactly, represent a set of bitstrings; BDDs have gained popularity in the field of verification lately see e.g. <ref> [DJS95, McM93] </ref>. That this approach may lead to spectacular results is evidenced by papers like [BCM C 92, MS92b, CGH C 93]. Although symbolic model checking has actually found its way into industry on an extensive scale, it is not a panacea.
Reference: [Mer90] <author> N. MercouroV. </author> <title> Analyse s emantique des communications entre processus de programmes parall eles. </title> <type> PhD thesis, </type> <institution> Ecole Polytechnique, Laboratoire d'Informatique, Palaiseau, France, </institution> <month> September </month> <year> 1990. </year>
Reference-contexts: Such a symmetry is needed for example when abstractions are to be composed, allowing for a stepwise design of an analysis. Examples of such composed abstractions may be found in <ref> [Mer90] </ref>, [CDY91] and also in Section 4.8.1 in this thesis. In general, several orderings on the concrete objects may be introduced, one for each of these reasons.
Reference: [Mil71] <author> R. Milner. </author> <title> An algebraic definition of simulation between programs. </title> <booktitle> In Second International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 481489. </pages> <publisher> British Computer Society, </publisher> <address> London, </address> <year> 1971. </year>
Reference-contexts: From this point of view, the termi nology s simulates t, introduced in <ref> [Mil71] </ref>, is awkward. 2.4] Transition Systems 27 Proof Define the function F : P.6 1 fi 6 2 / ! P.6 1 fi 6 2 / by F . / D f.s; t/ 2 j 8 s 0 26 1 [R 1 .s; s 0 / ) 9 t 0 26 <p> In <ref> [Mil71] </ref>, Milner introduced the term simulation to denote a homomorphism between deterministic systems. <p> In computer science, bisimulation is usually attributed to Park, who introduced the term in [Par81], in the context of automata. Milner introduced the notion of simulation in <ref> [Mil71] </ref> and observational equivalence in [Mil80]. Branching bisim-ulation has been proposed as an alternative to observational equivalence in, among others, [GW89, vG90a, vG93a, vG93b]. A large variety of behavioural equivalences has been defined and studied over the past ten years; see [DN87] for a discussion.
Reference: [Mil80] <author> R. Milner. </author> <title> A Calculus of Communicating Systems. </title> <booktitle> Number 92 in LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1980. </year>
Reference-contexts: Several observational or weak equivalences have been proposed to more faithfully capture the notion of equivalence in the presence of silent moves: observational equivalence in the sense of [HM85], observation equivalence (called t -bisimulation equivalence in [BK85]) of <ref> [Mil80] </ref>, -bisimulation of [BG87], delay bisimulation of [Mil83], and branching bisimulation of [GW89]. In [vG93b], van Glabbeek convincingly argues that, in a sense, branching bisimulation equivalence (branching equivalence for short) is the coarsest equivalence that respects the branching structure of a process with silent moves. <p> In computer science, bisimulation is usually attributed to Park, who introduced the term in [Par81], in the context of automata. Milner introduced the notion of simulation in [Mil71] and observational equivalence in <ref> [Mil80] </ref>. Branching bisim-ulation has been proposed as an alternative to observational equivalence in, among others, [GW89, vG90a, vG93a, vG93b]. A large variety of behavioural equivalences has been defined and studied over the past ten years; see [DN87] for a discussion. Also [BK90] contains a lot of material on this topic.
Reference: [Mil83] <author> Robin Milner. </author> <title> Calculi for synchrony and asynchrony. </title> <journal> Journal of Theoretical Computer Science, </journal> <note> 25:267310, 1983. Bibliography 205 </note>
Reference-contexts: Several observational or weak equivalences have been proposed to more faithfully capture the notion of equivalence in the presence of silent moves: observational equivalence in the sense of [HM85], observation equivalence (called t -bisimulation equivalence in [BK85]) of [Mil80], -bisimulation of [BG87], delay bisimulation of <ref> [Mil83] </ref>, and branching bisimulation of [GW89]. In [vG93b], van Glabbeek convincingly argues that, in a sense, branching bisimulation equivalence (branching equivalence for short) is the coarsest equivalence that respects the branching structure of a process with silent moves. <p> The distinguishing power of flat CTL.U/ is characterised by the equivalence flat . This equivalence is similar to that of delay bisimulation introduced in <ref> [Mil83] </ref>. The only diVerence is that the latter is defined over edge-labelled transition systems.
Reference: [MJ81] <editor> Steven S. Muchnick and Neil D. Jones, editors. </editor> <title> Program Flow Analysis: Theory and Applications. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood CliVs, NJ, </address> <year> 1981. </year>
Reference-contexts: should clearly be avoided; hence a criterion for reasoning about the quality of abstractions is introduced. 3.4 Related Work For an overview of various examples of, and approaches to, program analysis before the conception of the unifying framework of Abstract Interpretation the reader is referred to the bibliographies in [CC77], <ref> [MJ81] </ref>, [AH87] and [AU77]. A more recent overview article is [JN95]. The idea of viewing a program analysis as an approximate computation operating on descriptions of data appears in computer science as early as 1963 in the work of Naur ([Nau63]).
Reference: [MJ86] <author> A. Mycroft and N. Jones. </author> <title> A relational framework for abstract interpretation. In Programs as data objects, </title> <booktitle> number 154 in LNCS, </booktitle> <pages> pages 536547. </pages> <publisher> Springer, </publisher> <year> 1986. </year>
Reference-contexts: Adaptations of the original Galois-connection framework in the realm of various programming paradigms are: [BHA86, Nie88] in the context of functional programs, which drop the requirement of best concretisations; [MS89a, MS92a] in the context of logic programs, which drop the requirement of best descriptions; and <ref> [MJ86] </ref> in the context of non-recursive programs, which drops both the requirements of best concretisations and best descriptions.
Reference: [MP92] <author> Zohar Manna and Amir Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems: Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: A more extensive overview and comparison can be found in Section 4.9. 1.4.2 Program verification For proof-based methods, introductions as well as bibliographies may be found in [AO91], [Fra92] or <ref> [MP92, MP95] </ref> for example. The latter books are also recommended for an overview of temporal logic. Model checking was introduced independently in [QS82] and [CE81]. It has led to a large stream of both practically and theoretically oriented articles.
Reference: [MP95] <author> Zohar Manna and Amir Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems: Verification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1995. </year>
Reference-contexts: A more extensive overview and comparison can be found in Section 4.9. 1.4.2 Program verification For proof-based methods, introductions as well as bibliographies may be found in [AO91], [Fra92] or <ref> [MP92, MP95] </ref> for example. The latter books are also recommended for an overview of temporal logic. Model checking was introduced independently in [QS82] and [CE81]. It has led to a large stream of both practically and theoretically oriented articles.
Reference: [MS89a] <author> K. Marriott and H. Sndergaard. </author> <title> Semantics-based dataflow analysis of logic programs. </title> <editor> In G. X. Ritter, editor, </editor> <booktitle> Information Processing 89, </booktitle> <pages> pages 601606. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1989. </year>
Reference-contexts: This is illustrated by a unified analysis that captures many analyses used in the field of functional languages. Adaptations of the original Galois-connection framework in the realm of various programming paradigms are: [BHA86, Nie88] in the context of functional programs, which drop the requirement of best concretisations; <ref> [MS89a, MS92a] </ref> in the context of logic programs, which drop the requirement of best descriptions; and [MJ86] in the context of non-recursive programs, which drops both the requirements of best concretisations and best descriptions.
Reference: [MS89b] <author> K. Marriott and H. Sndergaard. </author> <title> A tutorial on abstract interpretation of logic programs. </title> <booktitle> Notes distributed at the North American Conference on Logic Programming, </booktitle> <year> 1989. </year>
Reference-contexts: The approach that we follow in this chapter has been influenced by the (successful) eVorts of Marriott and Sndergaard to give an orderly account of the theory and some of its applications: <ref> [MS89b, Sn90] </ref>, and especially [Mar93]. More recently, the Cousots' overview articles [CC92a] and [CC92b] take a similar systematic approach in their presentation.
Reference: [MS92a] <author> K. Marriott and H. Sndergaard. </author> <title> Bottom-up dataflow analysis of normal logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 13:181204, </volume> <year> 1992. </year>
Reference-contexts: This is illustrated by a unified analysis that captures many analyses used in the field of functional languages. Adaptations of the original Galois-connection framework in the realm of various programming paradigms are: [BHA86, Nie88] in the context of functional programs, which drop the requirement of best concretisations; <ref> [MS89a, MS92a] </ref> in the context of logic programs, which drop the requirement of best descriptions; and [MJ86] in the context of non-recursive programs, which drops both the requirements of best concretisations and best descriptions.
Reference: [MS92b] <author> K. L. McMillan and J. Schwalbe. </author> <title> Formal verification of the Gigamax cache consistency protocol. </title> <editor> In N. Suzuki, editor, </editor> <booktitle> Shared Memory Multiprocessing. </booktitle> <publisher> The MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: This is a tree-like structure that is used to, often compactly, represent a set of bitstrings; BDDs have gained popularity in the field of verification lately see e.g. [DJS95, McM93]. That this approach may lead to spectacular results is evidenced by papers like <ref> [BCM C 92, MS92b, CGH C 93] </ref>. Although symbolic model checking has actually found its way into industry on an extensive scale, it is not a panacea.
Reference: [MSS86] <author> A.C. Melton, D.A. Schmidt, and D.E. Strecker. </author> <title> Galois connections and computer science applications. </title> <editor> In David Pitt, Samson Abramsky, Axel Poigne, and David Rydeheard, editors, </editor> <booktitle> Category Theory and Computer Programming, number 240 in LNCS, </booktitle> <pages> pages 299312. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1986. </year>
Reference-contexts: Galois connections have many properties, of which we mention a few. The interested reader is referred to <ref> [Ore44, Pic52, MSS86, CC92a, ABH C 92] </ref>. <p> Thus, the abstract domain may be normalised to ff.fl .A//. This is called reduction in [CC92a]. In [Ore44], such a Galois connection is called perfect in A, [CC92a] calls it a Galois surjection and <ref> [MSS86] </ref> a Galois insertion from A to C. 3.2.1.10 Lemma (Theorem 5.3.0.6 in [CC79 ]) Let .ff; fl / be a Galois connec tion from .C; v/ to .A; /.
Reference: [Nau63] <author> P. Naur. </author> <title> The design of the Gier Algol compiler, part II. </title> <journal> BIT, </journal> <volume> 3:145 166, </volume> <year> 1963. </year>
Reference: [NC94] <author> Mogens Nielsen and Christian Clausen. </author> <title> Bisimulation, games, and logic. </title> <editor> In J. Karhumaki, H. Maurer, and G. Rozenberg, editors, </editor> <booktitle> Results and Trends in Theoretical Computer Science, number 812 in LNCS, </booktitle> <pages> pages 289306. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1994. </year>
Reference-contexts: For the case of CTL fl .U//stut 180 Logics, Equivalences and Behavioural Partition Refinement [6.8 tering equivalence, partition refinement algorithms can be found in [BCG88, GV90]. The reader who is interested in game characterisations of equivalences could have a look at <ref> [Ehr61, Fra54, IK87, Tho93, NC94] </ref>. 6.8 Concluding Remarks We have investiged the correspondences between a number of temporal logics and behavioural equivalences, and also between behavioural equivalences and partition refinement algorithms.
Reference: [Nie82] <author> F. Nielson. </author> <title> A denotational framework for data flow analysis. </title> <journal> Acta Infor-matica, </journal> <note> 18:265287, 1982. 206 Bibliography </note>
Reference-contexts: General conditions are investigated that ensure that fl is consistent with the interpretations I and I 0 . The advantage of this metalanguage approach is that correctness is guaranteed of any abstract semantics defined in M. The idea of using a metalanguage was advocated by Nielson in <ref> [Nie82, Nie88] </ref>. 3.5 Concluding Remarks This chapter has given an overview of abstraction theories. To start with, we have identified two major concerns of such theories. One is how to relate objects to descriptions, and the consequences of this for the preservation of properties.
Reference: [Nie88] <author> F. Nielson. </author> <title> Strictness analysis and denotational abstract interpretation. Information and Computation, </title> <address> 76(1):2992, </address> <year> 1988. </year>
Reference-contexts: This is illustrated by a unified analysis that captures many analyses used in the field of functional languages. Adaptations of the original Galois-connection framework in the realm of various programming paradigms are: <ref> [BHA86, Nie88] </ref> in the context of functional programs, which drop the requirement of best concretisations; [MS89a, MS92a] in the context of logic programs, which drop the requirement of best descriptions; and [MJ86] in the context of non-recursive programs, which drops both the requirements of best concretisations and best descriptions. <p> General conditions are investigated that ensure that fl is consistent with the interpretations I and I 0 . The advantage of this metalanguage approach is that correctness is guaranteed of any abstract semantics defined in M. The idea of using a metalanguage was advocated by Nielson in <ref> [Nie82, Nie88] </ref>. 3.5 Concluding Remarks This chapter has given an overview of abstraction theories. To start with, we have identified two major concerns of such theories. One is how to relate objects to descriptions, and the consequences of this for the preservation of properties.
Reference: [Ore44] <author> O. </author> <title> Ore. Galois connexions. </title> <journal> Transactions of the American Mathematical Society, </journal> <volume> 55:493513, </volume> <year> 1944. </year>
Reference-contexts: Galois connections have many properties, of which we mention a few. The interested reader is referred to <ref> [Ore44, Pic52, MSS86, CC92a, ABH C 92] </ref>. <p> set fy j x v g.y/g has a glb for every x 2 P; 6 The investigations reported in [LNS82] suggest that this lemma is a folk theorem in the sense of [Har80]. 7 In fact, Galois connections as defined here are semi-dual with respect to the original definition of <ref> [Ore44] </ref>: the definition given there requires f and g to be antitone ( f is antitone if x v y ) f .x/ - f .y/) and both f ffi g and g ffi f to be extensive. <p> Another motivation is based on the observation that descriptions a may always safely be replaced by ff.fl .a//, which yields the same or a better description. Thus, the abstract domain may be normalised to ff.fl .A//. This is called reduction in [CC92a]. In <ref> [Ore44] </ref>, such a Galois connection is called perfect in A, [CC92a] calls it a Galois surjection and [MSS86] a Galois insertion from A to C. 3.2.1.10 Lemma (Theorem 5.3.0.6 in [CC79 ]) Let .ff; fl / be a Galois connec tion from .C; v/ to .A; /.
Reference: [Par81] <author> D. Park. </author> <title> Concurrency and automata on infinite sequences. </title> <editor> In Peter Deussen, editor, </editor> <booktitle> Theoretical Computer Science, number 104 in LNCS, </booktitle> <pages> pages 167183. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: In computer science, bisimulation is usually attributed to Park, who introduced the term in <ref> [Par81] </ref>, in the context of automata. Milner introduced the notion of simulation in [Mil71] and observational equivalence in [Mil80]. Branching bisim-ulation has been proposed as an alternative to observational equivalence in, among others, [GW89, vG90a, vG93a, vG93b].
Reference: [Pic52] <editor> G. Pickert. Bemerkungen uber Galois-Verbindungen. Archiv der Math-ematik, 3:285289, </editor> <year> 1952. </year>
Reference-contexts: Galois connections have many properties, of which we mention a few. The interested reader is referred to <ref> [Ore44, Pic52, MSS86, CC92a, ABH C 92] </ref>.
Reference: [PL90] <author> David K. Probst and Hon F. Li. </author> <title> Using partial-order semantics to avoid the state explosion problem in asynchronous systems. </title> <booktitle> In Clarke and Kurshan [CK90], </booktitle> <pages> pages 146155. </pages>
Reference: [Pla84] <author> David A. Plaisted. </author> <title> The occur-check problem in Prolog. </title> <booktitle> In 1984 International Symposium On Logic Programming, </booktitle> <pages> pages 272280. </pages> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1984. </year>
Reference-contexts: The ideas described there are inspired by similar notions of tunable abstractions in the field of logic programming, see for example <ref> [Pla84] </ref>. A novel aspect is the incremental computation of abstract functions. In Chapters 5 and 6, a diVerent paradigm to construct strongly preserving abstractions is considered: partition refinement algorithms. This approach may be viewed as a process of stepwise refinement of an Abstract Kripke structure.
Reference: [Pnu77] <author> Amir Pnueli. </author> <title> The temporal logic of programs. </title> <booktitle> In 18th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 4657. </pages> <year> 1977. </year>
Reference-contexts: In particular, we want to be able to express typical properties of reactive systems also called reactive properties. To this purpose, we use temporal logic. Examples are LTL (linear temporal logic, see <ref> [Pnu77] </ref>), CTL (computation tree logic, see [CES86]), CTL fl ([EH86, EL87]), HML (Henessy-Milner Logic, see [HM85]) and L (the -calculus, see [Koz83]).
Reference: [Pnu86] <author> A. Pnueli. </author> <title> Linear and branching structures in the semantics and logics of reactive systems. </title> <booktitle> In Proc. of the Twelfth International Colloquium on Automata Languages and Programming (ICALP), number 194 in LNCS, </booktitle> <pages> pages 1532. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1986. </year>
Reference-contexts: See the section on related work towards the end of this chapter for an 1 Indeed, this is a refinement of Definition 3.2.2.1, specialised for the case that is an equivalence relation. 2 In <ref> [Pnu86] </ref>, this is (conversely) called adequacy of the logic with respect to the equivalence we also sometimes do this. <p> The only diVerence is that the latter is defined over edge-labelled transition systems. So, when flat CTL.U/ is reinterpreted over such transition systems (for details of the diVerence between the state and action-based approaches see [DNV90a]), its 15 <ref> [Pnu86] </ref>, which defines a number of compatibility types between logics and equivalences, calls this expressivity. 6.8] Concluding Remarks 181 induced equivalence will probably coincide with delay equivalence. To the best of our knowledge, no modal characterisation of this equivalence has been given before.
Reference: [PT87] <author> Robert Paige and Robert E. Tarjan. </author> <title> Three partition refinement algorithms. </title> <journal> SIAM Journal of Computation, </journal> <volume> 16(6):973989, </volume> <year> 1987. </year>
Reference-contexts: Partition refinement algorithms that divide out the equivalence classes of some behavioural equivalence by successive refinement of the blocks of a partition have been presented for bisimu-lation (e.g. in <ref> [PT87, BFH C 92] </ref>) and stuttering (or branching) equivalence (e.g. in [BCG88, GV90]). These equivalences both correspond to logics that are closed under negation, namely CTL fl and CTL fl .U/ (also see the next chapter). <p> For simulation equivalence, the only previous decision algorithm that we know of is [CC95], which does not fit the partition refinement scheme. More recently, [HHK95] presents an algorithm that indeed uses ideas from <ref> [PT87] </ref>. In general, the behavioural equivalence corresponding to a property set that is an arbitrary subset of a temporal logic will not have a nice regular form like bisimula-tion, simulation equivalence or stuttering equivalence. <p> Partition refinement algorithms originate in automata theory. Algorithms for minimisation of automata (see [Hop71]) form a precursor; optimisations and adaptations have been presented in <ref> [PT87, KS90, BFH C 92] </ref>. For the case of CTL fl .U//stut 180 Logics, Equivalences and Behavioural Partition Refinement [6.8 tering equivalence, partition refinement algorithms can be found in [BCG88, GV90].
Reference: [PZ86] <author> Amir Pnueli and Lenore Zuck. </author> <title> Probabilistic verification by tableaux. </title> <booktitle> In LICS86 [LIC86], </booktitle> <pages> pages 322331. </pages>
Reference-contexts: An alternative approach, often called model checking as well, based on inclusion between automata over infinite words, was developed by Vardi and Wolper ([VW86]) and by Kurshan ([Kur90], also see [Kur94]). A closely related method is the tableau-based approach, see <ref> [LP85, PZ86] </ref>. Model checking has been quite successful in the verification of finite-state programs like protocols and controllers. Some reports may be found in the Applications sessions of the CAV conferences ([Sif89], [CK90], [LS91], [vBP92], [Cou93], [Dil94], [Wol95]). <p> This automaton is then multiplied with the transition system K. The resulting automaton accepts the behaviours in the intersection of K and :'. Thus, if (and only if ) this intersection is empty, K jD ' holds. See e.g. [VW86, Kur94]. 28 Preliminaries <ref> [2.4 Related is the tableau-based appoach see e.g. [LP85, PZ86] </ref>. In the graph-traversal approach, ' is checked over K in a more direct fashion. <p> The resulting automaton accepts the behaviours in the intersection of K and :'. Thus, if (and only if ) this intersection is empty, K jD ' holds. See e.g. [VW86, Kur94]. 28 Preliminaries [2.4 Related is the tableau-based appoach see e.g. <ref> [LP85, PZ86] </ref>. In the graph-traversal approach, ' is checked over K in a more direct fashion. For example, the states of K are labelled with subformulae of ' in an iterative fashion, starting with propositions and labelling with longer formulae in every subsequent step.
Reference: [QS82] <author> J. P. Queille and J. Sifakis. </author> <title> Specification and verification of concurrent systems in CESAR. </title> <editor> In M. Dezani-Ciancaglini and U. Montanari, editors, </editor> <booktitle> International Symposium on Programming, number 137 in LNCS, </booktitle> <pages> pages 337351. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1982. </year>
Reference-contexts: One assumption is that model checking is used to establish the validity of properties over programs; this is an a-posteriori, model-based, automatic method for property verification and was introduced by Queille and Sifakis in <ref> [QS82] </ref> and independently by Clarke and Emerson in [CE81]. An alternative approach, often called model checking as well, based on inclusion between automata over infinite words, was developed by Vardi and Wolper ([VW86]) and by Kurshan ([Kur90], also see [Kur94]). <p> The latter books are also recommended for an overview of temporal logic. Model checking was introduced independently in <ref> [QS82] </ref> and [CE81]. It has led to a large stream of both practically and theoretically oriented articles. Recently, much research has concentrated on tackling the state-explosion problem, see the two subsections below. <p> For example, the states of K are labelled with subformulae of ' in an iterative fashion, starting with propositions and labelling with longer formulae in every subsequent step. Such an algorithm is presented in [CES86]. Another approach is presented in <ref> [QS82] </ref>, in which a fix-point algorithm is used to compute sets of states satisfying the subformulae of '. It relies on the availability of the pre-image function pre R (Definition 2.1.0.1) of the transition relation R, which may be viewed as an implicit or symbolic representation of the transition system.
Reference: [Sch86] <author> D. A. Schmidt. </author> <title> Denotational Semantics: A Methodology for language Development. </title> <publisher> Allyn & Bacon, </publisher> <address> Newton, MA, </address> <year> 1986. </year> <note> Bibliography 207 </note>
Reference: [Sco82] <author> Dana S. Scott. </author> <title> Domains for denotational semantics. </title> <editor> In M. Nielsen and E. M. Schmidt, editors, </editor> <booktitle> Automata, Languages and Programming, number 140 in LNCS, </booktitle> <pages> pages 577613. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1982. </year>
Reference: [Sif82] <author> J. Sifakis. </author> <title> Property preserving homomorphisms and a notion of simulation for transition systems. </title> <institution> Rapport de Recherche 332, Laboratoire d'Informatique et de Mathematiques Appliqees de Grenoble, </institution> <month> November </month> <year> 1982. </year>
Reference-contexts: Our approach treats data and control in a uniform way and hence has a more general applicability. Other general frameworks for abstraction in the context of model checking, besides those already mentioned above, are presented in <ref> [Sif82, Sif83] </ref> (containing much pioneering research), [Kur90] (homomorphic reductions), [Bur92] (in the context of trace theory, mainly in a real-time setting) and [Lon93] (combined with compositional techniques). <p> In [Mil71], Milner introduced the term simulation to denote a homomorphism between deterministic systems. Since then, it has been re-adapted to nondeterministic transition systems and has become popular in the areas of program refinement and verification; <ref> [Sif82] </ref>, [Sif83] and [HM80] are some early papers on this topic. [Dil89] and [Kur90] focus on trace (linear time) semantics and universal safety and liveness properties. Some of the first papers that consider the (strong) preservation of full CTL fl and L are [CGL92] and [BBLS92].
Reference: [Sif83] <author> J. Sifakis. </author> <title> Property preserving homomorphisms of transition systems. </title> <editor> In Edmund Clarke and Dexter Kozen, editors, </editor> <booktitle> 4th Workshop on Logics of Programs, number 164 in LNCS, </booktitle> <pages> pages 458473. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1983. </year>
Reference-contexts: Our approach treats data and control in a uniform way and hence has a more general applicability. Other general frameworks for abstraction in the context of model checking, besides those already mentioned above, are presented in <ref> [Sif82, Sif83] </ref> (containing much pioneering research), [Kur90] (homomorphic reductions), [Bur92] (in the context of trace theory, mainly in a real-time setting) and [Lon93] (combined with compositional techniques). <p> In [Mil71], Milner introduced the term simulation to denote a homomorphism between deterministic systems. Since then, it has been re-adapted to nondeterministic transition systems and has become popular in the areas of program refinement and verification; [Sif82], <ref> [Sif83] </ref> and [HM80] are some early papers on this topic. [Dil89] and [Kur90] focus on trace (linear time) semantics and universal safety and liveness properties. Some of the first papers that consider the (strong) preservation of full CTL fl and L are [CGL92] and [BBLS92].
Reference: [Sif89] <author> J. Sifakis, </author> <title> editor. Automatic Verification Methods for Finite State Systems (CAV89), </title> <booktitle> number 407 in LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1989. </year>
Reference: [Sin72] <author> M. SintzoV. </author> <title> Calculating properties of programs by valuation on specific models. </title> <journal> SIGPLAN Notices, </journal> <volume> 7(1):203207, </volume> <booktitle> 1972. (Proc. ACM Conf. Proving Assertions about Programs.) </booktitle>
Reference-contexts: A more recent overview article is [JN95]. The idea of viewing a program analysis as an approximate computation operating on descriptions of data appears in computer science as early as 1963 in the work of Naur ([Nau63]). Another early example of the idea is given in <ref> [Sin72] </ref>. The Cousots are the first to relate standard to non-standard semantics by a Galois insertion [CC77].
Reference: [Sn90] <author> H. Sndergaard. </author> <title> Semantic based analysis and transformation of logic programs. </title> <type> Technical Report 12, </type> <institution> The University of Melbourne, </institution> <month> June </month> <year> 1990. </year> <note> Revised version of PhD thesis submitted to the University of Copenhagen, </note> <month> December, </month> <year> 1989. </year>
Reference-contexts: The approach that we follow in this chapter has been influenced by the (successful) eVorts of Marriott and Sndergaard to give an orderly account of the theory and some of its applications: <ref> [MS89b, Sn90] </ref>, and especially [Mar93]. More recently, the Cousots' overview articles [CC92a] and [CC92b] take a similar systematic approach in their presentation.
Reference: [Sti89] <author> Colin Stirling. </author> <title> Comparing linear and branching time temporal logics. </title> <editor> In B. Banieqbal, H. Barringer, and A. Pnueli, editors, </editor> <booktitle> Temporal Logic in Specification, number 398 in LNCS, </booktitle> <pages> pages 120. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1989. </year>
Reference: [Sti92] <author> C. Stirling. </author> <title> Modal and temporal logics. </title> <editor> In S. Abramsky, Dov M. Gab-bay, and T. S. E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science. Background: Computational Structures, </booktitle> <volume> volume 2, </volume> <pages> pages 477563. </pages> <publisher> Oxford University Press, Oxford, </publisher> <year> 1992. </year>
Reference-contexts: Although this thesis is about techniques that aim to extend of the applicability of model checking, the particular model-checking approach that is chosen and the details of the algorithms are immaterial. The interested reader is referred to the articles mentioned above. Furthermore, a number of overviews have recently appeared: <ref> [Eme90, Sti92, CGL93, Kur94] </ref>. Chapter 3 Abstraction and Preservation Besides introducing abstraction and Abstract Interpretation, this chapter presents a systematic reconstruction of several frameworks for abstraction that occur in the literature. We formalise the notion of property preservation, and investigate how weak and strong preservation lead to diVerent frameworks.
Reference: [Sto77] <author> J.E. Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1977. </year>
Reference: [Tar55] <author> A. Tarski. </author> <title> A lattice theoretical fixpoint theorem and its applications. </title> <journal> Pacific journal of Mathematics, </journal> <note> 5:285309, 1955. 208 Bibliography </note>
Reference-contexts: In order for fixpoints to exist, it suYces if C and A are complete partial orders and the functions are monotonic <ref> [Tar55] </ref>.
Reference: [Tho93] <editor> Wolfgang Thomas. </editor> <booktitle> On the Ehrenfeucht-Fra sse game in theoretical computer science. </booktitle> <editor> In M. et al. Gaudel, editor, </editor> <booktitle> TAPSOFT, number 668 in LNCS, </booktitle> <pages> pages 559568. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1993. </year>
Reference-contexts: For the case of CTL fl .U//stut 180 Logics, Equivalences and Behavioural Partition Refinement [6.8 tering equivalence, partition refinement algorithms can be found in [BCG88, GV90]. The reader who is interested in game characterisations of equivalences could have a look at <ref> [Ehr61, Fra54, IK87, Tho93, NC94] </ref>. 6.8 Concluding Remarks We have investiged the correspondences between a number of temporal logics and behavioural equivalences, and also between behavioural equivalences and partition refinement algorithms.
Reference: [Val90] <author> Antti Valmari. </author> <title> A stubborn attack on state explosion. </title> <booktitle> In Clarke and Kurshan [CK90], </booktitle> <pages> pages 156165. </pages>
Reference: [vBP92] <editor> G. von Bochmann and D.K. Probst, editors. </editor> <booktitle> Computer-Aided Verification, number 663 in LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: A closely related method is the tableau-based approach, see [LP85, PZ86]. Model checking has been quite successful in the verification of finite-state programs like protocols and controllers. Some reports may be found in the Applications sessions of the CAV conferences ([Sif89], [CK90], [LS91], <ref> [vBP92] </ref>, [Cou93], [Dil94], [Wol95]). Model checking a program (in the narrow sense) involves two distinct phases, depicted in Figure 1.1a. First, a given notation 2 P of the program has to be unfolded into a model C this is called (model) construction.
Reference: [vBvES94] <editor> Johan van Benthem, Jan van Eijck, and Vera Stebletsova. </editor> <title> Modal logic, transition systems and processes. </title> <journal> Journal of Logic and Computation, </journal> <volume> 4(5):811855, </volume> <year> 1994. </year>
Reference: [vG90a] <author> R.J. van Glabbeek. </author> <title> Comparative Concurrency Semantics and Refinement of Actions. </title> <type> PhD thesis, </type> <institution> Free University of Amsterdam/Center for Math. and Comp. </institution> <address> Sc., </address> <year> 1990. </year>
Reference-contexts: In computer science, bisimulation is usually attributed to Park, who introduced the term in [Par81], in the context of automata. Milner introduced the notion of simulation in [Mil71] and observational equivalence in [Mil80]. Branching bisim-ulation has been proposed as an alternative to observational equivalence in, among others, <ref> [GW89, vG90a, vG93a, vG93b] </ref>. A large variety of behavioural equivalences has been defined and studied over the past ten years; see [DN87] for a discussion. Also [BK90] contains a lot of material on this topic.
Reference: [vG90b] <author> R.J. van Glabbeek. </author> <title> The linear time branching time spectrum. </title> <booktitle> In Baeten and Klop [BK90], </booktitle> <pages> pages 278297. </pages>
Reference-contexts: A related development is the research on comparative concurrency semantics <ref> [vG90b] </ref> in the context of process algebras with silent moves ([vG93a]).
Reference: [vG93a] <author> R.J. van Glabbeek. </author> <title> The linear time branching time spectrum II. the semantics of sequential systems with silent moves. </title> <note> Preliminary version available from boole.stanford.edu, 1993. Extended abstract in Proc. CONCUR 93, LNCS 715, pp. 6681. Springer-Verlag, Berlin, </note> <year> 1993. </year>
Reference-contexts: In computer science, bisimulation is usually attributed to Park, who introduced the term in [Par81], in the context of automata. Milner introduced the notion of simulation in [Mil71] and observational equivalence in [Mil80]. Branching bisim-ulation has been proposed as an alternative to observational equivalence in, among others, <ref> [GW89, vG90a, vG93a, vG93b] </ref>. A large variety of behavioural equivalences has been defined and studied over the past ten years; see [DN87] for a discussion. Also [BK90] contains a lot of material on this topic.
Reference: [vG93b] <author> R.J. van Glabbeek. </author> <title> What is branching time semantics and why to use it? Technical Report STAN-CS-93-1486, </title> <institution> Stanford University, Dept. of Comp. </institution> <address> Sc., CA 94305, </address> <year> 1993. </year> <note> Also appeared in The Concurrency Column (M. Nielsen, ed.), Bulletin of the EATCS 53, </note> <month> June </month> <year> 1994, </year> <pages> pp. </pages> <year> 190198. </year>
Reference-contexts: In <ref> [vG93b] </ref>, van Glabbeek convincingly argues that, in a sense, branching bisimulation equivalence (branching equivalence for short) is the coarsest equivalence that respects the branching structure of a process with silent moves. <p> Adding back the Next operator to CTL fl .U/ results in a logic whose induced equivalence is finer than branching equivalence and thus too fine according to <ref> [vG93b] </ref>. So, the development from (strong) bisimulation to branching bisimulation as the proper notion of equivalence in the world of comparative concurrency semantics, is the parallel of the shift of attention from CTL fl to CTL fl .U/ in the world of specification logics. <p> In computer science, bisimulation is usually attributed to Park, who introduced the term in [Par81], in the context of automata. Milner introduced the notion of simulation in [Mil71] and observational equivalence in [Mil80]. Branching bisim-ulation has been proposed as an alternative to observational equivalence in, among others, <ref> [GW89, vG90a, vG93a, vG93b] </ref>. A large variety of behavioural equivalences has been defined and studied over the past ten years; see [DN87] for a discussion. Also [BK90] contains a lot of material on this topic.
Reference: [VW86] <author> Moshe Y. Vardi and Pierre Wolper. </author> <title> An automata-theoretic approach to automatic program verification (preliminary report). </title> <booktitle> In LICS86 [LIC86], </booktitle> <pages> pages 332344. </pages>
Reference-contexts: This automaton is then multiplied with the transition system K. The resulting automaton accepts the behaviours in the intersection of K and :'. Thus, if (and only if ) this intersection is empty, K jD ' holds. See e.g. <ref> [VW86, Kur94] </ref>. 28 Preliminaries [2.4 Related is the tableau-based appoach see e.g. [LP85, PZ86]. In the graph-traversal approach, ' is checked over K in a more direct fashion.
Reference: [Wol86] <author> P. Wolper. </author> <title> Expressing interesting properties of programs in propositional temporal logic. </title> <booktitle> In Proc. 13th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 184193. </pages> <year> 1986. </year>
Reference-contexts: Clearly, this is only possible if the program is data-independent, i.e. the data values do not aVect the course of the computation. An example is a simple protocol whose only task is to transport messages from sender to receiver, without performing any error checking etc. <ref> [Wol86] </ref> describes such abstractions. Our approach treats data and control in a uniform way and hence has a more general applicability.
Reference: [Wol95] <author> Pierre Wolper, </author> <title> editor. </title> <booktitle> Computer Aided Verification, number 939 in LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1995. </year> <note> Bibliography 209 </note>
Reference-contexts: A closely related method is the tableau-based approach, see [LP85, PZ86]. Model checking has been quite successful in the verification of finite-state programs like protocols and controllers. Some reports may be found in the Applications sessions of the CAV conferences ([Sif89], [CK90], [LS91], [vBP92], [Cou93], [Dil94], <ref> [Wol95] </ref>). Model checking a program (in the narrow sense) involves two distinct phases, depicted in Figure 1.1a. First, a given notation 2 P of the program has to be unfolded into a model C this is called (model) construction. This is formalised by a mapping I called interpretation.

References-found: 190

