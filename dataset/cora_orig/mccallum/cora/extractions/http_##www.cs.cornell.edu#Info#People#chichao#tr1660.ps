URL: http://www.cs.cornell.edu/Info/People/chichao/tr1660.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/chichao/papers.htm
Root-URL: http://www.cs.brown.edu/
Title: Implementing Multiple Protection Domains in Java  
Author: Chris Hawblitzel, ChiChao Chang, Grzegorz Czajkowski, Deyu Hu, and Thorsten von Eicken 
Affiliation: Department of Computer Science Cornell University  
Pubnum: Technical Report 97-1660  
Abstract: Safe language technology can be used for protection within a single address space. This protection is enforced by the languages type system, which ensures that references to objects cannot be forged. A safe language alone, however, lacks many features taken for granted in more traditional operating systems, such as rights revocation, thread protection, resource management, and support for domain termination. This paper describes the J-Kernel, a portable Java-based protection system that addresses these issues. A number of microbenchmarks are presented to characterize the costs of language-based protection, and an extensible web server based on the J-Kernel demonstrates the use of safe language techniques in a large application.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> B. N. Bershad, S. Savage, P. Pardyak, E. G. Sirer, M. Fiuczynski, D. Becker, S. Eggers, and C. Chambers. </author> <title> Extensibility, Safety and Performance in the SPIN Operating System. </title> <booktitle> In Proceedings of the 15 th ACM Symposium on Operating Systems Principles (SOSP), </booktitle> <address> Copper Mountain, CO, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: On the other hand, a web server allowing arbitrary users to upload extensions requires bulletproof protection assumed.to guard against malicious behavior. Several projects <ref> [1, 4, 8, 11, 37] </ref> have recently described how to build protection domains around components in a safe language environment, where a protection domain specifies the resources to which a software component has access. <p> HTTP server throughput (in pages/second) 12 correspond to the share anything approach described in Section 2. They do not address the issues of revocation, domain termination, thread protection, or resource accounting. The SPIN project <ref> [1] </ref> allows safe Modula-3 code to be downloaded into the operating system kernel to extend the kernels functionality. SPIN has a particularly nice model of dynamic linking [35] to control the namespace of different extensions.
Reference: 2. <author> B. N. Bershad, T. E. Anderson, E. D. Lazowska, and H. M. Levy. </author> <title> Lightweight Remote Procedure Call. </title> <booktitle> In Proceedings of the 12 th ACM Symposium on Operating Systems Principles (SOSP), </booktitle> <pages> pages 102-113, </pages> <address> Arizona, </address> <month> December </month> <year> 1989. </year>
Reference: 3. <author> R. S. Boyer, and Y. Yu. </author> <title> Automated proofs of object code for a widely used microprocessor. </title> <journal> J. ACM 43, </journal> <month> 1 (Jan. </month> <year> 1996), </year> <month> 166-192. </month> <title> Sy stem Operation Platform Time (us) L4 Round-trip IP C P 5-133 1.82 Ex okernel P rotected control transfer (r/t) DEC-5000 2.40 Eros Round-trip IP C P 5-120 4.90 J-Kernel M ethod invocation with 3 args P 5-133 3.77 Table 6. Comparison with selected kernels. </title> <type> 14 </type>
Reference-contexts: While, in theory, it is possible to prove that certain pieces of code only modify a restricted set of memory locations, in practice this is very difficult for languages like C and assembly language <ref> [3, 28] </ref>, and cannot be fully automated. In contrast, the type system and the linker in a safe language restrict what operations a particular piece of code is allowed to perform on which memory locations.
Reference: 4. <author> J. S. Chase, H. M. Levy, E. D. Lazowska, and M. Baker-Harvey. </author> <title> Lightweight Shared Objects in a 64-Bit Operating System. </title> <booktitle> In Proceedings of the ACM ObjectOriented Programming Systems, Languages, and Applications (OOPSLA), </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: On the other hand, a web server allowing arbitrary users to upload extensions requires bulletproof protection assumed.to guard against malicious behavior. Several projects <ref> [1, 4, 8, 11, 37] </ref> have recently described how to build protection domains around components in a safe language environment, where a protection domain specifies the resources to which a software component has access. <p> Wallach et. al. [37] describe three models of Java security: type hiding (making use of dynamic class loading to control a domains namespace), stack introspection, and capabilities. They recommended a mix of these three techniques. The E language from Electric Communities <ref> [4] </ref> is an extension of Java targeted towards distributed systems. Es security architecture is capability based; programmers are encouraged to use object references as the fundamental building block for protection. Odyssey [8] is a system that supports mobile agents written in Java. It supports capabilities defined with special IDL files. <p> Similarities exist between the J-Kernel and single-address operating systems (SASOS), like Opal <ref> [4] </ref> and Mungi [13]. SASOS remove the address space borders, allowing for cheaper and easier sharing of data between processes. Opal and Mungi were implemented on architectures offering large address spaces (64-bit) and used password capabilities as the protection mechanism.
Reference: 5. <author> S. Drossopoulou, S. Eisenbach. </author> <title> Java is Type Safe - Probably. </title> <booktitle> In Proceedings of the 11 th European Conference on ObjectOriented Programming, </booktitle> <address> Jyvskyl, Finland, </address> <month> June </month> <year> 1997. </year>
Reference: 6. <institution> Electric Communities. </institution> <note> The E White Paper. Available at http://www.communities.com/products/tools/e. </note>
Reference: 7. <author> R. Engler, M. F. Kaashoek, and J. James OToole. Exokernel: </author> <title> An Operating System Architecture for Application-Level Resource Management. </title> <booktitle> In Proceedings of the 15 th ACM Symposium on Operating Systems Principles (SOSP), </booktitle> <address> Copper Mountain, CO, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: The systems are carefully tuned and aggressively exploit features of the underlying hardware. The L4 m-kernel [11] rigorously aims for minimality and is designed from scratch, unlike first-generation m-kernels, which evolved from monolithic OS kernels. The system was successful at dispelling some common misconceptions about m-kernel performance limitations. Exokernel <ref> [7] </ref> shares L4s goal of being an ultrafast m-kernel, but is also concerned with untrusted loadable modules (similar to the SPIN project). Untrusted code is given efficient control over hardware resources by separating management from protection.
Reference: 8. <institution> General Magic. Odyssey. </institution> <note> Available at http://www.genmagic.com/agents. </note>
Reference-contexts: On the other hand, a web server allowing arbitrary users to upload extensions requires bulletproof protection assumed.to guard against malicious behavior. Several projects <ref> [1, 4, 8, 11, 37] </ref> have recently described how to build protection domains around components in a safe language environment, where a protection domain specifies the resources to which a software component has access. <p> The servlets are now being re-implemented using the J-Kernel. By using a protection domain for each component, the problems of the Jigsaw version are avoided. 5 Related Work Several major vendors have proposed extensions to the basic Java sandbox security model for applets <ref> [8, 16, 31, 26] </ref>. However, all of these proposals have focused on protecting trusted system resources from untrusted applets, and have not really addressed applet-to-applet communication and protection. By only addressing protection of trusted system resources, they have avoided the difficult questions about object sharing, class sharing, and thread protection. <p> They recommended a mix of these three techniques. The E language from Electric Communities [4] is an extension of Java targeted towards distributed systems. Es security architecture is capability based; programmers are encouraged to use object references as the fundamental building block for protection. Odyssey <ref> [8] </ref> is a system that supports mobile agents written in Java. It supports capabilities defined with special IDL files.
Reference: 9. <author> L. Gong. </author> <title> Java Security: Present and Near Future. </title> <journal> IEEE Micro, </journal> <volume> 17(3) </volume> <pages> 14-19, </pages> <month> May/June </month> <year> 1997. </year>
Reference: 10. <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java language specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: This paper explores the use of safe language technology to offer high performance as well as protection in a software component environment. Safe languages such as Java <ref> [10] </ref>, Modula-3 [30], and CAML [20] use type safety and controlled linking to enforce protection between multiple components without relying on hardware support.
Reference: 11. <author> D. Hagimont, and L. Ismail. </author> <title> A Protection Scheme for Mobile Agents on Java. </title> <booktitle> In Proceedings of the 3 rd Annual ACM/IEEE International Conference on Mobile Computing and Networking, </booktitle> <address> Budapest, Hungary, </address> <month> September 26-30, </month> <year> 1997. </year>
Reference-contexts: On the other hand, a web server allowing arbitrary users to upload extensions requires bulletproof protection assumed.to guard against malicious behavior. Several projects <ref> [1, 4, 8, 11, 37] </ref> have recently described how to build protection domains around components in a safe language environment, where a protection domain specifies the resources to which a software component has access. <p> Several research operating systems support very fast inter-process communication. Recent projects, like L4, Exokernel, and Eros, provide fine-tuned implementations of selected IPC mechanisms, yielding an order of magnitude improvement over traditional operating systems. The systems are carefully tuned and aggressively exploit features of the underlying hardware. The L4 m-kernel <ref> [11] </ref> rigorously aims for minimality and is designed from scratch, unlike first-generation m-kernels, which evolved from monolithic OS kernels. The system was successful at dispelling some common misconceptions about m-kernel performance limitations.
Reference: 12. <editor> H. Hrtig, et. al. </editor> <booktitle> The Performance of m-Kernel-Based Systems. In Proceedings of the 16 th ACM Symposium on Operating Systems Principles (SOSP 97), </booktitle> <month> October 5-8, </month> <year> 1997, </year> <pages> Saint-Malo, </pages> <address> France. </address>
Reference: 13. <author> G. Heiser, et. al. </author> <title> Implementation and Performance of the Mungi Single-Address-Space Operating System. </title> <type> Technical Report UNSW-CSE-TR-9704, </type> <month> June </month> <year> 1997, </year> <institution> the Univeristy of New South Wales, </institution> <address> Sydney, Australia. </address>
Reference-contexts: Similarities exist between the J-Kernel and single-address operating systems (SASOS), like Opal [4] and Mungi <ref> [13] </ref>. SASOS remove the address space borders, allowing for cheaper and easier sharing of data between processes. Opal and Mungi were implemented on architectures offering large address spaces (64-bit) and used password capabilities as the protection mechanism. Password capabilities are protected from forgery by a combination of encryption and sparsity.
Reference: 14. <author> JavaSoft. </author> <title> JavaBeans, </title> <note> Version 1.01 Specification. Available at http://java.sun.com. </note>
Reference-contexts: Most web servers support plug-ins as well and in this case, the robustness issue is even more important a browser crash may be annoying, but a server crash can be disastrous. The robustness versus performance tradeoff is pervasive in component software (e.g., OLE, JavaBeans <ref> [14] </ref>, ActiveX, OpenDoc). Microsofts COM [25], for example, provides two different models for composing components: each component can run in its own process for protection, or multiple components can share a process (often termed in-proc) for performance.
Reference: 15. <author> JavaSoft. </author> <title> Remote Method Invocation Specification. </title> <note> Available at http://java.sun.com. </note>
Reference-contexts: Other classes that provide corresponding implementations can then be declared to implement the interface. Normally interface classes are used to provide a limited form of multiple inheritance (properly called interface inheritance) in that a class can implement multiple interfaces. However, Suns remote method invocation (RMI) specification <ref> [15] </ref> pioneered the use of interfaces as compiler annotations. Instead of using a separate interface definition language (IDL), the RMI specification simply uses interface classes that are flagged to the RMI system in that they extend the class Remote. <p> This avoids offline stub generators and IDL files, and it allows the J-Kernel to specialize the stubs to invoke the target methods with minimal overhead. Besides switching domains, stubs have three roles: copying arguments, supporting revocation, and protecting threads. By default, the J-Kernel uses Javas built-in serialization features <ref> [15] </ref> to copy an argument: the J-Kernel serializes an argument into an array of bytes, and then deserializes the byte array to produce a fresh copy of the argument. While this is convenient because many built-in Java classes are serializable, it involves a substantial overhead.
Reference: 16. <author> JavaSoft. </author> <title> New Security Model for JDK1.2. </title> <note> Available at http://java.sun.com </note>
Reference-contexts: The servlets are now being re-implemented using the J-Kernel. By using a protection domain for each component, the problems of the Jigsaw version are avoided. 5 Related Work Several major vendors have proposed extensions to the basic Java sandbox security model for applets <ref> [8, 16, 31, 26] </ref>. However, all of these proposals have focused on protecting trusted system resources from untrusted applets, and have not really addressed applet-to-applet communication and protection. By only addressing protection of trusted system resources, they have avoided the difficult questions about object sharing, class sharing, and thread protection.
Reference: 17. <author> JavaSoft. </author> <title> Java Servlet API. </title> <note> Available at http://java.sun.com. </note>
Reference-contexts: The goal is to allow users to dynamically extend the functionality of the server by uploading Java programs, called servlets <ref> [17] </ref>, that customize the HTTP request processing for a subset of the servers URL space. Instead of building (or porting) an entire HTTP server in Java, we integrated the J-Kernel into the off-the-shelf Microsoft server (IIS 3.0).
Reference: 18. <author> JavaSoft JavaServer Documentation. </author> <note> Available at http://java.sun.com </note>
Reference-contexts: RPC costs using standard NT mechanisms (in ms) 11 Server throughput measurements To quantify the impact of the J-Kernel overheads in the performance of the HTTP server, several simple experiments measure the number of documents per second that can be served by Microsofts IIS, Suns Java Web Server 1.0.2 (JWS) <ref> [18] </ref>, and J-Kernel running inside IIS. The hardware platform consists of a quad-processor 200MHz Pentium-Pro (results obtained on one and two-processor machines are similar). The parameter of the experiments is the size of document being served.
Reference: 19. <author> A. K. Jones and W. A. Wulf. </author> <title> Towards the Design of Secure Systems. </title> <journal> Software Practice and Experience, </journal> <volume> Vol. 5, No. </volume> <pages> 4. </pages>
Reference-contexts: While this can potentially lead to safety with no overhead, generating the proofs is nontrivial. The J-Kernel enforces a structure that is similar to traditional capability systems <ref> [19, 21] </ref>. Both the J-Kernel and traditional capability systems are founded on the notion of unforgeable capabilities. In both, capabilities name objects in a context-independent manner, so that capabilities can be passed from one domain to another. <p> Using Java as the basis for the J-Kernel simplifies many of the issues that plagued traditional capability systems. First, unlike systems based on capability lists, the J-Kernel can store capabilities in data structures, because capabilities are implemented as Java objects. Second, rights amplification <ref> [19] </ref> is implicit in the objectoriented nature of Java: invocations are made on methods, rather than functions, and methods automatically acquire rights to their self parameter. In addition, selective class sharing can be used to amplify other parameters.
Reference: 20. <author> X. Leroy. </author> <title> Objective Caml. </title> <note> Available at http://pauillac.inria.fr/ocaml/. </note>
Reference-contexts: This paper explores the use of safe language technology to offer high performance as well as protection in a software component environment. Safe languages such as Java [10], Modula-3 [30], and CAML <ref> [20] </ref> use type safety and controlled linking to enforce protection between multiple components without relying on hardware support. In a safe language environment, calls across protection boundaries could potentially be 2 as cheap as simple function calls 1 , enabling as much communication between components as desired without performance drawbacks.
Reference: 21. <author> H. M. Levy. </author> <title> Capability-Based Computer Systems. </title> <publisher> Digital Press, </publisher> <address> Bedford, Massachusetts, </address> <year> 1984. </year>
Reference-contexts: While this can potentially lead to safety with no overhead, generating the proofs is nontrivial. The J-Kernel enforces a structure that is similar to traditional capability systems <ref> [19, 21] </ref>. Both the J-Kernel and traditional capability systems are founded on the notion of unforgeable capabilities. In both, capabilities name objects in a context-independent manner, so that capabilities can be passed from one domain to another.
Reference: 22. <editor> J. Liedtke. </editor> <booktitle> 2Qfl NHUQHOfl &RQVWUXFWLRQfl In Proceedings of the 15 th ACM Symposium on Operating Systems Principles (SOSP), </booktitle> <address> Copper Mountain, CO, </address> <month> December </month> <year> 1995. </year>
Reference: 23. <editor> J. Liedtke, et. al. </editor> <booktitle> Achieved IPC Performance. In Proceedings of the 6 th Workshop on Hot Topics in Operating Systems (HotOS), </booktitle> <address> May 5-6, Chatham, MA. </address>
Reference: 24. <author> T. Lindholm, and F. Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference: 25. <author> Microsoft Corporation and Digital Equipment Corporaton. </author> <title> The Component Object Model Specification. </title> <address> Redmond, WA, </address> <month> July </month> <year> 1996. </year>
Reference-contexts: Most web servers support plug-ins as well and in this case, the robustness issue is even more important a browser crash may be annoying, but a server crash can be disastrous. The robustness versus performance tradeoff is pervasive in component software (e.g., OLE, JavaBeans [14], ActiveX, OpenDoc). Microsofts COM <ref> [25] </ref>, for example, provides two different models for composing components: each component can run in its own process for protection, or multiple components can share a process (often termed in-proc) for performance.
Reference: 26. <institution> Microsoft Corporation. Microsoft Security Management Architecture White Paper. </institution> <note> Available at http://www.microsoft.com/ie/security. </note>
Reference-contexts: The servlets are now being re-implemented using the J-Kernel. By using a protection domain for each component, the problems of the Jigsaw version are avoided. 5 Related Work Several major vendors have proposed extensions to the basic Java sandbox security model for applets <ref> [8, 16, 31, 26] </ref>. However, all of these proposals have focused on protecting trusted system resources from untrusted applets, and have not really addressed applet-to-applet communication and protection. By only addressing protection of trusted system resources, they have avoided the difficult questions about object sharing, class sharing, and thread protection.
Reference: 27. <author> G. Morrisett, D. Walker, K. Crary, and N. Glew. </author> <title> From System F to Typed Assembly Language. </title> <booktitle> To appear in the 1998 Symposium on Principles of Programming Languages. </booktitle>
Reference-contexts: Second, all current language-based protection systems are designed around a single language, which limits developers and doesnt handle legacy code. Software fault isolation [36] and verification of assembly language <ref> [28, 29, 27] </ref> may someday offer solutions, but are still an active area of research [31]. Section 4 describes an extensible web server based on the J-Kernel. Section 5 discusses related work, and section 6 concludes. <p> Since it uses Modula-3 pointers directly as capabilities, the limitations of the share anything approach apply to it. Several recent software-based protection techniques do not rely on a particular high level language like Java or Modula-3. Typed assembly language <ref> [27] </ref> pushes type safety down to the assembly language level, so that code written at the assembly language level can be statically type checked and verified as safe.
Reference: 28. <author> G. Necula and P. Lee. </author> <title> Safe Kernel Extensions Without RunTime Checking. </title> <booktitle> In Proceedings of the 2 nd Operating Systems Design and Implementation (OSDI), </booktitle> <address> Seattle, WA, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: Second, all current language-based protection systems are designed around a single language, which limits developers and doesnt handle legacy code. Software fault isolation [36] and verification of assembly language <ref> [28, 29, 27] </ref> may someday offer solutions, but are still an active area of research [31]. Section 4 describes an extensible web server based on the J-Kernel. Section 5 discusses related work, and section 6 concludes. <p> While, in theory, it is possible to prove that certain pieces of code only modify a restricted set of memory locations, in practice this is very difficult for languages like C and assembly language <ref> [3, 28] </ref>, and cannot be fully automated. In contrast, the type system and the linker in a safe language restrict what operations a particular piece of code is allowed to perform on which memory locations. <p> With suitable optimizations, sandboxed code can run nearly as fast as the original binary on RISC architectures. However, it is not clear how to extend optimized sandboxing techniques to CISC architectures, and sandboxing cannot enforce protection at as fine a granularity as a type system. Proof carrying code <ref> [28, 29] </ref> generalizes many different approaches to software protection arbitrary binary code can be executed as long as it comes with a proof that it is safe. While this can potentially lead to safety with no overhead, generating the proofs is nontrivial.
Reference: 29. <author> G. Necula. </author> <title> Proof-carrying code. </title> <booktitle> In 24 th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 106-119, </pages> <address> Paris, </address> <year> 1997. </year>
Reference-contexts: Second, all current language-based protection systems are designed around a single language, which limits developers and doesnt handle legacy code. Software fault isolation [36] and verification of assembly language <ref> [28, 29, 27] </ref> may someday offer solutions, but are still an active area of research [31]. Section 4 describes an extensible web server based on the J-Kernel. Section 5 discusses related work, and section 6 concludes. <p> With suitable optimizations, sandboxed code can run nearly as fast as the original binary on RISC architectures. However, it is not clear how to extend optimized sandboxing techniques to CISC architectures, and sandboxing cannot enforce protection at as fine a granularity as a type system. Proof carrying code <ref> [28, 29] </ref> generalizes many different approaches to software protection arbitrary binary code can be executed as long as it comes with a proof that it is safe. While this can potentially lead to safety with no overhead, generating the proofs is nontrivial.
Reference: 30. <author> G. Nelson, ed. </author> <title> System Programming in Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: This paper explores the use of safe language technology to offer high performance as well as protection in a software component environment. Safe languages such as Java [10], Modula-3 <ref> [30] </ref>, and CAML [20] use type safety and controlled linking to enforce protection between multiple components without relying on hardware support.
Reference: 31. <author> Netscape Corporation. </author> <title> Java Capabilities API. </title> <note> Available at http://www.netscape.com. </note>
Reference-contexts: Second, all current language-based protection systems are designed around a single language, which limits developers and doesnt handle legacy code. Software fault isolation [36] and verification of assembly language [28, 29, 27] may someday offer solutions, but are still an active area of research <ref> [31] </ref>. Section 4 describes an extensible web server based on the J-Kernel. Section 5 discusses related work, and section 6 concludes. In fact, in the case of Java, just-in-time compilers have the opportunity to perform optimizations that would be impossible in a system based on hardware protection. <p> The servlets are now being re-implemented using the J-Kernel. By using a protection domain for each component, the problems of the Jigsaw version are avoided. 5 Related Work Several major vendors have proposed extensions to the basic Java sandbox security model for applets <ref> [8, 16, 31, 26] </ref>. However, all of these proposals have focused on protecting trusted system resources from untrusted applets, and have not really addressed applet-to-applet communication and protection. By only addressing protection of trusted system resources, they have avoided the difficult questions about object sharing, class sharing, and thread protection.
Reference: 32. <author> V. Saraswat. </author> <title> Java is not typesafe. </title> <note> Available at http://www.research.att.com/~vj/bug.html. </note>
Reference: 33. <author> Z. Shao. </author> <title> Typed Common Intermediate Format. </title> <booktitle> 1997 USENIX Conference on DomainSpecific Languages, </booktitle> <address> Santa Barbara, California, </address> <month> October </month> <year> 1997. </year>
Reference: 34. <author> J. S. Shapiro, D. J. Farber, and J. M. Smith. </author> <title> The Measured Performance of a Fast Local IPC. </title> <booktitle> In the 5 th International Workshop on ObjectOrientation in Operating Systems, </booktitle> <address> Seattle, Washington. </address> <year> 1996 </year>
Reference-contexts: Exokernel [7] shares L4s goal of being an ultrafast m-kernel, but is also concerned with untrusted loadable modules (similar to the SPIN project). Untrusted code is given efficient control over hardware resources by separating management from protection. The focus of the EROS <ref> [34] </ref> project is to support orthogonal persistence and real-time computations. Despite quite different objectives, all three systems manage to provide very fast implementations of IPC with comparable performance, as shown in Table 6. A short explanation of the operation column is needed.
Reference: 35. <author> E. G. Sirer, M. Fiuczynski, P. Pardyak, and B. Bershad. </author> <title> Safe Dynamic Linking in an Extensible Operating System. </title> <booktitle> 1 Workshop on Compiler Support for Systems Software, </booktitle> <month> February </month> <year> 1996. </year> <month> 15 </month>
Reference-contexts: They do not address the issues of revocation, domain termination, thread protection, or resource accounting. The SPIN project [1] allows safe Modula-3 code to be downloaded into the operating system kernel to extend the kernels functionality. SPIN has a particularly nice model of dynamic linking <ref> [35] </ref> to control the namespace of different extensions. Since it uses Modula-3 pointers directly as capabilities, the limitations of the share anything approach apply to it. Several recent software-based protection techniques do not rely on a particular high level language like Java or Modula-3.
Reference: 36. <author> R. Wahbe, S. Lucco, T. E. Anderson, and S. L. Graham. </author> <title> Efficient Software-Based Fault Isolation. </title> <booktitle> In Proceedings of the 14 ACM Symposium on Operating Systems Principles (SOSP), </booktitle> <address> Asheville, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: Second, all current language-based protection systems are designed around a single language, which limits developers and doesnt handle legacy code. Software fault isolation <ref> [36] </ref> and verification of assembly language [28, 29, 27] may someday offer solutions, but are still an active area of research [31]. Section 4 describes an extensible web server based on the J-Kernel. Section 5 discusses related work, and section 6 concludes. <p> Typed assembly language [27] pushes type safety down to the assembly language level, so that code written at the assembly language level can be statically type checked and verified as safe. Software fault isolation <ref> [36] </ref> inserts runtime sandboxing checks into binary executables to restrict the range of memory that is accessible to the code. With suitable optimizations, sandboxed code can run nearly as fast as the original binary on RISC architectures.
Reference: 37. <author> D. S. Wallach, D. Balfanz, D. Dean, and E. W. Felten. </author> <title> Extensible Security Architectures for Java. </title> <booktitle> In Proceedings of the 16 ACM Symposium on Operating Systems Principles (SOSP), </booktitle> <address> Saint-Malo, France, </address> <month> October </month> <year> 1997. </year>
Reference-contexts: On the other hand, a web server allowing arbitrary users to upload extensions requires bulletproof protection assumed.to guard against malicious behavior. Several projects <ref> [1, 4, 8, 11, 37] </ref> have recently described how to build protection domains around components in a safe language environment, where a protection domain specifies the resources to which a software component has access. <p> It is not obvious how these approaches can extend to a more general model allowing communication between mutually suspicious domains. A number of related safe-language systems are based on the idea of using object references as capabilities. Wallach et. al. <ref> [37] </ref> describe three models of Java security: type hiding (making use of dynamic class loading to control a domains namespace), stack introspection, and capabilities. They recommended a mix of these three techniques. The E language from Electric Communities [4] is an extension of Java targeted towards distributed systems.
Reference: 38. <institution> World Wide Web Consortium, Jigsaw 1.0, </institution> <note> http://www.w3.org/Jigsaw. </note>
Reference-contexts: The course staff wrote compiler, assembler, and linker components in Java, which students used for course homeworks and projects. For a number of reasons, the course staff chose a web-based solution and implemented the components as servlets running in an extensible web server, Jigsaw. Jigsaw <ref> [38] </ref> is a web server written in Java by the W 3 C, and servlets are really just dynamically loaded classes without robust protection. Since these servlets are developed by the trusted course staff, malicious attack is not a source of concern.
Reference: 39. <author> W. A. Wulf, R. Levin, and S.P. Harbison, Hydra/C. </author> <title> mmp: An Experimental Computer System, </title> <publisher> McGraw-Hill, </publisher> <address> New York, NY (1981). </address>
Reference-contexts: In addition, selective class sharing can be used to amplify other parameters. Although many capability systems did not support revocation, the idea of using indirection to implement revocation is certainly not new. The issue of resource accounting was also known to implementers of capability systems Wulf et. al. <ref> [39] </ref> point out that No one owns an object in the Hydra scheme of things; thus its very hard to know to whom the cost of maintaining it should be charged, and that the accounting issue would need to be addressed in a production operating system.
References-found: 39

