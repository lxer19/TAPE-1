URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/CU-CS-641-93.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/
Root-URL: http://www.cs.berkeley.edu
Title: A Comparison of Object-Oriented Programming in Four Modern Languages  
Author: Robert Henderson Benjamin Zorn 
Date: Revised July 1993  
Address: Campus Box #430  Boulder 80309-0430  Boulder  
Affiliation: Department of Computer Science  University of Colorado,  ffi University of Colorado at  
Pubnum: CU-CS-641-93  
Abstract: Technical Report CU-CS-641-93 Department of Computer Science Campus Box 430 University of Colorado Boulder, Colorado 80309 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Gunther Blashek, Gustav Pomberger, and Alois Stritzinger. </author> <title> A comparison of object-oriented programming languages. </title> <journal> Structured Programming, </journal> <volume> 10(4) </volume> <pages> 187-197, </pages> <year> 1989. </year>
Reference-contexts: In addition to having more quantitative performance comparisons, our paper also considers a greater number of approaches; we examine a broad spectrum of experimental approaches to object-oriented programming. Blaschek et al compare the languages C++, Eiffel, Oberon, and Smalltalk-80 <ref> [1] </ref>. Their comparison includes a general description of each language and a point-by-point comparison of a number of specific features including inheritance, efficiency, complexity, and reliability. Schmidt and Omohun-dro compare the features for object-oriented programming in CLOS, Eiffel and Sather [12].
Reference: [2] <author> Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <title> Modula-3 language definition. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(8) </volume> <pages> 15-43, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: As with each of the other languages except C++, garbage collection is provided to free the programmer from the onerous task of memory management. Modula-3 While Oberon represents a minimal evolution of Modula-2 to support object-oriented programming, Modula-3 <ref> [2, 4] </ref> is a larger language providing support for large, multi-person programming projects with separate module interface specification and exception handling as well as concurrency and garbage collection. Modula-3 is a strongly-typed language with an emphasis on safety.
Reference: [3] <author> Craig Chambers and David Ungar. Custimization: </author> <title> Optimizing compiler technology for Self, a dynamically-typed object-oriented programming language. </title> <booktitle> In Proceedings of the SIGPLAN'89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 146-160, </pages> <address> Portland, OR, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: Not surprisingly, Self is the slowest of the five languages, due largely to the dynamic nature of the language that requires a large amount of run-time checking not required by the other languages. However, the Self system does perform extensive innovative optimizations to reduce this run-time overhead <ref> [3, 6] </ref>. The Self database implementation used the optimization described in the Inheritance Section to avoid the dynamic indirection associated with data parents.
Reference: [4] <author> Sam Harbison. </author> <title> Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1992. </year>
Reference-contexts: As with each of the other languages except C++, garbage collection is provided to free the programmer from the onerous task of memory management. Modula-3 While Oberon represents a minimal evolution of Modula-2 to support object-oriented programming, Modula-3 <ref> [2, 4] </ref> is a larger language providing support for large, multi-person programming projects with separate module interface specification and exception handling as well as concurrency and garbage collection. Modula-3 is a strongly-typed language with an emphasis on safety.
Reference: [5] <author> Urs Holzle. </author> <type> Personal communications. </type> <month> January </month> <year> 1993. </year>
Reference-contexts: In this example, dataparent has lower precedence, as indicated by the two asterisks following the name, so that the print method from studentTraits is used for student files. An alternate approach eliminates data parents from the model <ref> [5] </ref>. Using this approach, the student prototype is created by cloning the personnel prototype and adding additional slots, thereby eliminating the dynamic indirection associated with accessing data slots of the parent.
Reference: [6] <author> Urs Holzle, Craig Chambers, and David Ungar. </author> <title> Optimizing dynamically-typed object-oriented languages with polymorphic inline caches. </title> <booktitle> In Proceedings of the European Conference on Object-Oriented Programming, </booktitle> <month> July </month> <year> 1991. </year>
Reference-contexts: Not surprisingly, Self is the slowest of the five languages, due largely to the dynamic nature of the language that requires a large amount of run-time checking not required by the other languages. However, the Self system does perform extensive innovative optimizations to reduce this run-time overhead <ref> [3, 6] </ref>. The Self database implementation used the optimization described in the Inheritance Section to avoid the dynamic indirection associated with data parents.
Reference: [7] <author> Chu-Cheow Lim and Andreas Stolcke. </author> <title> Sather language design and performance evaluation. </title> <type> Technical Report TR-91-034, </type> <institution> International Computer Science Institute, Berkeley, </institution> <address> CA, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: However, Sather has a more general dispatch mechanism than C++ and, in the Rel0.2i implementation, there is a higher associated overhead. The Sather compiler uses a single word dispatch cache to minimize the cost of dispatch <ref> [7] </ref>. As a result, the cost of dispatch is highly dependent on the miss-rate of this cache. The effect of dispatch cache miss rate on run-time is discussed later in the paper. Our initial version of the database application implemented social security numbers as strings. <p> A detailed discussion of the Sather dispatch cache design and an evaluation of the dispatch efficiency was written by Lim and Stolcke <ref> [7] </ref>. They measure the dispatch cache miss rate of the Sather compiler (written in Sather) and find the average miss rate to be approximately 20%.
Reference: [8] <author> Hanspeter Mossenbock and Josef Templ. </author> <title> Object Oberon | a modest object-oriented language. </title> <journal> Structured Programming, </journal> <volume> 10(4) </volume> <pages> 199-207, </pages> <year> 1989. </year> <month> 25 </month>
Reference-contexts: The most important addition is type extensions [19], which provide basic support for inheritance. Oberon has evolved into Oberon-2, the most recent of the Oberon languages, and is described by Mossenbock and Wirth [9]. Oberon-2 was influenced by Object-Oberon <ref> [8] </ref> and incorporates type-bound procedures, which are equivalent to methods. Type-extensions and type-bound procedures provide the support for object-oriented programming generally provided by explicit classes in object-oriented programming languages.
Reference: [9] <author> Hanspeter Mossenbock and Niklaus Wirth. </author> <title> The programming language Oberon-2. </title> <journal> Structured Program--ming, </journal> <volume> 12 </volume> <pages> 179-195, </pages> <year> 1991. </year>
Reference-contexts: Oberon is largely the result of removing features from Modula-2, however a few features were added. The most important addition is type extensions [19], which provide basic support for inheritance. Oberon has evolved into Oberon-2, the most recent of the Oberon languages, and is described by Mossenbock and Wirth <ref> [9] </ref>. Oberon-2 was influenced by Object-Oberon [8] and incorporates type-bound procedures, which are equivalent to methods. Type-extensions and type-bound procedures provide the support for object-oriented programming generally provided by explicit classes in object-oriented programming languages.
Reference: [10] <author> Stephen Omohundro and Chu-Cheow Lim. </author> <title> The Sather language and libraries. </title> <type> Technical Report TR-92-017, </type> <institution> International Computer Science Institute, Berkeley, </institution> <address> CA, </address> <month> February </month> <year> 1992. </year>
Reference-contexts: However, the safety features of the language can be explicitly circumvented when increased efficiency or functionality are necessary. Modula-3 supports object 4 oriented programming by providing object types, which are incorporated into the basic module structure of the language. Sather Sather <ref> [11, 10] </ref> was derived from Eiffel with an emphasis on simplicity and efficiency. While Oberon-2 and Modula-3 are procedural languages that provide support for both modules and objects, Sather places a central emphasis on objects and classes.
Reference: [11] <author> Stephen M. Omohundro. </author> <title> The Sather Language. </title> <booktitle> International Computer Science Institute, </booktitle> <address> Berkeley, CA, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: However, the safety features of the language can be explicitly circumvented when increased efficiency or functionality are necessary. Modula-3 supports object 4 oriented programming by providing object types, which are incorporated into the basic module structure of the language. Sather Sather <ref> [11, 10] </ref> was derived from Eiffel with an emphasis on simplicity and efficiency. While Oberon-2 and Modula-3 are procedural languages that provide support for both modules and objects, Sather places a central emphasis on objects and classes.
Reference: [12] <author> Heinz W. Schmidt and Stephen Omohundro. </author> <title> CLOS, Eiffel, and Sather: a comparison. </title> <type> Technical Report TR-91-047, </type> <institution> International Computer Science Institute, Berkeley, </institution> <address> CA, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: Their comparison includes a general description of each language and a point-by-point comparison of a number of specific features including inheritance, efficiency, complexity, and reliability. Schmidt and Omohun-dro compare the features for object-oriented programming in CLOS, Eiffel and Sather <ref> [12] </ref>. Their comparison includes language features, program performance, and available programming environments. While both of these comparisons are detailed and complete, they are not conducted in the 5 context of a single specific example.
Reference: [13] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: We include C++ in the descriptions below because it is used as a baseline for performance comparisons later in the paper. C++ C++ <ref> [13] </ref> is a widely-used object-oriented programming language and provides a well-known baseline for comparison. C++ supports object-oriented programming by extending C with classes that group functions and data, provide information hiding, and support inheritance. C++ is statically-typed and attempts to significantly reduce the run-time overhead of object-oriented programming.
Reference: [14] <author> David Ungar, Craig Chambers, Bar-Wei Chang, and Urs Holzle. </author> <title> Organizing programs without classes. LISP and Symbolic Computation: </title> <journal> An International Journal, </journal> <volume> 4(3) </volume> <pages> 37-56, </pages> <year> 1991. </year>
Reference-contexts: Finally, Figure 5 shows the Personnel and Student traits and prototypes objects definitions in Self. Self makes use of prototypes with cloning rather than classes with instantiation. However, the behavior of classes with inheritance can be achieved in Self as described by Ungar et al <ref> [14] </ref>. To explain how this is done, we will use our database application as an example. Consider the relationship between student and personnel files.
Reference: [15] <author> David Ungar and Randall B. Smith. </author> <title> Self: the power of simplicity. LISP and Symbolic Computation: </title> <journal> An International Journal, </journal> <volume> 4(3) </volume> <pages> 1-20, </pages> <year> 1991. </year>
Reference-contexts: While in many ways the philosophy of Sather is closer to that of Smalltalk and other purely object-oriented languages, Sather is interesting because it also emphasizes static-typing and performance. Self Self <ref> [15] </ref> is a dynamically typed, object-oriented programming language with message passing that was designed to support exploratory programming. Self represents a deviation from organization by classes supported by most object-oriented programming languages. Instead of classes with instance variables and methods, Self incorporates prototypes with slots.
Reference: [16] <author> Jack C. Wileden, Lori A. Clarke, and Alexander L. Wolf. </author> <title> A comparative evaluation of object definition techniques for large prototyping systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(4) </volume> <pages> 670-699, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Furthermore, our approach allows us to carefully investigate the cost of dynamic dispatch in each of the languages implementations evaluated, while theirs does not. Other comparisons of object-oriented techniques have also appeared. Wileden, Clark, and Wolf evaluate object definition techniques in prototyping systems <ref> [16] </ref>. Their investigation focuses only on object definition and the utility of these techniques for building large prototype systems. This paper differs from others like it because it compares a wide variety of experimental approaches to object-oriented programming in the context of a simple example.
Reference: [17] <author> Niklaus Wirth. </author> <title> Programming in Modula-2. </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1982. </year>
Reference-contexts: Programmers who do not use the object-oriented features of C++ get the same performance they would using C. If programmers need dynamic dispatch in C++, they explicitly use "virtual functions," otherwise functions are statically bound. Oberon Oberon [18] was designed by Niklaus Wirth as a successor to Modula-2 <ref> [17] </ref>. Oberon is largely the result of removing features from Modula-2, however a few features were added. The most important addition is type extensions [19], which provide basic support for inheritance.
Reference: [18] <author> Niklaus Wirth. </author> <title> From Modula to Oberon. </title> <journal> Software|Practice and Experience, </journal> <volume> 18(7) </volume> <pages> 661-670, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: Programmers who do not use the object-oriented features of C++ get the same performance they would using C. If programmers need dynamic dispatch in C++, they explicitly use "virtual functions," otherwise functions are statically bound. Oberon Oberon <ref> [18] </ref> was designed by Niklaus Wirth as a successor to Modula-2 [17]. Oberon is largely the result of removing features from Modula-2, however a few features were added. The most important addition is type extensions [19], which provide basic support for inheritance.
Reference: [19] <author> Niklaus Wirth. </author> <title> Type extensions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(2) </volume> <pages> 204-214, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: Oberon Oberon [18] was designed by Niklaus Wirth as a successor to Modula-2 [17]. Oberon is largely the result of removing features from Modula-2, however a few features were added. The most important addition is type extensions <ref> [19] </ref>, which provide basic support for inheritance. Oberon has evolved into Oberon-2, the most recent of the Oberon languages, and is described by Mossenbock and Wirth [9]. Oberon-2 was influenced by Object-Oberon [8] and incorporates type-bound procedures, which are equivalent to methods.
Reference: [20] <author> Wayne Wolf. </author> <title> A practical comparison of two object-oriented languages. </title> <journal> IEEE Software, </journal> <volume> 6(5) </volume> <pages> 61-68, </pages> <month> September </month> <year> 1989. </year> <month> 26 </month>
Reference-contexts: Wolf's comparison of object-oriented programming in C++ and Flavors is based on building systems for designing electronic hardware <ref> [20] </ref>. He qualitatively compares the languages' features, including support of objects, typing, memory management, etc. Because the languages compared are so different, only a minimal quantitative comparison of performance is included.
References-found: 20

