URL: ftp://osm7.cs.byu.edu/papers/OSAToAda.ps.gz
Refering-URL: http://osm7.cs.byu.edu/Papers.html
Root-URL: 
Email: E-Mail Addresses: sbodily@osm7.cs.byu.edu embley@cs.byu.edu woodfiel@cs.byu.edu  
Title: Implementing OSA Model Instances in Ada  
Author: Susan Bodily David W. Embley Scott N. Woodfield 
Address: TMCB 3361 Provo, UT 84602  
Affiliation: Brigham Young University Computer Science Department  
Abstract: Object-oriented Systems Analysis (OSA) [EKW92] is an analysis model whose purpose is to provide a way for analysts to capture and record real-world, system-application information. To produce software, OSA model instances must be mapped into code using some programming language. This paper shows how to map OSA model instances into production-quality Ada code. The technique uses templates that directly and efficiently support OSA concepts. We give basic templates, show how to map OSA concepts directly into the templates, and explain and discuss efficiency considerations. We illustrate our ideas with two sample applications. 
Abstract-found: 1
Intro-found: 1
Reference: [Atk91] <author> Atkinson, C., </author> <title> Object-Oriented Reuse, Concurrency, and Distribution: An Ada-Based Approach, </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: Operations to manipulate the set are a part of the templates. So, an object class in our Ada code corresponds exactly with the OSA object class concept. 1 Extensions to Ada83 requiring a pre-processor are InnovAda [SiC88], ADA++ [FFF89], Classic Ada [SPS92], and DRAGOON <ref> [Atk91] </ref>. 2 Electronic copies are available by anonymous ftp [Ftp]. 4 Relationship sets, in OSA, are sets of relationships. Relationships are logical connections between object instances. We represent these relationships as tuples of object instances. Our templates have sets that store these relationships along with the set manipulation operations. <p> This provides independent and concurrent operation of object instances. Thus, our Ada code maps directly to the OSA behavior concept. This task technique is similar to the methods presented by Atkinson <ref> [Atk91] </ref>, Collard [Col89], and Meyer [Mey88] but has been extended for use with OSA. As a practical matter, it may be possible to remove some or all of the model concurrency when the problem being solved is not inherently concurrent. We have developed templates to allow this.
Reference: [Bod93] <author> Bodily, S., </author> <title> Ada Templates for OSA Implementation, </title> <type> Technical Report BYU-CS-93-7, </type> <institution> Computer Science Department, Brigham Young University, </institution> <year> 1993. </year>
Reference-contexts: Figures 4 and 5 show an abbreviated version of the template for an object-class package. Figure 4 is the package specification and Figure 5 is the package body. (The full templates are 9 pages long, including comments <ref> [Bod93] </ref>.) In the following discussion, an example of the use of the object-class template is shown to aid in understanding. When templates are shown, the parts of a template package to be filled in for each object class are shown in bold, italicized, slightly larger letters. <p> Figures 7 and 8 show an abbreviated version of the template for binary relationship sets. Figure 7 shows the 14 relationship-set package specification and Figure 8 shows the package body. (The full template including comments for binary relationship sets is 4 pages long <ref> [Bod93] </ref>.) 3.2.1 Relationship-Set Package Specification with Relationship_Set_Package; package body Binary_Relationship_Set is type Tuple is record First : An_Object_Class.Object; Second : B_Object_Class.Object; end record; package Relationship_Set is new Relationship_Set_Package (Tuple); procedure Clear is begin Relationship_Set.Clear; end Clear; procedure Build_Tuple (First_Object : in An_Object_Class.Object; Second_Object : in B_Object_Class.Object) is This_Tuple : Tuple; begin
Reference: [Boo87] <author> Booch, G., </author> <title> Software Components with Ada: Structures, Tools, and Subsystems, </title> <address> Benjamin/Cummings, </address> <year> 1987. </year>
Reference-contexts: If memory management is of concern for a particular application, an appropriate memory management package should be included and object-instance manipulation routines should be changed to accommodate the memory-management scheme. An example of such a memory management scheme can be seen in the Storage_Manager_Sequential package <ref> [Boo87] </ref>. Alternatively, a compiler that provides memory management can be used. Any object classes, relationship sets, and support packages used for the implementation of the object-class are included in the context clauses as appropriate. <p> If multiple inheritance appears in an OSA model instance a transformation to an equivalent model instance containing only single inheritance is required [Tem93]. The set packages in the object-class and relationship-set packages are based on the Booch Ada components <ref> [Boo87] </ref>. We use the set abstract data type defined by Booch except that we make it a container package and add an iterator routine to extract set elements one at a time.
Reference: [Cly93] <author> Clyde, </author> <title> S.W., An Initial Theoretical Foundation for Object-Oriented Systems Analysis and Design, </title> <type> PhD Dissertation, </type> <institution> Brigham Young University, </institution> <year> 1993. </year>
Reference-contexts: The time interval between the calling of the Build procedure and the calling of the Create procedure when producing an object instance is the "becoming" time interval described in the formal definition of OSA <ref> [Cly93] </ref>. That is the time period between the time when an object instance comes into being and the time an object becomes a member of the object class. Object-class manipulation routines allow a class of object instances to be manipulated.
Reference: [Col89] <author> Collard, P., </author> <title> "Object-Oriented Programming Techniques with Ada: An Example", </title> <journal> Ada Letters, </journal> <volume> vol. 9 no. 6, </volume> <month> Sep/Oct </month> <year> 1989. </year>
Reference-contexts: This provides independent and concurrent operation of object instances. Thus, our Ada code maps directly to the OSA behavior concept. This task technique is similar to the methods presented by Atkinson [Atk91], Collard <ref> [Col89] </ref>, and Meyer [Mey88] but has been extended for use with OSA. As a practical matter, it may be possible to remove some or all of the model concurrency when the problem being solved is not inherently concurrent. We have developed templates to allow this.
Reference: [Dew90] <author> Dewdney, </author> <title> A.K., The Magic Machine: A Handbook of Computer Sorcery, </title> <editor> W. H. </editor> <publisher> Freeman and Company, </publisher> <year> 1990. </year>
Reference-contexts: See Object-Oriented Systems Analysis A Model-Driven Approach [EKW92] for more details. As we introduce OSA, we also introduce one of the examples we have chosen to illustrate our ideas. The example is a cellular automaton known as the Hodgepodge Machine <ref> [Dew90] </ref> to illustrate OSA concepts. In the Hodgepodge Machine, cells are born and cells die according to rules about cells and their neighbors. Different types of cell neighborhoods and different rules allow for various versions of the Hodgepodge Machine.
Reference: [DoD83] <author> United States Department of Defense, </author> <title> Reference Manual for the Ada Programming Language: </title> <booktitle> ANSI/MIL-STD-1815A-1983, Ada Joint Program Office, </booktitle> <year> 1983. </year>
Reference-contexts: However, any set container package that provides a compatible interface can be used. OSA behavior models permit intra-object concurrency as well as inter-object concurrency. The templates support this notion since tasks can contain other tasks <ref> [DoD83] </ref>. Placing tasks within the main object task models intra-object concurrency. Certain applications require persistent objects and OSA supports persistent objects. Object persistence can be supported in our translation scheme by providing a method for object storage.
Reference: [EKW92] <author> Embley, D.W., </author> <title> B.D. Kurtz, and S.N. Woodfield, Object-Oriented Systems Analysis: A Model Driven Approach, </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction Object-oriented Systems Analysis (OSA) <ref> [EKW92] </ref> is a formally defined analysis model. Since its definition has precise underlying semantics, an analysis done using OSA provides a sound basis for software design and implementation. <p> Thus, it precisely captures object-oriented concepts without the limitations imposed by implementation considerations. We give a brief discussion of OSA in the following paragraphs. The discussion is not complete but should give the reader some background for understanding the translation discussions. See Object-Oriented Systems Analysis A Model-Driven Approach <ref> [EKW92] </ref> for more details. As we introduce OSA, we also introduce one of the examples we have chosen to illustrate our ideas. The example is a cellular automaton known as the Hodgepodge Machine [Dew90] to illustrate OSA concepts.
Reference: [FFF89] <author> Forestier, J.P., C. Fonarino, P. Franchi-Zannettacci, </author> <title> "ADA++: A Class and Inheritance Extension for Ada", Alvarez, </title> <editor> A., ed., </editor> <booktitle> Ada: the design choice Proceedings Ada-Europe International Conference, </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: Our templates have sets that store object instances. Operations to manipulate the set are a part of the templates. So, an object class in our Ada code corresponds exactly with the OSA object class concept. 1 Extensions to Ada83 requiring a pre-processor are InnovAda [SiC88], ADA++ <ref> [FFF89] </ref>, Classic Ada [SPS92], and DRAGOON [Atk91]. 2 Electronic copies are available by anonymous ftp [Ftp]. 4 Relationship sets, in OSA, are sets of relationships. Relationships are logical connections between object instances. We represent these relationships as tuples of object instances.
Reference: [Ftp] <institution> Ada Templates for OSA Implementation, </institution> <note> Anonymous FTP to osm7.cs.byu.edu in directory osa_ada/version2. </note>
Reference-contexts: So, an object class in our Ada code corresponds exactly with the OSA object class concept. 1 Extensions to Ada83 requiring a pre-processor are InnovAda [SiC88], ADA++ [FFF89], Classic Ada [SPS92], and DRAGOON [Atk91]. 2 Electronic copies are available by anonymous ftp <ref> [Ftp] </ref>. 4 Relationship sets, in OSA, are sets of relationships. Relationships are logical connections between object instances. We represent these relationships as tuples of object instances. Our templates have sets that store these relationships along with the set manipulation operations.
Reference: [MeT93] <author> Merritt, J.E., M. Troost, </author> <title> Task Rendezvous Timing on the CDC4301 Single Board Computer, </title> <type> Technical Report PX19377, </type> <institution> Unisys Government Systems, Communication Systems, </institution> <address> Salt Lake City, Utah, </address> <year> 1993. </year>
Reference-contexts: This concern should be reconsidered in light of Ada compilers that are currently available and in which considerable improvement in task operations has occurred. One study performed at Unisys Government Systems Group, Communication Systems in Salt Lake City, Utah <ref> [MeT93] </ref> shows that task switching without data occurs in 30 micro-seconds on a 25 Mhz R3000 computer using an Alsys compiler (a rather modest system by today's standards). Task switching with data of three or four words occurs in about 35 microseconds.
Reference: [Mey88] <author> Meyer, B., </author> <title> Object-Oriented Software Construction, </title> <publisher> Prentice Hall, </publisher> <year> 1988. </year>
Reference-contexts: This provides independent and concurrent operation of object instances. Thus, our Ada code maps directly to the OSA behavior concept. This task technique is similar to the methods presented by Atkinson [Atk91], Collard [Col89], and Meyer <ref> [Mey88] </ref> but has been extended for use with OSA. As a practical matter, it may be possible to remove some or all of the model concurrency when the problem being solved is not inherently concurrent. We have developed templates to allow this. <p> Task switching with data of three or four words occurs in about 35 microseconds. The time required for a task switch with a 200 byte data buffer is 65 micro-seconds. Concurrent operations with this kind of speed should be adequate for most applications. Meyer <ref> [Mey88] </ref> expresses some concern about the use of a technique such as we have described here due to "the overhead of creating a new parallel process in current operating environments." We believe that we can overcome many if not all of these overhead problems.
Reference: [SiC88] <author> Simonian, R., M. Crone, "InnovAda: </author> <title> True Object-Oriented Programming in Ada", </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> vol. 1 no. 4, </volume> <month> Nov/Dec </month> <year> 1988. </year>
Reference-contexts: Our templates have sets that store object instances. Operations to manipulate the set are a part of the templates. So, an object class in our Ada code corresponds exactly with the OSA object class concept. 1 Extensions to Ada83 requiring a pre-processor are InnovAda <ref> [SiC88] </ref>, ADA++ [FFF89], Classic Ada [SPS92], and DRAGOON [Atk91]. 2 Electronic copies are available by anonymous ftp [Ftp]. 4 Relationship sets, in OSA, are sets of relationships. Relationships are logical connections between object instances. We represent these relationships as tuples of object instances.
Reference: [SPC89] <author> Software Productivity Consortium, </author> <title> Ada Quality and Style Guidelines for Professional Programmers, </title> <publisher> Van Nostrand Reinhold, </publisher> <year> 1989. </year>
Reference-contexts: Consequently, there are no interaction routines in the Clock object class specification of Figure 6. Object-Class Package Exceptions The exceptions defined for an object class are used to notify users of the object-class package of some disastrous condition <ref> [SPC89] </ref>. The exceptions are raised only when the package has been misused or some exceptional system event has occurred such as no more space available for additions to the object-class set. Figure 4 shows the object-class package exception definitions. Associated comments describe the meaning of each exception.
Reference: [SPS92] <institution> Software Productivity Solutions, Inc. (SPS), </institution> <note> Classic-Ada User's Manual, </note> <year> 1989 1992. </year> <month> 26 </month>
Reference-contexts: Our templates have sets that store object instances. Operations to manipulate the set are a part of the templates. So, an object class in our Ada code corresponds exactly with the OSA object class concept. 1 Extensions to Ada83 requiring a pre-processor are InnovAda [SiC88], ADA++ [FFF89], Classic Ada <ref> [SPS92] </ref>, and DRAGOON [Atk91]. 2 Electronic copies are available by anonymous ftp [Ftp]. 4 Relationship sets, in OSA, are sets of relationships. Relationships are logical connections between object instances. We represent these relationships as tuples of object instances.
Reference: [Tem93] <author> Templ, S., </author> <title> "A Systematic Approach to Multiple Inheritance Implementation", </title> <journal> ACM SIGPLAN Notices, </journal> <volume> vol. 28, no. 4, </volume> <month> Apr </month> <year> 1993. </year> <month> 27 </month>
Reference-contexts: This is known as multiple inheritance. Our Ada implementation scheme does not support multiple inheritance at this time. If multiple inheritance appears in an OSA model instance a transformation to an equivalent model instance containing only single inheritance is required <ref> [Tem93] </ref>. The set packages in the object-class and relationship-set packages are based on the Booch Ada components [Boo87]. We use the set abstract data type defined by Booch except that we make it a container package and add an iterator routine to extract set elements one at a time.
References-found: 16

