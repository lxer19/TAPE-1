URL: http://www.cis.ohio-state.edu/~paolo/research/publications/cs-tr-97-32.ps
Refering-URL: http://www.cis.ohio-state.edu/~paolo/research/
Root-URL: http://www.cis.ohio-state.edu
Email: fpaolo,manig@cs.caltech.edu  
Title: A Distributed Infrastructure for Software Component Technology  
Author: Paolo A.G. Sivilotti and K. Mani Chandy 
Date: September 27, 1997  
Address: Pasadena CA, 91125  
Affiliation: California Institute of Technology  
Abstract: Software components are the building blocks for larger systems. Component implementations, however, are transient; software vendors support products over a relatively short life cycle. This paper presents an infrastructure for software components that is based on the separation of specification and implementation. The keystone of this infrastructure is a distributed, persistent component repository. This approach has two significant strengths. Firstly, it permits the laborious process of specification and reasoning to be amortized over more than the life span of a single component implementation. Secondly, it provides a uniform and universal ability both to access existing components and to publish new ones. The theoretical foundations of this infrastructure are presented as well as the engineering issues involved in its realization. 
Abstract-found: 1
Intro-found: 1
Reference: [AL92] <author> Mart in Abadi and Leslie Lamport. </author> <title> Composing specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(4) </volume> <pages> 1-60, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: The key property of this specification language is that properties are entirely local. We use certificates to specify component behavior that is true regardless of the environment in which it is placed. This is more restrictive than traditional forms of rely-guarantee specifications <ref> [AL92, Jon83, CM88] </ref> in which component behavior is predicated on the environment behaving in a particular manner. This restriction means that certificates can be verified in isolation, indepen dent of any potential environments. <p> Calcu MAX.c := SIMPLE val MAX SIMPLE val valin1 in2 v : int in1 in2 BIG' Composition SIMPLE lational program refinement from specification to an implementable specification (i.e., a program) has received considerable attention [Mor87]. Several variations on rely-guarantee specifications have been proposed for distributed systems <ref> [AL92, Jon83, CM88] </ref>. The specifications we propose place no requirement on the environment. They are most similar in nature to "exists-component" properties of [CS95]. Our use of strictly local properties in specification systems is similar to the modified rely-guarantee construct of [MS96].
Reference: [BLCGP92] <author> T.J. Berners-Lee, R. Cailliau, J-F Groff, and B. Pollermann. </author> <title> World-wide web: The information universe. </title> <journal> Electronic Networking: Research, Applications, and Policy, </journal> <volume> 1(2) </volume> <pages> 52-58, </pages> <month> Spring </month> <year> 1992. </year>
Reference-contexts: 1 Motivation Information publication and retrieval has been revolutionized by the World Wide Web <ref> [BLCGP92] </ref>. With the emergence of languages such as Java and commercial standards such as CORBA for distributed object computations, distributed systems are poised to undergo a similar revolution.
Reference: [BSP + 95] <author> B. Bershad, S. Savage, P. Pardyak, E.G. Sirer, D. Becker, M. Fiuczynski, C. Chambers, and S. Eggers. </author> <title> Extensibility, safety and performance in the SPIN operating system. </title> <booktitle> In Symposium on Operating System Principles, </booktitle> <pages> pages 267-284, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: Validation of Implementation A customer decides whether to use a particular component implementation based on the specification of that component. What assurances can be given that the implementation in fact meets the published specification? Digital signatures can be used to identify the source of the implementation <ref> [BSP + 95, Rou96] </ref>, but this simply transforms the problem into one of trust. Proof-carrying code [NL96] allows customers to validate the component byte-code with respect to safety conditions, but progress properties are beyond the ver-ification system.
Reference: [CM86] <author> K.M. Chandy and Jayadev Misra. </author> <title> How processes learn. </title> <journal> Distributed Computing, </journal> <volume> 1(1) </volume> <pages> 40-52, </pages> <year> 1986. </year>
Reference-contexts: Thus, any theorem that uses existing theorems in the repository must register such use with the theorems in question. This requirement is a result of knowledge theory <ref> [CM86] </ref>. Finding Components One of the primary limitations in the Web as an information retrieval system is the difficulty of finding information. The lack of structure is a strength to the degree it simplifies the publication process and a weakness to the degree it hampers finding published information.
Reference: [CM88] <author> K. Mani Chandy and Jayadev Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <year> 1988. </year>
Reference-contexts: The key property of this specification language is that properties are entirely local. We use certificates to specify component behavior that is true regardless of the environment in which it is placed. This is more restrictive than traditional forms of rely-guarantee specifications <ref> [AL92, Jon83, CM88] </ref> in which component behavior is predicated on the environment behaving in a particular manner. This restriction means that certificates can be verified in isolation, indepen dent of any potential environments. <p> Calcu MAX.c := SIMPLE val MAX SIMPLE val valin1 in2 v : int in1 in2 BIG' Composition SIMPLE lational program refinement from specification to an implementable specification (i.e., a program) has received considerable attention [Mor87]. Several variations on rely-guarantee specifications have been proposed for distributed systems <ref> [AL92, Jon83, CM88] </ref>. The specifications we propose place no requirement on the environment. They are most similar in nature to "exists-component" properties of [CS95]. Our use of strictly local properties in specification systems is similar to the modified rely-guarantee construct of [MS96].
Reference: [CS95] <author> K. Mani Chandy and Beverly A. Sanders. </author> <title> Predicate transformers for reasoning about concurrent computation. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 24(2) </volume> <pages> 129-148, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: For infinite computations, this is equivalent to stating that :p occurs infinitely often. These properties have been explored in [Mis95b, Mis95a] and have been shown to be sound and relatively complete <ref> [CS95] </ref>. From these fundamental properties, we derive some familiar properties: invariant, stable, and leads-to (written ; ). <p> Several variations on rely-guarantee specifications have been proposed for distributed systems [AL92, Jon83, CM88]. The specifications we propose place no requirement on the environment. They are most similar in nature to "exists-component" properties of <ref> [CS95] </ref>. Our use of strictly local properties in specification systems is similar to the modified rely-guarantee construct of [MS96]. The validation problem has been addressed in the work on proof-carrying code [NL96].
Reference: [CS97] <author> K. Mani Chandy and Paolo A.G. Sivilotti. Follows: </author> <title> A new operator for safety and progress. </title> <type> Technical report, </type> <institution> Computer Science Department, Califor-nia Institute of Technology, </institution> <year> 1997. </year>
Reference-contexts: A follows property is interesting as it captures both safety and progress properties. It can be used to succinctly express and reason about many components and systems. This property is discussed in more detail in <ref> [CS97] </ref>. We will use follows to succinctly define the channel types of our model. Channel Types The RPC target abstraction is equivalent to a message-passing abstraction consisting of a collection of virtual one-way channels between components.
Reference: [Daw91] <author> J. Dawes. </author> <title> The VDM-SL Reference Guide. </title> <publisher> Pitman/UCL Press, </publisher> <year> 1991. </year> <note> ISBN 0-273-03151-1. </note>
Reference-contexts: This property of re-placeability is critical when building a model for component software. Many formal notations exist for writing such specifications (e.g., Larch [GHG + 93, Lea96], VDM [Jon90] and VDM-SL <ref> [Daw91] </ref>, and Z [Spi92]). We propose a new language for convenience, as well as to highlight important elements. This language is designed to express the behavioral elements we consider important for commodity distributed component technology.
Reference: [FC95] <author> Ian T. Foster and K. Mani Chandy. </author> <title> Fortran M: A language for modular parallel programming. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 25(1), </volume> <month> February </month> <year> 1995. </year>
Reference-contexts: Three RPC targets, named f, g, and h are declared, along with two neighbors, A and B. Neighbor A has two RPC targets (named j and k) and neighbor B has one (named j). RPC targets are an abstraction for many communication paradigms, such as inboxes in Fortran M <ref> [FC95] </ref>, channels in PVM [GBD + 94] and MPI [SOHL + 95, GLS94], and methods in the IDL description of a CORBA object [Obj95]. Even shared-memory signaling can be modeled in this way, with appropriate channel types.
Reference: [FS97] <author> Marin Fowler and Kendall Scott. </author> <title> UML Distilled: Applying the Standard Object Modeling Language. Addison-Wesley Object Technology Series. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1997. </year>
Reference-contexts: Larch [GHG + 93, Lea96], Z [Spi92]), and TLA [Lam94], for example, have met with considerable success. More recently, notations such as UML <ref> [FS97] </ref> have arisen in the context of object-based analysis and design. All of these approaches are (either implicitly or explicitly) based on the fundamental distinction between specification and implementation. Interesting work has also been done based on the removal of this distinction.
Reference: [GBD + 94] <author> Al Geist, Adam Beguelin, Jack Dongarra, Weicheng Jiang, Robert Manchek, and Vaidy Sunderam. </author> <title> PVM: Parallel Virtual Machine A Users' Guide and Tutorial for Networked Parallel Computing. </title> <publisher> MIT Press, </publisher> <address> 55 Hayward Street, Cambridge, MA 02142-1399, </address> <year> 1994. </year>
Reference-contexts: Neighbor A has two RPC targets (named j and k) and neighbor B has one (named j). RPC targets are an abstraction for many communication paradigms, such as inboxes in Fortran M [FC95], channels in PVM <ref> [GBD + 94] </ref> and MPI [SOHL + 95, GLS94], and methods in the IDL description of a CORBA object [Obj95]. Even shared-memory signaling can be modeled in this way, with appropriate channel types.
Reference: [GHG + 93] <author> John V. Guttag, James J. Horning, S. J. Garland, K. D. Jones, A. Modet, and J. M. Wing. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1993. </year>
Reference-contexts: This property of re-placeability is critical when building a model for component software. Many formal notations exist for writing such specifications (e.g., Larch <ref> [GHG + 93, Lea96] </ref>, VDM [Jon90] and VDM-SL [Daw91], and Z [Spi92]). We propose a new language for convenience, as well as to highlight important elements. This language is designed to express the behavioral elements we consider important for commodity distributed component technology. <p> In particular, we have designed and verified a distributed auction application and distributed tree search algorithm [SC97]. 8 Related Work Much work has been done on the formal specification of software components. Larch <ref> [GHG + 93, Lea96] </ref>, Z [Spi92]), and TLA [Lam94], for example, have met with considerable success. More recently, notations such as UML [FS97] have arisen in the context of object-based analysis and design.
Reference: [GLS94] <author> William Gropp, Ewing Lusk, and An-thony Skjellum. </author> <title> Using MPI: Portable Parallel Programming with the Message-Passing Interface. </title> <publisher> MIT Press, </publisher> <address> 55 Hay-ward Street, Cambridge, MA 02142-1399, </address> <year> 1994. </year>
Reference-contexts: Neighbor A has two RPC targets (named j and k) and neighbor B has one (named j). RPC targets are an abstraction for many communication paradigms, such as inboxes in Fortran M [FC95], channels in PVM [GBD + 94] and MPI <ref> [SOHL + 95, GLS94] </ref>, and methods in the IDL description of a CORBA object [Obj95]. Even shared-memory signaling can be modeled in this way, with appropriate channel types.
Reference: [Jon83] <author> C. B. Jones. </author> <title> Tentative steps toward a development method for interfering programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(4) </volume> <pages> 596-619, </pages> <year> 1983. </year>
Reference-contexts: The key property of this specification language is that properties are entirely local. We use certificates to specify component behavior that is true regardless of the environment in which it is placed. This is more restrictive than traditional forms of rely-guarantee specifications <ref> [AL92, Jon83, CM88] </ref> in which component behavior is predicated on the environment behaving in a particular manner. This restriction means that certificates can be verified in isolation, indepen dent of any potential environments. <p> Calcu MAX.c := SIMPLE val MAX SIMPLE val valin1 in2 v : int in1 in2 BIG' Composition SIMPLE lational program refinement from specification to an implementable specification (i.e., a program) has received considerable attention [Mor87]. Several variations on rely-guarantee specifications have been proposed for distributed systems <ref> [AL92, Jon83, CM88] </ref>. The specifications we propose place no requirement on the environment. They are most similar in nature to "exists-component" properties of [CS95]. Our use of strictly local properties in specification systems is similar to the modified rely-guarantee construct of [MS96].
Reference: [Jon90] <author> Cliff B. Jones. </author> <title> Systematic Software Development Using VDM. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: This property of re-placeability is critical when building a model for component software. Many formal notations exist for writing such specifications (e.g., Larch [GHG + 93, Lea96], VDM <ref> [Jon90] </ref> and VDM-SL [Daw91], and Z [Spi92]). We propose a new language for convenience, as well as to highlight important elements. This language is designed to express the behavioral elements we consider important for commodity distributed component technology.
Reference: [Lam94] <author> Leslie Lamport. </author> <title> The temporal logic of actions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 872-923, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: In particular, we have designed and verified a distributed auction application and distributed tree search algorithm [SC97]. 8 Related Work Much work has been done on the formal specification of software components. Larch [GHG + 93, Lea96], Z [Spi92]), and TLA <ref> [Lam94] </ref>, for example, have met with considerable success. More recently, notations such as UML [FS97] have arisen in the context of object-based analysis and design. All of these approaches are (either implicitly or explicitly) based on the fundamental distinction between specification and implementation.
Reference: [Lea96] <author> Gary T. Leavens. </author> <title> An overview of Larch/C++: Behavioural specifications for C++ modules. </title> <type> Technical Report TR #96-01c, </type> <institution> Department of Computer Science, Iowa State University, 226 Atana-soff Hall, Ames, </institution> <address> Iowa 50011-1040, USA, </address> <month> February </month> <year> 1996. </year> <note> Revised January 1997. </note>
Reference-contexts: This property of re-placeability is critical when building a model for component software. Many formal notations exist for writing such specifications (e.g., Larch <ref> [GHG + 93, Lea96] </ref>, VDM [Jon90] and VDM-SL [Daw91], and Z [Spi92]). We propose a new language for convenience, as well as to highlight important elements. This language is designed to express the behavioral elements we consider important for commodity distributed component technology. <p> In particular, we have designed and verified a distributed auction application and distributed tree search algorithm [SC97]. 8 Related Work Much work has been done on the formal specification of software components. Larch <ref> [GHG + 93, Lea96] </ref>, Z [Spi92]), and TLA [Lam94], for example, have met with considerable success. More recently, notations such as UML [FS97] have arisen in the context of object-based analysis and design.
Reference: [Mis95a] <author> Jayadev Misra. </author> <title> A logic for concurrent programming: Progress. </title> <journal> Journal of Computer & Software Engineering, </journal> <volume> 3(2) </volume> <pages> 273-300, </pages> <year> 1995. </year>
Reference-contexts: For infinite computations, this is equivalent to stating that :p occurs infinitely often. These properties have been explored in <ref> [Mis95b, Mis95a] </ref> and have been shown to be sound and relatively complete [CS95]. From these fundamental properties, we derive some familiar properties: invariant, stable, and leads-to (written ; ).
Reference: [Mis95b] <author> Jayadev Misra. </author> <title> A logic for concurrent programming: Safety. </title> <journal> Journal of Computer & Software Engineering, </journal> <volume> 3(2) </volume> <pages> 239-272, </pages> <year> 1995. </year>
Reference-contexts: For infinite computations, this is equivalent to stating that :p occurs infinitely often. These properties have been explored in <ref> [Mis95b, Mis95a] </ref> and have been shown to be sound and relatively complete [CS95]. From these fundamental properties, we derive some familiar properties: invariant, stable, and leads-to (written ; ).
Reference: [Mor87] <author> Joseph M. Morris. </author> <title> A theoretical basis for stepwise refinement and the progamming calculus. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 9(3) </volume> <pages> 287-306, </pages> <year> 1987. </year>
Reference-contexts: Interesting work has also been done based on the removal of this distinction. Calcu MAX.c := SIMPLE val MAX SIMPLE val valin1 in2 v : int in1 in2 BIG' Composition SIMPLE lational program refinement from specification to an implementable specification (i.e., a program) has received considerable attention <ref> [Mor87] </ref>. Several variations on rely-guarantee specifications have been proposed for distributed systems [AL92, Jon83, CM88]. The specifications we propose place no requirement on the environment. They are most similar in nature to "exists-component" properties of [CS95].
Reference: [MS96] <author> Rajit Manohar and Paolo A.G. Sivilotti. </author> <title> Composing processes using modified rely-guarantee specifications. </title> <type> Technical Report CS-TR-96-22, </type> <institution> Computer Science Department, California Institute of Technology, </institution> <address> 256-80 Caltech, Pasadena, CA 91125, </address> <month> June 12 </month> <year> 1996. </year>
Reference-contexts: The specifications we propose place no requirement on the environment. They are most similar in nature to "exists-component" properties of [CS95]. Our use of strictly local properties in specification systems is similar to the modified rely-guarantee construct of <ref> [MS96] </ref>. The validation problem has been addressed in the work on proof-carrying code [NL96]. Our model, however, allows for the expression of progress properties which are outside the scope of proof-carrying code. 9 Conclusion Distributed software component technology is faced with many challenges.
Reference: [NL96] <author> George C. Necula and Peter Lee. </author> <title> Proof-carrying code. </title> <type> Technical Report CMU-CS-96-165, </type> <institution> Canegie Mellon University, </institution> <address> Pittsburgh, PA 15213, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: What assurances can be given that the implementation in fact meets the published specification? Digital signatures can be used to identify the source of the implementation [BSP + 95, Rou96], but this simply transforms the problem into one of trust. Proof-carrying code <ref> [NL96] </ref> allows customers to validate the component byte-code with respect to safety conditions, but progress properties are beyond the ver-ification system. <p> They are most similar in nature to "exists-component" properties of [CS95]. Our use of strictly local properties in specification systems is similar to the modified rely-guarantee construct of [MS96]. The validation problem has been addressed in the work on proof-carrying code <ref> [NL96] </ref>. Our model, however, allows for the expression of progress properties which are outside the scope of proof-carrying code. 9 Conclusion Distributed software component technology is faced with many challenges. Important issues include heterogeneity, interoperability, performance, security, maintenance, support, and pricing.
Reference: [Obj95] <author> Object Management Group. </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <month> July </month> <year> 1995. </year> <note> Revision 2.0. </note>
Reference-contexts: RPC targets are an abstraction for many communication paradigms, such as inboxes in Fortran M [FC95], channels in PVM [GBD + 94] and MPI [SOHL + 95, GLS94], and methods in the IDL description of a CORBA object <ref> [Obj95] </ref>. Even shared-memory signaling can be modeled in this way, with appropriate channel types. The RPC target abstraction permits two operations: the sending of a message by a component, and the delivery of a message by the environment.
Reference: [Par72] <author> D. L. Parnas. </author> <title> A technique for software module specification with examples. </title> <journal> Communications of the ACM, </journal> <volume> 15(5) </volume> <pages> 330-336, </pages> <month> May </month> <year> 1972. </year>
Reference-contexts: This description does not impact refinement or composition. It is simply a descriptive aid, useful in the retrieval process. 5 Specification vs. Implementation The behavior of a component is defined by that component's specification. Abstract modular specifications are the underpinning of software engineering <ref> [Par72] </ref>. Such specifications allow a system designer to select a component for inclusion in a larger application without looking at the implementation of the component and without repeating lengthy arguments of correctness with respect to this implementation [Zwi88]. An implementation is only verified to meet its specification once.
Reference: [Pou95] <author> Jeffrey S. Poulin. </author> <title> Populating software repositories: Incentives and domain-specific software. </title> <journal> Journal of Systems and Software, </journal> <volume> 30(3) </volume> <pages> 187-199, </pages> <month> September </month> <year> 1995. </year>
Reference: [Rou96] <author> F. Rouaix. </author> <title> A Web navigator with applets in Caml. </title> <booktitle> In Proceedings of the 5th International World Wide Web Conference, </booktitle> <pages> pages 1365-1371, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: Validation of Implementation A customer decides whether to use a particular component implementation based on the specification of that component. What assurances can be given that the implementation in fact meets the published specification? Digital signatures can be used to identify the source of the implementation <ref> [BSP + 95, Rou96] </ref>, but this simply transforms the problem into one of trust. Proof-carrying code [NL96] allows customers to validate the component byte-code with respect to safety conditions, but progress properties are beyond the ver-ification system.
Reference: [SC97] <author> Paolo A.G. Sivilotti and K. Mani Chandy. </author> <title> A global infrastructure for software component technology. </title> <type> Technical report, </type> <institution> Computer Science Department, California Institute of Technology, </institution> <year> 1997. </year>
Reference-contexts: The specification for this new component, BIG' is given in Figure 8. (The ASCII sequence +-&gt; is used to represent a leads-to relationship.) For a proof of this refinement relationship, see <ref> [SC97] </ref>. A composition relationship between specifications is a many-to-one relationship. As with refinement, we represent this relationship graphically with directed edges between components. An edge links a constituent component with a composition node (that describes the bindings between constituent components). An edge also links the composition node with a specification. <p> We have experimented with the use of this technique of component composition and refinement for the development of more complex systems. In particular, we have designed and verified a distributed auction application and distributed tree search algorithm <ref> [SC97] </ref>. 8 Related Work Much work has been done on the formal specification of software components. Larch [GHG + 93, Lea96], Z [Spi92]), and TLA [Lam94], for example, have met with considerable success. More recently, notations such as UML [FS97] have arisen in the context of object-based analysis and design.
Reference: [SOHL + 95] <author> Marc Snir, Steve W. Otto, Steven Huss-Lederman, David W. Walker, and Jack Dongarra. </author> <title> MPI: The Complete Reference. </title> <publisher> MIT Press, </publisher> <address> 55 Hayward Street, Cambridge, MA 02142-1399, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: Neighbor A has two RPC targets (named j and k) and neighbor B has one (named j). RPC targets are an abstraction for many communication paradigms, such as inboxes in Fortran M [FC95], channels in PVM [GBD + 94] and MPI <ref> [SOHL + 95, GLS94] </ref>, and methods in the IDL description of a CORBA object [Obj95]. Even shared-memory signaling can be modeled in this way, with appropriate channel types.
Reference: [Spi92] <author> J. Michael Spivey. </author> <title> The Z Notation: A Reference Manual. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <address> New York, NY, </address> <note> second edition, </note> <year> 1992. </year>
Reference-contexts: This property of re-placeability is critical when building a model for component software. Many formal notations exist for writing such specifications (e.g., Larch [GHG + 93, Lea96], VDM [Jon90] and VDM-SL [Daw91], and Z <ref> [Spi92] </ref>). We propose a new language for convenience, as well as to highlight important elements. This language is designed to express the behavioral elements we consider important for commodity distributed component technology. <p> In particular, we have designed and verified a distributed auction application and distributed tree search algorithm [SC97]. 8 Related Work Much work has been done on the formal specification of software components. Larch [GHG + 93, Lea96], Z <ref> [Spi92] </ref>), and TLA [Lam94], for example, have met with considerable success. More recently, notations such as UML [FS97] have arisen in the context of object-based analysis and design. All of these approaches are (either implicitly or explicitly) based on the fundamental distinction between specification and implementation.
Reference: [Zwi88] <author> J. Zwiers. </author> <title> Compositionality, Concur-rency and Partial Correctness: Proof Theories for Networks of Processes, and Their Connections. </title> <type> PhD thesis, </type> <institution> Technical University Eindhoven, </institution> <year> 1988. </year> <note> available as LNCS 321, Springer-Verlag. </note>
Reference-contexts: Abstract modular specifications are the underpinning of software engineering [Par72]. Such specifications allow a system designer to select a component for inclusion in a larger application without looking at the implementation of the component and without repeating lengthy arguments of correctness with respect to this implementation <ref> [Zwi88] </ref>. An implementation is only verified to meet its specification once. This proof is valid regardless of the context in which the component is used. This property of compositionality is critical when building large or complicated systems. The separation of specification and implementation has another, complementary, advantage.
References-found: 30

