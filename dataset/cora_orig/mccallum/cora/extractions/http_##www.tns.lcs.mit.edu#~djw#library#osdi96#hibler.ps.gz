URL: http://www.tns.lcs.mit.edu/~djw/library/osdi96/hibler.ps.gz
Refering-URL: http://www.tns.lcs.mit.edu/~djw/library/osdi96/index.html
Root-URL: 
Email: Email: office@usenix.org  
Title: Microkernels Meet Recursive Virtual Machines  
Phone: 1. Phone: 510 528-8649 2. FAX: 510 548-5738 3.  4.  
Author: Bryan Ford, Mike Hibler, Jay Lepreau, Patrick Tullmann, Godmar Back, and Stephen Clawson 
Affiliation: University of Utah  
Web: WWW URL: http://www.usenix.org  
Date: October 1996  
Note: The following paper was originally published in the Proceedings of the USENIX 2nd Symposium on Operating Systems Design and Implementation Seattle, Washington,  For more information about USENIX Association contact:  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> M. Accetta, R. Baron, W. Bolosky, D. Golub, R. Rashid, A. Teva nian, and M. Young. </author> <title> Mach: A New Kernel Foundation for UNIX Development. </title> <booktitle> In Proc. of the Summer 1986 USENIX Conf., </booktitle> <pages> pages 93-112, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Of primary interest are the following three specific aspects of this property: hierarchical resource management, state visibility, and reference relativity. 3.1.1 Hierarchical Resource Management In popular systems such as Unix, Windows NT [45], and Mach <ref> [1] </ref>, each process in the system exists independently of all other processes. A child process can outlive the parent process that created it, and retains all of its resources after its parent is destroyed (see Figure 4). <p> The Clans & Chiefs mechanism in L3 [38] provides border control directly in a microkernel environment. In most microkernels that use a capability model, such as Mach <ref> [1] </ref> and KeyKOS [6, 27], border control can be achieved through interposition. Whereas the state encapsulation property allows the parent to control state inside the boundary, border control allows the parent to control the child's view of the world outside the boundary.
Reference: [2] <author> A. Adl-Tabatabai, G. Langdale, S. Lucco, and R. Wahbe. </author> <title> Efficient and Language-Independent Mobile Programs. </title> <booktitle> In Proc. ACM SIG-PLAN Symp. on Programming Language Design and Implementation, </booktitle> <pages> pages 127-136, </pages> <month> May </month> <year> 1996. </year> <title> Nester stacks on the horizontal axis were chosen to be representative of actual usage. In each stack, `K' is the kernel's Common Protocols server, `P' is the process manager, `M' is the memory manager, `C' is the check-pointer, and `T' is the tracer. </title>
Reference-contexts: However, other processor architectures could be used just as easily, including purely emulation-based instruction sets such as Omniware <ref> [2] </ref> or Java bytecode [25]. The only restriction is that application processes must only use the subset of the instruction set that satisfies the properties described in Section 3; otherwise they may not function properly in virtualized environments.
Reference: [3] <author> A. Appel and K. Li. </author> <title> Virtual Memory Primitives for User Programs. </title> <booktitle> In Proceedings of the 4th Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 96-107, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: We configured the heap to 4MB for this test. Memtest stresses memory management and is representative of programs that first allocate memory and then repeatedly operate on it. appel2: This benchmark tests a combination of basic virtual memory primitives as identified by Appel and Li <ref> [3] </ref>. This test, known as trap+protN+unprot in the original paper, measures the time to protect 100 pages, randomly access each page, and, in the fault handler, unprotect the faulting page.
Reference: [4] <author> N. Batlivala, B. Gleeson, J. Hamrick, S. Lurndal, D. Price, and J. Soddy. </author> <title> Experience With SVR4 Over Chorus. </title> <booktitle> In Proc. of the USENIX Workshop on Micro-kernels and Other Kernel Architectures, </booktitle> <pages> pages 223-241, </pages> <address> Seattle, WA, </address> <month> Apr. </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Increasing operating system modularity and extensibility without excessively hurting performance is a topic of much ongoing research [5, 9, 18, 36, 40]. Microkernels <ref> [4, 24] </ref> attempt to decompose operating systems horizontally by moving traditional kernel functionality into servers running in user mode.
Reference: [5] <author> B. N. Bershad, S. Savage, P. Pardyak, E. G. Sirer, M. E. Fiuczyn ski, D. Becker, C. Chambers, and S. Eggers. </author> <title> Extensibility, Safety, and Performance in the SPIN Operating System. </title> <booktitle> In Proc. of the 15th ACM Symp. on Operating Systems Principles, </booktitle> <pages> pages 267-284, </pages> <address> Copper Mountain, CO, </address> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Increasing operating system modularity and extensibility without excessively hurting performance is a topic of much ongoing research <ref> [5, 9, 18, 36, 40] </ref>. Microkernels [4, 24] attempt to decompose operating systems horizontally by moving traditional kernel functionality into servers running in user mode. <p> Our work shares many of the extensibility goals of other current kernel-related research <ref> [5, 18, 46, 50] </ref>, but takes a different, often complementary, approach. For example, the Exokernel pushes the red line between the privileged kernel and unprivileged code as low as possible so that application code can gain more control over the hardware.
Reference: [6] <author> A. C. Bomberger and N. </author> <title> Hardy. </title> <booktitle> The KeyKOS Nanokernel Archi tecture. In Proc. of the USENIX Workshop on Micro-kernels and Other Kernel Architectures, </booktitle> <pages> pages 95-112, </pages> <address> Seattle, WA, </address> <month> Apr. </month> <year> 1992. </year>
Reference-contexts: Other systems support a hierarchical resource pool abstraction from which the resources used to create processes are allocated; destroying a pool destroys any sub-pools created from it as well as all processes created from these pools. For example, KeyKOS space banks <ref> [6, 27] </ref> serve this purpose, as do ledgers in OSF's MK++ [43]. <p> The Clans & Chiefs mechanism in L3 [38] provides border control directly in a microkernel environment. In most microkernels that use a capability model, such as Mach [1] and KeyKOS <ref> [6, 27] </ref>, border control can be achieved through interposition. Whereas the state encapsulation property allows the parent to control state inside the boundary, border control allows the parent to control the child's view of the world outside the boundary.
Reference: [7] <author> T. C. Bressoud and F. B. Schneider. </author> <title> Hyporvisor-based Fault tolerance. </title> <booktitle> In Proc. of the 15th ACM Symp. on Operating Systems Principles, </booktitle> <pages> pages 1-11, </pages> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: We used micro benchmarks to measure the system's performance in a variety of configurations. These measurements indicate a slowdown of about 0-35% per virtual machine layer, in contrast to conventional recursive virtual machines whose slowdown is 20%-100% <ref> [7] </ref>. Some nesters, such as the process manager, do not need to interpose on performance-critical interfaces such as memory allocation or file I/O, and hence take better advantage of the short-circuit communication facilities provided by the microkernel architecture. These nesters cause almost no slowdown at all. <p> Therefore, traditional virtual machine systems used (and needed) only shallow hierarchies, implementing all required functionality in a single hypervisor. As hardware became cheap and ubiquitous, virtual machines became less common, although they remain in use in specialized contexts such as fault tolerance <ref> [7] </ref>, and safe environments for untrusted applications [25]. In this paper we revive the idea of using virtual machine concepts pervasively throughout a system, but for the purpose of enhancing OS modularity, flexibility, and extensibility, rather than merely for hardware multiplexing. <p> A few existing operating systems, such as KeyKOS [34] and L3 [39], have implemented checkpointing on a whole-machine basis in the kernel. Similarly, a hypervisor was recently used to provide fault tolerance (replication) on a whole-machine basis on PA-RISC machines <ref> [7] </ref>. While these features appear practical and useful in some situations, they are inflexibly tied to the machine boundary and cannot easily be used on smaller scopes, such as a process or a group of processes, or on larger scopes, such as networked clusters of machines.
Reference: [8] <author> M. I. Bushnell. </author> <title> Towards a New Strategy of OS Design. </title> <booktitle> In GNU's Bulletin, </booktitle> <address> Cambridge, MA, </address> <month> Jan. </month> <year> 1994. </year> <note> Also http://www.cs.pdx.edu/-trent/gnu/hurd-paper.html. </note>
Reference-contexts: Our high-level interfaces, defined in CORBA IDL, are known as the Common Protocols because they are common to each layer in the nesting hierarchy. The Fluke Common Protocols, modeled on existing multiserver systems <ref> [8, 33] </ref>, are designed to support a POSIX-compatible environment, though many of the interfaces are generic enough to support other APIs such as Win32. Table 1 shows the currently defined interfaces and example methods for each.
Reference: [9] <author> P. Cao, E. W. Felten, and K. Li. </author> <title> Implementation and Performance of Application-Controlled File Caching. </title> <booktitle> In Proc. of the First Symp. on Operating Systems Design and Implementation, </booktitle> <pages> pages 165-177, </pages> <address> Monterey, CA, Nov. 1994. </address> <publisher> USENIX Assoc. </publisher>
Reference-contexts: 1 Introduction Increasing operating system modularity and extensibility without excessively hurting performance is a topic of much ongoing research <ref> [5, 9, 18, 36, 40] </ref>. Microkernels [4, 24] attempt to decompose operating systems horizontally by moving traditional kernel functionality into servers running in user mode.
Reference: [10] <author> J. Carter, D. Khandekar, and L. Kamb. </author> <title> Distributed Shared Mem ory: Where We Are and Where We Should Be Headed. </title> <booktitle> In Proceedings of the Fifth Workshop on Hot Topics in Operating Systems, </booktitle> <pages> pages 119-122, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: Increasing the scope of existing mechanisms: There are algorithms and software packages available for common operating systems to provide features such as distributed shared memory (DSM) <ref> [10, 32] </ref>, checkpoint-ing [11], and security against untrusted applications [52]. However, these systems only cleanly support applications running in a single logical protection domain. In a nested process model, any process can create further nested sub-processes which are completely encapsulated within the parent.
Reference: [11] <author> K. Chandy and L. Lamport. </author> <title> Distributed Snapshots: Determining Global States of Distributed Systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <month> Feb. </month> <year> 1985. </year>
Reference-contexts: Increasing the scope of existing mechanisms: There are algorithms and software packages available for common operating systems to provide features such as distributed shared memory (DSM) [10, 32], checkpoint-ing <ref> [11] </ref>, and security against untrusted applications [52]. However, these systems only cleanly support applications running in a single logical protection domain. In a nested process model, any process can create further nested sub-processes which are completely encapsulated within the parent.
Reference: [12] <author> J. S. Chase, H. M. Levy, M. J. Feeley, and E. D. Lazowska. </author> <title> Sharing and Protection in a Single Address Space Operating System. </title> <type> Technical Report UW-CSE-93-04-02, </type> <institution> University of Washington Computer Science Department, </institution> <month> Apr. </month> <year> 1993. </year>
Reference-contexts: Furthermore, there can be no hope of cloning or replicating a process within a single global identifier namespace, since the global identifiers representing all the internal objects can only refer to one object within that scope. Implementing fork () in a single-address-space system <ref> [12] </ref> is a well-known instance of this problem. 3.2 Border Control Another primary property of virtual machines is the ability of a hypervisor to monitor and control all communication across the border surrounding a virtual machine without impeding communication within the virtual machine.
Reference: [13] <author> J. B. Chen and B. N. Bershad. </author> <title> The Impact of Operating Sys tem Structure on Memory System Performance. </title> <booktitle> In Proc. of the 14th ACM Symp. on Operating Systems Principles, </booktitle> <pages> pages 120-133, </pages> <year> 1993. </year>
Reference-contexts: For example, while our checkpointer example would probably still apply, the decomposed process manager and virtual memory manager wouldn't. Because we chose the microkernel approach, our system takes the well-known microkernel performance hit <ref> [13] </ref> due to the additional decomposition and context switching overhead.
Reference: [14] <author> D. R. Cheriton and K. J. Duda. </author> <title> A Caching Model of Operating Sys tem Kernel Functionality. </title> <booktitle> In Proc. of the First Symp. on Operating Systems Design and Implementation, </booktitle> <pages> pages 179-193. </pages> <publisher> USENIX As-soc., </publisher> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: Same-architecture hypervisors that delegate to the base processor the job of executing unprivileged instructions depend on the processor to reveal the child's full register state through trap frames or shadow registers. With notable exceptions such as the Cache Kernel <ref> [14] </ref> and Amoeba [47], most operating systems are not as good about making a child process's state visible to its parent. <p> This mechanism is similar to the kernel object caching mechanism in the Cache Kernel <ref> [14] </ref>, except that our mechanism does not impose ordering restrictions on manipulating kernel objects.
Reference: [15] <author> G. Deconinck, J. Vounckx, R. Cuyvers, and R. Lauwereins. </author> <title> Sur vey of Checkpointing and Rollback Techniques. </title> <institution> Technical Report O3.1.8 and O3.1.12, ESAT-ACCA Laboratory Katholieke Univer-siteit Leuven, Belgium, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: This algorithm, of course, will not scale well to large applications or distributed environments. However, more efficient checkpointers based on well-known single-process algorithms <ref> [15, 17] </ref> could be implemented in our environment in the same way, and should also work automatically over multi-process domains.
Reference: [16] <author> R. P. Draves. </author> <title> A Revised IPC Interface. </title> <booktitle> In Proc. of the USENIX Mach Workshop, </booktitle> <pages> pages 101-121, </pages> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: This technique of adjusting user-level registers to reflect kernel state transitions is used throughout Fluke to provide full kernel state exportability without reducing efficiency by breaking up all system calls into minimal atomic units. The Mach IPC system <ref> [16] </ref> uses a similar technique, except that user code must explicitly check for interruption after every IPC operation and restart it manually if necessary.
Reference: [17] <author> E. N. Elnozahy, D. B. Johnson, and W. Zwaenepoel. </author> <title> The Perfor mance of Consistent Checkpointing. </title> <booktitle> In 11th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 39-47, </pages> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: This algorithm, of course, will not scale well to large applications or distributed environments. However, more efficient checkpointers based on well-known single-process algorithms <ref> [15, 17] </ref> could be implemented in our environment in the same way, and should also work automatically over multi-process domains.
Reference: [18] <author> D. R. Engler, M. F. Kaashoek, and J. O'Toole Jr. Exokernel: </author> <title> An Operating System Architecture for Application-level Resource Management. </title> <booktitle> In Proc. of the 15th ACM Symp. on Operating Systems Principles, </booktitle> <pages> pages 251-266, </pages> <address> Copper Mountain, CO, </address> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Increasing operating system modularity and extensibility without excessively hurting performance is a topic of much ongoing research <ref> [5, 9, 18, 36, 40] </ref>. Microkernels [4, 24] attempt to decompose operating systems horizontally by moving traditional kernel functionality into servers running in user mode. <p> Our work shares many of the extensibility goals of other current kernel-related research <ref> [5, 18, 46, 50] </ref>, but takes a different, often complementary, approach. For example, the Exokernel pushes the red line between the privileged kernel and unprivileged code as low as possible so that application code can gain more control over the hardware.
Reference: [19] <author> B. </author> <title> Ford and Flux Project Members. The Flux Operating System Toolkit. </title> <institution> University of Utah. </institution> <note> Postscript and HTML available under http://www.cs.utah.edu/projects/flux/oskit/html/, 1996. </note>
Reference-contexts: The initial implementation was designed primarily with portability, readability, and flexibility in mind rather than maximum performance; it is written mostly in machine-independent C and relies heavily on generic facilities provided by the Flux OS Toolkit <ref> [19] </ref>. The prototype supports kernel pre-emptibility, full multiprocessor locking, and can be configured to run under either an interrupt or process model. The kernel currently contains built-in console, serial, clock, disk, and network drivers, although it is designed to support out-of-kernel drivers in the future.
Reference: [20] <author> B. Ford, M. Hibler, </author> <title> and Flux Project Members. Fluke: Flexi ble -kernel Environment (draft documents). </title> <institution> University of Utah. </institution> <note> Postscript and HTML available under http://www.cs.utah.edu/-projects/flux/fluke/html/, 1996. </note>
Reference-contexts: Figure 7 shows a sample of the Fluke microkernel API <ref> [20] </ref>. 4.2.1 Address Spaces The Fluke kernel supports an arbitrary number of address spaces, much like stripped-down Unix processes or Mach tasks; multiple threads can run in each address space. Unlike most operating systems, address spaces in Fluke are defined relative to other spaces.
Reference: [21] <author> B. Ford and S. Susarla. </author> <title> CPU Inheritance Scheduling. </title> <booktitle> In Proc. of the Second Symp. on Operating Systems Design and Implementation, </booktitle> <address> Seattle, WA, Oct. 1996. </address> <publisher> USENIX Assoc. </publisher>
Reference-contexts: The scheduling hierarchy usually corresponds to the nested process hierarchy, but is not required to do so. Our scheduling model, which has been prototyped and tested in user space but not yet as part of the Fluke kernel, is detailed in a companion paper <ref> [21] </ref>. However, only its relative, hierarchical nature is important to the nested process architecture.
Reference: [22] <author> R. P. Goldberg. </author> <title> Architecture of Virtual Machines. </title> <booktitle> In AFIPS Conf. Proc., </booktitle> <month> June </month> <year> 1973. </year>
Reference-contexts: For example, the most well-known virtual machine system, VM/370 [28, 29], provides virtual memory and security between multiple concurrent virtual machines, all exporting the IBM S/370 hardware architecture. Furthermore, special virtualizable hardware architectures <ref> [22, 35] </ref> have been proposed, whose design goal is to allow virtual machines to be stacked much more efficiently. This paper presents a new approach to OS extensibility which combines both microkernel and virtual machine concepts in one system. <p> This memory remapping mechanism is similar to that of L4 [40], Grasshopper [41], and the f-maps in virtual machine systems <ref> [22, 23] </ref>. Our architecture uses this mechanism to provide the state containment and state visibility properties described in Section 3.
Reference: [23] <author> R. P. Goldberg. </author> <title> Survey of Virtual Machine Reseach. </title> <journal> IEEE Com puter Magazine, </journal> <pages> pages 34-45, </pages> <month> June </month> <year> 1974. </year>
Reference-contexts: 1 Introduction Increasing operating system modularity and extensibility without excessively hurting performance is a topic of much ongoing research [5, 9, 18, 36, 40]. Microkernels [4, 24] attempt to decompose operating systems horizontally by moving traditional kernel functionality into servers running in user mode. Recursive virtual machines <ref> [23] </ref>, on the other hand, allow operating systems to be decomposed This research was supported in part by the Defense Advanced Research Projects Agency, monitored by the Department of the Army, under contract number DABT63-94-C-0058. <p> Since the upper and lower interfaces of a hypervisor are the same, a sufficiently complete hypervisor can even run additional copies of itself, recursively. Virtual machines have been used for a variety of purposes including security, fault tolerance, and operating system software development <ref> [23] </ref>. In their heyday, virtual machine systems were not driven by modularity issues at all, but instead were created to make better use of scarce, expensive hardware resources. <p> This memory remapping mechanism is similar to that of L4 [40], Grasshopper [41], and the f-maps in virtual machine systems <ref> [22, 23] </ref>. Our architecture uses this mechanism to provide the state containment and state visibility properties described in Section 3.
Reference: [24] <author> D. Golub, R. Dean, A. Forin, and R. Rashid. </author> <title> Unix as an Application Program. </title> <booktitle> In Proc. of the Summer 1990 USENIX Conf., </booktitle> <pages> pages 87-96, </pages> <address> Anaheim, CA, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Increasing operating system modularity and extensibility without excessively hurting performance is a topic of much ongoing research [5, 9, 18, 36, 40]. Microkernels <ref> [4, 24] </ref> attempt to decompose operating systems horizontally by moving traditional kernel functionality into servers running in user mode.
Reference: [25] <author> J. Gosling and H. McGilton. </author> <title> The Java Language Environ ment: A White Paper. </title> <type> Technical report, </type> <institution> Sun Microsystems Computer Company, </institution> <year> 1996. </year> <note> Available as http://java.sun.com/doc/-language environment/. </note>
Reference-contexts: We describe related work concerning the details of our design later, in the appropriate sections. 2.1 Traditional Virtual Machines A virtual machine simulator, such as the Java interpreter <ref> [25] </ref>, is a program that runs on one hardware architecture and implements in software a virtual machine conforming to a completely different architecture. <p> Therefore, traditional virtual machine systems used (and needed) only shallow hierarchies, implementing all required functionality in a single hypervisor. As hardware became cheap and ubiquitous, virtual machines became less common, although they remain in use in specialized contexts such as fault tolerance [7], and safe environments for untrusted applications <ref> [25] </ref>. In this paper we revive the idea of using virtual machine concepts pervasively throughout a system, but for the purpose of enhancing OS modularity, flexibility, and extensibility, rather than merely for hardware multiplexing. For these purposes, virtual machines based on hardware architectures have several drawbacks. <p> However, other processor architectures could be used just as easily, including purely emulation-based instruction sets such as Omniware [2] or Java bytecode <ref> [25] </ref>. The only restriction is that application processes must only use the subset of the instruction set that satisfies the properties described in Section 3; otherwise they may not function properly in virtualized environments.
Reference: [26] <author> P. Goyal, X. Guo, and H. M. Vin. </author> <title> A Hierarchical CPU Scheduler For Multimedia Operations. </title> <booktitle> In Proc. of the Second Symp. on Operating Systems Design and Implementation, </booktitle> <address> Seattle, WA, Oct. 1996. </address> <publisher> USENIX Assoc. </publisher>
Reference-contexts: However, only its relative, hierarchical nature is important to the nested process architecture. Other hierarchical schedulers should also work, such as the meter system in KeyKOS [27], lot-tery/stride scheduling [53], and SFQ scheduling <ref> [26] </ref>. 4.3 High-level Protocols While our low-level IPC mechanism provides primitive capability-based communication channels, a higher level protocol defines the conventions for communication over these channels.
Reference: [27] <author> N. </author> <title> Hardy. </title> <booktitle> The KeyKos Architecture. Operating Systems Review, </booktitle> <month> Sept. </month> <year> 1985. </year>
Reference-contexts: Other systems support a hierarchical resource pool abstraction from which the resources used to create processes are allocated; destroying a pool destroys any sub-pools created from it as well as all processes created from these pools. For example, KeyKOS space banks <ref> [6, 27] </ref> serve this purpose, as do ledgers in OSF's MK++ [43]. <p> The Clans & Chiefs mechanism in L3 [38] provides border control directly in a microkernel environment. In most microkernels that use a capability model, such as Mach [1] and KeyKOS <ref> [6, 27] </ref>, border control can be achieved through interposition. Whereas the state encapsulation property allows the parent to control state inside the boundary, border control allows the parent to control the child's view of the world outside the boundary. <p> However, only its relative, hierarchical nature is important to the nested process architecture. Other hierarchical schedulers should also work, such as the meter system in KeyKOS <ref> [27] </ref>, lot-tery/stride scheduling [53], and SFQ scheduling [26]. 4.3 High-level Protocols While our low-level IPC mechanism provides primitive capability-based communication channels, a higher level protocol defines the conventions for communication over these channels.
Reference: [28] <institution> IBM Virtual Machine Facility /370 Planning Guide. Technical Re port GC20-1801-0, IBM Corporation, </institution> <year> 1972. </year>
Reference-contexts: Traditionally, virtual machines have been implemented on and export existing hardware architectures so they can support naive operating systems (see Figure 1). For example, the most well-known virtual machine system, VM/370 <ref> [28, 29] </ref>, provides virtual memory and security between multiple concurrent virtual machines, all exporting the IBM S/370 hardware architecture. Furthermore, special virtualizable hardware architectures [22, 35] have been proposed, whose design goal is to allow virtual machines to be stacked much more efficiently. <p> In contrast, a virtual machine monitor or hypervisor, such as VM/370 <ref> [28, 29] </ref>, is a program that creates one or more virtual machines exporting the same hardware architecture as the machine it runs on.
Reference: [29] <institution> IBM Virtual Machine Facility /370: </institution> <note> Release 2 Planning Guide. Technical Report GC20-1814-0, </note> <institution> IBM Corporation, </institution> <year> 1973. </year>
Reference-contexts: Traditionally, virtual machines have been implemented on and export existing hardware architectures so they can support naive operating systems (see Figure 1). For example, the most well-known virtual machine system, VM/370 <ref> [28, 29] </ref>, provides virtual memory and security between multiple concurrent virtual machines, all exporting the IBM S/370 hardware architecture. Furthermore, special virtualizable hardware architectures [22, 35] have been proposed, whose design goal is to allow virtual machines to be stacked much more efficiently. <p> In contrast, a virtual machine monitor or hypervisor, such as VM/370 <ref> [28, 29] </ref>, is a program that creates one or more virtual machines exporting the same hardware architecture as the machine it runs on.
Reference: [30] <author> Intel. </author> <title> i960 Extended Architecture Programmer's Reference Man ual, </title> <year> 1994. </year>
Reference-contexts: All active kernel objects are logically associated with, or attached to, a small chunk of physical memory; this is reminiscent of tagged processor architectures such as System 38 [37] and the Intel i960XA <ref> [30] </ref>. A process can invoke kernel operations on kernel objects residing on pages mapped into its address space by specifying the virtual address of the object as a parameter to the appropriate system call.
Reference: [31] <author> M. Jones. </author> <title> Interposition Agents: Transparently Interposing User Code at the System Interface. </title> <booktitle> In Proc. of the 14th ACM Symp. on Operating Systems Principles, </booktitle> <pages> pages 80-93, </pages> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: This form of interposition can be used, for example, to trace system calls or change the process's view of the file system <ref> [31, 33] </ref>, or to provide security against an untrusted application [52]. However, these mechanisms can only be applied easily to a single application process and generally cannot be used in combination (only one interposition module can be used on a given process).
Reference: [32] <author> P. Keleher, A. L. Cox, S. Dwarkadas, and W. Zwaenepoel. Tread Marks: </author> <title> Distributed Shared Memory on Standard Workstations and Operating Systems. </title> <booktitle> In Proc. of the 1994 Winter USENIX Conf., </booktitle> <pages> pages 115-132, </pages> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: Increasing the scope of existing mechanisms: There are algorithms and software packages available for common operating systems to provide features such as distributed shared memory (DSM) <ref> [10, 32] </ref>, checkpoint-ing [11], and security against untrusted applications [52]. However, these systems only cleanly support applications running in a single logical protection domain. In a nested process model, any process can create further nested sub-processes which are completely encapsulated within the parent.
Reference: [33] <author> Y. A. Khalidi and M. N. Nelson. </author> <title> Extensible File Systems in Spring. </title> <booktitle> In Proc. of the 14th ACM Symp. on Operating Systems Principles, </booktitle> <pages> pages 1-14, </pages> <year> 1993. </year>
Reference-contexts: This form of interposition can be used, for example, to trace system calls or change the process's view of the file system <ref> [31, 33] </ref>, or to provide security against an untrusted application [52]. However, these mechanisms can only be applied easily to a single application process and generally cannot be used in combination (only one interposition module can be used on a given process). <p> Our high-level interfaces, defined in CORBA IDL, are known as the Common Protocols because they are common to each layer in the nesting hierarchy. The Fluke Common Protocols, modeled on existing multiserver systems <ref> [8, 33] </ref>, are designed to support a POSIX-compatible environment, though many of the interfaces are generic enough to support other APIs such as Win32. Table 1 shows the currently defined interfaces and example methods for each.
Reference: [34] <author> C. Landau. </author> <title> The Checkpoint Mechanism in KeyKOS. </title> <booktitle> In Proc. Second International Workshop on Object Orientation in Operating Systems, </booktitle> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: There is a large body of work on checkpointers both in and out of the kernel. A few existing operating systems, such as KeyKOS <ref> [34] </ref> and L3 [39], have implemented checkpointing on a whole-machine basis in the kernel. Similarly, a hypervisor was recently used to provide fault tolerance (replication) on a whole-machine basis on PA-RISC machines [7].
Reference: [35] <author> H. C. Lauer and D. Wyeth. </author> <title> A Recursive Virtual Machine Architec ture. </title> <booktitle> In ACM SIGARCH-SIGOPS Workshop on Virtual Computer Systems, </booktitle> <pages> pages 113-116, </pages> <month> Mar. </month> <year> 1973. </year>
Reference-contexts: For example, the most well-known virtual machine system, VM/370 [28, 29], provides virtual memory and security between multiple concurrent virtual machines, all exporting the IBM S/370 hardware architecture. Furthermore, special virtualizable hardware architectures <ref> [22, 35] </ref> have been proposed, whose design goal is to allow virtual machines to be stacked much more efficiently. This paper presents a new approach to OS extensibility which combines both microkernel and virtual machine concepts in one system.
Reference: [36] <author> C. H. Lee, M. C. Chen, and R. C. Chang. </author> <title> HiPEC: High Perfor mance External Virtual Memory Caching. </title> <booktitle> In Proc. of the First Symp. on Operating Systems Design and Implementation, </booktitle> <pages> pages 153-164, </pages> <address> Monterey, CA, Nov. 1994. </address> <publisher> USENIX Assoc. </publisher>
Reference-contexts: 1 Introduction Increasing operating system modularity and extensibility without excessively hurting performance is a topic of much ongoing research <ref> [5, 9, 18, 36, 40] </ref>. Microkernels [4, 24] attempt to decompose operating systems horizontally by moving traditional kernel functionality into servers running in user mode.
Reference: [37] <author> H. M. Levy. </author> <title> Capability Based Computer Systems. </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: All active kernel objects are logically associated with, or attached to, a small chunk of physical memory; this is reminiscent of tagged processor architectures such as System 38 <ref> [37] </ref> and the Intel i960XA [30]. A process can invoke kernel operations on kernel objects residing on pages mapped into its address space by specifying the virtual address of the object as a parameter to the appropriate system call. <p> Also, various other Mach system calls are not cleanly interruptible at all and therefore do not support full state visibility. 4.2.4 Capabilities All references between low-level objects in Fluke are represented as kernel-mediated capabilities <ref> [37] </ref>. Each primitive object type contains a number of capability slots. For example, each thread object contains an address space slot, which refers to the address space in which the thread is to run.
Reference: [38] <editor> J. Liedtke. Clans and Chiefs. </editor> <booktitle> In Proc. </booktitle> <volume> 12. </volume> <editor> GI/ITG-Fachtagung Ar chitektur von Rechensystemen, </editor> <year> 1992. </year>
Reference-contexts: Barring shared memory channels, the only way for virtual machines to communicate with each other is to trap into the hypervisor, which can handle the request however it chooses. The Clans & Chiefs mechanism in L3 <ref> [38] </ref> provides border control directly in a microkernel environment. In most microkernels that use a capability model, such as Mach [1] and KeyKOS [6, 27], border control can be achieved through interposition. <p> For example, a nester that interposes on file system-related operations does not also need to intercept messages to other external services. This contrasts with L3's Clans & Chiefs model <ref> [38] </ref>, where interposition is all or nothing: if a parent wants to intercept any communication transparently, it must intercept all communication. 4.2.5 Scheduling The final type of resource with which the Fluke kernel deals directly is CPU time.
Reference: [39] <author> J. Liedtke. </author> <title> A Persistent System in Real Use Experiences of the First 13 Years. </title> <booktitle> In Proc. of the Third International Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 2-11, </pages> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: Some operating systems, such as L3 <ref> [39] </ref>, directly support a hierarchical virtual machine-like process model in which a parent process can destroy a child process and be assured that all of the child's descendants will also go away and their resources will be freed. <p> There is a large body of work on checkpointers both in and out of the kernel. A few existing operating systems, such as KeyKOS [34] and L3 <ref> [39] </ref>, have implemented checkpointing on a whole-machine basis in the kernel. Similarly, a hypervisor was recently used to provide fault tolerance (replication) on a whole-machine basis on PA-RISC machines [7].
Reference: [40] <author> J. Liedtke. </author> <title> On Micro-Kernel Construction. </title> <booktitle> In Proc. of the 15th ACM Symp. on Operating Systems Principles, </booktitle> <pages> pages 237-250, </pages> <address> Copper Mountain, CO, </address> <month> Dec. </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Increasing operating system modularity and extensibility without excessively hurting performance is a topic of much ongoing research <ref> [5, 9, 18, 36, 40] </ref>. Microkernels [4, 24] attempt to decompose operating systems horizontally by moving traditional kernel functionality into servers running in user mode. <p> This memory remapping mechanism is similar to that of L4 <ref> [40] </ref>, Grasshopper [41], and the f-maps in virtual machine systems [22, 23]. Our architecture uses this mechanism to provide the state containment and state visibility properties described in Section 3.
Reference: [41] <author> A. Lindstrom, J. Rosenberg, and A. Dearle. </author> <title> The Grand Unified Theory of Address Spaces. </title> <booktitle> In Proc. of the Fifth Workshop on Hot Topics in Operating Systems, </booktitle> <month> May </month> <year> 1995. </year>
Reference-contexts: This memory remapping mechanism is similar to that of L4 [40], Grasshopper <ref> [41] </ref>, and the f-maps in virtual machine systems [22, 23]. Our architecture uses this mechanism to provide the state containment and state visibility properties described in Section 3.
Reference: [42] <author> M. Litzkow and M. Solomon. </author> <title> Supporting Checkpointing and Pro cess Migration Outside the UNIX Kernel. </title> <booktitle> In Proc. of the Winter 1992 USENIX Conf., </booktitle> <year> 1992. </year>
Reference-contexts: Additionally, the border control provided by the capability model allows the checkpointer to interpose on whichever interfaces it needs to; our implementation interposes on only those things necessary for a minimal complete checkpoint, comparable to the functionality offered by other user-level checkpointers <ref> [42, 48] </ref>. There is a large body of work on checkpointers both in and out of the kernel. A few existing operating systems, such as KeyKOS [34] and L3 [39], have implemented checkpointing on a whole-machine basis in the kernel.
Reference: [43] <author> K. Loepere et al. </author> <title> MK++ Kernel Executive Summary. </title> <type> Technical report, </type> <institution> Open Software Foundation, </institution> <year> 1995. </year>
Reference-contexts: For example, KeyKOS space banks [6, 27] serve this purpose, as do ledgers in OSF's MK++ <ref> [43] </ref>. This hierarchical resource management property is a critical prerequisite for many of the applications described in this paper; without it, a parent process cannot even identify all of the state representing a child process subtree, let alone manage it coherently.
Reference: [44] <author> L. McVoy and C. Staelin. lmbench: </author> <title> Portable Tools for Performance Analysis. </title> <booktitle> In Proc. of 1996 USENIX Conf., </booktitle> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: Forktest creates a parent-child chain four levels deep; each level performs a simple computation and then returns the result in its exit status. readtest: This test is similar to the lmbench <ref> [44] </ref> bw file read test. It reads an 8MB file in 8KB chunks accessing every word of the buffer after each read. It is intended to discover the best-case file caching capability of the operating system. matconn: The final benchmark is a computationally intensive application.
Reference: [45] <author> Microsoft Corporation. </author> <title> Win32 Programmer's Reference, </title> <booktitle> 1993. </booktitle> <pages> 999 pp. </pages>
Reference-contexts: Of primary interest are the following three specific aspects of this property: hierarchical resource management, state visibility, and reference relativity. 3.1.1 Hierarchical Resource Management In popular systems such as Unix, Windows NT <ref> [45] </ref>, and Mach [1], each process in the system exists independently of all other processes. A child process can outlive the parent process that created it, and retains all of its resources after its parent is destroyed (see Figure 4).
Reference: [46] <author> A. B. Montz, D. Mosberger, S. W. O'Malley, L. L. Peterson, T. A. Proebsting, and J. H. Hartman. </author> <title> Scout: A Communications-oriented Operating System. </title> <type> Technical Report 94-20, </type> <institution> University of Arizona, Dept. of Computer Science, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: Our work shares many of the extensibility goals of other current kernel-related research <ref> [5, 18, 46, 50] </ref>, but takes a different, often complementary, approach. For example, the Exokernel pushes the red line between the privileged kernel and unprivileged code as low as possible so that application code can gain more control over the hardware.
Reference: [47] <author> S. J. Mullender. </author> <title> Experiences with Distributed Systems, chapter Process Management in Distributed Operating Systems. </title> <booktitle> Lecture Notes in Computer Science no. </booktitle> <volume> 309. </volume> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Same-architecture hypervisors that delegate to the base processor the job of executing unprivileged instructions depend on the processor to reveal the child's full register state through trap frames or shadow registers. With notable exceptions such as the Cache Kernel [14] and Amoeba <ref> [47] </ref>, most operating systems are not as good about making a child process's state visible to its parent.
Reference: [48] <author> J. S. Plank, M. Beck, G. Kingsley, and K. Li. Libckpt: </author> <title> Transparent Checkpointing under Unix. </title> <booktitle> In Proc. of the Winter 1995 USENIX Technical Conf., </booktitle> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: Additionally, the border control provided by the capability model allows the checkpointer to interpose on whichever interfaces it needs to; our implementation interposes on only those things necessary for a minimal complete checkpoint, comparable to the functionality offered by other user-level checkpointers <ref> [42, 48] </ref>. There is a large body of work on checkpointers both in and out of the kernel. A few existing operating systems, such as KeyKOS [34] and L3 [39], have implemented checkpointing on a whole-machine basis in the kernel.
Reference: [49] <author> M. Rosenblum, S. Herrod, E. Witchel, and A. Gupta. </author> <title> Fast and Ac curate Multiprocessor Simulation: The SimOS Approach. </title> <journal> IEEE Parallel and Distributed Technology, </journal> <volume> 3(4), </volume> <year> 1995. </year>
Reference-contexts: For our purposes, a pure virtual machine system is one in which each layer completely simulates the environment of the next higher layer, including all instructions, memory accesses, and device I/O <ref> [49] </ref>. Our work hinges on two primary properties of such systems: state encapsulation and border control.
Reference: [50] <author> C. Small and M. Seltzer. VINO: </author> <title> An Intergrated Platform for Oper ating System and Database Research. </title> <type> Technical Report TR-30-94, </type> <institution> Harvard University, </institution> <year> 1994. </year>
Reference-contexts: Our work shares many of the extensibility goals of other current kernel-related research <ref> [5, 18, 46, 50] </ref>, but takes a different, often complementary, approach. For example, the Exokernel pushes the red line between the privileged kernel and unprivileged code as low as possible so that application code can gain more control over the hardware.
Reference: [51] <author> P. Tullmann, J. Lepreau, B. Ford, and M. Hibler. </author> <title> User-level Check pointing Through Exportable Kernel State. </title> <booktitle> In Proc. Fifth International Workshopon Object Orientation in Operating Systems, </booktitle> <address> Seat-tle, WA, </address> <month> Oct. </month> <year> 1996. </year> <note> IEEE. </note>
Reference-contexts: In addition, there are system calls that a process can use to determine the location of all kernel objects within a given range of its own virtual address space, as well as system calls to examine and modify the state of these objects <ref> [51] </ref>. This kernel object design, coupled with the address space remapping mechanism described above, provides the state containment and state visibility properties for kernel object state as well as plain data, allowing parent pro cesses to identify and gain access to all of the vital state comprising a child process.
Reference: [52] <author> D. Wagner, I. Goldberg, and R. Thomas. </author> <title> A Secure Environment for Untrusted Helper Applications. </title> <booktitle> In Proc. of the 6th USENIX Unix Security Symp., </booktitle> <year> 1996. </year>
Reference-contexts: Increasing the scope of existing mechanisms: There are algorithms and software packages available for common operating systems to provide features such as distributed shared memory (DSM) [10, 32], checkpoint-ing [11], and security against untrusted applications <ref> [52] </ref>. However, these systems only cleanly support applications running in a single logical protection domain. In a nested process model, any process can create further nested sub-processes which are completely encapsulated within the parent. <p> This form of interposition can be used, for example, to trace system calls or change the process's view of the file system [31, 33], or to provide security against an untrusted application <ref> [52] </ref>. However, these mechanisms can only be applied easily to a single application process and generally cannot be used in combination (only one interposition module can be used on a given process).
Reference: [53] <author> C. A. Waldspurger. </author> <title> Lottery and Stride Scheduling: Flexible Proportional-Share Resource Management. </title> <type> PhD thesis, </type> <institution> Mas-sachusetts Institute of Technology, </institution> <month> Sept. </month> <year> 1995. </year>
Reference-contexts: However, only its relative, hierarchical nature is important to the nested process architecture. Other hierarchical schedulers should also work, such as the meter system in KeyKOS [27], lot-tery/stride scheduling <ref> [53] </ref>, and SFQ scheduling [26]. 4.3 High-level Protocols While our low-level IPC mechanism provides primitive capability-based communication channels, a higher level protocol defines the conventions for communication over these channels.
Reference: [54] <author> M. V. Wilkes and R. M. Needham. </author> <title> The Cambridge CAP Computer and its Operating System. </title> <publisher> North Holland, </publisher> <address> NY, </address> <year> 1979. </year>
Reference-contexts: The resulting architecture is similar to conventional process models such as Unix's, though with some important differences to make processes recursively virtualizable or nestable; hence the term nested process architecture. The Cambridge CAP computer <ref> [54] </ref> implemented a similar high-level architecture in microcode supporting an arbitrarily deep process hierarchy in which parent processes virtualize memory, CPU, and trap handlers for child processes. <p> Since only the kernel can access the actual contents of a capability, capabilities can be passed freely between arbitrary processes in our system, allowing communication to short-circuit the process hierarchy when appropriate. This contrasts with CAP <ref> [54] </ref>, where capabilities are used only for communication within a process and all interprocess communication is strictly parent-child and based on traps.
References-found: 54

