URL: http://choices.cs.uiuc.edu/sefika/oopsla-96.ps.Z
Refering-URL: http://choices.cs.uiuc.edu/Papers.html
Root-URL: http://www.cs.uiuc.edu
Email: email: fsefika,sane,royg@cs.uiuc.edu  
Title: Architecture-Oriented Visualization  
Author: Mohlalefi Sefika Aamod Sane Roy H. Campbell 
Web: www: http://choices.cs.uiuc.edu  
Address: 1304 W. Springfield Avenue, Urbana, IL 61801  
Affiliation: University of Illinois at Urbana-Champaign Department of Computer Science  
Note: Accepted at OOPSLA-96  Supported by Lesotho AFGRAAD Fellowship. Supported by CNRI contract CNRI GIGABIT/UILL.  
Abstract: Tracking the changing dynamics of object-oriented frameworks[5], design patterns[7], architectural styles[8], and subsystems during the development and reuse cycle can aid producing complex systems. Unfortunately, current object-oriented programming tools are relatively oblivious to the rich architectural abstractions in a system. This paper shows that architecture-oriented visualization, the presentation of system dynamics in terms of its architectural abstractions, is highly beneficial in designing complex systems. In addition, the paper presents architecture-aware instrumentation, a new technique for building efficient on-line instrumentation to support architectural queries. We demonstrate the effectiveness and performance of the scheme with case studies in the design of the Choices object-oriented operating system. PageCount: 17 pages without figures and references Category: Research Topic Area: dynamic program analysis; instrumentation, reuse, components and frameworks; software architecture and design patterns Copyright: Permission to make digital/hard copy of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage, the copyright notice, the title of the publication and its date appear, and notice is given that copying is by permission of 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers, Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1986. </year>
Reference: [2] <author> Marla J. Baker and Stephen G. Eick. </author> <title> Visualizing Software Systems. </title> <booktitle> In Proceedings of the 16th International Conference on Software Engineering, </booktitle> <pages> pages 59-67, </pages> <year> 1994. </year>
Reference-contexts: We select the VM bar from Figure 1 to get the space-filling diagram <ref> [2] </ref> of Figure 2. The diagram depicts the virtual memory subsystem frameworks and their class hierarchy components, with filled rectangles indicating the relative number of processes blocked. The class hierarchies are represented by rectangles whose size is proportional to the number of classes in the corresponding hierarchy.
Reference: [3] <author> Grady Booch. </author> <title> Object-Oriented Analysis and Design With Applications . The Benjamin/Cummings Publishing Company, </title> <publisher> Inc., </publisher> <year> 1994. </year>
Reference-contexts: For the most part, the framework and the subsystem appear to be cohesive: intra-component interaction is much greater than inter-component interaction. However, Disk and RpcBuffer exbibit anomalous, heavy communication. * Class Interactions: To understand the unusual interaction, we click on the thick arrow, generating the Object Interaction Diagram <ref> [3] </ref> of Figure 6. The diagram statistics indicates that the method getState () is called with high frequency. Code inspection revealed that getState () was initially used for debugging RPC data buffering to and from disk (for example, for long-lived client/server connections exchanging very large data).
Reference: [4] <author> R. H. Campbell, N. Islam, D. Raila, and P. Madany. </author> <title> Designing and Implementing Choices: An Object-Oriented System in C++. </title> <journal> Communications of the ACM, </journal> <pages> pages 117-126, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: Recent research [5, 7, 9] demonstrates the value of gross architectural structures in promoting design and implementation reuse for understanding and building complex systems. In our own studies of the customization of the Choices <ref> [4] </ref> object-oriented operating system, we often needed answers to questions like: * How many times does this application process visit the file system? * Is this lock currently in use by any subframework of the virtual memory system? * Which subframework of the virtual memory system communicates most frequently with the <p> In ProgramExplorer, the data is collected into a Prolog database. In ObjectVisualizer, multi-level hash tables organize the data, supporting data accumulation, albeit only on a per-method basis. Structured instruments were exploited in a limited manner in the Choices operating system <ref> [4] </ref>. Madany uses objectified C++ classes, called first-class Classes, to examine the run-time structure and behavior of the operating system. Classes provide run-time type information, enabling the querying of class inheritance and class instance 20 relations among objects. Instruments that are related by inheritance can be controlled in groups dynamically.
Reference: [5] <author> L. Peter Deutsch. </author> <title> Design Reuse and Frameworks in the Smalltalk-80 Programming System. </title> <editor> In Ted J. Biggerstaff and Alan J. Perlis, editors, </editor> <booktitle> Software Reusability, </booktitle> <volume> volume II, </volume> <pages> pages 55-71. </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction Designers conceive complex systems as architectures with design patterns [7], frameworks <ref> [5] </ref>, architectural styles [8], and subsystems. As the system evolves, they customize these components, tune performance, and make reuse decisions. These complex tasks require understanding component behavior, tracking resource usage, and detecting integration problems. <p> Most conventional object-oriented software analysis tools, however, provide dynamic inspection primarily in terms of lower-level units like classes, instances, and methods [19, 20, 14, 15, 17, 12]. Architectural abstractions with a granularity that is larger than an object or class are opaque to such tools. Recent research <ref> [5, 7, 9] </ref> demonstrates the value of gross architectural structures in promoting design and implementation reuse for understanding and building complex systems.
Reference: [6] <author> Brian Foote and Ralph E. Johnson. </author> <title> Reflective Facilities in Smalltalk-80. </title> <booktitle> In OOPSLA 89, Conference Proceedings, </booktitle> <pages> pages 327-335. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: Snodgrass' instrumentation is mainly targeted towards distributed debugging and monitoring, not on analyzing the software architecture of the system. Other related research includes work on computational reflection. While rich structures and meta-level architectures for reflection have previously been defined <ref> [18, 11, 6, 24] </ref>, issues in the explicit representation of gross architectural abstractions appear to be under emphasized.
Reference: [7] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </author> <title> Design Patterns, Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1994. </year>
Reference-contexts: 1 Introduction Designers conceive complex systems as architectures with design patterns <ref> [7] </ref>, frameworks [5], architectural styles [8], and subsystems. As the system evolves, they customize these components, tune performance, and make reuse decisions. These complex tasks require understanding component behavior, tracking resource usage, and detecting integration problems. <p> Most conventional object-oriented software analysis tools, however, provide dynamic inspection primarily in terms of lower-level units like classes, instances, and methods [19, 20, 14, 15, 17, 12]. Architectural abstractions with a granularity that is larger than an object or class are opaque to such tools. Recent research <ref> [5, 7, 9] </ref> demonstrates the value of gross architectural structures in promoting design and implementation reuse for understanding and building complex systems. <p> More 14 15 16 over, the traversal strategy and instrument organization must be orthogonal, so that either might be changed independently. For instance, we might want to use the same traversal strategy over multiple abstraction levels. * Solution: We separate the responsibility for traversing the instruments in an Iterator <ref> [7] </ref> object. Each iterator has a specialized algorithm for traversing its collection of instruments. * Consequences: Iterators know the details of the collection, but the instrument managers and data collectors are isolated from those details.
Reference: [8] <author> D. Garlan, R. Allen, and J. Ockerbloom. </author> <title> Exploiting Style in Architectural Design Environments. </title> <booktitle> In Proceedings of the 2nd ACM SIGSOFT, </booktitle> <pages> pages 175-188, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Designers conceive complex systems as architectures with design patterns [7], frameworks [5], architectural styles <ref> [8] </ref>, and subsystems. As the system evolves, they customize these components, tune performance, and make reuse decisions. These complex tasks require understanding component behavior, tracking resource usage, and detecting integration problems. Program instrumentation and visualization tools that support analysis in terms of architectural abstractions would markedly simplify these activities.
Reference: [9] <author> David Garlan and Mary Shaw. </author> <title> An Introduction to the Field of Software Architecture. </title> <editor> In V. Ambriola and G. Tortora, editors, </editor> <booktitle> Advances in Software Engineering and Knowledge Engineering, volume I. </booktitle> <publisher> World Scientific Publishing Company, </publisher> <year> 1995. </year> <month> 22 </month>
Reference-contexts: Most conventional object-oriented software analysis tools, however, provide dynamic inspection primarily in terms of lower-level units like classes, instances, and methods [19, 20, 14, 15, 17, 12]. Architectural abstractions with a granularity that is larger than an object or class are opaque to such tools. Recent research <ref> [5, 7, 9] </ref> demonstrates the value of gross architectural structures in promoting design and implementation reuse for understanding and building complex systems.
Reference: [10] <author> Philip Haynes, Tim Menzies, and Robert F. Cohen. </author> <title> Visualisations of large object-oriented systems. </title> <type> Technical Report TR 95-4, </type> <institution> Monash University, </institution> <address> Melbourne, Australia, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: In each study, we use information from higher levels to select lower-level components for further study. The 3 system offers many graphical presentations, each suitable for viewing behavior at some abstraction level. When we want aggregate, relative statistics, we use diagrams like bar charts and ternary diagrams <ref> [10] </ref>. When the information must be correlated to the system structure, we use space-filling diagrams that make it easy to relate the run-time statistics to the relevant system parts. When we have to display pair-wise component interaction, we use affinity diagrams and object interaction diagrams. <p> We exploit this facility to routinely check the design properties of Choices after every version [22]. This case study considers an instance where we recognized and repaired undesirable subsystem couplings during our system evaluation. * Subsystem: The ternary diagram <ref> [10] </ref> in Figure 4 portrays relative communication between four device driver frameworks and three subsystems: the naming system, the remote procedure call (RPC) system, and the device driver system. The diagram helps quickly compare the degree of interaction among each framework and the three subsystems.
Reference: [11] <author> Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Snodgrass' instrumentation is mainly targeted towards distributed debugging and monitoring, not on analyzing the software architecture of the system. Other related research includes work on computational reflection. While rich structures and meta-level architectures for reflection have previously been defined <ref> [18, 11, 6, 24] </ref>, issues in the explicit representation of gross architectural abstractions appear to be under emphasized.
Reference: [12] <author> D. R. Kohr, S. Zhang, M. Rahman, and D. A. Reed. </author> <title> Object-Oriented Parallel Operating Systems: A Performance Study. </title> <booktitle> In Scientific Programming, </booktitle> <year> 1994. </year>
Reference-contexts: Program instrumentation and visualization tools that support analysis in terms of architectural abstractions would markedly simplify these activities. Most conventional object-oriented software analysis tools, however, provide dynamic inspection primarily in terms of lower-level units like classes, instances, and methods <ref> [19, 20, 14, 15, 17, 12] </ref>. Architectural abstractions with a granularity that is larger than an object or class are opaque to such tools. Recent research [5, 7, 9] demonstrates the value of gross architectural structures in promoting design and implementation reuse for understanding and building complex systems. <p> While this application was executing, we gathered instrumentation data for the query "How many methods of the virtual memory system were called by the file system?" 2 . The instrumentation data packets and execution times were measured over five second intervals. 5.1 Data generation generated using traditional instrumentation <ref> [15, 14, 20, 19, 12, 16] </ref>. Here, every data packet includes information about the method that was called, so the number of packets equals the number of methods called regardless of the granularity of system modelling. The solid bars display data collected using architecture-aware instrumentation.
Reference: [13] <author> C. </author> <title> Laffra and A Malhotra. HotWire:A Visual Debugger for C++. </title> <booktitle> In Proceedings of the USENIX C++ Conference, </booktitle> <pages> pages 39-54, </pages> <year> 1994. </year>
Reference-contexts: Again, it is clear that enabling few instruments reduces the impact of instrumentation. 6 Related Research Current dynamic visualization tools for object-oriented programs appear to focus on animating class, object, and method interactions <ref> [19, 20, 13] </ref>. ProgramExplorer [14, 15], Pattern-Lint [22], and OS View [21] are some of the new systems that visualize architecture-level concepts like frameworks and design patterns. However, the granularity of system depiction is still classes, objects, and methods.
Reference: [14] <author> Danny B. Lange and Yuichi Nakamura. </author> <title> Interactive Visualization of Design Patterns Can help in Framework Understanding. </title> <booktitle> In OOPSLA, </booktitle> <year> 1995. </year>
Reference-contexts: Program instrumentation and visualization tools that support analysis in terms of architectural abstractions would markedly simplify these activities. Most conventional object-oriented software analysis tools, however, provide dynamic inspection primarily in terms of lower-level units like classes, instances, and methods <ref> [19, 20, 14, 15, 17, 12] </ref>. Architectural abstractions with a granularity that is larger than an object or class are opaque to such tools. Recent research [5, 7, 9] demonstrates the value of gross architectural structures in promoting design and implementation reuse for understanding and building complex systems. <p> While this application was executing, we gathered instrumentation data for the query "How many methods of the virtual memory system were called by the file system?" 2 . The instrumentation data packets and execution times were measured over five second intervals. 5.1 Data generation generated using traditional instrumentation <ref> [15, 14, 20, 19, 12, 16] </ref>. Here, every data packet includes information about the method that was called, so the number of packets equals the number of methods called regardless of the granularity of system modelling. The solid bars display data collected using architecture-aware instrumentation. <p> Again, it is clear that enabling few instruments reduces the impact of instrumentation. 6 Related Research Current dynamic visualization tools for object-oriented programs appear to focus on animating class, object, and method interactions [19, 20, 13]. ProgramExplorer <ref> [14, 15] </ref>, Pattern-Lint [22], and OS View [21] are some of the new systems that visualize architecture-level concepts like frameworks and design patterns. However, the granularity of system depiction is still classes, objects, and methods.
Reference: [15] <author> Danny B. Lange and Yuichi Nakamura. </author> <title> Program Explorer: A Program Visualizer for C++. </title> <booktitle> In Usenix Conference on Object-Oriented Technologies, </booktitle> <pages> pages 39-54, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Program instrumentation and visualization tools that support analysis in terms of architectural abstractions would markedly simplify these activities. Most conventional object-oriented software analysis tools, however, provide dynamic inspection primarily in terms of lower-level units like classes, instances, and methods <ref> [19, 20, 14, 15, 17, 12] </ref>. Architectural abstractions with a granularity that is larger than an object or class are opaque to such tools. Recent research [5, 7, 9] demonstrates the value of gross architectural structures in promoting design and implementation reuse for understanding and building complex systems. <p> While this application was executing, we gathered instrumentation data for the query "How many methods of the virtual memory system were called by the file system?" 2 . The instrumentation data packets and execution times were measured over five second intervals. 5.1 Data generation generated using traditional instrumentation <ref> [15, 14, 20, 19, 12, 16] </ref>. Here, every data packet includes information about the method that was called, so the number of packets equals the number of methods called regardless of the granularity of system modelling. The solid bars display data collected using architecture-aware instrumentation. <p> Again, it is clear that enabling few instruments reduces the impact of instrumentation. 6 Related Research Current dynamic visualization tools for object-oriented programs appear to focus on animating class, object, and method interactions [19, 20, 13]. ProgramExplorer <ref> [14, 15] </ref>, Pattern-Lint [22], and OS View [21] are some of the new systems that visualize architecture-level concepts like frameworks and design patterns. However, the granularity of system depiction is still classes, objects, and methods.
Reference: [16] <author> Rahman M. </author> <title> Choices Instrumentation Support. </title> <type> Technical report, </type> <institution> University of Illinois-Urbana Champaign, </institution> <year> 1992. </year>
Reference-contexts: While this application was executing, we gathered instrumentation data for the query "How many methods of the virtual memory system were called by the file system?" 2 . The instrumentation data packets and execution times were measured over five second intervals. 5.1 Data generation generated using traditional instrumentation <ref> [15, 14, 20, 19, 12, 16] </ref>. Here, every data packet includes information about the method that was called, so the number of packets equals the number of methods called regardless of the granularity of system modelling. The solid bars display data collected using architecture-aware instrumentation.
Reference: [17] <author> Peter W. Madany, Roy H. Campbell, and Panos Kougiouris. </author> <title> Experiences Building an Object-Oriented System in C++. </title> <booktitle> In Technology of Object-Oriented Languages and Systems Conference, </booktitle> <address> Paris, France, </address> <month> March </month> <year> 1991. </year>
Reference-contexts: Program instrumentation and visualization tools that support analysis in terms of architectural abstractions would markedly simplify these activities. Most conventional object-oriented software analysis tools, however, provide dynamic inspection primarily in terms of lower-level units like classes, instances, and methods <ref> [19, 20, 14, 15, 17, 12] </ref>. Architectural abstractions with a granularity that is larger than an object or class are opaque to such tools. Recent research [5, 7, 9] demonstrates the value of gross architectural structures in promoting design and implementation reuse for understanding and building complex systems.
Reference: [18] <editor> Pattie Maes. </editor> <title> Concepts and Experiments in Computational Reflection. </title> <booktitle> In OOPSLA 87, Conference Proceedings, </booktitle> <pages> pages 147-155. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference-contexts: Snodgrass' instrumentation is mainly targeted towards distributed debugging and monitoring, not on analyzing the software architecture of the system. Other related research includes work on computational reflection. While rich structures and meta-level architectures for reflection have previously been defined <ref> [18, 11, 6, 24] </ref>, issues in the explicit representation of gross architectural abstractions appear to be under emphasized.
Reference: [19] <author> W. De Pauw, R. Helm, D. Kimelman, and J. Vlissides. </author> <title> Visualizing the Behavior of Object-Oriented Systems. </title> <booktitle> In OOPSLA, </booktitle> <month> October </month> <year> 1993. </year>
Reference-contexts: Program instrumentation and visualization tools that support analysis in terms of architectural abstractions would markedly simplify these activities. Most conventional object-oriented software analysis tools, however, provide dynamic inspection primarily in terms of lower-level units like classes, instances, and methods <ref> [19, 20, 14, 15, 17, 12] </ref>. Architectural abstractions with a granularity that is larger than an object or class are opaque to such tools. Recent research [5, 7, 9] demonstrates the value of gross architectural structures in promoting design and implementation reuse for understanding and building complex systems. <p> While this application was executing, we gathered instrumentation data for the query "How many methods of the virtual memory system were called by the file system?" 2 . The instrumentation data packets and execution times were measured over five second intervals. 5.1 Data generation generated using traditional instrumentation <ref> [15, 14, 20, 19, 12, 16] </ref>. Here, every data packet includes information about the method that was called, so the number of packets equals the number of methods called regardless of the granularity of system modelling. The solid bars display data collected using architecture-aware instrumentation. <p> Again, it is clear that enabling few instruments reduces the impact of instrumentation. 6 Related Research Current dynamic visualization tools for object-oriented programs appear to focus on animating class, object, and method interactions <ref> [19, 20, 13] </ref>. ProgramExplorer [14, 15], Pattern-Lint [22], and OS View [21] are some of the new systems that visualize architecture-level concepts like frameworks and design patterns. However, the granularity of system depiction is still classes, objects, and methods.
Reference: [20] <author> W. De Pauw, R. Helm, D. Kimelman, and J. Vlissides. </author> <title> Modelling Object-Oriented Program Execution. </title> <booktitle> In Proceedings of the 8th European Conference on Object-Oriented Programming, ECOOP'94. Lecture Notes in Computer Science, </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: Program instrumentation and visualization tools that support analysis in terms of architectural abstractions would markedly simplify these activities. Most conventional object-oriented software analysis tools, however, provide dynamic inspection primarily in terms of lower-level units like classes, instances, and methods <ref> [19, 20, 14, 15, 17, 12] </ref>. Architectural abstractions with a granularity that is larger than an object or class are opaque to such tools. Recent research [5, 7, 9] demonstrates the value of gross architectural structures in promoting design and implementation reuse for understanding and building complex systems. <p> While this application was executing, we gathered instrumentation data for the query "How many methods of the virtual memory system were called by the file system?" 2 . The instrumentation data packets and execution times were measured over five second intervals. 5.1 Data generation generated using traditional instrumentation <ref> [15, 14, 20, 19, 12, 16] </ref>. Here, every data packet includes information about the method that was called, so the number of packets equals the number of methods called regardless of the granularity of system modelling. The solid bars display data collected using architecture-aware instrumentation. <p> Again, it is clear that enabling few instruments reduces the impact of instrumentation. 6 Related Research Current dynamic visualization tools for object-oriented programs appear to focus on animating class, object, and method interactions <ref> [19, 20, 13] </ref>. ProgramExplorer [14, 15], Pattern-Lint [22], and OS View [21] are some of the new systems that visualize architecture-level concepts like frameworks and design patterns. However, the granularity of system depiction is still classes, objects, and methods.
Reference: [21] <author> Mohlalefi Sefika and Roy H. Campbell. </author> <title> An Open Visual Model For Object-Oriented Operating Systems. </title> <booktitle> In Fourth International Workshop on Object Orientation in Operating Systems, Lund, </booktitle> <address> Sweden, </address> <month> August </month> <year> 1995. </year> <month> 23 </month>
Reference-contexts: Again, it is clear that enabling few instruments reduces the impact of instrumentation. 6 Related Research Current dynamic visualization tools for object-oriented programs appear to focus on animating class, object, and method interactions [19, 20, 13]. ProgramExplorer [14, 15], Pattern-Lint [22], and OS View <ref> [21] </ref> are some of the new systems that visualize architecture-level concepts like frameworks and design patterns. However, the granularity of system depiction is still classes, objects, and methods.
Reference: [22] <author> Mohlalefi Sefika, Aamod Sane, and Roy H. Campbell. </author> <title> Monitoring Compliance of a Software System With Its High-Level Design Models. </title> <booktitle> In To appear in Proceedings of the 18th International Conference on Software Engineering, </booktitle> <year> 1996. </year>
Reference-contexts: The second study (Section 3.1) concerns a problem in subsystem cohesion and coupling that showed up during a routine check that we apply after every major change in system design <ref> [22] </ref>. The check tracks subsystem interactions at the subsystem-, framework-, class-, and method-levels and reveals significant architectural changes that could indicate flaws in the modifications. The check is essentially a conformance test and is feasible because architecture-oriented visualization simplifies the process. <p> We exploit this facility to routinely check the design properties of Choices after every version <ref> [22] </ref>. <p> Again, it is clear that enabling few instruments reduces the impact of instrumentation. 6 Related Research Current dynamic visualization tools for object-oriented programs appear to focus on animating class, object, and method interactions [19, 20, 13]. ProgramExplorer [14, 15], Pattern-Lint <ref> [22] </ref>, and OS View [21] are some of the new systems that visualize architecture-level concepts like frameworks and design patterns. However, the granularity of system depiction is still classes, objects, and methods.
Reference: [23] <author> R Snodgrass. </author> <title> A Relational Approach to Monitoring Complex Systems. </title> <journal> ACM Transactions of Computer Systems 6(2) </journal> <pages> 157-196, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: However, the instrument selection is purely based on class type information. This introspection scheme does not go beyond the class level, nor does it explicitly represent relations among instruments other than Classes. A similar class-based approach is adopted by De Pauw et al.[19]. Snodgrass <ref> [23] </ref> presents a method for monitoring program execution in which a programmer uses relational algebra queries to track run-time dynamics. The scheme is more tailored for data organization (using a conceptual temporal database) than instrument organization.

References-found: 23

