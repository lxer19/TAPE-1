URL: http://www.cs.rutgers.edu/~minsky/583/arch2.ps
Refering-URL: http://www.cs.rutgers.edu/~minsky/583/coord.html
Root-URL: http://www.cs.rutgers.edu
Email: minsky@cs.rutgers.edu  
Title: Why Should Architectural Principles be Enforced?  
Author: Naftaly H. Minsky 
Keyword: architectural model, law-governed software, evolution, in variants of evolution, firewalls, protection.  
Note: Work supported in part by NSF grants No. CCR-9308773  
Date: August 12, 1998  
Address: New Brunswick, NJ, 08903 USA  
Affiliation: Department of Computer Science Rutgers University  
Abstract: There is an emerging consensus that an explicit architectural model would be invaluable for large evolving software systems, providing them with a framework within which such a system can be reasoned about and maintained. But the great promise of architectural models has not been fulfilled so far, due to a gap between the model and the system it purports to describe. It is our contention that this gap is best bridged if the model is not just stated, but is enforced. This gives rise to a concept enforced architectural model |or, a law | which is explored in this paper. We argue that this model has two major beneficial consequences: First, by bridging the above mentioned gap between an architectural model and the actual system, an enforced architectural model provides a truly reliable framework within which a system can be reasoned about and maintained. Second, our model provides software developers with a carefully circumscribed flexibility in molding the law of a project, during its evolutionary lifetime|while maintaining certain architectural principles as invariant of evolution. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> N. Belkhtair, J. Estublier, and W. Melo. Adele-tempo: </author> <title> An environment for process modeling and enaction. </title> <editor> In A. Finkelstein, J. Kramer, and B. Nu-seibeh, editors, </editor> <booktitle> Software Process Modeling and Technology. </booktitle> <publisher> John Wiley and Sons, </publisher> <year> 1994. </year>
Reference-contexts: The process of software evolution is the subject of an extensive body of research on what is called process-centered environments such as Arcadia [6], Marvel [7], Polis [2], and Adele-Tempo <ref> [1] </ref>. There are similarities between our law|as a means for regulating the process of software development|and the concept of "process programming" in Arcadia, or the set of rules of Marvel Polis or Adele.
Reference: [2] <author> Paolo Ciancarini. </author> <title> Enacting rule-based software processes with polis. </title> <type> Technical report, </type> <institution> University of Pisa, </institution> <month> october </month> <year> 1991. </year>
Reference-contexts: The process of software evolution is the subject of an extensive body of research on what is called process-centered environments such as Arcadia [6], Marvel [7], Polis <ref> [2] </ref>, and Adele-Tempo [1]. There are similarities between our law|as a means for regulating the process of software development|and the concept of "process programming" in Arcadia, or the set of rules of Marvel Polis or Adele.
Reference: [3] <author> C. K. Duby, S. Meyers, and S. P. Reiss. CCEL: </author> <title> A metalanguage for C++. </title> <booktitle> In USENIX C++ Conference, </booktitle> <month> August </month> <year> 1992. </year>
Reference-contexts: of codified design principles [i.e., an architectural model] must be supplemented by checks to ensure that the actual implan tation adheres to its design constraints and guidelines." This approach led to the development of various tools whose purpose is to verify that a given system satisfies a given architectural model <ref> [3, 18, 22] </ref>. But the mere existence of verification tools is not sufficient for ensuring the compliance with a principle, particularly not for rapidly evolving systems.
Reference: [4] <author> D. Garlan. </author> <title> Research direction in software architecture. </title> <journal> ACM Computing Surveys, </journal> <volume> 27(2) </volume> <pages> 257-261, </pages> <year> 1995. </year>
Reference-contexts: We share with the emerging research on SA the conviction that a complex evolving system needs an explicit architectural model, which provides a framework within which the system can be reasoned about and maintained <ref> [21, 4, 23] </ref>.
Reference: [5] <author> D. Garlan and D. Perry. </author> <title> Introduction to the special issue on software architecture. </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> April </month> <year> 1995. </year>
Reference-contexts: 1 Introduction There is an emerging consensus that an explicit architectural model should be invaluable for large evolving software systems <ref> [5] </ref>. This should be particularly true for the part of the model that specify the principles and guidelines that are to govern the structure of the system, and its evolution over time|such as the requirement that the system be layered 1 .
Reference: [6] <author> D. Heimbinger. </author> <title> Prescription versus proscription in process-centered environments. </title> <booktitle> In Proceedings of the 6th International Software Process Workshop, </booktitle> <address> Hakkaido Japan, </address> <month> October </month> <year> 1990. </year> <note> To appear. </note>
Reference-contexts: The process of software evolution is the subject of an extensive body of research on what is called process-centered environments such as Arcadia <ref> [6] </ref>, Marvel [7], Polis [2], and Adele-Tempo [1]. There are similarities between our law|as a means for regulating the process of software development|and the concept of "process programming" in Arcadia, or the set of rules of Marvel Polis or Adele.
Reference: [7] <author> G. et al. Kaiser. </author> <title> Intelligent assistance for software development and maintenance. </title> <journal> IEEE Software, </journal> <month> May </month> <year> 1988. </year>
Reference-contexts: The process of software evolution is the subject of an extensive body of research on what is called process-centered environments such as Arcadia [6], Marvel <ref> [7] </ref>, Polis [2], and Adele-Tempo [1]. There are similarities between our law|as a means for regulating the process of software development|and the concept of "process programming" in Arcadia, or the set of rules of Marvel Polis or Adele.
Reference: [8] <editor> M.M. Lehman. </editor> <booktitle> Program Evolution, </booktitle> <pages> pages 3-24. </pages> <publisher> IFIP, </publisher> <year> 1985. </year> <institution> Teichroew and David Eds. </institution>
Reference-contexts: i ; where 2 We say "more or less," because the operational context of such along-lived sequence of systems is itself likely to change, even if relatively slowly. 3 The term "e-system" is used here, in part, to recall a somewhat related concept called an "e-type program" introduced by Lehman <ref> [8] </ref>. 4 The term "architecture" is used here in a somewhat different sense than in a phrase "architectural principle"|which is what is being established under LGA. 3 1.
Reference: [9] <author> N.H. Minsky. </author> <title> Law-governed systems. </title> <journal> The IEE Software Engineering Journal, </journal> <month> September </month> <year> 1991. </year>
Reference-contexts: Space limitation precluded any discussion of the structure of these metaRules, but see <ref> [9] </ref> for a general discussion of metaRules and for rule-formation. * Finally, Rule R11 allows the manager of each division to remove rules defined as belonging to his own division.
Reference: [10] <author> N.H. Minsky. </author> <title> Independent on-line monitoring of evolving systems. </title> <booktitle> In Proceedings of the 18th International Conference on Software Engineering (ICSE), </booktitle> <month> March </month> <year> 1996. </year>
Reference-contexts: The concept of strong invariant provides useful and necessary means for ensuring that certain high level societal principles will always be satisfied. (For a demonstration of how this can be done for the principle of internal control in financial systems the reader is referred to <ref> [10] </ref>. 2.3 On the Implementation of LGA So far we have built two different implementation of LGA: Darwin-E [13], and Moses [15]. They deal with different kinds of systems, support different types of laws, use different enforcement techniques, and have different advantages and limitations. <p> These include, under Darwin-E, access-control regimes of the kind exemplified by our case study in this paper; more dynamic access-control of the kind used in operating systems [14]; auditability, which is particularly critical for financial systems <ref> [10] </ref>; establishing various programming 6 Note that the actual programming of a module does not have to be done under E, and it is not under Darwin-E, in particular. <p> We do this under the Darwin-E environment, assuming that the system is to be written in the Eiffel language. We start with a very brief description of the structure of laws under Darwin-E, referring the reader to <ref> [13, 10] </ref> for more details. <p> These are calls to routines that are guaranteed not to make any permanent change to the system. This concept of side-effect-free routines is 13 established by a small set of primitive rules permanently associated with every e-system under Darwin-E environment, in a manner described in <ref> [10] </ref>. The Initial Evolution Sub-law Let us turn now to the control provided by L 0 over the process of evolution of S , including the manner in which the law itself is allowed to be changed.
Reference: [11] <author> N.H. Minsky. </author> <title> Law-governed regularities in object systems; part 1: An abstract model. </title> <journal> Theory and Practice of Object Systems (TAPOS), </journal> <volume> 2(1), </volume> <year> 1996. </year>
Reference-contexts: What we propose here is to make such a policy explicit, and to enforce it, thus creating what we call an e-system 3 (for "evolving system"), denoting it by S. This is made possible by what we call law-governed architecture 4 (LGA) <ref> [11] </ref>, under which an e-system is defined as follows: Definition 1 An e-system S is a triple hS; L; E i ; where 2 We say "more or less," because the operational context of such along-lived sequence of systems is itself likely to change, even if relatively slowly. 3 The term
Reference: [12] <author> N.H. Minsky. </author> <title> Taking software architecture seriously. </title> <type> Technical report, </type> <institution> Rutgers University, </institution> <month> April </month> <year> 1996. </year> <note> (available through http://www.cs.rutgers.edu/~minsky/index.html). </note>
Reference-contexts: The point of this principle is to provide a way for the kernel to keep some of its methods for internal use only. (The manner in which methods can be declared internal to a division, or exported from it, is discussed in <ref> [12] </ref>.) The enforcement of this principle is again essential because it protects the kernel, guaranteeing that a non exported method will never be called by any code in the therapy-division. (Unlike the previous two principles, this one can be established as an invariant under some conventional languages, such as Java, in
Reference: [13] <author> N.H. Minsky. </author> <title> Law-governed regularities in object systems; part 2: A concrete implementation. </title> <journal> Theory and Practice of Object Systems (TAPOS), </journal> <volume> 3(2), </volume> <year> 1997. </year>
Reference-contexts: from a lower layer to a higher one|and no down-call across more than one layer. 2 Our concept of enforced architectural model, is based squarely on the au-thor's concept of law-governed architecture (LGA), which so far has been implemented in two different manners (by means of Darwin-E software development environment <ref> [13] </ref>, and by means of the Moses toolkit [15].) and which has been applied experimentally to a wide range of applications. This paper, then, is more of a polemic|trying to argue the need for and the benefit of enforced architectural models|than a report of new technical results. <p> We continue, in Section 3, with an informal case study: defining an enforced architectural model for of an evolving software embedded in an intensive-care unit, In Section 4 we present a concrete implementation of this case study under the the LGA-based Darwin-E environment <ref> [13] </ref>. In Section 5 we describe some related work, and we conclude in Section 6. 2 On the Nature of Enforced Architectural Mod els As we attempt here to model evolving system, it is important to first clarify the type of evolution we have in mind. <p> certain high level societal principles will always be satisfied. (For a demonstration of how this can be done for the principle of internal control in financial systems the reader is referred to [10]. 2.3 On the Implementation of LGA So far we have built two different implementation of LGA: Darwin-E <ref> [13] </ref>, and Moses [15]. They deal with different kinds of systems, support different types of laws, use different enforcement techniques, and have different advantages and limitations. They are basically complementary, and are intended to be eventually combined into one comprehensive environment. <p> Principle 1 The kernel-division D k has exclusive access to the actuators that control the flow of various fluids and gases into the veins of the patient, and to the gauges that monitor the patient`s status. 7 This is an elaboration of an example given in <ref> [13] </ref>. 7 This principle localizes the direct interaction with the patient in D k , providing us with the ability build into D k a model of the patient that is completely independent of the rest of the system, and invariant of the evolution of anything but D k itself. <p> We do this under the Darwin-E environment, assuming that the system is to be written in the Eiffel language. We start with a very brief description of the structure of laws under Darwin-E, referring the reader to <ref> [13, 10] </ref> for more details. <p> These, and other regulated interactions, are discussed in detail in <ref> [13] </ref>. The disposition of a given interaction t is determined by evaluating the "goal" can t with respect to the the system-part of law L, which is expected to contain some rules that deal with this interaction.
Reference: [14] <author> N.H. Minsky and P. Pal. </author> <title> Providing multiple views for objects by means of surrogates. </title> <type> Technical report, </type> <institution> Rutgers University, LCSR, </institution> <month> November </month> <year> 1995. </year> <note> (available through http://www.cs.rutgers.edu/~minsky/). </note>
Reference-contexts: Some indication of this range is given by the type of principles we already implemented under Darwin-E and Moses. These include, under Darwin-E, access-control regimes of the kind exemplified by our case study in this paper; more dynamic access-control of the kind used in operating systems <ref> [14] </ref>; auditability, which is particularly critical for financial systems [10]; establishing various programming 6 Note that the actual programming of a module does not have to be done under E, and it is not under Darwin-E, in particular.
Reference: [15] <author> N.H. Minsky and V. Ungureanu. </author> <title> Regulated coordination in open distributed systems. </title> <editor> In David Garlan and Daniel Le Metayer, editors, </editor> <booktitle> Proc. of Coordination'97: Second International Conference on Coordination Models and Languages; LNCS 1282, </booktitle> <pages> pages 81-98, </pages> <month> September </month> <year> 1997. </year>
Reference-contexts: no down-call across more than one layer. 2 Our concept of enforced architectural model, is based squarely on the au-thor's concept of law-governed architecture (LGA), which so far has been implemented in two different manners (by means of Darwin-E software development environment [13], and by means of the Moses toolkit <ref> [15] </ref>.) and which has been applied experimentally to a wide range of applications. This paper, then, is more of a polemic|trying to argue the need for and the benefit of enforced architectural models|than a report of new technical results. <p> societal principles will always be satisfied. (For a demonstration of how this can be done for the principle of internal control in financial systems the reader is referred to [10]. 2.3 On the Implementation of LGA So far we have built two different implementation of LGA: Darwin-E [13], and Moses <ref> [15] </ref>. They deal with different kinds of systems, support different types of laws, use different enforcement techniques, and have different advantages and limitations. They are basically complementary, and are intended to be eventually combined into one comprehensive environment. <p> It is the insertion of a module into a e-system that needs to be mediated by E. 6 styles [20]; and making sure that certain programming patterns are not misused [19]. Under Moses we have implemented a wide range of distributed coordination mechanisms <ref> [15] </ref>; dynamic reconfiguration mechanisms for distributed systems [17]; and very sophisticated security and access control policies [16]. 3 Intensive-Care System: an Informal Case study Consider the software system embedded in an intensive care unit 7 .
Reference: [16] <author> N.H. Minsky and V. Ungureanu. </author> <title> Unified support for heterogeneous security policies in distributed systems. </title> <booktitle> In 7th USENIX Security Symposium, </booktitle> <month> January </month> <year> 1998. </year>
Reference-contexts: Under Moses we have implemented a wide range of distributed coordination mechanisms [15]; dynamic reconfiguration mechanisms for distributed systems [17]; and very sophisticated security and access control policies <ref> [16] </ref>. 3 Intensive-Care System: an Informal Case study Consider the software system embedded in an intensive care unit 7 .
Reference: [17] <author> N.H. Minsky, V. Ungureanu, W. Wang, and J. Zhang. </author> <title> Building reconfiguration primitives into the law of a system. </title> <booktitle> In Proc. of the Third International Conference on Configurable Distributed Systems (ICCDS'96), </booktitle> <month> March </month> <year> 1996. </year> <note> (available through http://www.cs.rutgers.edu/~minsky/). </note>
Reference-contexts: Under Moses we have implemented a wide range of distributed coordination mechanisms [15]; dynamic reconfiguration mechanisms for distributed systems <ref> [17] </ref>; and very sophisticated security and access control policies [16]. 3 Intensive-Care System: an Informal Case study Consider the software system embedded in an intensive care unit 7 .
Reference: [18] <author> G.C. Murphy, D. Notkin, and K. Sullivan. </author> <title> Software reflextion models: Bridging the gap between source and high level models. </title> <booktitle> In Proceedings of the Third ACM Symposium on the Foundation of Software Engineering, </booktitle> <year> 1995. </year>
Reference-contexts: But the great promise of architectural models has not been fulfilled so far. The main reason for this has been aptly described by Murphy, Notkin and Sullivan <ref> [18] </ref>, in the following manner: "Although these [architectural] models are commonly used, reasoning about the system in terms of such models can be dangerous because the models are almost always inaccurate with respect to the system's source." In other word, there is a gap between the model and the system it <p> of codified design principles [i.e., an architectural model] must be supplemented by checks to ensure that the actual implan tation adheres to its design constraints and guidelines." This approach led to the development of various tools whose purpose is to verify that a given system satisfies a given architectural model <ref> [3, 18, 22] </ref>. But the mere existence of verification tools is not sufficient for ensuring the compliance with a principle, particularly not for rapidly evolving systems.
Reference: [19] <author> P. Pal. </author> <title> Law-governed support for realizing design patterns. </title> <booktitle> In Proceedings of the 17th Conference on Technology of Object-Oriented Languages and Systems(TOOLS-17), </booktitle> <pages> pages 25-34, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: It is the insertion of a module into a e-system that needs to be mediated by E. 6 styles [20]; and making sure that certain programming patterns are not misused <ref> [19] </ref>. Under Moses we have implemented a wide range of distributed coordination mechanisms [15]; dynamic reconfiguration mechanisms for distributed systems [17]; and very sophisticated security and access control policies [16]. 3 Intensive-Care System: an Informal Case study Consider the software system embedded in an intensive care unit 7 .
Reference: [20] <author> P. Pal and N.H. Minsky. </author> <title> Imposing the law of demeter and its variations. </title> <booktitle> In Proceedings of the 18th Conference on Technology of Object-Oriented Languages and Systems(TOOLS-18), </booktitle> <month> August </month> <year> 1996. </year>
Reference-contexts: It is the insertion of a module into a e-system that needs to be mediated by E. 6 styles <ref> [20] </ref>; and making sure that certain programming patterns are not misused [19].
Reference: [21] <author> D.E. Perry and A.L. Wolf. </author> <title> Foundations for the study of software architecture. </title> <journal> Software Engineering Notes, </journal> <volume> 17(4) </volume> <pages> 40-52, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: We share with the emerging research on SA the conviction that a complex evolving system needs an explicit architectural model, which provides a framework within which the system can be reasoned about and maintained <ref> [21, 4, 23] </ref>.
Reference: [22] <author> M. Sefica, A Sane, and R.H. Campbell. </author> <title> Monitoring complience of a software system with its high-level design model. </title> <booktitle> In Proceedings of the 18th International Conference on Software Engineering (ICSE), </booktitle> <month> March </month> <year> 1996. </year>
Reference-contexts: The currently prevailing approach for bridging this gap has been described by Sefica, Sane and Cambell <ref> [22] </ref>, as follows: "the use of codified design principles [i.e., an architectural model] must be supplemented by checks to ensure that the actual implan tation adheres to its design constraints and guidelines." This approach led to the development of various tools whose purpose is to verify that a given system satisfies <p> of codified design principles [i.e., an architectural model] must be supplemented by checks to ensure that the actual implan tation adheres to its design constraints and guidelines." This approach led to the development of various tools whose purpose is to verify that a given system satisfies a given architectural model <ref> [3, 18, 22] </ref>. But the mere existence of verification tools is not sufficient for ensuring the compliance with a principle, particularly not for rapidly evolving systems.
Reference: [23] <author> M. Shaw. </author> <title> Architectural issues in software reuse: It's not just the functionality, it's the packaging. </title> <booktitle> In Proceedings of IEEE Symp. on Software Reuse, </booktitle> <year> 1995. </year>
Reference-contexts: We share with the emerging research on SA the conviction that a complex evolving system needs an explicit architectural model, which provides a framework within which the system can be reasoned about and maintained <ref> [21, 4, 23] </ref>.
References-found: 23

