URL: ftp://ftp.cs.utexas.edu/pub/psp/seuss/Krueger:MSThesis.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/psp/
Root-URL: http://www.cs.utexas.edu
Title: by  
Author: Ingolf Heiko Kruger 
Date: 1996  
Note: Copyright  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> W. Adams: </author> <title> Concurrent programming with a single thread of control, Dissertation Proposal, </title> <institution> Department of Computer Sciences, The University of Texas at Austin, </institution> <month> April </month> <year> 1995 </year>
Reference-contexts: A loose execution introduces a restricted notion of concurrency. Here, actions that are compatible may be executed concurrently. Intuitively, the parallel execution of compatible actions preserves properties of a tight execution. For a formal definition of compatibility, see <ref> [1] </ref>. One of the goals of the research in Seuss is to provide a compiler for Seuss programs, which takes advantage of compatibility information. <p> Intuitively, procedures in a Seuss program are defined to be compatible if their concurrent execution is equivalent to a sequential execution (in some possible order). (A formal definition 42 of compatibility is given in <ref> [1] </ref>.) This compatibility information can be used to carry out several action executions in parallel, thus introducing concurrency into program execution.
Reference: [2] <author> G. Booch: </author> <title> Object-oriented analysis and design with applications, 2nd ed., </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass. </address> <year> 1994 </year>
Reference-contexts: Seuss is based on the following concepts: * boxes * clones * procedures * tight program execution. Boxes can be compared to classes in object-based and object-oriented programming languages (cf. <ref> [2] </ref>). They define the structure (i.e. the state space) and the behavior (i.e. the set of procedures) of their instances. Clones are the instances of boxes. Each clone has its local state. Clones communicate (i.e. exchange information about their respective state) by calling upon each others' procedures.
Reference: [3] <author> K. M. Chandy, J. Misra: </author> <title> Parallel Program Design. A Foundation, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1988 </year>
Reference: [4] <institution> Free Software Foundation: </institution> <address> The GNU C++ library: libg++, </address> <note> online documentation (http://www.gnu.ai.mit.edu:80/stuff/doc.html) </note>
Reference-contexts: PVM is used as the basis of the runtime system. Throughout the implementation we have extensively used data structures defined in the GNU C++ library, libg++ (cf. <ref> [4] </ref>). These data structures contributed greatly to the rapid development of our code. <p> Unfortunately this library was not available for the GNU C++ compiler at the time the implementation of SeussCpp was started. We will not describe the use of libg++ in depth here, since detailed documentation exists for this library (cf. <ref> [4] </ref>).
Reference: [5] <author> E. Gamma, R. Helm, R. Johnson, J. Vlissides: </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1995 </year>
Reference-contexts: Therefore, we have chosen another approach. The scheme we adopt is a design pattern frequently appearing in object-oriented systems. It is called the "visitor" pattern and is described in detail in <ref> [5] </ref>. Its benefit is the disentanglement 59 of the code for the data structure to be traversed and the code for the traversal. The latter is implemented by a class called Visitor that provides a method called Visit for each member of the class hierarchy of the former.
Reference: [6] <author> Al Geist et al: </author> <title> PVM. Parallel Virtual Machine. A Users' Guide and Tutorial for Networked Parallel Computing, </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1994 </year>
Reference-contexts: To provide an environment for the execution of SeussCpp programs on computer networks, a runtime system based on PVM was designed and implemented. PVM (Parallel Virtual Machine) provides an interface for program development for heterogeneous computer networks (cf. <ref> [6] </ref>). Programs consist of processes which exchange state information via message passing. Because clones can be directly mapped to processes, PVM is an excellent basis for a runtime system for SeussCpp programs. <p> Since we do not want to concern ourselves with the low level details of process communication over computer networks, we generate code for the Parallel Virtual Machine (PVM), which provides an interface for program development for heterogeneous computer networks (cf. <ref> [6] </ref>). The remaining task, therefore, is to translate a SeussCpp program into a set of processes which are executable on top of PVM. The basic idea behind our code generator was outlined in 5.1. <p> It abstracts away from the underlying hardware and presents the user with a model of a parallel machine on which programs can be executed. PVM can be used on heterogeneous computer networks as well as on specialized parallel machines. <ref> [6] </ref> contains a description of the concepts and features of PVM. Here, we briefly review the elements of PVM that appear in our examples. Parallel programs running under PVM consist of a set of processes, which communicate by sending messages to one another.
Reference: [7] <author> W. Gropp, E. Lusk, A. Skjellum: </author> <title> Using MPI: Portable Parallel Programming with the Message-Passing Interface, </title> <publisher> MIT Press, Cam. </publisher> <address> Mass. </address> <year> 1995 </year>
Reference-contexts: It might also be beneficial to use different bases for the runtime system, other than PVM, to experiment with the efficiency of the runtime system. A possible substitute for PVM is MPI (cf. <ref> [7] </ref>), which provides basically the same communication primitives as PVM, but is not yet as widely used. To evaluate the usability of SeussCpp as a programming language for applications of reasonable size, an attempt should be made to take the sources of existing applications and to translate them into SeussCpp.
Reference: [8] <author> Rajeev Joshi: </author> <title> SeussCpp 0.0 : Syntax Description, </title> <note> Note RJ-01 </note>
Reference-contexts: Its output code should be executable on computer networks in a distributed fashion. 1.2 Goals of this Thesis In [16] no commitment to a specific sequential programming language for procedure bodies has been made. However, making such a commitment allows us to construct a compiler for Seuss programs. In <ref> [8] </ref> C++ was chosen for this purpose. The aim of this Thesis is to design and implement a compiler for SeussCpp, the language defined in [8]. Due to the fact that Seuss is an ongoing research project, the input language of the compiler is likely to change over time. <p> However, making such a commitment allows us to construct a compiler for Seuss programs. In <ref> [8] </ref> C++ was chosen for this purpose. The aim of this Thesis is to design and implement a compiler for SeussCpp, the language defined in [8]. Due to the fact that Seuss is an ongoing research project, the input language of the compiler is likely to change over time. Therefore, the design and the components used in the implementation should be as general as possible. <p> Now we will build a concrete programming language around these concepts. The resulting programming language is called SeussCpp and has been designed by Rajeev Joshi (cf. <ref> [8] </ref>). It allows the user to write the sequential parts of their programs in C++. Unlike Seuss, SeussCpp does not support nested boxes. Instead, the notion of modules is added. In the following sections we introduce the syntax of SeussCpp by giving the grammar for the language, described using EBNF.
Reference: [9] <author> Rajeev Joshi: </author> <title> A definition of Link Consistency for SeussCpp , Note RJ-04 </title>
Reference-contexts: Since each producer puts exactly MAX_NUM_OF_ITEMS into ch, after exactly 3flMAX_NUM_OF_ITEMS calls to put and a corresponding number of accepted gets, a fix-point is reached. 3.9 Link Consistency In section 3.6 we have introduced the notion of method access specification. In <ref> [9] </ref> Rajeev Joshi gives a precise definition of link consistency for SeussCpp programs. We repeat his definition below. An implementation of an algorithm for checking the link consistency condition, which is also due to Rajeev Joshi (cf. [10]), is discussed in section 5.6.
Reference: [10] <author> Rajeev Joshi: </author> <title> An algorithm for Link Consistency, </title> <note> Note RJ-02 </note>
Reference-contexts: In [9] Rajeev Joshi gives a precise definition of link consistency for SeussCpp programs. We repeat his definition below. An implementation of an algorithm for checking the link consistency condition, which is also due to Rajeev Joshi (cf. <ref> [10] </ref>), is discussed in section 5.6. Let M and C denote the sets of modules and clones defined in the program, respectively. Let U = M [ C; In this context we shall call the members of U units. Let denote the set of method names (defined in the boxes). <p> This concludes our description of the implementation of the symbol table. 5.6 Consistency Checker The link consistency condition, which was defined in section 3.9, can be implemented by a simple algorithm. The algorithm, of which we give a brief outline below, has been developed by Rajeev Joshi (cf. <ref> [10] </ref>). We assume that the set of box instances is totally ordered, and that all access lists are sorted on this order. Moreover, associated with each module is a list of the modules and instances that are directly defined in the module.
Reference: [11] <author> Rajeev Joshi: </author> <type> PhD Thesis, </type> <note> in preparation 138 </note>
Reference-contexts: To evaluate the usability of SeussCpp as a programming language for applications of reasonable size, an attempt should be made to take the sources of existing applications and to translate them into SeussCpp. Such experiments are now under way (cf. <ref> [11] </ref>), and will provide hints on the applicability of SeussCpp programs. 128 Appendix A The complete grammar of SeussCpp &lt;SeussCpp Program&gt; ::= f &lt;Module Definition&gt; g fl &lt;Module Definition&gt; ::= module &lt;Identifier&gt; f &lt;Module Body&gt; g &lt;Module Body&gt; ::= f &lt;Access Spec&gt; g fl f &lt;Module Component&gt; g fl &lt;Access Spec&gt;
Reference: [12] <author> M. Kaltenbach: </author> <title> Model Checking for UNITY, </title> <type> Technical Report TR94-31, </type> <institution> The University of Texas at Austin, </institution> <year> 1994 </year>
Reference-contexts: Alternatively, we could have chosen to implement list templates ourselves. However, it is our belief that reuse of existing components is one of the big advantages of object-oriented design and implementation. Since our confidence in the classes available in libg++ was encouraged by other projects (for instance, cf. <ref> [12] </ref>), we decided against "reinventing the wheel". Yet another alternative would have been to use the standard template library (cf. [18]), which provides container classes based on C++'s template mechanism. Unfortunately this library was not available for the GNU C++ compiler at the time the implementation of SeussCpp was started.
Reference: [13] <author> I. Kruger, M. </author> <month> Sihling: </month> <institution> Implementierung der Laufzeitkomponente des GOS-Interpreters. Fortgeschrittenenpraktikum, Ausarbeitung, Technische Univer-sitat Munchen, </institution> <year> 1995 </year>
Reference-contexts: CppCode stores a textual representation of the C++ code fragment corresponding to the given AST node. Any EBNF grammar can be turned into a class hierarchy by a fairly mechanical procedure (cf. [20], <ref> [13] </ref>). Every rule of the form &lt;N&gt; ::= &lt;N0&gt; &lt;N1&gt; can be turned into a class N, derived from Nonterminal, which has two members of type N0 and N1, respectively. <p> It is tempting to simply extend the elements of the AST class hierarchy by members to hold the acquired information. Experience shows (cf. <ref> [13] </ref>), that this approach has three major drawbacks. First, it leads to huge classes in the hierarchy representing the AST.
Reference: [14] <author> I. Kruger: AMIGA. </author> <title> Programmieren mit Modula-2, </title> <institution> Markt&Technik, Munchen, </institution> <year> 1988 </year>
Reference: [15] <author> J. R. Levine, T. Mason, D. Brown: </author> <title> lex & yacc, </title> <address> O'Reilly, Sebastopol, Ca., </address> <year> 1995 </year>
Reference-contexts: The scanner and the parser are generated using flex and bison respectively (for a description, see <ref> [15] </ref>); the other components are written in C++. PVM is used as the basis of the runtime system. Throughout the implementation we have extensively used data structures defined in the GNU C++ library, libg++ (cf. [4]). These data structures contributed greatly to the rapid development of our code.
Reference: [16] <author> J. Misra: </author> <title> A Discipline of Multiprogramming, </title> <year> 1996 </year> <month> (ftp://ftp.cs.utexas.edu/pub/psp/seuss/discipline.ps.Z) </month>
Reference-contexts: Specification, implementation and verification of the latter are well understood. Therefore, Seuss proposes a "complete disentanglement of the sequential and concurrent aspects of programming" (cf. <ref> [16] </ref>). This is achieved by the fact that Seuss has no built in notion of concurrency. Execution of Seuss programs consists of a single thread of control. This allows the system designer to reason about Seuss programs without having to take concurrency into account. <p> We give a quick overview of Seuss, below; for a detailed discussion, see <ref> [16] </ref>. The components of the Seuss programming model are procedures, boxes and clones. Boxes can be likened to classes in object-based and object-oriented programming. They define types that describe the state space and the behavior (i.e. the set of procedures) of their instances. Clones are instances of boxes. <p> One of the goals of the research in Seuss is to provide a compiler for Seuss programs, which takes advantage of compatibility information. Its output code should be executable on computer networks in a distributed fashion. 1.2 Goals of this Thesis In <ref> [16] </ref> no commitment to a specific sequential programming language for procedure bodies has been made. However, making such a commitment allows us to construct a compiler for Seuss programs. In [8] C++ was chosen for this purpose. <p> Chapter 5 contains a detailed description of an implementation of the design. We conclude with a discussion in chapter 6. 4 Chapter 2 Seuss Seuss has been developed as a new model of multiprogramming by J. Misra. A detailed description of its syntax and semantics can be found in <ref> [16] </ref>. Here, we describe the underlying concepts of this model. We do not focus on syntactic issues, since in chapter 3 a programming language based on Seuss will be presented and its formal syntax will be given. <p> This allows us to use a logic like UNITY to specify and prove properties of Seuss programs. An embedding of Seuss into UNITY logic is under way (cf. <ref> [16] </ref>). Although no inherent notion of concurrency exists in Seuss, we anticipate that a lot of procedures in a given program can be executed in parallel. <p> In the following sections we elaborate further on the concepts introduced by Seuss and illustrate them by examples. We will not introduce a specific syntax for Seuss here. Instead, we will use the one provided in <ref> [16] </ref> and define a formal syntax for a concrete instance of Seuss in the next chapter. 6 2.1 Boxes Boxes are similar to classes in object-based and object-oriented programming. They describe the state space and procedures which determine the behavior of their instances. <p> It is required that every action of every clone is chosen infinitely often during program execution. Put another way, every action of every clone is executed eventually. In <ref> [16] </ref>, the runtime structure of Seuss programs is discussed in detail. This concludes our introduction to the concepts of Seuss. In the next chapter, we describe the syntax of a concrete programming language based on Seuss. It uses C++ as the programming language for the sequential parts of Seuss programs. <p> Among these are boxes and clones for representing channels (first-in-first-out, last-in-first-out, unordered and faulty channels) and semaphores (binary, general, weak, strong and snoopy semaphores). For these and other examples of possible members of a library module, 31 see <ref> [16] </ref>. The actual content of the library will be determined by the demands of SeussCpp programmers. 32 Chapter 4 Compiler and Runtime System Design In this chapter, the design of a compiler for SeussCpp is presented.
Reference: [17] <author> J. Misra: </author> <title> Closure Properties, </title> <address> 1994 (ftp://ftp.cs.utexas.edu/pub/psp/unity/new unity/closure.ps.Z) </address>
Reference-contexts: In this section we will also describe the use of &lt;Method Access Spec&gt; , as we promised in section 3.2.1. Method access specifications are useful in reasoning about the correctness of composite programs. <ref> [17] </ref> contains a detailed discussion of access specifications. Clones are declared by giving a list of clone names, separated by a colon from the type specification.
Reference: [18] <author> D. R. Musser, A. Saini: </author> <title> STL Tutorial & Reference Guide: C++ Programming with the Standard Template Library, </title> <publisher> Addison Wesley, </publisher> <address> Reading, Mass. </address> <year> 1996 </year>
Reference-contexts: Since our confidence in the classes available in libg++ was encouraged by other projects (for instance, cf. [12]), we decided against "reinventing the wheel". Yet another alternative would have been to use the standard template library (cf. <ref> [18] </ref>), which provides container classes based on C++'s template mechanism. Unfortunately this library was not available for the GNU C++ compiler at the time the implementation of SeussCpp was started. We will not describe the use of libg++ in depth here, since detailed documentation exists for this library (cf. [4]).
Reference: [19] <author> L. C. Paulson: </author> <title> ML for the working programmer, </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1993 </year>
Reference-contexts: This approach is chosen because it allows us to explain the various parts of the code generator in a succinct and compositional way, without cluttering the discussion by C++ syntax. The notation we chose is similar to that of functional programming languages such as ML (cf. <ref> [19] </ref>), but has a slightly more liberal syntax. The main element of our notation is function definition. A function definition consists of a signature (denoting the input and output types of the function to be defined) and a description of how to map input values to output values.
Reference: [20] <author> U. Schunemann, K. Bichler: </author> <title> Praktische Semesterarbeit: Parser und opera-tionelle Semantik fur GOS, Advanced Practical, </title> <institution> Technical University of Munich, </institution> <year> 1994 </year> <month> 139 </month>
Reference-contexts: CppCode stores a textual representation of the C++ code fragment corresponding to the given AST node. Any EBNF grammar can be turned into a class hierarchy by a fairly mechanical procedure (cf. <ref> [20] </ref>, [13]). Every rule of the form &lt;N&gt; ::= &lt;N0&gt; &lt;N1&gt; can be turned into a class N, derived from Nonterminal, which has two members of type N0 and N1, respectively.
References-found: 20

