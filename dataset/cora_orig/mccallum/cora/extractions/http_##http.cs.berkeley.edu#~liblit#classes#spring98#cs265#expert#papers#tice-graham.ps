URL: http://http.cs.berkeley.edu/~liblit/classes/spring98/cs265/expert/papers/tice-graham.ps
Refering-URL: http://http.cs.berkeley.edu/~liblit/classes/spring98/cs265/expert/
Root-URL: 
Email: cmtice@cs.berkeley.edu  graham@cs.berkeley.edu  
Title: OPTVIEW: A New Approach for Examining Optimized Code  
Author: Caroline Tice Susan L. Graham 
Address: Berkeley  
Affiliation: University of California, Berkeley  University of California,  
Abstract: The task of mapping between source programs and machine code, once the code has been optimized and transformed by a compiler is often difficult. Yet there are many instances, such as debugging optimized code or attributing performance analysis data to source lines, when it is useful or necessary to understand at the source level what is occurring in the binary. The standard approach has been for tools to attempt to map directly from the optimized binary to the original source. Such mappings are often fragile, and sometimes inaccurate or misleading. We suggest an alternative approach. Rather than mapping directly between the original source and the binary, we create a modified version of the source program, still recognizable, but updated to reflect some of the effects of optimizations, thus facilitating mapping from the binary. We have implemented a tool, Optview, to demonstrate and test these ideas. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Adl-Tabatabai, </author> <title> "Source Level Debugging of Globally Optimized Code", </title> <type> Ph.D. Dissertation, </type> <institution> Carnegie-Mellon University, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: The key instruction for a function call is the jump to the code for that function. Key functionality is not a completely new concept. It is closely related to the idea of semantic breakpoints <ref> [1, 6, 12] </ref>. Not all language statements have a single easily identifiable key instructions. Some control flow constructs have multiple key instructions. Most types of language statements have an easily identifiable corresponding key instruction (for instance, the conditional branch used for a conditional statement).
Reference: [2] <author> P. Breuer and J. Bowen, </author> <title> "Decompilation: The Enumeration of Types and Grammars", </title> <journal> in ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 16, No. 5, </volume> <month> Sept. </month> <year> 1994. </year>
Reference-contexts: The greatest difficulty in creating modified code that compiles has been to get the types and declarations correct. A natural question at this point is why not use reverse engineering techniques to obtain an optimized source program directly from the optimized binary <ref> [2, 4, 9, 10] </ref>. The reason for not doing so is that the new program must be recognizable and understandable by someone familiar with the original program.
Reference: [3] <author> G. Brooks, G. Hansen, and S. Simmons, </author> <title> "A New Approach to Debugging Optimized Code", </title> <booktitle> Proceedings of the 1992 PLDI Conference, </booktitle> <year> 1992 </year>
Reference-contexts: The designers of the Convex debugger for optimized code <ref> [3] </ref>, created an extremely fine-grained, accurate mapping between the optimized binary and the original source. The debugger then used a combination of highlighting and code animation (in the original source) to show the user exactly what was happening in the binary. There are several problems with this approach.
Reference: [4] <author> C. Cifuentes and K. Gough, </author> <title> "Decompilation of Binary Programs", </title> <type> Technical Report FIT-TR-94-03, </type> <institution> Faculty of Information Technology, Queensland University of Technology, Australia, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: The greatest difficulty in creating modified code that compiles has been to get the types and declarations correct. A natural question at this point is why not use reverse engineering techniques to obtain an optimized source program directly from the optimized binary <ref> [2, 4, 9, 10] </ref>. The reason for not doing so is that the new program must be recognizable and understandable by someone familiar with the original program.
Reference: [5] <author> L. </author> <title> Cool, "Debugging VLIW Code After Instruction Scheduling", M.S. </title> <type> Thesis, </type> <institution> Oregon Graduate Institute of Science and Technology, </institution> <month> July </month> <year> 1992 </year>
Reference-contexts: Also, unless the user knows a lot about optimizations already, it can be more confusing than informative to see highlighting jump around all over the code. Cool describes the design of a system to make instruction scheduling apparent in a VLIW machine <ref> [5] </ref>. Cool focussed entirely on this single optimization, and never actually implemented his design. Some of the work done by Optview is reminiscent of term rewriting systems (TRSs) and could possibly be done using such a framework [8].
Reference: [6] <author> M. Copperman, </author> <title> "Debugging Optimized Code without Being Misled", </title> <type> Ph.D. Dissertation, </type> <institution> University of California, Santa Cruz, </institution> <month> May </month> <year> 1994 </year>
Reference-contexts: The key instruction for a function call is the jump to the code for that function. Key functionality is not a completely new concept. It is closely related to the idea of semantic breakpoints <ref> [1, 6, 12] </ref>. Not all language statements have a single easily identifiable key instructions. Some control flow constructs have multiple key instructions. Most types of language statements have an easily identifiable corresponding key instruction (for instance, the conditional branch used for a conditional statement).
Reference: [7] <author> D. Coutant, S. Meloy, and M. Ruscetta, </author> <title> "DOC: A Practical Approach to Source-Level Debugging of Globally Optimized Code", </title> <booktitle> In Proceedings of the 1988 PLDI Conference, </booktitle> <year> 1988 </year>
Reference: [8] <author> A. van Deursen, P. Klint, F. </author> <title> Tip, "Origin Tracking", </title> <journal> Journal of Symbolic Computation 15, </journal> <year> 1993 </year>
Reference-contexts: Cool focussed entirely on this single optimization, and never actually implemented his design. Some of the work done by Optview is reminiscent of term rewriting systems (TRSs) and could possibly be done using such a framework <ref> [8] </ref>. In particular, rewriting multifunctional language constructs in simpler terms, as well as applying CSE, PRE, and copy propagation effects could all be done using such a system.
Reference: [9] <author> D. Jackson and E. Rollins, </author> <title> "A New Model of Program Dependences for Reverse Engineering", </title> <booktitle> in Proceedings of the 1994 ACM SIGSOFT Conference, </booktitle> <month> December </month> <year> 1994. </year>
Reference-contexts: The greatest difficulty in creating modified code that compiles has been to get the types and declarations correct. A natural question at this point is why not use reverse engineering techniques to obtain an optimized source program directly from the optimized binary <ref> [2, 4, 9, 10] </ref>. The reason for not doing so is that the new program must be recognizable and understandable by someone familiar with the original program.
Reference: [10] <author> R. Sites, A. Chernoff, M. Kirk, M. Marks, and S. Robinson, </author> <title> "Binary Translation", </title> <journal> Communications of the ACM, </journal> <volume> Vol. 36, No. 2, </volume> <month> February </month> <year> 1993. </year>
Reference-contexts: The greatest difficulty in creating modified code that compiles has been to get the types and declarations correct. A natural question at this point is why not use reverse engineering techniques to obtain an optimized source program directly from the optimized binary <ref> [2, 4, 9, 10] </ref>. The reason for not doing so is that the new program must be recognizable and understandable by someone familiar with the original program.
Reference: [11] <author> R. Wismueller, </author> <title> "Debugging of Globally Optimized Programs Using Data Flow Analysis", </title> <booktitle> In Proceedings of the 1994 PLDI Conference, </booktitle> <year> 1994. </year>
Reference: [12] <author> P. Zellweger, </author> <title> "High Level Debugging of Optimized Code", </title> <type> Ph.D. Dissertation, </type> <institution> University of Califor-nia, Berkeley, </institution> <month> May </month> <year> 1984. </year> <month> 8 </month>
Reference-contexts: The key instruction for a function call is the jump to the code for that function. Key functionality is not a completely new concept. It is closely related to the idea of semantic breakpoints <ref> [1, 6, 12] </ref>. Not all language statements have a single easily identifiable key instructions. Some control flow constructs have multiple key instructions. Most types of language statements have an easily identifiable corresponding key instruction (for instance, the conditional branch used for a conditional statement).
References-found: 12

