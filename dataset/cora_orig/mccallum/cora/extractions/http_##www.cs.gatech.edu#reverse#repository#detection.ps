URL: http://www.cs.gatech.edu/reverse/repository/detection.ps
Refering-URL: http://www.cs.gatech.edu/reverse/repos.html
Root-URL: 
Email: fspencer, kurt, lindag@cc.gatech.edu  
Title: Detecting Interleaving  
Author: Spencer Rugaber, Kurt Stirewalt, and Linda M. Wills 
Address: Atlanta, Georgia 30332-0280  
Affiliation: College of Computing Georgia Institute of Technology  
Abstract: The various goals and requirements of a system are realized in software as fragments of code that are typically "interleaved" in that they may be woven together in the same contiguous textual area of code. The fragments of code are often delocalized and overlap rather than being composed in a simple linear sequence. Interleaving severely complicates software comprehension and maintenance. To address this problem, we are developing analysis tools, based on the Software Refinery. This paper describes our experiences in detecting interleaving in a corpus of mathematical software written in Fortran from the Jet Propulsion Laboratory. In particular, it discusses how feasible it is to detect interleaving of various types and the ability of existing tools to assist these types of detection. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aho, R. Sethi, and J. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: It should be obvious from our other examples that the contains function is simple to construct in Refine. We can express the execution conditions regarding S 1 and S 2 using a construct from flow analysis called a dominator <ref> [1] </ref>. We say that the call of S 1 dominates the call of S 2 if the call of S 2 implies that S 1 has already been called in that routine.
Reference: [2] <author> T. Biggerstaff, B. Mitbander, and D. Webster. </author> <title> Program understanding and the concept assignment problem. </title> <journal> Comm. of the ACM, </journal> <volume> 37(5) </volume> <pages> 72-83, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: This particular kind of interleaving was also easily detected. In general, the detection and extraction of interleaved fragments is a hard problem. It is related to overlapping implementations [18], potpourri module detection [5], slicing [25, 15], cluster analysis <ref> [2, 10, 21] </ref>, and objectivization (the extraction of candidate objects from non-object oriented programs) [3, 6, 7]. To the extent that the analysis can be based on program information only, the approach we have undertaken appears adequate.
Reference: [3] <author> R. Bowdidge and W. Griswold. </author> <title> Automated support for encapsulating abstract data types. </title> <booktitle> In Proc. 2nd ACM SIGSOFT Symp. on Foundations of Software Engineering, </booktitle> <pages> pages 97-110, </pages> <address> New Orleans, </address> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: In general, the detection and extraction of interleaved fragments is a hard problem. It is related to overlapping implementations [18], potpourri module detection [5], slicing [25, 15], cluster analysis [2, 10, 21], and objectivization (the extraction of candidate objects from non-object oriented programs) <ref> [3, 6, 7] </ref>. To the extent that the analysis can be based on program information only, the approach we have undertaken appears adequate. However, interleaved fragments are instantiations of plans, and many plans are direct expressions of application domain requirements.
Reference: [4] <author> R. Brooks. </author> <title> Towards a theory of the comprehension of computer programs. </title> <journal> Int. Journal of Man-Machine Studies, </journal> <volume> 18 </volume> <pages> 543-554, </pages> <year> 1983. </year>
Reference-contexts: Plans can occur and be interleaved at any abstraction level from source code text to application domain structures. The process of understanding a piece of software involves two parallel knowledge acquisition activities <ref> [4, 16, 23] </ref>: 1. using domain knowledge to understand the code knowledge about the application sets up expectations about how abstract concepts are typically manifested in concrete code implementations; 2. using knowledge of the code to understand the domain what is discovered in the code is used to build up a
Reference: [5] <author> F. Calliss and B. Cornelius. </author> <title> Potpourri module detection. </title> <booktitle> In IEEE Conf. on Software Maintenance - 1990, </booktitle> <pages> pages 46-51, </pages> <address> San Diego, CA, November 1990. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: For example, routines with multiple outputs share intermediate computations as a way of improving run-time efficiency. This particular kind of interleaving was also easily detected. In general, the detection and extraction of interleaved fragments is a hard problem. It is related to overlapping implementations [18], potpourri module detection <ref> [5] </ref>, slicing [25, 15], cluster analysis [2, 10, 21], and objectivization (the extraction of candidate objects from non-object oriented programs) [3, 6, 7]. To the extent that the analysis can be based on program information only, the approach we have undertaken appears adequate.
Reference: [6] <author> G. Canfora, A. Cimitile, and M. Munro. </author> <title> A reverse engineering method for identifying reusable abstract data types. </title> <booktitle> In Proc. of the First Working Conference on Reverse Engineering, </booktitle> <pages> pages 73-82, </pages> <address> Baltimore, Maryland, May 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: In general, the detection and extraction of interleaved fragments is a hard problem. It is related to overlapping implementations [18], potpourri module detection [5], slicing [25, 15], cluster analysis [2, 10, 21], and objectivization (the extraction of candidate objects from non-object oriented programs) <ref> [3, 6, 7] </ref>. To the extent that the analysis can be based on program information only, the approach we have undertaken appears adequate. However, interleaved fragments are instantiations of plans, and many plans are direct expressions of application domain requirements.
Reference: [7] <author> A. Cimitile, M. Tortorella, and M. Munro. </author> <title> Program comprehension through the identification of abstract data types. </title> <booktitle> In Proc. 3rd Workshop on Program Comprehension, </booktitle> <pages> pages 12-19, </pages> <address> Washington, D.C., November 1994. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: In general, the detection and extraction of interleaved fragments is a hard problem. It is related to overlapping implementations [18], potpourri module detection [5], slicing [25, 15], cluster analysis [2, 10, 21], and objectivization (the extraction of candidate objects from non-object oriented programs) <ref> [3, 6, 7] </ref>. To the extent that the analysis can be based on program information only, the approach we have undertaken appears adequate. However, interleaved fragments are instantiations of plans, and many plans are direct expressions of application domain requirements.
Reference: [8] <author> J-M. DeBaud, B. Moopen, and S. Rugaber. </author> <title> Domain analysis and reverse engineering. </title> <booktitle> In IEEE Conf. on Software Maintenance - 1994, </booktitle> <pages> pages 326-335. </pages>
Reference-contexts: The simultaneous elaboration of application and program understanding is characteristic of Synchronized Refinement, the overarching approach we take to reverse engineering [16]. How best to express and use the domain information is still an open question, however, but some discussion of the issues is provided in <ref> [8] </ref>. We expect the use of domain information to be a prerequisite for further significant increases in the power of program understanding technology. 5.4 Future Directions The work described here raises several further questions related to interleaving. One of these concerns the appropriate level of abstraction in the domain model.
Reference: [9] <author> A. Garlan and M. Shaw. </author> <title> Software Architecture: Perspectives on an Emerging Discipline. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1995. </year>
Reference-contexts: But this will not always be true. In fact, architectures can be interleaved just like programs. This problem appears to be quite hard, but we can see attacking it both from the top down, by trying to detect instances of specific architectural styles <ref> [9] </ref>, and from the bottom up, by trying to detect specific kinds of module groupings, such as the afferent, efferent, and transformer modules that are a part of Structured Design [24]. Acknowledgments Support for this research has been provided by ARPA under order number A870, contract number NAG 2-890.
Reference: [10] <author> D. Hutchens and V. Basili. </author> <title> System structure analysis: Clustering with data bindings. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 11(8), </volume> <month> August </month> <year> 1985. </year>
Reference-contexts: This particular kind of interleaving was also easily detected. In general, the detection and extraction of interleaved fragments is a hard problem. It is related to overlapping implementations [18], potpourri module detection [5], slicing [25, 15], cluster analysis <ref> [2, 10, 21] </ref>, and objectivization (the extraction of candidate objects from non-object oriented programs) [3, 6, 7]. To the extent that the analysis can be based on program information only, the approach we have undertaken appears adequate.
Reference: [11] <institution> Reasoning Systems Incorporated. Software Refinery Toolkit. </institution> <address> Palo Alto, CA. </address>
Reference-contexts: Software Refinery We are developing mechanisms for detecting various classes of interleaving with the aim of growing a partial model of the application domain. We are building these mechanisms on a collection of commercial tools, called the Software Refinery <ref> [11] </ref>. This is a comprehensive tool suite including language-specific analyzers and browsers for Fortran, C, Ada, and Cobol, language extension mechanisms for building new analyzers, and a user interface construction tool for displaying the results of analysis.
Reference: [12] <author> W. Kozaczynski and J.Q. Ning. </author> <title> Automated program understanding by concept recognition. </title> <journal> Automated Software Engineering, </journal> <volume> 1(1) </volume> <pages> 61-78, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: This requires the use of cliche recognition techniques (e.g., <ref> [12, 17, 26] </ref>). It also raises the question of describing the domain itself in Refine, and consequently being able to reason about it. We would also like to look at architectural issues.
Reference: [13] <author> S. Letovsky and E. Soloway. </author> <title> Delocalized plans and program comprehension. </title> <journal> IEEE Software, </journal> <volume> 3(3), </volume> <year> 1986. </year>
Reference-contexts: We use the term plan to denote a description or representation of a computational structure that the designers have proposed as a way of achieving some purpose or goal in a program <ref> [13, 19] </ref>. Plans can occur at any level of abstraction from architectural overviews to code. Interleaving expresses the merging of two or more distinct plans within some contiguous textual area of a program. <p> Because two or more design purposes are implemented in a single segment of code, each individual code fragment responsible for a separate purpose is more spread out than it would be if it were encapsulated. This makes it difficult to gather together all the pieces to ensure consistent maintenance <ref> [13] </ref>. Distracting details also get in the way and must be filtered out from the midst of the delocalized plan.
Reference: [14] <author> M. Lowry, A. Philpot, T. Pressburger, and I. Under-wood. </author> <title> A formal approach to domain-oriented software design environments. </title> <booktitle> In Knowledge-based Software Engineering Conference, </booktitle> <year> 1994. </year>
Reference-contexts: Amphion Domain Model We have obtained a partial model of the application domain of this software from NASA Ames researchers, who have developed a component-based software synthesis system, called Amphion <ref> [14] </ref>. Am-phion composes routines from SPICELIB by making use of a domain theory that includes formal specifications of the library routines, connecting them to abstract concepts in the solar system geometry domain.
Reference: [15] <author> J.Q. Ning, A. Engberts, and W. Kozaczynski. </author> <title> Automated support for legacy code understanding. </title> <journal> Comm. of the ACM, </journal> <volume> 37(5) </volume> <pages> 50-57, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: This particular kind of interleaving was also easily detected. In general, the detection and extraction of interleaved fragments is a hard problem. It is related to overlapping implementations [18], potpourri module detection [5], slicing <ref> [25, 15] </ref>, cluster analysis [2, 10, 21], and objectivization (the extraction of candidate objects from non-object oriented programs) [3, 6, 7]. To the extent that the analysis can be based on program information only, the approach we have undertaken appears adequate.
Reference: [16] <author> S. Ornburn and S. Rugaber. </author> <title> Reverse engineering: Resolving conflicts between expected and actual software designs. </title> <booktitle> In IEEE Conf. on Software Maintenance - 1992, </booktitle> <pages> pages 32-40, </pages> <address> Orlando, Florida, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: Plans can occur and be interleaved at any abstraction level from source code text to application domain structures. The process of understanding a piece of software involves two parallel knowledge acquisition activities <ref> [4, 16, 23] </ref>: 1. using domain knowledge to understand the code knowledge about the application sets up expectations about how abstract concepts are typically manifested in concrete code implementations; 2. using knowledge of the code to understand the domain what is discovered in the code is used to build up a <p> For example, there were situations where a routine computed several results, but the domain model only described one of them. The simultaneous elaboration of application and program understanding is characteristic of Synchronized Refinement, the overarching approach we take to reverse engineering <ref> [16] </ref>. How best to express and use the domain information is still an open question, however, but some discussion of the issues is provided in [8].
Reference: [17] <author> A. Quilici. </author> <title> A memory-based approach to recognizing programming plans. </title> <journal> Comm. of the ACM, </journal> <volume> 37(5) </volume> <pages> 84-93, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: This requires the use of cliche recognition techniques (e.g., <ref> [12, 17, 26] </ref>). It also raises the question of describing the domain itself in Refine, and consequently being able to reason about it. We would also like to look at architectural issues.
Reference: [18] <author> C. Rich. </author> <title> A formal representation for plans in the Programmer's Apprentice. </title> <booktitle> In Proc. 7th Int. Joint Conf. Artificial Intelligence, </booktitle> <pages> pages 1044-1052, </pages> <address> Vancou-ver, British Columbia, Canada, </address> <month> August </month> <year> 1981. </year>
Reference-contexts: For example, routines with multiple outputs share intermediate computations as a way of improving run-time efficiency. This particular kind of interleaving was also easily detected. In general, the detection and extraction of interleaved fragments is a hard problem. It is related to overlapping implementations <ref> [18] </ref>, potpourri module detection [5], slicing [25, 15], cluster analysis [2, 10, 21], and objectivization (the extraction of candidate objects from non-object oriented programs) [3, 6, 7]. To the extent that the analysis can be based on program information only, the approach we have undertaken appears adequate.
Reference: [19] <author> C. Rich and R. C. Waters. </author> <title> The Programmer's Apprentice. </title> <publisher> Addison-Wesley and ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: We use the term plan to denote a description or representation of a computational structure that the designers have proposed as a way of achieving some purpose or goal in a program <ref> [13, 19] </ref>. Plans can occur at any level of abstraction from architectural overviews to code. Interleaving expresses the merging of two or more distinct plans within some contiguous textual area of a program. <p> In our case, the domain model that we used was fairly low level. If the ultimate goal is to map a program back to its requirements, then, program constructs must be described in terms of domain vocabulary. For example, if we can detect certain stereotypical constructs (called cliches <ref> [19] </ref>) and map them back to a domain concept (such as an ellipsoid or an orthogonal projection), then we can use our knowledge of geometry to further understand and describe a program. This requires the use of cliche recognition techniques (e.g., [12, 17, 26]).
Reference: [20] <author> S. Rugaber, K. Stirewalt, and L. Wills. </author> <title> The interleaving problem in program understanding. </title> <booktitle> In Proc. of the Second Working Conference on Reverse Engineering, </booktitle> <address> July 1995. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Using the Software Refinery allows us to leverage commercially available tools as well as evaluate the strengths and limitations of its approach to program analysis. 1.2 Contributions and Outline of Paper We have developed an initial characterization of interleaving <ref> [20] </ref>, based primarily on an empirical study of SPICELIB. We briefly summarize our characterization in Section 2. We then present a detailed example of one of the mechanisms we have built to detect a particular type of interleaving the interleaving of exception-handling code with the program's primary computation. <p> Interleaving can be characterized by the delocalization of the code for the individual plans involved, the sharing of some resource, and the performance of multiple, independent roles in the program's overall purpose. (Our characterization of interleaving and several detailed examples are presented in more depth in <ref> [20] </ref>.) There are several reasons why interleaving is a source of difficulties. The first has to do with delo-calization. <p> It seems likely that if every call of a subprogram passes a constant parameter, then that subprogram is involved in control coupling interleaving. We expect to test this variant along with the original analysis to see if there is a correspondence of results. Routine Co-occurrence Properties. In <ref> [20] </ref> we described a general form of interleaving called reformulation wrappers. A reformulation wrapper is used to transform one problem into another that is simpler to solve and then to transfer the solution back to the original situation.
Reference: [21] <author> R. Schwanke. </author> <title> An intelligent tool for re-engineering software modularity. </title> <booktitle> In IEEE Conf. on Software Maintenance - 1991, </booktitle> <pages> pages 83-92, </pages> <year> 1991. </year>
Reference-contexts: This particular kind of interleaving was also easily detected. In general, the detection and extraction of interleaved fragments is a hard problem. It is related to overlapping implementations [18], potpourri module detection [5], slicing [25, 15], cluster analysis <ref> [2, 10, 21] </ref>, and objectivization (the extraction of candidate objects from non-object oriented programs) [3, 6, 7]. To the extent that the analysis can be based on program information only, the approach we have undertaken appears adequate.
Reference: [22] <author> D. Smith, G. Kotik, and S. Westfold. </author> <title> Research on knowledge-based software environments at Kestrel Institute. </title> <journal> IEEE Trans. on Software Engineering, </journal> <month> Novem-ber </month> <year> 1985. </year>
Reference-contexts: It maintains an object oriented repository for holding the results of anal-yses, such as abstract syntax trees and symbol tables. It provides a powerful wide-spectrum language, called Refine <ref> [22] </ref>, which supports pattern matching and querying the repository.
Reference: [23] <author> E. Soloway and K. Ehrlich. </author> <title> Empirical studies of programming knowledge. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 10(5) </volume> <pages> 595-609, </pages> <month> September </month> <year> 1984. </year>
Reference-contexts: Plans can occur and be interleaved at any abstraction level from source code text to application domain structures. The process of understanding a piece of software involves two parallel knowledge acquisition activities <ref> [4, 16, 23] </ref>: 1. using domain knowledge to understand the code knowledge about the application sets up expectations about how abstract concepts are typically manifested in concrete code implementations; 2. using knowledge of the code to understand the domain what is discovered in the code is used to build up a
Reference: [24] <author> W. Stevens, G. Myers, and L. Constantine. </author> <title> Structured design. </title> <journal> IBM Systems Journal, </journal> <volume> 13(2) </volume> <pages> 115-139, </pages> <year> 1974. </year>
Reference-contexts: but we can see attacking it both from the top down, by trying to detect instances of specific architectural styles [9], and from the bottom up, by trying to detect specific kinds of module groupings, such as the afferent, efferent, and transformer modules that are a part of Structured Design <ref> [24] </ref>. Acknowledgments Support for this research has been provided by ARPA under order number A870, contract number NAG 2-890. We would like to thank Larry Markosian for helping us to obtain the Software Refinery and the NAIF group at JPL for enabling our study of SPICELIB.
Reference: [25] <author> M. Weiser. </author> <title> Program slicing. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 10 </volume> <pages> 352-357, </pages> <year> 1984. </year>
Reference-contexts: What is needed is to isolate the separate strands of computation, understand them individually and then see how they interrelate. We are building analysis tools to do this. Traditional slicing techniques <ref> [25] </ref> are applicable to this problem but are not powerful enough to disentangle all forms of interleaving. <p> This particular kind of interleaving was also easily detected. In general, the detection and extraction of interleaved fragments is a hard problem. It is related to overlapping implementations [18], potpourri module detection [5], slicing <ref> [25, 15] </ref>, cluster analysis [2, 10, 21], and objectivization (the extraction of candidate objects from non-object oriented programs) [3, 6, 7]. To the extent that the analysis can be based on program information only, the approach we have undertaken appears adequate.
Reference: [26] <author> L. Wills. </author> <title> Automated program recognition by graph parsing. </title> <type> Technical Report 1358, </type> <institution> MIT Artificial Intelligence Lab., </institution> <month> July </month> <year> 1992. </year> <type> PhD Thesis. </type>
Reference-contexts: This requires the use of cliche recognition techniques (e.g., <ref> [12, 17, 26] </ref>). It also raises the question of describing the domain itself in Refine, and consequently being able to reason about it. We would also like to look at architectural issues.
Reference: [27] <author> E. Yourdon and L. Constantine. </author> <title> Structured Design: Fundamentals of a Discipline of Computer Program and Systems Design. </title> <publisher> Prentice-Hall, </publisher> <year> 1979. </year>
Reference-contexts: Control Coupling. Sometimes a programmer will implement a subprogram that uses one of its input parameters as a flag to choose among a set of possible computations to perform. This is a form of control coupling <ref> [27] </ref>: "any connection between two modules that communicates elements of control," and it is a class of interleaving involving delocalized control. Subprogram calls with constant parameter values are potentially involved in control coupling.
References-found: 27

