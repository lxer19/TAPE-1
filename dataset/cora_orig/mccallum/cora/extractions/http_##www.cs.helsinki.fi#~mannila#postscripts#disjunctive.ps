URL: http://www.cs.helsinki.fi/~mannila/postscripts/disjunctive.ps
Refering-URL: http://www.cs.helsinki.fi/~mannila/data-mining-publications.html
Root-URL: 
Email: Email: mannila@cs.helsinki.fi.  
Title: Disjunctive Datalog  Polynomial Hierarchy collapses, disjunctive datalog is more expressive than normal logic programming with negation.  
Author: Thomas Eiter Georg Gottlob Heikki Mannila 
Keyword: Categories and Subject Descriptors: H.2.3 [Database Management]: Query Languages; D.1.6 [Programming Techniques]: Logic Programming; I.2.3 [Artificial Intelligence]: Deduction and Theorem Proving; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods; F.2.2 [Analysis of Algorithms and Problem Complexity]: Nonnumerical Algorithms and Problems; F.4.1 [Mathematical Logic and Formal Languages]: Mathematical Logic General Terms: Theory Additional Key Words and Phrases: datalog, disjunctive logic programming, deductive systems, expressive power, finite model theory, finite structures, descriptive complexity theory.  
Address: Helsinki, P.O. Box 26, FIN-00014 Helsinki, Finland.  
Affiliation: Department of Computer Science, University of  
Note: ACM Transactions on Database Systems, to appear.  2 Thus, unless the  Part of this authors' work has been carried out while visiting the Technical University of Vienna.  
Abstract: We consider disjunctive datalog, a powerful database query language based on disjunctive logic programming. Briefly, disjunctive datalog is a variant of datalog where disjunctions may appear in the rule heads; advanced versions also allow for negation in the bodies, which can be handled according to a semantics for negation in disjunctive logic programming. In particular, we investigate three different semantics for disjunctive datalog: the minimal model semantics, the perfect models semantics, and the stable model semantics. For each of these semantics, the expressive power and complexity are studied. We show that the possibility variants of these semantics express the same set of queries. In fact, they precisely capture the complexity class p These results are not only of theoretical interest; we demonstrate that problems relevant in practice such as computing the optimal tour value in the Traveling Salesman Problem and eigenvector computations can be handled in disjunctive datalog, but not datalog with negation (unless the Polynomial Hierarchy collapses). In addition, we study modularity properties of disjunctive datalog and investigate syntactic restrictions of the formalisms. fl This paper substantially augments and improves an extended abstract presented at PODS '94 [34]. y Computer Science Group, Faculty of Mathematics, University of Gieen, Arndtstrae 2, D-35392 Germany. Email: Thomas.Eiter@informatik.uni-giessen.de z Information Systems Department, Technical University of Vienna, Paniglgasse 16, A-1040 Wien, Aus-tria. Email: (eiter|gottlob)@dbai.tuwien.ac.at
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Abiteboul, E. Simon, and V. Vianu. </author> <title> Non-Deterministic Languages to Express Deterministic Transformations. </title> <booktitle> In Proc. PODS '90, </booktitle> <pages> pp. 218-229, </pages> <year> 1990. </year>
Reference-contexts: The result of the query computed by a query program (i.e., of ()) on an input database D is defined in terms of the models S (; D), by taking as usual either the union of all models or the intersection <ref> [1, 78] </ref>. The former approach (union) is known as possibility inference (also termed brave or credulous reasoning in the AI community), and the latter (intersection) as certainty inference (also termed cautious or skeptical inference) [42, 1]. Definition 3.4 Let inf be an inference modality from p (ossibility), c (ertainty). <p> The former approach (union) is known as possibility inference (also termed brave or credulous reasoning in the AI community), and the latter (intersection) as certainty inference (also termed cautious or skeptical inference) <ref> [42, 1] </ref>. Definition 3.4 Let inf be an inference modality from p (ossibility), c (ertainty).
Reference: [2] <author> S. Abiteboul, R. Hull, and V. Vianu. </author> <title> Foundations of Databases. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Our results provide a clear picture of the expressiveness of disjunctive datalog in the various settings. Moreover, they complement and extend previous results of important extensions of datalog and related query languages (see <ref> [2, 44] </ref>). Note that the major versions of DATALOG : [47, 78, 84] express database queries in NP (resp. co-NP) under possibility (resp. certainty) inference. Thus, disjunction adds expressive power (unless 2 = NP). A consequence of the high expressive power of disjunctive datalog is a high worst-case complexity. <p> compares disjunctive datalog to common and novel database query languages, addresses the issue of why its precise expressiveness characterization is relevant, and outlines open issues for future work. 2 Preliminaries We assume familiarity with the basic concepts of complexity theory and logical query languages for databases; for a background, see <ref> [64, 83, 19, 2] </ref>. A relational scheme over a domain Dom is a (possibly empty) list R = R 1 ; : : : ; R k of relation symbols R i , i = 1; : : : ; k of arity a (R i ) 0. <p> We consider first boolean (generic) queries and then general (generic) queries. In order to assure genericity of queries, we focus on disjunctive datalog programs that are constant-free. Constants in queries are not an issue, since they can be provided by designated input relations (see <ref> [2, Section 9] </ref>). The following proposition on the complexity of minimal, stable, and perfect models of propositional programs is well-known. Proposition 6.1 [32] Let be a propositional (i.e., ground) program and let p be a propositional atom. <p> It is known that many prominent query languages (e.g., stratified datalog, fixpoint queries, while queries etc) can only express queries that are definable in L ! 1! <ref> [48, 49, 2] </ref>. Moreover, it is known that L ! 1! has a 0-1 law, i.e., every query from this language is either almost surely true or almost surely false, if the size of the universe grows to infinity [48]. <p> Moreover, by our complexity-theoretic characterization of the expressiveness of disjunctive datalog ( p 2 ), we are able to compare disjunctive datalog with well-known database query languages. These relationships are depicted in Figure 2. Proofs and/or references for the other query languages appearing in this figure can found in <ref> [2] </ref>; here, DATALOG : wf denotes nondisjunctive datalog with well-founded negation [84]. Solid lines represent proper inclusion (), while dashed lines stand for possibly improper inclusion (). In the latter case, it is currently not known, but strongly believed that the inclusion is proper. <p> A similar comment applies to several other expressive query languages studied in the literature, for example, to the language of While-Queries studied by Chandra and Harel [20] and the language of Partial Fixpoint Queries considered by Abiteboul and Vianu (cf. <ref> [2] </ref>). The latter two languages both capture the highly intractable complexity-class PSPACE. This raises the question of whether it makes sense to study such expressive, and therefore complex, query languages.
Reference: [3] <author> J. Balcazar, A. Lozano, and J. Toran. </author> <title> The Complexity of Algorithmic Problems on Succinct Instances. </title> <editor> In R. Baeta-Yates and U. Manber, editors, </editor> <booktitle> Computer Science, </booktitle> <pages> pp. 351-377. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: Notice that NP NEXP-TIME NP , and hence NEXPTIME NP -complete problems are provably intractable; few natural among them are known. We establish the NEXPTIME NP -completeness results using complexity upgrade techniques that extend results in <ref> [3, 63, 64] </ref>, applied to results in [80]. * We demonstrate the practical relevance of disjunctive datalog by exhibiting queries which can be expressed in disjunctive datalog but not in standard datalog with negation (DATALOG : ) unless the Polynomial Hierarchy collapses. <p> The proof of this result relies on the use of complexity upgrade techniques that extend the results in <ref> [3, 63] </ref>, applied to results in [80], and the simulation of boolean circuits by a DATALOG _ program without 6= and negation under minimal model semantics. In [47], a similar simulation was described in DATALOG :;6= using stratified negation and fixpoint semantics. <p> In [47], a similar simulation was described in DATALOG :;6= using stratified negation and fixpoint semantics. Briefly, the proof consists in a reduction of a problem on graphs, co-CERT3COL [80], in its succinct version co-CERT3COL S <ref> [3] </ref>, i.e., the problem input consists of a boolean circuit C w by which the bits of the standard problem input w (a binary string encoding the graph) can be computed. Using the complexity upgrade techniques, we show that co-CERT3COL S is exp 2 -complete. <p> For not-gates, j = k (cf. [47]). As shown in [63], the succinct problem setting often leads to an exponential complexity increase. The results and techniques of [63] (see also [64]) were generalized in <ref> [3] </ref> to the succinct version of any decision problem A encoded as a language over f0; 1g. <p> The following theorem shows how to obtain hardness results under polynomial-time trans-formability ( p m ) for the succinct problem version from hardness of the standard problem under polylogtime transformability ( P LT m ). This theorem is a generalization of <ref> [3, The orem 5] </ref>, where the theorem is formulated for logtime transformability ( LT m ). <p> Then, for every B, if B is hard for C2 under P LT m -transformation, then B S is hard for C1 under p m -transformation. 34 Proof. (Sketch) The theorem can be easily shown along the lines of the proof of Theorem 5 in <ref> [3] </ref> by using a generalization of the following Conversion Lemma in [3]: If A LT m B then A S p m B S . It can be seen, by carefully looking at the proof in [3], that the Conversion Lemma remains valid if A LT m B is replaced by <p> is hard for C2 under P LT m -transformation, then B S is hard for C1 under p m -transformation. 34 Proof. (Sketch) The theorem can be easily shown along the lines of the proof of Theorem 5 in <ref> [3] </ref> by using a generalization of the following Conversion Lemma in [3]: If A LT m B then A S p m B S . It can be seen, by carefully looking at the proof in [3], that the Conversion Lemma remains valid if A LT m B is replaced by A P LT m B. <p> can be easily shown along the lines of the proof of Theorem 5 in <ref> [3] </ref> by using a generalization of the following Conversion Lemma in [3]: If A LT m B then A S p m B S . It can be seen, by carefully looking at the proof in [3], that the Conversion Lemma remains valid if A LT m B is replaced by A P LT m B. To show the theorem, assume that B is hard for C2 under P LT m -transformation, and let A 2 C1 be arbitrary.
Reference: [4] <author> C. Baral and M. Gelfond. </author> <title> Logic Programming and Knowledge Representation. </title> <journal> J. Logic Programming, </journal> 19/20:73-148, 1994. 
Reference-contexts: For example, a DLP may contain rules such as M ale (x) _ F emale (x) P erson (x): The usefulness of disjunctive rules for knowledge representation, database querying, and for representing incomplete information, is generally acknowledged (see <ref> [38, 4] </ref>). Various semantics of DLPs have been proposed; they are commonly based on the paradigm of minimal models, which underlies Minker's Generalized Closed World Assumption [58]. For an overview of various semantics for DLPs, the reader may consult [55] and Minker's more recent article [59].
Reference: [5] <author> C. Baral and V.S. Subrahmanian. </author> <title> Stable and Extension Class Theory for Logic Programs and Default Logic. </title> <journal> J. Automated Reasoning, </journal> <volume> 8 </volume> <pages> 345-366, </pages> <year> 1992. </year>
Reference-contexts: As shown in [12], the expressive powers of the two languages are different in that context. Autoepistemic logic [60] has the same expressive power as default logic [12]. Promising variants of default logic such as stable class default logic <ref> [5] </ref> remain to be explored. Acknowledgements The authors would like to thank several people for their comments on this work. In particular, we are indebted to P.A. Bonatti, J. Dix, K. Inoue, Ph. Kolaitis, J.S. Schlipf, H. Veith, and V. Vianu for important hints and comments.
Reference: [6] <author> C. Bell, A. Nerode, R. Ng, </author> <title> and V.S. Subrahmanian. Mixed Integer Programming Methods for Computing Non-Monotonic Deductive Databases. </title> <journal> JACM, </journal> <volume> 41(6) </volume> <pages> 1178-1215, </pages> <year> 1994. </year>
Reference-contexts: Seipel [79] in Wurzburg (Germany) implements various semantics and methods developed by Minker and his students [55, 59] at College Park (Maryland, U.S.A.). There, V.S. Subrahmanian and his coworkers <ref> [6, 61, 7] </ref>, use integer programming methods for implementing normal and disjunctive logic programming.
Reference: [7] <author> C. Bell, A. Nerode, R. Ng, </author> <title> and V.S. Subrahmanian. Implementing Deductive Databases by Mixed Integer Programming. </title> <journal> ACM Trans. on Database Syst., </journal> <volume> 21(2) </volume> <pages> 238-269, </pages> <year> 1996. </year>
Reference-contexts: Seipel [79] in Wurzburg (Germany) implements various semantics and methods developed by Minker and his students [55, 59] at College Park (Maryland, U.S.A.). There, V.S. Subrahmanian and his coworkers <ref> [6, 61, 7] </ref>, use integer programming methods for implementing normal and disjunctive logic programming.
Reference: [8] <author> R. Ben-Eliyahu and R. Dechter. </author> <title> Propositional Semantics for Disjunctive Logic Programs. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <volume> 12 </volume> <pages> 53-87, </pages> <year> 1994. </year>
Reference-contexts: Therefore, unless the Polynomial Hierarchy collapses, those examples can not be formulated in datalog with choice. Note that choice can be implemented using head-cycle-free disjunction <ref> [8] </ref>. Loosely speaking, a program is headcycle-free if no two distinct atoms which occur together in the head of a rule mutually depend on each other. <p> Note that choice can be implemented using head-cycle-free disjunction [8]. Loosely speaking, a program is headcycle-free if no two distinct atoms which occur together in the head of a rule mutually depend on each other. Since, by the results in <ref> [8, 35] </ref>, headcycle-free programs capture NP (resp. co-NP) under the possibility (resp. certainty) variant of the stable model semantics, it is not surprising that the programs exhibited in Example 3 and 4 are not headcycle-free. <p> Seipel [79] in Wurzburg (Germany) implements various semantics and methods developed by Minker and his students [55, 59] at College Park (Maryland, U.S.A.). There, V.S. Subrahmanian and his coworkers [6, 61, 7], use integer programming methods for implementing normal and disjunctive logic programming. Ben-Eliyahu <ref> [8, 9] </ref> (Ben Gurion University and Technion, Israel) has recently started a project of implementing a subclass of disjunctive logic programs (so called headcycle-free programs) that is less complex (thus also less powerful) than the full class; see [35] for more details. <p> Due to its plain syntax, DATALOG _;: is amenable for automatic program analysis and optimization. In particular, modularity properties (as described in Section 5) and natural syntactic restrictions on DA-TALOG _;: programs (such as head-cycle freeness) can be exploited to improve efficiency <ref> [8, 51] </ref>. On the other hand, due to its rich (and in some sense more succinct) syntax, DQL is far less accessible to such methods. For example, the concept of stratification for default theories is much more intricated than for logic programs [23].
Reference: [9] <author> R. Ben-Eliyahu and L. Palopoli. </author> <title> Reasoning with Minimal Models: Efficient Algorithms and Applications. </title> <booktitle> In Proc. Fourth Intl Conf. on Principles of Knowledge Representation and Reasoning (KR-94), </booktitle> <pages> pp. 39-50, </pages> <year> 1994. </year>
Reference-contexts: Seipel [79] in Wurzburg (Germany) implements various semantics and methods developed by Minker and his students [55, 59] at College Park (Maryland, U.S.A.). There, V.S. Subrahmanian and his coworkers [6, 61, 7], use integer programming methods for implementing normal and disjunctive logic programming. Ben-Eliyahu <ref> [8, 9] </ref> (Ben Gurion University and Technion, Israel) has recently started a project of implementing a subclass of disjunctive logic programs (so called headcycle-free programs) that is less complex (thus also less powerful) than the full class; see [35] for more details.
Reference: [10] <author> N. Bidoit and C. Froidevaux. </author> <title> Minimalism Subsumes Default Logic and Circumscription in Stratified Logic Programming. </title> <booktitle> In Proc. LICS-87, </booktitle> <pages> pp. 89-97. </pages> <publisher> IEEE CS Press, </publisher> <year> 1987. </year>
Reference-contexts: Proposition 3.2 [66] Let be a stratified program. Then, PM () = SM (). Moreover, (i) if is disjunction-free, then has a unique perfect (resp. stable) model; (ii) if is positive (i.e., :-free), then PM () = SM () = MM (). We remark that in <ref> [10] </ref> a semantics of stratified programs was proposed using default logic; it is equivalent to the stable (and also perfect) model semantics. The evaluation of a query program over a database amounts to evaluating the ground program given by the facts in the database plus the instantiated rules.
Reference: [11] <author> N. Bidoit and C. Froidevaux. </author> <title> General Logic Databases and Programs: Default Semantics and Stratification. </title> <journal> Information and Computation, </journal> <volume> 19 </volume> <pages> 15-54, </pages> <year> 1991. </year>
Reference-contexts: This naturally raises the question about how these formalisms are related, in particular with regard to possible translations. On one hand, note that each disjunctive logic program can be translated into an equivalent default theory. A concrete translation, related to earlier work in <ref> [11] </ref>, was described by Sakama and Inoue in [73]. Their translation is rather intuitive and modular, which means that the translation of a disjunctive logic program is obtained by the union of the independent translations of the single rules.
Reference: [12] <author> P. Bonatti and T. Eiter. </author> <title> Querying Disjunctive Databases Through Nonmonotonic Logics. </title> <booktitle> In Proc. 5th Intl. Conference on Database Theory (ICDT '95), </booktitle> <volume> LNCS 893, </volume> <pages> pp. 68-81, </pages> <year> 1995. </year> <note> Also Theoretical Computer Science, </note> <month> 160 </month> <pages> 321-363, </pages> <year> 1996. </year>
Reference-contexts: It seems that DQL is a suitable language for bridging the impedance mismatch between advanced knowledge representation and relational databases. Another aspect highlighting the difference between disjunctive datalog and DQL is their expressive power over disjunctive (clausal) databases. As shown in <ref> [12] </ref>, the expressive powers of the two languages are different in that context. Autoepistemic logic [60] has the same expressive power as default logic [12]. Promising variants of default logic such as stable class default logic [5] remain to be explored. <p> Another aspect highlighting the difference between disjunctive datalog and DQL is their expressive power over disjunctive (clausal) databases. As shown in <ref> [12] </ref>, the expressive powers of the two languages are different in that context. Autoepistemic logic [60] has the same expressive power as default logic [12]. Promising variants of default logic such as stable class default logic [5] remain to be explored. Acknowledgements The authors would like to thank several people for their comments on this work. In particular, we are indebted to P.A. Bonatti, J. Dix, K. Inoue, Ph. Kolaitis, J.S. Schlipf, H.
Reference: [13] <author> A. Borgida. </author> <title> Description Logics in Data Management. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 7(5) </volume> <pages> 671-682, </pages> <year> 1995. </year>
Reference-contexts: This is indeed the case with DATALOG _;: : it is easily (polynomially) recognizable whether a query does or does not contain disjunctions or unstratified negation. For a discussion of similar modular approaches in the field of terminological databases, cf. Section 6 in <ref> [13] </ref>; for a related discussion of the expressiveness versus complexity question, see [30]. Finally, we believe that the exact determination of the expressiveness and complexity of DATALOG _;: at the second level of the Polynomial Hierarchy is important for two reasons.
Reference: [14] <author> S. Brass and Jurgen Dix. </author> <title> Disjunctive Semantics based upon Partial and Bottom-Up Evaluation. </title> <editor> In Leon Sterling, editor, </editor> <booktitle> Proc. 12th Int. Conf. on Logic Programming, Tokyo, </booktitle> <pages> pp. 199-213. </pages> <publisher> MIT, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: This requirement is well-acknowledged, and led to the formulation of desirable modularity properties for normal and disjunctive logic programs, cf. [78, 27, 83, 70, 53]. The notion of modularity of programs is related to invariance under unfolding (cf. <ref> [14] </ref>) which was independently established for the static semantics [67, 68] and for the D-WFS semantics [14]. Notice that stratified programs enjoy such a modularity property. <p> The notion of modularity of programs is related to invariance under unfolding (cf. <ref> [14] </ref>) which was independently established for the static semantics [67, 68] and for the D-WFS semantics [14]. Notice that stratified programs enjoy such a modularity property. If 0 ; 1 ; : : : ; k is a stratification of a program , then each stratum i can be seen as a module which is on top of all lower strata, i.e. S j&lt;i j . <p> For example, the group of Dix and Furbach [29] in Koblenz (Germany), in an ambitious project, implements the disjunctive stable semantics and other semantics of disjunctive logic programming; in particular, they implement the recently proposed static semantics [67, 68], which is very similar to the D-WFS semantics <ref> [14, 16, 17] </ref> and the well-founded circumscription semantics [90]; in fact, for disjunctive datalog, static semantics and well-founded circumscription semantics coincide (cf. [91]).
Reference: [15] <author> S. Brass and J. Dix. </author> <title> A General Framework for Semantics of Disjunctive Logic Programs based on Partial Evaluation. </title> <journal> J. Logic Programming. </journal> <note> To appear. 45 </note>
Reference: [16] <author> S. Brass, J. Dix, and T. Przymusinski. </author> <title> Super logic programs. </title> <booktitle> In Proc. International Conf. on Principles of Knowledge Representation and Reasoning (KR-96), </booktitle> <address> Vancouver, Canada. </address> <pages> pp. 529-540. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1996. </year>
Reference-contexts: For example, the group of Dix and Furbach [29] in Koblenz (Germany), in an ambitious project, implements the disjunctive stable semantics and other semantics of disjunctive logic programming; in particular, they implement the recently proposed static semantics [67, 68], which is very similar to the D-WFS semantics <ref> [14, 16, 17] </ref> and the well-founded circumscription semantics [90]; in fact, for disjunctive datalog, static semantics and well-founded circumscription semantics coincide (cf. [91]). <p> Notice that, since the static semantics coincides on :-free disjunctive logic programs with the minimal model semantics <ref> [16] </ref>, it is clear from our results that DATALOG _;: programs can express under this semantics every query in p 2 . Moreover, preliminary results based on characterizations in [16] indicate that it can only express such queries, and thus has the same expressive power as DATALOG _;: under the certainty <p> Notice that, since the static semantics coincides on :-free disjunctive logic programs with the minimal model semantics <ref> [16] </ref>, it is clear from our results that DATALOG _;: programs can express under this semantics every query in p 2 . Moreover, preliminary results based on characterizations in [16] indicate that it can only express such queries, and thus has the same expressive power as DATALOG _;: under the certainty variant of the stable model semantics; we leave this for further study.
Reference: [17] <author> S. Brass, J. Dix, I. Niemela, and T. Przymusinski. </author> <title> A comparison of the static and disjunctive well-founded semantics. (In preparation.), </title> <institution> University of California at Riverside, </institution> <year> 1996. </year>
Reference-contexts: For example, the group of Dix and Furbach [29] in Koblenz (Germany), in an ambitious project, implements the disjunctive stable semantics and other semantics of disjunctive logic programming; in particular, they implement the recently proposed static semantics [67, 68], which is very similar to the D-WFS semantics <ref> [14, 16, 17] </ref> and the well-founded circumscription semantics [90]; in fact, for disjunctive datalog, static semantics and well-founded circumscription semantics coincide (cf. [91]).
Reference: [18] <author> M. Cadoli, T. Eiter, and G. Gottlob. </author> <title> Using Default Logic as a Query Language. </title> <booktitle> In Proc. Fourth Intl Conf. on Principles of Knowledge Representation and Reasoning (KR-94), </booktitle> <pages> pp. 99-108, </pages> <year> 1994. </year> <note> Full paper IEEE Transactions on Knowledge and Data Engineering. To appear. </note>
Reference-contexts: One of the most popular nonmonotonic logics is Reiter's default logic [69]. This logic was developed as a knowledge representation formalism and was originally not conceived 42 as a database query language. However, in <ref> [18] </ref> a suitable setting was defined in which default logic can be used as a query language for relational databases (Default Query Language, DQL). It was shown in [18] that DQL has over relational databases the same expressive power as disjunctive datalog. <p> However, in <ref> [18] </ref> a suitable setting was defined in which default logic can be used as a query language for relational databases (Default Query Language, DQL). It was shown in [18] that DQL has over relational databases the same expressive power as disjunctive datalog. This naturally raises the question about how these formalisms are related, in particular with regard to possible translations. On one hand, note that each disjunctive logic program can be translated into an equivalent default theory. <p> A related proposal for handling disjunction by using normal defaults has been recently pointed out in [82]. Based on the translation mapping of [73], a translation from DATALOG _;: under the stable semantics into DQL can be obtained. Therefore, as already remarked in <ref> [18] </ref>, the fact that DQL expresses at least as much as DATALOG _;: under the stable semantics follows from Theorems 6.9, 6.11 of the present paper in combination with the translation result by Sakama and Inoue. <p> Notwithstanding, a direct expressiveness proof for DQL, which does not rely on disjunctive datalog but exploits particular syntactic features of DQL was given in the appendix of <ref> [18] </ref>. That proof is instructive to users of default logic, because it shows how database properties can be expressed in DQL via their semantics in second-order logic. <p> On the other hand, to the best of our knowledge, no translation from default logic to disjunctive logic programming is known in the literature. Therefore, the expressivity results in Section 6 of the present paper cannot be obtained from the results in <ref> [18] </ref> by means of translations. Genuine and more involved proofs were in order to determine the expressive power of disjunctive datalog (in particular, for :-free disjunctive datalog). <p> For example, the concept of stratification for default theories is much more intricated than for logic programs [23]. The strength of DQL is that certain AI problems such as model-based diagnostic reasoning about complex devices can be more naturally expressed in that language <ref> [18] </ref>. It seems that DQL is a suitable language for bridging the impedance mismatch between advanced knowledge representation and relational databases. Another aspect highlighting the difference between disjunctive datalog and DQL is their expressive power over disjunctive (clausal) databases.
Reference: [19] <author> S. Ceri, G. Gottlob, and L. Tanca. </author> <title> Logical Programming and Databases. </title> <publisher> Springer, </publisher> <year> 1990. </year>
Reference-contexts: In this paper, we study disjunctive logic programming in the context of databases. Datalog is a well-known database query language that uses disjunction-free logic programs, where no functions are allowed <ref> [83, 19] </ref>. We deal here with extensions of such programs by disjunction (and, as well as for datalog, by negation); the corresponding query languages thus amount to disjunctive datalog. Briefly, a disjunctive logic program (DLP) is a logic program where disjunction may occur in the rule heads. <p> compares disjunctive datalog to common and novel database query languages, addresses the issue of why its precise expressiveness characterization is relevant, and outlines open issues for future work. 2 Preliminaries We assume familiarity with the basic concepts of complexity theory and logical query languages for databases; for a background, see <ref> [64, 83, 19, 2] </ref>. A relational scheme over a domain Dom is a (possibly empty) list R = R 1 ; : : : ; R k of relation symbols R i , i = 1; : : : ; k of arity a (R i ) 0. <p> relational scheme R is in p k 1, iff there exists a 1 k (R)-sentence such that for each D 2 D (R), D j= iff P (D) = true. 3 Disjunctive datalog We assume that the reader is familiar with the basic concepts of deductive databases and logic programming <ref> [54, 83, 19] </ref>. Recall that datalog programs are function-free logic programs.
Reference: [20] <author> A. Chandra and D. Harel. </author> <title> Structure and Complexity of Relational Queries. </title> <journal> J. Computer and System Sciences, </journal> <volume> 25 </volume> <pages> 99-128, </pages> <year> 1982. </year>
Reference-contexts: Usually, attention is restricted to generic queries <ref> [20] </ref> (or, less restrictively, to C-generic queries, which allow generic constants), which are invariant under permutations of the elements of Dom. Genericity of queries asserts data independence, i.e., data representation does not have any impact on the query result. <p> Notice that this way we obtain, using complexity upgrading techniques, a simple proof of the folklore result that pure DATALOG has EXPTIME-complete expression complexity, which is implicit already in <ref> [85, 20] </ref>. Indeed, the exponential upgrade of P is EXPTIME; problems that are complete for P under P LT m reductions (or even stronger notions of 39 reductions) can be expressed in pure datalog. <p> A similar comment applies to several other expressive query languages studied in the literature, for example, to the language of While-Queries studied by Chandra and Harel <ref> [20] </ref> and the language of Partial Fixpoint Queries considered by Abiteboul and Vianu (cf. [2]). The latter two languages both capture the highly intractable complexity-class PSPACE. This raises the question of whether it makes sense to study such expressive, and therefore complex, query languages.
Reference: [21] <author> A. Chandra and D. Harel. </author> <title> Horn Clause Queries and Generalizations. </title> <journal> J. Logic Programming, </journal> <volume> 2 </volume> <pages> 1-15, </pages> <year> 1985. </year>
Reference-contexts: Thus, the certainty MM-semantics does not provide model selection with respect to positive atoms, and computes the same query result as classical (certainty) semantics. Therefore, DATALOG _;6= c falls back to query languages in co-NP which are well-understood (cf. FN-queries in <ref> [21] </ref>). For the other semantics (SM,PM), the certainty variant is precisely symmetric to the possibility variant if (stratified) negation is allowed. For instance, the boolean (constant-free) DA-TALOG _;: p;SM queries express the p 2 database properties and the boolean (constant-free) DATALOG _;: c;SM queries express the p 2 database properties.
Reference: [22] <author> J. Chen. </author> <title> Minimal Knowledge + Negation as Failure = Only Knowing (Sometimes). </title> <editor> In L.- M. Pereira and A. Nerode, editors, </editor> <booktitle> Proc. Second Intl Workshop on Logic Programming and Nonmonotonic Reasoning (LPNMR '93), </booktitle> <pages> pp. 132-150, </pages> <address> Lisbon, July 1993. </address> <publisher> MIT Press. </publisher>
Reference-contexts: If a modular embedding from query language L 1 to L 2 exists, then, in a sense, L 1 can be seen as a fragment or sublanguage of L 2 . Interestingly, there exists no modular embedding of DQL into disjunctive datalog. This can be seen as follows. In <ref> [52, 22] </ref>, modular embeddings of disjunctive logic programming into autoepistemic logic [60] are exhibited. Thus, if there existed a modular embedding of default logic into disjunctive logic programming, by composition, there would also exist a modular embedding of default logic into autoepistemic logic.
Reference: [23] <author> P. Cholewinski. </author> <title> Reasoning with Stratified Default Theories. </title> <editor> In W. Marek, A. Nerode, and M. Truszczynski, editors, </editor> <booktitle> Proc. Third Intl Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR '95), </booktitle> <volume> LNCS 928, </volume> <pages> pp. 273-286, </pages> <address> Lexington KY, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: On the other hand, due to its rich (and in some sense more succinct) syntax, DQL is far less accessible to such methods. For example, the concept of stratification for default theories is much more intricated than for logic programs <ref> [23] </ref>. The strength of DQL is that certain AI problems such as model-based diagnostic reasoning about complex devices can be more naturally expressed in that language [18]. It seems that DQL is a suitable language for bridging the impedance mismatch between advanced knowledge representation and relational databases.
Reference: [24] <author> J. Chomicki and V.S. Subrahmanian. </author> <title> Generalized Closed World Assumption is 0 2 -complete. </title> <journal> Information Processing Letters, </journal> <volume> 34 </volume> <pages> 289-291, </pages> <year> 1990. </year>
Reference-contexts: However, until recently, little was known on the complexity and the expressive power of disjunctive logic programming. Noticeable recursion-theoretic results on disjunctive inference formalisms over infinite structures where obtained by Schlipf [76], who showed that general circumscription over the integers is 1 2 -complete, and by Chomicki and Subrahmanian <ref> [24] </ref>, who showed that Minker's Generalized Closed World Assumption is 0 2 -complete. These results show that 1 on infinite structures, disjunctive logic programming is harder than both classical reasoning and normal logic programming [24] (see [77] for an overview). <p> showed that general circumscription over the integers is 1 2 -complete, and by Chomicki and Subrahmanian <ref> [24] </ref>, who showed that Minker's Generalized Closed World Assumption is 0 2 -complete. These results show that 1 on infinite structures, disjunctive logic programming is harder than both classical reasoning and normal logic programming [24] (see [77] for an overview). However, most computer science applications deal with finite structures, in particular, with database relations. In this context, the important question of whether each DLP can be replaced by an equivalent normal logic program was open.
Reference: [25] <author> J. Cullum and R. Willoughby. </author> <title> Lanczos Algorithms for Large Symmetric Eigenvalue Compu tations, volume 1. </title> <publisher> Birkhauser, </publisher> <address> Boston, </address> <year> 1985. </year>
Reference-contexts: Every such nontrivial solution x is called an eigenvector (w.r.t. ). Eigenvalues/eigenvectors have important applications in many areas, e.g. to structural analysis, quantum chemistry, power system analysis, stability analysis, VLSI design, and geophysics <ref> [25] </ref>. It is well-known that the eigenvectors of a real matrix M form with the zero vector a vector space, and thus in general infinitely many eigenvectors exist.
Reference: [26] <author> A. Dawar. </author> <title> A Restricted Second Order Logic for Finite Structures. </title> <editor> In D. Leivant, editor, </editor> <booktitle> Proc. Intl Workshop on Logic and Computational Complexity (LCC '94), LNCS 960, Bloomington IN, 1995. </booktitle> <publisher> Springer. </publisher>
Reference-contexts: In fact, as shown in Section 4, graph 3-colorability can be expressed in DATA-LOG _ p ; on the other hand, it has been shown that graph 3-colorability can not be expressed in L ! 1! <ref> [26] </ref>. Thus, Proposition 7.1 (Constant-free) DATALOG _ p is not equivalent to any fragment of L ! 1! . As shown below, the inequality relation can not be recognized by a DATALOG _ p query.
Reference: [27] <author> J. Dix. </author> <title> Classifying Semantics of Disjunctive Logic Programs. </title> <booktitle> In Proc. JICSLP-92, </booktitle> <pages> pp. 798 812, </pages> <address> Washington DC, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: This semantics generalizes the well acknowledged stable semantics for normal logic programs [37]. Much work has been spent on the suitability of these and other DLP semantics in various contexts, as well as on mathematical and structural properties, cf. <ref> [27, 55, 59, 74] </ref>. However, until recently, little was known on the complexity and the expressive power of disjunctive logic programming. <p> This requirement is well-acknowledged, and led to the formulation of desirable modularity properties for normal and disjunctive logic programs, cf. <ref> [78, 27, 83, 70, 53] </ref>. The notion of modularity of programs is related to invariance under unfolding (cf. [14]) which was independently established for the static semantics [67, 68] and for the D-WFS semantics [14]. Notice that stratified programs enjoy such a modularity property. <p> predicate P directly depends in on predicate Q, if P occurs in the head of some rule of and Q occurs (positively or negatively) in the same rule; P depends on Q (in ) if the pair (P; Q) is in the transitive closure of the direct dependency relation (cf. <ref> [27] </ref>). P and Q are mutually recursive if P depends on Q and vice versa. Intuitively, if P depends on Q, the extension of Q may influence derivability of ground atoms on P ; if P and Q are mutually recursive, they ought to be computed in the same module.
Reference: [28] <editor> J. Dix, D. Loveland, J. Minker, and D. Warren, editors. </editor> <title> Disjunctive Logic Programming and Databases: Nonmonotonic Aspects, Schlo Dagstuhl, Germany, </title> <type> Seminar Report 150, </type> <year> 1996. </year>
Reference-contexts: 1 Introduction Strong interest in enhancing logic programs by the capability of disjunction emerged in the logic programming, artificial intelligence, and databases communities. This interest is documented by a number of publications (cf. [55, 59]) and even workshops dedicated to this subject <ref> [88, 28] </ref>. In this paper, we study disjunctive logic programming in the context of databases. Datalog is a well-known database query language that uses disjunction-free logic programs, where no functions are allowed [83, 19].
Reference: [29] <author> J. Dix and M. Muller. </author> <title> Implementing Semantics of Disjunctive Logic Programs Using Fringes and Abstract Properties. </title> <editor> In L.-M. Pereira and A. Nerode, editors, </editor> <booktitle> Proc. Second Intl Workshop on Logic Programming and Nonmonotonic Reasoning (LPNMR '93), </booktitle> <pages> pp. 43-59, </pages> <address> Lisbon, July 1993. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Several current projects deal with the implementation of disjunctive datalog or, more generally, of disjunctive logic programming, in which the design of such algorithms and methods is a primary goal. For example, the group of Dix and Furbach <ref> [29] </ref> in Koblenz (Germany), in an ambitious project, implements the disjunctive stable semantics and other semantics of disjunctive logic programming; in particular, they implement the recently proposed static semantics [67, 68], which is very similar to the D-WFS semantics [14, 16, 17] and the well-founded circumscription semantics [90]; in fact, for
Reference: [30] <author> J. Doyle and R. Patil. </author> <title> Two Theses of Knowledge Representation: Language Restrictions, Taxonomic Classification, and the Utility of Representation Services. </title> <journal> Artificial Intelligence, </journal> <volume> 48 </volume> <pages> 261-297, </pages> <year> 1991. </year>
Reference-contexts: For a discussion of similar modular approaches in the field of terminological databases, cf. Section 6 in [13]; for a related discussion of the expressiveness versus complexity question, see <ref> [30] </ref>. Finally, we believe that the exact determination of the expressiveness and complexity of DATALOG _;: at the second level of the Polynomial Hierarchy is important for two reasons.
Reference: [31] <author> T. Eiter and G. Gottlob. </author> <title> Note on the Complexity of Some Eigenvector Problems. </title> <type> Technical Report CD-TR 95/89, </type> <institution> Christian Doppler Laboratory for Expert Systems, TU Vienna, </institution> <month> December </month> <year> 1995. </year>
Reference-contexts: One can show that the computed query is both NP- and co-NP-hard; precisely, the query is complete for the class fi p p 2 [O (log n)], i.e. the class of problems solvable in polynomial time with logarithmically many NP oracle queries) <ref> [31] </ref>. Thus, the query can not be formulated in DATALOG : (unless PH collapses). Computing a single maximal eigenvector does not specify a generic query, unless this vector is uniquely determined. By discrimination among the maximal eigenvectors, it is possible to single out a unique such vector. <p> Note that computing the lexicographically first maximal eigenvector is an F p 2 -complete query <ref> [31] </ref>, and is thus not expressible in DATALOG : (unless PH collapses). Even harder queries on eigenvectors can be expressed. <p> This query is p 2 -complete <ref> [31] </ref>, and thus much harder than the previous queries; it is among the hardest queries that can be expressed in disjunctive datalog. In the above examples, candidate solutions are generated by one component of the program and tested by another.
Reference: [32] <author> T. Eiter and G. Gottlob. </author> <title> On the Computational Cost of Disjunctive Logic Programming: Propositional Case. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> 15(3/4):289-323, 1995. 
Reference-contexts: However, most computer science applications deal with finite structures, in particular, with database relations. In this context, the important question of whether each DLP can be replaced by an equivalent normal logic program was open. Recently, Eiter and Gottlob <ref> [32] </ref> analyzed the complexity of propositional disjunctive logic programming (see [32] for a detailed treatment). They show that in this setting, most forms of DLP are computationally harder than normal logic programming with negation (unless the Polynomial Hierarchy collapses). <p> However, most computer science applications deal with finite structures, in particular, with database relations. In this context, the important question of whether each DLP can be replaced by an equivalent normal logic program was open. Recently, Eiter and Gottlob <ref> [32] </ref> analyzed the complexity of propositional disjunctive logic programming (see [32] for a detailed treatment). They show that in this setting, most forms of DLP are computationally harder than normal logic programming with negation (unless the Polynomial Hierarchy collapses). <p> For these semantics, symmetric results ( p 2 -expressiveness) holds for certainty reasoning. In particular, the results show that for disjunctive datalog the SM-semantics and the PM-semantics express precisely the same set of queries; in the light of results in <ref> [32] </ref>, this is probably not true for DATALOG : , i.e. nondisjunctive datalog with negation. * We show that disjunctive datalog queries are p 2 -complete in the data size and NEXP-TIME NP -complete in the program size under the possibility version of all considered semantics. <p> Constants in queries are not an issue, since they can be provided by designated input relations (see [2, Section 9]). The following proposition on the complexity of minimal, stable, and perfect models of propositional programs is well-known. Proposition 6.1 <ref> [32] </ref> Let be a propositional (i.e., ground) program and let p be a propositional atom. Deciding if p 2 M for some M 2 S () is p 2 -complete for S = MM ; SM ; PM . <p> Proof. That each query q c;SM (resp. q c;PM ) is 2 -recognizable follows from the known fact that, given a propositional program and an atom p, deciding if p 2 M for all M 2 SM () (resp. M 2 PM ()) is in p 2 (cf. <ref> [32] </ref>; the proof is dual to the membership part of Proposition 6.1). It remains to show that each generic total query q : D (R) ! D (S) that is p 2 -recognizable can be expressed in DATALOG _;: s c . <p> Thus, adding disjunction to pure Horn clauses allows one to express 2 -hard queries. The proof is via a program for deciding whether an atom a occurs in some minimal model of a given propositional program (cf. <ref> [32] </ref>). Theorem 8.2 The boolean DATALOG _ p queries are p 2 -hard in the data size, even if no negation occurs in query programs. Proof. <p> By Corollary 6 in <ref> [32] </ref> it follows that, given , deciding if for a fixed 32 propositional letter P , it holds P 2 M for some M 2 MM () is p 2 -hard, provided that a constant for true, given by &gt;, is available.
Reference: [33] <author> T. Eiter, G. Gottlob, and Y. Gurevich. </author> <title> Normal Forms for Second-Order Logic over Finite Structures, and Classification of NP Optimization Problems. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 78 </volume> <pages> 111-125, </pages> <year> 1996. </year>
Reference-contexts: This result is proved exploiting a strengthened form of Fagin's Theorem generalized to the Polynomial Hierarchy ( p p 2 = NP NP , . . . ) [36, 81], which exists for finite structures only and classes p k where k 2 <ref> [33] </ref>. The same expressive power ( p gained by adding negation (:) in case of both the SM and the PM semantics. For these semantics, symmetric results ( p 2 -expressiveness) holds for certainty reasoning. <p> The construction uses a lemma, whose proof can be found in <ref> [34, 33] </ref>. We needs some concepts first. Assume that S and F , L are distinguished relation symbols which do not occur in R. <p> Lemma 6.4 <ref> [34, 33] </ref> A database property P on R is in p 2 iff P is definable on the enumerated databases over R by a 1 2 formula over vocabulary R; S; F; L of the form (9S)(8T)(9x)'(x); (2) where '(x) = # 1 (x) _ _ # k (x) and the <p> In fact, each DQL query can be easily expressed by a 1 2 second-order formula, which, as shown in <ref> [33] </ref> can be brought into the normal form used in Theorem 6.3, and thus translated into DATALOG _;6= . However, this translation has two shortcomings. First, it is not a true embedding since it extends the language by new predicate symbols. Second, it is not modular.
Reference: [34] <author> T. Eiter, G. Gottlob, and H. Mannila. </author> <title> Adding Disjunction to Datalog. </title> <booktitle> In Proc. PODS '94, </booktitle> <pages> pp. 267-278, </pages> <month> May </month> <year> 1994. </year> <month> 46 </month>
Reference-contexts: In particular, the decomposition into the SCCs supports parallelization of model computation to the highest degree among all decompositions, and is thus appealing for an implementation of datalog that exploits parallel processing for query evaluation. We remark that in [53], independent of <ref> [34] </ref> and at the same time, a modularity property for the answer set semantics to extended disjunctive logic programs (which contain two kinds of negation) has been stated which is very similar (and in fact equivalent) to Lemma 5.1, based on the notion of splitting set. <p> Under this view, the main result of [53] (Splitting Set Theorem) amounts for programs with only one kind of negation precisely to Lemma 5.1 (Lemma 6.1 in <ref> [34] </ref>). It is no surprise that the same modularity property has been independently found in slightly different settings, since it is quite natural. Moreover, Lifschitz and Turner extend their result to iterated splittings of a program (Splitting Sequence Theorem), which decomposes the program into a chain of modules. <p> The construction uses a lemma, whose proof can be found in <ref> [34, 33] </ref>. We needs some concepts first. Assume that S and F , L are distinguished relation symbols which do not occur in R. <p> Lemma 6.4 <ref> [34, 33] </ref> A database property P on R is in p 2 iff P is definable on the enumerated databases over R by a 1 2 formula over vocabulary R; S; F; L of the form (9S)(8T)(9x)'(x); (2) where '(x) = # 1 (x) _ _ # k (x) and the
Reference: [35] <author> T. Eiter, N. Leone, and D. Sacca. </author> <title> Expressive Power of Partial Models for Disjunctive Deductive Databases. </title> <booktitle> In Proc. Intl Workshop on Logic in Databases (LID '96), </booktitle> <editor> D. Pedreschi and C. Zaniolo, editors, </editor> <volume> LNCS 1154, </volume> <pages> pp. 245-264, </pages> <year> 1996. </year>
Reference-contexts: Note that choice can be implemented using head-cycle-free disjunction [8]. Loosely speaking, a program is headcycle-free if no two distinct atoms which occur together in the head of a rule mutually depend on each other. Since, by the results in <ref> [8, 35] </ref>, headcycle-free programs capture NP (resp. co-NP) under the possibility (resp. certainty) variant of the stable model semantics, it is not surprising that the programs exhibited in Example 3 and 4 are not headcycle-free. <p> Ben-Eliyahu [8, 9] (Ben Gurion University and Technion, Israel) has recently started a project of implementing a subclass of disjunctive logic programs (so called headcycle-free programs) that is less complex (thus also less powerful) than the full class; see <ref> [35] </ref> for more details. Last but not least, a project for implementing a prototype of disjunctive datalog based on the stable model semantics (funded by the Austrian Science Foundation (FWF)) was most recently started at the information systems department of TU Vienna.
Reference: [36] <author> R. Fagin. </author> <title> Generalized First-Order Spectra and Polynomial-Time Recognizable Sets. </title> <editor> In R. M. Karp, editor, </editor> <booktitle> Complexity of Computation, </booktitle> <pages> pp. 43-74. </pages> <publisher> AMS, </publisher> <year> 1974. </year>
Reference-contexts: Thus, adding 6= (inequality) to DATALOG _ (giving DATALOG _;6= ) suffices to gain full expressive power. This result is proved exploiting a strengthened form of Fagin's Theorem generalized to the Polynomial Hierarchy ( p p 2 = NP NP , . . . ) <ref> [36, 81] </ref>, which exists for finite structures only and classes p k where k 2 [33]. The same expressive power ( p gained by adding negation (:) in case of both the SM and the PM semantics. For these semantics, symmetric results ( p 2 -expressiveness) holds for certainty reasoning. <p> Proposition 2.1 <ref> [36, 81] </ref> A database property P over a relational scheme R is in p k 1, iff there exists a 1 k (R)-sentence such that for each D 2 D (R), D j= iff P (D) = true. 3 Disjunctive datalog We assume that the reader is familiar with the basic
Reference: [37] <author> M. Gelfond and V. Lifschitz. </author> <title> The Stable Model Semantics for Logic Programming. </title> <booktitle> In Proc. Fifth Logic Programming Symposium, </booktitle> <pages> pp. 1070-1080, </pages> <address> Cambridge Mass., 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Note that the perfect model approach is successfully used by Kifer, Lausen, and Wu [45] for defining a semantics of object oriented languages. * Disjunctive stable model semantics [66, 38]. This semantics generalizes the well acknowledged stable semantics for normal logic programs <ref> [37] </ref>. Much work has been spent on the suitability of these and other DLP semantics in various contexts, as well as on mathematical and structural properties, cf. [27, 55, 59, 74]. However, until recently, little was known on the complexity and the expressive power of disjunctive logic programming. <p> We consider minimal models [58] (arising in the AI community in circumscription [57], and in advanced forms of the Closed World Assumption, e.g. the Extended Generalized CWA [89]), the perfect models [65], and the (disjunctive) stable models <ref> [37, 66] </ref>, which are among the most well-known such concepts. Using these concepts, we define different semantics of disjunctive datalog, which give rise to different query languages; the semantics of sublanguages is implicit. We need some notation and concepts from (disjunctive) logic programming.
Reference: [38] <author> M. Gelfond and V. Lifschitz. </author> <title> Classical Negation in Logic Programs and Disjunctive Databases. </title> <journal> New Generation Computing, </journal> <volume> 9 </volume> <pages> 365-385, </pages> <year> 1991. </year>
Reference-contexts: For example, a DLP may contain rules such as M ale (x) _ F emale (x) P erson (x): The usefulness of disjunctive rules for knowledge representation, database querying, and for representing incomplete information, is generally acknowledged (see <ref> [38, 4] </ref>). Various semantics of DLPs have been proposed; they are commonly based on the paradigm of minimal models, which underlies Minker's Generalized Closed World Assumption [58]. For an overview of various semantics for DLPs, the reader may consult [55] and Minker's more recent article [59]. <p> This semantics has been defined for general DLPs, but is particularly suited for stratified DLPs. Note that the perfect model approach is successfully used by Kifer, Lausen, and Wu [45] for defining a semantics of object oriented languages. * Disjunctive stable model semantics <ref> [66, 38] </ref>. This semantics generalizes the well acknowledged stable semantics for normal logic programs [37]. Much work has been spent on the suitability of these and other DLP semantics in various contexts, as well as on mathematical and structural properties, cf. [27, 55, 59, 74].
Reference: [39] <author> G. Gottlob. </author> <title> Translating Default Logic into Standard Autoepistemic Logic. </title> <journal> JACM, </journal> <volume> 42(4) </volume> <pages> 711-740, </pages> <year> 1995. </year>
Reference-contexts: Thus, if there existed a modular embedding of default logic into disjunctive logic programming, by composition, there would also exist a modular embedding of default logic into autoepistemic logic. This would contradict a result in <ref> [39] </ref> which proves that there exists no modular embedding of default logic into autoepistemic logic. 43 The existence of a modular embedding of DATALOG _;: into DQL and the nonexistence of a modular embedding in the reverse direction can be interpreted as follows.
Reference: [40] <author> G. Gottlob, N. Leone, and H. Veith. </author> <title> Second-Order Logic and the Weak Exponential Hierarchies. </title> <booktitle> In Proc. Conference on Mathematical Foundations of Computer Science (MFCS-95), </booktitle> <volume> LNCS 969, </volume> <pages> pp. 66-81, </pages> <address> Prague, </address> <year> 1995. </year> <note> Full paper available as CD-TR 95/80, </note> <institution> Christian Doppler Lab for Expert Systems, TU Vienna. </institution>
Reference-contexts: Furthermore, A p m long (A) S ([3, Lemma 4]); by transitivity, A p m B S , and thus B S is p m -hard for C1. A strengthening of this theorem from p m -transformation to logspace-transformation is shown in <ref> [86, 40] </ref>. The proof of Theorem 8.8 uses this complexity upgrade technique. It gives a polynomial time transformation of the succinct version co-CERT3COL S of the graph problem co-CERT3COL, to evaluating boolean :-free DATALOG _ p query programs over a fixed data base. <p> Moreover, the transformation described in the proof of Theorem 8.8 can be performed in logspace. Thus, by using the strengthening of Theorem 8.4 from p m -transformation to logspace-transformation <ref> [86, 40] </ref>, one can obtain a strengthening of Theorem 8.8 to logspace-transformation. In fact, the function of a circuit can be computed by a program that uses neither disjunction nor negation, i.e., a pure datalog program; this improves on the proof approach in [47], where negation was needed.
Reference: [41] <author> Y. Gurevich. </author> <title> Logic and the Challenge of Computer Science. </title> <editor> In E. Borger, editor, </editor> <booktitle> Trends in Theoretical Computer Science, chapter 1. </booktitle> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference-contexts: Query q is C-recognizable, where C is a complexity class, iff the QOT-problem is in C (cf. <ref> [41] </ref>). Similarly, a database property P is C-recognizable (or, in C) iff deciding P (D) = true is in C.
Reference: [42] <author> T. Imielinski and W. Lipski. </author> <title> The Relational Model of Data and Cylindric Algebras. </title> <journal> J. Computer and System Sciences, </journal> <volume> 28 </volume> <pages> 80-102, </pages> <year> 1984. </year>
Reference-contexts: The former approach (union) is known as possibility inference (also termed brave or credulous reasoning in the AI community), and the latter (intersection) as certainty inference (also termed cautious or skeptical inference) <ref> [42, 1] </ref>. Definition 3.4 Let inf be an inference modality from p (ossibility), c (ertainty).
Reference: [43] <author> N. Immerman. </author> <title> Relational Queries Computable in Polynomial Time. </title> <journal> Information and Control, </journal> <volume> 68 </volume> <pages> 86-104, </pages> <year> 1986. </year>
Reference-contexts: Section 8). Analogous to DATALOG, which expresses all P-time queries on enumerated databases (i.e., databases with a successor relation on the universe) <ref> [85, 43] </ref>, DATALOG _ p expresses all p 2 -recognizable queries on enumerated databases, since the inequality predicate can be easily defined from the enumeration of the universe.
Reference: [44] <author> P. Kanellakis. </author> <title> Elements of Relational Database Theory. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B, chapter 17. </booktitle> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: Our results provide a clear picture of the expressiveness of disjunctive datalog in the various settings. Moreover, they complement and extend previous results of important extensions of datalog and related query languages (see <ref> [2, 44] </ref>). Note that the major versions of DATALOG : [47, 78, 84] express database queries in NP (resp. co-NP) under possibility (resp. certainty) inference. Thus, disjunction adds expressive power (unless 2 = NP). A consequence of the high expressive power of disjunctive datalog is a high worst-case complexity. <p> On the other hand, the fact that hard queries can be formulated does not necessarily imply that all queries within the same complexity can be formulated. A well-known example is datalog, which can express P-time hard queries, but not all P-time queries <ref> [44] </ref>. Such query languages are not balanced in the sense that the complexity dominates the expressive power. As will be shown in the following, plain disjunctive datalog suffers this property, while DATALOG _;6= p is balanced.
Reference: [45] <author> M. Kifer, G. Lausen, and J. Wu. </author> <title> Logical foundations of object-oriented and frame-based languages. </title> <journal> JACM, </journal> <volume> 42(4) </volume> <pages> 740-843, </pages> <year> 1995. </year>
Reference-contexts: This semantics has been defined for general DLPs, but is particularly suited for stratified DLPs. Note that the perfect model approach is successfully used by Kifer, Lausen, and Wu <ref> [45] </ref> for defining a semantics of object oriented languages. * Disjunctive stable model semantics [66, 38]. This semantics generalizes the well acknowledged stable semantics for normal logic programs [37].
Reference: [46] <author> P. Kolaitis. </author> <title> The Expressive Power of Stratified Logic Programs. </title> <journal> Information and Computation, </journal> <volume> 90 </volume> <pages> 50-66, </pages> <year> 1991. </year>
Reference-contexts: Notice that allowing stratified negation in nondisjunctive datalog programs does not establish the balance of the language, since still only a strict subset of the P-time computable queries can be expressed, where each level of stratification adds expressive power <ref> [46] </ref>. On the other hand, inspection of the proofs in Section 6 yields that a single level of stratified negation in disjunctive programs gives the full expressive power.
Reference: [47] <author> P. Kolaitis and C. H. Papadimitriou. </author> <title> Why Not Negation By Fixpoint ? J. </title> <journal> Computer and System Sciences, </journal> <volume> 43 </volume> <pages> 125-144, </pages> <year> 1991. </year>
Reference-contexts: Our results provide a clear picture of the expressiveness of disjunctive datalog in the various settings. Moreover, they complement and extend previous results of important extensions of datalog and related query languages (see [2, 44]). Note that the major versions of DATALOG : <ref> [47, 78, 84] </ref> express database queries in NP (resp. co-NP) under possibility (resp. certainty) inference. Thus, disjunction adds expressive power (unless 2 = NP). A consequence of the high expressive power of disjunctive datalog is a high worst-case complexity. <p> Thus the expressive power of disjunctive datalog is one level above the 21 expressive power of normal datalog under stable model semantics [78] or fixpoint semantics <ref> [47] </ref>, which is NP. An interesting result is that the full expressive power is already available with DATA LOG _;6= programs; hence, also the DATALOG _;6= p queries capture p 2 , provided that inequality literals are allowed in the body. <p> The proof of this result relies on the use of complexity upgrade techniques that extend the results in [3, 63], applied to results in [80], and the simulation of boolean circuits by a DATALOG _ program without 6= and negation under minimal model semantics. In <ref> [47] </ref>, a similar simulation was described in DATALOG :;6= using stratified negation and fixpoint semantics. <p> For not-gates, j = k (cf. <ref> [47] </ref>). As shown in [63], the succinct problem setting often leads to an exponential complexity increase. The results and techniques of [63] (see also [64]) were generalized in [3] to the succinct version of any decision problem A encoded as a language over f0; 1g. <p> In fact, the function of a circuit can be computed by a program that uses neither disjunction nor negation, i.e., a pure datalog program; this improves on the proof approach in <ref> [47] </ref>, where negation was needed. The following observation is crucial for this improvement. Fact.
Reference: [48] <author> P. Kolaitis and M. Vardi. </author> <title> Fixpoint Logic vs. Infinitary Logic in Finite-Model Theory. </title> <booktitle> In Proc. LICS-92, </booktitle> <pages> pp. 61-71. </pages> <publisher> IEEE Computer Science Press, </publisher> <year> 1992. </year>
Reference-contexts: This is established by exploiting a weak form of monotonicity of the query programs. Notice that for normal (i.e., nondisjunctive) datalog, nonexpressiveness results have been shown using the tool of infinitary logic with finitely many variables (L ! 1! ) <ref> [49, 48] </ref>. It is known that many prominent query languages (e.g., stratified datalog, fixpoint queries, while queries etc) can only express queries that are definable in L ! 1! [48, 49, 2]. <p> It is known that many prominent query languages (e.g., stratified datalog, fixpoint queries, while queries etc) can only express queries that are definable in L ! 1! <ref> [48, 49, 2] </ref>. Moreover, it is known that L ! 1! has a 0-1 law, i.e., every query from this language is either almost surely true or almost surely false, if the size of the universe grows to infinity [48]. <p> Moreover, it is known that L ! 1! has a 0-1 law, i.e., every query from this language is either almost surely true or almost surely false, if the size of the universe grows to infinity <ref> [48] </ref>. Since the Even-query does not have this property, it can not be expressed in L ! 1! , and hence also not in any of the query languages subsumed by L ! 1! .
Reference: [49] <author> P. Kolaitis and M. Vardi. </author> <title> On the Expressive Power of Datalog: Tools and a Case Study. </title> <editor> J. </editor> <booktitle> Computer and System Sciences, 51(1):110, 1995. Abstract in Proc. PODS '90, </booktitle> <pages> pp. 61-71. </pages>
Reference-contexts: This means that extending plain disjunctive datalog by inequality literals results in the maximal increase of the expressive power, as opposed to nondisjunctive datalog, where the increase is minor <ref> [49] </ref>. On the other hand, compared to (plain) DATALOG, which expresses a strict subclass of the P-time queries, the expressive power of DATALOG _ increases a lot, since DATALOG _ p can express some p 2 -hard queries (cf. Section 8). <p> This is established by exploiting a weak form of monotonicity of the query programs. Notice that for normal (i.e., nondisjunctive) datalog, nonexpressiveness results have been shown using the tool of infinitary logic with finitely many variables (L ! 1! ) <ref> [49, 48] </ref>. It is known that many prominent query languages (e.g., stratified datalog, fixpoint queries, while queries etc) can only express queries that are definable in L ! 1! [48, 49, 2]. <p> It is known that many prominent query languages (e.g., stratified datalog, fixpoint queries, while queries etc) can only express queries that are definable in L ! 1! <ref> [48, 49, 2] </ref>. Moreover, it is known that L ! 1! has a 0-1 law, i.e., every query from this language is either almost surely true or almost surely false, if the size of the universe grows to infinity [48]. <p> This class consists of all problems which can be decided on a nondeterministic Turing machine in single exponential time (i.e., in time O (2 p (n) ), where p (n) is polynomial), with the use of an NP-oracle. Notice that few natural exp 2 -complete problems are known (see <ref> [49] </ref> for an example in the context of second-order logic).
Reference: [50] <author> M. Krentel. </author> <title> The Complexity of Optimization Problems. </title> <journal> J. Computer and System Sciences 36 </journal> <pages> 490-509, </pages> <year> 1988. </year>
Reference-contexts: Computing an optimal tour is both NP-hard and co-NP-hard. In fact, in [62] it was shown that deciding whether the cost of an optimal tour is even is p 2 -complete, and in 11 <ref> [50] </ref> it was shown that computing this cost (or even a single bit) is F p 2 -complete under so called metric reductions. Hence, this is not possible in DATALOG : (unless PH collapses). Here, we describe a disjunctive datalog program which can do this under the stable semantics.
Reference: [51] <author> N. Leone, P. Rullo, and F. Scarcello. </author> <title> Disjunctive Stable Models: Unfounded Sets, Fixpoint Semantics and Computation. </title> <booktitle> Abstract in Proc. Intl Logic Programming Symposium (ILPS-95), </booktitle> <pages> pp. 399-413, </pages> <address> Portland, Oregon, 1995. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Last but not least, a project for implementing a prototype of disjunctive datalog based on the stable model semantics (funded by the Austrian Science Foundation (FWF)) was most recently started at the information systems department of TU Vienna. Results and techniques from <ref> [51] </ref> are a starting point for this work. The current and future research of these groups is centered around the development of smart algorithms for disjunctive logic programming. <p> Due to its plain syntax, DATALOG _;: is amenable for automatic program analysis and optimization. In particular, modularity properties (as described in Section 5) and natural syntactic restrictions on DA-TALOG _;: programs (such as head-cycle freeness) can be exploited to improve efficiency <ref> [8, 51] </ref>. On the other hand, due to its rich (and in some sense more succinct) syntax, DQL is far less accessible to such methods. For example, the concept of stratification for default theories is much more intricated than for logic programs [23].
Reference: [52] <author> V. Lifschitz and H. Turner. </author> <title> Extended Logic Programs as Autoepistemic Theories. </title> <editor> In L.- M. Pereira and A. Nerode, editors, </editor> <booktitle> Proc. Second Intl Workshop on Logic Programming and Nonmonotonic Reasoning (LPNMR '93), </booktitle> <pages> pp. 101-114, </pages> <address> Lisbon, July 1993. </address> <publisher> MIT Press. </publisher>
Reference-contexts: If a modular embedding from query language L 1 to L 2 exists, then, in a sense, L 1 can be seen as a fragment or sublanguage of L 2 . Interestingly, there exists no modular embedding of DQL into disjunctive datalog. This can be seen as follows. In <ref> [52, 22] </ref>, modular embeddings of disjunctive logic programming into autoepistemic logic [60] are exhibited. Thus, if there existed a modular embedding of default logic into disjunctive logic programming, by composition, there would also exist a modular embedding of default logic into autoepistemic logic.
Reference: [53] <author> V. Lifschitz and H. Turner. </author> <title> Splitting a Logic Program. </title> <booktitle> In Proc. ICLP-94, </booktitle> <pages> pp. 23-38, </pages> <address> Santa Margherita Ligure, Italy, </address> <month> June </month> <year> 1994. </year> <pages> MIT-Press. </pages>
Reference-contexts: This requirement is well-acknowledged, and led to the formulation of desirable modularity properties for normal and disjunctive logic programs, cf. <ref> [78, 27, 83, 70, 53] </ref>. The notion of modularity of programs is related to invariance under unfolding (cf. [14]) which was independently established for the static semantics [67, 68] and for the D-WFS semantics [14]. Notice that stratified programs enjoy such a modularity property. <p> In particular, the decomposition into the SCCs supports parallelization of model computation to the highest degree among all decompositions, and is thus appealing for an implementation of datalog that exploits parallel processing for query evaluation. We remark that in <ref> [53] </ref>, independent of [34] and at the same time, a modularity property for the answer set semantics to extended disjunctive logic programs (which contain two kinds of negation) has been stated which is very similar (and in fact equivalent) to Lemma 5.1, based on the notion of splitting set. <p> Under this view, the main result of <ref> [53] </ref> (Splitting Set Theorem) amounts for programs with only one kind of negation precisely to Lemma 5.1 (Lemma 6.1 in [34]). It is no surprise that the same modularity property has been independently found in slightly different settings, since it is quite natural.
Reference: [54] <author> J. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1984. </year>
Reference-contexts: relational scheme R is in p k 1, iff there exists a 1 k (R)-sentence such that for each D 2 D (R), D j= iff P (D) = true. 3 Disjunctive datalog We assume that the reader is familiar with the basic concepts of deductive databases and logic programming <ref> [54, 83, 19] </ref>. Recall that datalog programs are function-free logic programs.
Reference: [55] <author> J. Lobo, J. Minker, and A. Rajasekar. </author> <title> Foundations of Disjunctive Logic Programming. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1992. </year>
Reference-contexts: 1 Introduction Strong interest in enhancing logic programs by the capability of disjunction emerged in the logic programming, artificial intelligence, and databases communities. This interest is documented by a number of publications (cf. <ref> [55, 59] </ref>) and even workshops dedicated to this subject [88, 28]. In this paper, we study disjunctive logic programming in the context of databases. Datalog is a well-known database query language that uses disjunction-free logic programs, where no functions are allowed [83, 19]. <p> Various semantics of DLPs have been proposed; they are commonly based on the paradigm of minimal models, which underlies Minker's Generalized Closed World Assumption [58]. For an overview of various semantics for DLPs, the reader may consult <ref> [55] </ref> and Minker's more recent article [59]. In this paper, we limit our attention to three important semantics for disjunctive logic programming (and thus for disjunctive datalog), whose precise definition will be given in Section 3: * Minimal model semantics. <p> This semantics generalizes the well acknowledged stable semantics for normal logic programs [37]. Much work has been spent on the suitability of these and other DLP semantics in various contexts, as well as on mathematical and structural properties, cf. <ref> [27, 55, 59, 74] </ref>. However, until recently, little was known on the complexity and the expressive power of disjunctive logic programming. <p> Recall that datalog programs are function-free logic programs. We consider here the extension of datalog to disjunctive logic programs; for a background on disjunctive logic programming, see <ref> [55, 59] </ref>. 3.1 Syntax A disjunctive datalog rule is a clause of the form a 1 _ _ a n b 1 ; ; b m ; 1 n; 0 m; (1) over a function-free first-order language, where the a i 's are atoms forming the head of the clause, and <p> allows disjunction in the head and negation of predicates from R. 1 DATALOG _;: , disjunctive datalog, is the language of all query programs. 3.2 Semantics There are several proposals to capture the meaning of disjunctive logic programs, based on different concepts of the intended models of a program (cf. <ref> [55, 59] </ref>). We consider minimal models [58] (arising in the AI community in circumscription [57], and in advanced forms of the Closed World Assumption, e.g. the Extended Generalized CWA [89]), the perfect models [65], and the (disjunctive) stable models [37, 66], which are among the most well-known such concepts. <p> Seipel [79] in Wurzburg (Germany) implements various semantics and methods developed by Minker and his students <ref> [55, 59] </ref> at College Park (Maryland, U.S.A.). There, V.S. Subrahmanian and his coworkers [6, 61, 7], use integer programming methods for implementing normal and disjunctive logic programming.
Reference: [56] <author> D. Maier and B. Vance. </author> <title> A Call to Order. </title> <booktitle> In Proc. PODS '93, </booktitle> <pages> pp. 1-16, </pages> <year> 1993. </year>
Reference-contexts: Example 4 (Eigenvectors) The need for doing matrix computations in databases has been recently emphasized <ref> [56] </ref>. In this context, we consider queries connected with eigenvector computations.
Reference: [57] <author> J. McCarthy. </author> <title> Applications of Circumscription to Formalizing Common-Sense Knowledge. </title> <journal> Artificial Intelligence, </journal> <volume> 28 </volume> <pages> 89-116, </pages> <year> 1986. </year> <month> 47 </month>
Reference-contexts: This semantics, also termed Extended Generalized Closed World Assumption (EGCWA) [89], is closely related to McCarthy's circumscription <ref> [57] </ref>. * Perfect model semantics [65]. This semantics has been defined for general DLPs, but is particularly suited for stratified DLPs. <p> We consider minimal models [58] (arising in the AI community in circumscription <ref> [57] </ref>, and in advanced forms of the Closed World Assumption, e.g. the Extended Generalized CWA [89]), the perfect models [65], and the (disjunctive) stable models [37, 66], which are among the most well-known such concepts. <p> Without inequality literals, this is not the case; we discuss this in detail in the next section. This result also shows that the expressive power of circumscription <ref> [57] </ref>, applied to function-free first-order theories, is p 2 under brave (possibility) inference. Our plan for this section is a follows. We consider first boolean (generic) queries and then general (generic) queries. In order to assure genericity of queries, we focus on disjunctive datalog programs that are constant-free.
Reference: [58] <author> J. Minker. </author> <title> On Indefinite Data Bases and the Closed World Assumption. </title> <booktitle> In Proc. 6 th Con--ference on Automated Deduction (CADE-82), </booktitle> <volume> LNCS 138, </volume> <pages> pp. 292-308, </pages> <year> 1982. </year>
Reference-contexts: Various semantics of DLPs have been proposed; they are commonly based on the paradigm of minimal models, which underlies Minker's Generalized Closed World Assumption <ref> [58] </ref>. For an overview of various semantics for DLPs, the reader may consult [55] and Minker's more recent article [59]. <p> We consider minimal models <ref> [58] </ref> (arising in the AI community in circumscription [57], and in advanced forms of the Closed World Assumption, e.g. the Extended Generalized CWA [89]), the perfect models [65], and the (disjunctive) stable models [37, 66], which are among the most well-known such concepts.
Reference: [59] <author> J. Minker. </author> <title> Overview of Disjunctive Logic Programming. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> <volume> 12 </volume> <pages> 1-24, </pages> <year> 1994. </year>
Reference-contexts: 1 Introduction Strong interest in enhancing logic programs by the capability of disjunction emerged in the logic programming, artificial intelligence, and databases communities. This interest is documented by a number of publications (cf. <ref> [55, 59] </ref>) and even workshops dedicated to this subject [88, 28]. In this paper, we study disjunctive logic programming in the context of databases. Datalog is a well-known database query language that uses disjunction-free logic programs, where no functions are allowed [83, 19]. <p> Various semantics of DLPs have been proposed; they are commonly based on the paradigm of minimal models, which underlies Minker's Generalized Closed World Assumption [58]. For an overview of various semantics for DLPs, the reader may consult [55] and Minker's more recent article <ref> [59] </ref>. In this paper, we limit our attention to three important semantics for disjunctive logic programming (and thus for disjunctive datalog), whose precise definition will be given in Section 3: * Minimal model semantics. <p> This semantics generalizes the well acknowledged stable semantics for normal logic programs [37]. Much work has been spent on the suitability of these and other DLP semantics in various contexts, as well as on mathematical and structural properties, cf. <ref> [27, 55, 59, 74] </ref>. However, until recently, little was known on the complexity and the expressive power of disjunctive logic programming. <p> Recall that datalog programs are function-free logic programs. We consider here the extension of datalog to disjunctive logic programs; for a background on disjunctive logic programming, see <ref> [55, 59] </ref>. 3.1 Syntax A disjunctive datalog rule is a clause of the form a 1 _ _ a n b 1 ; ; b m ; 1 n; 0 m; (1) over a function-free first-order language, where the a i 's are atoms forming the head of the clause, and <p> allows disjunction in the head and negation of predicates from R. 1 DATALOG _;: , disjunctive datalog, is the language of all query programs. 3.2 Semantics There are several proposals to capture the meaning of disjunctive logic programs, based on different concepts of the intended models of a program (cf. <ref> [55, 59] </ref>). We consider minimal models [58] (arising in the AI community in circumscription [57], and in advanced forms of the Closed World Assumption, e.g. the Extended Generalized CWA [89]), the perfect models [65], and the (disjunctive) stable models [37, 66], which are among the most well-known such concepts. <p> Seipel [79] in Wurzburg (Germany) implements various semantics and methods developed by Minker and his students <ref> [55, 59] </ref> at College Park (Maryland, U.S.A.). There, V.S. Subrahmanian and his coworkers [6, 61, 7], use integer programming methods for implementing normal and disjunctive logic programming.
Reference: [60] <author> R. Moore. </author> <title> Semantical Considerations on Nonmonotonic Logics. </title> <journal> Artificial Intelligence, </journal> <volume> 25 </volume> <pages> 75-94, </pages> <year> 1985. </year>
Reference-contexts: Interestingly, there exists no modular embedding of DQL into disjunctive datalog. This can be seen as follows. In [52, 22], modular embeddings of disjunctive logic programming into autoepistemic logic <ref> [60] </ref> are exhibited. Thus, if there existed a modular embedding of default logic into disjunctive logic programming, by composition, there would also exist a modular embedding of default logic into autoepistemic logic. <p> Another aspect highlighting the difference between disjunctive datalog and DQL is their expressive power over disjunctive (clausal) databases. As shown in [12], the expressive powers of the two languages are different in that context. Autoepistemic logic <ref> [60] </ref> has the same expressive power as default logic [12]. Promising variants of default logic such as stable class default logic [5] remain to be explored. Acknowledgements The authors would like to thank several people for their comments on this work. In particular, we are indebted to P.A. Bonatti, J.
Reference: [61] <author> A. Nerode, R. Ng, </author> <title> and V.S. Subrahmanian. Computing Circumscriptive Databases. I: Theory and Algorithms. </title> <journal> Information and Computation, </journal> <volume> 116 </volume> <pages> 58-80, </pages> <year> 1995. </year>
Reference-contexts: Seipel [79] in Wurzburg (Germany) implements various semantics and methods developed by Minker and his students [55, 59] at College Park (Maryland, U.S.A.). There, V.S. Subrahmanian and his coworkers <ref> [6, 61, 7] </ref>, use integer programming methods for implementing normal and disjunctive logic programming.
Reference: [62] <author> C. Papadimitriou. </author> <title> The Complexity of Unique Solutions. </title> <journal> JACM, </journal> <volume> 31 </volume> <pages> 492-500, </pages> <year> 1984. </year>
Reference-contexts: Computing an optimal tour is both NP-hard and co-NP-hard. In fact, in <ref> [62] </ref> it was shown that deciding whether the cost of an optimal tour is even is p 2 -complete, and in 11 [50] it was shown that computing this cost (or even a single bit) is F p 2 -complete under so called metric reductions.
Reference: [63] <author> C. Papadimitriou and M. Yannakakis. </author> <title> A Note on Succinct Representations of Graphs. </title> <journal> Information and Computation, </journal> <volume> 71 </volume> <pages> 181-185, </pages> <year> 1985. </year>
Reference-contexts: Notice that NP NEXP-TIME NP , and hence NEXPTIME NP -complete problems are provably intractable; few natural among them are known. We establish the NEXPTIME NP -completeness results using complexity upgrade techniques that extend results in <ref> [3, 63, 64] </ref>, applied to results in [80]. * We demonstrate the practical relevance of disjunctive datalog by exhibiting queries which can be expressed in disjunctive datalog but not in standard datalog with negation (DATALOG : ) unless the Polynomial Hierarchy collapses. <p> The proof of this result relies on the use of complexity upgrade techniques that extend the results in <ref> [3, 63] </ref>, applied to results in [80], and the simulation of boolean circuits by a DATALOG _ program without 6= and negation under minimal model semantics. In [47], a similar simulation was described in DATALOG :;6= using stratified negation and fixpoint semantics. <p> Such effects were investigated for the "succinct versions" of graph-theoretic problems in <ref> [63] </ref>, where a graph whose vertices are elements of f0; 1g n is represented by a boolean circuit with 2n input bits; the circuit outputs 1 if and only if the input represents two vertices which are connected by an edge. <p> For not-gates, j = k (cf. [47]). As shown in <ref> [63] </ref>, the succinct problem setting often leads to an exponential complexity increase. The results and techniques of [63] (see also [64]) were generalized in [3] to the succinct version of any decision problem A encoded as a language over f0; 1g. <p> For not-gates, j = k (cf. [47]). As shown in <ref> [63] </ref>, the succinct problem setting often leads to an exponential complexity increase. The results and techniques of [63] (see also [64]) were generalized in [3] to the succinct version of any decision problem A encoded as a language over f0; 1g.
Reference: [64] <author> C. H. Papadimitriou. </author> <title> Computational Complexity. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Notice that NP NEXP-TIME NP , and hence NEXPTIME NP -complete problems are provably intractable; few natural among them are known. We establish the NEXPTIME NP -completeness results using complexity upgrade techniques that extend results in <ref> [3, 63, 64] </ref>, applied to results in [80]. * We demonstrate the practical relevance of disjunctive datalog by exhibiting queries which can be expressed in disjunctive datalog but not in standard datalog with negation (DATALOG : ) unless the Polynomial Hierarchy collapses. <p> compares disjunctive datalog to common and novel database query languages, addresses the issue of why its precise expressiveness characterization is relevant, and outlines open issues for future work. 2 Preliminaries We assume familiarity with the basic concepts of complexity theory and logical query languages for databases; for a background, see <ref> [64, 83, 19, 2] </ref>. A relational scheme over a domain Dom is a (possibly empty) list R = R 1 ; : : : ; R k of relation symbols R i , i = 1; : : : ; k of arity a (R i ) 0. <p> It is possible to formulate many queries which can not be expressed in standard datalog. Among these queries are classical optimization problems such as Traveling Salesman, Maximum Clique, Minimal Vertex Cover etc. <ref> [64] </ref> which are NP-hard and NP-easy, i.e., solvable in polynomial time with an oracle for NP. 9 In this section, we show several practical queries that can be formulated in disjunctive datalog, but not in standard datalog unless PH collapses, which is generally believed to be false (see [64]). <p> Cover etc. <ref> [64] </ref> which are NP-hard and NP-easy, i.e., solvable in polynomial time with an oracle for NP. 9 In this section, we show several practical queries that can be formulated in disjunctive datalog, but not in standard datalog unless PH collapses, which is generally believed to be false (see [64]). In our examples involving optimization problems, we use integers 0; 1; : : : and the standard arithmetic operations (resp. predicates) of addition and multiplication. <p> For not-gates, j = k (cf. [47]). As shown in [63], the succinct problem setting often leads to an exponential complexity increase. The results and techniques of [63] (see also <ref> [64] </ref>) were generalized in [3] to the succinct version of any decision problem A encoded as a language over f0; 1g. <p> This problem is complete for P under projection translations, even if negation is restricted to input gates [87] (essentially, this can be seen as an encoding of the MONOTONE CIRCUIT VALUE problem in <ref> [64] </ref>). A pure datalog program solving this problem is straightforward. <p> For example, important optimization problems such as computing optimal tours for the TSP or computing maximal eigenvectors are expressible, while playing games like GO (which is PSPACE-complete, cf. <ref> [64] </ref>) is 41 not possible in DATALOG _;: unless the Polynomial Hierarchy collapses. The complexity results give us useful information about the algorithmic nature of the query-answering problem.
Reference: [65] <author> T. Przymusinski. </author> <title> On the Declarative and Procedural Semantics of Stratified Deductive Databases. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pp. 193-216. </pages> <publisher> Morgan Kaufman, </publisher> <address> Washington DC, </address> <year> 1988. </year>
Reference-contexts: This semantics, also termed Extended Generalized Closed World Assumption (EGCWA) [89], is closely related to McCarthy's circumscription [57]. * Perfect model semantics <ref> [65] </ref>. This semantics has been defined for general DLPs, but is particularly suited for stratified DLPs. Note that the perfect model approach is successfully used by Kifer, Lausen, and Wu [45] for defining a semantics of object oriented languages. * Disjunctive stable model semantics [66, 38]. <p> We consider minimal models [58] (arising in the AI community in circumscription [57], and in advanced forms of the Closed World Assumption, e.g. the Extended Generalized CWA [89]), the perfect models <ref> [65] </ref>, and the (disjunctive) stable models [37, 66], which are among the most well-known such concepts. Using these concepts, we define different semantics of disjunctive datalog, which give rise to different query languages; the semantics of sublanguages is implicit. We need some notation and concepts from (disjunctive) logic programming. <p> Notice that each stable model of is a minimal model, i.e., SM () MM () holds. However, the converse is not true in general. Perfect models have been proposed earlier than disjunctive stable models in <ref> [65] </ref>. The definition of perfect models for arbitrary programs is provided in the appendix; we characterize here only the perfect models of stratified programs, for which the perfect models amount to the commonly agreed models. <p> The characterization is known by the equivalence of perfect models and models of prioritized circumscription for stratified programs <ref> [65] </ref>, and can be easily proved from properties and results below. <p> Dix, K. Inoue, Ph. Kolaitis, J.S. Schlipf, H. Veith, and V. Vianu for important hints and comments. Furthermore, we are grateful to the anonymous referees for their constructive comments and helpful suggestions for improvement. A Appendix: Perfect models The perfect models of a program are defined as follows (cf. <ref> [65] </ref>). A priority relation &lt; is defined on HB using an auxiliary relation as follows.
Reference: [66] <author> T. Przymusinski. </author> <title> Stable Semantics for Disjunctive Programs. </title> <journal> New Generation Computing, </journal> <volume> 9 </volume> <pages> 401-424, </pages> <year> 1991. </year>
Reference-contexts: This semantics has been defined for general DLPs, but is particularly suited for stratified DLPs. Note that the perfect model approach is successfully used by Kifer, Lausen, and Wu [45] for defining a semantics of object oriented languages. * Disjunctive stable model semantics <ref> [66, 38] </ref>. This semantics generalizes the well acknowledged stable semantics for normal logic programs [37]. Much work has been spent on the suitability of these and other DLP semantics in various contexts, as well as on mathematical and structural properties, cf. [27, 55, 59, 74]. <p> We consider minimal models [58] (arising in the AI community in circumscription [57], and in advanced forms of the Closed World Assumption, e.g. the Extended Generalized CWA [89]), the perfect models [65], and the (disjunctive) stable models <ref> [37, 66] </ref>, which are among the most well-known such concepts. Using these concepts, we define different semantics of disjunctive datalog, which give rise to different query languages; the semantics of sublanguages is implicit. We need some notation and concepts from (disjunctive) logic programming. <p> I, which is obtained by removing from ground () all clauses that contain a negative literal :a in the body such that a 2 I, and by removing all negative literals from the remaining clauses; Notice that I is a :-free grounded (i.e., variable-free) program. Definition 3.2 <ref> [66] </ref> An interpretation M is a (disjunctive) stable model of iff M 2 MM ( M ); by SM () we denote the set of all stable models of . Notice that each stable model of is a minimal model, i.e., SM () MM () holds. <p> Notice that like stable models, perfect models are always minimal models. For convenience, we use in the sequel S as a generic variable for MM ; PM ; and SM . The following proposition states fundamental relationships between minimal, perfect, and stable models. Proposition 3.2 <ref> [66] </ref> Let be a stratified program. Then, PM () = SM (). Moreover, (i) if is disjunction-free, then has a unique perfect (resp. stable) model; (ii) if is positive (i.e., :-free), then PM () = SM () = MM ().
Reference: [67] <author> T. C. Przymusinski. </author> <title> A knowledge representation framework based on autoepistemic logic of minimal beliefs. </title> <booktitle> In Proc. Twelfth National Conference on Artificial Intelligence, AAAI-94, </booktitle> <address> Seattle, </address> <month> August </month> <year> 1994, </year> <pages> pp. 952-959, </pages> <address> 1994. </address> <publisher> AAAI, Morgan Kaufmann. </publisher>
Reference-contexts: This requirement is well-acknowledged, and led to the formulation of desirable modularity properties for normal and disjunctive logic programs, cf. [78, 27, 83, 70, 53]. The notion of modularity of programs is related to invariance under unfolding (cf. [14]) which was independently established for the static semantics <ref> [67, 68] </ref> and for the D-WFS semantics [14]. Notice that stratified programs enjoy such a modularity property. <p> For example, the group of Dix and Furbach [29] in Koblenz (Germany), in an ambitious project, implements the disjunctive stable semantics and other semantics of disjunctive logic programming; in particular, they implement the recently proposed static semantics <ref> [67, 68] </ref>, which is very similar to the D-WFS semantics [14, 16, 17] and the well-founded circumscription semantics [90]; in fact, for disjunctive datalog, static semantics and well-founded circumscription semantics coincide (cf. [91]).
Reference: [68] <author> T. C. Przymusinski. </author> <title> Static semantics for normal and disjunctive logic programs. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> (14):323-357, 1995. 
Reference-contexts: This requirement is well-acknowledged, and led to the formulation of desirable modularity properties for normal and disjunctive logic programs, cf. [78, 27, 83, 70, 53]. The notion of modularity of programs is related to invariance under unfolding (cf. [14]) which was independently established for the static semantics <ref> [67, 68] </ref> and for the D-WFS semantics [14]. Notice that stratified programs enjoy such a modularity property. <p> For example, the group of Dix and Furbach [29] in Koblenz (Germany), in an ambitious project, implements the disjunctive stable semantics and other semantics of disjunctive logic programming; in particular, they implement the recently proposed static semantics <ref> [67, 68] </ref>, which is very similar to the D-WFS semantics [14, 16, 17] and the well-founded circumscription semantics [90]; in fact, for disjunctive datalog, static semantics and well-founded circumscription semantics coincide (cf. [91]).
Reference: [69] <author> R. Reiter. </author> <title> A Logic for Default Reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 13 </volume> <pages> 81-132, </pages> <year> 1980. </year>
Reference-contexts: On the more theoretical side, we currently investigate the expressive power of non-monotonic formalisms that are related to disjunctive logic programming. One of the most popular nonmonotonic logics is Reiter's default logic <ref> [69] </ref>. This logic was developed as a knowledge representation formalism and was originally not conceived 42 as a database query language. However, in [18] a suitable setting was defined in which default logic can be used as a query language for relational databases (Default Query Language, DQL).
Reference: [70] <author> K. Ross. </author> <title> Modular Stratification and Magic Sets for Datalog Programs with Negation. </title> <journal> JACM, </journal> <volume> 41(6) </volume> <pages> 1216-1267, </pages> <year> 1994. </year>
Reference-contexts: This requirement is well-acknowledged, and led to the formulation of desirable modularity properties for normal and disjunctive logic programs, cf. <ref> [78, 27, 83, 70, 53] </ref>. The notion of modularity of programs is related to invariance under unfolding (cf. [14]) which was independently established for the static semantics [67, 68] and for the D-WFS semantics [14]. Notice that stratified programs enjoy such a modularity property. <p> Guided by this intuition, we introduce a formal notion of program decomposition. A subset C of the rules of is called a complete component of (cf. <ref> [70] </ref>), if for every predicate P that occurs in the head of any rule from C, every rule from belongs to C that has P in the head or some predicate Q mutually recursive with P . <p> It is easily checked that the collection of all complete components that are minimal with respect to inclusion (called strongly connected components (SCCs) in <ref> [83, 70] </ref>), is a decomposition and a refinement of any other decomposition, and hence the unique most refined decomposition of . Example 5 (ctd) Since 2 . 2 , by Proposition 5.2 1 and 2 are complete components of = 1 [ 2 .
Reference: [71] <author> D. Sacca. </author> <title> The Expressive Powers of Stable Models for Bound and Unbound DATALOG Queries. </title> <journal> J. Computer and System Sciences, </journal> <note> to appear. </note>
Reference-contexts: In the latter case, it is currently not known, but strongly believed that the inclusion is proper. Note that recent results of Sacca show that normal logic programming using maximal or least undefined partial stable models can have the same expressive power as disjunctive logic programming <ref> [71] </ref>. DATALOG _;: appears to be a language of very high expressive power, and therefore, the worst-case complexity of answering queries in this formalism is very high, which may be seen as a serious drawback.
Reference: [72] <author> D. Sacca and C. Zaniolo. </author> <title> Stable Models and Non-Determinism in Logic Programs with Negation. </title> <booktitle> In Proc. PODS '90, </booktitle> <pages> pp. 205-218, </pages> <year> 1990. </year>
Reference-contexts: In the above examples, candidate solutions are generated by one component of the program and tested by another. This is reminds of datalog extended with a choice construct, by which such candidates can be nondeterministically generated. As shown by Sacca and Zaniolo <ref> [72] </ref>, choice can be be formulated using stable models of a normal program that has unstratified rules. However, in this setting, the testing phase where the validity of a choice is checked is limited to a polynomial time computation.
Reference: [73] <author> C. Sakama and K. Inoue. </author> <title> Relating Disjunctive Logic Programs to Default Theories. </title> <editor> In L.- M. Pereira and A. Nerode, editors, </editor> <booktitle> Proc. Second Intl Workshop on Logic Programming and Nonmonotonic Reasoning (LPNMR '93), </booktitle> <pages> pp. 266-282, </pages> <address> Lisbon, July 1993. </address> <publisher> MIT Press. </publisher>
Reference-contexts: On one hand, note that each disjunctive logic program can be translated into an equivalent default theory. A concrete translation, related to earlier work in [11], was described by Sakama and Inoue in <ref> [73] </ref>. Their translation is rather intuitive and modular, which means that the translation of a disjunctive logic program is obtained by the union of the independent translations of the single rules. <p> In this translation, each rule is rewritten to a default and further normal defaults enforcing the closed world assumption are added. A related proposal for handling disjunction by using normal defaults has been recently pointed out in [82]. Based on the translation mapping of <ref> [73] </ref>, a translation from DATALOG _;: under the stable semantics into DQL can be obtained.
Reference: [74] <author> C. Sakama and K. Inoue. </author> <title> An Alternative Approach to the Semantics of Disjunctive Logic Programs and Deductive Databases. </title> <journal> J. Automated Reasoning, </journal> <volume> 13 </volume> <pages> 145-172, </pages> <year> 1994. </year>
Reference-contexts: This semantics generalizes the well acknowledged stable semantics for normal logic programs [37]. Much work has been spent on the suitability of these and other DLP semantics in various contexts, as well as on mathematical and structural properties, cf. <ref> [27, 55, 59, 74] </ref>. However, until recently, little was known on the complexity and the expressive power of disjunctive logic programming.
Reference: [75] <author> C. Sakama and K. Inoue. </author> <title> Paraconsistent Stable Semantics for Extended Disjunctive Programs. </title> <journal> J. Logic and Computation, </journal> <volume> 5(3) </volume> <pages> 265-285, </pages> <year> 1995. </year>
Reference: [76] <author> J. Schlipf. </author> <title> Decidability and Definability with Circumscription. </title> <journal> Annals of Pure and Applied Logic, </journal> <volume> 35 </volume> <pages> 173-191, </pages> <year> 1987. </year>
Reference-contexts: However, until recently, little was known on the complexity and the expressive power of disjunctive logic programming. Noticeable recursion-theoretic results on disjunctive inference formalisms over infinite structures where obtained by Schlipf <ref> [76] </ref>, who showed that general circumscription over the integers is 1 2 -complete, and by Chomicki and Subrahmanian [24], who showed that Minker's Generalized Closed World Assumption is 0 2 -complete.
Reference: [77] <author> J. Schlipf. </author> <title> A Survey of Complexity and Undecidability Results in Logic Programming. </title> <journal> Annals of Mathematics and Artificial Intelligence, </journal> 15(3/4):257-288, 1995. 
Reference-contexts: These results show that 1 on infinite structures, disjunctive logic programming is harder than both classical reasoning and normal logic programming [24] (see <ref> [77] </ref> for an overview). However, most computer science applications deal with finite structures, in particular, with database relations. In this context, the important question of whether each DLP can be replaced by an equivalent normal logic program was open.
Reference: [78] <author> J. Schlipf. </author> <title> The Expressive Powers of Logic Programming Semantics. </title> <journal> J. Computer and System Sciences, </journal> <volume> 51(1) </volume> <pages> 64-86, </pages> <year> 1995. </year> <booktitle> Abstract in Proc. PODS '90, </booktitle> <pages> pp. 196-204. </pages>
Reference-contexts: Our results provide a clear picture of the expressiveness of disjunctive datalog in the various settings. Moreover, they complement and extend previous results of important extensions of datalog and related query languages (see [2, 44]). Note that the major versions of DATALOG : <ref> [47, 78, 84] </ref> express database queries in NP (resp. co-NP) under possibility (resp. certainty) inference. Thus, disjunction adds expressive power (unless 2 = NP). A consequence of the high expressive power of disjunctive datalog is a high worst-case complexity. <p> The result of the query computed by a query program (i.e., of ()) on an input database D is defined in terms of the models S (; D), by taking as usual either the union of all models or the intersection <ref> [1, 78] </ref>. The former approach (union) is known as possibility inference (also termed brave or credulous reasoning in the AI community), and the latter (intersection) as certainty inference (also termed cautious or skeptical inference) [42, 1]. Definition 3.4 Let inf be an inference modality from p (ossibility), c (ertainty). <p> This requirement is well-acknowledged, and led to the formulation of desirable modularity properties for normal and disjunctive logic programs, cf. <ref> [78, 27, 83, 70, 53] </ref>. The notion of modularity of programs is related to invariance under unfolding (cf. [14]) which was independently established for the static semantics [67, 68] and for the D-WFS semantics [14]. Notice that stratified programs enjoy such a modularity property. <p> Thus the expressive power of disjunctive datalog is one level above the 21 expressive power of normal datalog under stable model semantics <ref> [78] </ref> or fixpoint semantics [47], which is NP. An interesting result is that the full expressive power is already available with DATA LOG _;6= programs; hence, also the DATALOG _;6= p queries capture p 2 , provided that inequality literals are allowed in the body.
Reference: [79] <author> D. Seipel. </author> <title> Non-Monotonic Reasoning Based on Minimal Models and its Efficient Implementation. </title> <booktitle> In [88], </booktitle> <pages> pp. 53-60. </pages>
Reference-contexts: Moreover, preliminary results based on characterizations in [16] indicate that it can only express such queries, and thus has the same expressive power as DATALOG _;: under the certainty variant of the stable model semantics; we leave this for further study. Seipel <ref> [79] </ref> in Wurzburg (Germany) implements various semantics and methods developed by Minker and his students [55, 59] at College Park (Maryland, U.S.A.). There, V.S. Subrahmanian and his coworkers [6, 61, 7], use integer programming methods for implementing normal and disjunctive logic programming.
Reference: [80] <author> I. Stewart. </author> <title> Complete Problems Involving Boolean Labelled Structures and Projection Transactions. </title> <journal> J. Logic and Computation, </journal> <volume> 1(6) </volume> <pages> 861-882, </pages> <year> 1991. </year>
Reference-contexts: Notice that NP NEXP-TIME NP , and hence NEXPTIME NP -complete problems are provably intractable; few natural among them are known. We establish the NEXPTIME NP -completeness results using complexity upgrade techniques that extend results in [3, 63, 64], applied to results in <ref> [80] </ref>. * We demonstrate the practical relevance of disjunctive datalog by exhibiting queries which can be expressed in disjunctive datalog but not in standard datalog with negation (DATALOG : ) unless the Polynomial Hierarchy collapses. <p> The proof of this result relies on the use of complexity upgrade techniques that extend the results in [3, 63], applied to results in <ref> [80] </ref>, and the simulation of boolean circuits by a DATALOG _ program without 6= and negation under minimal model semantics. In [47], a similar simulation was described in DATALOG :;6= using stratified negation and fixpoint semantics. Briefly, the proof consists in a reduction of a problem on graphs, co-CERT3COL [80], in <p> in <ref> [80] </ref>, and the simulation of boolean circuits by a DATALOG _ program without 6= and negation under minimal model semantics. In [47], a similar simulation was described in DATALOG :;6= using stratified negation and fixpoint semantics. Briefly, the proof consists in a reduction of a problem on graphs, co-CERT3COL [80], in its succinct version co-CERT3COL S [3], i.e., the problem input consists of a boolean circuit C w by which the bits of the standard problem input w (a binary string encoding the graph) can be computed. <p> The query program involves a subprogram which simulates boolean circuits by which the relations in the input structure encoding the graph can be computed. Problem co-CERT3COL is as follows (cf. <ref> [80] </ref>): Instance of size n: a graph G on the vertices f0; 1; : : : ; n 1g such that every edge is labeled with a disjunction of two literals, where each literal is over the boolean variables fX i;j : i; j = 0; : : : ; n
Reference: [81] <author> L. J. Stockmeyer. </author> <title> The Polynomial-Time Hierarchy. </title> <journal> Theoretical Computer Science, </journal> <volume> 3 </volume> <pages> 1-22, </pages> <year> 1977. </year>
Reference-contexts: Thus, adding 6= (inequality) to DATALOG _ (giving DATALOG _;6= ) suffices to gain full expressive power. This result is proved exploiting a strengthened form of Fagin's Theorem generalized to the Polynomial Hierarchy ( p p 2 = NP NP , . . . ) <ref> [36, 81] </ref>, which exists for finite structures only and classes p k where k 2 [33]. The same expressive power ( p gained by adding negation (:) in case of both the SM and the PM semantics. For these semantics, symmetric results ( p 2 -expressiveness) holds for certainty reasoning. <p> As common with query languages, we will focus in our analysis of the expressive power of disjunctive datalog on generic queries. 4 It is well-known that second-order definability of properties on finite structures is closely connected to computability within the Polynomial Hierarchy (PH) <ref> [81] </ref>. Recall that the classes of PH are defined as follows: p p p p k , p k , and k+1 = co k+1 . <p> Proposition 2.1 <ref> [36, 81] </ref> A database property P over a relational scheme R is in p k 1, iff there exists a 1 k (R)-sentence such that for each D 2 D (R), D j= iff P (D) = true. 3 Disjunctive datalog We assume that the reader is familiar with the basic
Reference: [82] <author> H. Turner. </author> <title> Representing Actions in Default Logic: A Situation Calculus Approach. In Proc. Common Sense '96, </title> <year> 1996. </year>
Reference-contexts: In this translation, each rule is rewritten to a default and further normal defaults enforcing the closed world assumption are added. A related proposal for handling disjunction by using normal defaults has been recently pointed out in <ref> [82] </ref>. Based on the translation mapping of [73], a translation from DATALOG _;: under the stable semantics into DQL can be obtained.
Reference: [83] <author> J. D. Ullman. </author> <title> Principles of Database and Knowledge Base Systems. </title> <publisher> CS Press, </publisher> <year> 1989. </year>
Reference-contexts: In this paper, we study disjunctive logic programming in the context of databases. Datalog is a well-known database query language that uses disjunction-free logic programs, where no functions are allowed <ref> [83, 19] </ref>. We deal here with extensions of such programs by disjunction (and, as well as for datalog, by negation); the corresponding query languages thus amount to disjunctive datalog. Briefly, a disjunctive logic program (DLP) is a logic program where disjunction may occur in the rule heads. <p> compares disjunctive datalog to common and novel database query languages, addresses the issue of why its precise expressiveness characterization is relevant, and outlines open issues for future work. 2 Preliminaries We assume familiarity with the basic concepts of complexity theory and logical query languages for databases; for a background, see <ref> [64, 83, 19, 2] </ref>. A relational scheme over a domain Dom is a (possibly empty) list R = R 1 ; : : : ; R k of relation symbols R i , i = 1; : : : ; k of arity a (R i ) 0. <p> relational scheme R is in p k 1, iff there exists a 1 k (R)-sentence such that for each D 2 D (R), D j= iff P (D) = true. 3 Disjunctive datalog We assume that the reader is familiar with the basic concepts of deductive databases and logic programming <ref> [54, 83, 19] </ref>. Recall that datalog programs are function-free logic programs. <p> This requirement is well-acknowledged, and led to the formulation of desirable modularity properties for normal and disjunctive logic programs, cf. <ref> [78, 27, 83, 70, 53] </ref>. The notion of modularity of programs is related to invariance under unfolding (cf. [14]) which was independently established for the static semantics [67, 68] and for the D-WFS semantics [14]. Notice that stratified programs enjoy such a modularity property. <p> S j&lt;i j . We consider here a more general concept, in which modules can be even unstratified programs (cf. <ref> [83] </ref>); it shows that hierarchical structured query programming is possible in disjunctive datalog using stable models. This makes the language, besides its declarative nature, appealing as a powerful extension of familiar datalog. <p> On the other hand, it is possible to break up any given query program efficiently into components and then compute the stable models bottom up, according to a dependency relation between components. This property is important for implementation, and has been exploited already in systems based on datalog <ref> [83] </ref>. <p> It is easily checked that the collection of all complete components that are minimal with respect to inclusion (called strongly connected components (SCCs) in <ref> [83, 70] </ref>), is a decomposition and a refinement of any other decomposition, and hence the unique most refined decomposition of . Example 5 (ctd) Since 2 . 2 , by Proposition 5.2 1 and 2 are complete components of = 1 [ 2 .
Reference: [84] <author> A. van Gelder, K. Ross, and J. Schlipf. </author> <title> The Well-Founded Semantics for General Logic Programs. </title> <journal> JACM, </journal> <volume> 38(3) </volume> <pages> 620-650, </pages> <year> 1991. </year>
Reference-contexts: Our results provide a clear picture of the expressiveness of disjunctive datalog in the various settings. Moreover, they complement and extend previous results of important extensions of datalog and related query languages (see [2, 44]). Note that the major versions of DATALOG : <ref> [47, 78, 84] </ref> express database queries in NP (resp. co-NP) under possibility (resp. certainty) inference. Thus, disjunction adds expressive power (unless 2 = NP). A consequence of the high expressive power of disjunctive datalog is a high worst-case complexity. <p> These relationships are depicted in Figure 2. Proofs and/or references for the other query languages appearing in this figure can found in [2]; here, DATALOG : wf denotes nondisjunctive datalog with well-founded negation <ref> [84] </ref>. Solid lines represent proper inclusion (), while dashed lines stand for possibly improper inclusion (). In the latter case, it is currently not known, but strongly believed that the inclusion is proper.
Reference: [85] <author> M. Vardi. </author> <title> Complexity of Relational Query Languages. </title> <booktitle> In Proc. 14th ACM STOC, </booktitle> <pages> pp. 137-146, </pages> <address> San Francisco, </address> <year> 1982. </year>
Reference-contexts: Similarly, a database property P is C-recognizable (or, in C) iff deciding P (D) = true is in C. A query language is a set L of query expressions E and a function defining the semantics of L, such that for each E 2 L, (E) is a query <ref> [85] </ref>. The expressive power E (L) of L is the set of all queries definable by query expressions from L, i.e., E (L) = fq : q = (E); E 2 Lg. Of particular interest are the generic queries definable in L. <p> Section 8). Analogous to DATALOG, which expresses all P-time queries on enumerated databases (i.e., databases with a successor relation on the universe) <ref> [85, 43] </ref>, DATALOG _ p expresses all p 2 -recognizable queries on enumerated databases, since the inequality predicate can be easily defined from the enumeration of the universe. <p> However, for q = q Even this is not true (Theorem 7.3). This proves the theorem. 31 8 Complexity of disjunctive datalog An important aspect of a query language is its computational complexity, which is traditionally measured by data and expression complexity, cf. <ref> [85] </ref>. The data (resp. expression) complexity of a query language L is defined as the complexity of the QOT-problem in Section 2 for the queries defined by expressions E 2 L, where E is part of the input and E (resp. D) is fixed. <p> Since I can be constructed from C I in polynomial time, the result follows. Notice that evaluating a given DATALOG _;: query program under p; S semantics on a given database (termed combined complexity in <ref> [85] </ref>), is exp 2 -complete as well. Remarks. Without loss of generality, we could bypass or-gates in the boolean circuit simu lation, by simulating or-gates with and-gates and not-gates. Moreover, the transformation described in the proof of Theorem 8.8 can be performed in logspace. <p> Notice that this way we obtain, using complexity upgrading techniques, a simple proof of the folklore result that pure DATALOG has EXPTIME-complete expression complexity, which is implicit already in <ref> [85, 20] </ref>. Indeed, the exponential upgrade of P is EXPTIME; problems that are complete for P under P LT m reductions (or even stronger notions of 39 reductions) can be expressed in pure datalog.
Reference: [86] <author> H. Veith. </author> <title> Logical Reducibilities in Finite Model Theory. </title> <type> Master's thesis, </type> <institution> Information Systems Department, TU Vienna, Austria, </institution> <month> September </month> <year> 1994. </year>
Reference-contexts: Furthermore, A p m long (A) S ([3, Lemma 4]); by transitivity, A p m B S , and thus B S is p m -hard for C1. A strengthening of this theorem from p m -transformation to logspace-transformation is shown in <ref> [86, 40] </ref>. The proof of Theorem 8.8 uses this complexity upgrade technique. It gives a polynomial time transformation of the succinct version co-CERT3COL S of the graph problem co-CERT3COL, to evaluating boolean :-free DATALOG _ p query programs over a fixed data base. <p> Stewart showed that the complementary problem CERT3COL (i.e., negated condition for Yes-instances) is complete for p 2 under projection translations. It can be easily seen that projection translatability implies P LT m -transformability (cf. <ref> [86] </ref>). Thus, co-CERT3COL is complete for p 2 under P LT m -transformation. Applying the complexity upgrade theorem, we thus obtain Theorem 8.5 co-CERT3COL S is complete for exp 2 under p m -transformation. We next describe disjunctive datalog programs for deciding co-CERT3COL and for simulating a boolean circuit. <p> Moreover, the transformation described in the proof of Theorem 8.8 can be performed in logspace. Thus, by using the strengthening of Theorem 8.4 from p m -transformation to logspace-transformation <ref> [86, 40] </ref>, one can obtain a strengthening of Theorem 8.8 to logspace-transformation. In fact, the function of a circuit can be computed by a program that uses neither disjunction nor negation, i.e., a pure datalog program; this improves on the proof approach in [47], where negation was needed.
Reference: [87] <author> H. Veith. </author> <title> Succinct Representation and Leaf Languages. </title> <booktitle> In 11th Annual IEEE Conference on Computational Complexity, </booktitle> <pages> pp. 118-126, </pages> <address> Philadelphia, PA, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: An example is the CIRCUIT VALUE problem (compute the output of a Boolean circuit on a given input). This problem is complete for P under projection translations, even if negation is restricted to input gates <ref> [87] </ref> (essentially, this can be seen as an encoding of the MONOTONE CIRCUIT VALUE problem in [64]). A pure datalog program solving this problem is straightforward.
Reference: [88] <editor> B. Wolfinger, editor. </editor> <booktitle> 13th IFIP World Computer Congress, Proc. Workshop FG2: Disjunctive Logic Programming and Disjunctive Databases, Hamburg, August 1994. </booktitle> <publisher> Springer Berlin. </publisher>
Reference-contexts: 1 Introduction Strong interest in enhancing logic programs by the capability of disjunction emerged in the logic programming, artificial intelligence, and databases communities. This interest is documented by a number of publications (cf. [55, 59]) and even workshops dedicated to this subject <ref> [88, 28] </ref>. In this paper, we study disjunctive logic programming in the context of databases. Datalog is a well-known database query language that uses disjunction-free logic programs, where no functions are allowed [83, 19].
Reference: [89] <author> A. Yahya and L. Henschen. </author> <title> Deduction in Non-Horn Databases. </title> <journal> J. Automated Reasoning, </journal> <volume> 1(2) </volume> <pages> 141-160, </pages> <year> 1985. </year>
Reference-contexts: In this paper, we limit our attention to three important semantics for disjunctive logic programming (and thus for disjunctive datalog), whose precise definition will be given in Section 3: * Minimal model semantics. This semantics, also termed Extended Generalized Closed World Assumption (EGCWA) <ref> [89] </ref>, is closely related to McCarthy's circumscription [57]. * Perfect model semantics [65]. This semantics has been defined for general DLPs, but is particularly suited for stratified DLPs. <p> We consider minimal models [58] (arising in the AI community in circumscription [57], and in advanced forms of the Closed World Assumption, e.g. the Extended Generalized CWA <ref> [89] </ref>), the perfect models [65], and the (disjunctive) stable models [37, 66], which are among the most well-known such concepts. Using these concepts, we define different semantics of disjunctive datalog, which give rise to different query languages; the semantics of sublanguages is implicit.
Reference: [90] <author> J.-H. You and L.-Y. Yuan. </author> <title> Autoepistemic Circumscription and Logic Programming. </title> <journal> J. Automated Reasoning, </journal> <volume> 10 </volume> <pages> 143-160, </pages> <year> 1993. </year>
Reference-contexts: Dix and Furbach [29] in Koblenz (Germany), in an ambitious project, implements the disjunctive stable semantics and other semantics of disjunctive logic programming; in particular, they implement the recently proposed static semantics [67, 68], which is very similar to the D-WFS semantics [14, 16, 17] and the well-founded circumscription semantics <ref> [90] </ref>; in fact, for disjunctive datalog, static semantics and well-founded circumscription semantics coincide (cf. [91]). The static semantics associates with each program a set of modal formulas as its meaning; it appears to be the best candidate for a natural extension of the well-founded semantics to disjunctive logic programs.
Reference: [91] <author> J.-H. You and L.-Y. Yuan. </author> <title> On the Extension of Logic Programming with Negation through Uniform Proofs. </title> <editor> In W. Marek, A. Nerode, and M. Truszczynski, editors, </editor> <booktitle> Proc. Third Intl Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR '95), </booktitle> <volume> LNCS 928, </volume> <pages> pp. 231-244, </pages> <address> Lexington KY, </address> <month> July </month> <year> 1995. </year> <month> 49 </month>
Reference-contexts: stable semantics and other semantics of disjunctive logic programming; in particular, they implement the recently proposed static semantics [67, 68], which is very similar to the D-WFS semantics [14, 16, 17] and the well-founded circumscription semantics [90]; in fact, for disjunctive datalog, static semantics and well-founded circumscription semantics coincide (cf. <ref> [91] </ref>). The static semantics associates with each program a set of modal formulas as its meaning; it appears to be the best candidate for a natural extension of the well-founded semantics to disjunctive logic programs.
References-found: 91

