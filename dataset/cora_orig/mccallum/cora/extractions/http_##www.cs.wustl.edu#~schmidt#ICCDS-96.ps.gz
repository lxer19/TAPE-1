URL: http://www.cs.wustl.edu/~schmidt/ICCDS-96.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/patterns-experience.html
Root-URL: 
Email: schmidt@cs.wustl.edu  
Phone: (314) 935-7538  
Title: A Family of Design Patterns For Flexibly Configuring Network Services in Distributed Systems  
Author: Douglas C. Schmidt 
Address: St. Louis, MO 63130, USA  
Affiliation: Department of Computer Science Washington University  
Abstract: This paper has been submitted to the International Conference on Configurable Distributed Systems, Annapolis, Mary-land, May 6-8, 1996. Abstract This paper describes a family of design patterns that enhance the flexibility and extensibility of communication software by permitting network services to evolve independently of the strategies used to passively initialize the services. The paper makes three contributions to the study and development of configurable distributed systems. First, it identifies five orthogonal dimensions of passive service initialization: service advertisement, endpoint listening, service handler creation, passive connection establishment, and service handler activation. Second, the paper illustrates how a family of design patterns have been used to build a communication software framework that supports flexible configuration of different strategies for each of these five dimensions. Third, the paper demonstrates how design patterns and frameworks are being used successfully to develop configurable large-scale production distributed systems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction Despite dramatic increases in network and host performance, designing and implementing extensible communication software for complex distributed systems remains challenging. Design patterns <ref> [1] </ref> are a promising technique for capturing and articulating proven techniques for developing extensible distributed software. Design patterns express the static and dynamic structures and collaborations of components in software architectures. <p> By decoupling service initialization from service processing, the Acceptor pattern enables the creation of extensible and efficient network services. When used in conjunction with a family of other patterns (such as the Reactor [2] and Strategy <ref> [1] </ref> patterns), the Acceptor pattern provides a reusable component in the ACE communication software framework [3]. <p> Peers are located throughout local area networks (LANs) and wide-area networks (WANs) and are used to monitor and control network resources (such as satellites or remote offices). The Gateway is a Mediator <ref> [1] </ref> that coordinates interactions between its connected Peers. From the Gateway's perspective, these Peer services differ solely by their message framing formats and payload types. The Gateway uses a connection-oriented interprocess communication (IPC) mechanism (such as TCP) to transmit data between its connected Peers. <p> ACE is an object-oriented network programming framework that has been used to develop configurable production distributed systems. The ACE implementation of Acceptor leverages other design patterns such as Factory Method, Strategy, Bridge, and Abstract Factory <ref> [1] </ref>. As discussed in Section 4.4, these patterns enable the Acceptor pattern to flexibly configure alternative strategies for service advertisement, endpoint listening, service handler creation, service connection acceptance, and service activation. <p> Acceptor to accept connections from peers. These strategies include the following: * Connection-oriented (CONS) establishment which uses connection-oriented protocols (such as TCP, SPX, gies or TP4). * Connectionless (CLNS) establishment which uses the Adapter pattern <ref> [1] </ref> to utilize a uniform interface for connectionless protocols. * Concurrency Strategies: The Acceptor uses its activation strategy to determine the type of concurrency mechanism a Svc Handler will use to process data exchanged with its peer. Figure 9 illustrates common strategies configured into the Acceptor to activate Svc Handlers. <p> It also ensures that various the strategies can work together correctly. 4.4 Using Patterns to Implement the Acceptor The ACE implementation of the Acceptor pattern applies the Adapter, Factory Method, Strategy, Bridge, and Abstract Factory patterns described in <ref> [1] </ref>. These patterns facilitate the flexible and extensible configuration and use of the initialization strategies discussed above. <p> Each pattern used in the ACE Acceptor is briefly defined below, the design forces it resolves are outlined, and an example of how the pattern is used to implement the Acceptor is presented. * Using the Adapter Pattern in the Acceptor: The Adapter pattern <ref> [1] </ref> converts the interface of a component into another interface expected by users of the component. This pattern allows components to work together that otherwise could not due to incompatibilities between component interfaces. <p> The Adapter pattern ensures that these two classes can be used identically by different instantiations of the Svc Handler class. * Using the Strategy Pattern in the Acceptor: The Strategy pattern <ref> [1] </ref> defines a family of algorithms, encapsulates each one as an object, and makes them interchangeable. The ACE Acceptor uses this pattern to determine the passive initialization strategies used to create, accept, and execute a Svc Handler. <p> Since 8 all concurrency algorithms are encapsulated in a uniform interface, however, it is easy to replace this strategy with an alternative one (such as running the Svc Handler in a separate process). * Using the Bridge Pattern in the Acceptor: The Bridge pattern <ref> [1] </ref> decouples an abstraction from its implementation so that the two can vary independently. <p> In the Template Method version of accept the steps in the Acceptor's passive initialization algorithm are fixed, but these steps can be overridden by a derived class. * Using the Factory Method Pattern in the Acceptor: The Factory Method pattern <ref> [1] </ref> defines a stable interface for initializing a component, but allows subclasses to spec Pattern ify the details of the initialization. <p> the ``demand'' creation // strategy by allocating a new SVC HANDLER. return new SVC_HANDLER; - Note that it is the responsibility of the Acceptor's Strategy Factory to determine the type of subclass associated with the creation strategy . * Using the Abstract Factory in the Acceptor: The Abstract Factory pattern <ref> [1] </ref> provides a single interface that creates families of related objects without requiring the specification of their concrete classes. The ACE Acceptor uses this pattern to simplify the interface to the Acceptor by localizing all five initialization strategies into a single class. <p> In addition, shaded rectangles indicate processes and curly lines within a process indicate separate threads of control. egy designated by their Strategy Factories. Meanwhile, the *Acceptors continue to listen for new connections. 6 Related Work <ref> [1, 11, 12] </ref> identify and catalog many fundamental design patterns. This section examines how the patterns described in this paper relate to other patterns in the literature and to existing systems in the field. The intent of the Acceptor pattern is similar to the Configuration pattern [13]. <p> In addition, the Acceptor pattern also focuses on decoupling service behavior from the service's concurrency strategies. The Acceptor pattern may be viewed as an object creational pattern <ref> [1] </ref>. A creational pattern assembles the resources necessary to create an object and decouples the creation and initialization of the object from subsequent use of the object. The Acceptor pattern is a factory that passively creates and initializes service handlers.
Reference: [2] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: By decoupling service initialization from service processing, the Acceptor pattern enables the creation of extensible and efficient network services. When used in conjunction with a family of other patterns (such as the Reactor <ref> [2] </ref> and Strategy [1] patterns), the Acceptor pattern provides a reusable component in the ACE communication software framework [3]. <p> Figure 6 illustrates common strategies configured into the Acceptor to wait for connections. These strategies include the following * Reactive listeners which use an event-demultiplexor like the Reactor <ref> [2] </ref> to listen passively on a set of endpoints in a single thread of control. * Threaded listeners which use a separate thread of control for each listener. * Svc Handler Creation Strategies: The Acceptor uses its creation strategy to initialize a Svc Handler that will communicate with the new peer. <p> Figure 9 illustrates common strategies configured into the Acceptor to activate Svc Handlers. These strategies include the following: * Reactive activation which executes all Svc Handlers within a single thread of control by using the Reactor pattern <ref> [2] </ref>. * Thread activation which executes each Svc Handler within its own separate thread). * Thread pool activation which executes each Svc Handler within a pool of threads to increase perfor mance on multi-processors. * Process activation which executes each Svc Handler within a separate process.
Reference: [3] <author> D. C. Schmidt and T. Suda, </author> <title> An Object-Oriented Framework for Dynamically Configuring Extensible Distributed Communication Systems, </title> <journal> IEE/BCS Distributed Systems Engineering Journal (Special Issue on Configurable Distributed Systems), </journal> <volume> vol. 2, </volume> <pages> pp. 280-293, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: When used in conjunction with a family of other patterns (such as the Reactor [2] and Strategy [1] patterns), the Acceptor pattern provides a reusable component in the ACE communication software framework <ref> [3] </ref>. <p> This pattern was discovered by generalizing from extensive experience building reusable communication frameworks for a range of distributed systems <ref> [4, 3] </ref>. In all these systems, the tasks performed by a service are independent of the following: * Which endpoint initiated the connection: connection establishment is inherently asymmetrical since the passive endpoint waits whereas the active endpoint initiates the connection. <p> initialized, this phase performs application-specific tasks that process the data exchanged between the Svc Handler and its connected peer (s). 4 A Family of Patterns for Configuring Extensible Acceptors This section describes how the Acceptor pattern has been implemented in a highly configurable manner in the ADAPTIVE Communication Environment (ACE) <ref> [3] </ref>. ACE is an object-oriented network programming framework that has been used to develop configurable production distributed systems. The ACE implementation of Acceptor leverages other design patterns such as Factory Method, Strategy, Bridge, and Abstract Factory [1]. <p> Implementations of the Acceptor and Reactor patterns described in this paper are freely available via the World Wide Web at URL http://www.cs.wustl.edu/schmidt/. This distribution contains complete source code, documentation, and example test drivers for the C++ components developed as part of the ACE object-oriented network programming toolkit <ref> [3] </ref> developed at the University of California, Irvine and Washington University. The ACE toolkit is currently being used on communication software for production communication systems, as well as academic research projects. Thanks to Tim Harrison for comments on this paper.
Reference: [4] <author> D. C. Schmidt and T. Suda, </author> <title> The Service Configurator Framework: An Extensible Architecture for Dynamically Configuring Concurrent, Multi-Service Network Daemons, </title> <booktitle> in Proceedings of the Second International Workshop on Configurable Distributed Systems, </booktitle> <address> (Pittsburgh, PA), </address> <pages> pp. 190-201, </pages> <publisher> IEEE, </publisher> <month> Mar. </month> <year> 1994. </year>
Reference-contexts: This pattern was discovered by generalizing from extensive experience building reusable communication frameworks for a range of distributed systems <ref> [4, 3] </ref>. In all these systems, the tasks performed by a service are independent of the following: * Which endpoint initiated the connection: connection establishment is inherently asymmetrical since the passive endpoint waits whereas the active endpoint initiates the connection. <p> The handler performs a service using data exchanged on the connection. Thus, the subsequent 12 behavior of the service is decoupled from its initialization strategies. UNIX network superservers (such as inetd [5], listen [6], and the Service Configurator daemon <ref> [4] </ref>) are widely used applications of the Acceptor pattern. These su-perservers utilize a master Acceptor process that listens for connections on a set of communication ports. Each port is associated with a communication-related service (such as the standard Internet services ftp, telnet, daytime, and echo).
Reference: [5] <author> W. R. Stevens, </author> <title> UNIX Network Programming. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: Once the connection is established, however, data may be transferred between services at the endpoints in any manner that obeys an application's communication protocol (e.g., peer-to-peer, request-response, oneway streaming, etc.). * The network programming interfaces and underlying protocols used to establish the connection: different network programming interfaces (such as sockets <ref> [5] </ref> or TLI [6]) provide different routines to establish connections using various underlying transport protocols (such as TCP, SPX, or TP4). <p> Figure 5 illustrates common strategies configured into the Acceptor to advertise services. These strategies include the following: * Well-known addresses such as Internet port numbers and host names <ref> [5] </ref>. * Endpoint portmappers such as those used by Sun RPC [9] and DCE [10]. * X.500 directory service which is a ISO OSI standard for mapping names to values in a distributed system. indicates template instantiation; and a solid circle illustrates a composition relationship between two classes. * Endpoint Listener <p> This pattern allows components to work together that otherwise could not due to incompatibilities between component interfaces. The ACE Acceptor uses the Adapter pattern to provide a uniform interface that encapsulates differences between non-uniform network programming mechanisms such as sockets, TLI, named pipes, and STREAM pipes <ref> [5] </ref>. Adapter pattern to enhance its portability across platforms that contain different network programming interfaces (such as sockets but not TLI, or vice versa). <p> The handler performs a service using data exchanged on the connection. Thus, the subsequent 12 behavior of the service is decoupled from its initialization strategies. UNIX network superservers (such as inetd <ref> [5] </ref>, listen [6], and the Service Configurator daemon [4]) are widely used applications of the Acceptor pattern. These su-perservers utilize a master Acceptor process that listens for connections on a set of communication ports.
Reference: [6] <author> S. Rago, </author> <title> UNIX System V Network Programming. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: is established, however, data may be transferred between services at the endpoints in any manner that obeys an application's communication protocol (e.g., peer-to-peer, request-response, oneway streaming, etc.). * The network programming interfaces and underlying protocols used to establish the connection: different network programming interfaces (such as sockets [5] or TLI <ref> [6] </ref>) provide different routines to establish connections using various underlying transport protocols (such as TCP, SPX, or TP4). <p> The handler performs a service using data exchanged on the connection. Thus, the subsequent 12 behavior of the service is decoupled from its initialization strategies. UNIX network superservers (such as inetd [5], listen <ref> [6] </ref>, and the Service Configurator daemon [4]) are widely used applications of the Acceptor pattern. These su-perservers utilize a master Acceptor process that listens for connections on a set of communication ports.
Reference: [7] <author> D. C. Schmidt, T. H. Harrison, and E. Al-Shaer, </author> <title> Object-Oriented Components for High-speed Network Programming, </title> <booktitle> in Proceedings of the Conference on Object-Oriented Technologies, </booktitle> <address> (Monterey, CA), </address> <publisher> USENIX, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: Another drawback is that using low-level network programming (such as sockets or TLI) is non-portable and error-prone. These low-level interfaces do not provide adequate type-checking since they utilize low-level I/O handles. As shown in <ref> [7] </ref>, it is surprisingly easy to accidentally misuse these interfaces in ways that cannot be detected until run-time. Therefore, a more flexible and efficient way to design the Peers and Gateway is to use the Acceptor pattern. <p> This eliminates a class of subtle errors that can arise when programming with weakly typed network programming interfaces such as sockets or TLI <ref> [7] </ref>. However, the Acceptor pattern also exhibits the following drawbacks when used in practice: * Additional instructions: compared with overhead of programming to the underlying network programming interfaces directly.
Reference: [8] <author> G. Booch, </author> <title> Object Oriented Analysis and Design with Applications (2 nd Edition). </title> <address> Redwood City, California: Ben-jamin/Cummings, </address> <year> 1993. </year>
Reference-contexts: The structure of the key participants in the Acceptor pattern is illustrated by the Booch class diagram <ref> [8] </ref> in Figure 2 and described below: 1 * Svc Handler: This class defines a generic interface for a service. Each Svc Handler contains a communication endpoint (peer stream ). This endpoint is used to exchange data between the Svc Handler and its connected peer. <p> The concurrency strategy configured into each Acceptor dictates how each Svc Handler processes events. established. 5 The various *Routers exchange data with their connected Peers using the type of concurrency strat 5 This diagram uses additional Booch notation <ref> [8] </ref>, where solid clouds indicate objects and undirected edges indicate some type of link (such as a pointer or reference) exists between two objects. In addition, shaded rectangles indicate processes and curly lines within a process indicate separate threads of control. egy designated by their Strategy Factories.
Reference: [9] <author> Sun Microsystems, </author> <title> Open Network Computing: RPC Programming, </title> <month> June </month> <year> 1991. </year>
Reference-contexts: Figure 5 illustrates common strategies configured into the Acceptor to advertise services. These strategies include the following: * Well-known addresses such as Internet port numbers and host names [5]. * Endpoint portmappers such as those used by Sun RPC <ref> [9] </ref> and DCE [10]. * X.500 directory service which is a ISO OSI standard for mapping names to values in a distributed system. indicates template instantiation; and a solid circle illustrates a composition relationship between two classes. * Endpoint Listener Strategies: The Acceptor uses its endpoint listening strategy to wait passively
Reference: [10] <author> J. Dilley, OODCE: </author> <title> A C++ Framework for the OSF Distributed Computing Environment, </title> <booktitle> in Proceedings of the Winter Usenix Conference, USENIX Association, </booktitle> <month> January </month> <year> 1995. </year> <month> 13 </month>
Reference-contexts: Figure 5 illustrates common strategies configured into the Acceptor to advertise services. These strategies include the following: * Well-known addresses such as Internet port numbers and host names [5]. * Endpoint portmappers such as those used by Sun RPC [9] and DCE <ref> [10] </ref>. * X.500 directory service which is a ISO OSI standard for mapping names to values in a distributed system. indicates template instantiation; and a solid circle illustrates a composition relationship between two classes. * Endpoint Listener Strategies: The Acceptor uses its endpoint listening strategy to wait passively for peers to
Reference: [11] <author> F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal, </author> <title> Pattern-Oriented Software Architecture A System of Patterns. </title> <journal> Wileys and Sons, </journal> <note> to appear 1996. </note>
Reference-contexts: In addition, shaded rectangles indicate processes and curly lines within a process indicate separate threads of control. egy designated by their Strategy Factories. Meanwhile, the *Acceptors continue to listen for new connections. 6 Related Work <ref> [1, 11, 12] </ref> identify and catalog many fundamental design patterns. This section examines how the patterns described in this paper relate to other patterns in the literature and to existing systems in the field. The intent of the Acceptor pattern is similar to the Configuration pattern [13].
Reference: [12] <editor> J. O. Coplien and D. C. Schmidt, eds., </editor> <booktitle> Pattern Languages of Program Design. </booktitle> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: In addition, shaded rectangles indicate processes and curly lines within a process indicate separate threads of control. egy designated by their Strategy Factories. Meanwhile, the *Acceptors continue to listen for new connections. 6 Related Work <ref> [1, 11, 12] </ref> identify and catalog many fundamental design patterns. This section examines how the patterns described in this paper relate to other patterns in the literature and to existing systems in the field. The intent of the Acceptor pattern is similar to the Configuration pattern [13].
Reference: [13] <author> S. Crane, J. Magee, and N. Pryce, </author> <title> Design Patterns for Binding in Distributed Systems, </title> <booktitle> in The OOPSLA '95 Workshop on Design Patterns for Concurrent, Parallel, and Distributed Object-Oriented Systems, </booktitle> <address> (Austin, TX), </address> <publisher> ACM, </publisher> <month> Oct. </month> <year> 1995. </year>
Reference-contexts: This section examines how the patterns described in this paper relate to other patterns in the literature and to existing systems in the field. The intent of the Acceptor pattern is similar to the Configuration pattern <ref> [13] </ref>. The Configuration pattern decouples structural issues related to configuring services in distributed applications from the execution of the services themselves.
Reference: [14] <author> J. Magee, N. Dulay, and J. Kramer, </author> <title> A Constructive Development Environment for Parallel and Distributed Programs, </title> <booktitle> in Proceedings of the 2 nd International Workshop on Configurable Distributed Systems, </booktitle> <address> (Pittsburgh, PA), </address> <pages> pp. 1-14, </pages> <publisher> IEEE, </publisher> <month> Mar. </month> <year> 1994. </year>
Reference-contexts: The intent of the Acceptor pattern is similar to the Configuration pattern [13]. The Configuration pattern decouples structural issues related to configuring services in distributed applications from the execution of the services themselves. This pattern has been used in frameworks for configuring distributed systems (such as Regis <ref> [14] </ref> and Polylith [15]) to support the construction of a distributed system from a set of components. In a similar way, the Acceptor pattern de-couples service initialization from service processing.
Reference: [15] <author> J. M. Purtilo, </author> <title> The Polylith Software Toolbus, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <note> To appear 1994. </note>
Reference-contexts: The Configuration pattern decouples structural issues related to configuring services in distributed applications from the execution of the services themselves. This pattern has been used in frameworks for configuring distributed systems (such as Regis [14] and Polylith <ref> [15] </ref>) to support the construction of a distributed system from a set of components. In a similar way, the Acceptor pattern de-couples service initialization from service processing.
References-found: 15

