URL: ftp://ftp.win.tue.nl/pub/techreports/michelr/ComputingScienceReports96-19.ps.Z
Refering-URL: http://www.win.tue.nl/cs/fm/michelr/msc.html
Root-URL: http://www.win.tue.nl
Title: Static Semantics of Message Sequence Charts  
Author: M.A. Reniers 
Address: P.O. Box 513, NL-5600 MB Eindhoven, The Netherlands.  
Affiliation: Department of Mathematics and Computing Science, Eindhoven University of Technology,  
Abstract-found: 0
Intro-found: 1
Reference: [CCHvK90] <author> A. A. R. Cockburn, W. Citrin, R. F. Hauser, and J. von Kanel. </author> <title> An environment for interactive design of communication architectures. </title> <editor> In L. Logrippo, R. L. Probert, and H. Ural, editors, </editor> <title> Protocol Specification, Testing and Verification, </title> <booktitle> volume 10 of Proc. IFIP WG 6.1 Tenth International Symposium, </booktitle> <pages> pages 115-127, </pages> <address> Ottawa, 1990. </address> <publisher> North-Holland. </publisher>
Reference-contexts: Within industry Sequence Charts are used mainly as a test case description language. Various kinds of Sequence Charts are used although they differ on minor points only. One can think of the following: Extended Sequence Charts [GR89], Time Sequence Diagrams [ISO91], Arrow Diagrams [CCI88], Information Flow Diagrams <ref> [CCHvK90] </ref>, Synchronous Interworkings [MvWW93, MW93] and Siemens-SCs [Sie92]. A comparison of these languages can be found in [GGR93a].
Reference: [CCI88] <author> CCITT. </author> <title> CCITT Recommendation Q.699: Interworking between the Digital Subscriber Layer 3 Protocol and the Signalling System No. 7 ISDN User Part CCITT. </title> <address> Geneva, </address> <year> 1988. </year>
Reference-contexts: Within industry Sequence Charts are used mainly as a test case description language. Various kinds of Sequence Charts are used although they differ on minor points only. One can think of the following: Extended Sequence Charts [GR89], Time Sequence Diagrams [ISO91], Arrow Diagrams <ref> [CCI88] </ref>, Information Flow Diagrams [CCHvK90], Synchronous Interworkings [MvWW93, MW93] and Siemens-SCs [Sie92]. A comparison of these languages can be found in [GGR93a].
Reference: [dM93] <author> J. de Man. </author> <title> Towards a formal semantics of Message Sequence Charts. </title> <editor> In O. Frge-mand and A. Sarma, editors, </editor> <title> SDL'93 Using Objects, </title> <booktitle> Proceedings Sixth SDL Forum, </booktitle> <pages> pages 157-165, </pages> <address> Darmstadt, 1993. </address> <publisher> Elsevier Science Publishers. </publisher>
Reference-contexts: A formal semantics based on process algebra is proposed for standardization in [MR94b, IT95a]. Other approaches towards the definition of a formal semantics are based on automaton theory [LL92b, LL92a, LL94], Petri net theory [GGR93b], and process algebra <ref> [dM93, MvWW93, MW93, MR94a] </ref>. Besides the formalization of the dynamic semantics of Message Sequence Charts, also the syntax requirements (static semantics) of Message Sequence Charts need to be formalized. The reasons for doing so are the same as for formalizing the dynamic semantics. The document is structured as follows.
Reference: [GGR93a] <author> J. Grabowski, P. Graubmann, and E. Rudolph. </author> <title> The standardization of Message Sequence Charts. </title> <booktitle> In Software Engineering Standards Symposium, </booktitle> <volume> '93, </volume> <pages> pages 48-63, </pages> <address> Brighton, 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: One can think of the following: Extended Sequence Charts [GR89], Time Sequence Diagrams [ISO91], Arrow Diagrams [CCI88], Information Flow Diagrams [CCHvK90], Synchronous Interworkings [MvWW93, MW93] and Siemens-SCs [Sie92]. A comparison of these languages can be found in <ref> [GGR93a] </ref>. To enhance tool support, feasibility of Sequence Chart exchange between tools, and harmonization of the use of Sequence Charts within CCITT Study Groups, a standardization of such Sequence Charts was proposed by the CCITT (nowadays called the ITU (International Telecommunication Union)).
Reference: [GGR93b] <author> J. Grabowski, P. Graubmann, and E. Rudolph. </author> <title> Towards a petri net based semantics definition for Message Sequence Charts. </title> <editor> In O. Frgemand and A. Sarma, editors, </editor> <title> SDL'93 Using Objects, </title> <booktitle> Proceedings Sixth SDL Forum, </booktitle> <pages> pages 179-190, </pages> <address> Darmstadt, 1993. </address> <publisher> Elsevier Science Publishers. </publisher>
Reference-contexts: Finally a formal semantics will help to harmonize the use of Message Se--quence Charts. A formal semantics based on process algebra is proposed for standardization in [MR94b, IT95a]. Other approaches towards the definition of a formal semantics are based on automaton theory [LL92b, LL92a, LL94], Petri net theory <ref> [GGR93b] </ref>, and process algebra [dM93, MvWW93, MW93, MR94a]. Besides the formalization of the dynamic semantics of Message Sequence Charts, also the syntax requirements (static semantics) of Message Sequence Charts need to be formalized. The reasons for doing so are the same as for formalizing the dynamic semantics.
Reference: [GR89] <author> J. Grabowski and E. Rudolph. </author> <title> Putting extended sequence charts to practice. </title> <editor> In O. Frgemand and M.M. Marques, editors, </editor> <booktitle> SDL'89 The Language at Work, </booktitle> <pages> pages 3-10, </pages> <address> Lisbon, 1989. </address> <publisher> North-Holland. </publisher>
Reference-contexts: Within industry Sequence Charts are used mainly as a test case description language. Various kinds of Sequence Charts are used although they differ on minor points only. One can think of the following: Extended Sequence Charts <ref> [GR89] </ref>, Time Sequence Diagrams [ISO91], Arrow Diagrams [CCI88], Information Flow Diagrams [CCHvK90], Synchronous Interworkings [MvWW93, MW93] and Siemens-SCs [Sie92]. A comparison of these languages can be found in [GGR93a].
Reference: [ISO91] <author> ISO/IEC. </author> <title> Revised Text of CD 10731, Information Technology Open Systems Interconnection Conventions for the Definition of OSI Service Conventions, </title> <address> ISO/IEC JTC 1/SC 21 N 6341, </address> <year> 1991. </year>
Reference-contexts: Within industry Sequence Charts are used mainly as a test case description language. Various kinds of Sequence Charts are used although they differ on minor points only. One can think of the following: Extended Sequence Charts [GR89], Time Sequence Diagrams <ref> [ISO91] </ref>, Arrow Diagrams [CCI88], Information Flow Diagrams [CCHvK90], Synchronous Interworkings [MvWW93, MW93] and Siemens-SCs [Sie92]. A comparison of these languages can be found in [GGR93a].
Reference: [IT93] <author> ITU-TS. </author> <title> ITU-TS Recommendation Z.120: Message Sequence Chart (MSC). </title> <address> ITU-TS, Geneva, </address> <month> September </month> <year> 1993. </year>
Reference-contexts: Introduction The purpose of this document is to formally define the syntax requirements of Message Sequence Charts. The description of the syntax requirements as presented in Recommendation Z.120 <ref> [IT93] </ref> is open to ambiguous interpretation and should therefore be reconsidered. A new set of syntax requirements is formulated and their formalization is presented. This formalization is based on predicates and functions. The approach taken towards the formalization of the static semantics has been illustrated in [Ren95]. <p> The recommended version of Sequence Charts is called Message Sequence Charts. Recommendation Z.120 Message Sequence Chart (MSC) <ref> [IT93] </ref> contains a description of an abstract syntax, a graphical syntax, and a textual syntax of the language Message Sequence Chart. Besides these syntax descriptions also an informal semantics and an informal description of the syntax requirements are given. <p> These primitives are conditions, timer handling, process creation and process termination, coregions, and instance decomposition. With respect to instance decomposition, the syntax used in this document deviates slightly from the syntax presented in Recommendation Z.120 <ref> [IT93] </ref>. 2.2 Basic Message Sequence Charts A Basic Message Sequence Chart is a finite collection of instances. An instance is an abstract entity on which message outputs, message inputs and local actions may be specified. An instance is denoted by a vertical axis. <p> Table 2.6: Extension with decomposition of instances &lt;msc doc&gt; ::= mscdocument &lt;doc head&gt; &lt;doc body&gt; endmscdocument; &lt;doc head&gt; ::= &lt;doc name&gt; [ related to &lt;sdl ref&gt; ]; &lt;doc body&gt; ::= &lt;&gt; | &lt;msc&gt; &lt;doc body&gt; &lt;inst head&gt; ::= &lt;inst name&gt; [[:]&lt;inst kind&gt;] decomposed; Within the standard of Message Sequence Charts <ref> [IT93] </ref> there are two types of charts: Message Sequence Charts and Sub Message Sequence Charts. A Sub Message Sequence Chart is distinguished from an ordinary Message Sequence Charts by its use of the reserved keywords submsc and endsubmsc in stead of msc and endmsc. <p> This type of chart is allowed to represent a decomposition of an instance. In no way, this restriction implies that the treatment of the syntax requirements does not cover the essentials of the complete standardized language. The only requirement from Recommendation Z.120 <ref> [IT93] </ref> which no longer applies is that every Sub Message Sequence Chart must be referenced by some decomposed instance in some chart in the Message Sequence Chart document. 14 Chapter 3 Preliminaries In this chapter some basic notions on sets, relations and multisets are introduced. <p> Therefore, it is not clear (in the textual representation) which of the two is created by instance j. Therefore, the following syntax requirement is formulated. Within a chart there must not be two or more instances with the same name <ref> [IT93, section 2.2, page 3] </ref>. In the remainder of this section this requirement will be formalized. First, an equivalence on instance definitions is defined which identifies instances with the same name without considering the kind names in the instance heads. <p> Therefore, only the internal messages need to be considered. The instance head of an instance definition contains the definition of an instance name. The declared instances within a chart are the instances specified within that chart. The following syntax requirement is formulated. Only declared instances may be referenced <ref> [IT93, section 2.2, page 3] </ref>. First, a function DeclInstNames is defined which determines the names of all instances specified within a chart. These are exactly the names of the declared instances. This follows from the uniqueness rule for instances (see Section 4.2). <p> To avoid this situation a syntax requirement is formulated which guarantees that there are no two message outputs which refer to the same abstract message and also that there are no two message inputs which refer to the same abstract message. Recommendation Z.120 <ref> [IT93] </ref> states the following syntax requirement. For messages exchanged between instances the following must hold: to each message output at most one corresponding message input has to be specified and vice versa [IT93, section 4.3, page 12]. <p> Recommendation Z.120 [IT93] states the following syntax requirement. For messages exchanged between instances the following must hold: to each message output at most one corresponding message input has to be specified and vice versa <ref> [IT93, section 4.3, page 12] </ref>. Two message output events which are defined on different instances cannot concern the same message since they have different sender instances. Also, two message input events which are defined on different instances cannot concern the same message since they have different receiver instances. <p> For this message only the message output is specified. There is no corresponding message input. The following syntax requirement is formulated. For messages exchanged between instances the following must hold: to each message output a corresponding message input has to be specified and vice versa <ref> [IT93, section 4.3, page 12] </ref>. This requirement can be combined easily with the requirement from the previous section. Together they express that there is a 1-1-correspondence between message outputs and message inputs. Note that this requirement only applies to messages which are exchanged between instances. <p> The syntax requirement from Section 4.4.2 is repeated for conditions. Only declared instances may be referenced <ref> [IT93, section 2.2, page 3] </ref>. 33 A function SpecifiedInsts is defined which associates to a condition event the names of all in-stances listed in its shared instance list. If the condition event does not have a shared instance list, the empty set is taken as a value. <p> If instance b is contained in the shared instance list of a shared condition attached to instance a then instance a must be contained in the shared instance list of the corresponding shared condition attached to instance b <ref> [IT93, section 4.4, page 13] </ref>. Unfortunately, this formulation does not cover the complete set of problem cases. <p> As was the case for messages and conditions, the create events may only reference instances which are declared. To each create there must be a corresponding instance with the same name <ref> [IT93, section 4.7, page 18] </ref>. Using the functions CreateName and CreateEvents from Appendix B the instances referenced by the create events of a chart ch are given by fCreateName (cr) j cr @CreateEvents (ch)g. <p> Recommendation Z.120 states the uniqueness rule for process creation as follows. An instance can be created only once, i.e. within one chart two or more creates with the same name must not appear <ref> [IT93, section 4.7, page 18] </ref>. First, an equivalence &lt;create&gt; = is defined which identifies two create events if and only if they refer to the same instance. <p> Instances with type process may create another instance and may be created. An instance on which a create event is specified must be of type process, if its type is specified. The instance name has to refer to an instance with type process, if its type is specified <ref> [IT93, section 4.7, pages 17-18] </ref>. This requirement expresses that both the creating instance, i.e. the instance on which the create event is specified, and the created instance, i.e. the instance the create event refers to, must be if a type is present of type process. <p> Only instances of type process may be terminated. Recommendation Z.120 states for the typing of terminating instances the following requirement. The stop at the end of an instance definition is allowed only for instances of type process <ref> [IT93, section 4.8, page 18] </ref>. <p> This partial ordering restricted to communication events and process creation events is described in a minimal form by the causal dependency graph. The causal dependency graph is an extension of the connectivity graph <ref> [IT93] </ref>. It is extended with nodes representing process creation events and with arrows from 40 a create node to the first node stemming from the created instance. The nodes of the causal depen-dency graph represent the message output, message input and process creation events. <p> The syntax requirement is formulated as follows. It is not allowed that a message output is causally depending on its corresponding message input, directly or via other messages <ref> [IT93, section 4.3, page 12] </ref>. In Figure 4.5 the causal dependency graphs of the example charts are given. In both cases it is clear that it contains a loop. 41 The requirement as stated in [IT93] is not completely satisfactory. <p> In Figure 4.5 the causal dependency graphs of the example charts are given. In both cases it is clear that it contains a loop. 41 The requirement as stated in <ref> [IT93] </ref> is not completely satisfactory. It states the dependency of message inputs on message outputs only in terms of messages. But it can also be the case that a message output is causally depending on its corresponding message input via the creation of an instance. <p> Therefore, the following requirement is stated in Recommendation Z.120. If instance a and instance b share the same condition then for each message exchanged between these instances, the message output and message input must be placed both before or both after the condition <ref> [IT93, section 4.4, page 13] </ref>. Since create events are considered special communication events this can be repeated for the crossing of a condition by a create arrow. This results in the following additional requirement. <p> A chart is referenced through a chart name. Therefore, it is required that there are no two charts within a document with the same chart name. Within a document there must not be two or more charts with the same name <ref> [IT93, section 2.2, page 3] </ref>. The formalization of this requirement follows the lines of the formalization of the previously dis cussed uniqueness rules. First an equivalence &lt;chart&gt; = on charts is defined which identifies charts with the same name. <p> The formulation of the syntax requirement for references to declared charts is formulated as follows. Within the charts of a document only references to charts specified within that document may be specified <ref> [IT93, section 2.2, page 3] </ref>. As a first step towards the formalization of this requirement a function DeclaredChartNames is defined which associates to a document the names of the charts defined therein. <p> This yields the following syntax requirement. There must be a unique correspondence between the external message outputs of a decomposed instance and the message outputs of the corresponding chart which are sent to the exterior. An analogous correspondence must hold for incoming messages <ref> [IT93, section 4.2, page 9, section 5.2, pages 20-21] </ref>. With respect to a given instance, an external message output of that instance is a message output which is sent by the given instance but not also received by that instance. <p> Next, the rule for decomposition is considered. The ordering of the external communication events of the decomposed instance must be preserved in the corresponding chart <ref> [IT93, section 5.2, page 21] </ref>.
Reference: [IT94] <author> ITU-TS. </author> <title> Correction List for Z.120. </title> <address> Geneva, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: This requirement is formulated for the textual representation of charts as follows. If two conditions are ordered directly (because they have an instance in common) or ordered indirectly via conditions on other instances, this order must be respected on all instances that share these two conditions <ref> [IT94, Extensions: section 5, page 8] </ref>. From the textual representation of a chart, a condition graph will be constructed. The nodes of the condition graph are the abstract conditions from Section 4.5 extended with the occurrence number. <p> Chart example specifies a non-decomposed instance i and a decomposed instance d. This decomposed instance d refers to chart d. As a result chart example depends on chart d. A chart may not be depending on itself, directly or through a number of decompositions <ref> [IT94, Extensions: section 6, page 8] </ref>. A chart dependency graph is constructed from the textual representation of a document. The nodes of the chart dependency graph are labelled by the charts from the document and the arrows between the nodes of the graph represent the dependency relation induced by decomposition.
Reference: [IT95a] <author> ITU-TS. </author> <title> ITU-TS Recommendation Z.120 Annex B: Algebraic semantics of Message Sequence Charts. </title> <address> ITU-TS, Geneva, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: Furthermore validation of computer tools for Message Sequence Charts only makes sense if an exact mean 1 ing is available. Finally a formal semantics will help to harmonize the use of Message Se--quence Charts. A formal semantics based on process algebra is proposed for standardization in <ref> [MR94b, IT95a] </ref>. Other approaches towards the definition of a formal semantics are based on automaton theory [LL92b, LL92a, LL94], Petri net theory [GGR93b], and process algebra [dM93, MvWW93, MW93, MR94a].
Reference: [IT95b] <author> ITU-TS. </author> <title> Minutes of Question 9/10 Study Group. </title> <address> St. Petersburg, </address> <month> March </month> <year> 1995. </year>
Reference-contexts: In turn, the chart head consists of a chart name and optionally a chart interface. The chart interface is considered an overview of the instances which are specified within the chart body. The following requirement for chart interfaces is stated in <ref> [IT95b] </ref>: The information given in the instance list in the chart interface, if present, must be consistent with the information specified in the instance heads [IT95b]. <p> The following requirement for chart interfaces is stated in <ref> [IT95b] </ref>: The information given in the instance list in the chart interface, if present, must be consistent with the information specified in the instance heads [IT95b]. Consider the following chart. msc example; inst i: process kn, j: process x; instance i: block kn; ... endinstance; instance j; ... endinstance; endmsc; The head of instance i states that it is of type block whereas the chart interface states that instance i is of type process.
Reference: [LL92a] <author> P. Ladkin and S. Leue. </author> <title> An analysis of Message Sequence Charts. </title> <type> Technical Report IAM-92-013, </type> <institution> University of Berne, </institution> <year> 1992. </year> <month> 63 </month>
Reference-contexts: Finally a formal semantics will help to harmonize the use of Message Se--quence Charts. A formal semantics based on process algebra is proposed for standardization in [MR94b, IT95a]. Other approaches towards the definition of a formal semantics are based on automaton theory <ref> [LL92b, LL92a, LL94] </ref>, Petri net theory [GGR93b], and process algebra [dM93, MvWW93, MW93, MR94a]. Besides the formalization of the dynamic semantics of Message Sequence Charts, also the syntax requirements (static semantics) of Message Sequence Charts need to be formalized.
Reference: [LL92b] <author> P. Ladkin and S. Leue. </author> <title> An automaton interpretation of Message Sequence Charts. </title> <type> Technical Report IAM-92-012, </type> <institution> University of Berne, </institution> <year> 1992. </year>
Reference-contexts: Finally a formal semantics will help to harmonize the use of Message Se--quence Charts. A formal semantics based on process algebra is proposed for standardization in [MR94b, IT95a]. Other approaches towards the definition of a formal semantics are based on automaton theory <ref> [LL92b, LL92a, LL94] </ref>, Petri net theory [GGR93b], and process algebra [dM93, MvWW93, MW93, MR94a]. Besides the formalization of the dynamic semantics of Message Sequence Charts, also the syntax requirements (static semantics) of Message Sequence Charts need to be formalized.
Reference: [LL94] <author> P. B. Ladkin and S. Leue. </author> <title> What do Message Sequence Charts mean? In R. </title> <editor> L. Ten-ney, P. D. Amer, and M. U. Uyar, editors, </editor> <booktitle> Formal Description Techniques VI, IFIP Transactions C, Proceedings Sixth International Conference on Formal Description Techniques, </booktitle> <pages> pages 301-316, </pages> <address> Boston, 1994. </address> <publisher> North-Holland. </publisher>
Reference-contexts: Finally a formal semantics will help to harmonize the use of Message Se--quence Charts. A formal semantics based on process algebra is proposed for standardization in [MR94b, IT95a]. Other approaches towards the definition of a formal semantics are based on automaton theory <ref> [LL92b, LL92a, LL94] </ref>, Petri net theory [GGR93b], and process algebra [dM93, MvWW93, MW93, MR94a]. Besides the formalization of the dynamic semantics of Message Sequence Charts, also the syntax requirements (static semantics) of Message Sequence Charts need to be formalized.
Reference: [MR94a] <author> S. Mauw and M. A. Reniers. </author> <title> An algebraic semantics of Basic Message Sequence Charts. </title> <journal> The Computer Journal, </journal> <volume> 37(4) </volume> <pages> 269-277, </pages> <year> 1994. </year>
Reference-contexts: A formal semantics based on process algebra is proposed for standardization in [MR94b, IT95a]. Other approaches towards the definition of a formal semantics are based on automaton theory [LL92b, LL92a, LL94], Petri net theory [GGR93b], and process algebra <ref> [dM93, MvWW93, MW93, MR94a] </ref>. Besides the formalization of the dynamic semantics of Message Sequence Charts, also the syntax requirements (static semantics) of Message Sequence Charts need to be formalized. The reasons for doing so are the same as for formalizing the dynamic semantics. The document is structured as follows.
Reference: [MR94b] <author> S. Mauw and M.A. Reniers. </author> <title> An algebraic semantics of Message Sequence Charts. </title> <type> Technical Report CSN 94/23, </type> <institution> Eindhoven University of Technology, Department of Computing Science, </institution> <year> 1994. </year>
Reference-contexts: Furthermore validation of computer tools for Message Sequence Charts only makes sense if an exact mean 1 ing is available. Finally a formal semantics will help to harmonize the use of Message Se--quence Charts. A formal semantics based on process algebra is proposed for standardization in <ref> [MR94b, IT95a] </ref>. Other approaches towards the definition of a formal semantics are based on automaton theory [LL92b, LL92a, LL94], Petri net theory [GGR93b], and process algebra [dM93, MvWW93, MW93, MR94a].
Reference: [MvWW93] <author> S. Mauw, M. van Wijk, and T. Winter. </author> <title> A formal semantics of synchronous Inter-workings. </title> <editor> In O. Frgemand and A. Sarma, editors, </editor> <title> SDL'93 Using Objects, </title> <booktitle> Proceedings Sixth SDL Forum, </booktitle> <pages> pages 167-178, </pages> <address> Darmstadt, 1993. </address> <publisher> Elsevier Science Publishers. </publisher>
Reference-contexts: Various kinds of Sequence Charts are used although they differ on minor points only. One can think of the following: Extended Sequence Charts [GR89], Time Sequence Diagrams [ISO91], Arrow Diagrams [CCI88], Information Flow Diagrams [CCHvK90], Synchronous Interworkings <ref> [MvWW93, MW93] </ref> and Siemens-SCs [Sie92]. A comparison of these languages can be found in [GGR93a]. <p> A formal semantics based on process algebra is proposed for standardization in [MR94b, IT95a]. Other approaches towards the definition of a formal semantics are based on automaton theory [LL92b, LL92a, LL94], Petri net theory [GGR93b], and process algebra <ref> [dM93, MvWW93, MW93, MR94a] </ref>. Besides the formalization of the dynamic semantics of Message Sequence Charts, also the syntax requirements (static semantics) of Message Sequence Charts need to be formalized. The reasons for doing so are the same as for formalizing the dynamic semantics. The document is structured as follows.
Reference: [MW93] <author> S. Mauw and T. Winter. </author> <title> A prototype toolset for Interworkings. </title> <journal> Philips Telecommunication Review, </journal> <volume> 51(3) </volume> <pages> 41-45, </pages> <year> 1993. </year>
Reference-contexts: Various kinds of Sequence Charts are used although they differ on minor points only. One can think of the following: Extended Sequence Charts [GR89], Time Sequence Diagrams [ISO91], Arrow Diagrams [CCI88], Information Flow Diagrams [CCHvK90], Synchronous Interworkings <ref> [MvWW93, MW93] </ref> and Siemens-SCs [Sie92]. A comparison of these languages can be found in [GGR93a]. <p> A formal semantics based on process algebra is proposed for standardization in [MR94b, IT95a]. Other approaches towards the definition of a formal semantics are based on automaton theory [LL92b, LL92a, LL94], Petri net theory [GGR93b], and process algebra <ref> [dM93, MvWW93, MW93, MR94a] </ref>. Besides the formalization of the dynamic semantics of Message Sequence Charts, also the syntax requirements (static semantics) of Message Sequence Charts need to be formalized. The reasons for doing so are the same as for formalizing the dynamic semantics. The document is structured as follows.
Reference: [Ren94] <author> M.A. Reniers. </author> <title> Syntax requirements of Message Sequence Charts. </title> <type> Technical Report TD PL/10-59, </type> <institution> ITU-TS Study Group 10, Geneva, </institution> <year> 1994. </year>
Reference-contexts: It is not allowed that the instance list in the chart interface contains more than one entry for an instance in the chart body <ref> [Ren94, section 4.3, page 14] </ref>. The information the chart interface and the instance heads give about an instance may consist of the instance name and the instance kind. In turn, the instance kind consists of a kind name and optionally a kind denominator.
Reference: [Ren95] <author> M. A. Reniers. </author> <title> Syntax requirements of Message Sequence Charts. </title> <editor> In R. Brk and A. Sarma, editors, </editor> <booktitle> SDL'95 With MSC in CASE, Proceedings Seventh SDL Forum, </booktitle> <pages> pages 63-74, </pages> <address> Oslo, 1995. </address> <publisher> Elsevier Science Publishers. </publisher>
Reference-contexts: A new set of syntax requirements is formulated and their formalization is presented. This formalization is based on predicates and functions. The approach taken towards the formalization of the static semantics has been illustrated in <ref> [Ren95] </ref>. Sequence Charts are a widespread means for the description and specification of selected system runs within distributed systems with asynchronous communication, especially telecommunication systems.
Reference: [Sie92] <author> Siemens AG. </author> <title> Comments on Recommendation Z.120 Message Sequence Chart (MSC). </title> <booktitle> Germany, 1992. CCITT Interims Meeting. </booktitle> <pages> 64 </pages>
Reference-contexts: Various kinds of Sequence Charts are used although they differ on minor points only. One can think of the following: Extended Sequence Charts [GR89], Time Sequence Diagrams [ISO91], Arrow Diagrams [CCI88], Information Flow Diagrams [CCHvK90], Synchronous Interworkings [MvWW93, MW93] and Siemens-SCs <ref> [Sie92] </ref>. A comparison of these languages can be found in [GGR93a].
References-found: 21

