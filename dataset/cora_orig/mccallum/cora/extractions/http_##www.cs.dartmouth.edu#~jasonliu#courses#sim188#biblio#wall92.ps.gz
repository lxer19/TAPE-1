URL: http://www.cs.dartmouth.edu/~jasonliu/courses/sim188/biblio/wall92.ps.gz
Refering-URL: http://www.cs.dartmouth.edu/~jasonliu/courses/sim188/notes-06.html
Root-URL: http://www.cs.dartmouth.edu
Title: Code Modification  
Author: David W. Wall d i g i t a l 
Address: Avenue Palo Alto, California 94301 USA  
Affiliation: Western Research Laboratory 250 University  
Note: Systems for Late  
Abstract: M A Y 1 9 9 2 Research Report 92/3 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Anita Borg, R. E. Kessler, Georgia Lazana, and David W. Wall. </author> <title> Long address traces from RISC machines: Generation and analysis. </title> <booktitle> Seventeenth Annual International Symposium on Computer Architecture, </booktitle> <pages> pp. 270-279, </pages> <month> May </month> <year> 1990. </year> <note> A more detailed version is available as WRL Research Report 89/14, </note> <month> September </month> <year> 1989. </year>
Reference-contexts: The Mahler system does code modification in the linker. A wide variety of transformations are possible: intermodule register allocation, instruction pipeline scheduling, source-level instrumentation compatible with gprof [8], and instruction-level instrumentation like basic block counting and address tracing <ref> [1] </ref>. The linker decides in the usual manner which modules to link, including modules extracted from libraries. Each is passed to the module rewriter, which modifies it according to the transformations requested.
Reference: [2] <author> F. Chow, M. Himelstein, E. Killian, and L. Weber. </author> <title> Engineering a RISC compiler system. </title> <booktitle> Digest of Papers: Compcon 86, </booktitle> <pages> pp. 132-137, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: Without this convention, data addresses might change (as in fact they do under Mahler on the Titan); Pixie would have to do loads and stores with an extra level of indirection, just as it does indirect jumps. 333333333333333 * A predecessor, moxie <ref> [2] </ref>, translated a MIPS executable into an equivalent VAX executable, allowing the MIPS compilers to be tested extensively before MIPS hardware existed. 4 SYSTEMS FOR LATE CODE MODIFICATION The instrumentation added by Pixie needs three registers for its own use, which it must steal from the registers already used by the
Reference: [3] <author> Fred C. Chow. </author> <title> Minimizing register usage penalty at procedure calls. </title> <booktitle> Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 85-94. </pages> <note> Published as SIGPLAN Notices 23 (7), </note> <month> July </month> <year> 1988. </year>
Reference: [4] <author> Jack W. Davidson and Christopher W. Fraser. </author> <title> Code selection through object code optimization. </title> <booktitle> ACM Transactions on Programming Languages and Systems 6 (4), </booktitle> <pages> pp. 505-526, </pages> <month> October </month> <year> 1984. </year>
Reference: [5] <author> Jack W. Davidson and Christopher W. Fraser. </author> <title> Register allocation and exhaustive peephole optimization. </title> <booktitle> Software Practice and Experience 14 (9), </booktitle> <pages> pp. 857-865, </pages> <month> Sep-tember </month> <year> 1984. </year>
Reference: [6] <author> Phillip B. Gibbons and Steven S. Muchnick. </author> <title> Efficient instruction scheduling for a pipelined architecture. </title> <booktitle> Proceedings of the SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pp. 11-16. </pages> <note> Published as SIGPLAN Notices 21 (7), </note> <month> July </month> <year> 1986. </year>
Reference: [7] <author> Aaron Goldberg and John Hennessy. </author> <title> MTOOL: A method for detecting memory bottlenecks. </title> <note> WRL Technical Note TN-17, </note> <month> December </month> <year> 1990. </year>
Reference-contexts: In any case we should be able to do instrumentation less intrusively. Acknowledgements Aaron Goldberg experimented with a less general form of Nixie's approach as part of his summer project <ref> [7] </ref> at DECWRL, and I am indebted to him for several stimulating discussions. Most of what I know about Pixie I have learned by disassembling the code it produces, but along the way Earl Killian has given me a hint or three, for which I am most grateful.
Reference: [8] <author> Susan L. Graham, Peter B. Kessler, and Marshall K. McKusick. </author> <title> An execution profiler for modular programs. </title> <booktitle> Software Practice and Experience 13 (8), </booktitle> <pages> pp. 120-126, </pages> <month> August </month> <year> 1983. </year>
Reference-contexts: Mahler The Mahler system [21,22,23,25] is the back-end code generator and linker for the Titan [12,18], an experimental workstation built at DECWRL. The Mahler system does code modification in the linker. A wide variety of transformations are possible: intermodule register allocation, instruction pipeline scheduling, source-level instrumentation compatible with gprof <ref> [8] </ref>, and instruction-level instrumentation like basic block counting and address tracing [1]. The linker decides in the usual manner which modules to link, including modules extracted from libraries. Each is passed to the module rewriter, which modifies it according to the transformations requested. <p> On the other hand, this approach means the user need not recompile, and means we need not maintain instrumented versions of the libraries, as has been the usual practice, for example, in systems that support gprof <ref> [8] </ref>. The need to relink is inconvenient, however, and it is interesting that another approach is possible. 4.
Reference: [9] <author> John Hennessy and Thomas Gross. </author> <title> Postpass code optimization of pipeline constraints. </title> <booktitle> ACM Transactions on Programming Languages and Systems 5 (3), </booktitle> <pages> pp. 422-448, </pages> <month> July </month> <year> 1983. </year>
Reference: [10] <author> Mark I. Himelstein, Fred C. Chow, and Kevin Enderby. </author> <title> Cross-module optimizations: Its implementation and benefits. </title> <booktitle> Proceedings of the Summer 1987 USENIX Conference, </booktitle> <pages> pp. 347-356, </pages> <month> June </month> <year> 1987. </year>
Reference: [11] <author> S. C. Johnson. </author> <title> Postloading for fun and profit. </title> <booktitle> Proceedings of the Winter 1990 USENIX Conference, </booktitle> <pages> pp. 325-330, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: A somewhat similar approach, which does require changing the linker, was recently described by Johnson <ref> [11] </ref>. A modified linker always retains a compact form of the relocation information, even for completely linked programs. Code modification can then occur after linking, as it does in Pixie, without sacrificing the type knowledge that Mahler found so useful. 8.
Reference: [12] <author> Norman P. Jouppi, Jeremy Dion, David Boggs, and Michael J. K. Nielsen. </author> <title> MultiTitan: Four architecture papers. </title> <note> WRL Research Report 87/8, </note> <month> April </month> <year> 1988. </year>
Reference: [13] <author> Gerry Kane. </author> <title> MIPS R2000 Risc Architecture. </title> <publisher> Prentice Hall, </publisher> <year> 1987. </year>
Reference-contexts: Nixie The first compromise we built was a system called Nixie. Nixie works very much like Pixie, but makes certain assumptions about the code it modifies. The framework of this approach is threefold. First, the MIPS architecture <ref> [13] </ref> has a strong bias in favor of using r31 as the return address register.
Reference: [14] <author> Earl A. Killian. </author> <type> Personal communication. </type>
Reference: [15] <author> Scott McFarling. </author> <title> Program optimization for instruction caches. </title> <booktitle> Third International Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pp. 183-191, </pages> <month> April </month> <year> 1989. </year> <title> Published as Computer Architecture News 17 (2), </title> <journal> Operating Systems Review 23 (special issue), SIGPLAN Notices 24 (special issue). </journal> <note> 18 SYSTEMS FOR LATE CODE MODIFICATION </note>
Reference-contexts: Other forms of optimization depend on having the entire program at hand all at once. In an environment with separately-compiled modules, this may mean we must apply the optimization to machine-level code. Global reorganization of code to reduce instruction cache misses <ref> [15] </ref> is one example. Intermodule allocation of registers to variables is another; the Mahler system [22] chose the register variables during linking and modified the object modules being linked to reflect this choice.
Reference: [16] <author> W. M. McKeeman. </author> <title> Peephole optimization. </title> <booktitle> Communications of the ACM 8 (7), </booktitle> <pages> pp. 443-444, </pages> <month> July </month> <year> 1965. </year>
Reference-contexts: The reasons one might want to do this fall into two categories, optimization and instrumentation. Some forms of optimization have to be performed on assembly-level or machine-level code. The oldest is peephole optimization <ref> [16] </ref>, which acts to tidy up code that a compiler has generated; it has since been generalized to include transformations on more machine-independent code [4,5].
Reference: [17] <institution> MIPS Computer Systems. RISCompiler and C Programmer's Guide. MIPS Computer Systems, Inc., </institution> <address> 930 Arques Ave., Sunnyvale, California 94086. </address> <year> 1989. </year>
Reference: [18] <author> Michael J. K. Nielsen. </author> <title> Titan system manual. </title> <note> WRL Research Report 86/1, </note> <month> September </month> <year> 1986. </year>
Reference: [19] <author> Vatsa Santhanam and Daryl Odnert. </author> <title> Register allocation across procedure and module boundaries. </title> <booktitle> Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 28-39. </pages> <note> Published as SIGPLAN Notices 25 (6), </note> <month> June </month> <year> 1990. </year>
Reference-contexts: Register allocation is a fairly high-level optimization, however, and other approaches have been taken, such as monolithic compilation of source modules or intermediate-language modules [3,10,20] or compilation with reference to program summary databases <ref> [19] </ref>. Optimization removes unnecessary operations; instrumentation adds them. A common form of machine-level instrumentation is basic block counting. We transform a program into an equivalent program that also counts each basic block as it is executed.
Reference: [20] <author> Peter A. Steenkiste and John L. Hennessy. </author> <title> A simple interprocedural register allocation algorithm and its effectiveness for LISP. </title> <booktitle> ACM Transactions on Programming Languages and Systems 11 (1), </booktitle> <pages> pp. 1-32, </pages> <month> January </month> <year> 1989. </year>
Reference: [21] <author> David W. Wall. </author> <title> Experience with a software-defined machine architecture. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <note> to appear. Also available as WRL Research Report 91/10, </note> <month> August </month> <year> 1991. </year>
Reference: [22] <author> David W. Wall. </author> <title> Global register allocation at link time. </title> <booktitle> Proceedings of the SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pp. 264-275. </pages> <note> Published as SIGPLAN Notices 21 (7), July 1986. Also available as WRL Research Report 86/3. </note>
Reference-contexts: In an environment with separately-compiled modules, this may mean we must apply the optimization to machine-level code. Global reorganization of code to reduce instruction cache misses [15] is one example. Intermodule allocation of registers to variables is another; the Mahler system <ref> [22] </ref> chose the register variables during linking and modified the object modules being linked to reflect this choice.
Reference: [23] <author> David W. Wall. </author> <title> Link-time code modification. </title> <note> WRL Research Report 89/17, Sep-tember 1989. </note>
Reference: [24] <author> David W. Wall. </author> <title> Register windows vs. register allocation. </title> <booktitle> Proceedings of the SIG-PLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 67-78. </pages> <note> Published as SIGPLAN Notices 23 (7), July 1988. Also available as WRL Research Report 87/5. </note>
Reference-contexts: SYSTEMS FOR LATE CODE MODIFICATION Still other kinds of instrumentation are easy to do by code modification. Address tracing for purposes of cache modeling [1,17] can be done by instrumenting the places where loads and stores occur and also the places where basic blocks begin. A 1988 study <ref> [24] </ref> compared software register allocation with hardware register windows, by instrumenting the code to keep track of procedure call depth, and counting the times when a machine with register windows would overflow its buffer of windows. Naturally, certain kinds of transformation are best done before we reach machine-level code.

References-found: 24

