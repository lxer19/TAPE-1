URL: ftp://ftp.eecs.umich.edu/groups/gasm/javainit.ps
Refering-URL: http://www.eecs.umich.edu/gasm/proglang.html
Root-URL: http://www.eecs.umich.edu
Email: e-mail: boerger@di.unipi.it  e-mail: wolfram@informatik.uni-ulm.de  
Phone: 2  
Title: Initialization Problems for Java  
Author: Egon Borger Wolfram Schulte 
Keyword: Key words: Programming language Java Virtual machine Compiler  
Address: I-56125 Pisa, Italy,  D-89069 Ulm, Germany,  
Affiliation: 1 Universita di Pisa, Dipartimento di Informatica,  Universitat Ulm, Fakultat fur Informatik,  
Abstract: We exhibit a grey area in the specification of Java and of its implementation through the Java Virtual Machine (JVM): the treatment of initialization of classes and interfaces. We report the result of our experiments with different implementations of Java, which confirm the theoretical prediction of our work on mathematical models for Java [4] and the JVM [3], namely that the designers of Java and the JVM have used notions of initialization which do not match and which a*ict the portability of Java programs. We show also that concurrent initialization may deadlock and that various current Java compilers violate the initialization semantics through standard optimization techniques. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <editor> J. Alves-Foss, editor. </editor> <title> Formal Syntax and Semantics of Java(tm). </title> <note> Springer LNCS, to appear. </note> <year> 1998. </year>
Reference: 2. <author> P. Bertelsen. </author> <title> Semantics of Java byte code. </title> <note> Ftp at: ftp://ftp.dina.kvl.dk/pub/Staff/Peter.Bertelsen/jvm-semantics.ps.gz, </note> <year> 1997. </year>
Reference-contexts: To simplify the formal analysis, none of these theoretical studies does care about initialization and as a consequence none of them did detect Java's initialization problems. In their descriptions of defensive JVMs Bertelsen <ref> [2] </ref> and Cohen [5] noticed the problems of underspecification and ambiguity. However, their observations were never confirmed. Perara and Bertelsen maintain an on-line list of errors, ommissions, and ambiguities of the JLS and the JVMS [8].
Reference: 3. <author> E. Borger and W. Schulte. </author> <title> Defining the Java Virtual Machine as platform for provably correct Java compilation. </title> <editor> In L. Brim, J. Gruska, and J. Zlatuska, editors, MFCS'98, </editor> <publisher> Springer LNCS 1450, </publisher> <year> 1998. </year>
Reference-contexts: We report the result of our experiments with different implementations of Java, which confirm the theoretical prediction of our work on mathematical models for Java [4] and the JVM <ref> [3] </ref>, namely that the designers of Java and the JVM have used notions of initialization which do not match and which a*ict the portability of Java programs. We show also that concurrent initialization may deadlock and that various current Java compilers violate the initialization semantics through standard optimization techniques. <p> Vol. 20, No. 4, 1999. Through two recent studies, where we provide a mathematical definition of the meaning of Java [4] and prove a natural scheme for compilation of Java on the Java Virtual Machine (JVM) to be correct <ref> [3] </ref>, we discovered the following problems with initialization in Java and its implementations: The exact moment when initializers for static fields in interfaces are executed is underspecified in the Java Language Specification (JLS) [6]. <p> The JLS says that the superinter-faces of a class or of an interface need not be initialized before a class or an interface is initialized [6, x 12.4.1]. They can be initialized, but their initialization is not required. Starting from our models for Java [4] and for the JVM <ref> [3] </ref> one can provide different refinements that are compatible with the requirements of the JLS but yield different results for interface initialization. Experimentation with current implementations confirms this: different implementations leads to different results due to this underspecification of interface initialization. <p> Yet, the corresponding Java phrases, namely the reference type cast expression and the instanceof operator, are not active uses in Java. These expressions do not trigger the initialization of the referenced types. This inconsistency can be traced in our rigorous models for Java [4] and the JVM <ref> [3] </ref> as platform for compiling Java code. The inconsistency is experimentally demonstrated by slightly changing application Main of Fig. 1. We extend the class A (in line 1) by a static method someObject that returns a new instance of class A.
Reference: 4. <author> E. Borger and W. Schulte. </author> <title> A programmer friendly modular definition of the semantics of Java. </title> <note> In Alves-Foss [1]. </note>
Reference-contexts: We report the result of our experiments with different implementations of Java, which confirm the theoretical prediction of our work on mathematical models for Java <ref> [4] </ref> and the JVM [3], namely that the designers of Java and the JVM have used notions of initialization which do not match and which a*ict the portability of Java programs. <p> An additional complication is caused by parallel threads that try to initialize the same class at the same time. ? This paper appears in Software Concepts& Tools. Vol. 20, No. 4, 1999. Through two recent studies, where we provide a mathematical definition of the meaning of Java <ref> [4] </ref> and prove a natural scheme for compilation of Java on the Java Virtual Machine (JVM) to be correct [3], we discovered the following problems with initialization in Java and its implementations: The exact moment when initializers for static fields in interfaces are executed is underspecified in the Java Language Specification <p> The JLS says that the superinter-faces of a class or of an interface need not be initialized before a class or an interface is initialized [6, x 12.4.1]. They can be initialized, but their initialization is not required. Starting from our models for Java <ref> [4] </ref> and for the JVM [3] one can provide different refinements that are compatible with the requirements of the JLS but yield different results for interface initialization. Experimentation with current implementations confirms this: different implementations leads to different results due to this underspecification of interface initialization. <p> Attardi that in JDK 1.2 for Solaris of Sun our program is not initialized anymore. 2 With respect to the JLS [6, x 12.4.1] this description is slightly simplified, however, for our purposes it suffices. For a more rigorous and complete definition see also <ref> [4] </ref>. the role of a symbol table. JVM instructions that take classes, interfaces, fields or methods as operands, reference these entities symbolically using the constant pool. <p> Yet, the corresponding Java phrases, namely the reference type cast expression and the instanceof operator, are not active uses in Java. These expressions do not trigger the initialization of the referenced types. This inconsistency can be traced in our rigorous models for Java <ref> [4] </ref> and the JVM [3] as platform for compiling Java code. The inconsistency is experimentally demonstrated by slightly changing application Main of Fig. 1. We extend the class A (in line 1) by a static method someObject that returns a new instance of class A. <p> We replace the call of A:someObject in line 9 by the body of the method someObject declared in class A. ... 9 I i = (I) (args.length==0 ? null : new A ()); According to the Java semantics (see [6]), which is reflected in our model <ref> [4] </ref>, this change should have no effect. However, most compilers deduce that the type of the conditional expression is either A or the null type. In both cases the reference type cast to the interface I will succeed and so most compilers eliminate it (see Table 1). <p> Awaked threads check the initialization status of the class. If initialization was successful the awaked thread immediately returns, if initialization failed an exception is thrown. This behavior of Java is formalized in our model Java T <ref> [4] </ref>. Now consider the problem that there are two classes A and B, which static initializer depend on each other (see Fig. 2 for the example). The result of executing these initializers is dependent on the thread scheduler. <p> However, if two threads concurrently enter the static initializers, then|as can be checked in our model <ref> [4] </ref> for Java|both will detect a first use of the respective other class. But since the initialization of the other class is in progress by the respective other thread, both start waiting, but no thread will awake them. This is a typical deadlock.
Reference: 5. <author> R. M. Cohen. </author> <title> Defensive Java virtual machine version 0.5 alpha release. Web pages at: </title> <note> http: //www.cli.com/software/djvm/, 1997. </note>
Reference-contexts: To simplify the formal analysis, none of these theoretical studies does care about initialization and as a consequence none of them did detect Java's initialization problems. In their descriptions of defensive JVMs Bertelsen [2] and Cohen <ref> [5] </ref> noticed the problems of underspecification and ambiguity. However, their observations were never confirmed. Perara and Bertelsen maintain an on-line list of errors, ommissions, and ambiguities of the JLS and the JVMS [8].
Reference: 6. <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java(tm) Language Specification. </title> <publisher> Addison Wesley, </publisher> <year> 1996. </year> <title> 6 One could develop weaker constraints, for example that the dependency relation between classes, established by the use of variables in static initializers and initializers for static fields, must be acyclic. However, this would complicate compile-time checking as well as bytecode verification. Egon Borger, Wolfram Schulte: Initialization Problems for Java 5 </title>
Reference-contexts: prove a natural scheme for compilation of Java on the Java Virtual Machine (JVM) to be correct [3], we discovered the following problems with initialization in Java and its implementations: The exact moment when initializers for static fields in interfaces are executed is underspecified in the Java Language Specification (JLS) <ref> [6] </ref>. They can either be initialized when an interface field is first used, or when a class (an interface) that implements (extends) the interface is initialized. The JLS and the JVM Specification (JVMS) [7] use semantically different and conflicting concepts to define when a class or interface is initialized. <p> The JLS says that the superinter-faces of a class or of an interface need not be initialized before a class or an interface is initialized <ref> [6, x 12.4.1] </ref>. They can be initialized, but their initialization is not required. Starting from our models for Java [4] and for the JVM [3] one can provide different refinements that are compatible with the requirements of the JLS but yield different results for interface initialization. <p> The constant pool plays 1 It has been pointed out to us by G. Attardi that in JDK 1.2 for Solaris of Sun our program is not initialized anymore. 2 With respect to the JLS <ref> [6, x 12.4.1] </ref> this description is slightly simplified, however, for our purposes it suffices. For a more rigorous and complete definition see also [4]. the role of a symbol table. JVM instructions that take classes, interfaces, fields or methods as operands, reference these entities symbolically using the constant pool. <p> Both implementations behave differently, yet both are right but on different levels. Table 1 describes the behavior of our program for several different systems. A similar problem arises in the context of array creation expressions. Whereas the JLS <ref> [6, x 12.4.1] </ref> defines that in an array creation expression the array's base type is initialized, this is left out in the JVMS [7, x 2.16.4]. But on the other hand constant pool resolution requires the initialization of the base type of any referenced array [7, x 5.1.3]. <p> As a consequence, most implementations trigger class resolution in array creation expressions, an exception is Visual Age 1.0 on Windows NT. Another ambiguity appears, if a class initializer raises an exception that is not handled within the method. In this case the JLS <ref> [6, x 12.4.2] </ref> and the JVMS [6, x 2.16.5] require that the method's class must be labeled as erroneous. <p> As a consequence, most implementations trigger class resolution in array creation expressions, an exception is Visual Age 1.0 on Windows NT. Another ambiguity appears, if a class initializer raises an exception that is not handled within the method. In this case the JLS [6, x 12.4.2] and the JVMS <ref> [6, x 2.16.5] </ref> require that the method's class must be labeled as erroneous. <p> This behavior contradicts the language and machine specification as well as our models [3,4]. 4 Netscape 3 initializes the interface lazily, whereas Netscape 4 does it eagerly. 5 An ExceptionInInitializerError is a subclass of RuntimeException as specified in <ref> [6, x 20.23] </ref> and not a subclass of Error as specified in the introduction to chapter 20 in [6]. 4 Optimization May Go Wrong Several compilers do not preserve the semantics of initialization. This can be demonstrated experimentally by slightly changing Main of Sect. 3. <p> machine specification as well as our models [3,4]. 4 Netscape 3 initializes the interface lazily, whereas Netscape 4 does it eagerly. 5 An ExceptionInInitializerError is a subclass of RuntimeException as specified in [6, x 20.23] and not a subclass of Error as specified in the introduction to chapter 20 in <ref> [6] </ref>. 4 Optimization May Go Wrong Several compilers do not preserve the semantics of initialization. This can be demonstrated experimentally by slightly changing Main of Sect. 3. <p> We replace the call of A:someObject in line 9 by the body of the method someObject declared in class A. ... 9 I i = (I) (args.length==0 ? null : new A ()); According to the Java semantics (see <ref> [6] </ref>), which is reflected in our model [4], this change should have no effect. However, most compilers deduce that the type of the conditional expression is either A or the null type. <p> However, in general this cannot be statically decided. Indeed, most aforementioned compilers do not preserve the semantics of initialization under all circumstances. An exception might be Microsoft J++, for which we did not find a negative test case. The language designers of Java have foreseen this problem (cf. <ref> [6, x 12.4.3] </ref>). Nevertheless, we found this compiler error interesting to note, since this kind of error is typical for subtle errors involving implicit actions and side effects. 5 Initialization May Deadlock Java supports concurrency. <p> Concurrent initialization is difficult because several threads may be trying to initialize a class at the same time. Java proposes the following strategy <ref> [6, x 12.4.2] </ref>: When initialization of a class is in progress by some thread, then other threads that 4 Egon Borger, Wolfram Schulte: Initialization Problems for Java 1 class A - 5 class B - 2 static char a = 'a'; 6 static char b = 'b'; 3 static a= B.b;-
Reference: 7. <author> T. Lindholm and F. Yellin. </author> <title> The Java(tm) Virtual Machine Specification. </title> <publisher> Addison Wesley, </publisher> <year> 1996. </year>
Reference-contexts: They can either be initialized when an interface field is first used, or when a class (an interface) that implements (extends) the interface is initialized. The JLS and the JVM Specification (JVMS) <ref> [7] </ref> use semantically different and conflicting concepts to define when a class or interface is initialized. Whereas the JLS uses the concept of first active use to trigger class or interface initialization, the JVM implements the initialization as a mandatory step of its (constant pool) resolution process. <p> behavior of different implementations. 3 Initialization is Ambiguous Initialization in Java is based on the concept of first active use: if a constructor or a member of a class is used, the class must be initialized. 2 On the level of the JVM initialization is triggered by constant pool resolution <ref> [7, x 5] </ref>. The constant pool plays 1 It has been pointed out to us by G. <p> Table 1 describes the behavior of our program for several different systems. A similar problem arises in the context of array creation expressions. Whereas the JLS [6, x 12.4.1] defines that in an array creation expression the array's base type is initialized, this is left out in the JVMS <ref> [7, x 2.16.4] </ref>. But on the other hand constant pool resolution requires the initialization of the base type of any referenced array [7, x 5.1.3]. As a consequence, most implementations trigger class resolution in array creation expressions, an exception is Visual Age 1.0 on Windows NT. <p> Whereas the JLS [6, x 12.4.1] defines that in an array creation expression the array's base type is initialized, this is left out in the JVMS [7, x 2.16.4]. But on the other hand constant pool resolution requires the initialization of the base type of any referenced array <ref> [7, x 5.1.3] </ref>. As a consequence, most implementations trigger class resolution in array creation expressions, an exception is Visual Age 1.0 on Windows NT. Another ambiguity appears, if a class initializer raises an exception that is not handled within the method.
Reference: 8. <author> R. Perera and P. Bertelsen. </author> <title> Java spec report. Web pages at: </title> <note> http://www.dina.kvl.dk/~jsr/, 1998. </note>
Reference-contexts: In their descriptions of defensive JVMs Bertelsen [2] and Cohen [5] noticed the problems of underspecification and ambiguity. However, their observations were never confirmed. Perara and Bertelsen maintain an on-line list of errors, ommissions, and ambiguities of the JLS and the JVMS <ref> [8] </ref>.
Reference: 9. <author> V. Saraswat. </author> <title> Java is not type-safe. Web pages at: </title> <note> http://www.research.att.com/~vj/main.html, 1997. </note>
Reference-contexts: As predicted by our mathematical model for Java, different implementations (e.g. the JDK 1.1) deadlock. 6 Discussion and Proposal of Solution Mostly the analysis of Java is concentrated on finding security errors. Work in this area can be classified as experimental, for instance <ref> [9, 10] </ref>, or theoretical, for instance [1,11]. To simplify the formal analysis, none of these theoretical studies does care about initialization and as a consequence none of them did detect Java's initialization problems.
Reference: 10. <author> E.G. Sirer, S. McDirmid, and B. Bershad. </author> <month> Kimera: </month>
Reference-contexts: As predicted by our mathematical model for Java, different implementations (e.g. the JDK 1.1) deadlock. 6 Discussion and Proposal of Solution Mostly the analysis of Java is concentrated on finding security errors. Work in this area can be classified as experimental, for instance <ref> [9, 10] </ref>, or theoretical, for instance [1,11]. To simplify the formal analysis, none of these theoretical studies does care about initialization and as a consequence none of them did detect Java's initialization problems.
References-found: 10

