URL: http://www.cs.washington.edu/research/projects/spin/www/papers/Usenix96/extprotarch.ps
Refering-URL: http://velvet.cs.washington.edu/spin/docs/spin.html
Root-URL: 
Email: fmef,bershadg@cs.washington.edu  
Title: An Extensible Protocol Architecture for Application-Specific Networking  
Author: Marc E. Fiuczynski Brian N. Bershad 
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract: Plexus is a networking architecture that allows applications to achieve high performance with customized protocols. Application-specific protocols are written in a typesafe language and installed dynamically into the operating system kernel. Because these protocols execute within the kernel, they can access the network interface and other operating system services with low overhead. Protocols implemented with Plexus outperform equivalent protocols implemented on conventional monolithic systems. Plexus runs in the context of the SPIN extensible operating system. 
Abstract-found: 1
Intro-found: 1
Reference: [BFM + 94] <author> A. Banerjea, D. Ferrari, B. Mah, M. Moran, D. Verma, , and H. Zhang. </author> <title> The Tenet Real-Time Protocol Suite: Design, Implementation, and Experiences. </title> <type> Technical Report 94-059, </type> <institution> International Computer Science Institute, Berkeley, </institution> <month> November </month> <year> 1994. </year>
Reference-contexts: The protocol architecture in conventional operating systems does not easily accommodate application-specific protocols. First, application-specific code often runs substantially slower than native kernel protocol code <ref> [BFM + 94, RH91, Bir93, vRHB94] </ref>. Second, the failure of a protocol module can cause the entire operating system to fail [SMP92, Tho95].
Reference: [BHL93] <author> Edoardo Biagioni, Robert Harper, and Peter Lee. </author> <title> Standard ML Signatures for a Protocol Stack. </title> <type> Technical Report CMU-CS-FOX-93-01, </type> <institution> Carnegie Mellon University, </institution> <year> 1993. </year>
Reference-contexts: Similarly, our guards are functionally equivalent to virtual protocols. The main difference between the two architectures is that we permit users to safely and dynamically extend the protocol graph in the kernel by allowing application-specific protocol code to be placed within the stack. The Fox project <ref> [BHL93] </ref> uses a high level language, ML, to implement protocol stacks. Through the use of strongly typed interfaces they can compose arbitrary protocol and experiment with customized protocols. However, their system runs only in user space, making it difficult to achieve good performance with a customized protocol.
Reference: [Bir93] <author> K.P. Birman. </author> <title> The Process Group Approach to Reliable Distributed Computing. </title> <journal> Communications of the ACM, </journal> <volume> 36(12), </volume> <month> December </month> <year> 1993. </year>
Reference-contexts: The protocol architecture in conventional operating systems does not easily accommodate application-specific protocols. First, application-specific code often runs substantially slower than native kernel protocol code <ref> [BFM + 94, RH91, Bir93, vRHB94] </ref>. Second, the failure of a protocol module can cause the entire operating system to fail [SMP92, Tho95].
Reference: [BSP + 95] <author> Brian N. Bershad, Stefan Savage, Przemys law Pardyak, Emin Gun Sirer, Marc E. Fiuczynski, David Becker, Susan Eggers, and Craig Chambers. </author> <title> Extensibility, Safety and Performance in the SPIN Operating System. </title> <booktitle> In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: We have built Plexus in the context of the SPIN extensible operating system <ref> [BSP + 95] </ref>. The system runs on DEC ALPHA workstations, and supports a range of protocols, including IP, ARP, ICMP, UDP, TCP and HTTP. <p> In Section 6 we survey related work. Finally, in Section 7 we conclude. 2 Overview of the SPIN oper ating system SPIN is an operating system that can be dynamically and safely specialized to meet the performance and functionality requirements of applications <ref> [BSP + 95] </ref>. Applications define system extensions in Modula-3 [Nel91], which is an Algol-like typesafe programming language. Extensions are dynamically linked into the kernel virtual address space, where they can access other operating system services with low latency.
Reference: [CFF + 93] <author> Chran-Ham Chang, Richard Flower, John Forecast, Heather Gray, William R. Haw, K. K. Ramakrish-nan, Ashok P. Nadkarni, Uttam N. Shikarpur, and Kathleen M. Wilde. </author> <title> High-performance TCP/IP and UDP/IP Networking in DEC OSF/1 for Alpha AXP. </title> <journal> Digitial Technical Journal, </journal> <volume> 5(1), </volume> <year> 1993. </year>
Reference-contexts: In contrast, the same protocols implemented in DIGITAL UNIX using the same device drivers are substantially slower despite the fact that the DEC implementation has been highly optimized <ref> [CFF + 93] </ref>. 1.1 Motivation A protocol that performs well for one class of applications can be a bottleneck for others. For example, applications that perform large bulk data transfers over wide area networks are best served by a protocol implementation that provides large local buffers.
Reference: [CSZ92] <author> David D. Clark, Scott Shenker, and Lixia Zhang. </author> <title> Supporting Real-Time Applications in an Integrated Services Packet Network: Architecture and Mechanism. </title> <booktitle> In SIGCOMM '92 Conference Proceedings, </booktitle> <pages> pages 14-26, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: 1 Introduction This paper describes the design and implementation of Plexus, a protocol architecture that allows arbitrary applications to define application-specific protocols. Plexus allows protocol processing to be tailored using application-level knowledge, thus providing the framework for supporting new protocols <ref> [CSZ92] </ref>, and implementing optimizations to existing protocols such as integrated layer processing and application level framing and buffering strategies [CT90]. A key aspect of Plexus is that application protocol code executes within a kernel-level protocol graph that can be dynamically changed as applications come and go.
Reference: [CT90] <author> D. D. Clark and D. L. Tennenhouse. </author> <title> Architectural Considerations for a New Generation of Protocols. </title> <booktitle> In Proceedings of the ACM SIGCOMM '90 Symposium on Communications Architectures and Protocols, </booktitle> <pages> pages 200-208, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Plexus allows protocol processing to be tailored using application-level knowledge, thus providing the framework for supporting new protocols [CSZ92], and implementing optimizations to existing protocols such as integrated layer processing and application level framing and buffering strategies <ref> [CT90] </ref>. A key aspect of Plexus is that application protocol code executes within a kernel-level protocol graph that can be dynamically changed as applications come and go. <p> The current implementation makes two passes over the data, one pass for the checksum and another to decompress the image. The client viewer is a good candidate for the integrated layer processing optimizations suggested by Clark <ref> [CT90] </ref>. We use the same video display code for both the SPIN application extension and the DIGITAL UNIX application. To achieve this, the video client implemented on DIGITAL UNIX maps the framebuffer directly into its address space and uses the same viewer code as the SPIN implementation.
Reference: [FP93a] <author> Kevin Fall and Joseph Pasquale. </author> <title> Exploiting In-kernel Data Paths to Improve I/O Throughput and CPU Availability. </title> <booktitle> In Proceedings of the 1993 Winter USENIX Conference, </booktitle> <pages> pages 327-333, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: In these systems, application-specific extensibility is not safely possible, as any system extension can bring down the entire system or violate system integrity. Fall and Pasquale describe a splicing mechanism that enables applications to route data between two devices directly within the kernel <ref> [FP93a, FP93b] </ref>. Splicing is only a partial solution, however, if applications must manipulate the data, for example, to decrypt, before passing it on to the next stage in the splice.
Reference: [FP93b] <author> Kevin Fall and Joseph Pasquale. </author> <title> Improving Continuous-media Playback Performance With In-kernel Data Paths. </title> <booktitle> In Proceedings of the IEEE International Conference on Multimedia Computing and Systems (ICMCS), </booktitle> <pages> pages 100-109, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: In these systems, application-specific extensibility is not safely possible, as any system extension can bring down the entire system or violate system integrity. Fall and Pasquale describe a splicing mechanism that enables applications to route data between two devices directly within the kernel <ref> [FP93a, FP93b] </ref>. Splicing is only a partial solution, however, if applications must manipulate the data, for example, to decrypt, before passing it on to the next stage in the splice.
Reference: [GM] <author> James Gosling and Henry McGilton. </author> <title> The Java Language Environment: </title> <note> A White Paper. http://java.sun.com. </note>
Reference-contexts: Dynamic linking/unlinking is necessary to install and remove new protocol extensions into and from the kernel. An in-kernel firewall makes it possible to run user code within the kernel without compromising system integrity. Typesafe languages are not the only mechanism for implementing firewalls. Alternative strategies include interpreted languages <ref> [GM, Ous94] </ref> and software based fault isolation techniques [WLAG93]. 4 Performance In this section we describe basic latency and throughput measurements for Plexus on a range of networking devices.
Reference: [HFG + 96] <author> W. C. Hsieh, M. E. Fiuczynski, C. Garrett, S. Savage, D. Becker, and B. N. Bershad. </author> <title> Language Support for Extensible Systems. </title> <booktitle> In First Workshop on Compiler Support for Systems Software, </booktitle> <month> February </month> <year> 1996. </year>
Reference-contexts: Although unsafe casts are possible using Modula-3's LOOPHOLE operator, there is no way to ensure that the operator is used in only safe ways. To allow for safe casting operations, we have defined a new operator for Modula-3 that converts an array of bytes to a restricted Modula-3 type <ref> [HFG + 96] </ref>. The signature of the new operator is VIEW (a,T):T. The result of VIEW (a,T) is the expression a's bit pattern interpreted as a value of type T, which must be a scalar type or an aggregate of scalar types. <p> The first requirement reduces the likelihood that an interrupt is lost during the handling of a previous one. The second simplifies the delivery of interrupts, enabling them to be processed in the context of "special" lightweight kernel threads. We have introduced a small amount of compile-time support <ref> [HFG + 96] </ref> to enable a delegating protocol manager, such as the Ethernet layer, to ascertain whether a potential event handler is a "good" candidate for running within an interrupt context.
Reference: [HPAO89] <author> Norman C. Hutchinson, Larry Peterson, Mark B. Abbott, and Sean O'Malley. </author> <title> RPC in x-kernel: Evaluating New Design Techniques. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 91-101, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: First, application-specific code often runs substantially slower than native kernel protocol code [BFM + 94, RH91, Bir93, vRHB94]. Second, the failure of a protocol module can cause the entire operating system to fail [SMP92, Tho95]. In response to this, some systems only allow the "superuser" to define new protocols <ref> [HPAO89, Sun, Wel95] </ref>, greatly limiting the set of applications for which a new protocol can be defined. In other systems, the protocols must be defined when the system is built [OP92]. Finally, the overall structure of protocols in most commercial systems does not encourage small localized changes.
Reference: [IBM93] <author> IBM Corporation. </author> <title> AIX Version 3 for RISC System/6000 Kernel Extensions and Device Support Programming Concepts, </title> <month> October </month> <year> 1993. </year> <month> SC23-2207-00. </month>
Reference-contexts: UNIX. The DIGITAL UNIX implementation runs at user-level and is unable to respect end-to-end TCP semantics. 6 Related Work Many operating systems provide an interface that enable code to be installed into the kernel at runtime. Examples include dynamically linked device drivers, system calls, and networking protocols <ref> [Sun, IBM93, Wel95] </ref>. However, the extensions in these systems can see all kernel symbol names, giving them free-reign over the internals of the system. For example, a dynamically linked extension has complete access to the virtual memory subsystem, thus can manipulate data belonging to all currently running applications.
Reference: [MB93] <author> Chris Maeda and Brian N. Bershad. </author> <title> Protocol Service Decomposition for High-Performance Networking. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 244-255, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Second, using link-time control services, Plexus restricts direct access to lower level interfaces, ensuring that applications do not snoop or spoof network packets. The strategies are functionally identical to, although less costly than, those found in conventional operating systems where application-specific protocols execute in user-space <ref> [TNML93, MB93] </ref>; the first prevents arbitrary kernel memory from being accessed, while the second prevents arbitrary kernel functions from being called. We have built Plexus in the context of the SPIN extensible operating system [BSP + 95]. <p> This model of protection is similar to the one used by the Mach user-level protocol library, where the UNIX server installs packet filters on behalf of the library's requests <ref> [MB93] </ref>. To send a packet, an untrusted, higher-level protocol must obtain the right to "raise" the PacketSend event that transfers the packet to a lower level protocol. Protocol managers prevent spoofing at this level by defining a PacketSend event specific to a legitimate sending endpoint. <p> Splicing is only a partial solution, however, if applications must manipulate the data, for example, to decrypt, before passing it on to the next stage in the splice. Several projects have defined protocol structures allowing applications to use their own protocols in a safe manner within their address space <ref> [TNML93, MB93] </ref>. Our architecture resembles their organization by separating protocol send and receive code from end-point management, but allows applications to link code into the kernel virtual address space where they have low latency access to operating system services, buffer management, and the network interface.
Reference: [MRA87] <author> J. Mogul, R. Rashid, and M. Accetta. </author> <title> The Packet Filter: An Efficient Mechanism for User-level Network Code. </title> <booktitle> In Proceedings of the Eleventh ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 39-51, </pages> <year> 1987. </year>
Reference-contexts: Extensions define the operations that occur in response to events, whereas guards ensure that those operations happen only at the proper time. Plexus relies on guards to implement packet filters <ref> [MRA87] </ref> that correctly route packets through the protocol graph to particular implementations of a protocol. 3 The Plexus Architecture Plexus allows applications to define new protocols or to change the implementation of existing protocols. The system is structured as a protocol graph of event raisers and event handlers.
Reference: [Nel91] <author> Greg Nelson, </author> <title> editor. System Programming in Modula-3. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: Finally, in Section 7 we conclude. 2 Overview of the SPIN oper ating system SPIN is an operating system that can be dynamically and safely specialized to meet the performance and functionality requirements of applications [BSP + 95]. Applications define system extensions in Modula-3 <ref> [Nel91] </ref>, which is an Algol-like typesafe programming language. Extensions are dynamically linked into the kernel virtual address space, where they can access other operating system services with low latency. Low latency is important because it enables fine-grained interaction between the application and the operating system.
Reference: [OP92] <author> S. W. O'Malley and L. L. Peterson. </author> <title> A Dynamic Network Architecture. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(2), </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: In response to this, some systems only allow the "superuser" to define new protocols [HPAO89, Sun, Wel95], greatly limiting the set of applications for which a new protocol can be defined. In other systems, the protocols must be defined when the system is built <ref> [OP92] </ref>. Finally, the overall structure of protocols in most commercial systems does not encourage small localized changes. Plexus offers application developers a protocol architecture having five properties key to the construction of application-specific solutions: * Performance. <p> Our architecture resembles their organization by separating protocol send and receive code from end-point management, but allows applications to link code into the kernel virtual address space where they have low latency access to operating system services, buffer management, and the network interface. The x-kernel <ref> [OP92] </ref> provides a framework for implementing network protocols. In the x-kernel, many small protocols, called micro- and virtual- protocols, implement simple processing functions tied together by a complex graph to implement a standard protocol. Similarly, our architecture decomposes the stack into a protocol graph using SPIN events and guards.
Reference: [Ous94] <author> John K. Ousterhout. </author> <title> Tcl and the TK Toolkit. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1994. </year>
Reference-contexts: Dynamic linking/unlinking is necessary to install and remove new protocol extensions into and from the kernel. An in-kernel firewall makes it possible to run user code within the kernel without compromising system integrity. Typesafe languages are not the only mechanism for implementing firewalls. Alternative strategies include interpreted languages <ref> [GM, Ous94] </ref> and software based fault isolation techniques [WLAG93]. 4 Performance In this section we describe basic latency and throughput measurements for Plexus on a range of networking devices.
Reference: [PP93] <author> Lawrence G. Palmer and Rick S. Palmer. </author> <month> DECspin: </month>
Reference-contexts: We expect that with better video hardware, such as the DEC J300 device <ref> [PP93] </ref>, the dominant performance bottleneck will be the protocol processing rather than the application processing. Protocol forwarding Plexus can be used to provide protocol functionality not generally available in conventional systems.
References-found: 19

