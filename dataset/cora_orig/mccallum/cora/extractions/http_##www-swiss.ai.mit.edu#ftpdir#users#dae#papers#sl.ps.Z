URL: http://www-swiss.ai.mit.edu/ftpdir/users/dae/papers/sl.ps.Z
Refering-URL: http://www-swiss.ai.mit.edu/ftpdir/users/dae/home.html
Root-URL: 
Email: espinosa@cs.columbia.edu  
Title: Semantic Lego  
Author: David Espinosa 
Date: January 1994  
Address: New York, NY 10027  
Affiliation: Columbia University Department of Computer Science  
Abstract: We exhibit Semantic Lego, a modular system for constructing programming language implementations from denotational-style building blocks. We present languages as abstract data types, show that ADTs have advantages over interpreters, and incrementally construct semantics for them using type transformations and liftings. We derive specific type transformations (third order) and lift-ings (monads) from more fundamental considerations and show that monads transform rather than compose. Semantic Lego extends Moggi, Wadler, and Steele's earlier work and has applications to language extensibility, the construction of interpreters and compilers, and the study of semantic models. 
Abstract-found: 1
Intro-found: 1
Reference: [AKHS88] <author> Hal Abelson, Jacob Katzenelson, Matthew Halfant, and Gerald Jay Sussman. </author> <title> The Lisp Experience. </title> <booktitle> Annual Review of Computer Science, </booktitle> <volume> 3 </volume> <pages> 167-195, </pages> <year> 1988. </year>
Reference-contexts: The above program runs without an interpreter, showing that new semantics does not require new syntax. In essence, the child reuses the parent's syntax, showing that "metalinguistic abstraction" is not fundamentally different from procedural and data abstraction, contrary to some presentations <ref> [AKHS88] </ref>. Since the interactivity of the child is also inherited, the ADT formulation suitable for both interpreted and compiled parent languages. On the other hand, compositionality, that the meaning of the whole is determined by the meaning of the parts, is the essential glue that binds parent and child.
Reference: [JD93] <author> Mark P. Jones and Luc Duponcheel. </author> <title> Composing monads. </title> <type> Technical Report YALEU / DCS / RR-1004, </type> <institution> Yale University, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: On the other hand, TCCs are not entirely local. For instance, the side-effects TCC F (T)A = Sto (A) ! T (A fi Sto (A)) modifies T by both right and left composition in one step. As noted by Jones and Duponcheel <ref> [JD93] </ref>, this construction yields a different monad than composition with two separate TCs. In general, module interfaces should be as flexible as possible, since they need not implement language ADTs directly. <p> After reading his paper, I had planned to define stratified monads, towers of unit and bind operators that could transformed and thus allow left composition. This approach resembles pseudomonads but is still not as simple or powerful as monad constructors. 4.4 Jones and Duponcheel In <ref> [JD93] </ref>, Mark Jones and Luc Duponcheel seriously address the problem of composing monads. They find that if one of several auxiliary maps is defined relating the structures of two monads, they can be composed, in an order depending which map is used.
Reference: [KBdR91] <author> Gregor Kiczales, Daniel G. Bobrow, and Jim des Rivieres. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: In general, module interfaces should be as flexible as possible, since they need not implement language ADTs directly. This organization leaves an outlet for parametrization in the style of metaobject protocols <ref> [Kic92, KBdR91] </ref>. 3.6 Why Monads? This section describes when we need monads in place of the weaker map and ts operators described in section 3.3.1. Monads are connected with lambda calculus, so we examine the call-by-value environment TCC, F (T)A = Env (A) ! TA.
Reference: [Kic92] <author> Gregor Kiczales. </author> <title> Toward a new model of abstraction in software engineering. </title> <booktitle> In Proceedings of the International Workshop on Reflection and Meta-Level Architecture, </booktitle> <pages> pages 1-11, </pages> <address> Tama-City, Tokyo, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: In general, module interfaces should be as flexible as possible, since they need not implement language ADTs directly. This organization leaves an outlet for parametrization in the style of metaobject protocols <ref> [Kic92, KBdR91] </ref>. 3.6 Why Monads? This section describes when we need monads in place of the weaker map and ts operators described in section 3.3.1. Monads are connected with lambda calculus, so we examine the call-by-value environment TCC, F (T)A = Env (A) ! TA.
Reference: [KW92] <author> David King and Philip Wadler. </author> <title> Combining monads. </title> <booktitle> In Proceedings of the Fifth Annual Glasgow Workshop on Functional Programming, </booktitle> <address> Ayr, Scotland, 1992. </address> <publisher> Springer Workshops in Computer Science. </publisher>
Reference-contexts: Later, in [WPJ93, Wad92b], he demonstrated the utility of mon-ads for structuring programs rather than semantics. Mon-ads factor loosely-coupled programs and thereby hide imperative features such as state and I/O, solving the old problem of passing information through a functional program without introducing additional arguments. In <ref> [KW92] </ref>, Wadler and David King showed how to combine the lists monad L with any monad M to form a monad ML.
Reference: [MC93] <author> Eugenio Moggi and Pietro Cenciarelli. </author> <title> A syntactic approach to modularity in denotational semantics. </title> <booktitle> In Category Theory and Computer Science. </booktitle> <publisher> Springer LNCS, </publisher> <year> 1993. </year>
Reference-contexts: If not, we can form them by lifting the concepts discussed in section 3 to the syntactic domain. Implementations could then be transformed to increase efficiency. Syntactic treatments of monads and monad constructors are given in [Wad92b] and <ref> [MC93] </ref> respectively. 3 Modular Models To build the models shown, construct-type begins with the base type 0 and the operator show. Building blocks such as booleans and side-effects each contain a type transformation, a set of lifting operators, and a set of language operators that are used to: 1. <p> Second, Moggi's notes use non-elementary category theory and, on first reading, appear impractical and difficult. The notes are also not widely available, and the only published paper referring to monad constructors is the two-page summary [Mog91a]. His more recent paper <ref> [MC93] </ref> presents a syntactic treatment in hope of "hiding the category-theoretic concepts and sophistication of the original approach in suitable metalanguages". It describes what is essentially monad constructor translation, but, despite Moggi's good intentions, is no easier than the original.
Reference: [Mog89a] <author> Eugenio Moggi. </author> <title> An abstract view of programming languages. </title> <type> Technical Report ECS-LFCS-90-113, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, Edinburgh, </institution> <address> Scotland, </address> <month> June </month> <year> 1989. </year> <note> FTP from theory.doc.ic.ac.uk : theory/papers/Moggi. </note>
Reference-contexts: 1 Introduction Our goal is to construct implementations for a wide variety of programming languages from a small set of reusable parts. Beginning from Eugenio Moggi's work <ref> [Mog89a] </ref>, we present languages as abstract data types and incrementally construct ADT implementations from semantic modules. We work in the area of "computational semantics" in that we demonstrate Semantic Lego, a prototype implementation in Scheme, rather than construct domain-theoretic models. <p> are required because procedural abstraction over language features implies nested use of T. 4 Previous Work This section relates Semantic Lego to previous work and addresses the question of why it took so long for the rest of us to realize what Moggi knew all along. 6 4.1 Moggi In <ref> [Mog89a, Mog89b, Mog91b] </ref>, Eugenio Moggi realized that monads could be used to structure denota-tional models. He showed that lambda calculus could be parametrized by an arbitrary monad to yield widely varying semantics. <p> He showed that lambda calculus could be parametrized by an arbitrary monad to yield widely varying semantics. His course notes <ref> [Mog89a] </ref>, written while he was visiting Stanford, also present much additional material, including monad constructors, called TCCs here. The present paper transfers Moggi's ideas from mathematics to computation, simplifying and motivating them. <p> Jonathan Rees recently used a natural deduction theorem prover to derive monads for a given TC [Ree]. Inversely, what are the internal logics of the Kleisli categories of various monads? Can a theorem prover be parametrized by a monad? Fourth, in <ref> [Mog89a] </ref>, Moggi discusses lifting natural transformations in the category of (strong) monads.
Reference: [Mog89b] <author> Eugenio Moggi. </author> <title> Computational lambda calculus and monads. </title> <booktitle> In IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 14-23, </pages> <address> Asilomar, CA, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: are required because procedural abstraction over language features implies nested use of T. 4 Previous Work This section relates Semantic Lego to previous work and addresses the question of why it took so long for the rest of us to realize what Moggi knew all along. 6 4.1 Moggi In <ref> [Mog89a, Mog89b, Mog91b] </ref>, Eugenio Moggi realized that monads could be used to structure denota-tional models. He showed that lambda calculus could be parametrized by an arbitrary monad to yield widely varying semantics.
Reference: [Mog91a] <author> Eugenio Moggi. </author> <title> A modular approach to deno-tational semantics. </title> <booktitle> In Category Theory and Computer Science, </booktitle> <pages> pages 138-139. </pages> <publisher> Springer LNCS 530, </publisher> <month> September </month> <year> 1991. </year>
Reference-contexts: Second, Moggi's notes use non-elementary category theory and, on first reading, appear impractical and difficult. The notes are also not widely available, and the only published paper referring to monad constructors is the two-page summary <ref> [Mog91a] </ref>. His more recent paper [MC93] presents a syntactic treatment in hope of "hiding the category-theoretic concepts and sophistication of the original approach in suitable metalanguages". It describes what is essentially monad constructor translation, but, despite Moggi's good intentions, is no easier than the original.
Reference: [Mog91b] <author> Eugenio Moggi. </author> <title> Notions of computation and monads. </title> <journal> Information and Computation, </journal> <volume> 93:55 - 92, </volume> <year> 1991. </year>
Reference-contexts: are required because procedural abstraction over language features implies nested use of T. 4 Previous Work This section relates Semantic Lego to previous work and addresses the question of why it took so long for the rest of us to realize what Moggi knew all along. 6 4.1 Moggi In <ref> [Mog89a, Mog89b, Mog91b] </ref>, Eugenio Moggi realized that monads could be used to structure denota-tional models. He showed that lambda calculus could be parametrized by an arbitrary monad to yield widely varying semantics.
Reference: [Ree] <author> Jonathan Rees. </author> <type> Personal communication. </type>
Reference-contexts: Are these useful distinctions? See sections 4.3 and 4.4 for further remarks. Third, through the Curry-Howard isomorphism, the existence of operators is equivalent to the provability of their types in constructive logic. Jonathan Rees recently used a natural deduction theorem prover to derive monads for a given TC <ref> [Ree] </ref>. Inversely, what are the internal logics of the Kleisli categories of various monads? Can a theorem prover be parametrized by a monad? Fourth, in [Mog89a], Moggi discusses lifting natural transformations in the category of (strong) monads.
Reference: [Ste94] <author> Guy L. Steele Jr. </author> <title> Building interpreters by composing monads. </title> <booktitle> In Proceedings of the 21st Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Portland, OR, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: Despite Moggi's earlier formulation of monad constructors, they described their work as "combining M and L" rather than "constructing ML from M", and even in discussing monad constructors did not realize the significance of the idea. 4.3 Steele In <ref> [Ste94] </ref>, Guy Steele shows how to compose pseudomon-ads, a new construction. Although they compose, pseu-domonads are both more complex and less general than monad constructors. In fact, pseudomonads are essentially monad constructors limited to extension by right composition.
Reference: [Wad92a] <editor> Philip Wadler. </editor> <booktitle> The essence of functional programming. In Proceedings of the 19th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-14, </pages> <address> Albuquerque, NM, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: In category-theoretic terms, monads are more likely to be objects than arrows, since they do not have an obvious composition. Once viewed as objects, they transform via endofunctors on the category. So category theory leads, as is often the case, to a suitable design. 4.2 Wadler In <ref> [Wad92a] </ref>, Philip Wadler popularized Moggi's ideas by presenting monadic interpreters written in Haskell. Later, in [WPJ93, Wad92b], he demonstrated the utility of mon-ads for structuring programs rather than semantics.
Reference: [Wad92b] <author> Philip Wadler. </author> <title> Monads for functional programming. </title> <editor> In Manfred Broy, editor, </editor> <booktitle> Program Design Calculi, Proceedings of the Marktober-dorf Summer School, </booktitle> <year> 1992. </year>
Reference-contexts: Syntactic modules may be powerful enough to construct expression representations of ADT implementations. If not, we can form them by lifting the concepts discussed in section 3 to the syntactic domain. Implementations could then be transformed to increase efficiency. Syntactic treatments of monads and monad constructors are given in <ref> [Wad92b] </ref> and [MC93] respectively. 3 Modular Models To build the models shown, construct-type begins with the base type 0 and the operator show. <p> Once viewed as objects, they transform via endofunctors on the category. So category theory leads, as is often the case, to a suitable design. 4.2 Wadler In [Wad92a], Philip Wadler popularized Moggi's ideas by presenting monadic interpreters written in Haskell. Later, in <ref> [WPJ93, Wad92b] </ref>, he demonstrated the utility of mon-ads for structuring programs rather than semantics. Mon-ads factor loosely-coupled programs and thereby hide imperative features such as state and I/O, solving the old problem of passing information through a functional program without introducing additional arguments.
Reference: [WPJ93] <author> Philip Wadler and Simon Peyton-Jones. </author> <title> Imperative functional programming. </title> <booktitle> In Proceedings of the 20th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Charleston, SC, </address> <month> January </month> <year> 1993. </year> <month> 8 </month>
Reference-contexts: Once viewed as objects, they transform via endofunctors on the category. So category theory leads, as is often the case, to a suitable design. 4.2 Wadler In [Wad92a], Philip Wadler popularized Moggi's ideas by presenting monadic interpreters written in Haskell. Later, in <ref> [WPJ93, Wad92b] </ref>, he demonstrated the utility of mon-ads for structuring programs rather than semantics. Mon-ads factor loosely-coupled programs and thereby hide imperative features such as state and I/O, solving the old problem of passing information through a functional program without introducing additional arguments.
References-found: 15

