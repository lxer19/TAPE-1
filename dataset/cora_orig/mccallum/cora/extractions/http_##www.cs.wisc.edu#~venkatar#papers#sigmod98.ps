URL: http://www.cs.wisc.edu/~venkatar/papers/sigmod98.ps
Refering-URL: http://www.cs.wisc.edu/~venkatar/venkatar.html
Root-URL: 
Title: Cost-Based Optimization of Decision Support Queries using  
Author: Transient-Views Subbu N. Subramanian Shivakumar Venkataraman 
Address: San Jose, CA 95141 San Jose, CA 95141  
Affiliation: IBM Santa Teresa Labs IBM Santa Teresa Labs  
Abstract: Next generation decision support applications, besides being capable of processing huge amounts of data, require the ability to integrate and reason over data from multiple, heterogeneous data sources. Often, these data sources differ in a variety of aspects such as their data models, the query languages they support, and their network protocols. Also, typically they are spread over a wide geographical area. The cost of processing decision support queries in such a setting is quite high. However, processing these queries often involves redundancies such as repeated access of same data source and multiple execution of similar processing sequences. Minimizing these redundancies would significantly reduce the query processing cost. In this paper, we (1) propose an architecture for processing complex decision support queries involving multiple, heterogeneous data sources; (2) introduce the notion of transient-views materialized views that exist only in the context of execution of a query that is useful for minimizing the redundancies involved in the execution of these queries; (3) develop a cost-based algorithm that takes a query plan as input and generates an optimal "covering plan", by minimizing redundancies in the original plan; (4) validate our approach by means of an implementation of the algorithms and a detailed performance study based on TPC-D benchmark queries on a commercial database system; and finally, (5) compare and contrast our approach with work in related areas, in particular, the areas of answering queries using views and optimization using common sub-expressions. Our experiments demonstrate the practicality and usefulness of transient-views in significantly improving the performance of decision support queries. 
Abstract-found: 1
Intro-found: 1
Reference: [Abi97] <author> Abiteboul, Serge. </author> <title> Querying Semi-Structured Data. </title> <booktitle> In 6th ICDT, Delphi, </booktitle> <address> Greece, </address> <month> Jan. </month> <year> 1997. </year>
Reference: [AMMT96] <author> Atzeni, Paolo, Mecca, Giansalvatore, Merialdo, Paolo, and Tabet, Elena. </author> <title> Structures in the web. </title> <type> Tech. report, </type> <institution> DDS, Sezione Informatica, Uni-versita di Roma Tre, </institution> <year> 1996. </year> <type> Tech. Rep. </type>
Reference: [ASD + 91] <author> Ahmed, R., Smedt, P., Du, W., Kent, W., Ketabchi, A., and Litwin, W. </author> <title> The Pegasus Heterogeneous Multidatabase System. </title> <booktitle> In IEEE Computer, </booktitle> <month> December </month> <year> 1991. </year>
Reference: [CAS94] <author> Christophides, V., Cluet, S. Abiteboul, S., and Scholl, M. </author> <title> From structured documents to novel query facilities. </title> <booktitle> In ACM SIGMOD, </booktitle> <year> 1994. </year>
Reference: [CGH + 94] <author> Chawathe, S., Garcia-Molina, H., Hammer, H., Ireland, K., Papakonstantinou, Y., Ull-man, J.D., and Widom, J. </author> <title> The TSIMMIS Project: Integration of Heterogeneous Informa--tion Sources. </title> <booktitle> In IPSJ, </booktitle> <address> Tokyo, Japan, </address> <year> 1994. </year>
Reference-contexts: The majority of the approaches are based on the idea of developing a database-like `wrapper' for data sources and implementing queries against these sources <ref> [CGH + 94, HKWY97, TRS97] </ref>. Typically, wrappers provide a relational or object-relational view of the data in the non-traditional sources, and enable the user to use a common language/interface to query data from the diverse sources.
Reference: [CKPS95] <author> S. Chaudhuri, R. Krishnamurthy, S. Potami-anos, and K. Shim. </author> <title> Optimizing Queries with Materialized Views. </title> <booktitle> In ICDE, </booktitle> <month> March </month> <year> 1995. </year>
Reference-contexts: Ross et al. [RSS96] address the problem of efficiently maintaining materialized views by maintaining other materialized views. Srivastava et al. [SDJL96] and Levy et al. [LMSS95] describe algorithms to determine the portions of the query that can be expressed efficiently using the definition of materialized views. Chaudhuri et al. <ref> [CKPS95] </ref> describe the problem of optimizing queries in the presence of materialized views. They identify portions of the query that can be answered with the materialized view and determine if it is efficient to answer the query using the materialized view.
Reference: [DFJ + 96] <author> S Dar, M. Franklin, B Jonsson, D. Srivastava, and M. Tan. </author> <title> Semantic Data Caching and Replacement. </title> <booktitle> In VLDB, </booktitle> <address> Mumbai, </address> <month> Sept </month> <year> 1996. </year>
Reference-contexts: Thus his work is applicable in a restricted setting of single relation queries. There are several papers that are based on caching query results, for answering future queries. Franklin <ref> [DFJ + 96] </ref> use semantic data caching to identify data in the client buffer in a client-server environment. Finkelstein [Fin82] also use similar methods to cache data of previously executed queries to answer future queries. Jarke [Jar84] discusses the problem of common subexpression isolation.
Reference: [Fin82] <author> S. Finkelstein. </author> <title> Common Subexpression Analysis in Database Applications. </title> <booktitle> In ACM SIG-MOD, </booktitle> <year> 1982. </year>
Reference-contexts: Thus his work is applicable in a restricted setting of single relation queries. There are several papers that are based on caching query results, for answering future queries. Franklin [DFJ + 96] use semantic data caching to identify data in the client buffer in a client-server environment. Finkelstein <ref> [Fin82] </ref> also use similar methods to cache data of previously executed queries to answer future queries. Jarke [Jar84] discusses the problem of common subexpression isolation. He presents several different formulations of the problem under various query language frameworks.
Reference: [GBLP95] <author> J. Gray, A. Bosworth, A. Layman, and H. Pi-rahesh. </author> <title> Data Cube: A Relational Aggregation Operator Generalizing Group-By, Cross-Tab, and Sub-Totals. </title> <type> Tech. Rep. </type> <institution> MSR-TR-95-22, Microsoft, </institution> <year> 1995. </year>
Reference-contexts: In the area of Online Analytical Processing (OLAP), papers have studied the problem of determining the views to materialize in the presence of space constraints so that computation can be speeded up to compute the Cube By operator proposed by Gray et al <ref> [GBLP95] </ref>. These papers are related to our work in that, they address the specific problem of using materialized views while computing the Cube operator. Harinarayanan et al. [HRU96] have studied the problem of computing data cubes efficiently by materializing intermediate results.
Reference: [GHRU97] <author> H. Gupta, V. Harinarayanan, A. Rajaraman, and J. Ullman. </author> <title> Index Selection for OLAP. </title> <booktitle> In ICDE, </booktitle> <month> May </month> <year> 1997. </year>
Reference-contexts: Harinarayanan et al. [HRU96] have studied the problem of computing data cubes efficiently by materializing intermediate results. They have also studied algorithms on when to construct indexes on intermediate results <ref> [GHRU97] </ref>. Gupta [Gup97] develop a theoretical framework for identifying the views to materialize so that they can be maintained efficiently in the presence of storage constraints. 3 Architecture In this section, we describe the HDBS architecture which forms the setting for the work described in this paper.
Reference: [GLS93] <author> P. Gassner, G.M. Lohman, and Y Schiefer, B. Wang. </author> <title> Query Optimization in the IBM DB2 Family. </title> <journal> Data Engineering Bulletin, </journal> <volume> 16(4), </volume> <year> 1993. </year>
Reference-contexts: The results received are translated, converted to local types, and combined with the results of queries on local tables and returned to the user. 3.1 Query Optimizer Our optimizer architecture is based on the well-known STAR-BURST relational query optimizer <ref> [GLS93] </ref> and [HFLP89], extended to a HDBS setting. Figure 1 shows the stages that a query goes through in the optimizer before it is executed.
Reference: [GM80] <author> J. Grant and J. Minker. </author> <title> On optimizing the Evaluation of a Set of Expressions . Tech. </title> <type> Rep. </type> <institution> TR-916, Univ. of Maryland, </institution> <month> July </month> <year> 1980. </year>
Reference-contexts: The IE algorithm generates several redundant temporary relations for each pair of identical subplan operators. The HA algorithm is based on the work by Grant and Minker <ref> [GM80] </ref> and [GM81] uses many non-optimal intermediate query plans for each query in the query batch to optimize the plan for the batch of queries so that the global plan is optimized. <p> In an attempt to find fast access paths for view processing, Roussopoulos [Rou82b] and [Rou82a] provides a framework for interquery analysis based on query graphs introduced by Wong and Youssefi ([WY76]). Kim [Kim84] describes a two stage optimization procedure similar to that of <ref> [GM80] </ref>. The unit of sharing in queries in Kim's proposal is a relation and does not extend to arbitrary expressions that are part of a query. Thus his work is applicable in a restricted setting of single relation queries.
Reference: [GM81] <author> J. Grant and J. Minker. </author> <title> Optimization in Deductive and Conventional Relational Database Systems. </title> <booktitle> Advances in Database Theory, </booktitle> <volume> 1 </volume> <pages> 195-234, </pages> <year> 1981. </year>
Reference-contexts: The IE algorithm generates several redundant temporary relations for each pair of identical subplan operators. The HA algorithm is based on the work by Grant and Minker [GM80] and <ref> [GM81] </ref> uses many non-optimal intermediate query plans for each query in the query batch to optimize the plan for the batch of queries so that the global plan is optimized. The HA and the IE algorithm require a strict notion of equality between query plans for them to be combined.
Reference: [Gup97] <author> H. Gupta. </author> <title> Selection of Views to Materialize in a Data Warehouse. </title> <booktitle> In ICDT, </booktitle> <month> January </month> <year> 1997. </year>
Reference-contexts: Harinarayanan et al. [HRU96] have studied the problem of computing data cubes efficiently by materializing intermediate results. They have also studied algorithms on when to construct indexes on intermediate results [GHRU97]. Gupta <ref> [Gup97] </ref> develop a theoretical framework for identifying the views to materialize so that they can be maintained efficiently in the presence of storage constraints. 3 Architecture In this section, we describe the HDBS architecture which forms the setting for the work described in this paper.
Reference: [Hal76] <author> P.V. Hall. </author> <title> Optimization of a Single Relational Expression in a Relational Database System. </title> <journal> IBM Journal of R&D, </journal> <volume> 20(3), </volume> <month> May </month> <year> 1976. </year>
Reference-contexts: Finally, we discuss future research and conclude in Section 7. 2 Related Work One of the early works on optimizing queries with common subexpression is the work of Hall <ref> [Hal76] </ref>. This work was based on identifying common subexpressions by examining the query syntax. Identifying redundant expressions based on the query syntax can have a detrimental effect of performance as it limits the optimizer's choice for generating optimal plans. We illustrate this using an example in Section 6. <p> Similar to the TPCD queries, the graph shows a 60% reduction in response time when transient-views were used for these two queries. 6.4 Transient-View vs Query Rewrite In this section we demonstrate the detrimental effect of generating common subexpressions to eliminate redundancies by examining the query syntax <ref> [Hal76] </ref>. We compare the performance of TPCD-Q02 with transient-views and with factoring redundancies based on the query syntax. For Q02, the common subexpression factoring algorithm based on query syntax identifies the join between PART-SUPP, REGION, SUPPLIER, and NATION as a common subexpression.
Reference: [HFLP89] <author> L. Haas, J. Freytag, G. Lohman, and H. Pira-hesh. </author> <title> Extensible Query Processing In Starburst. </title> <booktitle> In ACM SIGMOD, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: The results received are translated, converted to local types, and combined with the results of queries on local tables and returned to the user. 3.1 Query Optimizer Our optimizer architecture is based on the well-known STAR-BURST relational query optimizer [GLS93] and <ref> [HFLP89] </ref>, extended to a HDBS setting. Figure 1 shows the stages that a query goes through in the optimizer before it is executed. <p> We also present an algorithm that helps identify equivalent subplans in a given query plan. 4.1 Definitions and Notation Our approach to optimizing decision support queries is based on studying the query execution plan generated by a cost-based optimizer <ref> [HFLP89] </ref>, [JV84], and [SAC + 79]. Naturally, we make use of the Plan tree as the underlying data structure for representing the query execution plan. <p> Before closing this section, we note that our modeling of the plans, operators, and the properties, closely resemble the way most commercial relational systems implement their query engines <ref> [HFLP89] </ref>. 4.2 Equivalence of Subplans As mentioned in Section 1, our approach to optimization is based on analyzing the query plan generated by the optimizer for `equivalent' subparts in the plan, and combining them into a transient view so that the redundancies in computation is avoided.
Reference: [HKWY97] <author> L.M. Haas, D. Kossmann, E.L. Wimmers, and J. Yang. </author> <title> Optimizing Queries Across Diverse Data Sources. </title> <booktitle> In VLDB, </booktitle> <month> Aug </month> <year> 1997. </year>
Reference-contexts: The majority of the approaches are based on the idea of developing a database-like `wrapper' for data sources and implementing queries against these sources <ref> [CGH + 94, HKWY97, TRS97] </ref>. Typically, wrappers provide a relational or object-relational view of the data in the non-traditional sources, and enable the user to use a common language/interface to query data from the diverse sources.
Reference: [HRU96] <author> V. Harinaryanan, A. Rajaraman, and J.D. Ull-man. </author> <title> Implementing Data Cubes Efficiently. </title> <booktitle> In ACM SIGMOD, </booktitle> <pages> pages 205-216, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: These papers are related to our work in that, they address the specific problem of using materialized views while computing the Cube operator. Harinarayanan et al. <ref> [HRU96] </ref> have studied the problem of computing data cubes efficiently by materializing intermediate results. They have also studied algorithms on when to construct indexes on intermediate results [GHRU97].
Reference: [Jar84] <author> M. Jarke. </author> <title> Common Subexpression Isolation in Multiple Query Optimization. Query Processing in Database Systems, </title> <publisher> Springer Verlab, </publisher> <pages> pages 191-205, </pages> <year> 1984. </year>
Reference-contexts: Franklin [DFJ + 96] use semantic data caching to identify data in the client buffer in a client-server environment. Finkelstein [Fin82] also use similar methods to cache data of previously executed queries to answer future queries. Jarke <ref> [Jar84] </ref> discusses the problem of common subexpression isolation. He presents several different formulations of the problem under various query language frameworks. He discusses how common expressions can be detected and used according to their type.
Reference: [JV84] <author> M. Jarke and Y. Vassiliou. </author> <title> Query Optimization in Database Systems. </title> <journal> ACM Computing Surveys, </journal> <month> June </month> <year> 1984. </year>
Reference-contexts: We also present an algorithm that helps identify equivalent subplans in a given query plan. 4.1 Definitions and Notation Our approach to optimizing decision support queries is based on studying the query execution plan generated by a cost-based optimizer [HFLP89], <ref> [JV84] </ref>, and [SAC + 79]. Naturally, we make use of the Plan tree as the underlying data structure for representing the query execution plan.
Reference: [Kim84] <author> W Kim. </author> <title> Global Optimization of Relational Queries. Query Processing in Database Systems, </title> <publisher> Springer Verlag, </publisher> <year> 1984. </year>
Reference-contexts: In an attempt to find fast access paths for view processing, Roussopoulos [Rou82b] and [Rou82a] provides a framework for interquery analysis based on query graphs introduced by Wong and Youssefi ([WY76]). Kim <ref> [Kim84] </ref> describes a two stage optimization procedure similar to that of [GM80]. The unit of sharing in queries in Kim's proposal is a relation and does not extend to arbitrary expressions that are part of a query. Thus his work is applicable in a restricted setting of single relation queries.
Reference: [LMSS95] <author> A.Y. Levy, A.O. Mendelzon, Y. Sagiv, and D. Srivastava. </author> <title> Answering Queries Using Views. </title> <booktitle> In ACM SODS, </booktitle> <month> May </month> <year> 1995. </year>
Reference-contexts: Ross et al. [RSS96] address the problem of efficiently maintaining materialized views by maintaining other materialized views. Srivastava et al. [SDJL96] and Levy et al. <ref> [LMSS95] </ref> describe algorithms to determine the portions of the query that can be expressed efficiently using the definition of materialized views. Chaudhuri et al. [CKPS95] describe the problem of optimizing queries in the presence of materialized views.
Reference: [LRO96] <author> Levy, A.Y., Rajaraman, A., and Ordille, J.J. </author> <title> Querying Heterogeneous Information Sources using Source Descriptions. </title> <booktitle> In VLDB, </booktitle> <address> pg 251-262, </address> <year> 1996. </year>
Reference: [LSS96] <author> Lakshmanan L.V.S., Sadri F., and Subrama-nian, I. N. </author> <title> SchemaSQL a language for querying and restructuring multidatabase systems. </title> <booktitle> In VLDB, </booktitle> <address> pg 239-250, Bombay, </address> <month> September </month> <year> 1996. </year>
Reference: [PGW95] <author> Papakonstantinou, Yannis, Garcia-Molina, H., and Widom, Jennifer. </author> <title> Object exchange across heterogeneous information sources. </title> <booktitle> In ICDE, </booktitle> <address> Taipei, Taiwan, </address> <month> February </month> <year> 1995. </year>
Reference: [PHH92] <author> H Pirahesh, J.M Hellerstein, and W. Hassan. </author> <title> Extensible/Rule Based Query Rewrite Optimization in Starburst. </title> <booktitle> In ACM SIGMOD, </booktitle> <pages> pages 39-48, </pages> <year> 1992. </year>
Reference-contexts: stage in the query optimizer: * Parser: The query from the user is first parsed, semantically analyzed, and translated into a chosen internal representation that is referred to as the Query Graph Model (QGM). * Query Rewrite: The output of the parser is transformed by a set of rewrite rules <ref> [PHH92] </ref>.
Reference: [Rou82a] <author> N. Roussopoulos. </author> <title> The Logical Access Path Schema of A Database. </title> <journal> IEEE Trans. on Soft. Engg., </journal> <volume> 8(6) </volume> <pages> 563-573, </pages> <month> Nov </month> <year> 1982. </year>
Reference-contexts: They also assume that the join predicates are simple equi-joins. In contrast, we use a very broad definition of equivalence, that includes plans with different predicates, different group by and join predicates. In an attempt to find fast access paths for view processing, Roussopoulos [Rou82b] and <ref> [Rou82a] </ref> provides a framework for interquery analysis based on query graphs introduced by Wong and Youssefi ([WY76]). Kim [Kim84] describes a two stage optimization procedure similar to that of [GM80].
Reference: [Rou82b] <author> N. Roussopoulos. </author> <title> View Indexing in Relational Databases. </title> <journal> ACM TODS, </journal> <volume> 7(2) </volume> <pages> 258-290, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: They also assume that the join predicates are simple equi-joins. In contrast, we use a very broad definition of equivalence, that includes plans with different predicates, different group by and join predicates. In an attempt to find fast access paths for view processing, Roussopoulos <ref> [Rou82b] </ref> and [Rou82a] provides a framework for interquery analysis based on query graphs introduced by Wong and Youssefi ([WY76]). Kim [Kim84] describes a two stage optimization procedure similar to that of [GM80].
Reference: [RSS96] <author> K.A. Ross, D. Srivastava, and S. Sudarshan. </author> <title> Materialized View Maintainence and Integrity Constraint Checking: Trading Space for Time. </title> <booktitle> In ACM SIGMOD,May 1996. </booktitle>
Reference-contexts: There is also research work that addresses the problem of maintaining materialized views so that they can be maintained efficiently when there are updates to the base tables. Ross et al. <ref> [RSS96] </ref> address the problem of efficiently maintaining materialized views by maintaining other materialized views. Srivastava et al. [SDJL96] and Levy et al. [LMSS95] describe algorithms to determine the portions of the query that can be expressed efficiently using the definition of materialized views.
Reference: [SAB + 95] <author> Subramanian, V.S., Adali, S., Brink, A., Emery, R., Lu, J.J, Rajput, A., Rogers, T.J., Ross, R., and Ward, C. </author> <title> HERMES: Heterogeneous Reasoning and Mediator System. </title> <type> Tech. Rep., </type> <institution> Inst. for Adv. Comp. Studies and Dept. of CS. Univ. of Maryland, </institution> <year> 1995. </year>
Reference: [SAC + 79] <author> P. Selinger, M. Astrhan, D. Chamberlin, R. Lo-rie, and T. Price. </author> <title> Access path selection in a relational database management system. </title> <booktitle> In ACM SIGMOD, </booktitle> <year> 1979. </year>
Reference-contexts: We also present an algorithm that helps identify equivalent subplans in a given query plan. 4.1 Definitions and Notation Our approach to optimizing decision support queries is based on studying the query execution plan generated by a cost-based optimizer [HFLP89], [JV84], and <ref> [SAC + 79] </ref>. Naturally, we make use of the Plan tree as the underlying data structure for representing the query execution plan.
Reference: [SDJL96] <author> D. Srivastava, S. Dar, S. Jagadish, and A. Levy. </author> <title> Answering Queries with Aggregation Using Views. </title> <booktitle> In VLDB, </booktitle> <month> Sept </month> <year> 1996. </year>
Reference-contexts: There is also research work that addresses the problem of maintaining materialized views so that they can be maintained efficiently when there are updates to the base tables. Ross et al. [RSS96] address the problem of efficiently maintaining materialized views by maintaining other materialized views. Srivastava et al. <ref> [SDJL96] </ref> and Levy et al. [LMSS95] describe algorithms to determine the portions of the query that can be expressed efficiently using the definition of materialized views. Chaudhuri et al. [CKPS95] describe the problem of optimizing queries in the presence of materialized views.
Reference: [Sel88] <author> T.K Sellis. </author> <title> Multiple-Query Optimization. </title> <journal> ACM TODS, </journal> <volume> 13(1) </volume> <pages> 23-52, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: The cost-based approach that we use ensures that our substitutions only result in better plans. We compare transient-views with a syntax based approach in Section 6. The work closely related to ours is that of Sellis <ref> [Sel88] </ref>. His work is in the context of optimizing multiple queries submitted as a batch of queries to the database. Sellis describes two algorithms, Interleaved Execution (IE) and Heuristic Algorithm (HA), to identify common subplans that are identical when multiple queries are submitted for batch execution.
Reference: [SV98] <author> N. Subramanian and S. Venkataraman. </author> <title> Cost based optimization of decision support queries using transient-views. </title> <type> Internal Report, </type> <year> 1998. </year>
Reference-contexts: For the purposes of this paper, if two plans differ in the order and key property, they are will not be considered equivalent. Please refer to <ref> [SV98] </ref> we have defined a broader notion of plan equivalence to include the order and key properties Property Notation Example Tables T i Relation T1, T2 Columns Cols i C1, C2, C3 Join preds J P i T1.C1 RelOp T2.C2 Simple preds SP i T1.C1 RelOp Const Aggregation AF i (Exp) <p> Refer to <ref> [SV98] </ref> for further details Property Condition Join method Identical Outer plan Equivalent Inner plan Equivalent Join predicates Identical Table 4: Join Properties Property Condition Input plan Equivalent Select list does not matter Aggregation Functions does not matter Group by list subset and add columns from the simple predicate Table 5: Group <p> Refer to <ref> [SV98] </ref> for further details 4.3 Equivalence Algorithm In this section, we describe an efficient algorithm that given a query plan, identifies equivalent subplans in it.
Reference: [TPC93] <author> TPC. </author> <title> TPC Benchmark T M D (Decision Sup port). Working draft 6.0, Transaction Processing Performance Council, </title> <month> August </month> <year> 1993. </year>
Reference-contexts: In order to make complex decisions involving the buying and selling of stocks for the clients, the broker would have to analyze and compare information from all of these sources. Typically, these complex queries contain sub-queries that share computational steps. Analysis of the TPCD <ref> [TPC93] </ref> benchmark queries reveals that there is redundancy in computation even in simple queries Currently available database query optimizers do not have the wherewithal to identify these redundancies so that the results of one execution could be used for processing other segments of the query. <p> The ORDER table also maintains the total price of the order, the order and ship priorities. We also had small NATION (25) and REGION (5) tables to associate suppliers and customers with the area they come from. For further information on the benchmark refer to the TPCD benchmark specification <ref> [TPC93] </ref>. The overall database size was around 100MB. We split the TPCD tables and placed the SUPPLIER, NATION, and REGION table on a remote database accessed over the network. We placed the rest of the tables in the local DataJoiner database.
Reference: [TRS97] <author> M. Tork-Roth and P. Schwarz. </author> <title> Dont Scrap It, Wrap It! A Wrapper Architecture for Legacy Data Sources . In VLDB, </title> <month> Aug </month> <year> 1997. </year>
Reference-contexts: The majority of the approaches are based on the idea of developing a database-like `wrapper' for data sources and implementing queries against these sources <ref> [CGH + 94, HKWY97, TRS97] </ref>. Typically, wrappers provide a relational or object-relational view of the data in the non-traditional sources, and enable the user to use a common language/interface to query data from the diverse sources. <p> The following is the list of operators <ref> [TRS97] </ref> we consider in our work: scan , join , group by , and rquery . These operators form the building blocks for the query plan. We choose the above list of operators as they are sufficient to describe any plan tree with the properties described in Table 1 .
Reference: [TRV96] <author> Tomasic, A., Raschid, L., and Valduriez, P. </author> <title> Scaling heterogeneous databases and the design of disco. </title> <booktitle> In IEEE DCS, </booktitle> <year> 1996. </year>
Reference: [VZ97] <author> S. Venkataraman and T. Zhang. </author> <title> DataJoiner Optimizer: Optimizing Query for Heterogenous Database Systems. </title> <note> In Submitted for Publication, </note> <year> 1997. </year>
Reference-contexts: This architecture is loosely based on the DataJoiner <ref> [VZ97] </ref> heterogeneous database system. The HDBMS provides a single database image to tables (or table views obtained via relational wrappers) in multiple data sources. The database clients access remote tables as local tables through user defined aliases. <p> equiv [lvl][i]) f equiv ancst = equiv classes of ancestor nodes common ancst = equiv ancst " common ancst if (common ancst is null) f add equiv [lvl][i] to selected list; break; g if (common ancst not null) prune equiv [lvl][i]; g g 6 Performance We implemented transient-views in DataJoiner <ref> [VZ97] </ref>, a commercial heterogeneous database system, based on DB2. We used the TPCD benchmark queries to evaluate the performance impact of transient-views. Additionally, we formulated two queries based on the TPCD benchmark schema. We evaluated the queries on one processor RS6000 machines, on the AIX 3.2 platform.
Reference: [WY76] <author> E. Wong and K. Youssefi. </author> <title> Decomposition: A Strategy for Query Processing. </title> <journal> ACM TODS, </journal> <volume> 1(3) </volume> <pages> 223-241, </pages> <month> Sept </month> <year> 1976. </year>
References-found: 39

