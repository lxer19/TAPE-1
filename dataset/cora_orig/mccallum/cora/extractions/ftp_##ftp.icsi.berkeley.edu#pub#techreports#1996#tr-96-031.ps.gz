URL: ftp://ftp.icsi.berkeley.edu/pub/techreports/1996/tr-96-031.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/techreports/1996.html
Root-URL: http://www.icsi.berkeley.edu
Title: Reasoning about Sets via Atomic Decomposition atomic decomposition technique separates a collection of sets into
Author: Hans Jurgen Ohlbach Jana Koehler formul. 
Note: The  
Date: August 1996  
Pubnum: TR-96-031  
Abstract: We introduce a new technique that translates cardinality information about finite sets into simple arithmetic terms and thereby enables a system to reason about such set cardinalities by solving arithmetic equation problems. As a particular application we show how this technique yields new inference pro cedures for concept languages with so called number restriction operators. 
Abstract-found: 1
Intro-found: 1
Reference: [AC95] <author> F. Ajili and E. Contejean. </author> <title> Complete solving of linear diophantine equations and inequa-tions without adding variables. </title> <editor> In U. Montanari and F. Rossi, editors, </editor> <booktitle> Proceedings of the 1st International Conference on Principles and Practice of Constraint Programming (CP-95). </booktitle> <publisher> Springer, </publisher> <year> 1995. </year>
Reference-contexts: The first algorithms [Hue78, For83] were limited to the case where a single equation has to be solved. More recent approaches can directly handle systems of equations [GH85, CF89, CD94] or even general linear constraints involving inequations <ref> [AC95, CD94] </ref> and disequations [DT95]. Therefore we did not go into further details of the equation solving aspects.
Reference: [BC96] <author> A. Boudet and H. Comon. </author> <title> Diophantine equations, Presburger arithmetic and finite automata. </title> <editor> In H. Kirchner, editor, </editor> <booktitle> Proceedings of the Colloquium on Trees in Algebra and Programming (CAAP'96), Lecture Notes in Computer Science. </booktitle> <publisher> Springer, </publisher> <year> 1996. </year>
Reference-contexts: This calls for optimized algorithms, which do not compute solutions, but only check consistency. Some first techniques have been presented in <ref> [Dom91, BC96] </ref> and we are currently exploring ways to develop a consistency checking algorithm that suits exactly our application purpose. The atomic decomposition method is a new approach for developing inference systems for concept languages.
Reference: [BH91] <author> F. Baader and B. Hollunder. KRIS: </author> <title> Knowledge representation and inference system. </title> <journal> SIGART Bulletin, </journal> <volume> 2(2) </volume> <pages> 8-15, </pages> <year> 1991. </year>
Reference-contexts: The general method, however, is not restricted to this language. Therefore this section has also a paradigmatic character. 4 Concept Languages Concept languages are late descendants of Minski's frames [Min90] and Brachman's KL-ONE [BS85]. They come in a variety of different versions, e.g. ALC [SSS91], CLASSIC [BPS94], KRIS <ref> [BH91] </ref>, LOOM [Mac94], but common to most of them is the separation of a concept language database into a so called T-Box (terminological box) and a so called A-Box (assertional box). The T-Box contains specifications of so-called concept terms and role terms.
Reference: [BPS94] <author> A. Borgida and P. Patel-Schneider. </author> <title> A semantics and complete algorithm for subsumption in the CLASSIC description logic. </title> <journal> Journal of Artificial Intelligence Research, </journal> <volume> 1 </volume> <pages> 277-308, </pages> <year> 1994. </year>
Reference-contexts: The general method, however, is not restricted to this language. Therefore this section has also a paradigmatic character. 4 Concept Languages Concept languages are late descendants of Minski's frames [Min90] and Brachman's KL-ONE [BS85]. They come in a variety of different versions, e.g. ALC [SSS91], CLASSIC <ref> [BPS94] </ref>, KRIS [BH91], LOOM [Mac94], but common to most of them is the separation of a concept language database into a so called T-Box (terminological box) and a so called A-Box (assertional box). The T-Box contains specifications of so-called concept terms and role terms.
Reference: [BS85] <author> R. Brachman and J. Schmolze. </author> <title> An overview of the KL-ONE knowledge representation system. </title> <journal> Cognitive Science, </journal> <volume> 9(2) </volume> <pages> 171-216, </pages> <year> 1985. </year>
Reference-contexts: As an example for an application we investigate in detail one particular knowledge representation language. The general method, however, is not restricted to this language. Therefore this section has also a paradigmatic character. 4 Concept Languages Concept languages are late descendants of Minski's frames [Min90] and Brachman's KL-ONE <ref> [BS85] </ref>. They come in a variety of different versions, e.g. ALC [SSS91], CLASSIC [BPS94], KRIS [BH91], LOOM [Mac94], but common to most of them is the separation of a concept language database into a so called T-Box (terminological box) and a so called A-Box (assertional box).
Reference: [CD94] <author> E. Contejean and H. Devie. </author> <title> An efficient incremental algorithm for solving systems of linear diophantine equations. </title> <journal> Journal of Information and Computation, </journal> <volume> 113 </volume> <pages> 143-172, </pages> <year> 1994. </year>
Reference-contexts: A large variety of different algorithms that solve Diophantine equation systems is presented in the literature. The first algorithms [Hue78, For83] were limited to the case where a single equation has to be solved. More recent approaches can directly handle systems of equations <ref> [GH85, CF89, CD94] </ref> or even general linear constraints involving inequations [AC95, CD94] and disequations [DT95]. Therefore we did not go into further details of the equation solving aspects. <p> The first algorithms [Hue78, For83] were limited to the case where a single equation has to be solved. More recent approaches can directly handle systems of equations [GH85, CF89, CD94] or even general linear constraints involving inequations <ref> [AC95, CD94] </ref> and disequations [DT95]. Therefore we did not go into further details of the equation solving aspects.
Reference: [CF89] <author> M. Clausen and A. Fortenbacher. </author> <title> Efficient solution of linear diophantine equations. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 8 </volume> <pages> 201-216, </pages> <year> 1989. </year>
Reference-contexts: A large variety of different algorithms that solve Diophantine equation systems is presented in the literature. The first algorithms [Hue78, For83] were limited to the case where a single equation has to be solved. More recent approaches can directly handle systems of equations <ref> [GH85, CF89, CD94] </ref> or even general linear constraints involving inequations [AC95, CD94] and disequations [DT95]. Therefore we did not go into further details of the equation solving aspects.
Reference: [Che80] <author> B. F. Chellas. </author> <title> Modal Logic: An Introduction. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1980. </year>
Reference-contexts: Proof: Since ' is satisfiable, there is a model E = (D; =) with x 0 2 E (') for some x 0 2 D. From E we construct a finite model using selective filtration [Gab70, Gab72], a variant of Lemmon and Scott's filtration <ref> [LS66, Che80] </ref>. Let be the set of all concept-subterms 14 in '. Since ' is finite, is finite as well.
Reference: [DLNN95] <author> F. Donini, M. Lenzerini, D. Nardi, and W. Nutt. </author> <title> The complexity of concept languages. </title> <note> Research Report DFKI-RR-95-07, DFKI, </note> <year> 1995. </year>
Reference-contexts: Much effort has been invested in recent years to explore the borderline between propositional logic and FOL by investigating various versions of concept languages, see <ref> [DLNN95] </ref> for a good summary of recent results. In this paper, we want to emphasize the treatment of set cardinalities. <p> The concept term (13) is not a valid declaration because we do not yet consider qualified number restrictions of the kind atleast n r:c. In spite of the restricted expressivity of the language (though subsumption is co-NP-hard [Neb90] and satisfiability is PSPACE-complete <ref> [DLNN95] </ref>), one can formalize a number of interesting features. For example, the concept terms (11) and (12) together state that male and female are disjoint concepts. There are no hermaphrodites.
Reference: [Dom91] <author> E. Domenjoud. </author> <title> Solving systems of linear diophantine equations: An algebraic approach. </title> <editor> In A. Tarlecki, editor, </editor> <booktitle> Mathematical Foundations of Computer Science 1991: Proc. of the 16th International Symposium, volume 520 of Lecture Notes in Computer Science, </booktitle> <pages> pages 141-150. </pages> <publisher> Springer, </publisher> <year> 1991. </year>
Reference-contexts: This calls for optimized algorithms, which do not compute solutions, but only check consistency. Some first techniques have been presented in <ref> [Dom91, BC96] </ref> and we are currently exploring ways to develop a consistency checking algorithm that suits exactly our application purpose. The atomic decomposition method is a new approach for developing inference systems for concept languages.
Reference: [DT95] <author> E. Domenjoud and A. Tomas. </author> <title> From Elliot-MacMahon to an algorithm for general linear constriants on naturals. </title> <editor> In Ugo Montanari and Francesca Rossi, editors, </editor> <booktitle> Proceedings of the 1st International Conference on Principles and Practice of Constraint Programming (CP-95). </booktitle> <publisher> Springer, </publisher> <year> 1995. </year>
Reference-contexts: The first algorithms [Hue78, For83] were limited to the case where a single equation has to be solved. More recent approaches can directly handle systems of equations [GH85, CF89, CD94] or even general linear constraints involving inequations [AC95, CD94] and disequations <ref> [DT95] </ref>. Therefore we did not go into further details of the equation solving aspects.
Reference: [For83] <author> A. Fortenbacher. Algebraische unifikation, </author> <year> 1983. </year>
Reference-contexts: A large variety of different algorithms that solve Diophantine equation systems is presented in the literature. The first algorithms <ref> [Hue78, For83] </ref> were limited to the case where a single equation has to be solved. More recent approaches can directly handle systems of equations [GH85, CF89, CD94] or even general linear constraints involving inequations [AC95, CD94] and disequations [DT95].
Reference: [Gab70] <author> D. M. Gabbay. </author> <title> Selective filtration in modal logics. </title> <journal> Theoria, </journal> <volume> 36 </volume> <pages> 323-330, </pages> <year> 1970. </year>
Reference-contexts: Proof: Since ' is satisfiable, there is a model E = (D; =) with x 0 2 E (') for some x 0 2 D. From E we construct a finite model using selective filtration <ref> [Gab70, Gab72] </ref>, a variant of Lemmon and Scott's filtration [LS66, Che80]. Let be the set of all concept-subterms 14 in '. Since ' is finite, is finite as well.
Reference: [Gab72] <author> D. M. Gabbay. </author> <title> A general filtration method for modal logics. </title> <journal> Journal of Philosophical Logic, </journal> <volume> 10 </volume> <pages> 135-146, </pages> <year> 1972. </year>
Reference-contexts: Proof: Since ' is satisfiable, there is a model E = (D; =) with x 0 2 E (') for some x 0 2 D. From E we construct a finite model using selective filtration <ref> [Gab70, Gab72] </ref>, a variant of Lemmon and Scott's filtration [LS66, Che80]. Let be the set of all concept-subterms 14 in '. Since ' is finite, is finite as well.
Reference: [GH85] <author> T. Guckenbiehl and A. Herold. </author> <title> Solving linear diophantine equations. </title> <type> Technical Report SEKI-85-IV-KL, </type> <institution> University of Kaiserslautern, </institution> <year> 1985. </year>
Reference-contexts: A large variety of different algorithms that solve Diophantine equation systems is presented in the literature. The first algorithms [Hue78, For83] were limited to the case where a single equation has to be solved. More recent approaches can directly handle systems of equations <ref> [GH85, CF89, CD94] </ref> or even general linear constraints involving inequations [AC95, CD94] and disequations [DT95]. Therefore we did not go into further details of the equation solving aspects.
Reference: [HNSS90] <author> B. Hollunder, W. Nutt, and M. Schmidt-Schauss. </author> <title> Subsumption algorithms for concept description languages. </title> <booktitle> In Proceedings of the 9th European Conference on Artificial Intelligence (ECAI-90), </booktitle> <address> Stockholm, Sweden,, </address> <year> 1990. </year> <month> 36 </month>
Reference-contexts: None of the known inference procedures for these kind of languages does the inferences by evaluating arithmetical terms. The standard tableaux approach generates sets of witnessing constants, counts the length of lists, and makes a lot of case distinctions, see <ref> [OSH95, HNSS90] </ref>. For example, if it hits the number restriction in city = place ^atleast 1000000 has-inhabitant it would generate one million constants, one for each inhabitant. Translating such a term into predicate logic is even worse.
Reference: [Hu69] <author> T. C. Hu. </author> <title> Integer programming and network flows. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1969. </year>
Reference-contexts: The problem of solving Diophantine equation systems has come up in a number of other areas as well, such as unification of predicate logic terms with associative-commutative function symbols [PS82], constraint handling in logic programming languages [Jou94], integer programming [Sch86, Kov80], and network flow problems <ref> [Hu69] </ref>. A large variety of different algorithms that solve Diophantine equation systems is presented in the literature. The first algorithms [Hue78, For83] were limited to the case where a single equation has to be solved.
Reference: [Hue78] <author> G. Huet. </author> <title> An algorithm to generate the basis of solutions to homogeneous linear diophantine equations. </title> <journal> Information Processing Letters, </journal> <volume> 7(3), </volume> <year> 1978. </year>
Reference-contexts: A large variety of different algorithms that solve Diophantine equation systems is presented in the literature. The first algorithms <ref> [Hue78, For83] </ref> were limited to the case where a single equation has to be solved. More recent approaches can directly handle systems of equations [GH85, CF89, CD94] or even general linear constraints involving inequations [AC95, CD94] and disequations [DT95].
Reference: [Jou94] <editor> J.-P. Jouannaud, editor. </editor> <booktitle> First International Conference on Constraints in Computational Logics, volume 845 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer, </publisher> <address> Berlin, New York, </address> <year> 1994. </year>
Reference-contexts: The problem of solving Diophantine equation systems has come up in a number of other areas as well, such as unification of predicate logic terms with associative-commutative function symbols [PS82], constraint handling in logic programming languages <ref> [Jou94] </ref>, integer programming [Sch86, Kov80], and network flow problems [Hu69]. A large variety of different algorithms that solve Diophantine equation systems is presented in the literature. The first algorithms [Hue78, For83] were limited to the case where a single equation has to be solved.
Reference: [Kov80] <author> L. B. Kovacs. </author> <title> Combinatorial methods of discrete programming, </title> <booktitle> volume 2 of Mathematical methods of operations research. </booktitle> <publisher> kademiai Kiado, </publisher> <address> Budapest, </address> <year> 1980. </year>
Reference-contexts: The problem of solving Diophantine equation systems has come up in a number of other areas as well, such as unification of predicate logic terms with associative-commutative function symbols [PS82], constraint handling in logic programming languages [Jou94], integer programming <ref> [Sch86, Kov80] </ref>, and network flow problems [Hu69]. A large variety of different algorithms that solve Diophantine equation systems is presented in the literature. The first algorithms [Hue78, For83] were limited to the case where a single equation has to be solved.
Reference: [LS66] <author> E. Lemmon and D. Scott. </author> <title> Intentional Logics. </title> <publisher> Stanford, </publisher> <year> 1966. </year>
Reference-contexts: Proof: Since ' is satisfiable, there is a model E = (D; =) with x 0 2 E (') for some x 0 2 D. From E we construct a finite model using selective filtration [Gab70, Gab72], a variant of Lemmon and Scott's filtration <ref> [LS66, Che80] </ref>. Let be the set of all concept-subterms 14 in '. Since ' is finite, is finite as well.
Reference: [Mac94] <author> R. MacGregor. </author> <title> A description classifier for the predicate calculus. </title> <booktitle> In Proceedings AAAI-94, </booktitle> <pages> pages 213-220. </pages> <publisher> Morgan Kaufmann, </publisher> <address> San Francisco, </address> <year> 1994. </year>
Reference-contexts: Therefore this section has also a paradigmatic character. 4 Concept Languages Concept languages are late descendants of Minski's frames [Min90] and Brachman's KL-ONE [BS85]. They come in a variety of different versions, e.g. ALC [SSS91], CLASSIC [BPS94], KRIS [BH91], LOOM <ref> [Mac94] </ref>, but common to most of them is the separation of a concept language database into a so called T-Box (terminological box) and a so called A-Box (assertional box). The T-Box contains specifications of so-called concept terms and role terms.
Reference: [Min90] <author> M. Minsky. </author> <title> A framework for representing knowledge. </title> <editor> In R. J. Brachman and H. J. Levesque, editors, </editor> <booktitle> Reprinted in Readings in Kwowledge Representation, </booktitle> <pages> pages 245-262. </pages> <publisher> Morgan Kaufmann, </publisher> <address> San Francisco, </address> <year> 1990. </year>
Reference-contexts: As an example for an application we investigate in detail one particular knowledge representation language. The general method, however, is not restricted to this language. Therefore this section has also a paradigmatic character. 4 Concept Languages Concept languages are late descendants of Minski's frames <ref> [Min90] </ref> and Brachman's KL-ONE [BS85]. They come in a variety of different versions, e.g. ALC [SSS91], CLASSIC [BPS94], KRIS [BH91], LOOM [Mac94], but common to most of them is the separation of a concept language database into a so called T-Box (terminological box) and a so called A-Box (assertional box).
Reference: [Neb90] <author> B. Nebel. </author> <title> Reasoning and Revision in Hybrid Representation Systems. </title> <booktitle> Lecture Notes in Artificial Intelligence 422. </booktitle> <publisher> Springer, </publisher> <year> 1990. </year>
Reference-contexts: In Section 4, we apply the mechanism to the concept language T F ++ and show how the consistency and subsumption problems over concept terms can be reduced to solvability tests for systems of equations. The language T F ++ is an extension of the language T F <ref> [Neb90] </ref> which adds more complex role hierarchies and a more expressive arithmetic constraint part to the original core language. <p> Therefore we consider a relatively weak concept language which has no negation, no disjunction, and no existential quantification, just conjunction, universal quantification and, in the basic version, number restrictions of the kind atleast n r and atmost n r, and as abbreviation, exactly n r, see <ref> [Neb90] </ref>. In addition, there can be so called role hierarchies. For example, has-son has-child expresses that the has-son-relation is a sub-relation of the has-child-relation. Typical T-Box declarations of this language are (11, 12). <p> Typical T-Box declarations of this language are (11, 12). The concept term (13) is not a valid declaration because we do not yet consider qualified number restrictions of the kind atleast n r:c. In spite of the restricted expressivity of the language (though subsumption is co-NP-hard <ref> [Neb90] </ref> and satisfiability is PSPACE-complete [DLNN95]), one can formalize a number of interesting features. For example, the concept terms (11) and (12) together state that male and female are disjoint concepts. There are no hermaphrodites. <p> The formal proof can be found in the appendix, Section 6. 4.2 The Language T F ++ The concept language we have been investigating for this paper is the T-Box language T F ++ , which is an extension of the language T F <ref> [Neb90] </ref>. T F itself has only conjunction, the universal quantifier, the number restrictions atleast and atmost, but allows for a tree-like role hierarchy. In T F ++ we can allow for arbitrary role hierarchy specifications in the sense of Definition 2.7. <p> The new interpretation E 00 still satisfies ' in a, but not . Thus, E 00 (') 6 E 00 ( ). Let us illustrate the subsumption checking procedure with an example taken from <ref> [Neb90] </ref>, page 80.
Reference: [OSH95] <author> H. J. Ohlbach, R. Schmidt, and U. Hustadt. </author> <title> Translating graded modalities into predicate logic. </title> <institution> Research Report MPI-I-95-2-008, Max-Planck-Institute of Computer Science, </institution> <year> 1995. </year> <note> To appear in H. </note> <editor> Wansing (ed), </editor> <title> Proof Theory for Modal Logic, </title> <publisher> Oxford Univ. Press. </publisher>
Reference-contexts: None of the known inference procedures for these kind of languages does the inferences by evaluating arithmetical terms. The standard tableaux approach generates sets of witnessing constants, counts the length of lists, and makes a lot of case distinctions, see <ref> [OSH95, HNSS90] </ref>. For example, if it hits the number restriction in city = place ^atleast 1000000 has-inhabitant it would generate one million constants, one for each inhabitant. Translating such a term into predicate logic is even worse.
Reference: [PS82] <author> G. E. Peterson and M. E. Stickel. </author> <title> Complete sets of reductions using associative and/or commutative unification. </title> <type> Technical Note 269, </type> <institution> SRI, </institution> <year> 1982. </year>
Reference-contexts: A typical example of such a language is the language of Diophantine equation systems. The problem of solving Diophantine equation systems has come up in a number of other areas as well, such as unification of predicate logic terms with associative-commutative function symbols <ref> [PS82] </ref>, constraint handling in logic programming languages [Jou94], integer programming [Sch86, Kov80], and network flow problems [Hu69]. A large variety of different algorithms that solve Diophantine equation systems is presented in the literature.
Reference: [Sch86] <author> A. Schrijver. </author> <title> Theory of linear and integer programming. Wiley-Interscience series in discrete mathematics. </title> <publisher> Wiley, </publisher> <address> Chichester, New York, </address> <year> 1986. </year>
Reference-contexts: The problem of solving Diophantine equation systems has come up in a number of other areas as well, such as unification of predicate logic terms with associative-commutative function symbols [PS82], constraint handling in logic programming languages [Jou94], integer programming <ref> [Sch86, Kov80] </ref>, and network flow problems [Hu69]. A large variety of different algorithms that solve Diophantine equation systems is presented in the literature. The first algorithms [Hue78, For83] were limited to the case where a single equation has to be solved.
Reference: [Seg71] <author> K. Segerberg. </author> <title> An essay in classical modal logic (3 vols.). Filosofiska studier, nr. </title> <type> 13, </type> <institution> Uppsala Universitet, </institution> <year> 1971. </year>
Reference-contexts: Then we show that the disjoint union of two models is again a model. This is in a sense the inverse of Segerberg's `bulldozing theorem' for modal logic, which says that generated sub-models are models again <ref> [Seg71] </ref>.
Reference: [SSS91] <author> M. Schmidt-Schau and G. Smolka. </author> <title> Attributive concept descriptions with complements. </title> <journal> Artificial Intelligence, </journal> <volume> 48 </volume> <pages> 1-26, </pages> <year> 1991. </year> <title> 37 List of Symbols </title>
Reference-contexts: The general method, however, is not restricted to this language. Therefore this section has also a paradigmatic character. 4 Concept Languages Concept languages are late descendants of Minski's frames [Min90] and Brachman's KL-ONE [BS85]. They come in a variety of different versions, e.g. ALC <ref> [SSS91] </ref>, CLASSIC [BPS94], KRIS [BH91], LOOM [Mac94], but common to most of them is the separation of a concept language database into a so called T-Box (terminological box) and a so called A-Box (assertional box). The T-Box contains specifications of so-called concept terms and role terms.
References-found: 29

